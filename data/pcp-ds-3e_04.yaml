- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Basic Mathematics
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基础数学
- en: 'As we delve deeper into the realm of data science, it is essential to understand
    the basic mathematical principles and concepts that are fundamental to the field.
    While math may often be perceived as intimidating, my goal is to make this learning
    experience as engaging and enjoyable as possible. In this chapter, we will cover
    key topics such as basic symbols and terminology, logarithms, and exponents, set
    theory, calculus, and matrix (linear) algebra. Additionally, we will explore other
    fields of mathematics and their applications in data science and other scientific
    endeavors, including the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们深入数据科学的领域，理解基本的数学原理和概念是非常重要的，这些概念是该领域的基础。尽管数学常常被认为令人生畏，但我的目标是尽可能让这个学习过程既有趣又愉快。在本章中，我们将涵盖一些关键主题，如基本符号和术语、对数与指数、集合论、微积分和矩阵（线性）代数。此外，我们还将探讨其他数学领域及其在数据科学和其他科学研究中的应用，包括以下内容：
- en: Basic symbols/terminology
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本符号/术语
- en: Logarithms/exponents
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对数/指数
- en: Set theory
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合论
- en: Calculus
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微积分
- en: Matrix (linear) algebra
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 矩阵（线性）代数
- en: It is important to remember that, as discussed previously, mathematics is one
    of the three crucial components of data science. The concepts presented in this
    chapter will not only be useful in later chapters but also in understanding probabilistic
    and statistical models. These are fundamental building blocks for anyone aspiring
    to become a data scientist, and as such, should be thoroughly understood.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记住的是，正如前面所讨论的，数学是数据科学的三个关键组成部分之一。本章中呈现的概念不仅在后续章节中有用，也有助于理解概率和统计模型。这些是任何有志成为数据科学家的人的基本构建块，因此应该被彻底理解。
- en: As a math teacher, it is my duty to educate and enlighten my students on the
    undeniable importance of mathematics in our daily lives. From the simplest tasks,
    such as watering plants and feeding pets, to more complex endeavors, mathematical
    principles and concepts are constantly at play. Even though these calculations
    and predictions may not always be done consciously, they are still being made
    by the human brain. It is my goal to help my students understand and appreciate
    the fundamental role that math plays in our daily lives and to realize the innate
    mathematical abilities that reside within us all.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名数学老师，我的责任是教育和启发学生，让他们认识到数学在我们日常生活中的不可否认的重要性。从最简单的任务，如浇水和喂养宠物，到更复杂的工作，数学原理和概念始终在发挥作用。即使这些计算和预测不总是有意识地进行，但它们仍然由人脑完成。我的目标是帮助学生理解和欣赏数学在我们日常生活中的基础性作用，并意识到我们每个人内在的数学能力。
- en: Basic symbols and terminology
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本符号和术语
- en: In the following section, we will review the mathematical concepts of vectors,
    matrices, arithmetic symbols, and linear algebra, as well as some more subtle
    notations used by data scientists.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将回顾向量、矩阵、算术符号和线性代数的数学概念，以及数据科学家常用的一些更细致的符号表示。
- en: Vectors and matrices
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向量和矩阵
- en: A **vector** is defined as an object with both magnitude and direction. This
    definition, however, is a bit complicated. For our purpose, a vector is simply
    a one-dimensional array representing a series of numbers. Put another way, a vector
    is a list of numbers.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**向量**被定义为具有大小和方向的对象。然而，这一定义有点复杂。就我们的目的而言，向量仅仅是表示一系列数字的单维数组。换句话说，向量就是一个数字列表。'
- en: 'It is generally represented using an arrow or bold font, as shown here:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 它通常使用箭头或粗体字表示，如下所示：
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mover><mi>x</mi><mo
    stretchy="true">→</mo></mover><mi>o</mi><mi>r</mi><mi mathvariant="script">x</mi></mrow></mrow></math>](img/1.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mover><mi>x</mi><mo
    stretchy="true">→</mo></mover><mi>o</mi><mi>r</mi><mi mathvariant="script">x</mi></mrow></mrow></math>](img/1.png)'
- en: 'Vectors are broken into components, which are individual members of the vector.
    We use index notations to denote the element that we are referring to, as illustrated
    here:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 向量被分解为组件，它们是向量的各个成员。我们使用索引符号来表示我们指代的元素，如下所示：
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mi>I</mi><mi>f</mi><mover><mi>x</mi><mo
    stretchy="true">→</mo></mover><mo>=</mo><mfenced open="(" close=")"><mtable columnwidth="auto"
    columnalign="center" rowspacing="1.0000ex 1.0000ex" rowalign="baseline baseline
    baseline"><mtr><mtd><mn>3</mn></mtd></mtr><mtr><mtd><mn>6</mn></mtd></mtr><mtr><mtd><mn>8</mn></mtd></mtr></mtable></mfenced><mi>t</mi><mi>h</mi><mi>e</mi><mi>n</mi><msub><mi
    mathvariant="script">x</mi><mn>1</mn></msub><mo>=</mo><mn>3</mn></mrow></mrow></math>](img/2.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mi>I</mi><mi>f</mi><mover><mi>x</mi><mo
    stretchy="true">→</mo></mover><mo>=</mo><mfenced open="(" close=")"><mtable columnwidth="auto"
    columnalign="center" rowspacing="1.0000ex 1.0000ex" rowalign="baseline baseline
    baseline"><mtr><mtd><mn>3</mn></mtd></mtr><mtr><mtd><mn>6</mn></mtd></mtr><mtr><mtd><mn>8</mn></mtd></tr></mtable></mfenced><mi>t</mi><mi>h</mi><mi>e</mi><mi>n</mi><msub><mi
    mathvariant="script">x</mi><mn>1</mn></msub><mo>=</mo><mn>3</mn></mrow></mrow></math>](img/2.png)'
- en: Note
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 注
- en: In math, we generally refer to the first element as index 1, as opposed to computer
    science, where we generally refer to the first element as index 0\. It is important
    to remember which index system you are using.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在数学中，我们通常将第一个元素称为索引 1，而在计算机科学中，我们通常将第一个元素称为索引 0。记住你使用的是哪种索引系统是很重要的。
- en: 'In Python, we can represent arrays in many ways. We could simply use a Python
    list to represent the preceding array: *x = [3, 6, 8]*. However, it is better
    to use the `numpy` array type to represent arrays, as shown here, because it gives
    us much more utility when performing vector operations:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，我们可以用多种方式表示数组。我们可以简单地使用 Python 列表来表示前面的数组：*x = [3, 6, 8]*。然而，最好使用
    `numpy` 数组类型来表示数组，如此处所示，因为它在进行向量操作时提供了更多的实用功能：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Regardless of the Python representation, vectors give us a simple way of storing
    *multiple dimensions* of a single data point/observation.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 不管 Python 的表示方式如何，向量为我们提供了一种简单的方法来存储单个数据点/观察值的 *多维* 信息。
- en: 'If we measure the average satisfaction rating (0-100) of employees in three
    departments of a company as being *57* for HR, *89* for engineering, and *94*
    for management, we can represent this as a vector with the following formula:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们测量一家公司的三个部门员工的平均满意度评分（0-100），HR 部门为 *57*，工程部门为 *89*，管理部门为 *94*，我们可以用以下公式表示这一向量：
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mi>X</mi><mo>=</mo><mfenced
    open="(" close=")"><mtable columnwidth="auto" columnalign="center" rowspacing="1.0000ex
    1.0000ex" rowalign="baseline baseline baseline"><mtr><mtd><msub><mi mathvariant="script">x</mi><mn>1</mn></msub></mtd></mtr><mtr><mtd><msub><mi
    mathvariant="script">x</mi><mn>2</mn></msub></mtd></mtr><mtr><mtd><msub><mi mathvariant="script">x</mi><mn>3</mn></msub></mtd></mtr></mtable></mfenced><mo>=</mo><mfenced
    open="(" close=")"><mtable columnwidth="auto" columnalign="center" rowspacing="1.0000ex
    1.0000ex" rowalign="baseline baseline baseline"><mtr><mtd><mn>57</mn></mtd></mtr><mtr><mtd><mn>89</mn></mtd></mtr><mtr><mtd><mn>94</mn></mtd></mtr></mtable></mfenced></mrow></mrow></math>](img/3.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mi>X</mi><mo>=</mo><mfenced
    open="(" close=")"><mtable columnwidth="auto" columnalign="center" rowspacing="1.0000ex
    1.0000ex" rowalign="baseline baseline baseline"><mtr><mtd><msub><mi mathvariant="script">x</mi><mn>1</mn></msub></mtd></mtr><mtr><mtd><msub><mi
    mathvariant="script">x</mi><mn>2</mn></msub></mtd></mtr><mtr><mtd><msub><mi mathvariant="script">x</mi><mn>3</mn></msub></mtd></mtr></mtable></mfenced><mo>=</mo><mfenced
    open="(" close=")"><mtable columnwidth="auto" columnalign="center" rowspacing="1.0000ex
    1.0000ex" rowalign="baseline baseline baseline"><mtr><mtd><mn>57</mn></mtd></mtr><mtr><mtd><mn>89</mn></mtd></mtr><mtr><mtd><mn>94</mn></mtd></mtr></mtable></mfenced></mrow></mrow></math>](img/3.png)'
- en: This vector holds three different bits of information about our data. This is
    the perfect use of a vector in data science.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这个向量包含了我们数据的三个不同信息点。这是数据科学中向量的完美应用。
- en: You can also think of a vector as being the theoretical generalization of the
    pandas `Series` object. So, naturally, we need something to represent the DataFrame.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以将向量看作是 pandas `Series` 对象的理论性推广。因此，我们自然需要某种方式来表示 DataFrame。
- en: We can extend our notion of an array to move beyond a single dimension and represent
    data in multiple dimensions.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以扩展数组的概念，使其超越单维并表示多维数据。
- en: 'A **matrix** is a two-dimensional representation of arrays of numbers. **Matrices**
    (plural of matrix) have two main characteristics that we need to be aware of.
    The dimension of a matrix, denoted by *n x m* (*n by m*), tells us that the matrix
    has *n* rows and *m* columns. Matrices are generally denoted by a capital, bold-faced
    letter, such as *X*. Consider the following example:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**矩阵**是一个二维的数字数组表示。**矩阵**（matrix的复数）有两个主要特点需要我们注意。矩阵的维度用*n x m*（*n乘m*）表示，告诉我们矩阵有*n*行和*m*列。矩阵通常用大写加粗字母表示，如*X*。考虑以下示例：'
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mfenced
    open="(" close=")"><mtable columnwidth="auto" columnalign="center" rowspacing="1.0000ex
    1.0000ex" rowalign="baseline baseline baseline"><mtr><mtd><mrow><mn>3</mn><mn>4</mn></mrow></mtd></mtr><mtr><mtd><mrow><mn>8</mn><mn>55</mn></mrow></mtd></mtr><mtr><mtd><mrow><mn>5</mn><mn>9</mn></mrow></mtd></mtr></mtable></mfenced></mrow></math>](img/4.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mfenced
    open="(" close=")"><mtable columnwidth="auto" columnalign="center" rowspacing="1.0000ex
    1.0000ex" rowalign="baseline baseline baseline"><mtr><mtd><mrow><mn>3</mn><mn>4</mn></mrow></mtd></mtr><mtr><mtd><mrow><mn>8</mn><mn>55</mn></mrow></mtd></mtr><mtr><mtd><mrow><mn>5</mn><mn>9</mn></mrow></mtd></mtr></mtable></mfenced></mrow></math>](img/4.png)'
- en: This is a *3 x 2 (3 by 2)* matrix because it has three rows and two columns.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个*3 x 2 (3乘2)*矩阵，因为它有三行和两列。
- en: Note
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If a matrix has the same number of rows and columns, it is called a **square
    matrix**.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果矩阵的行数和列数相同，那么它就是**方阵**。
- en: The matrix is our generalization of the pandas DataFrame. It is arguably one
    of the most important mathematical objects in our toolkit. It is used to hold
    organized information – in our case, data.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵是我们对pandas DataFrame的概括。可以说，它是我们工具箱中最重要的数学对象之一。它用于存储组织好的信息——在我们的案例中，就是数据。
- en: 'Revisiting our previous example, let’s say we have three offices in different
    locations, each with the same three departments: HR, engineering, and management.
    We could make three different vectors, each holding a different office’s satisfaction
    scores, as shown here:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 重新审视我们之前的例子，假设我们有三个在不同地点的办公室，每个办公室都有相同的三个部门：人力资源、工程部和管理部。我们可以创建三个不同的向量，每个向量存储一个办公室的满意度评分，如下所示：
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mi
    mathvariant="normal">x</mi><mo>=</mo><mfenced open="(" close=")"><mtable columnwidth="auto"
    columnalign="center" rowspacing="1.0000ex 1.0000ex" rowalign="baseline baseline
    baseline"><mtr><mtd><mn>57</mn></mtd></mtr><mtr><mtd><mn>89</mn></mtd></mtr><mtr><mtd><mn>94</mn></mtd></mtr></mtable></mfenced><mo>,</mo><mi
    mathvariant="normal">y</mi><mo>=</mo><mfenced open="(" close=")"><mtable columnwidth="auto"
    columnalign="center" rowspacing="1.0000ex 1.0000ex" rowalign="baseline baseline
    baseline"><mtr><mtd><mn>67</mn></mtd></mtr><mtr><mtd><mn>87</mn></mtd></mtr><mtr><mtd><mn>94</mn></mtd></mtr></mtable></mfenced><mo>,</mo><mi
    mathvariant="normal">z</mi><mo>=</mo><mfenced open="(" close=")"><mtable columnwidth="auto"
    columnalign="center" rowspacing="1.0000ex 1.0000ex" rowalign="baseline baseline
    baseline"><mtr><mtd><mn>65</mn></mtd></mtr><mtr><mtd><mn>98</mn></mtd></mtr><mtr><mtd><mn>60</mn></mtd></mtr></mtable></mfenced></mrow></mrow></math>](img/5.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mi
    mathvariant="normal">x</mi><mo>=</mo><mfenced open="(" close=")"><mtable columnwidth="auto"
    columnalign="center" rowspacing="1.0000ex 1.0000ex" rowalign="baseline baseline
    baseline"><mtr><mtd><mn>57</mn></mtd></mtr><mtr><mtd><mn>89</mn></mtd></mtr><mtr><mtd><mn>94</mn></mtd></mtr></mtable></mfenced><mo>,</mo><mi
    mathvariant="normal">y</mi><mo>=</mo><mfenced open="(" close=")"><mtable columnwidth="auto"
    columnalign="center" rowspacing="1.0000ex 1.0000ex" rowalign="baseline baseline
    baseline"><mtr><mtd><mn>67</mn></mtd></mtr><mtr><mtd><mn>87</mn></mtd></mtr><mtr><mtd><mn>94</mn></mtd></mtr></mtable></mfenced><mo>,</mo><mi
    mathvariant="normal">z</mi><mo>=</mo><mfenced open="(" close=")"><mtable columnwidth="auto"
    columnalign="center" rowspacing="1.0000ex 1.0000ex" rowalign="baseline baseline
    baseline"><mtr><mtd><mn>65</mn></mtd></mtr><mtr><mtd><mn>98</mn></mtd></mtr><mtr><mtd><mn>60</mn></mtd></mtr></mtable></mfenced></mrow></mrow></math>](img/5.png)'
- en: However, this is not only cumbersome but also unscalable. What if you have 100
    different offices? In this case, you would need to have 100 different one-dimensional
    arrays to hold this information.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这不仅繁琐，而且不可扩展。如果你有100个不同的办公室怎么办？在这种情况下，你将需要100个不同的一维数组来存储这些信息。
- en: 'This is where a matrix alleviates this problem. Let’s make a matrix where each
    row represents a different department and each column represents a different office,
    as shown in *Table 4.1*:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这时，矩阵可以缓解这个问题。我们可以创建一个矩阵，其中每一行代表一个不同的部门，每一列代表一个不同的办公室，如*表格 4.1*所示：
- en: '|  | Office 1 | Office 2 | Office 3 |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '|  | 办公室 1 | 办公室 2 | 办公室 3 |'
- en: '| HR | 57 | 67 | 65 |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| 人力资源 | 57 | 67 | 65 |'
- en: '| Engineering | 89 | 87 | 98 |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| 工程部 | 89 | 87 | 98 |'
- en: '| Management | 94 | 84 | 60 |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| 管理 | 94 | 84 | 60 |'
- en: Table 4.1 – Some sample data we want to model as a matrix
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4.1 – 我们希望建模为矩阵的一些示例数据
- en: 'This is much more natural. Now, let’s strip away the labels; we’ll be left
    with a matrix:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这样会更加自然。现在，我们去掉标签；我们将得到一个矩阵：
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mi>X</mi><mo>=</mo><mfenced
    open="(" close=")"><mtable columnwidth="auto" columnalign="center" rowspacing="1.0000ex
    1.0000ex" rowalign="baseline baseline baseline"><mtr><mtd><mrow><mn>57</mn><mn>67</mn><mn>65</mn></mrow></mtd></mtr><mtr><mtd><mrow><mn>89</mn><mn>87</mn><mn>98</mn></mrow></mtd></mtr><mtr><mtd><mrow><mn>94</mn><mn>94</mn><mn>60</mn></mrow></mtd></mtr></mtable></mfenced></mrow></mrow></math>](img/6.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mi>X</mi><mo>=</mo><mfenced
    open="(" close=")"><mtable columnwidth="auto" columnalign="center" rowspacing="1.0000ex
    1.0000ex" rowalign="baseline baseline baseline"><mtr><mtd><mrow><mn>57</mn><mn>67</mn><mn>65</mn></mrow></mtd></mtr><mtr><mtd><mrow><mn>89</mn><mn>87</mn><mn>98</mn></mrow></mtd></tr><mtr><mtd><mrow><mn>94</mn><mn>94</mn><mn>60</mn></mrow></mtd></tr></mtable></mfenced></mrow></mrow></math>](img/6.png)'
- en: Quick exercises
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 快速练习
- en: 'The following is a list of quick exercises you can do to understand matrices
    better:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些快速练习，帮助你更好地理解矩阵：
- en: If we added a fourth office, would we need a new row or column?
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们增加一个第四个办公室，我们需要新的一行还是一列？
- en: What would the dimension of the matrix be after we added the fourth office?
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们添加了第四个办公室，那么矩阵的维度会是多少？
- en: If we eliminate the management department from the original X matrix, what would
    the dimension of the new matrix be?
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们从原始 X 矩阵中去掉管理部门，那么新矩阵的维度会是多少？
- en: What is the general formula to find out the number of elements in the matrix?
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算矩阵元素个数的通用公式是什么？
- en: Answers
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 答案
- en: 'Here are the answers:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是答案：
- en: Column
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列
- en: 3 x 4
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3 x 4
- en: 2 x 3
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2 x 3
- en: '*n × m* (*n* being the number of rows and *m* being the number of columns)'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*n × m* (*n* 是行数，*m* 是列数)'
- en: Let’s move on to arithmetic symbols.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来讨论一下算术符号。
- en: Arithmetic symbols
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 算术符号
- en: In this section, we will go over some symbols associated with basic arithmetic
    that appear in most, if not all, data science tutorials and books.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍一些与基本算术相关的符号，这些符号在大多数数据科学教程和书籍中都会出现。
- en: Summation
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总和
- en: The uppercase sigma, ∑, symbol is a universal symbol for addition. Whatever
    is to the right of the sigma symbol is usually something iterable, meaning that
    we can go over it one by one (for example, a vector).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 大写的西格玛符号 ∑ 是加法的通用符号。西格玛符号右边通常是可迭代的内容，意味着我们可以逐个遍历它（例如，一个向量）。
- en: For example, let’s create the representation of a vector, X=[1,2,3,4,5].
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们来创建一个向量 X=[1,2,3,4,5] 的表示。
- en: 'To find the sum of the content, we can use the following formula:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找到内容的总和，我们可以使用以下公式：
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mo>∑</mo><msub><mi>x</mi><mi
    mathvariant="normal">i</mi></msub><mo>=</mo><mn>15</mn></mrow></mrow></math>](img/7.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mo>∑</mo><msub><mi>x</mi><mi
    mathvariant="normal">i</mi></msub><mo>=</mo><mn>15</mn></mrow></mrow></math>](img/7.png)'
- en: 'In Python, we can use the following formula:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，我们可以使用以下公式：
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mi>s</mi><mi>u</mi><mi>m</mi><mo>(</mo><mi>x</mi><mo>)</mo><mi
    mathvariant="normal">#</mi><mo>=</mo><mo>=</mo><mn>15</mn></mrow></mrow></mrow></math>](img/8.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mi>s</mi><mi>u</mi><mi>m</mi><mo>(</mo><mi>x</mi><mo>)</mo><mi
    mathvariant="normal">#</mi><mo>=</mo><mo>=</mo><mn>15</mn></mrow></mrow></mrow></math>](img/8.png)'
- en: 'For example, the formula for calculating the mean of a series of numbers is
    quite common. If we have a vector (*x*) of length *n*, the mean of the vector
    can be calculated as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，计算一系列数字的平均值的公式非常常见。如果我们有一个长度为 *n* 的向量 (*x*)，那么可以按照以下公式计算该向量的平均值：
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mi>m</mi><mi>e</mi><mi>a</mi><mi>n</mi><mo>=</mo><mn>1</mn><mo>/</mo><mi>n</mi><mo>∑</mo><msub><mi>x</mi><mi>i</mi></msub><mo>=</mo><mn>15</mn></mrow></mrow></math>](img/9.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mi>m</mi><mi>e</mi><mi>a</mi><mi>n</mi><mo>=</mo><mn>1</mn><mo>/</mo><mi>n</mi><mo>∑</mo><msub><mi>x</mi><mi>i</mi></msub><mo>=</mo><mn>15</mn></mrow></mrow></math>](img/9.png)'
- en: This means that we will add up each element of *x*, denoted by *xi*, and then
    multiply the sum by *1/n*, otherwise known as dividing by *n* (the length of the
    vector).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们将逐一加总 *x* 中的每个元素，记作 *xi*，然后将总和乘以 *1/n*，也就是除以 *n*（向量的长度）。
- en: 'In Python, we can use the following formula to get the mean of the array, *x*:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，我们可以使用以下公式来计算数组 *x* 的平均值：
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mi>m</mi><mi>e</mi><mi>a</mi><mi>n</mi><mo>=</mo><mi>s</mi><mi>u</mi><mi>m</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>/</mo><mi>l</mi><mi>e</mi><mi>n</mi><mo>(</mo><mi>x</mi><mo>)</mo><mi
    mathvariant="normal">#</mi><mo>=</mo><mo>=</mo><mn>3</mn></mrow></mrow></mrow></math>](img/10.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mi>m</mi><mi>e</mi><mi>a</mi><mi>n</mi><mo>=</mo><mi>s</mi><mi>u</mi><mi>m</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>/</mo><mi>l</mi><mi>e</mi><mi>n</mi><mo>(</mo><mi>x</mi><mo>)</mo><mi
    mathvariant="normal">#</mi><mo>=</mo><mo>=</mo><mn>3</mn></mrow></mrow></mrow></math>](img/10.png)'
- en: Dot product
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 点积
- en: 'The dot product is an operator such as addition and multiplication. It is used
    to combine two vectors, as shown here:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 点积是一种操作符，类似于加法和乘法。它用于将两个向量结合起来，如下所示：
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mfenced
    open="(" close=")"><mfrac><mn>3</mn><mn>7</mn></mfrac></mfenced><mo>.</mo><mfenced
    open="(" close=")"><mfrac><mn>9</mn><mn>5</mn></mfrac></mfenced><mo>=</mo><mn>3</mn><mi
    mathvariant="normal">*</mi><mn>9</mn><mo>+</mo><mn>7</mn><mi mathvariant="normal">*</mi><mn>5</mn><mo>=</mo><mn>62</mn></mrow></mrow></math>](img/11.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mfenced
    open="(" close=")"><mfrac><mn>3</mn><mn>7</mn></mfrac></mfenced><mo>.</mo><mfenced
    open="(" close=")"><mfrac><mn>9</mn><mn>5</mn></mfrac></mfenced><mo>=</mo><mn>3</mn><mi
    mathvariant="normal">*</mi><mn>9</mn><mo>+</mo><mn>7</mn><mi mathvariant="normal">*</mi><mn>5</mn><mo>=</mo><mn>62</mn></mrow></mrow></math>](img/11.png)'
- en: 'What does this mean? Let’s say we have a vector that represents a customer’s
    sentiments toward three genres of movies: comedy, romance, and action.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着什么呢？假设我们有一个向量，表示顾客对三种电影类型（喜剧、浪漫和动作）的情感。
- en: Note
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: When using a dot product, note that an answer is a single number, known as a
    **scalar**.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用点积时，请注意，结果是一个单一的数字，称为**标量**。
- en: 'On a scale of 1 to 5, a customer loves comedies, hates romantic movies, and
    is fine with action movies. We might represent this as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在1到5的评分范围内，一位顾客喜欢喜剧，讨厌浪漫电影，并且对动作片持中立态度。我们可以如下表示：
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mfenced separators="|"><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mn>5</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>1</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>3</mml:mn></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mfenced></mml:math>](img/12.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mfenced separators="|"><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mn>5</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>1</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>3</mml:mn></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mfenced></mml:math>](img/12.png)'
- en: Here, *5* denotes their love for comedies, *1* denotes their hatred of romantic
    movies, and *3* denotes the customer’s indifference toward action movies.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，*5* 表示他们对喜剧的喜爱，*1* 表示他们对浪漫电影的厌恶，而*3* 表示顾客对动作片的冷漠。
- en: 'Now, let’s assume that we have two new movies, one of which is a romantic comedy
    and the other is a funny action movie. The movies would have their own vector
    of qualities, as shown here:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们有两部新电影，一部是浪漫喜剧，另一部是搞笑动作片。这些电影将拥有各自的质量向量，如下所示：
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mi>m</mi><mn>1</mn><mo>=</mo><mfenced
    open="(" close=")"><mtable columnwidth="auto" columnalign="center" rowspacing="1.0000ex
    1.0000ex" rowalign="baseline baseline baseline"><mtr><mtd><mn>4</mn></mtd></mtr><mtr><mtd><mn>5</mn></mtd></mtr><mtr><mtd><mn>1</mn></mtd></mtr></mtable></mfenced><mi>m</mi><mn>2</mn><mo>=</mo><mfenced
    open="(" close=")"><mtable columnwidth="auto" columnalign="center" rowspacing="1.0000ex
    1.0000ex" rowalign="baseline baseline baseline"><mtr><mtd><mn>5</mn></mtd></mtr><mtr><mtd><mn>1</mn></mtd></mtr><mtr><mtd><mn>5</mn></mtd></mtr></mtable></mfenced></mrow></mrow></math>](img/13.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mi>m</mi><mn>1</mn><mo>=</mo><mfenced
    open="(" close=")"><mtable columnwidth="auto" columnalign="center" rowspacing="1.0000ex
    1.0000ex" rowalign="baseline baseline baseline"><mtr><mtd><mn>4</mn></mtd></mtr><mtr><mtd><mn>5</mn></mtd></mtr><mtr><mtd><mn>1</mn></mtd></mtr></mtable></mfenced><mi>m</mi><mn>2</mn><mo>=</mo><mfenced
    open="(" close=")"><mtable columnwidth="auto" columnalign="center" rowspacing="1.0000ex
    1.0000ex" rowalign="baseline baseline baseline"><mtr><mtd><mn>5</mn></mtd></mtr><mtr><mtd><mn>1</mn></mtd></mtr><mtr><mtd><mn>5</mn></mtd></mtr></mtable></mfenced></mrow></mrow></math>](img/13.png)'
- en: Here, *m1* is our romantic comedy and *m2* is our funny action movie.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，*m1* 代表我们的浪漫喜剧，*m2* 代表我们的搞笑动作片。
- en: To make a recommendation, we must apply the dot product between the customer’s
    preferences for each movie. The higher value will win and, therefore, will be
    recommended to the user.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要做出推荐，我们必须应用顾客对每部电影的偏好的点积。较高的值将获胜，因此将推荐给用户。
- en: 'Let’s compute the recommendation score for each movie. For movie 1, we want
    to compute the following:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们计算每部电影的推荐分数。对于电影 1，我们要计算以下内容：
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mfenced
    open="(" close=")"><mtable columnwidth="auto" columnalign="center" rowspacing="1.0000ex
    1.0000ex" rowalign="baseline baseline baseline"><mtr><mtd><mn>5</mn></mtd></mtr><mtr><mtd><mn>1</mn></mtd></mtr><mtr><mtd><mn>3</mn></mtd></mtr></mtable></mfenced><mo>.</mo><mfenced
    open="(" close=")"><mtable columnwidth="auto" columnalign="center" rowspacing="1.0000ex
    1.0000ex" rowalign="baseline baseline baseline"><mtr><mtd><mn>4</mn></mtd></mtr><mtr><mtd><mn>5</mn></mtd></mtr><mtr><mtd><mn>1</mn></mtd></mtr></mtable></mfenced></mrow></mrow></math>](img/14.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mfenced
    open="(" close=")"><mtable columnwidth="auto" columnalign="center" rowspacing="1.0000ex
    1.0000ex" rowalign="baseline baseline baseline"><mtr><mtd><mn>5</mn></mtd></mtr><mtr><mtd><mn>1</mn></mtd></mtr><mtr><mtd><mn>3</mn></mtd></mtr></mtable></mfenced><mo>.</mo><mfenced
    open="(" close=")"><mtable columnwidth="auto" columnalign="center" rowspacing="1.0000ex
    1.0000ex" rowalign="baseline baseline baseline"><mtr><mtd><mn>4</mn></mtd></mtr><mtr><mtd><mn>5</mn></mtd></mtr><mtr><mtd><mn>1</mn></mtd></mtr></mtable></mfenced></mrow></mrow></math>](img/14.png)'
- en: 'We can think of this problem as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这个问题看作是：
- en: '![Figure 4.1 – How to interpret a dot product](img/B19488_04_01.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.1 – 如何解释点积](img/B19488_04_01.jpg)'
- en: Figure 4.1 – How to interpret a dot product
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 – 如何解释点积
- en: 'The answer we obtain is *28*, but what does this number mean? On what scale
    is it? Well, the best score anyone can ever get is when all values are *5*, making
    the outcome as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到的答案是 *28*，但这个数字代表什么？它是在什么尺度上？嗯，任何人能得到的最佳分数是所有值都为 *5*，结果如下：
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mfenced
    open="(" close=")"><mtable columnwidth="auto" columnalign="center" rowspacing="1.0000ex
    1.0000ex" rowalign="baseline baseline baseline"><mtr><mtd><mn>5</mn></mtd></mtr><mtr><mtd><mn>5</mn></mtd></mtr><mtr><mtd><mn>5</mn></mtd></mtr></mtable></mfenced><mo>.</mo><mfenced
    open="(" close=")"><mtable columnwidth="auto" columnalign="center" rowspacing="1.0000ex
    1.0000ex" rowalign="baseline baseline baseline"><mtr><mtd><mn>5</mn></mtd></mtr><mtr><mtd><mn>5</mn></mtd></mtr><mtr><mtd><mn>5</mn></mtd></mtr></mtable></mfenced><mo>=</mo><msup><mn>5</mn><mn>2</mn></msup><mo>+</mo><msup><mn>5</mn><mn>2</mn></msup><mo>+</mo><msup><mn>5</mn><mn>2</mn></msup><mo>=</mo><mn>75</mn></mrow></mrow></math>](img/15.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mfenced
    open="(" close=")"><mtable columnwidth="auto" columnalign="center" rowspacing="1.0000ex
    1.0000ex" rowalign="baseline baseline baseline"><mtr><mtd><mn>5</mn></mtd></mtr><mtr><mtd><mn>5</mn></mtd></mtr><mtr><mtd><mn>5</mn></mtd></mtr></mtable></mfenced><mo>.</mo><mfenced
    open="(" close=")"><mtable columnwidth="auto" columnalign="center" rowspacing="1.0000ex
    1.0000ex" rowalign="baseline baseline baseline"><mtr><mtd><mn>5</mn></mtd></mtr><mtr><mtd><mn>5</mn></mtd></mtr><mtr><mtd><mn>5</mn></mtd></mtr></mtable></mfenced><mo>=</mo><msup><mn>5</mn><mn>2</mn></msup><mo>+</mo><msup><mn>5</mn><mn>2</mn></msup><mo>+</mo><msup><mn>5</mn><mn>2</mn></msup><mo>=</mo><mn>75</mn></mrow></mrow></math>](img/15.png)'
- en: 'The lowest possible score is when all values are *1*, as shown here:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 最低可能的分数是当所有值为 *1* 时，如下所示：
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mfenced
    open="(" close=")"><mtable columnwidth="auto" columnalign="center" rowspacing="1.0000ex
    1.0000ex" rowalign="baseline baseline baseline"><mtr><mtd><mn>1</mn></mtd></mtr><mtr><mtd><mn>1</mn></mtd></mtr><mtr><mtd><mn>1</mn></mtd></mtr></mtable></mfenced><mo>.</mo><mfenced
    open="(" close=")"><mtable columnwidth="auto" columnalign="center" rowspacing="1.0000ex
    1.0000ex" rowalign="baseline baseline baseline"><mtr><mtd><mn>1</mn></mtd></mtr><mtr><mtd><mn>1</mn></mtd></mtr><mtr><mtd><mn>1</mn></mtd></mtr></mtable></mfenced><mo>=</mo><msup><mn>1</mn><mn>2</mn></msup><mo>+</mo><msup><mn>1</mn><mn>2</mn></msup><mo>+</mo><msup><mn>1</mn><mn>2</mn></msup><mo>=</mo><mn>3</mn></mrow></mrow></math>](img/16.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mfenced
    open="(" close=")"><mtable columnwidth="auto" columnalign="center" rowspacing="1.0000ex
    1.0000ex" rowalign="baseline baseline baseline"><mtr><mtd><mn>1</mn></mtd></mtr><mtr><mtd><mn>1</mn></mtd></mtr><mtr><mtd><mn>1</mn></mtd></mtr></mtable></mfenced><mo>.</mo><mfenced
    open="(" close=")"><mtable columnwidth="auto" columnalign="center" rowspacing="1.0000ex
    1.0000ex" rowalign="baseline baseline baseline"><mtr><mtd><mn>1</mn></mtd></mtr><mtr><mtd><mn>1</mn></mtd></mtr><mtr><mtd><mn>1</mn></mtd></mtr></mtable></mfenced><mo>=</mo><msup><mn>1</mn><mn>2</mn></msup><mo>+</mo><msup><mn>1</mn><mn>2</mn></msup><mo>+</mo><msup><mn>1</mn><mn>2</mn></msup><mo>=</mo><mn>3</mn></mrow></mrow></math>](img/16.png)'
- en: 'So, we must think about *28* on a scale from *3* to *75*. The number 28 is
    closer to 3 than it is to 75\. Let’s try this for movie 2:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们必须在从*3*到*75*的尺度上考虑*28*。数字28离3更近，而不是75。让我们对电影2进行这个尝试：
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mfenced
    open="(" close=")"><mtable columnwidth="auto" columnalign="center" rowspacing="1.0000ex
    1.0000ex" rowalign="baseline baseline baseline"><mtr><mtd><mn>5</mn></mtd></mtr><mtr><mtd><mn>1</mn></mtd></mtr><mtr><mtd><mn>3</mn></mtd></mtr></mtable></mfenced><mo>.</mo><mfenced
    open="(" close=")"><mtable columnwidth="auto" columnalign="center" rowspacing="1.0000ex
    1.0000ex" rowalign="baseline baseline baseline"><mtr><mtd><mn>5</mn></mtd></mtr><mtr><mtd><mn>1</mn></mtd></mtr><mtr><mtd><mn>5</mn></mtd></mtr></mtable></mfenced><mo>=</mo><mo>(</mo><mn>5</mn><mi
    mathvariant="normal">*</mi><mn>5</mn><mo>)</mo><mo>+</mo><mo>(</mo><mn>1</mn><mi
    mathvariant="normal">*</mi><mn>1</mn><mo>)</mo><mo>+</mo><mo>(</mo><mn>3</mn><mi
    mathvariant="normal">*</mi><mn>5</mn><mo>)</mo><mo>=</mo><mn>41</mn></mrow></mrow></mrow></math>](img/17.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mfenced
    open="(" close=")"><mtable columnwidth="auto" columnalign="center" rowspacing="1.0000ex
    1.0000ex" rowalign="baseline baseline baseline"><mtr><mtd><mn>5</mn></mtd></mtr><mtr><mtd><mn>1</mn></mtd></mtr><mtr><mtd><mn>3</mn></mtd></mtr></mtable></mfenced><mo>.</mo><mfenced
    open="(" close=")"><mtable columnwidth="auto" columnalign="center" rowspacing="1.0000ex
    1.0000ex" rowalign="baseline baseline baseline"><mtr><mtd><mn>5</mn></mtd></mtr><mtr><mtd><mn>1</mn></mtd></mtr><mtr><mtd><mn>5</mn></mtd></mtr></mtable></mfenced><mo>=</mo><mo>(</mo><mn>5</mn><mi
    mathvariant="normal">*</mi><mn>5</mn><mo>)</mo><mo>+</mo><mo>(</mo><mn>1</mn><mi
    mathvariant="normal">*</mi><mn>1</mn><mo>)</mo><mo>+</mo><mo>(</mo><mn>3</mn><mi
    mathvariant="normal">*</mi><mn>5</mn><mo>)</mo><mo>=</mo><mn>41</mn></mrow></mrow></mrow></math>](img/17.png)'
- en: This is higher than 28! So, between movie 1 and movie 2, we would recommend
    movie 2 to our user. This is, in essence, how most movie prediction engines work.
    They build a customer profile, which is represented as a vector. They then take
    a vector representation of each movie they have to offer, combine them with the
    customer profile (perhaps with a dot product), and make recommendations from there.
    Of course, most companies must do this on a much larger scale, which is where
    a particular field of mathematics, called **linear algebra**, can be very useful;
    we will look at it later in this chapter.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这个比28还高！所以，在电影1和电影2之间，我们会向用户推荐电影2。这本质上就是大多数电影预测引擎的工作原理。它们构建了一个客户档案，表示为一个向量。然后，它们将每个电影的向量表示与客户档案相结合（可能通过点积），从那里做出推荐。当然，大多数公司必须在更大的规模上做这件事，这时一种特别的数学领域——**线性代数**就显得非常有用；我们将在本章后面讨论它。
- en: Logarithms/exponents
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对数/指数
- en: 'An **exponent** tells you how many times you have to multiply a number by itself,
    as illustrated in *Figures 4.3* and *4.4*:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**指数**告诉你要将一个数字乘以自身多少次，如*图4.3*和*图4.4*所示：'
- en: '![Figure 4.2 – The exponent tells you how many times to multiply a number by
    itself](img/B19488_04_02.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图4.2 – 指数告诉你要将一个数字乘以自身多少次](img/B19488_04_02.jpg)'
- en: Figure 4.2 – The exponent tells you how many times to multiply a number by itself
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2 – 指数告诉你要将一个数字乘以自身多少次
- en: 'A **logarithm** is a number that answers the question “What exponent gets me
    from the base to this other number?” This can be denoted as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**对数**是回答“什么指数可以从底数得到这个数字？”这个问题的数字。可以表示如下：'
- en: '![Figure 4.3 – The exponent from Figure 4.3 written in logarithm form](img/B19488_04_03.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图4.3 – 图4.3中的指数以对数形式表示](img/B19488_04_03.jpg)'
- en: Figure 4.3 – The exponent from Figure 4.3 written in logarithm form
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3 – 图4.3中的指数以对数形式表示
- en: If these two concepts seem similar, then you are correct! Exponents and logarithms
    are heavily related. In fact, the words exponent and logarithm mean the same thing!
    A logarithm is an exponent. The preceding two equations are two versions of the
    same thing. The basic idea is that 2 times 2 times 2 times 2 is 16.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这两个概念看起来相似，那么你是对的！指数和对数是密切相关的。事实上，指数和对数是同一个意思！对数就是指数。前面两个方程式是同一个东西的两种表现方式。基本的意思是2乘2乘2乘2等于16。
- en: '*Figure 4**.5* depicts how we can use both versions to say the same thing.
    Note how I use arrows to move from the log formula to the exponent formula:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4.5*展示了我们如何使用两种版本表达相同的内容。注意我如何使用箭头从对数公式移动到指数公式：'
- en: '![Figure 4.4 – Logarithms and exponents are the same!](img/B19488_04_04.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图4.4 – 对数和指数是一样的！](img/B19488_04_04.jpg)'
- en: Figure 4.4 – Logarithms and exponents are the same!
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4 – 对数和指数是一样的！
- en: 'Consider the following examples:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><msub><mrow><mi>l</mi><mi>o</mi><mi>g</mi></mrow><mn>31</mn></msub><mn>81</mn><mo>=</mo><mn>4</mn><mi>b</mi><mi>e</mi><mi>c</mi><mi>a</mi><mi>u</mi><mi>s</mi><mi>e</mi><msup><mn>3</mn><mn>4</mn></msup><mo>=</mo><mn>81</mn></mrow></mrow></math>](img/18.png)'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><msub><mrow><mi>l</mi><mi>o</mi><mi>g</mi></mrow><mn>31</mn></msub><mn>81</mn><mo>=</mo><mn>4</mn><mi>b</mi><mi>e</mi><mi>c</mi><mi>a</mi><mi>u</mi><mi>s</mi><mi>e</mi><msup><mn>3</mn><mn>4</mn></msup><mo>=</mo><mn>81</mn></mrow></mrow></math>](img/18.png)'
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><msub><mrow><mi>l</mi><mi>o</mi><mi>g</mi></mrow><mn>5</mn></msub><mn>125</mn><mo>=</mo><mn>3</mn><mi>b</mi><mi>e</mi><mi>c</mi><mi>a</mi><mi>u</mi><mi>s</mi><mi>e</mi><msup><mn>5</mn><mn>3</mn></msup><mo>=</mo><mn>125</mn></mrow></mrow></math>](img/19.png)'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><msub><mrow><mi>l</mi><mi>o</mi><mi>g</mi></mrow><mn>5</mn></msub><mn>125</mn><mo>=</mo><mn>3</mn><mi>b</mi><mi>e</mi><mi>c</mi><mi>a</mi><mi>u</mi><mi>s</mi><mi>e</mi><msup><mn>5</mn><mn>3</mn></msup><mo>=</mo><mn>125</mn></mrow></mrow></math>](img/19.png)'
- en: 'Let’s rewrite the first equation to note something interesting:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新写一下第一个公式，来注意一个有趣的地方：
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><msub><mrow><mi>l</mi><mi>o</mi><mi>g</mi></mrow><mn>3</mn></msub><mn>81</mn><mo>=</mo><mn>4</mn></mrow></mrow></math>](img/20.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><msub><mrow><mi>l</mi><mi>o</mi><mi>g</mi></mrow><mn>3</mn></msub><mn>81</mn><mo>=</mo><mn>4</mn></mrow></mrow></math>](img/20.png)'
- en: 'Now, let’s replace 81 with the equivalent statement, ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mn>3</mml:mn></mml:mrow><mml:mrow><mml:mn>4</mml:mn></mml:mrow></mml:msup></mml:math>](img/21.png),
    as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们把81替换为等价的表达式，![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msup><mml:mrow><mml:mn>3</mml:mn></mml:mrow><mml:mrow><mml:mn>4</mml:mn></mml:mrow></mml:msup></mml:math>](img/21.png)，如下所示：
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><msub><mrow><mi>l</mi><mi>o</mi><mi>g</mi></mrow><mn>5</mn></msub><mn>125</mn><mo>=</mo><mn>3</mn></mrow></mrow></math>](img/22.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><msub><mrow><mi>l</mi><mi>o</mi><mi>g</mi></mrow><mn>5</mn></msub><mn>125</mn><mo>=</mo><mn>3</mn></mrow></mrow></math>](img/22.png)'
- en: Something interesting to note is that the 3s seem to *cancel out*. This is very
    important when dealing with numbers that are more difficult to work with than
    3s and 4s.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，3s似乎可以*抵消*。在处理比3和4更难计算的数字时，这一点非常重要。
- en: Exponents and logarithms are most important when dealing with growth. More often
    than not, if a quantity is growing (or declining in growth), an exponent/logarithm
    can help model this behavior.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 指数和对数在处理增长时最为关键。通常，如果某个数量在增长（或下降的增长），指数/对数可以帮助模拟这种行为。
- en: 'For example, the number *e* is around `2.718` and has many practical applications.
    A very common application is interest calculation for saving. Suppose you have
    $5,000 deposited in a bank with continuously compounded interest at the rate of
    3%. In this case, you can use the following formula to model the growth of your
    deposit:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，数字 *e* 大约是 `2.718`，并且有很多实际应用。一个非常常见的应用是存款的利息计算。假设你在银行存入5000美元，并且以3%的年利率进行连续复利。在这种情况下，你可以使用以下公式来模拟你存款的增长：
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi mathvariant="normal">A</mml:mi><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mi
    mathvariant="normal">P</mml:mi><mml:mi mathvariant="normal">e</mml:mi></mml:mrow><mml:mrow><mml:mi
    mathvariant="normal">r</mml:mi><mml:mi mathvariant="normal">t</mml:mi></mml:mrow></mml:msup></mml:math>](img/23.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi mathvariant="normal">A</mml:mi><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mi
    mathvariant="normal">P</mml:mi><mml:mi mathvariant="normal">e</mml:mi></mml:mrow><mml:mrow><mml:mi
    mathvariant="normal">r</mml:mi><mml:mi mathvariant="normal">t</mml:mi></mml:mrow></mml:msup></mml:math>](img/23.png)'
- en: 'In this formula, we have the following:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个公式中，我们有以下内容：
- en: '*A* denotes the final amount'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*A* 表示最终金额'
- en: '*P* denotes the principal investment (**5000**)'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*P* 表示本金投资额 (**5000**)'
- en: '*e* denotes a constant (**2.718**)'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*e* 表示常数 (**2.718**)'
- en: '*r* denotes the rate of growth (**.03**)'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*r* 表示增长率 (**.03**)'
- en: '*t* denotes the time (in years)'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*t* 表示时间（单位为年）'
- en: 'When will our investment double? How long would I have to have my money in
    this investment to achieve 100% growth? We can write this in mathematical form,
    as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的投资什么时候会翻倍？我需要把钱投资多长时间才能实现 100% 的增长？我们可以用数学形式表示如下：
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mn>10,000</mml:mn><mml:msup><mml:mrow><mml:mo>=</mml:mo><mml:mn>5,000</mml:mn><mml:mi
    mathvariant="normal">e</mml:mi></mml:mrow><mml:mrow><mml:mo>.</mml:mo><mml:mn>03</mml:mn><mml:mi
    mathvariant="normal">t</mml:mi></mml:mrow></mml:msup></mml:math>](img/24.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mn>10,000</mml:mn><mml:msup><mml:mrow><mml:mo>=</mml:mo><mml:mn>5,000</mml:mn><mml:mi
    mathvariant="normal">e</mml:mi></mml:mrow><mml:mrow><mml:mo>.</mml:mo><mml:mn>03</mml:mn><mml:mi
    mathvariant="normal">t</mml:mi></mml:mrow></mml:msup></mml:math>](img/24.png)'
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mn>2</mn><mo>=</mo><msup><mi
    mathvariant="normal">e</mi><mrow><mo>.</mo><mn>03</mn><mi mathvariant="normal">t</mi></mrow></msup><mo>(</mo><mi
    mathvariant="normal">d</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">v</mi><mi
    mathvariant="normal">i</mi><mi mathvariant="normal">d</mi><mi mathvariant="normal">e</mi><mi
    mathvariant="normal">d</mi><mi mathvariant="normal">b</mi><mi mathvariant="normal">y</mi><mn>5,000</mn><mi
    mathvariant="normal">o</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">b</mi><mi
    mathvariant="normal">o</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">h</mi><mi
    mathvariant="normal">s</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">d</mi><mi
    mathvariant="normal">e</mi><mi mathvariant="normal">s</mi><mo>)</mo></mrow></mrow></mrow></math>](img/25.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mn>2</mn><mo>=</mo><msup><mi
    mathvariant="normal">e</mi><mrow><mo>.</mo><mn>03</mn><mi mathvariant="normal">t</mi></mrow></msup><mo>(</mo><mi
    mathvariant="normal">d</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">v</mi><mi
    mathvariant="normal">i</mi><mi mathvariant="normal">d</mi><mi mathvariant="normal">e</mi><mi
    mathvariant="normal">d</mi><mi mathvariant="normal">b</mi><mi mathvariant="normal">y</mi><mn>5,000</mn><mi
    mathvariant="normal">o</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">b</mi><mi
    mathvariant="normal">o</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">h</mi><mi
    mathvariant="normal">s</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">d</mi><mi
    mathvariant="normal">e</mi><mi mathvariant="normal">s</mi><mo>)</mo></mrow></mrow></mrow></math>](img/25.png)'
- en: 'At this point, we have a variable in the exponent that we want to solve. When
    this happens, we can use the logarithm notation to figure it out:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们在指数中有一个变量，需要求解。遇到这种情况时，我们可以使用对数符号来计算：
- en: '![Figure 4.5 – The conversion from exponent form to logarithm form](img/B19488_04_05.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.5 – 从指数形式到对数形式的转换](img/B19488_04_05.jpg)'
- en: Figure 4.5 – The conversion from exponent form to logarithm form
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.5 – 从指数形式到对数形式的转换
- en: This leaves us with ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>e</mml:mi></mml:mrow></mml:msub><mml:mo>(</mml:mo><mml:mn>2</mml:mn><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mo>.</mml:mo><mml:mn>03</mml:mn><mml:mi>t</mml:mi></mml:math>](img/26.png).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这时我们得到的结果是 ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>e</mml:mi></mml:mrow></mml:msub><mml:mo>(</mml:mo><mml:mn>2</mml:mn><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mo>.</mml:mo><mml:mn>03</mml:mn><mml:mi>t</mml:mi></mml:math>](img/26.png)。
- en: 'When we take the logarithm of a number with a base of *e*, it is called a **natural
    logarithm**. We can rewrite the logarithm as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们对一个以 *e* 为底的数字取对数时，这叫做**自然对数**。我们可以将对数重写如下：
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi mathvariant="normal">l</mml:mi><mml:mi mathvariant="normal">n</mml:mi><mml:mo>(</mml:mo><mml:mn>2</mml:mn><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mo>.</mml:mo><mml:mn>03</mml:mn><mml:mi
    mathvariant="normal">t</mml:mi></mml:math>](img/27.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi mathvariant="normal">l</mml:mi><mml:mi mathvariant="normal">n</mml:mi><mml:mo>(</mml:mo><mml:mn>2</mml:mn><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mo>.</mml:mo><mml:mn>03</mml:mn><mml:mi
    mathvariant="normal">t</mml:mi></mml:math>](img/27.png)'
- en: 'Using a calculator (or Python), we’ll find that ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>l</mml:mi><mml:mi>n</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mo>.</mml:mo><mml:mn>069</mml:mn></mml:math>](img/28.png):'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 使用计算器（或Python），我们可以发现 ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>l</mml:mi><mml:mi>n</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mo>.</mml:mo><mml:mn>069</mml:mn></mml:math>](img/28.png)：
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mn>0.69</mn><mo>−</mo><mo>.</mo><mn>03</mn><mi>t</mi></mrow></mrow></math>](img/29.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mn>0.69</mn><mo>−</mo><mo>.</mo><mn>03</mn><mi>t</mi></mrow></mrow></math>](img/29.png)'
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi mathvariant="normal">t</mml:mi><mml:mo>=</mml:mo><mml:mn>2.31</mml:mn></mml:math>](img/30.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:mi mathvariant="normal">t</mml:mi><mml:mo>=</mml:mo><mml:mn>2.31</mml:mn></mml:math>](img/30.png)'
- en: This means that it would take *2.31* years to double our money.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们需要*2.31*年才能使我们的钱翻倍。
- en: Set theory
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集合理论
- en: Set theory involves mathematical operations at the set level. It is sometimes
    thought of as a basic fundamental group of theorems that governs the rest of mathematics.
    For our purpose, we’ll use set theory to manipulate groups of elements.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 集合理论涉及集合层级的数学运算。它有时被认为是支配其余数学的基本定理群体。为了我们的目的，我们将使用集合理论来操作元素群体。
- en: A **set** is a collection of distinct objects.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '**集合**是由不同对象组成的集合。'
- en: 'That’s it! A set can be thought of as a list in Python but with no repeat objects.
    There is even a set of objects in Python:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！集合可以被看作是一个没有重复对象的Python列表。Python中甚至有集合对象：
- en: '[PRE1]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In Python, curly braces, `{ }`, can denote a set or a dictionary. Remember
    that a dictionary in Python is a set of key-value pairs. An example is shown here:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，大括号`{ }`可以表示一个集合或字典。请记住，Python中的字典是由键值对组成的集合。一个示例如下：
- en: '[PRE2]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: They share this notation because they share a quality in that sets cannot have
    duplicate elements, just as dictionaries cannot have duplicate keys.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 它们共享这个符号，因为它们具有相同的特性——集合不能有重复元素，就像字典不能有重复的键一样。
- en: 'The **magnitude** of a set is the number of elements in the set and is represented
    as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 集合的**大小**是集合中元素的数量，表示如下：
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mo>|</mo><mi
    mathvariant="normal">A</mi><mo>|</mo><mo>=</mo><mi mathvariant="normal">m</mi><mi
    mathvariant="normal">a</mi><mi mathvariant="normal">g</mi><mi mathvariant="normal">n</mi><mi
    mathvariant="normal">i</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">u</mi><mi
    mathvariant="normal">d</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">o</mi><mi
    mathvariant="normal">f</mi><mi mathvariant="normal">A</mi></mrow></mrow></mrow></math>](img/31.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mo>|</mo><mi
    mathvariant="normal">A</mi><mo>|</mo><mo>=</mo><mi mathvariant="normal">m</mi><mi
    mathvariant="normal">a</mi><mi mathvariant="normal">g</mi><mi mathvariant="normal">n</mi><mi
    mathvariant="normal">i</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">u</mi><mi
    mathvariant="normal">d</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">o</mi><mi
    mathvariant="normal">f</mi><mi mathvariant="normal">A</mi></mrow></mrow></mrow></math>](img/31.png)'
- en: 'We can get the magnitude of a set in Python using the `len` command:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`len`命令在Python中获取集合的大小：
- en: '[PRE3]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The concept of an empty set exists and is denoted by **{}**. This null set is
    said to have a magnitude of 0.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 空集合的概念是存在的，它用**{}**表示。这个空集的大小为0。
- en: 'If we wish to denote that an element is within a set, we can use the epsilon
    notation, as shown here:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想表示一个元素属于某个集合，可以使用ε符号表示，如下所示：
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mn>2</mn><mo>∈</mo><mo>{</mo><mn>1,2</mn><mo>,</mo><mn>3</mn><mo>}</mo></mrow></mrow></mrow></math>](img/32.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mn>2</mn><mo>∈</mo><mo>{</mo><mn>1,2</mn><mo>,</mo><mn>3</mn><mo>}</mo></mrow></mrow></mrow></math>](img/32.png)'
- en: 'This notation means that the element, `2`, exists in the set of *1*, *2*, and
    *3*. If one set is entirely inside another set, we say that it is a **subset**
    of its larger counterpart:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这个符号表示元素`2`存在于集合*1*、*2*和*3*中。如果一个集合完全包含在另一个集合中，我们称其为该大集合的**子集**：
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mi>A</mi><mo>=</mo><mo>{</mo><mn>1,5</mn><mo>,</mo><mn>6</mn><mo>}</mo><mo>,</mo><mi>B</mi><mo>=</mo><mo>{</mo><mn>1,5</mn><mo>,</mo><mn>6,7</mn><mo>,</mo><mn>8</mn><mo>}</mo></mrow></mrow></mrow></math>](img/33.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mi>A</mi><mo>=</mo><mo>{</mo><mn>1,5</mn><mo>,</mo><mn>6</mn><mo>}</mo><mo>,</mo><mi>B</mi><mo>=</mo><mo>{</mo><mn>1,5</mn><mo>,</mo><mn>6,7</mn><mo>,</mo><mn>8</mn><mo>}</mo></mrow></mrow></mrow></math>](img/33.png)'
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mi>A</mi><mo>⊆</mo><mi>B</mi></mrow></mrow></math>](img/34.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mi>A</mi><mo>⊆</mo><mi>B</mi></mrow></mrow></math>](img/34.png)'
- en: (*A is a subset of B because every element in A is also* *in B.*)
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: (*A是B的子集，因为A中的每个元素也在B中。*)
- en: So, *A* is a subset of *B* and *B* is called the **superset** of *A*. If *A*
    is a subset of *B* but *A* does not equal *B* (meaning that there is at least
    one element in *B* that is not in *A*), then *A* is called a **proper subset**
    of *B*.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，*A*是*B*的子集，而*B*被称为*A*的**超集**。如果*A*是*B*的子集，但*A*不等于*B*（意味着在*B*中至少有一个元素不在*A*中），那么*A*被称为*B*的**真子集**。
- en: 'Consider the following examples:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: A set of even numbers is a subset of all integers
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 偶数集合是所有整数的子集
- en: Every set is a subset, but not a proper subset, of itself
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个集合都是它自己的子集，但不是它自己的真子集
- en: A set of all tweets is a superset of English tweets
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有推文的集合是英文推文的超集
- en: In data science, we use sets (and lists) to represent a list of objects and,
    often, to generalize the behavior of consumers. It is common to reduce a customer
    to a set of characteristics.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据科学中，我们使用集合（和列表）来表示对象的列表，并且常常用来概括消费者的行为。将客户简化为一组特征是常见做法。
- en: 'Imagine that we are a marketing firm trying to predict where a person wants
    to shop for clothes. We are given a set of clothing brands the user has previously
    visited, and our goal is to predict a new store that they would also enjoy. Suppose
    a specific user has previously shopped at the following stores:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们是一个营销公司，试图预测一个人想去哪里购物。我们已经获得了一个用户之前访问过的服装品牌集合，我们的目标是预测一个新的他们也会喜欢的商店。假设某个特定用户之前去过以下商店：
- en: '[PRE4]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'So, `user1` has previously shopped at `Target`, `Banana Republic`, and `Old
    Navy`. Let’s also look at a different user, called `user2`, as shown here:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，`user1`之前在`Target`、`Banana Republic`和`Old Navy`购物。让我们再看看另一个用户，称为`user2`，如下所示：
- en: '[PRE5]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Suppose we are wondering how similar these users are. With the limited information
    we have, one way to define similarity is to see how many stores there are that
    they both shop at. This is called an **intersection**.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想知道这两个用户有多相似。根据我们掌握的有限信息，一种定义相似性的方法是看他们都去过多少家商店。这个过程被称为**交集**。
- en: 'The intersection of two sets is a set whose elements appear in both sets. It
    is denoted using the ∩ symbol, as shown here:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 两个集合的交集是一个包含出现在两个集合中的元素的集合。它使用∩符号表示，如下所示：
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mi
    mathvariant="normal">u</mi><mi>s</mi><mi>e</mi><mi>r</mi><mn>1</mn><mo>∩</mo><mi>u</mi><mi>s</mi><mi>e</mi><mi>r</mi><mn>2</mn><mo>=</mo><mo>{</mo><mi>B</mi><mi>a</mi><mi>n</mi><mi>a</mi><mi>n</mi><mi>a</mi><mi>R</mi><mi>e</mi><mi>p</mi><mi>u</mi><mi>b</mi><mi>l</mi><mi>i</mi><mi>c</mi><mo>}</mo></mrow></mrow></mrow></math>](img/35.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mi
    mathvariant="normal">u</mi><mi>s</mi><mi>e</mi><mi>r</mi><mn>1</mn><mo>∩</mo><mi>u</mi><mi>s</mi><mi>e</mi><mi>r</mi><mn>2</mn><mo>=</mo><mo>{</mo><mi>B</mi><mi>a</mi><mi>n</mi><mi>a</mi><mi>n</mi><mi>a</mi><mi>R</mi><mi>e</mi><mi>p</mi><mi>u</mi><mi>b</mi><mi>l</mi><mi>i</mi><mi>c</mi><mo>}</mo></mrow></mrow></mrow></math>](img/35.png)'
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mi
    mathvariant="normal">u</mi><mi>s</mi><mi>e</mi><mi>r</mi><mn>1</mn><mo>∩</mo><mi>u</mi><mi>s</mi><mi>e</mi><mi>r</mi><mn>2</mn><mo>=</mo><mo>{</mo><mi>B</mi><mi>a</mi><mi>n</mi><mi>a</mi><mi>n</mi><mi>a</mi><mi>R</mi><mi>e</mi><mi>p</mi><mi>u</mi><mi>b</mi><mi>l</mi><mi>i</mi><mi>c</mi><mo>}</mo></mrow></mrow></mrow></math>](img/36.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mi
    mathvariant="normal">u</mi><mi>s</mi><mi>e</mi><mi>r</mi><mn>1</mn><mo>∩</mo><mi>u</mi><mi>s</mi><mi>e</mi><mi>r</mi><mn>2</mn><mo>=</mo><mo>{</mo><mi>B</mi><mi>a</mi><mi>n</mi><mi>a</mi><mi>n</mi><mi>a</mi><mi>R</mi><mi>e</mi><mi>p</mi><mi>u</mi><mi>b</mi><mi>l</mi><mi>i</mi><mi>c</mi><mo>}</mo></mrow></mrow></mrow></math>](img/36.png)'
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mo>|</mo><mi
    mathvariant="normal">u</mi><mi>s</mi><mi>e</mi><mi>r</mi><mn>1</mn><mo>∩</mo><mi>u</mi><mi>s</mi><mi>e</mi><mi>r</mi><mn>2</mn><mo>|</mo><mo>=</mo><mn>1</mn></mrow></mrow></mrow></math>](img/37.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mo>|</mo><mi
    mathvariant="normal">u</mi><mi>s</mi><mi>e</mi><mi>r</mi><mn>1</mn><mo>∩</mo><mi>u</mi><mi>s</mi><mi>e</mi><mi>r</mi><mn>2</mn><mo>|</mo><mo>=</mo><mn>1</mn></mrow></mrow></mrow></math>](img/37.png)'
- en: The intersection of the two users is just one store. So, right away, that doesn’t
    seem great. However, each user only has three elements in their set, so having
    1/3 does not seem as bad. Suppose we are curious about how many stores are represented
    between the two of them; this is called a **union**.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 两个用户的交集只有一个商店。因此，直接看上去，这似乎不太理想。然而，每个用户在他们的集合中只有三个元素，所以拥有 1/3 的交集并不显得那么糟糕。假设我们想知道这两个用户之间有多少个商店被表示出来，这就叫做**并集**。
- en: 'The union of two sets is a set whose elements appear in either set. It is denoted
    using the ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mo>∪</mml:mo></mml:math>](img/38.png)
    symbol, as shown here:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 两个集合的并集是一个集合，它的元素出现在任意一个集合中。它用![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mo>∪</mml:mo></mml:math>](img/38.png)符号表示，如下所示：
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mi
    mathvariant="normal">u</mi><mi>s</mi><mi>e</mi><mi>r</mi><mn>1</mn><mo>∪</mo><mi>u</mi><mi>s</mi><mi>e</mi><mi>r</mi><mn>2</mn><mo>=</mo><mo>{</mo><mi>B</mi><mi>a</mi><mi>n</mi><mi>a</mi><mi>n</mi><mi>a</mi><mi>R</mi><mi>e</mi><mi>p</mi><mi>u</mi><mi>b</mi><mi>l</mi><mi>i</mi><mi>c</mi><mo>,</mo><mi>T</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi><mo>,</mo><mi>O</mi><mi>l</mi><mi>d</mi><mi>N</mi><mi>a</mi><mi>v</mi><mi>y</mi><mo>,</mo><mi>G</mi><mi>a</mi><mi>p</mi><mo>,</mo><mi>K</mi><mi>o</mi><mi>h</mi><mi>l</mi><mo>′</mo><mi>s</mi><mo>}</mo></mrow></mrow></mrow></math>](img/39.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mi
    mathvariant="normal">u</mi><mi>s</mi><mi>e</mi><mi>r</mi><mn>1</mn><mo>∪</mo><mi>u</mi><mi>s</mi><mi>e</mi><mi>r</mi><mn>2</mn><mo>=</mo><mo>{</mo><mi>B</mi><mi>a</mi><mi>n</mi><mi>a</mi><mi>n</mi><mi>a</mi><mi>R</mi><mi>e</mi><mi>p</mi><mi>u</mi><mi>b</mi><mi>l</mi><mi>i</mi><mi>c</mi><mo>,</mo><mi>T</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi><mo>,</mo><mi>O</mi><mi>l</mi><mi>d</mi><mi>N</mi><mi>a</mi><mi>v</mi><mi>y</mi><mo>,</mo><mi>G</mi><mi>a</mi><mi>p</mi><mo>,</mo><mi>K</mi><mi>o</mi><mi>h</mi><mi>l</mi><mo>′</mo><mi>s</mi><mo>}</mo></mrow></mrow></mrow></math>](img/39.png)'
- en: 'When looking at the similarities between `user1` and `user2`, we should use
    a combination of the `user1` and `user2` have one element in common out of a total
    of five distinct elements between them. So, we can define the similarity between
    the two users as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看`user1`和`user2`之间的相似性时，我们应该使用`user1`和`user2`之间有一个共同元素，而这两个用户之间总共有五个不同的元素。因此，我们可以定义两个用户之间的相似度如下：
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mfrac><mrow><mo>|</mo><mi
    mathvariant="normal">u</mi><mi mathvariant="normal">s</mi><mi mathvariant="normal">e</mi><mi
    mathvariant="normal">r</mi><mn>1</mn><mo>∩</mo><mi mathvariant="normal">u</mi><mi
    mathvariant="normal">s</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">r</mi><mn>2</mn><mo>|</mo></mrow><mrow><mo>|</mo><mi
    mathvariant="normal">u</mi><mi mathvariant="normal">s</mi><mi mathvariant="normal">e</mi><mi
    mathvariant="normal">r</mi><mn>1</mn><mo>∪</mo><mi mathvariant="normal">u</mi><mi
    mathvariant="normal">s</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">r</mi><mn>2</mn><mo>|</mo></mrow></mfrac><mo>=</mo><mfrac><mn>1</mn><mn>5</mn></mfrac><mo>=</mo><mo>.</mo><mn>2</mn></mrow></mrow></math>](img/40.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mfrac><mrow><mo>|</mo><mi
    mathvariant="normal">u</mi><mi mathvariant="normal">s</mi><mi mathvariant="normal">e</mi><mi
    mathvariant="normal">r</mi><mn>1</mn><mo>∩</mo><mi mathvariant="normal">u</mi><mi
    mathvariant="normal">s</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">r</mi><mn>2</mn><mo>|</mo></mrow><mrow><mo>|</mo><mi
    mathvariant="normal">u</mi><mi mathvariant="normal">s</mi><mi mathvariant="normal">e</mi><mi
    mathvariant="normal">r</mi><mn>1</mn><mo>∪</mo><mi mathvariant="normal">u</mi><mi
    mathvariant="normal">s</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">r</mi><mn>2</mn><mo>|</mo></mrow></mfrac><mo>=</mo><mfrac><mn>1</mn><mn>5</mn></mfrac><mo>=</mo><mo>.</mo><mn>2</mn></mrow></mrow></math>](img/40.png)'
- en: 'This has a name in set theory: the **Jaccard measure**. In general, for the
    *A* and *B* sets, the Jaccard measure (Jaccard similarity) between the two sets
    is defined as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这在集合论中有一个名字：**Jaccard度量**。一般来说，对于*A*和*B*集合，Jaccard度量（Jaccard相似度）定义如下：
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mi>J</mi><mi>S</mi><mo>(</mo><mi>A</mi><mo>,</mo><mi>B</mi><mo>)</mo><mo>=</mo><mfrac><mrow><mo>|</mo><mi
    mathvariant="normal">A</mi><mo>∩</mo><mi mathvariant="normal">B</mi><mo>|</mo></mrow><mrow><mo>|</mo><mi
    mathvariant="normal">A</mi><mo>∪</mo><mi mathvariant="normal">B</mi><mo>|</mo></mrow></mfrac></mrow></mrow></mrow></math>](img/41.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mi>J</mi><mi>S</mi><mo>(</mo><mi>A</mi><mo>,</mo><mi>B</mi><mo>)</mo><mo>=</mo><mfrac><mrow><mo>|</mo><mi
    mathvariant="normal">A</mi><mo>∩</mo><mi mathvariant="normal">B</mi><mo>|</mo></mrow><mrow><mo>|</mo><mi
    mathvariant="normal">A</mi><mo>∪</mo><mi mathvariant="normal">B</mi><mo>|</mo></mrow></mfrac></mrow></mrow></mrow></math>](img/41.png)'
- en: It can also be defined as the magnitude of the intersection of the two sets
    divided by the magnitude of the union of the two sets.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 它也可以定义为两个集合交集的大小与两个集合并集的大小之比。
- en: This gives us a way to quantify similarities between elements represented with
    sets.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们提供了一种量化集合之间相似度的方法。
- en: Intuitively, the Jaccard measure is a number between `0` and `1`, such that
    when the number is closer to `0`, people are more dissimilar, and when the measure
    is closer to `1`, people are considered similar to each other.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 直观上，Jaccard 衡量是一个介于 `0` 和 `1` 之间的数值，当该数值越接近 `0` 时，表示两者差异越大；当数值越接近 `1` 时，表示两者相似度越高。
- en: 'If we think about the definition, then it makes sense. Take a look at the measure
    once more:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们考虑这个定义，那么它就有意义了。再看一下这个衡量公式：
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mi>J</mi><mi>S</mi><mo>(</mo><mi>A</mi><mo>,</mo><mi>B</mi><mo>)</mo><mo>=</mo><mfrac><mrow><mi
    mathvariant="normal">N</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">m</mi><mi
    mathvariant="normal">b</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">r</mi><mi
    mathvariant="normal">o</mi><mi mathvariant="normal">f</mi><mi mathvariant="normal">s</mi><mi
    mathvariant="normal">t</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">r</mi><mi
    mathvariant="normal">e</mi><mi mathvariant="normal">s</mi><mi mathvariant="normal">t</mi><mi
    mathvariant="normal">h</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">y</mi><mi
    mathvariant="normal">s</mi><mi mathvariant="normal">h</mi><mi mathvariant="normal">a</mi><mi
    mathvariant="normal">r</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">i</mi><mi
    mathvariant="normal">n</mi><mi mathvariant="normal">c</mi><mi mathvariant="normal">o</mi><mi
    mathvariant="normal">m</mi><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi
    mathvariant="normal">n</mi></mrow><mrow><mi mathvariant="normal">U</mi><mi mathvariant="normal">n</mi><mi
    mathvariant="normal">i</mi><mi mathvariant="normal">q</mi><mi mathvariant="normal">u</mi><mi
    mathvariant="normal">e</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">u</mi><mi
    mathvariant="normal">m</mi><mi mathvariant="normal">b</mi><mi mathvariant="normal">e</mi><mi
    mathvariant="normal">r</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">f</mi><mi
    mathvariant="normal">s</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">o</mi><mi
    mathvariant="normal">r</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">s</mi><mi
    mathvariant="normal">t</mi><mi mathvariant="normal">h</mi><mi mathvariant="normal">e</mi><mi
    mathvariant="normal">y</mi><mi mathvariant="normal">l</mi><mi mathvariant="normal">i</mi><mi
    mathvariant="normal">k</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">d</mi><mi
    mathvariant="normal">c</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">m</mi><mi
    mathvariant="normal">b</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">n</mi><mi
    mathvariant="normal">e</mi><mi mathvariant="normal">d</mi></mrow></mfrac></mrow></mrow></mrow></math>](img/42.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mi>J</mi><mi>S</mi><mo>(</mo><mi>A</mi><mo>,</mo><mi>B</mi><mo>)</mo><mo>=</mo><mfrac><mrow><mi
    mathvariant="normal">N</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">m</mi><mi
    mathvariant="normal">b</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">r</mi><mi
    mathvariant="normal">o</mi><mi mathvariant="normal">f</mi><mi mathvariant="normal">s</mi><mi
    mathvariant="normal">t</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">r</mi><mi
    mathvariant="normal">e</mi><mi mathvariant="normal">s</mi><mi mathvariant="normal">t</mi><mi
    mathvariant="normal">h</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">y</mi><mi
    mathvariant="normal">s</mi><mi mathvariant="normal">h</mi><mi mathvariant="normal">a</mi><mi
    mathvariant="normal">r</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">i</mi><mi
    mathvariant="normal">n</mi><mi mathvariant="normal">c</mi><mi mathvariant="normal">o</mi><mi
    mathvariant="normal">m</mi><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi
    mathvariant="normal">n</mi></mrow><mrow><mi mathvariant="normal">U</mi><mi mathvariant="normal">n</mi><mi
    mathvariant="normal">i</mi><mi mathvariant="normal">q</mi><mi mathvariant="normal">u</mi><mi
    mathvariant="normal">e</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">u</mi><mi
    mathvariant="normal">m</mi><mi mathvariant="normal">b</mi><mi mathvariant="normal">e</mi><mi
    mathvariant="normal">r</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">f</mi><mi
    mathvariant="normal">s</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">o</mi><mi
    mathvariant="normal">r</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">s</mi><mi
    mathvariant="normal">t</mi><mi mathvariant="normal">h</mi><mi mathvariant="normal">e</mi><mi
    mathvariant="normal">y</mi><mi mathvariant="normal">l</mi><mi mathvariant="normal">i</mi><mi
    mathvariant="normal">k</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">d</mi><mi
    mathvariant="normal">c</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">m</mi><mi
    mathvariant="normal">b</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">n</mi><mi
    mathvariant="normal">e</mi><mi mathvariant="normal">d</mi></mrow></mfrac></mrow></mrow></mrow></math>](img/42.png)'
- en: Here, the numerator represents the number of stores that the users have in common
    (in the sense that they like shopping there), while the denominator represents
    the unique number of stores that they like put together.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，分子表示用户共同拥有的商店数量（即他们喜欢在那里购物），而分母表示他们喜欢的独特商店数量的总和。
- en: 'We can represent this in Python using some simple code, as shown here:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用一些简单的代码在 Python 中表示这一点，如下所示：
- en: '[PRE6]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Set theory becomes highly prevalent when we enter the world of probability and
    also when dealing with high-dimensional data. We can use sets to represent real-world
    events taking place, and probability becomes set theory with vocabulary on top
    of it.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 集合论在我们进入概率世界和处理高维数据时变得非常重要。我们可以使用集合来表示现实世界中发生的事件，而概率则是建立在集合论基础上的一套词汇。
- en: Linear algebra
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线性代数
- en: As we’ve already seen, a movie recommendation engine utilizes several mathematical
    concepts to provide accurate and personalized recommendations to users. However,
    in a scenario where a vast collection of 10,000 movies is available for recommendation,
    computational efficiency becomes a crucial factor. Linear algebra, an area of
    mathematics that deals with matrices and vectors, provides the necessary tools
    to perform these calculations efficiently.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前看到的，电影推荐引擎利用了几个数学概念，以便向用户提供准确的个性化推荐。然而，在有10,000部电影可供推荐的情况下，计算效率变得尤为重要。线性代数，作为一种涉及矩阵和向量的数学领域，提供了进行这些计算所需的工具，使得计算更加高效。
- en: Linear algebra focuses on analyzing and manipulating matrices and vectors to
    extract useful information and apply it in practical situations. As we proceed,
    it is important to have a solid understanding of the basic principles of linear
    algebra. Therefore, we will be reviewing several key rules of linear algebra before
    delving further into the topic.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 线性代数专注于分析和操作矩阵与向量，以提取有用的信息并将其应用于实际情境。随着我们深入学习，理解线性代数的基本原理非常重要。因此，在进一步探讨之前，我们将回顾线性代数的几个关键规则。
- en: Matrix multiplication
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 矩阵乘法
- en: 'Like numbers, we can multiply matrices together. Multiplying matrices is, in
    essence, a mass-produced way of taking several dot products at once. Let’s, for
    example, try to multiply the following matrices:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 和数字一样，我们可以将矩阵相乘。矩阵乘法本质上是一种批量化进行点积的方式。比如，我们可以尝试将以下矩阵相乘：
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mfenced
    open="(" close=")"><mtable columnwidth="auto" columnalign="center" rowspacing="1.0000ex
    1.0000ex" rowalign="baseline baseline baseline"><mtr><mtd><mrow><mn>1</mn><mn>5</mn></mrow></mtd></mtr><mtr><mtd><mrow><mn>5</mn><mn>8</mn></mrow></mtd></mtr><mtr><mtd><mrow><mn>7</mn><mn>8</mn></mrow></mtd></mtr></mtable></mfenced><mo>.</mo><mfenced
    open="(" close=")"><mfrac><mrow><mn>3</mn><mn>4</mn></mrow><mrow><mn>2</mn><mn>5</mn></mrow></mfrac></mfenced></mrow></mrow></math>](img/43.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mfenced
    open="(" close=")"><mtable columnwidth="auto" columnalign="center" rowspacing="1.0000ex
    1.0000ex" rowalign="baseline baseline baseline"><mtr><mtd><mrow><mn>1</mn><mn>5</mn></mrow></mtd></mtr><mtr><mtd><mrow><mn>5</mn><mn>8</mn></mrow></mtd></mtr><mtr><mtd><mrow><mn>7</mn><mn>8</mn></mrow></mtd></mtr></mtable></mfenced><mo>.</mo><mfenced
    open="(" close=")"><mfrac><mrow><mn>3</mn><mn>4</mn></mrow><mrow><mn>2</mn><mn>5</mn></mrow></mfrac></mfenced></mrow></mrow></math>](img/43.png)'
- en: 'We need to consider a couple of things:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要考虑几点：
- en: Unlike numbers, the multiplication of matrices is not *commutative*, meaning
    that the order in which you multiply matrices matters a great deal.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与数字不同，矩阵的乘法是*非交换的*，这意味着你相乘矩阵的顺序非常重要。
- en: To multiply matrices, their dimensions must match up. This means that the first
    matrix must have the same number of columns as the second matrix has rows.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要进行矩阵乘法，它们的维度必须匹配。这意味着第一个矩阵的列数必须与第二个矩阵的行数相同。
- en: To remember this, write out the dimensions of the matrices. In this case, we
    have a *3 x 2* matrix times a *2 x 2* matrix. You can multiply matrices together
    if the second number in the first-dimension pair is the same as the first number
    in the second-dimension pair. The resulting matrix will always have dimensions
    equal to the outer numbers in the dimension pairs (the ones you did not circle).
    In this case, the resulting matrix will have a dimension of *3* *x 2*.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 为了记住这一点，可以写出矩阵的维度。在这个例子中，我们有一个*3 x 2*的矩阵与一个*2 x 2*的矩阵相乘。如果第一个矩阵的第一维的第二个数与第二个矩阵的第二维的第一个数相同，就可以进行矩阵乘法。结果矩阵的维度将等于维度对外部的数字（你没有圈出的那些）。在这个例子中，结果矩阵的维度是*3
    x 2*。
- en: How to multiply matrices together
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何将矩阵相乘
- en: To multiply matrices, there is a simple procedure we can follow. Essentially,
    we are performing a bunch of dot products.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵相乘有一个简单的步骤可以遵循。基本上，我们是在执行一系列的点积运算。
- en: 'Recall our earlier sample problem, which was as follows:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾我们之前的示例问题，问题如下：
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mfenced
    open="(" close=")"><mtable columnwidth="auto" columnalign="center" rowspacing="1.0000ex
    1.0000ex" rowalign="baseline baseline baseline"><mtr><mtd><mrow><mn>1</mn><mn>5</mn></mrow></mtd></mtr><mtr><mtd><mrow><mn>5</mn><mn>8</mn></mrow></mtd></mtr><mtr><mtd><mrow><mn>7</mn><mn>8</mn></mrow></mtd></mtr></mtable></mfenced><mo>.</mo><mfenced
    open="(" close=")"><mfrac><mrow><mn>3</mn><mn>4</mn></mrow><mrow><mn>2</mn><mn>5</mn></mrow></mfrac></mfenced></mrow></mrow></math>](img/43.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mfenced
    open="(" close=")"><mtable columnwidth="auto" columnalign="center" rowspacing="1.0000ex
    1.0000ex" rowalign="baseline baseline baseline"><mtr><mtd><mrow><mn>1</mn><mn>5</mn></mrow></mtd></mtr><mtr><mtd><mrow><mn>5</mn><mn>8</mn></mrow></mtd></mtr><mtr><mtd><mrow><mn>7</mn><mn>8</mn></mrow></mtd></mtr></mtable></mfenced><mo>.</mo><mfenced
    open="(" close=")"><mfrac><mrow><mn>3</mn><mn>4</mn></mrow><mrow><mn>2</mn><mn>5</mn></mrow></mfrac></mfenced></mrow></mrow></math>](img/43.png)'
- en: 'We know that our resulting matrix will have a dimension of *3 x 2*. So, we
    know it will look something like this:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道，得到的矩阵的维度将是*3 x 2*。所以，我们知道它的形状大致是这样的：
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mfenced
    open="(" close=")"><mtable columnwidth="auto" columnalign="center" rowspacing="1.0000ex
    1.0000ex" rowalign="baseline baseline baseline"><mtr><mtd><mrow><msub><mi mathvariant="normal">m</mi><mn>11</mn></msub><msub><mi
    mathvariant="normal">m</mi><mn>12</mn></msub></mrow></mtd></mtr><mtr><mtd><mrow><msub><mi
    mathvariant="normal">m</mi><mn>21</mn></msub><msub><mi mathvariant="normal">m</mi><mn>22</mn></msub></mrow></mtd></mtr><mtr><mtd><mrow><msub><mi
    mathvariant="normal">m</mi><mn>31</mn></msub><msub><mi mathvariant="normal">m</mi><mn>32</mn></msub></mrow></mtd></mtr></mtable></mfenced></mrow></math>](img/45.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mfenced
    open="(" close=")"><mtable columnwidth="auto" columnalign="center" rowspacing="1.0000ex
    1.0000ex" rowalign="baseline baseline baseline"><mtr><mtd><mrow><msub><mi mathvariant="normal">m</mi><mn>11</mn></msub><msub><mi
    mathvariant="normal">m</mi><mn>12</mn></msub></mrow></mtd></mtr><mtr><mtd><mrow><msub><mi
    mathvariant="normal">m</mi><mn>21</mn></msub><msub><mi mathvariant="normal">m</mi><mn>22</mn></msub></mrow></mtd></mtr><mtr><mtd><mrow><msub><mi
    mathvariant="normal">m</mi><mn>31</mn></msub><msub><mi mathvariant="normal">m</mi><mn>32</mn></msub></mrow></mtd></mtr></mtable></mfenced></mrow></math>](img/45.png)'
- en: Note
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Note that each element of the matrix is indexed using a double index. The first
    number represents the row, while the second number represents the column. So,
    the *m*32 element is the element in the third row of the second column. Each element
    is the result of a dot product between rows and columns of the original matrices.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，矩阵的每个元素使用双重索引。第一个数字代表行，第二个数字代表列。所以，*m*32元素是第二列第三行的元素。每个元素是原始矩阵的行与列之间的点积结果。
- en: 'The *mxy* element is the result of the dot product of the *xth* row of the
    first matrix and the *yth* column of the second matrix. Let’s solve a few:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '*mxy*元素是第一矩阵的第*x*行与第二矩阵的第*y*列之间的点积结果。我们来解决几个：'
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:mn>11</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac linethickness="0pt"><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mn>5</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced><mml:mo>.</mml:mo><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac linethickness="0pt"><mml:mrow><mml:mn>3</mml:mn></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mn>13</mml:mn></mml:math>](img/46.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:mn>11</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac linethickness="0pt"><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mn>5</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced><mml:mo>.</mml:mo><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac linethickness="0pt"><mml:mrow><mml:mn>3</mml:mn></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mn>13</mml:mn></mml:math>](img/46.png)'
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:mn>12</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac linethickness="0pt"><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mn>5</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced><mml:mo>.</mml:mo><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac linethickness="0pt"><mml:mrow><mml:mn>4</mml:mn></mml:mrow><mml:mrow><mml:mn>5</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mn>29</mml:mn></mml:math>](img/47.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:mn>12</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac linethickness="0pt"><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mn>5</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced><mml:mo>.</mml:mo><mml:mfenced
    separators="|"><mml:mrow><mml:mfrac linethickness="0pt"><mml:mrow><mml:mn>4</mml:mn></mml:mrow><mml:mrow><mml:mn>5</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mn>29</mml:mn></mml:math>](img/47.png)'
- en: 'We eventually get a resulting matrix that looks as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，我们会得到一个结果矩阵，如下所示：
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mfenced
    open="(" close=")"><mtable columnwidth="auto" columnalign="center" rowspacing="1.0000ex
    1.0000ex" rowalign="baseline baseline baseline"><mtr><mtd><mrow><mn>13</mn><mn>29</mn></mrow></mtd></mtr><mtr><mtd><mrow><mn>31</mn><mn>60</mn></mrow></mtd></mtr><mtr><mtd><mrow><mn>37</mn><mn>68</mn></mrow></mtd></mtr></mtable></mfenced></mrow></math>](img/48.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mfenced
    open="(" close=")"><mtable columnwidth="auto" columnalign="center" rowspacing="1.0000ex
    1.0000ex" rowalign="baseline baseline baseline"><mtr><mtd><mrow><mn>13</mn><mn>29</mn></mrow></mtd></mtr><mtr><mtd><mrow><mn>31</mn><mn>60</mn></mrow></mtd></mtr><mtr><mtd><mrow><mn>37</mn><mn>68</mn></mrow></mtd></mtr></mtable></mfenced></mrow></math>](img/48.png)'
- en: 'Nice! Let’s go back to the movie recommendation example. Recall the user’s
    movie genre preferences of comedy, romance, and action, illustrated as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！我们回到电影推荐的例子。回忆一下用户的电影类型偏好：喜剧、浪漫和动作，如下所示：
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mi>U</mi><mo>=</mo><mi>u</mi><mi>s</mi><mi>e</mi><mi>r</mi><mi>p</mi><mi>r</mi><mi>e</mi><mi>f</mi><mi>s</mi><mo>=</mo><mfenced
    open="(" close=")"><mtable columnwidth="auto" columnalign="center" rowspacing="1.0000ex
    1.0000ex" rowalign="baseline baseline baseline"><mtr><mtd><mn>5</mn></mtd></mtr><mtr><mtd><mn>1</mn></mtd></mtr><mtr><mtd><mn>3</mn></mtd></mtr></mtable></mfenced></mrow></mrow></math>](img/49.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mi>U</mi><mo>=</mo><mi>u</mi><mi>s</mi><mi>e</mi><mi>r</mi><mi>p</mi><mi>r</mi><mi>e</mi><mi>f</mi><mi>s</mi><mo>=</mo><mfenced
    open="(" close=")"><mtable columnwidth="auto" columnalign="center" rowspacing="1.0000ex
    1.0000ex" rowalign="baseline baseline baseline"><mtr><mtd><mn>5</mn></mtd></mtr><mtr><mtd><mn>1</mn></mtd></tr><mtr><mtd><mn>3</mn></mtd></mtr></mtable></mfenced></mrow></mrow></math>](img/49.png)'
- en: Now, suppose we have 10,000 movies, all with a rating for these three categories.
    To make a recommendation, we need to take the dot product of the preference vector
    with each of the 10,000 movies. We can use matrix multiplication to represent
    this.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们有10,000部电影，每部电影都有这三类的评分。为了进行推荐，我们需要将偏好向量与每一部10,000部电影进行点积计算。我们可以使用矩阵乘法来表示这一过程。
- en: 'Instead of writing them all out, let’s express them using the matrix notation.
    We already have *U*, defined here as the user’s preference vector (it can also
    be thought of as a *3 x 1* matrix), but we also need a movie matrix:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要将它们全部写出来，而是使用矩阵表示法。我们已经有了*U*，它在这里被定义为用户的偏好向量（也可以视作一个*3 x 1*的矩阵），但我们还需要一个电影矩阵：
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mi>M</mi><mo>=</mo><mi>m</mi><mi>o</mi><mi>v</mi><mi>i</mi><mi>e</mi><mi>s</mi><mo>=</mo><mn>3</mn><mi>x</mi><mn>10,000</mn></mrow></mrow></math>](img/50.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mi>M</mi><mo>=</mo><mi>m</mi><mi>o</mi><mi>v</mi><mi>i</mi><mi>e</mi><mi>s</mi><mo>=</mo><mn>3</mn><mi>x</mi><mn>10,000</mn></mrow></mrow></math>](img/50.png)'
- en: 'Now, we have two matrices; one is *3 x 1* and the other is *3 x 10,000*. We
    can’t multiply these matrices as they are because the dimensions do not work out.
    We will have to change *U* a bit. To do this, we can take the *transpose* of the
    matrix (turning all rows into columns and all columns into rows). This will switch
    the dimensions around:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有两个矩阵；一个是*3 x 1*，另一个是*3 x 10,000*。由于维度不匹配，我们不能直接相乘。我们需要稍微调整一下*U*。为此，我们可以对矩阵进行*转置*（将所有行变为列，将所有列变为行）。这样就能改变维度：
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><msup><mi>U</mi><mi
    mathvariant="normal">T</mi></msup><mo>=</mo><mi mathvariant="normal">t</mi><mi
    mathvariant="normal">r</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">n</mi><mi
    mathvariant="normal">s</mi><mi mathvariant="normal">p</mi><mi mathvariant="normal">o</mi><mi
    mathvariant="normal">s</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">o</mi><mi
    mathvariant="normal">f</mi><mi mathvariant="normal">U</mi><mo>=</mo><mo>(</mo><mn>5</mn><mn>1</mn><mn>3</mn><mo>)</mo></mrow></mrow></mrow></math>](img/51.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><msup><mi>U</mi><mi
    mathvariant="normal">T</mi></msup><mo>=</mo><mi mathvariant="normal">t</mi><mi
    mathvariant="normal">r</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">n</mi><mi
    mathvariant="normal">s</mi><mi mathvariant="normal">p</mi><mi mathvariant="normal">o</mi><mi
    mathvariant="normal">s</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">o</mi><mi
    mathvariant="normal">f</mi><mi mathvariant="normal">U</mi><mo>=</mo><mo>(</mo><mn>5</mn><mn>1</mn><mn>3</mn><mo>)</mo></mrow></mrow></mrow></math>](img/51.png)'
- en: 'So, now, we have two matrices that can be multiplied together. Let’s visualize
    what this looks like:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有了可以相乘的两个矩阵。让我们来可视化一下这个过程：
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mo>(</mo><mn>5</mn><mn>1</mn><mn>3</mn><mo>)</mo><mo>.</mo><mfenced
    open="(" close=")"><mtable columnwidth="auto" columnalign="center" rowspacing="1.0000ex
    1.0000ex" rowalign="baseline baseline baseline"><mtr><mtd><mrow><mn>4</mn><mn>5</mn><mo>...</mo><mo>.</mo></mrow></mtd></mtr><mtr><mtd><mrow><mn>1</mn><mn>4</mn><mo>...</mo><mo>.</mo></mrow></mtd></mtr><mtr><mtd><mrow><mn>51</mn><mi>x</mi><mn>13</mn><mo>...</mo><mo>.</mo></mrow></mtd></mtr></mtable></mfenced><mn>3</mn><mi>x</mi><mn>1,000</mn></mrow></mrow></mrow></math>](img/52.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><mo>(</mo><mn>5</mn><mn>1</mn><mn>3</mn><mo>)</mo><mo>.</mo><mfenced
    open="(" close=")"><mtable columnwidth="auto" columnalign="center" rowspacing="1.0000ex
    1.0000ex" rowalign="baseline baseline baseline"><mtr><mtd><mrow><mn>4</mn><mn>5</mn><mo>...</mo><mo>.</mo></mrow></mtd></tr><mtr><mtd><mrow><mn>1</mn><mn>4</mn><mo>...</mo><mo>.</mo></mrow></mtd></mtr><mtr><mtd><mrow><mn>51</mn><mi>x</mi><mn>13</mn><mo>...</mo><mo>.</mo></mrow></mtd></mtr></mtable></mfenced><mn>3</mn><mi>x</mi><mn>1,000</mn></mrow></mrow></mrow></math>](img/52.png)'
- en: 'The resulting matrix will be a *1 x 1,000* matrix (a vector) of 10,000 predictions
    for each movie. Let’s try this out in Python:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的矩阵将是一个*1 x 1,000*的矩阵（一个向量），包含10,000个每部电影的预测结果。让我们在Python中试试这个：
- en: '[PRE7]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We are using the `numpy` array function to create our matrices. We will have
    both a `user_pref` matrix and a `movies` matrix to represent our data.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用`numpy`数组函数来创建我们的矩阵。我们将有一个`user_pref`矩阵和一个`movies`矩阵来表示我们的数据。
- en: 'To check our dimensions, we can use the `numpy shape` variable, as shown here:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查我们的矩阵维度，我们可以使用`numpy shape`变量，如下所示：
- en: '[PRE8]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This checks out. Last but not least, let’s use the matrix multiplication method
    of `numpy` (called dot) to perform the operation:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这没问题。最后但同样重要的是，让我们使用`numpy`的矩阵乘法方法（称为dot）来执行这个操作：
- en: '[PRE9]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The result is an array of integers that represents the recommendations for each
    movie.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个整数数组，表示每部电影的推荐结果。
- en: 'For a quick extension of this, let’s run some code that predicts across more
    than 10,000 movies:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 为了快速扩展这一点，让我们运行一些代码来预测超过10,000部电影的结果：
- en: '[PRE10]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: It took only a bit longer than 4 seconds to run through 100 million movies using
    matrix multiplication.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 使用矩阵乘法运行1亿部电影仅用了稍长于4秒。
- en: Summary
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we took a look at some basic mathematical principles that will
    become very important as we progress through this book. Between logarithms/exponents,
    matrix algebra, and proportionality, mathematics has a big role not just in analyzing
    data but in many aspects of our lives.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们回顾了一些基本的数学原理，这些原理将在本书接下来的内容中变得非常重要。无论是对数/指数、矩阵代数还是比例关系，数学在分析数据以及我们生活的许多方面都扮演着重要角色。
- en: 'The coming chapters will take a much deeper dive into two big areas of mathematics:
    probability and statistics. Our goal will be to define and interpret the smallest
    and biggest theorems in these two giant fields of mathematics.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的章节将深入探讨数学的两个重要领域：概率论和统计学。我们的目标是定义并解释这两个巨大的数学领域中的最小和最大定理。
- en: It is in these next few chapters that everything will start to come together.
    So far in this book, we have looked at math examples, data exploration guidelines,
    and basic insights into types of data. It is time to begin to tie all of these
    concepts together.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几章中，所有的内容将开始结合起来。到目前为止，我们已经看过了数学实例、数据探索指南以及对数据类型的基本理解。现在是时候将所有这些概念串联在一起了。
