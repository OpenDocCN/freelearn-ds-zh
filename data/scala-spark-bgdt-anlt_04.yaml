- en: Collection APIs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合API
- en: '"That we become depends on what we read after all of the professors have finished
    with us. The greatest university of all is a collection of books."'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: “我们变成什么取决于我们在所有教授结束后读了什么。最伟大的大学是一堆书。”
- en: '- Thomas Carlyle'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '- 托马斯·卡莱尔'
- en: 'One of the features that attract most Scala users in its Collection APIs that
    are very powerful, flexible, and has lots of operations coupled with it. The wide
    range of operations will make your life easy dealing with any kind of data. We
    are going to introduce Scala collections APIs including their different types
    and hierarchies in order to accommodate different types of data and solve a wide
    range of different problems. In a nutshell, the following topics will be covered
    in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 吸引大多数Scala用户的功能之一是其集合API非常强大、灵活，并且具有许多与之相关的操作。广泛的操作范围将使您轻松处理任何类型的数据。我们将介绍Scala集合API，包括它们的不同类型和层次结构，以适应不同类型的数据并解决各种不同的问题。简而言之，本章将涵盖以下主题：
- en: Scala collection APIs
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Scala集合API
- en: Types and hierarchies
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型和层次结构
- en: Performance characteristics
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能特征
- en: Java interoperability
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java互操作性
- en: Using Scala implicits
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Scala隐式
- en: Scala collection APIs
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scala集合API
- en: The Scala collections are a well-understood and frequently used programming
    abstraction that can be distinguished between mutable and immutable collections.
    Like a mutable variable, a *mutable* collection can be changed, updated, or extended
    when necessary. However, like an immutable variable, i*mmutable* collections cannot
    be changed. Most collection classes to utilize them are located in the packages
    `scala.collection`, `scala.collection.immutable`, and `scala.collection.mutable`,
    respectively.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Scala集合是一种被广泛理解和频繁使用的编程抽象，可以区分为可变和不可变集合。像可变变量一样，*可变*集合在必要时可以被更改、更新或扩展。然而，像不可变变量一样，*不可变*集合无法更改。大多数使用它们的集合类位于`scala.collection`、`scala.collection.immutable`和`scala.collection.mutable`包中。
- en: 'This extremely powerful feature of Scala provides you with the following facility
    to use and manipulate your data:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Scala的这一极其强大的特性为您提供了以下使用和操作数据的便利：
- en: '**Easy to use**: For example, it helps you eliminate the interference between
    iterators and collection updates. As a result, a small vocabulary consisting of
    20-50 methods should be enough to solve most of your collection problem in your
    data analytics solution.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易于使用**: 例如，它帮助您消除迭代器和集合更新之间的干扰。因此，一个由20-50个方法组成的小词汇表应该足以解决您数据分析解决方案中的大多数集合问题。'
- en: '**Concise**: You can use functional operations with a light-weight syntax and
    combine operations and, at the end, you will feel like that you''re using custom
    algebra.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简洁**: 您可以使用轻量级语法进行功能操作，并组合操作，最后，您会感觉自己在使用自定义代数。'
- en: '**Safe**: Helps you deal with most errors while coding.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全**: 帮助您在编码时处理大多数错误。'
- en: '**Fast**: most collection objects are carefully tuned and optimized; this enables
    you data computation in a faster way.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**快速**: 大多数集合对象都经过精心调整和优化；这使得您可以以更快的方式进行数据计算。'
- en: '**Universal**: Collections enable you to use and perform the same operations
    on any type, anywhere.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通用**: 集合使您能够在任何地方对任何类型执行相同的操作。'
- en: In the next section, we will explore the types and associated hierarchies of
    Scala collection APIs. We will see several examples of using most features in
    the collection APIs.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将探讨Scala集合API的类型和相关层次结构。我们将看到在集合API中使用大多数功能的几个示例。
- en: Types and hierarchies
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型和层次结构
- en: Scala collections are a well-understood and frequently-used programming abstraction
    that can be distinguished between mutable and immutable collections. Like a mutable
    variable, a mutable collection can be changed, updated, or extended when necessary.
    Like an immutable variable, immutable collections; cannot be changed. Most collection
    classes that utilize them are located in the packages `scala.collection`, `scala.collection.immutable`,
    and `scala.collection.mutable`, respectively.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Scala集合是一种被广泛理解和频繁使用的编程抽象，可以区分为可变和不可变集合。像可变变量一样，可变集合在必要时可以被更改、更新或扩展。像不可变变量一样，不可变集合无法更改。大多数使用它们的集合类位于`scala.collection`、`scala.collection.immutable`和`scala.collection.mutable`包中。
- en: The following hierarchical diagram (*Figure 1*) shows the Scala collections
    API hierarchy according to the official documentation of Scala. These all are
    either high-level abstract classes or traits. These have mutable as well as immutable
    implementations.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 以下分层图表（*图1*）显示了Scala集合API的层次结构，根据Scala的官方文档。这些都是高级抽象类或特征。这些都有可变和不可变的实现。
- en: '![](img/00091.jpeg)**Figure 1:** Collections under package scala.collection'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/00091.jpeg)**图1:** scala.collection包下的集合'
- en: Traversable
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Traversable
- en: '**Traversable** is the root of the collections'' hierarchy. In Traversable,
    there are definitions for a wide range of operations that the Scala Collections
    API offers. There is only one abstract method in Traversable, which is the `foreach`
    method.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**Traversable**是集合层次结构的根。在Traversable中，有Scala集合API提供的各种操作的定义。在Traversable中只有一个抽象方法，即`foreach`方法。'
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This method is essential to all the operations contained in Traversable. If
    you have studied data structures, you will be familiar with traversing a data
    structure's elements and executing a function on each element. The `foreach` method
    does exactly so that, it traverses the elements in the collection and executes
    a function `f` on each element. As we mentioned, this is an abstract method and
    it was designed to have different definitions according to the underlying collection
    that will make use of it, to ensure highly optimized code for each collection.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法对Traversable中包含的所有操作都是必不可少的。如果您学过数据结构，您将熟悉遍历数据结构元素并在每个元素上执行函数的过程。`foreach`方法正是这样做的，它遍历集合中的元素，并在每个元素上执行函数`f`。正如我们提到的，这是一个抽象方法，它被设计为根据将使用它的底层集合的不同定义，以确保为每个集合高度优化的代码。
- en: Iterable
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Iterable
- en: '**Iterable** is the second root in the hierarchy diagram of the Scala collections
    API. It has an abstract method called iterator that must be implemented/defined
    in all other subcollections. It also implements the `foreach` method from the
    root, which is Traversable. But as we mentioned, all the descendent subcollections
    will override this implementation to make specific optimizations related to this
    subcollection.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**Iterable**是Scala集合API层次结构图中的第二个根。它有一个名为iterator的抽象方法，必须在所有其他子集合中实现/定义。它还实现了根中的`foreach`方法，即Traversable。但正如我们提到的，所有后代子集合将覆盖此实现，以进行与该子集合相关的特定优化。'
- en: Seq, LinearSeq, and IndexedSeq
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Seq、LinearSeq和IndexedSeq
- en: A sequence has some differences from the usual Iterable, and it has a defined
    length and order. Seq has two sub-traits such as `LinearSeq` and `IndexedSeq`.
    Let's have a quick overview on them.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 序列与通常的Iterable有一些不同之处，它有一个定义的长度和顺序。Seq有两个子特征，如`LinearSeq`和`IndexedSeq`。让我们快速概述一下它们。
- en: '`LinearSeq` is a base trait for linear sequences. Linear sequences have reasonably
    efficient head, tail, and `isEmpty` methods. If these methods provide the fastest
    way to traverse the collection, a collection `Coll` that extends this trait should
    also extend `LinearSeqOptimized[A, Coll[A]]`. `LinearSeq` has three concrete methods:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`LinearSeq`是线性序列的基本特征。线性序列具有相当高效的head、tail和`isEmpty`方法。如果这些方法提供了最快的遍历集合的方式，那么扩展此特征的集合`Coll`也应该扩展`LinearSeqOptimized[A,
    Coll[A]]`。`LinearSeq`有三个具体方法：'
- en: '**isEmpty:** This checks if the list is empty or not'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**isEmpty:** 这检查列表是否为空'
- en: '**head**: This returns the first element in the list/sequence'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**head**: 这返回列表/序列中的第一个元素'
- en: '**tail**: This returns all the elements of the list but the first one. Each
    of the subcollections that inherit the `LinearSeq` will have its own implementation
    of these methods to ensure good performance. Two collections that inherit/extend
    are streams and lists.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**tail**: 这返回列表的所有元素，但不包括第一个元素。继承`LinearSeq`的每个子集合都将有自己的这些方法的实现，以确保良好的性能。继承/扩展的两个集合是streams和lists。'
- en: For more on this topic, refer to this URL at [http://www.scala-lang.org/api/current/scala/collection/LinearSeq.html.](http://www.scala-lang.org/api/current/scala/collection/LinearSeq.html)
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 有关此主题的更多信息，请参阅[http://www.scala-lang.org/api/current/scala/collection/LinearSeq.html.](http://www.scala-lang.org/api/current/scala/collection/LinearSeq.html)
- en: 'Finally, `IndexedSeq` has two methods that it''s defined in terms of them:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`IndexedSeq`有两个方法，它是根据它们定义的：
- en: '**Apply**: This finds elements by index.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Apply**: 这通过索引查找元素。'
- en: '**length**: This returns the length of the sequence. Finding an element by
    its index requires well performing implementation by the subcollections. Two of
    these indexed sequences are `Vector` and `ArrayBuffer`.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**length**: 这返回序列的长度。通过子集合的性能良好的实现来按索引查找元素。其中两个索引序列是`Vector`和`ArrayBuffer`。'
- en: Mutable and immutable
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可变和不可变
- en: 'In Scala, you will find mutable and immutable collections. A collection can
    have a mutable implementation and an immutable implementation. That''s the reason
    why, in Java, a `List` can''t be both a `LinkedList` and an `ArrayList`, but `List`
    has a `LinkedList` implementation and an `ArrayList` implementation. The following
    figure shows all collections in the package `scala.collection.immutable`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在Scala中，您会发现可变和不可变的集合。一个集合可以有一个可变的实现和一个不可变的实现。这就是为什么在Java中，`List`不能同时是`LinkedList`和`ArrayList`，但`List`有`LinkedList`实现和`ArrayList`实现的原因。以下图显示了包`scala.collection.immutable`中的所有集合：
- en: '![](img/00099.jpeg)**Figure 2:** All collections in package scala.collection.immutable'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/00099.jpeg)**图2:** scala.collection.immutable包中的所有集合'
- en: 'Scala imports the immutable collections by default, and if you need to use
    a mutable one, then you need to import it yourself. Now to get a brief overview
    of all collections in package `scala.collection.mutable`, refer to the following
    diagram:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Scala默认导入不可变集合，如果需要使用可变集合，则需要自己导入。现在，要简要了解包`scala.collection.mutable`中的所有集合，请参考以下图表：
- en: '![](img/00103.jpeg)**Figure 3:** All collections in package Scala.collection.mutable'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/00103.jpeg)**图3:** Scala.collection.mutable包中的所有集合'
- en: In every OOP and functional programming language, an array is an important collection
    package that helps us to store data objects so that, later on, we can access them
    very easily as well. In the next subsection, we will see a detailed discussion
    on arrays with some examples.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个面向对象编程和函数式编程语言中，数组都是一个重要的集合包，它帮助我们存储数据对象，以便以后可以很容易地访问它们。在下一小节中，我们将看到关于数组的详细讨论，并附有一些示例。
- en: Arrays
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组
- en: 'An array is a mutable collection. In arrays, the order of the elements will
    be preserved and duplicated elements will be kept. Being mutable, you can change
    the value of any element of the array by accessing it by its index number. Let''s
    demonstrate arrays with several examples. Use the following line of code to just
    declare a simple array:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是一个可变集合。在数组中，元素的顺序将被保留，并且重复的元素将被保留。作为可变集合，您可以通过访问其索引号来更改数组的任何元素的值。让我们通过几个示例演示数组。使用以下代码行来声明一个简单的数组：
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, print all the elements of the array:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打印数组的所有元素：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, print a particular element: for example, element 3:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打印特定的元素：例如，元素3：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let''s sum all the elements and print the sum:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们对所有元素求和并打印出来：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Finding the smallest element:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 查找最小的元素：
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Finding the largest element:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 查找最大的元素：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Another way of creating and defining an array is using the `range ()` method
    that goes as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种创建和定义数组的方法是使用`range()`方法，如下所示：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The preceding line of code means that I have created an array with elements
    between 5 and 20 with the range difference 2\. If you don''t specify the 3^(rd)
    parameter, Scala will assume the range difference is:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码行意味着我创建了一个数组，其中的元素在5到20之间，范围差为2。如果不指定第三个参数，Scala将假定范围差为：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, let''s see how to access the elements as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看如何访问元素：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'It''s even possible to concatenate two arrays using the `concat()` method as
    follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 甚至可以使用`concat()`方法连接两个数组，如下所示：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Note that for using the `range()` and the `concat()` method, you will need
    to import the Scala `Array` package as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，要使用`range()`和`concat()`方法，您需要导入Scala`Array`包，如下所示：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Lastly, it''s even possible to define and use a multi-dimensional array as
    follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，甚至可以定义和使用多维数组如下：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, first create a matrix using the preceding array as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，首先使用前面的数组创建一个矩阵如下：
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Print the earlier matrix as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下方式打印先前的矩阵：
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The complete source code of the previous example can be seen as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 前面示例的完整源代码如下所示：
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You will get the following output:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 您将获得以下输出：
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In Scala, lists preserve order, keep duplicated elements, and also check their
    immutability. Now, let's see some examples of using lists in Scala in the next
    subsection.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在Scala中，列表保留顺序，保留重复元素，并检查其不可变性。现在，让我们在下一小节中看一些在Scala中使用列表的示例。
- en: Lists
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 名单
- en: 'As discussed earlier, Scala provides mutable and immutable collections. The
    Immutable collections are imported by default, but if you need to use a mutable
    one you need to import yourself. A list is an immutable collections, and it can
    be used if you want order between the elements to be preserved and duplicates
    to be kept. Let''s demonstrate an example and see how lists preserve order and
    keep duplicated elements, and also check its immutability:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Scala提供了可变和不可变的集合。不可变集合默认导入，但如果需要使用可变集合，则需要自行导入。列表是不可变集合，如果您希望元素之间保持顺序并保留重复项，则可以使用它。让我们演示一个例子，看看列表如何保留顺序并保留重复元素，并检查其不可变性：
- en: '[PRE17]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You can define lists using two different building blocks. `Nil` represents
    the tail of the `List` and, afterwards, an empty `List`. So, the preceding example
    can be rewritten as:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用两种不同的构建块来定义列表。`Nil`表示`List`的尾部，之后是一个空的`List`。因此，前面的例子可以重写为：
- en: '[PRE18]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let''s check lists with its method in the following detailed example:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在以下详细示例中检查列表及其方法：
- en: '[PRE19]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You will get the following output:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 您将获得以下输出：
- en: '[PRE20]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now, let's see another quick overview of how to use sets in your Scala application
    in the next subsection.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在下一小节中快速概述如何在Scala应用程序中使用集合。
- en: Sets
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合
- en: 'A set is one of the most widely used collections. In sets order will not be
    preserved and sets don''t allow duplicate elements. You can think of it as the
    mathematical notation of sets. Let''s demonstrate this by an example, and we will
    see how sets don''t preserve ordering and don''t allow duplicates:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 集合是最广泛使用的集合之一。在集合中，顺序不会被保留，集合不允许重复元素。你可以把它看作是集合的数学表示法。让我们通过一个例子来演示一下，我们将看到集合不保留顺序，也不允许重复：
- en: '[PRE21]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The following source code shows the different uses of sets in a Scala program:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 以下源代码显示了在Scala程序中使用集合的不同方法：
- en: '[PRE22]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You will get the following output:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 您将获得以下输出：
- en: '[PRE23]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: From my personal experience while developing Spark applications using Java or
    Scala, I found very frequent uses of tuples, especially for grouping collections
    of elements without using any explicit classes. In the next subsection, we will
    see how to get started with Tuples in Scala.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我个人的经验，在使用Java或Scala开发Spark应用程序时，我发现元组的使用非常频繁，特别是用于分组元素的集合，而不使用任何显式类。在下一小节中，我们将看到如何在Scala中开始使用元组。
- en: Tuples
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 元组
- en: Scala tuples are used to combine a fixed number of items together. The ultimate
    target of this grouping is to help in the anonymous function and so that they
    can be passed around as a whole. The real difference with an array or list is
    that a tuple can hold objects of different types while maintaining the information
    of the type of each element, while a collection doesn't and uses, as the type,
    the common type (for instance, in the previous example, the type of that set would
    be `Set[Any]`).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Scala元组用于将固定数量的项目组合在一起。这种分组的最终目标是帮助匿名函数，以便它们可以作为一个整体传递。与数组或列表的真正区别在于，元组可以容纳不同类型的对象，同时保持每个元素类型的信息，而集合不会，并且使用公共类型作为类型（例如，在前面的例子中，该集合的类型将是`Set[Any]`）。
- en: From the computational point of view, Scala tuples are also immutable. In other
    words, Tuples do use a classes to store elements (for example, `Tuple2`, `Tuple3`,
    `Tuple22`, and so on).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 从计算的角度来看，Scala元组也是不可变的。换句话说，元组使用类来存储元素（例如，`Tuple2`、`Tuple3`、`Tuple22`等）。
- en: 'The following is an example of a tuple holding an integer, a string, and the
    console:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个包含整数、字符串和控制台的元组的示例：
- en: '[PRE24]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Which is syntactic sugar (shortcut) for the following:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这是以下的语法糖（快捷方式）：
- en: '[PRE25]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Another example:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子：
- en: '[PRE26]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'There are no named accessors for you to access the tuple data but instead you
    need to use accessors that are based on the position and are 1-based not 0-based.
    For example:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 您无法使用命名访问器访问元组数据，而是需要使用基于位置的访问器，其基于1而不是0。例如：
- en: '[PRE27]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Moreover, tuples can fit perfectly in pattern matching. For example:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，元组可以完美地适应模式匹配。例如：
- en: '[PRE28]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You can even use the special operator `->` in order to write a compact syntax
    for 2-values tuples. For example:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 您甚至可以使用特殊运算符`->`来编写2值元组的紧凑语法。例如：
- en: '[PRE29]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The following is a more detailed example to demonstrate tuple functionality:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个更详细的示例，以演示元组功能：
- en: '[PRE30]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'You will get the following output:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 您将获得以下输出：
- en: '[PRE31]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Now, let's delve into the world of using maps in Scala, these are widely used
    to hold basic datatypes.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解在Scala中使用地图，这些地图被广泛用于保存基本数据类型。
- en: Maps
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 地图
- en: 'A map is an `Iterable` consisting of pairs of keys and values (also named mappings
    or associations). A map is also one of the most widely used connections as it
    can be used to hold basic datatypes. For example:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 地图是由键和值对（也称为映射或关联）组成的`Iterable`。地图也是最广泛使用的连接之一，因为它可以用于保存基本数据类型。例如：
- en: '[PRE32]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Scala's `Predef` object offers an implicit conversion that lets you write `key
    -> value` as an alternate syntax for the `pair (key, value)`. For instance, `Map("a"
    -> 10, "b" -> 15, "c" -> 16)` means exactly the same as `Map(("a", 10), ("b",
    15), ("c", 16))`, but reads better.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Scala的`Predef`对象提供了一个隐式转换，让您可以将`key -> value`写成`pair (key, value)`的替代语法。例如，`Map("a"
    -> 10, "b" -> 15, "c" -> 16)`的含义与`Map(("a", 10), ("b", 15), ("c", 16))`完全相同，但读起来更好。
- en: 'Moreover, a `Map` can be simply considered a collection of `Tuple2s`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`Map`可以简单地被视为`Tuple2s`的集合：
- en: '[PRE33]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The preceding line will be understood as:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 前一行将被理解为：
- en: '[PRE34]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In the example, we can state that using `Map` a function can be stored, and
    this is the whole point of functions in a Functional Programming language: they
    are first-class citizens and can be used anywhere.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们可以说使用`Map`可以存储一个函数，这就是函数在函数式编程语言中的全部意义：它们是头等公民，可以在任何地方使用。
- en: 'Suppose you have a method for finding the max element in an array as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个用于查找数组中最大元素的方法如下：
- en: '[PRE35]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, let''s map it such that using the `Map` the method can be stored:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们映射它，以便使用`Map`存储该方法：
- en: '[PRE36]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Let''s another of using maps as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看另一个使用映射的例子：
- en: '[PRE37]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The following is a detailed example to demonstrate `Map` functionality:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个详细的示例，演示了`Map`的功能：
- en: '[PRE38]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'You will get the following output:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 您将得到以下输出：
- en: '[PRE39]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Now, let's take a quick overview of using option in Scala; this is basically
    a data container that can hold data.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们快速概述一下在Scala中使用选项；这基本上是一个可以容纳数据的数据容器。
- en: Option
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选项
- en: The `Option` type is used frequently in Scala programs, and you can compare
    this with the null value available in Java, which indicates no value. Scala `Option
    [T]` is a container for zero or one element for a given type. An `Option [T]`
    can be either a `Some [T]` or `None` object, which represents a missing value.
    For instance, the get method of Scala's `Map` produces `Some` (value) if a value
    corresponding to a given key has been found, or `None` if the given key is not
    defined in the `Map`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`Option`类型在Scala程序中经常使用，您可以将其与Java中的空值进行比较，空值表示没有值。Scala的`Option [T]`是给定类型的零个或一个元素的容器。`Option
    [T]`可以是`Some [T]`或`None`对象，它表示缺少值。例如，Scala的`Map`的get方法如果找到与给定键对应的值，则产生`Some`（value），如果给定键在`Map`中未定义，则产生`None`。'
- en: 'The basic trait for an `Option` looks like this:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`Option`的基本特征如下：'
- en: '[PRE40]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'For example, in the following code, we are trying to map and show some meagacities
    that are located in some countries such as `India`, `Bangladesh`, `Japan`, and
    `USA`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在下面的代码中，我们试图映射并显示一些位于一些国家的大城市，如`印度`，`孟加拉国`，`日本`和`美国`：
- en: '[PRE41]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now, to make the preceding code work, we need to have the `show()` method defined
    somewhere. Here, we can do it by Scala pattern matching using `Option` as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了使前面的代码工作，我们需要在某个地方定义`show()`方法。在这里，我们可以使用`Option`通过Scala模式匹配来实现：
- en: '[PRE42]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Combining these as follows should print the accurate and desired result that
    we are expecting:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 将它们组合如下应该打印出我们期望的准确结果：
- en: '[PRE43]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'You will get the following output:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 您将得到以下输出：
- en: '[PRE44]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Using the `getOrElse()` method, it is possible to access a value or a default
    when no value is present. For example:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`getOrElse()`方法，可以在没有值时访问值或默认值。例如：
- en: '[PRE45]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'You will get the following output:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 您将得到以下输出：
- en: '[PRE46]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Moreover, using the `isEmpty()` method, you can check if the option is `None`
    or not. For example:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，使用`isEmpty()`方法，您可以检查选项是否为`None`。例如：
- en: '[PRE47]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now, here''s the complete program:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这是完整的程序：
- en: '[PRE48]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'You will get the following output:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 您将得到以下输出：
- en: '[PRE49]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Let''s take a look at other examples on when to use `Option`. For example,
    the `Map.get()` method uses `Option` in order to tell the user if the element
    that he tries to access exists or not. For example:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看何时使用`Option`的其他示例。例如，`Map.get()`方法使用`Option`来告诉用户他尝试访问的元素是否存在。例如：
- en: '[PRE50]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Now, we will see how to use exists, which is used to check if a predicate holds
    for a subset of a set of elements in the Traversal collection.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将看到如何使用exists，它用于检查遍历集合中一组元素的子集是否满足谓词。
- en: Exists
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Exists
- en: 'Exists checks if a predicate holds for at least one element in the Traversable
    collection. For example:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Exists检查是否至少有一个元素在Traversable集合中满足谓词。例如：
- en: '[PRE51]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '**Using the fat arrow:** `=>` is called the *right arrow*, *fat arrow,* or
    *rocket* and is used for passing parameters by name. That means the expression
    will be evaluated when a parameter is accessed. It is actually syntactic sugar
    for a zero parameter function `call: x: () => Boolean`. Let''s see an example
    using this operator is as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用fat arrow：** `=>`称为*右箭头*、*粗箭头*或*火箭*，用于通过名称传递参数。这意味着当访问参数时，表达式将被评估。它实际上是一个零参数函数`call:
    x: () => Boolean`的语法糖。让我们看一个使用这个操作符的例子如下：'
- en: '`package com.chapter4.CollectionAPI`'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`package com.chapter4.CollectionAPI`'
- en: '`object UsingFatArrow {`'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`object UsingFatArrow {`'
- en: '`def fliesPerSecond(callback: () => Unit) {`'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`def fliesPerSecond(callback: () => Unit) {`'
- en: '`while (true) { callback(); Thread sleep 1000 }`'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`while (true) { callback(); Thread sleep 1000 }`'
- en: '`}`'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`}`'
- en: '`def main(args: Array[String]): Unit= {`'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`def main(args: Array[String]): Unit= {`'
- en: '`fliesPerSecond(() => println("Time and tide wait for none but fly like arrows
    ..."))`'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`fliesPerSecond(() => println("时间和潮汐等待着没有，但飞得像一支箭..."))`'
- en: '`}`'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`}`'
- en: '`}`'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`}`'
- en: 'You will get the following output:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 您将得到以下输出：
- en: '`Time and tide wait for none but flies like an arrow...`'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`时间和潮汐等待着没有，但飞得像一支箭...`'
- en: '`Time and tide wait for none but flies like an arrow...`'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`时间和潮汐等待着没有，但飞得像一支箭...`'
- en: '`Time and tide wait for none but flies like an arrow...`'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`时间和潮汐等待着没有，但飞得像一支箭...`'
- en: '`Time and tide wait for none but flies like an arrow...`'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`时间和潮汐等待着没有，但飞得像一支箭...`'
- en: '`Time and tide wait for none but flies like an arrow...`'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`时间和潮汐等待着没有，但飞得像一支箭...`'
- en: '`Time and tide wait for none but flies like an arrow...`'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`时间和潮汐等待着没有，但飞得像一支箭...`'
- en: 'A detailed example can be seen in the following code as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在以下代码中看到一个详细的示例：
- en: '[PRE52]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'You will get the following output:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 您将得到以下输出：
- en: '[PRE53]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '**Note: Using the infix operator in Scala**:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意：在Scala中使用中缀运算符**：'
- en: 'In the earlier example and in a subsequent section, we used the Scala infix
    notation. Suppose you would like to perform some operation with complex numbers
    and have a case class with an add method for adding two complex numbers:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的例子和后续的部分中，我们使用了Scala的中缀表示法。假设你想对复数执行一些操作，并且有一个带有添加两个复数的方法的案例类：
- en: '[PRE54]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Now in order to access the properties of this class, you need to create an
    object like this:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了访问这个类的属性，你需要创建一个像这样的对象：
- en: '[PRE55]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Moreover, suppose you have the following two complex numbers defined:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，假设你已经定义了以下两个复数：
- en: '[PRE56]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now to access the `plus()` method from the case class, you will do something
    like this:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在要从案例类中访问`plus()`方法，你需要这样做：
- en: '[PRE57]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'This should give you output: `Complex(16.0,29.0)`. However, isn''t it good
    if you just call the method like this:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该给你输出：`Complex(16.0,29.0)`。然而，如果你像这样调用方法会不会更好：
- en: '[PRE58]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'And it really works like a charm. Here is the complete example:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 它确实像魅力一样起作用。以下是完整的示例：
- en: '[PRE59]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '**The precedence of an infix operator**: This is determined by the operator''s
    first character. Characters are listed below in increasing order of precedence,
    with characters on the same line having the same precedence:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '**中缀运算符的优先级**：这由运算符的第一个字符决定。字符按优先级递增的顺序列在下面，同一行上的字符具有相同的优先级：'
- en: '[PRE60]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '**General warning**: Using the infix notation for calling regular, non-symbolic
    methods is discouraged and should be used only if it significantly increases readability.
    One example of a sufficiently motivated use of infix notation is matchers and
    other parts of the tests definition in `ScalaTest`.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '**一般警告**：不鼓励使用中缀表示法来调用常规的非符号方法，只有在它显著提高可读性时才应该使用。中缀表示法的一个充分动机的例子是`ScalaTest`中的匹配器和测试定义的其他部分。'
- en: Another interesting element in the Scala collection package is using `forall`.
    It is used to check if a predicate holds for each element in a `Traversable` collection.
    In the next subsection, we will see an example of it.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: Scala集合包中的另一个有趣的元素是使用`forall`。它用于检查谓词是否对`Traversable`集合中的每个元素成立。在下一小节中，我们将看到一个例子。
- en: Forall
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Forall
- en: 'Forall checks if a predicate holds for each element in a `Traversable` collection.
    It can be defined formally as follows:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: Forall检查谓词是否对`Traversable`集合中的每个元素成立。可以正式定义如下：
- en: '[PRE61]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Let''s see an example as follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子如下：
- en: '[PRE62]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: While writing Scala code for preprocessing especially, we often need to filter
    selected data objects. The filter feature of the Scala collection API is used
    for that. In the next sub-section, we will see an example of using filter.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写Scala代码进行预处理时，我们经常需要过滤选定的数据对象。Scala集合API的过滤功能用于此目的。在下一小节中，我们将看到使用过滤的例子。
- en: Filter
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Filter
- en: '`filter` selects all the elements that satisfy a specific predicate. It can
    be defined formally as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter`选择所有满足特定谓词的元素。可以正式定义如下：'
- en: '[PRE63]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Let''s see an example as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子如下：
- en: '[PRE64]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: A map is used to build a new collection or set of elements by traversing a function
    to all elements of the collection. In the next subsection, we will see an example
    of using `Map`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: Map用于通过对集合的所有元素应用函数来构建新的集合或元素集。在下一小节中，我们将看到使用`Map`的例子。
- en: Map
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Map
- en: 'Map is used to build a new collection or set of elements by traversing a function
    to all elements of the collection. It can be defined formally as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: Map用于通过对集合的所有元素应用函数来构建新的集合或元素集。可以正式定义如下：
- en: '[PRE65]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Let''s see an example as follows:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子如下：
- en: '[PRE66]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: While using the collection API in Scala, you often need to select the n^(th)
    elements of the list or array for example. In the next sub-section, we will explore
    examples of using take.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Scala的集合API时，你经常需要选择列表或数组的第n个元素。在下一小节中，我们将探讨使用take的例子。
- en: Take
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Take
- en: 'Take is used to take the first n elements of a collection. The formal definition
    of using `take` is as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Take用于获取集合的前n个元素。使用`take`的正式定义如下：
- en: '[PRE67]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Let''s see an example as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子如下：
- en: '[PRE68]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'You will get the following output:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到以下输出：
- en: '[PRE69]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: In Scala, if want to partition specific collections into a map of an other `Traversable`
    collection according to a specific partitioning function, you can use the `groupBy()`
    method. In the next subsection, we will show some examples of using `groupBy()`.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在Scala中，如果想要根据特定的分区函数将特定的集合分成另一个`Traversable`集合的映射，可以使用`groupBy()`方法。在下一小节中，我们将展示使用`groupBy()`的一些例子。
- en: GroupBy
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GroupBy
- en: 'GroupBy is used to partition specific collections into a map of other Traversable
    collections according to a specific partitioning function. It can be defined formally
    as follows:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: GroupBy用于根据特定的分区函数将特定的集合分成其他`Traversable`集合的映射。可以正式定义如下：
- en: '[PRE70]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Let''s see an example as follows:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子如下：
- en: '[PRE71]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: In Scala, if you want to select all the elements in a Traversable collection
    but the last one, you can use `init`. In the next subsection, we will see examples
    of it.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在Scala中，如果你想选择`Traversable`集合中除了最后一个元素之外的所有元素，可以使用`init`。在下一小节中，我们将看到它的例子。
- en: Init
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Init
- en: '`init` selects all the elements in a `Traversable` collection but the last
    one. It can be defined formally as follows:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`init`选择`Traversable`集合中除了最后一个元素之外的所有元素。可以正式定义如下：'
- en: '[PRE72]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Let''s see an example as follows:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子如下：
- en: '[PRE73]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: In Scala, if you want to select all elements except the first n elements, you
    should use drop. In the next subsection, we will see how to use drop.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在Scala中，如果你想选择除了前n个元素之外的所有元素，你应该使用drop。在下一小节中，我们将看到如何使用drop。
- en: Drop
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Drop
- en: '`drop` is used to select all elements except the first n elements. It can be
    defined formally as follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`drop`用于选择除了前n个元素之外的所有元素。可以正式定义如下：'
- en: '[PRE74]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Let''s see an example as follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子如下：
- en: '[PRE75]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: In Scala, if you want take a set of elements until a predicate is satisfied,
    you should use `takeWhile`. In the next subsection, we will see how to use `takeWhile`.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在Scala中，如果你想要在满足谓词的情况下获取一组元素，你应该使用`takeWhile`。在下一小节中，我们将看到如何使用`takeWhile`。
- en: TakeWhile
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TakeWhile
- en: 'TakeWhile is used to take a set of elements until a predicate is satisfied.
    It can be defined formally as follows:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: TakeWhile用于获取一组元素，直到满足谓词。可以正式定义如下：
- en: '[PRE76]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Let''s see an example as follows:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子如下：
- en: '[PRE77]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'You will get the following output:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 您将得到以下输出：
- en: '[PRE78]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: In Scala, if you want to omit a set of elements till a predicate is satisfied,
    you should use `dropWhile`. We will see some examples of this in the next subsection.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在Scala中，如果您想要省略一组元素，直到满足谓词，您应该使用`dropWhile`。我们将在下一小节中看到一些此类示例。
- en: DropWhile
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DropWhile
- en: '`dropWhile` is used to omit a set of elements till a predicate is satisfied.
    It can be defined formally as follows:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`dropWhile`用于省略一组元素，直到满足谓词。可以正式定义如下：'
- en: '[PRE79]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Let''s see an example as follows:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子如下：
- en: '[PRE80]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: In Scala, if you want to use your **User Defined Functions** (**UDF**) such
    that it takes a function as an argument in the nested list and combines the output
    back together, `flatMap()` is a perfect candidate. We will see examples of using
    `flatMap()` in the next section.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在Scala中，如果您想要使用您的**用户定义函数**（**UDF**），使其接受嵌套列表中的函数作为参数，并将输出组合在一起，`flatMap()`是一个完美的选择。我们将在下一节中看到使用`flatMap()`的例子。
- en: FlatMap
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FlatMap
- en: 'FltatMap takes a function as an argument. The function given to `flatMap()`
    doesn''t work on nested lists but it produces a new collection. It can be defined
    formally as follows:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: FltatMap接受一个函数作为参数。给定给`flatMap()`的函数不适用于嵌套列表，但它会产生一个新的集合。可以正式定义如下：
- en: '[PRE81]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Let''s see an example as follows:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子如下：
- en: '[PRE82]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: We have just about finished covering the uses of Scala collection features.
    Also note that methods such as `Fold()`, `Reduce()`, `Aggregate()`, `Collect()`,
    `Count()`, `Find()`, and `Zip()` can be used to pass from one collection to another
    (for example, `toVector`, `toSeq`, `toSet`, `toArray`). However, we will see such
    examples in upcoming chapters. For the time being, it's time to see some performance
    characteristics of different Scala collection APIs.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎已经完成了对Scala集合功能的使用。还要注意，诸如`Fold()`、`Reduce()`、`Aggregate()`、`Collect()`、`Count()`、`Find()`和`Zip()`等方法可以用于从一个集合传递到另一个集合（例如，`toVector`、`toSeq`、`toSet`、`toArray`）。但是，我们将在即将到来的章节中看到这样的例子。目前，是时候看一下不同Scala集合API的性能特征了。
- en: Performance characteristics
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能特征
- en: In Scala, different collections have different performance characteristics and
    these performance characteristics are the reason you will prefer to choose one
    collection over the others. In this section, we will judge the performance characteristics
    of Scala collection objects from the operational and memory usage point of view.
    At the end of this section, we will provide some guidelines for selecting appropriate
    collection objects for your code and problem types.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在Scala中，不同的集合具有不同的性能特征，这些性能特征是您选择一个集合而不是其他集合的原因。在本节中，我们将从操作和内存使用的角度评估Scala集合对象的性能特征。在本节结束时，我们将为您的代码和问题类型选择适当的集合对象提供一些指导方针。
- en: Performance characteristics of collection objects
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 序列类型（不可变）的性能特征
- en: The following are the performance characteristics Scala Collections, based on
    the official documentation of Scala.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是Scala集合的性能特征，基于Scala的官方文档。
- en: '**Const**: The operation takes only constant time.'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**常数**：该操作只需要常数时间。'
- en: '**eConst**: The operation takes effectively constant time, but this might depend
    on some assumptions such as the maximum length of a vector or the distribution
    of hash keys.'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**eConst**：该操作实际上需要常数时间，但这可能取决于一些假设，例如向量的最大长度或哈希键的分布。'
- en: '**Linear**: The operation grows linearly with the collection size.'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**线性**：该操作随着集合大小线性增长。'
- en: '**Log**: The operation grows logarithmically with the collection size.'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**日志**：该操作随着集合大小对数增长。'
- en: '**aConst**: The operation takes the amortized constant time. Some invocations
    of the operation might take longer, but if many operations are performed on average
    only constant time per operation is taken.'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**aConst**：该操作需要摊销常数时间。该操作的一些调用可能需要更长时间，但如果平均执行许多操作，每个操作只需要常数时间。'
- en: '**NA**: Operation is not supported.'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NA**：不支持该操作。'
- en: Performance characteristics of sequence types (immutable) are presented in the
    following table.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变序列类型的性能特征在下表中呈现。
- en: '| **Immutable CO*** | **Head** | **Tail** | **Apply** | **Update** | **Prepend**
    | **Append** | **Insert** |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '| **不可变CO*** | **头** | **尾** | **应用** | **更新** | **前置** | **附加** | **插入** |'
- en: '| List | Const | Const | Linear | Linear | Const | Linear | NA |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '| 列表 | 常数 | 常数 | 线性 | 线性 | 常数 | 线性 | NA |'
- en: '| Stream | Const | Const | Linear | Linear | Const | Linear | NA |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '| 流 | 常数 | 常数 | 线性 | 线性 | 常数 | 线性 | NA |'
- en: '| Vector | eConst | eConst | eConst | eConst | eConst | eConst | NA |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '| 向量 | eConst | eConst | eConst | eConst | eConst | eConst | NA |'
- en: '| Stack | Const | Const | Linear | Linear | Const | Linear | Linear |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '| 栈 | 常数 | 常数 | 线性 | 线性 | 常数 | 线性 | 线性 |'
- en: '| Queue | aConst | aConst | Linear | Linear | Const | Const | NA |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '| 队列 | aConst | aConst | 线性 | 线性 | 常数 | 常数 | NA |'
- en: '| Range | Const | Const | Const | NA | NA | NA | NA |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '| 范围 | 常数 | 常数 | 常数 | NA | NA | NA | NA |'
- en: '| String | Const | Linear | Const | Linear | Linear | Linear | NA |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '| 字符串 | 常数 | 线性 | 常数 | 线性 | 线性 | 线性 | NA |'
- en: '**Table 1:** Performance characteristics of sequence types (immutable) [*CO==
    Collection Object]'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '**表1：**序列类型（不可变）的性能特征[*CO==集合对象]'
- en: 'The following table shows the meaning of the operations described in **Table
    1** and **Table 3** here:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了在**表1**和**表3**中描述的操作的含义：
- en: '| **Head** | Is used to select the first few elements of an existing sequence.
    |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '| **头** | 用于选择现有序列的前几个元素。 |'
- en: '| **Tail** | Is used to select all elements except the first one and returns
    a new sequence. |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '| **尾** | 用于选择除第一个元素之外的所有元素，并返回一个新序列。 |'
- en: '| **Apply** | Is used for indexing purposes. |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '| **应用** | 用于索引目的。 |'
- en: '| **Update** | It is used as the functional update for immutable sequences.
    For the mutable sequence, it is a side-effecting update (with update for mutable
    sequences). |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '| **更新** | 用作不可变序列的函数更新。对于可变序列，它是一个具有副作用的更新（对于可变序列的更新）。'
- en: '| **Prepend** | It is used to add an element to the front of an existing sequence.
    A new sequence is produced for immutable sequences. For the mutable sequence,
    the existing one is modified. |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '| **前置** | 用于在现有序列的前面添加元素。对于不可变序列，会生成一个新序列。对于可变序列，会修改现有序列。 |'
- en: '| **Append** | It is used to add an element at the end of an existing sequence.
    A new sequence is produced for immutable sequences. For a mutable sequence, the
    existing one is modified. |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
  zh: '| **追加** | 用于在现有序列的末尾添加元素。对于不可变序列，会生成一个新序列。对于可变序列，会修改现有序列。 |'
- en: '| **Insert** | It is used to insert an element at an arbitrary position in
    an existing sequence. This can be done however directly for mutable sequences.
    |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
  zh: '| **插入** | 用于在现有序列的任意位置插入元素。对于可变序列，可以直接进行操作。 |'
- en: '**Table 2:** The meaning of the operation described in table 1'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '**表2：**表1中描述的操作的含义'
- en: 'Performance characteristics of sequence types (mutable) are shown in **Table
    3** as follows:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 序列类型（可变）的性能特征如**表3**所示：
- en: '| **Mutable CO*** | **Head** | **Tail** | **Apply** | **update** | **Prepend**
    | **Append** | **Insert** |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
  zh: '| **可变CO*** | **头** | **尾** | **应用** | **更新** | **前置** | **追加** | **插入** |'
- en: '| ArrayBuffer | Const | Linear | Const | Const | Linear | aConst | Linear |'
  id: totrans-297
  prefs: []
  type: TYPE_TB
  zh: '| ArrayBuffer | 常数 | 线性 | 常数 | 常数 | 线性 | 常数 | 线性 |'
- en: '| ListBuffer | Const | Linear | Linear | Linear | Const | Const | Linear |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
  zh: '| ListBuffer | 常数 | 线性 | 线性 | 线性 | 常数 | 常数 | 线性 |'
- en: '| StringBuilder | Const | Linear | Const | Const | Linear | aCconst | Linear
    |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
  zh: '| StringBuilder | 常数 | 线性 | 常数 | 常数 | 线性 | 常数 | 线性 |'
- en: '| MutableList | Const | Linear | Linear | Linear | Const | Const | Linear |'
  id: totrans-300
  prefs: []
  type: TYPE_TB
  zh: '| MutableList | 常数 | 线性 | 线性 | 线性 | 常数 | 常数 | 线性 |'
- en: '| Queue | Const | Linear | Linear | Linear | Const | Const | Linear |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
  zh: '| Queue | 常数 | 线性 | 线性 | 线性 | 常数 | 常数 | 线性 |'
- en: '| ArraySeq | Const | Linear | Const | Const | NA | NA | NA |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
  zh: '| ArraySeq | 常数 | 线性 | 常数 | 常数 | NA | NA | NA |'
- en: '| Stack | Const | Linear | Linear | Linear | Const | Linear | Linear |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
  zh: '| 栈 | 常数 | 线性 | 线性 | 线性 | 常数 | 线性 | 线性 |'
- en: '| ArrayStack | Const | Linear | Const | Const | aConst | Linear | Linear |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
  zh: '| ArrayStack | 常数 | 线性 | 常数 | 常数 | 常数 | 线性 | 线性 |'
- en: '| Array | Const | Linear | Const | Const | NA | NA | NA |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '| Array | 常数 | 线性 | 常数 | 常数 | NA | NA | NA |'
- en: '**Table 3:** Performance characteristics of sequence types (mutable) [*CO==
    Collection Object]'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '**表3：**序列类型（可变）的性能特征[*CO==集合对象]'
- en: For more information about mutable collections and other types of collections,
    you can refer to this link ([http://docs.scala-lang.org/overviews/collections/performance-characteristics.html](http://docs.scala-lang.org/overviews/collections/performance-characteristics.html)).
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '有关可变集合和其他类型的集合的更多信息，您可以参考此链接（[http://docs.scala-lang.org/overviews/collections/performance-characteristics.html](http://docs.scala-lang.org/overviews/collections/performance-characteristics.html)）。 '
- en: 'Performance characteristics of set and map types are shown in the following
    table:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 集合和映射类型的性能特征如下表所示：
- en: '| **Collection types** | **Lookup** | **Add** | **Remove** | **Min** |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '| **集合类型** | **查找** | **添加** | **移除** | **最小** |'
- en: '| **immutable** | - | - | - | - |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '| **不可变** | - | - | - | - |'
- en: '| HashSet/HashMap | eConst | eConst | eConst | Linear |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '| HashSet/HashMap | 常数 | 常数 | 常数 | 线性 |'
- en: '| TreeSet/TreeMap | Log | Log | Log | Log |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '| TreeSet/TreeMap | 对数 | 对数 | 对数 | 对数 |'
- en: '| BitSet | Const | Linear | Linear | eConst* |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '| BitSet | 常数 | 线性 | 线性 | 常数* |'
- en: '| ListMap | Linear | Linear | Linear | Linear |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '| ListMap | 线性 | 线性 | 线性 | 线性 |'
- en: '| **Collection types** | **Lookup** | **Add** | **Remove** | **Min** |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
  zh: '| **集合类型** | **查找** | **添加** | **移除** | **最小** |'
- en: '| **mutable** | - | - | - | - |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
  zh: '| **可变** | - | - | - | - |'
- en: '| HashSet/HashMap | eConst | eConst | eConst | Linear |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
  zh: '| HashSet/HashMap | 常数 | 常数 | 常数 | 线性 |'
- en: '| WeakHashMap | eConst | eConst | eConst | Linear |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
  zh: '| WeakHashMap | 常数 | 常数 | 常数 | 线性 |'
- en: '| BitSet | Const | aConst | Const | eConst* |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
  zh: '| BitSet | 常数 | 常数 | 常数 | 线性 |'
- en: '| TreeSet | Log | Log | Log | Log |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
  zh: '| TreeSet | 对数 | 对数 | 对数 | 对数 |'
- en: '**Table 4:** Performance characteristics of set and map types [ * applicable
    only if bits are densely packed]'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '**表4：**集合和映射类型的性能特征[*仅当位密集打包时适用]'
- en: 'The following table shows the meaning of each operation described in **Table
    4**:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了表4中描述的每个操作的含义：
- en: '| **Operation** | **Meaning** |'
  id: totrans-323
  prefs: []
  type: TYPE_TB
  zh: '| **操作** | **含义** |'
- en: '| **Lookup** | Is used to test whether an element is contained in a set. Secondly,
    it is also used to select a value associated with a particular key. |'
  id: totrans-324
  prefs: []
  type: TYPE_TB
  zh: '| **查找** | 用于测试元素是否包含在集合中。其次，也用于选择与特定键关联的值。 |'
- en: '| **Add** | It is used to add a new element to a set. Secondly, it is also
    used to add a new key/value pair to a map. |'
  id: totrans-325
  prefs: []
  type: TYPE_TB
  zh: '| **添加** | 用于向集合添加新元素。其次，也用于向映射添加新的键/值对。 |'
- en: '| **Remove** | It is used to remove an element from a set or a key from a map.
    |'
  id: totrans-326
  prefs: []
  type: TYPE_TB
  zh: '| **移除** | 用于从集合中移除元素或从映射中移除键。 |'
- en: '| **Min** | It is used to select the smallest element of the set or the smallest
    key of a map. |'
  id: totrans-327
  prefs: []
  type: TYPE_TB
  zh: '| **最小** | 用于选择集合中最小的元素或映射中最小的键。 |'
- en: '**Table 5:** The meaning of each operation described in Table 4'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '**表5：**表4中描述的每个操作的含义'
- en: One of the basic performance metrics is the memory usage by a particular collection
    object. In the next section, we will provide some guidelines about how to measure
    these metrics based on memory usage.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 基本性能指标之一是特定集合对象的内存使用情况。在下一节中，我们将提供一些关于如何基于内存使用情况来衡量这些指标的指导方针。
- en: Memory usage by collection objects
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合对象的内存使用情况
- en: 'Sometimes, there are several benchmarking questions arrived for example: A
    `Lists` faster than `Vectors` for what you''re doing or are `Vectors` faster than
    `Lists`? How much memory can you save using unboxed Arrays to store primitives?
    When you do performance tricks such as pre-allocating arrays or using a `while`
    loop instead of a `foreach` call, how much does it really matter? `var l: List`
    or val `b: mutable.Buffer`? Memory usage can be estimated using different Scala
    benchmark codes, for example, refer to [https://github.com/lihaoyi/scala-bench](https://github.com/lihaoyi/scala-bench).'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '有时，会有一些基准测试问题，例如：`List`比`Vector`更适合你正在做的事情，还是`Vector`比`List`更快？使用非包装的数组来存储原始数据可以节省多少内存？当您执行性能技巧时，例如预先分配数组或使用`while`循环而不是`foreach`调用，这到底有多重要？`var
    l: List`还是`val b: mutable.Buffer`？可以使用不同的Scala基准测试代码来估算内存使用情况，例如，请参阅[https://github.com/lihaoyi/scala-bench](https://github.com/lihaoyi/scala-bench)。'
- en: 'Table 6 here shows the estimated size (bytes) of the various immutable collections
    of 0-elements, 1- element, 4- elements, and powers of four all the way up to 1,048,576
    elements. Although mostse are deterministic, these might be changed depending
    on your platform:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 表6在这里显示了各种不可变集合的估计大小（字节），从0个元素，1个元素，4个元素和4的幂一直到1,048,576个元素。尽管大多数是确定性的，但这些可能会根据您的平台而改变：
- en: '| **Size** | **0** | **1** | **4** | **16** | **64** | **256** | **1,024**
    | **4,069** | **16,192** | **65,536** | **262,144** | **1,048,576** |'
  id: totrans-333
  prefs: []
  type: TYPE_TB
  zh: '| **大小** | **0** | **1** | **4** | **16** | **64** | **256** | **1,024** |
    **4,069** | **16,192** | **65,536** | **262,144** | **1,048,576** |'
- en: '|  |  |  |  |  |  |  |  |  |  |  |  |  |'
  id: totrans-334
  prefs: []
  type: TYPE_TB
  zh: '|  |  |  |  |  |  |  |  |  |  |  |  |  |'
- en: '| Vector | 56 | 216 | 264 | 456 | 1,512 | 5,448 | 21,192 | 84,312 | 334,440
    | 1,353,192 | 5,412,168 | 21,648,072 |'
  id: totrans-335
  prefs: []
  type: TYPE_TB
  zh: '| 向量 | 56 | 216 | 264 | 456 | 1,512 | 5,448 | 21,192 | 84,312 | 334,440 | 1,353,192
    | 5,412,168 | 21,648,072 |'
- en: '| Array[Object] | 16 | 40 | 96 | 336 | 1,296 | 5,136 | 20,496 | 81,400 | 323,856
    | 1,310,736 | 5,242,896 | 20,971,536 |'
  id: totrans-336
  prefs: []
  type: TYPE_TB
  zh: '| 数组[对象] | 16 | 40 | 96 | 336 | 1,296 | 5,136 | 20,496 | 81,400 | 323,856 |
    1,310,736 | 5,242,896 | 20,971,536 |'
- en: '| List | 16 | 56 | 176 | 656 | 2,576 | 10,256 | 40,976 | 162,776 | 647,696
    | 2,621,456 | 10,485,776 | 41,943,056 |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
  zh: '| 列表 | 16 | 56 | 176 | 656 | 2,576 | 10,256 | 40,976 | 162,776 | 647,696 |
    2,621,456 | 10,485,776 | 41,943,056 |'
- en: '| Stream (unforced) | 16 | 160 | 160 | 160 | 160 | 160 | 160 | 160 | 160 |
    160 | 160 | 160 |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
  zh: '| 流（未强制） | 16 | 160 | 160 | 160 | 160 | 160 | 160 | 160 | 160 | 160 | 160 |
    160 |'
- en: '| Stream (forced) | 16 | 56 | 176 | 656 | 2,576 | 10,256 | 40,976 | 162,776
    | 647,696 | 2,621,456 | 10,485,776 | 41,943,056 |'
  id: totrans-339
  prefs: []
  type: TYPE_TB
  zh: '| 流（强制） | 16 | 56 | 176 | 656 | 2,576 | 10,256 | 40,976 | 162,776 | 647,696
    | 2,621,456 | 10,485,776 | 41,943,056 |'
- en: '| Set | 16 | 32 | 96 | 880 | 3,720 | 14,248 | 59,288 | 234,648 | 895,000 |
    3,904,144 | 14,361,000 | 60,858,616 |'
  id: totrans-340
  prefs: []
  type: TYPE_TB
  zh: '| 集合 | 16 | 32 | 96 | 880 | 3,720 | 14,248 | 59,288 | 234,648 | 895,000 | 3,904,144
    | 14,361,000 | 60,858,616 |'
- en: '| Map | 16 | 56 | 176 | 1,648 | 6,800 | 26,208 | 109,112 | 428,592 | 1,674,568
    | 7,055,272 | 26,947,840 | 111,209,368 |'
  id: totrans-341
  prefs: []
  type: TYPE_TB
  zh: '| 地图 | 16 | 56 | 176 | 1,648 | 6,800 | 26,208 | 109,112 | 428,592 | 1,674,568
    | 7,055,272 | 26,947,840 | 111,209,368 |'
- en: '| SortedSet | 40 | 104 | 248 | 824 | 3,128 | 12,344 | 49,208 | 195,368 | 777,272
    | 3,145,784 | 12,582,968 | 50,331,704 |'
  id: totrans-342
  prefs: []
  type: TYPE_TB
  zh: '| 排序集 | 40 | 104 | 248 | 824 | 3,128 | 12,344 | 49,208 | 195,368 | 777,272
    | 3,145,784 | 12,582,968 | 50,331,704 |'
- en: '| Queue | 40 | 80 | 200 | 680 | 2,600 | 10,280 | 41,000 | 162,800 | 647,720
    | 2,621,480 | 10,485,800 | 41,943,080 |'
  id: totrans-343
  prefs: []
  type: TYPE_TB
  zh: '| 队列 | 40 | 80 | 200 | 680 | 2,600 | 10,280 | 41,000 | 162,800 | 647,720 |
    2,621,480 | 10,485,800 | 41,943,080 |'
- en: '| String | 40 | 48 | 48 | 72 | 168 | 552 | 2,088 | 8,184 | 32,424 | 131,112
    | 524,328 | 2,097,192 |'
  id: totrans-344
  prefs: []
  type: TYPE_TB
  zh: '| 字符串 | 40 | 48 | 48 | 72 | 168 | 552 | 2,088 | 8,184 | 32,424 | 131,112 |
    524,328 | 2,097,192 |'
- en: '**Table 6:** The estimated size (bytes) of the various collections'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '**表6：**各种集合的估计大小（字节）'
- en: 'The following table shows the estimated size (bytes) of the array used in Scala
    with 0-elements, 1- element, 4- elements, and powers of four all the way up to
    1,048,576 elements. Although mostse are deterministic, these might change depending
    on your platform:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 下表显示了在Scala中使用的数组的估计大小（字节），其中包括0个元素，1个元素，4个元素和4的幂一直到1,048,576个元素。尽管大多数是确定性的，但这些可能会根据您的平台而改变：
- en: '| **Size** | **0** | **1** | **4** | **16** | **64** | **256** | **1,024**
    | **4,069** | **16,192** | **65,536** | **262,144** | **1,048,576** |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
  zh: '| **大小** | **0** | **1** | **4** | **16** | **64** | **256** | **1,024** |
    **4,069** | **16,192** | **65,536** | **262,144** | **1,048,576** |'
- en: '|  |  |  |  |  |  |  |  |  |  |  |  |  |'
  id: totrans-348
  prefs: []
  type: TYPE_TB
  zh: '|  |  |  |  |  |  |  |  |  |  |  |  |  |'
- en: '| Array[Object] | 16 | 40 | 96 | 336 | 1,296 | 5,136 | 20,496 | 81,400 | 323,856
    | 1,310,736 | 5,242,896 | 20,971,536 |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
  zh: '| 数组[对象] | 16 | 40 | 96 | 336 | 1,296 | 5,136 | 20,496 | 81,400 | 323,856 |
    1,310,736 | 5,242,896 | 20,971,536 |'
- en: '|  |  |  |  |  |  |  |  |  |  |  |  |  |'
  id: totrans-350
  prefs: []
  type: TYPE_TB
  zh: '|  |  |  |  |  |  |  |  |  |  |  |  |  |'
- en: '| **Size** | **0** | **1** | **4** | **16** | **64** | **256** | **1,024**
    | **4,069** | **16,192** | **65,536** | **262,144** | **1,048,576** |'
  id: totrans-351
  prefs: []
  type: TYPE_TB
  zh: '| **大小** | **0** | **1** | **4** | **16** | **64** | **256** | **1,024** |
    **4,069** | **16,192** | **65,536** | **262,144** | **1,048,576** |'
- en: '|  |  |  |  |  |  |  |  |  |  |  |  |  |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
  zh: '|  |  |  |  |  |  |  |  |  |  |  |  |  |'
- en: '| Array[Boolean] | 16 | 24 | 24 | 32 | 80 | 272 | 1,040 | 4,088 | 16,208 |
    65,552 | 262,160 | 1,048,592 |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
  zh: '| 数组[Boolean] | 16 | 24 | 24 | 32 | 80 | 272 | 1,040 | 4,088 | 16,208 | 65,552
    | 262,160 | 1,048,592 |'
- en: '| Array[Byte] | 16 | 24 | 24 | 32 | 80 | 272 | 1,040 | 4,088 | 16,208 | 65,552
    | 262,160 | 1,048,592 |'
  id: totrans-354
  prefs: []
  type: TYPE_TB
  zh: '| 数组[字节] | 16 | 24 | 24 | 32 | 80 | 272 | 1,040 | 4,088 | 16,208 | 65,552 |
    262,160 | 1,048,592 |'
- en: '| Array[Short] | 16 | 24 | 24 | 48 | 144 | 528 | 2,064 | 8,160 | 32,400 | 131,088
    | 524,304 | 2,097,168 |'
  id: totrans-355
  prefs: []
  type: TYPE_TB
  zh: '| 数组[短] | 16 | 24 | 24 | 48 | 144 | 528 | 2,064 | 8,160 | 32,400 | 131,088
    | 524,304 | 2,097,168 |'
- en: '| Array[Int] | 16 | 24 | 32 | 80 | 272 | 1,040 | 4,112 | 16,296 | 64,784 |
    262,160 | 1,048,592 | 4,194,320 |'
  id: totrans-356
  prefs: []
  type: TYPE_TB
  zh: '| 数组[整数] | 16 | 24 | 32 | 80 | 272 | 1,040 | 4,112 | 16,296 | 64,784 | 262,160
    | 1,048,592 | 4,194,320 |'
- en: '| Array[Long] | 16 | 24 | 48 | 144 | 528 | 2,064 | 8,208 | 32,568 | 129,552
    | 524,304 | 2,097,168 | 8,388,624 |'
  id: totrans-357
  prefs: []
  type: TYPE_TB
  zh: '| 数组[长] | 16 | 24 | 48 | 144 | 528 | 2,064 | 8,208 | 32,568 | 129,552 | 524,304
    | 2,097,168 | 8,388,624 |'
- en: '| Boxed Array[Boolean] | 16 | 40 | 64 | 112 | 304 | 1,072 | 4,144 | 16,328
    | 64,816 | 262,192 | 1,048,624 | 4,194,352 |'
  id: totrans-358
  prefs: []
  type: TYPE_TB
  zh: '| 包装数组[Boolean] | 16 | 40 | 64 | 112 | 304 | 1,072 | 4,144 | 16,328 | 64,816
    | 262,192 | 1,048,624 | 4,194,352 |'
- en: '| Boxed Array[Byte] | 16 | 40 | 96 | 336 | 1,296 | 5,136 | 8,208 | 20,392 |
    68,880 | 266,256 | 1,052,688 | 4,198,416 |'
  id: totrans-359
  prefs: []
  type: TYPE_TB
  zh: '| 包装数组[字节] | 16 | 40 | 96 | 336 | 1,296 | 5,136 | 8,208 | 20,392 | 68,880 |
    266,256 | 1,052,688 | 4,198,416 |'
- en: '| Boxed Array[Short] | 16 | 40 | 96 | 336 | 1,296 | 5,136 | 20,496 | 81,400
    | 323,856 | 1,310,736 | 5,230,608 | 20,910,096 |'
  id: totrans-360
  prefs: []
  type: TYPE_TB
  zh: '| 包装数组[短] | 16 | 40 | 96 | 336 | 1,296 | 5,136 | 20,496 | 81,400 | 323,856
    | 1,310,736 | 5,230,608 | 20,910,096 |'
- en: '| Boxed Array[Int] | 16 | 40 | 96 | 336 | 1,296 | 5,136 | 20,496 | 81,400 |
    323,856 | 1,310,736 | 5,242,896 | 20,971,536 |'
  id: totrans-361
  prefs: []
  type: TYPE_TB
  zh: '| 包装的Array[Int] | 16 | 40 | 96 | 336 | 1,296 | 5,136 | 20,496 | 81,400 | 323,856
    | 1,310,736 | 5,242,896 | 20,971,536 |'
- en: '| Boxed Array[Long] | 16 | 48 | 128 | 464 | 1,808 | 7,184 | 28,688 | 113,952
    | 453,392 | 1,835,024 | 7,340,048 | 29,360,144 |'
  id: totrans-362
  prefs: []
  type: TYPE_TB
  zh: '| 包装的Array[Long] | 16 | 48 | 128 | 464 | 1,808 | 7,184 | 28,688 | 113,952 |
    453,392 | 1,835,024 | 7,340,048 | 29,360,144 |'
- en: '**Table 7**: The estimated size (bytes) of the arrays in Scala'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '**表7**：Scala数组的估计大小（字节）'
- en: 'However, this book does not set out to distinguish them in a broad way and
    hence we will omit any discussion on these topics. Refer to the following information
    box for further guidelines on these:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，本书并不打算在广泛的范围内对它们进行区分，因此我们将省略对这些主题的讨论。有关这些主题的进一步指南，请参考以下信息框：
- en: For very detailed benchmarking for Scala Collections with timed code, refer
    to this link on GitHub ([https://github.com/lihaoyi/scala-bench/tree/master/bench/src/main/scala/bench](https://github.com/lihaoyi/scala-bench/tree/master/bench/src/main/scala/bench)).
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Scala集合的详细基准测试，请参阅GitHub上的此链接（[https://github.com/lihaoyi/scala-bench/tree/master/bench/src/main/scala/bench](https://github.com/lihaoyi/scala-bench/tree/master/bench/src/main/scala/bench)）。
- en: As we mentioned in [Chapter 1](part0022.html#KVCC1-21aec46d8593429cacea59dbdcd64e1c),
    *Introduction to Scala*, Scala has a very rich Collection API. The same applies
    for Java but there are lots of differences between the two Collection APIs. In
    the next section, we will see some examples on Java interoperability.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第1章](part0022.html#KVCC1-21aec46d8593429cacea59dbdcd64e1c)中提到的，*Scala简介*，Scala拥有非常丰富的集合API。Java也是如此，但是两种集合API之间存在许多差异。在下一节中，我们将看到一些关于Java互操作性的示例。
- en: Java interoperability
  id: totrans-367
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java互操作性
- en: As we mentioned earlier, Scala has very rich collection API. The same applies
    for Java but there are lots of differences between the two collection APIs. For
    example, both APIs have iterable, iterators, maps, sets, and sequences. But Scala
    has advantages; it pays more attention to immutable collections and provides more
    operations for you in order to produce another collection. Sometimes, you want
    to use or access Java collections or vice versa.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，Scala拥有非常丰富的集合API。Java也是如此，但是两种集合API之间存在许多差异。例如，两种API都有iterable、iterators、maps、sets和sequences。但是Scala有优势；它更加关注不可变集合，并提供更多的操作，以便生成另一个集合。有时，您希望使用或访问Java集合，反之亦然。
- en: '`JavaConversions` is no longer a sound choice. `JavaConverters` makes the conversion
    between Scala and Java collection explicit and you''ll be much less likely to
    experience implicit conversions you didn''t intend to use.'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '`JavaConversions`不再是一个明智的选择。`JavaConverters`使得Scala和Java集合之间的转换变得明确，您不太可能遇到意外使用的隐式转换。'
- en: 'As a matter of fact, it''s quite trivial to do so because Scala offers in an
    implicit way to convert between both APIs in the `JavaConversion` object. So,
    you might find bidirectional conversions for the following types:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，这样做相当简单，因为Scala以一种隐式的方式在`JavaConversion`对象中提供了在两种API之间进行转换的功能。因此，您可能会发现以下类型的双向转换：
- en: '[PRE83]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'In order to be able to use these kinds of conversion, you need to import them
    from the `JavaConversions` object. For example:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够使用这种转换，您需要从`JavaConversions`对象中导入它们。例如：
- en: '[PRE84]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'By this, you have automatic conversions between Scala collections and their
    corresponding in Java:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，您可以在Scala集合和其对应的Java集合之间进行自动转换：
- en: '[PRE85]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'You can also try to convert other Scala collections into Java ones. For example:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以尝试将其他Scala集合转换为Java集合。例如：
- en: '[PRE86]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Java doesn''t provide the functionality to distinguish between immutable and
    mutable collections. The `List` will be `java.util.List` where all attempts to
    mutate its elements will throw an `Exception`. The following is an example to
    demonstrate this:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: Java不提供区分不可变和可变集合的功能。`List`将是`java.util.List`，对其元素进行任何尝试修改都会抛出异常。以下是一个示例来演示这一点：
- en: '[PRE87]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: In [Chapter 2](part0058.html#1NA0K1-21aec46d8593429cacea59dbdcd64e1c), *Object-Oriented
    Scala*, we briefly discussed using implicits. However, we will provide a detailed
    discussion on using implicits in the next section.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](part0058.html#1NA0K1-21aec46d8593429cacea59dbdcd64e1c)中，*面向对象的Scala*，我们简要讨论了使用隐式。然而，在下一节中，我们将详细讨论使用隐式。
- en: Using Scala implicits
  id: totrans-381
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Scala隐式
- en: We have addressed implicits in the previous chapters, but here we are going
    to see more examples. Implicit parameters are very similar to default parameters
    but they use different mechanisms in order to find the default value.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在之前的章节中已经讨论了隐式，但在这里我们将看到更多示例。隐式参数与默认参数非常相似，但它们使用不同的机制来查找默认值。
- en: 'An implicit parameter is one that is passed to a constructor or a method and
    is marked as implicit, which means that the compiler will search for an implicit
    value within the scope if you don''t provide a value for this parameter. For example:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 隐式参数是传递给构造函数或方法的参数，并且被标记为implicit，这意味着如果您没有为该参数提供值，编译器将在范围内搜索隐式值。例如：
- en: '[PRE88]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Implicits are very useful for the collection API. For example, the collections
    API use implicit parameters to supply `CanBuildFrom` objects for many methods
    in these collections. This happens usually because users aren't concerned with
    these parameters.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 隐式对于集合API非常有用。例如，集合API使用隐式参数为这些集合中的许多方法提供`CanBuildFrom`对象。这通常发生是因为用户不关心这些参数。
- en: 'One constraint is that you can''t have more than one implicit keyword per method
    and it must be at the start of the parameter list. Here are some invalid examples:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 一个限制是每个方法不能有多个implicit关键字，并且必须位于参数列表的开头。以下是一些无效的示例：
- en: '[PRE89]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '**Number of implicit parameters:** Note that you can have more than one implicit
    parameter. But, you cannot have more than one group of implicit parameters.'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '**隐式参数的数量：**请注意，您可以有多个隐式参数。但是，您不能有多个隐式参数组。'
- en: 'The following is for more than 1 implicit parameter:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 对于多个隐式参数，如下所示：
- en: '[PRE90]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'The final parameter list on a function can be identified or marked as implicit.
    This means the values will be taken from the context as they are being called.
    In other words, if there is no implicit value of the exact type in the scope,
    the source code using implicit will not be compiled. The reason is simple: since
    the implicit value must be resolved to a single value type, it would be a better
    idea to make the type specific to its purpose to avoid implicit clashes.'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的最终参数列表可以被标识或标记为隐式。这意味着值将从上下文中被调用时被取出。换句话说，如果在范围内没有确切类型的隐式值，使用隐式的源代码将不会被编译。原因很简单：由于隐式值必须解析为单一值类型，最好将类型特定于其目的，以避免隐式冲突。
- en: 'Moreover, you do not require methods to find an implicit. For example:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你不需要方法来找到一个隐式。例如：
- en: '[PRE91]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'When your Scala compiler finds an expression of wrong types for the context
    it is feeding, it will look for an implicit function value instead for type-checking.
    So, the difference between your regular methods is that the one marked implicit
    will be inserted for you by the compiler when a `Double` is found but an `Int`
    is required. For example:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的Scala编译器发现一个表达式的类型与上下文不符时，它会寻找一个隐式函数值来进行类型检查。因此，你的常规方法与标记为隐式的方法之间的区别在于，当发现`Double`但需要`Int`时，编译器会为你插入标记为隐式的方法。例如：
- en: '[PRE92]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'The earlier code will work the same as:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码将与以下代码相同：
- en: '[PRE93]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: In the second we've inserted the conversion manually. At first, the compiler
    did this automatically. The conversion is required because of the type annotation
    on the left-hand side.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个例子中，我们手动插入了转换。起初，编译器会自动执行这个操作。之所以需要转换是因为左侧有类型注释。
- en: While working with data, we will often need to convert one type to another.
    Scala implicit type conversion gives us this facility. We will see several examples
    of it in the next section.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理数据时，我们经常需要将一种类型转换为另一种类型。Scala隐式类型转换为我们提供了这种便利。我们将在下一节中看到它的几个例子。
- en: Implicit conversions in Scala
  id: totrans-400
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scala中的隐式转换
- en: 'An implicit conversion from type `S` to type `T` is defined by an implicit
    value that has function type `S => T`, or by an implicit method convertible to
    a value of that type. Implicit conversions are applied in two situations (source:
    [http://docs.scala-lang.org/tutorials/tour/implicit-conversions](http://docs.scala-lang.org/tutorials/tour/implicit-conversions)):'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 从类型`S`到类型`T`的隐式转换是由具有函数类型`S => T`的隐式值定义的，或者由可转换为该类型值的隐式方法定义。隐式转换适用于两种情况（来源：[http://docs.scala-lang.org/tutorials/tour/implicit-conversions](http://docs.scala-lang.org/tutorials/tour/implicit-conversions)）：
- en: If an expression e is of type `S`, and S does not conform to the expression's
    expected type `T`
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果表达式e的类型为`S`，并且S不符合表达式的预期类型`T`
- en: In a selection `e.m` with `e` of type `S`, if the selector `m` does not denote
    a member of `S`.
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在选择`e.m`中，`e`的类型为`S`，如果选择器`m`不表示`S`的成员。
- en: 'Well, we have seen how to use infix operator in Scala. Now, let''s see some
    use cases of Scala implicit conversion. Suppose we have the following code segment:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，我们已经看到了如何在Scala中使用中缀运算符。现在，让我们看一些Scala隐式转换的用例。假设我们有以下代码段：
- en: '[PRE94]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'In the preceding code, we defined some methods for performing addition, subtraction,
    and a unary operation for complex numbers (that is, both real and imaginary numbers).
    Inside the `main()` method, we called these methods with real values. The output
    is given as follows:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们定义了一些方法来执行复数（即实部和虚部）的加法、减法和一元操作。在`main()`方法中，我们用实数调用了这些方法。输出如下：
- en: '[PRE95]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: But what if we want to support adding a normal number to a complex number, how
    would we do that? We could certainly overload our `plus` method to take a `Double`
    argument so that it's going to support the following expression.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我们想要支持将一个普通数字添加到一个复数，我们该怎么做呢？我们当然可以重载我们的`plus`方法以接受一个`Double`参数，这样它就可以支持以下表达式。
- en: '[PRE96]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'For this, we can use Scala implicit conversion. It supports implicit conversion
    for both real and complex numbers for mathematical operation. So, we can just
    use that tuple as the parameter for our implicit conversion and convert it into
    a `Complex` refer to the following:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们可以使用Scala隐式转换。它支持数学运算的实数和复数的隐式转换。因此，我们可以将该元组作为隐式转换的参数，并将其转换为`Complex`，参见以下内容：
- en: '[PRE97]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Alternatively, for double to complex conversion as follows:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，对于双精度到复数的转换如下：
- en: '[PRE98]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'To take the advantage of this conversion, we need to import the following:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 为了利用这种转换，我们需要导入以下内容：
- en: '[PRE99]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Now, we can execute something like this on Scala REPL/IDE:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在Scala REPL/IDE上执行类似这样的操作：
- en: '[PRE100]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'You will get the following output:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到以下输出：
- en: '[PRE101]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'The full source code for this example can be seen as follows:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子的完整源代码可以如下所示：
- en: '[PRE102]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: We have now more or less covered Scala collection APIs. There are other features
    too, but page limitations prevented us from covering them. Interested readers
    who still want to explore this should refer to this page [http://www.scala-lang.org/docu/files/collections-api/collections.html](http://www.scala-lang.org/docu/files/collections-api/collections.html).
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在或多或少地涵盖了Scala集合API。还有其他特性，但是页面限制阻止我们覆盖它们。对于仍然想要探索的感兴趣的读者，可以参考这个页面[http://www.scala-lang.org/docu/files/collections-api/collections.html](http://www.scala-lang.org/docu/files/collections-api/collections.html)。
- en: Summary
  id: totrans-423
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Throughout this chapter, we have seen many examples of using the Scala collections
    API. It's very powerful, flexible, and has lots of operations coupled with them.
    This wide range of operations will make your life easy dealing with any kind of
    data. We introduced the Scala collections API, and its different types and hierarchies.
    We also demonstrated the capabilities of the Scala collections API and how it
    can be used in order to accommodate different types of data and solve a wide range
    of different problems. In summary, you learned about types and hierarchies, performance
    characteristic, Java interoperability, and the usage of implicits. So, this is
    more or less the end of the learning Scala. However, you will keep on learning
    more advanced topics and operations using Scala through the following chapters.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了许多使用Scala集合API的示例。它非常强大、灵活，并且具有许多与之相关的操作。这种广泛的操作范围将使您在处理任何类型的数据时更加轻松。我们介绍了Scala集合API及其不同类型和层次结构。我们还展示了Scala集合API的功能以及如何使用它来适应不同类型的数据并解决各种不同的问题。总之，您了解了类型和层次结构、性能特征、Java互操作性以及隐式的使用。因此，这或多或少是学习Scala的结束。然而，您将在接下来的章节中继续学习更高级的主题和操作。
- en: In the next chapter, we will explore data analysis and big data to see the challenges
    that big data provides and how they are dealt via distributed computing and the
    approach suggested by functional programming. You will also learn about MapReduce,
    Apache Hadoop, and finally Apache Spark and see how they embrace this approach
    and these techniques.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨数据分析和大数据，以了解大数据提供的挑战以及它们是如何通过分布式计算和函数式编程所提出的方法来解决的。您还将了解MapReduce、Apache
    Hadoop，最后还会了解Apache Spark，并看到它们是如何采用这种方法和这些技术的。
