- en: '*Chapter 9*: Improving Job Applications with Streamlit'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第9章*：使用Streamlit提升工作申请'
- en: At this point in this book, you should already be an experienced Streamlit user.
    You have a good grasp of everything – from Streamlit design to deployment, to
    data visualization, and everything in between. This chapter is designed to be
    application-focused; it will show you some great use cases for Streamlit applications
    so that you can be inspired to create your own! We will start by demonstrating
    how to use Streamlit for *Proof Of Skill Data Projects*. Then, we will then move
    on to discuss how to use Streamlit in the *Take Home* sections of job applications.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的这一部分，你应该已经是一个经验丰富的Streamlit用户。你对所有内容都有很好的掌握——从Streamlit的设计到部署，再到数据可视化，及其间的一切。本章旨在应用为主；它将展示一些Streamlit应用的优秀用例，帮助你获得灵感，创造属于你自己的应用！我们将从展示如何使用Streamlit进行*技能证明数据项目*开始。然后，我们将讨论如何在工作申请的*Take
    Home*部分使用Streamlit。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Using Streamlit for proof of skill data projects
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Streamlit进行技能证明数据项目
- en: Improving job applications in Streamlit
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Streamlit中提升工作申请
- en: Technical requirements
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The following is a list of software and hardware installations that are required
    for this chapter:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章所需的软硬件安装列表：
- en: '`streamlit-lottie`: To download this library, run the following code in your
    Terminal:'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`streamlit-lottie`：要下载这个库，请在终端运行以下代码：'
- en: '[PRE0]'
  id: totrans-8
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Interestingly, `streamlit-lottie` uses the `lottie` open source library, which
    allows us to add web-native animations (such as a GIF) to our Streamlit apps.
    Frankly, it is a wonderful library that you can use to beautify Streamlit apps
    and was created by Andy Fanilo, a prolific Streamlit app creator.
  id: totrans-9
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有趣的是，`streamlit-lottie`使用了`lottie`开源库，这使我们能够在Streamlit应用中添加网页原生动画（如GIF）。坦率地说，这是一个很棒的库，可以用来美化Streamlit应用，由Streamlit应用的多产创作者Andy
    Fanilo创建。
- en: 'The job application example folder: The central repository for this book can
    be found at [https://github.com/tylerjrichards/Getting-Started-with-Streamlit-for-Data-Science](https://github.com/tylerjrichards/Getting-Started-with-Streamlit-for-Data-Science).
    Within this repository, the `job_application_example` folder will contain some
    of the files that you will need for the second section of the chapter, covering
    job applications. If you do not have this main repository downloaded already,
    use the following code in your Terminal to clone it:'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工作申请示例文件夹：本书的中央仓库可以在[https://github.com/tylerjrichards/Getting-Started-with-Streamlit-for-Data-Science](https://github.com/tylerjrichards/Getting-Started-with-Streamlit-for-Data-Science)找到。在这个仓库中，`job_application_example`文件夹将包含你在本章第二部分（工作申请）中所需的一些文件。如果你还没有下载这个主仓库，请在终端使用以下代码进行克隆：
- en: '[PRE1]'
  id: totrans-11
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now that we have everything set up, let's begin!
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好一切，开始吧！
- en: Using Streamlit for proof of skill data projects
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Streamlit进行技能证明数据项目
- en: Proving to others that you are a skilled data scientist is notoriously difficult.
    Anyone can put Python or machine learning on their résumé or even work in a research
    group at a university that might do some machine learning. But often, recruiters,
    professors you want to work with, and data science managers rely on things on
    your résumé that are proxies for competence, such as having attended the "right"
    university or already having a fancy data science internship or job.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 向他人证明你是一个熟练的数据科学家是出了名的困难。任何人都可以在简历上写上Python或机器学习，甚至可以在做机器学习的大学研究小组工作。但往往，招聘人员、你想合作的教授以及数据科学经理们更多依赖于简历上的一些间接标志来评估能力，例如是否就读于“名校”，或已经拥有一份高级的数据科学实习或工作经历。
- en: Prior to Streamlit, there were not many effective solutions to this problem.
    If you put a Python file or Jupyter Notebook on your GitHub profile, the time
    it would take for someone to understand whether the work was impressive or not
    was too much of a risk to take. If the recruiter has to click on the right repository
    in your GitHub profile and then click through numerous files until they find the
    Jupyter notebook with unreadable code (without comments), you've already lost
    them. If the recruiter sees "machine learning" on your résumé, but it takes five
    clicks to see any machine learning product or code that you've written, you've
    already lost them. Most interested parties will spend a very small amount of time
    on your résumé; on average, visitors to my personal portfolio site (www.tylerjrichards.com)
    spend around 2 minutes on the site before moving elsewhere.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Streamlit 出现之前，这个问题几乎没有什么有效的解决方案。如果你将一个 Python 文件或 Jupyter Notebook 放到你的 GitHub
    个人资料上，别人要花费的时间来了解这个作品是否令人印象深刻，风险太大。如果招聘人员必须点击你 GitHub 个人资料中的正确仓库，然后点击多个文件，直到找到那份没有注释、难以阅读的
    Jupyter Notebook，你就已经失去了他们的关注。如果招聘人员在你的简历上看到“机器学习”，但需要点击五次才能看到你写的任何机器学习产品或代码，那么你就已经失去了他们的兴趣。大多数感兴趣的人在你的简历上花的时间非常少；根据我的个人网站（www.tylerjrichards.com）的数据，访客平均在该网站上停留约
    2 分钟，之后就会离开。
- en: One solution to this issue is to try creating and sharing Streamlit apps that
    are specific to the skills that you would like to showcase the most broadly. For
    instance, if you have a lot of experience in fundamental statistics, you might
    create a Streamlit app that proves, or illustrates, a fundamental statistical
    theorem such as the central limit theorem – just as we did earlier in this book.
    If instead, you have experience in natural language processing, you could create
    an app that shows off a new text-generating neural network that you have created.
    The point here is to minimize the number of clicks someone would need to make
    until they get proof of your competence within a desired area.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的一种方法是尝试创建和分享专门展示你想要最广泛展示的技能的 Streamlit 应用程序。例如，如果你在基础统计学方面有丰富经验，你可以创建一个
    Streamlit 应用程序，证明或说明一个基本的统计定理，如中心极限定理——就像我们在本书中早些时候做的那样。如果你有自然语言处理的经验，你可以创建一个展示你所创建的新的文本生成神经网络的应用程序。关键在于最小化别人需要点击的次数，直到他们看到你在某个领域的能力证明。
- en: Many of the Streamlit apps that we have created already do serve this purpose.
    Let's run through a few examples.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建的许多 Streamlit 应用程序确实达到了这个目的。让我们来看几个例子。
- en: Machine learning – the Penguins app
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 机器学习 – Penguins 应用
- en: In [*Chapter 4*](B16864_04_Final_VK_ePub.xhtml#_idTextAnchor049), *Using Machine
    Learning with Streamlit*, we created a random forest model that was trained on
    our Palmer's Penguin dataset to predict the species of penguin according to features
    such as weight, island of habitation, and bill length. Then, we saved that model
    so that we could use it in our Streamlit app.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第4章*](B16864_04_Final_VK_ePub.xhtml#_idTextAnchor049)，*使用 Streamlit 进行机器学习*中，我们创建了一个随机森林模型，使用我们的
    Palmer's Penguin 数据集进行训练，根据特征如体重、栖息岛屿和喙长来预测企鹅的物种。然后，我们保存了该模型，以便在 Streamlit 应用程序中使用。
- en: 'To produce our Streamlit app, we need (in the first iteration) to run the following
    code. This will create the model to be deployed:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生成我们的 Streamlit 应用程序，我们需要（在第一次迭代中）运行以下代码。这将创建要部署的模型：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In this first section, we import our libraries, load our data, and train/evaluate
    our model while printing out the evaluation results. Then, we save the model results
    to the `pickle` files using the following code:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分中，我们导入库，加载数据，并训练/评估我们的模型，同时打印出评估结果。然后，我们使用以下代码将模型结果保存到`pickle`文件中：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Recall that at the end of the chapter, we added a new feature so that if a user
    uploaded their own dataset, they could use our model training script to train
    a model entirely on their data (provided it was in the same format; it came with
    some preconditions).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，在本章的结尾，我们添加了一个新功能，使得如果用户上传自己的数据集，他们可以使用我们的模型训练脚本，完全基于他们的数据训练一个模型（前提是数据格式相同，且有一些前提条件）。
- en: This app, in its final form, shows that we have, at least, some knowledge about
    data cleaning, how to do one-hot encoding on our variables, how we think about
    evaluating our models on test data, and finally, how to deploy our pre-trained
    models in an application. That alone is going to look much better than just putting
    "machine learning" on our résumé, and it shows evidence of some of the skills
    that we have. Without this proof of skill, the recruiter or hiring manager who
    is looking at our application will have to either trust that we are being entirely
    honest on our résumé (and from reading hundreds of résumés over the years, that
    is a bad assumption to make) or use a proxy for confidence such as a university
    degree (this is also a bad proxy for assessing competence).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应用的最终版本显示了我们至少具备了数据清理的知识，如何对变量进行独热编码，如何评估模型在测试数据上的表现，最后，如何将预训练的模型部署到应用中。仅这一点就比在简历上单纯写“机器学习”要好得多，而且它展示了我们一些技能的实际证据。没有这种技能证明，招聘人员或招聘经理在查看我们的申请时，只能要么完全相信我们简历上的信息（但根据多年的简历筛选经验，这是一个很糟糕的假设），要么通过某些替代标准来评估我们的能力，比如大学学位（但这同样是一个评估能力的糟糕标准）。
- en: 'In addition to this, when we deployed this app to Streamlit Sharing in [*Chapter
    5*](B16864_05_Final_VK_ePub.xhtml#_idTextAnchor056), *Deploying Streamlit with
    Streamlit Sharing*, we discussed an automatic feature that comes free with Streamlit
    Sharing: the **View app source** button. As you can see in the following screenshot,
    when we deploy our apps, Streamlit adds a button to the user''s **Settings** drop-down
    menu that allows them to view the source code behind the app:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，当我们在[*第 5 章*](B16864_05_Final_VK_ePub.xhtml#_idTextAnchor056)《使用 Streamlit
    Sharing 部署 Streamlit》一节中将应用部署到 Streamlit Sharing 时，我们讨论了 Streamlit Sharing 中免费的一个自动化功能：**查看应用源代码**按钮。如以下截图所示，当我们部署应用时，Streamlit
    会在用户的**设置**下拉菜单中添加一个按钮，允许他们查看应用背后的源代码：
- en: '![Figure 9.1 – The View app source option'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.1 – 查看应用源代码选项'
- en: '](img/B16864_09_1.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16864_09_1.jpg)'
- en: Figure 9.1 – The View app source option
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.1 – 查看应用源代码选项
- en: In this way, users can always check to make sure malicious code (for example,
    whether a researcher's Penguin data is not being stored by the app) is not being
    deployed by Streamlit Sharing. As a secondary feature, the user can also view
    the code that you wrote to built the app, which improves the ability for us to
    use Streamlit as a *Proof of Skill* tool.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，用户可以随时检查，确保恶意代码（例如，研究人员的企鹅数据是否被应用存储）不会被 Streamlit Sharing 部署。作为附加功能，用户还可以查看你编写的构建应用的代码，这增强了我们将
    Streamlit 作为*技能证明*工具的能力。
- en: Visualization – the Pretty Trees app
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可视化 – 漂亮的树木应用
- en: 'In [*Chapter 6*](B16864_06_Final_VK_ePub.xhtml#_idTextAnchor065), *Beautifying
    Streamlit Apps*, we worked on a Streamlit application that could create beautiful
    and dynamic visualizations of trees in San Francisco, which resulted in the following
    app:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第 6 章*](B16864_06_Final_VK_ePub.xhtml#_idTextAnchor065)《美化 Streamlit 应用》中，我们开发了一个
    Streamlit 应用，它可以创建美观且动态的旧金山树木可视化，最终形成了以下这个应用：
- en: '![Figure 9.2 – Mapping a web app'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.2 – 映射一个 Web 应用'
- en: '](img/B16864_09_2.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16864_09_2.jpg)'
- en: Figure 9.2 – Mapping a web app
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.2 – 映射一个 Web 应用
- en: 'Within this app, we had to create multiple different visualizations (that is,
    two histograms and one map) that dynamically updated based on the user inputs
    on the right-hand side. With an app like this, we were able to show off our data
    manipulation skills, our familiarity with the pandas, Matplotlib, and Seaborn
    libraries, and even that we understood how to deal with datetimes in Python. Let''s
    take a look at the section of the app''s code that focuses on visualization:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个应用中，我们需要创建多个不同的可视化（即两个直方图和一个地图），这些可视化会根据右侧用户输入动态更新。通过这样的应用，我们能够展示我们在数据处理方面的技能、对
    pandas、Matplotlib 和 Seaborn 库的熟悉程度，甚至展示我们理解如何在 Python 中处理日期时间。我们来看看这个应用中专注于可视化的代码部分：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This code is fairly easy to read for anyone who is familiar with Python or other
    scripting languages, and it is a heck of a lot better than simply putting "data
    visualization" or "pandas" on a résumé.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码对于任何熟悉 Python 或其他脚本语言的人来说都相当容易理解，而且它比简历上仅仅写“数据可视化”或“pandas”要好得多。
- en: At this point, I hope you are convinced. Streamlit apps are an excellent way
    to showcase your work to recruiters, potential hiring managers, or anyone to whom
    you need to prove your set of skills. In the next section, we will cover this
    process in a little more detail and demonstrate how to use Streamlit to bolster
    your applications to companies that you might want to work for.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 到这个时候，我希望你已经信服了。Streamlit 应用程序是展示你的工作给招聘人员、潜在的招聘经理或任何需要你证明技能的人群的绝佳方式。在下一节中，我们将更加详细地讲解这个过程，并演示如何利用
    Streamlit 来增强你向你可能想要应聘的公司提交的申请。
- en: Improving job applications in Streamlit
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改善 Streamlit 中的求职申请
- en: Often, data science and machine learning job applications rely on take-home
    data science challenges to judge candidates. Frankly, this is a brutal and annoying
    experience that companies can demand because of the dynamic between the applicant
    and the employer. For instance, it could take a candidate 5–10 hours to fully
    complete a data science challenge, but it might only take the employer 10 minutes
    to evaluate it. Additionally, an individual virtual or telephone interview might
    take 30–45 minutes for the employer, plus an extra 15 minutes to write up feedback,
    compared to the same 30–45 minutes for the applicant. Because getting 5–10 hours
    of work gives them a very high signal per minute of employee time, employers have
    trended toward including these challenges within their job applications.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，数据科学和机器学习职位的求职申请依赖于带回家的数据科学挑战来评估候选人。坦率地说，这是一个残酷且令人烦恼的经历，因为申请人与雇主之间的动态关系。举例来说，候选人可能需要
    5-10 小时才能完成一个数据科学挑战，但雇主可能只需要 10 分钟来评估它。此外，一个虚拟或电话面试对于雇主来说可能需要 30-45 分钟，加上额外的 15
    分钟写反馈，相比之下，申请人也要花费同样的 30-45 分钟。因为雇主通过获得 5-10 小时的工作可以在每分钟员工时间上获得非常高的信号，所以雇主趋向于在招聘申请中包含这些挑战。
- en: You can use the opportunity here to use Streamlit to stand out from the crowd
    by creating a fully functioning application instead of sending the company a Jupyter
    Notebook, Word document, or PowerPoint deck.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里你可以利用这个机会，通过创建一个完整运行的应用程序来从人群中脱颖而出，而不是仅仅发送 Jupyter Notebook、Word 文档或 PowerPoint
    演示文稿给公司。
- en: Questions
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: 'Let''s walk through a fictional example about a job applicant who is in the
    middle of applying to a major US airline. They are given two main questions to
    solve – one has a dataset included:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个虚构的例子来讲解一下，一个求职者正在申请一家美国大型航空公司的职位。他们被给出两个主要的问题需要解决——其中一个包含了数据集：
- en: '**Question 1**: **Airport distance**'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**问题 1**：**机场距离**'
- en: The first exercise asks, "Given the included dataset of airports and locations
    (in latitude and longitude), write a function that takes an airport code as input
    and returns the airports listed from nearest to furthest from the input airport."
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第一个练习要求：“给定包含机场和地点（以经纬度表示）的数据集，编写一个函数，接受一个机场代码作为输入，并返回按距离从近到远排列的机场列表。”
- en: '**Question 2**: **Representation**'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**问题 2**：**表示方法**'
- en: The second question asks, "How would you transform a collection of searches
    into a numeric vector representing a trip? Assume that we have hundreds of thousands
    of users and we want to represent all of their trips this way. Ideally, we want
    this to be a general representation that we could use in multiple different modeling
    projects, but we definitely care about finding similar trips. How, precisely,
    would you compare two trips to see how similar they are? What information do you
    feel might be missing from the preceding data that would help improve your representation?"
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第二个问题问到：“你如何将一系列搜索转化为一个表示旅行的数字向量？假设我们有成千上万的用户，并且希望以这种方式表示他们的所有旅行。理想情况下，我们希望这是一个通用的表示，可以在多个不同的建模项目中使用，但我们更关心的是找到相似的旅行。那么，具体来说，你如何比较两次旅行，以了解它们的相似程度？你认为前述数据中缺少了哪些信息，能够帮助改善你的表示方法？”
- en: Note
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: Don't worry about writing code in this section; you can simply describe any
    transformations of data that you would perform. Your description should be clear
    enough so that a data scientist reading it would know how to implement your solution
    if necessary.
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不用担心在这一部分编写代码；你可以简单描述你将执行的任何数据转换。你的描述应该足够清晰，以便让阅读它的数据科学家知道如果有必要，如何实现你的解决方案。
- en: 'Now that we have the required questions, we can get a new Streamlit app started.
    To do this, I went through the same process that we have used in each chapter
    thus far. We create a new folder for our app within our central folder (`streamlit_apps`),
    called `job_application_example`. Within this folder, we can create a Python file,
    called `job_streamlit.py`, in our Terminal, using the following command:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了所需的问题，我们可以开始新的 Streamlit 应用程序。为此，我采用了迄今为止在每一章中使用的相同过程。我们在我们的中央文件夹（`streamlit_apps`）中创建一个新的文件夹，命名为`job_application_example`。在这个文件夹内，我们可以通过终端使用以下命令创建一个
    Python 文件，命名为 `job_streamlit.py`：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Answering Question 1
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回答问题 1
- en: It is not hugely important for you to understand exactly how to answer the problem
    at hand, but the overall framework is quite important. The Streamlit app we create
    should read like an incredibly dynamic document that answers the question in a
    unique way, depending on the ability of Streamlit to make an application that
    could not easily be replicated by an applicant with a Word document.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 对于你来说，理解如何回答当前问题并不至关重要，但整体框架是非常重要的。我们创建的 Streamlit 应用程序应该像一个极具动态感的文档，根据 Streamlit
    的能力回答问题，并以一种独特的方式呈现，这种方式是用 Word 文档无法轻易复制的。
- en: 'To begin, we can create a title that introduces us and kicks off the format
    for the whole application. One improvement here is to add an optional animation
    at the top of the application using the `streamlit-lottie` library that we learned
    about in [*Chapter 7*](B16864_07_Final_VK_ePub.xhtml#_idTextAnchor074), *Exploring
    Streamlit Components*, as shown in the following code:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以创建一个标题，介绍我们自己，并为整个应用程序的格式开个头。这里的一个改进是，使用我们在[*第 7 章*](B16864_07_Final_VK_ePub.xhtml#_idTextAnchor074)《探索
    Streamlit 组件》中学到的 `streamlit-lottie` 库，在应用程序顶部添加一个可选的动画，代码如下：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The preceding code will create an application with a beautiful airplane animation
    at the top, as presented in the following screenshot:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将创建一个带有美丽飞机动画的应用程序，如下图所示：
- en: '![Figure 9.3 – An airplane GIF'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.3 – 一只飞机的 GIF 动画'
- en: '](img/B16864_09_3.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16864_09_3.jpg)'
- en: Figure 9.3 – An airplane GIF
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.3 – 一只飞机的 GIF 动画
- en: 'Next, we need to copy and paste the question below our subheader. Streamlit
    has many options for putting text into applications. One option that we have not
    used yet is to wrap our text inside three apostrophe signs, which tells Streamlit
    to write this text using the markdown language. This is useful for large blocks
    of text, such as the following one, which begins to answer the first question:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要将问题复制并粘贴到子标题下。Streamlit 提供了多种在应用程序中插入文本的方式。我们尚未使用的一种方式是将文本放入三个撇号内，这会告诉
    Streamlit 使用 Markdown 语言来显示该文本。这对于大块文本非常有用，例如下面这段文字，它开始回答第一个问题：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As mentioned in the *Technical requirements* section of this chapter, two files
    are needed to complete this application. The first is the dataset of the airport
    locations (called `airport_location.csv`), and the second is a picture that shows
    the Haversine distance (that is, the distance between two points on a sphere;
    the file is appropriately named `haversine.png`). Please copy those files into
    the same folder as the Streamlit application Python file.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章的*技术要求*部分所述，完成此应用程序需要两个文件。第一个是机场位置数据集（称为 `airport_location.csv`），第二个是显示哈弗辛距离的图片（即球面上两点之间的距离；文件名为
    `haversine.png`）。请将这些文件复制到与 Streamlit 应用程序 Python 文件相同的文件夹中。
- en: 'Now, we need to complete the first step: loading the data. We need to both
    complete this step in Streamlit and also show the code to the user. This is different
    from other Streamlit applications, where the code is hidden in the background.
    However, because the user definitely wants to see our code, as they will be assessing
    us on it, we need to do both. We can use the `st.echo()` function, which we used
    previously, to print out the code block to our app. We can do this with the following
    code:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要完成第一步：加载数据。我们需要在 Streamlit 中完成这一步，并且还需要将代码展示给用户。这与其他 Streamlit 应用程序不同，其他应用程序中的代码通常隐藏在后台。然而，由于用户肯定希望看到我们的代码，因为他们会基于这些代码进行评估，我们需要同时做这两件事。我们可以使用之前用过的
    `st.echo()` 函数，将代码块打印到应用程序中。我们可以使用以下代码来实现：
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: I would like to note here that we have placed a comment at the top of this code.
    This is not for the purpose of annotating code for you, the reader, but for the
    application reader. It is good practice to occasionally comment on the purpose
    of the code that you are writing both within the code and in the blocks of text
    before and after; this is so that the reader understands the approach you are
    trying to take. This is especially important in a job application but is good
    practice for collaborative Streamlit apps, too.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我想在这里指出，我们在此代码顶部添加了一条注释。这不是为了给您作为读者注释代码，而是为了应用程序的读者。偶尔在您编写的代码内部和前后的文本块中对编写代码的目的进行评论是个好习惯；这样读者就能理解您试图采取的方法。这在求职申请中尤为重要，但对于协作的
    Streamlit 应用程序也是一个良好的实践。
- en: 'Our next step is to explain the Haversine formula and show the image in our
    Streamlit application, which we have done in the following code block. It is totally
    acceptable to take a narrative format in your blocks of text. Simply imagine what
    you would like to read as a hiring manager and try to replicate that as well as
    you can:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一步是解释 Haversine 公式，并在我们的 Streamlit 应用程序中展示图像，我们已在以下代码块中完成。在您的文本块中采用叙述格式是完全可以的。只需想象您希望招聘经理阅读的内容，并尽可能复制：
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, our application should look similar to the following screenshot:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的应用程序应该看起来与以下屏幕截图类似：
- en: '![Figure 9.4 – Loading the data for Question 1'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.4 – 加载问题 1 的数据'
- en: '](img/B16864_09_4.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16864_09_4.jpg)'
- en: Figure 9.4 – Loading the data for Question 1
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.4 – 加载问题 1 的数据
- en: 'We have our list of items to address, the animation, the Haversine distance
    formula, and the basic code to read in the data. At this point, we need to implement
    the Haversine distance formula in Python and also show our implementation:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有要解决的问题清单、动画、Haversine 距离公式以及读取数据的基本代码。此时，我们需要在 Python 中实现 Haversine 距离公式并展示我们的实现：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The first section of our code does not create our function but instead, prints
    out the function that we will create to the Streamlit app. This is so that the
    reader of the application can view both pieces of important code that we have
    written and interact with the code itself. If we just created a function to implement
    the Haversine distance, the reader of our application would not really know how
    we solved the problem at hand! The following code block creates this function:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们代码的第一部分并不创建我们的函数，而是将我们将要在 Streamlit 应用程序中创建的函数打印出来。这样，应用程序的读者可以查看我们编写的两个重要代码片段并与代码本身进行交互。如果我们只是创建了一个函数来实现
    Haversine 距离，那么我们应用程序的读者实际上不会真正了解我们是如何解决手头问题的！以下代码块创建了这个函数：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We have completed our Haversine implementation! Whenever we want to find the
    distance between two locations, we can call our formula, input the longitude and
    latitude, and get the distance in kilometers. This app is useful; however, at
    the moment, it is not much better than a Word document. Our next step is to allow
    the user to input their own points to check and see whether the Haversine distance
    is working. Almost no one knows how many kilometers apart two points on the globe
    are, so I have included default points and checked the real distance between them:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们完成了 Haversine 的实现！每当我们想要找到两个位置之间的距离时，我们可以调用我们的公式，输入经度和纬度，然后获得以公里为单位的距离。这个应用程序很有用；然而，目前它不比一个
    Word 文档好多少。我们的下一步是允许用户输入他们自己的点来检查和查看 Haversine 距离是否有效。几乎没有人知道地球上两点之间相隔多少公里，因此我已包含了默认点并检查了它们之间的实际距离：
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'When we put in our default values, the app returns a distance that is approximately
    2 kilometers off, as shown in the following screenshot:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们输入默认值时，应用程序返回的距离大约偏差了 2 公里，如下屏幕截图所示：
- en: '![Figure 9.5 – Implementing the Haversine distance'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.5 – 实现 Haversine 距离'
- en: '](img/B16864_09_5.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16864_09_5.jpg)'
- en: Figure 9.5 – Implementing the Haversine distance
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.5 – 实现 Haversine 距离
- en: 'At this point, our next step is to combine all of the pieces by using the implemented
    Haversine distance calculator on our given dataset. This is briefly shown in the
    following screenshot:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们的下一步是通过在给定数据集上使用实现的 Haversine 距离计算器来组合所有部分。这在以下屏幕截图中简要显示：
- en: '![Figure 9.6 – The airport distances that have been given'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.6 – 已给出的机场距离'
- en: '](img/B16864_09_6.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16864_09_6.jpg)'
- en: Figure 9.6 – The airport distances that have been given
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.6 – 已给出的机场距离
- en: 'This dataset has airport codes and their corresponding `lat` and `long` values.
    The following code block introduces a solution that combines the two distances
    and leaves out the full `get_distance_list` function, as it is simply a copy of
    the function that we have implemented twice already:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数据集包含机场代码及其对应的`lat`和`long`值。以下代码块展示了一种将两种距离结合起来的解决方案，并省略了完整的`get_distance_list`函数，因为它只是我们已经实现过两次的函数的复制：
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Finally, we can implement this distance formula on the dataframe we have been
    given. We can allow the user to input their own airport code from the options
    that we have data on and return the correct values:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以在给定的数据框上实现此距离公式。我们可以让用户从我们拥有数据的选项中输入自己的机场代码，并返回正确的值：
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This is the end of our first question. We can add an optional section at the
    end about how we would change our implementation if we had more time to work on
    this problem. This is always a good idea if you know you only want to spend a
    few hours on the total application, but you also want to demonstrate that you
    know how to improve it if you had more time. An example of this is shown in the
    following code block, to be placed directly after the preceding code block:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们第一个问题的结束部分。我们可以在最后添加一个可选部分，讲述如果我们有更多时间来处理这个问题，我们会如何修改我们的实现。如果你知道自己只想在整个应用程序上花费几个小时，但又希望展示你知道如何在有更多时间的情况下改进它，这总是一个好主意。以下代码块展示了一个例子，应直接放在前面的代码块后面：
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Alternatively, you could always just end with a statement about the preceding
    code and move on to the second question. At this point, our answer to *Question
    1* is complete and should look similar to the following screenshot:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，你也可以直接以一段关于前述代码的说明来结束，并继续处理第二个问题。此时，我们对*问题 1*的回答已完成，并应类似于以下截图：
- en: '![Figure 9.7 – Taking user input'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.7 – 获取用户输入'
- en: '](img/B16864_09_7.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16864_09_7.jpg)'
- en: Figure 9.7 – Taking user input
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.7 – 获取用户输入
- en: We have now successfully answered *Question 1*! We can always check the distances
    between these airports by hand to obtain the same result. But let's move on to
    the second question in our application.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经成功回答了*问题 1*！我们可以手动检查这些机场之间的距离以获得相同的结果。但让我们继续处理应用中的第二个问题。
- en: Answering Question 2
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回答问题 2
- en: 'The second question is far more straightforward and only asks for text responses.
    Here, the trick is to try to add some lists or Python objects in order to break
    up large paragraphs of text. To begin, we will explain our attempt at answering
    the question and then demonstrate how it might look inside a dataframe:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个问题更为直接，仅要求提供文本答案。在这里，技巧是尽量添加一些列表或Python对象，以打破大量的文本段落。首先，我们将解释我们回答问题的尝试，然后展示它在数据框中的展示效果：
- en: '[PRE16]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, we can think of some columns that would be useful for when we are making
    a representation of when a user is searching for flights on this major US airline.
    We can put them into an example dataframe, as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以思考一些在用户搜索美国主要航空公司航班时可能有用的列。我们可以将它们放入一个示例数据框，如下所示：
- en: '[PRE17]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'For the remainder of the question, we can add a bit of knowledge regarding
    how to find the distance between two points using different methods and then call
    it a day:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 对于问题的其余部分，我们可以添加一些关于如何使用不同方法找到两个点之间距离的知识，然后就可以结束了：
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The second question''s answer should be similar to the following screenshot:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个问题的答案应类似于以下截图：
- en: '![Figure 9.8 – Answering Question 2'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.8 – 回答问题 2'
- en: '](img/B16864_09_8.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16864_09_8.jpg)'
- en: Figure 9.8 – Answering Question 2
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.8 – 回答问题 2
- en: 'As you can see, this example demonstrates how to approach take-home data assignments
    with the help of the Streamlit library to make more impressive applications. The
    final step of this work is to deploy this Streamlit app and share the link with
    the recruiter. I would strongly advise you to deploy this on Heroku to guarantee
    that no one else can view the questions or the data that has been provided by
    the company. You can also take further precautions, such as putting a textbox
    at the beginning of the application that functions as a hacky password protector
    for the application, as shown in the following code block:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这个例子展示了如何利用Streamlit库帮助解决家庭作业中的数据任务，并制作更具吸引力的应用。此项工作的最后一步是部署这个Streamlit应用，并将链接分享给招聘人员。我强烈建议你将其部署到Heroku上，以确保其他人无法查看招聘公司提供的问题或数据。你也可以采取进一步的预防措施，例如在应用程序开头放置一个文本框，作为应用的“临时”密码保护，如下方代码块所示：
- en: '[PRE19]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, the entire application will not run unless the user inputs `example_password`
    into the textbox. This is certainly not secure, but it is useful for relatively
    unimportant (at least, in terms of secrecy) applications such as a take-home application:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，除非用户在文本框中输入 `example_password`，否则整个应用程序将无法运行。这显然并不安全，但对于相对不重要的（至少在保密性方面）应用程序，如带回家的应用程序，它是有用的：
- en: '![Figure 9.9 – Entering the password'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.9 – 输入密码'
- en: '](img/B16864_09_9.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16864_09_9.jpg)'
- en: Figure 9.9 – Entering the password
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.9 – 输入密码
- en: As you can see, the only way for this application to load is if the correct
    password has been entered. Otherwise, the user will see a blank page. Alternatively,
    you can also set the password in Streamlit Sharing using Streamlit secrets, which
    is currently a feature in Streamlit for Teams and will be covered in [*Chapter
    11*](B16864_11_Final_VK_ePub.xhtml#_idTextAnchor122), *Using Streamlit for Teams*.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，只有输入正确的密码，应用程序才能加载。否则，用户将看到一个空白页面。或者，你也可以在 Streamlit Sharing 中使用 Streamlit
    secrets 设置密码，这是目前 Streamlit for Teams 的一个功能，将在[*第 11 章*](B16864_11_Final_VK_ePub.xhtml#_idTextAnchor122)中讲解，*使用
    Streamlit for Teams*。
- en: Summary
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter is the most application-focused chapter we have created so far.
    We have focused heavily on job applications and the application cycle for data
    science and machine learning interviews. Additionally, we have learned how to
    password protect our applications, how to create applications that prove to recruiters
    and data science hiring managers that we are the skilled data scientists that
    we know we are, and how to stand out in take-home data science interviews by creating
    Streamlit apps. The next chapter will focus on Streamlit as a toy, and you will
    learn how to create public-facing Streamlit projects for the community.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是我们迄今为止创建的最注重应用的章节。我们重点讨论了数据科学和机器学习面试的职位申请及申请流程。此外，我们还学习了如何为我们的应用程序设置密码保护，如何创建能够向招聘人员和数据科学招聘经理证明我们是熟练数据科学家的应用程序，以及如何通过创建
    Streamlit 应用程序在远程数据科学面试中脱颖而出。下一章将重点介绍 Streamlit 作为一个玩具，你将学习如何为社区创建面向公众的 Streamlit
    项目。
