- en: <st c="0">12</st>
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="0">12</st>
- en: <st c="3">Linear Data Structures</st>
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="3">线性数据结构</st>
- en: <st c="26">In this chapter, we will explore the foundational concepts of</st>
    **<st c="89">linear data structures</st>**<st c="111">, which play a</st> <st
    c="125">critical role in computer science and algorithm design.</st> <st c="182">We
    will start by understanding the basics of arrays and linked lists and learning
    how these structures store and manage data.</st> <st c="308">The chapter will
    guide you through the key operations performed on these structures, such as insertion,
    deletion, and searching, and you will examine their time complexities to understand
    their efficiency.</st> <st c="514">By comparing arrays and linked lists, you will
    gain insight into the trade-offs involved in choosing the right data structure
    for</st> <st c="644">specific applications.</st>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="26">在本章中，我们将探索</st> **<st c="89">线性数据结构</st>**<st c="111">的基础概念，这些概念在计算机科学和算法设计中发挥着</st>
    <st c="125">至关重要的作用。</st> <st c="182">我们将从理解数组和链表的基本知识开始，学习这些结构如何存储和管理数据。</st>
    <st c="308">本章将引导你了解这些结构上的关键操作，如插入、删除和查找，并通过分析它们的时间复杂度来理解它们的效率。</st> <st c="514">通过比较数组和链表，你将更好地理解在特定应用中选择合适数据结构时的权衡。</st>
    <st c="644">应用。</st>
- en: <st c="666">As we progress, we will discover more advanced linear data structures
    such as stacks, queues, and</st> **<st c="765">double-ended queues</st>** <st
    c="784">(</st>**<st c="786">deques</st>**<st c="792">).</st> <st c="796">We</st>
    <st c="799">will learn how these structures extend the functionality of basic
    lists and how they are applied in real-world scenarios, such as task scheduling
    and resource management.</st> <st c="970">Additionally, the chapter will introduce
    you to</st> **<st c="1018">skip lists</st>**<st c="1028">, a</st> <st c="1032">probabilistic
    data structure that offers a balance between the efficiency of arrays and the
    flexibility of linked lists.</st> <st c="1153">By the end of this chapter, you
    will be well-equipped with the knowledge needed to implement and utilize these
    linear data</st> <st c="1276">structures effectively.</st>
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="666">随着我们的深入学习，我们将发现更多高级的线性数据结构，如栈、队列和</st> **<st c="765">双端队列</st>**
    <st c="784">(</st>**<st c="786">双向队列</st>**<st c="792">)。</st> <st c="796">我们</st>
    <st c="799">将学习这些结构如何扩展基本列表的功能，以及它们如何应用于实际场景，如任务调度和资源管理。</st> <st c="970">此外，本章还将介绍</st>
    **<st c="1018">跳表</st>**<st c="1028">，一种</st> <st c="1032">概率数据结构，在数组的高效性和链表的灵活性之间提供了平衡。</st>
    <st c="1153">通过本章的学习，你将掌握有效实现和使用这些线性数据结构所需的知识。</st> <st c="1276">结构。</st>
- en: <st c="1299">Essentially, this chapter will cover the</st> <st c="1341">following
    topics:</st>
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1299">本章将涵盖以下主题：</st>
- en: <st c="1358">Lists</st>
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1358">列表</st>
- en: <st c="1364">Skip lists</st>
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1364">跳表</st>
- en: <st c="1375">Stacks</st>
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1375">栈</st>
- en: <st c="1382">Queue</st>
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1382">队列</st>
- en: <st c="1388">Deque</st>
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1388">双端队列</st>
- en: <st c="1394">Lists</st>
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="1394">列表</st>
- en: <st c="1400">A</st> **<st c="1403">list</st>** <st c="1407">is</st> <st c="1411">an
    ordered collection of items that can hold elements of the same or different types,
    where each element is indexed and has a specific position within the list.</st>
    <st c="1572">Lists are commonly used to store sequences of data that can be easily
    accessed, inserted, or removed.</st> <st c="1674">They can hold elements of different
    types, though in some programming languages, lists are more often homogeneous,
    meaning all elements are of the</st> <st c="1821">same type.</st>
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1400">A</st> **<st c="1403">列表</st>** <st c="1407">是一个有序的元素集合，可以容纳相同或不同类型的元素，其中每个元素都有索引并在列表中占据特定位置。</st>
    <st c="1572">列表通常用于存储可以轻松访问、插入或删除的数据序列。</st> <st c="1674">它们可以包含不同类型的元素，尽管在一些编程语言中，列表通常是同质的，意味着所有元素都属于</st>
    <st c="1821">相同类型。</st>
- en: <st c="1831">Lists are generally implemented using either arrays or linked structures,
    and these two approaches result in distinct characteristics regarding performance
    and memory usage.</st> <st c="2006">When elements in a list are stored in contiguous
    memory locations, the list is known as an</st> **<st c="2097">array</st>**<st
    c="2102">. In</st> <st c="2106">this case, accessing elements by index is very
    efficient, typically taking constant time (</st>![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1046.png)<st
    c="2197"><st c="2199">), since the memory location of any element can be directly
    computed.</st> <st c="2269">However, arrays have a fixed size once they are created,
    which can lead to inefficiencies if the number of elements changes frequently,
    requiring the creation of new arrays and copying</st> <st c="2454">of data.</st></st>
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1831">列表通常通过数组或链式结构来实现，这两种方式在性能和内存使用上有明显不同。</st> <st c="2006">当列表中的元素存储在连续的内存位置时，该列表被称为</st>
    **<st c="2097">数组</st>**<st c="2102">。在</st> <st c="2106">这种情况下，通过索引访问元素非常高效，通常需要常数时间（</st>![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1046.png)<st
    c="2197"><st c="2199">），因为可以直接计算任何元素的内存位置。</st> <st c="2269">然而，数组一旦创建后大小固定，如果元素的数量频繁变化，就可能导致效率低下，需要创建新的数组并复制</st>
    <st c="2454">数据。</st></st>
- en: <st c="2462">On the other hand, if the list is implemented using linked structures,
    it is referred to as a</st> **<st c="2557">linked list</st>**<st c="2568">. In
    a</st> <st c="2574">linked list, each element, known as</st> <st c="2610">a</st>
    **<st c="2613">node</st>**<st c="2617">, contains a reference (or link) to the
    next node in the sequence.</st> <st c="2684">This structure allows the list to
    grow and shrink dynamically as elements are added or removed, without the need
    for large blocks of contiguous memory.</st> <st c="2836">However, because the
    nodes are scattered throughout memory, accessing an element by index requires
    traversing the list from the beginning, which can be time-consuming (</st>![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/450.png)
    <st c="3004"><st c="3006">in the</st> <st c="3014">worst case).</st></st>
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="2462">另一方面，如果列表是通过链式结构实现的，则称为</st> **<st c="2557">链表</st>**<st c="2568">。在链表中，每个元素，称为</st>
    <st c="2610">一个</st> **<st c="2613">节点</st>**<st c="2617">，包含一个指向序列中下一个节点的引用（或链接）。</st>
    <st c="2684">这种结构使得列表可以在添加或删除元素时动态增长或缩小，而无需占用大块的连续内存。</st> <st c="2836">然而，由于节点分散在内存中，通过索引访问元素需要从头遍历列表，这可能会很耗时（</st>![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/450.png)
    <st c="3004"><st c="3006">在最坏情况下）。</st></st>
- en: <st c="3026">The choice between using an array or a linked list depends on the
    specific needs of the application, such as the frequency of insertions and deletions
    versus the need for quick access to elements.</st> <st c="3224">Arrays are generally
    preferred when fast access and predictable memory usage are crucial, while linked
    lists are more suitable for scenarios where dynamic resizing and frequent modifications
    are needed.</st> <st c="3427">In the following subsections, we will explore the
    key characteristics of arrays, particularly in relation to algorithm efficiency
    and the various operations that can be performed</st> <st c="3606">on them.</st>
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3026">在选择使用数组还是链表时，取决于应用程序的具体需求，比如插入和删除的频率与快速访问元素的需求之间的权衡。</st> <st c="3224">当快速访问和可预测的内存使用至关重要时，通常优先选择数组，而链表则更适用于需要动态调整大小和频繁修改的场景。</st>
    <st c="3427">在接下来的小节中，我们将探讨数组的关键特性，特别是在算法效率和可以执行的各种操作方面。</st> <st c="3606">。</st>
- en: <st c="3614">Arrays</st>
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="3614">数组</st>
- en: <st c="3621">An</st> **<st c="3625">array</st>** <st c="3630">is</st> <st c="3634">a
    fundamental data structure that consists of a collection of elements, each identified
    by</st> <st c="3725">at least one array index or key.</st> <st c="3758">Arrays
    are one of the simplest and most widely used data structures in computer science.</st>
    <st c="3847">They are typically used to store a fixed-size sequence of elements
    of the same type.</st> <st c="3932">The position of each element is defined by
    its index, which usually starts</st> <st c="4007">from zero.</st>
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3621">一个</st> **<st c="3625">数组</st>** <st c="3630">是一个基本的数据结构，由一组元素组成，每个元素通过</st>
    <st c="3725">至少一个数组索引或键来标识。</st> <st c="3758">数组是计算机科学中最简单且最广泛使用的数据结构之一。</st>
    <st c="3847">它们通常用于存储相同类型的固定大小的元素序列。</st> <st c="3932">每个元素的位置由其索引定义，通常从零开始。</st>
- en: <st c="4017">Arrays possess the</st> <st c="4036">following</st> <st c="4047">defining
    characteristics that influence their behavior</st> <st c="4102">and performance:</st>
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4017">数组具有以下</st> <st c="4036">定义特征，影响它们的行为</st> <st c="4047">和性能：</st>
- en: '**<st c="4118">Fixed size</st>**<st c="4129">: Once an array is created, its
    size is set and cannot be altered.</st> <st c="4197">This means that the number
    of elements that an array can hold is predetermined at the time of its creation.</st>
    <st c="4305">For example, in most programming languages, we must specify the size
    of an array when it is declared, such as</st> **<st c="4415">int[] a = new int[10];</st>**
    <st c="4437">in Java, which creates an array that can hold 10 integers.</st> <st
    c="4497">The following is a simple array declaration</st> <st c="4541">in Python:</st>'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="4118">固定大小</st>**<st c="4129">：一旦创建了数组，它的大小就被设置好，无法更改。</st> <st c="4197">这意味着数组能够容纳的元素数量在创建时就已预定。</st>
    <st c="4305">例如，在大多数编程语言中，我们必须在声明数组时指定数组的大小，例如</st> **<st c="4415">int[] a = new
    int[10];</st>** <st c="4437">在Java中，这会创建一个能够容纳10个整数的数组。</st> <st c="4497">以下是一个简单的数组声明</st>
    <st c="4541">在Python中的例子：</st>'
- en: '[PRE0]'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**<st c="4672">Contiguous memory allocation</st>**<st c="4701">: The elements
    of an array are stored in contiguous memory locations.</st> <st c="4772">This
    enables efficient access to any element by calculating its memory address using
    a simple mathematical formula.</st> <st c="4888">For instance, in a one-dimensional
    array</st> *<st c="4929">a</st>* <st c="4930">of size</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/477.png)<st
    c="4939"><st c="4940">, the address of the element</st> *<st c="4969">a[i]</st>*
    <st c="4973">can be calculated as</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>b</mi><mi>a</mi><mi>s</mi><mi>e</mi><mo>+</mo><mi>i</mi><mi
    mathvariant="normal">*</mi><mi>l</mi><mi>e</mi><mi>n</mi><mi>g</mi><mi>t</mi><mi>h</mi></mrow></mrow></math>](img/1795.png)<st
    c="4995"><st c="5013">, where</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>b</mml:mi><mml:mi>a</mml:mi><mml:mi>s</mml:mi><mml:mi>e</mml:mi></mml:math>](img/1796.png)
    <st c="5021"><st c="5026">is the base memory address,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi></mml:math>](img/701.png)
    <st c="5054"><st c="5055">is the index of the element in the array</st> *<st c="5097">a</st>*<st
    c="5098">, and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>l</mml:mi><mml:mi>e</mml:mi><mml:mi>n</mml:mi><mml:mi>g</mml:mi><mml:mi>t</mml:mi><mml:mi>h</mml:mi></mml:math>](img/1798.png)
    <st c="5104"><st c="5111">is the size of each element in the array.</st> <st c="5153">For
    example, it is 1 for 1 byte, 2 for 16 bits or words, and so on.</st> *<st c="5221">Table
    12.1</st>* <st c="5231">illustrates a simple example of</st> <st c="5264">an array.</st></st></st></st></st></st>'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="4672">连续内存分配</st>**<st c="4701">：数组的元素存储在连续的内存位置中。</st> <st c="4772">这使得通过简单的数学公式计算内存地址，从而高效地访问任何元素成为可能。</st>
    <st c="4888">例如，在一个一维数组</st> *<st c="4929">a</st>* <st c="4930">，其大小为</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/477.png)<st
    c="4939"><st c="4940">，元素的地址</st> *<st c="4969">a[i]</st>* <st c="4973">可以通过以下公式计算：</st>
    ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>b</mi><mi>a</mi><mi>s</mi><mi>e</mi><mo>+</mo><mi>i</mi><mi
    mathvariant="normal">*</mi><mi>l</mi><mi>e</mi><mi>n</mi><mi>g</mi><mi>t</mi><mi>h</mi></mrow></mrow></math>](img/1795.png)<st
    c="4995"><st c="5013">，其中</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>b</mml:mi><mml:mi>a</mml:mi><mml:mi>s</mml:mi><mml:mi>e</mml:mi></mml:math>](img/1796.png)
    <st c="5021"><st c="5026">是基地址，</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>i</mml:mi></mml:math>](img/701.png)
    <st c="5054"><st c="5055">是数组中元素的索引</st> *<st c="5097">a</st>*<st c="5098">，而</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>l</mml:mi><mml:mi>e</mml:mi><mml:mi>n</mml:mi><mml:mi>g</mml:mi><mml:mi>t</mml:mi><mml:mi>h</mml:mi></mml:math>](img/1798.png)
    <st c="5104"><st c="5111">是数组中每个元素的大小。</st> <st c="5153">例如，对于1字节的元素，大小为1；对于16位或字的元素，大小为2，等等。</st>
    *<st c="5221">表12.1</st>* <st c="5231">展示了一个简单的数组示例。</st></st></st></st></st></st>'
- en: '| <st c="5273">Memory address</st> | <st c="5288">FF01</st> | <st c="5293">FF02</st>
    | <st c="5298">FF03</st> | <st c="5303">FF04</st> | <st c="5308">FF05</st> | <st
    c="5313">FF06</st> |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| <st c="5273">内存地址</st> | <st c="5288">FF01</st> | <st c="5293">FF02</st>
    | <st c="5298">FF03</st> | <st c="5303">FF04</st> | <st c="5308">FF05</st> | <st
    c="5313">FF06</st> |'
- en: '| <st c="5318">Content</st> | <st c="5326">23</st> | <st c="5329">123</st>
    | <st c="5333">54</st> | <st c="5336">67</st> | <st c="5339">34</st> | <st c="5342">87</st>
    |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| <st c="5318">内容</st> | <st c="5326">23</st> | <st c="5329">123</st> | <st
    c="5333">54</st> | <st c="5336">67</st> | <st c="5339">34</st> | <st c="5342">87</st>
    |'
- en: '| <st c="5345">Index</st> | <st c="5351">0</st> | <st c="5353">1</st> | <st
    c="5354">2</st> | <st c="5355">3</st> | <st c="5356">4</st> | <st c="5357">5</st>
    |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| <st c="5345">索引</st> | <st c="5351">0</st> | <st c="5353">1</st> | <st c="5354">2</st>
    | <st c="5355">3</st> | <st c="5356">4</st> | <st c="5357">5</st> |'
- en: '<st c="5358">Table 12.1: An example array</st>'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5358">表12.1：一个数组示例</st>
- en: '**<st c="5386">Homogeneous elements</st>**<st c="5407">: All elements in an
    array must be of the same data type, ensuring that the array is a uniform collection.</st>
    <st c="5515">For example, an array of integers</st> **<st c="5549">int[]</st>**
    <st c="5554">can only store integer values, and an array of strings</st> **<st
    c="5610">String[]</st>** <st c="5618">can only store</st> <st c="5634">string
    values.</st>'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="5386">同质元素</st>**<st c="5407">：数组中的所有元素必须具有相同的数据类型，确保数组是一个统一的集合。</st>
    <st c="5515">例如，整数数组</st> **<st c="5549">int[]</st>** <st c="5554">只能存储整数值，而字符串数组</st>
    **<st c="5610">String[]</st>** <st c="5618">只能存储</st> <st c="5634">字符串值。</st>'
- en: '**<st c="5648">Indexed access</st>**<st c="5663">: Arrays</st> <st c="5672">allow
    direct access to any element using its index, providing constant-time access,
    which is one of the key advantages of this data structure.</st> <st c="5816">Accessing
    the third element in an array</st> *<st c="5856">a</st>* <st c="5857">is as simple
    as</st> *<st c="5874">a</st>* <st c="5875">[2].</st>'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="5648">索引访问</st>**<st c="5663">：数组</st> <st c="5672">允许通过索引直接访问任何元素，提供常数时间的访问，这是这种数据结构的主要优势之一。</st>
    <st c="5816">访问数组中的第三个元素</st> *<st c="5856">a</st>* <st c="5857">就像是</st> *<st
    c="5874">a</st>* <st c="5875">[2]一样简单。</st>'
- en: <st c="5880">Arrays</st> <st c="5888">support a variety of operations, each
    with its own performance implications.</st> <st c="5965">Here are the</st> <st
    c="5977">major operations commonly performed on arrays, along with their</st>
    <st c="6042">time complexities:</st>
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5880">数组</st> <st c="5888">支持多种操作，每种操作都有其独特的性能影响。</st> <st c="5965">以下是</st>
    <st c="5977">常见的数组操作及其</st> <st c="6042">时间复杂度：</st>
- en: '**<st c="6060">Insertion</st>**<st c="6070">: This</st> <st c="6078">refers
    to adding a new element to the array.</st> <st c="6123">For example, consider</st>
    **<st c="6145">a = [1, 2, 3, 4]</st>**<st c="6161">. Inserting</st> **<st c="6173">5</st>**
    <st c="6174">at the end of the array is straightforward if there is space.</st>
    <st c="6237">However, inserting</st> **<st c="6256">5</st>** <st c="6257">at index</st>
    **<st c="6267">1</st>** <st c="6268">requires shifting all elements from index</st>
    **<st c="6311">1</st>** <st c="6312">to the right.</st> <st c="6327">The time
    complexity of insertion in arrays is</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1799.png)
    <st c="6373"><st c="6374">in the best case and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1294.png)
    <st c="6396"><st c="6397">in the worst case.</st> <st c="6417">The best case is
    inserting at the end in a partially filled array.</st> <st c="6484">If inserting
    at the beginning or middle, requires shifting of elements, it is the worst case.</st>
    <st c="6578">The following is a</st> <st c="6597">Python example:</st>'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="6060">插入</st>**<st c="6070">：这是指向数组中添加新元素。</st> <st c="6123">例如，考虑</st>
    **<st c="6145">a = [1, 2, 3, 4]</st>**<st c="6161">。如果有空间，将</st> **<st c="6173">5</st>**
    <st c="6174">插入数组的末尾是非常直接的。</st> <st c="6237">然而，若要将</st> **<st c="6256">5</st>**
    <st c="6257">插入到索引</st> **<st c="6267">1</st>** <st c="6268">，则需要将索引</st> **<st
    c="6311">1</st>** <st c="6312">到右边的所有元素移动。</st> <st c="6327">数组插入操作的时间复杂度是</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1799.png)
    <st c="6373"><st c="6374">在最佳情况下，时间复杂度为</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1294.png)
    <st c="6396"><st c="6397">在最坏情况下，时间复杂度为</st>。</st> <st c="6417">最佳情况是在部分填充的数组末尾插入元素。</st>
    <st c="6484">如果是在数组的开头或中间插入，则需要移动元素，属于最坏情况。</st> <st c="6578">以下是一个</st> <st c="6597">Python示例：</st>'
- en: '[PRE1]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: <st c="6681">Since Python uses zero-based indexing, the</st> `<st c="6725">a.insert(1,
    5)</st>` <st c="6739">operation inserts the value into the second position of</st>
    <st c="6796">the array.</st></st></st>
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="6681">由于Python使用零索引，因此</st> `<st c="6725">a.insert(1, 5)</st>` <st c="6739">操作会将值插入数组的第二个位置。</st></st></st>
- en: '**<st c="6806">Deletion</st>**<st c="6815">: This</st> <st c="6823">involves
    removing an element from the array.</st> <st c="6868">Given</st> **<st c="6874">a
    = [1, 2, 3, 4]</st>**<st c="6890">, deleting element</st> **<st c="6909">2</st>**
    <st c="6910">at index</st> **<st c="6920">1</st>** <st c="6921">requires shifting
    all elements after index</st> **<st c="6965">1</st>** <st c="6966">to the left
    to fill the gap.</st> <st c="6996">In the best case, deleting the last element
    has a time complexity of</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1425.png)<st
    c="7065"><st c="7066">. However, if we delete an element from the beginning or
    middle of the array, it requires shifting the subsequent elements, resulting</st>
    <st c="7200">in a worst-case time complexity</st> <st c="7232">of</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/995.png)<st
    c="7235"><st c="7236">:</st>'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="6806">删除</st>**<st c="6815">: 删除</st> <st c="6823">是指从数组中移除一个元素。</st>
    <st c="6868">假设有</st> **<st c="6874">a = [1, 2, 3, 4]</st>**<st c="6890">，删除索引</st>
    **<st c="6909">2</st>** <st c="6910">处的元素</st> **<st c="6920">1</st>** <st c="6921">需要将索引</st>
    **<st c="6965">1</st>** <st c="6966">之后的所有元素向左移动，以填补空缺。</st> <st c="6996">在最好的情况下，删除最后一个元素的时间复杂度为</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1425.png)<st
    c="7065"><st c="7066">。然而，如果我们删除数组开头或中间的元素，则需要将随后的元素移动，导致最坏情况下的时间复杂度为</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/995.png)<st
    c="7235"><st c="7236">：</st>'
- en: '[PRE2]</st></st>'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[PRE2]</st>'
- en: '**<st c="7285">Edit or update</st>**<st c="7300">: Editing is</st> <st c="7314">modifying
    an existing element in the array.</st> <st c="7358">Given</st> **<st c="7364">a
    = [1, 2, 3, 4]</st>**<st c="7380">, changing the element at index</st> **<st c="7412">2</st>**
    <st c="7413">from</st> **<st c="7419">3</st>** <st c="7420">to</st> **<st c="7424">5</st>**
    <st c="7425">is a direct</st> <st c="7438">operation.</st> <st c="7449">We can
    directly access the element by its index and update it, which makes its time</st>
    <st c="7533">complexity</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1046.png)<st
    c="7544"><st c="7545">:</st>'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="7285">编辑或更新</st>**<st c="7300">: 编辑是</st> <st c="7314">修改数组中现有元素的操作。</st>
    <st c="7358">假设有</st> **<st c="7364">a = [1, 2, 3, 4]</st>**<st c="7380">，将索引</st>
    **<st c="7412">2</st>** <st c="7413">处的元素</st> **<st c="7419">3</st>** <st c="7420">改为</st>
    **<st c="7424">5</st>** <st c="7425">是一个直接的</st> <st c="7438">操作。</st> <st c="7449">我们可以通过索引直接访问该元素并更新它，因此其时间复杂度为</st>
    <st c="7533">!<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math></st><st
    c="7544"><st c="7545">:</st>'
- en: '[PRE3]</st>'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[PRE3]</st>'
- en: '**<st c="7597">Search</st>**<st c="7604">: Searching</st> <st c="7616">involves
    finding a specific element within an array.</st> <st c="7670">This topic was covered
    extensively in</st> [*<st c="7708">Chapter 7</st>*](B22248_07_split_000.xhtml#_idTextAnchor103)<st
    c="7717">, where most of the search algorithms discussed were based on arrays
    as the underlying data structure.</st> <st c="7820">In</st> [*<st c="7823">Chapter
    13</st>*](B22248_13.xhtml#_idTextAnchor200)<st c="7833">, we will explore how
    searching can be performed on non-linear data structures, such</st> <st c="7918">as
    trees.</st>'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="7597">搜索</st>**<st c="7604">: 搜索</st> <st c="7616">是指在数组中查找特定元素。</st>
    <st c="7670">这一主题在</st> [*<st c="7708">第7章</st>*](B22248_07_split_000.xhtml#_idTextAnchor103)<st
    c="7717">中进行了广泛讨论，讨论的多数搜索算法是基于数组作为底层数据结构的。</st> <st c="7820">在</st> [*<st c="7823">第13章</st>*](B22248_13.xhtml#_idTextAnchor200)<st
    c="7833">中，我们将探讨如何在非线性数据结构上进行搜索，如树形结构。</st>'
- en: '**<st c="7927">Access</st>**<st c="7934">: Access</st> <st c="7944">refers
    to retrieving the value of an element at a specific index</st> <st c="8009">in
    an array.</st> <st c="8022">One of the key advantages of arrays is that their
    access time is constant (</st>![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1804.png)<st
    c="8097"><st c="8099">), allowing any element to be directly retrieved by its
    index without the need</st> <st c="8178">for traversal.</st></st>'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="7927">访问</st>**<st c="7934">：访问</st> <st c="7944">指的是在数组中特定索引处检索元素的值。</st>
    <st c="8009">数组的一个关键优势之一是其访问时间是常数时间（</st>![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1804.png)<st
    c="8097"><st c="8099">），允许直接通过其索引检索任何元素，无需遍历。</st>'
- en: <st c="8192">Arrays can be implemented in more sophisticated structures.</st>
    <st c="8253">One example is</st> `<st c="8292">list</st>` <st c="8296">in Python).</st>
    <st c="8309">These</st> <st c="8314">arrays can resize themselves when elements
    are added beyond the initial capacity.</st> <st c="8397">However, the underlying
    principle remains the same, with arrays providing efficient access and traversal.</st>
    <st c="8503">Another</st> <st c="8510">example is</st> **<st c="8522">multidimensional
    arrays</st>**<st c="8545">. These arrays can be extended into multiple dimensions,
    such as 2D arrays (matrices) or 3D arrays, which are particularly useful in applications
    such as image processing, scientific simulations, and game development.</st> <st
    c="8763">The following is an example 2D array</st> <st c="8800">in Python:</st>
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="8192">数组可以在更复杂的结构中实现。</st> <st c="8253">一个例子是</st> `<st c="8292">列表</st>`
    <st c="8296">在Python中）。</st> <st c="8309">这些</st> <st c="8314">数组可以在元素添加到初始容量之外时调整大小。</st>
    <st c="8397">然而，其基本原理保持不变，数组提供了高效的访问和遍历。</st> <st c="8503">另一个</st> <st c="8510">例子是</st>
    **<st c="8522">多维数组</st>**<st c="8545">。这些数组可以扩展到多个维度，如2D数组（矩阵）或3D数组，在图像处理、科学模拟和游戏开发等应用中特别有用。</st>
    <st c="8763">以下是Python中的一个2D数组示例</st> <st c="8800">：</st>
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '**<st c="8926">Arrays</st>** <st c="8933">are a</st> <st c="8939">fundamental</st>
    <st c="8952">and highly efficient data structure for storing and managing collections
    of elements, especially when the size of the collection is known and remains constant.</st>
    <st c="9112">Their contiguous memory allocation allows for fast access and straightforward
    implementation of various operations.</st> <st c="9228">However, their fixed size
    and potential inefficiencies in insertion and deletion make them less flexible
    compared to other data structures such as linked lists.</st> <st c="9389">Understanding
    the trade-offs and appropriate use cases for arrays is essential for effective
    algorithm design</st> <st c="9499">and implementation.</st>'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**<st c="8926">数组</st>** <st c="8933">是</st> <st c="8939">一种基本且高效的数据结构，用于存储和管理元素集合，特别是当集合的大小已知且保持恒定时。</st>
    <st c="9112">它们的连续内存分配使得访问快速，并且各种操作的实现直接明了。</st> <st c="9228">然而，它们的固定大小和插入、删除可能存在的低效性使得它们相比于其他数据结构如链表而言不够灵活。</st>
    <st c="9389">了解数组的权衡和适当的使用案例对于有效的算法设计和实现至关重要。</st>'
- en: <st c="9518">Linked lists</st>
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="9518">链表</st>
- en: '<st c="9531">A</st> **<st c="9534">linked list</st>** <st c="9545">is a</st>
    <st c="9550">linear</st> <st c="9557">data structure in which elements, called
    nodes, are arranged sequentially.</st> <st c="9633">Unlike arrays, linked lists
    do not store their elements in contiguous memory locations.</st> <st c="9721">Instead,
    each node in a linked list contains at least two parts: the data and a reference
    (or pointer) to the next node in the sequence.</st> <st c="9858">This structure
    allows linked lists to be dynamic in size, easily growing or shrinking as elements
    are added</st> <st c="9966">or removed.</st>'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="9531">链表</st> **<st c="9534">是</st>** <st c="9545">一种</st> <st c="9550">线性</st>
    <st c="9557">数据结构，其中元素（称为节点）按顺序排列。</st> <st c="9633">与数组不同，链表不在连续的内存位置存储其元素。</st>
    <st c="9721">相反，链表中的每个节点至少包含两个部分：数据和指向序列中下一个节点的引用（或指针）。</st> <st c="9858">这种结构允许链表在元素添加或删除时动态调整大小，轻松增长或缩小。</st>
- en: <st c="9977">Linked lists have several</st> <st c="10003">key characteristics
    that distinguish them from other data structures such</st> <st c="10078">as arrays:</st>
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="9977">链表有几个</st> <st c="10003">关键特点，使其与其他数据结构（如数组）区分开来：</st>
- en: '**<st c="10088">Dynamic size</st>**<st c="10101">: Linked lists can dynamically
    increase or decrease in size, as nodes can be added or removed as needed without
    reallocating or reorganizing the entire data structure.</st> <st c="10270">For
    example, we can continue adding nodes to a linked list without worrying about
    a</st> <st c="10354">predefined size.</st>'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="10088">动态大小</st>**<st c="10101">：链表的大小可以动态增长或缩小，因为节点可以根据需要添加或删除，而无需重新分配或重新组织整个数据结构。</st>
    <st c="10270">例如，我们可以继续向链表中添加节点，而不必担心预先定义的大小。</st>'
- en: '**<st c="10370">Non-contiguous memory allocation</st>**<st c="10403">: Unlike
    arrays, linked lists do not require contiguous memory locations.</st> <st c="10478">Each
    node is stored independently in memory and linked together using pointers.</st>
    <st c="10558">For instance, in a singly linked list, each node contains a pointer
    to the next node, allowing elements to be scattered</st> <st c="10678">throughout
    memory.</st>'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="10370">非连续内存分配</st>**<st c="10403">：与数组不同，链表不要求连续的内存位置。</st> <st c="10478">每个节点都独立存储在内存中，并通过指针连接在一起。</st>
    <st c="10558">例如，在单向链表中，每个节点包含指向下一个节点的指针，这样元素就可以分散存储在内存中。</st> <st c="10678">通过内存分布。</st>'
- en: '**<st c="10696">Sequential access</st>**<st c="10714">: Linked lists must be
    accessed sequentially from the beginning, as there is no direct way to access
    a specific element by index.</st> <st c="10845">For example, to access the third
    element in a linked list, we must traverse the first</st> <st c="10931">two nodes.</st>'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="10696">顺序访问</st>**<st c="10714">：链表必须从头开始顺序访问，因为没有直接通过索引访问特定元素的方法。</st>
    <st c="10845">例如，要访问链表中的第三个元素，我们必须先遍历前两个节点。</st>'
- en: '**<st c="10941">Variants</st>**<st c="10950">: Linked lists</st> <st c="10965">come
    in different forms, including singly linked lists (where each node points to the
    next), doubly linked lists (where each node points to both the next and previous
    nodes), and circular linked lists (where the last node points back to the first).</st>
    <st c="11215">For example, in a doubly linked list, traversal can happen in both
    directions due to the pointers to both the previous and</st> <st c="11338">next
    nodes.</st>'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="10941">变种</st>**<st c="10950">：链表</st> <st c="10965">有不同的形式，包括单向链表（每个节点指向下一个节点）、双向链表（每个节点指向下一个节点和上一个节点）以及循环链表（最后一个节点指向第一个节点）。</st>
    <st c="11215">例如，在双向链表中，由于每个节点都有指向前后节点的指针，因此可以在两个方向上进行遍历。</st> <st c="11338">下一个节点。</st>'
- en: <st c="11349">Linked lists support various operations, each with specific performance
    characteristics.</st> <st c="11439">Let’s review the major operations, along with
    their time complexities</st> <st c="11509">and examples.</st>
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="11349">链表支持各种操作，每个操作具有特定的性能特征。</st> <st c="11439">让我们回顾一下主要操作及其时间复杂度</st>
    <st c="11509">和示例。</st>
- en: <st c="11522">Insertion in a linked list</st>
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="11522">链表插入</st>
- en: <st c="11549">Consider</st> <st c="11558">this linked list:</st> `<st c="11577">24</st>`
    <st c="11579">→</st> `<st c="11582">3</st>` <st c="11583">→</st> `<st c="11586">12</st>`
    <st c="11588">→</st> `<st c="11591">17</st>`<st c="11593">. If we want to insert
    the value</st> `<st c="11626">8</st>` <st c="11627">between</st> `<st c="11636">3</st>`
    <st c="11637">and</st> `<st c="11642">12</st>`<st c="11644">, the process involves
    creating a new node with the value</st> `<st c="11702">3</st>` <st c="11703">and
    updating the pointers accordingly.</st> <st c="11743">Here’s how we can do it
    step</st> <st c="11772">by step:</st>
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="11549">考虑</st> <st c="11558">这个链表：</st> `<st c="11577">24</st>` <st c="11579">→</st>
    `<st c="11582">3</st>` <st c="11583">→</st> `<st c="11586">12</st>` <st c="11588">→</st>
    `<st c="11591">17</st>`<st c="11593">。如果我们想将值</st> `<st c="11626">8</st>` <st
    c="11627">插入</st> `<st c="11636">3</st>` <st c="11637">和</st> `<st c="11642">12</st>`<st
    c="11644">之间，过程包括创建一个新节点，节点值为</st> `<st c="11702">8</st>` <st c="11703">并相应地更新指针。</st>
    <st c="11743">下面是逐步操作：</st> <st c="11772">步骤：</st>
- en: '**<st c="11780">Create the new node</st>**<st c="11800">: First, we create
    a new node that contains the value</st> **<st c="11855">8</st>**<st c="11856">.
    Initially, the pointer of this new node is set to</st> **<st c="11908">null</st>**<st
    c="11912">, as it does not point to</st> <st c="11938">anything yet.</st>'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**<st c="11780">创建新节点</st>**<st c="11800">：首先，我们创建一个包含值</st> **<st c="11855">8</st>**<st
    c="11856">的新节点。初始时，这个新节点的指针被设置为</st> **<st c="11908">null</st>**<st c="11912">，因为它尚未指向任何内容。</st>'
- en: '**<st c="11951">Update the pointer of the new node</st>**<st c="11986">: Next,
    set the pointer of the new node to point to the node that comes after</st> **<st
    c="12065">3</st>**<st c="12066">, which is the node containing</st> **<st c="12097">12</st>**<st
    c="12099">. Now, the new node</st> **<st c="12119">3</st>** <st c="12120">is connected
    to</st> <st c="12137">node</st> **<st c="12142">4</st>**<st c="12143">.</st>'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**<st c="11951">更新新节点的指针</st>**<st c="11986">：接下来，将新节点的指针设置为指向下一个节点，</st> **<st
    c="12065">3</st>**<st c="12066">，即包含</st> **<st c="12097">12</st>**<st c="12099">的节点。现在，新节点</st>
    **<st c="12119">3</st>** <st c="12120">已连接到</st> <st c="12137">节点</st> **<st c="12142">4</st>**<st
    c="12143">。</st>'
- en: '**<st c="12144">Update the pointer of the previous node</st>**<st c="12184">:
    Finally, update the pointer of the node containing</st> **<st c="12238">3</st>**
    <st c="12239">to point to the new node</st> **<st c="12265">8</st>**<st c="12266">.
    This completes the insertion, resulting in the linked</st> **<st c="12322">list
    24</st>** <st c="12329">→</st> **<st c="12332">3</st>** <st c="12333">→</st> **<st
    c="12336">8</st>** <st c="12337">→</st> **<st c="12340">12</st>** <st c="12342">→</st>
    **<st c="12345">17</st>**<st c="12347">.</st>'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**<st c="12144">更新前一个节点的指针</st>**<st c="12184">：最后，更新包含</st> **<st c="12238">3</st>**
    <st c="12239">的节点的指针，使其指向新节点</st> **<st c="12265">8</st>**<st c="12266">。这完成了插入，结果是链表</st>
    **<st c="12322">24</st>** <st c="12329">→</st> **<st c="12332">3</st>** <st c="12333">→</st>
    **<st c="12336">8</st>** <st c="12337">→</st> **<st c="12340">12</st>** <st c="12342">→</st>
    **<st c="12345">17</st>**<st c="12347">。</st>'
- en: '*<st c="12348">Figure 12</st>**<st c="12358">.1</st>* <st c="12361">illustrates
    the process of inserting a new node in</st> <st c="12412">linked lists.</st>'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*<st c="12348">图12.1</st>* <st c="12361">展示了在</st> <st c="12412">链表中插入新节点的过程。</st>'
- en: '![Figure 12.1: The process of adding a new node to a linked list in three steps](img/B22248_12_1.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图12.1：在三步中向链表添加新节点的过程](img/B22248_12_1.jpg)'
- en: '<st c="12540">Figure 12.1: The process of adding a new node to a linked list
    in three steps</st>'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="12540">图12.1：在三步中向链表添加新节点的过程</st>
- en: <st c="12617">In</st> *<st c="12621">Figure 12</st>**<st c="12630">.1</st>*<st
    c="12632">,</st> *<st c="12634">Link</st>* <st c="12638">represents</st> <st c="12649">the
    pointer to the</st> `<st c="12710">24</st>`<st c="12712">).</st> <st c="12716">The
    last node, referred to as the</st> `<st c="12776">17</st>`<st c="12778">), points
    to</st> `<st c="12792">null</st>`<st c="12796">, indicating the end of the list.</st>
    <st c="12830">We represent a pointer to</st> `<st c="12856">null</st>` <st c="12860">with
    the</st> `<st c="12870">/</st>` <st c="12871">symbol.</st> <st c="12880">The address
    of the newly created node is labeled as</st> `<st c="12932">New</st>`<st c="12935">,
    and initially, it points</st> <st c="12962">to</st> `<st c="12965">null</st>`<st
    c="12969">.</st>
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="12617">在</st> *<st c="12621">图12.1</st>*<st c="12632">中，</st> *<st c="12634">Link</st>*
    <st c="12638">表示指向</st> `<st c="12710">24</st>`<st c="12712">的指针。</st> <st c="12716">最后一个节点，称为</st>
    `<st c="12776">17</st>`<st c="12778">)，指向</st> `<st c="12792">null</st>`<st c="12796">，表示链表的结束。</st>
    <st c="12830">我们用</st> `<st c="12856">null</st>` <st c="12860">表示一个指向</st> `<st
    c="12870">/</st>` <st c="12871">符号的指针。</st> <st c="12880">新创建的节点的地址标记为</st> `<st
    c="12932">New</st>`<st c="12935">，初始时，它指向</st> `<st c="12965">null</st>`<st c="12969">。</st>
- en: <st c="12970">Here is a simple Python implementation of the</st> <st c="13017">preceding
    process:</st>
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="12970">这是一个简单的 Python 实现，展示了</st> <st c="13017">上述过程：</st>
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: <st c="13741">To test the</st> <st c="13753">functionality of both the</st>
    `<st c="13780">Node</st>` <st c="13784">class and the</st> `<st c="13799">LinkedList</st>`
    <st c="13809">class, we can use the</st> <st c="13832">following example:</st>
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13741">为了测试</st> <st c="13753">`Node` 类和 `LinkedList` 类的功能，我们可以使用以下示例：</st>
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: <st c="14152">Let’s briefly explain</st> <st c="14175">the code:</st>
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="14152">让我们简要解释一下</st> <st c="14175">这段代码：</st>
- en: '**<st c="14184">Node</st>**<st c="14189">: Each</st> **<st c="14197">Node</st>**
    <st c="14201">object stores a</st> **<st c="14218">data</st>** <st c="14222">value
    and a</st> **<st c="14235">next</st>** <st c="14239">pointer in the next node
    in the</st> <st c="14272">linked list.</st>'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="14184">Node</st>**<st c="14189">：每个</st> **<st c="14197">Node</st>**
    <st c="14201">对象存储一个</st> **<st c="14218">数据</st>** <st c="14222">值和一个</st> **<st
    c="14235">指向下一个节点的</st>** <st c="14239">指针，在</st> <st c="14272">链表中。</st>'
- en: '**<st c="14284">LinkedList</st>**<st c="14295">: The</st> **<st c="14302">LinkedList</st>**
    <st c="14312">class manages the linked list, including the</st> <st c="14358">insertion
    operation.</st>'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="14284">LinkedList</st>**<st c="14295">：`LinkedList`</st> **<st c="14302">类管理链表，包括</st>**
    <st c="14358">插入操作。</st>'
- en: '**<st c="14378">insert_after</st>**<st c="14391">: This method inserts a new
    node after a given node (</st>**<st c="14445">prev_node</st>**<st c="14455">).</st>
    <st c="14459">The new node is created with the</st> **<st c="14492">new_data</st>**
    <st c="14500">value, and pointers are updated to insert it correctly into</st>
    <st c="14561">the list.</st>'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="14378">insert_after</st>**<st c="14391">：该方法在给定节点（</st>**<st c="14445">prev_node</st>**<st
    c="14455">）后插入新节点。</st><st c="14459">新节点的数据为</st> **<st c="14492">new_data</st>**
    <st c="14500">，并且更新指针以正确插入到</st> <st c="14561">链表中。</st>'
- en: '**<st c="14570">print_list</st>**<st c="14581">: This method traverses the
    linked list and prints the data of</st> <st c="14645">each node.</st>'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="14570">print_list</st>**<st c="14581">：该方法遍历链表并打印每个节点的数据。</st>'
- en: <st c="14655">The time</st> <st c="14665">complexity of insertion in a linked
    list is</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1805.png)
    <st c="14709"><st c="14710">in the best case, such as when inserting at the beginning
    or end of the list if the position is already known.</st> <st c="14822">In the
    worst case, when inserting at a specific position requires traversal through the
    list, the time complexity</st> <st c="14936">is</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/995.png)<st
    c="14939"><st c="14940">.</st></st></st>
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="14655">链表中插入操作的时间复杂度为</st> <st c="14665">![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1805.png)<st
    c="14709">，最佳情况下，例如在链表开头或结尾插入时，如果位置已知。</st> <st c="14822">最坏情况下，如果需要通过链表遍历特定位置进行插入，时间复杂度为</st>
    <st c="14936">![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/995.png)<st
    c="14939">。</st>
- en: <st c="14941">Deletion in linked lists</st>
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="14941">链表中的删除操作</st>
- en: <st c="14966">Deletion from a linked</st> <st c="14989">list involves removing
    a specific node.</st> <st c="15030">For instance, given the</st> `<st c="15054">24</st>`
    <st c="15056">→</st> `<st c="15059">3</st>` <st c="15060">→</st> `<st c="15063">12</st>`
    <st c="15065">→</st> `<st c="15068">17</st>` <st c="15070">linked list, deleting
    the node with the value</st> `<st c="15117">3</st>` <st c="15118">requires bypassing
    it by updating the pointer of the previous node (</st>`<st c="15187">2</st>`<st
    c="15189">) to point to the next node (</st>`<st c="15218">4</st>`<st c="15220">).</st>
    <st c="15223">Like insertion, the time complexity of the deletion operation in
    linked lists depends on the location of the node to be deleted.</st> <st c="15352">In
    the worst case, when traversal is needed to find the node, the time complexity
    is</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1071.png)<st
    c="15437"><st c="15438">.</st> *<st c="15440">Figure 12</st>**<st c="15449">.2</st>*
    <st c="15451">illustrates the deleting process in the example</st> <st c="15500">link
    list.</st></st>
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="14966">链表中的删除操作涉及删除特定节点。</st> <st c="14989">例如，给定链表</st> `<st c="15054">24</st>`
    <st c="15056">→</st> `<st c="15059">3</st>` <st c="15060">→</st> `<st c="15063">12</st>`
    <st c="15065">→</st> `<st c="15068">17</st>` <st c="15070">，删除值为</st> `<st c="15117">3</st>`
    <st c="15118">的节点需要通过更新前一个节点（</st>`<st c="15187">2</st>`<st c="15189">）的指针来绕过它（</st>`<st
    c="15218">4</st>`<st c="15220">）。</st> <st c="15223">与插入类似，链表中删除操作的时间复杂度取决于要删除节点的位置。</st>
    <st c="15352">最坏情况下，需要遍历查找节点，时间复杂度为</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1071.png)<st
    c="15437">。</st> *<st c="15440">图 12</st>**<st c="15449">.2</st>* <st c="15451">展示了示例链表中的删除过程。</st></st>
- en: '![Figure 12.2: The process of deleting a node in a linked list](img/B22248_12_2.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.2：链表中删除节点的过程](img/B22248_12_2.jpg)'
- en: '<st c="15545">Figure 12.2: The process of deleting a node in a linked list</st>'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="15545">图 12.2：链表中删除节点的过程</st>
- en: <st c="15605">In</st> *<st c="15609">Figure 12</st>**<st c="15618">.3</st>*<st
    c="15620">, the top part displays the linked list before the deletion of the node
    with the value</st> `<st c="15707">12</st>`<st c="15709">, while the bottom part
    shows the linked list after the deletion.</st> <st c="15775">The following is
    an</st> <st c="15794">example Python code for deleting a node in a</st> <st c="15840">linked
    list:</st>
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="15605">在</st> *<st c="15609">图12</st>**<st c="15618">.3</st>*<st c="15620">中，顶部部分显示了删除值为</st>
    `<st c="15707">12</st>`<st c="15709">的节点之前的链表，底部部分则显示了删除后的链表。</st> <st c="15775">以下是一个</st>
    <st c="15794">删除链表中节点的示例Python代码：</st>
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: <st c="16213">The</st> `<st c="16218">delete_node</st>` <st c="16229">function
    should be added to the</st> `<st c="16262">LinkedList</st>` <st c="16272">class
    in the</st> <st c="16286">previous section.</st>
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="16213">`<st c="16218">delete_node</st>` <st c="16229">函数应当添加到</st> `<st
    c="16262">LinkedList</st>` <st c="16272">类中，参见前一节。</st>
- en: <st c="16303">Edit in link lists</st>
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="16303">在链表中编辑</st>
- en: <st c="16322">Editing involves</st> <st c="16339">modifying the data within
    an existing node in the linked list.</st> <st c="16403">For instance, if we want
    to change the value of the second node from</st> `<st c="16472">2</st>` <st c="16473">to</st>
    `<st c="16477">5</st>` <st c="16478">in the</st> `<st c="16486">1</st>` <st c="16487">→</st>
    `<st c="16490">2</st>` <st c="16491">→</st> `<st c="16494">3</st>` <st c="16495">→</st>
    `<st c="16498">4</st>` <st c="16499">linked list, we would update the node’s data
    accordingly.</st> <st c="16558">The time complexity for this operation is</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1011.png)
    <st c="16600"><st c="16601">because we may need to traverse the list to locate
    the node to be updated.</st> <st c="16677">Here is a piece of sample Python code
    for the</st> <st c="16723">edit/update operation:</st></st>
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="16322">编辑操作涉及</st> <st c="16339">修改链表中现有节点的数据。</st> <st c="16403">例如，如果我们想将第二个节点的值从</st>
    `<st c="16472">2</st>` <st c="16473">改为</st> `<st c="16477">5</st>` <st c="16478">，那么在链表</st>
    `<st c="16486">1</st>` <st c="16487">→</st> `<st c="16490">2</st>` <st c="16491">→</st>
    `<st c="16494">3</st>` <st c="16495">→</st> `<st c="16498">4</st>` <st c="16499">中，我们需要相应地更新该节点的数据。</st>
    <st c="16558">这个操作的时间复杂度是</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1011.png)
    <st c="16600"><st c="16601">因为我们可能需要遍历链表来找到要更新的节点。</st> <st c="16677">以下是一个进行</st>
    <st c="16723">编辑/更新操作的示例Python代码：</st></st>
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: <st c="16974">The</st> `<st c="16979">update_node</st>` <st c="16990">function
    should be added to the</st> `<st c="17023">LinkedList</st>` <st c="17033">class
    in the</st> <st c="17047">previous section.</st>
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="16974">`<st c="16979">update_node</st>` <st c="16990">函数应当添加到</st> `<st
    c="17023">LinkedList</st>` <st c="17033">类中，参见前一节。</st>
- en: <st c="17064">Searching in linked lists</st>
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="17064">在链表中查找</st>
- en: <st c="17090">In</st> [*<st c="17094">Chapter 7</st>*](B22248_07_split_000.xhtml#_idTextAnchor103)<st
    c="17103">, we</st> <st c="17107">explored a variety of search algorithms in detail,
    all of which are based on arrays as the underlying data structure.</st> <st c="17226">For
    instance, in binary search, we can directly access an element at a specific index,
    such as the middle of the array.</st> <st c="17346">However, when using a linked
    list, finding a node with a specific value becomes more challenging due to the
    sequential nature of the data structure.</st> <st c="17495">This means that regardless
    of the search algorithm used, when applied to a singly linked list, the search
    essentially becomes a sequential, linear search.</st> <st c="17650">As a result,
    searching in a linked list has a time complexity</st> <st c="17712">of</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1809.png)<st
    c="17715"><st c="17716">.</st></st>
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="17090">In</st>` [*<st c="17094">第7章</st>*](B22248_07_split_000.xhtml#_idTextAnchor103)<st
    c="17103">，我们详细探讨了多种搜索算法，这些算法都基于数组作为底层数据结构。</st> <st c="17226">例如，在二分查找中，我们可以直接访问数组中特定索引处的元素，例如数组的中间元素。</st>
    <st c="17346">然而，当使用链表时，由于数据结构的顺序特性，找到具有特定值的节点变得更加困难。</st> <st c="17495">这意味着无论使用何种搜索算法，当应用于单链表时，搜索本质上变成了顺序的线性查找。</st>
    <st c="17650">因此，链表中的搜索时间复杂度为</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1809.png)<st
    c="17715"><st c="17716">.</st></st>'
- en: <st c="17717">Here is the Python code example using a singly</st> <st c="17765">linked
    list:</st>
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="17717">Here is the Python code example using a singly</st>` `<st c="17765">linked
    list:</st>`'
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: <st c="17979">The</st> `<st c="17984">search_node</st>` <st c="17995">function</st>
    <st c="18005">should be added to the</st> `<st c="18028">LinkedList</st>` <st
    c="18038">class in the</st> <st c="18052">previous section.</st>
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="17979">The</st>` `<st c="17984">search_node</st>` `<st c="17995">function</st>`
    `<st c="18005">should be added to the</st>` `<st c="18028">LinkedList</st>` `<st
    c="18038">class in the</st>` `<st c="18052">previous section.</st>`'
- en: <st c="18069">Access in link lists</st>
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`<st c="18069">Access in link lists</st>`'
- en: <st c="18090">This</st> <st c="18096">operation involves retrieving the value
    of a node at a specific position in the linked list.</st> <st c="18189">For example,
    accessing the fourth node in the</st> `<st c="18235">17</st>` <st c="18237">→</st>
    `<st c="18240">12</st>` <st c="18242">→</st> `<st c="18245">3</st>` <st c="18246">→</st>
    `<st c="18249">24</st>` <st c="18251">→</st> `<st c="18254">6</st>` <st c="18255">linked
    list requires sequential traversal to reach the desired node.</st> <st c="18325">The
    time complexity for this operation is</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1071.png)<st
    c="18367"><st c="18368">. The following is a simple Python code implementing access
    in a</st> <st c="18433">linked list:</st></st>
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="18090">This</st>` `<st c="18096">operation involves retrieving the
    value of a node at a specific position in the linked list.</st>` <st c="18189">例如，访问</st>
    `<st c="18235">17</st>` <st c="18237">→</st> `<st c="18240">12</st>` <st c="18242">→</st>
    `<st c="18245">3</st>` <st c="18246">→</st> `<st c="18249">24</st>` <st c="18251">→</st>
    `<st c="18254">6</st>` <st c="18255">链表中的第四个节点时，需要顺序遍历直到到达目标节点。</st> <st c="18325">此操作的时间复杂度为</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1071.png)<st
    c="18367"><st c="18368">。以下是一个实现链表访问的简单 Python 代码：</st></st>'
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: <st c="18670">The</st> `<st c="18675">get_nth</st>` <st c="18682">function should
    be added to the</st> `<st c="18715">LinkedList</st>` <st c="18725">class in the</st>
    <st c="18739">previous section.</st>
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="18670">The</st>` `<st c="18675">get_nth</st>` `<st c="18682">function
    should be added to the</st>` `<st c="18715">LinkedList</st>` `<st c="18725">class
    in the</st>` `<st c="18739">previous section.</st>`'
- en: <st c="18756">In practice, linked lists</st> <st c="18783">are commonly used
    as the underlying data structure for implementing stacks and queues due to their
    ability to dynamically resize.</st> <st c="18913">They are also employed in operating
    systems for managing memory allocation, where free memory blocks are linked together
    in a list.</st> <st c="19045">Another significant application of linked lists
    is in representing adjacency lists in graphs or trees, where each vertex points
    to a linked list of</st> <st c="19193">adjacent vertices.</st>
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="18756">在实际应用中，链表</st> <st c="18783">通常作为实现栈和队列的基础数据结构，因为它们具有动态调整大小的能力。</st>
    <st c="18913">它们也被操作系统用于内存分配管理，在这种情况下，空闲内存块被连接在一个链表中。</st> <st c="19045">链表的另一个重要应用是在图或树中表示邻接表，每个顶点指向一个包含</st>
    <st c="19193">邻接顶点的链表。</st>
- en: <st c="19211">Linked lists offer a flexible and dynamic alternative to arrays,
    especially in scenarios where the size of the data structure needs to change frequently.</st>
    <st c="19366">Their non-contiguous memory allocation allows for efficient insertions
    and deletions without the need to shift elements, unlike arrays.</st> <st c="19502">However,
    this flexibility comes with the drawback of sequential access times, making linked
    lists less suitable for applications that require frequent random access.</st>
    <st c="19668">Understanding the trade-offs between linked lists and other data
    structures, such as arrays, is essential for selecting the most appropriate structure
    for a given problem.</st> <st c="19840">In the next section, we will briefly explore
    other variants of</st> <st c="19903">linked lists.</st>
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="19211">链表提供了一个灵活且动态的替代数组的方案，特别是在数据结构需要频繁改变大小的场景中。</st> <st c="19366">它们的非连续内存分配允许高效的插入和删除操作，无需像数组那样移动元素。</st>
    <st c="19502">然而，这种灵活性也带来了顺序访问时间的问题，使得链表不太适合需要频繁随机访问的应用。</st> <st c="19668">理解链表与其他数据结构（如数组）之间的权衡，对于选择最合适的数据结构来解决特定问题至关重要。</st>
    <st c="19840">在下一节中，我们将简要探讨其他类型的</st> <st c="19903">链表。</st>
- en: <st c="19916">Doubly and circular linked lists</st>
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="19916">双向和循环链表</st>
- en: '<st c="19949">A</st> **<st c="19952">doubly linked list</st>** <st c="19970">is
    a</st> <st c="19975">type of linked list in which each node</st> <st c="20015">contains
    two pointers: one pointing to the next node and another pointing to the previous
    node (see</st> *<st c="20115">Figure 12</st>**<st c="20124">.3</st>*<st c="20126">).</st>
    <st c="20130">This bidirectional structure allows traversal of the list in both
    forward and backward directions, making certain operations more efficient.</st>
    <st c="20271">Although doubly linked lists allow bidirectional access, their sequential
    nature means that the time complexity for major operations remains similar to
    that of singly</st> <st c="20438">linked lists.</st>'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="19949">一个</st> **<st c="19952">双向链表</st>** <st c="19970">是</st> <st c="19975">一种链表类型，其中每个节点</st>
    <st c="20015">包含两个指针：一个指向下一个节点，另一个指向前一个节点（参见</st> *<st c="20115">图12</st>**<st
    c="20124">.3</st>*<st c="20126">）。</st> <st c="20130">这种双向结构允许在前向和反向方向上遍历链表，使得某些操作更加高效。</st>
    <st c="20271">尽管双向链表允许双向访问，但它们的顺序性质意味着主要操作的时间复杂度与单向链表类似。</st>
- en: '![Figure 12.3: An example doubly linked list](img/B22248_12_3.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图12.3：一个示例双向链表](img/B22248_12_3.jpg)'
- en: '<st c="20478">Figure 12.3: An example doubly linked list</st>'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="20478">图12.3：一个示例双向链表</st>
- en: <st c="20520">Another variation of</st> <st c="20542">the linked</st> <st c="20552">list
    is the</st> **<st c="20565">circular linked list</st>** <st c="20585">where the
    last node points back to the first node, forming a circular structure (see</st>
    *<st c="20671">Figure 12</st>**<st c="20680">.4</st>*<st c="20682">).</st> <st
    c="20686">This can be applied to both singly and doubly linked lists.</st> <st
    c="20746">Since the last node connects back to the first, we can traverse the
    list in a loop without encountering a null reference.</st> <st c="20868">This
    characteristic is ideal for applications where data needs to be looped through
    continuously, such as in round-robin scheduling or buffer management.</st> <st
    c="21022">Like</st> <st c="21027">doubly linked lists, circular linked lists do
    not provide any improvement in</st> <st c="21104">time complexity compared to
    non-circular</st> <st c="21145">linked lists.</st>
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="20520">另一种链表的变体是</st> <st c="20542">循环链表</st> <st c="20552">，其中最后一个节点指向第一个节点，形成一个循环结构（见</st>
    *<st c="20671">图 12</st>**<st c="20680">.4</st>*<st c="20682">）。</st> <st c="20686">这可以应用于单向链表和双向链表。</st>
    <st c="20746">由于最后一个节点连接回第一个节点，我们可以在不遇到空引用的情况下循环遍历链表。</st> <st c="20868">这一特性非常适用于需要持续循环遍历数据的应用场景，如轮询调度或缓冲区管理。</st>
    <st c="21022">与</st> <st c="21027">双向链表类似，循环链表在</st> <st c="21104">时间复杂度上并没有比非循环链表提供任何改进。</st>
    <st c="21145">链表。</st>
- en: '![Figure 12.4: A circular linked list](img/B22248_12_4.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.4：循环链表](img/B22248_12_4.jpg)'
- en: '<st c="21184">Figure 12.4: A circular linked list</st>'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="21184">图 12.4：循环链表</st>
- en: <st c="21219">Both doubly linked lists and circular linked lists offer distinct
    advantages depending on the use case.</st> <st c="21324">Doubly linked lists provide
    more flexibility in navigation and easier node removal, while circular linked
    lists enable efficient cyclic traversal of data.</st> <st c="21479">In terms of
    performance, both structures exhibit similar time complexities to singly linked
    lists but with added benefits in specific operations.</st> <st c="21625">In the
    next section, we will explore a data structure that combines the advantages of
    both linked lists</st> <st c="21729">and arrays.</st>
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="21219">双向链表和循环链表在不同的使用场景中各自具有独特的优势。</st> <st c="21324">双向链表在导航上提供了更大的灵活性，且节点移除更为容易，而循环链表则能够高效地进行数据的循环遍历。</st>
    <st c="21479">在性能方面，这两种结构的时间复杂度与单向链表相似，但在特定操作中具有额外的优势。</st> <st c="21625">在下一节中，我们将探讨一种结合了链表和数组优势的数据结构。</st>
    <st c="21729">和数组。</st>
- en: <st c="21740">Skip lists</st>
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="21740">跳表</st>
- en: '<st c="21751">As</st> <st c="21755">we discussed in the previous chapter, when
    studying data structures, it’s important to evaluate their performance in three
    key operations: insertion, deletion, and search.</st> <st c="21927">Arrays excel
    in searching, particularly when the data is already sorted, thanks to their direct
    (or random) access capabilities, which allow for sublinear time complexity.</st>
    <st c="22099">However, due to their static nature, arrays can present challenges
    when it comes to inserting new data or deleting existing data.</st> <st c="22229">On
    the other hand, linked lists exhibit the opposite behavior.</st> <st c="22292">Their
    dynamic allocation allows for easy insertion and deletion, but the lack of direct
    access means that searching, even in sorted data, becomes a sequential process
    with linear</st> <st c="22471">time complexity.</st>'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="21751">正如我们在上一章讨论的那样，在学习数据结构时，评估其在插入、删除和查找三项关键操作中的性能非常重要。</st> <st c="21927">数组在查找方面表现优异，特别是在数据已经排序的情况下，因为它们具备直接（或随机）访问能力，允许实现亚线性时间复杂度。</st>
    <st c="22099">然而，由于数组是静态的，当涉及到插入新数据或删除现有数据时，它们可能会带来挑战。</st> <st c="22229">另一方面，链表表现出相反的行为。</st>
    <st c="22292">它们的动态分配使得插入和删除变得容易，但由于缺乏直接访问，甚至在排序数据中，查找也变成了一个顺序过程，具有线性</st> <st
    c="22471">时间复杂度。</st>
- en: '<st c="22487">This question then arises: Is it possible to combine the benefits
    of both arrays and linked lists?</st> <st c="22587">In other words, can we achieve
    faster-than-sequential access, similar to arrays, while also enjoying the dynamic
    memory allocation of linked lists?</st> <st c="22735">The answer lies in the</st>
    **<st c="22758">skip list</st>**<st c="22767">. A</st> **<st c="22771">skip list</st>**
    <st c="22780">is a probabilistic data structure that extends the basic linked
    list by adding multiple levels of linked lists, allowing for faster search, insertion,
    and deletion operations.</st> <st c="22957">Each level of a skip list contains
    a subset of the elements from the level below, with the bottommost level containing
    all elements in a simple linked list.</st> <st c="23114">Higher levels act as
    “express lanes” to skip over multiple elements at once, hence the name</st> *<st
    c="23206">skip list</st>*<st c="23215">.</st> *<st c="23217">Figure 12</st>**<st
    c="23226">.6</st>* <st c="23228">illustrates an example of a skip list.</st> <st
    c="23268">Level 1 functions as a standard linked list, while all the upper levels
    serve as</st> <st c="23349">express lanes.</st>'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="22487">这个问题由此产生：是否有可能结合数组和链表的优点？</st> <st c="22587">换句话说，是否能像数组一样实现比顺序访问更快的访问，同时享受链表的动态内存分配优势？</st>
    <st c="22735">答案就在于</st> **<st c="22758">跳表</st>**<st c="22767">。跳表是一种概率数据结构，通过在基本链表的基础上增加多个链表层级，从而实现更快速的搜索、插入和删除操作。</st>
    <st c="22957">跳表的每一层包含来自下层的部分元素，最底层包含所有元素，形成一个简单的链表。</st> <st c="23114">更高的层级充当“快速通道”，一次跳过多个元素，这就是</st>
    *<st c="23206">跳表</st>*<st c="23215">的名字来源。</st> *<st c="23217">图 12</st>**<st
    c="23226">.6</st>* <st c="23228">展示了一个跳表的示例。</st> <st c="23268">第 1 层作为标准链表工作，而所有上层则充当</st>
    <st c="23349">快速通道。</st>
- en: <st c="23363">Let’s explain the</st> <st c="23382">concept of a skip list using
    an analogy.</st> <st c="23423">Imagine we are traveling to meet a friend at a
    specific station in a bus system.</st> <st c="23504">The bus stops at every station,
    and each stop takes a considerable amount of time, so we want to minimize the
    number of stops on our way to our friend’s station.</st> <st c="23666">There are</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/23.png)
    <st c="23676"><st c="23677">stations in total, and we know the exact station number
    where our friend is waiting.</st> <st c="23763">The bus system has two types</st>
    <st c="23792">of lines:</st></st>
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="23363">让我们通过类比来解释</st> <st c="23382">跳表的概念。</st> <st c="23423">假设我们正在前往一个特定车站见朋友，车站位于公交系统中的某一站。</st>
    <st c="23504">公交车会在每个车站停靠，每次停靠都需要耗费相当的时间，所以我们希望在前往朋友车站的途中尽量减少停靠站点的数量。</st> <st
    c="23666">一共有</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/23.png)
    <st c="23676"><st c="23677">个车站，而我们知道朋友所在车站的具体编号。</st> <st c="23763">该公交系统有两种</st>
    <st c="23792">线路类型：</st></st>
- en: <st c="23801">The regular bus stops at every</st> <st c="23833">single station</st>
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="23801">常规公交车会在每个</st> <st c="23833">车站停靠。</st>
- en: <st c="23847">The express line stops only at four stations, specifically at</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>4</mml:mn></mml:mrow></mml:mfrac></mml:math>](img/1812.png)<st
    c="23910"><st c="23911">,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac></mml:math>](img/547.png)<st
    c="23913"><st c="23914">,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mn>3</mml:mn><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>4</mml:mn></mml:mrow></mml:mfrac></mml:math>](img/1814.png)<st
    c="23916"><st c="23917">,</st> <st c="23919">and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/48.png)</st></st></st>
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快速线路仅停靠四个车站，具体为：![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>4</mml:mn></mml:mrow></mml:mfrac></mml:math>](img/1812.png)，![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac></mml:math>](img/547.png)，![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mn>3</mml:mn><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>4</mml:mn></mml:mrow></mml:mfrac></mml:math>](img/1814.png)，<st
    c="23919">和</st>![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/48.png)。
- en: <st c="23972">Taking the regular bus is the safest option because it ensures
    we will reach our destination, but it requires stopping at every station, which
    can be inefficient, taking</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/48.png)
    <st c="24142"><st c="24191">stops in total.</st> <st c="24207">Alternatively,
    we could take the express bus, which only makes four stops.</st> <st c="24282">If
    our friend’s station falls within one of the intervals between these express stops
    (for example, between 1 and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>4</mml:mn></mml:mrow></mml:mfrac></mml:math>](img/1812.png)<st
    c="24396"><st c="24397">, or between</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>4</mml:mn></mml:mrow></mml:mfrac><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:math>](img/1818.png)
    <st c="24410"><st c="24411">and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac></mml:math>](img/547.png)<st
    c="24416"><st c="24417">), we can get off the bus at the nearest express stop
    and switch to the regular bus to reach our friend’s exact station.</st> <st c="24538">By
    doing this, we reduce the number of stops from a maximum of</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/1820.png)
    <st c="24601"><st c="24602">to around</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>4</mml:mn></mml:mrow></mml:mfrac><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:math>](img/1818.png)<st
    c="24613"><st c="24614">, making our journey much more efficient.</st> <st c="24656">The
    skip list is similar to this</st> <st c="24689">bus system.</st></st></st></st></st></st></st>
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 乘坐常规公交是最安全的选择，因为它确保我们能够到达目的地，但它需要在每个站点停靠，这可能会低效，总共需要停靠的次数为 ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/48.png)
    <st c="24142"><st c="24191">站点。</st> <st c="24207">另外，我们可以选择快线公交，它只停靠四个站点。</st>
    <st c="24282">如果我们朋友的站点位于这些快线停靠站之间的某个区间内（例如，在 1 和</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>4</mml:mn></mml:mrow></mml:mfrac></mml:math>](img/1812.png)<st
    c="24396"><st c="24397">之间，或者在</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>4</mml:mn></mml:mrow></mml:mfrac><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:math>](img/1818.png)
    <st c="24410"><st c="24411">和</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:fraction></mml:math>](img/547.png)<st
    c="24416"><st c="24417">之间），我们可以在离朋友的站点最近的快线停靠站下车，然后换乘常规公交，直达朋友的站点。</st> <st c="24538">通过这样做，我们将停靠站的数量从最多的</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>n</mml:mi></mml:math>](img/1820.png)
    <st c="24601"><st c="24602">减少到大约</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>4</mml:mn></mml:mrow></mml:mfrac><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:math>](img/1818.png)<st
    c="24613"><st c="24614">，使得我们的旅程更加高效。</st> <st c="24656">跳表的结构与这种</st> <st c="24689">公交系统类似。</st>
- en: <st c="24700">Skip lists have several defining</st> <st c="24733">characteristics
    that influence their behavior</st> <st c="24780">and performance:</st>
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="24700">跳表具有几个定义特征，</st> <st c="24733">这些特征会影响其行为</st> <st c="24780">和性能：</st>
- en: '**<st c="24796">Multiple levels</st>**<st c="24812">: Skip lists consist of
    multiple levels, where each level above the base level contains a subset of elements
    from the previous level.</st> <st c="24947">The bottommost level is a standard
    linked list containing all elements.</st> <st c="25019">In a skip list, the first
    level might contain all elements, the second level might contain half, the third
    level might contain a quarter, and</st> <st c="25161">so on.</st>'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="24796">多个层级</st>**<st c="24812">：跳表由多个层级组成，每个层级包含前一个层级的一个子集。</st>
    <st c="24947">最底层是一个标准的链表，包含所有元素。</st> <st c="25019">在跳表中，第一层可能包含所有元素，第二层可能包含一半元素，第三层可能包含四分之一元素，</st>
    <st c="25161">以此类推。</st>'
- en: '**<st c="25167">Probabilistic balancing</st>**<st c="25191">: Skip lists use
    randomization to determine the level at which each element will appear.</st> <st
    c="25281">This leads to an average-case time complexity similar to balanced binary
    search trees without the need for complex balancing algorithms.</st> <st c="25418">For
    example, when inserting an element, a random number of levels (up to a maximum)
    is chosen for the element to be</st> <st c="25534">included in.</st>'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="25167">概率平衡</st>**<st c="25191">：跳表使用随机化来确定每个元素出现的层级。</st> <st c="25281">这使得跳表的平均时间复杂度与平衡二叉搜索树类似，而无需复杂的平衡算法。</st>
    <st c="25418">例如，在插入一个元素时，会为该元素随机选择一个（最多的）层级。</st>'
- en: '**<st c="25546">Efficient searching</st>**<st c="25566">: Skip lists allow
    for faster searching by skipping over large portions of the list using the higher
    levels, reducing the number of comparisons needed.</st> <st c="25719">For</st>
    <st c="25723">instance, searching for an element in a skip list can quickly bypass
    multiple nodes by moving through the</st> <st c="25829">upper levels.</st>'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="25546">高效的查找</st>**<st c="25566">：跳表通过使用更高层级跳过列表中的大部分部分，从而提高查找速度，减少所需比较次数。</st>
    <st c="25719">例如，在跳表中查找一个元素时，可以通过跳过多个节点来迅速找到该元素。</st> <st c="25829">通过上层级，可以加速查找。</st>'
- en: '**<st c="25842">Dynamic resizing</st>**<st c="25859">: Skip lists can dynamically
    adjust their structure as elements are added or removed, maintaining efficient
    operations without needing to rebuild the entire structure.</st> <st c="26028">For
    example, as new elements are inserted, they may be added to multiple levels depending
    on the</st> <st c="26125">randomization process.</st>'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="25842">动态调整大小</st>**<st c="25859">：跳表可以在添加或删除元素时动态调整其结构，保持高效的操作而无需重建整个结构。</st>
    <st c="26028">例如，随着新元素的插入，可能会根据</st> <st c="26125">随机化过程将它们添加到多个层级。</st>'
- en: <st c="26147">Skip lists support various operations, each with specific performance
    characteristics.</st> <st c="26235">The following section outlines the major operations,
    along with their time complexities</st> <st c="26323">and examples.</st>
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="26147">跳表支持各种操作，每个操作都有特定的性能特征。</st> <st c="26235">以下部分概述了主要操作及其时间复杂度</st>
    <st c="26323">和示例。</st>
- en: <st c="26336">Insertion in skip lists</st>
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="26336">跳表中的插入</st>
- en: <st c="26360">Inserting</st> <st c="26371">numbers into a skip list involves
    a few steps.</st> <st c="26418">For this example, we will insert the numbers</st>
    `<st c="26463">3</st>`<st c="26464">,</st> `<st c="26466">4</st>`<st c="26467">,</st>
    `<st c="26469">5</st>`<st c="26470">,</st> `<st c="26472">7</st>`<st c="26473">,</st>
    `<st c="26475">8</st>`<st c="26476">,</st> `<st c="26478">9</st>`<st c="26479">,
    and</st> `<st c="26485">10</st>` <st c="26487">into a skip list with 4 levels.</st>
    <st c="26520">Each number will be inserted one by one, and the levels will be
    assigned based on randomization.</st> <st c="26617">Here’s a detailed step-by-step
    description of how this</st> <st c="26672">process works:</st>
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="26360">向跳表中插入</st> <st c="26371">数字需要几个步骤。</st> <st c="26418">在这个例子中，我们将插入数字</st>
    `<st c="26463">3</st>`<st c="26464">,</st> `<st c="26466">4</st>`<st c="26467">,</st>
    `<st c="26469">5</st>`<st c="26470">,</st> `<st c="26472">7</st>`<st c="26473">,</st>
    `<st c="26475">8</st>`<st c="26476">,</st> `<st c="26478">9</st>`<st c="26479">
    和</st> `<st c="26485">10</st>` <st c="26487">到一个有四个层级的跳表中。</st> <st c="26520">每个数字将一个接一个地插入，层级将根据随机化过程进行分配。</st>
    <st c="26617">以下是这个</st> <st c="26672">过程的详细逐步描述：</st>
- en: '**<st c="26686">Step 1: Initialize the skip list</st>**<st c="26719">: Start
    with an empty skip list that has four levels:</st> *<st c="26774">Level 4</st>*
    <st c="26781">(topmost),</st> *<st c="26793">Level 3</st>*<st c="26800">,</st>
    *<st c="26802">Level 2</st>*<st c="26809">, and</st> *<st c="26815">Level 1</st>*
    <st c="26822">(bottommost).</st> <st c="26837">Initially, the list has only a
    head node at each level pointing</st> <st c="26901">to</st> **<st c="26904">null</st>**<st
    c="26908">.</st>'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="26686">步骤 1: 初始化跳表</st>**<st c="26719">：从一个空的跳表开始，该跳表有四个层级：</st> *<st
    c="26774">等级 4</st>* <st c="26781">（最上层），</st> *<st c="26793">等级 3</st>*<st c="26800">，</st>
    *<st c="26802">等级 2</st>*<st c="26809">，以及</st> *<st c="26815">等级 1</st>* <st
    c="26822">（最底层）。</st> <st c="26837">最初，列表的每个层级只有一个头节点，指向</st> <st c="26901">null</st><st
    c="26908">。</st>'
- en: '**<st c="26909">Step 2:</st>** **<st c="26918">Insert 3</st>**<st c="26926">:</st>'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="26909">步骤 2:</st>** **<st c="26918">插入 3</st>**<st c="26926">：</st>'
- en: '**<st c="26928">Determine levels for 3</st>**<st c="26950">: Randomly determine
    the levels at which</st> **<st c="26992">3</st>** <st c="26993">should appear.</st>
    <st c="27009">Let’s assume it appears at</st> <st c="27036">all levels.</st>'
  id: totrans-114
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="26928">确定 3 的层级</st>**<st c="26950">：随机确定</st> **<st c="26992">3</st>**
    <st c="26993">应该出现在的层级。</st> <st c="27009">假设它出现在</st> <st c="27036">所有层级。</st>'
- en: '**<st c="27047">Insertion</st>**<st c="27057">: At</st> *<st c="27063">Levels
    1</st>* <st c="27071">to</st> *<st c="27075">4</st>*<st c="27076">, there are
    no other nodes; so,</st> **<st c="27108">3</st>** <st c="27109">is simply inserted,
    and the head node at</st> *<st c="27151">Levels 1</st>* <st c="27159">to</st>
    *<st c="27163">4</st>* <st c="27164">now points</st> <st c="27176">to</st> **<st
    c="27179">3</st>**<st c="27180">.</st>'
  id: totrans-115
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="27047">插入</st>**<st c="27057">：在</st> *<st c="27063">等级 1</st>* <st
    c="27071">到</st> *<st c="27075">4</st>*<st c="27076">，没有其他节点；所以，</st> **<st c="27108">3</st>**
    <st c="27109">只是被插入，且</st> *<st c="27151">等级 1</st>* <st c="27159">到</st> *<st
    c="27163">4</st>* <st c="27164">的头节点现在指向</st> <st c="27176">3</st><st c="27180">。</st>'
- en: <st c="27181">Here is the</st> <st c="27194">skip list:</st>
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="27181">这里是</st> <st c="27194">跳表：</st>
- en: '<st c="27204">Level 4: 3 --></st> <st c="27220">null</st>'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '<st c="27204">等级 4: 3 --></st> <st c="27220">null</st>'
- en: '<st c="27224">Level 3: 3 --></st> <st c="27240">null</st>'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '<st c="27224">等级 3: 3 --></st> <st c="27240">null</st>'
- en: '<st c="27244">Level 2: 3 --></st> <st c="27260">null</st>'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '<st c="27244">等级 2: 3 --></st> <st c="27260">null</st>'
- en: '<st c="27264">Level 1: 3 --></st> <st c="27280">null</st>'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '<st c="27264">等级 1: 3 --></st> <st c="27280">null</st>'
- en: '**<st c="27284">Step 3:</st>** **<st c="27293">Insert 4</st>**<st c="27301">:</st>'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="27284">步骤 3:</st>** **<st c="27293">插入 4</st>**<st c="27301">：</st>'
- en: '**<st c="27303">Determine levels for 4</st>**<st c="27325">: Randomly determine
    the levels at which</st> **<st c="27367">4</st>** <st c="27368">should appear.</st>
    <st c="27384">Suppose it appears only at</st> *<st c="27411">Level 1</st>*<st
    c="27418">. The higher levels remain unchanged as</st> **<st c="27458">3</st>**
    <st c="27459">does not</st> <st c="27469">appear there.</st>'
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="27303">确定 4 的层级</st>**<st c="27325">：随机确定</st> **<st c="27367">4</st>**
    <st c="27368">应该出现在的层级。</st> <st c="27384">假设它只出现在</st> *<st c="27411">等级 1</st>*<st
    c="27418">。较高层级保持不变，因为</st> **<st c="27458">3</st>** <st c="27459">不出现在那里。</st>'
- en: '**<st c="27482">Insertion</st>**<st c="27492">: Traverse</st> *<st c="27504">Level
    1</st>* <st c="27511">from the head to the appropriate position.</st> **<st c="27555">4</st>**
    <st c="27556">should be inserted after</st> **<st c="27582">3</st>**<st c="27583">.
    Update the pointers so that</st> **<st c="27613">3</st>** <st c="27614">now points
    to</st> **<st c="27629">4</st>** <st c="27630">at</st> *<st c="27634">Level 1</st>*<st
    c="27641">.</st>'
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="27482">插入</st>**<st c="27492">：从头到适当位置遍历</st> *<st c="27504">等级 1</st>*
    <st c="27511">。应该将</st> **<st c="27555">4</st>** <st c="27556">插入到</st> **<st
    c="27582">3</st>**<st c="27583">之后。</st> 更新指针，使得</st> **<st c="27613">3</st>**
    <st c="27614">现在指向</st> **<st c="27629">4</st>** <st c="27630">在</st> *<st c="27634">等级
    1</st>*<st c="27641">。</st>'
- en: <st c="27642">Here is the</st> <st c="27654">skip list:</st>
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="27642">这里是</st> <st c="27654">跳表：</st>
- en: '<st c="27665">Level 4: 3 --></st> <st c="27681">null</st>'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '<st c="27665">等级 4: 3 --></st> <st c="27681">null</st>'
- en: '<st c="27685">Level 3: 3 --></st> <st c="27701">null</st>'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '<st c="27685">等级 3: 3 --></st> <st c="27701">null</st>'
- en: '<st c="27705">Level 2: 3 --></st> <st c="27721">null</st>'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '<st c="27705">等级 2: 3 --></st> <st c="27721">null</st>'
- en: '<st c="27725">Level 1: 3 --> 4 --></st> <st c="27747">null</st>'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '<st c="27725">等级 1: 3 --> 4 --></st> <st c="27747">null</st>'
- en: '`<st c="27808">5</st>` <st c="27809">is assigned randomly to</st> *<st c="27834">Levels
    1</st>*<st c="27842">,</st> *<st c="27844">2</st>*<st c="27845">,</st> <st c="27847">and</st>
    *<st c="27851">3</st>*<st c="27852">.</st>'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="27808">5</st>` <st c="27809">被随机分配到</st> *<st c="27834">等级 1</st>*<st
    c="27842">，</st> *<st c="27844">2</st>*<st c="27845">，</st> <st c="27847">和</st>
    *<st c="27851">3</st>*<st c="27852">。</st>'
- en: '**<st c="27853">Insertion</st>**<st c="27863">: In</st> *<st c="27869">Levels
    2</st>* <st c="27877">and</st> *<st c="27882">3</st>*<st c="27883">, element</st>
    **<st c="27893">5</st>** <st c="27894">is the next element to</st> **<st c="27918">3</st>**<st
    c="27919">. Then, pointers of</st> **<st c="27939">3</st>** <st c="27940">at these
    levels are updated to point to</st> **<st c="27981">5</st>**<st c="27982">. In</st>
    *<st c="27987">Level 1</st>*<st c="27994">, insert</st> **<st c="28003">5</st>**
    <st c="28004">after</st> **<st c="28011">4</st>** <st c="28012">by updating the</st>
    <st c="28029">pointers accordingly.</st>'
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="27853">插入</st>**<st c="27863">：在</st> *<st c="27869">级别 2</st>* <st
    c="27877">和</st> *<st c="27882">3</st>*<st c="27883">，元素</st> **<st c="27893">5</st>**
    <st c="27894">是下一个元素，</st> **<st c="27918">3</st>**<st c="27919">。然后，这些级别的</st>
    **<st c="27939">3</st>** <st c="27940">的指针会更新，指向</st> **<st c="27981">5</st>**<st
    c="27982">。在</st> *<st c="27987">级别 1</st>*<st c="27994">，将</st> **<st c="28003">5</st>**
    <st c="28004">插入到</st> **<st c="28011">4</st>** <st c="28012">之后，并相应更新指针。</st>'
- en: <st c="28050">Here is the</st> <st c="28063">skip list:</st>
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="28050">这是</st> <st c="28063">跳表：</st>
- en: '<st c="28073">Level 4: 3 --></st> <st c="28089">null</st>'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="28073">级别 4：3 --></st> <st c="28089">null</st>
- en: '<st c="28093">Level 3: 3 --> 5 --></st> <st c="28115">null</st>'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="28093">级别 3：3 --> 5 --></st> <st c="28115">null</st>
- en: '<st c="28119">Level 2: 3 --> 5 --></st> <st c="28141">null</st>'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="28119">级别 2：3 --> 5 --></st> <st c="28141">null</st>
- en: '<st c="28145">Level 1: 3 --> 4 -->5 --></st> <st c="28172">null</st>'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="28145">级别 1：3 --> 4 -->5 --></st> <st c="28172">null</st>
- en: '**<st c="28176">Step 5:</st>** **<st c="28185">Insert 7</st>**<st c="28193">:</st>'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="28176">步骤 5：</st>** **<st c="28185">插入 7</st>**<st c="28193">：</st>'
- en: '**<st c="28195">Determine levels for 7</st>**<st c="28217">: Suppose</st> **<st
    c="28228">7</st>** <st c="28229">is assigned randomly to</st> *<st c="28254">Level
    1</st>*<st c="28261">. All upper levels</st> <st c="28280">remain unchanged.</st>'
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="28195">确定 7 的级别</st>**<st c="28217">：假设</st> **<st c="28228">7</st>**
    <st c="28229">被随机分配给</st> *<st c="28254">级别 1</st>*<st c="28261">。所有上级</st> <st
    c="28280">保持不变。</st>'
- en: '**<st c="28297">Insertion</st>**<st c="28307">: In</st> *<st c="28313">Level
    1</st>* <st c="28321">insert</st> **<st c="28328">7</st>** <st c="28329">after</st>
    **<st c="28335">5</st>**<st c="28336">.</st>'
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="28297">插入</st>**<st c="28307">：在</st> *<st c="28313">级别 1</st>* <st
    c="28321">将</st> **<st c="28328">7</st>** <st c="28329">插入到</st> **<st c="28335">5</st>**<st
    c="28336">之后。</st>'
- en: <st c="28337">Here is the</st> <st c="28349">skip list:</st>
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="28337">这是</st> <st c="28349">跳表：</st>
- en: '<st c="28360">Level 4: 3 --></st> <st c="28376">null</st>'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="28360">级别 4：3 --></st> <st c="28376">null</st>
- en: '<st c="28380">Level 3: 3 --></st> <st c="28396">5 -->null</st>'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="28380">级别 3：3 --></st> <st c="28396">5 -->null</st>
- en: '<st c="28405">Level 2: 3 --></st> <st c="28421">5 -->null</st>'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="28405">级别 2：3 --></st> <st c="28421">5 -->null</st>
- en: '<st c="28430">Level 1: 3 --> 4 --> 5 -->7 --></st> <st c="28463">null</st>'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="28430">级别 1：3 --> 4 --> 5 -->7 --></st> <st c="28463">null</st>
- en: '**<st c="28467">Step 6:</st>** **<st c="28476">Insert 8</st>**<st c="28484">:</st>'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="28467">步骤 6：</st>** **<st c="28476">插入 8</st>**<st c="28484">：</st>'
- en: '**<st c="28486">Determine levels for 8</st>**<st c="28508">: Let’s assume</st>
    **<st c="28524">8</st>** <st c="28525">is assigned randomly to</st> *<st c="28550">Levels
    1</st>* <st c="28558">and</st> *<st c="28563">2</st>*<st c="28564">.</st>'
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="28486">确定 8 的级别</st>**<st c="28508">：假设</st> **<st c="28524">8</st>**
    <st c="28525">被随机分配给</st> *<st c="28550">级别 1</st>* <st c="28558">和</st> *<st
    c="28563">2</st>*<st c="28564">。</st>'
- en: '**<st c="28565">Insertion</st>**<st c="28575">: In</st> *<st c="28581">Level
    2</st>*<st c="28588">, insert</st> **<st c="28597">8</st>** <st c="28598">after</st>
    **<st c="28605">5</st>** <st c="28606">by updating the pointers.</st> <st c="28633">In</st>
    *<st c="28636">Level 1</st>*<st c="28643">, insert</st> **<st c="28652">8</st>**
    <st c="28653">after</st> **<st c="28659">7</st>**<st c="28660">.</st>'
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="28565">插入</st>**<st c="28575">：在</st> *<st c="28581">级别 2</st>*<st
    c="28588">，将</st> **<st c="28597">8</st>** <st c="28598">插入到</st> **<st c="28605">5</st>**
    <st c="28606">之后，通过更新指针。</st> <st c="28633">在</st> *<st c="28636">级别 1</st>*<st
    c="28643">，将</st> **<st c="28652">8</st>** <st c="28653">插入到</st> **<st c="28659">7</st>**<st
    c="28660">之后。</st>'
- en: <st c="28661">Here is the</st> <st c="28674">skip list:</st>
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="28661">这是</st> <st c="28674">跳表：</st>
- en: '<st c="28684">Level 4: 3 --></st> <st c="28700">null</st>'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="28684">级别 4：3 --></st> <st c="28700">null</st>
- en: '<st c="28704">Level 3: 3 --> 5 --></st> <st c="28726">null</st>'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="28704">级别 3：3 --> 5 --></st> <st c="28726">null</st>
- en: '<st c="28730">Level 2: 3 --> 5 --> 8 --></st> <st c="28758">null</st>'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="28730">级别 2：3 --> 5 --> 8 --></st> <st c="28758">null</st>
- en: '<st c="28762">Level 1: 3 --> 4 --> 5 --> 7 --> 8 --></st> <st c="28802">null</st>'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="28762">级别 1：3 --> 4 --> 5 --> 7 --> 8 --></st> <st c="28802">null</st>
- en: <st c="28806">For</st> *<st c="28811">Steps 9</st>* <st c="28818">and</st> *<st
    c="28823">10</st>*<st c="28825">, we do similar to what we did with element</st>
    **<st c="28869">7</st>**<st c="28870">. The final skip list after inserting all
    elements is illustrated in</st> *<st c="28939">Figure 12</st>**<st c="28948">.5</st>*<st
    c="28950">.</st>
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="28806">对于</st> *<st c="28811">步骤9</st>* <st c="28818">和</st> *<st c="28823">步骤10</st>*<st
    c="28825">，我们会像处理元素</st> **<st c="28869">7</st>**<st c="28870">一样进行。插入所有元素后的最终跳表在</st>
    *<st c="28939">图12</st>**<st c="28948">.5</st>*<st c="28950">中进行了展示。</st>
- en: '![Figure 12.5: An example skip list with four levels](img/B22248_12_5.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![图12.5：一个具有四个层级的跳表示例](img/B22248_12_5.jpg)'
- en: '<st c="29049">Figure 12.5: An example skip list with four levels</st>'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="29049">图12.5：一个具有四个层级的跳表示例</st>
- en: <st c="29099">The insertion</st> <st c="29114">process in a skip list involves
    determining the levels at which a new element will appear and updating the pointers
    at each relevant level to maintain the order.</st> <st c="29276">The random assignment
    of levels ensures that the skip list remains balanced, providing efficient search,
    insertion, and deletion operations.</st> <st c="29417">The preceding steps illustrate
    how each number was inserted into the skip list, taking advantage of the express
    lanes created by the</st> <st c="29550">higher levels.</st>
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="29099">跳表中的插入</st> <st c="29114">过程涉及确定新元素将出现在何层，并更新每个相关层级的指针以维持顺序。</st>
    <st c="29276">层级的随机分配确保跳表保持平衡，从而提供高效的查找、插入和删除操作。</st> <st c="29417">上述步骤展示了每个数字是如何被插入到跳表中的，利用了</st>
    <st c="29550">更高层级创建的快速通道。</st>
- en: <st c="29564">The following Python code is an implementation of insertion into
    a</st> <st c="29632">skip list:</st>
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="29564">以下是插入到跳表中的Python代码实现：</st>
- en: '[PRE11]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: <st c="31042">Let’s look inside</st> <st c="31061">the code and explain the
    main classes of</st> <st c="31102">the algorithm:</st>
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="31042">让我们来看一下</st> <st c="31061">代码，并解释该算法的主要类：</st>
- en: '**<st c="31116">Node</st>**<st c="31121">: Each</st> **<st c="31129">Node</st>**
    <st c="31133">object stores a</st> **<st c="31150">value</st>** <st c="31155">and
    a list of</st> **<st c="31170">forward</st>** <st c="31177">pointers that are
    4 in level 1, 5 in level 2, 5 in level 3 and null in</st> <st c="31249">level
    4</st>'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="31116">节点</st>**<st c="31121">：每个**<st c="31129">节点</st>**<st c="31133">对象存储一个</st>
    **<st c="31150">值</st>**<st c="31155">和一个指向</st> **<st c="31170">前向</st>**<st
    c="31177">指针的列表，在第1层有4个指针，第2层有5个，第3层有5个，第4层为null</st>'
- en: '**<st c="31256">SkipList</st>**<st c="31265">: This contains the</st> <st c="31286">following
    functions:</st>'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="31256">跳表</st>**<st c="31265">：包含以下功能：</st>'
- en: '**<st c="31306">random_level()</st>**<st c="31321">: This generates a random
    level for each new node based on a</st> <st c="31383">probabilistic model</st>'
  id: totrans-161
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="31306">random_level()</st>**<st c="31321">：此方法根据</st> <st c="31383">概率模型</st>
    <st c="31383">为每个新节点生成一个随机层级</st>'
- en: '**<st c="31402">insert()</st>**<st c="31411">: This inserts a new value into
    the skip list at the</st> <st c="31465">appropriate levels</st>'
  id: totrans-162
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="31402">insert()</st>**<st c="31411">：此方法将在跳表的</st> <st c="31465">适当层级插入一个新值</st>'
- en: '**<st c="31483">print_skiplist()</st>**<st c="31500">: This prints the skip
    list, displaying the nodes at each level from the topmost level down to the</st>
    <st c="31600">bottommost level</st>'
  id: totrans-163
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="31483">print_skiplist()</st>**<st c="31500">：此方法打印跳表，显示从最高层到</st>
    <st c="31600">最低层的每一层节点</st>'
- en: <st c="31616">As an example, we</st> <st c="31635">create a skip list with up
    to three levels.</st> <st c="31679">The values</st> `<st c="31690">3</st>`<st
    c="31691">,</st> `<st c="31693">4</st>`<st c="31694">,</st> `<st c="31696">5</st>`<st
    c="31697">,</st> `<st c="31699">7</st>`<st c="31700">,</st> `<st c="31702">8</st>`<st
    c="31703">,</st> `<st c="31705">9</st>`<st c="31706">, and</st> `<st c="31712">10</st>`
    <st c="31714">are inserted into the skip list.</st> <st c="31748">Finally, we
    print the skip list, displaying how the nodes are organized across the various
    levels, which looks something</st> <st c="31869">like this:</st>
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="31616">作为示例，我们</st> <st c="31635">创建一个最多包含三层的跳表。</st> <st c="31679">插入的值为</st>
    `<st c="31690">3</st>`<st c="31691">，</st> `<st c="31693">4</st>`<st c="31694">，</st>
    `<st c="31696">5</st>`<st c="31697">，</st> `<st c="31699">7</st>`<st c="31700">，</st>
    `<st c="31702">8</st>`<st c="31703">，</st> `<st c="31705">9</st>`<st c="31706">，和</st>
    `<st c="31712">10</st>` <st c="31714">被插入到跳表中。</st> <st c="31748">最后，我们打印跳表，显示节点在各个层级中的组织方式，如下所示：</st>
- en: '[PRE12]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: <st c="32019">After insertion, let’s discuss the behavior of a skip list during</st>
    <st c="32086">search operations.</st>
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="32019">插入后，我们来讨论跳表在</st> <st c="32086">查找操作中的表现。</st>
- en: <st c="32104">Search in skip lists</st>
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="32104">在跳表中搜索</st>
- en: <st c="32125">Searching</st> <st c="32135">for an item in a skip list involves
    starting at the highest level and moving forward through the list until the target
    is found or the search needs to move down a level.</st> <st c="32306">Here’s a
    step-by-step explanation of how to search for the number</st> *<st c="32372">8</st>*
    <st c="32373">in the skip list we</st> <st c="32394">previously constructed.</st>
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="32125">在跳表中搜索一个项，通常是从最高层开始，沿着列表向前移动，直到找到目标或者需要下移一层。</st> <st c="32306">以下是一步步的解释，如何在我们之前构建的跳表中搜索数字</st>
    *<st c="32372">8</st>* <st c="32373">。</st>
- en: '**<st c="32417">Step 1</st>**<st c="32424">: Start at the highest level (</st>*<st
    c="32455">Level 4</st>*<st c="32463">):</st>'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="32417">步骤 1</st>**<st c="32424">: 从最高层开始（</st>*<st c="32455">Level
    4</st>*<st c="32463">）：</st>'
- en: <st c="32466">Start at the head node at</st> *<st c="32493">Level 3</st>*<st
    c="32500">.</st>
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="32466">从</st> *<st c="32493">Level 3</st>*<st c="32500">的头节点开始。</st>
- en: <st c="32501">Is</st> **<st c="32505">3</st>** <st c="32506">(the first value
    at</st> *<st c="32527">Level 3</st>*<st c="32534">) less than</st> **<st c="32547">7</st>**<st
    c="32548">? Yes; the next node</st> <st c="32569">is</st> **<st c="32572">null</st>**<st
    c="32576">.</st>
  id: totrans-171
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="32501">是</st> **<st c="32505">3</st>** <st c="32506">(第一个值在</st> *<st
    c="32527">Level 3</st>*<st c="32534">) 小于</st> **<st c="32547">7</st>**<st c="32548">吗？是的；下一个节点</st>
    <st c="32569">是</st> **<st c="32572">null</st>**<st c="32576">。</st>
- en: '**<st c="32577">Step 2</st>**<st c="32584">: Move down to</st> *<st c="32600">Level
    3</st>*<st c="32607">:</st>'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="32577">步骤 2</st>**<st c="32584">: 移动到</st> *<st c="32600">Level 3</st>*<st
    c="32607">：</st>'
- en: <st c="32609">Now, drop down to node</st> **<st c="32632">3</st>** <st c="32633">at</st>
    *<st c="32637">Level 3</st>* <st c="32644">and the next node</st> <st c="32663">is</st>
    **<st c="32666">5</st>**<st c="32667">.</st>
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="32609">现在，下降到节点</st> **<st c="32632">3</st>** <st c="32633">在</st> *<st
    c="32637">Level 3</st>* <st c="32644">，下一个节点</st> <st c="32663">是</st> **<st c="32666">5</st>**<st
    c="32667">。</st>
- en: <st c="32668">Is</st> **<st c="32672">5</st>** <st c="32673">less than</st>
    **<st c="32684">9</st>**<st c="32685">? Yes.</st> <st c="32692">Move to node</st>
    **<st c="32705">5</st>**<st c="32706">. The next node which</st> <st c="32728">in
    null.</st>
  id: totrans-174
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="32668">是</st> **<st c="32672">5</st>** <st c="32673">小于</st> **<st c="32684">9</st>**<st
    c="32685">吗？是的。</st> <st c="32692">移动到节点</st> **<st c="32705">5</st>**<st c="32706">。下一个节点</st>
    <st c="32728">为空。</st>
- en: '**<st c="32736">Step 3</st>**<st c="32743">: Move down to</st> *<st c="32759">Level
    2</st>*<st c="32766">:</st>'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="32736">步骤 3</st>**<st c="32743">: 移动到</st> *<st c="32759">Level 2</st>*<st
    c="32766">：</st>'
- en: <st c="32768">Now, drop down to node</st> **<st c="32791">5</st>** <st c="32792">at</st>
    *<st c="32796">Level 3</st>* <st c="32803">and the next node</st> <st c="32822">is</st>
    **<st c="32825">8</st>**<st c="32826">.</st>
  id: totrans-176
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="32768">现在，下降到节点</st> **<st c="32791">5</st>** <st c="32792">在</st> *<st
    c="32796">Level 3</st>* <st c="32803">，下一个节点</st> <st c="32822">是</st> **<st c="32825">8</st>**<st
    c="32826">。</st>
- en: <st c="32827">Is</st> **<st c="32831">8</st>** <st c="32832">less than</st>
    **<st c="32843">9</st>**<st c="32844">? No.</st>
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="32827">是</st> **<st c="32831">8</st>** <st c="32832">小于</st> **<st c="32843">9</st>**<st
    c="32844">吗？不。</st>
- en: '**<st c="32849">Step 4</st>**<st c="32856">: Move down to</st> *<st c="32872">Level
    1</st>*<st c="32879">:</st>'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="32849">步骤 4</st>**<st c="32856">: 移动到</st> *<st c="32872">Level 1</st>*<st
    c="32879">：</st>'
- en: <st c="32881">The next node is</st> **<st c="32898">7</st>**<st c="32899">.
    The target</st> <st c="32912">is found.</st>
  id: totrans-179
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="32881">下一个节点是</st> **<st c="32898">7</st>**<st c="32899">。目标</st> <st
    c="32912">已找到。</st>
- en: <st c="32921">The total number of comparisons is three, demonstrating a clear
    improvement over the sequential search in</st> *<st c="33028">Level 1</st>* <st
    c="33035">that would be required in a standard linked list.</st> <st c="33086">Skip
    lists are significantly</st> <st c="33114">more efficient than linked lists, especially
    when dealing with</st> <st c="33178">large datasets.</st>
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="32921">总比较次数为三次，显示出相较于标准链表中</st> *<st c="33028">Level 1</st>* <st c="33035">顺序查找的明显改进。</st>
    <st c="33086">跳表在效率上明显优于链表，尤其是在处理</st> <st c="33178">大数据集时。</st>
- en: <st c="33193">The following is a</st> `<st c="33213">search</st>` <st c="33219">method
    that must be added to the previously described</st> `<st c="33274">SkipList</st>`
    <st c="33282">class:</st>
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="33193">以下是必须添加到之前描述的</st> `<st c="33213">search</st>` <st c="33219">方法，它将添加到</st>
    `<st c="33274">SkipList</st>` <st c="33282">类中：</st>
- en: '[PRE13]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: <st c="33555">The following is an example usage of</st> `<st c="33593">search</st>`
    <st c="33599">in a</st> `<st c="33605">SkipList</st>` <st c="33613">class:</st>
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="33555">以下是</st> `<st c="33593">search</st>` <st c="33599">在</st> `<st
    c="33605">SkipList</st>` <st c="33613">类中的示例用法：</st>
- en: '[PRE14]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: <st c="34106">By inserting</st> <st c="34119">the example data, it produces
    the</st> <st c="34154">following results:</st>
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="34106">通过插入</st> <st c="34119">示例数据，得到以下结果：</st>
- en: '[PRE15]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: <st c="34323">To conclude our discussion on skip lists, we will skip the detailed
    explanation of deletion.</st> <st c="34417">Deletion in a skip list involves first
    performing a search, followed by updating the</st> <st c="34502">necessary pointers.</st>
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="34323">为了总结我们关于跳表的讨论，我们将跳过删除的详细解释。</st> <st c="34417">跳表中的删除操作首先进行查找，然后更新</st>
    <st c="34502">必要的指针。</st>
- en: <st c="34521">Skip lists offer efficient average-case time complexities for
    search, delete, and insert operations, typically performing at</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>O</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1436.png)<st
    c="34647"><st c="34656">. This efficiency is achieved through the use of multiple
    levels of linked lists, allowing operations to skip over large portions of data,
    similar to a binary search tree.</st> <st c="34828">In the best case, operations
    can approach</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1823.png)
    <st c="34870"><st c="34871">when the target element is close to the starting point.</st>
    <st c="34928">However, due to the probabilistic nature of skip lists, there is
    a small chance that the structure could degenerate, leading to a worst-case time
    complexity of</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1071.png)
    <st c="35088"><st c="35089">for these operations.</st> <st c="35112">Despite this,
    the average-case performance remains robust, making skip lists a practical choice
    for dynamic data structures where balanced search, insertion, and deletion times</st>
    <st c="35289">are crucial.</st></st></st></st>
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="34521">跳表为搜索、删除和插入操作提供了高效的平均时间复杂度，通常为</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mi>O</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow></mrow></mrow></math>](img/1436.png)<st
    c="34647"><st c="34656">。这种效率是通过使用多级链表实现的，使得操作可以跳过大量数据，类似于二叉搜索树。</st> <st c="34828">在最优情况下，当目标元素靠近起始点时，操作的时间复杂度可以接近</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1823.png)
    <st c="34870"><st c="34871">。</st> <st c="34928">然而，由于跳表的概率性质，结构有可能退化，导致最坏情况下的时间复杂度为</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1071.png)
    <st c="35088"><st c="35089">。</st> <st c="35112">尽管如此，跳表在平均情况下的性能仍然稳健，使其成为动态数据结构的实用选择，特别是在平衡搜索、插入和删除时间</st>
    <st c="35289">至关重要的场景中。</st></st></st></st>
- en: <st c="35301">Stacks</st>
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="35301">栈</st>
- en: '<st c="35308">A</st> **<st c="35311">stack</st>** <st c="35316">is a</st> <st
    c="35321">linear data structure that follows the LIFO principle, meaning that
    the last element added to the stack is the first one to be removed.</st> <st c="35458">Think
    of it as a stack of plates: we add new plates on top, and when we need a plate,
    we take the top one off first.</st> <st c="35575">Stacks are used in various applications,
    including expression evaluation, function call management, and undo mechanisms</st>
    <st c="35695">in software.</st>'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="35308">一个</st> **<st c="35311">栈</st>** <st c="35316">是一个</st> <st c="35321">线性数据结构，遵循后进先出（LIFO）原则，这意味着最后添加到栈中的元素会最先被移除。</st>
    <st c="35458">可以将其想象为一堆盘子：我们将新的盘子放在顶部，当需要盘子时，我们首先取走最上面的那个。</st> <st c="35575">栈广泛用于各种应用，包括表达式求值、函数调用管理和软件中的撤销机制。</st>
- en: <st c="35707">Stacks have several</st> <st c="35727">defining characteristics
    that influence their behavior</st> <st c="35783">and performance:</st>
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="35707">栈有几个</st> <st c="35727">决定其行为和性能的特征：</st>
- en: '**<st c="35799">LIFO order</st>**<st c="35810">: The last element inserted
    into the stack is the first one to be removed.</st> <st c="35886">For example,
    if we push the numbers</st> **<st c="35922">1</st>**<st c="35923">,</st> **<st
    c="35925">2</st>**<st c="35926">, and</st> **<st c="35932">3</st>** <st c="35933">onto
    a stack, we will pop them off in the reverse order:</st> **<st c="35991">3</st>**<st
    c="35992">,</st> **<st c="35994">2</st>**<st c="35995">,</st> **<st c="35997">1</st>**<st
    c="35998">.</st>'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="35799">LIFO 顺序</st>**<st c="35810">: 最后插入的元素是最先被移除的。</st> <st c="35886">例如，如果我们将数字</st>
    **<st c="35922">1</st>**<st c="35923">,</st> **<st c="35925">2</st>**<st c="35926">和</st>
    **<st c="35932">3</st>** <st c="35933">推入栈中，它们将以相反的顺序被弹出：</st> **<st c="35991">3</st>**<st
    c="35992">,</st> **<st c="35994">2</st>**<st c="35995">,</st> **<st c="35997">1</st>**<st
    c="35998">。</st>'
- en: '**<st c="35999">Operations performed at one end</st>**<st c="36031">: All insertions
    (push) and deletions (pop) are performed at the top of the stack.</st> <st c="36115">There
    is no direct access to elements in the middle or bottom of the stack.</st> <st
    c="36191">If we push several elements onto a stack, we can only access the most
    recently added element directly.</st> <st c="36294">It also means there is no
    random access to the stack.</st> <st c="36348">Unlike arrays, we cannot directly
    access elements at a specific index in a stack.</st> <st c="36430">Access is restricted
    to the top</st> <st c="36462">element only.</st>'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="35999">一端操作</st>**<st c="36031">: 所有的插入（push）和删除（pop）操作都在栈的顶部进行。</st>
    <st c="36115">无法直接访问栈中间或底部的元素。</st> <st c="36191">如果我们将多个元素推入栈中，我们只能直接访问最近添加的元素。</st>
    <st c="36294">这也意味着栈不支持随机访问。</st> <st c="36348">与数组不同，我们不能直接访问栈中某个特定索引的元素。</st>
    <st c="36430">访问仅限于栈顶</st> <st c="36462">元素。</st>'
- en: '**<st c="36475">Dynamic size</st>**<st c="36488">: Stacks can dynamically grow
    or shrink as elements are pushed or popped.</st> <st c="36563">As we push more
    elements onto a stack, its size increases, and as we pop elements off, its</st>
    <st c="36654">size decreases.</st>'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="36475">动态大小</st>**<st c="36488">: 栈可以随着元素的推入或弹出动态增大或缩小。</st> <st c="36563">当我们将更多元素推入栈时，栈的大小会增加；而当我们弹出元素时，栈的大小会减小。</st>'
- en: <st c="36669">Stacks support a few fundamental operations, each with specific
    performance characteristics.</st> <st c="36763">The following are these major
    operations, along with their time complexities</st> <st c="36840">and examples:</st>
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="36669">栈支持几个基本操作，每个操作具有特定的性能特点。</st> <st c="36763">以下是这些主要操作及其时间复杂度</st>
    <st c="36840">和示例：</st>
- en: '**<st c="36853">push</st>**<st c="36858">: It adds a new element to the top
    of the stack.</st> <st c="36908">Its time complexity is</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1266.png)<st
    c="36931"><st c="36932">, as the operation involves simply adding an element to
    the top of the stack.</st> <st c="37010">The following is a simple</st> <st c="37036">Python
    example:</st>'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="36853">push</st>**<st c="36858">: 它将一个新元素添加到栈顶。</st> <st c="36908">它的时间复杂度是</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1266.png)<st
    c="36931"><st c="36932">，因为此操作仅涉及将元素添加到栈顶。</st> <st c="37010">以下是一个简单的</st> <st
    c="37036">Python 示例：</st>'
- en: '[PRE16]</st>'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[PRE16]</st>'
- en: '**<st c="37148">pop</st>**<st c="37152">: This removes the top element from
    the stack.</st> <st c="37200">It performs the removal in constant time (</st>![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1046.png)<st
    c="37242"><st c="37244">).</st> <st c="37247">The following is a</st> <st c="37266">Python
    example:</st>'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="37148">pop</st>**<st c="37152">: 这会移除栈顶元素。</st> <st c="37200">它在常数时间内执行移除操作
    (</st>![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1046.png)<st
    c="37242"><st c="37244">).</st> <st c="37247">以下是一个</st> <st c="37266">Python
    示例：</st>'
- en: '[PRE17]</st>'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[PRE17]</st>'
- en: '**<st c="37320">peek</st>**<st c="37325">: It is</st> <st c="37333">for retrieving
    the value of the top element without removing it from the stack.</st> <st c="37414">For
    the stack</st> **<st c="37428">[1, 2, 3]</st>**<st c="37437">, peeking would return</st>
    **<st c="37460">3</st>** <st c="37461">without altering the stack.</st> <st c="37490">The
    time complexity is</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1827.png)<st
    c="37513"><st c="37514">, as it only involves accessing the top element.</st>
    <st c="37563">A simple Python instruction is</st> <st c="37594">as follows:</st>'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="37320">peek</st>**<st c="37325">: 它用于获取栈顶元素的值，但不将其从栈中移除。</st> <st
    c="37333">对于栈</st> **<st c="37428">[1, 2, 3]</st>**<st c="37437">，peek 操作将返回</st>
    **<st c="37460">3</st>** <st c="37461">，并且不会改变栈的状态。</st> <st c="37490">时间复杂度为</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1827.png)<st
    c="37513"><st c="37514">，因为它只涉及访问栈顶元素。</st> <st c="37563">一个简单的 Python 指令如下：</st>'
- en: '[PRE18]</st>'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[PRE18]</st>'
- en: '**<st c="37629">search</st>**<st c="37636">: As usual, this is for finding
    an element in the stack.</st> <st c="37694">For example, if we search for element</st>
    **<st c="37732">2</st>** <st c="37733">in the stack</st> **<st c="37747">[1, 2,
    3]</st>**<st c="37756">, we would find it at position 1 from the top.</st> <st
    c="37803">Obviously, the time complexity of</st> **<st c="37837">search</st>**
    <st c="37843">in stacks is</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1828.png)<st
    c="37857"><st c="37858">, as it may require scanning through the entire stack
    from top to bottom.</st> <st c="37932">Let’s see a simple</st> <st c="37951">Python
    example:</st>'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="37629">search</st>**<st c="37636">: 通常用于在栈中查找一个元素。</st> <st c="37694">例如，如果我们在栈</st>
    **<st c="37732">[1, 2, 3]</st>**<st c="37733">中查找元素</st> **<st c="37747">2</st>**<st
    c="37756">，我们会在栈顶往下数第 1 位找到它。</st> <st c="37803">显然，栈中</st> **<st c="37837">search</st>**
    <st c="37843">操作的时间复杂度是</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math>](img/1828.png)<st
    c="37857"><st c="37858">，因为它可能需要从栈顶到栈底逐个扫描。</st> <st c="37932">让我们来看一个简单的</st>
    <st c="37951">Python 示例：</st>'
- en: '[PRE19]</st>'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[PRE19]</st>'
- en: '**<st c="38065">edit</st>**<st c="38070">: This modifies the value of the top
    element in the stack.</st> <st c="38130">If the top element of the stack</st>
    **<st c="38162">[1, 2, 3]</st>** <st c="38171">is</st> **<st c="38175">3</st>**
    <st c="38176">and we want to change it to</st> **<st c="38205">5</st>**<st c="38206">,
    the stack would become</st> **<st c="38231">[1, 2, 5]</st>**<st c="38240">. It
    does this operation in constant time (</st>![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1829.png)<st
    c="38283"><st c="38285">) since the operation only affects the top element.</st>
    <st c="38337">A Python code example is</st> <st c="38362">as follows:</st>'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="38065">edit</st>**<st c="38070">: 该操作修改栈顶元素的值。</st> <st c="38130">如果栈顶元素是</st>
    **<st c="38162">[1, 2, 3]</st>** <st c="38171">，其值为</st> **<st c="38175">3</st>**
    <st c="38176">，我们希望将其改为</st> **<st c="38205">5</st>**<st c="38206">，则栈会变为</st>
    **<st c="38231">[1, 2, 5]</st>**<st c="38240">。此操作的时间复杂度为常数时间（</st>![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1829.png)<st
    c="38283"><st c="38285">），因为该操作只影响栈顶元素。</st> <st c="38337">一个 Python 代码示例如下：</st>'
- en: '[PRE20]</st>'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[PRE20]</st>'
- en: <st c="38440">Some programming languages also support additional operations
    such as</st> `<st c="38511">isFull</st>`<st c="38517">, which checks whether the
    stack is full, and</st> `<st c="38563">isEmpty</st>`<st c="38570">, which determines
    whether the stack</st> <st c="38607">is empty.</st>
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="38440">一些编程语言还支持额外的操作，例如</st> `<st c="38511">isFull</st>`<st c="38517">，用于检查栈是否已满，以及</st>
    `<st c="38563">isEmpty</st>`<st c="38570">，用于判断栈是否为空。</st>
- en: <st c="38616">Stacks are extensively</st> <st c="38639">used in computer programming
    for several key applications.</st> <st c="38699">Here are a few important</st>
    <st c="38724">use cases:</st>
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="38616">栈在计算机编程中有着广泛的应用，涉及多个关键场景。</st> <st c="38699">以下是一些重要的</st> <st
    c="38724">使用案例：</st>
- en: <st c="38734">Stacks store function calls, pushing each invocation onto the
    stack and popping it when the</st> <st c="38827">function completes</st>
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="38734">栈用于存储函数调用，将每个调用压入栈中，并在</st> <st c="38827">函数完成时弹出</st>
- en: <st c="38845">They are used for converting and evaluating expressions, particularly
    for changing infix expressions to postfix or</st> <st c="38961">prefix notation</st>
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="38845">它们用于转换和评估表达式，特别是将中缀表达式转换为后缀或</st> <st c="38961">前缀表示法</st>
- en: <st c="38976">Stacks implement undo features in software, where each action
    is pushed onto the stack and can be undone by popping</st> <st c="39093">it off</st>
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="38976">栈在软件中实现撤销功能，每个操作都会压入栈中，可以通过弹出操作撤销</st> <st c="39093">它</st>
- en: <st c="39099">Stacks are a fundamental and versatile data structure used in
    many algorithms and applications.</st> <st c="39196">They provide efficient</st>
    `<st c="39219">push</st>` <st c="39223">and</st> `<st c="39228">pop</st>` <st
    c="39231">operations with a time complexity of</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1830.png)
    <st c="39269"><st c="39270">and are particularly useful in scenarios where the
    last element added needs to be the first one removed.</st> <st c="39376">However,
    their lack of random access and LIFO nature can make them less suitable for situations
    where elements need to be accessed in a different order.</st> <st c="39529">Understanding
    the trade-offs and appropriate use cases for stacks is essential for effective
    algorithm design and implementation.</st> <st c="39659">In the next section, we
    will explore queues, which operate in a manner opposite</st> <st c="39739">to
    stacks.</st></st>
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="39099">栈是许多算法和应用中使用的基础且多功能的数据结构。</st> <st c="39196">它们提供高效的</st> `<st
    c="39219">push</st>` <st c="39223">和</st> `<st c="39228">pop</st>` <st c="39231">操作，时间复杂度为</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1830.png)
    <st c="39269"><st c="39270">，特别适用于需要先入后出的场景。</st> <st c="39376">然而，它们缺乏随机访问和 LIFO
    特性，可能不适用于需要按不同顺序访问元素的情况。</st> <st c="39529">了解栈的权衡和适用场景对于有效的算法设计和实现至关重要。</st>
    <st c="39659">在下一节中，我们将探讨与栈相反操作的队列。</st> <st c="39739">队列。</st>
- en: <st c="39749">Queue</st>
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="39749">队列</st>
- en: '<st c="39755">A</st> **<st c="39758">queue</st>** <st c="39763">operates</st>
    <st c="39772">on the FIFO principle, meaning it has a behavior opposite to stacks:
    The first element added is the first to be removed.</st> <st c="39894">This structure
    is analogous to a line of people waiting for service: The first person in line
    is the first to be served.</st> <st c="40015">Queues are used in various scenarios,
    including task scheduling, buffering, and managing resources in</st> <st c="40117">computer
    systems.</st>'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="39755">一个</st> **<st c="39758">队列</st>** <st c="39763">按 FIFO 原则操作，这意味着它的行为与栈相反：第一个添加的元素是第一个被移除的。</st>
    <st c="39894">这种结构类似于排队等待服务的人群：排队的第一个人是第一个被服务的。</st> <st c="40015">队列用于多种场景，包括任务调度、缓冲和计算机系统中的资源管理。</st>
    <st c="40117">计算机系统中。</st>
- en: <st c="40134">Queues have several</st> <st c="40155">characteristics that influence
    their behavior</st> <st c="40201">and performance:</st>
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="40134">队列有几个</st> <st c="40155">影响其行为和性能的特点：</st> <st c="40201">和性能：</st>
- en: '**<st c="40217">FIFO order</st>**<st c="40228">: The first element inserted
    into the queue is the first one to</st> <st c="40293">be removed.</st>'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="40217">FIFO 顺序</st>**<st c="40228">：插入到队列中的第一个元素是第一个被</st> <st c="40293">移除的。</st>'
- en: '**<st c="40304">Operations at opposite ends</st>**<st c="40332">: Elements
    are added at the rear (end) of the queue and removed from the front (beginning)
    of</st> <st c="40427">the queue.</st>'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="40304">两端操作</st>**<st c="40332">：元素在队列的后端（末端）添加，并从队列的前端（开始）移除。</st>'
- en: '**<st c="40437">Dynamic size</st>**<st c="40450">: Queues</st> <st c="40460">can
    dynamically grow or shrink as elements are enqueued or dequeued.</st> <st c="40529">As
    we enqueue more elements, the size of the queue increases, and as we dequeue elements,
    the</st> <st c="40623">size decreases.</st>'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="40437">动态大小</st>**<st c="40450">：队列</st> <st c="40460">可以在元素入队或出队时动态增大或减小。</st>
    <st c="40529">当我们入队更多元素时，队列的大小会增加；当我们出队元素时，</st> <st c="40623">队列的大小会减少。</st>'
- en: '**<st c="40638">No random access</st>**<st c="40655">: Like stacks and unlike
    arrays, we cannot directly access elements at a specific index in a queue.</st>
    <st c="40756">Access is restricted to the front</st> <st c="40790">element only.</st>'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="40638">没有随机访问</st>**<st c="40655">：像栈一样，队列与数组不同，不能直接通过特定的索引访问元素。</st>
    <st c="40756">访问仅限于队列的前端</st> <st c="40790">元素。</st>'
- en: <st c="40803">Queues support some fundamental operations, each with specific
    performance characteristics.</st> <st c="40896">The following are the</st> <st
    c="40918">major operations:</st>
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="40803">队列支持一些基本操作，每个操作都有特定的性能特点。</st> <st c="40896">以下是主要操作：</st>
- en: '**<st c="40935">enqueue</st>**<st c="40943">: This</st> <st c="40950">involves
    adding a new element to the rear of the queue.</st> <st c="41007">Consider a queue
    that currently holds the elements</st> **<st c="41058">1</st>** <st c="41059">and</st>
    **<st c="41064">2</st>**<st c="41065">. Enqueuing</st> **<st c="41077">3</st>**
    <st c="41078">into the queue would place it at the rear, resulting in the queue</st>
    **<st c="41145">[1, 2, 3]</st>**<st c="41154">. This operation is performed in
    constant time or</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1189.png)<st
    c="41204"><st c="41205">, as the operation involves simply adding an element to
    the end of the queue.</st> <st c="41283">A simple Python example is</st> <st c="41310">as
    follows:</st>'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="40935">入队</st>**<st c="40943">：这涉及将一个新元素添加到队列的末尾。</st> <st c="41007">假设队列当前包含元素</st>
    **<st c="41058">1</st>** <st c="41059">和</st> **<st c="41064">2</st>**<st c="41065">。将</st>
    **<st c="41077">3</st>** <st c="41078">加入队列时，它会被放置在队列的末尾，结果是队列变为</st> **<st c="41145">[1,
    2, 3]</st>**<st c="41154">。此操作在常数时间内执行，或</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1189.png)<st
    c="41204"><st c="41205">，因为该操作仅涉及将元素添加到队列的末尾。</st> <st c="41283">一个简单的 Python
    示例如下：</st> <st c="41310">如下：</st>'
- en: '[PRE21]</st>'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[PRE21]</st>'
- en: '**<st c="41459">dequeue</st>**<st c="41467">: It</st> <st c="41473">removes
    the front element from the queue.</st> <st c="41515">If we dequeue the queue</st>
    **<st c="41539">[1, 2, 3]</st>**<st c="41548">, the front element</st> **<st c="41568">1</st>**
    <st c="41569">is removed, leaving us with the queue</st> **<st c="41608">[2, 3]</st>**<st
    c="41614">. Similar to</st> **<st c="41627">enqueue</st>**<st c="41634">, the
    time complexity here is</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:math>](img/1832.png)<st
    c="41664"><st c="41665">, as it involves removing the front element.</st> <st
    c="41710">Here is a simple</st> <st c="41727">Python instruction:</st>'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="41459">出队</st>**<st c="41467">：此操作用于移除队列的前端元素。</st> <st c="41515">如果我们出队队列</st>
    **<st c="41539">[1, 2, 3]</st>**<st c="41548">，前端元素</st> **<st c="41568">1</st>**
    <st c="41569">会被移除，剩下队列</st> **<st c="41608">[2, 3]</st>**<st c="41614">。与</st>
    **<st c="41627">入队</st>**<st c="41634">相似，此操作的时间复杂度是</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mfenced
    separators="|"><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:math>](img/1832.png)<st
    c="41664"><st c="41665">，因为它仅涉及移除前端元素。</st> <st c="41710">这里是一个简单的</st> <st c="41727">Python
    指令：</st>'
- en: '[PRE22]</st>'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[PRE22]</st>'
- en: '**<st c="41775">peek</st>**<st c="41780">: This is</st> <st c="41790">for retrieving
    the value of the front element without removing it from the queue and it performs
    in constant time.</st> <st c="41906">For the queue</st> **<st c="41920">[1, 2,
    3]</st>**<st c="41929">, peeking would return</st> **<st c="41952">1</st>** <st
    c="41953">without altering the queue.</st> <st c="41982">The Python instruction
    for peeking can be like</st> <st c="42029">the following:</st>'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="41775">查看队首</st>**<st c="41780">：此操作用于检索队列前端元素的值，而不将其从队列中移除，且此操作在常数时间内执行。</st>
    <st c="41906">对于队列</st> **<st c="41920">[1, 2, 3]</st>**<st c="41929">，查看队首会返回</st>
    **<st c="41952">1</st>** <st c="41953">，并且队列不发生变化。</st> <st c="41982">查看队首的 Python
    指令可以如下：</st> <st c="42029">如下：</st>'
- en: '[PRE23]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '**<st c="42068">search</st>**<st c="42075">: A</st> <st c="42080">queue conducts
    a search in linear time, as it may require scanning through the entire queue from
    front to rear.</st> <st c="42192">The following is a Python code implementing
    a search in</st> <st c="42248">a queue:</st>'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="42068">查找</st>**<st c="42075">：队列的查找操作是线性时间的，因为它可能需要从队列的前端扫描到队列的末尾。</st>
    <st c="42192">以下是实现队列查找的 Python 代码：</st> <st c="42248">如下：</st>'
- en: '[PRE24]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: <st c="42298">Some programming languages also support additional operations
    such as</st> `<st c="42369">isFull</st>`<st c="42375">, which checks whether the
    queue is full, and</st> `<st c="42421">isNull</st>`<st c="42427">, which determines
    whether the queue</st> <st c="42464">is empty.</st>
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="42298">一些编程语言还支持额外的操作，如</st> `<st c="42369">isFull</st>`<st c="42375">，用于检查队列是否已满，以及</st>
    `<st c="42421">isNull</st>`<st c="42427">，用于确定队列</st> <st c="42464">是否为空。</st>
- en: <st c="42473">Similar to stacks, queues</st> <st c="42499">have numerous applications
    in computer programming.</st> <st c="42552">A well-known example is</st> **<st
    c="42576">task scheduling</st>**<st c="42591">, where queues are used in operating
    systems to manage processes.</st> <st c="42657">Processes are enqueued when they
    are ready to run and dequeued once they are executed.</st> <st c="42744">Another
    example is buffering, where queues temporarily store data before it is processed,
    such as in print queues or streaming services.</st> <st c="42881">Lastly, queues
    play a crucial role in resource management, ensuring that access to shared resources
    is handled in the order requests</st> <st c="43014">are received.</st>
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="42473">类似于堆栈，队列</st> <st c="42499">在计算机编程中有着广泛的应用。</st> <st c="42552">一个著名的例子是</st>
    **<st c="42576">任务调度</st>**<st c="42591">，在操作系统中，队列被用来管理进程。</st> <st c="42657">当进程准备好运行时，它们会被加入队列，执行完毕后则会从队列中移除。</st>
    <st c="42744">另一个例子是缓冲，在这种情况下，队列临时存储数据，直到数据被处理，比如在打印队列或流媒体服务中。</st> <st c="42881">最后，队列在资源管理中起着至关重要的作用，确保对共享资源的访问是按照请求的顺序进行的。</st>
    <st c="43014">队列是一个基本的数据结构，广泛用于许多算法和应用，特别是在需要以FIFO方式管理任务或资源的场景中。</st>
- en: <st c="43027">Queues are a fundamental data structure used in many algorithms
    and applications, particularly in scenarios that require managing tasks or resources
    in a FIFO manner.</st> <st c="43195">They provide efficient enqueue and dequeue
    operations with a time complexity of</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1833.png)
    <st c="43275"><st c="43276">but do not allow random access to elements.</st> <st
    c="43321">Understanding the appropriate use cases for queues is essential for
    effective algorithm design and implementation.</st> <st c="43436">In the final
    section of this chapter, we expand on the concept of a queue by introducing a
    structure that has two ends, effectively combining the functionalities of both
    a stack and</st> <st c="43618">a queue.</st></st>
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="43027">队列提供高效的入队和出队操作，时间复杂度为</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1833.png)
    <st c="43275"><st c="43276">但不允许对元素进行随机访问。</st> <st c="43321">理解队列的适当使用场景对于有效的算法设计和实现至关重要。</st>
    <st c="43436">在本章的最后一节中，我们通过引入一种具有两个端点的结构，扩展了队列的概念，从而有效地结合了堆栈和</st> <st c="43618">队列的功能。</st></st>
- en: <st c="43626">Deque</st>
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="43626">双端队列</st>
- en: <st c="43632">A</st> **<st c="43635">deque</st>** <st c="43640">is a</st> <st
    c="43646">versatile data structure that allows the insertion and deletion of elements
    from both ends of the sequence, making it a generalization of both stacks and
    queues.</st> <st c="43808">Deques can operate as both a stack and a queue, providing
    greater flexibility in how elements are added</st> <st c="43912">or removed.</st>
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="43632">双端队列（Deque）</st> **<st c="43635">是一种</st>** <st c="43640">多功能的数据结构，允许从序列的两个端点插入和删除元素，使其成为堆栈和队列的广义形式。</st>
    <st c="43808">双端队列可以同时作为堆栈和队列使用，提供了更大的灵活性来处理元素的添加</st> <st c="43912">或移除。</st>
- en: <st c="43923">Let’s highlight the</st> <st c="43943">properties</st> <st c="43955">of
    deques:</st>
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="43923">让我们重点介绍一下</st> <st c="43943">双端队列（Deque）的</st> <st c="43955">特性：</st>
- en: '**<st c="43965">Insertions and deletions at both ends</st>**<st c="44003">:
    Elements can be added or removed from either the front or the rear of the deque.</st>
    <st c="44087">For example, we can push elements onto the front or rear of the
    deque and pop them off from either end</st> <st c="44190">as well.</st>'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="43965">在两个端点进行插入和删除</st>**<st c="44003">：元素可以从双端队列的前端或后端进行添加或移除。</st>
    <st c="44087">例如，我们可以将元素推入双端队列的前端或后端，并从任一端弹出它们。</st> <st c="44190">同样也可以进行操作。</st>'
- en: '**<st c="44198">No fixed direction</st>**<st c="44217">: Deques do not enforce
    a strict LIFO or FIFO order; instead, they allow operations at both ends.</st>
    <st c="44316">For instance, we can treat a deque as a stack by only using one
    end or as a queue by using</st> <st c="44407">both ends.</st>'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="44198">无固定方向</st>**<st c="44217">：双端队列不强制执行严格的LIFO或FIFO顺序；相反，它们允许在两端进行操作。</st>
    <st c="44316">例如，我们可以将双端队列视为栈，只使用一端，或视为队列，使用两端。</st>'
- en: '**<st c="44417">Dynamic size</st>**<st c="44430">: Deques can dynamically grow
    or shrink as elements are added or removed from</st> <st c="44509">either end.</st>'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="44417">动态大小</st>**<st c="44430">：双端队列可以随着元素的添加或删除动态增长或收缩。</st>'
- en: '**<st c="44520">No random access</st>**<st c="44537">: Like stacks and queues,
    deques do not allow direct access to elements at a</st> <st c="44615">specific
    index.</st>'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="44520">无随机访问</st>**<st c="44537">：像栈和队列一样，双端队列不允许直接访问指定索引处的元素。</st>'
- en: <st c="44630">Deques support a wide range of operations, each with specific
    performance characteristics.</st> <st c="44722">The following</st> <st c="44736">are
    the major operations, along with their time complexities</st> <st c="44797">and
    examples:</st>
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="44630">双端队列支持多种操作，每种操作具有特定的性能特点。</st> <st c="44722">以下是主要操作及其时间复杂度</st>
    <st c="44736">和示例：</st>
- en: '**<st c="44810">Add to front (insert at the front)</st>**<st c="44845">: This
    involves adding a new element to the front of the deque.</st> <st c="44910">For
    example, if the deque currently holds</st> **<st c="44952">[2, 3]</st>**<st c="44958">,
    adding</st> **<st c="44967">1</st>** <st c="44968">to the front would result in</st>
    **<st c="44998">[1, 2, 3]</st>**<st c="45007">. This is done in constant time,
    as the operation involves simply adding an element to the front.</st> <st c="45105">Here
    is a simple piece of</st> <st c="45131">Python code:</st>'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="44810">从前端添加（在前端插入）</st>**<st c="44845">：此操作将一个新元素添加到双端队列的前端。</st>
    <st c="44910">例如，如果当前双端队列为</st> **<st c="44952">[2, 3]</st>**<st c="44958">，将</st>
    **<st c="44967">1</st>** <st c="44968">添加到前端，将变成</st> **<st c="44998">[1, 2, 3]</st>**<st
    c="45007">。此操作在常数时间内完成，因为它只涉及将元素添加到前端。</st> <st c="45105">下面是一个简单的</st> <st c="45131">Python代码：</st>'
- en: '[PRE25]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '**<st c="45241">Add to rear (insert at the rear)</st>**<st c="45274">: This
    adds a new element to the rear of the deque.</st> <st c="45327">If the deque currently
    holds</st> **<st c="45356">[1, 2]</st>**<st c="45362">, adding</st> **<st c="45371">3</st>**
    <st c="45372">to the rear would result in</st> **<st c="45401">[1, 2, 3]</st>**<st
    c="45410">. Similar to</st> *<st c="45423">add to front</st>*<st c="45435">, the
    time complexity is</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1425.png)<st
    c="45460"><st c="45461">. The following is a simple Python instruction to do</st>
    <st c="45514">this operation:</st>'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="45241">从后端添加（在后端插入）</st>**<st c="45274">：此操作将一个新元素添加到双端队列的后端。</st>
    <st c="45327">如果当前双端队列为</st> **<st c="45356">[1, 2]</st>**<st c="45362">，将</st>
    **<st c="45371">3</st>** <st c="45372">添加到后端，将变成</st> **<st c="45401">[1, 2, 3]</st>**<st
    c="45410">。与</st> *<st c="45423">从前端添加</st>*<st c="45435">类似，时间复杂度为</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1425.png)<st
    c="45460"><st c="45461">。下面是一个简单的Python指令来执行</st> <st c="45514">此操作：</st>'
- en: '[PRE26]</st>'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[PRE26]</st>'
- en: '**<st c="45566">Remove from front (delete from the front)</st>**<st c="45608">:
    This operation removes the front</st> <st c="45644">element from the deque in
    constant time.</st> <st c="45685">If we remove the front element from the deque</st>
    **<st c="45731">[1, 2, 3]</st>**<st c="45740">, it becomes</st> **<st c="45753">[2,
    3]</st>**<st c="45759">. A simple Python instruction to execute the</st> *<st
    c="45804">remove from front</st>* <st c="45821">operation is</st> <st c="45835">as
    follows:</st>'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="45566">从前端删除（从前端删除）</st>**<st c="45608">：此操作以常数时间从双端队列的前端删除元素。</st>
    <st c="45685">如果我们从双端队列</st> **<st c="45731">[1, 2, 3]</st>**<st c="45740">删除前端元素，它将变为</st>
    **<st c="45753">[2, 3]</st>**<st c="45759">。执行</st> *<st c="45804">从前端删除</st>*
    <st c="45821">操作的简单Python指令如下：</st>'
- en: '[PRE27]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '**<st c="45872">Remove from rear (delete from the rear)</st>**<st c="45912">:
    Similar to the previous operation, only from the rear of the deque.</st> <st c="45983">The
    Python code for this operation is</st> <st c="46021">as follows:</st>'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="45872">从后端删除（从后端删除）</st>**<st c="45912">：与前一个操作类似，只是从双端队列的后端删除元素。</st>
    <st c="45983">执行此操作的Python代码如下：</st>'
- en: '[PRE28]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '**<st c="46055">Peek (access the front or rear element)</st>**<st c="46095">:
    Retrieve the value of the front or rear element without removing it from the deque
    in constant time.</st> <st c="46199">For the deque</st> **<st c="46213">[1, 2,
    3]</st>**<st c="46222">, peeking the front would return</st> **<st c="46255">1</st>**<st
    c="46256">, and peeking the rear would</st> <st c="46285">return</st> **<st c="46292">3</st>**<st
    c="46293">:</st>'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="46055">Peek（访问前端或后端元素）</st>**<st c="46095">：在常数时间内检索前端或后端元素的值，而不将其从双端队列中移除。</st>
    <st c="46199">对于双端队列</st> **<st c="46213">[1, 2, 3]</st>**<st c="46222">，查看前端将返回</st>
    **<st c="46255">1</st>**<st c="46256">，查看后端将返回</st> <st c="46285">3</st>**<st
    c="46292">：</st>'
- en: '[PRE29]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: <st c="46465">It’s important to note that many of the functions used for a deque
    may or may not be supported by different programming languages.</st> <st c="46597">Fortunately,
    Python provides built-in support for</st> <st c="46647">these functions.</st>
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="46465">需要注意的是，许多用于双端队列的函数可能会或不会被不同的编程语言支持。</st> <st c="46597">幸运的是，Python
    提供了对</st> <st c="46647">这些函数的内置支持。</st>
- en: <st c="46663">Deques have several important use cases in computer programming.</st>
    <st c="46729">One key example is task scheduling, where deques are used in scheduling
    algorithms to add or remove tasks from either end of the queue as needed.</st>
    <st c="46875">Another use case is in sliding window algorithms, where deques are
    employed to efficiently manage elements as they are added or removed from the
    window while it moves across a dataset.</st> <st c="47060">Lastly, deques are
    also used in implementing undo/redo functionality in applications, allowing actions
    to be added or removed from either end of</st> <st c="47205">the deque.</st>
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="46663">双端队列在计算机编程中有几个重要的应用场景。</st> <st c="46729">一个关键的例子是任务调度，在任务调度算法中，双端队列被用于根据需要从队列的两端添加或移除任务。</st>
    <st c="46875">另一个应用场景是在滑动窗口算法中，双端队列被用来高效管理元素，随着窗口在数据集上滑动，元素被添加或移除。</st> <st c="47060">最后，双端队列也被用于实现应用程序中的撤销/重做功能，允许从队列的任意一端添加或移除操作。</st>
- en: <st c="47215">Deques are a flexible</st> <st c="47238">data structure that generalizes
    both stacks and queues, allowing insertion and deletion at both ends.</st> <st
    c="47340">They provide efficient operations with a time complexity of</st> ![<mml:math
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1189.png)
    <st c="47400"><st c="47401">for adding or removing elements at either end.</st>
    <st c="47449">Deques are particularly useful in scenarios where elements need
    to be managed from both ends, such as task scheduling, sliding window algorithms,
    and undo/redo functionality.</st> <st c="47624">Understanding the appropriate
    use cases for deques is essential for effective algorithm design</st> <st c="47719">and
    implementation.</st></st>
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="47215">双端队列是一种灵活的</st> <st c="47238">数据结构，它综合了栈和队列的特点，允许在两端进行插入和删除操作。</st>
    <st c="47340">它们提供高效的操作，时间复杂度为</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math>](img/1189.png)
    <st c="47400"><st c="47401">，用于在任意一端添加或移除元素。</st> <st c="47449">双端队列在需要从两端管理元素的场景中特别有用，如任务调度、滑动窗口算法以及撤销/重做功能。</st>
    <st c="47624">理解双端队列的适用场景对于有效的算法设计</st> <st c="47719">和实现至关重要。</st>
- en: <st c="47738">Summary</st>
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="47738">总结</st>
- en: <st c="47746">In this chapter, we explored various linear data structures, focusing
    on their definitions, characteristics, and operations.</st> <st c="47872">We began
    with an in-depth look at arrays and linked lists, examining how they handle fundamental
    operations such as insertion, deletion, and searching.</st> <st c="48024">We discussed
    the trade-offs between these structures, noting the efficiency of arrays in accessing
    elements and the flexibility of linked lists in dynamic memory allocation.</st>
    <st c="48198">The chapter also covered more advanced linear structures such as
    stacks, queues, and deques, illustrating their practical applications in computer
    programming, from task scheduling to expression evaluation and</st> <st c="48408">resource
    management.</st>
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="47746">在这一章中，我们探讨了各种线性数据结构，重点关注它们的定义、特性和操作。</st> <st c="47872">我们首先深入研究了数组和链表，分析了它们如何处理基本操作，如插入、删除和查找。</st>
    <st c="48024">我们讨论了这些结构之间的权衡，指出数组在访问元素方面的高效性，以及链表在动态内存分配方面的灵活性。</st> <st c="48198">本章还介绍了更高级的线性结构，如栈、队列和双端队列，展示了它们在计算机编程中的实际应用，从任务调度到表达式求值和</st>
    <st c="48408">资源管理。</st>
- en: <st c="48428">We then introduced the skip list, a probabilistic data structure
    that combines the advantages of both arrays and linked lists, offering efficient
    search, insertion, and deletion operations.</st> <st c="48619">Through detailed
    examples, we demonstrated how skip lists improve upon the limitations of traditional
    linked lists.</st> <st c="48735">As we concluded the chapter, we emphasized the
    importance of understanding the appropriate use cases for each data structure
    to optimize algorithm design.</st> <st c="48890">You now have a thorough understanding
    of linear data structures, which play a crucial role in algorithm design.</st>
    <st c="49002">In the next chapter, we will shift our focus to non-linear data
    structures, exploring their unique properties</st> <st c="49112">and applications.</st>
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="48428">接着，我们介绍了跳表，一种概率性数据结构，它结合了数组和链表的优点，提供了高效的查找、插入和删除操作。</st> <st c="48619">通过详细示例，我们展示了跳表如何改进传统链表的局限性。</st>
    <st c="48735">在本章的结尾，我们强调了理解每种数据结构的适用场景的重要性，以优化算法设计。</st> <st c="48890">现在，你已经对线性数据结构有了透彻的了解，这些数据结构在算法设计中起着至关重要的作用。</st>
    <st c="49002">在下一章中，我们将转向非线性数据结构，探讨它们独特的特性</st> <st c="49112">和应用。</st>
- en: <st c="49129">References and further reading</st>
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="49129">参考文献及进一步阅读</st>
- en: '*<st c="49160">Introduction to Algorithms</st>*<st c="49187">. By Thomas H.</st>
    <st c="49202">Cormen, Charles E.</st> <st c="49221">Leiserson, Ronald L.</st>
    <st c="49242">Rivest, and Clifford Stein.</st> <st c="49270">Fourth Edition.</st>
    <st c="49286">MIT</st> <st c="49290">Press.</st> <st c="49297">2022:</st>'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*<st c="49160">算法导论</st>*<st c="49187">. 作者：Thomas H.</st> <st c="49202">Cormen，Charles
    E.</st> <st c="49221">Leiserson，Ronald L.</st> <st c="49242">Rivest，和Clifford
    Stein.</st> <st c="49270">第四版.</st> <st c="49286">MIT</st> <st c="49290">Press.</st>
    <st c="49297">2022年：</st>'
- en: '*<st c="49302">Chapter 10</st>*<st c="49313">,</st> *<st c="49315">Elementary</st>*
    *<st c="49326">Data Structures</st>*'
  id: totrans-257
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*<st c="49302">第10章</st>*<st c="49313">,</st> *<st c="49315">基本</st>* *<st
    c="49326">数据结构</st>*'
- en: '*<st c="49341">Algorithms</st>*<st c="49352">. By R.</st> <st c="49360">Sedgewick,
    K.</st> <st c="49374">Wayne.</st> <st c="49381">Fourth Edition.</st> <st c="49397">Addison-Wesley.</st>
    <st c="49413">2011:</st>'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*<st c="49341">算法</st>*<st c="49352">. 作者：R.</st> <st c="49360">Sedgewick，K.</st>
    <st c="49374">Wayne.</st> <st c="49381">第四版.</st> <st c="49397">Addison-Wesley.</st>
    <st c="49413">2011年：</st>'
- en: '*<st c="49418">Chapter</st>* *<st c="49427">1</st>*<st c="49428">,</st> *<st
    c="49430">Fundamentals</st>*'
  id: totrans-259
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*<st c="49418">第1章</st>* *<st c="49427">,</st>* *<st c="49430">基础知识</st>*'
- en: '*<st c="49442">Data Structures and Algorithm Analysis in C++</st>*<st c="49488">.
    By Mark A.</st> <st c="49501">Weiss.</st> <st c="49508">Fourth Edition.</st> <st
    c="49524">Pearson.</st> <st c="49533">2012:</st>'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*<st c="49442">C++中的数据结构与算法分析</st>*<st c="49488">. 作者：Mark A.</st> <st c="49501">Weiss.</st>
    <st c="49508">第四版.</st> <st c="49524">Pearson.</st> <st c="49533">2012年：</st>'
- en: '*<st c="49538">Chapter 3</st>*<st c="49548">,</st> *<st c="49550">Lists, Stacks,</st>*
    *<st c="49565">and Queues</st>*'
  id: totrans-261
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*<st c="49538">第3章</st>*<st c="49548">,</st> *<st c="49550">列表、栈</st>* *<st
    c="49565">和队列</st>*'
