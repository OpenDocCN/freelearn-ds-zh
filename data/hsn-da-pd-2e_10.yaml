- en: '*Chapter 7*: Financial Analysis – Bitcoin and the Stock Market'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第7章*：金融分析——比特币与股票市场'
- en: It's time to switch gears and work on an application. In this chapter, we will
    explore a financial application by performing an analysis of bitcoin and the stock
    market. This chapter builds upon everything we have learned so far—we will extract
    data from the Internet; perform some exploratory data analysis; create visualizations
    with `pandas`, `seaborn`, and `matplotlib`; calculate important metrics for analyzing
    the performance of financial instruments using `pandas`; and get a taste of building
    some models. Note that we are not trying to learn financial analysis here, but
    rather walk through an introduction of how the skills we have learned in this
    book can be applied to financial analysis.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候转变思路并开始开发一个应用程序了。在本章中，我们将通过分析比特币和股票市场来探索一个金融应用。 本章将建立在我们迄今为止学到的所有知识基础上——我们将从互联网提取数据；进行一些探索性数据分析；使用`pandas`、`seaborn`和`matplotlib`创建可视化；计算分析金融工具性能的关键指标；并初步体验模型构建。请注意，我们这里并不是要学习金融分析，而是通过介绍如何将本书中学到的技能应用于金融分析。
- en: This chapter is also a departure from the standard workflow in this book. Up
    until this point, we have been working with Python as more of a functional programming
    language. However, Python also supports `StockReader` class), visualizing financial
    assets (with the `Visualizer` classes), calculating financial metrics (with the
    `StockAnalyzer` class), and modeling financial data (with the `StockModeler` class).
    Since we will need a lot of code to make the analysis process clean and easy to
    reproduce, we will build a Python package to house these classes. The code will
    be reproduced in the text and explained as usual; however, we don't need to type/run
    it on our own—be sure to read the *Chapter materials* section for this chapter
    to get set up properly.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章也是本书中标准工作流程的一次突破。到目前为止，我们一直将Python作为一种功能性编程语言来使用。然而，Python也支持面向对象编程，例如`StockReader`类（用于获取数据）、`Visualizer`类（用于可视化金融资产）、`StockAnalyzer`类（用于计算金融指标）以及`StockModeler`类（用于建模金融数据）。由于我们需要大量代码来使分析过程简洁且易于复现，我们将构建一个Python包来存放这些类。代码将在文中展示并逐步解释；然而，我们不需要自己键入或运行它——确保阅读本章的*本章材料*部分，正确设置环境。
- en: This chapter will be challenging and may require a few rereads; however, it
    will teach best practices, and the skills acquired here will dramatically improve
    your coding skills, which will quickly pay off. One main takeaway should be that
    OOP can be very helpful in packaging up analysis tasks. Each class should have
    a single purpose and be well documented. If we have many classes, we should spread
    them across separate files and make a package. This makes it very easy for others
    to install/use them and for us to standardize the way certain tasks are performed
    across a project. As an example, we shouldn't have each of our collaborators on
    a project writing their own functions to connect to a database. Standardized,
    well-documented code will save lots of headaches down the road.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将具有一定挑战性，可能需要多读几遍；然而，它将教会你最佳实践，并且在这里学到的技能将大大提高你的编程能力，这些技能会迅速带来回报。一个主要的收获应该是，面向对象编程（OOP）在打包分析任务方面非常有帮助。每个类应该有一个单一的目标，并且要有良好的文档。如果我们有许多类，应该将它们分布到不同的文件中，创建一个包。这样，其他人就能很容易地安装/使用它们，我们也能标准化在整个项目中执行某些任务的方式。举个例子，我们不应该让项目中的每个合作者都写自己的数据库连接函数。标准化且良好文档化的代码将节省很多后续麻烦。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Building a Python package
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建一个Python包
- en: Collecting financial data
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 收集金融数据
- en: Conducting exploratory data analysis
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进行探索性数据分析
- en: Performing technical analysis of financial instruments
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对金融工具进行技术分析
- en: Modeling performance using historical data
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用历史数据建模性能
- en: Chapter materials
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本章材料
- en: 'For this chapter, we will be creating our own package for stock analysis. This
    makes it extremely easy for us to distribute our code and for others to use our
    code. The final product of this package is on GitHub at [https://github.com/stefmolin/stock-analysis/tree/2nd_edition](https://github.com/stefmolin/stock-analysis/tree/2nd_edition).
    Python''s package manager, `pip`, is capable of installing packages from GitHub
    and also building them locally; this leaves us with either of the following choices
    as to how we want to proceed:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，我们将创建自己的股票分析包。这使得我们非常容易分发我们的代码，并且其他人也能使用我们的代码。该包的最终产品已上传至 GitHub：[https://github.com/stefmolin/stock-analysis/tree/2nd_edition](https://github.com/stefmolin/stock-analysis/tree/2nd_edition)。Python
    的包管理工具 `pip` 可以从 GitHub 安装包，也可以本地构建包；因此，我们可以选择以下任意方式继续操作：
- en: Install from GitHub if we don't plan on editing the source code for our own
    use.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们不打算修改源代码以供个人使用，可以从 GitHub 安装。
- en: Fork and clone the repository and then install it on our machine in order to
    modify the code.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Fork 并克隆仓库，然后在本地机器上安装它，以便修改代码。
- en: 'If we wish to install from GitHub directly, we don''t need to do anything here
    since this was installed when we set up our environment back in [*Chapter 1*](B16834_01_Final_SK_ePub.xhtml#_idTextAnchor015),
    *Introduction to Data Analysis*; however, for reference, we would do the following
    to install packages from GitHub:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望直接从 GitHub 安装，这里不需要做任何操作，因为在[*第一章*](B16834_01_Final_SK_ePub.xhtml#_idTextAnchor015)中设置环境时已经完成了安装，*数据分析入门*；不过，作为参考，我们可以执行以下操作来从
    GitHub 安装包：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Tip
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: The `@2nd_edition` portion of the URL tells `pip` to install the version that
    was tagged `2nd_edition`. To install the version of the code on a particular branch
    instead, replace this with `@<branch_name>`. For example, if we want the code
    being developed on a branch called `dev`, we use `@dev`. Be sure to check that
    the branch exists first, of course. We can also use the commit hash in the same
    fashion to grab a specific commit. More information is available at [https://pip.pypa.io/en/latest/reference/pip_install/#git](https://pip.pypa.io/en/latest/reference/pip_install/#git).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: URL 中的`@2nd_edition`部分告诉`pip`安装标记为`2nd_edition`的版本。要安装特定分支上的版本，只需将其替换为`@<branch_name>`。例如，如果我们希望安装在名为`dev`的分支上开发的代码，可以使用`@dev`。当然，务必先检查该分支是否存在。我们还可以使用提交哈希值以相同方式抓取特定的提交。有关更多信息，请访问[https://pip.pypa.io/en/latest/reference/pip_install/#git](https://pip.pypa.io/en/latest/reference/pip_install/#git)。
- en: 'To install locally in editable mode—meaning that any changes will automatically
    be reflected locally without having to reinstall—we use the `-e` flag. Run the
    following from the command line in the virtual environment we created in [*Chapter
    1*](B16834_01_Final_SK_ePub.xhtml#_idTextAnchor015), *Introduction to Data Analysis*,
    to do so. Note that this will clone the latest version of the package, which may
    be different from the version in the text (the version with the `2nd_edition`
    tag):'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 若要在可编辑模式下本地安装—即任何更改会自动在本地反映，而无需重新安装—我们使用`-e`标志。请在我们在[*第一章*](B16834_01_Final_SK_ePub.xhtml#_idTextAnchor015)中创建的虚拟环境的命令行中运行以下命令。请注意，这将克隆该包的最新版本，可能与书中的版本不同（即带有`2nd_edition`标签的版本）：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Important note
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'This example uses `git clone` over SSH; if SSH keys are not set up already,
    clone over HTTPS instead by using a variation of the URL: `https://github.com/stefmolin/stock-analysis.git`.
    Alternatively, follow the instructions on GitHub for generating SSH keys first.
    Consult this Stack Overflow post if you''re interested in just cloning the version
    with the `2nd_edition` tag: [https://stackoverflow.com/questions/20280726/how-to-git-clone-a-specific-tag](https://stackoverflow.com/questions/20280726/how-to-git-clone-a-specific-tag).'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例使用的是通过 SSH 克隆`git clone`；如果尚未设置 SSH 密钥，请改为通过 HTTPS 克隆，使用如下 URL：`https://github.com/stefmolin/stock-analysis.git`。或者，可以按照
    GitHub 上的说明首先生成 SSH 密钥。如果你有兴趣只克隆带有`2nd_edition`标签的版本，请参考这个 Stack Overflow 贴文：[https://stackoverflow.com/questions/20280726/how-to-git-clone-a-specific-tag](https://stackoverflow.com/questions/20280726/how-to-git-clone-a-specific-tag)。
- en: We will be using this package throughout this chapter. The directory for this
    chapter in this book's repository has the `financial_analysis.ipynb` notebook
    we will use for our actual analysis and can be found at [https://github.com/stefmolin/Hands-On-Data-Analysis-with-Pandas-2nd-edition/tree/master/ch_07](https://github.com/stefmolin/Hands-On-Data-Analysis-with-Pandas-2nd-edition/tree/master/ch_07).
    The `data/` folder contains backup files in case the data sources have changed
    since publication or there are any errors when collecting the data with the `StockReader`
    class; simply read in the CSV files and follow along with the rest of this chapter
    should this happen. Similarly, the `exercises/` folder contains backup files for
    the exercises.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中使用此包。本书仓库中本章的目录包含我们实际分析时将使用的`financial_analysis.ipynb`笔记本，地址为[https://github.com/stefmolin/Hands-On-Data-Analysis-with-Pandas-2nd-edition/tree/master/ch_07](https://github.com/stefmolin/Hands-On-Data-Analysis-with-Pandas-2nd-edition/tree/master/ch_07)。`data/`文件夹包含备份文件，以防数据源自发布以来有所更改，或使用`StockReader`类收集数据时出现错误；如果发生这种情况，只需读取CSV文件并按照本章剩余内容进行操作。同样，`exercises/`文件夹也包含练习的备份文件。
- en: Important note
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: If we change a file in a package installed in editable mode when working with
    Jupyter Notebooks, we will need to restart our kernel or open a new Python shell
    and reimport the package. This is because Python will cache it after import. Other
    options include using `importlib.reload()` or the IPython `autoreload` extension
    ([https://ipython.readthedocs.io/en/stable/config/extensions/autoreload.html](https://ipython.readthedocs.io/en/stable/config/extensions/autoreload.html)).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在使用Jupyter Notebook时修改了一个以可编辑模式安装的包中的文件，我们需要重新启动内核或打开一个新的Python shell并重新导入该包。这是因为Python会在导入后缓存它。其他选项包括使用`importlib.reload()`或IPython的`autoreload`扩展（[https://ipython.readthedocs.io/en/stable/config/extensions/autoreload.html](https://ipython.readthedocs.io/en/stable/config/extensions/autoreload.html)）。
- en: Building a Python package
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建一个Python包
- en: Building packages is considered good coding practice since it allows for writing
    modular code and reuse. `matplotlib` to plot something, we don't need to know
    what the code inside the functions we call is doing exactly—it suffices to simply
    know what the input and output will be to build on top of it.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 构建包被视为良好的编码实践，因为它允许编写模块化代码并实现重用。使用`matplotlib`绘制图形时，我们不需要知道我们调用的函数内部到底在做什么——只需了解输入和输出是什么，就足以在其基础上进行构建。
- en: Package structure
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 包结构
- en: A `window_calc.py` from [*Chapter 4*](B16834_04_Final_SK_ePub.xhtml#_idTextAnchor082),
    *Aggregating Pandas DataFrames*, and `viz.py` from [*Chapter 6*](B16834_06_Final_SK_ePub.xhtml#_idTextAnchor125),
    *Plotting with Seaborn and Customization Techniques*, were both modules. A **package**
    is a collection of modules organized into directories. Packages can also be imported,
    but when we import a package we have access to certain modules inside, so we don't
    have to import each one individually. This also allows us to build modules that
    import from each other without the need to maintain a single very large module.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`window_calc.py`来自[*第4章*](B16834_04_Final_SK_ePub.xhtml#_idTextAnchor082)，*聚合Pandas
    DataFrame*，以及`viz.py`来自[*第6章*](B16834_06_Final_SK_ePub.xhtml#_idTextAnchor125)，*使用Seaborn绘图与自定义技巧*，这两个都是模块。**包**是由组织成目录的模块集合。包也可以被导入，但当我们导入一个包时，我们可以访问其中的某些模块，这样就不必单独导入每一个模块。这还允许我们构建可以相互导入的模块，而不必维护一个非常大的模块。'
- en: 'To turn modules into a package, we follow these steps:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将模块转化为包，我们按照以下步骤进行：
- en: Create a directory with the name of the package (`stock_analysis` for this chapter).
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为包的目录（本章使用`stock_analysis`）。
- en: Place the modules in the aforementioned directory.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将模块放置在上述目录中。
- en: Add an `__init__.py` file containing any Python code to run upon importing the
    package (this can be—and often is—empty).
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`__init__.py`文件，其中包含导入包时要执行的任何Python代码（这个文件可以为空，也经常是空的）。
- en: Make a `setup.py` file at the same level as the package's top-level directory
    (`stock_analysis` here), which will give `pip` instructions on how to install
    the package. See the *Further reading* section for information on creating this.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在包的顶层目录（此处为`stock_analysis`）的同级别创建一个`setup.py`文件，它将向`pip`提供有关如何安装该包的指令。有关创建此文件的详细信息，请参见*进一步阅读*部分。
- en: 'Once the aforementioned steps are complete, the package can be installed with
    `pip`. Note that, while our package only contains a single directory, we can build
    a package with as many subpackages as we desire. These subpackages are created
    just as if we were creating a package, with the exception that they don''t need
    a `setup.py` file:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦上述步骤完成，可以使用 `pip` 安装该包。请注意，尽管我们的包仅包含一个目录，但我们可以根据需要构建包含多个子包的包。这些子包的创建与创建包时类似，唯一不同的是它们不需要
    `setup.py` 文件：
- en: Create a directory for the subpackage inside the main package directory (or
    inside some other subpackage).
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主包目录（或某个其他子包内）创建一个子包目录。
- en: Place the subpackage's modules in this directory.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将子包的模块放入该目录。
- en: Add the `__init__.py` file, with code that should be run when the subpackage
    is imported (this can be empty).
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `__init__.py` 文件，其中包含当导入子包时应执行的代码（此文件可以为空）。
- en: 'The directory hierarchy for a package with a single subpackage would look something
    like this:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一个包含单个子包的包的目录层次结构大致如下所示：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Some other things to be aware of when building a package include the following:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 构建包时需要注意的其他事项包括以下内容：
- en: Writing a **README** file for the repository so that others know what it contains
    (see [https://www.makeareadme.com/](https://www.makeareadme.com/)).
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为仓库编写**README**文件，以便他人了解它包含的内容（见：[https://www.makeareadme.com/](https://www.makeareadme.com/)）。
- en: '`pylint` package at [https://www.pylint.org/](https://www.pylint.org/)).'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pylint` 包，网址：[https://www.pylint.org/](https://www.pylint.org/))。'
- en: Adding tests that will make sure changes to the code don't break anything and
    that the code does what it is meant to do (take a look at the `pytest` package
    at [https://docs.pytest.org/en/latest/](https://docs.pytest.org/en/latest/)).
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加测试，确保代码修改不会破坏任何功能，并且代码能够按预期工作（请查看 `pytest` 包，网址：[https://docs.pytest.org/en/latest/](https://docs.pytest.org/en/latest/)）。
- en: Overview of the stock_analysis package
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: stock_analysis 包概述
- en: 'In this chapter, we will be creating a Python package called `stock_analysis`
    using the various Python packages we have discussed so far, along with the Python
    standard library. This package is located in the `stock-analysis` repository ([https://github.com/stefmolin/stock-analysis](https://github.com/stefmolin/stock-analysis)),
    which is arranged like this:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用迄今为止讨论的各种 Python 包以及 Python 标准库，创建一个名为 `stock_analysis` 的 Python 包。该包位于
    `stock-analysis` 仓库中（[https://github.com/stefmolin/stock-analysis](https://github.com/stefmolin/stock-analysis)），其结构如下：
- en: '![Figure 7.1 – Structure of the stock-analysis repository'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.1 – stock-analysis 仓库的结构'
- en: '](img/Figure_7.1_B16834.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.1_B16834.jpg)'
- en: Figure 7.1 – Structure of the stock-analysis repository
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1 – stock-analysis 仓库的结构
- en: 'The modules in our package will contain custom classes for conducting the technical
    analysis of an asset. **Classes** should be designed for a single purpose; this
    makes it easier to build, use, and debug if issues arise. Therefore, we will be
    building several classes in order to cover the various facets of our financial
    analysis. We will need a class for each of the following purposes:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们包中的模块将包含用于进行资产技术分析的自定义类。**类**应为单一目的而设计，这样有助于构建、使用和调试，特别是当出现问题时。因此，我们将构建多个类，以覆盖财务分析的各个方面。我们需要为以下每个目的创建一个类：
- en: '![Figure 7.2 – Main themes and classes for the stock_analysis package'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.2 – stock_analysis 包的主要主题和类'
- en: '](img/Figure_7.2_B16834.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.2_B16834.jpg)'
- en: Figure 7.2 – Main themes and classes for the stock_analysis package
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.2 – stock_analysis 包的主要主题和类
- en: It can be helpful to visualize the interaction between modules in a package
    and the functionality each class provides. For this purpose, we can build **Unified
    Modeling Language** (**UML**) diagrams.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 可视化包中模块之间的交互及每个类所提供的功能是很有帮助的。为此，我们可以构建**统一建模语言**（**UML**）图。
- en: UML diagrams
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UML 图
- en: '`utils.py` for utility functions:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`utils.py` 用于工具函数：'
- en: '![Figure 7.3 – Module dependencies in the stock_analysis package'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.3 – stock_analysis 包的模块依赖关系'
- en: '](img/Figure_7.3_B16834.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.3_B16834.jpg)'
- en: Figure 7.3 – Module dependencies in the stock_analysis package
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.3 – stock_analysis 包的模块依赖关系
- en: Tip
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'The `pylint` package comes with `pyreverse`, which makes UML diagrams. If `graphviz`
    is installed ([http://www.graphviz.org/download/](http://www.graphviz.org/download/)),
    running the following from the command line generates a PNG file for the relationship
    between modules and a UML diagram for the classes (provided the repository was
    cloned and `pylint` is installed): `pyreverse -o png stock_analysis`'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`pylint`包附带了`pyreverse`，它可以生成UML图。如果已安装`graphviz`（[http://www.graphviz.org/download/](http://www.graphviz.org/download/)），从命令行运行以下命令可以生成PNG文件，显示模块之间的关系以及类的UML图（前提是已克隆代码库并安装了`pylint`）：`pyreverse
    -o png stock_analysis`'
- en: 'The UML diagram for the classes in the `stock_analysis` package looks like
    this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`stock_analysis`包中类的UML图如下所示：'
- en: '![Figure 7.4 – UML diagrams for classes in the stock_analysis package'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.4 – `stock_analysis`包中类的UML图'
- en: '](img/Figure_7.4_B16834.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.4_B16834.jpg)'
- en: Figure 7.4 – UML diagrams for classes in the stock_analysis package
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.4 – `stock_analysis`包中类的UML图
- en: The top section in each box contains the class name; the middle section contains
    the attributes of that class; while the bottom section contains any methods defined
    in that class. Notice the arrows pointing from the `AssetGroupVisualizer` and
    `StockVisualizer` classes to the `Visualizer` class? This means that both are
    a type of `Visualizer`. The methods shown for the `AssetGroupVisualizer` and `StockVisualizer`
    classes are defined differently in those classes compared to the `Visualizer`
    class. We will cover this in more depth in the *Exploratory data analysis* section.
    Throughout the remaining sections of this chapter, we will be going over each
    of the classes in the `stock_analysis` package in more detail and using their
    functionality to perform technical analysis of financial assets.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 每个框的顶部部分包含类名；中间部分包含该类的属性；底部部分包含该类中定义的任何方法。注意从`AssetGroupVisualizer`和`StockVisualizer`类指向`Visualizer`类的箭头吗？这意味着这两个类都是`Visualizer`的一种类型。对于`AssetGroupVisualizer`和`StockVisualizer`类所显示的方法，它们在这些类中与`Visualizer`类中的定义不同。我们将在*探索性数据分析*部分更深入地探讨这一点。在本章的其余部分，我们将更详细地讨论`stock_analysis`包中的每个类，并利用它们的功能对金融资产进行技术分析。
- en: Collecting financial data
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 收集金融数据
- en: Back in [*Chapter 2*](B16834_02_Final_SK_ePub.xhtml#_idTextAnchor035), *Working
    with Pandas DataFrames*, and [*Chapter 3*](B16834_03_Final_SK_ePub.xhtml#_idTextAnchor061),
    *Data Wrangling with Pandas*, we worked with APIs to gather data; however, there
    are other ways to collect data from the Internet. We can use `pandas` offers with
    the `pd.read_html()` function—it returns a dataframe for each of the HTML tables
    it finds on the page. For economic and financial data, an alternative is the `pandas_datareader`
    package, which the `StockReader` class in the `stock_analysis` package uses to
    collect financial data.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第2章*](B16834_02_Final_SK_ePub.xhtml#_idTextAnchor035)《使用Pandas DataFrame》中，以及[*第3章*](B16834_03_Final_SK_ePub.xhtml#_idTextAnchor061)《使用Pandas进行数据清洗》中，我们使用API收集数据；然而，还有其他方式可以从互联网上收集数据。我们可以使用`pandas`提供的`pd.read_html()`函数，它会为页面上找到的每个HTML表格返回一个DataFrame。对于经济和金融数据，另一种选择是`pandas_datareader`包，它被`stock_analysis`包中的`StockReader`类用于收集金融数据。
- en: Important note
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: 'In case anything has changed with the data sources that are used in this chapter
    or you encounter errors when using the `StockReader` class to collect data, the
    CSV files in the `data/` folder can be read in as a replacement in order to follow
    along with the text; for example:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果本章使用的数据源发生了变化，或者在使用`StockReader`类收集数据时遇到错误，可以读取`data/`文件夹中的CSV文件作为替代，以便继续跟随文本进行操作；例如：
- en: '`pd.read_csv(''data/bitcoin.csv'', index_col=''date'',` `parse_dates=True)`'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`pd.read_csv(''data/bitcoin.csv'', index_col=''date'',` `parse_dates=True)`'
- en: The StockReader class
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: StockReader 类
- en: 'Since we will be collecting data for various assets across the same date range,
    it makes sense to create a class that hides all of the implementation details
    and, therefore, avoid lots of copying and pasting (and potential mistakes). For
    this purpose, we will build the `StockReader` class, which will make it easier
    to collect data for bitcoin, stocks, and stock market indices. We can simply create
    an instance of the `StockReader` class by providing the date range we want for
    our analysis, and then use the methods it provides to get whichever data we please.
    The following UML diagram provides a high-level overview of the implementation:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将在相同的日期范围内收集各种资产的数据，创建一个隐藏所有实现细节的类是有意义的，因此避免大量复制粘贴（以及潜在的错误）。为此，我们将建立`StockReader`类，它将使得收集比特币、股票和股票市场指数的数据变得更容易。我们可以简单地通过提供我们分析所需的日期范围创建`StockReader`类的实例，然后使用它提供的方法获取任何我们喜欢的数据。以下的UML图表提供了实现的高层次概述：
- en: '![Figure 7.5 – UML diagram for the StockReader class'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.5 – StockReader类的UML图表'
- en: '](img/Figure_7.5_B16834.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.5_B16834.jpg)'
- en: Figure 7.5 – UML diagram for the StockReader class
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5 – StockReader类的UML图表
- en: 'The UML diagram tells us that the `StockReader` class provides an attribute
    for the available tickers (`available_tickers`) and can perform the following
    actions:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: UML图表告诉我们`StockReader`类提供了一个可用股票代码（`available_tickers`）的属性，并且可以执行以下操作：
- en: Pull bitcoin data in the desired currency with the `get_bitcoin_data()` method.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`get_bitcoin_data()`方法以所需货币拉取比特币数据。
- en: Pull daily foreign exchange rates data with the `get_forex_rates()` method.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`get_forex_rates()`方法拉取每日外汇汇率数据。
- en: Pull data for an index on the stock market (such as the S&P 500) with the `get_index_data()`
    method.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`get_index_data()`方法拉取股票市场上特定指数（如标准普尔500指数）的数据。
- en: Look up the ticker (stock market symbol) for a specific index (for instance,
    ^GSPC for the S&P 500 ticker on Yahoo! Finance) with the `get_index_ticker()`
    method.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`get_index_ticker()`方法查找特定指数的股票市场符号（例如，在Yahoo! Finance上的标准普尔500指数的^GSPC）。
- en: Collect the risk-free rate of return with the `get_risk_free_rate_of_return()`
    method.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`get_risk_free_rate_of_return()`方法收集无风险收益率。
- en: Pull data for a ticker on the stock market (such as NFLX for Netflix) with the
    `get_ticker_data()` method.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`get_ticker_data()`方法拉取股票市场上特定股票（比如Netflix的NFLX）的数据。
- en: Now that we understand why we need this class and have a high-level overview
    of its structure, we can proceed to looking at the code. Since there is a lot
    of code in the `stock_analysis/stock_reader.py` module to review, we will break
    down the file piece by piece. Note that this may change the indentation level,
    so please consult the file itself for the full version.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们理解了为什么需要这门课程，并对其结构有了高层次的概述，我们可以继续查看代码。由于在`stock_analysis/stock_reader.py`模块中有大量代码需要审查，我们将逐个部分地分解这个文件。请注意，这可能会改变缩进级别，因此请查看文件本身以获取完整版本。
- en: 'The first line of the module is the `help()` on the module itself, that will
    appear near the top. This describes the purpose of our module. This is immediately
    followed by any imports we will need:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 模块的第一行是关于模块本身的`help()`，它将出现在顶部附近。这描述了我们模块的目的。接着是我们将需要的任何导入：
- en: '[PRE3]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Notice that the `import` statements are organized in three groups, following
    **PEP 8** (Python style guidelines available at https://www.python.org/dev/peps/pep-0008/),
    which states that they should be in the following order:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`import`语句按照**PEP 8**（Python风格指南，网址为https://www.python.org/dev/peps/pep-0008/）进行了三组组织，规定它们应按以下顺序排列：
- en: Standard library imports (`datetime` and `re`)
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 标准库导入（`datetime`和`re`）
- en: Third-party libraries (`pandas` and `pandas_datareader`)
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第三方库（`pandas`和`pandas_datareader`）
- en: Relative import from another module in the `stock_analysis` package (`.utils`)
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 来自`stock_analysis`包中另一个模块的相对导入（`.utils`）
- en: 'After our imports, we define the `StockReader` class. First, we create a dictionary
    mapping tickers for indices to a descriptive name in `_index_tickers`. Notice
    that our class also has a docstring, which defines its purpose. Here, we will
    only reproduce a few of the tickers available:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的导入之后，我们定义了`StockReader`类。首先，我们创建一个字典，将指数的股票代码映射到描述性名称`_index_tickers`中。注意，我们的类还有一个文档字符串，定义了它的目的。在这里，我们只会列出一些可用的股票代码：
- en: '[PRE4]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'When building a class, there are many **special methods** (colloquially referred
    to as *dunder methods* because their names start and end with double underscores)
    that we can provide to customize the behavior of the class when it''s used with
    language operators:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建类时，有许多**特殊方法**（俗称*dunder方法*，因为它们的名称以双下划线开头和结尾），我们可以提供这些方法来定制类在与语言操作符一起使用时的行为：
- en: Initialize an object (`__init__()`).
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化对象（`__init__()`）。
- en: Make an object comparable for sorting (`__eq__()`, `__lt__()`, `__gt__()`, and
    more).
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使对象可以进行排序比较（`__eq__()`、`__lt__()`、`__gt__()`等）。
- en: Perform arithmetic on the object (`__add__()`, `__sub__()`, `__mul__()`, and
    so on).
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行对象的算术运算（`__add__()`、`__sub__()`、`__mul__()`等）。
- en: Be able to use built-in Python functions such as `len()` on it (`__len__()`).
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够使用内建的Python函数，例如`len()`（`__len__()`）。
- en: Get a string representation of the object for use with the `print()` function
    (`__repr__()` and `__str__()`).
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取对象的字符串表示，用于`print()`函数（`__repr__()`和`__str__()`）。
- en: Support iteration and indexing (`__getitem__()`, `__iter__()`, and `__next__()`).
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持迭代和索引（`__getitem__()`、`__iter__()`和`__next__()`）。
- en: Thankfully, we don't have to write all this functionality every time we make
    a class. In most cases, we just need the `__init__()` method, which is run when
    we create an object. (More information on special methods can be found at [https://dbader.org/blog/python-dunder-methods](https://dbader.org/blog/python-dunder-methods)
    and [https://docs.python.org/3/reference/datamodel.html#special-method-names.](https://docs.python.org/3/reference/datamodel.html#special-method-names.))
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们不需要每次创建类时都编写所有这些功能。在大多数情况下，我们只需要`__init__()`方法，它会在我们创建对象时执行。（有关特殊方法的更多信息，请访问[https://dbader.org/blog/python-dunder-methods](https://dbader.org/blog/python-dunder-methods)和[https://docs.python.org/3/reference/datamodel.html#special-method-names.](https://docs.python.org/3/reference/datamodel.html#special-method-names.))
- en: 'Objects of the `StockReader` class hold on to the start and end dates that
    data will be gathered for, so we put this in the `__init__()` method. We parse
    the dates that are passed in by the caller to allow for the use of any date separator;
    for example, we will be able to handle inputs of Python `datetime` objects; strings
    in the form of `''YYYYMMDD''`; or strings representing dates using any separator
    that matches the non-digit regular expression (`\D`), such as `''YYYY|MM|DD''`
    or `''YYYY/MM/DD''`. The separator, if there is one, gets replaced with an empty
    string so that we can build our datetimes using the `''YYYYMMDD''` format in our
    method. In addition, we raise a `ValueError` if the caller gives us a start date
    equal to or after the end date:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`StockReader`类的对象持有数据采集的开始和结束日期，因此我们将其放入`__init__()`方法中。我们解析调用者传入的日期，以便允许使用任何日期分隔符；例如，我们将能够处理Python
    `datetime`对象的输入；形如`''YYYYMMDD''`的字符串；或使用任何与非数字正则表达式（`\D`）匹配的分隔符表示日期的字符串，例如`''YYYY|MM|DD''`或`''YYYY/MM/DD''`。如果有分隔符，我们将其替换为空字符串，以便在我们的方法中使用`''YYYYMMDD''`格式构建日期时间。此外，如果调用者给定的开始日期等于或晚于结束日期，我们将引发`ValueError`：'
- en: '[PRE5]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note that we didn't define `_index_tickers` in the `__init__()` method, which
    is called upon creation of this object, because we only need one copy of this
    information for all the objects that are created from this class. The `_index_tickers`
    class attribute is private (signified, by convention, with a preceding underscore)
    in the sense that unless a user of this class knows the name of it, they won't
    find it easily (note that methods can also be private). This is done with the
    intention of protecting it (although it isn't guaranteed) and also because the
    user doesn't need it directly (it's for the internal workings of the class). Instead,
    we will provide a **property**, which we can access as an attribute, and a class
    method for getting the value mapped to a given key in that dictionary.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们没有在`__init__()`方法中定义`_index_tickers`，该方法在对象创建时被调用，因为我们只需要为从这个类创建的所有对象保留一份该信息。`_index_tickers`类属性是私有的（按约定，前面有一个下划线），这意味着，除非该类的用户知道它的名称，否则他们不会轻易找到它（请注意，方法也可以是私有的）。这样做的目的是为了保护它（尽管不能完全保证）并且因为用户并不需要直接访问它（它是为了类的内部工作）。相反，我们将提供一个**属性**，我们可以像访问属性一样访问它，还会提供一个类方法，用于获取映射到字典中给定键的值。
- en: Tip
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: '**Class methods** are methods that can be used on the class itself, without
    having to create an instance of the class beforehand. This contrasts with the
    instance methods we have seen so far. **Instance methods** are used with instances
    of a class for actions specific to that instance. We often don''t need class methods,
    but if we have data that is shared across all instances of a class, it makes more
    sense to create a class method rather than an instance method.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**类方法**是可以在类本身上使用的方法，无需事先创建类的实例。这与我们到目前为止看到的实例方法相对。**实例方法**是与类的实例一起使用的，用于特定于该实例的操作。我们通常不需要类方法，但如果我们有共享于所有实例的数据，创建类方法比实例方法更有意义。'
- en: 'Since `_index_tickers` is private, we want to provide an easy way for users
    of our class to see what is available. Therefore, we will create a property for
    the keys of `_index_tickers`. To do so, we use the `@property` decorator. `@property`
    and `@classmethod`) and write one of our own to clean up and standardize the results
    across the methods that gather the data (`@label_sanitizer`). To use a decorator,
    we place it above the function or method definition:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`_index_tickers`是私有的，我们希望为类的用户提供查看可用项的简便方法。因此，我们将为`_index_tickers`的键创建一个属性。为此，我们使用`@property`装饰器。`@property`和`@classmethod`）装饰器，并编写我们自己的装饰器以清理并标准化跨方法收集数据的结果（`@label_sanitizer`）。要使用装饰器，我们将其放在函数或方法定义之上：
- en: '[PRE6]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Furthermore, we provide a way of getting the ticker using a class method because
    our tickers are stored in a class variable. Class methods, by convention, receive
    `cls` as their first argument while instance methods receive `self`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们通过类方法提供获取股票代码的方式，因为我们的股票代码存储在类变量中。按照惯例，类方法将`cls`作为第一个参数，而实例方法将`self`作为第一个参数：
- en: '[PRE7]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Tip
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'If we want to prohibit certain actions within our code, we can check for them
    and `raise` errors as we see fit; this allows us to provide more informative error
    messages or simply accompany specific errors with some additional actions before
    reraising them (by using `raise` without an expression). If, instead, we wish
    to run certain code when something goes wrong, we use a `try...except` block:
    we surround the possibly troublesome code with `try` and put what to do if trouble
    occurs in the `except` clause.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要禁止代码中的某些操作，我们可以检查并根据需要`raise`错误；这允许我们提供更具信息性的错误消息，或者在重新引发错误之前，简单地附加一些额外的操作（通过`raise`没有表达式）。如果我们希望在某些事情出错时运行特定代码，则使用`try...except`块：我们将可能出问题的代码放在`try`中，并将遇到问题时该做的事情放在`except`子句中。
- en: 'When we get to the *Technical analysis of financial instruments* section, we
    will need the risk-free rate of return to calculate some of the metrics. This
    is the rate of return of an investment that has no risk of financial loss; in
    practice, we use the 10-year US Treasury bill. Since this rate will depend on
    the date range we are analyzing, we will add this functionality to the `StockReader`
    class and avoid having to look it up ourselves. We will use the `pandas_datareader`
    package to collect this data from the Federal Reserve Bank of St. Louis ([https://fred.stlouisfed.org/series/DGS10](https://fred.stlouisfed.org/series/DGS10)),
    providing the option to return the daily rates for the date range we are studying
    (to analyze the data itself) or just the last one (if we need a single value for
    a calculation):'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们进入*金融工具的技术分析*部分时，我们将需要无风险回报率来计算一些指标。这是指没有金融损失风险的投资回报率；在实际操作中，我们使用10年期美国国债收益率。由于这个利率会依赖于我们分析的日期范围，因此我们将把这个功能添加到`StockReader`类中，避免自己查找。我们将使用`pandas_datareader`包从圣路易斯联邦储备银行收集数据（[https://fred.stlouisfed.org/series/DGS10](https://fred.stlouisfed.org/series/DGS10)），提供选择返回我们研究的日期范围的每日利率（用于分析数据本身），或者仅返回最后一个利率（如果我们需要单一值进行计算）：
- en: '[PRE8]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The remaining method code is replaced with `pass`, which tells Python to do
    nothing (and reminds us to update it later) so that the code can function as it
    was reproduced. We will write the following methods in the next section:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的方法代码用`pass`替代，表示告诉Python什么都不做（并提醒我们稍后更新），以便代码可以按原样运行。我们将在下一节编写以下方法：
- en: '[PRE9]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Important note
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Since we aren't going to be looking at foreign exchange rates, we won't cover
    the `get_forex_rates()` method in this chapter; however, this method provides
    an additional example of how to use the `pandas_datareader` package, so I encourage
    you to take a look at it. Note that, in order to use this method, you will need
    to get a free API key from AlphaVantage at [https://www.alphavantage.co/support/#api-key](https://www.alphavantage.co/support/#api-key).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不会查看外汇汇率，本章不涉及`get_forex_rates()`方法；然而，这个方法提供了如何使用`pandas_datareader`包的另一个示例，因此我鼓励你看看它。请注意，为了使用这个方法，你需要从AlphaVantage获取一个免费的API密钥，网址是[https://www.alphavantage.co/support/#api-key](https://www.alphavantage.co/support/#api-key)。
- en: 'Both the `get_ticker_data()` and `get_forex_rates()` methods are decorated
    with `@label_sanitizer`, which aligns the data we receive from various sources
    to the same column names so that we don''t have to clean them later. The `@label_sanitizer`
    decorator is defined in the `stock_analysis/utils.py` module. As we did previously,
    let''s begin by looking at the docstring and imports of the `utils` module:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_ticker_data()`和`get_forex_rates()`方法都使用了`@label_sanitizer`装饰器，这样可以将我们从不同来源收到的数据统一为相同的列名，从而避免我们后续清理数据。`@label_sanitizer`装饰器定义在`stock_analysis/utils.py`模块中。和之前一样，我们首先来看一下`utils`模块的文档字符串和导入：'
- en: '[PRE10]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, we have the `_sanitize_label()` function, which will clean up a single
    label. Note that we prefix the function name with an underscore because we don''t
    intend for the users of our package to use this directly—it is for our decorator
    to use:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有`_sanitize_label()`函数，它将清理单个标签。请注意，我们在函数名前加了下划线，因为我们不打算让包的用户直接使用它——它是为我们的装饰器使用的：
- en: '[PRE11]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Finally, we define the `@label_sanitizer` decorator, which is a function that
    cleans up the column and index names in the data we get from the Internet. Without
    this decorator, the column names in our collected data could have unexpected characters
    such as asterisks or spaces in them, making them unwieldy. By using the decorator,
    the methods will always return a dataframe with the names cleaned, saving us a
    step:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们定义了`@label_sanitizer`装饰器，它是一个清理我们从互联网上获得的数据的列名和索引名的函数。没有这个装饰器，我们收集的数据中的列名可能会有一些意外的字符，比如星号或空格，使得数据难以使用。通过使用这个装饰器，方法将始终返回一个清理过列名的数据框，省去了我们的一步：
- en: '[PRE12]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note that there is also a decorator inside the definition of the `label_sanitizer()`
    function. The `@wraps` decorator from the `functools` module in the standard library
    gives the decorated function/method the same docstring it had beforehand; this
    is necessary because decoration actually creates a new function/method, thus rendering
    `help()` pretty useless unless we intervene.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`label_sanitizer()`函数的定义中也有一个装饰器。来自标准库`functools`模块的`@wraps`装饰器会将装饰过的函数/方法的文档字符串与原始文档字符串相同；这是必要的，因为装饰操作实际上会创建一个新函数/方法，从而使得`help()`函数变得无效，除非我们进行干预。
- en: Tip
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: Using the `@label_sanitizer` syntax is `method = label_sanitizer(method)`. However,
    both are valid.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`@label_sanitizer`语法的方式是`method = label_sanitizer(method)`。不过，两者都是有效的。
- en: Now that we understand decorators, we are ready to finish building the `StockReader`
    class. Note that we will be using and creating additional decorators for the other
    classes in the `stock_analysis` package as well, so make sure that you are comfortable
    with them before moving on.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经理解了装饰器，准备好完成`StockReader`类的构建。请注意，我们还将为`stock_analysis`包中的其他类使用并创建附加的装饰器，因此在继续之前，请确保你对这些装饰器已经足够熟悉。
- en: Collecting historical data from Yahoo! Finance
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从Yahoo! Finance收集历史数据
- en: 'The foundation of our data collection will be the `get_ticker_data()` method.
    It uses the `pandas_datareader` package to grab the data from Yahoo! Finance:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数据收集的基础将是`get_ticker_data()`方法。它使用`pandas_datareader`包从Yahoo! Finance获取数据：
- en: '[PRE13]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Important note
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'There have been issues with `pandas_datareader` and the Yahoo! Finance API
    in the past, causing the `pandas_datareader` developers to deprecate support for
    it via the `web.DataReader()` function ([https://pandas-datareader.readthedocs.io/en/latest/whatsnew.html#v0-6-0-january-24-2018](https://pandas-datareader.readthedocs.io/en/latest/whatsnew.html#v0-6-0-january-24-2018));
    instead, we have to use their workaround: `web.get_data_yahoo()`.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 过去，`pandas_datareader`和Yahoo! Finance API曾出现过一些问题，导致`pandas_datareader`开发者通过`web.DataReader()`函数（[https://pandas-datareader.readthedocs.io/en/latest/whatsnew.html#v0-6-0-january-24-2018](https://pandas-datareader.readthedocs.io/en/latest/whatsnew.html#v0-6-0-january-24-2018)）弃用了对它的支持；因此，我们必须使用他们的替代方法：`web.get_data_yahoo()`。
- en: 'To collect data for a stock market index, we can use the `get_index_data()`
    method, which first looks up the index''s ticker and then calls the `get_ticker_data()`
    method we just defined. Note that since the `get_ticker_data()` method is decorated
    with `@label_sanitizer`, the `get_index_data()` method doesn''t need the `@label_sanitizer`
    decorator:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 要收集股票市场指数的数据，我们可以使用`get_index_data()`方法，该方法首先查找指数的股票代码，然后调用我们刚刚定义的`get_ticker_data()`方法。请注意，由于`get_ticker_data()`方法使用了`@label_sanitizer`装饰器，因此`get_index_data()`方法不需要使用`@label_sanitizer`装饰器：
- en: '[PRE14]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Yahoo! Finance also provides data for bitcoin; however, we must pick a currency
    to use. The `get_bitcoin_data()` method accepts a currency code to create the
    symbol for the search on Yahoo! Finance (for instance, BTC-USD for bitcoin data
    in USD). The actual collection of the data is once again handled by the `get_ticker_data()`
    method:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Yahoo! Finance也提供比特币的数据；然而，我们必须选择一个货币来使用。`get_bitcoin_data()`方法接受一个货币代码来创建Yahoo!
    Finance搜索的符号（例如，BTC-USD表示以美元计价的比特币数据）。实际的数据收集仍然由`get_ticker_data()`方法处理：
- en: '[PRE15]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'At this point, the `StockReader` class is ready for use, so let''s get started
    in the `financial_analysis.ipynb` notebook and import the `stock_analysis` package
    that will be used for the rest of this chapter:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，`StockReader`类已经可以使用，因此让我们在`financial_analysis.ipynb`笔记本中开始工作，并导入将用于本章其余部分的`stock_analysis`包：
- en: '[PRE16]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Python runs the `stock_analysis/__init__.py` file when we import the `stock_analysis`
    package:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们导入`stock_analysis`包时，Python会运行`stock_analysis/__init__.py`文件：
- en: '[PRE17]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Important note
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The code in the `stock_analysis/__init__.py` file makes it easier for us to
    access the package's classes—for example, rather than having to run `stock_analysis.stock_reader.StockReader()`,
    we only have to run `stock_analysis.StockReader()`to create a `StockReader` object.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`stock_analysis/__init__.py`文件中的代码使我们更容易访问包中的类——例如，我们不需要运行`stock_analysis.stock_reader.StockReader()`，只需运行`stock_analysis.StockReader()`即可创建一个`StockReader`对象。'
- en: 'Next, we will create an instance of the `StockReader` class by providing the
    start and (optionally) end dates for the data it will collect. We will work with
    2019-2020 data. Note that when we run this code, Python is calling the `StockReader.__init__()`
    method:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将通过提供数据收集的开始日期和（可选的）结束日期，创建`StockReader`类的实例。我们将使用2019-2020年的数据。请注意，当我们运行此代码时，Python会调用`StockReader.__init__()`方法：
- en: '[PRE18]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, we will collect the **Facebook, Apple, Amazon, Netflix, and Google** (**FAANG**),
    S&P 500, and bitcoin data. Since all the stocks we are working with are priced
    in USD, we will ask for the bitcoin data in USD. Note that we are using a generator
    expression and multiple assignment to get dataframes for each FAANG stock:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将收集**Facebook、Apple、Amazon、Netflix和Google**（**FAANG**）、S&P 500和比特币数据。由于我们使用的所有股票的价格都是以美元计价的，因此我们会请求以美元计价的比特币数据。请注意，我们使用了生成器表达式和多重赋值来获取每个FAANG股票的数据框：
- en: '[PRE19]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Tip
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Be sure to run `help(stock_analysis.StockReader)` or `help(reader)` to see all
    the methods and properties that are defined. The output clearly denotes which
    methods are class methods in a different section, and the properties will be listed
    at the bottom in the `data descriptors` section. This is an important step to
    take in order to get familiar with new code.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 确保运行`help(stock_analysis.StockReader)`或`help(reader)`，以查看所有已定义的方法和属性。输出会清楚地标明哪些方法是类方法，并将属性列在底部的`data
    descriptors`部分。这是熟悉新代码的重要步骤。
- en: Exploratory data analysis
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索性数据分析
- en: Now that we have our data, we want to get familiar with it. As we saw in [*Chapter
    5*](B16834_05_Final_SK_ePub.xhtml#_idTextAnchor106), *Visualizing Data with Pandas
    and Matplotlib* and [*Chapter 6*](B16834_06_Final_SK_ePub.xhtml#_idTextAnchor125),
    *Plotting with Seaborn and Customization Techniques*, creating good visualizations
    requires knowledge of `matplotlib`, and—depending on the data format and the end
    goal for the visualization—`seaborn`. Just as we did with the `StockReader` class,
    we want to make it easier to visualize both individual assets and groups of assets,
    so rather than expecting users of our package (and, perhaps, our collaborators)
    to be proficient with `matplotlib` and `seaborn`, we will create wrappers around
    this functionality. This means that users of this package only have to be able
    to use the `stock_analysis` package to visualize their financial data. In addition,
    we are able to set a standard for how the visualizations look and avoid copying
    and pasting large amounts of code for each new analysis we want to conduct, which
    brings consistency and efficiency gains.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了数据，我们想要熟悉它。正如我们在[*第5章*](B16834_05_Final_SK_ePub.xhtml#_idTextAnchor106)《使用Pandas和Matplotlib进行数据可视化》和[*第6章*](B16834_06_Final_SK_ePub.xhtml#_idTextAnchor125)《使用Seaborn绘图与自定义技巧》中看到的，创建好的可视化需要了解`matplotlib`，并且——根据数据格式和可视化的最终目标——还需要了解`seaborn`。就像我们在`StockReader`类中做的那样，我们希望让用户更容易地可视化单个资产和资产组，因此，我们不会指望我们包的用户（以及可能的合作者）精通`matplotlib`和`seaborn`，而是将围绕这些功能创建包装器。这意味着用户只需能够使用`stock_analysis`包来可视化他们的财务数据。此外，我们能够为可视化的外观设定标准，避免在进行每次新分析时复制和粘贴大量代码，从而带来一致性和效率的提升。
- en: 'To make all of this possible, we have the `Visualizer` classes in `stock_analysis/stock_visualizer.py`.
    There are three classes in this file:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这一切成为可能，我们在`stock_analysis/stock_visualizer.py`中有`Visualizer`类。这个文件中有三个类：
- en: '`Visualizer`: This is the base class for defining the functionality of a `Visualizer`
    object. Most of the methods are **abstract**, meaning that the subclasses (children)
    that inherit from this superclass (parent) will need to override them and implement
    the code; these define what an object should do, without getting into the specifics.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Visualizer`：这是定义`Visualizer`对象功能的基类。大多数方法是**抽象的**，这意味着从这个父类继承的子类（子类）需要重写这些方法并实现代码；这些方法定义了对象应该做什么，但不涉及具体细节。'
- en: '`StockVisualizer`: This is the subclass we will use to visualize a single asset.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StockVisualizer`：这是我们将用来可视化单个资产的子类。'
- en: '`AssetGroupVisualizer`: This is the subclass we will use to visualize multiple
    assets using `groupby()` operations.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AssetGroupVisualizer`：这是我们将用来通过`groupby()`操作可视化多个资产的子类。'
- en: 'Before we discuss the code for these classes, let''s go over some additional
    functions in the `stock_analysis/utils.py` file, which will help create these
    asset groups and describe them for EDA purposes. For these functions, we need
    to import `pandas`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论这些类的代码之前，让我们先来看一下`stock_analysis/utils.py`文件中的一些附加函数，这些函数将帮助我们创建这些资产组并为EDA目的描述它们。对于这些函数，我们需要导入`pandas`：
- en: '[PRE20]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `group_stocks()` function takes in a dictionary that maps the name of the
    asset to the dataframe for that asset and outputs a new dataframe with all the
    data from the input dataframes and a new column, denoting which asset the data
    belongs to:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`group_stocks()`函数接受一个字典，字典将资产的名称映射到该资产的数据框，并输出一个新的数据框，包含输入数据框的所有数据以及一列新数据，标明数据属于哪个资产：'
- en: '[PRE21]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Since we will have many methods and functions throughout the package that will
    expect their dataframes in a specific format, we will build a new decorator: `@validate_df`.
    This decorator checks that the input to a given method or function is an object
    of type `DataFrame` and that it has at least the columns specified with the `columns`
    argument of the decorator. We will provide the columns as a `set` object. This
    allows us to check the set difference between the columns we must have and the
    columns in the input data (see [*Chapter 4*](B16834_04_Final_SK_ePub.xhtml#_idTextAnchor082),
    *Aggregating Pandas DataFrames*, for a review of set operations). If the dataframe
    has the columns we request (at a minimum), the set difference will be empty, which
    means that the dataframe passes the test. This decorator will raise a `ValueError`
    if either of these conditions is violated.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在整个包中，我们将有许多方法和函数期望它们的数据框具有特定格式，因此我们将构建一个新的装饰器：`@validate_df`。这个装饰器检查传递给给定方法或函数的输入是否为`DataFrame`类型的对象，并且至少包含装饰器`columns`参数指定的列。我们将以`set`对象的形式提供这些列。这样我们就可以检查我们需要的列与输入数据中的列之间的集合差异（参见[*第4章*](B16834_04_Final_SK_ePub.xhtml#_idTextAnchor082)，*聚合Pandas数据框*，了解集合操作）。如果数据框包含我们要求的列（至少），那么集合差异将为空，这意味着数据框通过了测试。如果违反了这些条件，装饰器将抛出`ValueError`。
- en: 'Let''s take a look at how this is defined in the `stock_analysis/utils.py`
    file:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下在`stock_analysis/utils.py`文件中是如何定义的：
- en: '[PRE22]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Groups made with the `group_stocks()` function can be described in a single
    output using the `describe_group()` function. The `group_stocks()` function adds
    a column called `name` that `describe_group()` looks for, so we use the `@validate_df`
    decorator to make sure that the format is correct before trying to run the function:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`group_stocks()`函数创建的组可以通过`describe_group()`函数在一个输出中进行描述。`group_stocks()`函数添加了一个名为`name`的列，而`describe_group()`会查找这个列，因此我们使用`@validate_df`装饰器确保格式正确，然后再尝试运行该函数：
- en: '[PRE23]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Let''s use the `group_stocks()` function to make some asset groups for our
    analysis:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`group_stocks()`函数为我们的分析创建一些资产组：
- en: '[PRE24]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Using these groups, the output of `describe()` can be much more informative
    for comparison purposes compared to running it on each dataframe separately. The
    `describe_group()` function handles running `describe()` with `groupby()`. This
    makes it easier to look at the summary for the closing price across assets:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些组，`describe()`的输出在比较时要比分别对每个数据框运行它更有信息量。`describe_group()`函数通过`groupby()`来运行`describe()`。这使得查看不同资产的收盘价汇总更加方便：
- en: '[PRE25]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'At a glance, we can see that we have more data for bitcoin than the rest. This
    is because the prices change daily, whereas for stocks, we only see the data for
    trading days. Another thing we can glean from this is scale; bitcoin is not only
    much more volatile but is much higher in value than everything else:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 一眼看去，我们可以看到比特币的数据比其他资产更多。这是因为比特币的价格每天都会变化，而股票数据只包含交易日的数据。我们还可以从中得出一个结论，即比特币不仅波动性大，而且价值远高于其他资产：
- en: '![Figure 7.6 – Summary statistics for the closing price per financial instrument'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.6 – 各金融工具的收盘价汇总统计]'
- en: '](img/Figure_7.6_B16834.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.6_B16834.jpg)'
- en: Figure 7.6 – Summary statistics for the closing price per financial instrument
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.6 – 各金融工具的收盘价汇总统计
- en: 'If we don''t want to look at the assets individually, we can combine them into
    a portfolio, which we can treat as a single asset. The `make_portfolio()` function
    from `stock_analysis/utils.py` groups the data by date and sums all the columns,
    giving us the total stock price and volume traded of our portfolio:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不想单独查看每个资产，我们可以将它们组合成一个投资组合，视其为一个单一资产。`stock_analysis/utils.py`中的`make_portfolio()`函数按日期对数据进行分组并对所有列求和，从而得出我们投资组合的总股价和交易量：
- en: '[PRE26]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This function assumes that the assets are traded on the same frequency. Bitcoin
    trades every day of the week, while the stock market doesn't. For this reason,
    we would have to decide how to handle this difference before using this function
    if our portfolio was a mix of bitcoin and the stock market; consult our discussion
    of reindexing in [*Chapter 3*](B16834_03_Final_SK_ePub.xhtml#_idTextAnchor061),
    *Data Wrangling with Pandas*, for a possible strategy. We will use this function
    in the exercises at the end of this chapter to build a portfolio of the FAANG
    stocks, which all trade on the same frequency, in order to look at the effect
    of after-hours trading on the FAANG stocks as a whole.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数假设资产是以相同的频率进行交易的。比特币每天交易，而股市则不是。因此，如果我们的投资组合是比特币和股市的混合体，在使用此函数之前，我们需要决定如何处理这一差异；请参考我们在[*第
    3 章*](B16834_03_Final_SK_ePub.xhtml#_idTextAnchor061)中关于重新索引的讨论，*使用 Pandas 进行数据清洗*，以寻找可能的策略。我们将在本章末尾的练习中使用此函数，构建一个由
    FAANG 股票组成的投资组合，这些股票的交易频率相同，以便观察盘后交易对整个 FAANG 股票的影响。
- en: The Visualizer class family
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可视化器类族
- en: 'As we learned from previous chapters, visualization will make our analysis
    much easier, so let''s begin our discussion of the `Visualizer` classes in `stock_analysis/stock_visualizer.py`.
    First, we will define our base class, `Visualizer`. The following UML diagram
    tells us this is our base class because it has arrows pointing to it. These arrows
    originate from the subclasses (`AssetGroupVisualizer` and `StockVisualizer`):'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们从前几章中了解到的那样，可视化将使我们的分析变得更加轻松，因此让我们开始讨论 `stock_analysis/stock_visualizer.py`
    中的 `Visualizer` 类。首先，我们将定义我们的基础类 `Visualizer`。以下的 UML 图告诉我们这是我们的基础类，因为它有箭头指向它，这些箭头来自子类（`AssetGroupVisualizer`
    和 `StockVisualizer`）：
- en: '![Figure 7.7 – Visualizer class hierarchy'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.7 – 可视化器类层次结构'
- en: '](img/Figure_7.7_B16834.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.7_B16834.jpg)'
- en: Figure 7.7 – Visualizer class hierarchy
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.7 – 可视化器类层次结构
- en: '*Figure 7.7* also tells us the methods we will be defining for each of the
    classes in this section. This includes methods for visualizing the effect of after-hours
    trading (`after_hours_trades()`) and the evolution over time of an asset''s price
    (`evolution_over_time()`), which we will use to compare assets visually.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7.7* 还告诉我们将为本节中的每个类定义哪些方法。这包括可视化盘后交易影响（`after_hours_trades()`）和资产价格随时间变化（`evolution_over_time()`）的方法，我们将用它们来进行资产的可视化比较。'
- en: 'We start the module with our docstring and imports. For our visualizations,
    we will need `matplotlib`, `numpy`, `pandas`, and `seaborn`, along with `mplfinance`
    (a `matplotlib` derivative package for financial visualizations):'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以文档字符串和导入开始模块。对于我们的可视化，我们将需要 `matplotlib`、`numpy`、`pandas` 和 `seaborn`，以及
    `mplfinance`（一个用于金融可视化的 `matplotlib` 派生包）：
- en: '[PRE27]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Next, we begin by defining the `Visualizer` class. This class will hold the
    data it will be used to visualize, so we put this in the `__init__()` method:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们开始定义 `Visualizer` 类。这个类将保存将用于可视化的数据，因此我们将其放入 `__init__()` 方法中：
- en: '[PRE28]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This base class will provide us with `matplotlib` function we need to call
    for the orientation; static methods don''t depend on the class for data. We define
    the `add_reference_line()` method for adding horizontal or vertical lines (and
    anything in between) using the `@staticmethod` decorator; notice we don''t have
    `self` or `cls` as the first argument:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 该基础类将为我们提供调用 `matplotlib` 函数所需的功能；静态方法不依赖于类的数据。我们使用 `@staticmethod` 装饰器定义 `add_reference_line()`
    方法，用于添加水平或垂直线（以及介于两者之间的任何内容）；注意，我们没有将 `self` 或 `cls` 作为第一个参数：
- en: '[PRE29]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Tip
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: See the *Further reading* section for more information on class methods, static
    methods, and abstract methods.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 有关类方法、静态方法和抽象方法的更多信息，请参见*进一步阅读*部分。
- en: 'The `shade_region()` static method for adding shaded regions to a plot is similar
    to the `add_reference_line()` static method:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`shade_region()` 静态方法用于向图表添加阴影区域，它类似于 `add_reference_line()` 静态方法：'
- en: '[PRE30]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Since we want our plotting capabilities to be flexible, we are going to define
    a static method that will make it easy for us to plot one or many items without
    needing to check the number of items beforehand. This will be utilized in the
    classes we build using the `Visualizer` class as our base:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望我们的绘图功能具有灵活性，我们将定义一个静态方法，使得我们可以轻松地绘制一个或多个项目，而无需事先检查项目的数量。这将在我们使用 `Visualizer`
    类作为基础构建的类中得到应用：
- en: '[PRE31]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We want to support window functions for single assets and groups of them; however,
    the implementation of this will vary, so we will define an **abstract method**
    (a method without implementation) in the superclass, and the subclasses will override
    it to provide the implementation:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望支持单一资产和资产组的窗口函数；然而，这一实现会有所不同，因此我们将在超类中定义一个**抽象方法**（一个没有实现的方法），子类将重写它以提供具体实现：
- en: '[PRE32]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This allows us to define functionality that depends on `_window_calc()` but
    doesn''t need to know the exact implementation, just the result. The `moving_average()`
    method uses `_window_calc()` to add moving average lines to the plot:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这样我们就可以定义依赖于`_window_calc()`的功能，但不需要知道具体实现，只需要知道结果。`moving_average()`方法使用`_window_calc()`将移动平均线添加到图表中：
- en: '[PRE33]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In a similar fashion, we define the `exp_smoothing()` method, which will use
    `_window_calc()` to add exponentially smoothed moving average lines to the plot:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们定义了`exp_smoothing()`方法，它将使用`_window_calc()`将指数平滑的移动平均线添加到图表中：
- en: '[PRE34]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Note that while we have methods for adding the moving average and the exponentially
    smoothed moving average to a plot of a column, they both call `_window_calc()`,
    which isn't defined here. This is because each of the subclasses will have its
    own implementation of `_window_calc()`, while they will inherit the top-level
    method without the need to override `moving_average()` or `exp_smoothing()`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，虽然我们有方法可以将移动平均和指数平滑移动平均添加到列的图表中，但它们都调用了`_window_calc()`，该方法在此处未定义。这是因为每个子类都会有自己的`_window_calc()`实现，而它们将继承顶层方法，无需重写`moving_average()`或`exp_smoothing()`。
- en: Important note
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Remember that methods preceded with a single underscore (`_`) are Python's version
    of `help()` on objects of that class. We created `_window_calc()` as a private
    method because users of the `Visualizer` classes will only need to call `moving_average()`
    and `exp_smoothing()`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，以单个下划线（`_`）开头的方法是Python对该类对象的`help()`版本。我们将`_window_calc()`作为私有方法创建，因为`Visualizer`类的用户只需要调用`moving_average()`和`exp_smoothing()`。
- en: 'Finally, we will add placeholders for the methods all subclasses will have.
    These are abstract methods that will be defined by each subclass individually
    because the implementation will be different depending on if we are visualizing
    a single asset or a group of them. For brevity, the following is a subset of the
    abstract methods defined in this class:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将为所有子类添加占位符方法。这些是抽象方法，将由每个子类单独定义，因为实现会根据我们是可视化单一资产还是资产组而有所不同。为了简洁，以下是该类中定义的一部分抽象方法：
- en: '[PRE35]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The subclasses will also define any methods that are unique to them and/or override
    the implementation of the `Visualizer` class, if necessary. Anything they don't
    override, they will inherit. By using `Visualizer` by what all `Visualizers` should
    do and then have more specific versions, such as the `StockVisualizer` class,
    which handles single assets only.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 子类还将定义它们特有的方法，并/或根据需要重写`Visualizer`类的实现。它们没有重写的方法将会继承。通过使用`Visualizer`来定义所有`Visualizers`应做的事情，然后提供更具体的版本，例如仅处理单一资产的`StockVisualizer`类。
- en: Visualizing a stock
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可视化股票
- en: Let's start the `StockVisualizer` class by inheriting from `Visualizer`; we
    will choose not to override the `__init__()` method because the `StockVisualizer`
    class will only have a dataframe as an attribute. Instead, we will provide implementations
    for the methods that need to be added (which are unique to this class) or overridden.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过继承`Visualizer`类来开始实现`StockVisualizer`类；我们选择不重写`__init__()`方法，因为`StockVisualizer`类只会有一个数据框作为属性。相反，我们将为需要添加（该类特有的）或重写的方法提供实现。
- en: Important note
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: We will only cover a subset of the functionality in the interest of brevity;
    however, I highly encourage you to both read through the full code base and test
    out the functionality in the notebook.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁起见，我们只涵盖一部分功能；然而，我强烈建议你阅读完整的代码库并在笔记本中测试功能。
- en: 'The first method we will override is `evolution_over_time()`, which will create
    a line plot of a column over time:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重写的第一个方法是`evolution_over_time()`，它将创建一个随着时间变化的列的折线图：
- en: '[PRE36]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Next, we will use `mplfinance` to create a **candlestick plot**, which is a
    way to visualize the OHLC data together. Each row of the OHLC time series will
    be plotted as a candlestick. When the candlestick is black, the asset''s closing
    price was smaller than the opening price (it lost value); when the candlestick
    is white, the asset''s closing price was higher than its opening price, as illustrated
    in the following diagram:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用 `mplfinance` 创建一个**蜡烛图**，这是一种将 OHLC 数据一起可视化的方法。每一行 OHLC 时间序列将被绘制为一根蜡烛。当蜡烛图为黑色时，资产的收盘价低于开盘价（表示亏损）；当蜡烛图为白色时，资产的收盘价高于开盘价，如下图所示：
- en: '![Figure 7.8 – Understanding a candlestick plot'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.8 – 理解蜡烛图'
- en: '](img/Figure_7.8_B16834.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.8_B16834.jpg)'
- en: Figure 7.8 – Understanding a candlestick plot
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.8 – 理解蜡烛图
- en: 'The `candlestick()` method also provides options to resample the data, show
    volume traded, and plot a specific date range:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`candlestick()` 方法还提供了重新采样数据、显示交易量和绘制特定日期范围的选项：'
- en: '[PRE37]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now, we add the `after_hours_trades()` method, which helps us visualize the
    effect after-hours trading had on an individual asset, with bars colored red for
    losses and green for gains:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们添加 `after_hours_trades()` 方法，帮助我们可视化盘后交易对单个资产的影响，亏损部分用红色条形图表示，盈利部分用绿色条形图表示：
- en: '[PRE38]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Next, we will add a static method that will allow us to fill the area between
    two curves of our choosing. The `fill_between()` method will use `plt.fill_between()`
    to color the area green or red depending on which curve is higher:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加一个静态方法，让我们可以填充两条曲线之间的区域。`fill_between()` 方法将使用 `plt.fill_between()`
    根据哪条曲线较高来为区域上色，绿色或红色：
- en: '[PRE39]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The `open_to_close()` method will help us visualize the daily differential
    between opening and closing price via the `fill_between()` static method. We will
    color the area green if the closing price is higher than the opening price and
    red if the opposite is true:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`open_to_close()` 方法将帮助我们通过 `fill_between()` 静态方法可视化每日开盘价与收盘价之间的差异。如果收盘价高于开盘价，我们会将区域涂成绿色；如果相反，则涂成红色：'
- en: '[PRE40]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In addition to visualizing the differential between the opening and closing
    price of an individual asset, we will want to compare prices between assets. The
    `fill_between_other()` method will help us visualize the differential between
    the asset we created the visualizer for and another asset, using `fill_between()`
    again. We will color the differential green when the visualizer''s asset is higher
    than the other asset and red for when it is lower:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 除了可视化单个资产的开盘价与收盘价之间的差异外，我们还希望比较不同资产之间的价格。`fill_between_other()` 方法将帮助我们可视化我们为某个资产创建的可视化工具与另一个资产之间的差异，再次使用
    `fill_between()`。当可视化工具中的资产价格高于另一个资产时，我们会将差异部分标为绿色，低于另一个资产时则标为红色：
- en: '[PRE41]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The time has finally come to override the `_window_calc()` method, which defines
    how to add reference lines based on window calculations for a single asset. Note
    how we are able to use the `pipe()` method (introduced in [*Chapter 4*](B16834_04_Final_SK_ePub.xhtml#_idTextAnchor082),
    *Aggregating Pandas DataFrames*) to make our window calculation plots work with
    different functions, and the `_iter_handler()` method to make our loop work without
    having to check if we have more than one reference line to plot:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 终于到了重写 `_window_calc()` 方法的时候，它定义了如何根据单个资产的窗口计算来添加参考线。注意，我们如何能够使用 `pipe()` 方法（在
    [*第 4 章*](B16834_04_Final_SK_ePub.xhtml#_idTextAnchor082) 中介绍，*聚合 Pandas DataFrame*）使我们的窗口计算图与不同的函数兼容，以及如何使用
    `_iter_handler()` 方法使我们的循环在不检查是否有多个参考线需要绘制的情况下工作：
- en: '[PRE42]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'So far, each visualization concerned data for a single asset; however, sometimes
    we want to be able to visualize the relationship between assets, so we will build
    a wrapper around the `jointplot()` function from `seaborn`:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，每个可视化都涉及单一资产的数据；然而，有时我们希望能够可视化资产之间的关系，因此我们将围绕 `seaborn` 的 `jointplot()`
    函数构建一个封装器：
- en: '[PRE43]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Another way of viewing the relationship between assets is the correlation matrix.
    `DataFrame` objects have a `corrwith()` method that will calculate the correlation
    coefficient between each column and the same column (by name) in another dataframe.
    This doesn''t fill the matrix that''s needed for a heatmap, as we saw in previous
    chapters; rather, it is the diagonal. The `correlation_heatmap()` method creates
    a matrix for the `sns.heatmap()` function and fills in the diagonal with the correlation
    coefficients; then, it makes sure that only the diagonal is displayed using a
    mask. In addition, we will use the daily percentage change of each column when
    calculating the correlations to handle the difference in scale (for instance,
    between Apple''s stock price and Amazon''s stock price):'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 观察资产之间关系的另一种方式是相关矩阵。`DataFrame` 对象有一个 `corrwith()` 方法，可以计算每列与另一个数据框中相同列（按名称）的相关系数。这并不能填充热图所需的矩阵，正如我们在前几章所看到的；它实际上是对角线。`correlation_heatmap()`
    方法创建一个矩阵供 `sns.heatmap()` 函数使用，并用相关系数填充对角线；然后，它通过遮罩确保仅显示对角线。此外，在计算相关性时，我们将使用每列的每日百分比变化，以处理规模差异（例如，苹果股票价格与亚马逊股票价格之间的差异）：
- en: '[PRE44]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now that we understand some of the functionality available in the `StockVisualizer`
    class, we can begin our exploratory analysis. Let''s create a `StockVisualizer`
    object to perform some EDA on the Netflix stock data:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了 `StockVisualizer` 类的一些功能，我们可以开始进行探索性分析。让我们创建一个 `StockVisualizer` 对象，对
    Netflix 股票数据进行一些EDA：
- en: '[PRE45]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Once we initialize our `StockVisualizer` object with the Netflix dataframe,
    we can generate many different plot types. We won''t go over examples of everything
    this object lets us do (I will leave that up to you to experiment with), but let''s
    take a look at the closing price over time with some moving averages to study
    the trend:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们用 Netflix 数据框初始化了 `StockVisualizer` 对象，我们就可以生成许多不同类型的图表。我们不会一一举例说明这个对象可以做什么（这留给你自己去实验），但让我们看看随时间变化的收盘价与一些移动平均线，以研究趋势：
- en: '[PRE46]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'These moving averages give us a smoothed version of the stock price curve.
    Notice that, in the shaded region, the 90-day moving average is acting like a
    ceiling for the stock price:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这些移动平均线给我们提供了股价曲线的平滑版本。请注意，在阴影区域内，90 日移动平均线像是股票价格的天花板：
- en: '![Figure 7.9 – Netflix stock price with moving averages'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.9 – Netflix 股票价格与移动平均线](img/Figure_7.9_B16834.jpg)'
- en: '](img/Figure_7.9_B16834.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.9_B16834.jpg)'
- en: Figure 7.9 – Netflix stock price with moving averages
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.9 – Netflix 股票价格与移动平均线
- en: Traders experiment with different-period moving averages depending on the task
    at hand, such as anticipating upside moves (increases in stock price) and making
    planned exits before downside moves (decreases in stock price). Other uses include
    calculating automatic **support** and **resistance** levels (which we first saw
    in [*Chapter 6*](B16834_06_Final_SK_ePub.xhtml#_idTextAnchor125), *Plotting with
    Seaborn and Customization Techniques*) by finding the portion of the moving average
    line that props up the data from beneath or the one that acts as a ceiling for
    the data, respectively. When a stock price approaches the support, the price tends
    to be attractive enough that people buy, thus increasing the price (moving up
    from the support toward the resistance). However, when the stock reaches the resistance,
    it tends to encourage people to sell, bringing the stock price down (moving away
    from the resistance and toward the support).
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 交易者根据手头任务的不同，尝试使用不同周期的移动平均线，例如预测股价上涨（股价上涨）并在股价下跌前做出计划性退出（股价下跌）。其他用途包括通过找到支撑线和阻力线来自动计算**支撑位**和**阻力位**（我们在[
    *第 6 章* ](B16834_06_Final_SK_ePub.xhtml#_idTextAnchor125)，*使用 Seaborn 进行绘图与自定义技巧*
    中首次看到），通过找到支撑线支撑数据的部分，或找到作为数据天花板的部分。当股价接近支撑位时，价格通常会足够吸引人，促使人们买入，从而推动股价上涨（从支撑位向阻力位移动）。然而，当股价达到阻力位时，通常会促使人们卖出，导致股价下跌（从阻力位远离，向支撑位靠近）。
- en: '*Figure 7.10* shows an example of how support (green) and resistance (red)
    act as lower and upper bounds, respectively, for the stock price; once the price
    hits either of these bounds, it tends to bounce back in the opposite direction
    due to buyers/sellers of the stock taking action:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7.10* 展示了支撑位（绿色）和阻力位（红色）如何分别作为股票价格的下限和上限；一旦价格触及这些边界之一，它通常会因为股票买卖双方的行动而反弹到相反方向：'
- en: '![Figure 7.10 – Example support and resistance for Netflix stock in 2018'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.10 – 2018 年 Netflix 股票的支撑位和阻力位示例](img/Figure_7.10_B16834.jpg)'
- en: '](img/Figure_7.10_B16834.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.10_B16834.jpg)'
- en: Figure 7.10 – Example support and resistance for Netflix stock in 2018
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.10 – 2018 年 Netflix 股票的支撑位和阻力位示例
- en: 'Often, the **exponentially weighted moving average** (**EWMA**) can provide
    a better trend since we can put additional emphasis on more recent values. Let''s
    see how exponential smoothing looks for our data:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，**指数加权移动平均线**（**EWMA**）可以提供更好的趋势，因为我们可以对最近的值给予更多的权重。让我们来看看对数据进行指数平滑处理的效果：
- en: '[PRE47]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The 90-day EWMA appears to be acting as the support level in the shaded region:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 90 天的 EWMA 看起来在阴影区域内充当了支撑位：
- en: '![Figure 7.11 – Netflix stock price with EWMAs'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.11 – Netflix 股票价格与 EWMAs'
- en: '](img/Figure_7.11_B16834.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.11_B16834.jpg)'
- en: Figure 7.11 – Netflix stock price with EWMAs
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.11 – Netflix 股票价格与 EWMAs
- en: Tip
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: The notebook contains a cell for interactive visualization of the moving average
    and the EWMA using widgets. We can use these types of visualizations to determine
    the best window for the calculations. Note that using this cell may require some
    additional setup, but it is all noted right above the cell in the notebook.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 该笔记本包含了一个用于交互式可视化移动平均线和指数加权移动平均线（EWMA）的单元格。我们可以使用这些类型的可视化来确定计算的最佳窗口。请注意，使用此单元格可能需要一些额外的设置，但相关设置已在单元格上方标明。
- en: 'In the exercises for [*Chapter 5*](B16834_05_Final_SK_ePub.xhtml#_idTextAnchor106),
    *Visualizing Data with Pandas and Matplotlib*, we wrote code for generating a
    visualization that represented the effect that after-hours trading had on Facebook;
    the `StockVisualizer` class also has this functionality. Let''s use the `after_hours_trades()`
    method to see how Netflix fared:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 5 章*](B16834_05_Final_SK_ePub.xhtml#_idTextAnchor106)《使用 Pandas 和 Matplotlib
    可视化数据》的练习中，我们编写了生成可视化图表的代码，展示了盘后交易对 Facebook 的影响；`StockVisualizer` 类也具备这个功能。我们使用
    `after_hours_trades()` 方法来查看 Netflix 的盘后交易表现：
- en: '[PRE48]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Netflix had a rough third quarter in 2019 in terms of after-hours trades:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: Netflix 在 2019 年第三季度的盘后交易表现不佳：
- en: '![Figure 7.12 – Visualizing the effect of after-hours trading on Netflix stock'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.12 – 可视化盘后交易对 Netflix 股票的影响'
- en: '](img/Figure_7.12_B16834.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.12_B16834.jpg)'
- en: Figure 7.12 – Visualizing the effect of after-hours trading on Netflix stock
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.12 – 可视化盘后交易对 Netflix 股票的影响
- en: 'We can use candlestick plots to study the OHLC data. Let''s create one for
    Netflix, along with a bar plot for volume traded, by using the `candlestick()`
    method. We will also resample the data into 2-week intervals to improve the visibility
    of the candlesticks:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用蜡烛图来研究 OHLC 数据。我们将使用 `candlestick()` 方法为 Netflix 创建一个蜡烛图，并同时绘制交易量的条形图。我们还将把数据重新采样为
    2 周的时间间隔，以便更清晰地展示蜡烛图：
- en: '[PRE49]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Remember from *Figure 7.8* that when the body of the candlestick is white,
    it means that the stock gained value. Note that, for the most part, the spikes
    in volume traded were accompanied by increases in stock value:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 从 *图 7.8* 中记得，当蜡烛图的实体为白色时，意味着股票价值上涨。请注意，大多数情况下，交易量的尖峰伴随着股票价值的上涨：
- en: '![Figure 7.13 – Candlestick plot with trading volume'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.13 – 带有交易量的蜡烛图'
- en: '](img/Figure_7.13_B16834.jpg)'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.13_B16834.jpg)'
- en: Figure 7.13 – Candlestick plot with trading volume
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.13 – 带有交易量的蜡烛图
- en: Tip
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'Traders use candlestick plots to look for and analyze patterns in an asset''s
    performance, which can be used to make trading decisions. Check out this article
    for an introduction to candlestick plots and some common patterns traders look
    for: [https://www.investopedia.com/trading/candlestick-charting-what-is-it/](https://www.investopedia.com/trading/candlestick-charting-what-is-it/).'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 交易者使用蜡烛图来寻找并分析资产表现中的模式，这些模式可以帮助做出交易决策。查看这篇文章，了解蜡烛图以及交易者常见的分析模式：[https://www.investopedia.com/trading/candlestick-charting-what-is-it/](https://www.investopedia.com/trading/candlestick-charting-what-is-it/)。
- en: 'Before moving on, we need to reset our plot styles. The `mplfinance` package
    sets many of the available styling options for its plots, so let''s return to
    the style we are familiar with for now:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，我们需要重置图表的样式。`mplfinance` 包提供了许多可用的样式选项，因此我们暂时返回到我们熟悉的样式：
- en: '[PRE50]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We have already taken a look at a stock in isolation (Facebook) in prior chapters,
    so let''s take this in a different direction and compare Netflix to others. Let''s
    use the `jointplot()` method to see how Netflix compares to the S&P 500:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们已经单独看过一只股票（Facebook），所以我们接下来将从另一个角度进行比较，把 Netflix 和其他股票做对比。我们使用 `jointplot()`
    方法来看 Netflix 与标普 500 的对比：
- en: '[PRE51]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'If we take a look at the plot, they appear to be weakly positively correlated.
    With financial analysis, we can calculate a metric called **beta** that indicates
    an asset''s correlation to an index, such as the S&P 500\. We will calculate beta
    in the *Technical analysis of financial instruments* section later in this chapter:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看一下图表，它们似乎有较弱的正相关关系。在金融分析中，我们可以计算一个叫做**beta**的指标，表示某个资产与一个指数（例如 S&P 500）之间的相关性。我们将在本章后面的*金融工具的技术分析*部分计算beta：
- en: '![Figure 7.14 – Comparing Netflix to the S&P 500'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.14 – 将Netflix与S&P 500进行比较'
- en: '](img/Figure_7.14_B16834.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.14_B16834.jpg)'
- en: Figure 7.14 – Comparing Netflix to the S&P 500
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.14 – 将Netflix与S&P 500进行比较
- en: 'We can use the `correlation_heatmap()` method to visualize the correlations
    between Netflix and Amazon as a heatmap, using the daily percentage change of
    each of the columns:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`correlation_heatmap()`方法，将Netflix和Amazon之间的相关性可视化为热力图，使用每列的日百分比变化：
- en: '[PRE52]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Netflix and Amazon are weakly positively correlated, but only on the OHLC data:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: Netflix和Amazon之间存在弱正相关，但仅在OHLC数据中：
- en: '![Figure 7.15 – Correlation heatmap between Netflix and Amazon'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.15 – Netflix与Amazon的相关性热力图'
- en: '](img/Figure_7.15_B16834.jpg)'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.15_B16834.jpg)'
- en: Figure 7.15 – Correlation heatmap between Netflix and Amazon
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.15 – Netflix与Amazon的相关性热力图
- en: 'Lastly, we can use the `fill_between_other()` method to see how another asset
    grew (or fell) in price compared to Netflix. We will compare Netflix to Tesla
    here to see an example of one stock surpassing another:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以使用`fill_between_other()`方法查看另一项资产与Netflix相比在价格上的增长（或下降）。在这里，我们将 Netflix
    与特斯拉进行比较，看看一个股票超过另一个股票的例子：
- en: '[PRE53]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Notice that the shaded region shrinks in height as it approaches the reference
    line—this is the difference between the values in Netflix stock and Tesla stock
    decreasing over time. On November 11, 2020, as Tesla overtakes Netflix, the shaded
    region changes in color (from green to red) and begins to increase in height as
    Tesla widens the gap:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，随着阴影区域接近参考线，其高度逐渐缩小——这表示 Netflix 股票和特斯拉股票之间的差异随着时间的推移而减小。在2020年11月11日，当特斯拉超过Netflix时，阴影区域的颜色发生变化（从绿色变为红色），并开始增高，因为特斯拉拉大了差距：
- en: '![Figure 7.16 – Stock price differential between Netflix and Tesla'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.16 – Netflix与特斯拉的股票价格差异'
- en: '](img/Figure_7.16_B16834.jpg)'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.16_B16834.jpg)'
- en: Figure 7.16 – Stock price differential between Netflix and Tesla
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.16 – Netflix与特斯拉的股票价格差异
- en: Up until this point, we have discussed visualizing a single asset—in this case,
    Netflix—so let's move on and see how we can perform some EDA across asset groups
    with the `AssetGroupVisualizer` class.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们讨论了如何可视化单一资产——在这种情况下是 Netflix——接下来我们将继续，看看如何使用`AssetGroupVisualizer`类在资产组之间进行一些EDA分析。
- en: Visualizing multiple assets
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可视化多个资产
- en: 'As we did previously, we will start by inheriting from the `Visualizer` class
    and writing our docstring. Note that the `AssetGroupVisualizer` class also keeps
    track of the column to use for `groupby()` operations, so we override the `__init__()`
    method; since this change was meant to be in addition to what was already there,
    we call the `__init__()` method of the superclass as well:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 就像之前那样，我们将从`Visualizer`类继承并编写我们的文档字符串。请注意，`AssetGroupVisualizer`类还会跟踪用于`groupby()`操作的列，因此我们会重写`__init__()`方法；由于这个更改是对已有代码的补充，因此我们也会调用父类的`__init__()`方法：
- en: '[PRE54]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Next, we define the `evolution_over_time()` method to plot the same column
    for all the assets in the group in a single plot for comparison purposes. Since
    our data is of a different shape, we will use `seaborn` this time:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义`evolution_over_time()`方法，以便在单个图中绘制资产组中所有资产的相同列，进行对比分析。由于我们的数据形状不同，这次我们将使用`seaborn`：
- en: '[PRE55]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'When using `seaborn` or only plotting a single asset, we didn''t have to worry
    about the layout of our subplots; however, for some of the other asset group visualizations,
    we need a way to automatically determine a reasonable subplot layout. For this,
    we will add the `_get_layout()` method, which will generate the `Figure` and `Axes`
    objects we need for a given number of subplots (determined by the number of unique
    assets in the group):'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`seaborn`或仅绘制单个资产时，我们不需要担心子图的布局；然而，对于一些其他资产组的可视化，我们需要一种方法来自动确定合理的子图布局。为此，我们将添加`_get_layout()`方法，该方法将为给定数量的子图生成所需的`Figure`和`Axes`对象（由资产组中唯一资产的数量决定）：
- en: '[PRE56]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now, we need to define how `_window_calc()` will work with groups. We will
    need to use our `_get_layout()` method to build subplots for each of the assets
    in the group:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要定义 `_window_calc()` 如何与资产组一起工作。我们需要使用 `_get_layout()` 方法为组中的每个资产构建子图：
- en: '[PRE57]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'We can override `after_hours_trades()` to visualize the effect of after-hours
    trading on a group of assets using subplots and iterating over the assets in the
    group:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以重写 `after_hours_trades()` 来可视化盘后交易对资产组的影响，方法是使用子图并遍历组中的资产：
- en: '[PRE58]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'With the `StockVisualizer` class, we were able to generate a joint plot between
    two assets'' closing prices, but here we can override `pairplot()` to allow us
    to see the relationships between the closing prices across assets in the group:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `StockVisualizer` 类，我们能够生成两只资产收盘价之间的联合图，但在这里我们可以重写 `pairplot()`，以便查看资产组中资产之间收盘价的关系：
- en: '[PRE59]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Finally, we add the `heatmap()` method, which generates a heatmap of the correlations
    between the closing prices of all the assets in the group:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们添加 `heatmap()` 方法，它生成所有资产组中收盘价之间相关性的热图：
- en: '[PRE60]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We can use the `heatmap()` method to see how the daily percentage change across
    assets compares. This will handle the difference in scale between the assets (Google
    and Amazon have much higher stock prices than Facebook and Apple, meaning that
    gains of a few dollars mean more to Facebook and Apple):'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `heatmap()` 方法查看资产之间的日变化百分比对比。这将处理资产间的规模差异（谷歌和亚马逊的股价远高于 Facebook 和苹果，这意味着几美元的涨幅对
    Facebook 和苹果来说影响更大）：
- en: '[PRE61]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Apple-S&P 500 and Facebook-Google have the strongest correlations, with bitcoin
    having no correlation with anything:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 苹果与标准普尔500指数、Facebook 与谷歌之间有最强的相关性，而比特币与任何资产都没有相关性：
- en: '![Figure 7.17 – Correlations between asset prices'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.17 – 资产价格之间的相关性'
- en: '](img/Figure_7.17_B16834.jpg)'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.17_B16834.jpg)'
- en: Figure 7.17 – Correlations between asset prices
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.17 – 资产价格之间的相关性
- en: 'In the interest of brevity, rather than show all the methods for visualizing
    an asset group, which will result in large plots, I will leave that to you to
    view and try out in the notebook. However, let''s combine these `Visualizers`
    to see how all of our assets evolved over time:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁起见，避免展示所有可视化资产组的方法（这些方法会生成大量图形），我将把这部分留给你在笔记本中查看并尝试。不过，让我们结合这些 `Visualizers`
    来看看所有资产随时间的演变：
- en: '[PRE62]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Note that bitcoin had huge gains to close out 2020 (check out the scale on
    the *y*-axis), and Amazon also saw a lot of growth in 2020:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，比特币在2020年底大幅上涨（查看 *y* 轴的刻度），而亚马逊在2020年也经历了显著增长：
- en: '![Figure 7.18 – Evolution of asset price over time'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.18 – 资产价格随时间的变化'
- en: '](img/Figure_7.18_B16834.jpg)'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.18_B16834.jpg)'
- en: Figure 7.18 – Evolution of asset price over time
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.18 – 资产价格随时间的变化
- en: Now that we have a good feel for our data, we are ready to look at some metrics.
    Note that, while we only looked at and used a subset of the code, I encourage
    you to try out all the methods in the `Visualizer` classes using the notebook
    for this chapter; the exercises will also offer an additional occasion to use
    them.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对数据有了充分的了解，我们可以开始查看一些指标了。请注意，虽然我们只查看并使用了部分代码，我鼓励你在本章的笔记本中尝试所有 `Visualizer`
    类的方法；练习题也将提供额外的机会来使用它们。
- en: Technical analysis of financial instruments
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 金融工具的技术分析
- en: With technical analysis of assets, metrics (such as cumulative returns and volatility)
    are calculated to compare various assets to each other. As with the previous two
    sections in this chapter, we will be writing a module with classes to help us.
    We will need the `StockAnalyzer` class for technical analysis of a single asset
    and the `AssetGroupAnalyzer` class for technical analysis of a group of assets.
    These classes are in the `stock_analysis/stock_analyzer.py` file.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在资产的技术分析中，计算一些指标（如累计回报和波动率）来比较不同资产之间的差异。与本章前两部分一样，我们将编写一个包含类的模块来帮助我们。我们将需要 `StockAnalyzer`
    类来分析单一资产的技术指标，和 `AssetGroupAnalyzer` 类来分析资产组的技术指标。这些类位于 `stock_analysis/stock_analyzer.py`
    文件中。
- en: 'As with the other modules, we will start with our docstring and imports:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他模块一样，我们将从文档字符串和导入开始：
- en: '[PRE63]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The StockAnalyzer class
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: StockAnalyzer 类
- en: 'For analyzing individual assets, we will build the `StockAnalyzer` class, which
    calculates metrics for a given asset. The following UML diagram shows all the
    metrics that it provides:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 对于单个资产的分析，我们将构建 `StockAnalyzer` 类来计算给定资产的指标。下图 UML 显示了它提供的所有指标：
- en: '![Figure 7.19 – Structure of the StockAnalyzer class'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.19 – StockAnalyzer 类的结构'
- en: '](img/Figure_7.19_B16834.jpg)'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.19_B16834.jpg)'
- en: Figure 7.19 – Structure of the StockAnalyzer class
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.19 – StockAnalyzer 类的结构
- en: 'A `StockAnalyzer` instance will be initialized with the data for the asset
    on which we want to perform a technical analysis. This means that our `__init__()`
    method will need to accept the data as a parameter:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '`StockAnalyzer` 实例将使用我们希望进行技术分析的资产数据进行初始化。这意味着我们的 `__init__()` 方法需要接受数据作为参数：'
- en: '[PRE64]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Most of the calculations for our technical analysis will rely on the closing
    price of the stock, so rather than needing to write `self.data.close` in all of
    our methods, we will create a property so that we can access it with `self.close`
    instead. This makes our code cleaner and easier to follow:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的大部分技术分析计算将依赖于股票的收盘价，因此，为了避免在所有方法中都写 `self.data.close`，我们将创建一个属性，使我们能够通过 `self.close`
    访问它。这使得我们的代码更加简洁和易于理解：
- en: '[PRE65]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'A few calculations will also need the percent change of the `close` column,
    so we will make a property for easier access to that as well:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 一些计算还需要 `close` 列的百分比变化，因此我们将为其创建一个属性，方便访问：
- en: '[PRE66]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Since we will be calculating support and resistance levels using the **pivot
    point**, which is the average of the high, low, and close on the last day in the
    data, we will make a property for it, as well:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将使用**枢轴点**来计算支撑和阻力水平，枢轴点是数据中最后一天的最高价、最低价和收盘价的平均值，因此我们也会为它创建一个属性：
- en: '[PRE67]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Note that we are also using other properties—`self.last_close`, `self.last_high`,
    and `self.last_low`—which we define using the `last()` method on the data, before
    selecting the column in question and using `iat[]` to get just the price:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们还使用了其他属性——`self.last_close`、`self.last_high` 和 `self.last_low`——这些属性通过在数据上使用
    `last()` 方法定义，然后选择相应的列并使用 `iat[]` 获取对应的价格：
- en: '[PRE68]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Now, we have everything we need to calculate support and resistance. We will
    be calculating each at three different levels, where the first level is the closest
    to the closing price and the third level is the farthest. The first level will
    therefore be the most restrictive level, and the third will be the least restrictive.
    We define the `resistance()` method as follows, allowing the caller to specify
    the level to calculate:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们拥有了计算支撑和阻力所需的一切。我们将在三个不同的水平上计算每个值，其中第一个水平离收盘价最近，第三个水平最远。因此，第一个水平是最具限制性的水平，第三个水平则是最不具限制性的。我们将
    `resistance()` 方法定义如下，允许调用者指定计算的级别：
- en: '[PRE69]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The `support()` method is defined in a similar fashion:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '`support()` 方法的定义方式类似：'
- en: '[PRE70]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Next, we will work on creating methods for analyzing asset volatility. First,
    we will calculate the daily standard deviation of the percent change in the closing
    price, for which we will need to specify the number of trading periods. In order
    to make sure that we can''t use more trading periods than we have in the data,
    we will define a property with the maximum value we can use for this argument:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建用于分析资产波动性的方法。首先，我们将计算收盘价百分比变化的日标准差，计算时需要指定交易期数。为了确保我们不会使用超出数据中期数的交易期数，我们将定义一个属性，其中包含可以用于此参数的最大值：
- en: '[PRE71]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Now that we have our maximum, we can define the `daily_std()` method, which
    calculates the daily standard deviation of the daily percentage change:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经得到了最大值，我们可以定义 `daily_std()` 方法，该方法计算每日百分比变化的日标准差：
- en: '[PRE72]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'While `daily_std()` is useful on its own, we can take this a step further and
    calculate annualized volatility by multiplying the daily standard deviation by
    the square root of the number of trading periods in the year, which we assume
    to be 252:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `daily_std()` 本身很有用，但我们可以更进一步，通过将日标准差乘以一年中交易期数的平方根来计算年化波动性，我们假设一年有 252 个交易日：
- en: '[PRE73]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'In addition, we can look at rolling volatility by using the `rolling()` method:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以使用 `rolling()` 方法来查看滚动波动性：
- en: '[PRE74]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'We often want to compare assets, so we provide the `corr_with()` method to
    calculate the correlations between them using daily percentage change:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常需要比较不同资产，因此我们提供了 `corr_with()` 方法，使用每日百分比变化来计算它们之间的相关性：
- en: '[PRE75]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Next, we define some metrics for comparing the level of dispersion of assets.
    In [*Chapter 1*](B16834_01_Final_SK_ePub.xhtml#_idTextAnchor015), *Introduction
    to Data Analysis*, we discussed the coefficient of variation (the `cv()` method)
    and the quantile coefficient of dispersion (the `qcd()` method), which we can
    use to achieve this, both of which we will add here:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义一些用于比较资产分散程度的指标。在[*第一章*](B16834_01_Final_SK_ePub.xhtml#_idTextAnchor015)《数据分析入门》中，我们讨论了变异系数（`cv()`方法）和分位数离散系数（`qcd()`方法），我们可以利用这些指标来实现此目标，接下来我们将添加这两者：
- en: '[PRE76]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'In addition, we want a way to quantify the volatility of an asset compared
    to an index, such as the S&P 500, for which we calculate `beta()` method, which
    allows the user to specify the index to use as a benchmark:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还希望有一种方法来量化资产相对于指数的波动性，例如标准普尔500指数（S&P 500），为此我们计算`beta()`方法，允许用户指定用作基准的指数：
- en: '[PRE77]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Next, we define a method for calculating the cumulative returns of an asset
    as a series. This is defined as the cumulative product of one plus the percent
    change in closing price:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个方法来计算资产的累积回报率，作为一个系列。这被定义为一加上收盘价百分比变化的累积乘积：
- en: '[PRE78]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The next few metrics we want to support require calculating the return of the
    portfolio. To make things simpler, we will assume that there is no distribution
    per share so that the return of the portfolio is the percent change from the starting
    price to the ending price over the time period covered by the data. We will define
    this as a static method since we will need to calculate this for an index, and
    not just the data stored in `self.data`:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们需要支持的几个指标要求计算投资组合的回报。为了简化问题，我们假设每股没有分红，因此投资组合的回报是从起始价格到结束价格的百分比变化，覆盖的数据时间段内。我们将其定义为静态方法，因为我们需要为一个指数计算该值，而不仅仅是`self.data`中存储的数据：
- en: '[PRE79]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'While beta allows us to compare an asset''s volatility to an index, **alpha**
    allows us to compare the returns of the asset to those of an index. To do so,
    we also need the risk-free rate of return, which is the rate of return of an investment
    that has no risk of financial loss; in practice, we use US Treasury bills for
    this. Calculating alpha requires calculating the portfolio return of the index
    and the asset, along with beta:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然beta可以让我们将资产的波动性与指数进行比较，但**alpha**使我们能够将资产的回报与指数的回报进行比较。为此，我们还需要无风险回报率，即没有财务损失风险的投资的回报率；在实际操作中，我们通常使用美国国债作为参考。计算alpha需要计算指数和资产的投资组合回报以及beta：
- en: '[PRE80]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Tip
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: '[PRE81]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'We also want to add methods that will tell us whether the asset is in a **bear
    market** or a **bull market**, meaning that it had a decline or increase in stock
    price of 20% or more in the last 2 months, respectively:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望添加一些方法，告诉我们资产是否处于**熊市**或**牛市**，即在过去2个月内，股票价格分别下跌或上涨了20％以上：
- en: '[PRE82]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Lastly, we will add a method for calculating the **Sharpe ratio**, which tells
    us the return we receive in excess of the risk-free rate of return for the volatility
    we take on with the investment:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将添加一个方法来计算**夏普比率**，该比率告诉我们在承担投资波动性时，相对于无风险回报率，我们所获得的超额回报：
- en: '[PRE83]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Take some time to digest the code in this module as we are continuing to build
    upon what we have discussed. We won't be using all of these metrics for our technical
    analysis, but I encourage you to try them out in the notebook for this chapter.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 花些时间消化本模块中的代码，因为我们将在之前讨论的基础上继续构建。我们不会使用所有这些指标进行技术分析，但我鼓励你在本章的笔记本中尝试这些方法。
- en: The AssetGroupAnalyzer class
  id: totrans-364
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`AssetGroupAnalyzer`类'
- en: All the calculations we will work with in this section are defined on the `StockAnalyzer`
    class; however, rather than having to run these for each of the assets we want
    to compare, we will also create the `AssetGroupAnalyzer` class (in the same module)
    that's capable of providing these metrics for a group of assets.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中我们将使用的所有计算都定义在`StockAnalyzer`类中；然而，为了避免对每个要比较的资产都进行计算，我们还将创建`AssetGroupAnalyzer`类（在同一个模块中），该类能够为一组资产提供这些指标。
- en: 'The `StockAnalyzer` and `AssetGroupAnalyzer` classes will share much of their
    functionality, which makes a strong argument for designing them with inheritance;
    however, sometimes—as in this case—composition can make more sense. When objects
    contain instances of other classes, it is referred to as `AssetGroupAnalyzer`
    class:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '`StockAnalyzer`和`AssetGroupAnalyzer`类将共享它们的大部分功能，这为它们的继承设计提供了强有力的论据；然而，有时——如在这种情况下——组合设计更有意义。当对象包含其他类的实例时，这就是`AssetGroupAnalyzer`类的情况：'
- en: '![Figure 7.20 – Structure of the AssetGroupAnalyzer class'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.20 – AssetGroupAnalyzer 类的结构'
- en: '](img/Figure_7.20_B16834.jpg)'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.20_B16834.jpg)'
- en: Figure 7.20 – Structure of the AssetGroupAnalyzer class
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.20 – AssetGroupAnalyzer 类的结构
- en: 'We create an `AssetGroupAnalyzer` instance by providing the dataframe for the
    assets and the name of the grouping column (if not `name`). Upon initialization,
    the `_composition_handler()` method is called to create a dictionary of `StockAnalyzer`
    objects (one for each asset):'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过提供资产的数据框和分组列的名称（如果不是 `name`）来创建 `AssetGroupAnalyzer` 实例。初始化时，会调用 `_composition_handler()`
    方法来创建 `StockAnalyzer` 对象的字典（每个资产一个）：
- en: '[PRE84]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The `AssetGroupAnalyzer` class has only one public method, `analyze()`—all
    the actual calculations are delegated to the `StockAnalyzer` objects stored in
    the `analyzers` attribute:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '`AssetGroupAnalyzer` 类只有一个公共方法，`analyze()`—所有实际的计算都委托给存储在 `analyzers` 属性中的
    `StockAnalyzer` 对象：'
- en: '[PRE85]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: With inheritance, in this case, all the methods would have to be overridden
    because they can't handle the `groupby()` operation. Conversely, with composition,
    all that's necessary is to create `StockAnalyzer` objects for each asset and use
    dictionary comprehensions for the calculations. Another neat thing is that, by
    using `getattr()`, there is no need to mirror the methods in the `AssetGroupAnalyzer`
    class because `analyze()` can grab the method by name using the `StockAnalyzer`
    objects.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 使用继承时，在这种情况下，所有方法都必须被重写，因为它们无法处理 `groupby()` 操作。相反，使用组合时，只需要为每个资产创建 `StockAnalyzer`
    对象，并使用字典推导式来进行计算。另一个很棒的地方是，使用 `getattr()` 时，无需在 `AssetGroupAnalyzer` 类中镜像方法，因为
    `analyze()` 可以通过名称使用 `StockAnalyzer` 对象来抓取方法。
- en: Comparing assets
  id: totrans-375
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较资产
- en: 'Let''s use the `AssetGroupAnalyzer` class to compare all the assets we have
    collected data for. As with prior sections, we won''t use all the methods in the
    `StockAnalyzer` class here, so be sure to try them out on your own:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 `AssetGroupAnalyzer` 类来比较我们收集的所有资产数据。与之前的章节一样，我们不会在这里使用 `StockAnalyzer`
    类中的所有方法，因此请务必自己尝试：
- en: '[PRE86]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Remember from [*Chapter 1*](B16834_01_Final_SK_ePub.xhtml#_idTextAnchor015),
    *Introduction to Data Analysis*, that the **coefficient of variation** (**CV**)
    is the ratio of the standard deviation to the mean; this helps us compare the
    variation of asset closing prices, even though their means are of different magnitudes
    (for instance, Amazon and Apple). The CV can also be used to compare the volatility
    to the expected return of an investment and quantify the risk-return trade-off.
    Let''s use the CV to see which asset''s closing price is the most widely dispersed:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 记住在[*第 1 章*](B16834_01_Final_SK_ePub.xhtml#_idTextAnchor015)《数据分析导论》中提到，**变异系数**（**CV**）是标准差与均值的比率；这有助于我们比较资产收盘价的变化程度，即使它们的均值差异较大（例如，亚马逊和苹果）。CV
    还可以用来比较投资的波动性与预期回报，并量化风险与回报的权衡。让我们使用 CV 来查看哪种资产的收盘价波动最大：
- en: '[PRE87]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'It''s probably not a surprise that bitcoin has the widest spread. Rather than
    use the closing price, percent change daily can be used to calculate the annualized
    volatility. This involves calculating the standard deviations of percent change
    over the last year and multiplying it by the square root of the number of trading
    days in the year (the code assumes 252). By using percent change, large changes
    in price (relative to the asset''s price) will be penalized more severely. Using
    annualized volatility, Facebook looks much more volatile compared to when we used
    the CV (although still not the most volatile):'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币有着最广泛的价格波动，这应该不是什么惊讶的事。与其使用收盘价，不如使用每日的百分比变化来计算年化波动率。这涉及到计算过去一年中百分比变化的标准差，并将其乘以一年中交易日数量的平方根（代码假设为
    252）。通过使用百分比变化，相对于资产价格的较大价格波动会受到更严厉的惩罚。使用年化波动率时，Facebook 看起来比我们使用 CV 时波动性更大（尽管仍然不是最波动的资产）：
- en: '[PRE88]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Given that all the assets have gained value toward the end of our dataset,
    let''s check if any of them have entered a **bull market**, meaning that the asset''s
    return in the last 2 months is a 20% or greater gain:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于所有资产在数据集末尾都获得了增值，接下来让我们检查这些资产是否进入了**牛市**，即在过去 2 个月内，资产的回报增长达到了 20% 或更高：
- en: '[PRE89]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'It looks like Apple and bitcoin had quite a November and December in 2020\.
    The other assets appear to not have fared as well; however, none of them are in
    a bear market (we can confirm this by passing `''is_bear_market''` to `analyze()`).
    Yet another way to analyze volatility is to compare the assets to an index by
    calculating **beta**. Positive values greater than 1 indicate volatility higher
    than the index, while negative values less than -1 indicate inverse relationships
    to the index:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来苹果和比特币在2020年11月和12月表现相当突出。其他资产的表现似乎不太好；然而，它们都没有进入熊市（我们可以通过将 `'is_bear_market'`
    传递给 `analyze()` 来确认这一点）。另一种分析波动性的方法是通过计算**贝塔值**来将资产与指数进行比较。大于1的正值表示波动性高于该指数，而小于-1的负值则表示与该指数的反向关系：
- en: '[PRE90]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Using the betas from the previous result, we can see that Apple is the most
    volatile compared to the S&P 500, meaning that if this was our portfolio (leaving
    out bitcoin for the moment), adding Apple would have increased the portfolio risk.
    However, we know that bitcoin is not correlated to the S&P 500 (see the correlation
    heatmap in *Figure 7.17*), so this low beta is misleading.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 使用之前结果中的贝塔值，我们可以看到与标准普尔500指数相比，苹果的波动性最大，这意味着如果这是我们的投资组合（暂时不考虑比特币），添加苹果股票会增加投资组合的风险。然而，我们知道比特币与标准普尔500指数之间没有相关性（请参见*图
    7.17*中的相关性热图），所以这个低贝塔值是具有误导性的。
- en: 'The last metric we will take a look at is `r_f`); we typically use the return
    of a US Treasury bill for this number. Rates can be looked up at [https://www.treasury.gov/resource-center/data-chart-center/interest-rates/pages/TextView.aspx?data=yield](https://www.treasury.gov/resource-center/data-chart-center/interest-rates/pages/TextView.aspx?data=yield);
    alternatively, we can use our `StockReader` object (`reader`) to collect this
    for us. Let''s compare the alphas for the assets using the S&P 500 as our index:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要查看的最后一个指标是 `r_f`）；我们通常使用美国国债的回报率作为这个数字。利率可以在[https://www.treasury.gov/resource-center/data-chart-center/interest-rates/pages/TextView.aspx?data=yield](https://www.treasury.gov/resource-center/data-chart-center/interest-rates/pages/TextView.aspx?data=yield)上查找；或者，我们可以使用
    `StockReader` 对象（`reader`）来为我们收集这个数据。让我们使用标准普尔500指数作为基准，比较这些资产的阿尔法值：
- en: '[PRE91]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Everything beat the S&P 500, which essentially being a portfolio of 500 stocks
    has lower risk and lower returns due to `Cycler` object ([https://matplotlib.org/cycler/](https://matplotlib.org/cycler/))
    that varies the color and line styles:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 所有资产的表现都超过了标准普尔500指数，而标准普尔500作为一个由500只股票组成的投资组合，其风险较低、回报较低，这是由于`Cycler`对象的存在（[https://matplotlib.org/cycler/](https://matplotlib.org/cycler/))，该对象改变颜色和线条样式：
- en: '[PRE92]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Despite the struggles in early 2020, all of the assets gained value. Notice
    that the bitcoin subplot''s *y*-axis goes from 0 to 7 (right subplot), while the
    stock market subplot (left) covers half of that range:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管2020年初面临困境，但所有资产都获得了价值。请注意，比特币子图的 *y* 轴范围是从 0 到 7（右侧子图），而股市子图（左侧）的范围则覆盖了该范围的一半：
- en: '![Figure 7.21 – Cumulative returns for all assets'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.21 – 所有资产的累计回报'
- en: '](img/Figure_7.21_B16834.jpg)'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.21_B16834.jpg)'
- en: Figure 7.21 – Cumulative returns for all assets
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.21 – 所有资产的累计回报
- en: Now that we have a good understanding of how to analyze financial instruments,
    let's try our hand at forecasting future performance.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对如何分析金融工具有了良好的理解，接下来我们来尝试预测未来的表现。
- en: Modeling performance using historical data
  id: totrans-396
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用历史数据建模表现
- en: 'The goal of this section is to give us a taste of how to build some models;
    as such, the following examples are not meant to be the best possible model, but
    rather a simple and relatively quick implementation for learning purposes. Once
    again, the `stock_analysis` package has a class for this section''s task: `StockModeler`.'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的目标是让我们了解如何构建一些模型；因此，以下示例并不意味着是最佳模型，而是为了学习目的的简单且相对快速的实现。再次提醒，`stock_analysis`
    包中有一个适用于本节任务的类：`StockModeler`。
- en: Important note
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: To fully understand the statistical elements of this section and modeling in
    general, we need a solid understanding of statistics; however, the purpose of
    this discussion is to show how modeling techniques can be applied to financial
    data without dwelling on the underlying mathematics.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 要完全理解本节的统计元素和建模一般原理，我们需要对统计学有一个扎实的理解；然而，本讨论的目的是展示如何将建模技术应用于金融数据，而不深入探讨背后的数学原理。
- en: The StockModeler class
  id: totrans-400
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: StockModeler类
- en: 'The `StockModeler` class will make it easier for us to build and evaluate some
    simple financial models without needing to interact directly with the `statsmodels`
    package. In addition, we will reduce the number of steps that are needed to generate
    a model with the methods we create. The following UML diagram shows that this
    is a rather simple class. Notice that we have no attributes because `StockModeler`
    is a **static class** (meaning that we don''t instantiate it):'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '`StockModeler` 类将使我们更容易构建和评估一些简单的金融模型，而无需直接与 `statsmodels` 包进行交互。此外，我们将减少生成模型所需的步骤。以下
    UML 图显示这是一个相当简单的类。请注意，我们没有属性，因为 `StockModeler` 是一个**静态类**（意味着我们不实例化它）：'
- en: '![Figure 7.22 – Structure of the StockModeler class'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.22 – StockModeler 类的结构'
- en: '](img/Figure_7.22_B16834.jpg)'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.22_B16834.jpg)'
- en: Figure 7.22 – Structure of the StockModeler class
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.22 – StockModeler 类的结构
- en: 'The `StockModeler` class is defined in `stock_analysis/stock_modeler.py` and
    has methods for both building models and doing some preliminary analysis of their
    performance. As usual, we start the module with our docstring and imports:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '`StockModeler` 类定义在 `stock_analysis/stock_modeler.py` 中，并具有构建模型和进行一些初步性能分析的方法。像往常一样，我们以文档字符串和导入开始模块：'
- en: '[PRE93]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Next, we will start the `StockModeler` class and raise an error if someone
    tries to instantiate it:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将开始 `StockModeler` 类，并在有人尝试实例化它时引发错误：
- en: '[PRE94]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: "One of the tasks we want this class to support is time series decomposition,\
    \ which \Lwe discussed back in [*Chapter 1*](B16834_01_Final_SK_ePub.xhtml#_idTextAnchor015),\
    \ *Introduction to Data Analysis*. We imported the `seasonal_decompose()` function\
    \ from `statsmodels`, so we just have to call it on the closing price in our `decompose()`\
    \ method:"
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望这个类支持的任务之一是时间序列分解，我们在[*第一章*](B16834_01_Final_SK_ePub.xhtml#_idTextAnchor015)《数据分析简介》中讨论过这个内容。我们从
    `statsmodels` 导入了 `seasonal_decompose()` 函数，所以我们只需在 `decompose()` 方法中对收盘价调用它：
- en: '[PRE95]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Notice that we have two decorators for the `decompose()` method. The topmost
    decorator is applied on the result of the ones below it. In this example, we have
    the following:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们对 `decompose()` 方法有两个装饰器。最上面的装饰器应用于它下面装饰器的结果。在这个例子中，我们有以下内容：
- en: '[PRE96]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'In addition, we want to support creating ARIMA models, which we also discussed
    in [*Chapter 1*](B16834_01_Final_SK_ePub.xhtml#_idTextAnchor015), *Introduction
    to Data Analysis*. ARIMA models use the *ARIMA(p, d, q)* notation, where *p* is
    the number of time lags (or order) of the AR model, *d* is the number of past
    values that were subtracted from the data (the I model), and *q* is the number
    of periods used in the MA model. So, an *ARIMA(1, 1, 1)* is a model with one time
    lag for the autoregressive portion, data differenced once, and a 1-period moving
    average. If we have any zeros for the orders, we can eliminate those—for example,
    *ARIMA(1, 0, 1)* is equivalent to *ARMA(1, 1)*, and *ARIMA(0, 0, 3)* is equivalent
    to *MA(3)*. A seasonal ARIMA model is written as *ARIMA(p, d, q)(P, D, Q)*m where
    *m* is the number of periods in the seasonal model and *P*, *D*, and *Q* are the
    orders for the seasonal ARIMA model. The `StockModeler.arima()` method doesn''t
    support the seasonal components (for simplicity) and takes *p*, *d*, and *q* as
    parameters, but to avoid confusion we will name them after the ARIMA feature they
    represent—for example, `ar` for autoregressive (*p*). In addition, we are going
    to have our static method provide the option of fitting the model before returning
    it:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还希望支持创建 ARIMA 模型，我们在[*第一章*](B16834_01_Final_SK_ePub.xhtml#_idTextAnchor015)《数据分析简介》中也讨论过这一点。ARIMA
    模型使用 *ARIMA(p, d, q)* 符号，其中 *p* 是 AR 模型的时间滞后数（或阶数），*d* 是从数据中减去的过去值的数量（即 I 模型），*q*
    是 MA 模型中使用的周期数。因此，*ARIMA(1, 1, 1)* 是一个包含一个自回归部分时间滞后、数据差分一次以及一个 1 期的移动平均的模型。如果我们有任何阶数为零的情况，可以去掉它们——例如，*ARIMA(1,
    0, 1)* 等同于 *ARMA(1, 1)*，而 *ARIMA(0, 0, 3)* 等同于 *MA(3)*。季节性 ARIMA 模型写作 *ARIMA(p,
    d, q)(P, D, Q)*m，其中 *m* 是季节性模型中的周期数，*P*、*D* 和 *Q* 是季节性 ARIMA 模型的阶数。`StockModeler.arima()`
    方法不支持季节性组件（为了简化）并且接收 *p*、*d* 和 *q* 作为参数，但为了避免混淆，我们会根据它们所代表的 ARIMA 特性给它们命名——例如，`ar`
    代表自回归（*p*）。此外，我们还将使我们的静态方法在返回之前提供拟合模型的选项：
- en: '[PRE97]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Tip
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Note that the method signature (`df, *, ar, i, ma, ...`) has an asterisk (`*`)
    in it. This forces the parameters listed after it to be supplied as keyword arguments
    when calling the method. It's a nice way to make sure that whoever uses this is
    explicit about what they want.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 注意方法签名（`df, *, ar, i, ma, ...`）中有一个星号（`*`）。这强制要求在调用方法时，列出的参数必须作为关键字参数传递。这是一种确保使用者明确表达他们需求的好方式。
- en: 'To go along with this, we want a way to evaluate the ARIMA model''s predictions,
    so we will add the `arima_predictions()` static method. We will also provide the
    option of getting back the predictions as a `Series` object or as a plot:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 为了配合这一点，我们需要一种评估 ARIMA 模型预测结果的方法，因此我们将添加 `arima_predictions()` 静态方法。我们还将提供将预测结果返回为
    `Series` 对象或图表的选项：
- en: '[PRE98]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Similar to what we built for ARIMA models, we will also provide the `regression()`
    method for building a linear regression model of the closing price with a lag
    of 1\. For this, we will once again use `statsmodels` (in [*Chapter 9*](B16834_09_Final_SK_ePub.xhtml#_idTextAnchor188),
    *Getting Started with Machine Learning in Python*, we will use `scikit-learn`
    for linear regression instead):'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于我们为 ARIMA 模型构建的内容，我们还将提供 `regression()` 方法，用于构建以 1 的滞后期为基础的收盘价线性回归模型。为此，我们将再次使用
    `statsmodels`（在 [*第 9 章*](B16834_09_Final_SK_ePub.xhtml#_idTextAnchor188)《在 Python
    中入门机器学习》中，我们将使用 `scikit-learn` 进行线性回归）：
- en: '[PRE99]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'As with the `arima_predictions()` method, we want to provide a way to review
    the predictions from the model, either as a `Series` object or as a plot. Unlike
    the ARIMA model, it will only predict one value at a time. Therefore, we will
    start our predictions on the day after the last closing price and iteratively
    use the previous prediction to predict the next one. To handle all this, we will
    write the `regression_predictions()` method:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `arima_predictions()` 方法类似，我们希望提供一种方式来查看模型的预测结果，可以选择以 `Series` 对象或图表的形式呈现。与
    ARIMA 模型不同，它每次只预测一个值。因此，我们将从最后一个收盘价后的第二天开始进行预测，并通过迭代使用前一个预测值来预测下一个值。为了处理这一切，我们将编写
    `regression_predictions()` 方法：
- en: '[PRE100]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Lastly, for both the ARIMA and linear regression models, we want to visualize
    the errors in the predictions, or `resid` attribute, which will give us the residuals;
    we simply need to plot them as a scatter plot to check their variance and a KDE
    to check their mean. For this, we will add the `plot_residuals()` method:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于 ARIMA 和线性回归模型，我们都希望可视化预测中的误差，或者 `resid` 属性，它将给出残差；我们只需要将它们绘制为散点图来检查其方差，并使用
    KDE 检查其均值。为此，我们将添加 `plot_residuals()` 方法：
- en: '[PRE101]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Now, let's take the `StockModeler` class for a spin, once again using the Netflix
    data.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用 Netflix 数据再次体验一下 `StockModeler` 类。
- en: Time series decomposition
  id: totrans-426
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 时间序列分解
- en: 'As mentioned in [*Chapter 1*](B16834_01_Final_SK_ePub.xhtml#_idTextAnchor015),
    *Introduction to Data Analysis*, time series can be decomposed into trend, seasonal,
    and remainder components utilizing a specified frequency. This can be achieved
    with the `statsmodels` package, which `StockModeler.decompose()` is using:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 如在 [*第 1 章*](B16834_01_Final_SK_ePub.xhtml#_idTextAnchor015)《数据分析简介》中提到的，时间序列可以利用指定的频率分解为趋势、季节性和剩余成分。这可以通过
    `statsmodels` 包实现，`StockModeler.decompose()` 正在使用该包：
- en: '[PRE102]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'This returns the decomposition plot for Netflix with a frequency of 20 trading
    days:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回 Netflix 股票价格的分解图，频率为 20 个交易日：
- en: '![Figure 7.23 – Time series decomposition of Netflix''s stock price over time'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.23 – Netflix 股票价格随时间变化的时间序列分解'
- en: '](img/Figure_7.23_B16834.jpg)'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.23_B16834.jpg)'
- en: Figure 7.23 – Time series decomposition of Netflix's stock price over time
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.23 – Netflix 股票价格随时间变化的时间序列分解
- en: For more complicated models, we could decompose and then build our model around
    the components. That is beyond the scope of this chapter, however, so let's move
    on to ARIMA models.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更复杂的模型，我们可以先进行分解，然后围绕这些组成部分构建我们的模型。然而，这超出了本章的范围，因此我们将继续讨论 ARIMA 模型。
- en: ARIMA
  id: totrans-434
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ARIMA
- en: 'As we discussed in [*Chapter 1*](B16834_01_Final_SK_ePub.xhtml#_idTextAnchor015),
    *Introduction to Data Analysis*, ARIMA models have autoregressive, difference,
    and moving average components. They can also be built using the `statsmodels`
    package, which the `StockModeler.arima()` method is using; this method returns
    a fitted ARIMA model for the stock according to the specifications provided. Here,
    we will use the `%%capture` magic to avoid printing any warnings triggered by
    the ARIMA model fitting, since we are making a simple model to explore functionality:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[*第1章*](B16834_01_Final_SK_ePub.xhtml#_idTextAnchor015)《数据分析导论》中讨论的那样，ARIMA模型包含自回归、差分和滑动平均部分。它们也可以使用`statsmodels`包来构建，`StockModeler.arima()`方法正是利用这个包；此方法会根据提供的规格返回一个拟合的ARIMA模型。这里，我们将使用`%%capture`魔法命令来避免显示ARIMA模型拟合过程中产生的任何警告，因为我们正在构建一个简单的模型来探索其功能：
- en: '[PRE103]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Tip
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: We're picking these values because they run in a reasonable amount of time.
    In practice, we can use the `autocorrelation_plot()` function from the `pandas.plotting`
    module that was introduced in [*Chapter 5*](B16834_05_Final_SK_ePub.xhtml#_idTextAnchor106),
    *Visualizing Data with Pandas and Matplotlib*, to help find a good value for `ar`.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择这些值是因为它们在合理的时间内运行。实际上，我们可以使用在[*第5章*](B16834_05_Final_SK_ePub.xhtml#_idTextAnchor106)《使用Pandas和Matplotlib进行数据可视化》中介绍的`pandas.plotting`模块中的`autocorrelation_plot()`函数，帮助找到一个合适的`ar`值。
- en: 'Once the model is fitted, we can obtain information on it with the model''s
    `summary()` method:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦模型拟合完成，我们可以通过模型的`summary()`方法获取相关信息：
- en: '[PRE104]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'The summary is quite extensive, and we should read the documentation when looking
    to interpret it; however, this article is likely to be a more digestible introduction:
    [https://medium.com/analytics-vidhya/interpreting-arma-model-results-in-statsmodels-for-absolute-beginners-a4d22253ad1c](https://medium.com/analytics-vidhya/interpreting-arma-model-results-in-statsmodels-for-absolute-beginners-a4d22253ad1c).
    Be advised that interpreting this summary will require a solid understanding of
    statistics:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 该摘要相当全面，我们在解释时应参考文档；然而，本文可能是更易理解的入门介绍：[https://medium.com/analytics-vidhya/interpreting-arma-model-results-in-statsmodels-for-absolute-beginners-a4d22253ad1c](https://medium.com/analytics-vidhya/interpreting-arma-model-results-in-statsmodels-for-absolute-beginners-a4d22253ad1c)。需要注意的是，解释此摘要需要扎实的统计学基础：
- en: '![Figure 7.24 – Summary of our ARIMA model'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.24 – ARIMA模型的摘要'
- en: '](img/Figure_7.24_B16834.jpg)'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.24_B16834.jpg)'
- en: Figure 7.24 – Summary of our ARIMA model
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.24 – ARIMA模型的摘要
- en: 'For our purposes, a simpler way of analyzing the model is to look at the `StockModeler.plot_residuals()`
    method helps check for this visually:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 为了分析这个模型，我们可以用一种更简单的方法，通过查看`StockModeler.plot_residuals()`方法来帮助我们可视化地检查残差：
- en: '[PRE105]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'While the residuals are centered at 0 (right subplot), they are **heteroskedastic**—note
    how their variance appears to increase over time (left subplot):'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管残差的均值为0（右侧子图），它们是**异方差的**——注意到它们的方差随时间增加（左侧子图）：
- en: '![Figure 7.25 – Evaluating the residuals of our ARIMA model'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.25 – 评估我们ARIMA模型的残差'
- en: '](img/Figure_7.25_B16834.jpg)'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.25_B16834.jpg)'
- en: Figure 7.25 – Evaluating the residuals of our ARIMA model
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.25 – 评估我们ARIMA模型的残差
- en: Tip
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: When we looked at the model summary in *Figure 7.24*, `statsmodels` ran a statistical
    test for heteroskedasticity using the default significance level of 0.05\. The
    value of the test statistic is labeled **Heteroskedasticity (H)** and the p-value
    is labeled **Prob(H) (two-sided)**. Note that the result was statistically significant
    (the p-value was less than or equal to the significance level), meaning it's very
    unlikely that our residuals are homoskedastic.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看*图7.24*中的模型摘要时，`statsmodels`使用默认显著性水平0.05进行了异方差性的统计检验。检验统计量标记为**异方差性（H）**，p值标记为**Prob(H)（双侧）**。需要注意的是，结果在统计上是显著的（p值小于或等于显著性水平），这意味着我们的残差不太可能是同方差的。
- en: As an alternative to building an ARIMA model, the `StockModeler` class also
    gives us the option of using linear regression to model the closing price of a
    financial instrument.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 作为构建ARIMA模型的替代方案，`StockModeler`类还提供了使用线性回归来模拟金融工具收盘价的选项。
- en: Linear regression with statsmodels
  id: totrans-454
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用statsmodels进行线性回归
- en: 'The `StockModeler.regression()` method builds a linear regression model for
    closing price as a function of the prior day''s closing price using `statsmodels`:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: '`StockModeler.regression()`方法使用`statsmodels`构建一个以前一天收盘价为自变量的线性回归模型，预测收盘价：'
- en: '[PRE106]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Once again, the `summary()` method gives us statistics on the model''s fit:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，`summary()`方法会给我们模型拟合的统计信息：
- en: '![Figure 7.26 – Summary of our linear regression model'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.26 – 我们的线性回归模型总结'
- en: '](img/Figure_7.26_B16834.jpg)'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.26_B16834.jpg)'
- en: Figure 7.26 – Summary of our linear regression model
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.26 – 我们的线性回归模型总结
- en: Tip
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'Take a look at this article for some guidance on how to interpret the summary:
    [https://medium.com/swlh/interpreting-linear-regression-through-statsmodels-summary-4796d359035a](https://medium.com/swlh/interpreting-linear-regression-through-statsmodels-summary-4796d359035a).'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 查看这篇文章以获取如何解读总结的指导：[https://medium.com/swlh/interpreting-linear-regression-through-statsmodels-summary-4796d359035a](https://medium.com/swlh/interpreting-linear-regression-through-statsmodels-summary-4796d359035a)。
- en: 'The adjusted R2 makes this model look very good since it is near 1 (in [*Chapter
    9*](B16834_09_Final_SK_ePub.xhtml#_idTextAnchor188), *Getting Started with Machine
    Learning in Python*, we will discuss this metric further); however, we know that
    this is simply because stock data is highly autocorrelated, so let''s look at
    the residuals again:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 调整后的R²使得这个模型看起来非常好，因为它接近1（在[*第9章*](B16834_09_Final_SK_ePub.xhtml#_idTextAnchor188)，《Python机器学习入门》中，我们将进一步讨论这个指标）；然而，我们知道这只是因为股票数据高度自相关，所以让我们再次查看残差：
- en: '[PRE107]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'This model also suffers from heteroskedasticity:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模型也存在异方差性问题：
- en: '![Figure 7.27 – Evaluating the residuals of our linear regression model'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.27 – 评估我们线性回归模型的残差'
- en: '](img/Figure_7.27_B16834.jpg)'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.27_B16834.jpg)'
- en: Figure 7.27 – Evaluating the residuals of our linear regression model
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.27 – 评估我们线性回归模型的残差
- en: Let's now see whether the ARIMA model or the linear regression model performs
    better at forecasting Netflix stock's closing prices.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看ARIMA模型和线性回归模型在预测Netflix股票收盘价方面，哪一个表现更好。
- en: Comparing models
  id: totrans-470
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较模型
- en: 'In order to compare our models, we need to test their predictions on some new
    data. Let''s gather the daily closing price of Netflix stock for the first two
    weeks in January 2021 and use the prediction methods in the `StockModeler` class
    to visualize our model predictions versus reality:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 为了比较我们的模型，我们需要在一些新的数据上测试它们的预测。让我们收集2021年1月前两周Netflix股票的每日收盘价，并使用`StockModeler`类中的预测方法来可视化我们的模型预测与现实的对比：
- en: '[PRE108]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'The ARIMA model''s predictions look more in line with the pattern we would
    expect, but, given the unpredictable nature of the stock market, both models are
    far off from what actually happened in the first two weeks of January 2021:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: ARIMA模型的预测看起来更符合我们预期的模式，但鉴于股市的不可预测性，两个模型都远离了2021年1月前两周实际发生的情况：
- en: '![Figure 7.28 – Model predictions versus reality'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.28 – 模型预测与现实对比'
- en: '](img/Figure_7.28_B16834.jpg)'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.28_B16834.jpg)'
- en: Figure 7.28 – Model predictions versus reality
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.28 – 模型预测与现实对比
- en: As we can see, forecasting stock performance is not easy, even for a few days.
    There is a lot of data that is not being captured by these models, such as news
    stories, regulations, and changes in management, to name a few. No matter how
    well a model appears to fit, be weary of trusting predictions as these will be
    extrapolations, and there is a lot of randomness not being accounted for.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，预测股票表现并不容易，即使是短短几天的预测也很困难。有许多数据没有被这些模型捕捉到，比如新闻报道、法规以及管理层的变化等。无论模型看起来拟合得多好，都要小心相信这些预测，因为它们仅仅是外推，而且有很多随机性没有被考虑在内。
- en: 'To further illustrate this, take a look at the following set of plots that
    have been generated using random walks and stock data. Only one is real data,
    but which one? The answer follows the plots, so be sure to take a guess before
    looking:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步说明这一点，请看以下通过随机游走和股票数据生成的一组图表。只有一组是真实数据，但是哪一组呢？答案会在图表之后出现，所以在查看之前一定要猜一下：
- en: '![Figure 7.29 – Real or fake stock data?'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.29 – 真实还是伪造的股票数据？'
- en: '](img/Figure_7.29_B16834.jpg)'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.29_B16834.jpg)'
- en: Figure 7.29 – Real or fake stock data?
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.29 – 真实还是伪造的股票数据？
- en: Each of these time series originates at the same point (Microsoft's closing
    price on July 1, 2019), but only **A** is real stock data—**B**, **C**, and **D**
    are all random walks. Hard (or impossible) to tell, right?
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 这些时间序列都来源于同一个点（2019年7月1日微软的收盘价），但只有**A**是真实的股票数据——**B**、**C**和**D**都是随机游走。很难（或者不可能）分辨，对吧？
- en: Summary
  id: totrans-483
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we saw how building Python packages for our analysis applications
    can make it very easy for others to carry out their own analyses and reproduce
    ours, as well as for us to create repeatable workflows for future analyses.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们看到构建Python包来进行分析应用程序的开发，可以让其他人非常容易地进行他们自己的分析并复现我们的结果，同时也让我们为未来的分析创建可重复的工作流程。
- en: The `stock_analysis` package we created in this chapter contained classes for
    gathering stock data from the Internet (`StockReader`); visualizing individual
    assets or groups of them (`Visualizer` family); calculating metrics for single
    assets or groups of them for comparisons (`StockAnalyzer` and `AssetGroupAnalyzer`,
    respectively); and time series modeling with decomposition, ARIMA, and linear
    regression (`StockModeler`). We also got our first look at using the `statsmodels`
    package in the `StockModeler` class. This chapter showed us how the `pandas`,
    `matplotlib`, `seaborn`, and `numpy` functionality that we've covered so far in
    this book has come together and how these libraries can work harmoniously with
    other packages for custom applications. I strongly encourage you to reread the
    code in the `stock_analysis` package and test out some of the methods we didn't
    cover in this chapter to make sure you have the concepts down.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章创建的`stock_analysis`包包含了多个类，用于从互联网收集股票数据（`StockReader`）；可视化单个资产或它们的组合（`Visualizer`家族）；计算单个资产或它们组合的指标以进行比较（分别为`StockAnalyzer`和`AssetGroupAnalyzer`）；以及使用分解、ARIMA和线性回归进行时间序列建模（`StockModeler`）。我们还首次了解了如何在`StockModeler`类中使用`statsmodels`包。本章展示了我们迄今为止在本书中学习的`pandas`、`matplotlib`、`seaborn`和`numpy`功能如何结合在一起，以及这些库如何与其他包协同工作以实现自定义应用。我强烈建议你重新阅读`stock_analysis`包中的代码，并测试一些我们在本章中未涵盖的方法，以确保你掌握了相关概念。
- en: In the next chapter, we will work on another application as we learn how to
    build a simulator for login attempts and try our hand at rule-based anomaly detection.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将进行另一个应用案例，学习如何构建一个登录尝试的模拟器，并尝试基于规则的异常检测。
- en: Exercises
  id: totrans-487
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'Use the `stock_analysis` package to complete the following exercises. Unless
    otherwise noted, use data from 2019 through the end of 2020\. In case there are
    any issues collecting the data with the `StockReader` class, backup CSV files
    are provided in the `exercises/` directory:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`stock_analysis`包完成以下练习。除非另有说明，数据应使用2019年到2020年末的数据。如果使用`StockReader`类收集数据时遇到问题，可以在`exercises/`目录中找到备份的CSV文件：
- en: Using the `StockAnalyzer` and `StockVisualizer` classes, calculate and plot
    three levels of support and resistance for Netflix's closing price.
  id: totrans-489
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`StockAnalyzer`和`StockVisualizer`类，计算并绘制Netflix收盘价的三个支撑位和阻力位。
- en: 'With the `StockVisualizer` class, look at the effect of after-hours trading
    on the FAANG stocks:'
  id: totrans-490
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`StockVisualizer`类，查看盘后交易对FAANG股票的影响：
- en: a) As individual stocks
  id: totrans-491
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a) 作为单独的股票
- en: b) As a portfolio using the `make_portfolio()` function from the `stock_analysis.utils`
    module
  id: totrans-492
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b) 使用来自`stock_analysis.utils`模块的`make_portfolio()`函数作为组合
- en: Using the `StockVisualizer.open_to_close()` method, create a plot that fills
    the area between the FAANG stocks' opening price (as a portfolio) and its closing
    price each day in red if the price declined and in green if the price increased.
    As a bonus, do the same for a portfolio of bitcoin and the S&P 500.
  id: totrans-493
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`StockVisualizer.open_to_close()`方法，创建一个图表，显示FAANG股票每个交易日的开盘价和收盘价之间的区域：如果价格下降，用红色填充；如果价格上涨，用绿色填充。作为附加任务，对比特币和S&P
    500的组合也做同样的操作。
- en: Mutual funds and `AssetGroupAnalyzer` class.
  id: totrans-494
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 共同基金和`AssetGroupAnalyzer`类。
- en: Write a function that returns a dataframe of one row with columns for `alpha`,
    `beta`, `sharpe_ratio`, `annualized_volatility`, `is_bear_market`, and `is_bull_market`,
    which each contain the results of running the respective methods on a given stock
    using the `StockAnalyzer` class. Dictionary comprehensions and the `getattr()`
    function, as used in the `AssetGroupAnalyzer.analyze()` method, will be useful.
  id: totrans-495
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个函数，返回一个包含以下列的单行数据框：`alpha`、`beta`、`sharpe_ratio`、`annualized_volatility`、`is_bear_market`和`is_bull_market`，这些列分别包含通过`StockAnalyzer`类对给定股票运行相应方法的结果。在`AssetGroupAnalyzer.analyze()`方法中使用的字典推导式和`getattr()`函数将会很有用。
- en: With the `StockModeler` class, build an ARIMA model fit on the S&P 500 data
    from January 1, 2019 through November 30, 2020 and use it to predict the performance
    in December 2020\. Be sure to examine the residuals and compare the predicted
    performance to the actual performance.
  id: totrans-496
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`StockModeler`类，在2019年1月1日至2020年11月30日的S&P 500数据上构建ARIMA模型，并使用该模型预测2020年12月的表现。务必检查残差，并将预测表现与实际表现进行比较。
- en: 'Request an API key for AlphaVantage ([https://www.alphavantage.co/support/#api-key](https://www.alphavantage.co/support/#api-key))
    and collect the daily foreign exchange rate from USD to JPY using the `get_forex_rates()`
    method on the same `StockReader` object you created to collect the data for the
    previous exercises. Build a candlestick plot with the data from February 2019
    through January 2020, resampled to 1-week intervals. Hint: take a look at the
    `slice()` function from the standard library ([https://docs.python.org/3/library/functions.html#slice](https://docs.python.org/3/library/functions.html#slice))
    in order to provide the date range.'
  id: totrans-497
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请求 AlphaVantage 的 API 密钥 ([https://www.alphavantage.co/support/#api-key](https://www.alphavantage.co/support/#api-key))，并使用你之前为收集数据创建的
    `StockReader` 对象，通过 `get_forex_rates()` 方法收集从 USD 到 JPY 的每日外汇汇率。使用 2019 年 2 月到
    2020 年 1 月的数据，构建一个蜡烛图，并将数据重采样为每周一次。提示：查看标准库中的 `slice()` 函数（[https://docs.python.org/3/library/functions.html#slice](https://docs.python.org/3/library/functions.html#slice)），以提供日期范围。
- en: Further reading
  id: totrans-498
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入阅读
- en: 'Check out the following resources for more information on the material covered
    in this chapter:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下资源，以获取更多关于本章内容的信息：
- en: '*A guide to Python''s function decorators*: [https://www.thecodeship.com/patterns/guide-to-python-function-decorators/](https://www.thecodeship.com/patterns/guide-to-python-function-decorators/)'
  id: totrans-500
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Python 函数装饰器指南*: [https://www.thecodeship.com/patterns/guide-to-python-function-decorators/](https://www.thecodeship.com/patterns/guide-to-python-function-decorators/)'
- en: '*Alpha*: [https://www.investopedia.com/terms/a/alpha.asp](https://www.investopedia.com/terms/a/alpha.asp)'
  id: totrans-501
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Alpha*: [https://www.investopedia.com/terms/a/alpha.asp](https://www.investopedia.com/terms/a/alpha.asp)'
- en: '*An Introduction to Classes and Inheritance (in Python)*: [http://www.jesshamrick.com/2011/05/18/an-introduction-to-classes-and-inheritance-in-python/](http://www.jesshamrick.com/2011/05/18/an-introduction-to-classes-and-inheritance-in-python/)'
  id: totrans-502
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Python 中的类和继承入门*: [http://www.jesshamrick.com/2011/05/18/an-introduction-to-classes-and-inheritance-in-python/](http://www.jesshamrick.com/2011/05/18/an-introduction-to-classes-and-inheritance-in-python/)'
- en: '*Beta*: [https://www.investopedia.com/terms/b/beta.asp](https://www.investopedia.com/terms/b/beta.asp)'
  id: totrans-503
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Beta*: [https://www.investopedia.com/terms/b/beta.asp](https://www.investopedia.com/terms/b/beta.asp)'
- en: '*Coefficient of Variation (CV)*: [https://www.investopedia.com/terms/c/coefficientofvariation.asp](https://www.investopedia.com/terms/c/coefficientofvariation.asp)'
  id: totrans-504
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*变异系数（CV）*: [https://www.investopedia.com/terms/c/coefficientofvariation.asp](https://www.investopedia.com/terms/c/coefficientofvariation.asp)'
- en: '*Classes (Python Documentation)*: [https://docs.python.org/3/tutorial/classes.html](https://docs.python.org/3/tutorial/classes.html)'
  id: totrans-505
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*类（Python 文档）*: [https://docs.python.org/3/tutorial/classes.html](https://docs.python.org/3/tutorial/classes.html)'
- en: '*How After-Hours Trading Affects Stock Prices*: [https://www.investopedia.com/ask/answers/05/saleafterhours.asp](https://www.investopedia.com/ask/answers/05/saleafterhours.asp)'
  id: totrans-506
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*盘后交易如何影响股票价格*: [https://www.investopedia.com/ask/answers/05/saleafterhours.asp](https://www.investopedia.com/ask/answers/05/saleafterhours.asp)'
- en: '*How to Create a Python Package*: [https://www.pythoncentral.io/how-to-create-a-python-package/](https://www.pythoncentral.io/how-to-create-a-python-package/)'
  id: totrans-507
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*如何创建一个 Python 包*: [https://www.pythoncentral.io/how-to-create-a-python-package/](https://www.pythoncentral.io/how-to-create-a-python-package/)'
- en: '*How to Create an ARIMA Model for Time Series Forecasting in Python*: [https://machinelearningmastery.com/arima-for-time-series-forecasting-with-python/](https://machinelearningmastery.com/arima-for-time-series-forecasting-with-python/)'
  id: totrans-508
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*如何在 Python 中创建 ARIMA 模型进行时间序列预测*: [https://machinelearningmastery.com/arima-for-time-series-forecasting-with-python/](https://machinelearningmastery.com/arima-for-time-series-forecasting-with-python/)'
- en: '*Linear Regression in Python using statsmodels*: [https://datatofish.com/statsmodels-linear-regression/](https://datatofish.com/statsmodels-linear-regression/)'
  id: totrans-509
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 statsmodels 的线性回归（Python）*: [https://datatofish.com/statsmodels-linear-regression/](https://datatofish.com/statsmodels-linear-regression/)'
- en: '*Object-Oriented Programming*: [https://python.swaroopch.com/oop.html](https://python.swaroopch.com/oop.html)'
  id: totrans-510
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*面向对象编程*: [https://python.swaroopch.com/oop.html](https://python.swaroopch.com/oop.html)'
- en: '*Random walk*: [https://en.wikipedia.org/wiki/Random_walk](https://en.wikipedia.org/wiki/Random_walk)'
  id: totrans-511
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*随机游走*: [https://en.wikipedia.org/wiki/Random_walk](https://en.wikipedia.org/wiki/Random_walk)'
- en: '*Stock Analysis*: [https://www.investopedia.com/terms/s/stock-analysis.asp](https://www.investopedia.com/terms/s/stock-analysis.asp)'
  id: totrans-512
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*股票分析*: [https://www.investopedia.com/terms/s/stock-analysis.asp](https://www.investopedia.com/terms/s/stock-analysis.asp)'
- en: '*Support and Resistance Basics*: [https://www.investopedia.com/trading/support-and-resistance-basics/](https://www.investopedia.com/trading/support-and-resistance-basics/)'
  id: totrans-513
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*支撑和阻力基础知识*: [https://www.investopedia.com/trading/support-and-resistance-basics/](https://www.investopedia.com/trading/support-and-resistance-basics/)'
- en: '*Technical Analysis*: [https://www.investopedia.com/technical-analysis-4689657](https://www.investopedia.com/technical-analysis-4689657)'
  id: totrans-514
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*技术分析*: [https://www.investopedia.com/technical-analysis-4689657](https://www.investopedia.com/technical-analysis-4689657)'
- en: '*The definitive guide on how to use static, class or abstract methods in Python*:
    [https://julien.danjou.info/guide-python-static-class-abstract-methods/](https://julien.danjou.info/guide-python-static-class-abstract-methods/)'
  id: totrans-515
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*如何在 Python 中使用静态方法、类方法或抽象方法的权威指南*: [https://julien.danjou.info/guide-python-static-class-abstract-methods/](https://julien.danjou.info/guide-python-static-class-abstract-methods/)'
- en: '*Writing the Setup Script*: [https://docs.python.org/3/distutils/setupscript.html](https://docs.python.org/3/distutils/setupscript.html)'
  id: totrans-516
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*编写设置脚本*: [https://docs.python.org/3/distutils/setupscript.html](https://docs.python.org/3/distutils/setupscript.html)'
