- en: Unsupervised Learning in Anaconda
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Anaconda 中进行无监督学习
- en: 'Before discussing unsupervised learning, it might be a good idea to introduce
    supervised learning since most of us will be familiar with functions discussed
    in the previous chapters. For a function of *y=f(x)*, usually we have values for
    independent variables of *x[1]*, *x[2]*, ... *x[n]* and a set of corresponding
    values for a dependent variable of *y*. In previous chapters, we have discussed
    various types of functions, such as the single-factor linear model. Our task is
    to figure out the format of the function, given a set of input values. For supervised
    learning, we have two datasets: the **training data** and **test data**. For the
    training dataset, it has a set of input variables and related output values (also
    called a **supervisory signal**). A supervised learning algorithm analyzes the
    training data and produces an inferred function. Then, we apply this inferred
    function to map the given test dataset.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论无监督学习之前，可能最好先介绍一下监督学习，因为我们大多数人对前几章讨论的函数会比较熟悉。对于 *y=f(x)* 这样的函数，通常我们有独立变量
    *x[1]*，*x[2]*，... *x[n]* 的值以及与之对应的因变量 *y* 的一组值。在前几章中，我们讨论了多种类型的函数，例如单因子线性模型。我们的任务是根据一组输入值来确定函数的形式。对于监督学习，我们有两个数据集：**训练数据**和**测试数据**。对于训练数据集，它包含一组输入变量和相关的输出值（也称为**监督信号**）。监督学习算法分析训练数据并推导出一个推断函数。然后，我们将这个推断函数应用于给定的测试数据集。
- en: Unlike supervised learning, we don't have *y* for unsupervised learning. In
    other words, unsupervised learning is used to draw inferences from datasets consisting
    of input data without labelled responses. In a sense, for supervised learning,
    we have both *x* and *y*, while for unsupervised learning, we have *x* only. In
    other words, for one algorithm, we have both input and output, while for the other,
    we have inputs only. The most common unsupervised learning method is Cluster Analysis,
    which is used for exploratory data analysis to find hidden patterns or groupings
    in data.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 与监督学习不同，**无监督学习**中没有 *y*。换句话说，无监督学习用于从包含输入数据但没有标记响应的数据集中推断结论。从某种意义上讲，监督学习有 *x*
    和 *y*，而无监督学习只有 *x*。换句话说，对于一种算法，我们有输入和输出，而对于另一种算法，我们只有输入。最常见的无监督学习方法是聚类分析，通常用于探索性数据分析，以发现数据中的隐藏模式或分组。
- en: 'In this chapter, the following topics will be covered:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Introduction to unsupervised learning
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无监督学习简介
- en: Hierarchical clustering
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 层次聚类
- en: k-means clustering
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: k-均值聚类
- en: 'Introduction to Python packages: `scipy`, `contrastive`, and `sklearn` (scikit-learn)'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 包介绍：`scipy`，`contrastive` 和 `sklearn`（scikit-learn）
- en: 'Introduction to R packages: `rattle`, `randomUniformForest`, and `Rmixmod`'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: R 包介绍：`rattle`，`randomUniformForest` 和 `Rmixmod`
- en: Implementation using Julia
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Julia 实现
- en: Task view for Cluster Analysis
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 聚类分析的任务视图
- en: Introduction to unsupervised learning
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无监督学习简介
- en: 'For unsupervised learning, we try to reorganize data or classify it into different
    groups based on certain traits or characteristics. For this purpose, we can use
    certain rules to categorize our dataset. For example, we could classify them into
    different groups based on investors'' characteristics, such as age, education
    level, background, job types, living city, profession, salary level, and house
    ownership. For instance, they could be classified into four types of investors:
    aggressive, risk averse, risk neutral, and extremely risk averse. After that,
    financial institutions could design and market specific financial products targeting
    different groups.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 对于无监督学习，我们尝试根据某些特征或属性重新组织数据或将其分类为不同的组。为此，我们可以使用一些规则来对数据集进行分类。例如，我们可以根据投资者的特征，如年龄、教育水平、背景、工作类型、居住城市、职业、薪资水平和房屋所有权，将他们划分为不同的组。例如，他们可以被划分为四种类型的投资者：激进型、厌恶风险型、中性型和极度厌恶风险型。之后，金融机构可以根据不同群体的需求，设计并营销特定的金融产品。
- en: To plan an equitable income tax policy, governments could classify potential
    taxpayers based on various criteria, such as income level and whether a person
    has a certain disability. Then, they could design distinct tax plans to target
    various groups with varying social welfare status. Such a tax policy could be
    more equitable than a simple progressive tax scheme.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了制定一个公平的所得税政策，政府可以根据不同的标准（例如收入水平和是否有某些残疾）对潜在纳税人进行分类。然后，他们可以设计不同的税务计划，针对不同社会福利状态的群体。这种税收政策可能比简单的累进税制更为公平。
- en: Another example is that investors could have over 5,000 stocks available to
    buy. It might be a good idea to group them according to various benchmarks, such
    as riskiness, profitability, familiarity, reputation, local/national/international,
    social responsibility, and transaction cost. After that, financial institutions
    could form different mutual funds which could be sold to different investors.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是，投资者可以购买超过 5000 支股票。一个好主意是根据各种基准将它们分组，例如风险性、盈利性、熟悉度、声誉、地域性/国家性/国际性、社会责任和交易成本。之后，金融机构可以形成不同的共同基金，并将其销售给不同的投资者。
- en: 'The following diagram is used to summarize the idea: grouping data according
    to certain criteria. The data is drawn from two normal distributions with the
    same standard deviation, but with different means. Later in the chapter, we will
    show the related code:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示用于总结这一思想：根据某些标准对数据进行分组。数据来自两个具有相同标准差、但均值不同的正态分布。我们将在本章后面展示相关代码：
- en: '![](img/b4187cf8-03f4-4341-ad53-3f97dded5985.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b4187cf8-03f4-4341-ad53-3f97dded5985.png)'
- en: 'The logic for clustering or grouping is that the distance between group members
    is less than that between groups. In other words, the similarity among members
    within each group is higher than that between groups. For instance, if we have
    ZIP codes of many houses, we could estimate the distance between each pair of
    houses and classify them into different communities. For numerical values, such
    as *(x[1],y[1]), (x[2],y[2]),* the difference could be defined by the following
    formula:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 聚类或分组的逻辑是，同一组内成员之间的距离小于组与组之间的距离。换句话说，每组内部成员的相似度高于组与组之间的相似度。例如，如果我们有许多房屋的邮政编码，我们可以估算每对房屋之间的距离，并将它们划分为不同的社区。对于数值型数据，比如
    *(x[1],y[1]), (x[2],y[2])*，它们之间的差异可以通过以下公式定义：
- en: '![](img/3b10edad-8c57-48b6-b27c-c359b6bec3e9.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3b10edad-8c57-48b6-b27c-c359b6bec3e9.png)'
- en: 'The following code generates a graph that shows the distance between two points.
    This is also called Euclidean distance:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码生成一个图形，显示两个点之间的距离，这也叫做欧几里得距离：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the previous code, `method="euclidean"` could be omitted since it is the
    default setting. The distance is `2.236` and the graph is ignored for brevity.
    The potential phrases for the method variable are `euclidean`, *maximum,* *manhattan,* *canberra,
    binary*, and *minkowski.* The general form is called the Minkowski distance, as
    shown here:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中，`method="euclidean"` 可以省略，因为它是默认设置。距离为 `2.236`，图形为简洁起见被忽略。方法变量的潜在值包括
    `euclidean`、*maximum*、*manhattan*、*canberra*、binary 和 *minkowski*。一般形式称为 Minkowski
    距离，如下所示：
- en: '![](img/f61bc53c-d682-49d6-8419-fa2105049b87.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f61bc53c-d682-49d6-8419-fa2105049b87.png)'
- en: 'Obviously, when *n* takes a value of `2`, Equation (2) is the same as Equation
    (1). On the other hand, when *p = 1*, this is equivalent to the Manhattan distance,
    as shown in the following:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，当 *n* 取 `2` 的值时，公式（2）与公式（1）相同。另一方面，当 *p = 1* 时，这就等同于曼哈顿距离，如下所示：
- en: '![](img/0c343a8b-dca2-439e-a8da-f0b2f48923e8.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0c343a8b-dca2-439e-a8da-f0b2f48923e8.png)'
- en: 'When *x* and *y* differ in terms of sizes, we could scale them by using the
    following formulae:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当 *x* 和 *y* 在大小上有所不同时，我们可以使用以下公式对其进行缩放：
- en: '![](img/f63d00d9-12c2-4936-a943-da2fa2912e76.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f63d00d9-12c2-4936-a943-da2fa2912e76.png)'
- en: 'The previous scaling method is based on the assumption that *x* and *y* are
    independent, where ![](img/9dd0a259-0c4d-42a4-ba5d-d3053294379a.png) (![](img/d7e8ba0b-c561-48da-94cb-a8ce3b7cc2d5.png))
    is the new data point for *x (y)*, *![](img/c435e423-edbb-4d77-8d07-2ae9739095ee.png) (![](img/f052afff-8055-4c10-bf01-ffd5be193128.png))*
    is the mean for *x (y)*, and *![](img/fd28ba58-bedd-4525-b74d-0f5d66adca14.png)(![](img/267ec792-db42-4961-a745-3f2f711035bc.png))*
    is the standard deviation of *x(y)*. If researchers put more weight on the direction
    of the data rather than the magnitude, then the cosine distance could be used.
    The cosine of two non-zero vectors can be derived by using the Euclidean dot product
    formula:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的缩放方法基于*x*和*y*是独立的假设，其中 ![](img/9dd0a259-0c4d-42a4-ba5d-d3053294379a.png) (![](img/d7e8ba0b-c561-48da-94cb-a8ce3b7cc2d5.png))
    是新数据点 *x (y)*， *![](img/c435e423-edbb-4d77-8d07-2ae9739095ee.png) (![](img/f052afff-8055-4c10-bf01-ffd5be193128.png))*
    是 *x (y)* 的均值，*![](img/fd28ba58-bedd-4525-b74d-0f5d66adca14.png)(![](img/267ec792-db42-4961-a745-3f2f711035bc.png))*
    是 *x(y)* 的标准差。如果研究人员更看重数据的方向而不是大小，那么可以使用余弦距离。两个非零向量的余弦可以通过欧几里得点积公式推导出来：
- en: '![](img/d3dc554e-a590-4c82-9854-0b85304a67f7.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d3dc554e-a590-4c82-9854-0b85304a67f7.png)'
- en: 'where *θ* is the angle between those two vectors. Also, we could view *cos(θ)*
    as a scaling factor, shown here:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *θ* 是这两个向量之间的角度。此外，我们可以将 *cos(θ)* 看作是一个缩放因子，如下所示：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Obviously, when the *x* and *y* vector has the exact same direction, *cos(θ)*
    has the highest value of 1\. When they have opposite directions, *cos(θ)* has
    a negative value.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，当 *x* 和 *y* 向量完全相同方向时，*cos(θ)* 的值为 1。当它们的方向相反时，*cos(θ)* 会变为负值。
- en: 'Given two vectors A and B, the cosine similarity, *cos(θ)*, is represented
    using a dot product and magnitude in the following:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 给定两个向量 A 和 B，余弦相似度 *cos(θ)* 可通过点积和大小表示，如下所示：
- en: '![](img/fdd66593-f9f3-462b-9208-28839851f4f1.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fdd66593-f9f3-462b-9208-28839851f4f1.png)'
- en: 'For categorical data points, they could not be ranked because of non-numeric
    values. For these cases, we can calculate the following similarity index:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 对于类别数据点，由于没有数值化，因此无法进行排序。对于这种情况，我们可以计算以下相似性指数：
- en: '![](img/188cf78b-353d-4ba4-b053-cf148e7599c7.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/188cf78b-353d-4ba4-b053-cf148e7599c7.png)'
- en: 'Where *n[matched]* is the number of matched treats and *n[total]* is the number
    of total treats. When we have both categorical and numeric data, we can estimate
    both types of distances first when choosing a weighted final value:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *n[matched]* 是匹配的特征数量，*n[total]* 是特征的总数。当我们同时拥有类别数据和数值数据时，我们可以在选择加权最终值时，先估算两种类型的距离：
- en: '![](img/793aebfe-458d-417d-a729-797743f6ba10.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/793aebfe-458d-417d-a729-797743f6ba10.png)'
- en: 'Assuming *d[num]* is the distance based on the numerical data and *d[cat]*
    is the distance based on the categorical data, we have the following equivalent:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 *d[num]* 是基于数值数据的距离，而 *d[cat]* 是基于类别数据的距离，我们可以得到以下等式：
- en: '![](img/97b9fe03-c9ef-4c8a-bc93-3a0cef53b2a5.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/97b9fe03-c9ef-4c8a-bc93-3a0cef53b2a5.png)'
- en: where *w[num]* is the weight of the numerical value.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *w[num]* 是数值的权重。
- en: 'Assume that we have two sets of data, *X* and *Y*. For the *X* set, we have
    *x[1]*, *x[2]*, ..., *x[n]*, while for the *Y* set, we have *y[1]*, *y[2]*, ...,
    and *y[m]*. In other words, for *X*, there are *n* observations, while for *Y*,
    there are *m* observations. For a pair of clusters, we have several ways to define
    their linkages (see the following table):'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有两组数据，*X* 和 *Y*。对于 *X* 集合，我们有 *x[1]*, *x[2]*, ..., *x[n]*，而对于 *Y* 集合，我们有
    *y[1]*, *y[2]*, ..., *y[m]*。换句话说，对于 *X*，有 *n* 个观测值，而对于 *Y*，有 *m* 个观测值。对于一对簇，我们有几种方式定义它们的连接方式（请参见下表）：
- en: '| **Linkage** | **Math formula** | **Description** |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| **连接方式** | **数学公式** | **描述** |'
- en: '| Single | ![](img/8697c477-f14c-4853-828a-2e22494f5788.png) | Shortest distance
    between the closest members of the two clusters |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| 单连接 | ![](img/8697c477-f14c-4853-828a-2e22494f5788.png) | 两个簇中最接近成员之间的最短距离
    |'
- en: '| Complete | ![](img/f3330f9d-1a50-4304-b9aa-1c5bd30acccd.png) | Longest distance
    between the members that are farthest apart (most dissimilar) |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 完全连接 | ![](img/f3330f9d-1a50-4304-b9aa-1c5bd30acccd.png) | 最远离的成员之间的最长距离（最不相似）
    |'
- en: '| Average | ![](img/5276dbe0-2eb7-45e3-aa7a-91807909229f.png) | Step 1: Get
    distances between all pairsStep 2: Calculate the average |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| 平均连接 | ![](img/5276dbe0-2eb7-45e3-aa7a-91807909229f.png) | 第一步：计算所有对之间的距离；第二步：计算平均值
    |'
- en: '| Centroid Method | ![](img/d4109ed8-9024-4a5b-9881-dca7811cb3bd.png) | Step
    1: Find the mean vector locationsStep 2: Get the distance between the two locations
    |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 重心法 | ![](img/d4109ed8-9024-4a5b-9881-dca7811cb3bd.png) | 第一步：找到均值向量的位置；第二步：计算这两个位置之间的距离
    |'
- en: Table 8.1 Four types of linkages between two clusters
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 表 8.1 两个簇之间的四种连接方式
- en: 'Let''s use some hypothetical values to see how to get those linkages. To make
    our estimate easier to understand, we have just five values (see the following
    code):'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用一些假设的值来看看如何获取这些连接。为了让我们的估算更容易理解，我们仅使用了五个值（请参见下面的代码）：
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Refer to the following output:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 请参见以下输出：
- en: '![](img/e5944b5d-2969-4c19-86dc-5cb6a77fcf73.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e5944b5d-2969-4c19-86dc-5cb6a77fcf73.png)'
- en: 'For the centers of these two clusters, we could guess that the first one should
    be about (65,140), while the second one should be around (170, 40) (see the following
    output code):'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这两个簇的中心，我们可以推测第一个簇的中心大约在 (65,140)，第二个簇的中心大约在 (170, 40)（请参见下面的输出代码）：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Hierarchical clustering
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 层次聚类
- en: In hierarchical clustering, the two most similar clusters are combined and continue
    to combine until all objects are in the same cluster. Hierarchical clustering
    produces a tree called a **dendrogram** that shows the hierarchy of the clusters.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在层次聚类中，最相似的两个簇会被合并，并继续合并，直到所有对象都在同一个簇中。层次聚类生成一个叫做**树状图**的树形图，展示了簇的层次结构。
- en: 'To show this concept, let''s start by looking at the dataset called `animals`
    embedded in the R package called `cluster`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示这个概念，首先让我们看看 R 包 `cluster` 中的名为 `animals` 的数据集：
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In total, we have 20 observations with 6 characteristics: `war`, `fly`, `ver`,
    `end`, `gro`, and `hai`, illustrated by their column names. The following table
    shows their definitions:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 总共，我们有 20 个观察值，包含 6 个特征：`war`、`fly`、`ver`、`end`、`gro` 和 `hai`，由它们的列名表示。以下表格展示了它们的定义：
- en: '| **#** | **Name** | **Description** |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| **#** | **名称** | **描述** |'
- en: '| 1 | `war` | warm-blooded |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| 1 | `war` | 温血动物 |'
- en: '| 2 | `fly` | can fly |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| 2 | `fly` | 能飞 |'
- en: '| 3 | `ver` | vertebrate |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| 3 | `ver` | 脊椎动物 |'
- en: '| 4 | `end` | endangered |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| 4 | `end` | 濒危 |'
- en: '| 5 | `gro` | live in groups |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| 5 | `gro` | 群居 |'
- en: '| 6 | `hai` | have hair |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| 6 | `hai` | 有毛发 |'
- en: Table 8.2 Definitions of column names for animals
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 表 8.2 动物列名的定义
- en: 'Again, we have 20 observations with 6 characters to describe each of them:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们有 20 个观察值，每个观察值由 6 个特征描述：
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `mona()` function is **MONothetic Analysis Clustering of Binary Variables**,
    and returns a list representing a divisive hierarchical clustering of a dataset
    with only binary variables. The related output is shown here:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`mona()` 函数是 **单一分析的二进制变量聚类**，返回一个列表，表示仅包含二进制变量的数据集的分裂层次聚类。相关输出如下：'
- en: '![](img/0b8abf3f-6597-4204-bf00-40285101ff6f.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0b8abf3f-6597-4204-bf00-40285101ff6f.png)'
- en: 'From the previous output, we can see that there are five groups. For example,
    the first observation called `ant` belongs to group 4\. Its vector is `[0, 0,
    0, 0,1,0]`. On the other hand, for the second observation called `bee`, it does
    not belong to any of those five groups (that is, its group is zero). Its six-value
    binary vector is `[0,1,0,0,1,1]`. To visually present the outcome, we have the
    following code:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 从之前的输出中可以看出，共有五个组。例如，第一个叫做 `ant` 的观察值属于第 4 组。它的向量是 `[0, 0, 0, 0, 1, 0]`。另一方面，第二个叫做
    `bee` 的观察值不属于任何一个组（也就是说，它的组是零）。它的六值二进制向量是 `[0, 1, 0, 0, 1, 1]`。为了直观地展示结果，我们有以下代码：
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The output is shown in the following screenshot:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如下截图所示：
- en: '![](img/8b03d7f2-c031-4386-8464-9e5dc3986394.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8b03d7f2-c031-4386-8464-9e5dc3986394.png)'
- en: 'From the previous graph, it can be seen that the first observation belongs
    to group 4, while the second one does not belong to any of those five groups.
    To draw a dendrogram for the dataset called `animals`, we have the following code:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 从之前的图可以看出，第一个观察值属于第 4 组，而第二个观察值不属于任何一个组。为了绘制名为 `animals` 数据集的树状图，我们有以下代码：
- en: '[PRE7]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Refer to the following graph:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考下图：
- en: '![](img/97a7f5cd-723f-476c-b916-4611a44e919f.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/97a7f5cd-723f-476c-b916-4611a44e919f.png)'
- en: 'For the next example, we generate two sets of random numbers drawn from a normal
    distribution with different means, `0` and `80`, with the same standard deviation
    of `8`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 对于下一个示例，我们生成两组来自正态分布的随机数，均值分别为`0`和`80`，标准差相同为`8`：
- en: '[PRE8]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The output graph is shown in the following diagram. From it, we can see that
    those random values belong to two distinct groups:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 输出图如下面的图所示。从中可以看出，这些随机值属于两个不同的组：
- en: '![](img/69b490fb-8dcb-46b3-9202-c6029484f852.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](img/69b490fb-8dcb-46b3-9202-c6029484f852.png)'
- en: 'Also note that the  `clara()` function from the program has the following structure:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 还请注意，程序中的 `clara()` 函数具有以下结构：
- en: '[PRE9]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: k-means clustering
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: k-means 聚类
- en: The purpose of k-means clustering is to partition *n* observations into *k*
    clusters, where each observation belongs to the cluster with the nearest mean.
    This results in a partitioning of the data space into a **Voronoi diagram**. In
    mathematics, a Voronoi diagram is a partitioning of a plane into regions based
    on the distance to points in a specific subset of the plane.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: k-means 聚类的目的是将 *n* 个观察值划分为 *k* 个聚类，其中每个观察值属于最近均值的聚类。这导致数据空间被划分为 **Voronoi 图**。在数学中，Voronoi
    图是将平面划分为区域，基于与平面中特定子集点的距离。
- en: 'Borrowed from Priyadarsini ([https://www.kaggle.com/maitree/kmeans-unsupervised-learning-using-wine-dataset/data](https://www.kaggle.com/maitree/kmeans-unsupervised-learning-using-wine-dataset/data)),
    the slightly modified code is given here:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 引自 Priyadarsini ([https://www.kaggle.com/maitree/kmeans-unsupervised-learning-using-wine-dataset/data](https://www.kaggle.com/maitree/kmeans-unsupervised-learning-using-wine-dataset/data))，略微修改的代码如下：
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The output is shown here:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '![](img/d25be667-5e59-440c-88b7-dc5f4d1569f9.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d25be667-5e59-440c-88b7-dc5f4d1569f9.png)'
- en: This square matrix shows the similarity between each combination of treatments.
    Blue values are all positive, representing similarity, while red values are negative,
    representing dissimilarity.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方阵展示了每种治疗组合之间的相似度。蓝色值表示相似，所有值为正，而红色值表示不相似，为负值。
- en: Introduction to Python packages – scipy
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python包介绍 – scipy
- en: 'The submodule from the `scipy` package is called `scipy.cluster`. With the
    following code, we can find all embedded functions. The document for this submodule
    is available here at [https://docs.scipy.org/doc/scipy/reference/cluster.hierarchy.html](https://docs.scipy.org/doc/scipy/reference/cluster.hierarchy.html):'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 来自`scipy`包的子模块叫做`scipy.cluster`。通过以下代码，我们可以找到所有内嵌的函数。这个子模块的文档可以在这里找到：[https://docs.scipy.org/doc/scipy/reference/cluster.hierarchy.html](https://docs.scipy.org/doc/scipy/reference/cluster.hierarchy.html)：
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The next screenshot shows the related output:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 下一张截图展示了相关的输出：
- en: '![](img/07935c9d-d3d2-4b69-9d2a-2ff805549fd1.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](img/07935c9d-d3d2-4b69-9d2a-2ff805549fd1.png)'
- en: 'First, we use the `scipy.cluster._hierarchy` function. This example is borrowed
    as well ([https://stackoverflow.com/questions/21638130/tutorial-for-scipy-cluster-hierarchy](https://stackoverflow.com/questions/21638130/tutorial-for-scipy-cluster-hierarchy)).
    The code is shown here:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用`scipy.cluster._hierarchy`函数。这个例子也来自于（[https://stackoverflow.com/questions/21638130/tutorial-for-scipy-cluster-hierarchy](https://stackoverflow.com/questions/21638130/tutorial-for-scipy-cluster-hierarchy)）。代码如下所示：
- en: '[PRE12]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The related graphs are shown here:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 相关图表如下所示：
- en: '![](img/9f2ad3cf-df57-4201-9eb1-c31a6222d1fd.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9f2ad3cf-df57-4201-9eb1-c31a6222d1fd.png)'
- en: The methods used are single and complete in terms of estimating the distance
    between two points. The top middle graph shows the clustering with two groups,
    while the top right one shows the clustering for five groups.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 使用的方法是单一的和完整的，用于估算两个点之间的距离。顶部中间的图表展示了两个组的聚类，而顶部右侧的图表展示了五组的聚类。
- en: Introduction to Python packages – contrastive
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python包介绍 – 对比
- en: 'To install the Python package called `contrastive`, we issue the following
    command after launching the Anaconda prompt:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装名为`contrastive`的Python包，我们在启动Anaconda提示符后输入以下命令：
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The following screenshot shows the top part of the installation:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了安装的顶部部分：
- en: '![](img/9e28a64d-0e6b-4b2c-a4c6-45d85f13561c.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9e28a64d-0e6b-4b2c-a4c6-45d85f13561c.png)'
- en: 'Using the `dir()` and `print()` functions, we could find more information about
    a function embedded in the Python package:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`dir()`和`print()`函数，我们可以找到更多关于Python包中函数的信息：
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The output is shown here:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '![](img/31d9c78d-cc2d-4f0c-bc13-3f0164441a45.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](img/31d9c78d-cc2d-4f0c-bc13-3f0164441a45.png)'
- en: Introduction to Python packages – sklearn (scikit-learn)
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python包介绍 – sklearn（scikit-learn）
- en: 'First, let''s look at the functions contained in the Python package called
    `sklearn`. The code has just three lines:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看一下名为`sklearn`的Python包中的函数。代码只有三行：
- en: '[PRE15]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The related output is shown here:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 相关输出如下所示：
- en: '![](img/ee25739c-0211-4257-89ed-1b4dbaf9dad6.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ee25739c-0211-4257-89ed-1b4dbaf9dad6.png)'
- en: 'For one specific submodule, it is called `sklearn.cluster`, as shown:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个特定的子模块，它叫做`sklearn.cluster`，如图所示：
- en: '[PRE16]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The output is shown here:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '![](img/e9ceacea-0503-459c-9ee5-8d8f72436b0e.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e9ceacea-0503-459c-9ee5-8d8f72436b0e.png)'
- en: 'In addition, we can show many embedded datasets by using the following three
    lines of Python code:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以使用以下三行Python代码展示许多内嵌数据集：
- en: '[PRE17]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The output is shown here:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '![](img/e85dd7e0-2720-41f0-a4df-bc9c9f8d09b6.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e85dd7e0-2720-41f0-a4df-bc9c9f8d09b6.png)'
- en: 'For example, if we want to use a dataset called `iris`, we can apply the `load_iris()`
    function, as shown:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想使用一个名为`iris`的数据集，可以调用`load_iris()`函数，如下所示：
- en: '[PRE18]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The first few lines are shown here:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示了前几行：
- en: '![](img/78d793f6-bbc2-4122-ba7e-561f86b2151c.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](img/78d793f6-bbc2-4122-ba7e-561f86b2151c.png)'
- en: 'The following code is one example of using the module:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是使用该模块的一个示例：
- en: '[PRE19]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The last line of the previous code shows the potential groups they belong to.
    The next example is by *Michel, Gramfort and Varoquaux* (2010), [http://scikit-learn.org/stable/auto_examples/cluster/plot_ward_structured_vs_unstructured.html#sphx-glr-auto-examples-cluster-plot-ward-structured-vs-unstructured-py](http://scikit-learn.org/stable/auto_examples/cluster/plot_ward_structured_vs_unstructured.html#sphx-glr-auto-examples-cluster-plot-ward-structured-vs-unstructured-py).
    The output is shown in the following screenshot:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码的最后一行显示了它们可能属于的分组。下一个示例来自*Michel, Gramfort 和 Varoquaux*（2010），[http://scikit-learn.org/stable/auto_examples/cluster/plot_ward_structured_vs_unstructured.html#sphx-glr-auto-examples-cluster-plot-ward-structured-vs-unstructured-py](http://scikit-learn.org/stable/auto_examples/cluster/plot_ward_structured_vs_unstructured.html#sphx-glr-auto-examples-cluster-plot-ward-structured-vs-unstructured-py)。输出如下所示：
- en: '![](img/749edf45-95c9-4f24-b49a-45c034ac5492.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/749edf45-95c9-4f24-b49a-45c034ac5492.png)'
- en: 'From the previous graphs, we visually view groups by their colors. For example,
    the left graph shows us there are six groups. The next example is about Agglomerative
    Clustering on a 2D embedding of digits. Since the program is too long, we would
    not include it here. You can find the program at [http://scikit-learn.org/stable/auto_examples/cluster/plot_digits_linkage.html#sphx-glr-auto-examples-cluster-plot-digits-linkage-py](http://scikit-learn.org/stable/auto_examples/cluster/plot_digits_linkage.html#sphx-glr-auto-examples-cluster-plot-digits-linkage-py).
    The related graph output is shown in the following screenshot. The graph shows
    several groups based on a few different definitions of distance (linkage):'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 从之前的图表中，我们可以通过颜色直观地查看分组。例如，左侧的图表显示我们有六个组。下一个示例是关于在数字的2D嵌入上进行的聚合聚类。由于程序太长，我们不会在这里包括它。你可以在[http://scikit-learn.org/stable/auto_examples/cluster/plot_digits_linkage.html#sphx-glr-auto-examples-cluster-plot-digits-linkage-py](http://scikit-learn.org/stable/auto_examples/cluster/plot_digits_linkage.html#sphx-glr-auto-examples-cluster-plot-digits-linkage-py)找到该程序。相关的图形输出如下所示。该图显示了基于几种不同的距离定义（链接）分组的情况：
- en: '![](img/82def4b1-5195-49ee-9f01-9fc1953a61e2.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](img/82def4b1-5195-49ee-9f01-9fc1953a61e2.png)'
- en: 'Based on the definitions of distance of **ward**, **average**, or **complete**,
    we have three ways to generate clusters. For each method, various colors represent
    different clusters. The last example is looking at the `iris` dataset, which is
    associated with **Principal Component Analysis** (**PCA**). PCA uses an orthogonal
    transformation to convert a set of observations of possibly correlated variables
    into a set of values of linearly uncorrelated variables called **principal components** ([http://scikit-learn.org/stable/auto_examples/decomposition/plot_pca_iris.html](http://scikit-learn.org/stable/auto_examples/decomposition/plot_pca_iris.html))[.](http://scikit-learn.org/stable/auto_examples/decomposition/plot_pca_iris.html)
    The related 3D picture is shown here. The graph shows the groups for these three
    types:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 基于**ward**、**average**或**complete**的距离定义，我们有三种方法来生成聚类。对于每种方法，不同的颜色表示不同的聚类。最后一个示例是查看`iris`数据集，该数据集与**主成分分析**（**PCA**）相关。PCA使用正交变换将可能相关的变量的一组观察值转换为一组线性不相关的变量，称为**主成分**（[http://scikit-learn.org/stable/auto_examples/decomposition/plot_pca_iris.html](http://scikit-learn.org/stable/auto_examples/decomposition/plot_pca_iris.html)）。相关的3D图像如下所示。该图显示了这三种类型的分组：
- en: '![](img/83b77261-d427-415f-a5fa-3c8e72f649db.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](img/83b77261-d427-415f-a5fa-3c8e72f649db.png)'
- en: One useful link is [http://scikit-learn.org/stable/modules/clustering.html](http://scikit-learn.org/stable/modules/clustering.html).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有用的链接是[http://scikit-learn.org/stable/modules/clustering.html](http://scikit-learn.org/stable/modules/clustering.html)。
- en: Introduction to R packages – rattle
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: R包简介 – rattle
- en: 'Before discussing one or two examples of using `rattle`, it might be a good
    idea to discuss an R package called `rattle.data`. As its name suggests, we could
    guess that it contains data used by `rattle`. It is a good idea to use a small
    dataset to generate a dendrogram. For the next case, we use the first `20` observations
    from a dataset called `wine`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论使用`rattle`的一个或两个示例之前，最好先介绍一个名为`rattle.data`的R包。顾名思义，我们可以猜测它包含了`rattle`使用的数据。使用一个小的数据集生成树状图是个不错的主意。对于下一个案例，我们使用一个名为`wine`的数据集中的前`20`个观察值：
- en: '[PRE20]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To launch `rattle`, we have the following two lines:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动`rattle`，我们需要以下两行：
- en: '[PRE21]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'For data, we choose R Dataset, then choose `x`, as shown in the following screenshot.
    To save space, only the top part is presented here:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数据，我们选择R数据集，然后选择`x`，如下面的截图所示。为了节省空间，这里只展示了上部分内容：
- en: '![](img/ede71328-7e7c-42df-9206-5cd13e04c788.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ede71328-7e7c-42df-9206-5cd13e04c788.png)'
- en: 'The following screenshot shows our choice:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了我们的选择：
- en: '![](img/17d38ba4-ee8c-4f14-95ae-cf360dc70211.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](img/17d38ba4-ee8c-4f14-95ae-cf360dc70211.png)'
- en: 'From the previous screenshot, we see 14 observations. Click Clusters, with
    a default of `10` clusters, and Dendrogram. See the result in the following screenshot:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的截图中，我们看到有14个观测值。点击Clusters，默认为`10`个集群，以及树状图。请参见以下截图中的结果：
- en: '![](img/b713d931-ff37-4e00-babf-cef265c52817.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b713d931-ff37-4e00-babf-cef265c52817.png)'
- en: The previous dendrogram is a tree diagram that is used to show the relationship
    for a clustering analysis. Based on the definition of distance or relationship,
    we have a link between the closed associated one pair. Then, we move one step
    up to link this pair with another adjacent point or observation. The procedure
    continues until we reach the final step of just one group.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的树状图是用于显示聚类分析关系的树形图。根据距离或关系的定义，我们将闭合相关的一对连接起来。然后，我们向上一层，将这对连接到另一个相邻的点或观测值。这个过程继续进行，直到我们到达最终的步骤，即只有一个组。
- en: Introduction to R packages – randomUniformForest
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: R包简介 – randomUniformForest
- en: 'The R package, `randomUniformForest` is for classification, regression, and
    unsupervised learning. The basic block for a random forest is the decision tree
    model. To make our classification, researchers add some random effect. Because
    of this, the random forest method performs better than the decision tree model.
    We can use the following code to install, load, and get help about this specific
    R package:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: R包`randomUniformForest`用于分类、回归和无监督学习。随机森林的基本模块是决策树模型。为了改进我们的分类，研究人员添加了一些随机效应。正因为如此，随机森林方法比决策树模型表现得更好。我们可以使用以下代码来安装、加载并获取有关该R包的帮助：
- en: '[PRE22]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'First, let''s look at a relatively simple program that tries to classify different
    plants into four groups by using the random forest method:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们来看一个相对简单的程序，它通过使用随机森林方法将不同的植物分为四组：
- en: '[PRE23]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'It is obvious that the function name of `unsupervised.randomUniformForest`
    is quite long. To make our program more readable, we generate a short name called
    `shortName` instead. The related output is shown in the following screenshot,
    where it illustrates four groups by color:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，`unsupervised.randomUniformForest`的函数名非常长。为了使我们的程序更具可读性，我们生成了一个名为`shortName`的简短名称。相关输出如下截图所示，展示了按颜色划分的四个组：
- en: '![](img/fa4f83d4-327a-4bb3-81c9-026a929f7e18.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fa4f83d4-327a-4bb3-81c9-026a929f7e18.png)'
- en: 'The second example presents several groups based on the wine quality, such
    as alcohol concentration, color, and dilution:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个示例展示了根据酒的质量（如酒精浓度、颜色和稀释度）划分的几个组：
- en: '[PRE24]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The graph is shown here:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示了图表：
- en: '![](img/09a517ab-ae5d-4c5a-9842-8628aa80eec5.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](img/09a517ab-ae5d-4c5a-9842-8628aa80eec5.png)'
- en: Introduction to R packages – Rmixmod
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: R包简介 – Rmixmod
- en: 'This R package is for supervised, unsupervised, and semi-supervised classification
    with **MIXture MODelling** (interface of MIXMOD software). First, let''s look
    at a dataset called `birds`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这个R包用于监督学习、无监督学习和半监督学习的分类，**MIXture MODelling**（MIXMOD软件接口）。首先，我们来看一个名为`birds`的数据集：
- en: '[PRE25]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'From the previous output, we know that there are `69` observations with `5` characteristics.
    The following example code is designed to plot bars based on eyebrow and collar:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的输出中，我们知道有`69`个观测值，具有`5`个特征。以下示例代码旨在基于眉毛和衣领绘制条形图：
- en: '[PRE26]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The graphs are shown here:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这些图表显示如下：
- en: '![](img/a2327af5-5f00-40f4-ba15-e1f8b139cda2.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a2327af5-5f00-40f4-ba15-e1f8b139cda2.png)'
- en: Implementation using Julia
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Julia实现
- en: 'For Julia, we use the package called `Clustering`. The next example is borrowed
    from *Lin, Regier, and Arslan* (2016) with a minor modification ([https://github.com/JuliaStats/Clustering.jl/blob/master/test/affprop.jl](https://github.com/JuliaStats/Clustering.jl/blob/master/test/affprop.jl)).
    First, we generate a set of random numbers. Then, replace the values along the
    main diagonal line with the median values. Then, the program classifies them into
    different groups:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Julia，我们使用了一个名为`Clustering`的包。下一个示例来自*Lin, Regier, and Arslan*（2016），并做了些微修改（[https://github.com/JuliaStats/Clustering.jl/blob/master/test/affprop.jl](https://github.com/JuliaStats/Clustering.jl/blob/master/test/affprop.jl)）。首先，我们生成一组随机数。然后，将主对角线上的值替换为中位数值。接着，程序将它们分类为不同的组：
- en: '[PRE27]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The output is shown here:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '![](img/80add43a-f72b-43ec-8d58-112f57ead85c.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80add43a-f72b-43ec-8d58-112f57ead85c.png)'
- en: Based on the output, we see a few groups and which numbers belong to which group.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 根据输出，我们看到了一些组，并了解了哪些数字属于哪个组。
- en: Task view for Cluster Analysis
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 聚类分析的任务视图
- en: 'In the previous chapters, we have discussed various kinds of task views. A
    task view is a set of R packages organized by one or a few experts around a topic.
    For the **Cluster Analysis**, [https://CRAN.R-project.org/view=Cluster](https://CRAN.R-project.org/view=Cluster),
    the top part is shown in the following screenshot:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们讨论了各种任务视图。任务视图是由一位或几位专家围绕某个主题组织的R包集合。对于**聚类分析**，[https://CRAN.R-project.org/view=Cluster](https://CRAN.R-project.org/view=Cluster)，其顶部部分如以下截图所示：
- en: '![](img/68937f40-a789-46c7-959e-22890acc7fa9.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](img/68937f40-a789-46c7-959e-22890acc7fa9.png)'
- en: 'As discussed in *[Chapter 6](c812a40e-eb24-4bb8-8af5-1cfe1834ec77.xhtml), Managing
    Packages*, we can use just three lines of R code to install these cluster-related
    packages:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在*[第六章](c812a40e-eb24-4bb8-8af5-1cfe1834ec77.xhtml)《管理包》中讨论的那样，我们可以使用仅三行R代码来安装这些与聚类相关的包：
- en: '[PRE28]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In total, there are about 154 R packages included in the previous task view
    called **Cluster,** as of March 21, 2018.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 截至2018年3月21日，前一个任务视图**Cluster**中总共包含约154个R包。
- en: Summary
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, we have discussed unsupervised learning. In particular, we
    have explained hierarchical clustering and k-means clustering. As for R and Python,
    we have explained several related packages:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了无监督学习，特别是层次聚类和k均值聚类。关于R和Python，我们介绍了几个相关的包：
- en: R: `rattle`, `Rmixmod`, and `randomUniformForest`
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: R：`rattle`、`Rmixmod`和`randomUniformForest`
- en: Python: `scipy.cluster`, `contrastive`, and `sklearn`
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python：`scipy.cluster`、`contrastive`和`sklearn`
- en: Several real-world examples have also been used to illustrate the applications
    of these packages in detail.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 还通过多个现实世界的例子详细说明了这些包的应用。
- en: For the next chapter, we will discuss supervised learning, such as classification,
    the k-nearest neighbors algorithm, Bayes' classifiers, reinforcement learning,
    and specific R and Python-related modules, such as `RTextTools` and `sklearn`.
    In addition, we will discuss implementation via R, Python, Julia, and Octave.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论监督学习，如分类、k最近邻算法、贝叶斯分类器、强化学习以及与R和Python相关的特定模块，如`RTextTools`和`sklearn`。此外，我们还将讨论通过R、Python、Julia和Octave的实现方法。
- en: Review questions and exercises
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复习问题和练习
- en: What does *unsupervised learning* mean?
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*无监督学习*是什么意思？'
- en: What is the major difference between unsupervised learning and supervised learning?
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 无监督学习和监督学习之间的主要区别是什么？
- en: How do we install the Python package `sklearn`?
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何安装Python包`sklearn`？
- en: Discuss the relationship between distance and clustering classification.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 讨论距离与聚类分类之间的关系。
- en: How do we define the distance between two objects?
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何定义两个对象之间的距离？
- en: For non-numeric values, how do we define a distance between two members?
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于非数值类型的值，我们如何定义两个成员之间的距离？
- en: For R, we could find a set of related packages related to unsupervised learning
    called `cluster`. Is there any task view, or similar super package, for Python?
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于R，我们可以找到一组与无监督学习相关的包，称为`cluster`。Python中是否有类似的任务视图或超包？
- en: 'First, generate the following set of random numbers:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，生成以下一组随机数：
- en: '[PRE29]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Then, based on the various definitions of distance, estimate the distances between
    those four groups.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，根据不同的距离定义，估计这四个组之间的距离。
- en: 'For the following set of data, estimate the minimum, maximum, and average distances:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对以下数据集，估计最小值、最大值和平均距离：
- en: '[PRE30]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: What is the usage of a dendrogram?
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 树状图的用途是什么？
- en: Draw a dendrogram by using all wine data.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用所有葡萄酒数据绘制树状图。
- en: Generate 20 random numbers with a mean of 1.2 and standard deviation of 2 from
    a normal distribution. Then draw a dendrogram.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从正态分布中生成20个随机数，均值为1.2，标准差为2。然后绘制树状图。
- en: 'Using a five-year monthly historical price data for 30 stocks, estimate their
    annualized standard deviations and means. Classify them into different groups.
    The source of data is Yahoo!Finance ([http://finance.yahoo.com](http://finance.yahoo.com)).
    Note that the following formulae are used to calculate an annualized standard
    deviation:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用30只股票的五年期每月历史价格数据，估算它们的年化标准差和均值，并将它们分类为不同的组。数据来源为Yahoo!Finance（[http://finance.yahoo.com](http://finance.yahoo.com)）。请注意，以下公式用于计算年化标准差：
- en: '![](img/9f277317-4d64-44b3-a79d-1796a5aeacc9.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9f277317-4d64-44b3-a79d-1796a5aeacc9.png)'
- en: Where *σ[annual]* is the annualized standard deviation, *σ[monthly]* is the
    standard deviation based on monthly returns, ![](img/55c15b72-5583-4adc-b383-60f548c17314.png) is
    the annualized mean return, and ![](img/6e626250-a85a-4787-a4ed-f19fb52240f3.png) is
    the monthly mean return.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 其中*σ[annual]*是年化标准差，*σ[monthly]*是基于月度回报的标准差，![](img/55c15b72-5583-4adc-b383-60f548c17314.png)是年化均值回报，![](img/6e626250-a85a-4787-a4ed-f19fb52240f3.png)是月度均值回报。
- en: For the R package called `cluster`, what is the meaning of the `votes.repub`
    dataset? Using that dataset, conduct a Cluster Analysis and draw a dendogram tree.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于名为`cluster`的R包，`votes.repub`数据集的含义是什么？使用该数据集进行聚类分析并绘制树状图。
- en: Find more information about the `linkage_tree()` function contained in the `sklearn.cluster`
    submodule. (Python)
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找有关`linkage_tree()`函数的更多信息，该函数包含在`sklearn.cluster`子模块中。（Python）
- en: For the `rattle` package, how do we save an R script?
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`rattle`包，我们如何保存一个R脚本？
