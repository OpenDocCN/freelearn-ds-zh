- en: Chapter 5. Advanced Computing with SciPy, Numba, and NumbaPro
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。使用SciPy、Numba和NumbaPro的高级计算
- en: In this chapter, the user will learn how to use `SciPy` to perform scientific
    computations. The `Numba` package will then be introduced as a way to accelerate
    computations. Finally, the `NumbaPro` capabilities of parallel execution in the
    GPU will be presented.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，用户将学习如何使用`SciPy`执行科学计算。然后，将介绍`Numba`包作为加速计算的方法。最后，将介绍`NumbaPro`的GPU并行执行能力。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Overview of `SciPy`
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SciPy`概述'
- en: Advanced mathematical algorithms with `SciPy`
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`SciPy`的高级数学算法
- en: Accelerating computations with `Numba` and `NumbaPro`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Numba`和`NumbaPro`加速计算
- en: 'Before running the examples in this chapter, load `pylab` by running the following
    command in a computing cell:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行本章中的示例之前，请通过在计算单元中运行以下命令来加载`pylab`：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Overview of SciPy
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`SciPy`概述'
- en: '`SciPy` is an extensive library for applied mathematics and scientific computation.
    The following is the complete list of all the modules available in the library:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '`SciPy`是一个广泛应用于数学和科学计算的库。以下是库中所有可用模块的完整列表：'
- en: '| Module | Functionality |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| 模块 | 功能 |'
- en: '| --- | --- |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `cluster` | Clustering algorithms |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| `cluster` | 聚类算法 |'
- en: '| `constants` | Physical and mathematical constants |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| `constants` | 物理和数学常数 |'
- en: '| `fftpack` | Fast Fourier Transform |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| `fftpack` | 快速傅里叶变换 |'
- en: '| `integrate` | Integration and ordinary differential equations |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| `integrate` | 积分与常微分方程 |'
- en: '| `interpolate` | Interpolation and splines |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| `interpolate` | 插值与样条 |'
- en: '| `io` | Input and output |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| `io` | 输入与输出 |'
- en: '| `linalg` | Linear algebra |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| `linalg` | 线性代数 |'
- en: '| `ndimage` | Image processing |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| `ndimage` | 图像处理 |'
- en: '| `odr` | Orthogonal distance regression |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| `odr` | 正交距离回归 |'
- en: '| `optimize` | Optimization and root-finding |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| `optimize` | 优化与根求解 |'
- en: '| `signal` | Signal processing |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| `signal` | 信号处理 |'
- en: '| `sparse` | Sparse matrices |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| `sparse` | 稀疏矩阵 |'
- en: '| `spatial` | Spatial data structures |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| `spatial` | 空间数据结构 |'
- en: '| `special` | Special functions |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| `special` | 特殊函数 |'
- en: '| `stats` | Statistical distributions |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| `stats` | 统计分布 |'
- en: '| `weave` | C/C++ integration |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| `weave` | C/C++ 集成 |'
- en: 'The standard way to import `SciPy` modules in scripts is using the following
    command line:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本中导入`SciPy`模块的标准方式是使用以下命令行：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, individual functions can be called with the usual module reference syntax,
    as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，可以使用通常的模块引用语法来调用各个函数，如下所示：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'However, many of the most used functions are available at the top level of
    the `SciPy` hierarchy. Also, we use IPython in the interactive mode and use (as
    we assume in this book) the magic, as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，许多最常用的函数可以在`SciPy`层次结构的顶层找到。此外，我们使用IPython的交互模式，并使用（本书中假设的）魔法命令，如下所示：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Many of the functions will be available without explicit module reference.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 许多函数将无需显式引用模块即可使用。
- en: In the next section, we present a sample of the functions available in `SciPy`.
    The reader is not expected to know the mathematical techniques and algorithms
    that will be used in the examples in depth.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将展示`SciPy`中可用的一些函数示例。读者不需要深入了解示例中将使用的数学技术和算法。
- en: Advanced mathematical algorithms with SciPy
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SciPy的高级数学算法
- en: 'In this section, we will cover some of the algorithms available in `SciPy`.
    Each of the following subsections features a representative example from a significant
    area of applied science. The examples are chosen so as not to require extensive
    domain knowledge but still be realistic. These are the topics and examples that
    we present:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将涵盖`SciPy`中一些可用的算法。以下每个子节都包含一个来自应用科学重要领域的代表性示例。这些示例的选择不需要广泛的领域知识，但仍然具有现实性。我们呈现的主题和示例如下：
- en: '**Solving equations and finding optimal values**: We will study a market model
    that requires the solution of a nonlinear system and a facility location problem
    requiring a nonstandard optimization.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**解方程和寻找最优值**：我们将研究一个市场模型，它需要求解一个非线性系统，以及一个需要非标准优化的设施选址问题。'
- en: '**Calculus and differential equations**: We will present a volume calculation
    that uses integral calculus, and **Newton''s canon**, a thought experiment proposed
    by Isaac Newton, which we will model using a system of differential equations.
    Finally, we will present a three-dimensional system, the famous Lorenz equations,
    which is an early example displaying chaotic behavior.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**微积分和常微分方程**：我们将展示一个利用积分微积分进行的体积计算，并介绍**牛顿的炮**，这是由艾萨克·牛顿提出的一个思想实验，我们将用常微分方程系统对其建模。最后，我们将介绍一个三维系统——著名的洛伦兹方程，这是早期表现出混沌行为的例子。'
- en: Solving equations and finding optimal values
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 求解方程和寻找最优值
- en: To illustrate this topic, we use a standard supply-versus-demand model from
    economics. In this model, supply and demand are related to prices by functional
    relationships, and the equilibrium market is found by determining the intersection
    of the supply and demand curves. The mathematical formulae we use in the example
    are somewhat arbitrary (thus possibly unrealistic) but will go beyond what is
    found in textbooks, where supply and demand are in general assumed to be linear.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这个主题，我们使用了经济学中一个标准的供需模型。在这个模型中，供需与价格之间有函数关系，市场均衡通过确定供需曲线的交点来找到。我们在示例中使用的数学公式有些是任意的（因此可能不现实），但这些公式超出了教科书中通常假设供需关系为线性关系的范围。
- en: 'The formulae that specify the supply and demand curves are as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 定义供需曲线的公式如下：
- en: '![Solving equations and finding optimal values](img/8341OS_05_15.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![求解方程和寻找最优值](img/8341OS_05_15.jpg)'
- en: 'We will use the *function factory* pattern. Run the following lines of code
    in a cell:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用*函数工厂*模式。在一个单元格中运行以下代码：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding code doesn't directly define the supply and demand curves. Instead,
    it specifies function factories. This approach makes it easier to work with parameters,
    which is what we normally want to do in applied problems since we expect the same
    model to be applicable to a variety of situations.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码并没有直接定义供需曲线，而是指定了函数工厂。这样做可以更方便地处理参数，这在应用问题中非常常见，因为我们希望相同的模型能适用于多种情况。
- en: 'Next, we set the parameter values and call the function factories to define
    the functions that actually evaluate the supply and demand curves, as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们设置参数值，并调用函数工厂来定义实际评估供需曲线的函数，如下所示：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The following lines of code make a graph of the curves:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码行生成了曲线的图像：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The following is the graph that is the output of the preceding lines of code:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是上述代码行输出的图像：
- en: '![Solving equations and finding optimal values](img/8341OS_05_01.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![求解方程和寻找最优值](img/8341OS_05_01.jpg)'
- en: 'The curves chosen for supply and demand reflect what would be reasonable assumptions:
    supply increases and demand decreases as the price gets higher. Even with a zero
    price, the demand is finite (reflecting the fact that there is a limited population
    interested in the product). On the other hand, the supply curve has a vertical
    asymptote (not shown in the plot), indicating that there is a production limit
    (so, even if the price goes to infinity, there is a limited quantity that can
    be offered in the market).'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 选择的供需曲线反映了合理的假设：随着价格上涨，供应增加而需求减少。即使价格为零，需求也是有限的（反映了市场中对产品感兴趣的人口有限）。另一方面，供给曲线具有垂直渐近线（在图中未显示），表明存在生产限制（即使价格趋近于无限，也只能提供有限的市场供应量）。
- en: 'The equilibrium point of the market is the intersection of the supply and demand
    curves. To find the equilibrium, we use the `optimize` module, which, besides
    providing functions for optimization, also has functions to solve numerical equations.
    The recommended function to find solutions for one-variable functions is `brentq()`,
    as illustrated in the following code:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 市场的均衡点是供需曲线的交点。为了找到均衡点，我们使用`optimize`模块，该模块除了提供优化函数外，还具有求解数值方程的功能。推荐用来求解一元函数的函数是`brentq()`，如下代码所示：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `brentq()` function assumes that the right-hand side of the equation we
    want to solve is `0`. So, we start by defining the `opt_func()` function that
    computes the difference between supply and demand. This function is the first
    argument of `brentq()`. The next two numerical arguments give an interval that
    contains the solutions. It is important to choose an interval that contains exactly
    one solution of the equation. In our example, this is easily done by looking at
    the graph, from which it is clear that the curves intersect between 1 and 2.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`brentq()`函数假设我们要求解的方程的右边是`0`。因此，我们首先定义`opt_func()`函数，该函数计算供给和需求之间的差值。这个函数是`brentq()`的第一个参数。接下来的两个数值参数给出了包含解的区间。选择一个确切包含方程解的区间非常重要。在我们的例子中，通过查看图形很容易做到这一点，因为可以明显看到曲线在1和2之间交叉。'
- en: 'Running the preceding code produces the following output:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码会产生以下输出：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The first value is the equilibrium point, which is the number of units (in thousands)
    that can be sold at the optimal price. The optimal price is computed using both
    the supply and demand curves (to check that the values are indeed the same).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个值是均衡点，即在最优价格下能够销售的单位数（以千为单位）。最优价格是通过供给曲线和需求曲线共同计算得出的（以检查这些值是否确实相同）。
- en: 'To illustrate an optimization problem in two variables, let''s consider a problem
    of optimal facility location. Suppose a factory has several manufacturing stations
    that need materials to be distributed from a single supply station. The factory
    floor is rectangular, and the distribution rails must be parallel to the walls
    of the factory. This last requirement is what makes the problem interesting. The
    function to be minimized is related to the so-called **taxicab** **distance**,
    which is illustrated in the following image:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明一个有两个变量的优化问题，我们考虑一个最优设施位置问题。假设一座工厂有若干个制造站点，需要从一个单一的供给站点分配材料。工厂的车间是矩形的，分配轨道必须与工厂的墙壁平行。这最后一个要求使问题变得有趣。需要最小化的函数与所谓的**出租车****距离**相关，具体如以下图所示：
- en: '![Solving equations and finding optimal values](img/8341OS_05_02.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![求解方程并寻找最优值](img/8341OS_05_02.jpg)'
- en: 'The first step is to define the points where the manufacturing stations are
    given, as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是定义给定制造站点的位置，如下所示：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The positions are stored as a 4 x 2 `NumPy` array called `points`, with one
    point in each row. The following command produces a plot of the points mentioned
    in the previous command line:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这些位置存储为一个4 x 2的`NumPy`数组，名为`points`，每行代表一个点。以下命令会绘制之前命令行中提到的这些点的图：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The points are displayed using a circular marker specified by the argument
    `o`, which also turns off the line segments connecting the points. The `ms` and
    `mfc` options specify the size of the marker (in pixels) and its color, respectively.
    The following image is then generated as the output:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这些点使用圆形标记显示，标记由参数`o`指定，该参数还关闭了连接这些点的线段。`ms`和`mfc`选项分别指定标记的大小（以像素为单位）和颜色。生成的输出为以下图像：
- en: '![Solving equations and finding optimal values](img/8341OS_05_03.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![求解方程并寻找最优值](img/8341OS_05_03.jpg)'
- en: 'The next step is to define the function to be minimized. We again prefer the
    approach of defining a function factory, as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是定义要最小化的函数。我们再次倾向于定义一个函数工厂的方法，如下所示：
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The main point of this code is the way in which the taxicab distance is computed,
    which takes full advantage of the flexibility of the array operations of `NumPy`.
    This is done in the following line of code:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的关键在于计算出租车距离的方式，充分利用了`NumPy`数组操作的灵活性。此操作在以下代码行中完成：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This code first computes the vector difference, `points-p`. Note that, here,
    `points` is a 4 x 2 array, while `p` is a 1 x 2 array. `NumPy` realizes that the
    dimensions of the arrays are different and uses its *broadcasting rules*. The
    effect is that the array `p` is subtracted from each row of the `points` array,
    which is exactly what we want. Then the `abs()` function computes the absolute
    value of each of the entries of the resulting array, and finally `sum()` adds
    all the entries. That's a lot of work done in a single line of code!
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码首先计算了向量差值`points-p`。请注意，`points`是一个4 x 2的数组，而`p`是一个1 x 2的数组。`NumPy`意识到数组的维度不同，并利用其*广播规则*。结果是，数组`p`被从`points`数组的每一行中减去，这正是我们想要的。接着，`abs()`函数计算结果数组中每个条目的绝对值，最后`sum()`函数将所有条目相加。这一切都在一行代码中完成，工作量非常大！
- en: We then have to use the function factory to define the function that will actually
    compute the taxicab distance.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们需要使用函数工厂来定义实际计算出租车距离的函数。
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The function factory is simply called with the array containing the actual
    positions as its argument. At this point, the problem is completely set up, and
    we are ready to compute the optimum, which is done with the following code:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 函数工厂只是简单地用包含实际位置的数组作为参数进行调用。此时，问题已经完全设置好，我们准备计算最优解，以下代码可以完成这一过程：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The minimization is computed by a call to the `minimize()` function. The first
    two arguments of this function are the objective function defined in the previous
    cell, `txmin()`, and an initial guess, `x0`. We just choose the origin as the
    initial guess, but in a real-world problem, we use any information we can gather
    to select a guess that is close to the actual minimum. Several optimization methods
    are available, suitable for different types of objective functions. We use the
    **Nelder-Mead method**, which is a heuristic algorithm that does not require smoothness
    of the objective function. This is well suited for the problem at hand. Finally,
    we specify two options for the method: the desired tolerance and a display option
    to print diagnostics. This produces the following output:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 最小化通过调用`minimize()`函数来计算。该函数的前两个参数是之前单元格中定义的目标函数`txmin()`和初始猜测值`x0`。我们选择原点作为初始猜测值，但在实际问题中，我们会利用所收集的信息来选择一个接近实际最小值的猜测值。该函数提供了几种优化方法，适用于不同类型的目标函数。我们使用**Nelder-Mead方法**，这是一种启发式算法，不要求目标函数具有光滑性，非常适合当前问题。最后，我们为该方法指定了两个选项：所需的容差和用于打印诊断信息的显示选项。这将生成以下输出：
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The preceding output states that a minimum was successfully found and gives
    its value. Note that, as in any numerical optimization method, in general, it
    can only be guaranteed that a local minimum was found. In this case, since the
    objective function is convex, the minimum is guaranteed to be global. The result
    of the function is stored in a `SciPy` data structure of the `OptimizeResult`
    type defined in the `optimize` module. To get the optimal position of the facility,
    we can use the following command:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 上述输出表示已成功找到最小值，并给出了其值。请注意，与任何数值优化方法一样，通常只能保证找到局部最小值。在这种情况下，由于目标函数是凸的，因此最小值必定是全局最小值。该函数的结果存储在`SciPy`数据结构中，这种数据结构是`optimize`模块中定义的`OptimizeResult`类型。要获取设施的最优位置，我们可以使用以下命令：
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The output of the preceding command is as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令的输出如下：
- en: '[PRE17]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To finish this example, we present the code that displays the optimal solution:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个示例，我们展示了显示最优解的代码：
- en: '[PRE18]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The calls to the `plot()` function are similar to the ones in the previous
    example. To give a nicely formatted title, we first define the `locstr` string,
    which displays the optimal location coordinates. This is a Python-formatted string
    with the format specification of `{:5.2f}`, that is, a floating-point field with
    width `5` and a precision of `2` digits. The result is the following figure:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 对`plot()`函数的调用类似于之前示例中的调用。为了给图表添加格式化良好的标题，我们首先定义`locstr`字符串，用于显示最优位置坐标。这个字符串是一个Python格式化字符串，格式规范为`{:5.2f}`，即宽度为`5`且精度为`2`位的小数。结果如下图所示：
- en: '![Solving equations and finding optimal values](img/8341OS_05_04.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![求解方程和寻找最优值](img/8341OS_05_04.jpg)'
- en: Calculus and differential equations
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 微积分和微分方程
- en: 'As an example of a calculus computation, we will show you how to compute the
    volume of a solid of revolution. The solid is created by rotating the curve displayed
    in the following figure around the *y*-axis:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 作为微积分计算的一个例子，我们将展示如何计算旋转体的体积。该旋转体是通过将下图中显示的曲线绕*y*轴旋转得到的：
- en: '![Calculus and differential equations](img/8341OS_05_05.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![微积分和微分方程](img/8341OS_05_05.jpg)'
- en: 'This curve is plotted with the following code:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这条曲线是通过以下代码绘制的：
- en: '[PRE19]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The curve is essentially a stretched and transposed inverse cosine function,
    as defined in the `make_gen()` function. It depends on two parameters, `a` and
    `b`, that specify its height and length, respectively. The `make_gen()` function
    is a function factory that returns a function that actually computes values in
    the curve. The actual function defining the curve is called `gen()` (for *generator*),
    so this is the function that is plotted.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 该曲线本质上是一个拉伸和转置的反余弦函数，定义在`make_gen()`函数中。它依赖于两个参数，`a`和`b`，分别指定其高度和长度。`make_gen()`函数是一个函数工厂，返回一个实际计算曲线值的函数。实际定义曲线的函数称为`gen()`（代表*生成器*），因此这是要绘制的函数。
- en: 'When this curve is rotated around the vertical axis, we obtain the solid plotted
    as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当这条曲线围绕垂直轴旋转时，我们得到了如下绘制的实体：
- en: '![Calculus and differential equations](img/8341OS_05_06.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![微积分和微分方程](img/8341OS_05_06.jpg)'
- en: 'The preceding figure, of course, was generated with IPython using the following
    code:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，前面的图是使用IPython生成的，使用了以下代码：
- en: '[PRE20]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The key function in this code is the call to `plot_trisurf()` in the last line.
    This function accepts three `NumPy` arrays, `xvalues`, `yvalues`, and `zvalues`,
    specifying the coordinates of the points on the surface. The arrays, `xvalues`
    and `yvalues` define points in a succession of concentric circles, as shown in
    the following image:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码中的关键函数是最后一行中对`plot_trisurf()`的调用。该函数接受三个`NumPy`数组，`xvalues`、`yvalues`和`zvalues`，指定了表面上点的坐标。数组`xvalues`和`yvalues`定义了一系列同心圆上的点，如下图所示：
- en: '![Calculus and differential equations](img/8341OS_05_07.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![微积分和微分方程](img/8341OS_05_07.jpg)'
- en: The value of the `z` coordinate is obtained by computing `gen(sqrt(x*x+y*y))`
    at each of these points, which has the effect of assigning the same height in
    the 3D plot to all points of each concentric circle.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`z`坐标的值是通过在每个点计算`gen(sqrt(x*x+y*y))`得到的，这样就将同心圆上的所有点在3D图中分配了相同的高度。'
- en: 'To compute the volume of the solid, we use the method of cylindrical shells.
    An explanation of how the method works is beyond the scope of this book, but it
    boils down to computing an integral, as shown in the following formula:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算实体的体积，我们使用圆柱壳法。该方法的工作原理超出了本书的范围，但归根结底是计算一个积分，如下公式所示：
- en: '![Calculus and differential equations](img/8341OS_05_08.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![微积分和微分方程](img/8341OS_05_08.jpg)'
- en: 'In this formula, the *f(x)* function represents the curve being rotated around
    the `y`-axis. To compute this integral, we use the `scipy.integrate` package.
    We use the `quad()` function, which is appropriate for the generic integration
    of functions that do not have singularities. The following is the code for this
    formula:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个公式中，*f(x)*函数代表围绕`y`轴旋转的曲线。为了计算这个积分，我们使用`scipy.integrate`包。我们使用`quad()`函数，适用于没有奇点的函数的通用积分。以下是这个公式的代码：
- en: '[PRE21]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'After importing the `integrate` module, we define the function to be integrated.
    Note that we use the `lambda` syntax since this is a one-line calculation. Finally,
    we call `quad()` to perform the integration. The arguments to the call are the
    function being integrated and the bounds of integration (from `0` to `b` in this
    case). The following is the output of the preceding lines of code:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 导入`integrate`模块后，我们定义要进行积分的函数。请注意，由于这是一行计算，我们使用了`lambda`语法。最后，我们调用`quad()`来执行积分。调用的参数是被积函数和积分的边界（在这种情况下是从`0`到`b`）。以下是前面几行代码的输出：
- en: '[PRE22]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The first number is the value of the integral, and the second one is an error
    estimate.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个数字是积分值，第二个是误差估计。
- en: 'In the next example, we consider *Newton''s canon*, a thought experiment at
    the very root of modern physics and calculus. The situation is illustrated in
    the following image, which is an engraving from the book by Sir Isaac Newton,
    *A Treatise of The System of the World*:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，我们考虑*牛顿的大炮*，这是现代物理和微积分根源的一个思维实验。以下图像展示了这种情况，这是艾萨克·牛顿爵士的著作《世界体系论》中的一幅雕刻：
- en: '![Calculus and differential equations](img/8341OS_05_14.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![微积分和微分方程](img/8341OS_05_14.jpg)'
- en: Newton asks us to imagine a canon sitting at the top of a very high mountain.
    If the canon shoots a projectile, it will fly for a while and eventually hit the
    ground. The larger the initial velocity of the projectile, the further away it
    will hit the ground. Let's imagine that we can shoot the projectile as fast as
    we want, and that there is no air resistance. Then, as the initial velocity increases,
    eventually the projectile will go around the earth and, if the canon is removed
    quickly enough, then the projectile will continue its orbit around Earth forever.
    Newton used this example to explain how the moon could revolve around Earth without
    ever falling under the action of gravity alone.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 牛顿让我们想象有一门大炮坐落在一座非常高的山顶上。如果大炮发射一颗抛射体，它会飞行一段时间，最终落到地面。抛射体的初速度越大，它落地的距离越远。让我们假设我们可以任意快地发射抛射体，并且没有空气阻力。这样，随着初速度的增加，最终抛射体将绕地球飞行，如果大炮足够迅速地移除，抛射体将永远继续绕地球轨道运行。牛顿用这个例子来解释月球是如何绕地球运行的，而不单单依靠重力作用下掉落。
- en: 'To model this situation, we need to use Newton''s law of gravitation as a system
    of differential equations:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要建模这个情况，我们需要使用牛顿的引力定律作为一个微分方程组：
- en: '![Calculus and differential equations](img/8341OS_05_09.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![微积分与微分方程](img/8341OS_05_09.jpg)'
- en: We will not attempt to explain how these formulae were obtained, with the only
    important point for us being that there are four state variables, with the first
    two representing the position of the projectile and the last two representing
    its velocity vector. Since the movement takes place in a plane through the center
    of Earth, only two position variables are needed. *G* and *M* are constants representing
    Newton's universal gravitational constant and the mass of Earth, respectively.
    The mass of the projectile does not appear, since the gravitational mass is exactly
    cancelled by the inertial mass.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会尝试解释这些公式是如何得出的，唯一对我们重要的是有四个状态变量，前两个表示抛射体的位置，后两个表示其速度向量。由于运动发生在通过地球中心的平面内，因此只需要两个位置变量。*G*和*M*分别是表示牛顿万有引力常数和地球质量的常量。抛射体的质量不出现，因为引力质量与惯性质量恰好抵消。
- en: 'The first step to solve this using `SciPy` is to define this set of differential
    equations, which is done with the following code:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`SciPy`来解决这个问题的第一步是定义这一组微分方程，具体实现如下代码：
- en: '[PRE23]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'All that we need to do is define a function that computes the right-hand side
    of the system of differential equations. We start by defining the constants, `M`
    and `G` (using SI units), and the auxiliary constant `C`, since `G` and `M` only
    appear in the equations through their product. The system is represented by the
    `ode_func()` function. This function must accept at least two parameters: a `NumPy`
    array, `xvec`, and a floating-point value, `t`. In our case, `xvec` is a four-dimensional
    vector since there are four state variables in our system. The variable, `t`,
    is not used in the system since there are no external forces (as there would be
    if we were launching a rocket instead of shooting a projectile). However, it must
    still be listed as an input parameter.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要做的是定义一个函数，计算微分方程组的右侧。我们首先定义常量`M`和`G`（使用国际单位制），以及辅助常量`C`，因为`G`和`M`仅通过它们的乘积出现在方程中。系统由`ode_func()`函数表示。这个函数必须至少接受两个参数：一个`NumPy`数组`xvec`和一个浮动值`t`。在我们的例子中，`xvec`是一个四维向量，因为我们的系统有四个状态变量。`t`变量在系统中没有被使用，因为没有外力（如果我们发射的是火箭而不是抛射体，那么就会有外力）。然而，它仍然必须作为输入参数列出。
- en: 'Inside `ode_func()`, we first extract the elements of the `xvec` vector with
    the assignment, as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ode_func()`内部，我们首先通过赋值提取`xvec`向量的各个元素，如下所示：
- en: '[PRE24]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This is not strictly necessary but improves readability. We then compute the
    auxiliary quantity, `d` (this is the denominator of the last two equations). Finally,
    the output array is computed according to the formulae in the system. Note that
    no derivatives are computed since all information that is needed by the solver
    is contained in the right-hand side of the equations.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是严格必要的，但有助于提高可读性。然后我们计算辅助量`d`（这是最后两个方程的分母）。最后，输出数组根据系统中的公式进行计算。请注意，没有计算任何导数，因为求解器所需的所有信息都包含在方程的右侧。
- en: 'We are now ready to solve the system of differential equations using the following
    lines of code:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备使用以下代码行来求解微分方程组：
- en: '[PRE25]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The first line of the preceding code imports the `integrate` module, where the
    differential equations are solved. We then need to specify the initial position
    and velocity of the projectile. We assume that the canon is at the North Pole,
    atop a tower of 50,000 m (although this is clearly unrealistic, we just choose
    such a large value to enhance the visibility of the orbit). Since Earth is not
    a perfect sphere, we use an average value for the radius. The initial velocity
    is set to `8500` m/s.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的第一行导入了`integrate`模块，该模块用于求解微分方程。然后，我们需要指定抛射物的初始位置和速度。我们假设火炮位于北极，位于50,000米高的塔楼上（虽然这显然不现实，我们选择如此大的值是为了增强轨道的可见性）。由于地球不是完美的球体，我们使用半径的平均值。初始速度设置为`8500`米/秒。
- en: 'The initial conditions are stored in a `NumPy` array with the following assignment:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 初始条件存储在一个`NumPy`数组中，通过以下赋值完成：
- en: '[PRE26]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The next step is to define the initial time (zero in our case) and the array
    of times at which the solution is sought. This is done with the following three
    lines of code:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是定义初始时间（在我们的例子中为零）和解所需的时间数组。这通过以下三行代码完成：
- en: '[PRE27]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We first define `tmax` as being the duration of the simulation (in seconds).
    The variable `dt` stores the time intervals at which we want to record the solution.
    In the preceding code, the solution will be recorded every 60 seconds for 8,650
    seconds. The final time was chosen by trial-and-error to correspond, approximately,
    to one orbit of the projectile.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义`tmax`为模拟的持续时间（以秒为单位）。变量`dt`存储我们希望记录解的时间间隔。在上述代码中，解将在8,650秒内每60秒记录一次。最终时间通过反复试验选择，以大致对应抛射物的一个轨道。
- en: 'We are now ready to compute the solution, which is done with a call to the
    `odeint()` function. The solution is stored in the vector, `xsol`, which has one
    row for each time at which the solution is computed. To see the first few rows
    of the vector, we can run the following command:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备计算解，这通过调用`odeint()`函数来完成。解存储在向量`xsol`中，该向量为每个计算解的时间提供一行。要查看该向量的前几行，我们可以运行以下命令：
- en: '[PRE28]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The preceding command produces the following output:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令产生了以下输出：
- en: '[PRE29]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: These values are the position and velocity vectors of the projectile from time
    `0` s to time `360` s at intervals of `60` s.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值是从`0`秒到`360`秒的抛射物的位置和速度向量，时间间隔为`60`秒。
- en: 'We definitely want to produce a plot of the orbit. This can be done by running
    the following code in a cell:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们确实希望绘制轨道图。这可以通过在一个单元格中运行以下代码来完成：
- en: '[PRE30]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We want to use the same scale in both axes since both axes represent spatial
    coordinates in meters. This is done in the first line of code. The second line
    sets the axis limits so that the plot of the orbit fits comfortably in the picture.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望两个轴使用相同的尺度，因为两个轴都表示以米为单位的空间坐标。这在第一行代码中完成。第二行设置轴的限制，使轨道的图表能够舒适地适应图像。
- en: 'Then, we plot a circle to represent Earth using the following lines of code:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用以下代码绘制一个圆形来表示地球：
- en: '[PRE31]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We have not emphasized using `Artist` objects in our plots since these are
    at a lower level than is usually required for scientific plots. Here, we are constructing
    a `Circle` object by giving its center, radius, and appearance options: a black
    edge color, brown face color, and a line width equal to 3\. The second line of
    code shows how to add the `Circle` object to the plot.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在图表中并未强调使用`Artist`对象，因为这些对象的级别较低，通常在科学绘图中不需要。这里，我们通过指定圆心、半径和外观选项来构建一个`Circle`对象：黑色边缘颜色、棕色填充颜色和线宽为3。第二行代码展示了如何将`Circle`对象添加到图表中。
- en: 'After drawing Earth, we plot the orbit using the following line of code:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制地球后，我们使用以下代码绘制轨道：
- en: '[PRE32]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This is a standard call to the `plot()` function. Note that we plot only the
    first two columns of the `xsol` array since these represent the position of the
    projectile (recall that the other two represent the velocity). The following image
    is what we get as the output:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对`plot()`函数的标准调用。请注意，我们只绘制`xsol`数组的前两列，因为这表示抛射物的位置（回想一下，其他两列表示速度）。以下图像是我们得到的输出：
- en: '![Calculus and differential equations](img/8341OS_05_10.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![微积分与微分方程](img/8341OS_05_10.jpg)'
- en: A numerical solution for differential equations is a sophisticated topic, and
    a complete treatment of the issue is beyond the scope of this book, but we will
    present the full form of the `odeint()` function and comment on some of the options.
    The `odeint()` function is a Python wrapper on the `lsoda` solver from `ODEPACK`,
    the Fortran library. Detailed information about the solver can be found at [http://people.sc.fsu.edu/~jburkardt/f77_src/odepack/odepack.html](http://people.sc.fsu.edu/~jburkardt/f77_src/odepack/odepack.html)
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 微分方程的数值解是一个复杂的话题，完整的处理超出了本书的范围，但我们将呈现`odeint()`函数的完整形式并评论其中的一些选项。`odeint()`函数是Python对`ODEPACK`的`lsoda`求解器的封装，`ODEPACK`是一个Fortran库。有关求解器的详细信息，请访问[http://people.sc.fsu.edu/~jburkardt/f77_src/odepack/odepack.html](http://people.sc.fsu.edu/~jburkardt/f77_src/odepack/odepack.html)
- en: 'The following lines of code are the complete signature of `odeint()`:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码行是`odeint()`的完整签名：
- en: '[PRE33]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The arguments, `ode_func`, `x0` and `tvalues`, have already been discussed.
    The argument `args` allows us to pass extra parameters to the equation being solved.
    This is a very common situation, which is illustrated in the next example. In
    this case, the function defining the system must have the following signature:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 参数`ode_func`、`x0`和`tvalues`已经讨论过。参数`args`允许我们向所求解的方程传递额外的参数。这是一种非常常见的情况，下面的示例将对此进行说明。在这种情况下，定义系统的函数必须具有以下签名：
- en: '[PRE34]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Here, `p1`, `p2`, and `pn` are extra parameters. These parameters are fixed
    for a single solution but can change from one solution to the other (they are
    normally used to represent the environment). The tuple passed to `args` must have
    a length exactly equal to the number of parameters that `ode_func()` requires.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`p1`、`p2`和`pn`是额外的参数。这些参数对于单个解是固定的，但可以在不同的解之间发生变化（通常用于表示环境）。传递给`args`的元组长度必须与`ode_func()`所需的参数数量完全相等。
- en: 'The following is a partial list of the meaning of the most common options:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是常见选项意义的部分列表：
- en: '`Dfun` is a function that computes the Jacobian of the system. This may improve
    the accuracy of the solution.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Dfun`是一个计算系统雅可比矩阵的函数。这可能提高解的精度。'
- en: Whether the Jacobian has the derivatives of the right-hand side along its columns
    (`True`, faster) or rows (`False`) is specified by `col_deriv`.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`col_deriv`指定了雅可比矩阵的导数是沿着列（`True`，更快）还是行（`False`）排列。'
- en: If `full_output` is set to `True`, the output contains diagnostics about the
    solution process. This may be useful if errors accumulate and the solution process
    is not successfully completed.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`full_output`设置为`True`，输出将包含关于解算过程的诊断信息。如果错误积累并且解算过程未成功完成，这可能会很有用。
- en: In the last example in this section, we present the Lorenz oscillator, a simplified
    model for atmospheric convection, and a famous equation that displays chaotic
    behavior for certain values of the parameters. We will also use this example to
    demonstrate how to plot solutions in three dimensions.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的最后一个示例中，我们展示了洛伦兹振荡器，这是大气对流的简化模型，也是一个在某些参数值下表现出混沌行为的著名方程。我们还将利用这个示例演示如何在三维空间中绘制解。
- en: 'The Lorenz system is defined by the following equations:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 洛伦兹系统由以下方程定义：
- en: '![Calculus and differential equations](img/8341OS_05_11.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![微积分和微分方程](img/8341OS_05_11.jpg)'
- en: 'We start by defining a Python function representing the system, as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过定义一个表示该系统的Python函数开始，如下所示：
- en: '[PRE35]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The only difference between this system and the previous one is the presence
    of the parameters `sigma`, `rho`, and `beta`. Note that they are just added as
    extra arguments to `ode_func()`. Solving the equation is almost the same as solving
    the previous example:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这个系统与前一个系统的唯一区别在于有了`sigma`、`rho`和`beta`参数。注意，它们只是作为额外的参数添加到`ode_func()`中。求解这个方程几乎与求解前一个示例一样：
- en: '[PRE36]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We define the array of times and the initial condition just as we did in the
    previous example. Notice that since this is a three-dimensional problem, there
    are initial conditions in an array with three components. Then comes the call
    to `odeint()`. The call now has an extra argument:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了时间数组和初始条件，就像在之前的示例中做的那样。请注意，由于这是一个三维问题，因此初始条件是一个包含三个分量的数组。接下来是对`odeint()`的调用。此时调用增加了一个额外的参数：
- en: '[PRE37]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This sets `sigma`, `rho`, and `beta`, respectively, to the values `10`, `28`,
    and `8/3`. These are values that are known to correspond to chaotic solutions.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这将`sigma`、`rho`和`beta`分别设置为`10`、`28`和`8/3`。这些值已知对应于混沌解。
- en: 'The solution can then be plotted with the following code:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 然后可以通过以下代码绘制解决方案：
- en: '[PRE38]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The first three lines of code set up the axes for three-dimensional plotting.
    The next line extracts the data in a format suitable for plotting:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 前三行代码设置了三维绘图的坐标轴。下一行提取了适合绘图的数据格式：
- en: '[PRE39]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This code illustrates a common pattern. The array `sol` contains the coordinates
    of the solutions along its columns, so we transpose the array so that the data
    is along the rows of the array, and then assign each row to one of the variables
    `x`, `y`, and `z`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码展示了一个常见的模式。数组`sol`包含了解决方案的坐标（以列的形式），因此我们将数组转置，使得数据沿数组的行排列，然后将每一行分配给变量`x`、`y`和`z`。
- en: 'The other lines of code are pretty straightforward: we call the `plot()` function
    and then add labels to the axes. The following is the figure that we get as the
    output:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 其他几行代码也很简单：我们调用了`plot()`函数，然后为坐标轴添加标签。以下是我们得到的输出图形：
- en: '![Calculus and differential equations](img/8341OS_05_12.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![微积分和微分方程](img/8341OS_05_12.jpg)'
- en: The preceding image is known as the classical Lorenz butterfly, a striking example
    of a strange attractor.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的图像被称为经典的洛伦兹蝴蝶，是一个奇异吸引子的 striking 示例。
- en: Accelerating computations with Numba and NumbaPro
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Numba和NumbaPro加速计算
- en: In this section, we will discuss `Numba` and `NumbaPro`, two very exciting libraries
    to accelerate the `NumPy` code. `Numba` and `NumbaPro` were created by *Continuum
    Analytics*, the same company that produces the Anaconda distribution. `Numba`
    is part of the standard Anaconda distribution, but `NumbaPro` is a commercial
    product that must be purchased separately as part of the `Accelerate` package.
    However, `NumbaPro` can be downloaded for a free trial period.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 本节我们将讨论`Numba`和`NumbaPro`，这两个非常激动人心的库，用于加速`NumPy`代码。`Numba`和`NumbaPro`由*Continuum
    Analytics*公司创建，后者也生产Anaconda发行版。`Numba`是标准的Anaconda发行版的一部分，但`NumbaPro`是一个商业产品，必须单独购买作为`Accelerate`包的一部分。不过，`NumbaPro`可以免费试用一段时间。
- en: 'These libraries are unique in that they allow the acceleration of code with
    the addition of a few lines of code. As the first example, let''s consider the
    following lines of code to multiply two matrices:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这些库的独特之处在于它们允许通过增加几行代码来加速代码执行。作为第一个示例，我们来看看以下几行代码来乘法两个矩阵：
- en: '[PRE40]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The preceding code uses the straightforward definition of matrix multiplication
    and looks very much like code that would be written if we were implementing the
    algorithm in C. It is not Python-like and definitely not optimized. (In a real-world
    situation, one would simply use the `NumPy` built-in matrix multiplication.) Note,
    in particular, that the dimensions of the matrices are not checked: it is assumed
    that the number of columns of `A` is equal to the number of rows of `B`.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码使用了矩阵乘法的简单定义，看起来就像我们在用C语言实现算法时写的代码。这不是Python风格的代码，显然也没有经过优化。（在实际情况中，通常会直接使用`NumPy`的内置矩阵乘法。）特别需要注意的是，矩阵的维度并未进行检查：假设`A`的列数等于`B`的行数。
- en: 'Let''s first try the computation with small matrices, as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 首先让我们尝试使用小矩阵进行计算，如下所示：
- en: '[PRE41]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We start by defining the matrices `A` and `B` (note that the dimensions are
    compatible for multiplication). As in all examples in this section, we are careful
    to include a data type specification (this may improve optimization). Then, we
    simply call `matrix_multiply`, store the result in the array `C`, and print the
    three matrices. The result is the following:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义矩阵`A`和`B`（注意它们的维度是兼容相乘的）。与本节中的所有示例一样，我们小心地指定了数据类型（这可能有助于优化）。然后，我们简单地调用`matrix_multiply`，将结果存储在数组`C`中，并打印这三个矩阵。结果如下所示：
- en: '[PRE42]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'You can verify that the algorithm is correct by manually checking a few entries.
    Alternatively, we can check whether the result agrees with the built-in matrix
    multiplication, as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过手动检查几个条目来验证算法的正确性。或者，我们也可以检查结果是否与内置的矩阵乘法一致，如下所示：
- en: '[PRE43]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Everything seems to be fine. Now, we want to define some larger random matrices,
    as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 一切看起来都很好。现在，我们希望定义一些更大的随机矩阵，如下所示：
- en: '[PRE44]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'In a 64-bit architecture, the preceding lines of code will automatically produce
    matrices of 64-bit floats. Next, we multiply the matrices and time the result
    as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在64位架构下，前面的代码行会自动生成64位浮点数矩阵。接下来，我们将矩阵相乘并计时，如下所示：
- en: '[PRE45]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The output of the preceding computation is as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 上述计算的输出结果如下：
- en: '[PRE46]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The timing results will, of course, differ depending on the machine running
    the code. This example was run on an Intel Core i7 processor at 3.5 GHz with 16
    GB of memory running a Microsoft Windows 7, 64-bit operating system.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 计时结果当然会因运行代码的机器而异。此示例在运行 Microsoft Windows 7 64 位操作系统的 Intel Core i7 处理器，主频为
    3.5 GHz，内存为 16 GB 的计算机上运行。
- en: 'Let''s now see how we can quickly optimize this function. First, load the `jit`
    function from the `Numba` module, as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何快速优化这个函数。首先，从`Numba`模块加载`jit`函数，如下所示：
- en: '[PRE47]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Then, define the function with the `@jit` decorator preceding it, as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，定义带有`@jit`装饰器的函数，如下所示：
- en: '[PRE48]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Note that the only change to the code is the addition of the decorator. (We
    also changed the name of the function to avoid confusion, but this is not necessary.)
    Decorators are an advanced Python topic, but we do not need to go into the details
    of how they work. More information about decorators is available in the excellent
    blog postings by Simeon Franklin at [http://simeonfranklin.com/blog/2012/jul/1/python-decorators-in-12-steps/](http://simeonfranklin.com/blog/2012/jul/1/python-decorators-in-12-steps/).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，代码中唯一的更改是添加装饰器。（我们还更改了函数的名称以避免混淆，但这并非必要。）装饰器是一个高级的 Python 主题，但我们不需要深入讨论它们的工作原理。有关装饰器的更多信息，请参考
    Simeon Franklin 在[http://simeonfranklin.com/blog/2012/jul/1/python-decorators-in-12-steps/](http://simeonfranklin.com/blog/2012/jul/1/python-decorators-in-12-steps/)上的优秀博客文章。
- en: 'Let''s now time our code, as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们计时我们的代码，如下所示：
- en: '[PRE49]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The following is the resultant output:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是结果输出：
- en: '[PRE50]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'This is a 260-fold improvement with a single line of code! You should keep
    things in perspective here since this kind of acceleration cannot be expected
    for generic code. Remember that we wrote our code purposefully in a way that does
    not use the already-optimized functions from `NumPy`. For the sake of comparison
    and full disclosure, let''s compare this with the built-in `dot()` method:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一行代码实现的 260 倍改进！在这里应该保持适度的观点，因为这种加速不能期望适用于通用代码。请记住，我们故意编写代码，不使用`NumPy`中已经优化过的函数。为了比较和充分披露，让我们将其与内置的`dot()`方法进行比较：
- en: '[PRE51]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The resultant output is as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 结果输出如下：
- en: '[PRE52]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: So, even with acceleration, our function cannot compete with built-in `NumPy`.
    We emphasize again that the goal of this section is to present an overview of
    acceleration techniques and not delve deeply into sophisticated optimization methods.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，即使加速了，我们的函数也无法与内置的`NumPy`竞争。我们再次强调，本节的目标是介绍加速技术的概述，而不是深入探讨复杂的优化方法。
- en: It is worth having some understanding of how the `@jit` decorator works. When
    a function decorated by `@jit` is called, the library attempts to infer the data
    type of the arguments and return value, and on the fly produces a compiled version
    of the function and then calls it. The result is a function call that is comparable
    to code written in C.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 了解`@jit`装饰器的工作原理是值得的。当调用由`@jit`装饰的函数时，库会尝试推断参数和返回值的数据类型，并动态生成函数的编译版本，然后调用它。结果是一个类似于用
    C 编写的代码的函数调用。
- en: 'Instead of letting the type of arguments and return value be inferred, it is
    possible to specify the data types, which may result in improved performance.
    The following table consists of the data types supported and the abbreviations
    used by `Numba`:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 可以指定数据类型，而不是让参数和返回值的类型被推断，这可能会提高性能。以下表格列出了`Numba`支持的数据类型及其缩写：
- en: '| Data type | Abbreviation |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: 数据类型 | 缩写 |
- en: '| --- | --- |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `boolean` | `b1` |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| `boolean` | `b1` |'
- en: '| `bool_` | `b1` |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| `bool_` | `b1` |'
- en: '| `byte` | `u1` |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| `byte` | `u1` |'
- en: '| `uint8` | `u1` |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| `uint8` | `u1` |'
- en: '| `uint16` | `u2` |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| `uint16` | `u2` |'
- en: '| `uint32` | `u4` |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| `uint32` | `u4` |'
- en: '| `uint64` | `u8` |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| `uint64` | `u8` |'
- en: '| `char` | `i1` |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| `char` | `i1` |'
- en: '| `int8` | `i1` |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| `int8` | `i1` |'
- en: '| `int16` | `i2` |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| `int16` | `i2` |'
- en: '| `int32` | `i4` |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| `int32` | `i4` |'
- en: '| `int64` | `i8` |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| `int64` | `i8` |'
- en: '| `float_` | `f4` |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| `float_` | `f4` |'
- en: '| `float32` | `f4` |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| `float32` | `f4` |'
- en: '| `double` | `f8` |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| `double` | `f8` |'
- en: '| `float64` | `f8` |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| `float64` | `f8` |'
- en: '| `complex64` | `c8` |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| `complex64` | `c8` |'
- en: '| `complex128` | `c16` |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| `complex128` | `c16` |'
- en: 'These names are all defined in the `Numba` module. For example, to define a
    function that adds two floating-point values, we use the following code:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些名称都在`Numba`模块中定义。例如，要定义一个将两个浮点值相加的函数，我们使用以下代码：
- en: '[PRE53]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Note the decorator syntax, which is as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 注意装饰器语法，如下所示：
- en: '[PRE54]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'This specifies a function that takes two `float64` arguments and returns a
    `float64` value. The function is then called, as follows:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这指定了一个接受两个 `float64` 参数并返回一个 `float64` 值的函数。然后，函数按如下方式调用：
- en: '[PRE55]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'This produces the expected result. However, if we try something like the following
    code, we get an error:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生预期的结果。然而，如果我们尝试类似以下代码，我们会遇到错误：
- en: '[PRE56]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'It is, however, possible to use arrays with the `@jit` decorator. To define
    a function that adds two one-dimensional arrays, one would use the following lines
    of code:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用 `@jit` 装饰器可以使用数组。要定义一个将两个一维数组相加的函数，可以使用以下代码行：
- en: '[PRE57]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Note how a vector is specified. A two-dimensional array is denoted by `f8[:,:]`,
    a three-dimensional array by `f8[:,:,:]`, and so on.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 注意如何指定向量。二维数组表示为 `f8[:,:]`，三维数组表示为 `f8[:,:,:]`，以此类推。
- en: '`NumbaPro` is the commercial version of `Numba` and adds several enhancements.
    We will focus on parallel processing using the **Graphics Processing Unit** (**GPU**)
    as an example of an exciting new technology that is made easily available in a
    notebook.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`NumbaPro` 是 `Numba` 的商业版，并增加了多个增强功能。我们将重点讨论使用**图形处理单元**（**GPU**）作为示例，进行并行处理，这是一个激动人心的新技术，现已轻松应用于笔记本中。'
- en: To run the examples that follow, the reader must have `NumbaPro`, a `CUDA`-compatible
    GPU (henceforth called the "device"), and the latest `CUDA`-compatible driver.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行以下示例，读者必须拥有 `NumbaPro`、`CUDA` 兼容的 GPU（以下简称“设备”）以及最新的 `CUDA` 兼容驱动程序。
- en: A list of `CUDA`-compatible devices can be found at [https://developer.nvidia.com/cuda-gpus](https://developer.nvidia.com/cuda-gpus).
    After verifying that you have a compatible device, download and install the latest
    version of the `CUDA SDK` from [https://developer.nvidia.com/cuda-downloads](https://developer.nvidia.com/cuda-downloads)
    for the appropriate platform. The `CUDA` toolkit comes with several examples that
    you can use to test the installation.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`CUDA` 兼容设备的列表可以在[https://developer.nvidia.com/cuda-gpus](https://developer.nvidia.com/cuda-gpus)找到。验证您的设备兼容性后，请从[https://developer.nvidia.com/cuda-downloads](https://developer.nvidia.com/cuda-downloads)下载并安装适合平台的最新版本
    `CUDA SDK`。`CUDA` 工具包附带了一些示例，您可以使用这些示例来测试安装情况。'
- en: The `NumbaPro` download is available at [https://store.continuum.io/cshop/accelerate/](https://store.continuum.io/cshop/accelerate/).
    Download and install the `Accelerate` library.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`NumbaPro` 下载可以通过[https://store.continuum.io/cshop/accelerate/](https://store.continuum.io/cshop/accelerate/)获得。下载并安装
    `Accelerate` 库。'
- en: 'To test the setup, start an IPython notebook and run the following in a cell:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试设置，启动一个 IPython 笔记本，并在单元格中运行以下内容：
- en: '[PRE58]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: If everything is fine, this will print a list of the `CUDA` libraries installed
    by Anaconda as well as a list of the `CUDA`-compatible devices available in your
    system. You will also see a `PASSED` message at the end of the display.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切正常，系统将打印出由 Anaconda 安装的 `CUDA` 库的列表以及系统中可用的 `CUDA` 兼容设备的列表。您还会看到显示末尾的 `PASSED`
    消息。
- en: Even though `CUDA` programming is a relatively easy path to massive parallelism,
    there are still some concepts that have to be mastered before we can tackle our
    first `CUDA` program. We will outline the basics of the architecture here, discussing
    only enough to run the examples that follow. For a complete specification, see
    the **CUDA Programming Guide**, available at [http://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#programming-model](http://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#programming-model).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 `CUDA` 编程是通向大规模并行计算的相对简单路径，但在我们开始第一个 `CUDA` 程序之前，仍然需要掌握一些概念。我们将在此简要概述架构的基础内容，只讨论足够运行后续示例的内容。有关完整规格，请参见**CUDA
    编程指南**，该指南可通过[http://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#programming-model](http://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#programming-model)获得。
- en: GPUs were originally designed to process rendering operations with greater speed
    than the computer's CPU is capable of. This processing acceleration is achieved,
    in large measure, by massively parallelizing the graphical operations required
    by the rendering pipeline.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: GPU 最初是为比计算机的 CPU 更快速地处理渲染操作而设计的。这种处理加速在很大程度上是通过大规模并行化渲染管道所需的图形操作来实现的。
- en: A `CUDA`-compatible GPU consists of an array of **Streaming Multiprocessors**
    (**SMs**). Each one of the SMs, by itself, cannot compete with current CPUs in
    terms of speed. However, the fact that many SMs can cooperate to solve a problem
    more than compensates for that. The SMs can also access memory that resides in
    the GPU, referred to as *device memory*.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`CUDA`兼容的GPU由一组**流多处理器**（**SMs**）组成。每个SM本身无法与当前的CPU在速度上竞争。然而，多个SM能够合作解决问题，这一点弥补了这一不足。SM还可以访问GPU中的内存，这部分内存称为*设备内存*。
- en: 'In `CUDA`, there is a strict separation between code that runs in the CPU and
    code that runs in the device (the GPU). One particular restriction is that while
    CPU code can only access regular computer memory, device code can only access
    device memory. Code that runs in the device is specified in a function called
    a *kernel*. The kernel is compiled into a low-level language that is understood
    by the SMs and runs into each SM asynchronously (meaning that each SM proceeds
    at its own pace unless special synchronization instructions are found). Thus,
    a simple computation in `CUDA` usually requires the following three steps:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在`CUDA`中，运行在CPU中的代码和运行在设备（GPU）中的代码有严格的分离。一个特别的限制是，CPU代码只能访问常规计算机内存，而设备代码只能访问设备内存。运行在设备中的代码被指定在一个名为*内核*的函数中。内核被编译成SM可以理解的低级语言，并异步地运行在每个SM中（意味着每个SM按照自己的节奏运行，除非遇到特殊的同步指令）。因此，`CUDA`中的简单计算通常需要以下三个步骤：
- en: Transfer input data from the computer memory to the device memory.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将输入数据从计算机内存传输到设备内存。
- en: Launch the kernel in the device.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设备中启动内核。
- en: Transfer output data from the device memory to the computer memory so that it
    is accessible to the CPU again.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将设备内存中的输出数据传输到计算机内存，以便CPU能够再次访问它。
- en: As you will see, the memory transfers are made transparent by Python `CUDA`.
    (There is still the possibility to control it programmatically if needed.)
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你将看到的，Python `CUDA`使内存传输变得透明。（如果需要，仍然可以通过编程方式控制它。）
- en: The kernel is launched simultaneously in an array of SMs, and each thread proceeds
    independently with the computation. Each SM can run several threads in parallel
    and can access all the device's memory. (The architecture is more complicated,
    and there are other kinds of memory available that will not be discussed here.)
    In the simplest case, each thread will access only a few memory areas, each containing
    a 64-bit floating value, and the memory accessed by a thread is never accessed
    by any other thread. So, there is no need for synchronization. In more complex
    problems, synchronization may be a major issue.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 内核同时在一组SM中启动，每个线程独立进行计算。每个SM可以并行运行多个线程，并且可以访问设备的所有内存。（架构更为复杂，还有其他类型的内存可用，这里不作讨论。）在最简单的情况下，每个线程只访问几个内存区域，每个区域包含一个64位浮动值，而且线程访问的内存不会被其他线程访问。因此，无需同步。在更复杂的问题中，同步可能成为一个主要问题。
- en: 'The set of threads being run features a two-level array structure:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 正在运行的线程集合具有二级数组结构：
- en: 'Threads are organized in **blocks**. Each block is an array of threads with
    up to `3` dimensions The dimensions of a block are stored in a variable called
    `blockDim`. Threads in a block are identified by the variable, `threadIdx`. This
    is a structure with three integer fields: `threadIdx.x`, `threadIdx.y`, and `threadIdx.z`.
    These fields uniquely identify each thread in the block.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程按**块**组织。每个块是一个最多具有`3`个维度的线程数组。块的维度存储在一个名为`blockDim`的变量中。块中的线程由变量`threadIdx`标识。这是一个具有三个整数字段的结构：`threadIdx.x`、`threadIdx.y`和`threadIdx.z`。这些字段唯一标识块中的每个线程。
- en: 'Blocks are organized in a **grid**. The grid is an array of blocks with up
    to `3` dimensions. The dimensions of the grid are stored in a variable called
    `gridDim`. Blocks in a grid are identified by the variable, `gridIdx`. This is
    a structure with three integer fields: `gridIdx.x`, `gridIdx.y`, and `gridIdx.z`.
    These fields uniquely identify each block in the grid.'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 块按**网格**组织。网格是一个最多具有`3`个维度的块数组。网格的维度存储在一个名为`gridDim`的变量中。网格中的块由变量`gridIdx`标识。这是一个具有三个整数字段的结构：`gridIdx.x`、`gridIdx.y`和`gridIdx.z`。这些字段唯一标识网格中的每个块。
- en: 'An example of this organizational structure is given in the following figure:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图给出了这种组织结构的一个示例：
- en: '![Accelerating computations with Numba and NumbaPro](img/8341OS_05_13.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![使用Numba和NumbaPro加速计算](img/8341OS_05_13.jpg)'
- en: 'In the preceding example, `gridDim` is `(2, 3, 1)` since there are two rows
    and three columns of blocks (and a single space dimension). All the blocks in
    the grid are one-dimensional, so `blockDim` is `(4, 1, 1)`. The third thread in
    the first block of the bottom row, for example, is identified by the following
    lines of code:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`gridDim`是`(2, 3, 1)`，因为有两行三列的块（以及一个单独的空间维度）。网格中的所有块都是一维的，所以`blockDim`是`(4,
    1, 1)`。例如，底部行中第一个块中的第三个线程由以下代码行标识：
- en: '[PRE59]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: At runtime, each individual thread has access to this identifying information.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时，每个线程都可以访问这些标识信息。
- en: 'A key point of the `CUDA` architecture is the following:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`CUDA`架构的一个关键点如下：'
- en: All threads in the same block always run concurrently in a single SM until all
    threads in the block have terminated
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同一块中的所有线程始终在一个SM中并行执行，直到块中的所有线程都执行完毕
- en: Different blocks can run concurrently or serially depending on the availability
    of an SM to carry out the computation
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同的块可以根据SM的可用性并行或串行执行计算
- en: 'We are now ready to define the kernel using Python `CUDA`. We will write a
    function that computes the sum of two vectors in the GPU. Run the following code
    in a cell:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备使用Python `CUDA`定义内核。我们将编写一个函数，在GPU中计算两个向量的和。在一个单元格中运行以下代码：
- en: '[PRE60]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: We assume that there is only one block of threads, and each thread is responsible
    for adding the elements of the array at a single position. The array position
    that a thread is responsible for is identified by the value of `threadIdx.x`.
    Note that the kernel has no return value. We need to specify an array, `result`,
    to hold the return value of the computation.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设只有一个线程块，每个线程负责在单个位置添加数组的元素。线程负责的数组位置由`threadIdx.x`的值确定。请注意，内核没有返回值。我们需要指定一个数组`result`，用于存储计算的返回值。
- en: 'Let''s now see how this function is called. Note that the grid and block geometry
    is not defined in the kernel. (The kernel can obtain geometry information if necessary;
    more on that later.) This is done when the kernel is launched:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看这个函数是如何被调用的。请注意，网格和块的几何形状并没有在内核中定义。（如果需要，内核可以获取几何信息；稍后会详细讲解。）这在启动内核时完成：
- en: '[PRE61]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The preceding lines of code give the following output:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码行给出了以下输出：
- en: '[PRE62]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The main point in this code is the following line:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的关键点在于以下这一行：
- en: '[PRE63]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The preceding line launches the kernel in a grid with `1` block, with `5` threads
    in the block. Both the grid and the blocks are one-dimensional. Let''s now add
    larger vectors:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码行在一个包含`1`个块、每个块包含`5`个线程的网格中启动内核。网格和块都是一维的。现在让我们添加更大的向量：
- en: '[PRE64]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The preceding lines of code are essentially the same as before but a little
    more generic in that the size of the array can be changed. What we want to do
    is increase the size of `n`. If you try a value such as `n=10000`, an error of
    type `CUDA_ERROR_INVALID_VALUE` occurs. The problem is that there is a hard limit
    on the number of threads that can be run by a single SM, that is, there is a limit
    to the number of threads that can be executed in a single block. To be able to
    handle large vectors, we need to modify the code so that it can handle multiple
    blocks. To this end, change the definition of the `sum()` function in the following
    way:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码行本质上与之前的代码相同，只是稍微通用了一些，因为数组的大小可以变化。我们想要做的是增加`n`的大小。如果你尝试使用`n=10000`这样的值，将会出现`CUDA_ERROR_INVALID_VALUE`类型的错误。问题在于单个SM可以运行的线程数是有限的，也就是说，单个块中可以执行的线程数有限。为了处理更大的向量，我们需要修改代码，使其能够处理多个块。为此，请以以下方式修改`sum()`函数的定义：
- en: '[PRE65]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The first thing to note is that we include an argument of type `int32` to hold
    the size of the arrays being added. The main point now is that threads in different
    blocks must address different areas of memory, so the computation of the index
    `i` associated to a thread is more complicated. Essentially, we must know the
    number of blocks that come before the current block, multiply that by the block
    dimension, and add the current thread index. Then, before adding the relevant
    memory positions, we check if the index is valid. This prevents the thread from
    accessing areas that are not part of the input/output arrays and is an essential
    check in more complex code. To test the code, run the following:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 首先需要注意的是，我们包含了一个类型为`int32`的参数，用于保存正在加法的数组的大小。现在的重点是，位于不同块中的线程必须访问不同的内存区域，因此计算与线程相关联的索引`i`变得更加复杂。本质上，我们必须知道当前块之前有多少个块，然后将其乘以块的维度，并加上当前线程的索引。然后，在访问相关的内存位置之前，我们会检查索引是否有效。这可以防止线程访问不属于输入/输出数组的区域，并且是更复杂代码中一个至关重要的检查。要测试代码，请运行以下内容：
- en: '[PRE66]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The preceding code should run without a hitch. Note that we are specifying a
    grid with `1000` blocks and `64` threads per block. The number of blocks in a
    grid is unlimited, the device being responsible for allocating the SMs in an optimal
    way. Note that the number of blocks must be large enough to cover the input/output
    arrays. In our case, this means `blockDim.x * gridDim.x >= n`.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码应该可以顺利运行。请注意，我们指定了一个包含`1000`个块且每个块有`64`个线程的网格。网格中的块数是无限制的，设备负责以最佳方式分配SM。请注意，块数必须足够大，以覆盖输入/输出数组。在我们的例子中，这意味着`blockDim.x
    * gridDim.x >= n`。
- en: 'We are now ready to compute with large vectors. Try the following code:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以开始使用大向量进行计算。试试下面的代码：
- en: '[PRE67]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The reader should experiment with different values of `n`, `bd`, and `gd`. Remember
    that the maximum value of `gd` depends on the device in your computer. An interesting
    experiment is to check how the computation scales for larger values of `n`.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 读者应尝试不同的`n`、`bd`和`gd`值。请记住，`gd`的最大值取决于你电脑中的设备。一个有趣的实验是检查计算在更大`n`值下的扩展性。
- en: Summary
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we covered the use of advanced mathematical algorithms in `SciPy`,
    including solving equations and finding optimal values, integration, and differential
    equations. The chapter concluded with a discussion on using parallelization in
    the GPU to accelerate computations.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们介绍了在`SciPy`中使用高级数学算法，包括解方程、寻找最优值、积分和微分方程。本章最后讨论了如何利用GPU并行化来加速计算。
