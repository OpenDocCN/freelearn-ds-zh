- en: Structures That Work
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有效的结构
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Using geospatial views
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用地理空间视图
- en: Using triggers to populate the geometry column
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用触发器填充几何列
- en: Structuring spatial data with table inheritance
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用表继承结构化空间数据
- en: Extending inheritance – table partitioning
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展继承 – 表分区
- en: Normalizing imports
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准化导入
- en: Normalizing internal overlays
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准化内部叠加
- en: Using polygon overlays for proportional census estimates
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用多边形叠加进行比例人口估计
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: 'This chapter focuses on ways to structure data using the functionality provided
    by the combination of PostgreSQL and PostGIS. These will be useful approaches
    for structuring and cleaning up imported data, converting tabular data into spatial
    data *on the fly* when it is entered, and maintaining relationships between tables
    and datasets using functionality endemic to the powerful combination of PostgreSQL
    and PostGIS. There are three categories of techniques with which we will leverage
    these functionalities: automatic population and modification of data using views
    and triggers, object orientation using PostgreSQL table inheritance, and using
    PostGIS functions (stored procedures) to reconstruct and normalize problematic
    data.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点介绍使用 PostgreSQL 和 PostGIS 功能组合提供的数据结构化方法。这些方法对于结构化和清理导入数据、在输入时将表格数据“即时”转换为空间数据以及使用
    PostgreSQL 和 PostGIS 强大组合的功能维护表和数据集之间的关系非常有用。我们将利用这些功能的三个技术类别：使用视图和触发器自动填充和修改数据、使用
    PostgreSQL 表继承进行面向对象，以及使用 PostGIS 函数（存储过程）重建和标准化有问题的数据。
- en: Automatic population of data is where the chapter begins. By leveraging PostgreSQL
    views and triggers, we can create ad hoc and flexible solutions to create connections
    between and within the tables. By extension, and for more formal or structured
    cases, PostgreSQL provides table inheritance and table partitioning, which allow
    for explicit hierarchical relationships between tables. This can be useful in
    cases where an object inheritance model enforces data relationships that either
    represent the data better, thereby resulting in greater efficiencies, or reduce
    the administrative overhead of maintaining and accessing the datasets over time.
    With PostGIS extending that functionality, the inheritance can apply not just
    to the commonly used table attributes, but to leveraging spatial relationships
    between tables, resulting in greater query efficiency with very large datasets.
    Finally, we will explore PostGIS SQL patterns that provide table normalization
    of data inputs, so datasets that come from flat filesystems or are not normalized
    can be converted to a form we would expect in a database.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 自动填充数据是本章的开始。通过利用 PostgreSQL 视图和触发器，我们可以创建灵活的解决方案，在表之间和表中创建连接。通过扩展，对于更正式或结构化的案例，PostgreSQL
    提供了表继承和表分区，这允许在表之间显式地建立层次关系。这在对象继承模型强制数据关系以更好地表示数据、从而提高效率或减少随着时间的推移维护和访问数据集的行政负担的情况下非常有用。通过
    PostGIS 扩展该功能，继承不仅适用于常用的表属性，还适用于利用表之间的空间关系，从而在非常大的数据集上实现更高的查询效率。最后，我们将探讨 PostGIS
    SQL 模式，它提供了数据输入的表标准化，因此来自平面文件系统或未标准化的数据集可以转换为我们在数据库中期望的形式。
- en: Using geospatial views
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用地理空间视图
- en: Views in PostgreSQL allow the ad hoc representation of data and data relationships
    in alternate forms. In this recipe, we'll be using views to allow for the automatic
    creation of point data based on tabular inputs. We can imagine a case where the
    input stream of data is non-spatial, but includes longitude and latitude or some
    other coordinates. We would like to automatically show this data as points in
    space.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: PostgreSQL中的视图允许以不同的形式表示数据和数据关系。在本例中，我们将使用视图来允许基于表格输入自动创建点数据。我们可以想象一个案例，其中数据输入流是非空间数据，但包括经纬度或其他坐标。我们希望自动将此数据作为空间中的点显示。
- en: Getting ready
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We can create a view as a representation of spatial data pretty easily. The
    syntax for creating a view is similar to creating a table, for example:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以非常容易地创建一个视图来表示空间数据。创建视图的语法与创建表类似，例如：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding command line, our `SELECT` query manipulates the data for us.
    Let's start with a small dataset. In this case, we will start with some random
    points, which could be real data.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的命令行中，我们的 `SELECT` 查询为我们操作数据。让我们从一个小的数据集开始。在这种情况下，我们将从一些随机点开始，这些点可能是真实数据。
- en: 'First, we create the table from which the view will be constructed, as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个表，视图将从该表构建，如下所示：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, let''s populate this with the data for testing using the following query:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用以下查询用测试数据填充它：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: How to do it...
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Now, to create the view, we will use the following query:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要创建视图，我们将使用以下查询：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: How it works...
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Our view is really a simple transformation of the existing data using PostGIS's
    `ST_MakePoint` function. The `ST_MakePoint` function takes the input of two numbers
    to create a PostGIS point, and in this case our view simply uses our *x* and *y*
    values to populate the data. Any time there is an update to the table to add a
    new record with *x* and *y* values, the view will populate a point, which is really
    useful for data that is constantly being updated.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的视图实际上是对现有数据进行简单转换的结果，使用PostGIS的`ST_MakePoint`函数。`ST_MakePoint`函数接受两个数字作为输入以创建一个PostGIS点，在这种情况下，我们的视图简单地使用我们的*x*和*y*值来填充数据。每当表中更新以添加包含*x*和*y*值的新记录时，视图将填充一个点，这对于不断更新的数据非常有用。
- en: There are two disadvantages to this approach. The first is that we have not
    declared our spatial reference system in the view, so any software consuming these
    points will not know the coordinate system we are using, that is, whether it is
    a geographic (latitude/longitude) or a planar coordinate system. We will address
    this problem shortly. The second problem is that many software systems accessing
    these points may not automatically detect and use the spatial information from
    the table. This problem is addressed in the *Using triggers to populate the geometry
    column* recipe.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法有两个缺点。第一个缺点是我们没有在视图中声明我们的空间参考系统，因此任何消费这些点的软件将不知道我们使用的坐标系，即它是地理坐标系（纬度/经度）还是平面坐标系。我们将很快解决这个问题。第二个问题是许多访问这些点的软件系统可能不会自动检测并使用表中的空间信息。这个问题在*使用触发器填充几何列*食谱中得到了解决。
- en: The **spatial reference system identifier** (**SRID**) allows us to specify
    the coordinate system for a given dataset. The numbering system is a simple integer
    value to specify a given coordinate system. SRIDs are derived originally from
    the **European Petroleum Survey Group** (**EPSG**) and are now maintained by the
    Surveying and Positioning Committee of the International Association of **Oil
    and Gas Producers** (**OGP**). Useful tools for SRIDs are spatial reference ([http://spatialreference.org](http://spatialreference.org))
    and Prj2EPSG ([http://prj2epsg.org/search](http://prj2epsg.org/search)).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**空间参考系统标识符**（**SRID**）允许我们指定给定数据集的坐标系。编号系统是一个简单的整数值，用于指定一个特定的坐标系。SRIDs最初来源于**欧洲石油调查组**（**EPSG**），现在由**油气生产者国际协会**（**OGP**）的测绘与定位委员会维护。用于SRID的有用工具是空间参考([http://spatialreference.org](http://spatialreference.org))和Prj2EPSG([http://prj2epsg.org/search](http://prj2epsg.org/search))。'
- en: There's more...
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'To address the first problem mentioned in the *How it works...* section, we
    can simply wrap our existing `ST_MakePoint` function in another function specifying
    the SRID as `ST_SetSRID`, as shown in the following query:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决*如何工作...*部分中提到的第一个问题，我们可以简单地用另一个指定SRID为`ST_SetSRID`的函数包装现有的`ST_MakePoint`函数，如下面的查询所示：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: See also
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The *Using triggers to populate the geometry column* recipe
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用触发器填充几何列*的食谱'
- en: Using triggers to populate the geometry column
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用触发器填充几何列
- en: In this recipe, we imagine that we have ever increasing data in our database,
    which needs spatial representation; however, in this case we want a hardcoded
    geometry column to be updated each time an insertion happens on the database,
    converting our *x* and *y* values to geometry as and when they are inserted into
    the database.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们假设我们的数据库中数据不断增加，需要空间表示；然而，在这种情况下，我们希望硬编码的几何列在数据库上每次插入时更新，将*x*和*y*值转换为几何形状，就像它们被插入到数据库中一样。
- en: The advantage of this approach is that the geometry is then registered in the
    `geometry_columns` view, and therefore this approach works reliably with more
    PostGIS client types than creating a new geospatial view. This also provides the
    advantage of allowing for a spatial index that can significantly speed up a variety
    of queries.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的优势是，几何形状随后被注册在`geometry_columns`视图中，因此这种方法比创建新的地理空间视图与更多的PostGIS客户端类型更可靠。这也提供了允许进行空间索引的优势，这可以显著加快各种查询的速度。
- en: Getting ready
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We will start by creating another table of random points with `x`, `y`, and
    `z` values, as shown in the following query:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建另一个包含 `x`、`y` 和 `z` 值的随机点表格，如下查询所示：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How to do it...
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Now we need a geometry column to populate. By default, the geometry column
    will be populated with null values. We populate a geometry column using the following
    query:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要一个几何列来填充。默认情况下，几何列将填充为空值。我们使用以下查询来填充几何列：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We now have a column called `geom` with an SRID of `3734`; that is, a point
    geometry type in two dimensions. Since we have `x`, `y`, and `z` data, we could,
    in principle, populate a 3D point table using a similar approach.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个名为 `geom` 的列，其 SRID 为 `3734`；即二维的点几何类型。由于我们有 `x`、`y` 和 `z` 数据，原则上我们可以使用类似的方法填充一个
    3D 点表。
- en: 'Since all the geometry values are currently null, we will populate them using
    an `UPDATE` statement as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有几何值目前都是空值，我们将使用以下 `UPDATE` 语句来填充它们：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The query here is simple when broken down. We update the `xwhyzed1` table and
    set the `the_geom` column using `ST_MakePoint`, construct our point using the
    `x` and `y` columns, and wrap it in an `ST_SetSRID` function in order to apply
    the appropriate spatial reference information. So far, we have just set the table
    up. Now, we need to create a trigger in order to continue to populate this information
    once the table is in use. The first part of the trigger is a new populated geometry
    function using the following query:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当分解查询时，这里很简单。我们更新 `xwhyzed1` 表并使用 `ST_MakePoint` 设置 `the_geom` 列，使用 `x` 和 `y`
    列构建我们的点，并将其包裹在 `ST_SetSRID` 函数中，以便应用适当的空间参考信息。到目前为止，我们只是设置了表格。现在，我们需要创建一个触发器，以便在表格使用时继续填充这些信息。触发器的第一部分是使用以下查询的新填充几何函数：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In essence, we have created a function that does exactly what we did manually:
    update the table''s geometry column with the combination of `ST_SetSRID` and `ST_MakePoint`,
    but only to the new registers being inserted, and not to all the table.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 实质上，我们创建了一个函数，它正好做了我们手动做的事情：使用 `ST_SetSRID` 和 `ST_MakePoint` 的组合更新表的几何列，但只更新新插入的注册，而不是整个表。
- en: There's more...
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多...
- en: 'While we have a function created, we have not yet applied it as a trigger to
    the table. Let us do that here as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们已经创建了一个函数，但我们还没有将其作为触发器应用到表格上。让我们在这里按照以下步骤进行：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let''s assume that the general geometry column update has not taken place yet,
    then the original five registers still have their geometry column in `null`. Now,
    once the trigger has been activated, any inserts into our table should be populated
    with new geometry records. Let us do a test insert using the following query:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一般的几何列更新尚未发生，那么原始的五个注册仍然在其几何列中为 `null`。现在，一旦触发器被激活，任何插入到我们的表中的数据都应该包含新的几何记录。让我们使用以下查询进行测试插入：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Check the rows to verify that the `geom` columns are updated with the command:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令检查行以验证 `geom` 列是否已更新：
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Or use `pgAdmin`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 或者使用 `pgAdmin`：
- en: '![](img/228a3c05-cbc1-4e11-b229-dcf0370c8e88.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/228a3c05-cbc1-4e11-b229-dcf0370c8e88.png)'
- en: 'After applying the general update, then all the registers will have a value
    on their `geom` column:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用一般更新后，所有注册的 `geom` 列都将有一个值：
- en: '![](img/36e423c6-31fa-4611-9106-9608a6658827.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/36e423c6-31fa-4611-9106-9608a6658827.png)'
- en: Extending further...
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步扩展...
- en: So far, we've implemented an `insert` trigger. What if the value changes for
    a particular row? In that case, we will require a separate update trigger. We'll
    change our original function to test the `UPDATE` case, and we'll use `WHEN` in
    our trigger to constrain updates to the column being changed.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经实现了一个 `insert` 触发器。如果特定行的值发生变化怎么办？在这种情况下，我们将需要一个单独的更新触发器。我们将更改我们的原始函数以测试
    `UPDATE` 的情况，并在我们的触发器中使用 `WHEN` 来约束对更改的列的更新。
- en: 'Also, note that the following function is written with the assumption that
    the user wants to always update the changing geometries based on the changing
    values:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，以下函数是基于用户希望始终根据变化值更新几何形状的假设编写的：
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: See also
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The *Using geospatial views* recipe
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用地理空间视图* 的配方'
- en: Structuring spatial data with table inheritance
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用表继承结构化空间数据
- en: 'An unusual and useful property of the PostgreSQL database is that it allows
    for object inheritance models as they apply to tables. This means that we can
    have parent/child relationships between tables and leverage that to structure
    the data in meaningful ways. In our example, we will apply this to hydrology data.
    This data can be points, lines, polygons, or more complex structures, but they
    have one commonality: they are explicitly linked in a physical sense and inherently
    related; they are all about water. Water/hydrology is an excellent natural system
    to model this way, as our ways of modeling it spatially can be quite mixed depending
    on scales, details, the data collection process, and a host of other factors.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: PostgreSQL数据库的一个不寻常且有用的特性是它允许对象继承模型，这些模型适用于表。这意味着我们可以在表之间建立父子关系，并利用这一点以有意义的方式组织数据。在我们的例子中，我们将此应用于水文数据。这些数据可以是点、线、多边形或更复杂的结构，但它们有一个共同点：它们在物理上是明确链接的，并且本质上相关；它们都与水有关。水/水文是一个非常好的自然系统，可以以这种方式进行建模，因为我们对它的空间建模方式可以根据比例、细节、数据收集过程以及许多其他因素而大相径庭。
- en: Getting ready
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备中
- en: The data we will be using is hydrology data that has been modified from engineering
    *blue lines* (see the following screenshot), that is, hydrologic data that is
    very detailed and is meant to be used at scales approaching 1:600\. The data in
    its original application aided, as breaklines, in detailed digital terrain modeling.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要使用的数据是经过修改的工程*蓝线*（见以下截图）的水文数据，即非常详细且旨在用于接近1:600比例尺的数据。在原始应用中，这些数据作为断线，有助于详细的数字地形建模。
- en: '![](img/dee607cd-b195-44a2-b68f-d00ab45c69bd.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/dee607cd-b195-44a2-b68f-d00ab45c69bd.png)'
- en: 'While useful in itself, the data was further manipulated, separating the linear
    features from area features, with additional polygonization of the area features,
    as shown in the following screenshot:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然本身很有用，但这些数据还进一步被操作，将线性特征与区域特征分开，并对区域特征进行了额外的多边形化，如下面的截图所示：
- en: '![](img/cbba571c-8f5e-451b-93e2-382ea0d45cd8.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cbba571c-8f5e-451b-93e2-382ea0d45cd8.png)'
- en: 'Finally, the data was classified into basic waterway categories, as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，数据被分类到基本水道类别，如下所示：
- en: '![](img/98c7b472-407a-4618-bde6-668416f084c0.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/98c7b472-407a-4618-bde6-668416f084c0.png)'
- en: 'In addition, a process was undertaken to generate centerlines for polygon features
    such as streams, which are effectively linear features, as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还进行了一个过程来生成如河流等多边形特征的中心线，这些特征实际上是线性特征，如下所示：
- en: '![](img/b7a60213-43b3-4386-970e-da5f209e1949.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b7a60213-43b3-4386-970e-da5f209e1949.png)'
- en: 'Hence, we have three separate but related datasets:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有三个相互独立但又相关的数据集：
- en: '`cuyahoga_hydro_polygon`'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cuyahoga_hydro_polygon`'
- en: '`cuyahoga_hydro_polyline`'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cuyahoga_hydro_polyline`'
- en: '`cuyahoga_river_centerlines`'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cuyahoga_river_centerlines`'
- en: 'Now, let us look at the structure of the tabular data. Unzip the hydrology
    file from the book repository and go to that directory. The `ogrinfo` utility
    can help us with this, as shown in the following command:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看表格数据的结构。从书籍存储库中解压水文文件并进入该目录。`ogrinfo`实用程序可以帮助我们，如下面的命令所示：
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The output is as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/e90c2a9b-ba18-42dd-9d26-677f877d92ed.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e90c2a9b-ba18-42dd-9d26-677f877d92ed.png)'
- en: 'Executing this query on each of the shapefiles, we see the following fields
    that are common to all the shapefiles:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个形状文件上执行此查询，我们看到以下所有形状文件都通用的字段：
- en: '`name`'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`'
- en: '`hyd_type`'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hyd_type`'
- en: '`geom_type`'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`geom_type`'
- en: It is by understanding our common fields that we can apply inheritance to completely
    structure our data.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 通过理解我们的通用字段，我们可以应用继承来完全组织我们的数据。
- en: How to do it...
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Now that we know our common fields, creating an inheritance model is easy.
    First, we will create a parent table with the fields common to all the tables,
    using the following query:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了我们的通用字段，创建一个继承模型就很容易了。首先，我们将创建一个父表，其中包含所有表共有的字段，使用以下查询：
- en: '[PRE14]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If you are paying attention, you will note that we also added a `geometry` field
    as all of our shapefiles implicitly have this commonality. With inheritance, every
    record inserted in any of the child tables will also be saved in our parent table,
    only these records will be stored without the extra fields specified for the child
    tables.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你注意到了，我们还在其中添加了一个`geometry`字段，因为所有我们的形状文件都隐含了这种共性。使用继承，任何插入到子表中的记录也将保存在我们的父表中，但这些记录将存储没有为子表指定的额外字段。
- en: 'To establish inheritance for a given table, we need to declare only the additional
    fields that the child table contains using the following query:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为了为给定的表建立继承关系，我们只需要使用以下查询声明子表包含的额外字段：
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, we are ready to load our data using the following commands:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好使用以下命令加载数据：
- en: '`shp2pgsql -s 3734 -a -i -I -W LATIN1 -g the_geom cuyahoga_hydro_polygon chp02.hydrology_polygon
    | psql -U me -d postgis_cookbook`'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shp2pgsql -s 3734 -a -i -I -W LATIN1 -g the_geom cuyahoga_hydro_polygon chp02.hydrology_polygon
    | psql -U me -d postgis_cookbook`'
- en: '`shp2pgsql -s 3734 -a -i -I -W LATIN1 -g the_geom cuyahoga_hydro_polyline chp02.hydrology_linestring
    | psql -U me -d postgis_cookbook`'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shp2pgsql -s 3734 -a -i -I -W LATIN1 -g the_geom cuyahoga_hydro_polyline chp02.hydrology_linestring
    | psql -U me -d postgis_cookbook`'
- en: '`shp2pgsql -s 3734 -a -i -I -W LATIN1 -g the_geom cuyahoga_river_centerlines
    chp02.hydrology_centerlines | psql -U me -d postgis_cookbook`'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shp2pgsql -s 3734 -a -i -I -W LATIN1 -g the_geom cuyahoga_river_centerlines
    chp02.hydrology_centerlines | psql -U me -d postgis_cookbook`'
- en: 'If we view our parent table, we will see all the records in all the child tables.
    The following is a screenshot of fields in `hydrology`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看父表，我们将看到所有子表中的所有记录。以下是对`hydrology`字段的一个截图：
- en: '![](img/ec505dd1-c9c9-430a-8fa1-0b2fa16302f9.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ec505dd1-c9c9-430a-8fa1-0b2fa16302f9.png)'
- en: 'Compare that to the fields available in `hydrology_linestring` that will reveal
    specific fields of interest:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 将它与`hydrology_linestring`中可用的字段进行比较，将揭示感兴趣的特定字段：
- en: '![](img/6ac3acbf-428c-406c-a158-e1ab36fb935c.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6ac3acbf-428c-406c-a158-e1ab36fb935c.png)'
- en: How it works...
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'PostgreSQL table inheritance allows us to enforce essentially hierarchical
    relationships between tables. In this case, we leverage inheritance to allow for
    commonality between related datasets. Now, if we want to query data from these
    tables, we can query directly from the parent table as follows, depending on whether
    we want a mix of geometries or just a targeted dataset:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: PostgreSQL表继承允许我们在表之间强制执行基本层次关系。在这种情况下，我们利用继承来允许相关数据集之间的共性。现在，如果我们想查询这些表中的数据，我们可以直接从父表查询，如下所示，具体取决于我们是否想要混合几何形状或只是针对特定数据集：
- en: '[PRE16]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'From any of the child tables, we could use the following query:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 从任何子表，我们可以使用以下查询：
- en: '[PRE17]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: See also
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: It is possible to extend this concept in order to leverage and optimize storage
    and querying by using the `CHECK` constrains in conjunction with inheritance.
    For more info, see the *Extending inheritance – table partitioning* recipe.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过结合使用`CHECK`约束和继承来扩展这个概念，以利用和优化存储和查询。有关更多信息，请参阅*扩展继承 – 表分区*配方。
- en: Extending inheritance – table partitioning
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展继承 – 表分区
- en: Table partitioning is an approach specific to PostgreSQL that extends inheritance
    to model tables that typically do not vary from each other in the available fields,
    but where the child tables represent logical partitioning of the data based on
    a variety of factors, be it time, value ranges, classifications, or in our case,
    spatial relationships. The advantages of partitioning include improved query performance
    due to smaller indexes and targeted scans of data, bulk loads, and deletes that
    bypass the costs of vacuuming. It can thus be used to put commonly used data on
    faster and more expensive storage, and the remaining data on slower and cheaper
    storage. In combination with PostGIS, we get the novel power of spatial partitioning,
    which is a really powerful feature for large datasets.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 表分区是特定于PostgreSQL的一种方法，它扩展了继承，用于模型化通常在可用字段上没有差异的表。但是，子表代表基于各种因素的数据的逻辑分区，无论是时间、值范围、分类，还是在我们的案例中，空间关系。分区的好处包括由于索引较小和针对数据的扫描而提高的查询性能，以及绕过真空操作成本的批量加载和删除。因此，可以将常用数据放在更快、更昂贵的存储上，而将剩余数据放在较慢、更便宜的存储上。与PostGIS结合使用，我们获得了空间分区的新颖功能，这对于大型数据集来说是一个非常强大的特性。
- en: Getting ready
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We could use many examples of large datasets that could benefit from partitioning.
    In our case, we will use a contour dataset. Contours are useful ways to represent
    terrain data, as they are well established and thus commonly interpreted. Contours
    can also be used to compress terrain data into linear representations, thus allowing
    it to be shown in conjunction with other data easily.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以举出许多大型数据集的例子，这些数据集可以从分区中受益。在我们的案例中，我们将使用等高线数据集。等高线是表示地形数据的有用方式，因为它们已经建立并且因此通常被解释。等高线还可以将地形数据压缩成线性表示，从而使其能够与其他数据一起轻松显示。
- en: The problem is, the storage of contour data can be quite expensive. Two-foot
    contours for a single US county can take 20 to 40 GB, and storing such data for
    a larger area such as a region or nation can become quite prohibitive from the
    standpoint of accessing the appropriate portion of the dataset in a performant
    way.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，轮廓数据的存储可能相当昂贵。一个美国县区的两英尺轮廓可能需要 20 到 40 GB，而对于更大区域，如地区或国家，存储此类数据可能从性能的角度来看变得相当有约束力。
- en: How to do it...
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The first step in this case may be to prepare the data. If we had a monolithic
    contour table called `cuy_contours_2`, we could choose to clip the data to a series
    of rectangles that will serve as our table partitions; in this case, `chp02.contour_clip`,
    using the following query:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个案例中，第一步可能是准备数据。如果我们有一个名为 `cuy_contours_2` 的单一轮廓表，我们可以选择将数据裁剪成一系列矩形，这些矩形将作为我们的表分区；在这种情况下，使用以下查询的
    `chp02.contour_clip`：
- en: '[PRE18]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We are performing two tests here in our query. We are using `ST_Within`, which
    tests whether a given contour is entirely within our area of interest. If so,
    we perform an intersection; the resultant geometry should just be the geometry
    of the contour.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在查询中执行了两个测试。我们使用了 `ST_Within`，它测试一个给定的轮廓是否完全位于我们的兴趣区域内。如果是这样，我们执行交集；结果几何形状应该是轮廓的几何形状。
- en: The `ST_Crosses` function checks whether the contour crosses the boundary of
    the geometry we are testing. This should capture all the geometries lying partially
    inside and partially outside our areas. These are the ones that we will truly
    intersect to get the resultant shape.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`ST_Crosses` 函数检查轮廓是否穿过我们正在测试的几何形状的边界。这应该会捕获所有部分位于我们区域内部和外部几何形状。这些是我们将真正相交以获得结果形状的几何形状。'
- en: 'In our case, it is easier and we don''t require this step. Our contour shapes
    are already individual shapefiles clipped to rectangular boundaries, as shown
    in the following screenshot:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，这样做更容易，我们不需要这一步。我们的轮廓形状已经是裁剪到矩形边界的独立形状文件，如下面的截图所示：
- en: '![](img/fe831299-188c-4bc0-96e4-eb3047a474a2.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fe831299-188c-4bc0-96e4-eb3047a474a2.png)'
- en: Since the data is already clipped into the chunks needed for our partitions,
    we can just continue to create the appropriate partitions.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 由于数据已经被裁剪成我们分区所需的块，我们只需继续创建适当的分区。
- en: 'Much like with inheritance, we start by creating our parent table using the
    following query:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 与继承类似，我们首先使用以下查询创建父表：
- en: '[PRE19]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here again, we maintain our constraints, such as `PRIMARY KEY,` and specify
    the geometry type (`MultiLineStringZM`), not because these will propagate to the
    child tables, but for any client software accessing the parent table to anticipate
    such constraints.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们再次保持约束，如 `PRIMARY KEY`，并指定几何类型（`MultiLineStringZM`），并不是因为这些会传播到子表中，而是为了让任何访问父表的客户端软件能够预测这些约束。
- en: 'Now we may begin to create tables that inherit from our parent table. In the
    process, we will create a `CHECK` constraint specifying the limits of our associated
    geometry using the following query:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以开始创建继承自父表的新表。在这个过程中，我们将创建一个 `CHECK` 约束，指定我们相关几何形状的限制，如下所示：
- en: '[PRE20]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We can complete the table structure for partitioning the contours with similar
    `CREATE TABLE` queries for our remaining tables, as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用与剩余表类似的 `CREATE TABLE` 查询来完成表结构的分区，如下所示：
- en: '[PRE21]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'And now we can load our contours shapefiles found in the `contours1` ZIP file
    into each of our child tables, using the following command, by replacing the filename.
    If we wanted to, we could even implement a trigger on the parent table, which
    would place each insert into its correct child table, though this might incur
    performance costs:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用以下命令将 `contours1` ZIP 文件中找到的轮廓形状文件加载到每个子表中，通过替换文件名。如果我们想的话，我们甚至可以在父表上实现一个触发器，将每个插入操作放入正确的子表中，尽管这可能会影响性能：
- en: '[PRE22]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: How it works...
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `CHECK` constraint in combination with inheritance is all it takes to build
    a table partitioning. In this case, we're using a bounding box as our `CHECK`
    constraint and simply inheriting the columns from the parent table. Now that we
    have this in place, queries against the parent table will check our `CHECK` constraints
    first before employing a query.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，结合继承的 `CHECK` 约束是构建表分区所需的所有内容。我们正在使用边界框作为 `CHECK` 约束，并简单地从父表继承列。现在我们已经设置了这些，对父表的查询将首先检查我们的
    `CHECK` 约束，然后再执行查询。
- en: This also allows us to place any of our lesser-used contour tables on cheaper
    and slower storage, thus allowing for cost-effective optimizations of large datasets.
    This structure is also beneficial for rapidly changing data, as updates can be
    applied to an entire area; the entire table for that area can be efficiently dropped
    and repopulated without traversing across the dataset.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这也允许我们将任何我们较少使用的等高线表放置在更便宜、更慢的存储上，从而允许对大型数据集进行成本效益的优化。这种结构对于快速变化的数据也有益，因为可以对整个区域应用更新；该区域的整个表可以有效地删除并重新填充，而无需遍历整个数据集。
- en: See also
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: For more on table inheritance in general, particularly the flexibility associated
    with the usage of alternate columns in the child table, see the previous recipe,
    *Structuring spatial data with table inheritance*.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于表继承的信息，特别是与子表中使用备用列相关的灵活性，请参阅之前的配方，*使用表继承结构化空间数据*。
- en: Normalizing imports
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规范化导入
- en: Often, data used in a spatial database is imported from other sources. As such,
    it may not be in a form that is useful for our current application. In such a
    case, it may be useful to write functions that will aid in transforming the data
    into a form that is more useful for our application. This is particularly the
    case when going from flat file formats, such as shapefiles, to relational databases
    such as PostgreSQL.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，空间数据库中使用的数据是从其他来源导入的。因此，它可能不是我们当前应用有用的形式。在这种情况下，编写辅助函数将数据转换成对我们应用更有用的形式可能是有用的。这尤其适用于从平面文件格式，如Shapefile，到关系数据库，如PostgreSQL的转换。
- en: A shapefile is a de facto as well as a format specification for the storage
    of spatial data, and is probably the most common delivery format for spatial data.
    A shapefile, in spite of its name, is never just one file, but a collection of
    files. It consists of at least `*.shp` (which contains geometry), `*.shx` (an
    index file), and `*.dbf` (which contains the tabular information for the shapefile).
    It is a powerful and useful format, but as a flat file, it is inherently non-relational.
    Each geometry is associated in a one-to-one relationship with each row in a table.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Shapefile是一种事实上的以及格式规范，用于存储空间数据，可能是空间数据最常用的交付格式。尽管名为Shapefile，但它绝不是单个文件，而是一组文件的集合。它至少包含`*.shp`（包含几何信息）、`*.shx`（索引文件）和`*.dbf`（包含Shapefile的表格信息）。这是一个强大且有用的格式，但作为一个平面文件，它本质上是非关系的。每个几何体与表格中的每一行都有一个一对一的关系。
- en: 'There are many structures that might serve as a proxy for relational stores
    in a shapefile. We will explore one here: a single field with delimited text for
    multiple relations. This is a not-too-uncommon hack to encode multiple relationships
    into a flat file. The other common approach is to create multiple fields to store
    what in a relational arrangement would be a single field.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多结构可能作为Shapefile中关系存储的代理。在这里我们将探讨其中一个：一个字段，用于分隔多个关系。这是将多个关系编码到平面文件中的一种不太常见的技巧。另一种常见的方法是创建多个字段来存储在关系安排中本应是一个单一字段的内容。
- en: Getting ready
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The dataset we will be working with is a trails dataset that has linear extents
    for a set of trails in a park system. The data is the typical data that comes
    from the GIS world; as a flat shapefile, there are no explicit relational constructs
    in the data.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要处理的数据集是一个公园系统中一系列小径的线性范围数据集。这些数据是典型的GIS世界中的数据；作为一个平面Shapefile，数据中没有显式的关系结构。
- en: 'First, unzip the `trails.zip` file and use the command line to go into it,
    then load the data using the following command:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，解压`trails.zip`文件，然后使用命令行进入它，然后使用以下命令加载数据：
- en: '[PRE23]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Looking at the linear data, we have some categories for the use type:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 观察线性数据，我们有关于用途类型的几个类别：
- en: '![](img/e73e89c3-d887-45c7-85dd-14d2b2d8092a.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e73e89c3-d887-45c7-85dd-14d2b2d8092a.png)'
- en: 'We want to retain this information as well as the name. Unfortunately, the
    `label_name` field is a messy field with a variety of related names concatenated
    with an ampersand (`&`), as shown in the following query:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望保留这些信息以及名称。不幸的是，`label_name`字段是一个混乱的字段，其中包含各种相关名称，通过和符号（`&`）连接，如下面的查询所示：
- en: '[PRE24]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'It will return the following output:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 它将返回以下输出：
- en: '![](img/740e10f2-cda8-4acc-8e49-6b3b54802548.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/740e10f2-cda8-4acc-8e49-6b3b54802548.png)'
- en: This is where the normalization of our table will begin.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们开始表规范化的地方。
- en: How to do it...
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: The first thing we need to do is find all the fields that don't have ampersands
    and use those as our unique list of available trails. In our case, we can do this,
    as every trail has at least one segment that is uniquely named and not associated
    with another trail name. This approach will not work with all datasets, so be
    careful in understanding your data before applying this approach to that data.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是找到所有没有`&`的字段，并使用这些作为我们可用的独特路径列表。在我们的案例中，我们可以这样做，因为每个路径至少有一个唯一命名的段，并且不与另一个路径名称相关联。这种方法并不适用于所有数据集，所以在应用此方法之前要仔细理解你的数据。
- en: 'To select the fields ordered without ampersands, we use the following query:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 要选择没有`&`的排序字段，我们使用以下查询：
- en: '[PRE25]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'It will return the following output:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 它将返回以下输出：
- en: '![](img/45c659e3-b010-4b13-9124-daaec6ca0ca6.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/45c659e3-b010-4b13-9124-daaec6ca0ca6.png)'
- en: 'Next, we want to search for all the records that match any of these unique
    trail names. This will give us the list of records that will serve as relations.
    The first step in doing this search is to append the percent (`%`) signs to our
    unique list in order to build a string on which we can search using a `LIKE` query:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们想要搜索所有匹配这些独特路径名称的记录。这将给我们一个记录列表，这些记录将作为关系。进行此搜索的第一步是在我们的独特列表中添加百分号（`%`）以构建一个可以使用`LIKE`查询进行搜索的字符串：
- en: '[PRE26]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Finally, we''ll use this in the context of a `WITH` block to do the normalization
    itself. This will provide us with a table of unique IDs for each segment in our
    first column, along with the associated `label` column. For good measure, we will
    do this as a `CREATE TABLE` procedure, as shown in the following query:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将在`WITH`块中使用这个来执行规范化本身。这将为我们提供第一列中每个段唯一的ID表，以及相关的`label`列。为了保险起见，我们将以`CREATE
    TABLE`过程的形式执行此操作，如下查询所示：
- en: '[PRE27]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If we view the first rows of the table created, `trails_names`, we have the
    following output with `pgAdmin`:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看创建的表的第一个行，`trails_names`，我们使用`pgAdmin`得到以下输出：
- en: '![](img/61a39308-ad2c-4f0a-8fd1-887f98d6b16e.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/61a39308-ad2c-4f0a-8fd1-887f98d6b16e.png)'
- en: 'Now that we have a table of the relations, we need a table of the geometries
    associated with `gid`. This, in comparison, is quite easy, as shown in the following
    query:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了关系表，我们需要一个与`gid`关联的几何表。相比之下，这相当简单，如下查询所示：
- en: '[PRE28]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: How it works...
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this example, we have generated a unique list of possible records in conjunction
    with a search for the associated records, in order to build table relationships.
    In one table, we have the geometry and a unique ID of each spatial record; in
    another table, we have the names associated with each of those unique IDs. Now
    we can explicitly leverage those relationships.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们生成了一组可能的唯一记录列表，并与关联记录的搜索一起构建表关系。在一个表中，我们有每个空间记录的几何和唯一ID；在另一个表中，我们有与每个唯一ID关联的名称。现在我们可以明确地利用这些关系。
- en: 'First, we need to establish our unique IDs as primary keys, as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要建立我们独特的ID作为主键，如下所示：
- en: '[PRE29]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now we can use that `PRIMARY KEY` as a `FOREIGN KEY` in our `trails_names`
    table using the following query:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用以下查询在`trails_names`表中将其作为`FOREIGN KEY`的`PRIMARY KEY`：
- en: '[PRE30]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This step isn''t strictly necessary, but does enforce referential integrity
    for queries such as the following:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这一步并非绝对必要，但它确实强制执行了以下查询等查询的引用完整性：
- en: '[PRE31]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The output is as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/1196c509-656a-4907-a288-ca9b161ca303.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1196c509-656a-4907-a288-ca9b161ca303.png)'
- en: There's more...
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: If we had multiple fields we wanted to normalize, we could write `CREATE TABLE`
    queries for each of them.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要规范化多个字段，我们可以为每个字段编写`CREATE TABLE`查询。
- en: It is interesting to note that the approach framed in this recipe is not limited
    to cases where we have a delimited field. This approach can provide a relatively
    generic solution to the problem of normalizing flat files. For example, if we
    have a case where we have multiple fields to represent relational info, such as
    `label1`, `label2`, `label3`, or similar multiple attribute names for a single
    record, we can write a simple query to concatenate them together before feeding
    that info into our query.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，本食谱中提出的方法不仅限于我们有分隔字段的情况。这种方法可以提供一个相对通用的解决方案来规范化平面文件的问题。例如，如果我们有一个多个字段来表示关系信息的案例，例如`label1`、`label2`、`label3`或类似的多属性名称，我们可以编写一个简单的查询将它们连接起来，然后再将信息输入到我们的查询中。
- en: Normalizing internal overlays
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规范化内部叠加
- en: Data from an external source can have issues in the table structure as well
    as in the topology, endemic to the geospatial data itself. Take, for example,
    the problem of data with overlapping polygons. If our dataset has polygons that
    overlap with internal overlays, then queries for area, perimeter, and other metrics
    may not produce predictable or consistent results.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 来自外部源的数据可能在表结构以及拓扑结构上存在问题，这是地理空间数据本身的固有属性。以具有重叠多边形的数据问题为例。如果我们的数据集中有多边形与内部重叠，那么对面积、周长和其他指标的查询可能不会产生可预测或一致的结果。
- en: There are a few approaches that can solve the problem of polygon datasets with
    internal overlays. The general approach presented here was originally proposed
    by *Kevin Neufeld* of *Refractions Research*.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以解决具有内部重叠的多边形数据集的问题。这里提出的一般方法最初是由*Refractions Research*的*凯文·纽菲尔德*提出的。
- en: Over the course of writing our query, we will also produce a solution for converting
    polygons to linestrings.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写查询的过程中，我们还将提供一个将多边形转换为线字符串的解决方案。
- en: Getting ready
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'First, unzip the `use_area.zip` file and go into it using the command line;
    then, load the dataset using the following command:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，解压`use_area.zip`文件，然后使用命令行进入它；接着，使用以下命令加载数据集：
- en: '[PRE32]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: How to do it...
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Now that the data is loaded into a table in the database, we can leverage PostGIS
    to flatten and get the union of the polygons, so that we have a normalized dataset.
    The first step in doing so using this approach will be to convert the *polygons*
    to *linestrings*. We can then link those *linestrings* and convert them back to
    *polygons*, representing the union of all the *polygon* inputs. We will perform
    the following tasks:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在数据已加载到数据库中的表中，我们可以利用PostGIS来展平和获取多边形的并集，以便我们有一个规范化的数据集。使用这种方法的第一步将是将*多边形*转换为*线字符串*。然后我们可以连接这些*线字符串*并将它们转换回*多边形*，表示所有*多边形*输入的并集。我们将执行以下任务：
- en: Convert polygons to linestrings
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将多边形转换为线字符串
- en: Convert linestrings back to polygons
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将线字符串转换回多边形
- en: Find the center points of the resultant polygons
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到结果多边形的中心点
- en: Use the resultant points to query tabular relationships
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用结果点来查询表格关系
- en: To convert polygons to linestrings, we'll need to extract just the portions
    of the polygons we want using `ST_ExteriorRing`, convert those parts to points
    using `ST_DumpPoints`, and then connect those points back into lines like a connect-the-dots
    coloring book using `ST_MakeLine`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 要将多边形转换为线字符串，我们需要使用`ST_ExteriorRing`提取我们想要的多边形部分，使用`ST_DumpPoints`将这些部分转换为点，然后使用`ST_MakeLine`将这些点连接成线，就像连接点彩图一样。
- en: 'Breaking it down further, `ST_ExteriorRing (the_geom)` will grab just the outer
    boundary of our polygons. But `ST_ExteriorRing` returns polygons, so we need to
    take that output and create a line from it. The easiest way to do this is to convert
    it to points using `ST_DumpPoints` and then connect those points. By default,
    the `Dump` function returns an object called a `geometry_dump`, which is not just
    simple geometry, but the geometry in combination with an array of integers. The
    easiest way to return the geometry alone is the leverage object notation to extract
    just the geometry portion of `geometry_dump,` as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步分解，`ST_ExteriorRing (the_geom)`将仅获取我们多边形的边界。但是`ST_ExteriorRing`返回多边形，因此我们需要将输出转换为线。最简单的方法是使用`ST_DumpPoints`将其转换为点，然后连接这些点。默认情况下，`Dump`函数返回一个名为`geometry_dump`的对象，它不仅仅是简单的几何形状，而是几何形状与整数数组的组合。最简单的方法是利用对象符号来提取`geometry_dump`的几何部分，如下所示：
- en: '[PRE33]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Piecing the geometry back together with `ST_ExteriorRing` is done using the
    following query:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ST_ExteriorRing`将几何形状重新拼接起来，可以使用以下查询完成：
- en: '[PRE34]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This should give us a listing of points in order from the exterior rings of
    all the points from which we want to construct our lines using `ST_MakeLine`,
    as shown in the following query:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会给出一个点列表，按照从我们想要使用`ST_MakeLine`构建线的所有点的外部环的顺序排列，如下查询所示：
- en: '[PRE35]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Since the preceding approach is a process we may want to use in many other
    places, it might be prudent to create a function from this using the following
    query:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 由于前面的方法是我们可能在许多其他地方想要使用的过程，因此可能明智地使用以下查询创建一个函数：
- en: '[PRE36]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now that we have the `polygon_to_line` function, we still need to force the
    linking of overlapping lines in our particular case. The `ST_Union` function will
    aid in this, as shown in the following query:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了`polygon_to_line`函数，我们仍然需要强制连接我们特定情况下的重叠线。`ST_Union`函数将有助于此，如下查询所示：
- en: '[PRE37]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now let''s convert linestrings back to polygons, and for this we can polygonize
    the result using `ST_Polygonize`, as shown in the following query:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将线字符串转换回多边形，为此我们可以使用`ST_Polygonize`函数来多边形化结果，如下查询所示：
- en: '[PRE38]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `ST_Polygonize` function will create a single multi polygon, so we need
    to explode this into multiple single polygon geometries if we are to do anything
    useful with it. While we are at it, we might as well do the following within a
    `CREATE TABLE` statement:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`ST_Polygonize`函数将创建一个单一的多边形，所以如果我们想对它做任何有用的操作，我们需要将其分解成多个单一的多边形几何体。同时，我们还可以在`CREATE
    TABLE`语句中做以下操作：'
- en: '[PRE39]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We will be performing spatial queries against this geometry, so we should create
    an index in order to ensure our query performs well, as shown in the following
    query:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将对这个几何体执行空间查询，因此我们应该创建一个索引以确保我们的查询性能良好，如下查询所示：
- en: '[PRE40]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In order to find the appropriate table information from the original geometry
    and apply that back to our resultant geometries, we will perform a point-in-polygon
    query. For that, we first need to calculate centroids on the resultant geometry:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从原始几何体中找到适当的表信息并将其应用到我们的结果几何体上，我们将执行点在多边形内查询。为此，我们首先需要在结果几何体上计算质心：
- en: '[PRE41]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'And as always, create a spatial index using the following query:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 并且，一如既往地，使用以下查询创建空间索引：
- en: '[PRE42]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The centroids then structure our point-in-polygon (`ST_Intersects`) relationship
    between the original tabular information and resultant polygons, using the following
    query:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，质心将根据以下查询在原始表格信息和结果多边形之间建立点在多边形内(`ST_Intersects`)的关系：
- en: '[PRE43]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'If we view the first rows of the table, we can see it links the identifier
    of points to their respective locations:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看表的前几行，我们可以看到它将点的标识符与其相应的位置联系起来：
- en: '![](img/f23cff08-dac5-435e-a138-95f9e215cc74.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f23cff08-dac5-435e-a138-95f9e215cc74.png)'
- en: How it works...
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Our essential approach here is to look at the underlying topology of the geometry
    and reconstruct a topology that is non-overlapping, and then use the centroids
    of that new geometry to construct a query that establishes the relationship to
    the original data.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的基本方法是查看几何体的底层拓扑，并重建一个非重叠的拓扑，然后使用这个新几何体的质心来构建一个查询，以建立与原始数据的关系。
- en: There's more...
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'At this stage, we can optionally establish a framework for referential integrity
    using a foreign key, as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们可以选择使用外键建立引用完整性框架，如下所示：
- en: '[PRE44]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Using polygon overlays for proportional census estimates
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用多边形叠加进行比例人口普查估计
- en: PostgreSQL functions abound for the aggregation of tabular data, including `sum`,
    `count`, `min`, `max`, and so on. PostGIS as a framework does not explicitly have
    spatial equivalents of these, but this does not prevent us from building functions
    using the aggregate functions from PostgreSQL in concert with PostGIS's spatial
    functionality.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: PostgreSQL提供了许多用于表格数据聚合的函数，包括`sum`、`count`、`min`、`max`等。作为框架的PostGIS并没有这些函数的空间等价物，但这并不妨碍我们使用PostgreSQL的聚合函数与PostGIS的空间功能一起构建函数。
- en: In this recipe, we will explore spatial summarization with the United States
    census data. The US census data, by nature, is aggregated data. This is done intentionally
    to protect the privacy of citizens. But when it comes to doing analyses with this
    data, the aggregate nature of the data can become problematic. There are some
    tricks to disaggregate data. Amongst the simplest of these is the use of a proportional
    sum, which we will do in this exercise.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将探索使用美国人口普查数据的空间汇总。美国人口普查数据本质上就是汇总数据。这是有意为之，以保护公民的隐私。但当涉及到使用这些数据进行分析时，数据的汇总性质可能会成为问题。有一些技巧可以分解数据。其中最简单的一种是使用比例和，我们将在这次练习中这样做。
- en: Getting ready
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The problem at hand is that a proposed trail has been drawn in order to provide
    services for the public. This example could apply to road construction or even
    finding sites for commercial properties for the purpose of provisioning services.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的问题是，为了向公众提供服务，已经绘制了一条提议的路径。这个例子可以适用于道路建设，甚至可以用于寻找商业地产的地点，以提供服务。
- en: 'First, unzip the `trail_census.zip` file, then perform a quick data load using
    the following commands from the unzipped folder:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，解压`trail_census.zip`文件，然后使用以下命令从解压的文件夹中快速加载数据：
- en: '[PRE45]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The preceding commands will produce the following outputs:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将产生以下输出：
- en: '![](img/2e1a9e32-06fd-496d-9623-aa47bb59958a.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2e1a9e32-06fd-496d-9623-aa47bb59958a.png)'
- en: 'If we view the proposed trail in our favorite desktop GIS, we have the following:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在我们最喜欢的桌面GIS中查看拟议的小径，我们会看到以下内容：
- en: '![](img/02ce64b3-b125-4afe-b247-6d99e788dabd.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/02ce64b3-b125-4afe-b247-6d99e788dabd.png)'
- en: In our case, we want to know the population within 1 mile of the trail, assuming
    that persons living within 1 mile of the trail are the ones most likely to use
    it, and thus most likely to be served by it.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们想要了解距离小径1英里范围内的居民数量，假设居住在距离小径1英里范围内的居民最有可能使用它，因此最有可能被它服务。
- en: 'To find out the population near this proposed trail, we overlay census block
    group population density information. Illustrated in the next screenshot is a
    1-mile buffer around the proposed trail:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找出这个拟议小径附近的人口，我们在人口普查街区组人口密度信息上叠加。下一个截图展示了拟议小径周围的1英里缓冲区：
- en: '![](img/0554efef-2029-4dc8-a325-a1a3f4a1b898.png)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0554efef-2029-4dc8-a325-a1a3f4a1b898.png)'
- en: 'One of the things we might note about this census data is the wide range of
    census densities and census block group sizes. An approach to calculating the
    population would be to simply select all census blocks that intersect our area,
    as shown in the following screenshot:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这些人口普查数据，我们可能会注意到人口密度和人口普查街区组大小的广泛范围。计算人口的一种方法就是简单地选择所有与我们的区域相交的街区，如下面的截图所示：
- en: '![](img/d3452784-b8b6-4916-a4e4-996f34b1f12f.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d3452784-b8b6-4916-a4e4-996f34b1f12f.png)'
- en: This is a simple procedure that gives us an estimate of 130 to 288 people living
    within 1 mile of the trail, but looking at the shape of the selection, we can
    see that we are overestimating the population by taking the complete blocks in
    our estimate.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的程序，它给我们提供了一个估计值，即距离小径1英里范围内居住的130到288人，但通过观察选择的形状，我们可以看到，我们在估计中采用了完整的街区，因此高估了人口数量。
- en: Similarly, if we just used the block groups whose centroids lay within 1 mile
    of our proposed trail alignment, we would underestimate the population.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果我们只使用其质心位于我们拟议的小径1英里范围内的街区组，我们就会低估人口数量。
- en: Instead, we will make some useful assumptions. Block groups are designed to
    be moderately homogeneous within the block group population distribution. Assuming
    that this holds true for our data, we can assume that for a given block group,
    if 50% of the block group is within our target area, we can attribute half of
    the population of that block group to our estimate. Apply this to all our block
    groups, sum them, and we have a refined estimate that is likely to be better than
    pure intersects or centroid queries. Thus, we employ a proportional sum.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们将做出一些有用的假设。街区组被设计为在街区组人口分布内适度同质。假设这一点适用于我们的数据，我们可以假设对于给定的街区组，如果街区组的50%位于我们的目标区域内，我们可以将那个街区组的一半人口归入我们的估计。将这一点应用于所有我们的街区组，将它们相加，我们就得到了一个更精确的估计，这比纯交集或质心查询更有可能准确。因此，我们采用比例求和。
- en: How to do it...
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'As the problem of a proportional sum is a generic problem, it could apply to
    many problems. We will write the underlying proportioning as a function. A function
    takes inputs and returns a value. In our case, we want our proportioning function
    to take two geometries, that is, the geometry of our buffered trail and block
    groups as well as the value we want proportioned, and we want it to return the
    proportioned value:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 由于比例求和问题是一个通用问题，它可能适用于许多问题。我们将把底层比例作为函数来编写。函数接受输入并返回一个值。在我们的案例中，我们希望我们的比例函数接受两个几何形状作为输入，即我们缓冲小径的几何形状以及街区组以及我们想要比例的值，我们希望它返回比例后的值：
- en: '[PRE46]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Now, for the purpose of our calculation, for any given intersection of buffered
    area and block group, we want to find the proportion that the intersection is
    over the overall block group. Then this value should be multiplied by the value
    we want to scale.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了我们的计算目的，对于缓冲区域和街区组的任何给定交集，我们想要找到交集占整个街区组的比例。然后这个值应该乘以我们想要缩放的值。
- en: 'In SQL, the function looks like the following query:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在SQL中，函数看起来像以下查询：
- en: '[PRE47]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The preceding query in its full form looks as follows:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 上述查询的完整形式如下：
- en: '[PRE48]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: How it works...
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Since we have written the query as a function, the query uses the `SELECT`
    statement to loop through all available records and give us a proportioned population.
    Astute readers will note that we have not yet done any work on summarization;
    we have only worked on the proportionality portion of the problem. We can do the
    summarization upon calling the function using PostgreSQL''s built-in aggregate
    functions. What is neat about this approach is that we need not just apply a sum,
    but we could also calculate other aggregates such as min or max. In the following
    example, we will just apply a sum:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将查询编写为一个函数，查询使用`SELECT`语句遍历所有可用记录，并给出一个按比例的人口。敏锐的读者会注意到，我们还没有进行任何汇总工作；我们只处理了问题的比例部分。我们可以在调用函数时使用PostgreSQL的内置聚合函数来进行汇总。这种方法的优点在于，我们不仅需要应用求和，还可以计算其他聚合，如最小值或最大值。在下面的示例中，我们将只应用求和：
- en: '[PRE49]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The value returned is quite different (a population of 96,081), which is more
    likely to be accurate.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的值相当不同（人口为96,081），这更有可能是准确的。
