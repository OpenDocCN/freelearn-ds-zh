- en: '*Chapter 10*: Turbo-charge Your Apps with Advanced Callbacks'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第10章*：通过高级回调为应用程序加速'
- en: We will now take our apps to a new level of abstraction and power by introducing
    new options available to callbacks. The general pattern we have followed has been
    that we provide users with a component that they can interact with. Based on a
    given set of options available to the component, users can influence certain actions,
    such as producing a chart, for example. We will be exploring other options such
    as deferring the execution of callbacks until a certain event happens, for example,
    clicking a "Submit" button. We will also take a look at how we can allow users
    to modify the layout of the app itself, by allowing them to add new dynamic components
    to it. We will use some of this knowledge to add a minor but important improvement
    to the clustering functionality that we introduced in [*Chapter 9*](B16780_09_Final_NM_ePub.xhtml#_idTextAnchor133),
    *Letting Your Data Speak for Itself with Machine Learning*.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在通过引入回调的新选项，将我们的应用程序提升到一个新的抽象层次和强大功能。我们遵循的基本模式是为用户提供一个可以交互的组件。基于该组件提供的选项集，用户可以影响某些动作，例如生成图表。我们将探索其他选项，例如推迟回调的执行，直到某个事件发生，例如点击“提交”按钮。我们还将看看如何允许用户修改应用程序的布局，允许他们向应用程序添加新的动态组件。我们将利用这些知识对在[*第9章*](B16780_09_Final_NM_ePub.xhtml#_idTextAnchor133)中引入的聚类功能进行一些小但重要的改进，*让数据为自己发声，使用机器学习*。
- en: We will first start by introducing the optional **State** parameter in our callbacks.
    So far, all of our callbacks fire immediately when the user makes changes to any
    of the inputs. In many cases, we want the users to set a few options and only
    then hit a "Submit" button to invoke the callback function. This becomes important
    when we have multiple inputs where it might be annoying or awkward if outputs
    change while users are still making changes. In other cases, those callbacks might
    take a long time to execute and/or be expensive to run. Again, in this case, we
    want to block the execution until the user decides to trigger it.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先介绍回调中的可选**State**参数。到目前为止，我们的所有回调都在用户对任何输入进行更改时立即触发。在许多情况下，我们希望用户设置一些选项，然后点击“提交”按钮才会触发回调函数。当我们有多个输入项时，如果输出在用户仍在更改时就发生变化，这可能会令人烦恼或不方便。在其他情况下，这些回调可能需要较长时间执行和/或需要消耗大量资源。因此，在这种情况下，我们希望在用户决定触发回调之前阻止其执行。
- en: Once the concept of `State` has been established, we will explore a new type
    of dynamic callbacks that enable our users to make changes to the app, by adding
    new charts for example. So far, we have allowed the users to simply modify the
    input values available in the interactive components. We can take this to a new
    level by introducing dynamic components that are generated based on the user's
    interactions.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`State`的概念被建立，我们将探索一种新的动态回调类型，允许用户通过例如添加新图表来更改应用程序。到目前为止，我们允许用户仅仅修改交互组件中的输入值。通过引入基于用户交互生成的动态组件，我们可以将这一功能提升到新的层次。
- en: Finally, we will get an overview of **pattern-matching callbacks**, which allow
    us to link dynamically created and interactive components together in a streamlined
    way.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将概述**模式匹配回调**，它允许我们以简化的方式将动态创建和交互式组件连接起来。
- en: 'Here are the main topics that we will cover in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章将要涵盖的主要内容：
- en: Understanding `State`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解`State`
- en: Creating components that control other components
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建控制其他组件的组件
- en: Allowing users to add dynamic components to the app
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许用户向应用程序添加动态组件
- en: Introducing pattern-matching callbacks
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引入模式匹配回调
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: We will be using the same basic tools that we have used in most chapters so
    far, and mainly focus on some new features in callback functions. We will use
    Dash, Dash HTML Components, Dash Core Components, and Dash Bootstrap Components
    for making our apps. For data manipulation, we will use pandas. For the charts
    and visualizations, we will be using Plotly and Plotly Express, and finally, we
    will use JupyterLab to interactively explore and create new functionality independently,
    before incorporating it into our app.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用到与前几章相同的基本工具，主要集中在回调函数中的一些新特性。我们将使用 Dash、Dash HTML 组件、Dash 核心组件和 Dash Bootstrap
    组件来构建我们的应用程序。数据操作方面，我们将使用 pandas。图表和可视化方面，我们将使用 Plotly 和 Plotly Express，最后，我们将使用
    JupyterLab 进行交互式探索，并独立创建新功能，最后将其整合到应用程序中。
- en: The code files of this chapter can be found on GitHub at [https://github.com/PacktPublishing/Interactive-Dashboards-and-Data-Apps-with-Plotly-and-Dash/tree/master/chapter_10](https://github.com/PacktPublishing/Interactive-Dashboards-and-Data-Apps-with-Plotly-and-Dash/tree/master/chapter_10).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在 GitHub 上找到，链接地址是：[https://github.com/PacktPublishing/Interactive-Dashboards-and-Data-Apps-with-Plotly-and-Dash/tree/master/chapter_10](https://github.com/PacktPublishing/Interactive-Dashboards-and-Data-Apps-with-Plotly-and-Dash/tree/master/chapter_10)。
- en: Check out the following video to see the Code in Action at [https://bit.ly/3v6ZYJw](https://bit.ly/3v6ZYJw).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看以下视频，观看代码的实际运行：[https://bit.ly/3v6ZYJw](https://bit.ly/3v6ZYJw)。
- en: Let's start by getting familiar with `State`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从熟悉`State`开始。
- en: Understanding State
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 State
- en: The typical callback function structure that we used so far contained one or
    more `Output` elements and one or more `Input` elements. As mentioned in the introduction,
    the callbacks fire immediately when users modify an `Input` element. We want to
    relax this option a little. We will start with a simple example demonstrating
    why and how to use `State`, which is an optional argument that can be given to
    our callbacks.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们使用的典型回调函数结构包含一个或多个`Output`元素和一个或多个`Input`元素。如引言中所述，当用户修改`Input`元素时，回调会立即触发。我们希望稍微放宽这个选项。我们将从一个简单的示例开始，展示为什么以及如何使用`State`，这是一个可选参数，可以传递给我们的回调函数。
- en: 'To make the problem we are trying to solve clear, take a look at *Figure 10.1*:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更清楚地说明我们试图解决的问题，请看一下*图 10.1*：
- en: '![Figure 10.1 – An interactive app with outputs that are not properly synchronized
    with input values](img/B16780_10_1.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.1 – 一个交互式应用，其输出与输入值未正确同步](img/B16780_10_1.jpg)'
- en: Figure 10.1 – An interactive app with outputs that are not properly synchronized
    with input values
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.1 – 一个交互式应用，其输出与输入值未正确同步
- en: As you can see, the output is showing the wrong values. The reason is that the
    app was made very slow by introducing a waiting time, to simulate a practical
    situation that you might face with your apps. The output was not wrong, actually;
    it just took too long to update, so when the input was changed, it wasn't immediately
    reflected in the output area. This is more important in this case because there
    are two inputs governing the output. The interval between modifying the first
    and second output might cause such confusion.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，输出显示的是错误的值。原因是为了模拟你在应用程序中可能遇到的实际情况，我们故意引入了等待时间，这使得应用变得非常慢。实际上，输出并不是错误的；只是更新需要较长时间，因此当输入发生变化时，输出区域没有立即反映变化。在这种情况下尤为重要的是，因为有两个输入项控制输出。修改第一个和第二个输出之间的间隔可能导致这种混淆。
- en: Another more important issue is that these options might take much more time
    and cost a lot in terms of lost computing power and/or lost analyst time. Our
    dataset is very small, and the types of calculations we ran on it are also very
    simple, so performance was not an issue. In practical situations, you will more
    likely deal with much larger datasets and run computations that take a considerable
    amount of time. For example, changing the number of clusters to update our model
    took a really negligible amount of time. In reality, that might take seconds,
    minutes, or even more. We will solve this by adding a "Submit" button and introducing
    `State` to our callback function.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个更重要的问题是，这些选项可能会消耗更多的时间，并在计算能力和/或分析人员时间的损失上花费大量成本。我们的数据集非常小，所进行的计算也很简单，因此性能并不是问题。在实际情况中，你更可能处理更大的数据集，并进行需要大量时间的计算。例如，修改集群的数量以更新我们的模型，所需时间非常短。实际上，这可能需要几秒钟、几分钟，甚至更长时间。我们将通过添加一个“提交”按钮并在回调函数中引入`State`来解决这个问题。
- en: Buttons are available as HTML components from the Dash HTML Components package.
    They can also be used through Dash Bootstrap Components. Using the latter has
    two advantages. First, they integrate well with the theme you are using, so this
    takes care of visual consistency. Also, and this is probably more important, they
    easily get one of the meaningful colors in case you want to communicate "success,"
    "warning," "danger," or any of the other available colors/messages.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮是 Dash HTML 组件包中的 HTML 组件。它们也可以通过 Dash Bootstrap 组件使用。使用后者有两个优点。首先，它们与所使用的主题很好地集成，确保了视觉上的一致性。其次，这一点可能更为重要的是，它们很容易显示出一种有意义的颜色，以便传达“成功”、“警告”、“危险”或其他任何可用的颜色/消息。
- en: Buttons are available as `dcc.Button` or `dbc.Button`. Let's see how they can
    be used to control the behavior of our app.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮可以通过`dcc.Button`或`dbc.Button`来实现。让我们看看它们如何控制应用程序的行为。
- en: We need to first clarify the difference between `Input` and `State` in our callbacks.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要澄清回调函数中`Input`和`State`的区别。
- en: Understanding the difference between Input and State
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解`Input`和`State`之间的区别
- en: First, keep in mind that `Input` is what triggers the function, and that `State`
    is simply a set of conditions that the app is in. It is up to us to decide which
    components functions as `State` and which as `Input`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，请记住，`Input`是触发函数的因素，而`State`只是应用程序所处的条件集。我们需要决定哪些组件作为`State`，哪些作为`Input`。
- en: 'Let''s update the guidelines for callback functions to clarify the distinction
    that was just introduced:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新回调函数的指导方针，以澄清刚刚引入的区别：
- en: The order of callback arguments has to always be one or more of `Output`, `Input`,
    and optionally `State` arguments, in that order. If we have multiple elements
    of any one of them, they all need to follow one another.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回调函数的参数顺序必须始终是`Output`、`Input`和可选的`State`，按照这个顺序。如果我们有多个相同类型的元素，它们必须依次排列。
- en: '`State` is optional.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`State`是可选的。'
- en: The `Input` element(s) is what triggers the callback to fire. Changing any or
    all of the `State` in the app would not cause the execution of the callback.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Input`元素是触发回调执行的因素。改变应用中的任何或所有`State`并不会导致回调的执行。'
- en: Once an `Input` element is modified, the callback will be triggered with whatever
    `State` has been changed since it was last triggered.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦`Input`元素被修改，回调将会触发，并且自上次触发以来，所有变化的`State`也会被传入回调。
- en: 'Let''s now see how to produce the code for the app shown in *Figure 10.1*,
    and then modify it for the desired behavior. The callback function currently looks
    like this:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何生成显示在*图10.1*中的应用程序代码，然后根据所需的行为进行修改。当前的回调函数看起来是这样的：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This is how we have managed all callbacks so far. Note that the callback will
    run if either of the two inputs were modified. The change we want to introduce
    will require two steps:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们至今管理所有回调函数的方式。请注意，回调会在两个输入中的任何一个被修改时运行。我们要引入的更改将需要两步操作：
- en: 'Add a button component to the page, placed under the `Textarea` component:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向页面添加一个按钮组件，放置在`Textarea`组件下方：
- en: '[PRE1]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Add the button as an `Input` argument to the callback function. We now introduce
    a new property that we haven''t seen yet, which is `n_clicks`. As the name suggests,
    this corresponds to the number of clicks that were made on a certain component
    during its lifetime in the user session. With every click, the number gets incremented
    by one, and we can use that variable to check and control the callback''s behavior.
    Note that we can also give it a default starting value, typically zero, but we
    can give it another number if we want:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将按钮作为`Input`参数添加到回调函数中。现在我们引入了一个我们还没有见过的新属性，即`n_clicks`。顾名思义，它对应于用户会话期间在某个组件上点击的次数。每次点击，数字就会增加一次，我们可以使用这个变量来检查和控制回调的行为。注意，我们也可以给它一个默认的起始值，通常为零，但如果我们愿意，也可以设置为其他数字：
- en: '[PRE2]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now that we have made the button our `Input`, we want to keep `Dropdown` and
    `Textarea`, but make them `State` arguments as follows:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们已经将按钮设定为`Input`，我们希望保留`Dropdown`和`Textarea`，但将它们作为`State`参数，如下所示：
- en: '[PRE3]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: With these changes, the callback now waits for `Input` to be changed. The user
    can change `Dropdown` and/or `Textarea` as many times as they want without being
    interrupted, and when they are ready, they can hit the "Submit" button to get
    the desired result.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过这些更改，回调现在等待`Input`的变化。用户可以多次更改`Dropdown`和/或`Textarea`，而不会被中断，等他们准备好时，可以点击“提交”按钮来获得所需的结果。
- en: 'When the app loads for the first time, the default value of the `n_clicks`
    property is `None`. Also, we have nothing in the `Textarea` component and there
    are no options selected from the dropdown yet. So, we do as usual: we use `raise
    PreventUpdate` if we don''t have a value for `n_clicks`. To update the function
    we introduced, we can simply introduce the following change to the signature of
    the function. Note the addition of the corresponding `n_clicks` argument, as well
    as its relative order:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当应用程序首次加载时，`n_clicks`属性的默认值为`None`。此外，`Textarea`组件中没有任何内容，且下拉菜单尚未选择任何选项。所以，我们按常规操作：如果没有`n_clicks`的值，我们就使用`raise
    PreventUpdate`。为了更新我们所引入的函数，我们可以简单地对函数的签名进行如下更改。注意新增了相应的`n_clicks`参数，以及它的相对顺序：
- en: '[PRE4]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If we update the code, we can see that things will work as expected and the
    user will be more in control of the process. *Figure 10.2* shows the updated functionality:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们更新代码，可以看到事情会按预期工作，用户将对流程有更多的控制权。*图 10.2* 显示了更新后的功能：
- en: '![Figure 10.2 – An interactive app with outputs now properly displaying the
    expected input values](img/B16780_10_2.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.2 – 一个互动应用，输出现在正确显示预期的输入值](img/B16780_10_2.jpg)'
- en: Figure 10.2 – An interactive app with outputs now properly displaying the expected
    input values
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.2 – 一个互动应用，输出现在正确显示预期的输入值
- en: We can improve this experience even more by providing the user with a visual
    cue, indicating that some processing is underway.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过提供视觉提示来进一步改善此体验，提示用户某些处理正在进行中。
- en: 'With this new knowledge fresh in mind, let''s use it to modify the behavior
    of our clustering functionality that we discussed in the introduction to this
    chapter. *Figure 10.3* shows the desired outcome that we want to achieve:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 牢记这些新知识后，我们可以利用它来修改我们在本章开头讨论的聚类功能的行为。*图 10.3* 显示了我们希望实现的预期结果：
- en: '![Figure 10.3 – The clustering functionality with a Submit button and a visual
    progress indicator](img/B16780_10_3.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.3 – 带有提交按钮和视觉进度指示器的聚类功能](img/B16780_10_3.jpg)'
- en: Figure 10.3 – The clustering functionality with a Submit button and a visual
    progress indicator
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.3 – 带有提交按钮和视觉进度指示器的聚类功能
- en: 'As you can see, we have introduced two new features. The first is the button
    that we have already discussed and implemented in our independent small app. The
    second is the Dash Core Components `Loading` component. This component is responsible
    for displaying the symbol that is seen moving, or sometimes spinning, where the
    output is expected to appear. Using it is extremely simple, but it''s also crucial
    in such cases as this. It''s always good to confirm to users that their selection
    (or any other interaction) has been acknowledged and is under process. Actually,
    I think it''s good to use the `Loading` component on all outputs to give this
    confirmation to users. It''s very easy to implement, and this is how we can update
    the app to reflect this functionality:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们引入了两个新特性。第一个是我们已经讨论并在独立小应用中实现的按钮。第二个是 Dash 核心组件 `Loading` 组件。该组件负责显示一个符号，这个符号在预期输出出现的地方移动或有时旋转。使用它非常简单，但在这种情况下非常关键。向用户确认他们的选择（或任何其他交互）已被识别并正在处理中总是件好事。事实上，我认为在所有输出中使用
    `Loading` 组件给用户这种确认是非常好的。它非常容易实现，以下是如何更新应用以反映这一功能：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `Graph` component already exists in our app; we just need to add it as the
    `children` argument to the `Loading` component as you can see in the preceding
    code. This will cause the animated symbol to remain animated until the underlying
    object appears in its place.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`Graph` 组件已经存在于我们的应用中；我们只需要将它作为 `children` 参数添加到 `Loading` 组件中，正如你在之前的代码中看到的。这将导致动画符号保持动画状态，直到底层对象出现在其位置。'
- en: 'Let''s now modify the callback function to make the desired change:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们修改回调函数以进行所需的更改：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We basically made two changes. We first introduced `clustering_submit_button`
    as an `Input` element and renamed each of the other arguments from `Input` to
    `State`. The other change is passing `n_clicks` as the first argument to the function
    signature. Remember that the names of the arguments can be anything, and what
    matters is their order. We gave them clear names so we can easily refer to them
    and manage them in the body of the function.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们基本上做了两项更改。首先，我们引入了 `clustering_submit_button` 作为 `Input` 元素，并将其他每个参数从 `Input`
    重命名为 `State`。另一个更改是将 `n_clicks` 作为第一个参数传递给函数签名。请记住，参数的名称可以是任何名称，重要的是它们的顺序。我们为它们起了清晰的名称，以便我们在函数体内轻松引用和管理它们。
- en: You have now modified the clustering functionality, giving the user more control
    and making it visually clearer with the `Loading` component. Feel free to add
    it wherever you want in the app.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经修改了聚类功能，给用户提供了更多的控制权，并通过 `Loading` 组件使其更加直观清晰。你可以随意在应用的任何地方添加它。
- en: Now we can take our callbacks to another interesting level.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将回调函数提升到另一个有趣的层次。
- en: Creating components that control other components
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建控制其他组件的组件
- en: 'How about we provide an interactive component on the page where its values
    (set by the user) serve as inputs to another function, which is in turn responsible
    for the final output? *Figure 10.4* shows what the result looks like, and following
    that is a discussion of the details and implementation:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如何在页面上提供一个交互组件，其值（由用户设置）作为另一个函数的输入，后者负责最终的输出？*图 10.4* 展示了结果的样子，随后是关于细节和实现的讨论：
- en: '![Figure 10.4 – An app with a component that dynamically determines the values
    of another component](img/B16780_10_4.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.4 – 一个包含动态决定另一个组件值的应用](img/B16780_10_4.jpg)'
- en: Figure 10.4 – An app with a component that dynamically determines the values
    of another component
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.4 – 一个包含动态决定另一个组件值的应用
- en: 'Let''s go through the visual elements of this app''s layout, one by one:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一了解这个应用布局中的视觉元素：
- en: '**Success message**: The green strip at the top doesn''t appear when the app
    loads. It only appears after the user adds the options to the dropdown and hits
    the **Set options** button. Note that there is a dynamic message showing the user
    the values that they added. Also, note that the alert message is "dismissable."
    We have the **x** symbol on the right, allowing the user to remove this message.'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**成功消息**：绿色条带在应用加载时不会出现。它仅在用户将选项添加到下拉菜单并点击**设置选项**按钮后才会显示。请注意，有一个动态消息显示用户所添加的值。另外，请注意，警告消息是“可关闭”的。右侧有**x**符号，允许用户移除此消息。'
- en: '`Textarea` component, which will be used to feed into the `options` property
    of the `Dropdown` component underneath it. At this point in the app, `Dropdown`
    is empty and has no options to choose from, and the `Graph` component also shows
    an empty chart.'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Textarea` 组件，用于传递给其下方 `Dropdown` 组件的 `options` 属性。在此时，`Dropdown` 为空，且没有可以选择的选项，`Graph`
    组件也显示一个空的图表。'
- en: '`Textarea` and hits this button, those lines will become options in `Dropdown`.'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当点击 `Textarea` 并点击此按钮时，这些行将成为 `Dropdown` 中的选项。
- en: '`Dropdown` component. After that, choosing a certain country code filters the
    dataset by getting rows where the country code is equal to the user''s selection.
    It then uses the resulting DataFrame to create the chart at the end.'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Dropdown` 组件。之后，选择特定的国家代码会通过获取与用户选择相等的国家代码行来过滤数据集。然后，它使用结果的 DataFrame 创建最终的图表。'
- en: There is not much practical value in such an app, as it would have been much
    easier to simply provide the options in a `Dropdown` component and produce the
    chart. We are simply doing this to demonstrate the new options that we can utilize
    and doing so with a dataset with which we are familiar. There is also a big potential
    for errors. What if the user doesn't know the code for a certain country? What
    if they make a typo? Again, this is just for demonstration purposes.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的应用没有太大的实际价值，因为直接提供 `Dropdown` 组件中的选项并生成图表会更简单。我们只是用它来展示我们可以利用的新选项，并且使用我们熟悉的数据集。同时也存在很大的错误潜力。假如用户不知道某个国家的代码呢？如果他们输入错误怎么办？再次强调，这仅仅是为了演示目的。
- en: This app can be written in around 30 lines of code and gives us two layers of
    options, where one depends on the other. One set of options "waits" and depends
    on the others to produce its outputs accordingly.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应用大约需要 30 行代码，它为我们提供了两层选项，其中一层依赖于另一层。一个选项集“等待”并依赖于其他选项，以相应地生成其输出。
- en: 'We now code the layout of the app, and after that we create the two callback
    functions that make it interactive:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们编写应用的布局代码，然后创建两个使其具有交互性的回调函数：
- en: 'Run the necessary imports:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行必要的导入：
- en: '[PRE7]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Create an app and its layout. All the following elements go into the app''s
    layout:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建应用及其布局。以下所有元素都将放入应用的布局中：
- en: '[PRE8]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Create an empty div that will contain the success message:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个空的 div，用于容纳成功消息：
- en: '[PRE9]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Create a `Label` component, telling the user how to interact with the app:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `Label` 组件，告诉用户如何与应用交互：
- en: '[PRE10]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Create an empty `Textarea` component. Note that this is also available and
    similar to the component of the same name, belonging to Dash Core Components:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个空的 `Textarea` 组件。请注意，它也可用，并且与 Dash Core Components 中的同名组件类似：
- en: '[PRE11]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Add a button for generating the dropdown and its options:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为生成下拉菜单及其选项添加一个按钮：
- en: '[PRE12]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Create an empty `Dropdown`:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个空的 `Dropdown`：
- en: '[PRE13]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Create an empty `Graph` component:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个空的 `Graph` 组件：
- en: '[PRE14]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This should be enough for the visual elements of our app. We now need two functions
    to create the interactivity we want:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该足以满足我们应用的视觉元素。接下来，我们需要两个函数来创建所需的交互性：
- en: '`set_dropdown_options`: This function will take the lines from `Textarea` as
    input and return a list of options to be fed to the `Dropdown` component.'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`set_dropdown_options`：这个函数将从`Textarea`中获取行作为输入，并返回一个选项列表供`Dropdown`组件使用。'
- en: '`create_population_chart`: This function takes its input from the `Dropdown`
    component and generates a population chart below it.'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`create_population_chart`：这个函数从`Dropdown`组件获取输入，并在其下方生成一个人口图表。'
- en: 'We now start with the first one:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们从第一个开始：
- en: 'Create the callback with the appropriate `Output`, `Input`, and `State` arguments.
    We have two outputs that this function affects. The first is the `options` property
    of the `Dropdown` component. The second is the div containing the success message.
    For our `Input`, we will have the button, and our `State` will be the `Textarea`
    component:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建具有适当`Output`、`Input`和`State`参数的回调函数。这个函数会影响两个输出，第一个是`Dropdown`组件的`options`属性，第二个是包含成功消息的div。对于我们的`Input`，我们会有一个按钮，而`State`将是`Textarea`组件：
- en: '[PRE15]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Create the function signature with appropriate argument names:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建带有适当参数名称的函数签名：
- en: '[PRE16]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Create a variable holding the text provided as a list. We achieve that by splitting
    the incoming text from `Textarea`. We also make sure to check for the case of
    not having any clicks and use `raise PreventUpdate` in that case:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个变量，保存作为列表提供的文本。我们通过分割`Textarea`中传入的文本来实现这一点。我们还确保检查没有点击的情况，并在这种情况下使用`raise
    PreventUpdate`：
- en: '[PRE17]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Create the success message as an `Alert` component, which is available from
    Dash Bootstrap Components. Note that we also color it with a "color" called "success."
    Naturally, you can also think of additional functionality that checks for valid
    inputs, and if it doesn''t get one, the color of the message would be "warning"
    or "danger," for example. Note that the text also dynamically adds the comma-separated
    options that were provided by the user. We also set `dismissable=True` to allow
    users to remove it from the page if they want to:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建成功消息作为一个`Alert`组件，这是Dash Bootstrap Components中的一部分。注意，我们还给它上了一个叫做“success”的颜色。自然，你还可以考虑额外的功能来检查有效的输入，如果没有有效输入，消息的颜色可能会是“warning”或“danger”。注意，文本还会动态地添加用户提供的逗号分隔选项。我们还设置了`dismissable=True`，允许用户在需要时将其从页面移除：
- en: '[PRE18]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Create the options list that will set the `options` property of the currently
    empty `Dropdown` component. We use the `text` variable for that:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建选项列表，用来设置当前空的`Dropdown`组件的`options`属性。我们使用`text`变量来实现：
- en: '[PRE19]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Return the tuple of `options` and `message`:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回`options`和`message`的元组：
- en: '[PRE20]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let''s now turn to our other function, which will take the selected country
    code, and use it to generate the chart:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们转到另一个函数，它将获取所选的国家代码，并利用它生成图表：
- en: 'Create the callback with the required `Output` and `Input`:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建具有所需`Output`和`Input`的回调函数：
- en: '[PRE21]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Create the function signature as well as the check for the availability of
    a value from the dropdown:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建函数签名以及检查`Dropdown`中值是否可用：
- en: '[PRE22]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Create the required DataFrame subset based on the input value:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据输入值创建所需的DataFrame子集：
- en: '[PRE23]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Return a chart with the appropriate values:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回一个包含适当值的图表：
- en: '[PRE24]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We can now run the preceding code and create the desired app.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以运行前面的代码并创建所需的应用程序。
- en: 'To better understand the structure of our app, and to get used to inspecting
    our callback chains, we can run the app in debug mode by running `app.run_server(debug=True)`
    and see how inputs and outputs relate to one another in *Figure 10.5*:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解应用程序的结构，并熟悉如何检查回调链，我们可以通过运行`app.run_server(debug=True)`在调试模式下运行应用程序，并查看输入和输出如何相互关联，如*图
    10.5*所示：
- en: '![Figure 10.5 – App callback graph](img/B16780_10_5.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.5 – 应用回调图](img/B16780_10_5.jpg)'
- en: Figure 10.5 – App callback graph
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.5 – 应用回调图
- en: You can easily see the names of the components and their IDs as specified in
    our code. You can easily trace the sequence of events, starting from the bottom
    left, following the arrows to the top right of the diagram.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以轻松地看到代码中指定的组件名称及其ID。你可以很容易地跟踪事件的顺序，从图表的左下角开始，沿着箭头走到右上角。
- en: We saw how we can create dynamic options in certain components that depend on
    other components for their values. Dash neatly handled the behavior of components
    and properly triggered the right functions when their inputs were available.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到如何在某些组件中创建动态选项，这些选项依赖于其他组件的值。Dash整洁地处理了组件的行为，并在输入可用时正确地触发了相应的函数。
- en: Let's take things to an even more abstract and powerful level. Let's now allow
    users to add full components by clicking a button.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将事情提升到一个更抽象和强大的层次。现在，让我们允许用户通过点击按钮添加完整的组件。
- en: Allowing users to add dynamic components to the app
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 允许用户向应用程序添加动态组件
- en: 'Not only will users be able to add components to the app''s layout, but the
    components'' contents will also be dynamically generated. Take a look at *Figure
    10.6* for the simplest example that we will start with:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 用户不仅能够向应用程序的布局中添加组件，而且这些组件的内容也将动态生成。看看*图 10.6*，它展示了我们将要开始的最简单示例：
- en: '![Figure 10.6 – An app allowing users to add components to the app''s layout](img/B16780_10_6.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.6 – 一个允许用户向应用程序布局中添加组件的应用程序](img/B16780_10_6.jpg)'
- en: Figure 10.6 – An app allowing users to add components to the app's layout
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.6 – 一个允许用户向应用程序布局中添加组件的应用程序
- en: Although extremely simple, the charts in this app have different dynamic names,
    as you can see in the chart titles. This was based on the dynamic value of `n_clicks`,
    which changes on every click.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个应用程序非常简单，但其中的图表有不同的动态名称，如你在图表标题中看到的。这是基于`n_clicks`的动态值，它在每次点击时都会变化。
- en: 'The amount of code required to generate this is similar to any simple app;
    there isn''t much complexity involved. We just need to look at it with fresh eyes.
    Let''s start by coding the layout, which will consist of two simple components:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 生成这个所需的代码量与任何简单应用程序类似；其中没有太多复杂性。我们只需要以新的视角来看待它。让我们从编写布局代码开始，布局将由两个简单的组件组成：
- en: 'Create a button to trigger the addition of new charts:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个按钮，用于触发添加新图表：
- en: '[PRE25]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Create an empty div, with its `children` attribute set to an empty list. The
    empty list is the key element that we will be working with:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个空的div，并将其`children`属性设置为空列表。这个空列表是我们将要操作的关键元素：
- en: '[PRE26]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: When this app loads for the first time, the user only sees a button that they
    can use to add a chart. The area below it gets populated with an additional chart
    every time they click the button.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当此应用程序第一次加载时，用户只会看到一个按钮，他们可以使用这个按钮来添加一个图表。每次点击按钮时，按钮下方的区域将填充一个新的图表。
- en: 'Let''s now create the callback function for this app:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们为这个应用程序创建回调函数：
- en: 'Create the `Output`, `Input`, and `State` arguments as usual. The interesting
    part to notice here is that the `children` property of the empty div acts both
    as `Output` and as `State`. We usually take some component''s value and use it
    to influence or change another component in the app. Who said we can''t take a
    component, make a change to it, and return it back to where it came from in its
    new state? This is exactly what we will do:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 像往常一样创建`Output`、`Input`和`State`参数。这里需要注意的有趣部分是，空div的`children`属性既充当`Output`又充当`State`。我们通常会获取某个组件的值，并用它来影响或改变应用程序中另一个组件的状态。谁说我们不能获取一个组件，改变它，然后将其以新状态返回原处呢？这正是我们将要做的：
- en: '[PRE27]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Create the function signature and check for `n_clicks`. Note here that `children`
    is acting as `State` in this case:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建函数签名并检查`n_clicks`。请注意，在这种情况下，`children`充当`State`：
- en: '[PRE28]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Create an empty bar chart with a dynamic title, using the `n_clicks` property:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个带有动态标题的空条形图，使用`n_clicks`属性：
- en: '[PRE29]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Append the new chart to the `children` component. If you remember, we set the
    initial value of `children` in the empty div as an empty list. The following line
    will take this list and append `new_chart` to it. There is nothing special about
    this; we are simply using Python''s `list.append` method:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新图表附加到`children`组件中。如果你记得，我们将空div中`children`的初始值设置为空列表。接下来的这一行将取出这个列表，并将`new_chart`添加到其中。这没有什么特别的；我们只是简单地使用Python的`list.append`方法：
- en: '[PRE30]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now that our `children` list has been mutated by appending a new item to it,
    we simply return it. Keep in mind that the return value of the callback function
    will go to the div, and so now it is acting as an output:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们的`children`列表已经通过向其中添加新项而被修改，我们只需返回它。请记住，回调函数的返回值将传递到div中，因此它现在充当输出：
- en: '[PRE31]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Note that this functionality was created by the application of simple principles.
    We aren't using any new features here. The first technique was passing `children`
    to our callback, and receiving it from the other side. The second one was using
    the `n_clicks` property to dynamically set the titles of the charts.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个功能是通过应用简单原则创建的。我们并没有使用任何新功能。第一个技巧是将`children`传递给我们的回调，并从另一端接收它。第二个技巧是使用`n_clicks`属性来动态设置图表的标题。
- en: 'The diagram in *Figure 10.7* shows the relationship between the elements we
    created:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10.7* 中的图示显示了我们创建的元素之间的关系：'
- en: '![Figure 10.7 – A callback function graph where a function returned a component
    that it received and mutated](img/B16780_10_7.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图10.7 – 一个回调函数图，其中一个函数返回它接收到并变更的组件](img/B16780_10_7.jpg)'
- en: Figure 10.7 – A callback function graph where a function returned a component
    that it received and mutated
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.7 – 一个回调函数图，其中一个函数返回它接收到并变更的组件
- en: This diagram will remain the same regardless of the number of charts that were
    added to the app. This means you don't have to worry about managing as many callback
    functions as there are clicks.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这个图表在应用中添加多少个图表并不会改变。这意味着你无需担心管理与点击次数相同的回调函数。
- en: If you are ready to take this even further, we can add another component under
    each chart, for example, a `Dropdown` component. And we can let the dropdown's
    selected value produce a chart. Each dropdown value will be independent of the
    others (if added by the user) and will only modify the chart it belongs to. The
    good news is that all this will also be managed with one additional callback function
    utilizing pattern-matching callbacks.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你准备好进一步扩展，我们可以在每个图表下方再添加一个组件，例如一个`Dropdown`组件。我们可以让下拉框选择的值生成图表。每个下拉框的值将独立于其他值（如果是用户添加的），并且只会修改它所属的图表。好消息是，所有这些也将通过一个额外的回调函数，利用模式匹配回调来管理。
- en: Introducing pattern-matching callbacks
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入模式匹配回调
- en: Mastering this feature, and here we are dealing with a truly new feature, will
    allow you to take your apps to a new level of interactivity and power. The most
    important feature of this capability is that it allows us to handle the interactivity
    of components that didn't exist before. As we've done so far, when we allowed
    users to create new charts by clicking a button, those components did not exist
    before in the app. The more interesting thing is that the callback function that
    handles them all is as simple as any other callback that takes values from a dropdown
    and produces a chart. The trick is in slightly changing the `id` attribute of
    our components.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 掌握这个功能（我们现在正在处理一个真正的新功能）将使你能够将应用提升到一个新的交互性和功能性水平。这个功能的最重要特点是，它允许我们处理那些以前不存在的组件的交互性。正如我们之前所做的，当我们允许用户通过点击按钮创建新的图表时，这些组件在应用中之前并不存在。更有趣的是，处理这些组件的回调函数与任何其他从下拉框获取值并生成图表的回调函数一样简单。诀窍在于稍微改变我们组件的`id`属性。
- en: 'So far, we have set the `id` attributes as strings, and the only requirement
    was that they be unique. We will now introduce a new way of creating this attribute,
    which is by using dictionaries. Let''s first take a look at the end goal, then
    modify the layout, the callbacks, and finally, discuss the new way of handling
    the `id` property. *Figure 10.8* shows what our app will look like:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直将`id`属性设置为字符串，唯一的要求是它们必须是唯一的。现在我们将介绍一种新的创建该属性的方法，即使用字典。让我们首先看看最终目标，然后修改布局、回调函数，最后讨论新的`id`属性处理方法。*图10.8*展示了我们的应用将会是什么样子：
- en: '![Figure 10.8 – An app allowing users to add interactive components to the
    app''s layout](img/B16780_10_8.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图10.8 – 一个允许用户向应用布局中添加交互式组件的应用](img/B16780_10_8.jpg)'
- en: Figure 10.8 – An app allowing users to add interactive components to the app's
    layout
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.8 – 一个允许用户向应用布局中添加交互式组件的应用
- en: In the previous app, we were able to let the user generate new components on
    the fly, and their content could be dynamic as well. We demonstrated this with
    chart titles, using the `n_clicks` property to set the title dynamically. But
    after adding those charts, the user couldn't interact with them. In other words,
    they are dynamically generated, with potentially dynamic content, but once generated,
    they are static, and we cannot interact with them.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的应用程序中，我们能够让用户实时生成新组件，并且这些组件的内容也可以是动态的。我们通过图表标题演示了这一点，使用`n_clicks`属性动态设置标题。但是，在添加这些图表后，用户无法与它们进行互动。换句话说，它们是动态生成的，可能具有动态内容，但一旦生成，它们就变成了静态的，我们无法与它们互动。
- en: The improvement we are now introducing is that we are making those charts interactive
    (using the dropdowns) and having each of them linked to a single component, a
    dropdown in this case. As you can see in *Figure 10.8*, each chart comes with
    its own dropdown, and the user can independently generate multiple charts on top
    of one another and compare. After that, they can do even more, by selecting different
    countries on different charts. Of course, you can imagine a more involved set
    of apps where users can do many other things.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在引入的改进是，我们使得这些图表具有交互性（使用下拉框），并将每个图表与一个单独的组件（在此情况下为下拉框）关联。如*图 10.8*所示，每个图表都有自己的下拉框，用户可以在图表上独立生成多个图表并进行对比。之后，用户还可以通过选择不同的国家，查看不同图表的数据。当然，你可以想象一个更复杂的应用集合，用户可以在其中进行更多操作。
- en: 'The new additions to create this new functionality will be done in three steps:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 创建这个新功能的新增内容将分为三个步骤：
- en: 'Modify the `add_new_chart` function: This will simply consist of adding a dropdown
    under each chart and appending two components, instead of one. Note that the layout
    is exactly the same. We simply have a button and an empty div underneath it.'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`add_new_chart`函数：这将只是简单地在每个图表下添加一个下拉框，并附加两个组件，而不是一个。请注意，布局完全相同。我们只是在它下面有一个按钮和一个空的div。
- en: 'Create a new callback function: This will link the newly generated pairs of
    charts and dropdowns to determine their behavior.'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的回调函数：这将把新生成的图表和下拉框对连接起来，以确定它们的行为。
- en: 'Modify the `id` attributes in the app: This is where we introduce the new functionality
    and is the main feature that allows us to manage as many additional components
    and their interactivity using a single callback function.'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改应用中的`id`属性：这是我们引入新功能的地方，也是主要功能，它允许我们通过一个回调函数管理多个附加组件及其交互性。
- en: 'We first start by modifying the `add_new_chart` callback function:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先开始修改`add_new_chart`回调函数：
- en: 'We defined `new_chart` in the function, and this remains the same. Right under
    that, we want to add `new_dropdown` for users to select the country that they
    want to visualize:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在函数中定义了`new_chart`，这一部分保持不变。在它下面，我们要添加`new_dropdown`，以供用户选择他们想要可视化的国家：
- en: '[PRE32]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Append the new components. In the first example, we appended `new_chart`, but
    this time, we want to append the two items. The only thing to modify is to put
    the two new components in a new div and append the new div. This way, we are effectively
    appending one element (the div that contains two elements):'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加新组件。在第一个示例中，我们附加了`new_chart`，但这次我们想要附加两个项目。唯一需要修改的地方是将这两个新组件放入一个新的div中，并附加这个新div。这样，我们实际上是在附加一个包含两个元素的div元素：
- en: '[PRE33]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This is enough to cause the button to append two items for each click. As you
    can see, the change was very simple. However, we will later come to set the `id`
    attributes for these components in order to make them dynamically interactive.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这足以让按钮每次点击时添加两个项目。如你所见，变动非常简单。然而，稍后我们会设置这些组件的`id`属性，以使它们能够动态交互。
- en: 'Now we have pairs of components added with every click on our button. One of
    them has to be an `Output` element (`Graph`), and the other has to be an `Input`
    element (`Dropdown`). As with every other interactivity feature, they need to
    be linked with a callback function. We will create this now, and after that, we
    will take a look at how to link those dynamic IDs together and manage how the
    two callbacks interact with each other. The function is as simple as any callback
    that we have created so far. Here it is, but without the decorator, which we will
    discuss right after:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在每次点击按钮时，我们都添加一对组件。其中一个必须是`Output`元素（图表），另一个必须是`Input`元素（下拉框）。与其他交互功能一样，它们需要通过回调函数进行关联。我们现在就创建这个回调函数，之后我们会看看如何将这些动态ID连接在一起，并管理这两个回调函数的交互。这个函数和我们之前创建的任何回调一样简单。下面是代码，但没有装饰器，我们稍后会讨论装饰器：
- en: '[PRE34]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '*Figure 10.9* contains a diagram showing our pattern-matching callback function:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10.9*包含一个展示我们模式匹配回调函数的图示：'
- en: '![Figure 10.9 – The callback graph of a pattern-matching callback](img/B16780_10_9.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.9 – 模式匹配回调的回调图](img/B16780_10_9.jpg)'
- en: Figure 10.9 – The callback graph of a pattern-matching callback
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.9 – 模式匹配回调的回调图
- en: The top graph in *Figure 10.9* is exactly the same as the one in *Figure 10.7*.
    It is for the simple function that adds new charts by appending them to the children
    of the empty div. Note that the `id` attributes are labeled above each box representing
    a component. Here they are **button** and **output**.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10.9*中的顶部图表与*图10.7*中的完全相同。它用于简单的功能，通过将新的图表附加到空div的子元素中来添加图表。请注意，`id`属性位于每个表示组件的框上方。这里它们是**button**和**output**。'
- en: The graph for the second callback, `create_population_chart`, shows a similar
    structure, but the IDs are dictionaries and not strings.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个回调函数`create_population_chart`的图表显示了类似的结构，但其中的ID是字典类型，而不是字符串。
- en: Pattern-matching callbacks use those dictionaries to map the different elements
    together. Let's unpack those dictionaries and then see how they fit into the callbacks.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 模式匹配回调使用这些字典来将不同的元素匹配在一起。让我们来拆解这些字典，然后看看它们如何与回调函数配合。
- en: 'The first one is `{"index": MATCH, "type": "dropdown"}`. I believe the **type**
    key is clear. We use it to make it easy to identify other components whose "type"
    is "dropdown." It''s important to note that these names could be anything, but
    obviously we would want meaningful and helpful names. The other dictionary has
    **chart** for its **type** key. Again, this is also flexible, but I think it''s
    clear here which elements we are referring to.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '第一个是`{"index": MATCH, "type": "dropdown"}`。我相信**type**键是明确的。我们使用它来方便识别其他“类型”为“dropdown”的组件。需要注意的是，这些名称可以是任何内容，但显然我们会希望使用有意义且有帮助的名称。另一个字典的**type**键是**chart**。同样，这也是灵活的，但我认为在这里我们清楚地知道是指哪些元素。'
- en: Now we want to have independent functionality for each pair of components. In
    other words, we want the user to be able to modify the second dropdown, generating
    whatever chart they want, without that action affecting any other components in
    the app. How do we achieve that? We simply tell Dash to match them, with `MATCH`.
    This again belongs to an arbitrarily named key, `MATCH` is a wildcard object that
    is available in the `dash.dependencies` module. There are also `ALL` and `ALLSMALLER`,
    which work in a similar way with slight differences, but we will mainly focus
    on `MATCH`. Now let's take a look at how the updated functions need to be specified
    to cater to those IDs. The good news is that the only things we have to change
    are the `id` attributes of the relevant components and pass them to the relevant
    callback function arguments.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们希望为每对组件提供独立的功能。换句话说，我们希望用户能够修改第二个下拉框，生成他们想要的任何图表，而不影响应用中的其他组件。我们怎么实现这一点呢？我们只需要告诉Dash使用`MATCH`来进行匹配。这个功能属于一个任意命名的键，`MATCH`是一个通配符对象，位于`dash.dependencies`模块中。还有`ALL`和`ALLSMALLER`，它们的工作方式相似，但有些细微差别，我们将主要关注`MATCH`。现在让我们来看一下，如何指定更新后的函数来适应这些ID。好消息是，我们只需要修改相关组件的`id`属性，并将其传递给相应的回调函数参数。
- en: 'We are now ready to add the proper `id` attributes to complete the pattern-matching
    callbacks. The first function, `add_new_chart`, takes the new dictionary `id`
    attributes for the inner components that we allow the user to add to the app.
    Note here that the "index" key takes `n_clicks` as its value. This value, as we
    saw several times, is dynamic and changes every time the user clicks the button.
    This means that every time the user clicks the button, we have a new unique ID
    with which we can identify this component:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备好添加适当的`id`属性，以完成模式匹配回调。第一个函数`add_new_chart`接受新字典`id`属性，用于表示允许用户添加到应用中的内部组件。请注意，这里的“index”键的值是`n_clicks`。正如我们之前多次看到的，它是动态的，每次用户点击按钮时都会发生变化。这意味着每次用户点击按钮时，我们都会得到一个新的唯一ID，用来标识这个组件：
- en: '[PRE35]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now we have to map those IDs properly in the second function that is responsible
    for managing their interactivity. The "`type`" key will be used to map "`chart`"
    to "`chart`" and "`dropdown`" to "`dropdown`". As for `n_clicks`, since it is
    dynamic, we match it with `MATCH`:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要在负责管理这些组件交互性的第二个函数中正确地映射这些ID。"`type`"键将用于将"`chart`"映射到"`chart`"和将"`dropdown`"映射到"`dropdown`"。至于`n_clicks`，由于它是动态的，我们使用`MATCH`进行匹配：
- en: '[PRE36]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Here you can find the full code for the two functions as a reference to get
    the full picture:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是两者函数的完整代码，作为参考，帮助你全面了解：
- en: '[PRE37]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: You can easily imagine how flexible and extensible our apps can become with
    such functionality, not to mention the ease of managing callbacks. Yet they are
    not straightforward and might need some time to get used to, which I believe is
    worth it.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以很容易想象，拥有这样的功能后，我们的应用将变得多么灵活和可扩展，更不用提回调管理的便利性了。然而，这些功能并不直接，可能需要一些时间去适应，我相信这是值得的。
- en: We introduced many new concepts around callbacks, utilized some tricks, and
    introduced new functionality. So, let's review what was covered in the chapter.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们介绍了许多关于回调的新概念，利用了一些技巧，并引入了新的功能。那么，接下来让我们回顾一下这一章中讲解的内容。
- en: Summary
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We first introduced the optional `State` argument to callback function decorators.
    We saw how by combining it with `Input`, we can defer the execution of functions
    until the user decides to execute them. We also ran several examples that added
    buttons to invoke the execution. We then created a simple app where the user's
    inputs to a certain component were used to dynamically populate options of another
    component that was "waiting." Those new options were in turn used to create another
    component.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先介绍了回调函数装饰器中的可选`State`参数。我们展示了如何将其与`Input`结合使用，从而延迟执行函数，直到用户决定执行它们。我们还运行了几个示例，添加了按钮来触发执行。然后，我们创建了一个简单的应用，其中用户对某个组件的输入用于动态填充另一个“等待”组件的选项。这些新选项反过来又被用于创建另一个组件。
- en: Another interesting application of simple principles was allowing users to add
    new components having dynamic content.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的应用是允许用户添加具有动态内容的新组件。
- en: We finally introduced the most powerful and flexible feature, the pattern-matching
    callbacks. We created an app where users are able to add as many charts as they
    want. Furthermore, those charts acted independently from one another, and users
    were empowered to customize their own dashboard.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终介绍了最强大和最灵活的功能——模式匹配回调。我们创建了一个应用，用户可以添加任意多的图表，而且这些图表相互独立，用户可以定制自己的仪表盘。
- en: That was a lot to cover, and we turn next to another feature that allows us
    to extend and expand our apps. We can only have so many components on a page until
    it becomes cluttered. In many cases, it makes sense to create separate pages/URLs
    for separate functionality, which is the topic of the next chapter.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这涵盖了很多内容，接下来我们将讨论另一个功能，它允许我们扩展和扩展我们的应用。页面上的组件数量是有限的，超过一定数量就会变得杂乱无章。在许多情况下，为了实现不同的功能，创建单独的页面/URL是有意义的，这也是下一章的主题。
