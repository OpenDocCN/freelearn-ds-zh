- en: Comprehensive Examples
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 综合示例
- en: In this chapter, we will present some comprehensive and longer examples together
    with a brief introduction to the theoretical background and the examples' complete
    implementation. Here, we want to show you how the concepts defined in this book
    are used in practice.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将提供一些综合性和较长的示例，并简要介绍理论背景以及示例的完整实现。在这里，我们希望向您展示本书中定义的概念如何在实践中应用。
- en: 'The following topics are covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Polynomials
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多项式
- en: The polynomial class
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多项式类
- en: Spectral clustering
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 谱聚类
- en: Solving initial value problems
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 求解初值问题
- en: 19.1 Polynomials
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 19.1 多项式
- en: First, we will demonstrate the power of the Python constructs presented so far
    by designing a class for polynomials.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将通过设计一个多项式类来展示迄今为止所介绍的 Python 构造的强大功能。
- en: Note that this class differs conceptually from the class `numpy.poly1d`.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个类在概念上与类 `numpy.poly1d` 不同。
- en: We will give some theoretical background, which will lead us to a list of requirements,
    and then we will give the code, with some comments.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将提供一些理论背景，这将引导我们列出需求，然后给出代码并附带一些注释。
- en: 19.1.1 Theoretical background
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 19.1.1 理论背景
- en: A polynomial [![](img/cf676805-9214-4814-86d5-3f6ddf906703.png)] is defined
    by its degree, representation, and coefficients. The polynomial representation
    shown in the preceding equation is called a *monomial representation*. In this
    representation, the polynomial is written as a linear combination of monomials
    ![](img/25b413e8-ec70-4273-8da1-e78fd46d3204.png).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 多项式 [![](img/cf676805-9214-4814-86d5-3f6ddf906703.png)] 由其阶数、表示法和系数定义。前面方程中展示的多项式表示法称为*单项式表示法*。在这种表示法中，多项式作为单项式的线性组合书写
    ![](img/25b413e8-ec70-4273-8da1-e78fd46d3204.png)。
- en: 'Alternatively, the polynomial can be written in:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，可以将多项式写成：
- en: '*Newton representation* with the coefficients ![](img/2e618d07-978d-4237-bb3b-49555b6fe6e6.png) and
    ![](img/776c7cef-d36a-4f49-8901-51d328d1e685.png) points, ![](img/70f4144b-4316-4d28-b040-817d7ab6231f.png):'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有系数的*牛顿表示法* [![](img/2e618d07-978d-4237-bb3b-49555b6fe6e6.png)] 和 [![](img/776c7cef-d36a-4f49-8901-51d328d1e685.png)]
    点，![](img/70f4144b-4316-4d28-b040-817d7ab6231f.png)：
- en: '![](img/176d225f-eaa2-4651-81a8-8553ef1c652a.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](img/176d225f-eaa2-4651-81a8-8553ef1c652a.png)'
- en: '*Lagrange representation *with the coefficients [![](img/18da50b7-20fb-43eb-9604-eb89b6c8a06e.png)]
    and [![](img/01acca46-18e0-49c4-953b-9c7ea04ef10e.png)] points, ![](img/a116db99-24f1-4ab8-a73d-0faa9559dca3.png):'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有系数的*拉格朗日表示* [![](img/18da50b7-20fb-43eb-9604-eb89b6c8a06e.png)] 和 [![](img/01acca46-18e0-49c4-953b-9c7ea04ef10e.png)]
    点，![](img/a116db99-24f1-4ab8-a73d-0faa9559dca3.png)：
- en: '![](img/cee88b71-4869-478a-a99b-3d922588ce2d.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cee88b71-4869-478a-a99b-3d922588ce2d.png)'
- en: 'with the cardinal functions:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 使用基函数：
- en: '![](img/53259454-4064-48ab-98ae-ba040828abed.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](img/53259454-4064-48ab-98ae-ba040828abed.png)'
- en: There are infinitely many representations, but we restrict ourselves here to
    these three typical ones.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 有无穷多种表示方法，但我们这里只限制于这三种典型表示。
- en: 'A polynomial can be determined from interpolation conditions:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 多项式可以通过插值条件确定：
- en: '![](img/7b6f78ad-9108-4210-861c-da2b195b4552.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7b6f78ad-9108-4210-861c-da2b195b4552.png)'
- en: 'with the given distinct values ![](img/df8177e3-c79a-47ce-bc35-4799dd8db630.png) and
    arbitrary values ![](img/ac1fbb98-6657-4d5e-9e9f-8a7a253adf9d.png) as input. In
    the Lagrange formulation, the interpolation polynomial is directly available,
    as its coefficients are the interpolation data. The coefficients for the interpolation
    polynomial in Newton representation can be obtained by a recursion formula, called
    the divided differences formula:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 给定不同的值 ![](img/df8177e3-c79a-47ce-bc35-4799dd8db630.png) 和任意值 ![](img/ac1fbb98-6657-4d5e-9e9f-8a7a253adf9d.png)
    作为输入。在拉格朗日公式中，插值多项式是直接可用的，因为其系数即为插值数据。牛顿表示法中的插值多项式系数可以通过递推公式获得，称为分差公式：
- en: '![](img/f9754f5f-e78a-4dbb-ab86-37ae62e43ecf.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f9754f5f-e78a-4dbb-ab86-37ae62e43ecf.png)'
- en: and
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 和
- en: '![](img/d4e1d2e6-7cbb-4959-944b-b8dbde44a6d9.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d4e1d2e6-7cbb-4959-944b-b8dbde44a6d9.png)'
- en: We then obtain the coefficients by ![](img/ea7657c7-0560-412c-b631-ab76258bc65a.png).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们通过 ![](img/ea7657c7-0560-412c-b631-ab76258bc65a.png) 获得系数。
- en: 'The coefficients of the interpolation polynomial in monomial representation
    are obtained by solving a linear system:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 单项式表示法中插值多项式的系数通过解线性系统获得：
- en: '![](img/b1c6949c-0d77-4b76-aa57-b3ba3ddb7e0a.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b1c6949c-0d77-4b76-aa57-b3ba3ddb7e0a.png)'
- en: 'A matrix that has a given polynomial ![](img/2baead6e-97d1-4d9e-8b27-d18720ef5356.png) (or
    a multiple of it) as its characteristic polynomial is called a *companion matrix*.
    The eigenvalues of the companion matrix are the zeros (roots) of the polynomial.
    An algorithm for computing the zeros of ![](img/5b023d20-84ee-4e91-b5e8-f6620cfb7579.png) can
    be constructed by first setting up its companion matrix and then computing the
    eigenvalues with `scipy.linalg.eig`. The companion matrix for a polynomial in
    Newton representation reads as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 一个具有给定多项式![](img/2baead6e-97d1-4d9e-8b27-d18720ef5356.png)（或其倍数）作为特征多项式的矩阵被称为*伴随矩阵*。伴随矩阵的特征值即为多项式的零点（根）。通过先建立其伴随矩阵，再使用`scipy.linalg.eig`计算特征值，可以构建一个计算![](img/5b023d20-84ee-4e91-b5e8-f6620cfb7579.png)零点的算法。牛顿表示下的多项式的伴随矩阵如下所示：
- en: '![](img/c8b727bb-a74b-4a36-b9a6-b814fe568d52.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c8b727bb-a74b-4a36-b9a6-b814fe568d52.png)'
- en: 19.1.2 Tasks
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 19.1.2 任务
- en: 'We can now formulate some programming tasks:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以制定一些编程任务：
- en: 'Write a class called `PolyNomial` with the attributes `points`, `degree`, `coeff`,
    and `basis`, where:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个名为`PolyNomial`的类，具有`points`、`degree`、`coeff`和`basis`属性，其中：
- en: '`points` is a list of tuples ![](img/4afd74eb-4a3f-4f69-bb79-76ec30fe0648.png).'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`points` 是一个元组列表！[](img/4afd74eb-4a3f-4f69-bb79-76ec30fe0648.png)。'
- en: '`degree` is the degree of the corresponding interpolation polynomial.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`degree` 是相应插值多项式的阶数。'
- en: '`coeff` contains the polynomial coefficients.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`coeff` 包含多项式的系数。'
- en: '`basis` is a string stating which representation is used.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`basis` 是一个字符串，指明所使用的表示形式。'
- en: Provide the class with a method for evaluating the polynomial at a given point.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为类提供一个方法，用于在给定点上评估多项式。
- en: Provide the class with a method called `plot` that plots the polynomial over
    a given interval.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为类提供一个名为`plot`的方法，用于在给定区间内绘制多项式。
- en: Write a method called `__add__` that returns a polynomial that is the sum of
    two polynomials. Be aware that only in the monomial case the sum can be computed
    by just summing up the coefficients.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个名为`__add__`的方法，返回两个多项式的和。需要注意的是，只有在单项式情况下，才能通过简单地将系数相加来计算和。
- en: Write a method that computes the coefficients of the polynomial represented
    in a monomial form.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个方法，计算表示为单项式形式的多项式的系数。
- en: Write a method that computes the polynomial's companion matrix.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个方法，计算多项式的伴随矩阵。
- en: Write a method that computes the zeros of the polynomial by computing the eigenvalues
    of the companion matrix.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个方法，通过计算伴随矩阵的特征值来计算多项式的零点。
- en: Write a method that computes the polynomial that is the ![](img/9ca472ad-554e-4ea9-b316-765cf23dbeac.png)^(th)
    derivative of the given polynomial.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个方法，计算给定多项式的![](img/9ca472ad-554e-4ea9-b316-765cf23dbeac.png)^(th) 导数。
- en: Write a method that checks whether two polynomials are equal. Equality can be
    checked by comparing all coefficients (zero leading coefficients should not matter).
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个方法，检查两个多项式是否相等。可以通过比较所有系数来检查相等性（零的首项系数不应影响结果）。
- en: 19.1.3 The polynomial class
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 19.1.3 多项式类
- en: 'Let''s now design a polynomial base class based on a monomial formulation of
    the polynomial. The polynomial can be initialized either by giving its coefficients
    with respect to the monomial basis or by giving a list of interpolation points,
    as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们基于单项式形式设计一个多项式基类。多项式可以通过给定其相对于单项式基的系数，或通过给定插值点列表来初始化，如下所示：
- en: '[PRE0]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The method `__init__` of the new class uses the construction `**args` as discussed
    in [Section 7.2.5](35749482-dbc7-41b2-aa19-dc63b242f18f.xhtml): *Variable number
    of arguments*. If no arguments are given, a zero polynomial is assumed. If the
    polynomial is given by interpolation points, the method used to compute the coefficients
    by solving a Vandermonde system is given as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 新类的`__init__`方法使用了构造`**args`，如[第7.2.5节](35749482-dbc7-41b2-aa19-dc63b242f18f.xhtml)中讨论的：*可变参数个数*。如果没有给定参数，则默认假定为零多项式。如果多项式由插值点给出，计算系数的方法是通过求解范德蒙矩阵系统，方法如下：
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'From [![](img/bcadae8d-6f6c-4b63-b486-8cdf1416a059.png)] given coefficients, [![](img/801a6016-08c3-4345-bec7-9b624ca74d69.png)]
    interpolation points are constructed by:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 从[![](img/bcadae8d-6f6c-4b63-b486-8cdf1416a059.png)] 给定的系数，[![](img/801a6016-08c3-4345-bec7-9b624ca74d69.png)]
    插值点由以下方式构造：
- en: '[PRE2]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The command `self(x)` does a polynomial evaluation, which is done by providing
    a method `__call__`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 命令`self(x)`进行多项式评估，这通过提供`__call__`方法来实现：
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '(See also the example for the method `__call__` in [Section 8.1.5](1654fae9-6203-4871-8352-e436445fa49a.xhtml):
    *Special methods.*) Here, this method uses the NumPy command `polyval`. As a next
    step, we just add for convenience two methods, which we decorate with the `property`
    decorator (see also [Section 7.8](35749482-dbc7-41b2-aa19-dc63b242f18f.xhtml):
    *Functions as decorators**)*:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: （参见[第 8.1.5 节](1654fae9-6203-4871-8352-e436445fa49a.xhtml)中的`__call__`方法示例：*特殊方法*。）这里，该方法使用了NumPy命令`polyval`。接下来的步骤，我们只需为了方便添加两个方法，并用`property`装饰器装饰它们（参见[第
    7.8 节](35749482-dbc7-41b2-aa19-dc63b242f18f.xhtml)：*作为装饰器的函数**)*：
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s explain what is going on here. We define a method to extract the ![](img/51485369-65e9-4da0-811d-1947fbb24f27.png)values
    of the data, which were used to define the polynomial. Similarly, a method to
    extract the ![](img/3a9672e4-ff7e-43b3-8049-7fc79880852c.png)values of the data
    is defined. With the `property` decorator, the result of calling the method is
    presented as if it were just an attribute of the polynomial. There are two coding
    alternatives:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们解释一下这里发生了什么。我们定义了一个方法来提取定义多项式时使用的数据的 ![](img/51485369-65e9-4da0-811d-1947fbb24f27.png)值。类似地，也定义了一个提取数据
    ![](img/3a9672e4-ff7e-43b3-8049-7fc79880852c.png)值的方法。通过`property`装饰器，调用该方法的结果呈现得就像它是多项式的一个属性一样。这里有两种编码选择：
- en: 'We use a method call:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用方法调用：
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This gives access to the ![](img/4b12e4f2-67b2-4d6f-b995-0911ae5ca323.png)values
    by the call: `p.x()`.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这通过调用：`p.x()`提供对 ![](img/4b12e4f2-67b2-4d6f-b995-0911ae5ca323.png)值的访问。
- en: We use the `property` decorator. It permits us to access the ![](img/35b8b3fb-62ea-4a59-9044-bcb3cffd718c.png)values
    simply by using this statement: `p.x`. We choose here the second variant.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`property`装饰器。它允许我们通过以下语句轻松访问 ![](img/35b8b3fb-62ea-4a59-9044-bcb3cffd718c.png)值：`p.x`。我们在这里选择第二种变体。
- en: 'It is always a good practice to define a `__repr__` method (see also [Section
    8.1.5](1654fae9-6203-4871-8352-e436445fa49a.xhtml): *Special methods.*). At least
    for a quick check of the results, this method is useful:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 定义`__repr__`方法始终是一个好习惯（参见[第 8.1.5 节](1654fae9-6203-4871-8352-e436445fa49a.xhtml)：*特殊方法*）。至少对于快速检查结果，这个方法非常有用：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We now provide a method for plotting the polynomial, as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们提供一个用于绘制多项式的方法，如下所示：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Note the use of the command `vectorize` (see [Section 4.8](b9f628e9-f682-41be-b5a6-94359f8629fc.xhtml):
    *Functions acting on arrays*). The method `__call__` is specific to the monomial
    representation and has to be changed if a polynomial is represented in another
    way. This is also the case for the computation of the polynomial''s companion
    matrix:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意使用`vectorize`命令（参见[第 4.8 节](b9f628e9-f682-41be-b5a6-94359f8629fc.xhtml)：*作用于数组的函数*）。`__call__`方法是特定于单项式表示的，如果多项式以其他方式表示，则必须进行更改。这对于计算多项式的伴随矩阵也是如此：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Once the companion matrix is available, the zeros of the polynomial are given
    by its eigenvalues:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦伴随矩阵可用，给定多项式的零点就是它的特征值：
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: To this end, the module `scipy.linalg` has to be imported first as `sl`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，必须首先导入模块`scipy.linalg`，并命名为`sl`。
- en: 19.1.4 Usage examples of the polynomial class
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 19.1.4 多项式类的使用示例
- en: Let's give some usage examples.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们给出一些使用示例。
- en: 'First, we create a polynomial instance from the given interpolation points:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们从给定的插值点创建一个多项式实例：
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The polynomial''s coefficients with respect to the monomial basis are available
    as an attribute of `p`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 相对于单项式基，多项式的系数作为`p`的一个属性提供：
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This corresponds to the polynomial ![](img/7d283009-8ea6-4ff2-b454-6ef8dba0c847.png) .
    The default plot of the polynomial, obtained by `p.plot((-3.5,3.5))`, results
    in the following figure (*Figure 19.1*):'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这对应于多项式 ![](img/7d283009-8ea6-4ff2-b454-6ef8dba0c847.png) 。通过`p.plot((-3.5,3.5))`获得的多项式默认图形如下所示（*图
    19.1*）：
- en: '![](img/25f8b282-b144-4a5b-9172-0f4b0a6bb942.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/25f8b282-b144-4a5b-9172-0f4b0a6bb942.png)'
- en: 'Figure 19.1: Result of the polynomial plot method'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图 19.1：多项式绘图方法的结果
- en: 'Finally, we compute the zeros of the polynomial, which in this case are two
    real numbers:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们计算多项式的零点，在此案例中是两个实数：
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The result can be verified by evaluating the polynomial at these points:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 结果可以通过在这些点处评估多项式来验证：
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 19.1.5 Newton polynomial
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 19.1.5 牛顿多项式
- en: 'The class  `NewtonPolyNomial` defines a polynomial described with respect to
    the Newton basis. We let it inherit some common methods from the polynomial base
    class, for example, `polynomial.plot`, `polynomial.zeros`, and even parts of the
    `__init__` method, by using the command `super` (see [Section 8.5](1654fae9-6203-4871-8352-e436445fa49a.xhtml):
    S*ubclasses and inheritance*):'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 类 `NewtonPolyNomial` 定义了一个基于牛顿基的多项式。我们通过使用命令 `super` 让它继承自多项式基类的一些常用方法，例如 `polynomial.plot`、`polynomial.zeros`，甚至
    `__init__` 方法的部分内容（参见 [第8.5节](1654fae9-6203-4871-8352-e436445fa49a.xhtml)：*子类与继承*）：
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Once the interpolation points are given, the computation of the coefficients
    is performed by:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦给定插值点，系数的计算就通过以下方式进行：
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We used divided differences for computing the Newton representation of the
    polynomial, which is programmed as a generator here (see [Section 9.3.1](66c25bba-72d2-46a9-929a-1f57fa7a1684.xhtml):
    *Generators* and [Section 9.4](66c25bba-72d2-46a9-929a-1f57fa7a1684.xhtml): *List-filling
    patterns*):'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了分割差分来计算多项式的牛顿表示，这里编程为生成器（参见 [第9.3.1节](66c25bba-72d2-46a9-929a-1f57fa7a1684.xhtml)：*生成器*
    和 [第9.4节](66c25bba-72d2-46a9-929a-1f57fa7a1684.xhtml)：*列表填充模式*）：
- en: '[PRE16]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let''s briefly check how this works:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简单检查一下这个是如何工作的：
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The function `print` executes the method `__repr__` of the base class and returns
    the following text:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `print` 执行基类的 `__repr__` 方法并返回以下文本：
- en: '[PRE18]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The polynomial evaluation is different from the corresponding method of the
    base class. The method `NewtonPolyNomial.__call__` needs to override `Polynomial.__call__`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 多项式评估与基类的相应方法不同。方法 `NewtonPolyNomial.__call__` 需要重写 `Polynomial.__call__`：
- en: '[PRE19]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Finally, we give the code for the companion matrix, which overrides the corresponding
    method of the parent class, as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们给出了伴随矩阵的代码，该代码重写了父类的相应方法，如下所示：
- en: '[PRE20]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note the use of Boolean arrays. The exercises will further build on this foundation.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意布尔数组的使用。练习将进一步在此基础上构建。
- en: 19.2 Spectral clustering
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 19.2 谱聚类
- en: 'An interesting application of eigenvectors is for clustering data. Using the
    eigenvectors of a matrix derived from a distance matrix, unlabeled data can be
    separated into groups. Spectral clustering methods get their name from the use
    of the spectrum of this matrix. A distance matrix for ![](img/e27f1d49-c801-4539-8009-9cae5853b3cf.png) elements
    (for example, the pairwise distance between data points) is an ![](img/a36e8b17-7e0b-488d-96b3-29c79c5257f2.png) symmetric
    matrix. Given such an ![](img/6b3e95b7-0207-425e-b217-6a476a631685.png) distance
    matrix ![](img/3972f882-789e-45e6-afcc-d1663436700b.png) with distance values
    [![](img/3fc43757-4ebf-4dd5-8163-c0a68970c633.png)], we can create the Laplacian
    matrix of the data points as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 特征向量的一个有趣应用是用于数据聚类。通过使用由距离矩阵导出的矩阵的特征向量，可以将未标记的数据分成不同的组。谱聚类方法因使用该矩阵的谱而得名。对于 ![](img/e27f1d49-c801-4539-8009-9cae5853b3cf.png)
    元素（例如，数据点之间的成对距离）的距离矩阵是一个 ![](img/a36e8b17-7e0b-488d-96b3-29c79c5257f2.png) 对称矩阵。给定这样的
    ![](img/6b3e95b7-0207-425e-b217-6a476a631685.png) 距离矩阵 ![](img/3972f882-789e-45e6-afcc-d1663436700b.png)，具有距离值
    [![](img/3fc43757-4ebf-4dd5-8163-c0a68970c633.png)]，我们可以按以下方式创建数据点的拉普拉斯矩阵：
- en: '![](img/f5e9c5d5-826b-4e10-a5bb-94ca67e03e66.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f5e9c5d5-826b-4e10-a5bb-94ca67e03e66.png)'
- en: 'Here, ![](img/d9020f81-cd8b-4d22-bb23-c67c1326984c.png)  is the identity matrix
    and ![](img/04f5ec10-48e3-4051-822a-b701c6660c95.png) is the diagonal matrix containing
    the row sums of ![](img/a68ab07c-1d27-4a51-ba39-01c32f498aef.png):'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，![](img/d9020f81-cd8b-4d22-bb23-c67c1326984c.png) 是单位矩阵，![](img/04f5ec10-48e3-4051-822a-b701c6660c95.png)
    是包含 ![](img/a68ab07c-1d27-4a51-ba39-01c32f498aef.png) 行和列和的对角矩阵：
- en: '![](img/30e0893d-305e-4689-80f9-af0988bad720.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/30e0893d-305e-4689-80f9-af0988bad720.png)'
- en: The data clusters are obtained from the eigenvectors of *L*. In the simplest
    case of data points with only two classes, the first eigenvector (that is, the
    one corresponding to the largest eigenvalue) is often enough to separate the data.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 数据聚类是通过 *L* 的特征向量得到的。在只有两类数据点的最简单情况下，第一个特征向量（即对应最大特征值的那个）通常足以将数据分开。
- en: 'Here is an example of simple two-class clustering. The following code creates
    some 2D data points and clusters them based on the first eigenvector of the Laplacian
    matrix:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的二类聚类示例。以下代码创建了一些二维数据点，并基于拉普拉斯矩阵的第一个特征向量对其进行聚类：
- en: '[PRE21]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The eigenvector corresponding to the largest eigenvalue gives the grouping
    (for example, by thresholding at ![](img/e6b3a21e-af03-46d9-80e9-3822e2be13d2.png))
    and can be shown with:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 对应最大特征值的特征向量给出了分组（例如，通过在 ![](img/e6b3a21e-af03-46d9-80e9-3822e2be13d2.png) 处进行阈值化）并可以通过以下方式展示：
- en: '[PRE22]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The following figure (*Figure 19.2*) shows the result of spectral clustering
    of a simple two-class dataset:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图 (*图 19.2*) 显示了简单两类数据集的谱聚类结果：
- en: '![](img/d21da077-88f0-432f-9653-866b8bd452e5.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d21da077-88f0-432f-9653-866b8bd452e5.png)'
- en: 'Figure 19.2: The result of a simple two-class clustering'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图 19.2：简单两类聚类的结果
- en: For more difficult datasets and more classes, one usually takes the ![](img/67e01793-7925-419d-9a24-2f5622e534c5.png) eigenvectors
    corresponding to the ![](img/8a74fede-f0f6-4984-ae52-1fd9ae82de90.png) largest
    eigenvalues and then clusters the data with some other method, but using the eigenvectors
    instead of the original data points. A common choice is the ![](img/2e934e12-050c-43a9-b47d-31e0f3116490.png)-means
    clustering algorithm, which is the topic of the next example.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更难的数据集和更多的类别，通常会采用与最大特征值对应的 ![](img/67e01793-7925-419d-9a24-2f5622e534c5.png)
    特征向量，然后使用其他方法对数据进行聚类，但使用的是特征向量而不是原始数据点。常见的选择是 ![](img/2e934e12-050c-43a9-b47d-31e0f3116490.png)-均值聚类算法，这是下一个示例的主题。
- en: 'The eigenvectors are used as input to ![](img/8ec8c440-a221-41d9-a7e7-5e81d4aa3d23.png)-means
    clustering, as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 特征向量作为输入用于 ![](img/8ec8c440-a221-41d9-a7e7-5e81d4aa3d23.png)-均值聚类，如下所示：
- en: '[PRE23]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Note that we computed the eigenvectors here using the singular value decomposition
    `sl.svd`. As ***L*** is symmetric, the result is the same as if we had used `sl.eig`,
    but `svd` gives the eigenvectors already ordered corresponding to the ordering
    of the eigenvalues. We also used throw-away variables. `svd` returns a list with
    three arrays, the left and right singular vectors, `U` and `V`, and the singular
    values, `S`, as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在此使用奇异值分解 `sl.svd` 计算了特征向量。由于 ***L*** 是对称的，结果与使用 `sl.eig` 得到的结果相同，但 `svd`
    已经按照特征值的顺序给出了特征向量。我们还使用了临时变量。`svd` 返回一个包含三个数组的列表：左奇异向量 `U`、右奇异向量 `V` 和奇异值 `S`，如下所示：
- en: '[PRE24]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'As we do not need `U` and `S` here, we can throw them away when unpacking the
    return value of `svd`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在这里不需要 `U` 和 `S`，因此可以在解包 `svd` 返回值时丢弃它们：
- en: '[PRE25]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The result can be plotted using:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 结果可以通过以下方式绘制：
- en: '[PRE26]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The following figure shows the result of spectral clustering of a simple *multiclass
    dataset:*
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了简单 *多类数据集* 的谱聚类结果：
- en: '![](img/d6c2329b-1d89-463c-ae70-1b9a5f9ee6b3.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d6c2329b-1d89-463c-ae70-1b9a5f9ee6b3.png)'
- en: 'Figure 19.3: An example of the spectral clustering of a simple four-class dataset'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图 19.3：简单四类数据集的谱聚类示例
- en: 19.3 Solving initial value problems
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 19.3 求解初值问题
- en: 'In this section, we will consider the mathematical task of numerically solving
    a system of ordinary equations for given initial values:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将考虑数值求解给定初值的常微分方程组的数学任务：
- en: '*![](img/e0418f42-aa8c-4b88-8fce-613f81f6b860.png).*'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '*![](img/e0418f42-aa8c-4b88-8fce-613f81f6b860.png)。*'
- en: 'The solution to this problem is a function ![](img/b2d66ae4-6c74-4bba-996c-d8e96dfe0de4.png).
    A numerical method computes approximations, ![](img/86022693-bb97-4372-8e87-d5da6318504d.png) at
    discrete  communications points, ![](img/eca4b607-0793-4c58-b3e8-ea1fc795b35d.png),
    within the interval of interest ![](img/623b90f9-82a7-4c3d-8b57-3e05a6e609bb.png).
    We collect the data that describes the problem in a class as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 该问题的解是一个函数 ![](img/b2d66ae4-6c74-4bba-996c-d8e96dfe0de4.png)。数值方法在离散的通信点 ![](img/86022693-bb97-4372-8e87-d5da6318504d.png)
    计算近似值，![](img/eca4b607-0793-4c58-b3e8-ea1fc795b35d.png)，位于感兴趣的区间 ![](img/623b90f9-82a7-4c3d-8b57-3e05a6e609bb.png)
    内。我们将描述问题的数据收集到一个类中，如下所示：
- en: '[PRE27]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The differential equation:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 微分方程：
- en: '![](img/72d19335-7a55-49bd-ab95-52b19bba506a.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/72d19335-7a55-49bd-ab95-52b19bba506a.png)'
- en: describes a mathematical pendulum; *[![](img/1f7d35f1-bd53-44fd-86b1-227069293644.png) ]*is
    its angle with respect to the vertical axis, ***g*** is the gravitation constant,
    and ***l*** is its length. The initial angle is ![](img/d2dd5a5d-e940-4681-8d88-8805e1ad95bb.png)
    and the initial angular velocity is zero.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 描述了一个数学摆；* [![](img/1f7d35f1-bd53-44fd-86b1-227069293644.png)] *是其相对于竖直轴的角度，***g***
    是重力常数，***l*** 是摆长。初始角度是 ![](img/d2dd5a5d-e940-4681-8d88-8805e1ad95bb.png)，初始角速度为零。
- en: 'The pendulum problem becomes an instance of the problem class, as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 摆锤问题成为问题类的一个实例，如下所示：
- en: '[PRE28]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: There might be different views on the problem at hand, leading to a different
    design of the class. For example, one might want to consider the interval of independent
    variables as a part of a solution process instead of the problem definition. The
    same holds when considering initial values. They might, as we did here, be considered
    a part of the mathematical problem, while other authors might want to allow variation
    of initial values by putting them as a part of the solution process.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 对当前问题可能会有不同的看法，这会导致不同的类设计。例如，有人可能希望将自变量的区间视为解过程的一部分，而不是问题定义的一部分。考虑初值时也是如此。我们在这里将其视为数学问题的一部分，而其他作者可能希望将初值作为解过程的一部分，从而允许初值的变化。
- en: 'The solution process is modeled as another class:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 解决过程被建模为另一个类：
- en: '[PRE29]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We continue by first defining two discretization schemes:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来首先定义两个离散化方案：
- en: '*Explicit Euler method*:'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*显式欧拉方法*：'
- en: '[PRE30]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '*Classical Runge-Kutta four-stage method (RK4)*:'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*经典龙格-库塔四阶法（RK4）*：'
- en: '[PRE31]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'With these, we can create instances to obtain the corresponding discretized
    versions of the pendulum ODE:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些工具，我们可以创建实例以获得相应的摆锤常微分方程的离散化版本：
- en: '[PRE32]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We can solve the two discrete models and plot the solution and the angle difference:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以解决这两个离散模型并绘制解与角度差：
- en: '[PRE33]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '![](img/2465db96-4a0d-44db-af7f-52fb01eae181.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2465db96-4a0d-44db-af7f-52fb01eae181.png)'
- en: 'Figure 19.4: Pendulum simulation with the explicit Euler method and comparison
    with the results of the more accurate Runge–Kutta 4 method'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图 19.4：使用显式欧拉方法的摆锤模拟，并与更精确的龙格-库塔四阶法的结果进行比较
- en: It is worthwhile discussing alternative class designs. What should be put in
    separate classes, what should be bundled into the same class?
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 讨论替代的类设计是值得的。什么应该放在独立的类中，什么应该归并到同一个类中？
- en: We strictly separated the mathematical problem from the numerical method. Where
    should the initial values go? Should they be part of the problem or part of the
    solver? Or should they be left as input parameters for the solve method of the
    solver instance? One might even design the program so that it allows several possibilities.
    The decision to use one of these alternatives depends on the future use of this
    program. Looping over various initial values as in parameter identification would
    be eased by leaving the initial values as input parameters for the solve method.
    On the other hand, simulating different model variants with the same initial values
    would make coupling the initial values to the problem preferable.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们严格将数学问题与数值方法分开。初值应该放在哪里？它们应该是问题的一部分还是解算器的一部分？或者它们应该作为解算器实例的求解方法的输入参数？甚至可以设计程序，允许多种可能性。选择使用这些替代方案之一取决于未来程序的使用。像参数识别中的各种初值循环，留初值作为求解方法的输入参数会更方便。另一方面，模拟具有相同初值的不同模型变体时，将初值与问题绑定起来会更为合理。
- en: We presented for simplicity only solvers with a constant and given step size.
    Is the design of the `IVPsolver` class appropriate for a future extension of adaptive
    methods, where a tolerance rather than a step size is given?
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为简化起见，我们仅展示了使用常定步长的求解器。`IVPsolver`类的设计是否适用于未来扩展自适应方法，其中给定的是容差而非步长？
- en: We suggested earlier using a generator construction for the stepping mechanism.
    Adaptive methods need to reject steps from time to time. Is this need conflicting
    with the design of the stepping mechanism in `IVPsolver.onestepper`?
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们之前建议使用生成器构造来实现步进机制。自适应方法需要时不时地拒绝某些步长。这种需求是否与`IVPsolver.onestepper`中步进机制的设计冲突？
- en: We encourage you to check the design of the two SciPy tools for solving initial
    values, namely `scipy.integrate.ode` and `scipy.integrate.odeint`.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们鼓励你检查两个 SciPy 工具的设计，这些工具用于解决初值问题，分别是`scipy.integrate.ode`和`scipy.integrate.odeint`。
- en: 19.4 Summary
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 19.4 小结
- en: Most of what we explained in this book was bundled into the three longer examples
    in this chapter. These examples mimic code development and give prototypes, which
    you are encouraged to alter and confront with your own ideas.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中大部分内容已经整合到本章的三个较长示例中。这些示例模拟了代码开发并提供了原型，鼓励你根据自己的想法进行修改和对比。
- en: You saw that code in scientific computing can have its own flavor due to its
    strong relationship with mathematically defined algorithms and that it is often
    wise to keep the relationship between code and formula visible. Python has techniques
    for this, as you have seen.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现，科学计算中的代码因其与数学定义的算法有着紧密关系，往往具有其独特风格，并且通常明智的做法是保持代码与公式之间的关系可见。Python 提供了实现这一点的技巧，正如你所看到的。
- en: 19.5 Exercises
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 19.5 练习
- en: '**Ex. 1:** Implement a method `__add__` that constructs a new polynomial ![](img/77fa6522-5de3-4e15-b0df-d9a450605771.png) by
    adding two given polynomials ![](img/724805b9-bea3-4a02-b1d4-5d81e8bd4634.png) and
    ![](img/e174fe97-c3d6-4bfb-a93a-1025e6028d8a.png). In monomial form, polynomials
    are added by just adding the coefficients, whereas in Newton form, the coefficients
    depend on the abscissas ![](img/171118dd-dce4-49d6-8f04-7b4855f2b4f2.png) of the
    interpolation points. Before adding the coefficients of both polynomials, the
    polynomial ![](img/8bdd5965-3db4-42e5-9eae-f37213bda9ef.png) has to get new interpolation
    points with the property that their abscissas ![](img/40eb87a9-fc00-48f8-a883-b285e80c460c.png) coincide
    with those of ![](img/296d4fcd-75bd-4819-8c45-3e084799040e.png), and the method `__changepoints__` has
    to be provided for that. It should change the interpolation points and return
    a new set of coefficients.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '**例 1：** 实现一个方法 `__add__`，通过将两个给定的多项式 ![](img/724805b9-bea3-4a02-b1d4-5d81e8bd4634.png)
    和 ![](img/e174fe97-c3d6-4bfb-a93a-1025e6028d8a.png) 相加，构造一个新的多项式 ![](img/77fa6522-5de3-4e15-b0df-d9a450605771.png)。在单项式形式中，多项式的相加只是将系数相加，而在牛顿形式中，系数依赖于插值点的横坐标
    ![](img/171118dd-dce4-49d6-8f04-7b4855f2b4f2.png)。在相加两个多项式的系数之前，多项式 ![](img/8bdd5965-3db4-42e5-9eae-f37213bda9ef.png)
    必须获得新的插值点，这些插值点的横坐标 ![](img/40eb87a9-fc00-48f8-a883-b285e80c460c.png) 必须与 ![](img/296d4fcd-75bd-4819-8c45-3e084799040e.png)
    的横坐标一致，并且必须提供方法 `__changepoints__` 来实现这一点。该方法应更改插值点，并返回一组新的系数。'
- en: '**Ex. 2:** Write conversion methods to convert a polynomial from Newton form
    into monomial form and vice versa.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**例 2：** 编写转换方法，将一个多项式从牛顿形式转换为单项式形式，反之亦然。'
- en: '**Ex. 3:** Write a method called `add_point` that takes a polynomial *q* and
    a tuple [![](img/81f6a09d-5109-4c61-be6a-296173b0cc9a.png)] as parameters and
    returns a new polynomial that interpolates `self.points` and [![](img/858f86f2-f43e-412f-8888-c5a5f8e7513f.png)].'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '**例 3：** 编写一个名为 `add_point` 的方法，该方法接受一个多项式 *q* 和一个元组 [![](img/81f6a09d-5109-4c61-be6a-296173b0cc9a.png)]
    作为参数，并返回一个新的多项式，该多项式插值 `self.points` 和 [![](img/858f86f2-f43e-412f-8888-c5a5f8e7513f.png)]。'
- en: '**Ex. 4:** Write a class called `LagrangePolynomial` that implements polynomials
    in Lagrange form and inherits as much as possible from the polynomial base class.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '**例 4：** 编写一个名为 `LagrangePolynomial` 的类，该类实现拉格朗日形式的多项式，并尽可能多地继承多项式基类。'
- en: '**Ex. 5:** Write tests for the polynomial class.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '**例 5：** 编写多项式类的测试。'
