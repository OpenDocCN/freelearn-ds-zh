- en: Chapter 4. Interactive Plotting and Graphical Interfaces
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章：交互式绘图与图形界面
- en: In this chapter, we will show the graphical capabilities of Python and how they
    can be used interactively with IPython.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将展示Python的图形功能以及如何与IPython交互式使用它们。
- en: NumPy provides a very efficient way of dealing with large amounts of data structured
    as multidimensional arrays. But looking at grids of numbers is often much less
    intuitive than looking at plots, such as curves, scatter plots, images, and likewise.
    Matplotlib is a particularly rich Python package for generating high-quality figures
    from NumPy data. It provides a simple, high-level interface much similar to Matlab,
    a commercial product that is popular in the engineering and scientific worlds.
    Matplotlib integrates very well with IPython.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy提供了一种非常高效的方式来处理大量以多维数组结构化的数据。但是，查看数字网格通常比查看图形（如曲线图、散点图、图像等）直观得多。Matplotlib是一个特别强大的Python包，用于从NumPy数据生成高质量的图形。它提供了一个简单的高级接口，类似于Matlab，这是一种在工程和科学界广受欢迎的商业产品。Matplotlib与IPython的集成非常好。
- en: 'We will also introduce **Graphical User Interface** (**GUI)** programming.
    Covering this rich subject extensively is far beyond the scope of this book. So
    we will only see basic examples in this chapter. We will cover the following points:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将介绍**图形用户界面**（**GUI**）编程。全面覆盖这一丰富的主题远远超出了本书的范围。因此，我们将在本章中仅展示一些基本示例。我们将涵盖以下几个要点：
- en: Plotting figures with Matplotlib
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Matplotlib绘制图形
- en: Image processing techniques
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像处理技术
- en: Geographical maps
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 地理地图
- en: Introduction to Graphical User Interfaces
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图形用户界面介绍
- en: Designing and debugging GUIs with IPython's event loop integration
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用IPython的事件循环集成设计和调试图形用户界面（GUI）
- en: Figures with Matplotlib
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Matplotlib绘制图形
- en: There are a lot of Python packages for curve plotting, but the most widely used
    one, by far, is Matplotlib. It is one of the most complete and powerful graphical
    libraries. It can be used both for interactive visualization and for generating
    high-quality figures that can be readily used in scientific publications. In addition,
    its high-level interface makes it particularly easy to use.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多Python包可以用于曲线绘制，但目前使用最广泛的仍然是Matplotlib。它是最完整、最强大的图形库之一。它既可以用于交互式可视化，也可以用于生成高质量的图形，方便在科学出版物中使用。此外，它的高级接口使得它特别容易使用。
- en: In this section, we will show some of the possibilities offered by Matplotlib
    as well as how it can be advantageously used with IPython.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将展示Matplotlib提供的一些功能，以及如何将它与IPython结合使用。
- en: Setting up IPython for interactive visualization
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置IPython进行交互式可视化
- en: IPython implements a loop integration system that allows to display graphical
    windows from the command-line interface without blocking the console. This is
    very useful when using Matplotlib or when creating graphical user interfaces.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: IPython实现了一个循环集成系统，允许从命令行界面显示图形窗口，而不会阻塞控制台。这在使用Matplotlib或创建图形用户界面时非常有用。
- en: Using Matplotlib
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Matplotlib
- en: Figures can be displayed interactively in IPython using event loop integration.
    Then, they can be updated dynamically from the command-line interface. The `%pylab`
    magic command (or the `--pylab` option to the `ipython` shell command) activates
    this integration automatically. It is possible to choose the backend renderer
    used for Matplotlib and IPython, for example, `--pylab qt`, which requires PyQt
    or PySide.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用事件循环集成在IPython中交互式地显示图形。然后，它们可以从命令行界面动态更新。`%pylab`魔法命令（或`ipython` shell命令中的`--pylab`选项）会自动激活这一集成。可以选择用于Matplotlib和IPython的后端渲染器，例如，`--pylab
    qt`，这需要PyQt或PySide。
- en: We will assume that the `%pylab` mode is active in IPython throughout this chapter.
    When using Matplotlib from a script instead from IPython, we can put the `from
    pylab import *` command at the top of the script. In a Python module, it might
    be a better idea to use `import matplotlib.pyplot as plt` so that the Matplotlib
    objects stay within their namespace.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设在本章中，IPython的`%pylab`模式是处于激活状态的。当从脚本中使用Matplotlib而不是IPython时，我们可以将`from
    pylab import *`命令放在脚本的顶部。在Python模块中，使用`import matplotlib.pyplot as plt`可能是个更好的选择，这样Matplotlib对象就会保持在它们的命名空间内。
- en: Also, the way of generating plots is slightly different in a script compared
    to IPython. In a script, the figure is displayed only when the function `show()`
    is called, typically, at the very end of the script, whereas, in the IPython command-line
    interface, the figure is shown and updated at each plot function.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在脚本中生成图形的方式与在IPython中的方式略有不同。在脚本中，只有在调用`show()`函数时，图形才会显示，通常是在脚本的最后，而在IPython命令行界面中，图形会在每次调用`plot`函数时显示和更新。
- en: Interactive navigation
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 交互式导航
- en: When showing a figure with Matplotlib, the window contains a few buttons for
    navigating interactively within the figure (panning and zooming) and for changing
    the figure's options. There is also the possibility to save the figure in a bitmap
    or vector format.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Matplotlib显示图形时，窗口中包含一些按钮，可以在图形中进行交互式导航（平移和缩放），以及更改图形的选项。还可以将图形保存为位图或矢量格式。
- en: Matplotlib in the IPython notebook
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Matplotlib在IPython笔记本中的应用
- en: Matplotlib can also be used in the notebook. When launching the notebook with
    `ipython notebook --pylab inline`, the plots appear in the output cells as images
    and are saved as base64 strings within the IPYNB files. Without this inline option,
    figures are displayed in separate windows as usual. It is also possible to activate
    this option within the notebook by using the command `%pylab inline`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Matplotlib也可以在笔记本中使用。当使用`ipython notebook --pylab inline`启动笔记本时，绘制的图形会以图像形式出现在输出单元格中，并作为base64字符串保存在IPYNB文件中。如果没有使用此inline选项，图形将像往常一样显示在单独的窗口中。也可以通过使用命令`%pylab
    inline`在笔记本中激活此选项。
- en: Standard plots
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标准图形
- en: In this section, we will see some examples of standard plots, such as lines,
    curves, scatter plots, and bar plots. In the next sections, we will also see images
    and maps. But Matplotlib offers far more plot types than what we will cover here,
    including 3D plots, geometrical shapes, vector fields, and so on.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看到一些标准图形的示例，例如线图、曲线图、散点图和条形图。在接下来的章节中，我们还将看到图像和地图。但Matplotlib提供的图形类型远远不止我们在这里讲解的内容，包括3D图形、几何形状、向量场等。
- en: Curves
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 曲线
- en: Drawing a curve with Matplotlib actually means drawing small, successive line
    segments that give the illusion of a smooth curve when the number of lines is
    large enough. To plot a mathematical function, one plots samples of this function
    within a given interval just as NumPy represents functions as arrays with sampled
    values.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Matplotlib绘制曲线实际上是绘制一小段一小段的线段，当线段足够多时，它们会给人一种平滑曲线的错觉。为了绘制一个数学函数，我们需要在给定区间内绘制该函数的样本，就像NumPy将函数表示为具有采样值的数组一样。
- en: 'For example, a time-dependent signal can be represented as a one-dimensional
    vector of sampled values at regular time intervals (for example, every 1 millisecond
    at a 1 kHz sampling frequency), such that one second of signal is represented
    as a 1000-unit long vector. The function `plot` can be used to draw this signal
    on the screen, for example:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个时变信号可以表示为一个一维向量，其中包含在规则时间间隔（例如，每1毫秒以1 kHz的采样频率）采样的值，这样1秒钟的信号就可以表示为一个1000个单位长的向量。可以使用`plot`函数将此信号绘制在屏幕上，例如：
- en: '![Curves](img/9932_04_01.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![曲线](img/9932_04_01.jpg)'
- en: Plotting a white noise signal in a notebook
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在笔记本中绘制白噪声信号
- en: Here, we generate a vector with random values following independent normal random
    variables. The resulting signal is a so-called white noise signal, a random signal
    with a flat power spectral density. When plotting the figure in the notebook with
    the `--pylab inline` option, Matplotlib generates an image representing this curve,
    and the image is then automatically inserted in the output cell.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们生成一个包含随机值的向量，这些值遵循独立的正态随机变量。生成的信号是所谓的白噪声信号，即功率谱密度平坦的随机信号。当使用`--pylab inline`选项在笔记本中绘制图形时，Matplotlib会生成一张表示该曲线的图像，随后图像会自动插入到输出单元格中。
- en: 'When the `plot` function receives a single vector as an argument, it assumes
    that this vector contains values on the y axis, whereas values on the x axis are
    automatically generated as integers from `0` to `len(y) - 1`. To explicitly specify
    the values on the x axis, we can use the following command: `plot(x,y)`.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当`plot`函数接收一个单一的向量作为参数时，它假设该向量包含y轴的值，而x轴的值则自动生成，从`0`到`len(y) - 1`的整数。若要显式指定x轴的值，我们可以使用以下命令：`plot(x,
    y)`。
- en: Scatter plots
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 散点图
- en: 'Scatter plots represent sets of points in two dimensions, using pixels or any
    other marker. Let''s continue with our cities example. Assuming we are in the
    right directory (the `citiesdata` alias), we can load the data and try to plot
    the geographical coordinates of all the cities:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 散点图通过使用像素或其他标记来表示二维空间中的一组点。让我们继续使用我们的城市示例。假设我们已经进入正确的目录（`citiesdata` 别名），我们可以加载数据并尝试绘制所有城市的地理坐标：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '![Scatter plots](img/9932_04_02.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![散点图](img/9932_04_02.jpg)'
- en: Displaying the cities' coordinates in the notebook
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在笔记本中显示城市坐标
- en: In this example, we plot the latitude (y axis) versus the longitude (x axis)
    of all the cities. The third argument (`','`) of the `plot` function specifies
    the marker type. Here, it corresponds to a scatter plot where each city is represented
    by a single pixel. We can easily recognize the shape of the continents even if
    they seem a bit distorted. This is because we plot the geographical coordinates
    in a Cartesian system, whereas it would be more appropriate to use a map projection
    method. We will get back to this issue later in this chapter.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们绘制了所有城市的纬度（y 轴）与经度（x 轴）。`plot` 函数的第三个参数（`','`）指定了标记类型。在这里，它对应于一个散点图，每个城市用一个像素表示。即使大陆的形状看起来有些扭曲，我们仍然可以轻松识别出它们的轮廓。这是因为我们在笛卡尔坐标系中绘制地理坐标，而使用地图投影方法会更加合适。我们将在本章后面回到这个问题。
- en: Bar graphs
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 条形图
- en: A bar graph is typically used for histograms, representing the distribution
    of values at different intervals. The `hist` function in Matplotlib accepts a
    vector of values and plots a histogram. The `bins` keyword allows to specify either
    the number of bins or the list of bins.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 条形图通常用于直方图，表示不同区间内值的分布。Matplotlib 中的 `hist` 函数接受一个值的向量并绘制直方图。`bins` 关键字允许指定箱数或箱的列表。
- en: 'For example, let''s plot the histogram of the nodes'' degrees in the Facebook
    graph example:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们绘制 Facebook 图示例中节点度数的直方图：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '![Bar graphs](img/9932_04_03.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![条形图](img/9932_04_03.jpg)'
- en: Distribution of the nodes' degrees in a graph
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图中节点度数的分布
- en: Here, `g.degree()` is a dictionary with the degree of each node (that is, the
    number of other nodes connected to it). The `values` method returns the list of
    all the degrees.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`g.degree()` 是一个字典，包含每个节点的度数（即与其连接的其他节点数）。`values` 方法返回所有度数的列表。
- en: There are far more graph types in Matplotlib than what we showed here, and the
    plotting possibilities are nearly endless. A wide variety of figure examples can
    be found in the Matplotlib Gallery on the official website ([http://matplotlib.org/gallery.html](http://matplotlib.org/gallery.html))
    and in Nicolas Rougier's tutorial ([http://www.loria.fr/~rougier/teaching/matplotlib/](http://www.loria.fr/~rougier/teaching/matplotlib/)).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Matplotlib 中，比我们展示的图形类型要多得多，绘图的可能性几乎是无穷无尽的。可以在 Matplotlib 官方网站的画廊中找到各种图形示例（[http://matplotlib.org/gallery.html](http://matplotlib.org/gallery.html)），以及
    Nicolas Rougier 的教程（[http://www.loria.fr/~rougier/teaching/matplotlib/](http://www.loria.fr/~rougier/teaching/matplotlib/)）。
- en: Plot customization
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘图自定义
- en: Matplotlib offers a lot of customization options. Here, we will see how to change
    styles and colors in figures, how to configure axes and legends, and how to display
    several plots on the same figure.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Matplotlib 提供了许多自定义选项。在这里，我们将看到如何更改图形中的样式和颜色，如何配置坐标轴和图例，以及如何在同一图形中显示多个图表。
- en: Styles and colors
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 样式和颜色
- en: By default, curves are continuous and have a uniform color. The style and color
    of the curves can easily be specified in the `plot` function.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，曲线是连续的，并且具有统一的颜色。可以在 `plot` 函数中轻松指定曲线的样式和颜色。
- en: The third argument of the `plot` function specifies the style and color of the
    curve in a short syntax. For example, '`-r`' means "continuous and red" while
    '`--g`' means "dashed and green". There are dozens of possible styles such as,
    `':'` for dotted lines, `'-.'` for dash-dot, `'.'` for points, `','` for pixels,
    `'o'` for circle markers, and so on.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`plot` 函数的第三个参数指定了曲线的样式和颜色，使用简洁的语法。例如，''`-r`'' 表示“连续且为红色”，而 ''`--g`'' 表示“虚线且为绿色”。有许多可能的样式，例如，`'':''`
    代表虚线，`''-.''` 代表点划线， `''.''` 代表点， `'',''` 代表像素， `''o''` 代表圆形标记，等等。'
- en: Also, there are eight colors with a single-character shortcut, namely `b`, `g`,
    and `r` (primary additive colors—blue, greed, and red); `c`, `m`, and `y` (secondary
    additive colors—cyan, magenta, and yellow); and `k` and `w` (black and white).
    Any other color can be specified by its hexadecimal code, RGB or RGBA tuple (values
    between `0` and `1`), and so on.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，有八种颜色对应一个字符的快捷键，分别是 `b`、`g` 和 `r`（主要的加色性颜色——蓝色、绿色和红色）；`c`、`m` 和 `y`（次要的加色性颜色——青色、品红色和黄色）；以及
    `k` 和 `w`（黑色和白色）。任何其他颜色可以通过其十六进制代码、RGB 或 RGBA 元组（值在 `0` 和 `1` 之间）等方式指定。
- en: Using a string for specifying the style and color is only a shortcut to the
    more general way of specifying styles and colors of plots, which is to use particular
    keyword arguments. These arguments include `linestyle` (or `ls`), `linewidth`
    (or `lw`), `marker`, `markerfacecolor` (or `mfc`), `markersize` (or `ms`), and
    so on. The full list of options can be found in the reference documentation of
    Matplotlib.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 使用字符串指定样式和颜色只是更一般的指定图表样式和颜色方式的快捷方式，更通用的方式是使用特定的关键字参数。这些参数包括 `linestyle`（或 `ls`）、`linewidth`（或
    `lw`）、`marker`、`markerfacecolor`（或 `mfc`）、`markersize`（或 `ms`）等。完整的选项列表可以在 Matplotlib
    的参考文档中找到。
- en: 'Also, when displaying several plots on the same figure, the color of each plot
    cycles through a predefined set of colors, such as blue, green, red, and so on.
    This cycle can be customized:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当在同一图形中显示多个图表时，每个图表的颜色会按预定义的颜色集轮换，例如蓝色、绿色、红色等。这个循环可以自定义：
- en: '[PRE2]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Tip
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Customizing Matplotlib**'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**自定义 Matplotlib**'
- en: '`rcParams` is a global, dictionary-like variable in Matplotlib with custom
    parameters. Nearly every aspect of Matplotlib can be configured here. Also, it
    is possible to specify permanent custom options by saving them in an ASCII text
    file called `matplotlibrc`, which can be stored either in the current directory
    (for local options) or in `~/.matplotlib` (for global options). In this file,
    each line contains a custom parameter, for example, `axes.color_cycle: [''r'',
    ''k'', ''c'']`.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`rcParams` 是 Matplotlib 中的一个全局字典样式的变量，用于存储自定义参数。几乎 Matplotlib 的每个方面都可以在这里进行配置。此外，还可以通过将其保存到名为
    `matplotlibrc` 的 ASCII 文本文件中来指定永久的自定义选项，该文件可以存储在当前目录（用于本地选项）或 `~/.matplotlib`
    目录下（用于全局选项）。在此文件中，每一行包含一个自定义参数，例如 `axes.color_cycle: [''r'', ''k'', ''c'']`。'
- en: Grid, axes, and legends
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 网格、坐标轴和图例
- en: 'A graph would not convey anything useful about the data without legends and
    axes. By default, Matplotlib displays axes and ticks automatically. The exact
    positions of the ticks can be set with `xticks` and `yticks`, and a grid can be
    added with the `grid` function. The extent of the x and y coordinates can be specified
    with `xlim` and `ylim`. The axes labels can be set with `xlabel` and `ylabel`.
    Also, it is possible to specify the legend with the `legend` keyword; the label
    of each line corresponds to the `label` keyword argument of the `plot` function.
    Finally, the `title` command displays the name of the figure. The following example
    illustrates how to use these options:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有图例和坐标轴，图形无法传达任何有用的数据。默认情况下，Matplotlib 会自动显示坐标轴和刻度。刻度的位置可以通过 `xticks` 和 `yticks`
    设置，可以通过 `grid` 函数添加网格。x 和 y 坐标的范围可以通过 `xlim` 和 `ylim` 指定。坐标轴标签可以通过 `xlabel` 和
    `ylabel` 设置。此外，可以通过 `legend` 关键字指定图例；每条线的标签对应于 `plot` 函数的 `label` 关键字参数。最后，`title`
    命令会显示图形的名称。以下示例演示了如何使用这些选项：
- en: '![Grid, axes, and legends](img/9932_04_05.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![网格、坐标轴和图例](img/9932_04_05.jpg)'
- en: Sine and cosine functions with axes and legends
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 带坐标轴和图例的正弦和余弦函数
- en: Tip
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Superposition of plots**'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**图表叠加**'
- en: Calling different plot functions updates the same figure in Matplotlib. This
    is how several plots can be shown on the same figure. To create a new figure in
    a new window, we need to call the function figure(). Finally, it is possible to
    display several independent figures within the same window using subplots, as
    we will see later in this section.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 调用不同的绘图函数会更新 Matplotlib 中的同一个图形。这是如何在同一个图形中显示多个图表的方式。要在新窗口中创建一个新图形，我们需要调用 `figure()`
    函数。最后，可以通过使用子图，在同一个窗口中显示多个独立的图形，如我们在本节后面将要看到的那样。
- en: Interaction from IPython
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 来自 IPython 的交互
- en: 'Creating Matplotlib figures with the IPython console using event loop integration
    allows to interact with them programmatically. It is possible to add new plots
    in a figure or to update it in real time, as shown in the following example:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 使用事件循环集成在 IPython 控制台中创建 Matplotlib 图形，可以通过编程与其进行交互。可以在一个图形中添加新的图表或实时更新它，以下面的示例为例：
- en: '[PRE3]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We first create a figure with two white noise signals (the `plot` function
    displays every column as an independent curve). Once the window with the figure
    has opened, we can return to the IPython console without closing that window.
    The output `Out[1]` contains a list of `Line2D` objects. Indeed, Matplotlib uses
    an object-oriented description of the figure. Let''s retrieve the first object
    (corresponding to the first curve) as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个包含两个白噪声信号的图形（`plot`函数将每一列显示为独立的曲线）。一旦包含该图形的窗口打开，我们就可以在不关闭该窗口的情况下返回到
    IPython 控制台。输出`Out[1]`包含一个`Line2D`对象的列表。实际上，Matplotlib 使用面向对象的方式描述图形。让我们按如下方式检索第一个对象（对应第一个曲线）：
- en: '[PRE4]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Tab completion on the `line` variable then shows the list of methods that we
    can use to update the figure. For instance, to change the line color from blue
    to red, we can type the following command:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在`line`变量上使用 Tab 键补全后，显示我们可以用来更新图形的方法列表。例如，要将线条颜色从蓝色更改为红色，我们可以输入以下命令：
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The figure is then updated accordingly. It may be necessary to force refresh
    the figure, for example, by panning or zooming.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，图形会相应地更新。可能需要强制刷新图形，例如通过平移或缩放。
- en: Finally, let's mention the **Edit** button in the figure window that offers
    a GUI for updating some figures' properties.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，提一下图形窗口中的**编辑**按钮，它提供了一个 GUI 来更新一些图形的属性。
- en: Drawing multiple plots
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绘制多个图表
- en: 'Multiple independent plots can be displayed on the same figure. We can define
    a grid with an arbitrary number of rows and columns and plot figures inside each
    box. Boxes can even span several rows or columns (using `subplot2grid`). For instance,
    the following example shows how to plot two figures with different coordinate
    systems side by side:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 多个独立的图表可以显示在同一个图形中。我们可以定义一个具有任意行列数的网格，并在每个框内绘制图形。框可以跨越多个行或列（使用`subplot2grid`）。例如，下面的示例展示了如何将两个具有不同坐标系的图形并排绘制：
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '![Drawing multiple plots](img/9932_04_06.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![绘制多个图表](img/9932_04_06.jpg)'
- en: Cartesian and polar plots in the same figure
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一图形中绘制笛卡尔坐标和极坐标图
- en: The `subplot` function simultaneously specifies how many columns (first argument)
    and rows (second argument) there are, but also the index of the box where the
    plot will be rendered (third argument, 1-based indexing, from left to right and
    top to bottom). The `polar=True` keyword argument specifies that the second subplot
    contains a polar graph. The `polar` function is similar to the `plot` function,
    but a polar coordinate system containing the attributes theta, and r is used where
    theta is the angle and r is the radius.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`subplot`函数同时指定了图形有多少列（第一个参数）和多少行（第二个参数），以及绘制图形的框索引（第三个参数，基于 1 的索引，从左到右、从上到下）。`polar=True`关键字参数指定第二个子图包含极坐标图。`polar`函数类似于`plot`函数，但使用极坐标系，其中包含角度theta和半径r，其中theta是角度，r是半径。'
- en: Advanced figures and graphics
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级图形与图表
- en: In this section, we will show more advanced graphical features offered by Matplotlib
    that are related to images and maps. We will also take a look at a few other graphical
    libraries.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将展示 Matplotlib 提供的与图像和地图相关的更高级图形功能。我们还将看看其他一些图形库。
- en: Image processing
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图像处理
- en: A colored N x M image can be represented as an N x M x 3 NumPy array corresponding
    to three N x M matrices for the red, green, and blue channels. Image processing
    algorithms can then be implemented efficiently with NumPy and SciPy and visualized
    with Matplotlib. In addition, the PIL package (Python Imaging Library) implements
    basic image processing routines for pictures.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一幅彩色的 N x M 图像可以表示为一个 N x M x 3 的 NumPy 数组，代表红色、绿色和蓝色通道的三个 N x M 矩阵。然后，可以使用
    NumPy 和 SciPy 高效地实现图像处理算法，并通过 Matplotlib 进行可视化。此外，PIL 包（Python Imaging Library）提供了基本的图像处理功能。
- en: Loading images
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加载图片
- en: Matplotlib's `imread` function opens a PNG image from the hard drive and returns
    an N x M x 3 (or N x M x 4 if there is an alpha transparency channel) NumPy array.
    It can also read other formats if PIL is installed. PIL also offers the `open`
    function for reading images in any format (BMP, GIF, JPEG, TIFF, and so on).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Matplotlib 的`imread`函数从硬盘中打开一个 PNG 图像，并返回一个 N x M x 3（如果存在 alpha 透明度通道，则为 N
    x M x 4）形状的 NumPy 数组。如果安装了 PIL，它还可以读取其他格式。PIL 还提供了`open`函数来读取任何格式的图像（BMP、GIF、JPEG、TIFF
    等）。
- en: 'In the following example, we download a PNG image from a remote URL and load
    it with `imread`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们从远程 URL 下载一个 PNG 图像，并使用`imread`加载它：
- en: '[PRE7]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `imread` function accepts either an image filename or a Python file-like
    object (like here, where we use the buffer returned by `urlopen`). The object
    returned by the `imread` function is a three-dimensional NumPy array.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`imread`函数接受图像文件名或Python文件类对象（如这里使用的`urlopen`返回的缓冲区）。`imread`函数返回的对象是一个三维NumPy数组。'
- en: 'We can also use PIL for reading images. We can either use `Image.open` to open
    an image file directly, or we can convert a NumPy array into a PIL image with
    the `Image.fromarray` function, as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用PIL读取图像。我们可以直接使用`Image.open`打开图像文件，或者使用`Image.fromarray`函数将NumPy数组转换为PIL图像，如下所示：
- en: '[PRE8]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `fromarray` function accepts an array with unsigned 8-bit integers, with
    values between `0` and `255`. This is the reason why we need to convert the NumPy
    array with floating point values to the required data type. Conversely, to convert
    a PIL image into a NumPy array, we can use the `array` function `im = array(img)`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`fromarray`函数接受一个包含无符号8位整数的数组，值范围在`0`到`255`之间。这就是为什么我们需要将浮动点值的NumPy数组转换为所需的数据类型。相反，要将PIL图像转换为NumPy数组，我们可以使用`array`函数`im
    = array(img)`。'
- en: Showing images
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 显示图像
- en: 'The `imshow` function of Matplotlib displays an image from a NumPy array, as
    shown in the following example:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Matplotlib的`imshow`函数从NumPy数组中显示图像，如以下示例所示：
- en: '[PRE9]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '![Showing images](img/9932_04_07.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![显示图像](img/9932_04_07.jpg)'
- en: Displaying an image in the notebook with Matplotlib
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在笔记本中使用Matplotlib显示图像
- en: 'The `imshow` function also accepts two-dimensional NumPy arrays (grayscale
    images). The mapping from scalar values between `0` and `1` to actual pixel colors
    can be specified with the color map. A color map is a linear gradient of colors
    defining the color of any value between `0` and `1`. A lot of predefined color
    maps are available in Matplotlib, and the full list can be found here: [http://www.scipy.org/Cookbook/Matplotlib/Show_colormaps](http://www.scipy.org/Cookbook/Matplotlib/Show_colormaps)'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`imshow`函数还接受二维NumPy数组（灰度图像）。从`0`到`1`的标量值到实际像素颜色的映射可以通过颜色映射来指定。颜色映射是一个线性渐变的颜色，定义了`0`到`1`之间任何值的颜色。Matplotlib中有很多预定义的颜色映射，完整的列表可以在此找到：[http://www.scipy.org/Cookbook/Matplotlib/Show_colormaps](http://www.scipy.org/Cookbook/Matplotlib/Show_colormaps)'
- en: To specify the color map in `imshow`, we can use the `cmap=get_cmap(name)` keyword
    argument, where name is the color map's name.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 要在`imshow`中指定颜色映射，我们可以使用`cmap=get_cmap(name)`关键字参数，其中`name`是颜色映射的名称。
- en: Using PIL
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用PIL
- en: 'Basic image processing routines, such as rotate, crop, filtering, copy and
    paste, geometrical transforms, and likewise, are provided by PIL. For example,
    to rotate an image, we can use the following command:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的图像处理操作，如旋转、裁剪、滤波、复制粘贴、几何变换等，都是PIL提供的。例如，要旋转图像，我们可以使用以下命令：
- en: '[PRE10]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '![Using PIL](img/9932_04_09.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![使用PIL](img/9932_04_09.jpg)'
- en: Rotating an image with PIL
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 使用PIL旋转图像
- en: Here, we rotate the image 45 degrees counterclockwise, and we convert back the
    image from PIL to NumPy to display it.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将图像逆时针旋转45度，并将图像从PIL转换回NumPy以进行显示。
- en: Advanced image processing – color quantization
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 高级图像处理 – 颜色量化
- en: PIL provides basic image processing functions, whereas SciPy can be used for
    more advanced algorithms.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: PIL提供了基本的图像处理功能，而SciPy可用于更高级的算法。
- en: 'Here we will show a small example of an advanced image processing algorithm
    called color quantization. The principle of this algorithm is to reduce the number
    of colors of an image while keeping most of the visual structure of the image.
    In this example, we will implement this algorithm with the `scipy.cluster` package.
    We will use the k-means algorithm to group the color values into a small number
    of clusters, and we will assign each pixel to its group''s color. Here is the
    code:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们将展示一个名为颜色量化的高级图像处理算法的小示例。该算法的原理是减少图像的颜色数量，同时保持图像的大部分视觉结构。在本示例中，我们将使用`scipy.cluster`包实现该算法。我们将使用k-means算法将颜色值分组为少量的簇，并将每个像素分配给其所属组的颜色。以下是代码：
- en: '[PRE11]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We only take the red channel and flatten the image with the `ravel` function
    so as to treat all pixels equally (that is, we get a one-dimensional vector instead
    of a two-dimensional matrix). Then, the `kmeans` function finds the clusters in
    the color space and returns the centroid colors. Finally, the `vq` function assigns
    each pixel to its centroid index, and we retrieve the resulting image clustered
    through fancy indexing of the centroid indices (in `qnt`) by the centroid colors
    (`centroids`). Since the output of this algorithm is a grayscale image, we need
    to specify a color map. We will use a set of colors that had its heyday some time
    ago, as shown here:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仅取红色通道，并使用`ravel`函数将图像展平，以便平等处理所有像素（也就是说，我们得到一个一维向量，而不是二维矩阵）。然后，`kmeans`函数在颜色空间中寻找聚类，并返回质心颜色。最后，`vq`函数将每个像素分配到其质心索引，并通过质心颜色（`centroids`）对质心索引（在`qnt`中）进行花式索引，得到最终的聚类图像。由于该算法的输出是灰度图像，我们需要指定一个颜色映射。我们将使用一组曾经流行的颜色，如下所示：
- en: '[PRE12]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '![Advanced image processing – color quantization](img/9932_04_10.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![高级图像处理 – 颜色量化](img/9932_04_10.jpg)'
- en: Color quantization with SciPy
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 使用SciPy进行颜色量化
- en: Here, the `ListedColormap` function creates a custom color map with a discrete
    set of colors.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`ListedColormap`函数创建了一个具有离散颜色集的自定义颜色映射。
- en: 'Finally, we can save the resulting image as a PNG file with Matplotlib''s `imsave`
    function, as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以使用Matplotlib的`imsave`函数将生成的图像保存为PNG文件，如下所示：
- en: '[PRE13]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Maps
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 地图
- en: Maps are a complex but important type of figure. The basemap toolkit (which
    needs to be installed separately) brings geographical capabilities to Matplotlib.
    It is highly powerful, and we will only scratch the surface in this section. Specifically,
    we will continue with our cities example to plot a human density map on a planisphere.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 地图是复杂但重要的图形类型。基础地图工具包（需要单独安装）为Matplotlib带来了地理能力。它非常强大，而在本节中我们仅仅是略微触及表面。具体来说，我们将继续使用城市示例，在天球仪上绘制人口密度图。
- en: 'First, we retrieve the locations and populations of the cities as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们按如下方式获取城市的位置和人口：
- en: '[PRE14]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next, we initialize a world map by specifying the projection type and map boundaries
    as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过指定投影类型和地图边界来初始化世界地图，如下所示：
- en: '[PRE15]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: There are a lot of different ways of projecting the surface of the earth on
    a plane, and the choice of one projection or another depends on the specific application.
    Here, we use the Miller cylindrical projection. The other keyword arguments give
    the latitude and longitude of the lower-left and upper-right corners.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 将地球表面投影到平面上的方法有很多种，选择某种投影方式取决于具体应用。在这里，我们使用米勒圆柱投影。其他关键字参数给出了左下角和右上角的纬度和经度。
- en: 'The next step is to generate a two-dimensional image with the world population
    density. To do this, we will need to project the geographical coordinates of the
    cities on our map, as shown here:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是生成一个二维图像，显示世界人口密度。为此，我们需要将城市的地理坐标投影到我们的地图上，如下所示：
- en: '[PRE16]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Calling the function `m(long,lat)` allows to get the `(x,y)` coordinates of
    the geographical positions with longitudes and latitudes. To generate the density
    map, we will also need the coordinates of the map boundaries, as shown here:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 调用函数`m(long, lat)`可以获取地理位置的`(x, y)`坐标，给定经纬度。为了生成密度图，我们还需要地图边界的坐标，如下所示：
- en: '[PRE17]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, let''s generate the density map. We will use the `histogram2d` function,
    which returns a two-dimensional histogram from a set of points. Here, each point
    corresponds to a city. We will also use a weight for each city, which corresponds
    to its population. Care must be taken for cities that do not have a population;
    we will set the weight to `1000` for these cities, as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们生成密度图。我们将使用`histogram2d`函数，该函数从一组点生成一个二维直方图。在这里，每个点对应一个城市。我们还将为每个城市使用一个权重，代表其人口。对于没有人口的城市需要特别处理，我们将这些城市的权重设置为`1000`，如下所示：
- en: '[PRE18]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now the `h` variable contains the population count in every small rectangle
    of a 500 x 500 grid spanning the whole planisphere. To generate a density map,
    we can apply a Gaussian filter to `log(h)` (corresponding to a kind of kernel
    density estimation) using SciPy. Using the logarithm can be useful when the values
    span several orders of magnitude. We also need to take care of zeros (corresponding
    to empty zones) because the logarithm of zero is undefined:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`h`变量包含了一个500 x 500网格上每个小矩形的总人口数，覆盖了整个平面图。为了生成密度图，我们可以对`log(h)`应用高斯滤波（相当于一种核密度估计），这可以通过SciPy实现。使用对数运算在值跨越多个数量级时非常有用。我们还需要处理零值（对应空白区域），因为零的对数是未定义的：
- en: '[PRE19]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The filter is applied to the function `log(h.T)` because the coordinate system
    of the `h` variable is transposed compared to the coordinate system of the map.
    Also, we use a filtering value of `1` here.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 该滤波器应用于函数`log(h.T)`，因为`h`变量的坐标系与地图的坐标系相比是转置的。此外，我们在这里使用了`1`的滤波值。
- en: 'Finally, we display the density map as well as the coast lines, as shown here:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们展示了密度图以及海岸线，如下所示：
- en: '[PRE20]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '![Maps](img/9932_04_11.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![地图](img/9932_04_11.jpg)'
- en: World map with population density using Matplotlib.basemap
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Matplotlib.basemap的世界人口密度图
- en: 3D plots
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3D图
- en: 'Matplotlib includes a 3D toolkit called `mplot3d` that can be used for basic
    3D plots, such as 3D curves, surface plots, and likewise. As an example, let''s
    create a surface plot. We first need to import the `mplot3d` toolkit as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Matplotlib包括一个名为`mplot3d`的3D工具包，可以用于基本的3D图，如3D曲线、表面图等。举个例子，我们先创建一个表面图。我们首先需要导入`mplot3d`工具包，方法如下：
- en: '[PRE21]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Then, we create the x, y, and z coordinates of a surface plot with the following
    commands:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用以下命令创建表面图的x、y和z坐标：
- en: '[PRE22]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The NumPy function `meshgrid` returns the coordinates of all the points in
    a grid that spans a rectangle area defined by the `X` and `Y` vectors. Finally,
    we create a 3D canvas and draw the surface plot as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy的函数`meshgrid`返回一个网格中所有点的坐标，这个网格覆盖了由`X`和`Y`向量定义的矩形区域。最后，我们创建一个3D画布并绘制表面图，如下所示：
- en: '[PRE23]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The Matplotlib function `gca` returns the current axis instance, and we specify
    here that this instance should use 3D projection. In the `plot_surface` function,
    the `rstride` and `cstride` keyword arguments give the row and column strides
    of the surface, whereas `cmap` is the color map and `linewidth` is the width of
    the wireframe. The following screenshot shows the result:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Matplotlib的函数`gca`返回当前的坐标轴实例，我们在这里指定该实例应使用3D投影。在`plot_surface`函数中，`rstride`和`cstride`关键字参数分别表示表面的行和列步长，而`cmap`是色图，`linewidth`是线框的宽度。以下截图显示了结果：
- en: '![3D plots](img/9932_04_12.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![3D图](img/9932_04_12.jpg)'
- en: A surface plot with mplot3D
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 使用mplot3D的表面图
- en: Animations
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动画
- en: Matplotlib is capable of creating animations and exporting them as MP4 videos
    using FFmpeg or MEncoder. The idea is to create a plot and write a function to
    update it at regular time intervals. The documentation of the animation module
    can be found at [http://matplotlib.org/api/animation_api.html](http://matplotlib.org/api/animation_api.html).
    Besides this, a tutorial made by Jake Vanderplas is available at [http://jakevdp.github.com/blog/2012/08/18/matplotlib-animation-tutorial/](http://jakevdp.github.com/blog/2012/08/18/matplotlib-animation-tutorial/).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Matplotlib能够创建动画，并通过FFmpeg或MEncoder将其导出为MP4视频。其基本思路是创建一个图形，并编写一个函数在定时间隔内更新它。动画模块的文档可以在[http://matplotlib.org/api/animation_api.html](http://matplotlib.org/api/animation_api.html)找到。此外，Jake
    Vanderplas制作的教程可以在[http://jakevdp.github.com/blog/2012/08/18/matplotlib-animation-tutorial/](http://jakevdp.github.com/blog/2012/08/18/matplotlib-animation-tutorial/)获得。
- en: Other visualization packages
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他可视化包
- en: 'Matplotlib is not the only visualization package in Python. Here are other
    similar libraries:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Matplotlib并不是Python中唯一的可视化包。这里是一些类似的库：
- en: '**Chaco**: This is an alternative library to Matplotlib ([http://code.enthought.com/chaco/](http://code.enthought.com/chaco/))'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Chaco**：这是一个替代Matplotlib的库（[http://code.enthought.com/chaco/](http://code.enthought.com/chaco/)）'
- en: '**PyQwt**: This is a plotting library based on PyQt ([http://pyqwt.sourceforge.net/](http://pyqwt.sourceforge.net/))'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PyQwt**：这是一个基于PyQt的绘图库（[http://pyqwt.sourceforge.net/](http://pyqwt.sourceforge.net/)）'
- en: '**PyQtGraph**: This package is also based on PyQt and offers 2D and 3D plotting
    features ([http://www.pyqtgraph.org/](http://www.pyqtgraph.org/))'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PyQtGraph**：这个包也是基于PyQt的，提供2D和3D绘图功能（[http://www.pyqtgraph.org/](http://www.pyqtgraph.org/)）'
- en: '**Visvis**: This package is based on OpenGL; it offers an object-oriented plotting
    interface ([http://code.google.com/p/visvis/](http://code.google.com/p/visvis/))'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Visvis**：这个包基于 OpenGL，提供了面向对象的绘图接口（[http://code.google.com/p/visvis/](http://code.google.com/p/visvis/)）'
- en: '**Mayavi**: This package offers 3D interactive visualization features, such
    as curves, surfaces, meshes, volume rendering, and likewise ([http://code.enthought.com/projects/mayavi/](http://code.enthought.com/projects/mayavi/))'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Mayavi**：这个包提供了 3D 交互式可视化功能，如曲线、表面、网格、体积渲染等（[http://code.enthought.com/projects/mayavi/](http://code.enthought.com/projects/mayavi/)）'
- en: '**PyOpenGL**: This Python library gives raw access to the popular OpenGL library;
    it offers low-level, hardware-accelerated 2D/3D graphics capabilities ([http://pyopengl.sourceforge.net/](http://pyopengl.sourceforge.net/))'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PyOpenGL**：这个 Python 库提供对流行的 OpenGL 库的原始访问，提供低级别的硬件加速 2D/3D 图形功能（[http://pyopengl.sourceforge.net/](http://pyopengl.sourceforge.net/)）'
- en: '**Galry**: This is a high-performance interactive visualization package based
    on PyOpenGL that targets very large datasets with tens or even hundreds of millions
    of points ([http://rossant.github.com/galry/](http://rossant.github.com/galry/))'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Galry**：这是一个基于 PyOpenGL 的高性能交互式可视化包，旨在处理非常大的数据集，包含数千万甚至数亿个数据点（[http://rossant.github.com/galry/](http://rossant.github.com/galry/)）'
- en: Graphical User Interfaces (GUI)
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图形用户界面（GUI）
- en: There was a time when human-computer interaction was only done through a command-line
    interface. Today, most regular computer users are much more confident with a mouse
    and graphical windows than with a keyboard and black screen with a blinking cursor.
    For this reason, any developer may be asked at some point to write a graphical
    interface, even the simplest possible, so as to let non-developer users interact
    comfortably with the program.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 曾几何时，人机交互只能通过命令行界面进行。如今，大多数普通计算机用户比起使用键盘和黑屏闪烁的光标，更习惯使用鼠标和图形窗口。因此，任何开发者在某个时刻可能都需要编写一个图形界面，哪怕是最简单的界面，以便让非开发者用户能够方便地与程序进行交互。
- en: A GUI can easily be integrated in any Python package. There are numerous graphical
    toolkits for Python, most of them being wrappers to native or C++ graphical libraries.
    Famous toolkits include Qt, wxWidgets, Tkinter, GTK, and so on. We will use Qt
    in this book's examples.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: GUI 可以轻松地集成到任何 Python 包中。Python 有很多图形工具包，大多数是本地或 C++ 图形库的封装。著名的工具包包括 Qt、wxWidgets、Tkinter、GTK
    等。在本书的示例中，我们将使用 Qt。
- en: GUI programming can be a hard subject, requiring in-depth knowledge of low-level
    details about the operating system, multithreading programming, as well as some
    basic notions about human-computer interactions. In this book, we will show a
    "Hello World" example that gives the very basics of PyQt. We will also see how
    GUIs can be manipulated interactively with IPython.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: GUI 编程可能是一个很难的课题，需要深入了解操作系统的底层细节、多线程编程，以及一些关于人机交互的基本概念。在本书中，我们将展示一个 "Hello World"
    示例，介绍 PyQt 的基本知识。我们还将展示如何通过 IPython 交互式地操作 GUI。
- en: Setting up IPython for interactive GUIs
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置 IPython 以进行交互式 GUI 编程
- en: IPython implements a loop integration system that allows the display of graphical
    windows from the command-line interface without blocking the console. This is
    very useful when creating GUIs because it becomes possible to interact with the
    windows dynamically from the command line.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: IPython 实现了一个循环集成系统，允许在命令行界面显示图形窗口而不阻塞控制台。在创建 GUI 时，这非常有用，因为可以通过命令行动态地与窗口进行交互。
- en: The `%gui` magic command activates the event loop integration. We need to provide
    the name of the graphical library to use. The possible names are `wx`, `qt`, `gtk`,
    and `tk`. Here we will work with Qt. So we can type `%gui qt`. The main Qt application
    is then automatically started in IPython. Another possibility is to launch IPython
    with `ipython --gui qt`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`%gui` 魔法命令激活事件循环集成。我们需要提供要使用的图形库的名称。可能的名称有 `wx`、`qt`、`gtk` 和 `tk`。在这里我们将使用
    Qt。所以我们可以输入 `%gui qt`。然后，IPython 中将自动启动主 Qt 应用程序。另一种方法是使用 `ipython --gui qt` 启动
    IPython。'
- en: The examples in this section require either PyQt4 or PySide. We will assume
    that PyQt4 is installed, but, if only PySide is installed, it will only be a matter
    of replacing `PyQt4` with `PySide` in the imports. The Qt binding API provided
    by both libraries is nearly identical.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的示例需要使用 PyQt4 或 PySide。我们假设已经安装了 PyQt4，但如果只安装了 PySide，您只需在导入语句中将 `PyQt4`
    替换为 `PySide`。这两个库提供的 Qt 绑定 API 几乎是相同的。
- en: A "Hello World" example
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个 "Hello World" 示例
- en: In this "Hello World" example, we will show a window with a button triggering
    a message box. We will also show how to interact with the window from the IPython
    console.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个"Hello World"示例中，我们将显示一个窗口，里面有一个按钮，点击按钮会触发一个消息框。我们还将展示如何从 IPython 控制台与窗口进行交互。
- en: 'To define a window, we need to create a class that is derived from the `QWidget`
    base class. `QWidget` is the base class of all Qt windows and controls, also called
    widgets. Here is the code of the "Hello World" example:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义一个窗口，我们需要创建一个从`QWidget`基类派生的类。`QWidget`是所有 Qt 窗口和控件的基类，也称为小部件。以下是"Hello World"示例的代码：
- en: '[PRE24]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Most of the work happens in the `HelloWorld` widget''s constructor. We first
    need to call the parent constructor. Then, we perform several steps to display
    the button:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分工作发生在`HelloWorld`小部件的构造函数中。我们首先需要调用父类的构造函数。接着，我们执行若干步骤来显示按钮：
- en: We first create a button, as in the instance of the `QPushButton` class. The
    first argument is the text of the button, and the second one is the parent widget's
    instance (`self`). Every specific control and widget is defined by a class that
    is derived from the `QWidget` base class and can be found in the `QtGui` namespace.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先创建一个按钮，类似于`QPushButton`类的实例。第一个参数是按钮的文本，第二个参数是父级小部件的实例（`self`）。每个特定的控件和小部件都是由从`QWidget`基类派生的类定义的，并且可以在`QtGui`命名空间中找到。
- en: We define the callback method that is called when the user clicks on the button.
    The `clicked` attribute is a Qt signal emitted as soon as the user clicks on the
    button. We connect this signal to the `clicked` method (called a slot) of our
    `HelloWorld` widget. Signals and slots are Qt's way of making different widgets
    communicate with each other. Signals are raised when some events occur, and slots
    connected to these signals are called whenever the signals are raised. Any widget
    contains a lot of predefined signals. Custom signals can also be created.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义了一个回调方法，当用户点击按钮时，该方法会被调用。`clicked`属性是一个 Qt 信号，一旦用户点击按钮就会发出。我们将这个信号连接到`HelloWorld`小部件的`clicked`方法（称为槽）。信号和槽是
    Qt 使不同小部件彼此通信的方式。当某些事件发生时，信号会被触发，连接到这些信号的槽会在信号触发时被调用。任何小部件都包含许多预定义的信号，也可以创建自定义信号。
- en: Then, we need to put the newly created button somewhere on the window. We first
    need to create a `QVBoxLayout` widget, which is a container widget containing
    a vertical stack of widgets. Here we only put the button in it, using the `addWidget`
    method. We also specify that this box is the window's layout. In this way, the
    main window contains this box that itself contains our button.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要将新创建的按钮放置在窗口中的某个位置。我们首先需要创建一个`QVBoxLayout`小部件，它是一个容器小部件，包含一个垂直排列的小部件堆栈。在这里，我们仅将按钮放入其中，使用`addWidget`方法。我们还指定这个框是窗口的布局。通过这种方式，主窗口包含了这个框，而这个框又包含了我们的按钮。
- en: Finally, we need to show the window with the command `self.show()`.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要使用命令`self.show()`来显示窗口。
- en: In the `clicked` method, we create a `QMessageBox` widget representing, by default,
    a dialog with a text and single **OK** button. The `setText` method specifies
    the text, and the `show` method displays the window.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在`clicked`方法中，我们创建一个`QMessageBox`小部件，它默认表示一个包含文本和单个**OK**按钮的对话框。`setText`方法指定文本，`show`方法显示窗口。
- en: 'Now assuming that the event loop integration with Qt has been activated in
    IPython either with `%gui qt` or `ipython --gui qt`, we can display the window
    with the following command:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设与 Qt 的事件循环集成已经在 IPython 中激活，无论是通过`%gui qt`还是`ipython --gui qt`，我们可以通过以下命令显示窗口：
- en: '[PRE25]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The window then appears, and the IPython console is still usable while the window
    is open.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 窗口随后会出现，且在窗口打开时，IPython 控制台仍然可用。
- en: '![A "Hello World" example](img/9932_04_13.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![一个"Hello World"示例](img/9932_04_13.jpg)'
- en: A basic Qt dialog
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 一个基本的 Qt 对话框
- en: Clicking on the button shows a dialog containing **Hello World**.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 点击按钮会显示一个对话框，其中包含**Hello World**。
- en: 'Also, we can interact with the window dynamically from the IPython console.
    For example, the following command displays the Hello World dialog exactly as
    if we had clicked on the button:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还可以从 IPython 控制台动态地与窗口进行交互。例如，以下命令将显示 Hello World 对话框，就像我们点击了按钮一样：
- en: '[PRE26]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This feature is particularly convenient when designing a complex window and
    for debugging purposes.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这个功能在设计复杂窗口和调试时特别方便。
- en: Summary
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we discovered the graphical possibilities offered by IPython,
    Matplotlib, and a few other packages. We can create plots, charts, histograms,
    maps, display and process images, graphical user interfaces, and so on. Figures
    can also be integrated very easily in a notebook. All aspects of the figures can
    be customized. These reasons explain why these tools are quite popular in the
    scientific and engineering communities, where data visualization plays a central
    role in most applications.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们发现了IPython、Matplotlib和其他一些包提供的图形化功能。我们可以创建图表、图形、直方图、地图，显示和处理图像，图形用户界面等等。图形也可以非常容易地集成到笔记本中。图形的各个方面都可以进行自定义。这些原因解释了为什么这些工具在科学和工程领域中非常受欢迎，在这些领域中，数据可视化在大多数应用中扮演着核心角色。
- en: In the next chapter, we will see some techniques to make Python code faster.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍一些加速Python代码的技巧。
