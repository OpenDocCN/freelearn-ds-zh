- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Sorting and Searching Algorithms
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 排序和搜索算法
- en: In this chapter, we will look at the algorithms that are used for sorting and
    searching. This is an important class of algorithms that can be used on their
    own or can become the foundation for more complex algorithms. These include **Natural
    Language Processing** (**NLP**) and pattern-extracting algorithms. This chapter
    starts by presenting different types of sorting algorithms. It compares the performance
    of various approaches to designing a sorting algorithm. Then, some searching algorithms
    are presented in detail. Finally, a practical example of the sorting and searching
    algorithms presented in this chapter is studied.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨用于排序和搜索的算法。这是一类重要的算法，可以单独使用，也可以成为更复杂算法的基础。这些包括**自然语言处理**（**NLP**）和模式提取算法。本章首先介绍了不同类型的排序算法。它比较了设计排序算法的各种方法的性能。然后，详细介绍了一些搜索算法。最后，研究了本章中介绍的排序和搜索算法的一个实际例子。
- en: By the end of this chapter, we should be able to understand the various algorithms
    that are used for sorting and searching, and we will be able to comprehend their
    strengths and weaknesses. As searching and sorting algorithms are the building
    blocks for many complex algorithms, understanding them in detail will help us
    better understand modern complex algorithms as well, as presented in the later
    chapters.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，我们应该能够理解用于排序和搜索的各种算法，并能够理解它们的优缺点。由于搜索和排序算法是许多复杂算法的基础，详细了解它们将有助于我们更好地理解现代复杂算法，正如后面章节中所介绍的那样。
- en: 'The following are the main concepts discussed in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章讨论的主要概念：
- en: Introducing sorting algorithms
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍排序算法
- en: Introducing searching algorithms
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍搜索算法
- en: Performance analysis of sorting and searching algorithms
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 排序和搜索算法的性能分析
- en: Practical applications of sorting and searching
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 排序和搜索的实际应用
- en: Let’s first look at some sorting algorithms.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看一些排序算法。
- en: Introducing sorting algorithms
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍排序算法
- en: The ability to efficiently sort and search items in a complex data structure
    is important as it is needed by many modern algorithms. The right strategy to
    sort and search data will depend on the size and type of the data, as discussed
    in this chapter. While the end result is exactly the same, the right sorting and
    searching algorithm will be needed for an efficient solution to a real-world problem.
    Thus, carefully analyzing the performance of these algorithms is important.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在复杂数据结构中高效地排序和搜索项目的能力非常重要，因为许多现代算法都需要这样的功能。正确的排序和搜索数据的策略将取决于数据的大小和类型，正如本章中所讨论的那样。虽然最终结果完全相同，但需要正确的排序和搜索算法才能为实际问题提供高效的解决方案。因此，仔细分析这些算法的性能非常重要。
- en: Sorting algorithms are used extensively in distributed data storage systems
    such as modern NoSQL databases that enable cluster and cloud computing architectures.
    In such data storage systems, data elements need to be regularly sorted and stored
    so that they can be retrieved efficiently.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 排序算法广泛应用于分布式数据存储系统，如现代NoSQL数据库，这些数据库支持集群和云计算架构。在这种数据存储系统中，数据元素需要定期排序和存储，以便能够有效地检索。
- en: 'The following sorting algorithms are presented in this chapter:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了以下排序算法：
- en: Bubble sort
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 冒泡排序
- en: Merge sort
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 归并排序
- en: Insertion sort
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插入排序
- en: Shell sort
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 希尔排序
- en: Selection sort
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择排序
- en: But before we look into these algorithms, let us first discuss the variable-swapping
    technique in Python that we will be using in the code presented in this chapter.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 但在我们深入研究这些算法之前，让我们先讨论Python中的变量交换技术，在本章中我们将在代码中使用它。
- en: Swapping variables in Python
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Python中交换变量
- en: 'When implementing sorting and searching algorithms, we need to swap the values
    of two variables. In Python, there is a standard way to swap two variables, which
    is as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现排序和搜索算法时，我们需要交换两个变量的值。在Python中，有一种标准的方法来交换两个变量的值，如下所示：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This simple way of swapping values is used throughout the sorting and searching
    algorithms in this chapter.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这种简单的交换值的方法在本章的排序和搜索算法中被广泛使用。
- en: Let’s start by looking at the bubble sort algorithm in the next section.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从下一节开始看冒泡排序算法。
- en: Bubble sort
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 冒泡排序
- en: Bubble sort is one of the simplest and slowest algorithms used for sorting.
    It is designed in such a way that the highest value in a list of data *bubbles*
    makes its way to the top as the algorithm loops through iterations. Bubble sort
    requires little runtime memory to run because all the ordering occurs within the
    original data structure. No new data structures are needed as temporary buffers.
    But its worst-case performance is *O(N2)*, which is quadratic time complexity
    (where *N* is the number of elements being sorted). As discussed in the following
    section, it is recommended to be used only for smaller datasets. Actual recommended
    limits for the size of the data for the use of bubble sort for sorting will depend
    on the memory and the processing resources available but keeping the number of
    elements (*N*) below 1000 can be considered as a general recommendation.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 冒泡排序是最简单也是最慢的排序算法之一。它的设计方式使得数据列表中最大的值在每次迭代中逐渐*冒泡*到列表的顶部。冒泡排序需要的运行时内存很少，因为所有的排序操作都发生在原始数据结构中。它不需要新的数据结构作为临时缓冲区。但其最坏情况性能是*O(N²)*，即二次时间复杂度（其中*N*为待排序元素的数量）。如下一节所讨论的，它建议仅用于较小的数据集。冒泡排序的实际推荐数据大小限制将取决于可用的内存和处理资源，但通常建议将元素数量（*N*）控制在1000以下。
- en: Understanding the logic behind bubble sort
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解冒泡排序背后的逻辑
- en: 'Bubble sort is based on various iterations, called passes. For a list of size
    *N*, bubble sort will have *N-1* passes. To understand its working, let’s focus
    on the first iteration: pass one.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 冒泡排序基于多次迭代，称为遍历。对于一个大小为*N*的列表，冒泡排序将有*N-1*次遍历。为了理解其工作原理，我们将专注于第一次迭代：第一次遍历。
- en: The goal of pass one is to push the highest value to the highest index (top
    of the list). In other words, we will see the highest value of the list *bubbling*
    its way to the top as pass one progresses.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次遍历的目标是将最大值推到列表的最高索引位置（顶部）。换句话说，随着第一次遍历的进行，我们将看到列表中的最大值逐渐*冒泡*到顶部。
- en: 'Bubble sort’s logic is based on comparing adjacent neighbor values. If the
    value at a higher index is higher in value than the value at a lower index, we
    exchange the values. This iteration continues until we reach the end of the list.
    This is shown in *Figure 3.1*:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 冒泡排序的逻辑基于比较相邻的邻居值。如果较高索引位置的值大于较低索引位置的值，我们就交换它们。这一迭代会一直进行，直到遍历到列表的末尾。该过程如*图3.1*所示：
- en: '![A picture containing text, electronics  Description automatically generated](img/B18046_03_01.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![一张包含文本的图片，电子产品  自动生成的描述](img/B18046_03_01.png)'
- en: 'Figure 3.1: Bubble sort algorithm'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1：冒泡排序算法
- en: 'Let’s now see how bubble sort can be implemented using Python. If we implement
    pass one of bubble sort in Python, it will look as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一下如何使用Python实现冒泡排序。如果我们在Python中实现冒泡排序的第一次遍历，它将如下所示：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Note that after the *first pass*:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在*第一次遍历*后：
- en: The highest value is at the top of the list, stored at `idx+1`.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最大值位于列表的顶部，存储在`idx+1`位置。
- en: While executing the first pass, the algorithm has to compare each of the elements
    of the list individually to *bubble* the maximum value to the top.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在执行第一次遍历时，算法必须单独比较列表中的每个元素，以*冒泡*出最大值并将其移至顶部。
- en: After completing the first pass, the algorithm moves on to the *second pass*.
    The goal of the second pass is to move the second-highest value to the second-highest
    index of the list. To do that, the algorithm will again compare adjacent neighbor
    values, exchanging them if they are not in order. The second pass will exclude
    the value at the top index, which was put in the right place by the first pass.
    So, it will have one less data element to tackle.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 完成第一次遍历后，算法进入到*第二次遍历*。第二次遍历的目标是将第二大值移动到列表中的第二大索引位置。为了实现这一点，算法将再次比较相邻的邻居值，如果它们的顺序不正确，则交换它们。第二次遍历将排除已经由第一次遍历放置到正确位置的顶部索引值。因此，它需要处理的数据元素将少一个。
- en: After completing the second pass, the algorithm keeps on performing the third
    pass and subsequent ones until all the data points of the list are in ascending
    order. The algorithm will need *N-1* passes for a list of size *N* to completely
    sort it.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 完成第二次遍历后，算法将继续进行第三次遍历及其后续遍历，直到列表中的所有数据点都按升序排列。对于一个大小为*N*的列表，算法需要进行*N-1*次遍历才能完全排序。
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We mentioned that performance is one of the limitations of the bubble sort
    algorithm. Let’s quantify the performance of bubble sort through the performance
    analysis of the bubble sort algorithm:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到过性能是冒泡排序算法的一个限制。接下来，我们将通过对冒泡排序算法的性能分析来量化其性能：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Optimizing bubble sort
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 优化冒泡排序
- en: The above implementation of bubble sort implemented with the `bubble_sort` function
    is a straightforward sorting method where adjacent elements are repeatedly compared
    and swapped if they are out of order. The algorithm consistently requires *O(N2)*
    comparisons and swaps in the worst-case scenario, where *N* is the number of elements
    in the list. This is because, for a list of *N* elements, the algorithm invariably
    goes through *N-1* passes, regardless of the initial order of the list.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 上述使用`bubble_sort`函数实现的冒泡排序是一种直接的排序方法，其中相邻元素不断被比较，并在顺序错误时进行交换。该算法在最坏情况下始终需要进行*O(N2)*次比较和交换，其中*N*是列表中的元素数量。这是因为，对于*N*个元素的列表，算法无论初始顺序如何，总是需要进行*N-1*次遍历。
- en: 'The following is an optimized version of bubble sort:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是优化版本的冒泡排序：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `optimized_bubble_sort` function introduces a notable enhancement to the
    bubble sort algorithm’s performance. By adding a `swapped` flag, this optimization
    permits the algorithm to detect early if the list is already sorted before making
    all *N-1* passes. When a pass completes without any swaps, it’s a clear indicator
    that the list has been sorted, and the algorithm can exit prematurely. Therefore,
    while the worst-case time complexity remains *O(N2)* for completely unsorted or
    reverse-sorted lists, the best-case complexity improves to *O(N)* for already
    sorted lists due to this optimization.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`optimized_bubble_sort`函数对冒泡排序算法的性能进行了显著的优化。通过引入一个`swapped`标志，这种优化使得算法可以在完成所有*N-1*次遍历之前，提前检测到列表是否已经排序。当一次遍历没有任何交换时，它就表明列表已经排序，算法可以提前退出。因此，尽管对于完全无序或反向排序的列表，最坏情况下时间复杂度仍为*O(N2)*，但由于这种优化，最佳情况下已经排序的列表的时间复杂度提高到了*O(N)*。'
- en: In essence, while both functions have a worst-case time complexity of *O(N2)*,
    the `optimized_bubble_sort` has the potential to perform significantly faster
    in real-world scenarios where data might be partially sorted, making it a more
    efficient version of the conventional bubble sort algorithm.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，虽然这两个函数在最坏情况下的时间复杂度都是*O(N2)*，但是`optimized_bubble_sort`在实际应用中可能表现得更快，特别是在数据部分已排序的情况下，使其成为传统冒泡排序算法的更高效版本。
- en: Performance analysis of the bubble sort algorithm
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 冒泡排序算法的性能分析
- en: 'It is easy to see that bubble sort involves two levels of loops:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易看出，冒泡排序包含两层循环：
- en: '**An outer loop**: These are also called **passes**. For example, pass one
    is the first iteration of the outer loop.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**外层循环**：这些也被称为**遍历**。例如，第一次遍历是外层循环的第一次迭代。'
- en: '**An inner loop**: This is when the remaining unsorted elements in the list
    are sorted until the highest value is bubbled to the right. The first pass will
    have *N-1* comparisons, the second pass will have *N-2* comparisons, and each
    subsequent pass will reduce the number of comparisons by one.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内层循环**：这是指在列表中剩余的未排序元素被排序，直到最大值被冒泡到右侧。第一次遍历将有*N-1*次比较，第二次遍历将有*N-2*次比较，每次遍历都会减少一次比较的数量。'
- en: 'The time complexity of the bubble sort algorithm is as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 冒泡排序算法的时间复杂度如下：
- en: '**Best case**: If the list is already sorted (or almost all elements are sorted),
    then the runtime complexity is *O(1)*.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最佳情况**：如果列表已经排序（或者几乎所有元素都已排序），那么运行时复杂度为*O(1)*。'
- en: '**Worst case**: If none or very few elements are sorted, then the worst-case
    runtime complexity is *O(n2)* as the algorithm will have to completely run through
    both the inner and outer loops.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最坏情况**：如果没有元素或只有很少的元素被排序，那么最坏情况下的运行时复杂度为*O(n2)*，因为算法将不得不完全执行内层和外层循环。'
- en: Now let us look into the insertion sort algorithm.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看插入排序算法。
- en: Insertion sort
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 插入排序
- en: The basic idea of insertion sort is that in each iteration, we remove a data
    point from the data structure we have and then insert it into its right position.
    That is why we call this the insertion sort algorithm.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 插入排序的基本思想是在每次迭代中，我们从已有的数据结构中移除一个数据点，然后将其插入到正确的位置。这就是我们称之为插入排序算法的原因。
- en: In the first iteration, we select the two data points and sort them. Then, we
    expand our selection and select the third data point and find its correct position,
    based on its value. The algorithm progresses until all the data points are moved
    to their correct positions.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一次迭代中，我们选择两个数据点并对它们进行排序。然后，我们扩展选择范围，选择第三个数据点并根据其值找到它的正确位置。算法会继续进行，直到所有数据点都被移动到正确的位置。
- en: 'This process is shown in the following diagram:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程如下面的图示所示：
- en: '![A picture containing table  Description automatically generated](img/B18046_03_02.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![A picture containing table  Description automatically generated](img/B18046_03_02.png)'
- en: 'Figure 3.2: Insertion sort algorithm'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2：插入排序算法
- en: 'The insertion sort algorithm can be coded in Python as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 插入排序算法可以通过以下方式在Python中实现：
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the core loop of the algorithm, we traverse through each element of the list
    starting from the second element (indexed at *1*). For each element, the algorithm
    checks the preceding elements to find their correct position in the sorted sublist.
    This check is performed in the condition `elements[j] > next_element`, ensuring
    that we’re placing our current ‘`next_element`' in the appropriate position in
    the sorted portion of the list.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在算法的核心循环中，我们从第二个元素（索引为*1*）开始遍历列表中的每个元素。对于每个元素，算法检查前面的元素，找出它们在已排序子列表中的正确位置。这个检查是在条件`elements[j]
    > next_element`中进行的，确保我们将当前的‘`next_element`'放置在列表已排序部分的适当位置。
- en: Let’s look at the performance of the insertion sort algorithm.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看插入排序算法的性能。
- en: Performance analysis of the insertion sort algorithm
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 插入排序算法的性能分析
- en: Understanding the efficiency of an algorithm is crucial in determining its suitability
    for different applications. Let’s delve into the performance characteristics of
    the insertion sort.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 理解算法的效率对于判断其适用于不同应用场景至关重要。让我们深入探讨插入排序的性能特点。
- en: '**Best case scenario**'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**最佳情况**'
- en: When the input data is already sorted, insertion sort demonstrates its best
    behavior. In such cases, the algorithm efficiently runs in linear time, denoted
    as *O(n)*, where *n* represents the number of elements in the data structure.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当输入数据已经排序时，插入排序表现最佳。在这种情况下，算法高效地在线性时间内运行，表示为*O(n)*，其中*n*表示数据结构中的元素数量。
- en: '**Worst case scenario**'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**最坏情况**'
- en: 'The efficiency takes a hit when the input is in reverse order, meaning the
    largest element is at the beginning. Here, for every element *i* (where *i* stands
    for the current element’s index in the loop), the inner loop might need to shift
    almost all preceding elements. The performance of insertion sort in this scenario
    can be represented mathematically by a quadratic function of the form:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当输入数据按逆序排列时，效率会受到影响，即最大元素位于开头。在这种情况下，对于每个元素*i*（其中*i*表示当前元素在循环中的索引），内层循环可能需要移动几乎所有前面的元素。插入排序在这种情况下的性能可以通过一个二次函数表示，形式如下：
- en: '![](img/B18046_03_001.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18046_03_001.png)'
- en: 'where:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 其中：
- en: '*w* is a weighting factor, adjusting the effect of *i*².'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*w*是一个权重因子，用于调整*i*²的影响。'
- en: '*N* represents a coefficient that scales with the size of the input.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*N*表示一个随着输入规模增长的系数。'
- en: '![](img/B18046_03_002.png) is a constant, typically representing minor overheads
    not covered by the other terms.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![](img/B18046_03_002.png) 是一个常量，通常表示其他项未涵盖的少量开销。'
- en: '**Average case scenario**'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**平均情况**'
- en: Generally, the average performance of insertion sort tends to be quadratic,
    which can be problematic for larger datasets.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，插入排序的平均性能趋向于二次，面对较大的数据集时，这可能会成为问题。
- en: '**Use cases and recommendations**'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用场景和建议**'
- en: 'Insertion sort is exceptionally efficient for:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 插入排序对于以下情况特别高效：
- en: Small datasets.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小型数据集。
- en: Nearly sorted datasets, where only a few elements are out of order.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 几乎排序的数据集，只有少数元素未排序。
- en: However, for larger, more random datasets, algorithms with better average and
    worst-case performances, like merge sort or quick sort, are more suitable. Insertion
    sort’s quadratic time complexity makes it less scalable for substantial amounts
    of data.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于较大且更加随机的数据集，具有更好平均和最坏情况性能的算法，如归并排序或快速排序，更为适用。插入排序的二次时间复杂度使其在处理大量数据时扩展性较差。
- en: Merge sort
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 归并排序
- en: Merge sort stands distinctively among sorting algorithms, like bubble sort and
    insertion sort, for its unique approach. Historically, it’s noteworthy that John
    von Neumann introduced this technique in 1940\. While many sorting algorithms
    perform better on partially sorted data, merge sort remains unfazed; its performance
    remains consistent irrespective of the initial arrangement of the data. This resilience
    makes it the preferred choice for sorting large datasets.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 与冒泡排序和插入排序等排序算法不同，归并排序因其独特的方法而显得格外突出。从历史上看，约翰·冯·诺依曼在1940年提出了这一技术。尽管许多排序算法在部分排序的数据上表现更好，但归并排序不受影响；其性能在数据初始排列方式无论如何都保持一致。这种韧性使其成为排序大数据集的首选方法。
- en: '**Divide and conquer: the core of merge sort**'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**分治法：归并排序的核心**'
- en: 'Merge sort employs a divide-and-conquer strategy comprising two key phases
    – splitting and merging:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 归并排序采用分治策略，包含两个关键阶段——分割和合并：
- en: '**Splitting phase**: Unlike directly iterating over the list, this phase recursively
    divides the dataset into halves. This division continues until each section reaches
    a minimal size (for illustrative purposes, let’s say a single element). While
    it might seem counterintuitive to split data to such granular levels, this granularity
    facilitates the organized merging in the next phase.'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**分割阶段**：与直接遍历列表不同，这一阶段递归地将数据集分割为两半。此分割继续进行，直到每个部分达到最小大小（为了说明目的，我们假设是一个元素）。虽然将数据分割到如此细粒度的程度可能看起来反直觉，但这种细粒度有助于在下一阶段进行有序的合并。'
- en: '**Merging phase**: Here, the previously divided parts are systematically merged.
    The algorithm continually processes and combines these sections until the entire
    list is sorted.'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**合并阶段**：在此阶段，先前分割的部分被系统地合并。算法不断处理并合并这些部分，直到整个列表被排序。'
- en: Refer to *Figure 3.3* for a visual representation of the merge sort algorithm.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 请参见*图3.3*，该图展示了归并排序算法的可视化表示。
- en: '![A diagram of a program  Description automatically generated with medium confidence](img/B18046_03_03.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![A diagram of a program  Description automatically generated with medium confidence](img/B18046_03_03.png)'
- en: 'Figure 3.3: Merge sort algorithm'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3：归并排序算法
- en: '**Pseudocode overview**'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**伪代码概览**'
- en: 'Before delving into the actual code, let’s understand its logic with some pseudocode:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入研究实际代码之前，让我们先通过一些伪代码来理解其逻辑：
- en: '[PRE11]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The pseudocode gives a snapshot of the algorithm’s steps:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 伪代码展示了该算法的步骤：
- en: Divide the list around a central `midPoint`.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将列表围绕中央的`midPoint`分割。
- en: Recursively split until each section has just one element.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 递归地将数组分割，直到每个部分只有一个元素。
- en: Systematically merge the sorted sections into a comprehensive sorted list.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 系统地将已排序的部分合并成一个完整的排序列表。
- en: '**Python implementation**'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python实现**'
- en: 'Here’s the Python rendition of merge sort:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是归并排序的Python实现：
- en: '[PRE12]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Shell sort
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Shell排序
- en: The bubble sort algorithm compares immediate neighbors and exchanges them if
    they are out of order. On the other hand, insertion sort creates the sorted list
    by transferring one element at a time. If we have a partially sorted list, insertion
    sort should give reasonable performance.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 冒泡排序算法比较相邻的元素，并在顺序错误时交换它们。另一方面，插入排序通过一次转移一个元素来创建排序好的列表。如果我们有一个部分排序的列表，插入排序应该能提供合理的性能。
- en: But for a totally unsorted list, sized *N*, you can argue that bubble sort will
    have to fully iterate through *N-1* passes in order to get it fully sorted.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 但对于完全未排序的列表，大小为*N*，你可以认为冒泡排序必须完全遍历*N-1*轮，才能将其完全排序。
- en: Donald Shell proposed Shell sort (named after him), which questions the importance
    of selecting immediate neighbors for comparison and swapping.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 唐纳德·谢尔（Donald Shell）提出了Shell排序（以他名字命名），该算法质疑了选择直接相邻元素进行比较和交换的重要性。
- en: Now, let’s understand this concept.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们理解这个概念。
- en: In pass one, instead of selecting immediate neighbors, we use elements that
    are at a fixed gap, eventually sorting a sublist consisting of a pair of data
    points. This is shown in the following diagram. In pass two, it sorts sublists
    containing four data points (see the following diagram). In subsequent passes,
    the number of data points per sublist keeps on increasing and the number of sublists
    keeps on decreasing until we reach a situation where there is just one sublist
    that consists of all the data points.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一轮中，我们不是选择直接相邻的元素，而是选择位于固定间隔的元素，最终排序由一对数据点组成的子列表。如下图所示。在第二轮中，它对包含四个数据点的子列表进行排序（见下图）。在随后的轮次中，每个子列表中的数据点数量不断增加，而子列表的数量不断减少，直到最终只剩下一个子列表，其中包含所有数据点。
- en: 'At this point, we can assume that the list is sorted:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在此时，我们可以假设列表已经排序：
- en: '![Chart  Description automatically generated](img/B18046_03_04.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![Chart  Description automatically generated](img/B18046_03_04.png)'
- en: 'Figure 3.4: Passes in the Shell sort algorithm'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4：Shell排序算法的各轮次
- en: 'In Python, the code for implementing the Shell sort algorithm is as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，实现Shell排序算法的代码如下：
- en: '[PRE14]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note that calling the `ShellSort` function has resulted in sorting the input
    array.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，调用`ShellSort`函数已经导致输入数组的排序。
- en: Performance analysis of the Shell sort algorithm
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Shell排序算法的性能分析
- en: It can be observed that, in the worst case, the Shell sort algorithm will have
    to run through both loops giving it a complexity of *O(n2)*. Shell sort is not
    for big data. It is used for medium-sized datasets. Roughly speaking, it has a
    reasonably good performance on a list with up to 6,000 elements. If the data is
    partially in the correct order, the performance will be better. In a best-case
    scenario, if a list is already sorted, it will only need one pass through *N*
    elements to validate the order, producing a best-case performance of *O(N)*.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 可以观察到，在最坏的情况下，Shell排序算法需要通过两个循环，因此它的时间复杂度为*O(n2)*。Shell排序不适用于大数据集，它适用于中等大小的数据集。大致来说，对于最多包含6,000个元素的列表，它的性能相对较好。如果数据部分已经有序，那么性能会更好。在最佳情况下，如果列表已经排序完毕，它只需要遍历*N*个元素来验证顺序，产生最优的*O(N)*性能。
- en: Selection sort
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择排序
- en: As we saw earlier in this chapter, bubble sort is one of the simplest sorting
    algorithms. Selection sort is an improvement on bubble sort, where we try to minimize
    the total number of swaps required with the algorithm. It is designed to make
    one swap for each pass, compared to *N-1* passes with the bubble sort algorithm.
    Instead of bubbling the largest value toward the top in baby steps (as done in
    bubble sort, resulting in *N-1* swaps), we look for the largest value in each
    pass and move it toward the top. So, after the first pass, the largest value will
    be at the top. After the second pass, the second largest value will be next to
    the top value. As the algorithm progresses, the subsequent values will move to
    their correct place based on their values.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在本章前面看到的，冒泡排序是最简单的排序算法之一。选择排序是冒泡排序的改进版本，它试图减少算法所需的交换次数。它的设计是每一轮仅进行一次交换，而冒泡排序需要进行*N-1*次交换。与冒泡排序将最大值逐步“冒泡”到顶部不同（这样会导致*N-1*次交换），选择排序每次都会寻找最大值并将其移动到顶部。因此，在第一次遍历后，最大值将位于顶部；第二次遍历后，第二大的值将紧跟在最大值后面。随着算法的进行，后续的值将根据其大小移动到正确的位置。
- en: 'The last value will be moved after the *(N-1)*^(th) pass. So, selection sort
    takes *N-1* passes to sort *N* items:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个值将在*(N-1)*^(次)遍后被移动。因此，选择排序需要*N-1*次遍历来排序*N*个项：
- en: '![Picture 16](img/B18046_03_05.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图片 16](img/B18046_03_05.png)'
- en: 'Figure 3.5: Selection sort algorithm'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5：选择排序算法
- en: 'The implementation of selection sort in Python is shown here:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示了选择排序在Python中的实现：
- en: '[PRE16]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Performance analysis of the selection sort algorithm
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选择排序算法的性能分析
- en: Selection sort’s worst-case performance is *O(N2)*. Note that its worst performance
    is similar to bubble sort, and it should not be used for sorting larger datasets.
    Still, selection sort is a better-designed algorithm than bubble sort and its
    average performance is better than bubble sort due to the reduction in the number
    of exchanges.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 选择排序的最坏情况性能是*O(N2)*。注意，它的最差性能与冒泡排序类似，因此不适合用于排序较大的数据集。不过，选择排序比冒泡排序更为精心设计，且由于减少了交换次数，它的平均性能也优于冒泡排序。
- en: Choosing a sorting algorithm
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择排序算法的选择
- en: When it comes to sorting algorithms, there isn’t a one-size-fits-all solution.
    The optimal choice often hinges on the specific circumstances surrounding your
    data, such as its size and current state. Here, we’ll delve into how to make an
    informed decision and highlight some real-world examples.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到排序算法时，并没有一种“放之四海而皆准”的解决方案。最优选择通常取决于你数据的具体情况，例如数据的大小和当前状态。在这里，我们将深入探讨如何做出明智的决策，并通过一些现实世界的例子来加以说明。
- en: '**Small and already sorted lists**'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**小型且已排序的列表**'
- en: For petite datasets, especially those already in order, it’s usually overkill
    to deploy a sophisticated algorithm. While an algorithm like merge sort is undeniably
    powerful, its complexities might overshadow its benefits for small data.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 对于较小的数据集，尤其是那些已经排好序的数据，通常使用复杂的算法会显得过于“杀鸡用牛刀”。虽然像归并排序这样强大的算法无可否认，但对于小数据集来说，它的复杂性可能会掩盖它的优势。
- en: '*Real-life example*: Imagine sorting a handful of books on a shelf by their
    authors’ last names. It’s simpler and quicker to just scan through and rearrange
    them manually (akin to a bubble sort) than to employ a detailed sorting method.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '*现实生活中的例子*：想象一下通过书架上书籍的作者姓氏来进行排序。直接扫描并手动调整顺序（类似于冒泡排序）比采用复杂的排序方法要简单快捷得多。'
- en: '**Partially sorted data**'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '**部分排序的数据**'
- en: When dealing with data that’s already somewhat organized, algorithms like insertion
    sort shine. They capitalize on the existing order, enhancing efficiency.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理已经有些组织的数据时，像插入排序这样的算法表现尤为出色。它们利用现有的顺序，从而提高效率。
- en: '*Real-life example*: Consider a classroom scenario. If students line up by
    height but a few are slightly out of place, the teacher can easily spot and adjust
    these minor discrepancies (mimicking insertion sort), rather than reordering the
    entire line.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '*现实生活中的例子*：考虑一个教室场景。如果学生按身高排队，但有一些略微不在正确位置，老师可以轻松发现并调整这些小的偏差（类似插入排序），而无需重新排队。'
- en: '**Large datasets**'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '**大数据集**'
- en: For extensive data, where the sheer volume can be overwhelming, merge sort proves
    to be a reliable ally. Its divide-and-conquer strategy efficiently tackles big
    lists, making it an industry favorite.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 对于庞大的数据集，数据量可能令人生畏，归并排序则被证明是一个可靠的帮手。其分治策略能够高效处理大列表，成为行业中的最爱。
- en: '*Real-life example*: Think about a massive library that receives thousands
    of books. Sorting these by publication date or author necessitates a systematic
    approach. Here, a method like merge sort, which breaks down the task into manageable
    chunks, is invaluable.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '*现实生活中的例子*：想象一下一个庞大的图书馆，每天接收成千上万本书籍。按出版日期或作者对它们进行排序需要一种系统的方法。在这里，像归并排序这样的算法，能够将任务分解成可管理的小块，显得尤为重要。'
- en: Introduction to searching algorithms
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 搜索算法简介
- en: 'At the heart of many computational tasks lies a fundamental need: locating
    specific data within complex structures. On the surface, the most straightforward
    approach might be to scan every single data point until you find your target.
    But, as we can imagine, this method loses its sheen as the volume of data swells.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多计算任务的核心中，存在一个基本需求：在复杂结构中定位特定数据。从表面上看，最简单的方法可能就是扫描每一个数据点，直到找到目标。但正如我们所想象的那样，随着数据量的增加，这种方法的效果会大打折扣。
- en: Why is searching so critical? Whether it’s a user querying a database, a system
    accessing files, or an application fetching specific data, efficient searching
    determines the speed and responsiveness of these operations. Without adept searching
    techniques, systems can become sluggish, especially with burgeoning datasets.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么搜索如此重要？无论是用户查询数据库、系统访问文件，还是应用程序获取特定数据，高效的搜索决定了这些操作的速度和响应能力。如果没有高效的搜索技术，系统会变得迟缓，尤其是在数据集不断膨胀的情况下。
- en: As the need for fast data retrieval rises, the role of sophisticated search
    algorithms becomes undeniable. They provide the agility and efficiency needed
    to wade through vast amounts of data, ensuring that systems remain nimble and
    users are satisfied. Thus, search algorithms act as the navigators of the digital
    realm, guiding us to the precise data we seek amid a sea of information.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 随着对快速数据检索需求的增加，复杂搜索算法的作用变得不可忽视。它们提供了所需的敏捷性和高效性，能够在海量数据中迅速找到目标，确保系统保持灵活，用户满意。因此，搜索算法成为数字世界的导航者，带领我们在信息的海洋中找到精确的数据。
- en: 'The following searching algorithms are presented in this section:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了以下搜索算法：
- en: Linear search
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线性搜索
- en: Binary search
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二分查找
- en: Interpolation search
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插值搜索
- en: Let’s look at each of them in more detail.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看它们。
- en: Linear search
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线性搜索
- en: One of the simplest strategies for searching data is to simply loop through
    each element looking for the target. Each data point is searched for a match and,
    when a match is found, the results are returned and the algorithm exits the loop.
    Otherwise, the algorithm keeps on searching until it reaches the end of the data.
    The obvious disadvantage of linear search is that it is very slow due to the inherent
    exhaustive search. The advantage is that the data does not need to be sorted,
    as required by the other algorithms presented in this chapter.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找数据的最简单策略之一是通过遍历每个元素来查找目标。每个数据点都会进行匹配搜索，当找到匹配时，返回结果并退出循环。否则，算法会继续搜索，直到数据的末尾。线性搜索的明显缺点是由于其固有的穷举搜索，它非常缓慢。其优点是数据无需像本章其他算法那样进行排序。
- en: 'Let’s look at the code for linear search:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下线性搜索的代码：
- en: '[PRE18]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let’s now look at the output of the preceding code:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看前面代码的输出：
- en: '[PRE19]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note that running the `LinearSearch` function returns a `True` value if it can
    successfully find the data.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，运行`LinearSearch`函数，如果能够成功找到数据，它将返回`True`值。
- en: Performance analysis of the linear search algorithm
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 线性搜索算法的性能分析
- en: As discussed, linear search is a simple algorithm that performs an exhaustive
    search. Its worst-case behavior is `O(N)`. More info can be found at [https://wiki.python.org/moin/TimeComplexity](https://wiki.python.org/moin/TimeComplexity).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，线性查找是一种简单的算法，执行的是穷举搜索。其最坏情况的时间复杂度为`O(N)`。更多信息请访问[https://wiki.python.org/moin/TimeComplexity](https://wiki.python.org/moin/TimeComplexity)。
- en: Binary search
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 二分查找
- en: 'The prerequisite of the binary search algorithm is sorted data. The algorithm
    iteratively divides a list into two parts and keeps track of the lowest and highest
    indices until it finds the value it is looking for:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 二分查找算法的前提是数据已经排序。该算法通过迭代地将列表分为两部分，并跟踪最低和最高索引，直到找到目标值：
- en: '[PRE21]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The output is as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE22]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note that calling the `BinarySearch` function will return `True` if the value
    is found in the input list.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，调用`BinarySearch`函数会在输入列表中找到值时返回`True`。
- en: Performance analysis of the binary search algorithm
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 二分查找算法的性能分析
- en: Binary search is so named because, at each iteration, the algorithm divides
    the data into two parts. If the data has N items, it will take a maximum of `O(logN)`
    steps to iterate. This means that the algorithm has an `O(logN)` runtime.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 二分查找之所以命名为“二分查找”，是因为在每次迭代中，算法都将数据分为两部分。如果数据有N个元素，最多需要`O(logN)`步进行迭代。这意味着该算法的运行时间复杂度为`O(logN)`。
- en: Interpolation search
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 插值查找
- en: 'Binary search is based on the logic that it focuses on the middle section of
    the data. Interpolation search is more sophisticated. It uses the target value
    to estimate the position of the element in the sorted array. Let’s try to understand
    it by using an example. Let’s assume we want to search for a word in an English
    dictionary, such as the word *river*. We will use this information to interpolate
    and start searching for words starting with *r*. A more generalized interpolation
    search can be programmed as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 二分查找的基本逻辑是它专注于数据的中间部分，而插值查找则更为复杂。插值查找利用目标值来估算元素在排序数组中的位置。我们通过一个例子来理解它。假设我们想在英语词典中查找一个单词，如*river*。我们将利用这些信息进行插值，并开始查找以*r*开头的单词。一个更为通用的插值查找可以编程实现如下：
- en: '[PRE24]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The output is as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE25]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note that before using `IntPolsearch`, the array first needs to be sorted using
    a sorting algorithm.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在使用`IntPolsearch`之前，数组需要先使用排序算法进行排序。
- en: Performance analysis of the interpolation search algorithm
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 插值查找算法的性能分析
- en: If the data is unevenly distributed, the performance of the interpolation search
    algorithm will be poor. The worst-case performance of this algorithm is *O(N)*,
    and if the data is somewhat reasonably uniform, the best performance is `O(log(log
    N))`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数据分布不均匀，插值查找算法的性能将较差。该算法的最坏情况时间复杂度为*O(N)*，而如果数据分布相对均匀，最佳性能则为`O(log(log N))`。
- en: Practical applications
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实际应用
- en: The ability to efficiently and accurately search data in a given data repository
    is critical to many real-life applications. Depending on your choice of searching
    algorithm, you may need to sort the data first as well. The choice of the right
    sorting and searching algorithms will depend on the type and the size of the data,
    as well as the nature of the problem you are trying to solve.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在给定数据存储库中高效且准确地查找数据，对于许多实际应用至关重要。根据你选择的查找算法，你可能还需要先对数据进行排序。选择合适的排序和查找算法将取决于数据的类型和大小，以及你要解决问题的性质。
- en: Let’s try to use the algorithms presented in this chapter to solve the problem
    of matching a new applicant at the immigration department of a certain country
    with historical records. When someone applies for a visa to enter the country,
    the system tries to match the applicant with the existing historical records.
    If at least one match is found, then the system further calculates the number
    of times that the individual has been approved or refused in the past. On the
    other hand, if no match is found, the system classes the applicant as a new applicant
    and issues them a new identifier.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试使用本章介绍的算法来解决某个国家移民局为新申请人匹配历史记录的问题。当有人申请签证进入该国时，系统会尝试将申请人与现有的历史记录进行匹配。如果找到至少一个匹配项，系统会进一步计算该人过去被批准或拒绝的次数。另一方面，如果没有找到匹配项，系统将此申请人归类为新申请人，并为其分配一个新的标识符。
- en: The ability to search, locate, and identify a person in the historical data
    is critical for the system. This information is important because if someone has
    applied in the past and the application is known to have been refused, then this
    may affect that individual’s current application in a negative way. Similarly,
    if someone’s application is known to have been approved in the past, this approval
    may increase the chances of that individual getting approval for their current
    application. Typically, the historical database will have millions of rows, and
    we will need a well-designed solution to match new applicants in the historical
    database.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在历史数据中搜索、定位和识别一个人的能力对于系统至关重要。这个信息非常重要，因为如果某人过去申请过且申请被拒绝，这可能会对该人当前的申请产生负面影响。同样，如果某人的申请过去被批准，这个批准可能会增加该人当前申请获批的机会。通常，历史数据库将包含数百万行数据，我们需要一个设计良好的解决方案，以便在历史数据库中匹配新的申请人。
- en: 'Let’s assume that the historical table in the database looks like the following:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 假设数据库中的历史表格如下所示：
- en: '| **Personal ID** | **Application ID** | **First name** | **Surname** | **DOB**
    | **Decision** | **Decision date** |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| **个人ID** | **申请ID** | **名字** | **姓氏** | **出生日期** | **决定** | **决定日期** |'
- en: '| 45583 | 677862 | John | Doe | 2000-09-19 | Approved | 2018-08-07 |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| 45583 | 677862 | John | Doe | 2000-09-19 | 已批准 | 2018-08-07 |'
- en: '| 54543 | 877653 | Xman | Xsir | 1970-03-10 | Rejected | 2018-06-07 |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| 54543 | 877653 | Xman | Xsir | 1970-03-10 | 被拒绝 | 2018-06-07 |'
- en: '| 34332 | 344565 | Agro | Waka | 1973-02-15 | Rejected | 2018-05-05 |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| 34332 | 344565 | Agro | Waka | 1973-02-15 | 被拒绝 | 2018-05-05 |'
- en: '| 45583 | 677864 | John | Doe | 2000-09-19 | Approved | 2018-03-02 |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| 45583 | 677864 | John | Doe | 2000-09-19 | 已批准 | 2018-03-02 |'
- en: '| 22331 | 344553 | Kal | Sorts | 1975-01-02 | Approved | 2018-04-15 |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| 22331 | 344553 | Kal | Sorts | 1975-01-02 | 已批准 | 2018-04-15 |'
- en: In this table, the first column, `Personal ID`, is associated with each of the
    unique applicants in the historical database. If there are 30 million unique applicants
    in the historical database, then there will be 30 million unique personal IDs.
    Each personal ID identifies an applicant in the historical database system.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个表格中，第一列`个人ID`与历史数据库中的每个独特申请人相关联。如果历史数据库中有3000万独特申请人，那么就会有3000万个独特的个人ID。每个个人ID都标识历史数据库系统中的一个申请人。
- en: The second column we have is `Application ID`. Each application ID identifies
    a unique application in the system. A person may have applied more than once in
    the past. So, this means that, in the historical database, we will have more unique
    application IDs than personal IDs. John Doe will only have one personal ID but
    has two application IDs, as shown in the preceding table.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第二列是`申请ID`。每个申请ID都标识系统中的唯一申请。一个人可能在过去申请过多次。因此，在历史数据库中，我们将拥有比个人ID更多的独特申请ID。John
    Doe 只有一个个人ID，但有两个申请ID，如上表所示。
- en: 'The preceding table only shows a sample of the historical dataset. Let’s assume
    that we have close to 1 million rows in our historical dataset, which contains
    the records of the last 10 years of applicants. New applicants are continuously
    arriving at the average rate of around 2 applicants per minute. For each applicant,
    we need to do the following:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 上表仅显示了历史数据集的一部分。假设我们在历史数据集中有接近100万行数据，涵盖了过去10年申请人的记录。新申请人以大约每分钟2个申请人的平均速度不断到达。对于每个申请人，我们需要做如下操作：
- en: Issue a new application ID for the applicant.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为申请人发放新的申请ID。
- en: See if there is a match with an applicant in the historical database.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看是否与历史数据库中的某个申请人匹配。
- en: If a match is found, use the personal ID for that applicant, as found in the
    historical database. We also need to determine how many times the application
    has been approved or refused in the historical database.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果找到匹配项，则使用该申请人在历史数据库中找到的个人ID。我们还需要确定该申请在历史数据库中已被批准或拒绝的次数。
- en: If no match is found, then we need to issue a new personal ID for that individual.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有找到匹配项，那么我们需要为该个人发放一个新的个人ID。
- en: 'Suppose a new person arrives with the following credentials:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有一个新的人带着以下凭证到达：
- en: '`First Name: John`'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`名字：John`'
- en: '`Surname: Doe`'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`姓氏：Doe`'
- en: '`DOB: 2000-09-19`'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`出生日期：2000-09-19`'
- en: Now, how can we design an application that can perform an efficient and cost-effective
    search?
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何设计一个能够高效且具成本效益地执行搜索的应用程序呢？
- en: 'One strategy for searching the new application in the database can be devised
    as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 一种搜索新申请的策略可以如下设计：
- en: Sort the historical database by `DOB`.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照`出生日期`（DOB）对历史数据库进行排序。
- en: Each time a new person arrives, issue a new application ID to the applicant.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每当有新的人到来时，向申请人发放一个新的应用ID。
- en: Fetch all the records that match that date of birth. This will be the primary
    search.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取所有与出生日期匹配的记录。这将是主要的搜索条件。
- en: Out of the records that have come up as matches, perform a secondary search
    using the first and last name.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从所有匹配的记录中，使用姓名进行二次搜索。
- en: If a match is found, use `Personal ID` to refer to the applicants. Calculate
    the number of approvals and refusals.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果找到匹配项，则使用`个人ID`来引用申请人。计算批准和拒绝的数量。
- en: If no match is found, issue a new personal ID to the applicant.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果未找到匹配项，则向申请人发放新的个人ID。
- en: Let’s try choosing the right algorithm to sort the historical database. We can
    safely rule out bubble sort as the size of the data is huge. Shell sort will perform
    better, but only if we have partially sorted lists. So, merge sort may be the
    best option for sorting the historical database.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试选择合适的算法来对历史数据库进行排序。由于数据量庞大，我们可以安全地排除冒泡排序。希尔排序表现更好，但前提是我们有部分已排序的列表。因此，归并排序可能是对历史数据库进行排序的最佳选择。
- en: When a new person arrives, we need to search for and locate that person in the
    historical database. As the data is already sorted, either interpolation search
    or binary search can be used. Because applicants are likely to be equally spread
    out, as per `DOB`, we can safely use binary search.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个新的人到来时，我们需要在历史数据库中搜索并定位该人。由于数据已经排序，可以使用插值搜索或二分查找。因为申请人可能会均匀分布，根据`DOB`，我们可以安全地使用二分查找。
- en: Initially, we search based on `DOB`, which returns a set of applicants sharing
    the same date of birth. Now, we need to find the required person within the small
    subset of people who share the same date of birth. As we have successfully reduced
    the data to a small subset, any of the search algorithms, including bubble sort,
    can be used to search for the applicant. Note that we have simplified the secondary
    search problem here a bit. We also need to calculate the total number of approvals
    and refusals by aggregating the search results, if more than one match is found.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，我们根据`DOB`进行搜索，返回一组具有相同出生日期的申请人。现在，我们需要在这一小部分具有相同出生日期的人中找到所需的申请人。由于我们已经成功将数据减少到一个小子集，因此可以使用任何搜索算法，包括冒泡排序，来搜索申请人。请注意，我们在这里简化了二次搜索问题。如果找到多个匹配项，我们还需要通过聚合搜索结果来计算批准和拒绝的总数。
- en: In a real-world scenario, each individual needs to be identified in the secondary
    search using some fuzzy search algorithm, as the first and last names may be spelled
    slightly differently. The search may need to use some kind of distance algorithm
    to implement the fuzzy search, where the data points whose similarity is above
    a defined threshold are considered the same.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实场景中，每个个体在二次搜索中都需要使用某种模糊搜索算法进行识别，因为姓名可能会有轻微的拼写差异。搜索可能需要使用某种距离算法来实现模糊搜索，在该算法中，相似度超过定义阈值的数据点被认为是相同的。
- en: Summary
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we presented a set of sorting and searching algorithms. We
    also discussed the strengths and weaknesses of different sorting and searching
    algorithms. We quantified the performance of these algorithms and learned when
    to use each algorithm.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们介绍了一组排序和查找算法。我们还讨论了不同排序和查找算法的优缺点。我们量化了这些算法的性能，并学习了何时使用每种算法。
- en: In the next chapter, we will study dynamic algorithms. We will also look at
    a practical example of designing an algorithm and the details of the page ranking
    algorithm. Finally, we will study the linear programming algorithm.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将学习动态算法。我们还将通过一个设计算法的实际示例来了解页面排名算法的细节。最后，我们将学习线性规划算法。
- en: Learn more on Discord
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Discord上了解更多
- en: 'To join the Discord community for this book – where you can share feedback,
    ask questions to the author, and learn about new releases – follow the QR code
    below:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 要加入本书的Discord社区——在这里你可以分享反馈、向作者提问并了解新版本的发布——请扫描下面的二维码：
- en: '[https://packt.link/WHLel](https://packt.link/WHLel)'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/WHLel](https://packt.link/WHLel)'
- en: '![](img/QR_Code1955211820597889031.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code1955211820597889031.png)'
