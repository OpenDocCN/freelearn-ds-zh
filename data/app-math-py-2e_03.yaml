- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Calculus and Differential Equations
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微积分与微分方程
- en: In this chapter, we will discuss various topics related to calculus. Calculus
    is the branch of mathematics that concerns the processes of differentiation and
    integration. Geometrically, the derivative of a function represents the gradient
    of the curve of the function, and the integral of a function represents the area
    below the curve of the function. Of course, these characterizations only hold
    in certain circumstances, but they provide a reasonable foundation for this chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将讨论与微积分相关的各种主题。微积分是数学的一个分支，涉及到微分和积分的过程。在几何上，函数的导数表示函数曲线的梯度，而函数的积分表示曲线下方的面积。当然，这些描述仅在某些情况下成立，但它们为本章提供了合理的基础。
- en: 'We’ll start by looking at calculus for a simple class of functions: polynomials.
    In the first recipe, we’ll create a class that represents a polynomial and define
    methods that differentiate and integrate the polynomial. Polynomials are convenient
    because the derivative or integral of a polynomial is again a polynomial. Then,
    we’ll use the `SymPy` package to perform symbolic differentiation and integration
    on more general functions. After that, we’ll look at methods for solving equations
    using the SciPy package. Then, we’ll turn our attention to numerical integration
    (quadrature) and solving differential equations. We’ll use the SciPy package to
    solve **ordinary differential equations** (**ODEs**) and systems of ODEs, and
    then use a finite difference scheme to solve a simple partial differential equation.
    Finally, we’ll use the **Fast Fourier transform** (**FFT**) to process a noisy
    signal and filter out the noise.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从研究一种简单类型的函数——多项式的微积分开始。在第一个实例中，我们将创建一个表示多项式的类，并定义求导和积分的方法。多项式之所以方便，是因为多项式的导数或积分仍然是一个多项式。接下来，我们将使用
    `SymPy` 包对更一般的函数进行符号微分和积分。然后，我们将使用 SciPy 包中的方法求解方程。接着，我们将把注意力转向数值积分（求积）和求解微分方程。我们将使用
    SciPy 包求解**常微分方程**（**ODEs**）及常微分方程系统，并利用有限差分法求解简单的偏微分方程。最后，我们将使用**快速傅里叶变换**（**FFT**）处理噪声信号并滤除噪声。
- en: The content of this chapter will help you solve problems that involve calculus,
    such as computing the solution to differential equations, which frequently arise
    when describing the physical world. We’ll also dip into calculus later in [*Chapter
    9*](B19085_09.xhtml#_idTextAnchor360) when we discuss optimization. Several optimization
    algorithms require some kind of knowledge of derivatives, including the backpropagation
    commonly used in **machine** **learning** (**ML**).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章内容将帮助你解决涉及微积分的问题，例如求解微分方程的解，而微分方程在描述物理世界时经常出现。稍后在 [*第九章*](B19085_09.xhtml#_idTextAnchor360)中，我们将进一步讨论优化问题。多个优化算法需要一定的导数知识，包括广泛应用于**机器学习**（**ML**）中的反向传播。
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍以下内容：
- en: Working with polynomials and calculus
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多项式与微积分运算
- en: Differentiating and integrating symbolically using SymPy
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 SymPy 进行符号微分和积分
- en: Solving equations
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 求解方程
- en: Integrating functions numerically using SciPy
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 SciPy 数值积分
- en: Solving simple differential equations numerically
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数值求解简单微分方程
- en: Solving systems of differential equations
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 求解微分方程系统
- en: Solving partial differential equations numerically
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数值求解偏微分方程
- en: Using discrete Fourier transforms for signal processing
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用离散傅里叶变换进行信号处理
- en: Automatic differentiation and calculus using JAX
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 JAX 进行自动微分和微积分
- en: Solving differential equations using JAX
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 JAX 求解微分方程
- en: Technical requirements
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In addition to the scientific Python packages NumPy and SciPy, we also need
    the SymPy, JAX, and `diffrax` packages. These can be installed using your favorite
    package manager, such as `pip`:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 除了科学计算 Python 包 NumPy 和 SciPy，我们还需要 SymPy、JAX 和 `diffrax` 包。你可以通过你喜欢的包管理器（如
    `pip`）进行安装：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'There are different options for the way you install JAX. Please see the official
    documentation for more details: [https://github.com/google/jax#installation](https://github.com/google/jax#installation).'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 JAX 有多种方式，请参阅官方文档了解更多详细信息：[https://github.com/google/jax#installation](https://github.com/google/jax#installation)。
- en: The code for this chapter can be found in the `Chapter 03` folder of the GitHub
    repository at [https://github.com/PacktPublishing/Applying-Math-with-Python-2nd-Edition/tree/main/Chapter%2003](https://github.com/PacktPublishing/Applying-Math-with-Python-2nd-Edition/tree/main/Chapter%2003).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在GitHub仓库的`Chapter 03`文件夹中找到，链接为[https://github.com/PacktPublishing/Applying-Math-with-Python-2nd-Edition/tree/main/Chapter%2003](https://github.com/PacktPublishing/Applying-Math-with-Python-2nd-Edition/tree/main/Chapter%2003)。
- en: Primer on calculus
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微积分入门
- en: 'Calculus is the study of functions and the way that they change. There are
    two major processes in calculus: **differentiation** and **integration**. Differentiation
    takes a function and produces a new function—called the **derivative**—that is
    the *best linear approximation* at each point. (You may see this described as
    the **gradient** of the function. Integration is often described as *anti-differentiation*—indeed,
    differentiating the integral of a function does give back the original function—but
    is also an abstract description of the area between the graph of the function
    and the ![](img/Formula_03_001.png) axis, taking into account where the curve
    is above or below the axis.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 微积分是研究函数及其变化方式的学科。微积分中有两个主要过程：**求导**和**积分**。求导将一个函数转化为一个新函数，称为**导数**，它是每个点处的*最佳线性逼近*。（你可能会看到这被描述为函数的**梯度**。积分通常被描述为*反求导*，确实，对函数的积分求导会得到原始函数，但也是对函数图形与![](img/Formula_03_001.png)轴之间区域的抽象描述，考虑曲线在轴上方或下方的位置。
- en: 'Abstractly, the derivative of a function ![](img/Formula_03_002.png) at a point
    ![](img/Formula_03_003.png) is defined as a limit (which we won’t describe here)
    of the quantity:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象地说，函数![](img/Formula_03_002.png)在点![](img/Formula_03_003.png)处的导数被定义为一个极限（我们这里不描述），其数量为：
- en: '![](img/Formula_03_004.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_03_004.jpg)'
- en: 'This is because this small number ![](img/Formula_03_005.png) becomes smaller
    and smaller. This is the *difference in* ![](img/Formula_03_006.png) divided by
    the *difference in* ![](img/Formula_03_007.png), which is why the derivative is
    sometimes written as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为这个小数![](img/Formula_03_005.png)变得越来越小。这是![](img/Formula_03_006.png)的*差异除以*![](img/Formula_03_007.png)的*差异，这就是为什么导数有时被写成如下形式：
- en: '![](img/Formula_03_008.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_03_008.jpg)'
- en: 'There are numerous rules for differentiating common function forms: for example,
    in the first recipe, we will see that the derivative of ![](img/Formula_03_009.png)
    is ![](img/Formula_03_010.png). The derivative of the exponential function ![](img/Formula_03_011.png)
    is, again, ![](img/Formula_03_012.png); the derivative of ![](img/Formula_03_013.png)
    is ![](img/Formula_03_014.png); and the derivative of ![](img/Formula_03_0141.png)
    is ![](img/Formula_03_016.png). These basic building blocks can be combined using
    the *product rule* and *chain rule*, and by the fact that derivatives of sums
    are sums of derivatives, to differentiate more complex functions.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多常见函数形式的求导规则：例如，在第一个公式中，我们将看到![](img/Formula_03_009.png)的导数是![](img/Formula_03_010.png)。指数函数![](img/Formula_03_011.png)的导数是，再次，![](img/Formula_03_012.png)；![](img/Formula_03_013.png)的导数是![](img/Formula_03_014.png)；![](img/Formula_03_0141.png)的导数是![](img/Formula_03_016.png)。这些基本构件可以使用*乘积法则*和*链式法则*以及导数的和是导数的和的事实来组合，以求导更复杂的函数。
- en: 'In its indefinite form, integration is the opposite process of differentiation.
    In its definite form, the integral of a function ![](img/Formula_03_017.png) is
    the (signed) area that lies between the curve of ![](img/Formula_03_018.png) and
    the ![](img/Formula_03_019.png) axis—note that this is a simple number, not a
    function. The indefinite integral of ![](img/Formula_03_020.png) is usually written
    like this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在其无限形式中，积分是求导的相反过程。在其确定形式中，函数![](img/Formula_03_017.png)的积分是曲线![](img/Formula_03_018.png)与![](img/Formula_03_019.png)轴之间的（带符号的）面积—注意这是一个简单的数值，不是一个函数。![](img/Formula_03_020.png)的不定积分通常写成这样：
- en: '![](img/Formula_03_021.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_03_021.jpg)'
- en: 'Here, the derivative of this function is ![](img/Formula_03_022.png). The definite
    integral of ![](img/Formula_03_023.png) between ![](img/Formula_03_024.png) and
    ![](img/Formula_03_025.png) is given by the following equation:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，这个函数的导数是![](img/Formula_03_022.png)。![](img/Formula_03_024.png)和![](img/Formula_03_025.png)之间的![](img/Formula_03_023.png)的定积分由以下方程给出：
- en: '![](img/Formula_03_026.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_03_026.jpg)'
- en: Here, ![](img/Formula_03_027.png) is the indefinite integral of ![](img/Formula_03_028.png).
    We can, of course, define the indefinite integral abstractly, using limits of
    sums approximating the area below the curve, and then define the indefinite integral
    in terms of this abstract quantity. (We won’t go into detail here.) The most important
    thing to remember with indefinite integrals is the **constant** **of integration**.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，![](img/Formula_03_027.png) 是 ![](img/Formula_03_028.png) 的不定积分。我们当然可以通过使用近似曲线下方区域的和的极限来抽象地定义不定积分，然后用这个抽象量来定义不定积分。（我们在这里不详细探讨。）需要记住的最重要的事情是**积分常数**。
- en: 'There are several easily deduced indefinite integrals (*anti-derivatives*)
    that we can quickly deduce: the integral of ![](img/Formula_03_029.png) is ![](img/Formula_03_030.png)
    (this is what we would differentiate to get ![](img/Formula_03_031.png)); the
    integral of ![](img/Formula_03_032.png) is ![](img/Formula_03_033.png); the integral
    of ![](img/Formula_03_034.png) is ![](img/Formula_03_035.png); and the integral
    of ![](img/Formula_03_036.png) is ![](img/Formula_03_037.png). In all these examples,
    ![](img/Formula_03_038.png) is the constant of integration. We can combine these
    simple rules to integrate more interesting functions by using the techniques of
    integration by parts or integration by substitution (and a host of much more involved
    techniques that we won’t mention here).'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个容易推导的定积分（*反导数*），我们可以快速推导出：![](img/Formula_03_029.png) 的积分是 ![](img/Formula_03_030.png)（这是我们求导得到
    ![](img/Formula_03_031.png) 的结果）；![](img/Formula_03_032.png) 的积分是 ![](img/Formula_03_033.png)；![](img/Formula_03_034.png)
    的积分是 ![](img/Formula_03_035.png)；![](img/Formula_03_036.png) 的积分是 ![](img/Formula_03_037.png)。在所有这些例子中，![](img/Formula_03_038.png)
    是积分常数。我们可以结合这些简单的规则，通过分部积分法或代换积分法（以及一些更复杂的技术，我们这里不作详细讨论）来对更有趣的函数进行积分。
- en: Working with polynomials and calculus
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作多项式和微积分
- en: 'Polynomials are among the simplest functions in mathematics and are defined
    as a sum:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 多项式是数学中最简单的函数之一，它们被定义为一个和式：
- en: '![](img/Formula_03_039.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_03_039.jpg)'
- en: Here, ![](img/Formula_03_040.png) represents a placeholder to be substituted
    (an indeterminate), and ![](img/Formula_03_041.png) is a number. Since polynomials
    are simple, they provide an excellent means for a brief introduction to calculus.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，![](img/Formula_03_040.png) 代表一个要被替换的占位符（不确定量），而 ![](img/Formula_03_041.png)
    是一个数字。由于多项式非常简单，它们为微积分的简要介绍提供了极好的手段。
- en: In this recipe, we will define a simple class that represents a polynomial and
    write methods for this class to perform differentiation and integration.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实例中，我们将定义一个表示多项式的简单类，并为该类编写微分和积分的方法。
- en: Getting ready
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备开始
- en: There are no additional packages required for this recipe.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实例不需要额外的包。
- en: How to do it...
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'The following steps describe how to create a class representing a polynomial,
    and implement differentiation and integration methods for this class:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤描述了如何创建一个表示多项式的类，并为该类实现微分和积分方法：
- en: 'Let’s start by defining a simple class to represent a polynomial:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从定义一个简单的类来表示多项式开始：
- en: '[PRE1]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now that we have defined a basic class for a polynomial, we can move on to
    implement the differentiation and integration operations for this `Polynomial`
    class to illustrate how these operations change polynomials. We start with differentiation.
    We generate new coefficients by multiplying each element in the current list of
    coefficients without the first element. We use this new list of coefficients to
    create a new `Polynomial` instance that is returned:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经定义了一个表示多项式的基本类，我们可以继续实现该 `Polynomial` 类的微分和积分操作，以说明这些操作如何改变多项式。我们从微分开始。通过将当前系数列表中的每个元素与第一个元素之外的其他元素相乘，我们生成新的系数。然后，我们使用这个新的系数列表创建一个新的
    `Polynomial` 实例，并返回该实例：
- en: '[PRE9]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To implement the integration method, we need to create a new list of coefficients
    containing the new constant (converted to a float for consistency) given by the
    argument. We then add to this list of coefficients the old coefficients divided
    by their new position in the list:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要实现积分方法，我们需要创建一个新的系数列表，其中包含由参数给出的新常数（为了保持一致性，转换为浮点数）。然后我们将旧系数除以它们在列表中的新位置，添加到这个系数列表中：
- en: '[PRE14]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Finally, to make sure these methods work as expected, we should test these
    two methods with a simple case. We can check this using a very simple polynomial,
    such as ![](img/Formula_03_042.png):'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，为了确保这些方法按预期工作，我们应该通过一个简单的例子来测试这两种方法。我们可以使用一个非常简单的多项式来进行检查，例如 ![](img/Formula_03_042.png)：
- en: '[PRE20]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The derivative here is given the coefficients ![](img/Formula_03_043.png) and
    ![](img/Formula_03_044.png), which corresponds to the polynomial ![](img/Formula_03_045.png),
    which is indeed the derivative of ![](img/Formula_03_046.png). Similarly, the
    coefficients of the integral correspond to the polynomial ![](img/Formula_03_047.png),
    which is also correct (with constant of integration ![](img/Formula_03_048.png)).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的导数给出了系数 ![](img/Formula_03_043.png) 和 ![](img/Formula_03_044.png)，它对应的多项式是
    ![](img/Formula_03_045.png)，这实际上是 ![](img/Formula_03_046.png) 的导数。类似地，积分的系数对应的多项式是
    ![](img/Formula_03_047.png)，这也是正确的（包含积分常数 ![](img/Formula_03_048.png)）。
- en: How it works...
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Polynomials offer an easy introduction to the basic operations of calculus,
    but it isn’t so easy to construct Python classes for other general classes of
    functions. That being said, polynomials are extremely useful because they are
    well understood and, perhaps more importantly, calculus for polynomials is very
    easy. For powers of a variable ![](img/Formula_03_049.png), the rule for differentiation
    is to multiply by the power and reduce the power by 1 so that ![](img/Formula_03_050.png)
    becomes ![](img/Formula_03_051.png), so our rule for differentiating a polynomial
    is to simply multiply each coefficient by its position and remove the first coefficient.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 多项式为微积分的基本运算提供了一个简单的介绍，但要为其他一般函数类构建 Python 类并不是那么容易。也就是说，多项式非常有用，因为它们已经被很好地理解，并且更重要的是，多项式的微积分运算非常简单。对于一个变量的幂
    ![](img/Formula_03_049.png)，微分规则是将幂与该幂相乘并将幂减 1，结果是 ![](img/Formula_03_050.png)
    变为 ![](img/Formula_03_051.png)，所以我们对多项式的微分规则是将每个系数乘以它的位置，并去掉第一个系数。
- en: Integration is more complex since the integral of a function is not unique.
    We can add any constant to an integral and obtain a second integral. For powers
    of a variable ![](img/Formula_03_052.png), the rule for integration is to increase
    the power by 1 and divide by the new power so that ![](img/Formula_03_053.png)
    becomes ![](img/Formula_03_054.png). Therefore, to integrate a polynomial, we
    increase each power of ![](img/Formula_03_055.png) by 1 and divide the corresponding
    coefficient by the new power. Hence, our rule is to first insert the new constant
    of integration as the first element and divide each of the existing coefficients
    by its new position in the list.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 积分更加复杂，因为一个函数的积分不是唯一的。我们可以在积分中加上任何常数，从而得到第二个积分。对于一个变量的幂 ![](img/Formula_03_052.png)，积分规则是将幂加
    1 并除以新的幂，结果是 ![](img/Formula_03_053.png) 变为 ![](img/Formula_03_054.png)。因此，要对多项式进行积分，我们将每个幂的
    ![](img/Formula_03_055.png) 加 1，并将相应的系数除以新的幂。因此，我们的规则是先插入新的积分常数作为第一个元素，然后将每个现有系数除以它在列表中的新位置。
- en: The `Polynomial` class that we defined in the recipe is rather simplistic but
    represents the core idea. A polynomial is uniquely determined by its coefficients,
    which we can store as a list of numerical values. Differentiation and integration
    are operations that we can perform on this list of coefficients. We include a
    simple `__repr__` method to help with the display of `Polynomial` objects, and
    a `__call__` method to facilitate evaluation at specific numerical values. This
    is mostly to demonstrate the way that a polynomial is evaluated.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在示例中定义的 `Polynomial` 类相当简化，但它代表了核心思想。一个多项式是由它的系数唯一决定的，我们可以将系数存储为数值列表。微分和积分是我们可以对这个系数列表执行的操作。我们包括了一个简单的
    `__repr__` 方法来帮助显示 `Polynomial` 对象，并且提供了一个 `__call__` 方法来便于在特定数值下进行计算。这个方法主要是为了展示多项式如何被计算。
- en: Polynomials are useful for solving certain problems that involve evaluating
    a computationally expensive function. For such problems, we can sometimes use
    some kind of polynomial interpolation, where we *fit* a polynomial to another
    function, and then use the properties of polynomials to help solve the original
    problem. Evaluating a polynomial is much *cheaper* than the original function,
    so this can lead to dramatic improvements in speed. This usually comes at the
    cost of some accuracy. For example, Simpson’s rule for approximating the area
    under a curve approximates the curve by quadratic polynomials over intervals defined
    by three consecutive mesh points. The area below each quadratic polynomial can
    be calculated easily by integration.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 多项式对于解决某些涉及评估计算开销大的函数的问题非常有用。对于这类问题，我们有时可以使用某种多项式插值，将一个多项式拟合到另一个函数上，然后利用多项式的性质来帮助解决原始问题。评估多项式比原始函数要*便宜*得多，因此这可以显著提高速度。这通常会以牺牲一些精度为代价。例如，辛普森法则通过在由三个连续网格点定义的区间上，用二次多项式来逼近曲线下的面积。每个二次多项式下的面积可以通过积分轻松计算。
- en: There’s more...
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Polynomials have many more important roles in computational programming than
    simply demonstrating the effect of differentiation and integration. For this reason,
    a much richer `Polynomial` class is provided in the `numpy.polynomial` NumPy package.
    The NumPy `Polynomial` class, and the various derived subclasses, are useful in
    all kinds of numerical problems and support arithmetic operations as well as other
    methods. In particular, there are methods for fitting polynomials to collections
    of data.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 多项式在计算编程中比单纯展示微分和积分的效果要扮演更多重要角色。因此，`numpy.polynomial` NumPy包中提供了一个更为丰富的`Polynomial`类。NumPy的`Polynomial`类及其衍生的各种子类在各种数值问题中都非常有用，支持算术运算以及其他方法。特别地，这些方法可以用于将多项式拟合到数据集合上。
- en: 'NumPy also provides classes, derived from `Polynomial`, that represent various
    special kinds of polynomials. For example, the `Legendre` class represents a specific
    system of polynomials called *Legendre polynomials*. Legendre polynomials are
    defined for ![](img/Formula_03_056.png) satisfying ![](img/Formula_03_057.png)
    and form an orthogonal system, which is important for applications such as numerical
    integration and the **finite element method** for solving partial differential
    equations. Legendre polynomials are defined using a recursive relation. We define
    them as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy还提供了从`Polynomial`类派生出的各种类，用于表示不同类型的特殊多项式。例如，`Legendre`类表示一种叫做*勒让德多项式*的特定多项式系统。勒让德多项式的定义为满足![](img/Formula_03_056.png)的![](img/Formula_03_057.png)，并形成一个正交系统，这在数值积分和用于求解偏微分方程的**有限元法**等应用中非常重要。勒让德多项式通过递归关系来定义。我们将其定义如下：
- en: '![](img/Formula_03_058.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_03_058.jpg)'
- en: 'Furthermore, for each ![](img/Formula_03_059.png), we define the ![](img/Formula_03_060.png)th
    Legendre polynomial to satisfy the recurrence relation:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，对于每个![](img/Formula_03_059.png)，我们定义第![](img/Formula_03_060.png)个勒让德多项式，使其满足递推关系：
- en: '![](img/Formula_03_061.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_03_061.jpg)'
- en: There are several other so-called *orthogonal (systems of) polynomials*, including
    *Laguerre polynomials*, *Chebyshev polynomials*, and *Hermite polynomials*.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 还有几种所谓的*正交（多项式）系统*，包括*拉盖尔多项式*、*切比雪夫多项式*和*厄尔米特多项式*。
- en: See also
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: Calculus is certainly well documented in mathematical texts, and there are many
    textbooks that cover the basic methods all the way to the deep theory. Orthogonal
    systems of polynomials are also well documented among numerical analysis texts.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 微积分在数学文献中有详细的记录，许多教科书覆盖了从基本方法到深层理论的内容。正交多项式系统也在数值分析的文献中得到了详细的记录。
- en: Differentiating and integrating symbolically using SymPy
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SymPy进行符号微分和积分
- en: At some point, you may have to differentiate a function that is not a simple
    polynomial, and you may need to do this in some kind of automated fashion—for
    example, if you are writing software for education. The Python scientific stack
    includes a package called SymPy, which allows us to create and manipulate symbolic
    mathematical expressions within Python. In particular, SymPy can perform differentiation
    and integration of symbolic functions, just like a mathematician.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 到某个时候，你可能需要对一个非简单多项式的函数进行微分，并且你可能需要以某种自动化的方式来完成这项工作——例如，如果你正在编写教育类软件。Python的科学计算堆栈包含一个名为SymPy的包，它允许我们在Python中创建和操作符号数学表达式。特别是，SymPy能够像数学家一样进行符号函数的微分和积分。
- en: In this recipe, we will create a symbolic function and then differentiate and
    integrate this function using the SymPy library.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将创建一个符号函数，然后使用 SymPy 库对该函数进行微分和积分。
- en: Getting ready
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Unlike some of the other scientific Python packages, there does not seem to
    be a standard alias under which SymPy is imported in the literature. Instead,
    the documentation uses a star import at several points, which is not in line with
    the *PEP8* style guide. This is possibly to make the mathematical expressions
    more natural. We will simply import the module under its name `sympy`, to avoid
    any confusion with the `scipy` package’s standard abbreviation, `sp` (which is
    the natural choice for `sympy` too):'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 与一些其他科学 Python 包不同，文献中似乎没有标准别名用于导入 SymPy。相反，文档在多个地方使用了星号导入，这与*PEP8* 风格指南不符。这可能是为了让数学表达式看起来更自然。我们将简单地使用其名称
    `sympy` 导入该模块，以避免与 `scipy` 包的标准缩写 `sp`（这也是 `sympy` 的自然选择）混淆：
- en: '[PRE25]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In this recipe, we will define a symbolic expression that represents the following
    function:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将定义一个符号表达式，表示以下函数：
- en: '![](img/Formula_03_062.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_03_062.jpg)'
- en: Then, we will see how to symbolically differentiate and integrate this function.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将看到如何对这个函数进行符号微分和积分。
- en: How to do it...
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Differentiating and integrating symbolically (as you would do by hand) is very
    easy using the SymPy package. Follow these steps to see how it is done:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 SymPy 包进行符号微分和积分（就像你手动操作一样）非常简单。按照以下步骤操作，看看如何实现：
- en: 'Once SymPy is imported, we define the symbols that will appear in our expressions.
    This is a Python object that has no particular value, just like a mathematical
    variable, but can be used in formulas and expressions to represent many different
    values simultaneously. For this recipe, we need only define a symbol for ![](img/Formula_03_063.png),
    since we will only require constant (literal) symbols and functions in addition
    to this. We use the `symbols` routine from `sympy` to define a new symbol. To
    keep the notation simple, we will name this new symbol `x`:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦导入 SymPy，我们就定义将在表达式中出现的符号。这是一个 Python 对象，没有特定值，就像数学变量一样，但可以在公式和表达式中同时表示多个不同的值。在这个食谱中，我们只需要定义一个符号用于
    ![](img/Formula_03_063.png)，因为除了这个符号外，我们只需要常量（字面量）符号和函数。我们使用 `sympy` 中的 `symbols`
    函数来定义一个新符号。为了简化符号表示，我们将这个新符号命名为 `x`：
- en: '[PRE26]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The symbols defined using the `symbols` function support all of the arithmetic
    operations, so we can construct the expression directly using the symbol `x` we
    just defined:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `symbols` 函数定义的符号支持所有算术运算，因此我们可以直接使用刚刚定义的符号 `x` 构建表达式：
- en: '[PRE27]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, we can use the symbolic calculus capabilities of SymPy to compute the
    derivative of `f`—that is, differentiate `f`. We do this using the `diff` routine
    in `sympy`, which differentiates a symbolic expression with respect to a specified
    symbol and returns an expression for the derivative. This is often not expressed
    in its simplest form, so we use the `sympy.simplify` routine to simplify the result:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以利用 SymPy 的符号计算能力来计算 `f` 的导数——也就是对 `f` 进行微分。我们使用 `sympy` 中的 `diff` 函数来对符号表达式进行微分，并返回导数的表达式。由于结果通常不是最简形式，我们使用
    `sympy.simplify` 函数来简化结果：
- en: '[PRE28]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We can check whether the result of the symbolic differentiation using SymPy
    is correct, compared to the derivative computed by hand using the product rule,
    defined as a SymPy expression, as follows:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以检查使用 SymPy 进行符号微分的结果是否正确，并与手工使用乘积法则计算的导数进行比较，该导数作为 SymPy 表达式定义，如下所示：
- en: '[PRE30]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'SymPy equality tests whether two expressions are equal, but not whether they
    are symbolically equivalent. Therefore, we must first simplify the difference
    of the two statements we wish to test and test for equality to `0`:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SymPy 的等式测试检查两个表达式是否相等，但不检查它们是否在符号上等价。因此，我们必须首先简化我们希望测试的两个语句的差异，并测试是否等于 `0`：
- en: '[PRE32]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We can integrate the derivative `fp` using SymPy by using the `integrate` function
    and check that this is again equal to `f`. It is a good idea to also provide the
    symbol with which the integration is to be performed by providing it as the second
    optional argument:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用 SymPy 的 `integrate` 函数对导数 `fp` 进行积分，并检查结果是否仍然等于 `f`。最好还通过提供第二个可选参数来指定进行积分的符号：
- en: '[PRE33]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As we can see, the result of integrating the derivative `fp` gives back the
    original function `f` (although we are technically missing the constant of integration
    ![](img/Formula_03_064.png)).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，积分导数 `fp` 的结果将返回原始函数 `f`（尽管我们在技术上缺少了积分常数 ![](img/Formula_03_064.png)）。
- en: How it works...
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: SymPy defines various classes to represent certain kinds of expressions. For
    example, symbols, represented by the `Symbol` class, are examples of *atomic expressions*.
    Expressions are built up in a similar way to how Python builds an abstract syntax
    tree from source code. These expression objects can then be manipulated using
    methods and standard arithmetic operations.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: SymPy 定义了各种类来表示某些类型的表达式。例如，由 `Symbol` 类表示的符号是 *原子表达式* 的例子。表达式的构建方式与 Python 从源代码构建抽象语法树类似。这些表达式对象可以使用方法和标准算术操作进行操作。
- en: SymPy also defines standard mathematical functions that can operate on `Symbol`
    objects to create symbolic expressions. The most important feature is the ability
    to perform symbolic calculus—rather than the numerical calculus that we explore
    in the remainder of this chapter—and give exact (sometimes called *analytic*)
    solutions to calculus problems.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: SymPy 还定义了标准数学函数，这些函数可以作用于 `Symbol` 对象，以创建符号表达式。最重要的功能是能够执行符号微积分——与我们在本章剩余部分探索的数值微积分不同——并给出微积分问题的精确（有时称为
    *解析*）解。
- en: The `diff` routine from the SymPy package performs differentiation on these
    symbolic expressions. The result of this routine is usually not in its simplest
    form, which is why we used the `simplify` routine to simplify the derivative in
    the recipe. The `integrate` routine symbolically integrates a `scipy` expression
    with respect to a given symbol. (The `diff` routine also accepts a symbol argument
    that specifies the symbol for differentiating against.) This returns an expression
    whose derivative is the original expression. This routine does not add a constant
    of integration, which is good practice when doing integrals by hand.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: SymPy 包中的 `diff` 例程对这些符号表达式进行微分。该例程的结果通常不是其最简形式，这就是为什么我们在食谱中使用 `simplify` 例程来简化导数的原因。`integrate`
    例程对给定符号进行符号积分（与 `scipy` 表达式相关）。(`diff` 例程也接受一个符号参数，用来指定微分所依赖的符号。) 该例程返回一个其导数为原始表达式的表达式。该例程不会添加积分常数，这在手动积分时是一种良好的实践。
- en: There’s more...
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: SymPy can do much more than simple algebra and calculus. There are submodules
    for various areas of mathematics, such as number theory, geometry, and other discrete
    mathematics (such as combinatorics).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: SymPy 能做的远不止简单的代数和微积分。它有许多子模块，涵盖数学的各个领域，例如数论、几何学和其他离散数学（如组合数学）。
- en: 'SymPy expressions (and functions) can be built into Python functions that can
    be applied to NumPy arrays. This is done using the `lambdify` routine from the
    `sympy.utilities` module. This converts a SymPy expression to a numerical expression
    that uses the NumPy equivalents of the SymPy standard functions to evaluate the
    expressions numerically. The result is similar to defining a Python Lambda, hence
    the name. For example, we could convert the function and derivative from this
    recipe into Python functions using this routine:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: SymPy 表达式（和函数）可以构建成 Python 函数，这些函数可以应用于 NumPy 数组。这是通过 `sympy.utilities` 模块中的
    `lambdify` 例程完成的。该例程将 SymPy 表达式转换为数值表达式，使用 SymPy 标准函数的 NumPy 等效函数来数值求解表达式。结果类似于定义一个
    Python Lambda，因此得名。例如，我们可以使用该例程将这个食谱中的函数和导数转换为 Python 函数：
- en: '[PRE35]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The `lambdify` routine takes two arguments. The first is the variables to be
    provided, `x` in the previous code block, and the second is the expression to
    be evaluated when this function is called. For example, we can evaluate the lambdified
    SymPy expressions defined previously as if they were ordinary Python functions:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`lambdify` 例程接受两个参数。第一个是需要提供的变量，在前面的代码块中为 `x`，第二个是当调用此函数时要评估的表达式。例如，我们可以像普通
    Python 函数一样评估之前定义的 lambdified SymPy 表达式：'
- en: '[PRE36]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We can even evaluate these lambdified expressions on NumPy arrays (as usual,
    with NumPy imported as `np`):'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以在 NumPy 数组上评估这些 lambdified 表达式（和往常一样，先导入 NumPy，通常命名为 `np`）：
- en: '[PRE37]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Note
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `lambdify` routine uses the Python `exec` routine to execute the code, so
    it should not be used with unsanitized input.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`lambdify` 例程使用 Python 的 `exec` 例程来执行代码，因此不应与未经清理的输入一起使用。'
- en: Solving equations
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解方程
- en: Many mathematical problems eventually reduce to solving an equation of the form
    ![](img/Formula_03_065.png), where ![](img/Formula_03_066.png) is a function of
    a single variable. Here, we try to find a value of ![](img/Formula_03_067.png)
    for which the equation holds. The values of ![](img/Formula_03_068.png) for which
    the equation holds are sometimes called *roots* of the equation. There are numerous
    algorithms for finding solutions to equations of this form. In this recipe, we
    will use the Newton-Raphson and secant methods to solve an equation of the form
    ![](img/Formula_03_069.png).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 许多数学问题最终归结为求解形式为 ![](img/Formula_03_065.png) 的方程，其中 ![](img/Formula_03_066.png)
    是单变量的函数。在这里，我们试图找到一个 ![](img/Formula_03_067.png) 的值，使得方程成立。使方程成立的 ![](img/Formula_03_068.png)
    的值有时称为方程的 *根*。对于这种形式的方程，有许多算法可以找到其解。在这个食谱中，我们将使用牛顿-拉弗森方法和割线法来求解形式为 ![](img/Formula_03_069.png)
    的方程。
- en: The Newton-Raphson method (Newton’s method) and the secant method are good,
    standard root-finding algorithms that can be applied in almost any situation.
    These are *iterative methods* that start with an approximation of the root and
    iteratively improve this approximation until it lies within a given tolerance.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 牛顿-拉弗森方法（牛顿法）和割线法是非常好的标准求根算法，可以在几乎任何情况下应用。这些是 *迭代方法*，从根的近似值开始，逐步改进这个近似值，直到它位于给定的容差范围内。
- en: 'To demonstrate these techniques, we will use the function from the *Differentiating
    and integrating symbolically using SymPy* recipe, defined by the following formula:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这些技术，我们将使用来自 *使用SymPy进行符号微分和积分* 这一食谱中的函数，定义如下公式：
- en: '![](img/Formula_03_070.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_03_070.jpg)'
- en: This is defined for all real values of ![](img/Formula_03_071.png) and has exactly
    two roots, one at ![](img/Formula_03_072.png) and one at ![](img/Formula_03_073.png).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数在所有实数值的 ![](img/Formula_03_071.png) 上都有定义，并且恰好有两个根，一个在 ![](img/Formula_03_072.png)
    处，另一个在 ![](img/Formula_03_073.png) 处。
- en: Getting ready
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The SciPy package contains routines for solving equations (among many other
    things). The root-finding routines can be found in the `optimize` module from
    the `scipy` package. As usual, we import NumPy as `np`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: SciPy 包含用于求解方程的例程（以及许多其他功能）。求根的例程可以在 `scipy` 包中的 `optimize` 模块找到。像往常一样，我们将 NumPy
    导入为 `np`。
- en: How to do it...
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做……
- en: 'The `optimize` package provides routines for numerical root finding. The following
    instructions describe how to use the `newton` routine from this module:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`optimize` 包提供了用于数值求解根的例程。以下说明描述了如何使用该模块中的 `newton` 例程：'
- en: 'The `optimize` module is not listed in the `scipy` namespace, so you must import
    it separately:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`optimize` 模块没有列在 `scipy` 命名空间中，因此必须单独导入：'
- en: '[PRE38]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Then, we must define this function and its derivative in Python:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们必须在 Python 中定义这个函数及其导数：
- en: '[PRE39]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The derivative of this function was computed in the previous recipe:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该函数的导数已在之前的食谱中计算过：
- en: '[PRE42]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'For both the Newton-Raphson and secant methods, we use the `newton` routine
    from `optimize`. Both the secant method and the Newton-Raphson method require
    the function as the first argument and the first approximation, `x0`, as the second
    argument. To use the Newton-Raphson method, we must provide the derivative of
    ![](img/Formula_03_074.png), using the `fprime` keyword argument:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于牛顿-拉弗森方法和割线法，我们都使用 `optimize` 中的 `newton` 例程。无论是割线法还是牛顿-拉弗森方法，都需要将函数作为第一个参数，将第一个近似值
    `x0` 作为第二个参数。使用牛顿-拉弗森方法时，我们必须提供 ![](img/Formula_03_074.png) 的导数，并使用 `fprime` 关键字参数：
- en: '[PRE44]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'To use the secant method, only the function is needed, but we must provide
    the first two approximations for the root; the second is provided as the `x1`
    keyword argument:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用割线法，只需要函数，但必须提供根的前两个近似值；第二个近似值通过 `x1` 关键字参数提供：
- en: '[PRE46]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Note
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Neither the Newton-Raphson nor the secant method is guaranteed to converge to
    a root. It is perfectly possible that the iterates of the method will simply cycle
    through a number of points (periodicity) or fluctuate wildly (chaos).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 牛顿-拉弗森方法和割线法都不能保证一定会收敛到一个根。方法的迭代过程有可能会在若干点之间循环（周期性）或剧烈波动（混沌）。
- en: How it works...
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: 'The Newton-Raphson method for a function ![](img/Formula_03_075.png) with derivative
    ![](img/Formula_03_076.png) and initial approximation ![](img/Formula_03_077.png)
    is defined iteratively using this formula:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个函数 ![](img/Formula_03_075.png)，其导数为 ![](img/Formula_03_076.png)，初始近似值为 ![](img/Formula_03_077.png)，牛顿-拉弗森方法通过以下公式进行迭代定义：
- en: '![](img/Formula_03_078.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_03_078.jpg)'
- en: For each integer, ![](img/Formula_03_079.png). Geometrically, this formula arises
    by considering the direction in which the gradient is negative (so, the function
    is decreasing) if ![](img/Formula_03_080.png) or positive (so, the function is
    increasing) if ![](img/Formula_03_081.png).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个整数，![](img/Formula_03_079.png)。从几何角度来看，这个公式通过考虑梯度为负（因此，函数在减小）时的方向（如果![](img/Formula_03_080.png)），或者梯度为正（因此，函数在增加）时的方向（如果![](img/Formula_03_081.png)）来得到。
- en: 'The secant method is based on the Newton-Raphson method, but replaces the first
    derivative with the following approximation:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 割线法基于牛顿-拉夫森方法，但将第一导数替换为以下近似值：
- en: '![](img/Formula_03_082.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_03_082.jpg)'
- en: 'When ![](img/Formula_03_083.png) is sufficiently small, which occurs if the
    method is converging, then this is a good approximation. The price paid for not
    requiring the derivative of the function ![](img/Formula_03_084.png) is that we
    require an additional initial guess to start the method. The formula for the method
    is given as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当![](img/Formula_03_083.png)足够小（这会在方法收敛时发生），那么这是一个很好的近似值。不需要函数![](img/Formula_03_084.png)的导数所付出的代价是我们需要额外的初始猜测来启动该方法。该方法的公式如下：
- en: '![](img/Formula_03_085.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_03_085.jpg)'
- en: Generally speaking, if either method is given an initial guess (guesses for
    the secant method) that is sufficiently close to a root, then the method will
    converge to that root. The Newton-Raphson method can also fail if the derivative
    is zero at one of the iterations, in which case the formula is not well defined.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，如果给定任一方法一个足够接近根的初始猜测（割线法的猜测），则该方法将收敛到该根。牛顿-拉夫森方法也可能失败，如果在某次迭代中导数为零，此时公式将无法定义。
- en: There’s more...
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The methods mentioned in this recipe are general-purpose methods, but there
    are others that may be faster or more accurate in some circumstances. Broadly
    speaking, root-finding algorithms fall into two categories: algorithms that use
    information about the function’s gradient at each iterate (Newton-Raphson, secant,
    Halley) and algorithms that require bounds on the location of a root (bisection
    method, Regula-Falsi, Brent). The algorithms discussed so far are of the first
    kind, and while generally quite fast, they may fail to converge.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱中提到的方法是通用方法，但在某些情况下，可能有其他方法更快或更准确。广义上讲，根求解算法可以分为两类：使用每次迭代时函数梯度信息的算法（如牛顿-拉夫森、割线法、哈雷法），以及需要知道根的区间范围的算法（如二分法、正则法、布伦特法）。到目前为止讨论的算法属于第一类，虽然通常非常快速，但它们可能会失败并无法收敛。
- en: 'The second kind of algorithm is those for which a root is known to exist within
    a specified interval ![](img/Formula_03_086.png). We can check whether a root
    lies within such an interval by checking that ![](img/Formula_03_087.png) and
    ![](img/Formula_03_088.png) have different signs—that is, one of ![](img/Formula_03_089.png)
    or ![](img/Formula_03_090.png) is true (provided, of course, that the function
    is *continuous*, which tends to be the case in practice). The most basic algorithm
    of this kind is the bisection algorithm, which repeatedly bisects the interval
    until a sufficiently good approximation to the root is found. The basic premise
    is to split the interval between ![](img/Formula_03_091.png) and ![](img/Formula_03_092.png)
    at the mid-point and select the interval in which the function changes sign. The
    algorithm repeats until the interval is very small. The following is a rudimentary
    implementation of this algorithm in Python:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 第二类算法是那些已知根存在于指定区间![](img/Formula_03_086.png)内的算法。我们可以通过检查![](img/Formula_03_087.png)和![](img/Formula_03_088.png)的符号是否不同来判断根是否位于该区间内——也就是说，![](img/Formula_03_089.png)或![](img/Formula_03_090.png)中的一个条件成立（当然，前提是函数是*连续的*，这在实际中通常是成立的）。这类算法中最基础的就是二分法，它通过反复二分区间直到找到足够精确的根的近似值。基本原理是将区间![](img/Formula_03_091.png)和![](img/Formula_03_092.png)的中点分割，并选择函数符号变化的区间。该算法重复进行，直到区间非常小。以下是该算法的一个简单Python实现：
- en: '[PRE48]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This method is guaranteed to converge since, at each step, the distance ![](img/Formula_03_093.png)
    is halved. However, it is possible that the method will require more iterations
    than Newton-Raphson or the secant method. A version of the bisection method can
    also be found in `optimize`. This version is implemented in C and is considerably
    more efficient than the version presented here, but the bisection method is not
    the fastest method in most cases.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法保证收敛，因为在每一步，距离 ![](img/Formula_03_093.png) 都会减半。然而，该方法可能需要比牛顿-拉弗森方法或割线法更多的迭代次数。`optimize`
    模块中也有一个版本的二分法，该版本用 C 实现，比这里介绍的版本效率要高得多，但在大多数情况下，二分法并不是最快的方法。
- en: 'Brent’s method is an improvement on the bisection method and is available in
    the `optimize` module as `brentq`. It uses a combination of bisection and interpolation
    to quickly find the root of an equation:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 布伦特法是对二分法的改进，并且在 `optimize` 模块中作为 `brentq` 提供。它结合了二分法和插值法，能够快速找到方程的根：
- en: '[PRE49]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: It is important to note that the techniques that involve bracketing (bisection,
    regula-falsi, Brent) cannot be used to find the root functions of a complex variable,
    whereas those techniques that do not use bracketing (Newton, secant, Halley) can.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，涉及括值法（如二分法、正割法、布伦特法）的技术不能用于求解复数变量的根函数，而不使用括值法的技术（如牛顿法、割线法、哈雷法）可以。
- en: Finally, some equations are not quite of the form ![](img/Formula_03_094.png)
    but can still be solved using these techniques. This is done by rearranging the
    equation so that it is of the required form (renaming functions if necessary).
    This is usually not too difficult and simply requires moving any terms on the
    right-hand side over to the left-hand side. For example, if you wish to find the
    fixed points of a function—that is, when ![](img/Formula_03_095.png)—then we would
    apply the method to the related function given by ![](img/Formula_03_096.png).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，有些方程的形式可能并非 ![](img/Formula_03_094.png)，但仍然可以使用这些技术进行求解。通过重新排列方程，使其符合所需的形式（如果必要，重新命名函数）来实现。这通常不太困难，只需要将右侧的任何项移到左侧。例如，如果你希望找到一个函数的固定点——也就是说，当
    ![](img/Formula_03_095.png) 时——我们就可以应用该方法到相关函数 ![](img/Formula_03_096.png) 上。
- en: Integrating functions numerically using SciPy
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 SciPy 进行数值积分
- en: 'Integration can be interpreted as the area that lies between a curve and the
    ![](img/Formula_03_097.png) axis, signed according to whether this area is above
    or below the axis. Some integrals cannot be computed directly using symbolic means,
    and instead, have to be approximated numerically. One classic example of this
    is the Gaussian error function, which was mentioned in the *Understanding basic
    mathematical functions* section in [*Chapter 1*](B19085_01.xhtml#_idTextAnchor014),
    *An Introduction to Basic Packages, Functions, and Concepts*. This is defined
    by the following formula:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 积分可以被解释为曲线与 ![](img/Formula_03_097.png) 轴之间的面积，面积的符号取决于该面积是在轴的上方还是下方。有些积分无法直接通过符号方式计算，而必须通过数值方法近似计算。一个经典的例子是高斯误差函数，它在《理解基本数学函数》一节中提到过，详见
    [*第1章*](B19085_01.xhtml#_idTextAnchor014)，*基本包、函数和概念简介*。该函数通过以下公式定义：
- en: '![](img/Formula_03_098.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_03_098.jpg)'
- en: Furthermore, the integral that appears here cannot be evaluated symbolically.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这里出现的积分无法通过符号方式计算。
- en: In this recipe, we will see how to use numerical integration routines in the
    SciPy package to compute the integral of a function.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将演示如何使用 SciPy 包中的数值积分例程来计算一个函数的积分。
- en: Getting ready
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We use the `scipy.integrate` module, which contains several routines for computing
    numerical integrals. We also import the NumPy library as `np`. We import this
    module as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `scipy.integrate` 模块，其中包含了几个用于计算数值积分的例程。我们还将 NumPy 库作为 `np` 导入。我们可以通过以下方式导入该模块：
- en: '[PRE50]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: How to do it...
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'The following steps describe how to numerically integrate a function using
    SciPy:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤描述了如何使用 SciPy 进行数值积分：
- en: 'We evaluate the integral that appears in the definition of the error function
    at the value ![](img/Formula_03_099.png). For this, we need to define the integrand
    (the function that appears inside the integral) in Python:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们计算在误差函数定义中出现的积分，计算的值为 ![](img/Formula_03_099.png)。为此，我们需要在 Python 中定义被积函数（出现在积分符号内部的函数）：
- en: '[PRE51]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: There are two main routines in `scipy.integrate` for performing numerical integration
    (quadrature) that can be used. The first is the `quad` function, which uses QUADPACK
    to perform the integration, and the second is `quadrature`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`scipy.integrate`中有两种主要的例程可以用于执行数值积分（求积），分别是`quad`函数和`quadrature`。第一个是使用QUADPACK执行积分的`quad`函数，第二个是`quadrature`。'
- en: 'The `quad` routine is a general-purpose integration tool. It expects three
    arguments, which are the function to be integrated (`erf_integrand`), the lower
    limit (`-1.0`), and the upper limit (`1.0`):'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`quad`例程是一个通用的积分工具。它需要三个参数：要积分的函数（`erf_integrand`），下限（`-1.0`）和上限（`1.0`）：'
- en: '[PRE53]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The first returned value is the value of the integral, and the second is an
    estimate of the error.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个返回值是积分的值，第二个返回值是误差的估计。
- en: 'Repeating the computation with the `quadrature` routine, we get the following.
    The arguments are the same as for the `quad` routine:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`quadrature`例程重复计算，我们得到如下结果。其参数与`quad`例程相同：
- en: '[PRE55]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The output is the same format as the code, with the value of the integral and
    then an estimate of the error. Notice that the error is larger for the `quadrature`
    routine. This is a result of the method terminating once the estimated error falls
    below a given tolerance, which can be modified when the routine is called.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 输出格式与代码相同，首先是积分值，然后是误差估计。请注意，`quadrature`例程的误差较大。这是由于该方法在估算误差小于给定容忍度时终止，而该容忍度可以在调用例程时进行修改。
- en: How it works...
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: 'Most numerical integration techniques follow the same basic procedure. First,
    we choose points ![](img/Formula_03_100.png) for ![](img/Formula_03_101.png) in
    the region of integration, and then use these values and the values ![](img/Formula_03_102.png)
    to approximate the integral. For example, with the trapezium rule, we approximate
    the integral with the following formula:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数数值积分技术遵循相同的基本过程。首先，我们选择积分区域内的点![](img/Formula_03_100.png) 和![](img/Formula_03_101.png)，然后使用这些值和![](img/Formula_03_102.png)来近似积分。例如，使用梯形法则时，我们使用以下公式来近似积分：
- en: '![](img/Formula_03_103.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_03_103.jpg)'
- en: 'Here, ![](img/Formula_03_104.png) and ![](img/Formula_03_105.png) is the (common)
    difference between adjacent ![](img/Formula_03_106.png) values, including the
    endpoints ![](img/Formula_03_107.png) and ![](img/Formula_03_108.png). This can
    be implemented in Python as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，![](img/Formula_03_104.png) 和 ![](img/Formula_03_105.png) 是相邻的![](img/Formula_03_106.png)值之间的（常见）差异，包括端点![](img/Formula_03_107.png)和![](img/Formula_03_108.png)。这可以在Python中实现如下：
- en: '[PRE59]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The algorithms used by `quad` and `quadrature` are far more sophisticated than
    this. Using this function to approximate the integral of `erf_integrand` using
    `trapezium` with 500 steps yields a result of 1.4936463036001209, which agrees
    with the approximations from the `quad` and `quadrature` routines to five decimal
    places.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`quad`和`quadrature`使用的算法比这要复杂得多。使用此函数通过`trapezium`法则和500步来近似积分`erf_integrand`，得到的结果为1.4936463036001209，与`quad`和`quadrature`例程的五位小数近似值一致。'
- en: The `quadrature` routine uses a fixed tolerance Gaussian quadrature, whereas
    the `quad` routine uses an adaptive algorithm implemented in the Fortran library
    QUADPACK routines. Timing both routines, we find that the `quad` routine is approximately
    five times faster than the `quadrature` routine for the problem described in the
    recipe. The `quad` routine executes in approximately 27 µs, averaging over 1 million
    executions, while the `quadrature` routine executes in approximately 134 µs. (Your
    results may differ depending on your system.) Generally speaking, you should use
    the quad method since it is both faster and more accurate unless you need the
    Gaussian quadrature implemented by `quadrature`.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`quadrature`例程使用固定容忍度的高斯求积，而`quad`例程则使用在Fortran库QUADPACK中实现的自适应算法。对两个例程进行计时，我们发现`quad`例程比`quadrature`例程快大约五倍，尤其是在本食谱中描述的问题上。`quad`例程的执行时间约为27微秒，经过100万次执行的平均值，而`quadrature`例程的执行时间约为134微秒。（您的结果可能会因系统而异。）一般来说，除非您需要`quadrature`实现的高斯求积，否则应使用`quad`方法，因为它既更快又更准确。'
- en: There’s more...
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多……
- en: The routines mentioned in this section require the integrand function to be
    known, which is not always the case. Instead, it might be the case that we know
    a number of pairs ![](img/Formula_03_109.png) with ![](img/Formula_03_110.png),
    but we don’t know the function ![](img/Formula_03_111.png) to evaluate at additional
    points. In this case, we can use one of the sampling quadrature techniques from
    `scipy.integrate`. If the number of known points is very large and all points
    are equally spaced, we can use Romberg integration for a good approximation of
    the integral. For this, we use the `romb` routine. Otherwise, we can use a variant
    of the trapezium rule (as shown previously) using the `trapz` routine, or Simpson’s
    rule using the `simps` routine.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 本节提到的例程要求已知被积函数，这并不总是成立。相反，我们可能已知一些数对 ![](img/Formula_03_109.png) 和 ![](img/Formula_03_110.png)，但我们并不知道函数
    ![](img/Formula_03_111.png)，也无法在额外的点上进行评估。在这种情况下，我们可以使用 `scipy.integrate` 中的某种采样求积技术。如果已知点的数量非常大且所有点间距相等，我们可以使用
    Romberg 积分法进行良好的积分近似。为此，我们使用 `romb` 例程。否则，我们可以使用梯形规则的变体（如前所示），利用 `trapz` 例程，或者使用辛普森法则，通过
    `simps` 例程进行计算。
- en: Solving simple differential equations numerically
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数值求解简单微分方程
- en: 'Differential equations arise in situations where a quantity evolves, usually
    over time, according to a given relationship. They are extremely common in engineering
    and physics, and appear quite naturally. One of the classic examples of a (very
    simple) differential equation is the law of cooling devised by Newton. The temperature
    of a body cools at a rate proportional to the current temperature. Mathematically,
    this means that we can write the derivative of the temperature ![](img/Formula_03_112.png)
    of the body at time ![](img/Formula_03_113.png) using the following differential
    equation:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 微分方程出现在某些量随着时间或其他因素变化的情形中，通常根据给定的关系式进行演化。它们在工程学和物理学中极为常见，且自然地出现。微分方程的一个经典（非常简单）的例子是牛顿提出的冷却定律。一个物体的温度以与当前温度成正比的速率降低。从数学角度看，这意味着我们可以使用以下微分方程来表示在时间
    ![](img/Formula_03_113.png) 时刻物体的温度 ![](img/Formula_03_112.png) 的导数：
- en: '![](img/Formula_03_114.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_03_114.jpg)'
- en: 'Here, ![](img/Formula_03_115.png) is a positive constant that determines the
    rate of cooling. This differential equation can be solved *analytically* by first
    *separating the variables* and then integrating and rearranging them. After performing
    this procedure, we obtain the general solution:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，![](img/Formula_03_115.png) 是一个正的常数，用于确定冷却速率。这个微分方程可以通过先*分离变量*，然后进行积分和重排来*解析*求解。经过这一过程，我们可以得到一般解：
- en: '![](img/Formula_03_116.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_03_116.jpg)'
- en: Here, ![](img/Formula_03_117.png) is the initial temperature.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，![](img/Formula_03_117.png) 是初始温度。
- en: In this recipe, we will solve a simple ODE numerically using the `solve_ivp`
    routine from SciPy.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，我们将使用 SciPy 的 `solve_ivp` 例程数值求解一个简单的常微分方程（ODE）。
- en: Getting ready
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will demonstrate the technique for solving a differential equation numerically
    in Python using the cooling equation described previously since we can compute
    the true solution in this case. We take the initial temperature to be ![](img/Formula_03_118.png)
    and ![](img/Formula_03_119.png). Let’s also find the solution for ![](img/Formula_03_120.png)
    values between ![](img/Formula_03_121.png) and ![](img/Formula_03_122.png).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将演示如何在 Python 中使用先前描述的冷却方程来数值求解一个微分方程，因为在这种情况下我们可以计算真实解。我们将初始温度设为 ![](img/Formula_03_118.png)
    和 ![](img/Formula_03_119.png)。同时，我们还要找到 ![](img/Formula_03_120.png) 在 ![](img/Formula_03_121.png)
    和 ![](img/Formula_03_122.png) 之间的解。
- en: 'For this recipe, we will need the NumPy library imported as `np`, the Matplotlib
    `pyplot` interface imported as `plt`, and the `integrate` module imported from
    SciPy:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们需要导入 NumPy 库，命名为 `np`，导入 Matplotlib 的 `pyplot` 接口，命名为 `plt`，以及从 SciPy
    导入 `integrate` 模块：
- en: '[PRE60]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'A general (first-order) differential equation has the following form:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 一般的（一级）微分方程具有以下形式：
- en: '![](img/Formula_03_123.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_03_123.jpg)'
- en: 'Here, ![](img/Formula_03_124.png) is some function of ![](img/Formula_03_125.png)
    (the independent variable) and ![](img/Formula_03_126.png) (the dependent variable).
    In this formula, ![](img/Formula_03_127.png) is the dependent variable and ![](img/Formula_03_128.png).
    The routines for solving differential equations in the SciPy package require the
    function ![](img/Formula_03_129.png) and an initial value ![](img/Formula_03_130.png)and
    the range of ![](img/Formula_03_131.png) values where we need to compute the solution.
    To get started, we need to define our function ![](img/Formula_03_132.png) in
    Python and create a variables ![](img/Formula_03_133.png) and ![](img/Formula_03_134.png)
    range ready to be supplied to the SciPy routine:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，![](img/Formula_03_124.png) 是 ![](img/Formula_03_125.png)（自变量）和 ![](img/Formula_03_126.png)（因变量）的一些函数。在此公式中，![](img/Formula_03_127.png)
    是因变量，![](img/Formula_03_128.png)。SciPy 包中求解微分方程的例程需要函数 ![](img/Formula_03_129.png)
    以及初始值 ![](img/Formula_03_130.png) 和我们需要计算解的 ![](img/Formula_03_131.png) 值的范围。为了开始，我们需要在
    Python 中定义我们的函数 ![](img/Formula_03_132.png) 并创建变量 ![](img/Formula_03_133.png)
    和 ![](img/Formula_03_134.png) 的范围，以便提供给 SciPy 例程：
- en: '[PRE61]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Next, we need to define the initial condition from which the solution should
    be found. For technical reasons, the initial ![](img/Formula_03_136.png) values
    must be specified as a one-dimensional NumPy array:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要定义求解该初值问题所需的初始条件。由于技术原因，初始 ![](img/Formula_03_136.png) 值必须指定为一维 NumPy
    数组：
- en: '[PRE62]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Since, in this case, we already know the true solution, we can also define
    this in Python ready to compare to the numerical solution that we will compute:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在这种情况下，我们已经知道真实解，因此我们也可以在 Python 中定义该解，以便与我们将计算的数值解进行比较：
- en: '[PRE63]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Let’s see how to solve this initial value problem using SciPy.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用 SciPy 求解这个初值问题。
- en: How to do it...
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Follow these steps to solve a differential equation numerically and plot the
    solution along with the error:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤，数值求解微分方程并绘制解和误差：
- en: 'We use the `solve_ivp` routine from the `integrate` module in SciPy to solve
    the differential equation numerically. We add a parameter for the maximum step
    size, with a value of `0.1`, so that the solution is computed at a reasonable
    number of points:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用 SciPy 中 `integrate` 模块的 `solve_ivp` 例程来数值求解微分方程。我们添加一个最大步长参数，值为 `0.1`，以确保解在合理数量的点处计算：
- en: '[PRE64]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Next, we extract the solution values from the `sol` object returned from the
    `solve_ivp` method:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们从 `solve_ivp` 方法返回的 `sol` 对象中提取解的值：
- en: '[PRE65]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Next, we plot the solution on a set of axes, as follows. Since we are also
    going to plot the approximation error on the same figure, we create two subplots
    using the `subplots` routine:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们在一组坐标轴上绘制解，如下所示。由于我们还将绘制同一图形中的近似误差，因此我们使用 `subplots` 例程创建两个子图：
- en: '[PRE67]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: This plots the solution on a set of axes displayed on the left-hand side of
    *Figure 3**.1*.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把解绘制在 *图 3**.1* 左侧的一组坐标轴上。
- en: 'To do this, we need to compute the true solution at the points that we obtained
    from the `solve_ivp` routine, and then calculate the absolute value of the difference
    between the true and approximated solutions:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们需要计算从 `solve_ivp` 例程中获得的点处的真实解，然后计算真实解与近似解之间差异的绝对值：
- en: '[PRE72]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Finally, on the right-hand side of *Figure 3**.1*, we plot the error in the
    approximation with a logarithmic scale on the ![](img/Formula_03_137.png) axis.
    We can then plot this on the right-hand side with a logarithmic scale ![](img/Formula_03_1371.png)
    axis using the `semilogy` plot command, as we saw in [*Chapter 2*](B19085_02.xhtml#_idTextAnchor036),
    *Mathematical Plotting* *with Matplotlib*:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在 *图 3**.1* 右侧，我们使用对数坐标轴绘制近似误差，轴上显示的是 ![](img/Formula_03_137.png) 的对数比例。然后，我们可以使用
    `semilogy` 绘图命令，按照在 [*第 2 章*](B19085_02.xhtml#_idTextAnchor036) 中展示的 *Matplotlib*
    数学绘图方法，将其绘制在右侧的对数坐标轴上 ![](img/Formula_03_1371.png)：
- en: '[PRE73]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The left-hand plot in *Figure 3**.1* shows decreasing temperature over time,
    while the right-hand plot shows that the error increases as we move away from
    the known value given by the initial condition:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3**.1* 左侧的图展示了温度随时间下降的情况，而右侧的图显示了误差随着我们远离初始条件给定的已知值而增加：'
- en: '![Figure 3.1 – Plot of the numerical solution to the cooling equation'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.1 – 冷却方程数值解的绘图'
- en: '](img/3.1.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/3.1.jpg)'
- en: Figure 3.1 – Plot of the numerical solution to the cooling equation
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1 – 冷却方程数值解的绘图
- en: Notice that the right-hand side plot is on a logarithmic scale and, while the
    rate of increase looks fairly dramatic, the values involved are very small (of
    order ![](img/Formula_03_138.png)).
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，右侧的图是对数坐标系，尽管增长速率看起来相当显著，但涉及的数值非常小（大约是 ![](img/Formula_03_138.png)）。
- en: How it works...
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Most methods for solving differential equations are *time-stepping* methods.
    The pairs ![](img/Formula_03_139.png) are generated by taking small ![](img/Formula_03_140.png)
    steps and approximating the value of the function ![](img/Formula_03_141.png).
    This is perhaps best illustrated by Euler’s method, which is the most basic time-stepping
    method. Fixing a small step size ![](img/Formula_03_142.png), we form the approximation
    at the ![](img/Formula_03_143.png)th step using the following formula:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数解微分方程的方法都是*时间步进*方法。通过小的 ![](img/Formula_03_140.png) 步长生成的数对 ![](img/Formula_03_139.png)，并近似求得函数
    ![](img/Formula_03_141.png) 的值。欧拉法作为最基本的时间步进方法，也许能最清晰地说明这一点。固定一个小的步长 ![](img/Formula_03_142.png)，我们使用以下公式在
    ![](img/Formula_03_143.png) 步生成近似值：
- en: '![](img/Formula_03_144.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_03_144.jpg)'
- en: We start from the known initial value ![](img/Formula_03_145.png). We can easily
    write a Python routine that performs Euler’s method as follows (there are, of
    course, many different ways to implement Euler’s method; this is a very simple
    example).
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从已知的初始值开始 ![](img/Formula_03_145.png)。我们可以很容易地编写一个执行欧拉法的 Python 程序，代码如下（当然，欧拉法有很多不同的实现方式；这是一个非常简单的例子）。
- en: 'First, we set up the method by creating lists that will store the ![](img/Formula_03_146.png)
    values and ![](img/Formula_03_150.png) values that we will return:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们通过创建将存储 ![](img/Formula_03_146.png) 和 ![](img/Formula_03_150.png) 值的列表来设置该方法：
- en: '[PRE77]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Euler’s method continues until we hit the end of the ![](img/Formula_03_146.png)
    range. Here, we use a `while` loop to accomplish this. The body of the loop is
    very simple; we first increment a counter `i`, and then append the new ![](img/Formula_03_146.png)
    and ![](img/Formula_03_150.png) values to their respective lists:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 欧拉法会持续进行，直到我们到达 ![](img/Formula_03_146.png) 范围的终点。在这里，我们使用 `while` 循环来完成这一过程。循环体非常简单；我们首先递增一个计数器
    `i`，然后将新的 ![](img/Formula_03_146.png) 和 ![](img/Formula_03_150.png) 值添加到各自的列表中：
- en: '[PRE78]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The method used by the `solve_ivp` routine, by default, is the **Runge-Kutta-Fehlberg**
    (**RKF45**) method, which has the ability to adapt the step size to ensure that
    the error in the approximation stays within a given tolerance. This routine expects
    three positional arguments: the function ![](img/Formula_03_151.png), the ![](img/Formula_03_152.png)
    range on which the solution should be found, and the initial ![](img/Formula_03_153.png)
    value (![](img/Formula_03_154.png) in our example). Optional arguments can be
    provided to change the solver, the number of points to compute, and several other
    settings.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`solve_ivp` 例程默认使用 **Runge-Kutta-Fehlberg** (**RKF45**) 方法，该方法能够自适应调整步长，确保近似值的误差保持在给定的容忍度范围内。此例程需要三个位置参数：函数
    ![](img/Formula_03_151.png)，求解所需的 ![](img/Formula_03_152.png) 范围，以及初始的 ![](img/Formula_03_153.png)
    值（在我们的示例中是 ![](img/Formula_03_154.png)）。可以提供可选的参数来更改求解器、计算点的数量以及其他设置。'
- en: 'The function passed to the `solve_ivp` routine must have two arguments, as
    in the general differential equation described in the *Getting ready* section.
    The function can have additional arguments, which can be provided using the `args`
    keyword for the `solve_ivp` routine, but these must be positioned after the two
    necessary arguments. Comparing the `euler` routine we defined earlier to the `solve_ivp`
    routine, both with a (maximum) step size of 0.1, we find that the maximum true
    error between the `solve_ivp` solution is in the order of 10-11, whereas the `euler`
    solution only manages an error of 0.19\. The `euler` routine is working, but the
    step size is much too large to overcome the accumulating error. For comparison,
    *Figure 3**.2* is a plot of the solution and error as produced by Euler’s method.
    Compare *Figure 3**.2* to *Figure 3**.1*. Note the scale on the error plot is
    dramatically different:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给 `solve_ivp` 函数的函数必须有两个参数，如*准备工作*部分所描述的常规微分方程。该函数还可以有额外的参数，可以通过 `solve_ivp`
    例程的 `args` 关键字传递，但这些参数必须位于两个必要参数之后。将我们之前定义的 `euler` 函数与 `solve_ivp` 函数进行比较，两个函数的最大步长为
    0.1，我们发现 `solve_ivp` 解的最大真实误差约为 10-11，而 `euler` 解的误差为 0.19。`euler` 方法有效，但步长太大，导致误差不断积累。为了比较，*图
    3**.2* 是欧拉法生成的解与误差的图表。将 *图 3**.2* 与 *图 3**.1* 进行比较，注意误差图的比例尺有很大的不同：
- en: '![Figure 3.2 – Plot of solution and error using Euler’s method with step size
    0.1'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.2 – 使用欧拉方法（步长为 0.1）绘制的解与误差图'
- en: '](img/3.2.jpg)'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/3.2.jpg)'
- en: Figure 3.2 – Plot of solution and error using Euler’s method with step size
    0.1
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2 – 使用欧拉方法（步长为 0.1）绘制的解与误差图
- en: The `solve_ivp` routine returns a solution object that stores information about
    the solution that has been computed. Most important here are the `t` and `y` attributes,
    which contain the ![](img/Formula_03_155.png) values on which the solution ![](img/Formula_03_156.png)
    is computed and the solution ![](img/Formula_03_157.png) itself. We used these
    values to plot the solution we computed. The ![](img/Formula_03_157.png) values
    are stored in a NumPy array of shape `(n, N)`, where `n` is the number of components
    of the equation (here, 1), and `N` is the number of points computed. The ![](img/Formula_03_157.png)
    values held in `sol` are stored in a two-dimensional array, which in this case
    has one row and many columns. We use the slice `y[0, :]` to extract this first
    row as a one-dimensional array that can be used to plot the solution in step 4.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`solve_ivp` 例程返回一个解对象，该对象存储有关已计算解的信息。这里最重要的是 `t` 和 `y` 属性，它们包含计算解 ![](img/Formula_03_156.png)
    的 ![](img/Formula_03_155.png) 值以及解本身 ![](img/Formula_03_157.png)。我们使用这些值来绘制我们计算出的解。
    ![](img/Formula_03_157.png) 值存储在一个形状为 `(n, N)` 的 NumPy 数组中，其中 `n` 是方程的组成部分数量（这里为
    1），`N` 是计算得到的点的数量。存储在 `sol` 中的 ![](img/Formula_03_157.png) 值保存在一个二维数组中，在这个例子中有一行和多列。我们使用切片
    `y[0, :]` 来提取这一行作为一个一维数组，可以用于在第 4 步中绘制解。'
- en: We use a logarithmically scaled ![](img/Formula_03_157.png) axis to plot the
    error because what is interesting there is the order of magnitude. Plotting it
    on a non-scaled ![](img/Formula_03_157.png) axis would give a line that is very
    close to the ![](img/Formula_03_162.png) axis, which doesn’t show the increase
    in the error as we move through the ![](img/Formula_03_163.png) values. The logarithmically
    scaled ![](img/Formula_03_157.png) axis shows this increase clearly.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用对数缩放的 ![](img/Formula_03_157.png) 坐标轴来绘制误差，因为这里有趣的是量级。将其绘制在未缩放的 ![](img/Formula_03_157.png)
    坐标轴上会得到一条非常接近 ![](img/Formula_03_162.png) 坐标轴的直线，这样无法显示随着我们通过 ![](img/Formula_03_163.png)
    值变化误差的增加。对数缩放的 ![](img/Formula_03_157.png) 坐标轴清晰地显示了这一增加。
- en: There’s more...
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: The `solve_ivp` routine is a convenient interface for a number of solvers for
    differential equations, the default being the RKF45 method. The different solvers
    have different strengths, but the RKF45 method is a good general-purpose solver.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '`solve_ivp` 例程是一个方便的接口，提供多种微分方程求解器，默认使用 RKF45 方法。这些求解器各有不同的优点，但 RKF45 方法是一个良好的通用求解器。'
- en: See also
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: For more detailed instructions on how to add subplots to a figure in Matplotlib,
    see the *Adding subplots* recipe from [*Chapter 2*](B19085_02.xhtml#_idTextAnchor036),
    *Mathematical Plotting* *with Matplotlib*.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 有关如何在 Matplotlib 中向图形添加子图的详细说明，请参见 [*第 2 章*](B19085_02.xhtml#_idTextAnchor036)
    中的 *添加子图* 方案，书名为 *Matplotlib 数学绘图*。
- en: Solving systems of differential equations
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 求解微分方程组
- en: 'Differential equations sometimes occur in systems consisting of two or more
    interlinked differential equations. A classic example is a simple model of the
    populations of competing species. This is a simple model of competing species
    labeled ![](img/Formula_03_165.png) (the prey) and ![](img/Formula_03_166.png)
    (the predators) given by the following equations:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 微分方程有时出现在由两个或多个互相关联的微分方程组成的系统中。一个经典的例子是竞争物种种群的简单模型。这个竞争物种的简单模型标记为 ![](img/Formula_03_165.png)（猎物）和
    ![](img/Formula_03_166.png)（捕食者），由以下方程给出：
- en: '![](img/Formula_03_167.jpg)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_03_167.jpg)'
- en: The first equation dictates the growth of the prey species ![](img/Formula_03_169.png),
    which, without any predators, would be exponential growth. The second equation
    dictates the growth of the predator species ![](img/Formula_03_170.png), which,
    without any prey, would be exponential decay. Of course, these two equations are
    *coupled*; each population change depends on both populations. The predators consume
    the prey at a rate proportional to the product of their two populations, and the
    predators grow at a rate proportional to the relative abundance of prey (again
    the product of the two populations).
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个方程决定了猎物物种 ![](img/Formula_03_169.png) 的增长，如果没有捕食者，它将呈指数增长。第二个方程决定了捕食者物种 ![](img/Formula_03_170.png)
    的增长，如果没有猎物，它将呈指数衰减。当然，这两个方程是 *耦合的*；每个人口变化都依赖于两个物种的数量。捕食者以与两者数量积成正比的速度捕食猎物，而捕食者的增长速度与猎物的相对丰度成正比（同样是两者数量的积）。
- en: In this recipe, we will analyze a simple system of differential equations and
    use the SciPy `integrate` module to obtain approximate solutions.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将分析一个简单的微分方程系统，并使用 SciPy `integrate` 模块来获得近似解。
- en: Getting ready
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The tools for solving a system of differential equations using Python are the
    same as those for solving a single equation. We again use the `solve_ivp` routine
    from the `integrate` module in SciPy. However, this will only give us a predicted
    evolution over time with given starting populations. For this reason, we will
    also employ some plotting tools from Matplotlib to better understand the evolution.
    As usual, the NumPy library is imported as `np` and the Matplotlib `pyplot` interface
    is imported as `plt`.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Python 求解微分方程组的工具与求解单一方程的工具是相同的。我们再次使用 SciPy `integrate` 模块中的 `solve_ivp`
    函数。然而，这只会给我们在给定起始种群下，预测的时间演化。因此，我们还将使用 Matplotlib 中的一些绘图工具，以便更好地理解种群演化。像往常一样，我们导入了
    NumPy 库并将其命名为 `np`，同时导入了 Matplotlib 的 `pyplot` 接口并将其命名为 `plt`。
- en: How to do it...
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The following steps walk us through how to analyze a simple system of differential
    equations:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的步骤将引导我们如何分析一个简单的微分方程系统：
- en: 'Our first task is to define a function that holds the system of equations.
    This function needs to take two arguments as for a single equation, except the
    dependent variable ![](img/Formula_03_171.png) (in the notation from the *Solving
    simple differential equations numerically* recipe) will now be an array with as
    many elements as there are equations. Here, there will be two elements. The function
    we need for the example system in this recipe is defined as follows:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的第一个任务是定义一个包含方程组的函数。这个函数需要接受两个参数，就像单一方程那样，唯一不同的是依赖变量 ![](img/Formula_03_171.png)（来自
    *数值求解简单微分方程* 食谱中的符号）将变成一个数组，数组的元素个数等于方程的个数。在这里，会有两个元素。我们为这个示例系统所需的函数定义如下：
- en: '[PRE79]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Now we have defined the system in Python, we can use the `quiver` routine from
    Matplotlib to produce a plot that will describe how the populations will evolve—given
    by the equations—at numerous starting populations. We first set up a grid of points
    on which we will plot this evolution. It is a good idea to choose a relatively
    small number of points for the `quiver` routine; otherwise, it becomes difficult
    to see details in the plot. For this example, we plot the population values between
    0 and 100:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们在 Python 中定义了系统，我们可以使用 Matplotlib 的 `quiver` 函数生成一个图表，描述在多个起始种群下，按照方程所给出的种群将如何演化。我们首先设置一个点的网格，在这个网格上我们将绘制这个演化。建议选择一个相对较少的点数来进行
    `quiver` 绘图；否则，图表的细节将变得难以看清。对于这个示例，我们绘制种群值在 0 到 100 之间的情况：
- en: '[PRE82]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Now, we compute the values of the system at each of these pairs. Notice that
    neither equation in the system is time-dependent (they are autonomous); the time
    variable ![](img/Formula_03_172.png) is unimportant in the calculation. We supply
    the value `0` for the ![](img/Formula_03_172.png) argument:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们在每对这些点上计算系统的值。注意，系统中的任何方程都不是时间相关的（它们是自治的）；时间变量 ![](img/Formula_03_172.png)
    在计算中不重要。我们为 ![](img/Formula_03_172.png) 参数提供值 `0`：
- en: '[PRE85]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'The `dp` and `dw` variables now hold the *direction* in which the population
    of ![](img/Formula_03_174.png) and ![](img/Formula_03_175.png) will evolve, respectively,
    if we started at each point in our grid. We can plot these directions together
    using the `quiver` routine from `matplotlib.pyplot`:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`dp` 和 `dw` 变量现在分别表示如果我们从网格中的每个点开始，物种 ![](img/Formula_03_174.png) 和 ![](img/Formula_03_175.png)
    将演化的 *方向*。我们可以使用 `matplotlib.pyplot` 中的 `quiver` 函数将这些方向绘制在一起：'
- en: '[PRE86]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Plotting the result of these commands now gives us *Figure 3**.3*, which gives
    a *global* picture of how solutions evolve:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制这些命令的结果现在给出了*图 3.3*，它提供了一个*全局*的视角，展示了解如何演变：
- en: '![Figure 3.3 – A quiver plot showing the population dynamics of two competing
    species'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.3 – 显示两种竞争物种种群动态的箭头图'
- en: '](img/3.3.jpg)'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/3.3.jpg)'
- en: Figure 3.3 – A quiver plot showing the population dynamics of two competing
    species
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3 – 显示两种竞争物种种群动态的箭头图
- en: To understand a solution more specifically, we need some initial conditions
    so that we can use the `solve_ivp` routine described in the previous recipe.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更具体地理解解，我们需要一些初始条件，以便能够使用前面食谱中描述的`solve_ivp`例程。
- en: 'Since we have two equations, our initial conditions will have two values. (Recall
    in the *Solving simple differential equations numerically* recipe, we saw that
    the initial condition provided to `solve_ivp` needs to be a NumPy array.) Let’s
    consider the initial values ![](img/Formula_03_176.png) and ![](img/Formula_03_177.png).
    We define these in a NumPy array, being careful to place them in the correct order:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们有两个方程，初始条件将有两个值。（回想在*数值求解简单微分方程*的食谱中，我们看到提供给`solve_ivp`的初始条件需要是一个NumPy数组。）让我们考虑初始值
    ![](img/Formula_03_176.png) 和 ![](img/Formula_03_177.png)。我们将它们定义在一个NumPy数组中，并小心地按正确的顺序放置它们：
- en: '[PRE91]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Now, we can use `solve_ivp` from the `scipy.integrate` module. We need to provide
    the `max_step` keyword argument to make sure that we have enough points in the
    solution to give a smooth solution curve:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以使用来自`scipy.integrate`模块的`solve_ivp`。我们需要提供`max_step`关键字参数，以确保我们在解中有足够的点，从而得到平滑的解曲线：
- en: '[PRE92]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Let’s plot this solution on our existing figure to show how this specific solution
    relates to the direction plot we have already produced. We also plot the initial
    condition at the same time:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将这个解绘制在现有图形上，以展示这个特定解如何与我们已经生成的方向图相关联。我们同时也绘制初始条件：
- en: '[PRE98]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'The result of this is shown in *Figure 3**.4*:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如*图 3.4*所示：
- en: '![Figure 3.4 – Solution trajectory plotted over a quiver plot showing the general
    behavior'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.4 – 在箭头图上绘制的解轨迹，展示了总体行为'
- en: '](img/3.4.jpg)'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/3.4.jpg)'
- en: Figure 3.4 – Solution trajectory plotted over a quiver plot showing the general
    behavior
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4 – 在箭头图上绘制的解轨迹，展示了总体行为
- en: We can see that the trajectory plotted is a closed loop. This means that the
    populations have a stable and periodic relationship. This is a common pattern
    when solving these equations.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到绘制出的轨迹是一个闭合的环路。这意味着种群之间有一个稳定且周期性的关系。这是解这些方程时常见的模式。
- en: How it works...
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: 'The method used for a system of ODEs is exactly the same as for a single ODE.
    We start by writing the system of equations as a single vector differential equation:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 用于系统ODE的方法与单一ODE完全相同。我们从将方程组写成单一的向量微分方程开始：
- en: '![](img/Formula_03_178.jpg)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_03_178.jpg)'
- en: This can then be solved using a time-stepping method as though ![](img/Formula_03_179.png)
    were a simple scalar value.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，可以使用时间步进方法来求解，就像 ![](img/Formula_03_179.png) 是一个简单的标量值一样。
- en: The technique of plotting the directional arrows on a plane using the `quiver`
    routine is a quick and easy way of learning how a system might evolve from a given
    state. The derivative of a function represents the gradient of the curve ![](img/Formula_03_180.png),
    and so a differential equation describes the gradient of the solution function
    at position ![](img/Formula_03_179.png) and time ![](img/Formula_03_182.png).
    A system of equations describes the gradient of separate solution functions at
    a given position ![](img/Formula_03_179.png) and time ![](img/Formula_03_182.png).
    Of course, the position is now a two-dimensional point, so when we plot the gradient
    at a point, we represent this as an arrow that starts at the point, in the direction
    of the gradient. The length of the arrow represents the size of the gradient;
    the longer the arrow, the *faster* the solution curve will move in that direction.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`quiver`例程在平面上绘制方向箭头的技术是一种快速且简单的方式来了解一个系统如何从给定状态演变。一个函数的导数表示曲线的梯度 ![](img/Formula_03_180.png)，因此微分方程描述了解函数在位置
    ![](img/Formula_03_179.png) 和时间 ![](img/Formula_03_182.png) 处的梯度。一个方程组描述了在给定位置
    ![](img/Formula_03_179.png) 和时间 ![](img/Formula_03_182.png) 处的各个解函数的梯度。当然，位置现在是一个二维点，因此当我们绘制该点的梯度时，我们将其表示为一支箭头，箭头从该点开始，指向梯度的方向。箭头的长度表示梯度的大小；箭头越长，解曲线在该方向上移动得就越*快*。
- en: 'When we plot the solution trajectory on top of this direction field, we can
    see that the curve (starting at the point) follows the direction indicated by
    the arrows. The behavior shown by the solution trajectory is a *limit cycle*,
    where the solution for each variable is periodic as the two species’ populations
    grow or decline. This description of the behavior is perhaps clearer if we plot
    each population against time, as seen in *Figure 3**.5*. What is not immediately
    obvious from *Figure 3**.4* is that the solution trajectory loops around several
    times, but this is clearly shown in *Figure 3**.5*:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将解轨迹绘制在这个方向场上时，可以看到曲线（从某个点开始）沿着箭头指示的方向移动。解轨迹所表现的行为是一个*极限环*，其中每个变量的解是周期性的，随着两个物种种群的增长或下降。这种行为的描述在我们将每个种群与时间进行绘制时，或许会更加清晰，如*图
    3.5*所示。从*图 3.4*中不容易立刻看出来的是解轨迹会绕几个圈，但这在*图 3.5*中清楚地展示了出来：
- en: '![Figure 3.5 – Plots of populations P and W against time'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.5 – 种群 P 和 W 随时间变化的图像'
- en: '](img/3.5.jpg)'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/3.5.jpg)'
- en: Figure 3.5 – Plots of populations P and W against time
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.5 – 种群 P 和 W 随时间变化的图像
- en: The periodic relationship described previously is clear in *Figure 3**.5*. Moreover,
    we can see the lag between the peak populations of the two species. Species ![](img/Formula_03_185.png)
    experiences peak population approximately 0.3 time periods after species ![](img/Formula_03_186.png).
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 前面描述的周期关系在*图 3.5*中非常明显。此外，我们还可以看到两个物种的种群峰值之间的滞后关系。物种 ![](img/Formula_03_185.png)
    的峰值种群大约在物种 ![](img/Formula_03_186.png) 后 0.3 个时间单位达到。
- en: There’s more...
  id: totrans-328
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The technique of analyzing a system of ODEs by plotting variables against one
    another, starting at various initial conditions, is called *phase space (plane)
    analysis*. In this recipe, we used the `quiver` plotting routine to quickly generate
    an approximation of the phase plane for a system of differential equations. By
    analyzing the phase plane of a system of differential equations, we can identify
    different local and global characteristics of the solution, such as limit cycles.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将变量彼此对比，针对不同的初始条件绘制出来，从而分析一个常微分方程系统的技术，称为*相空间（平面）分析*。在这个过程中，我们使用了 `quiver`
    绘图方法来快速生成微分方程系统的相平面的近似图。通过分析微分方程系统的相平面，我们可以识别解的不同局部和全局特征，如极限环。
- en: Solving partial differential equations numerically
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数值求解偏微分方程
- en: 'Partial differential equations are differential equations that involve *partial
    derivatives* of functions in two or more variables, as opposed to *ordinary derivatives*
    in only a single variable. Partial differential equations are a vast topic, and
    could easily fill a series of books. A typical example of a partial differential
    equation is the (one-dimensional) *heat equation*:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 偏微分方程是涉及多个变量的函数的*偏导数*的微分方程，而不是只有单一变量的*普通导数*。偏微分方程是一个广泛的主题，足以填满一系列的书籍。一个典型的偏微分方程的例子是（一维）*热方程*：
- en: '![](img/Formula_03_187.jpg)'
  id: totrans-332
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_03_187.jpg)'
- en: 'Here, ![](img/Formula_03_188.png) is a positive constant and ![](img/Formula_03_189.png)
    is a function. The solution to this partial differential equation is a function
    ![](img/Formula_03_190.png), which represents the temperature of a rod, occupying
    the ![](img/Formula_03_191.png) range ![](img/Formula_03_192.png), at a given
    time ![](img/Formula_03_193.png). To keep things simple, we will take ![](img/Formula_03_194.png),
    which amounts to saying that no heating/cooling is applied to the system, ![](img/Formula_03_195.png),
    and ![](img/Formula_03_196.png). In practice, we can rescale the problem to fix
    the constant ![](img/Formula_03_197.png), so this is not a restrictive problem.
    In this example, we will use boundary conditions:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，![](img/Formula_03_188.png) 是一个正的常数，![](img/Formula_03_189.png) 是一个函数。这个偏微分方程的解是一个函数
    ![](img/Formula_03_190.png)，它表示在给定时间 ![](img/Formula_03_193.png) 时，处于范围 ![](img/Formula_03_192.png)
    的杆的温度。为了简化问题，我们假设 ![](img/Formula_03_194.png)，这相当于说没有施加任何加热/冷却，![](img/Formula_03_195.png)，并且
    ![](img/Formula_03_196.png)。在实践中，我们可以重新调整问题的尺度，使常数 ![](img/Formula_03_197.png)
    固定，所以这并不是一个限制性问题。在这个例子中，我们将使用边界条件：
- en: '![](img/Formula_03_198.jpg)'
  id: totrans-334
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_03_198.jpg)'
- en: 'These are equivalent to saying that the ends of the rod are held at the constant
    temperature 0\. We will also use the initial temperature profile:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 这些等同于说杆的两端被保持在常温 0°。我们还将使用初始温度分布：
- en: '![](img/Formula_03_199.jpg)'
  id: totrans-336
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_03_199.jpg)'
- en: This initial temperature profile describes a smooth curve between the values
    of 0 and 2 that peaks at a value of 3, which might be the result of heating the
    rod at the center to a temperature of 3.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 这个初始温度分布描述了一条平滑的曲线，介于0和2之间，峰值为3，这可能是因为将杆的中心加热至温度3所导致的。
- en: We’re going to use a method called *finite differences*, where we divide the
    rod into a number of equal segments and the time range into a number of discrete
    steps. We then compute approximations for the solution at each of the segments
    and each time step.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一种叫做*有限差分法*的方法，先将杆分成若干等长的段，再将时间范围划分为若干离散的步长。然后，我们计算每个段和每个时间步的解的近似值。
- en: In this recipe, we will use finite differences to solve a simple partial differential
    equation.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将使用有限差分法来求解一个简单的偏微分方程。
- en: Getting ready
  id: totrans-340
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this recipe, we will need the NumPy and Matplotlib packages, imported as
    `np` and `plt`, as usual. We also need to import the `mplot3d` module from `mpl_toolkits`
    since we will be producing a 3D plot:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，我们将需要NumPy和Matplotlib包，分别以`np`和`plt`导入，和往常一样。我们还需要从`mpl_toolkits`中导入`mplot3d`模块，因为我们将绘制一个3D图：
- en: '[PRE101]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: We will also need some modules from the SciPy package.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一些来自SciPy包的模块。
- en: How to do it...
  id: totrans-344
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'In the following steps, we work through solving the heat equation using finite
    differences:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的步骤中，我们将通过有限差分法解决热方程：
- en: 'Let’s first create variables that represent the physical constraints of the
    system—the extent of the bar and the value of ![](img/Formula_03_200.png):'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们创建表示系统物理约束的变量——杆的长度和![](img/Formula_03_200.png)的值：
- en: '[PRE102]'
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'We first divide the ![](img/Formula_03_201.png) range into ![](img/Formula_03_202.png)
    equal intervals—we take ![](img/Formula_03_203.png) for this example—using ![](img/Formula_03_204.png)
    points. We can use the `linspace` routine from NumPy to generate these points.
    We also need the common length of each interval ![](img/Formula_03_205.png):'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先将![](img/Formula_03_201.png)范围划分为![](img/Formula_03_202.png)等间隔——我们在这个例子中取![](img/Formula_03_203.png)——使用![](img/Formula_03_204.png)个点。我们可以使用NumPy的`linspace`函数生成这些点。我们还需要每个区间的公共长度![](img/Formula_03_205.png)：
- en: '[PRE105]'
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Next, we need to set up the steps in the time direction. We take a slightly
    different approach here; we set the time step size ![](img/Formula_03_206.png)
    and the number of steps (implicitly making the assumption that we start at time
    0):'
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要设置时间方向上的步长。我们在这里采取稍微不同的方法；我们设置时间步长![](img/Formula_03_206.png)和步数（隐含假设从时间0开始）：
- en: '[PRE108]'
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: In order for the method to behave properly, we must have the following formula:![](img/Formula_03_207.jpg)
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使方法正确运行，我们必须满足以下公式：![](img/Formula_03_207.jpg)
- en: 'Otherwise, the system can become unstable. We store the left-hand side of this
    in a variable for use in step 5, and use an assertion to check that this inequality
    holds:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，系统可能会变得不稳定。我们将这个不等式的左边存储在一个变量中，以便在第5步使用，并用断言检查这个不等式是否成立：
- en: '[PRE111]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Now, we can construct a matrix that holds the coefficients from the finite
    difference scheme. To do this, we use the `diags` routine from the `scipy.sparse`
    module to create a sparse, tridiagonal matrix:'
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以构造一个矩阵来保存有限差分方案中的系数。为此，我们使用`scipy.sparse`模块中的`diags`函数来创建一个稀疏的三对角矩阵：
- en: '[PRE112]'
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Next, we create a blank matrix that will hold the solution:'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个空矩阵来保存解：
- en: '[PRE119]'
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'We need to add the initial profile to the first row. The best way to do this
    is to create a function that holds the initial profile and store the result of
    evaluating this function on the `x` array in the matrix `u` that we just created:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要将初始分布添加到第一行。最佳方法是创建一个函数来表示初始分布，并将该函数在`x`数组上求值的结果存储在我们刚刚创建的矩阵`u`中：
- en: '[PRE120]'
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Now, we can simply loop through each step, computing the next row of the matrix
    `u` by multiplying `A` and the previous row:'
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以简单地遍历每一步，通过将`A`与前一行相乘来计算矩阵`u`的下一行：
- en: '[PRE123]'
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'Finally, to visualize the solution we have just computed, we can plot the solution
    as a surface using Matplotlib:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了可视化我们刚刚计算的解，我们可以使用Matplotlib将解绘制为表面图：
- en: '[PRE125]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'The result of this is the surface plot shown in *Figure 3**.6*:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是如*图3.6*所示的表面图：
- en: '![Figure 3.6  -Numerical solution of the heat equation over the range'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.6 - 热方程在该范围内的数值解'
- en: '](img/3.6.jpg)'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/3.6.jpg)'
- en: Figure 3.6 -Numerical solution of the heat equation over the range ![](img/Formula_03_208.png)
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6 - 热方程在该范围内的数值解 ![](img/Formula_03_208.png)
- en: Along the ![](img/Formula_03_209.png) axis, we can see that the overall shape
    is similar to the shape of the initial profile but becomes flatter as time progresses.
    Along the ![](img/Formula_03_210.png) axis, the surface exhibits the exponential
    decay that is characteristic of cooling systems.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 沿着 ![](img/Formula_03_209.png) 轴，我们可以看到整体形状与初始轮廓相似，但随着时间的推移变得更加平坦。沿着 ![](img/Formula_03_210.png)
    轴，表面展现出典型的冷却系统特征——指数衰减。
- en: How it works...
  id: totrans-385
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The finite difference method works by replacing each of the derivatives with
    a simple fraction that involves only the value of the function, which we can estimate.
    To implement this method, we first break down the spatial range and time range
    into a number of discrete intervals, separated by mesh points. This process is
    called *discretization*. Then, we use the differential equation and the initial
    conditions and boundary conditions to form successive approximations, in a manner
    very similar to the time-stepping methods used by the `solve_ivp` routine in the
    *Solving simple differential equations* *numerically* recipe.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 有限差分法通过用只涉及函数值的简单分数来替代每个导数，这些函数值我们可以估计。为了实现此方法，我们首先将空间范围和时间范围分解为多个离散区间，由网格点分隔。这个过程称为*离散化*。然后，我们使用微分方程以及初始条件和边界条件形成连续的近似，方式与`solve_ivp`例程在*数值求解简单微分方程*中的时间步进方法非常相似。
- en: In order to solve a partial differential equation such as the heat equation,
    we need at least three pieces of information. Usually, for the heat equation,
    this will come in the form of *boundary conditions* for the spatial dimension,
    which tell us what the behavior is at either end of the rod, and *initial conditions*
    for the time dimension, which is the initial temperature profile over the rod.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决像热方程这样的偏微分方程，我们至少需要三项信息。通常，对于热方程，这些信息将以*边界条件*的形式出现在空间维度上，告诉我们杆子两端的行为，以及*初始条件*的形式出现在时间维度上，表示杆子上的初始温度分布。
- en: 'The finite difference scheme described previously is usually referred to as
    the **forward time cen** (**FTCS**) scheme, since we use the *forward finite difference*
    to estimate the time derivative and the *central finite difference* to estimate
    the (second-order) spatial derivative. The formula for the first-order finite
    difference approximation is shown here:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 前面描述的有限差分法通常称为**前向时间中心差分**（**FTCS**）法，因为我们使用*前向有限差分*来估计时间导数，使用*中心有限差分*来估计（二阶）空间导数。第一阶有限差分近似的公式如下：
- en: '![](img/Formula_03_211.jpg)'
  id: totrans-389
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_03_211.jpg)'
- en: 'Similarly, the second-order approximation is given by the following formula:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，二阶近似由以下公式给出：
- en: '![](img/Formula_03_212.jpg)'
  id: totrans-391
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_03_212.jpg)'
- en: 'Substituting these approximations into the heat equation, and using the approximation
    ![](img/Formula_03_213.png) for the value of ![](img/Formula_03_214.png) after
    ![](img/Formula_03_215.png) time steps at the ![](img/Formula_03_216.png) spatial
    point, we get this:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些近似代入热方程，并使用近似公式 ![](img/Formula_03_213.png) 来表示在 ![](img/Formula_03_215.png)
    时间步长后的 ![](img/Formula_03_214.png) 在 ![](img/Formula_03_216.png) 空间点的值，我们得到如下结果：
- en: '![](img/Formula_03_217.jpg)'
  id: totrans-393
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_03_217.jpg)'
- en: 'This can be rearranged to obtain the following formula:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以重新排列得到以下公式：
- en: '![](img/Formula_03_218.jpg)'
  id: totrans-395
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_03_218.jpg)'
- en: Roughly speaking, this equation says that the next temperature at a given point
    depends on the surrounding temperatures at the previous time. This also shows
    why the condition on the `r` value is necessary; if the condition does not hold,
    the middle term on the right-hand side will be negative.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 粗略地说，这个方程表明给定点的下一个温度依赖于前一个时间步长周围的温度。这也说明了为什么`r`值的条件是必要的；如果这个条件不成立，右侧的中间项将变为负数。
- en: 'We can write this system of equations in matrix form:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这个方程系统写成矩阵形式：
- en: '![](img/Formula_03_219.jpg)'
  id: totrans-398
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_03_219.jpg)'
- en: Here, ![](img/Formula_03_220.png) is a vector containing the approximation ![](img/Formula_03_221.png)
    and matrix ![](img/Formula_03_222.png), which was defined in step 4\. This matrix
    is tridiagonal, which means the nonzero entries appear on, or adjacent to, the
    leading diagonal. We use the `diag` routine from the SciPy `sparse` module, which
    is a utility for defining these kinds of matrices. This is very similar to the
    process described in the *Solving equations* recipe of this chapter. The first
    and last rows of this matrix have zeros, except in the top left and bottom right,
    respectively, that represent the (non-changing) boundary conditions. The other
    rows have coefficients that are given by the finite difference approximations
    for the derivatives on either side of the differential equation. We first create
    diagonal entries and entries above and below the diagonal, and then we use the
    `diags` routine to create a sparse matrix. The matrix should have ![](img/Formula_03_223.png)
    rows and columns, to match the number of mesh points, and we set the data type
    as double-precision floats and **compressed sparse row** (**CSR**) format.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，![](img/Formula_03_220.png)是一个向量，包含近似值![](img/Formula_03_221.png)和矩阵![](img/Formula_03_222.png)，该矩阵在步骤4中已定义。该矩阵是三对角矩阵，意味着非零项出现在主对角线或其邻近位置。我们使用来自SciPy
    `sparse`模块的`diag`函数，这是定义这类矩阵的工具。这与本章*求解方程*的过程非常相似。该矩阵的首行和末行都为零，除了左上角和右下角分别表示（不变的）边界条件。其他行则包含通过有限差分法对微分方程两侧的导数进行近似得到的系数。我们首先创建对角线上的条目以及对角线上下的条目，然后使用`diags`函数创建一个稀疏矩阵。该矩阵应具有![](img/Formula_03_223.png)行和列，以匹配网格点的数量，并且我们将数据类型设置为双精度浮点数，并采用**压缩稀疏行**（**CSR**）格式。
- en: The initial profile gives us the vector ![](img/Formula_03_224.png), and from
    this first point, we can compute each subsequent time step by simply performing
    a matrix multiplication, as we saw in step 7.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 初始配置给出了向量![](img/Formula_03_224.png)，从这个初始点开始，我们可以通过简单地执行矩阵乘法来计算每个后续时间步，就像我们在步骤7中看到的那样。
- en: There’s more...
  id: totrans-401
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: The method we describe here is rather crude since the approximation can become
    unstable, as we mentioned, if the relative sizes of time steps and spatial steps
    are not carefully controlled. This method is *explicit* since each time step is
    computed explicitly using only information from the previous time step. There
    are also *implicit* methods, which give a system of equations that can be solved
    to obtain the next time step. Different schemes have different characteristics
    in terms of the stability of the solution.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里描述的方法相当粗糙，因为如我们所提到的，如果时间步长和空间步长的相对大小没有得到精确控制，近似可能会变得不稳定。这种方法是*显式*的，因为每个时间步都是显式计算的，仅使用前一个时间步的信息。也有*隐式*方法，它给出一个方程组，可以求解得到下一个时间步。不同的方案在解的稳定性上有不同的特点。
- en: 'When the function ![](img/Formula_03_225.png) is not 0, we can easily accommodate
    this change by using the following assignment:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数![](img/Formula_03_225.png)不为0时，我们可以通过以下赋值来轻松处理这种变化：
- en: '![](img/Formula_03_226.jpg)'
  id: totrans-404
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_03_226.jpg)'
- en: 'Here, the function is suitably vectorized to make this formula valid. In terms
    of the code used to solve the problem, we need only include the definition of
    the function and then change the loop of the solution, as follows:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，函数已被适当向量化，使得该公式有效。就解决问题所用的代码而言，我们只需要包含函数的定义，然后更改解法中的循环，代码如下：
- en: '[PRE126]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: Physically, this function represents an external heat source (or sink) at each
    point along the rod. This may change over time, which is why, in general, the
    function should have both ![](img/Formula_03_227.png) and ![](img/Formula_03_228.png)
    as arguments (though they need not both be used).
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 从物理角度来看，这个函数表示杆上每个点的外部热源（或热汇）。这个热源可能会随时间变化，这就是为什么通常情况下，该函数应该同时具有![](img/Formula_03_227.png)和![](img/Formula_03_228.png)作为参数（尽管不一定都需要使用）。
- en: 'The boundary conditions we gave in this example represent the ends of the rod
    being kept at a constant temperature of 0\. These kinds of boundary conditions
    are sometimes called *Dirichlet* boundary conditions. There are also *Neumann*
    boundary conditions, where the derivative of the function ![](img/Formula_03_229.png)
    is given at the boundary. For example, we might have been given the following
    boundary conditions:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个示例中给出的边界条件表示杆的两端保持在0的恒定温度下。这类边界条件有时称为*狄利克雷*边界条件。也有*诺依曼*边界条件，在这种情况下，函数![](img/Formula_03_229.png)的导数在边界处给出。例如，我们可能会给定以下边界条件：
- en: '![](img/Formula_03_230.jpg)'
  id: totrans-409
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_03_230.jpg)'
- en: 'This could be interpreted physically as the ends of the rod being insulated
    so that heat cannot escape through the endpoints. For such boundary conditions,
    we need to modify the matrix ![](img/Formula_03_231.png) slightly, but otherwise,
    the method remains the same. Indeed, inserting an imaginary ![](img/Formula_03_232.png)
    value to the left of the boundary and using the backward finite difference at
    the left-hand boundary (![](img/Formula_03_233.png)), we obtain the following:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 从物理角度看，这可以解释为杆的两端被绝缘，从而热量无法通过端点逸出。对于这种边界条件，我们需要稍微修改矩阵 ![](img/Formula_03_231.png)，但方法本身保持不变。实际上，在边界左侧插入一个虚拟的
    ![](img/Formula_03_232.png) 值，并在左侧边界使用向后有限差分法（![](img/Formula_03_233.png)），我们得到如下结果：
- en: '![](img/Formula_03_234.jpg)'
  id: totrans-411
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_03_234.jpg)'
- en: 'Using this in the second-order finite difference approximation, we get this:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 在二阶有限差分近似中，我们得到如下结果：
- en: '![](img/Formula_03_235.jpg)'
  id: totrans-413
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_03_235.jpg)'
- en: 'This means that the first row of our matrix should contain ![](img/Formula_03_236.png),
    then ![](img/Formula_03_237.png), followed by ![](img/Formula_03_238.png). Using
    a similar computation for the right-hand limit gives a similar final row of the
    matrix:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们的矩阵的第一行应包含 ![](img/Formula_03_236.png)，然后是 ![](img/Formula_03_237.png)，接着是
    ![](img/Formula_03_238.png)。对右侧边界进行类似的计算将得到矩阵的类似最后一行：
- en: '[PRE127]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: For more complex problems involving partial differential equations, it is probably
    more appropriate to use a *finite elements* solver. Finite element methods use
    a more sophisticated approach for computing solutions than partial differential
    equations, which are generally more flexible than the finite difference method
    we saw in this recipe. However, this comes at the cost of requiring more setup
    that relies on more advanced mathematical theory. On the other hand, there is
    a Python package for solving partial differential equations using finite element
    methods such as **FEniCS** ([fenicsproject.org](https://fenicsproject.org)). The
    advantage of using packages such as FEniCS is that they are usually tuned for
    performance, which is important when solving complex problems with high accuracy.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 对于涉及偏微分方程的更复杂问题，使用*有限元*求解器可能更为合适。有限元方法在计算解决方案时采用比偏微分方程更复杂的方法，这种方法通常比我们在此处看到的有限差分法更灵活。然而，这也意味着需要更多的设置，并且依赖于更高级的数学理论。另一方面，确实有一个Python包可以使用有限元方法来求解偏微分方程，比如**FEniCS**（[fenicsproject.org](https://fenicsproject.org)）。使用像FEniCS这样的包的优势在于，它们通常经过性能调优，这在求解高精度复杂问题时非常重要。
- en: See also
  id: totrans-417
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: 'The FEniCS documentation gives a good introduction to the finite element method
    and a number of examples of using the package to solve various classic partial
    differential equations. A more comprehensive introduction to the method and the
    theory is given in the following book: *Johnson, C.* (*2009*). *Numerical solution
    of partial differential equations by the finite element method*. *Mineola, N.Y.:*
    *Dover Publications*.'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: FEniCS文档提供了有限元方法的良好介绍，并给出了使用该包解决各种经典偏微分方程的多个示例。关于该方法和理论的更全面介绍可以参见以下书籍：*Johnson,
    C.*（*2009*）。*有限元法求解偏微分方程的数值解法*。*Mineola, N.Y.:* *Dover Publications*。
- en: For more details on how to produce three-dimensional surface plots using Matplotlib,
    see the *Surface and contour plots* recipe from [*Chapter 2*](B19085_02.xhtml#_idTextAnchor036),
    *Mathematical Plotting* *with Matplotlib*.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 有关如何使用Matplotlib生成三维表面图的更多详细信息，请参阅[*第二章*](B19085_02.xhtml#_idTextAnchor036)中的*表面和等高线图*配方，*Matplotlib数学绘图*。
- en: Using discrete Fourier transforms for signal processing
  id: totrans-420
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用离散傅里叶变换进行信号处理
- en: One of the most useful tools coming from calculus is the **Fourier transform**
    (**FT**). Roughly speaking, the FT changes the representation, in a reversible
    way, of certain functions. This change of representation is particularly useful
    in dealing with signals represented as a function of time. In this instance, the
    FT takes the signal and represents it as a function of frequency; we might describe
    this as transforming from signal space to frequency space. This can be used to
    identify the frequencies present in a signal for identification and other processing.
    In practice, we will usually have a discrete sample of a signal, so we have to
    use the **discrete Fourier transform** (**DFT**) to perform this kind of analysis.
    Fortunately, there is a computationally efficient algorithm, called the FFT, for
    applying the DFT to a sample.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 微积分中最有用的工具之一是 **傅里叶变换**（**FT**）。粗略来说，傅里叶变换以可逆的方式改变某些函数的表示。这种表示的变化在处理以时间为函数的信号时尤为有用。在这种情况下，傅里叶变换将信号表示为频率的函数；我们可以将其描述为从信号空间到频率空间的转换。这样可以用于识别信号中存在的频率，进行识别和其他处理。实际上，我们通常会拥有一个离散的信号样本，因此我们必须使用
    **离散傅里叶变换**（**DFT**）来进行这种分析。幸运的是，有一个计算效率高的算法——称为 FFT——可以将 DFT 应用于样本。
- en: We will follow a common process for filtering a noisy signal using the FFT.
    The first step is to apply the FFT and use the data to compute the **power spectral
    density** (**PSD**) of the signal. Then, we identify peaks and filter out the
    frequencies that do not contribute a sufficiently large amount to the signal.
    Then, we apply the inverse FFT to obtain the filtered signal.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将遵循一个常见的过程，使用 FFT 对噪声信号进行滤波。第一步是应用 FFT，并使用数据计算信号的 **功率谱密度**（**PSD**）。然后，我们识别峰值，并滤除那些对信号贡献不足的频率。接下来，我们应用逆
    FFT 来获取滤波后的信号。
- en: In this recipe, we use the FFT to analyze a sample of a signal and identify
    the frequencies present and clean the noise from the signal.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们使用 FFT 来分析信号的样本，识别其中的频率，并从信号中清除噪声。
- en: Getting ready
  id: totrans-424
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this recipe, we will only need the NumPy and Matplotlib packages imported
    as `np` and `plt`, as usual. We will need an instance of the default random number
    generator, created as follows:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本食谱，我们只需要导入 NumPy 和 Matplotlib 包，分别作为 `np` 和 `plt`。我们还需要创建一个默认的随机数生成器实例，如下所示：
- en: '[PRE128]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: Now, let’s see how to use the DFT.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何使用 DFT。
- en: How to do it...
  id: totrans-428
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Follow these instructions to use the FFT to process a noisy signal:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下说明使用 FFT 来处理噪声信号：
- en: 'We define a function that will generate our underlying signal:'
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义了一个函数来生成我们的基础信号：
- en: '[PRE129]'
  id: totrans-431
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-432
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-433
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'Next, we create our sample signal by adding some Gaussian noise to the underlying
    signal. We also create an array that holds the true signal at the sample ![](img/Formula_03_239.png)
    values for convenience later:'
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们通过向基础信号中添加一些高斯噪声来创建我们的样本信号。为了方便后续处理，我们还创建了一个数组来存储在样本值处的真实信号 ![](img/Formula_03_239.png)：
- en: '[PRE132]'
  id: totrans-435
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-436
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-437
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-438
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-439
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-440
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'We use the `fft` module from NumPy to compute DFTs. We import this from NumPy
    before we start our analysis:'
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用 NumPy 的 `fft` 模块来计算 DFT。在开始分析之前，我们从 NumPy 导入它：
- en: '[PRE138]'
  id: totrans-442
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'To see what the noisy signal looks like, we can plot the sample signal points
    with the true signal superimposed:'
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了查看噪声信号的样子，我们可以将样本信号的点与真实信号叠加起来进行绘制：
- en: '[PRE139]'
  id: totrans-444
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-445
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-446
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-447
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-448
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-449
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-450
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-451
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-452
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-453
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'The plot created here is shown in *Figure 3**.7*. As we can see, the noisy
    signal does not bear much resemblance to the true signal (shown with the dashed
    line):'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 此处创建的图示显示在 *图 3.7* 中。如我们所见，噪声信号与真实信号（以虚线显示）几乎没有相似之处：
- en: '![Figure 3.7 – Noisy signal sample with true signal superimposed'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.7 – 带有叠加真实信号的噪声信号样本'
- en: '](img/3.7.jpg)'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/3.7.jpg)'
- en: Figure 3.7 – Noisy signal sample with true signal superimposed
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.7 – 带有叠加真实信号的噪声信号样本
- en: 'Now, we will use the DFT to extract the frequencies that are present in the
    sample signal. The `fft` routine in the `fft` module performs the DFT:'
  id: totrans-458
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将使用 DFT 提取样本信号中存在的频率。`fft` 模块中的 `fft` 例程执行 DFT：
- en: '[PRE149]'
  id: totrans-459
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'The `fft` module provides a routine for constructing the appropriate frequency
    values called `fftfreq`. For convenience, we also generate an array containing
    the integers at which the positive frequencies occur:'
  id: totrans-460
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`fft` 模块提供了一个名为 `fftfreq` 的例程，用于构建适当的频率值。为了方便起见，我们还生成了一个包含正频率出现位置的整数数组：'
- en: '[PRE150]'
  id: totrans-461
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-462
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'Next, compute the PSD of the signal, as follows:'
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，计算信号的 PSD，如下所示：
- en: '[PRE152]'
  id: totrans-464
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '[PRE153]'
  id: totrans-465
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'Now, we can plot the PSD of the signal for the positive frequencies and use
    this plot to identify frequencies:'
  id: totrans-466
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以绘制信号的正频率部分的 PSD，并利用该图来识别频率：
- en: '[PRE154]'
  id: totrans-467
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '[PRE155]'
  id: totrans-468
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-469
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '[PRE157]'
  id: totrans-470
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '[PRE158]'
  id: totrans-471
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'The result can be seen in *Figure 3**.8*. We can see in this diagram that there
    are spikes at roughly **4** and **7**, which are the frequencies of the signal
    that we defined earlier:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如*图 3**.8*所示。我们可以在这个图中看到，信号的频率大约在**4**和**7**附近，这就是我们之前定义的信号的频率：
- en: '![Figure 3.8 – PSD of a signal generated using the FFT'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.8 – 使用 FFT 生成的信号的 PSD'
- en: '](img/3.8.jpg)'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/3.8.jpg)'
- en: Figure 3.8 – PSD of a signal generated using the FFT
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.8 – 使用 FFT 生成的信号的 PSD
- en: 'We can identify these two frequencies to try to reconstruct the true signal
    from the noisy sample. All of the minor peaks that appear are not larger than
    2,000, so we can use this as a cut-off value for the filter. Let’s now extract
    from the list of all positive frequency indices the (hopefully 2) indices that
    correspond to the peaks above 2,000 in the PSD:'
  id: totrans-476
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以识别这两个频率，尝试从噪声样本中重建真实信号。所有出现的微小峰值都没有超过 2,000，因此我们可以使用这个值作为过滤器的截止值。现在，让我们从所有正频率索引的列表中提取（希望是
    2 个）与 PSD 中 2,000 以上的峰值对应的索引：
- en: '[PRE159]'
  id: totrans-477
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'Next, we create a new, clean spectrum that contains only the frequencies that
    we have extracted from the noisy signal. We do this by creating an array that
    contains only 0, and then copying the value of `spectrum` from those indices that
    correspond to the filtered frequencies and the negatives thereof:'
  id: totrans-478
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个新的干净频谱，只包含我们从噪声信号中提取的频率。我们通过创建一个仅包含 0 的数组来实现，然后复制那些与过滤频率及其负频率相对应的索引的
    `spectrum` 值：
- en: '[PRE160]'
  id: totrans-479
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '[PRE161]'
  id: totrans-480
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '[PRE162]'
  id: totrans-481
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE162]'
- en: 'Now, we use the inverse FFT (using the `ifft` routine) to transform this clean
    spectrum back to the time domain of the original sample. We take the real part
    using the `real` routine from NumPy to eliminate the erroneous imaginary parts:'
  id: totrans-482
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们使用逆 FFT（使用 `ifft` 函数）将这个干净的频谱转换回原始样本的时域。我们使用 NumPy 的 `real` 函数提取实部，以消除错误的虚部：
- en: '[PRE163]'
  id: totrans-483
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE163]'
- en: 'Finally, we plot this filtered signal over the true signal and compare the
    results:'
  id: totrans-484
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将这个过滤后的信号与真实信号叠加绘制，并比较结果：
- en: '[PRE164]'
  id: totrans-485
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[PRE165]'
  id: totrans-486
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE165]'
- en: '[PRE166]'
  id: totrans-487
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '[PRE167]'
  id: totrans-488
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE167]'
- en: '[PRE168]'
  id: totrans-489
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '[PRE169]'
  id: totrans-490
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE169]'
- en: '[PRE170]'
  id: totrans-491
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE170]'
- en: '[PRE171]'
  id: totrans-492
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE171]'
- en: '[PRE172]'
  id: totrans-493
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE172]'
- en: 'The result of step 11 is shown in *Figure 3**.9*. We can see that the filtered
    signal closely matches the true signal, except for some small discrepancies:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤 11 的结果如*图 3**.9*所示。我们可以看到，过滤后的信号与真实信号非常接近，除了有一些小的差异：
- en: '![Figure 3.9 – Filtered signal generated using FFTs superimposed over the true
    signal'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.9 – 使用 FFT 过滤后的信号与真实信号叠加'
- en: '](img/3.9.jpg)'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/3.9.jpg)'
- en: Figure 3.9 – Filtered signal generated using FFTs superimposed over the true
    signal
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.9 – 使用 FFT 过滤后的信号与真实信号叠加
- en: We can see in *Figure 3**.9* that the filtered signal (dashed line) fits fairly
    closely over the true signal (lighter solid line). It captures most (but not all)
    of the oscillations of the true signal.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在*图 3**.9*中看到，过滤后的信号（虚线）与真实信号（较浅的实线）非常接近。它捕捉到了真实信号的大部分（但不是全部）振荡。
- en: How it works...
  id: totrans-499
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The FT of a function ![](img/Formula_03_240.png) is given by the following
    integral:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 一个函数的 FT ![](img/Formula_03_240.png) 由以下积分给出：
- en: '![](img/Formula_03_241.jpg)'
  id: totrans-501
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_03_241.jpg)'
- en: 'The DFT is given by the following integral:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: DFT 由以下积分给出：
- en: '![](img/Formula_03_242.jpg)'
  id: totrans-503
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_03_242.jpg)'
- en: Here, the ![](img/Formula_03_243.png) values are the sample values as complex
    numbers. The DFT can be computed using the preceding formula, but in practice,
    this is not efficient. Computing using this formula is ![](img/Formula_03_244.png).
    The FFT algorithm improves the complexity to ![](img/Formula_03_245.png), which
    is significantly better. The book *Numerical Recipes* (full bibliographic details
    given in the *Further reading* section) gives a very good description of the FFT
    algorithm and the DFT.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，![](img/Formula_03_243.png) 值是作为复数的样本值。可以使用上述公式计算 DFT，但在实际应用中，这样做效率不高。使用该公式进行计算是
    ![](img/Formula_03_244.png)。FFT 算法将复杂度提高到 ![](img/Formula_03_245.png)，这显著改善了计算效率。书籍《*Numerical
    Recipes*》（完整书目信息见 *进一步阅读* 部分）对 FFT 算法和 DFT 做了非常好的描述。
- en: We will apply the DFT to a sample generated from a known signal (with known
    frequency modes) so that we can see the connection between the results we obtain
    and the original signal. To keep this signal simple, we created a signal that
    has only two frequency components with values 4 and 7\. From this signal, we generated
    a sample that we analyzed. Because of the way the FFT works, it is best if the
    sample has a size that is a power of 2; if this isn’t the case, we can pad the
    sample with zero elements to make this the case. We add some Gaussian noise to
    the sample signal, which takes the form of a normally distributed random number.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将对从已知信号（具有已知频率模式）生成的样本应用离散傅里叶变换（DFT），以便查看我们获得的结果与原始信号之间的关系。为了简化信号，我们创建了一个仅包含两个频率成分，值为4和7的信号。从这个信号中，我们生成了一个样本并进行了分析。由于快速傅里叶变换（FFT）的工作原理，最好是样本大小为2的幂；如果不是这种情况，我们可以通过在样本中填充零元素来使其符合要求。我们在样本信号中加入了一些高斯噪声，形式为正态分布的随机数。
- en: The array returned by the `fft` routine contains ![](img/Formula_03_246.png)
    elements, where ![](img/Formula_03_247.png) is the sample size. The element that
    index 0 corresponds to is the 0 frequency or DC shift. The next ![](img/Formula_03_248.png)elements
    are the values corresponding to the positive frequencies, and the final ![](img/Formula_03_249.png)
    elements are the values corresponding to the negative frequencies. The actual
    values of the frequencies are determined by the number of sampled points ![](img/Formula_03_250.png)
    and the sample spacing, which, in this example, is stored in `sample_d`.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: '`fft` 例程返回的数组包含 ![](img/Formula_03_246.png) 个元素，其中 ![](img/Formula_03_247.png)
    是样本大小。索引为0的元素对应的是0频率或直流偏移（DC shift）。接下来的 ![](img/Formula_03_248.png) 个元素对应正频率的值，最后
    ![](img/Formula_03_249.png) 个元素对应负频率的值。频率的实际值由采样点数 ![](img/Formula_03_250.png)
    和样本间距决定，在这个例子中，样本间距存储在 `sample_d` 中。'
- en: 'The PSD at the frequency ![](img/Formula_03_251.png) is given by the following
    formula:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 在频率 ![](img/Formula_03_251.png) 处的PSD由以下公式给出：
- en: '![](img/Formula_03_252.jpg)'
  id: totrans-508
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_03_252.jpg)'
- en: Here, ![](img/Formula_03_253.png) represents the FT of the signal at frequency
    ![](img/Formula_03_254.png). The PSD measures the contribution of each frequency
    to the overall signal, which is why we see peaks at approximately 4 and 7\. Since
    Python indexing allows us to use negative indices for elements starting from the
    end of the sequence, we can use the positive index array to get both the positive
    and negative frequency elements from `spectrum`.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，![](img/Formula_03_253.png) 代表了信号在频率 ![](img/Formula_03_254.png) 处的傅里叶变换（FT）。功率谱密度（PSD）衡量了各个频率对整体信号的贡献，这也是我们在大约4和7频率处看到峰值的原因。由于Python的索引允许我们使用负数索引来访问从序列末尾开始的元素，我们可以使用正索引数组来获取
    `spectrum` 中的正频率和负频率元素。
- en: In step 9, we identified the indices of the two frequencies that peak above
    2,000 on the plot. The frequencies that correspond to these indices are 3.984375
    and 6.97265625, which are not exactly equal to 4 and 7 but are very close. The
    reason for this discrepancy is the fact that we have sampled a continuous signal
    using a finite number of points. (Using more points will, of course, yield better
    approximations.)
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤9中，我们识别出了在图中峰值高于2000的两个频率的索引。这些索引对应的频率是3.984375和6.97265625，虽然它们与4和7不完全相同，但非常接近。造成这种差异的原因是我们使用有限数量的采样点来对连续信号进行采样。（使用更多的点当然会得到更好的近似值。）
- en: In step 11, we took the real part of the data returned from the inverse FFT.
    This is because, technically speaking, the FFT works with complex data. Since
    our data contained only real data, we expect that this new signal should also
    contain only real data. However, there will be some small errors made, meaning
    that the results are not totally real. We can remedy this by taking the real part
    of the inverse FFT. This is appropriate because we can see that the imaginary
    parts are very small.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤11中，我们取了逆FFT返回数据的实部。这是因为，从技术上讲，FFT处理的是复数数据。由于我们的数据仅包含实数数据，我们预计这个新信号也应该只包含实数数据。然而，由于某些小误差，结果并非完全是实数。我们可以通过取逆FFT的实部来解决这个问题。这是合适的，因为我们可以看到虚部非常小。
- en: We can see in *Figure 3**.9* that the filtered signal very closely matches the
    true signal, but not exactly. This is because, as mentioned previously, we are
    approximating a continuous signal with a relatively small sample.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 *图3.9* 中看到，经过滤波的信号与真实信号非常接近，但并不完全相同。这是因为，如前所述，我们正在用相对较小的样本来近似一个连续信号。
- en: There’s more...
  id: totrans-513
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: Signal processing in a production setting would probably make use of a specialized
    package, such as the `signal` module from `scipy`, or some lower-level code or
    hardware to perform filtering or cleaning of a signal. This recipe should be taken
    as more of a demonstration of the use of FFT as a tool for working with data sampled
    from some kind of underlying periodic structure (the signal). FFTs are useful
    for solving partial differential equations, such as the heat equation seen in
    the *Solving partial differential equations* *numerically* recipe.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产环境中，信号处理可能会使用专门的包，比如 `scipy` 中的 `signal` 模块，或者一些低级代码或硬件来执行信号的过滤或清理。这个示例更多是展示如何使用
    FFT 作为处理从某种周期性结构（即信号）中采样的数据的工具。FFT 在求解偏微分方程时非常有用，例如在 *数值解偏微分方程* 配方中看到的热方程。
- en: See also
  id: totrans-515
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: More information about random numbers and the normal distribution (Gaussian)
    can be found in [*Chapter 4*](B19085_04.xhtml#_idTextAnchor138), *Working with
    Randomness* *and Probability*.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 关于随机数和正态分布（高斯分布）的更多信息可以参考 [*第 4 章*](B19085_04.xhtml#_idTextAnchor138)，*随机性*
    和 *概率*。
- en: Automatic differentiation and calculus using JAX
  id: totrans-517
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 JAX 进行自动求导和微积分
- en: JAX is a linear algebra and automatic differentiation framework developed by
    Google for ML. It combines the capabilities of **Autograd** and its **Accelerated
    Linear Algebra** (**XLA**) optimizing compiler for linear algebra and ML. In particular,
    it allows us to easily construct complex functions, with automatic gradient computation,
    that can be run on **Graphics Processing Units** (**GPUs**) or **Tensor Processing
    Units** (**TPUs**). On top of all of this, it is relatively simple to use. In
    this recipe, we see how to make use of the JAX **just-in-time** (**JIT**) compiler,
    get the gradient of a function, and make use of different computation devices.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: JAX 是一个由 Google 开发的线性代数和自动求导框架，专为机器学习（ML）设计。它结合了 **Autograd** 和其 **加速线性代数**（**XLA**）优化编译器的功能，处理线性代数和机器学习。特别地，它允许我们轻松构建复杂的函数，自动计算梯度，并能在
    **图形处理单元**（**GPU**）或 **张量处理单元**（**TPU**）上运行。最重要的是，它相对易于使用。在本示例中，我们将看到如何利用 JAX
    的 **即时编译**（**JIT**）编译器，计算一个函数的梯度，并使用不同的计算设备。
- en: Getting ready
  id: totrans-519
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we need the JAX package installed. We will make use of the
    Matplotlib package, with the `pyplot` interface imported as `plt` as usual. Since
    we’re going to plot a function of two variables, we also need to import the `mplot3d`
    module from the `mpl_toolkits` package.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本示例，我们需要安装 JAX 包。我们将使用 Matplotlib 包，并像往常一样通过 `pyplot` 接口导入为 `plt`。由于我们要绘制一个二元函数，我们还需要从
    `mpl_toolkits` 包中导入 `mplot3d` 模块。
- en: How to do it…
  id: totrans-521
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现……
- en: 'The following steps show how to define a JIT-compiled function using JAX, compute
    the gradient of this function, and use a GPU or TPU to perform calculations:'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤展示了如何使用 JAX 定义一个 JIT 编译的函数，计算该函数的梯度，并使用 GPU 或 TPU 执行计算：
- en: 'First, we need to import the parts of the JAX library that we will use:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要导入我们将要使用的 JAX 库的部分模块：
- en: '[PRE173]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: 'Now, we can define our function, with the `@jit` decorator applied to tell
    JAX to JIT compile this function where necessary:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以定义我们的函数，并应用 `@jit` 装饰器，告诉 JAX 在必要时对这个函数进行 JIT 编译：
- en: '[PRE174]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: 'Next, we define a grid and plot our function:'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个网格并绘制我们的函数：
- en: '[PRE175]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: 'The resulting plot is shown in *Figure 3**.10*:'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 结果图如 *图 3.10* 所示：
- en: '![Figure 3.10 – Plot of a function of two variables computed using JAX'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.10 – 使用 JAX 计算的二元函数图]'
- en: '](img/3.10.jpg)'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/3.10.jpg)'
- en: Figure 3.10 – Plot of a function of two variables computed using JAX
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.10 – 使用 JAX 计算的二元函数图
- en: 'Now, we use the `grad` function (and the `jit` decorator) to define two new
    functions that are the partial derivatives with respect to the first and second
    arguments:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们使用 `grad` 函数（以及 `jit` 装饰器）来定义两个新函数，分别是相对于第一个和第二个参数的偏导数：
- en: '[PRE176]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: 'To quickly check that these functions are working, we print the values of these
    functions at ![](img/Formula_03_255.png):'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 为了快速检查这些函数是否正常工作，我们在 ![](img/Formula_03_255.png) 处打印这些函数的值：
- en: '[PRE177]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: 'To finish off, let’s plot the partial derivative with respect to ![](img/Formula_03_256.png):'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们绘制相对于 ![](img/Formula_03_256.png) 的偏导数：
- en: '[PRE178]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: 'The partial derivative plot is shown in *Figure 3**.11*:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 偏导数图如 *图 3.11* 所示：
- en: '![Figure 3.11 – Plot of the partial derivative of the function computed using
    autodiff in JAX'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.11 – 使用 JAX 自动求导计算的偏导数图]'
- en: '](img/3.11.jpg)'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/3.11.jpg)'
- en: Figure 3.11 – Plot of the partial derivative of the function computed using
    autodiff in JAX
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.11 – 使用 JAX 中的自动微分计算的函数的偏导数图
- en: A quick check confirms that this is indeed a plot of the partial derivative
    with respect to ![](img/Formula_03_256.png) of the function ![](img/Formula_03_258.png).
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 快速检查确认，这确实是函数相对于 ![](img/Formula_03_256.png) 的偏导数的图。
- en: How it works…
  id: totrans-544
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: JAX is an interesting mix of a JIT compiler, with an emphasis on fast linear
    algebra operations, combined with the power of Autograd, with support for acceleration
    devices (and several other features that we don’t use here). The JIT compilation
    works by tracing the linear algebra operations performed on the JAX version of
    the NumPy library and constructing an intermediate representation of the function
    in a form that can be understood by the XLA compiler. For any of this to work,
    you need to make sure that you only use the NumPy module from JAX (`jax.numpy`)
    rather than the *real* NumPy. JAX also provides a version of the SciPy package.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: JAX 是一个有趣的组合，结合了 JIT 编译器，专注于快速的线性代数操作，以及 Autograd 的强大功能，支持加速设备（以及我们这里没有使用的其他功能）。JIT
    编译通过跟踪 JAX 版本的 NumPy 库上执行的线性代数操作，并构建一个可以被 XLA 编译器理解的函数的中间表示来工作。为了让这一切工作，你需要确保只使用
    JAX 提供的 NumPy 模块（`jax.numpy`），而不是*真正的* NumPy。JAX 还提供了 SciPy 包的版本。
- en: 'One caveat of this approach is that the functions must be *pure*: they should
    not have side effects beyond the return value, and should not depend on any data
    not passed by arguments. It might still work if this is not the case, but you
    might get unexpected results—remember that the Python version of the function
    might only be executed once. Something else to consider is that, unlike NumPy
    arrays, JAX NumPy arrays cannot be updated in place using index notation and assignment.
    This, and several other current important caveats, are listed in the JAX documentation
    (refer to the following section, *See also…*).'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的一个警告是，函数必须是*纯粹的*：它们不应该有超出返回值的副作用，并且不应依赖于任何未通过参数传递的数据。如果情况不是这样，它可能仍然有效，但你可能会得到意想不到的结果——记住，Python版本的函数可能只会执行一次。另一个需要考虑的因素是，与NumPy数组不同，JAX
    NumPy数组不能使用索引表示法和赋值进行就地更新。这个问题，以及其他几个当前重要的警告，都列在了JAX文档中（请参考以下部分，*另见...*）。
- en: The `jit` decorator instructs JAX to construct compiled versions of the function
    where appropriate. It might actually produce several compiled versions depending
    on the types of arguments provided (for example, a different compiled function
    for scalar values versus array values).
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: '`jit` 装饰器指示 JAX 在适当的地方构建函数的编译版本。实际上，它可能会根据提供的参数类型生成多个编译版本（例如，针对标量值与数组值的不同编译函数）。'
- en: The `grad` function takes a function and produces a new function that computes
    the derivative with respect to the input variable. If the function has more than
    one input variable, then this is the partial derivative with respect to the first
    argument. The second optional argument, `argnums`, is used to specify which derivatives
    to compute. In the recipe, we have a function of two variables and used the `grad(f,
    0)` and `grad(f, 1)` commands to get the functions representing the two partial
    derivatives of the `f` function.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: '`grad` 函数接受一个函数并生成一个新函数，该函数计算相对于输入变量的导数。如果函数有多个输入变量，则这是相对于第一个参数的偏导数。第二个可选参数
    `argnums` 用于指定计算哪些导数。在本例中，我们有一个两变量函数，并使用了 `grad(f, 0)` 和 `grad(f, 1)` 命令来获取表示
    `f` 函数两个偏导数的函数。'
- en: Most of the functions from `jax.numpy` have the same interface as from `numpy`—we
    see a few of these functions in the recipe. The difference is that JAX versions
    produce arrays that are stored correctly for the accelerator device if one is
    used. We can use these arrays in contexts that expect NumPy arrays, such as plotting
    functions, without any issues.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: '`jax.numpy` 中的大多数函数与 `numpy` 中的接口相同——我们在本例中看到了一些这样的函数。不同之处在于，JAX 版本会根据使用的加速器设备正确地存储数组。如果使用
    NumPy 数组的上下文，例如绘图函数，我们可以毫无问题地使用这些数组。'
- en: In step 5 of the recipe, we printed the value of the two partial derivatives.
    Notice that we used the values `1.` and `-1.`. It is important to note that using
    the integer equivalent `1` and `-1` would have failed because of the way JAX handles
    floating-point numbers. (Since most GPU devices do not handle double-precision
    floating-point numbers well, the default float type in JAX is `float32`.)
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例的第5步中，我们打印了两个偏导数的值。请注意，我们使用了`1.`和`-1.`的值。重要的是要注意，使用整数等价物`1`和`-1`会失败，因为JAX处理浮点数的方式。（由于大多数GPU设备不善于处理双精度浮点数，JAX中的默认浮点类型是`float32`。）
- en: In step 6, we computed the derivative over the same region as the function.
    To do this, we had to flatten the ![](img/Formula_03_259.png) and ![](img/Formula_03_260.png)
    arrays and then use the `vmap` function to vectorize the `fx` derivative before
    reshaping the result. There is a complication in the way that `grad` works, which
    means that `fx` does not vectorize in the way we expect.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 在第6步中，我们在与函数相同的区域上计算了导数。为此，我们必须将![](img/Formula_03_259.png)和![](img/Formula_03_260.png)数组展平，然后使用`vmap`函数对`fx`导数进行向量化，最后对结果进行重塑。`grad`的工作方式存在一个复杂性，这意味着`fx`不会以我们预期的方式进行向量化。
- en: There’s more…
  id: totrans-552
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: JAX is designed to scale well as needs change, so lots of the components are
    designed with concurrency in mind. For instance, the random numbers module provides
    a random number generator that is capable of splitting effectively so that computations
    can run concurrently without changing the outcome. This wouldn’t be possible,
    for example, with a Mersenne Twister random generator, which would potentially
    produce different answers depending on the number of threads used because it doesn’t
    *split* in a statistically sound way.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: JAX的设计考虑到需求变化时能够良好扩展，因此许多组件在设计时考虑了并发性。例如，随机数模块提供了一个能够有效分裂的随机数生成器，这样计算可以并发执行，而不会改变结果。例如，使用Mersenne
    Twister随机数生成器就无法实现这一点，因为它在统计上不可靠地*分裂*，并且可能会因为线程数量的不同而产生不同的结果。
- en: See also
  id: totrans-554
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: 'Lots more information can be found in the JAX documentation:'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息可以在JAX文档中找到：
- en: '[https://jax.readthedocs.io/en/latest/](https://jax.readthedocs.io/en/latest/)'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://jax.readthedocs.io/en/latest/](https://jax.readthedocs.io/en/latest/)'
- en: Solving differential equations using JAX
  id: totrans-557
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JAX求解微分方程
- en: JAX provides a set of tools for solving a wide array of problems. Solving differential
    equations—such as initial value problems described in the *Solving simple differential
    equations numerically* recipe—should be well within the capabilities of this library.
    The `diffrax` package provides various solvers for differential equations leveraging
    the power and convenience of JAX.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: JAX提供了一套用于解决广泛问题的工具。求解微分方程——如在*数值求解简单微分方程*一节中描述的初值问题——应该完全在该库的能力范围之内。`diffrax`包提供了多种微分方程求解器，利用了JAX的强大功能和便利性。
- en: 'In the earlier recipe, we solved a relatively simple first-order ODE. In this
    recipe, we’re going to solve a second-order ODE to illustrate the technique. A
    **second-order ODE** is a differential equation that involves both the first and
    second derivatives of a function. To keep things simple, we’re going to solve
    a *linear* second-order ODE of the following form:'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们解决了一个相对简单的一阶常微分方程。在本例中，我们将解决一个二阶常微分方程，以展示该技巧。**二阶常微分方程**是涉及一个函数的一级和二级导数的微分方程。为了简单起见，我们将求解以下形式的*线性*二阶常微分方程：
- en: '![](img/Formula_03_261.jpg)'
  id: totrans-560
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_03_261.jpg)'
- en: 'Here, ![](img/Formula_03_262.png) is a function of ![](img/Formula_03_263.png)
    to be found. In particular, we’re going to solve the following equation:'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，![](img/Formula_03_262.png)是待求解的![](img/Formula_03_263.png)的函数。特别地，我们将求解以下方程：
- en: '![](img/Formula_03_264.jpg)'
  id: totrans-562
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_03_264.jpg)'
- en: The initial conditions are ![](img/Formula_03_265.png) and ![](img/Formula_03_266.png).
    (Note that this is a second-order differential equation, so we need two initial
    conditions.)
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 初始条件是![](img/Formula_03_265.png)和![](img/Formula_03_266.png)。（请注意，这是一个二阶微分方程，因此我们需要两个初始条件。）
- en: Getting ready
  id: totrans-564
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'Before we can start to solve this equation, we need to do some pen-and-paper
    work to reduce the second-order equation to a system of first-order differential
    equations that can be solved numerically. To do this, we make a substitution ![](img/Formula_03_267.png)
    and ![](img/Formula_03_268.png). When we do this, we get a system like this:'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始求解方程之前，我们需要做一些纸上工作，将二阶方程化简为可以数值求解的一阶微分方程组。为此，我们做了替代，得到了 ![](img/Formula_03_267.png)
    和 ![](img/Formula_03_268.png)。通过这个替代，我们得到了如下的系统：
- en: '![](img/Formula_03_269.jpg)'
  id: totrans-566
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_03_269.jpg)'
- en: We also get the initial conditions ![](img/Formula_03_270.png) and ![](img/Formula_03_271.png).
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还得到初始条件 ![](img/Formula_03_270.png) 和 ![](img/Formula_03_271.png)。
- en: For this recipe, we will need the `diffrax` package installed, along with JAX.
    As usual, we import the Matplotlib `pyplot` interface under the alias `plt`. We
    import `jax.numpy` under the alias `jnp` and the `diffrax` package.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们需要安装 `diffrax` 包和 JAX。如往常一样，我们将 Matplotlib 的 `pyplot` 接口导入并指定别名为 `plt`。我们将
    `jax.numpy` 导入并指定别名为 `jnp`，并导入 `diffrax` 包。
- en: How to do it…
  id: totrans-569
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现…
- en: 'The following steps show how to use JAX and the `diffrax` library to solve
    a second-order linear differential equation:'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤展示了如何使用 JAX 和 `diffrax` 库来求解二阶线性微分方程：
- en: 'First, we need to set up our function that represents the system of first-order
    ODEs we constructed in the *Getting* *ready* section:'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要设置代表我们在 *准备工作* 部分中构建的常微分方程组的函数：
- en: '[PRE179]'
  id: totrans-572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: 'Next, we set up the `diffrax` environment that we will use to solve the equation.
    We’ll use the solver recommended in the `diffrax` *quickstart guide* – see the
    *See also* section below for more details. The setup is as follows:'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们设置了将用于求解方程的 `diffrax` 环境。我们将使用 `diffrax` *快速入门指南* 中推荐的求解器 —— 详细内容请参见下面的
    *另见* 部分。设置如下：
- en: '[PRE180]'
  id: totrans-574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: 'Now, we use the `diffeqsolve` routine from `diffrax` to solve the differential
    equation on the range ![](img/Formula_03_272.png):'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们使用 `diffrax` 中的 `diffeqsolve` 例程来求解区间 ![](img/Formula_03_272.png) 上的微分方程：
- en: '[PRE181]'
  id: totrans-576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: 'Now we have solved the equation, we need to extract the values for ![](img/Formula_03_273.png)
    from the `solution` object:'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经求解了方程，接下来需要从 `solution` 对象中提取 ![](img/Formula_03_273.png) 的值：
- en: '[PRE182]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: 'Finally, we plot the results on a new figure:'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将在新图中绘制结果：
- en: '[PRE183]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: 'The resulting plot is shown in *Figure 3**.12*:'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 结果图示如 *图 3**.12* 所示：
- en: '![Figure 3.12 – Numerical solution to a second-order linear ODE'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.12 – 二阶线性常微分方程的数值解'
- en: '](img/3.12.jpg)'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/3.12.jpg)'
- en: Figure 3.12 – Numerical solution to a second-order linear ODE
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.12 – 二阶线性常微分方程的数值解
- en: We can see that when ![](img/Formula_03_274.png) is close to ![](img/Formula_03_275.png),
    the solution is approximately linear, but later on, the solution becomes non-linear.
    (The ![](img/Formula_03_274.png) range might be too small to see the interesting
    behavior of this system.)
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，当 ![](img/Formula_03_274.png) 接近 ![](img/Formula_03_275.png) 时，解大致是线性的，但之后解变得非线性。（![](img/Formula_03_274.png)
    范围可能太小，无法看到该系统的有趣行为。）
- en: How it works…
  id: totrans-586
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: '`diffrax` is built on top of JAX and provides various solvers for differential
    equations. In the recipe, we used the Dormand-Prince 5(4) `Dopri5` solver class,
    which is another example of a Runge-Kutta method for solving ODEs similar to the
    Runge-Kutta-Fehlberg method we saw in an earlier recipe.'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: '`diffrax` 是建立在 JAX 之上的，并提供了多种微分方程求解器。在这个示例中，我们使用了 Dormand-Prince 5(4) `Dopri5`
    求解器类，这是另一种求解常微分方程的 Runge-Kutta 方法，类似于我们在早期示例中看到的 Runge-Kutta-Fehlberg 方法。'
- en: Behind the scenes, `diffrax` translates the ODE initial value problem into a
    `diffrax` able to solve other kinds of differential equations besides these simple
    ODEs shown here; one of the goals of the library is to provide tools for numerically
    solving **stochastic differential equations** (**SDEs**). Since it is based on
    JAX, it should be easy to integrate this into other JAX workflows. It also has
    support for backpropagation through various adjoint methods.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，`diffrax` 将常微分方程的初值问题转换为一个 `diffrax`，能够求解除这些简单常微分方程之外的其他类型的微分方程；该库的目标之一是为数值求解
    **随机微分方程**（**SDEs**）提供工具。由于它是基于 JAX 的，应该很容易将其集成到其他 JAX 工作流中。它还支持通过各种伴随方法进行反向传播。
- en: See also
  id: totrans-589
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: 'More information about the `diffrax` library and the methods it contains can
    be found in the documentation:'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于 `diffrax` 库及其所包含方法的信息可以在文档中找到：
- en: '[https://docs.kidger.site/diffrax](https://docs.kidger.site/diffrax'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.kidger.site/diffrax](https://docs.kidger.site/diffrax)'
- en: )
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: Further reading
  id: totrans-593
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Calculus is a very important part of every undergraduate mathematics course.
    There are a number of excellent textbooks on calculus, including the classic textbook
    by Spivak and the more comprehensive course by Adams and Essex:'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 微积分是每个本科数学课程中非常重要的一部分。有许多优秀的微积分教材，包括Spivak的经典教材和Adams与Essex的更全面的课程：
- en: '*Spivak, M.* (*2006*). *Calculus*. *3rd ed*. *Cambridge: Cambridge* *University
    Press*.'
  id: totrans-595
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Spivak, M.* (*2006*)。*微积分*。*第3版*。*剑桥：剑桥大学出版社*。'
- en: '*Adams, R.* and *Essex, C.* (*2018*). *Calculus: A Complete Course*. *9th ed*.
    *Don Mills,* *Ont: Pearson*.'
  id: totrans-596
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Adams, R.* 和 *Essex, C.* (*2018*)。*微积分：完整课程*。*第9版*。*加拿大安大略省唐米尔斯：皮尔逊出版社*。'
- en: 'A good source for numerical differentiation and integration is the classic
    *Numerical Recipes* book, which gives a comprehensive description of how to solve
    many computational problems in C++, including a summary of the theory:'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的数值微分和积分的来源是经典的*数值计算法*一书，它全面描述了如何在C++中解决许多计算问题，并总结了相关理论：
- en: '*Press, W.*, *Teukolsky, S.*, *Vetterling, W*. and *Flannery, B.* (*2007*).
    *Numerical Recipes: The Art of Scientific Computing*. *3rd ed*. *Cambridge: Cambridge*
    *University Press*.'
  id: totrans-598
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Press, W.*, *Teukolsky, S.*, *Vetterling, W* 和 *Flannery, B.* (*2007*)。*数值计算法：科学计算的艺术*。*第3版*。*剑桥：剑桥大学出版社*。'
