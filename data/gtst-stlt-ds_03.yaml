- en: '*Chapter 2*: Uploading, Downloading, and Manipulating Data'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第2章*：上传、下载和操作数据'
- en: So far in this book, we have exclusively used simulated data in our Streamlit
    apps. This was useful for getting a good background in some of the basics of Streamlit,
    but most data science is not done on simulated data, but on real-world datasets
    that data scientists already have, or on datasets provided by users.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本书中的Streamlit应用程序一直使用的是模拟数据。这对于掌握一些Streamlit基础知识非常有用，但大多数数据科学工作并非在模拟数据上进行，而是基于数据科学家已经拥有的实际数据集，或者用户提供的数据集。
- en: This chapter will focus on the world of data in Streamlit apps, covering everything
    you will need to know to bring datasets to life using Streamlit. We will cover
    data manipulation, using user imported data, flow control, debugging Streamlit
    apps, and speeding up our data applications using caching through an example dataset
    called Palmer's Penguins.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将重点讲解Streamlit应用中的数据世界，涵盖使用Streamlit将数据集变为活跃的所有必要知识。我们将讨论数据操作、使用用户导入的数据、流程控制、调试Streamlit应用以及通过缓存加速数据应用等内容，所有这些内容都将通过一个名为Palmer's
    Penguins的数据集进行演示。
- en: 'In particular, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们将涵盖以下主题：
- en: The setup – Palmer's Penguins
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置——Palmer's Penguins
- en: Debugging Streamlit apps
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试Streamlit应用程序
- en: Data manipulation in Streamlit
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Streamlit中进行数据操作
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, we will need to download the Palmer's Penguins dataset, which
    can be found at [https://github.com/tylerjrichards/streamlit_apps/blob/main/penguin_app/penguins.csv](https://github.com/tylerjrichards/streamlit_apps/blob/main/penguin_app/penguins.csv).
    The setup for this chapter, along with an explanation of the dataset, can be found
    in the following section.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，我们需要下载Palmer's Penguins数据集，可以通过以下链接找到：[https://github.com/tylerjrichards/streamlit_apps/blob/main/penguin_app/penguins.csv](https://github.com/tylerjrichards/streamlit_apps/blob/main/penguin_app/penguins.csv)。本章的设置和数据集的解释将在以下部分详细说明。
- en: The setup – Palmer's Penguins
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置——Palmer's Penguins
- en: For this chapter, we'll be using a delightful dataset about Arctic penguins
    that comes from the work of Dr. Kristen Gorman ([https://www.uaf.edu/cfos/people/faculty/detail/kristen-gorman.php](https://www.uaf.edu/cfos/people/faculty/detail/kristen-gorman.php))
    and the Palmer Station, Antarctica LTER ([https://pal.lternet.edu/](https://pal.lternet.edu/)).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，我们将使用一个关于北极企鹅的数据集，该数据集来自Kristen Gorman博士的研究工作（[https://www.uaf.edu/cfos/people/faculty/detail/kristen-gorman.php](https://www.uaf.edu/cfos/people/faculty/detail/kristen-gorman.php)）以及南极洲Palmer站LTER项目（[https://pal.lternet.edu/](https://pal.lternet.edu/)）。
- en: Dataset acknowledgment
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 数据集致谢
- en: Data from the Palmer LTER data repository was supported by the Office of Polar
    Programs, NSF Grants OPP-9011927, OPP-9632763, and OPP-0217282.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 来自Palmer LTER数据仓库的数据由极地项目办公室（NSF Grants OPP-9011927, OPP-9632763, OPP-0217282）支持。
- en: This data is a common alternative to the famous Iris datasets and includes data
    on 344 individual penguins with 3 species represented. The data can be found in
    the GitHub repository for this book ([https://github.com/tylerjrichards/streamlit_apps](https://github.com/tylerjrichards/streamlit_apps)),
    in the `penguin_app` folder entitled `penguins.csv`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 该数据集是著名的鸢尾花数据集的常见替代品，包含344只个体企鹅的数据，涉及3个物种。数据可以在本书的GitHub仓库中找到（[https://github.com/tylerjrichards/streamlit_apps](https://github.com/tylerjrichards/streamlit_apps)），位于`penguin_app`文件夹下，文件名为`penguins.csv`。
- en: As we've discussed before, Streamlit apps run from inside our Python script.
    This sets the base directory to the location of the Python file with our Streamlit
    app, which means we can access any other files that we put in our app directory.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所讨论的，Streamlit应用程序是从我们的Python脚本中运行的。这将基准目录设置为Python文件所在的位置，也就是我们的Streamlit应用程序所在的位置，这意味着我们可以访问放在应用程序目录中的任何其他文件。
- en: 'First, let''s create a folder for our new app in our existing `streamlit_apps`
    folder using the following code block:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们在现有的`streamlit_apps`文件夹中创建一个新的文件夹，用于存放我们的应用程序，代码块如下：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'After this, download the data and put the resulting CSV file (named `penguins.csv`
    in the example) in the `penguin_app` folder. Now, our folder should have the `penguins.py`
    file and our `penguins.csv` file. For our first go around, we''re just going to
    print out the first five rows of our DataFrame using the `st.write()` function
    we learned earlier using the following code:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 下载数据后，将生成的CSV文件（示例中的文件名为`penguins.csv`）放入`penguin_app`文件夹中。现在，我们的文件夹中应该有`penguins.py`文件和`penguins.csv`文件。在第一次操作时，我们只需要使用之前学过的`st.write()`函数打印出数据框的前五行，代码如下：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The preceding code will produce the following Streamlit app when we run `streamlit
    run penguins.py` in the terminal:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码在我们终端运行 `streamlit run penguins.py` 时，会生成以下 Streamlit 应用：
- en: '![Figure 2.1 – The first five penguins'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.1 – 前五只企鹅'
- en: '](img/B16864_02_01.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16864_02_01.jpg)'
- en: Figure 2.1 – The first five penguins
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1 – 前五只企鹅
- en: Now that we have a good idea of what the data looks like, we will explore the
    dataset a bit more and then begin adding to our app.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对数据有了初步的了解，我们将进一步探索数据集，然后开始添加内容到我们的应用程序中。
- en: Exploring Palmer's Penguins
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索 Palmer's Penguins
- en: 'Before we begin working with this dataset, we should make some visualizations
    to better understand the data. As we saw before, we have many columns in this
    data, from the bill length to the flipper length, to the island the penguin lives
    on, to even the species of penguin. For our first visualization, we can see the
    flipper length by body mass for the three species:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始处理这个数据集之前，我们应该先做一些可视化，以便更好地理解数据。正如我们之前看到的，数据中有许多列，从喙长到鳍长，再到企鹅所在的岛屿，甚至是企鹅的物种。对于第一个可视化，我们可以看到三种物种的鳍长与体重之间的关系：
- en: '![Figure 2.2 – Flippers and weight'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.2 – 鳍和体重'
- en: '](img/B16864_02_02.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16864_02_02.jpg)'
- en: Figure 2.2 – Flippers and weight
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2 – 鳍和体重
- en: 'As we can see, the Gentoo species has a high flipper length and body mass,
    and it appears that flipper length is correlated with body mass for all species.
    Next, let''s look at the relationship between bill length and flipper length:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，Gentoo 物种的鳍长和体重都较高，并且似乎所有物种的鳍长都与体重相关。接下来，让我们看看喙长与鳍长之间的关系：
- en: '![Figure 2.3 – Flippers and bills'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.3 – 鳍和喙'
- en: '](img/B16864_02_03.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16864_02_03.jpg)'
- en: Figure 2.3 – Flippers and bills
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.3 – 鳍和喙
- en: From this graph, we can see that the Chinstrap species seem to have a longer
    bill than the Adelie species. There are many more combinations of variables that
    we could plot on a scatterplot, but could we instead make a data explorer Streamlit
    app do this for us?
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 从这张图表中，我们可以看到 Chinstrap 物种似乎有比 Adelie 物种更长的喙。我们还可以绘制更多变量组合的散点图，但我们能否创建一个数据探索
    Streamlit 应用来为我们完成这项工作？
- en: The final goal of this mini-app is going to be to ask the user to specify one
    of the species of penguins and to then also choose two other variables to use
    for a scatterplot. We'll start by learning how to take those inputs, and then
    create a dynamic visualization.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这个小应用的最终目标是让用户指定一种企鹅物种，并选择两个其他变量来用于绘制散点图。我们将从学习如何获取这些输入开始，然后创建动态可视化。
- en: 'The last user input that we learned about was the number input function, which
    won''t help us here. Streamlit has a select box function (`st.selectbox()`) that
    allows us to ask the user to select one option from multiple options (in our case,
    three options), and the function returns whatever the user selects. We will use
    this to get the three inputs for our scatterplot:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前学到的最后一个用户输入是数字输入函数，但在这里不会派上用场。Streamlit 有一个选择框函数（`st.selectbox()`），可以让我们让用户从多个选项中选择一个（在我们的例子中是三个选项），该函数返回用户选择的内容。我们将使用这个函数获取散点图所需的三个输入：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This code creates three new variables from three new select boxes that the
    user can input in our Streamlit app. The following screenshot shows the Streamlit
    app from the preceding code:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码从三个新的选择框中创建了三个新变量，用户可以在我们的 Streamlit 应用中输入这些变量。以下截图显示了上面代码所生成的 Streamlit
    应用：
- en: '![Figure 2.4 – User input on penguins'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.4 – 企鹅的用户输入'
- en: '](img/B16864_02_04.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16864_02_04.jpg)'
- en: Figure 2.4 – User input on penguins
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.4 – 企鹅的用户输入
- en: 'Now that we have the `selected_species` variable, we can filter our DataFrame
    and make a quick scatterplot using the selected `x` and `y` variables, as in this
    next block of code:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了 `selected_species` 变量，我们可以筛选 DataFrame，并使用选定的 `x` 和 `y` 变量快速绘制散点图，如下一个代码块所示：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This bit of preceding code adds to the previous example by loading our DataFrame,
    filtering by species, and then plotting in the same method from the previous chapter,
    which will result in the same app as before but with a scatterplot attached as
    well, as shown in the following screenshot:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码在前一个例子的基础上进行扩展，通过加载我们的 DataFrame、按物种筛选数据，然后使用上一章相同的方法绘制图表，最终将生成一个与之前相同的应用，但附加了散点图，如下图所示：
- en: '![Figure 2.5 – First penguins scatterplot'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.5 – 第一张企鹅散点图'
- en: '](img/B16864_02_05.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16864_02_05.jpg)'
- en: Figure 2.5 – First penguins scatterplot
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.5 – 第一张企鹅散点图
- en: 'Try to play around with this app and make sure that all the inputs and outputs
    are working correctly. Also notice that we''ve used the input variables to set
    out *x* axis and *y* axis labels, which means that those will update automatically
    when we make any new selections. Our graph doesn''t explicitly show what species
    is being graphed, so let''s practice making dynamic text. The following adds dynamic
    text to our Streamlit app''s graph title with the `format()` function native to
    Python:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试操作这个应用程序，确保所有的输入和输出都正常工作。还要注意，我们使用了输入变量来设置 *x* 轴和 *y* 轴的标签，这意味着当我们做出任何新选择时，它们会自动更新。我们的图表没有明确显示正在绘制的物种，因此让我们练习制作动态文本。以下代码使用
    Python 本地的 `format()` 函数，为我们 Streamlit 应用的图表标题添加动态文本：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The preceding code adds the species to our scatterplot and results in the following
    Streamlit app:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码将物种添加到了我们的散点图中，产生了如下的 Streamlit 应用：
- en: '![Figure 2.6 – Dynamic graph titles'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.6 – 动态图表标题'
- en: '](img/B16864_02_06.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16864_02_06.jpg)'
- en: Figure 2.6 – Dynamic graph titles
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.6 – 动态图表标题
- en: 'This looks great! We can also graph each species by hue and shape, as we did
    in the introductory graphs earlier in this book. The following code does this,
    and also uses the Seaborn dark grid theme to stand out against Streamlit''s white
    background a bit better:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来很棒！我们还可以像本书前面的介绍图表一样，按物种的颜色和形状绘制图表。以下代码实现了这一点，并使用 Seaborn 的深色网格主题，以便更好地突出显示在
    Streamlit 的白色背景上：
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The following screenshot shows our new and improved Palmer''s Penguins app,
    which allows us to select *x* and *y* axes and plots a scatterplot for us with
    the species in a different hue and shape:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了我们新改进的 Palmer's Penguins 应用，它允许我们选择 *x* 和 *y* 轴，并为我们绘制一个散点图，不同的物种显示为不同的颜色和形状：
- en: '![Figure 2.7 – Screenshot with shapes'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.7 – 带形状的截图'
- en: '](img/B16864_02_07.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16864_02_07.jpg)'
- en: Figure 2.7 – Screenshot with shapes
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.7 – 带形状的截图
- en: Note
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You are likely looking at this application through a black and white screenshot,
    which will only show the shape difference.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能正在通过一张黑白截图查看这个应用程序，只有形状的差异会被显示。
- en: The last step for this app is to allow the user to upload their own data. What
    if we wanted the research team at any point to be able to upload their data to
    this app and see the graphed results? Or what if there were three research groups,
    all with their own unique data with different column names, that wanted to use
    a method that we created? We'll approach this problem one aspect at a time. First,
    how do we accept data from users?
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应用的最后一步是允许用户上传他们自己的数据。如果我们希望研究团队在任何时候都能上传数据到这个应用，并查看图形化的结果呢？或者如果有三个研究小组，每个小组都有自己独特的数据和不同的列名，而他们想使用我们创建的方法呢？我们将一步一步地解决这个问题。首先，我们如何接受用户的数据？
- en: Streamlit has a function called `file_uploader()` that allows users of the app
    to upload data up to 200 MB in size (as a default). It works just like the other
    interactive widgets we've used before, with one exception. Our default in an interactive
    widget-like select box is just the first value in our list, but it does not make
    sense to have a default uploaded file before the user actually interacts with
    the app! The default user uploaded file has a value of `None`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Streamlit 提供了一个叫做 `file_uploader()` 的函数，允许应用的用户上传最大 200 MB 的数据（默认值）。它的工作方式和我们之前使用过的其他交互式组件一样，有一个例外。我们交互式组件中的默认值通常是列表中的第一个值，但在用户没有与应用互动之前，默认上传的文件值是
    `None`，这显然是没有意义的！
- en: This begins to cover a very important concept in Streamlit development, which
    is flow control. Flow control can be understood as thinking carefully through
    all the steps of your application because Streamlit will try to run the entire
    app at once if we're not explicit about things, such as wanting to wait until
    the user has uploaded a file to attempt to create a graphic or manipulate a DataFrame.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这开始涵盖 Streamlit 开发中的一个非常重要的概念——流程控制。流程控制可以理解为仔细思考应用程序的所有步骤，因为如果我们不明确指定某些事项，Streamlit
    会尝试一次性运行整个应用程序。例如，想要等待用户上传文件后再尝试创建图表或操作 DataFrame 时，就需要特别注意。
- en: Flow control in Streamlit
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Streamlit 中的流程控制
- en: 'As we talked about before, there are two solutions to this data upload default
    problem. We can provide a default file to use until the user interacts with the
    application, or we can stop the app until a file is uploaded. Let''s start with
    the first option. The following code uses the `st.file_uploader()` function from
    within an `if` statement. If the user uploads a file, then the app uses that;
    if they do not, then we default to the file we have used before:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所讨论的，对于数据上传的默认问题，有两种解决方案。我们可以提供一个默认文件，直到用户与应用程序进行交互，或者我们可以暂停应用程序，直到上传文件。我们从第一个选项开始。以下代码在`if`语句中使用了`st.file_uploader()`函数。如果用户上传文件，应用程序使用该文件；如果没有上传文件，则使用我们之前使用的默认文件：
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'When we run the preceding code in our terminal, we see our three user inputs
    (the *x* axis, the *y* axis, and the dataset), and also the graph even if we have
    yet to upload a file. The following screenshot shows this app:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在终端中运行前面的代码时，我们可以看到我们的三个用户输入（*x*轴，*y*轴和数据集），即使我们尚未上传文件，也会显示图形。以下截图展示了这个应用程序：
- en: '![Figure 2.8 – File input'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.8 – 文件输入'
- en: '](img/B16864_02_08.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16864_02_08.jpg)'
- en: Figure 2.8 – File input
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.8 – 文件输入
- en: The clear advantage of this approach is that there are always results shown
    in this application, but the results may not be useful to the user! For larger
    applications, this is a subpar solution as well because any data stored inside
    the app, regardless of use, is going to slow the application down. Later, in [*Chapter
    7*](B16864_07_Final_VK_ePub.xhtml#_idTextAnchor074), *Exploring Streamlit Components*,
    we'll discuss all of our options for deployment, including a built-in deployment
    option called Streamlit Sharing.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的明显优势在于该应用程序始终显示结果，但这些结果可能对用户没有帮助！对于更大的应用程序来说，这也是一个次优解，因为无论是否使用，应用程序内存储的任何数据都会拖慢应用程序的速度。稍后，在[*第7章*](B16864_07_Final_VK_ePub.xhtml#_idTextAnchor074)，“*探索Streamlit组件*”中，我们将讨论所有的部署选项，包括一个名为Streamlit
    Sharing的内置部署选项。
- en: 'Our second option is to stop the application entirely unless the user has uploaded
    a file. For that option, we''re going to use a new Streamlit function called `stop()`,
    which (predictably) stops the flow whenever it is called. It is best practice
    to use this to find errors in the app and to encourage the user to make some change
    or describe the error that is happening. This is not necessary for us but is a
    good thing to know for future applications. The following code uses an `if-else`
    statement with `st.stop()` in the `else` statement to prevent the entire app from
    running when `st.file_uploader()` is unused:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第二个选项是完全停止应用程序，除非用户上传了文件。对于这个选项，我们将使用一个新的Streamlit函数，名为`stop()`，该函数（如预期的那样）在被调用时停止应用程序的流程。使用这个函数是调试应用程序的最佳实践，它可以鼓励用户做出一些改变或描述发生的错误。虽然对于我们来说并非必须，但这对于未来的应用程序来说是一个很有用的知识。以下代码使用`if-else`语句，并在`else`语句中使用`st.stop()`来防止在`st.file_uploader()`未使用时，整个应用程序运行：
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As we can see with the following screenshot, until we upload our own data,
    we will not see a scatterplot, and the application stops. The Streamlit app simply
    waits to run fully until the user has uploaded their file instead of throwing
    an error:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下截图所示，直到我们上传自己的数据，我们将无法看到散点图，并且应用程序会停止。Streamlit应用程序会等待，直到用户上传文件才会完全运行，而不是抛出错误：
- en: '![Figure 2.9 – Streamlit stop'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.9 – Streamlit停止'
- en: '](img/B16864_02_09.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16864_02_09.jpg)'
- en: Figure 2.9 – Streamlit stop
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.9 – Streamlit停止
- en: Before we move on to data manipulation and create more complicated Streamlit
    apps, we should touch on some best practices for debugging Streamlit apps.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续进行数据处理并创建更复杂的Streamlit应用程序之前，我们应该讨论一些调试Streamlit应用程序的最佳实践。
- en: Debugging Streamlit apps
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试Streamlit应用程序
- en: We broadly have two options for Streamlit development.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们大致有两种Streamlit开发的选择。
- en: Develop in Streamlit and `st.write()` as a debugger.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Streamlit中开发并使用`st.write()`作为调试工具。
- en: Explore in Jupyter and then copy to Streamlit.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Jupyter中进行探索，然后复制到Streamlit。
- en: Developing in Streamlit
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Streamlit中开发
- en: In the first option, we write our code directly in Streamlit as we're experimenting
    and exploring exactly what our application will do. We've basically been taking
    this option already, which works very well if we have less exploration work and
    more implementation work to do.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个选项中，我们直接在Streamlit中编写代码，进行实验并准确探索我们的应用程序将如何运行。如果我们有较少的探索工作和更多的实现工作，基本上我们已经采用了这个选项，这样非常有效。
- en: 'Pros:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 优点：
- en: What you see is what you get
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所见即所得
- en: No need to maintain both IPython and Python versions of the same app
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无需维护IPython和Python版本的相同应用程序
- en: Better experience for learning how to write production code
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更适合学习如何编写生产级代码
- en: 'Cons:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 缺点：
- en: A slower feedback loop (the entire app must run before feedback)
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 较慢的反馈循环（必须运行整个应用才能得到反馈）
- en: A potentially unfamiliar development environment
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能是一个不太熟悉的开发环境
- en: Exploring in Jupyter and then copying to Streamlit
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Jupyter 中进行探索然后复制到 Streamlit
- en: Another option is to utilize the extremely popular Jupyter data science product
    to write and test out the Streamlit app's code before placing it in the necessary
    script and formatting it correctly. This can be useful for exploring new methods
    that will live in the Streamlit app, but it has serious downsides.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种选择是利用极受欢迎的 Jupyter 数据科学产品，先编写并测试 Streamlit 应用的代码，然后再将其放入必要的脚本中并正确格式化。这对于探索将会在
    Streamlit 应用中使用的新方法非常有用，但也存在严重的缺点。
- en: 'Pros:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 优点：
- en: The lightning-fast feedback loop makes it easier to experiment.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 闪电般的快速反馈循环使得实验变得更加容易。
- en: Users may be more familiar with Jupyter.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户可能更熟悉 Jupyter。
- en: The full app does not have to be run to get results.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不需要运行完整应用就能得到结果。
- en: 'Cons:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 缺点：
- en: Jupyter may provide deceptive results if run out of order.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果顺序不对，Jupyter 可能会提供误导性的结果。
- en: '''Copying'' code over from Jupyter is time-consuming.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 Jupyter 中‘复制’代码是非常耗时的。
- en: Python versioning may be different between Jupyter and Streamlit.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jupyter 和 Streamlit 之间可能存在不同的 Python 版本。
- en: My recommendation here is to develop Streamlit apps inside the environment where
    they are going to be run (that is, a Python file). For debugging, heavily utilize
    the `st.write()` function, which can print out nearly any Python object (dictionary,
    DataFrame, list, string, number, graph, and so on) that you may need. Try to only
    use another development environment such as Jupyter as a last resort!
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我的建议是，在应用将要运行的环境中开发 Streamlit 应用（即 Python 文件）。对于调试，充分利用 `st.write()` 函数，它可以打印出几乎任何你可能需要的
    Python 对象（字典、DataFrame、列表、字符串、数字、图形等等）。尽量只在最后的情况下使用其他开发环境，如 Jupyter！
- en: Data manipulation in Streamlit
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Streamlit 中进行数据处理
- en: 'Streamlit runs our Python file from the top down as a script, and so we can
    perform data manipulation with powerful libraries such as pandas in the same way
    that we might in a Jupyter notebook or a regular Python script. As we''ve discussed
    before, we can do all our regular data manipulation as normal. For our Palmer''s
    Penguins app, what if we wanted the user to be able to filter out penguins based
    on their gender? The following code filters our DataFrame using pandas:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Streamlit 以脚本的方式从头到尾运行我们的 Python 文件，因此我们可以像在 Jupyter notebook 或常规 Python 脚本中那样，使用强大的库如
    pandas 来执行数据处理。正如我们之前所讨论的，我们可以像往常一样进行所有常规的数据处理。以我们 Palmer's Penguins 应用为例，如果我们希望用户能够根据性别筛选企鹅呢？以下代码通过
    pandas 筛选我们的 DataFrame：
- en: '[PRE8]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: A couple of things to note here. First, we've added another `selectbox` plugin,
    with male, female, and all options. We could have done this by asking for a text
    input, but for data manipulation, we want to restrict user action as much as possible.
    We also made sure to dynamically change the title, which is recommended for clarity
    as we want to show the user that the data has been filtered by their input directly
    in the graph.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有几点需要注意。首先，我们添加了另一个 `selectbox` 插件，提供了男性、女性和全部选项。我们本可以通过请求文本输入来实现这一点，但对于数据处理，我们希望尽量限制用户的操作。我们还确保动态更改了标题，这是为了清晰起见，建议这样做，因为我们希望通过图表直接向用户展示数据已经根据他们的输入进行了筛选。
- en: An introduction to caching
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缓存介绍
- en: As we create more computationally intensive Streamlit apps and begin to use
    and upload larger datasets, we should start worrying about the runtime of these
    apps and work to increase our efficiency whenever possible. The easiest way to
    make a Streamlit app more efficient is through caching, which is storing some
    results in memory so that the app does not repeat the same work whenever possible.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们创建更多计算密集型的 Streamlit 应用并开始使用和上传更大的数据集，我们应开始关注这些应用的运行时，并尽可能提高效率。提高 Streamlit
    应用效率最简单的方法是通过缓存，即将某些结果存储在内存中，以便在可能的情况下，应用不会重复执行相同的工作。
- en: A good analogy to an app's cache is a human's short-term memory, where we keep
    bits of information close at hand that we think might be useful. When something
    is in our short-term memory, we don't have to think very hard to get access to
    that piece of information. In the same way, when we cache a piece of information
    in Streamlit, we are making a bet that we'll use that information often.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序缓存的一个很好的类比是人类的短期记忆，我们会将一些可能有用的信息保存在身边。当某个信息在我们的短期记忆中时，我们不需要费力思考就能访问它。同样，当我们在
    Streamlit 中缓存某个信息时，我们就像是在打赌，我们会频繁使用该信息。
- en: The way Streamlit caching works more specifically is by storing the results
    of a function in our app, and if that function is called with the same parameters
    by another user (or by us if we rerun the app), Streamlit does not run the same
    function but instead loads the result of the function from memory.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Streamlit 缓存的具体工作原理是通过将函数的结果存储在应用程序中，如果该函数在应用程序中被另一个用户（或我们重新运行应用程序时）使用相同的参数调用，Streamlit
    并不会重新执行该函数，而是从内存中加载该函数的结果。
- en: Let's prove to ourselves that this works! First, we'll create a function for
    our data upload part of the Penguins app, and then use the time library to artificially
    make the function take much longer than it would normally and see whether we can
    make our app faster using `st.cache()`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们证明这一方法有效！首先，我们将为 Penguins 应用程序的数据上传部分创建一个函数，然后使用 time 库故意让这个函数的运行时间比平常长得多，看看是否能够通过使用
    `st.cache()` 来加速应用程序。
- en: 'As you can see in the following code, we first made a new function called `load_file()`,
    which waits 3 seconds, and then loads the file that we need. Normally we would
    not intentionally slow down our app, but we want to know whether caching works:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如下代码所示，我们首先创建了一个新的函数 `load_file()`，该函数等待 3 秒钟，然后加载所需的文件。通常我们不会故意让应用程序变慢，但我们想知道缓存是否有效：
- en: '[PRE9]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now, let's run this app and then select the hamburger icon in the top right
    and press the rerun button (we can also just press the *R* key to rerun).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们运行这个应用程序，然后选择右上角的汉堡菜单图标，按下重新运行按钮（我们也可以直接按 *R* 键来重新运行）。
- en: 'We notice that each time we rerun the app, it takes at least 3 seconds. Now,
    let''s add our cache decorator on top of the `load_file` function and run our
    app again:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们注意到，每次重新运行应用程序时，至少需要 3 秒钟。现在，让我们在 `load_file` 函数上方添加缓存装饰器，然后再次运行我们的应用程序：
- en: '[PRE10]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As we run the app a few times, we can notice that it is much faster! When we
    rerun the app, two things happen. First, Streamlit checks the cache to ascertain
    whether that same function with the same inputs has been run before and returns
    the Penguins data from memory, and second, it does not run the `load_file` function
    at all, meaning we never run the `time.sleep(3)` command and also never spend
    the time required to load the data into Streamlit. We'll explore this caching
    function in more detail, but this method will get us the majority of the efficiency
    gains.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们多次运行应用程序时，会注意到它明显变快了！当我们重新运行应用程序时，会发生两件事。首先，Streamlit 会检查缓存，确认是否曾经使用相同的输入运行过该函数，并从内存中返回
    Penguins 数据；其次，它不会再次运行 `load_file` 函数，这意味着我们从未运行过 `time.sleep(3)` 命令，也没有花时间将数据加载到
    Streamlit 中。我们将更详细地探讨这个缓存功能，但这个方法将为我们带来大部分的效率提升。
- en: Summary
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter was full of fundamental building blocks that we will use vigorously
    throughout the remainder of this book, and that you will use to develop your own
    Streamlit applications.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 本章充满了基础构件，这些构件将在本书的剩余部分中广泛使用，你也将用它们来开发自己的 Streamlit 应用程序。
- en: On data, we covered how to bring our own DataFrames into Streamlit and how to
    accept user input in the form of a data file that brings us past only being able
    to simulate data. On other skillsets, we learned how to use our cache to make
    our data apps faster, how to control the flow of our Streamlit apps, and how to
    debug our Streamlit apps using `st.write()`. That's it for this chapter. Next,
    we'll move on to data visualization!
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据部分，我们介绍了如何将自己的 DataFrame 导入 Streamlit，如何接受以数据文件形式的用户输入，这使我们不再只能模拟数据。在其他技能方面，我们学习了如何使用缓存让数据应用程序运行得更快，如何控制
    Streamlit 应用程序的流程，以及如何使用 `st.write()` 调试 Streamlit 应用程序。本章到此为止。接下来，我们将进入数据可视化部分！
