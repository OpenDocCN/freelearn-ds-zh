- en: Chapter 9. Developing the Bitonic Sort with OpenCL
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 9 章。使用 OpenCL 开发位序排序
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Understanding sorting networks
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解排序网络
- en: Understanding bitonic sorting
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解位序排序
- en: Developing bitonic sorting in OpenCL
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 OpenCL 中开发位序排序
- en: Introduction
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Sorting is one of the most important problems in computer science and the ability
    to sort large amounts of data efficiently is absolutely critical. Sorting algorithms
    were traditionally been implemented on CPUs and they work very well there, but
    on the flipside implementing them on GPUs can be challenging. In the OpenCL programming
    model, we have both task and data parallelism and getting a sorting algorithm
    to work on the OpenCL model can be challenging, but mostly from the algorithm
    point of view, that is, how to create an algorithm that takes advantage of the
    massive data and task parallelism that OpenCL offers.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 排序是计算机科学中最重要的问题之一，能够有效地对大量数据进行排序是绝对关键的。排序算法传统上在 CPU 上实现，并且在那里工作得很好，但另一方面，在 GPU
    上实现它们可能会很具挑战性。在 OpenCL 编程模型中，我们既有任务并行性也有数据并行性，让排序算法在 OpenCL 模型上工作可能会很具挑战性，但主要是从算法的角度来看，即如何创建一个利用
    OpenCL 提供的巨大数据量和任务并行性的算法。
- en: 'Sorting methods can largely be categorized into two types: data-driven and
    data-independent. Data-driven sorting algorithms execute the next step of the
    algorithm depending on the value of the key under consideration, for example,
    the QuickSort. Data-independent sorting algorithms is rigid from this perspective
    because they do not change the order of processing according to the values of
    the key, so in that sense it doesn''t behave like data-driven sorting algorithms.
    They can be implemented in GPUs to exploit the massive data and task parallelism
    it offers. Hence we are going to explore the bitonic sort, as it''s a classic
    example of data-independent sorting algorithm and we''ll see how it can be represented
    by sorting networks, and eventually how they can be implemented efficiently in
    OpenCL to execute on GPUs.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 排序方法可以大致分为两种类型：数据驱动和数据独立。数据驱动排序算法根据考虑的键值执行算法的下一步，例如快速排序。数据独立排序算法从这一角度来看是刚性的，因为它们不会根据键值改变处理顺序，因此从这个意义上讲，它们不像数据驱动排序算法。它们可以实现在
    GPU 上以利用它提供的海量数据和任务并行性。因此，我们将探讨位序排序，因为它是一个数据独立排序算法的经典例子，我们将看到它如何通过排序网络来表示，最终我们将看到它们如何在
    OpenCL 中高效实现以在 GPU 上执行。
- en: Note
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Ken Batcher invented bitonic sort in 1968\. And for n items it would have a
    size of ![Introduction](img/4520OT_09_16.jpg) and a depth of ![Introduction](img/4520OT_09_17.jpg).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Ken Batcher 在 1968 年发明了位序排序。对于 n 个项目，它的大小为 ![介绍](img/4520OT_09_16.jpg) ，深度为
    ![介绍](img/4520OT_09_17.jpg) 。
- en: The bitonic sort works effectively by comparing two elements at any point in
    time and what this means is that it consumes two inputs and decides whether a
    is equal to b, a is less than b, or a is greater than b, that is, the algorithm
    primarily operates on two elements, given an input. The bitonic sort is an example
    of a non-adaptive sorting algorithm.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 位序排序通过在任何时刻比较两个元素来有效地工作，这意味着它消耗两个输入并决定 a 是否等于 b，a 是否小于 b，或者 a 是否大于 b，即算法主要在两个元素上操作，给定一个输入。位序排序是非自适应排序算法的一个例子。
- en: Note
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A non-adaptive sorting algorithm is the one where the sequence of operations
    performed is independent of the order of the data also known as data-independent.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 非自适应排序算法是那些操作序列独立于数据顺序的算法，也称为数据独立。
- en: To give you a more concrete idea of what non-adaptive sorting methods are like,
    let's create a fictitious instruction `cmpxchg`, which has the semantics of comparing
    two elements and exchanging them when necessary. This is how it would look if
    we were to implement a compare-swap operation between two elements. In the following
    example, we illustrate the fact that non-adaptive methods are equivalent to straight
    line programs for sorting and they can be expressed as a list of compare-exchange
    operations to be performed.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让您更具体地了解非自适应排序方法是什么样的，让我们创建一个虚构的指令 `cmpxchg`，它具有比较两个元素并在必要时交换它们的语义。如果我们要在两个元素之间实现比较-交换操作，它看起来会是这样。在下面的示例中，我们说明了非自适应方法等同于排序的直线程序，并且它们可以用要执行的比较-交换操作的列表来表示。
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: For example, the preceding sequence is a straight line program for sorting three
    elements; and quite often the goal of developing such an algorithm is to define
    for each *n*, a fixed sequence of the `cmpxchg` operations that can sort any set
    of *n* keys. To put it in another way, the algorithm doesn't take into account
    whether the data to be sorted is sorted prior or partially sorted.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，前面的序列是排序三个元素的直线程序；而且，开发此类算法的目标通常是为每个 *n* 定义一个固定的 `cmpxchg` 操作序列，该序列可以排序任何
    *n* 个键的集合。换句话说，算法不考虑要排序的数据是否已经排序或部分排序。
- en: Understanding sorting networks
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解排序网络
- en: In the previous section, we looked at a non-adaptive sorting algorithm and what
    it's nature is in its fundamental form. In this section, let's look at a model
    frequently used to study non-adaptive sorting algorithms. Technical literature
    has called this model, the sorting network. This form of sorting is also known
    as comparator networks, and is the idea behind the bitonic sort.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们研究了非自适应排序算法及其在基本形式中的本质。在本节中，让我们看看一个常用于研究非自适应排序算法的模型。技术文献将此模型称为排序网络。这种排序形式也称为比较器网络，是位序排序背后的理念。
- en: Sorting networks are the simplest model for this study, as they represent an
    abstract machine which accesses the data only through compare-exchange operations,
    and it comprises of atomic compare-exchanges also known as comparators which are
    wired together to implement the capability of general sorting.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 排序网络是这种研究的最简单模型，因为它们代表了一个抽象机器，它只通过比较-交换操作访问数据，它由原子比较-交换（也称为比较器）组成，这些比较器被连接在一起以实现通用排序的能力。
- en: How to do it...
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'The following is an illustration for sorting four keys. By convention, we draw
    a sorting network for *n* items as a sequence of *n* horizontal lines, with comparators
    connecting a pair of lines. We also imagine that the keys to be sorted pass from
    right to left through the network, with a pair of numbers exchanged if necessary
    to put the smaller on the top whenever the comparator is encountered:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对排序四个键的说明。按照惯例，我们绘制一个排序网络，用于排序 *n* 个项目，作为 *n* 条水平线的序列，比较器连接一对线。我们还想象要排序的键从右到左通过网络，如果需要，在遇到比较器时交换一对数字，以将较小的数字放在顶部：
- en: '![How to do it...](img/4520OT_09_01.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![如何做到这一点...](img/4520OT_09_01.jpg)'
- en: From the preceding diagram, you will notice that the keys move from left to
    right on the lines in the network. The comparators that they encounter would exchange
    the keys if necessary and continually push the smaller key towards the top of
    this network. An astute reader will notice that no exchanges were done on the
    fourth comparator. This sorting network will sort any permutation of four keys.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的图中，你会注意到键在网络中的行上从左到右移动。它们遇到的比较器在必要时会交换键，并不断将较小的键推向这个网络的顶部。一个敏锐的读者会注意到第四个比较器上没有进行交换。这个排序网络可以排序四个键的任何排列。
- en: There are other sorting networks other than this and the following network also
    sorts the same input as before, but it takes two more compare-exchange operations
    as compared to the previous sorting network. It is interesting to study and that's
    why this is left as an exercise for you to research on your own.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这个网络之外，还有其他排序网络，以下网络也排序与之前相同的输入，但与之前的排序网络相比，它需要两个额外的比较-交换操作。这很有趣，因此这被留给你自己研究作为练习。
- en: '![How to do it...](img/4520OT_09_02.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![如何做到这一点...](img/4520OT_09_02.jpg)'
- en: How it works...
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它如何工作...
- en: 'This sorting network exhibits a particular property and that is as long as
    the comparators do not overlap, then we can actually conduct the compare-exchange
    operations in parallel. Next, we need to understand how we can exact parallelism
    from this by grouping what can be done in parallel and needs to be performed in
    the next stage. Here''s the sorting network that is optimal for sorting any four
    keys and we show the operations that can be conducted in parallel which are broken
    into three stages of sorting:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这个排序网络具有一个特定的特性，那就是只要比较器不重叠，我们实际上可以并行执行比较-交换操作。接下来，我们需要了解我们如何通过将可以并行执行并在下一阶段需要执行的操作分组来获得这种并行性。下面是用于排序任何四个键的最优排序网络，我们展示了可以并行进行的操作，这些操作被分为三个排序阶段：
- en: '![How it works...](img/4520OT_09_03.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![它如何工作...](img/4520OT_09_03.jpg)'
- en: Although it is not the most efficient, the earlier diagram illustrates a possible
    parallel sorting network for any four keys. In this parallel sorting network,
    we could potentially launch threads where it will conduct the compare-exchange
    operations in three stages, and the result is that the input is sorted.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这不是最有效的方法，但早期的图示展示了任何四个键的可能并行排序网络。在这个并行排序网络中，我们可能启动线程，在三个阶段进行比较交换操作，结果是输入被排序。
- en: Tip
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Notice that this sorting network for sorting four keys is optimal from a computational
    point of view, as it has only to perform five compare-exchange operations in three
    stages.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个排序四个键的排序网络从计算角度来看是最佳的，因为它只需要在三个阶段执行五个比较交换操作。
- en: Understanding bitonic sorting
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解正序排序
- en: Previously we have discussed sorting networks and it closely relates to bitonic
    sorting, because sorting networks are employed to implement non-adaptive sorting
    algorithms, for example, bitonic sort. In bitonic sorting, we basically have an
    input (defined elsewhere) that's a bitonic sequence. A bitonic sequence is one
    that monotonically increases (decreases), reaches a single maximum (minimum),
    and then monotonically decreases (increases). A sequence is considered bitonic
    if it can be made so by cyclically shifting the sequence.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 之前我们已经讨论了排序网络，它与正序排序密切相关，因为排序网络被用来实现非自适应排序算法，例如正序排序。在正序排序中，我们基本上有一个输入（在别处定义），它是一个正序序列。正序序列是一种单调增加（减少），达到一个单一的最大（最小）值，然后单调减少（增加）的序列。如果一个序列可以通过循环移位变成这样的序列，那么它被认为是正序的。
- en: In general, we consider a few scenarios for determining whether the input is
    suitable for sorting (after all processor cycles are precious and it is a good
    idea not to waste them doing needless work). In fact, when we wish to sort some
    input based on a particular sorting algorithm, we would always consider whether
    the input is already sorted based on our criteria. In the context of bitonic sorting,
    we could possibly receive a bitonic sequence, and what we do for that is apply
    what is known as a bitonic split sequence or an arbitrary sequence, in the case
    of an operation on the input sequence and keep doing this until we reach the final
    sorted state.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们会考虑几种情况来确定输入是否适合排序（毕竟处理器周期是宝贵的，不浪费它们做无谓的工作是个好主意）。事实上，当我们希望根据特定的排序算法对某些输入进行排序时，我们总是会考虑输入是否已经根据我们的标准排序。在正序排序的上下文中，我们可能会收到一个正序序列，对于这种情况，我们应用所谓的正序分割序列或任意序列，在输入序列上的操作，并一直这样做，直到我们达到最终的排序状态。
- en: Note
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A bitonic split is an operation on a bitonic sequence, such that if ![Understanding
    bitonic sorting](img/4520OT_09_15.jpg) the two elements are exchanged, ![Understanding
    bitonic sorting](img/4520OT_09_18.jpg) and the operation produces two bitonic
    sequences A and B, such that the elements in A are less than the elements in B.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 正序分割是对正序序列的操作，如果![理解正序排序](img/4520OT_09_15.jpg)这两个元素被交换，![理解正序排序](img/4520OT_09_18.jpg)并且操作产生了两个正序序列A和B，使得A中的元素小于B中的元素。
- en: How to do it...
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The diagram shows how two bitonic sequences (at the top of the diagram) can
    be conceptually combined to a larger sequence (at the bottom of the diagram) by
    repeated application of this sorting algorithm:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 该图展示了如何通过重复应用此排序算法，将两个正序序列（图的上部）概念性地组合成一个更大的序列（图的底部）：
- en: '![How to do it...](img/4520OT_09_04.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/4520OT_09_04.jpg)'
- en: 'In the situation where we receive an arbitrary sequence, that is, unsorted
    and not in bitonic order, we have to basically produce a bitonic sequence from
    this unsorted input and then apply the same trick as before using the bitonic
    splits until we reach the final sorted state. The following diagram illustrates
    how a bitonic split or merge (as it''s often called) operates on separate sequences
    and produces the final sorted sequence either in ascending or descending order:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们收到一个任意序列的情况下，即未排序且不是正序的情况下，我们必须基本上从这个未排序的输入中产生一个正序序列，然后应用之前相同的技巧，使用正序分割直到我们达到最终的排序状态。以下图示说明了正序分割或合并（通常称为合并）如何作用于单独的序列，并产生最终排序序列，无论是升序还是降序：
- en: '![How to do it...](img/4520OT_09_05.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/4520OT_09_05.jpg)'
- en: In either case, we will know when to terminate if the split sizes have reached
    two, because at this point, it's a comparison operation between a and b, where
    either a is greater than or equal to b or b is greater than or equal to a. And
    it holds and depending on the sorting order, we will place them into their appropriate
    position in the output.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，如果分割大小达到了两个，我们就知道何时终止，因为在这个点上，它是 a 和 b 之间的比较操作，其中 a 大于或等于 b 或 b 大于或等于
    a。这成立，并且根据排序顺序，我们将它们放置在输出中的适当位置。
- en: 'Bitonic Sorting uses a principle created by Donald Knuth and it''s known as
    the Knuth''s 0/1 principle, which is: If a sorting algorithm that performs only
    element comparisons and exchanges on all sequences of zeros and ones, and then
    it sorts all sequences of arbitrary numbers.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 位序排序使用 Donald Knuth 创建的原则，被称为 Knuth 的 0/1 原则，即：如果一个排序算法只对所有零和一的序列执行元素比较和交换，然后它对所有的任意数字序列进行排序。
- en: Before we proceed to develop the bitonic sort algorithm using OpenCL, it's proper
    that we only introduce it through its sequential form from which we can begin
    to look for opportunities for parallelism.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们使用 OpenCL 开发位序排序算法之前，适当地只通过其顺序形式介绍它是合适的，这样我们可以开始寻找并行化的机会。
- en: 'The following code snippet is from `src/Ch9/BitonicSort_CPU_02/BitonicSort.c`
    and the relevant portions of the code are shown. This implementation is a translation
    of Batcher''s algorithm, that for illustration purpose is a recursive one and
    looks like this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段来自`src/Ch9/BitonicSort_CPU_02/BitonicSort.c`，并显示了相关的代码部分。这个实现是 Batcher
    算法的翻译，为了说明目的，它是一个递归的，看起来像这样：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This recursive program works is by repeatedly splitting its original input
    by half and it proceeds to sort each of the halves and merges those halves into
    bigger segments. This process is continued until the segment reaches the original
    size. Notice that it uses two other supporting functions to accomplish this and
    they''re called `shuffle` and `unshuffle`. They work similarly to the same functions
    in OpenCL (which isn''t a wonder because the same functions in OpenCL drew inspiration
    from them). Here are those functions:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这个递归程序通过反复将其原始输入分成一半，然后对每一半进行排序并将这些半部分合并成更大的段来工作。这个过程一直持续到段达到原始大小。请注意，它使用另外两个辅助函数来完成这项任务，它们被称为`shuffle`和`unshuffle`。它们的工作方式与
    OpenCL 中的相同函数类似（这并不奇怪，因为 OpenCL 中的相同函数受到了它们的启发）。以下是这些函数：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'And what they do is this: shuffling actually splits the input into halves again
    and picks each element from each half and place them side-by-side until it reaches
    the end of both halves. Unshuffling does exactly the opposite by removing those
    elements and placing them into their original positions and for those algorithm
    geeks in you, you would recognize that this is the program implementation of the
    top-down mergesort algorithm and belongs to the class of algorithms that uses
    the divide-and-conquer approach. As a refresher, an illustration is shown in the
    *How it works…* section of this recipe, which depicts how both shuffling and un-shuffling
    works in this algorithm.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 它们的操作是这样的：洗牌实际上再次将输入分成两半，并从每一半中选取每个元素并将它们并排放置，直到达到两半的末尾。逆洗牌则正好相反，通过移除这些元素并将它们放回它们原来的位置。对于那些算法爱好者来说，你会认识到这是自顶向下的归并排序算法的程序实现，属于使用分治方法的算法类别。作为一个复习，本食谱的*如何工作…*部分中有一个插图，展示了在这个算法中洗牌和逆洗牌是如何工作的。
- en: How it works...
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The concept of shuffling and unshuffling was explored in [Chapter 4](ch04.html
    "Chapter 4. Using OpenCL Functions"), *Using OpenCL Functions* and we invite you
    to head back there and refresh yourself with the concepts. The following diagram
    illustrates how `shuffle` and `unshuffle` (as defined before) would work given
    an imaginary input: **8**, **12**, **4**, **15**, **2**, **11**, **6**, **3**,
    **5**, **14**, **16**, **10**, **1**, **9**, **13**, **7**:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](ch04.html "第4章。使用 OpenCL 函数")*使用 OpenCL 函数*中探讨了洗牌和逆洗牌的概念，我们邀请您回到那里，用这些概念来更新自己。以下图表说明了在给定一个假想输入：**8**，**12**，**4**，**15**，**2**，**11**，**6**，**3**，**5**，**14**，**16**，**10**，**1**，**9**，**13**，**7**的情况下，`shuffle`和`unshuffle`（如之前定义的）将如何工作：
- en: '![How it works...](img/4520OT_09_06.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/4520OT_09_06.jpg)'
- en: Recursive algorithms similar to the one we have just presented are good for
    understanding the general flow of the algorithm, but it doesn't work well when
    you wish to run this algorithm on OpenCL GPUs because recursion isn't fully supported
    on GPUs. Even though you were to choose an implementation that runs on the CPU
    via OpenCL, it'll work but it won't be portable.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于我们刚才展示的递归算法对于理解算法的一般流程是好的，但当你希望在OpenCL GPU上运行此算法时，它并不适用，因为GPU并不完全支持递归。即使你选择一个通过OpenCL在CPU上运行的实现，它也能工作，但不会是可移植的。
- en: 'We need an iterative version of this algorithm we just discussed, and fortunately
    for us we can convert this recursive algorithm to an iterative one. We will look
    at the following solution from `src/Ch9/BitonicSort_CPU_02/BitonicSort.c`:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要我们刚才讨论的算法的迭代版本，幸运的是，我们可以将这个递归算法转换为迭代算法。我们将查看以下来自`src/Ch9/BitonicSort_CPU_02/BitonicSort.c`的解决方案：
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This algorithm is divided into phases indexed by the `p` variable. The last
    phase, which is when `p` is `N`, and each phase applies the sorting and merging
    to segments of sizes `N / 2`, `N / 4`, `N / 8` to ![How it works...](img/4520OT_09_20.jpg).
    When examining this code deeper by tracing the execution flow, you would notice
    that it is actually computing the sorting network that accepts 32 inputs (corresponding
    to the number of inputs in our input buffer), and when you read the diagram from
    left to right, you will notice that it approaches solving this problem in a bottom-up
    manner:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 此算法被分为由`p`变量索引的阶段。最后一个阶段是当`p`为`N`时，每个阶段都将排序和合并应用于大小为`N / 2`、`N / 4`、`N / 8`的段![如何工作...](img/4520OT_09_20.jpg)。通过更深入地检查此代码的执行流程，你会注意到它实际上是在计算一个接受32个输入（对应于我们输入缓冲区中的输入数量）的排序网络，并且当你从左到右阅读这个图时，你会注意到它是以自下而上的方式来解决这个问题：
- en: '![How it works...](img/4520OT_09_07.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/4520OT_09_07.jpg)'
- en: 'What I meant by bottom-up approach is that figure should be read from left
    to right (that''s also the flow of the data through this sorting network). When
    you draw columns around the first column, you''ll notice that the algorithm creates
    segments of sizes two. Then the second and third columns form segments of sizes
    4, then the fourth, fifth, and sixth columns form segments of size eight. They
    continue to form to sort/merge segments of sizes that are a power of two up to
    the point where it sorts and merges all the `N` elements in the input array. You
    will probably have realized that the algorithm doesn''t create any temporary data
    structures to hold temporary values and it''s actually sorting in-place. The immediate
    consequence of a sorting algorithm that sorts in-place is that it is memory efficient,
    since the output is written into the input and doesn''t create any memory storage
    at all. The following is an illustration of the partition sizes that the algorithm
    works on while at every stage:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我所说的自下而上的方法是指应该从左到右阅读这个图（这也是数据通过这个排序网络的流动方向）。当你围绕第一列画上柱状图时，你会注意到算法创建了大小为二的段。然后第二列和第三列形成大小为4的段，然后第四列、第五列和第六列形成大小为8的段。它们继续形成，以排序/合并大小为2的幂次的段，直到它对输入数组中的所有`N`个元素进行排序和合并。你可能已经意识到，该算法不会创建任何临时数据结构来存储临时值，它实际上是在原地排序。原地排序算法的直接影响是内存效率高，因为输出直接写入输入，并且不创建任何内存存储。以下是在每个阶段算法工作的分区大小示意图：
- en: '![How it works...](img/4520OT_09_08.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/4520OT_09_08.jpg)'
- en: To develop our understanding of the bitonic sort and sorting networks, it is
    important to understand how parallelism can be subsequently extracted from.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为了加深我们对双峰排序和排序网络的理解，了解如何从中提取并行性是很重要的。
- en: Developing bitonic sorting in OpenCL
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在OpenCL中开发双峰排序
- en: In this section, we will walk through an implementation of sorting an arbitrary
    input by using the bitonic sort in OpenCL which runs better on a GPU.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过使用在GPU上运行更好的OpenCL中的双峰排序来演示如何对任意输入进行排序的实现。
- en: 'We recall that bitonic sorting recursively sorts elements in the input by building
    up sequences and merging those into bigger sized sequences and then repeats the
    cycle, and the two key operations performs it really does is to conduct: a pairwise
    comparison to determine the greater/smaller of the two elements in a sequence,
    and merging the two sequences by applying the bitonic sort between them.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们回顾一下，位序排序递归地对输入元素进行排序，通过构建序列并将这些序列合并成更大的序列，然后重复这个循环，它真正执行的两个关键操作是：进行成对比较以确定序列中两个元素的较大/较小，并通过在它们之间应用位序排序来合并这两个序列。
- en: Getting ready
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: So far we have seen how we can apply the bitonic sort to bitonic sequences.
    The question we need to address next is what do we do with an input that is entirely
    arbitrary? The answer to that question is to make it into a bitonic sequence and
    then apply a series of bitonic splits/merge. At the beginning, pairwise compare-exchange
    operations are conducted for elements in the input, and at the end of this stage
    we have sorted segments of size two. The next stage is to group two segments of
    size two and perform compare-exchange producing segments of size four. The cycle
    repeats itself and the algorithm keeps creating bigger segments of size ![Getting
    ready](img/4520OT_09_14.jpg).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了如何将位序排序应用于位序序列。接下来我们需要解决的问题是对一个完全随机的输入我们应该怎么做？这个问题的答案是将其转换成一个位序序列，然后应用一系列的位序拆分/合并。最初，对输入中的元素进行成对比较交换操作，在这个阶段的最后，我们得到了大小为两的排序段。下一阶段是将两个大小为两的段组合起来，执行比较交换，产生大小为四的段。这个循环会重复进行，算法会持续创建更大的段，大小如![准备中](img/4520OT_09_14.jpg)所示。
- en: 'Recall from the previous section, where we saw the iterative version of the
    bitonic sort (the algorithm is repeated here) which uses an array index, `p`,
    to denote the phases in which the sort will take place and with each phase of
    the algorithm, the algorithm sorts and merges segments of sizes two, four, eight,
    and so on. And building up on that idea, each phase of the sort is going to be
    parallel. Also remember that we need to do two things:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 从上一节回顾，我们看到了位序排序的迭代版本（算法在此处重复），它使用数组索引 `p` 来表示排序将发生的阶段，并且随着算法的每个阶段，算法会排序和合并大小为两、四、八等的大小段。在此基础上，排序的每个阶段都将并行执行。同时记住，我们需要做两件事：
- en: Build a comparator network (bitonic split/sort) that sorts two smaller bitonic
    sequences into a large one, remembering the fact that sizes are powers of two.
    This pairwise comparison between two elements will be conducted by a single executing
    thread/work item.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建一个比较网络（位序拆分/排序），将两个较小的位序序列排序成一个较大的序列，记住大小是2的幂。两个元素之间的这种成对比较将由单个执行线程/工作项进行。
- en: Build bitonic sequences on each half, such that one half is monotonically increasing
    and the other half is monotonically decreasing.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每个半部分构建位序序列，使得一半是单调递增的，另一半是单调递减的。
- en: How to do it...
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何去做...
- en: Our strategy focuses on using a single executable thread performing the compare-exchange
    operation, and following is the Bitonic Sort OpenCL kernel which uses this simple
    strategy.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的战略侧重于使用单个可执行线程执行比较交换操作，以下是一个使用这种简单策略的位序排序 OpenCL 内核：
- en: 'The following code excerpt is taken from `Ch9/BitonicSort_GPU/BitonicSort.cl`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码摘录来自 `Ch9/BitonicSort_GPU/BitonicSort.cl`：
- en: '[PRE4]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Using the preceding OpenCL kernel code we need to build an executable, so that
    it can execute on our platform. As before, the compilation will look familiar
    to you. On my setup with an Intel Core i7 CPU and AMD HD6870x2 GPU running Ubuntu
    12.04 LTS, the compilation looks as follows, and it''ll create an executable called
    `BitonicSort` into the working directory:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面的 OpenCL 内核代码，我们需要构建一个可执行文件，以便它能在我们的平台上执行。和之前一样，编译过程对你来说应该很熟悉。在我的配置中，使用英特尔酷睿
    i7 CPU 和 AMD HD6870x2 GPU 运行 Ubuntu 12.04 LTS，编译过程如下，它会在工作目录中创建一个名为 `BitonicSort`
    的可执行文件：
- en: '[PRE5]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'At this point, you should have an executable deposited in that directory. All
    you need to do now is to run the program, simply execute the `BitonicSort` program
    in the directory and you should have noticed an output that resembles this:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你应该在那个目录中有一个可执行文件。现在你只需要运行程序，简单地在目录中执行 `BitonicSort` 程序，你应该已经注意到一个类似于以下输出的结果：
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: How it works...
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The algorithm starts from the basic strategy of using a thread to conduct the
    pairwise comparison-exchange operation. The details is that the host code will
    break down the original input into its respective phases, and for our testing
    purposes we have an input of 16 million elements which works out to 24 phases.
    In the host code, we use the `stage` variable to indicate that. Next at each phase,
    the algorithm will apply the bitonic split/sort and merge segments of sizes progressively
    from the least power of two to the greatest power of two, smaller or equal to
    the phases, for example if we are sorting for elements of size eight, then we
    would sort to produce segments of size two, then four, and finally we will sort
    and merge 4-by-4 sequences to get eight.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 算法从使用线程进行成对比较-交换操作的基本策略开始。具体来说，主机代码会将原始输入分解为其相应的阶段，为了测试目的，我们有一个包含1600万个元素的输入，这相当于24个阶段。在主机代码中，我们使用`stage`变量来表示这一点。接下来，在每一个阶段，算法将应用位序列分割/排序和合并大小从最小的2的幂次到最大的2的幂次，小于或等于阶段的大小，例如，如果我们正在对大小为八的元素进行排序，那么我们会排序以产生大小为二的段，然后是四，最后我们将对4-by-4序列进行排序和合并，以得到八。
- en: 'In detail when the kernel starts executing, it has to start building the bitonic
    subsequences by using the bitonic split. And to do that the kernel needs to know
    where to split the array, taking into account the current stage of the sort and
    it does this with the following code:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 详细来说，当内核开始执行时，它必须通过使用位序列分割来开始构建位序列子序列。为此，内核需要知道如何分割数组，考虑到当前排序阶段，它通过以下代码来完成：
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Next, the kernel loads the data values from the array by using the `leftId`
    and `rightId` indices and stores them in the thread''s local register memory.
    The next part of the algorithm is to build bitonic sequences, such that one half
    is monotonically increasing and the other half is monotonically decreasing. And
    we use the variable, `sameDirectionBlockWidth`, as a heuristic to guide whether
    we are going to sort increasingly or decreasingly. The following code does that:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，内核通过使用`leftId`和`rightId`索引从数组中加载数据值，并将它们存储在线程的本地寄存器内存中。算法的下一部分是构建位序列，使得一半是单调递增的，另一半是单调递减的。我们使用变量`sameDirectionBlockWidth`作为启发式方法来指导我们是按递增还是递减排序。以下代码实现了这一点：
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As an example, let''s assume that stage is three which implies that `sameDirectionBlockWidth`
    is eight. The following figure demonstrates what will eventually happen when the
    `sortIncreasing` variable flips based on the (above) computation, and hence creates
    the desired effect of bitonic sequencing:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设阶段是三，这意味着`sameDirectionBlockWidth`是八。以下图示展示了当`sortIncreasing`变量基于（上述）计算翻转时最终会发生什么，从而产生所需的位序列排序效果：
- en: '![How it works...](img/4520OT_09_09.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/4520OT_09_09.jpg)'
- en: The rest of the kernel code is concerned with the pairwise comparison-exchange
    operation, which we are familiar with by now.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 内核的其余代码与成对比较-交换操作有关，这是我们目前已经熟悉的。
- en: 'Another aspect of this implementation is that the algorithm is compute bound
    and it''s executed iteratively on the OpenCL GPU via the CPU, and the kernel is
    notified of which stage it''s at including its substages. This can be accomplished
    in the host code like this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 此实现的另一个方面是算法是计算密集型的，并且通过CPU在OpenCL GPU上迭代执行，内核会通知它所处的阶段及其子阶段。这可以在主机代码中这样完成：
- en: '[PRE9]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The code basically iterates over all the stages and its substages, and invokes
    the GPU to work on the same input buffer notifying the kernel which stage and
    substage the kernel is executing by invoking `clSetKernelArg` for the appropriate
    parameter. And then waits until the sorting is done in that phase before starting
    work on another (this is critical, otherwise the input buffer would be corrupted).
    In order to make the input buffer be both readable and writeable by the algorithm,
    it was created like this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 代码基本上遍历所有阶段及其子阶段，并调用GPU处理相同的输入缓冲区，通过调用`clSetKernelArg`为适当的参数通知内核它正在执行哪个阶段和子阶段。然后等待在该阶段完成排序后，才开始处理另一个（这是关键的，否则输入缓冲区会被损坏）。为了使输入缓冲区既能被算法读取又能被写入，它被创建如下：
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The execution of this algorithm will see the execution flow entering the host,
    and then leaving for the GPU and continuing to do this until the stages run out.
    This process is illustrated in the following diagram, though it cannot be scaled:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法的执行将看到执行流程进入宿主，然后离开前往GPU，并继续这样做，直到阶段结束。这个过程在以下图中得到了说明，尽管它不能缩放：
- en: '![How it works...](img/4520OT_09_10.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/4520OT_09_10.jpg)'
- en: 'We can actually apply an optimization on this kernel by employing a technique
    we have understood quite well so far, and that is using the shared memory. Shared
    memory, as you probably know by now, allows the developer to reduce global memory
    traffic since the program does not have to repeatedly request elements from the
    global memory space, but instead use what has been stored in its internal memory.
    Here''s a refresher on how the memory model in OpenCL looks like:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上可以通过使用我们迄今为止相当了解的技术对这个内核进行优化，那就是使用共享内存。正如你可能现在已经知道的，共享内存允许开发者减少全局内存流量，因为程序不需要反复从全局内存空间请求元素，而是使用其内部存储中已经存储的内容。以下是对OpenCL内存模型的一个复习：
- en: '![How it works...](img/4520OT_09_11.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/4520OT_09_11.jpg)'
- en: 'Applying the techniques we have learnt so far, we actually have one possible
    point in which we can apply shared memory techniques by looking out for code that
    is fetching data from the global memory. We will develop a solution using shared
    memory and expanding it slightly to have our program load it in strides. We''ll
    get into that in a short while. Let''s start at a plausible point for reworking
    our `bitonicSort` program taking into account the presence of shared memory:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 应用我们迄今为止学到的技术，我们实际上有一个可能的应用共享内存技术的点，那就是寻找从全局内存中获取数据的代码。我们将开发一个使用共享内存的解决方案，并将其稍微扩展以使我们的程序以步进方式加载。我们将在稍后讨论这一点。让我们从一个合理的点开始重新设计我们的
    `bitonicSort` 程序，考虑到共享内存的存在：
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We present the following kernel that uses shared memory, we''ll explain how
    it works, found in `Ch9/BitonicSort_GPU/BitonicSort.cl`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们展示了以下使用共享内存的内核，我们将在 `Ch9/BitonicSort_GPU/BitonicSort.cl` 中解释其工作原理：
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'What we did basically was to introduce a variable called `sharedMem` and the
    strategy for loading those values is simple: each thread will store two values
    (adjacent) in the shared memory data store, where it will be read out in the subsequent
    section and all reads which used to refer to the global memory is now conducted
    in the local/shared memory.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们基本上是引入了一个名为 `sharedMem` 的变量，加载这些值的策略很简单：每个线程将在共享内存数据存储中存储两个值（相邻的），在后续部分将被读取出来，所有原本指向全局内存的读取现在都在本地/共享内存中进行。
- en: 'The host code that is responsible for allocating this memory space is the following
    code snippet from `Ch9/BitonicSort_GPU/BitonicSort.c` taking into account that
    each thread writes two adjacent values. And hence it requires twice the amount
    of memory for a work group of 256 threads:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 负责分配此内存空间的宿主代码是来自 `Ch9/BitonicSort_GPU/BitonicSort.c` 的以下代码片段，考虑到每个线程写入两个相邻值。因此，对于256线程的工作组，它需要两倍的内存量：
- en: '[PRE13]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'And to see it in action you can compile the program like this (invoking `gcc`
    directly):'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要看到它的实际效果，你可以像这样编译程序（直接调用 `gcc`）：
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This deposits the `BitonicSort_GPU` program into that directory; another way
    is to invoke `cmake` at the root of this code base like this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这将 `BitonicSort_GPU` 程序存放到该目录中；另一种方法是像这样在代码库的根目录下调用 `cmake`：
- en: '[PRE15]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'And navigate to `Ch9/BitonicSort_GPU/` and invoke `make` like this:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到 `Ch9/BitonicSort_GPU/` 并像这样调用 `make`：
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The following is a diagram of how the writes to the shared memory are done
    with respect to the scheme we just described. Remember that all subsequent reads
    is through `sharedMem` instead of the global memory traffic, which means that
    a significant amount of bandwidth is saved:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是根据我们刚才描述的方案进行的共享内存写入的示意图。记住，所有后续的读取都是通过 `sharedMem` 而不是全局内存流量进行的，这意味着节省了大量的带宽：
- en: '![How it works...](img/4520OT_09_12.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/4520OT_09_12.jpg)'
- en: 'We can explore the algorithm a little further by examining the original kernel,
    `bitonicSort`, where the last part of the algorithm involves essentially a comparison-exchange
    operation before writing that result back out to global memory. In this situation,
    we can extrapolate the shared memory concept further by applying it again and
    our strategy is rather simple here: we have each executing thread writing two
    pairs, where each pair is this [![How it works...](img/4520OT_09_19.jpg)], and
    referenced by a key and a value. And in our algorithm the key refers to the output
    index (that is, `leftId`, `rightId`) and the value refers to the sorted value
    (that is, `lesser`, `greater`) that will reside at that key. The following diagram
    illustrates how each thread would have written the two pairs into the `aux` shared
    memory, and how they could be laid out in memory:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 通过检查原始内核 `bitonicSort`，我们可以进一步探索算法，其中算法的最后部分涉及在将结果写回全局内存之前的基本比较交换操作。在这种情况下，我们可以通过再次应用共享内存概念来进一步扩展共享内存的概念。我们的策略在这里相当简单：每个执行线程写入两个对，其中每个对是这种
    [![如何工作...](img/4520OT_09_19.jpg)]，并通过键和值引用。在我们的算法中，键指的是输出索引（即 `leftId`，`rightId`），而值指的是将驻留在该键处的排序值（即
    `lesser`，`greater`）。以下图示说明了每个线程如何将两个对写入 `aux` 共享内存，以及它们如何在内存中布局：
- en: '![How it works...](img/4520OT_09_13.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/4520OT_09_13.jpg)'
- en: 'The following kernel modifications are found at `Ch9/BitonicSort_GPU/BitonicSort.cl`
    in the kernel named `bitonicSort_sharedmem_2`. We will look at the portions where
    the changes were different relative to the `bitonicSort_sharedmem` kernel:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在内核名为 `bitonicSort_sharedmem_2` 的 `Ch9/BitonicSort_GPU/BitonicSort.cl` 文件中发现了以下内核修改。我们将查看与
    `bitonicSort_sharedmem` 内核相比有所不同的部分：
- en: '[PRE17]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The final section of the kernel illustrates how we allow only one executing
    thread, that is, the thread with ID zero, from each work group to conduct the
    actual write back to global memory from the shared memory, `aux`. Do note that
    the memory fence is necessary, since the memory in `aux` may not have been filled
    by the time the thread with ID zero has begun execution. Therefore, it's placed
    there to ensure memory coherency.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 内核的最后部分说明了我们如何只允许每个工作组中的一个执行线程，即 ID 为零的线程，从共享内存 `aux` 将实际写入全局内存的操作执行。请注意，内存栅栏是必要的，因为
    `aux` 中的内存可能不会在 ID 为零的线程开始执行时已填充。因此，它被放置在那里以确保内存一致性。
