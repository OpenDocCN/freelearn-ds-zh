- en: Chapter 13. Data Around Us
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 13 章。我们周围的数据
- en: Spatial data, also known as geospatial data, identifies geographic locations,
    such as natural or constructed features around us. Although all observations have
    some spatial content, such as the location of the observation, but this is out
    of most data analysis tools' range due to the complex nature of spatial information;
    alternatively, the spatiality might not be that interesting (at first sight) in
    the given research topic.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 空间数据，也称为地理空间数据，标识了地理位置，例如我们周围的天然或人工特征。尽管所有观测值都有一些空间内容，例如观测值的位置，但由于空间信息的复杂性质，这通常超出了大多数数据分析工具的范围；或者，在给定的研究主题中，空间性可能不是那么有趣（乍一看）。
- en: On the other hand, analyzing spatial data can reveal some very important underlying
    structures of the data, and it is well worth spending time visualizing the differences
    and similarities between close or far data points.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，分析空间数据可以揭示数据的一些非常重要的潜在结构，并且花时间可视化接近或远离数据点之间的差异和相似性是非常值得的。
- en: 'In this chapter, we are going to help with this and will use a variety of R
    packages to:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将帮助您完成这项工作，并使用各种 R 包来：
- en: Retrieve geospatial information from the Internet
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从互联网检索地理空间信息
- en: Visualize points and polygons on a map
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在地图上可视化点和多边形
- en: Compute some spatial statistics
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算一些空间统计量
- en: Geocoding
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 地理编码
- en: 'As in the previous chapters, we will use the `hflights` dataset to demonstrate
    how one can deal with data bearing spatial information. To this end, let''s aggregate
    our dataset, just like we did in [Chapter 12](ch12.html "Chapter 12. Analyzing
    Time-series"), *Analyzing Time-series*, but instead of generating daily data,
    let''s view the aggregated characteristics of the airports. For the sake of performance,
    we will use the `data.table` package again as introduced in [Chapter 3](ch03.html
    "Chapter 3. Filtering and Summarizing Data"), *Filtering and Summarizing Data*
    and [Chapter 4](ch04.html "Chapter 4. Restructuring Data"), *Restructuring Data*:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如前几章所述，我们将使用 `hflights` 数据集来演示如何处理包含空间信息的数据。为此，让我们像在 [第 12 章](ch12.html "第 12
    章。分析时间序列") *分析时间序列* 中所做的那样，对我们的数据集进行聚合，但这次不是生成每日数据，而是查看机场的聚合特征。为了性能考虑，我们将再次使用在
    [第 3 章](ch03.html "第 3 章。过滤和汇总数据") *过滤和汇总数据* 和 [第 4 章](ch04.html "第 4 章。重构数据")
    *重构数据* 中介绍的 `data.table` 包：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'So we have loaded and then immediately transformed the `hfights` dataset to
    a `data.table` object. At the same time, we aggregated by the destination of the
    flights to compute:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经加载了 `hfights` 数据集，并将其立即转换为 `data.table` 对象。同时，我们按航班的目的地进行聚合，以计算：
- en: The number of rows
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行数数量
- en: The number of cancelled flights
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 取消的航班数量
- en: The distance
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 距离
- en: The standard deviation of the elapsed time of the flights
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 飞行延误时间的标准差
- en: The arithmetic mean of the delays
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 延误的算术平均值
- en: 'The resulting R object looks like this:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 结果的 R 对象看起来像这样：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'So we have 116 observations all around the world and five variables describing
    those. Although this seems to be a spatial dataset, we have no geospatial identifiers
    that a computer can understand per se, so let''s fetch the *geocodes* of these
    airports from the Google Maps API via the `ggmap` package. First, let''s see how
    it works when we are looking for the geo-coordinates of Houston:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们拥有全球 116 个观测值和五个描述这些观测值的变量。尽管这似乎是一个空间数据集，但我们没有计算机可以理解的地理空间标识符，所以让我们通过 `ggmap`
    包从 Google Maps API 中获取这些机场的 *地理编码*。首先，让我们看看当我们寻找休斯顿的地理坐标时它是如何工作的：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'So the `geocode` function can return the matched latitude and longitude of
    the string we sent to Google. Now let''s do the very same thing for all flight
    destinations:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`geocode` 函数可以返回我们发送给 Google 的字符串匹配的纬度和经度。现在让我们为所有航班目的地做同样的事情：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Well, this took some time as we had to make 116 separate queries to the Google
    Maps API. Please note that Google limits you to 2,500 queries a day without authentication,
    so do not run this on a large dataset. There is a helper function in the package,
    called `geocodeQueryCheck`, which can be used to check the remaining number of
    free queries for the day.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这花了一些时间，因为我们不得不对 Google Maps API 进行了 116 次单独的查询。请注意，Google 对未经身份验证的用户每天的限制是
    2,500 次查询，所以不要在大型数据集上运行此操作。该包中有一个辅助函数，称为 `geocodeQueryCheck`，可以用来检查当天剩余的免费查询次数。
- en: 'Some of the methods and functions that we plan to use in some later sections
    of this chapter do not support `data.table`, so let''s fall back to the traditional
    `data.frame` format and also print the structure of the current object:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的一些后续部分中，我们计划使用的一些方法和函数不支持`data.table`，因此让我们退回到传统的`data.frame`格式，并打印当前对象的结构：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This was pretty quick and easy, wasn't it? Now that we have the longitude and
    latitude values of all the airports, we can try to show these points on a map.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常快且简单，不是吗？现在我们已经有了所有机场的经纬度值，我们可以尝试在地图上显示这些点。
- en: Visualizing point data in space
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在空间中可视化点数据
- en: 'For the first time, let''s keep it simple and load some package-bundled polygons
    as the base map. To this end, we will use the `maps` package. After loading it,
    we use the `map` function to render the polygons of the United States of America,
    add a title, and then some points for the airports and also for Houston with a
    slightly modified symbol:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次，让我们保持简单，加载一些捆绑的包多边形作为基础地图。为此，我们将使用`maps`包。加载后，我们使用`map`函数渲染美国的 polygons，添加标题，然后添加一些代表机场和休斯顿的符号（略有修改）：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '![Visualizing point data in space](img/2028OS_13_01.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![在空间中可视化点数据](img/2028OS_13_01.jpg)'
- en: 'And showing the airport names on the plot is pretty easy as well: we can use
    the well-known functions from the base `graphics` package. Let''s pass the three
    character names as labels to the text function with a slightly increased *y* value
    to shift the preceding text the previously rendered data points:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在图上显示机场名称也很容易：我们可以使用基`graphics`包中众所周知的功能。让我们将三个字符名称作为标签传递给`text`函数，并稍微增加 *y*
    值以将先前的文本移至先前渲染的数据点：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '![Visualizing point data in space](img/2028OS_13_02.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![在空间中可视化点数据](img/2028OS_13_02.jpg)'
- en: 'Now, we can also specify the color of the points to be rendered. This feature
    can be used to plot our first meaningful map to highlight the number of flights
    in 2011 to different parts of the USA:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们还可以指定要渲染的点颜色。这个功能可以用来绘制我们第一张有意义的地图，以突出2011年飞往美国不同地区的航班数量：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '![Visualizing point data in space](img/2028OS_13_03.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![在空间中可视化点数据](img/2028OS_13_03.jpg)'
- en: So the intensity of red shows the number of flights to the given points (airports);
    the values range from 1 to almost 10,000\. Probably it would be more meaningful
    to compute these values on a state level as there are many airports, very close
    to each other, which might be better aggregated at a higher administrative area
    level. To this end, we load the polygon of the states, match the points of interest
    (airports) with the overlaying polygons (states), and render the polygons as a
    thematic map instead of points, like we did on the previous pages.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，红色的强度表示飞往给定点的航班数量（机场）；值从1到近10,000。可能按州级别计算这些值更有意义，因为有许多机场彼此非常接近，可能更适合在更高级行政区域级别进行聚合。为此，我们加载了州的
    polygons，将感兴趣的点（机场）与叠加的多边形（州）匹配，并将 polygons 作为主题地图渲染，就像我们在前面的页面所做的那样。
- en: Finding polygon overlays of point data
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 寻找点数据的多边形叠加
- en: 'We already have all the data we need to identify the parent state of each airport.
    The `dt` dataset includes the geo-coordinates of the locations, and we managed
    to render the states as polygons with the `map` function. Actually, this latter
    function can return the underlying dataset without rendering a plot:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经拥有了所有识别每个机场的母州所需的数据。`dt`数据集包括位置的地理坐标，我们使用`map`函数成功地将 states 作为 polygons
    渲染出来。实际上，这个后一个函数可以返回底层数据集而不进行绘图：
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'So we have around 16,000 points describing the boundaries of the US states,
    but this map data is more detailed than we actually need (see for example the
    name of the polygons starting with Washington):'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有大约16,000个点描述了美国各州的边界，但这个地图数据比我们实际需要的更详细（例如，以华盛顿为开头的多边形名称）：
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In short, the non-connecting parts of a state are defined as separate polygons.
    To this end, let''s save a list of the state names without the string after the
    colon:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，一个州的非连接部分被定义为单独的多边形。为此，让我们保存一个不带冒号后字符串的州名称列表：
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We will use this list as the basis of aggregation from now on. Let''s transform
    this `map` dataset into another class of object, so that we can use the powerful
    features of the `sp` package. We will use the `maptools` package to do this transformation:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，我们将使用这个列表作为聚合的基础。让我们将这个`map`数据集转换成另一种类的对象，以便我们可以使用`sp`包的强大功能。我们将使用`maptools`包来完成这个转换：
- en: '[PRE11]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: An alternative way of getting the state polygons might be to directly load those
    instead of transforming from other data formats as described earlier. To this
    end, you may find the `raster` package especially useful to download free map
    **shapefiles** from `gadm.org` via the `getData` function. Although these maps
    are way too detailed for such a simple task, you can always simplify those—for
    example, with the `gSimplify` function of the `rgeos` package.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 获取州多边形的一种替代方法可能是直接加载这些多边形，而不是像之前描述的那样从其他数据格式转换。为此，您可能会发现`raster`包特别有用，可以通过`getData`函数从`gadm.org`下载免费的地图**shapefiles**。尽管这些地图对于如此简单的任务来说过于详细，但您总是可以通过例如`rgeos`包的`gSimplify`函数来简化它们。
- en: 'So we have just created an object called `us`, which includes the polygons
    of `map_data` for each state with the given **projection**. This object can be
    shown on a map just like we did previously, although you should use the general
    `plot` method instead of the `map` function:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们刚刚创建了一个名为`us`的对象，它包括每个州的`map_data`的多边形，以及给定的**投影**。这个对象可以像我们之前做的那样显示在地图上，尽管您应该使用通用的`plot`方法而不是`map`函数：
- en: '[PRE12]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '![Finding polygon overlays of point data](img/2028OS_13_04.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![寻找点数据的多边形叠加](img/2028OS_13_04.jpg)'
- en: 'Besides this, however, the `sp` package supports so many powerful features!
    For example, it''s very easy to identify the overlay polygons of the provided
    points via the `over` function. As this function name conflicts with the one found
    in the `grDevices` package, it''s better to refer to the function along with the
    namespace using a double colon:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，除了这个之外，`sp`包支持许多强大的功能！例如，通过`over`函数很容易识别提供的点的叠加多边形。由于该函数名与`grDevices`包中的函数冲突，最好使用双冒号同时引用函数和命名空间：
- en: '[PRE13]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: What happened here? First, we passed the coordinates and the whole dataset to
    the `SpatialPointsDataFrame` function, which stored our data as spatial points
    with the given longitude and latitude values. Next, we called the `over` function
    to left-join the values of `dtp` to the US states.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了什么？首先，我们将坐标和整个数据集传递给`SpatialPointsDataFrame`函数，该函数将我们的数据以给定经纬度值存储为空间点。接下来，我们调用了`over`函数，将`dtp`的值左连接到美国各州。
- en: Note
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'An alternative way of identifying the state of a given airport is to ask for
    more detailed information from the Google Maps API. By changing the default `output`
    argument of the `geocode` function, we can get all address components for the
    matched spatial object, which of course includes the state as well. Look for example
    at the following code snippet:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 识别给定机场状态的另一种方法是向Google Maps API请求更详细的信息。通过更改`geocode`函数的默认`output`参数，我们可以获取匹配空间对象的全部地址组件，当然也包括州信息。例如，查看以下代码片段：
- en: '[PRE14]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Based on this, you might want to get a similar output for all airports and filter
    the list for the short name of the state. The `rlist` package would be extremely
    useful in this task, as it offers some very convenient ways of manipulating lists
    in R.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 基于此，您可能希望为所有机场获取类似的输出，并过滤出州的简称。`rlist`包在这个任务中会非常有用，因为它提供了在R中操作列表的一些非常方便的方法。
- en: 'The only problem here is that we matched only one airport to the states, which
    is definitely not okay. See for example the fourth column in the earlier output:
    it shows `LAX` as the matched airport for `California` (returned by `states[4]`),
    although there are many others there as well.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这里唯一的问题是，我们只匹配了一个机场到各州，这显然是不正确的。例如，查看早期输出的第四列：它显示`LAX`是`加利福尼亚`的匹配机场（由`states[4]`返回），尽管那里还有很多其他机场。
- en: 'To overcome this issue, we can do at least two things. First, we can use the
    `returnList` argument of the `over` function to return all matched rows of `dtp`,
    and we will then post-process that data:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服这个问题，我们可以至少做两件事。首先，我们可以使用`over`函数的`returnList`参数来返回`dtp`的所有匹配行，然后我们将后处理这些数据：
- en: '[PRE15]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: So we created and called an anonymous function that will `sum` up the `Cancelled`
    values of the `data.frame` in each element of the list returned by `over`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们创建并调用了一个匿名函数，该函数将对`over`函数返回的列表中的每个元素的`data.frame`中的`Cancelled`值进行求和。
- en: 'Another, probably cleaner, approach is to redefine `dtp` to only include the
    related values and pass a function to `over` to do the summary:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种可能更干净的方法是重新定义`dtp`以仅包含相关值，并将函数传递给`over`以进行汇总：
- en: '[PRE16]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Either way, we have a vector to merge back to the US state names:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 无论哪种方式，我们都有一个向量可以合并回美国各州名称：
- en: '[PRE17]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'And to update all missing values to zero (as the number of cancelled flights
    in a state without any airport is not missing data, but exactly zero for sure):'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 并且将所有缺失的值更新为零（因为在没有任何机场的州中取消的航班数量不是缺失数据，而是一定为零）：
- en: '[PRE18]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Plotting thematic maps
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制主题地图
- en: 'Now we have everything to create our first *thematic* map. Let''s pass the
    `val` vector to the previously used `map` function (or `plot` it using the `us`
    object), specify a plot title, add a blue point for Houston, and then create a
    legend, which shows the quantiles of the overall number of cancelled flights as
    a reference:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了创建我们的第一个**主题**地图所需的一切。让我们将`val`向量传递给之前使用的`map`函数（或使用`us`对象进行绘图），指定一个绘图标题，添加一个代表休斯顿的蓝色点，然后创建一个图例，该图例显示整体取消航班数量的分位数作为参考：
- en: '[PRE19]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '![Plotting thematic maps](img/2028OS_13_05.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![绘制主题地图](img/2028OS_13_05.jpg)'
- en: Please note that, instead of a linear scale, we have decided to compute the
    square root of the relative values to define the intensity of the fill color,
    so that we can visually highlight the differences between the states. This was
    necessary as most flight cancellations happened in Texas (`748`), and there were
    no more than 150 cancelled flights in any other state (with the average being
    around 45).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们决定计算相对值的平方根来定义填充颜色的强度，而不是使用线性刻度，这样我们可以直观地突出显示各州之间的差异。这是必要的，因为大多数航班取消发生在德克萨斯州（`748`），其他任何州的取消航班不超过150次（平均约为45次）。
- en: Note
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can also easily load ESRI shape files or other geospatial vector data formats
    into R as points or polygons with a bunch of packages already discussed and a
    few others as well, such as the `maptools`, `rgdal`, `dismo`, `raster`, or `shapefile`
    packages.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以轻松地将ESRI形状文件或其他地理空间矢量数据格式加载到R中，作为点或多边形，使用已经讨论过的许多包以及一些其他包，例如`maptools`、`rgdal`、`dismo`、`raster`或`shapefile`包。
- en: Another, probably easier, way to generate country-level thematic maps, especially
    choropleth maps, is to load the `rworldmap` package made by Andy South, and rely
    on the convenient `mapCountryData` function.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种可能更容易的方法来生成国家层面的主题地图，特别是等值线地图，是加载由Andy South制作的`rworldmap`包，并依赖方便的`mapCountryData`函数。
- en: Rendering polygons around points
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制点周围的多边形
- en: Besides thematic maps, another really useful way of presenting spatial data
    is to draw artificial polygons around the data points based on the data values.
    This is especially useful if there is no available polygon shape file to be used
    to generate a thematic map.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 除了主题地图之外，另一种非常有用的展示空间数据的方式是根据数据值在数据点周围绘制人工多边形。这在没有可用的多边形形状文件来生成主题地图时尤其有用。
- en: A level plot, contour plot, or isopleths, might be an already familiar design
    from tourist maps, where the altitude of the mountains is represented by a line
    drawn around the center of the hill at the very same levels. This is a very smart
    approach having maps present the height of hills—projecting this third dimension
    onto a 2-dimensional image.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 等高线图、轮廓图或等值线，可能是一些从旅游地图中已经熟悉的设计，其中山脉的高度由围绕山丘中心的线条表示，这些线条处于完全相同的水平。这是一种非常聪明的做法，因为地图展示了小山的高度——将这个第三维度投影到二维图像上。
- en: 'Now let''s try to replicate this design by considering our data points as mountains
    on the otherwise flat map. We already know the heights and exact geo-coordinates
    of the geometric centers of these hills (airports); the only challenge here is
    to draw the actual shape of these objects. In other words:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试通过将我们的数据点视为平坦地图上的山脉来复制这种设计。我们已经知道这些小山（机场）的精确高度和几何中心的地理坐标；这里的唯一挑战是绘制这些物体的实际形状。换句话说：
- en: Are these *mountains* connected?
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些**山脉**是否相连？
- en: How steep are the *hillsides*?
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**山坡**的陡峭程度如何？'
- en: Should we consider any underlying spatial effects in the data? In other words,
    can we actually render these as *mountains* with a 3D shape instead of plotting
    independent points in space?
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们是否应该考虑数据中的任何潜在的空间效应？换句话说，我们能否实际上将这些渲染为具有3D形状的**山脉**，而不是在空间中绘制独立的点？
- en: If the answer for the last question is positive, then we can start trying to
    answer the other questions by fine-tuning the plot parameters. For now, let's
    simply suppose that there is a spatial effect in the underlying data, and it makes
    sense to visualize the data in such a way. Later, we will have the chance to disprove
    or support this statement either by analyzing the generated plots, or by building
    some geo-spatial models—some of these will be discussed later, in the *Spatial
    Statistics* section.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对最后一个问题的答案是肯定的，那么我们可以开始尝试通过微调绘图参数来回答其他问题。现在，让我们简单地假设底层数据中存在空间效应，并且以这种方式可视化数据是有意义的。稍后，我们将有机会通过分析生成的图表或构建一些地理空间模型来证明或反驳这个陈述——其中一些将在后面的
    *空间统计* 部分讨论。
- en: Contour lines
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 等高线
- en: 'First, let''s expand our data points into a matrix with the `fields` package.
    The size of the resulting R object is defined arbitrarily but, for the given number
    of rows and columns, which should be a lot higher to generate higher resolution
    images, 256 is a good start:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们使用 `fields` 包将我们的数据点扩展到一个矩阵。结果 R 对象的大小是任意定义的，但对于给定的行数和列数，为了生成更高分辨率的图像，256
    是一个好的起点：
- en: '[PRE20]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `as.image` function generates a special R object, which in short includes
    a 3‑dimensional matrix-like data structure, where the *x* and *y* axes represent
    the longitude and latitude ranges of the original data respectively. To simplify
    this even more, we have a matrix with 256 rows and 256 columns, where each of
    those represents a discrete value evenly distributed between the lowest and highest
    values of the latitude and longitude. And on the *z* axis, we have the `ArrDelay`
    values—which are in most cases of course missing:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`as.image` 函数生成一个特殊的 R 对象，简而言之，它包括一个类似于三维矩阵的数据结构，其中 *x* 和 *y* 轴分别代表原始数据的经纬度范围。为了进一步简化，我们有一个
    256 行 256 列的矩阵，其中每一行和每一列都代表经纬度最低值和最高值之间均匀分布的离散值。而在 *z* 轴上，我们有 `ArrDelay` 值——当然，在大多数情况下这些值是缺失的：'
- en: '[PRE21]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'What does this matrix look like? It''s better to see what we have at the moment:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这个矩阵看起来是什么样子？最好是看看我们目前拥有的内容：
- en: '[PRE22]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '![Contour lines](img/2028OS_13_06.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![等高线](img/2028OS_13_06.jpg)'
- en: Well, this does not seem to be useful at all. What is shown there? We rendered
    the *x* and *y* dimensions of the matrix with *z* colors here, and most tiles
    of this map are empty due to the high amount of missing values in *z*. Also, it's
    pretty straightforward now that the dataset includes many airports outside the
    USA as well. How does it look if we focus only on the USA?
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，这似乎一点用处都没有。那里展示了什么？我们在这里用 *z* 颜色渲染了矩阵的 *x* 和 *y* 维度，由于 *z* 轴上缺失值的高数量，这张地图的大部分图块都是空的。此外，现在很明显，数据集中还包括许多位于美国以外的机场。如果我们只关注美国，它会是什么样子？
- en: '[PRE23]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '![Contour lines](img/2028OS_13_07.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![等高线](img/2028OS_13_07.jpg)'
- en: Note
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: An alternative and more elegant approach to rendering only the US part of the
    matrix would be to drop the non-US airports from the database before actually
    creating the `out` R object. Although we will continue with this example for didactic
    purposes, with real data make sure that you concentrate on the target subset of
    your data instead of trying to smooth and model unrelated data points as well.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种更优雅的方法是，在实际上创建 `out` R 对象之前，从数据库中删除非美国机场。虽然我们将继续使用这个例子进行教学，但在实际数据中，请确保您专注于数据的目标子集，而不是尝试平滑和建模无关的数据点。
- en: 'A lot better! So we have our data points as a tile, now let''s try to identify
    the slope of these mountain peaks, to be able to render them on a future map.
    This can be done by smoothing the matrix:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 好多了！所以我们的数据点现在以图块的形式呈现，现在让我们尝试识别这些山峰的斜率，以便能够在未来的地图上渲染它们。这可以通过平滑矩阵来完成：
- en: '[PRE24]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'As can be seen in the preceding table, this algorithm successfully eliminated
    many missing values from the matrix. The `image.smooth` function basically reused
    our initial data point values in the neighboring tiles, and computed some kind
    of average for the conflicting overrides. This smoothing algorithm results in
    the following arbitrary map, which does not respect any political or geographical
    boundaries:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如前表所示，该算法成功从矩阵中消除了许多缺失值。`image.smooth` 函数基本上在我们的初始数据点值中重新使用了相邻图块，并计算了一些冲突覆盖的平均值。这种平滑算法产生了以下任意地图，它不尊重任何政治或地理边界：
- en: '[PRE25]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '![Contour lines](img/2028OS_13_08.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![等高线](img/2028OS_13_08.jpg)'
- en: 'It would be really nice to plot these artificial polygons along with the administrative
    boundaries, so let''s clear out all cells that do not belong to the territory
    of the USA. We will use the `point.in.polygon` function from the `sp` package
    to do so:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果能将这些人工多边形与行政边界一起绘制出来，那就太好了。让我们清除所有不属于美国领土的单元。我们将使用`sp`包中的`point.in.polygon`函数来完成此操作：
- en: '[PRE26]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In a nutshell, we have loaded the main polygon of the USA without any sub-administrative
    areas, and verified our cells in the `look` object, if those are overlapping the
    polygon. Then we simply reset the value of the cell, if not.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，我们加载了美国的主要多边形，没有包含任何次级行政区域，并在`look`对象中验证了我们的单元，如果它们与多边形重叠。然后，如果没有重叠，我们简单地重置单元的值。
- en: 'The next step is to render the boundaries of the USA, plot our smoothed contour
    plot, then add some eye-candy in the means of the US states and, the main point
    of interest, the airport:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是渲染美国的边界，绘制我们的平滑等高线图，然后在地图上添加一些关于美国各州的美观元素，以及主要关注点——机场：
- en: '[PRE27]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '![Contour lines](img/2028OS_13_09.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![等高线](img/2028OS_13_09.jpg)'
- en: Now this is pretty neat, isn't it?
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看起来相当不错，不是吗？
- en: Voronoi diagrams
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Voronoi图
- en: 'An alternative way of visualizing point data with polygons is to generate *Voronoi*
    cells between them. In short, the Voronoi map partitions the space into regions
    around the data points by aligning all parts of the map to one of the regions
    to minimize the distance from the central data points. This is extremely easy
    to interpret, and also to implement in R. The `deldir` package provides a function
    with the very same name for Delaunay triangulation:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 使用多边形可视化点数据的一种替代方法是生成它们之间的Voronoi单元。简而言之，Voronoi地图通过将地图的所有部分对齐到其中一个区域以最小化中心数据点的距离，将空间划分为围绕数据点的区域。这在R中实现起来非常容易，`deldir`包提供了一个具有相同名称的函数用于Delaunay三角剖分：
- en: '[PRE28]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '![Voronoi diagrams](img/2028OS_13_10.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![Voronoi图](img/2028OS_13_10.jpg)'
- en: Here, we represented the airports with red dots, as we did before, but also
    added the Dirichlet tessellation (Voronoi cells) rendered as dark-gray dashed
    lines. For more options on how to fine-tune the results, see the `plot.deldir`
    method.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们用红色点表示机场，就像之前一样，但还添加了以深灰色虚线渲染的Dirichlet划分（Voronoi单元）。有关如何微调结果的更多选项，请参阅`plot.deldir`方法。
- en: In the next section, let's see how to improve this plot by adding a more detailed
    background map to it.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，让我们看看如何通过添加更详细的背景地图来改进这个图表。
- en: Satellite maps
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 卫星地图
- en: There are many R packages on CRAN that can fetch data from Google Maps, Stamen,
    Bing, or OpenStreetMap—even some of the packages that we have previously used
    in this chapter, such as the `ggmap` package, can do this. Similarly, the `dismo`
    package also comes with both geo-coding and Google Maps API integration capabilities,
    and there are some other packages focused on that latter, such as the `RgoogleMaps`
    package.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: CRAN上有许多R包可以从Google Maps、Stamen、Bing或OpenStreetMap获取数据，甚至我们在这章中之前使用的一些包，如`ggmap`包，也可以这样做。同样，`dismo`包也提供了地理编码和Google
    Maps API集成功能，还有一些其他专注于这一领域的包，如`RgoogleMaps`包。
- en: 'Now we will use the `OpenStreetMap` package, mainly because it supports not
    only the awesome OpenStreetMap database back-end, but also a bunch of other formats
    as well. For example, we can render really nice terrain maps via Stamen:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将使用`OpenStreetMap`包，主要是因为它不仅支持令人惊叹的OpenStreetMap数据库后端，还支持许多其他格式。例如，我们可以通过Stamen渲染出非常漂亮的地面地图：
- en: '[PRE29]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'So we defined the left upper and right lower corners of the map we need, and
    also specified the map style to be a satellite map. As the data by default arrives
    from the remote servers with the Mercator projections, we first have to transform
    that to WGS84 (we used this previously), so that we can render the points and
    polygons on the top of the fetched map:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们定义了所需地图的左上角和右下角，并指定地图样式为卫星地图。由于默认情况下数据来自远程服务器，使用墨卡托投影，我们首先必须将其转换为WGS84（我们之前使用过），这样我们才能在获取的地图上渲染点和多边形：
- en: '[PRE30]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'And showtime at last:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，展示时间到了：
- en: '[PRE31]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '![Satellite maps](img/2028OS_13_11.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![卫星地图](img/2028OS_13_11.jpg)'
- en: This seems to be a lot better compared to the outline map we created previously.
    Now you can try some other map styles as well, such as `mapquest-aerial`, or some
    of the really nice-looking `cloudMade` designs.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前创建的轮廓地图相比，这似乎要好得多。现在你也可以尝试一些其他的地图样式，比如`mapquest-aerial`，或者一些看起来非常漂亮的`cloudMade`设计。
- en: Interactive maps
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 交互式地图
- en: Besides being able to use Web-services to download map tiles for the background
    of the maps created in R, we can also rely on some of those to generate truly
    interactive maps. One of the best known related services is the Google Visualization
    API, which provides a platform for hosting visualizations made by the community;
    you can also use it to share maps you've created with others.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 除了能够使用Web服务下载在R中创建的地图背景图块之外，我们还可以依赖其中的一些来生成真正交互式的地图。其中最知名的相关服务之一是Google Visualization
    API，它为社区制作的可视化提供了一个托管平台；你也可以用它与他人分享你创建的地图。
- en: Querying Google Maps
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查询谷歌地图
- en: In R, you can access this API via the `googleVis` package written and maintained
    by Markus Gesmann and Diego de Castillo. Most functions of the package generate
    HTML and JavaScript code that we can directly view in a Web browser as an `SVG`
    object with the `base` plot function; alternatively, we can integrate them in
    a Web page, for example via the IFRAME HTML tag.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在R中，你可以通过由Markus Gesmann和Diego de Castillo编写和维护的`googleVis`包访问这个API。该包的大多数函数生成HTML和JavaScript代码，我们可以直接在Web浏览器中以`SVG`对象的形式通过`base`绘图函数查看；或者，我们也可以通过例如IFRAME
    HTML标签将它们集成到网页中。
- en: 'The `gvisIntensityMap` function takes a `data.frame` with country ISO or USA
    state codes and the actual data to create a simple intensity map. We will use
    the `cancels` dataset we created in the *Finding Polygon Overlays of Point Data*
    section, but before that, we have to do some data transformations. Let''s add
    the state name as a new column to the `data.frame`, and replace the missing values
    with zero:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`gvisIntensityMap`函数接受一个包含国家ISO或美国州代码以及实际数据的`data.frame`，以创建一个简单的强度地图。我们将使用在*寻找点数据的多边形叠加*部分创建的`cancels`数据集，但在那之前，我们必须进行一些数据转换。让我们向`data.frame`添加一个新列作为州名，并用零替换缺失值：'
- en: '[PRE32]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now it''s time to load the package and pass the data along with a few extra
    parameters, signifying that we want to generate a state-level US map:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候加载包并传递数据以及一些额外的参数，表示我们想要生成一个州级别的美国地图：
- en: '[PRE33]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '![Querying Google Maps](img/2028OS_13_12.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![查询谷歌地图](img/2028OS_13_12.jpg)'
- en: The package also offers opportunities to query the Google Map API via the `gvisMap`
    function. We will use this feature to render the airports from the `dt` dataset
    as points on a Google Map with an auto-generated tooltip of the variables.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 该包还提供了通过`gvisMap`函数查询Google Map API的机会。我们将使用这个功能将`dt`数据集中的机场渲染为谷歌地图上的点，并自动生成变量的工具提示。
- en: 'But first, as usual, we have to do some data transformations again. The location
    argument of the `gvisMap` function takes the latitude and longitude values separated
    by a colon:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，像往常一样，我们又要进行一些数据转换。`gvisMap`函数的位置参数接受由冒号分隔的纬度和经度值：
- en: '[PRE34]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We also have to generate the tooltips as a new variable, which can be done
    easily with an `apply` call. We will concatenate the variable names and actual
    values separated by a HTML line break:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须生成一个新的变量作为工具提示，这可以通过一个`apply`调用轻松完成。我们将变量名称和实际值通过HTML换行符连接起来：
- en: '[PRE35]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'And now we just pass these arguments to the function for an instant interactive
    map:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只需将这些参数传递给函数，就可以立即得到一个交互式地图：
- en: '[PRE36]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '![Querying Google Maps](img/2028OS_13_13.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![查询谷歌地图](img/2028OS_13_13.jpg)'
- en: 'Another nifty feature of the `googleVis` package is that you can easily merge
    the different visualizations into one by using the `gvisMerge` function. The use
    of this function is quite simple: specify any two `gvis` objects you want to merge,
    and also whether they are to be placed horizontally or vertically.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`googleVis`包的另一个巧妙功能是，你可以通过使用`gvisMerge`函数轻松地将不同的可视化合并为一个。这个函数的使用相当简单：指定任何两个你想要合并的`gvis`对象，以及它们是水平还是垂直放置。'
- en: JavaScript mapping libraries
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JavaScript映射库
- en: 'The great success of the trending JavaScript data visualization libraries is
    only partly due to their great design. I suspect other factors also contribute
    to the general spread of such tools: it''s very easy to create and deploy full-blown
    data models, especially since the release and on-going development of Mike Bostock''s
    D3.js.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 趋势JavaScript数据可视化库的成功不仅仅是因为它们优秀的设计。我怀疑其他因素也促进了这些工具的普遍传播：创建和部署完整的数据模型非常容易，尤其是在Mike
    Bostock的D3.js发布和持续开发之后。
- en: Although there are also many really useful and smart R packages to interact
    directly with D3 and topojson (see for example my R user activity compilation
    at [http://bit.ly/countRies](http://bit.ly/countRies)). Now we will only focus
    on how to use Leaflet— probably the most used JavaScript library for interactive
    maps.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管也有许多非常实用和智能的R包可以直接与D3和topojson交互（例如，请参阅我的R用户活动汇编[http://bit.ly/countRies](http://bit.ly/countRies)）。现在我们只关注如何使用Leaflet——可能是最常用的JavaScript交互式地图库。
- en: What I truly love in R is that there are many packages wrapping other tools,
    so that R users can rely on only one programming language, and we can easily use
    C++ programs and Hadoop MapReduce jobs or build JavaScript-powered dashboards
    without actually knowing anything about the underlying technology. This is especially
    true when it comes to Leaflet!
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我真正喜欢R的是，有许多包封装了其他工具，这样R用户就可以只依赖一种编程语言，我们可以轻松地使用C++程序和Hadoop MapReduce作业或构建JavaScript驱动的仪表板，而实际上对底层技术一无所知。这尤其适用于Leaflet！
- en: There are at least two very nice packages that can generate a Leaflet plot from
    the R console, without a single line of JavaScript. The `Leaflet` reference class
    of the `rCharts` package was developed by Ramnath Vaidyanathan, and includes some
    methods to create a new object, set the viewport and zoom level, add some points
    or polygons to the map, and then render or print the generated HTML and JavaScript
    code to the console or to a file.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 至少有两个非常棒的包可以从R控制台生成Leaflet图，而不需要一行JavaScript。`rCharts`包的`Leaflet`参考类是由Ramnath
    Vaidyanathan开发的，包括一些创建新对象、设置视口和缩放级别、向地图添加一些点或多边形的方法，然后将生成的HTML和JavaScript代码渲染或打印到控制台或文件中。
- en: 'Unfortunately, this package is not on CRAN yet, so you will have to install
    it from GitHub:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这个包还没有在CRAN上，所以您必须从GitHub上安装它：
- en: '[PRE37]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'As a quick example, let''s generate a Leaflet map of the airports with some
    tooltips, like we did with the Google Maps API in the previous section. As the
    `setView` method expects numeric geo-coordinates as the center of the map, we
    will use Kansas City''s airport as a reference:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 作为快速示例，让我们生成一个带有一些工具提示的Leaflet机场地图，就像我们在上一节中使用Google Maps API所做的那样。由于`setView`方法期望将数值地理坐标作为地图的中心，我们将使用堪萨斯城的机场作为参考：
- en: '[PRE38]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '![JavaScript mapping libraries](img/2028OS_13_14.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![JavaScript映射库](img/2028OS_13_14.jpg)'
- en: 'Similarly, RStudio''s `leaflet` package and the more general `htmlwidgets`
    package also provide some easy ways to generate JavaScript-powered data visualizations.
    Let''s load the library and define the steps one by one using the pipe operator
    from the `magrittr` package, which is pretty standard for all packages created
    or inspired by RStudio or Hadley Wickham:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，RStudio的`leaflet`包和更通用的`htmlwidgets`包也提供了一些简单的方法来生成JavaScript驱动的数据可视化。让我们加载库，并使用`magrittr`包中的管道操作符一步一步定义步骤，这对于所有由RStudio或Hadley
    Wickham创建或受其启发的包来说都是相当标准的：
- en: '[PRE39]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '![JavaScript mapping libraries](img/2028OS_13_15.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![JavaScript映射库](img/2028OS_13_15.jpg)'
- en: I especially like this preceding map, as we can load a third-party satellite
    map in the background, then render the states as polygons; we also added the original
    data points along with some useful tooltips on the very same map with literally
    a one-line R command. We could even color the state polygons based on the aggregated
    results we computed in the previous sections! Ever tried to do the same in Java?
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我特别喜欢这张地图，因为我们可以在背景中加载第三方卫星地图，然后以多边形的形式渲染各州；我们还添加了原始数据点以及一些有用的工具提示，在同一个地图上仅用一行R命令即可实现。我们甚至可以根据我们在上一节中计算出的汇总结果来着色州的多边形！你尝试过在Java中做同样的事情吗？
- en: Alternative map designs
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不同的地图设计
- en: Besides being able to use third-party tools, another main reason why I tend
    to use R for all my data analysis tasks is that R is extremely powerful in creating
    custom data exploration, visualization, and modeling designs.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 除了能够使用第三方工具外，我倾向于使用R来完成所有数据分析任务的主要原因之一是R在创建自定义数据探索、可视化和建模设计方面非常强大。
- en: As an example, let's create a flow-map based on our data, where we will highlight
    the flights from Houston based on the number of actual and cancelled flights.
    We will use lines and circles to render these two variables on a 2-dimensional
    map, and we will also add a contour plot in the background based on the average
    time delay.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们基于我们的数据创建一个流图，我们将根据实际和取消的航班数量突出显示休斯顿的航班。我们将使用线条和圆圈在二维地图上渲染这两个变量，并且我们还将根据平均延误时间在背景中添加一个等高线图。
- en: 'But, as usual, let''s do some data transformations first! To keep the number
    of flows at a minimal level, let''s get rid of the airports outside the USA at
    last:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 但，像往常一样，我们先进行一些数据转换！为了将流量数量保持在最低水平，最后让我们去掉美国以外的机场：
- en: '[PRE40]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We will need the `diagram` package (to render curved arrows from Houston to
    the destination airports) and the `scales` package to create transparent colors:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要`diagram`包（用于从休斯顿到目的地的机场绘制曲线箭头）和`scales`包来创建透明颜色：
- en: '[PRE41]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Then, let''s render the contour map described in the *Contour Lines* section:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，让我们绘制*等高线*部分中描述的等高线图：
- en: '[PRE42]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'And then add a curved line from Houston to each of the destination airports,
    where the width of the line represents the number of cancelled flights and the
    diameter of the target circles shows the number of actual flights:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 然后从休斯顿到每个目的地机场添加一条曲线，其中线的宽度代表取消的航班数量，目标圆的直径显示实际航班的数量：
- en: '[PRE43]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '![Alternative map designs](img/2028OS_13_16.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![替代地图设计](img/2028OS_13_16.jpg)'
- en: Well, this chapter ended up being about visualizing spatial data, and not really
    about analyzing spatial data by fitting models, filtering raw data, and looking
    for spatial effects. In the last section of the chapter, let's see how one can
    start using analytical approaches with spatial data.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这一章最终是关于可视化空间数据，而不是真正通过拟合模型、过滤原始数据和寻找空间效应来分析空间数据。在这一章的最后部分，让我们看看如何开始使用空间数据分析方法。
- en: Spatial statistics
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 空间统计学
- en: Most exploratory data analysis projects dealing with spatial data start by looking
    for, and potentially filtering, spatial autocorrelation. In simple terms, this
    means that we are looking for spatial effects in the data—for instance, the similarities
    of some data points can be (partly) explained by the short distance between them;
    further points seem to differ a lot more. There is nothing surprising in this
    statement; probably all of you agree with this. But how can we test this on real
    data with analytical tools?
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数处理空间数据的数据探索分析项目都是从寻找和潜在过滤空间自相关开始的。简单来说，这意味着我们在寻找数据中的空间效应——例如，某些数据点的相似性可以（部分）由它们之间的短距离解释；更远的点似乎差异更大。这个陈述并不令人惊讶；可能你们所有人都同意这一点。但我们如何使用分析工具在真实数据上测试这一点呢？
- en: '*Moran''s I index* is a well-known and generally used measure to test whether
    spatial autocorrelation is present or not in the variable of interest. This is
    a quite simple statistical test with the null hypothesis that there is no spatial
    autocorrelation in the dataset.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '*Moran''s I指数*是众所周知且普遍使用的衡量标准，用于测试感兴趣变量中是否存在空间自相关。这是一个相当简单的统计检验，其零假设是数据集中不存在空间自相关。'
- en: 'With the current data structure we have, probably the easiest way to compute
    Moran''s I is to load the `ape` package, and pass the similarity matrix along
    with the variable of interest to the `Moran.I` function. First, let''s compute
    this similarity matrix by the inverse of the Euclidian distance matrix:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们目前的数据结构，计算Moran's I最简单的方法可能是加载`ape`包，并将相似性矩阵以及感兴趣的变量传递给`Moran.I`函数。首先，让我们通过欧几里得距离矩阵的逆来计算这个相似性矩阵：
- en: '[PRE44]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Then let''s replace all possible missing values (because the number of flights
    can be one as well, resulting in zero variance) in the `TimeVar` column, and let''s
    see if there is any spatial autocorrelation in the variance of the actual elapsed
    time of the flights:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 然后让我们替换掉`TimeVar`列中所有可能缺失的值（因为航班数量也可能是一个，导致方差为零），并看看航班的实际耗时方差中是否存在任何空间自相关：
- en: '[PRE45]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This was pretty easy, wasn't it? Based on the returned `P` value, we can reject
    the null hypothesis, and the `0.19` Moran's I suggests that the variation in the
    elapsed flight time is affected by the location of the destination airports, probably
    due to the very different distances.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当简单，不是吗？基于返回的`P`值，我们可以拒绝零假设，而`0.19`的Moran's I指数表明，航班耗时变化受到目的地机场位置的影响，这可能是由于非常不同的距离造成的。
- en: 'A reverse dependency of the previously mentioned `sp` package, the `spdep`
    package can also compute this index, although we have to first transform the similarity
    matrix into a list object:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 之前提到的`sp`包的反向依赖项，`spdep`包也可以计算这个指数，尽管我们首先必须将相似性矩阵转换为列表对象：
- en: '[PRE46]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Although the test results are similar to the previous run, and we can reject
    the null hypothesis of zero spatial autocorrelation in the data, the Moran's I
    index and the `P` values are not identical. This is mainly due to the fact that
    the `ape` package used weight matrix for the computation, while the `moran.test`
    function was intended to be used with polygon data, as it requires the neighbor
    lists of the data. Well, as our example included point data, this is not a clean-cut
    solution. Another main difference between the approaches is that the `ape` package
    uses normal approximation, while `spdep` implements randomization. But this difference
    is still way too high, isn't it?
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管测试结果与之前的运行相似，我们可以拒绝数据中零空间自相关的零假设，但Moran's I指数和`P`值并不相同。这主要是因为`ape`包使用了权重矩阵进行计算，而`moran.test`函数旨在与多边形数据一起使用，因为它需要数据的邻域列表。嗯，由于我们的例子包括点数据，这不是一个干净利落的解决方案。这两种方法之间的另一个主要区别是，`ape`包使用正态近似，而`spdep`实现随机化。但这个差异仍然太高，不是吗？
- en: 'Reading the function documentation reveals that we can improve the `spdep`
    approach: when converting the `matrix` into a `listw` object, we can specify the
    actual type of the originating matrix. In our case, as we are using the inverse
    distance matrix, a row-standardized style seems more appropriate:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读函数文档可以发现，我们可以改进`spdep`方法：在将`matrix`转换为`listw`对象时，我们可以指定原始矩阵的实际类型。在我们的案例中，因为我们使用的是逆距离矩阵，所以行标准化样式似乎更合适：
- en: '[PRE47]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Now the differences between this and the `ape` results are in an acceptable
    range, right?
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的`ape`结果与我们的差异在可接受的范围内，对吧？
- en: Unfortunately, this section cannot cover related questions or other statistical
    methods dealing with spatial data, but there are many really useful books out
    there dedicated to the topic. Please be sure to check the *Appendix* at the end
    of the book for some suggested titles.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 很遗憾，本节无法涵盖与空间数据相关的其他问题或统计方法，但市面上有许多专门针对这一主题的非常有用的书籍。请务必查看本书末尾的*附录*，以获取一些推荐的标题。
- en: Summary
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Congratulations, you have just finished the last systematic chapter of the book!
    Here, we focused on how to analyze spatial data mainly with data visualization
    tools.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你，你已经完成了本书的最后一章系统性的章节！在这里，我们主要关注了如何使用数据可视化工具来分析空间数据。
- en: Now let's see how we can combine the methods learned in the previous chapters.
    In the final part of the book, we will analyze the R community with various data
    science tools. If you liked this chapter, I am sure you will enjoy the final one
    as well.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何将前几章学到的方法结合起来。在本书的最后部分，我们将使用各种数据科学工具来分析R社区。如果你喜欢这一章，我确信你也会喜欢最后一章。
