- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Constraint Satisfaction
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 约束满足
- en: In this chapter, you will learn how genetic algorithms can be utilized to solve
    constraint satisfaction problems. We will start by describing the concept of constraint
    satisfaction and how it applies to search problems and combinatorial optimization.
    Then, we will look at several hands-on examples of constraint satisfaction problems
    and their Python-based solutions using the DEAP framework. The problems we will
    cover include the well-known **N-Queen** problem, followed by the **nurse scheduling**
    problem, and finally the **graph coloring** problem. Along the way, we will learn
    the difference between **hard and soft constraints**, as well as how they can
    be incorporated into the solution process.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何利用遗传算法解决约束满足问题。我们将从描述约束满足的概念开始，并讨论它如何应用于搜索问题和组合优化。然后，我们将通过几个实际示例，展示约束满足问题及其基于
    Python 的解决方案，使用 DEAP 框架。我们将讨论的问题包括著名的**N-皇后**问题，接着是**护士排班**问题，最后是**图着色**问题。在此过程中，我们将了解**硬约束和软约束**之间的区别，并学习如何将它们纳入解决过程。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Understanding the nature of constraint satisfaction problems
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解约束满足问题的性质
- en: Solving the N-Queens problem using a genetic algorithm coded with the DEAP framework
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 DEAP 框架编写的遗传算法解决 N-皇后问题
- en: Solving an example of the nurse scheduling problem using a genetic algorithm
    coded with the DEAP framework
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 DEAP 框架编写的遗传算法解决护士排班问题的示例
- en: Solving the graph coloring problem using a genetic algorithm coded with the
    DEAP framework
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 DEAP 框架编写的遗传算法解决图着色问题
- en: Understanding the concepts of hard and soft constraints, as well as how to apply
    them when solving a problem
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解硬约束和软约束的概念，以及在解决问题时如何应用它们
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In this chapter, we will be using Python 3 with the following supporting libraries:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用 Python 3 和以下支持库：
- en: '**deap**'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**deap**'
- en: '**numpy**'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**numpy**'
- en: '**matplotlib**'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**matplotlib**'
- en: '**seaborn**'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**seaborn**'
- en: '**networkx** – introduced in this chapter'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**networkx** – 本章介绍'
- en: Important note
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: If you’re using the **requirements.txt** file we’ve provided (see [*Chapter
    3*](B20851_03.xhtml#_idTextAnchor091)), these libraries will already be in your
    environment.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是我们提供的 **requirements.txt** 文件（参见 [*第三章*](B20851_03.xhtml#_idTextAnchor091)），这些库将在您的环境中。
- en: The programs that will be used in this chapter can be found in this book’s GitHub
    repository at [https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/tree/main/chapter_05](https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/tree/main/chapter_05).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中将使用的程序可以在本书的 GitHub 仓库中找到，链接为 [https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/tree/main/chapter_05](https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/tree/main/chapter_05)。
- en: 'Check out the following video to see the Code in Action: [https://packt.link/OEBOd](https://packt.link/OEBOd).'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频，了解代码的实际应用：[https://packt.link/OEBOd](https://packt.link/OEBOd)。
- en: Constraint satisfaction in search problems
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 搜索问题中的约束满足
- en: In the previous chapter, we looked at solving search problems, which focused
    on methodically evaluating states and transitions between states. Every state
    transition typically involves a cost or gain, and the objective of the search
    was to minimize the cost or maximize the gain. Constraint satisfaction problems
    are a *variant* of search problems, where the states must satisfy several constraints
    or limitations. If we can translate the various violations of constraints into
    cost and then strive to minimize the cost, solving a constraint satisfaction problem
    can resemble solving a general search problem.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们研究了如何解决搜索问题，重点是有条不紊地评估状态及其状态之间的转变。每个状态转变通常涉及到成本或收益，搜索的目标是最小化成本或最大化收益。约束满足问题是搜索问题的一种*变体*，其中状态必须满足多个约束或限制。如果我们能将各种约束违反转化为成本，并努力最小化成本，那么解决约束满足问题就可以类似于解决一般的搜索问题。
- en: Like combinatorial optimization problems, constraint satisfaction problems have
    important applications in fields such as artificial intelligence, operations research,
    and pattern matching. A better understanding of these problems may help in solving
    numerous types of problems that may seem unrelated at first glance. Constraint
    satisfaction problems often exhibit high complexity, which makes genetic algorithms
    a suitable candidate for solving them.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 像组合优化问题一样，约束满足问题在人工智能、运筹学和模式匹配等领域有重要应用。更好地理解这些问题有助于解决看似无关的各种问题。约束满足问题通常具有高度复杂性，这使得遗传算法成为解决它们的合适候选方法。
- en: The **N-Queens** problem, which will be presented in the next section, illustrates
    the concept of constraint satisfaction problems and demonstrates how they can
    be solved in a very similar manner to the problems we looked at in the previous
    chapter.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**N 皇后**问题将在下一节中介绍，展示了约束满足问题的概念，并演示了如何以与我们在上一章中研究的问题非常相似的方式来解决这些问题。'
- en: Solving the N-Queens problem
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决 N 皇后问题
- en: Originally known as the *eight-queen puzzle*, the classic N-Queens problem originated
    from the game of chess, and the *8x8* chessboard was its early playground. The
    task was to place eight chess queens on the board without any two of them threatening
    each other. In other words, no two queens can share the same row, same column,
    or same diagonal. The N-Queens problem is similar, using an *N×N* chessboard and
    *N* chess queens.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 最初被称为 *八皇后谜题* 的经典 N 皇后问题源自国际象棋游戏，*8x8* 棋盘是它的早期舞台。任务是将八个国际象棋皇后放置在棋盘上，确保它们之间没有任何威胁。换句话说，任何两只皇后都不能在同一行、同一列或同一对角线上。N
    皇后问题类似，使用一个 *N×N* 的棋盘和 *N* 个国际象棋皇后。
- en: 'The problem is known to have a solution for any natural number, *n*, except
    for the cases of *n=2* and *n=3*. For the original eight-queen case, there are
    92 solutions, or 12 unique solutions if we consider symmetrical solutions to be
    identical. One of the solutions is as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 已知对于任何自然数 *n*，除了 *n=2* 和 *n=3* 的情况外，该问题都有解。对于最初的八皇后问题，有 92 种解，或者如果将对称解视为相同，则有
    12 种唯一解。以下是其中一种解：
- en: '![Figure 5.1: One of the 92 possible solutions for the eight-queen puzzle](img/B20851_05_01.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.1：八皇后谜题的 92 种可能解之一](img/B20851_05_01.jpg)'
- en: 'Figure 5.1: One of the 92 possible solutions for the eight-queen puzzle'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1：八皇后谜题的 92 种可能解之一
- en: By applying combinatorics, the count of all possible ways to place eight pieces
    on the *8×8* board yields 4,426,165,368 combinations. However, if we can create
    our candidate solutions in a way that ensures that no two queens will be placed
    on the same row or the same column, the number of possible combinations is dramatically
    reduced to *8!* (factorial of 8), which amounts to 40,320\. We are going to take
    advantage of this idea in the next subsection when we choose the way our solution
    to this problem will be represented.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 通过应用组合数学，计算在 *8×8* 棋盘上放置八个棋子的所有可能方式，得到 4,426,165,368 种组合。然而，如果我们能以确保没有两只皇后被放置在同一行或同一列的方式来生成候选解，则可能的组合数量会大大减少，变为
    *8!*（8 的阶乘），即 40,320。我们将在下一小节中利用这一思想来选择我们解决此问题的表示方式。
- en: Solution representation
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解的表示
- en: When solving the N-Queens problem, we can take advantage of the knowledge that
    each row will host exactly one queen, and no two queens will share the same column.
    This means we can represent any candidate solution as an ordered list of integers
    – or a list of indices, with each index representing the column that one of the
    queens occupies for the current row.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决 N 皇后问题时，我们可以利用每一行都会恰好放置一只皇后，且没有两只皇后会在同一列的知识。这意味着我们可以将任何候选解表示为一个有序整数列表——或者一个索引列表，每个索引表示当前行中皇后所在的列。
- en: 'For example, in a four-queen problem over a 4×4 chessboard, we have the following
    list of indices:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在一个 4×4 的棋盘上解决四后问题时，我们有以下索引列表：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This translates to the following positions:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这转换为以下位置：
- en: In the first row, the queen is placed in position 3 (fourth column)
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第一行，皇后被放置在位置 3（第四列）。
- en: In the second row, the queen is placed in position 2 (third column).
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第二行，皇后被放置在位置 2（第三列）。
- en: In the third row, the queen is placed in position 0 (first column)
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第三行，皇后被放置在位置 0（第一列）。
- en: In the fourth row, the queen is placed in position 1 (second column)
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第四行，皇后被放置在位置 1（第二列）。
- en: 'This is depicted in the following figure:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如下图所示：
- en: '![Figure 5.2: Illustration of the queen arrangement represented by the list
    [3, 2, 0, 1]](img/B20851_05_02.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.2：由列表[3, 2, 0, 1]表示的皇后排列示意图](img/B20851_05_02.jpg)'
- en: 'Figure 5.2: Illustration of the queen arrangement represented by the list [3,
    2, 0, 1]'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2：由列表[3, 2, 0, 1]表示的皇后排列示意图
- en: 'Similarly, another arrangement of the indices may look as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，索引的另一种排列可能如下所示：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This arrangement represents the candidate solution shown in the following figure:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 该排列表示以下图示中的候选解：
- en: '![Figure 5.3: Illustration of the queen arrangement represented by the list
    [1, 3, 0, 2]](img/B20851_05_03.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.3：由列表[1, 3, 0, 2]表示的皇后排列示意图](img/B20851_05_03.jpg)'
- en: 'Figure 5.3: Illustration of the queen arrangement represented by the list [1,
    3, 0, 2]'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3：由列表[1, 3, 0, 2]表示的皇后排列示意图
- en: The only constraint violations that are possible in candidate solutions represented
    this way are shared diagonals between pairs of queens.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式表示的候选解中唯一可能的约束冲突是皇后对之间共享的对角线。
- en: 'For example, the first candidate solution we discussed contains two violations,
    as shown here:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们讨论的第一个候选解包含两个违反约束条件的情况，如下所示：
- en: '![Figure 5.4: Illustration of the queen arrangement represented by the list
    [3, 2, 0, 1], with constraint violations indicated](img/B20851_05_04.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.4：由列表[3, 2, 0, 1]表示的皇后排列示意图，标明了约束条件冲突](img/B20851_05_04.jpg)'
- en: 'Figure 5.4: Illustration of the queen arrangement represented by the list [3,
    2, 0, 1], with constraint violations indicated'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4：由列表[3, 2, 0, 1]表示的皇后排列示意图，标明了约束条件冲突
- en: However, the preceding one exhibited no violations.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，前面的排列没有违反任何约束条件。
- en: This means that, when evaluating the solutions that are represented in this
    way, we only need to find and count the shared diagonals between the positions
    they stand for.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，在评估以这种方式表示的解时，我们只需要找到并计算它们所代表位置之间共享的对角线。
- en: The solution representation we just discussed is a central part of the Python
    class that we will describe in the next subsection.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚讨论的解表示方法是Python类的核心部分，我们将在下一小节中描述该类。
- en: Python problem representation
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python问题表示
- en: 'To encapsulate the N-Queens problem, we’ve created a Python class called `NQueensProblem`.
    This class can be found in the `queens.py` file of this book’s GitHub repository:
    [https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_05/queens.py](https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_05/queens.py).'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为了封装N皇后问题，我们创建了一个名为`NQueensProblem`的Python类。该类可以在本书GitHub仓库中的`queens.py`文件找到：[https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_05/queens.py](https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_05/queens.py)。
- en: 'The class is initialized with the desired size of the problem and provides
    the following public methods:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 该类以问题的期望大小进行初始化，并提供以下公共方法：
- en: '**getViolationsCount(positions)**: This calculates the number of violations
    in the given solution, which is represented by a list of indices, as discussed
    in the previous subsection'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**getViolationsCount(positions)**：此函数计算给定解中违反约束条件的数量，该解由索引列表表示，如前一小节所述'
- en: '**plotBoard(positions)**: This plots the positions of the queens on the board
    according to the given solution'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**plotBoard(positions)**：此函数根据给定的解绘制皇后在棋盘上的位置'
- en: 'The `main` method of the class exercises the class methods by creating an eight-queen
    problem and testing the following candidate solution for it:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 该类的`main`方法通过创建一个八皇后问题并测试以下候选解来运用该类方法：
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This is followed by plotting the candidate solution and calculating the number
    of constraint violations.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 随后绘制候选解并计算违反约束条件的数量。
- en: 'The resulting output is shown here:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 结果输出如下：
- en: '[PRE3]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The plot for this is as follows – can you spot all three violations?
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是该问题的图示——你能找出所有三个违反约束条件的情况吗？
- en: '![Figure 5.5: Illustration of the eight-queen arrangement represented by the
    list [1, 2, 7, 5, 0, 3, 4, 6]](img/B20851_05_05.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.5：由列表[1, 2, 7, 5, 0, 3, 4, 6]表示的八皇后排列示意图](img/B20851_05_05.jpg)'
- en: 'Figure 5.5: Illustration of the eight-queen arrangement represented by the
    list [1, 2, 7, 5, 0, 3, 4, 6]'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.5：由列表[1, 2, 7, 5, 0, 3, 4, 6]表示的八皇后排列示意图
- en: In the next subsection, we will apply the genetic algorithm approach to solving
    the N- Queens problem.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一小节中，我们将应用遗传算法方法来解决N皇后问题。
- en: Genetic algorithms solution
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 遗传算法解法
- en: To solve the N-Queens problem using a genetic algorithm, we’ve created a Python
    program called `01-solve-n-queens.py`, which is located at [https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_05/01_solve_n_queens.py](https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_05/01_solve_n_queens.py).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用遗传算法解决N皇后问题，我们创建了一个名为`01-solve-n-queens.py`的Python程序，该程序位于[https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_05/01_solve_n_queens.py](https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_05/01_solve_n_queens.py)。
- en: Since the solution representation we chose for this problem is a list (or an
    array) of indices, which is similar to the representation we used for the **traveling
    salesman problem** (**TSP**) and the **vehicle routing problem** (**VRP**) in
    [*Chapter 4*](B20851_04.xhtml#_idTextAnchor155), *Combinatorial Optimization*,
    we can utilize a similar genetic approach to the one we used there. In addition,
    we’ll take advantage of **elitism** once more by reusing the elitist version that
    we created for DEAP’s simple genetic flow.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们为此问题选择的解决方案表示是一个索引的列表（或数组），类似于我们在[*第4章*](B20851_04.xhtml#_idTextAnchor155)中为**旅行商问题**（**TSP**）和**车辆路径规划问题**（**VRP**）使用的表示，我们可以利用类似的遗传方法，正如我们在那里使用的那样。此外，我们将再次利用**精英主义**，通过重用我们为DEAP的简单遗传流程创建的精英版本。
- en: 'The following steps describe the main parts of our solution:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤描述了我们解决方案的主要部分：
- en: 'Our program starts by creating an instance of the **NQueensProblem** class
    using the size of the problem we would like to solve:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的程序通过使用我们希望解决的问题的大小，创建**NQueensProblem**类的实例来开始：
- en: '[PRE4]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Since our goal is to minimize the count of violations (hopefully to a value
    of 0), we define a single objective, minimizing the fitness strategy:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们的目标是最小化冲突数量（希望达到0），我们定义了一个单一目标，即最小化适应度策略：
- en: '[PRE5]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Since the solution is represented by an ordered list of integers, where each
    integer denotes the column location of a queen, we can use the following toolbox
    definitions to create the initial population:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于解决方案由一个有序的整数列表表示，其中每个整数表示一个皇后的列位置，我们可以使用以下工具箱定义来创建初始种群：
- en: '[PRE6]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The actual fitness function is set to count the number of violations caused
    by the placement of the queens on the chessboard, as represented by each solution:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实际的适应度函数设置为计算由于皇后在棋盘上的放置所引起的冲突数量，每个解决方案代表一个冲突：
- en: '[PRE7]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As for the genetic operators, we use *tournament selection* with a tournament
    size of **2**, as well as the *crossover* and *mutation* operators, which are
    specialized for ordered lists:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 至于遗传操作符，我们使用*tournament selection*（锦标赛选择），其锦标赛大小为**2**，以及*交叉*和*突变*操作符，这些操作符是针对有序列表的：
- en: '[PRE8]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In addition, we continue to use the **elitist** approach, where the **hall-of-fame**
    (**HOF**) members – the current best individuals – are always passed untouched
    to the next generation. As we found out in the previous chapter, this approach
    works well with a tournament selection of size 2:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，我们继续使用**精英主义**方法，其中**名人堂**（**HOF**）成员——当前最好的个体——始终不受影响地传递到下一代。正如我们在上一章中发现的那样，这种方法与大小为2的锦标赛选择非常匹配：
- en: '[PRE9]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Since each N-Queens problem can have multiple possible solutions, we print
    out all HOF members, instead of just the top one, so that we can see how many
    valid solutions we found:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于每个N皇后问题可以有多个可能的解决方案，我们打印出所有HOF成员，而不仅仅是顶部的一个，以便我们可以看到找到多少个有效解决方案：
- en: '[PRE10]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As we saw earlier, our solution representation reduces the eight-queen case
    to only about 40,000 possible combinations, which makes it a rather small problem.
    To make things more interesting, let’s increase the size to 16 queens, where the
    number of possible candidate solutions will be *16!*. This calculates to the colossal
    value of 20,922,789,888,000\. The number of valid solutions to this problem is
    quite large too, at just under 15 million. However, compared to the number of
    possible combinations, searching for a valid solution is still like trying to
    find a needle in a haystack.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前看到的那样，我们的解决方案表示将八皇后情况简化为大约40,000个可能的组合，这使得问题相对较小。为了增加趣味性，让我们将大小增加到16个皇后，其中可能的候选解决方案数量将是*16!*。这个值计算为一个巨大的数字：20,922,789,888,000。这个问题的有效解决方案数量也相当大，接近1500万个。然而，与可能的组合数相比，寻找有效解决方案仍然像是在大海捞针。
- en: 'Before we run the program, let’s set the algorithm constants, as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行程序之前，让我们设置算法常量，如下所示：
- en: '[PRE11]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Running the program with these settings yields the following output:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些设置运行程序将得到以下输出：
- en: '[PRE12]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: From the printouts, we can see that a solution was first found in generation
    24, where the fitness value shows as `0`, which means no violations. In addition,
    the printout of the best solutions indicates that eight different solutions were
    found during the run. These solutions are the entries of `0` to `7` in the HOF,
    all of which have a fitness value of `0`. The next entry already has a fitness
    value of `1`, denoting a violation.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 从打印输出中，我们可以看到第一个解在第24代找到，其中适应度值显示为`0`，这意味着没有违反规则。此外，最佳解的打印输出表明在运行过程中找到的八个不同解，这些解的编号是`0`到`7`，它们的适应度值都是`0`。下一个解的适应度值已经为`1`，表示存在违规。
- en: 'The first plot that’s produced by the program depicts the placement of the
    16 queens on the *16x16* chessboard, as defined by the first valid solution that
    was found – `[7, 2, 8, 14, 9, 4, 0, 15, 6, 11, 13, 1, 3, 5,` `10, 12]`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 程序生成的第一个图表展示了根据找到的第一个有效解所定义的*16x16*国际象棋棋盘上16个皇后的位置，[7, 2, 8, 14, 9, 4, 0, 15,
    6, 11, 13, 1, 3, 5, 10, 12]：
- en: '![Figure 5.6: A plot of a valid 16-queen arrangement found by the program](img/B20851_05_06.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.6：程序找到的有效16皇后排列的图示](img/B20851_05_06.jpg)'
- en: 'Figure 5.6: A plot of a valid 16-queen arrangement found by the program'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.6：程序找到的有效16皇后排列的图示
- en: 'The second plot contains a graph of the max and average fitness values over
    the generations. From this graph, we can see that even though the best fitness
    value of zero was found early on – around generation 24 – the average fitness
    value kept decreasing as more solutions were found:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个图表包含了随着代数增加，最大和平均适应度值的图表。从该图表中，我们可以看到，尽管最佳适应度值为零在早期就找到——大约在第24代——但随着更多解的出现，平均适应度值不断下降：
- en: '![Figure 5.7: Stats of the program solving the 16-queen problem](img/B20851_05_07.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.7：程序解决16皇后问题的统计数据](img/B20851_05_07.jpg)'
- en: 'Figure 5.7: Stats of the program solving the 16-queen problem'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.7：程序解决16皇后问题的统计数据
- en: Increasing the value of `MAX_GENERATIONS` to 400 without making any other changes
    will result in us finding 38 valid solutions. If we increase `MAX_GENERATIONS`
    to 500, all 50 members of the HOF will contain valid solutions. You are encouraged
    to try out various combinations of the genetic algorithm’s settings, as well as
    solve other sizes of the N-Queen problem.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 将`MAX_GENERATIONS`的值增加到400而不做其他任何更改，将会找到38个有效解。如果我们将`MAX_GENERATIONS`增加到500，HOF中的所有50个成员将包含有效解。鼓励你尝试基因算法设置的各种组合，同时也可以解决其他规模的N皇后问题。
- en: In the next section, we will be transitioning from arranging game pieces on
    a board to placing workers on a work schedule.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一部分，我们将从安排棋盘上的棋子过渡到为工作安排排班。
- en: Solving the nurse scheduling problem
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决护士排班问题
- en: 'Imagine that you are responsible for scheduling the shifts for the nurses in
    your hospital department for this week. There are three shifts in a day – morning,
    afternoon, and night – and for each shift, you need to assign one or more of the
    eight nurses who work in your department. If this sounds like a simple task, take
    a look at the list of relevant hospital rules:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你负责为医院科室安排本周的护士班次。一天有三个班次——早班、午班和晚班——每个班次你需要安排一个或多个在科室工作的八名护士。如果这听起来像是一个简单的任务，那你可以看看以下相关的医院规定：
- en: A nurse is not allowed to work two consecutive shifts
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 护士不能连续工作两个班次
- en: A nurse is not allowed to work more than five shifts per week
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 护士每周不得工作超过五个班次
- en: 'The number of nurses per shift in your department should fall within the following
    limits:'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 科室中每个班次的护士数量应在以下限制范围内：
- en: 'Morning shift: 2-3 nurses'
  id: totrans-105
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 早班：2-3名护士
- en: 'Afternoon shift: 2-4 nurses'
  id: totrans-106
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 午班：2-4名护士
- en: 'Night shift: 1-2 nurses'
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 晚班：1-2名护士
- en: In addition, each nurse can have shift preferences. For example, one nurse prefers
    to only work morning shifts, another nurse prefers to not work afternoon shifts,
    and so on.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，每个护士可能有班次偏好。例如，一名护士只愿意上早班，另一名护士不愿意上下午班，等等。
- en: This task is an example of the **nurse scheduling problem** (**NSP**), which
    can have many variants. Possible variations may include different specialties
    for different nurses, the ability to work on cover shifts (overtime), or even
    different types of shifts – such as 8-hour shifts and 12-hour shifts.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这个任务是**护士排班问题**（**NSP**）的一个示例，它可以有许多变种。可能的变种包括不同护士的不同专科、加班班次（超时工作）的安排，甚至是不同类型的班次——例如8小时班次和12小时班次。
- en: By now, it probably seems like a good idea to write a program that will do the
    scheduling for you. Why not apply our knowledge of genetic algorithms to implement
    such a program? As usual, we will start by representing the solution to the problem.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，可能已经觉得编写一个程序来为你排班是个不错的主意。为什么不运用我们对遗传算法的了解来实现这样一个程序呢？和往常一样，我们将从表示问题的解法开始。
- en: Solution representation
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解法表示
- en: To solve the nurse scheduling problem, we decided to use a binary list (or array)
    to represent the schedule as it will be intuitive for us to interpret, and we’ve
    seen that genetic algorithms can handle this representation naturally.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决护士排班问题，我们决定使用二进制列表（或数组）来表示排班，因为这样直观易懂，而且我们已经看到遗传算法可以自然地处理这种表示。
- en: 'For each nurse, we can have a **binary string** representing the 21 shifts
    of the week. A value of 1 represents a shift that the nurse is scheduled to work
    on. For example, take a look at the following binary list:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个护士，我们可以有一个**二进制字符串**，表示该周的21个班次。值为1表示该护士被安排工作的班次。例如，看看以下的二进制列表：
- en: '[PRE13]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This list can be broken into the following groups of three values, representing
    the shifts this nurse will be working each day of the week:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这个列表可以被拆分为以下三个值一组，表示该护士每周每天将要工作的班次：
- en: '| **Sunday** | **Monday** | **Tuesday** | **Wednesday** | **Thursday** | **Friday**
    | **Saturday** |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| **周日** | **周一** | **周二** | **周三** | **周四** | **周五** | **周六** |'
- en: '| [0, 1, 0] | [1, 0, 1] | [0, 1, 1] | [0, 0, 0] | [0, 0, 1] | [1, 0, 0] | [0,
    1, 0] |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| [0, 1, 0] | [1, 0, 1] | [0, 1, 1] | [0, 0, 0] | [0, 0, 1] | [1, 0, 0] | [0,
    1, 0] |'
- en: '| Afternoon | Morning and night | Afternoon and night | None | Night | Morning
    | Afternoon |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| 下午 | 早晚班 | 下午晚班 | 无 | 夜班 | 早班 | 下午 |'
- en: 'Table 5.1: Converting the binary sequence into daily shifts'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 表 5.1：将二进制序列转换为每日班次
- en: The schedules of all nurses can be then concatenated together to create one
    long binary list representing the entire solution.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 所有护士的排班可以被连接在一起，形成一个长的二进制列表，表示整个解法。
- en: When evaluating a solution, this long list can be broken down into the schedules
    of the individual nurses, and violations of the constraints can be checked for.
    The preceding sample nurse schedule, for instance, contains two occurrences of
    consecutive 1 values that represent consecutive shifts being worked (afternoon
    followed by night, and night followed by morning). The number of weekly shifts
    for that same nurse can be calculated by totaling the binary values of the list,
    which results in 8 shifts. We can also easily check for adherence to the shift
    preferences by checking each day’s shifts against the given preferred shifts of
    that nurse.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在评估解法时，这个长列表可以被拆分成各个护士的排班，并检查是否违反约束条件。例如，前面提供的护士排班中，包含了两次连续的1值，表示连续的班次（下午接夜班，夜班接早班）。该护士的每周班次数可以通过将列表中的二进制值相加来计算，结果是8个班次。我们还可以通过检查每一天的班次与该护士的偏好班次来轻松验证是否遵循了班次偏好。
- en: Finally, to check for the constraints of the number of nurses per shift, we
    can sum the weekly schedules of all nurses and look for entries that are larger
    than the maximum allowed or smaller than the minimum allowed.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了检查每个班次护士数量的约束条件，我们可以将所有护士的周排班加总，并查找那些超出最大允许值或低于最小允许值的条目。
- en: But before we continue with our implementation, we need to discuss the difference
    between **hard constraints** and **soft constraints**.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 但在继续实施之前，我们需要讨论**硬约束**与**软约束**之间的区别。
- en: Hard constraints versus soft constraints
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 硬约束与软约束
- en: When solving the nurse scheduling problem, we should bear in mind that some
    of the constraints represent hospital rules that cannot be broken. A schedule
    that contains one or more violations of these rules will be considered invalid.
    More generally, these are known as **hard constraints**.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决护士排班问题时，我们应该牢记，某些约束条件代表了医院规则，是无法违反的。包含一个或多个违反这些规则的排班将被视为无效。更一般地来说，这些被称为**硬约束**。
- en: The nurses’ preferences, on the other hand, can be considered **soft constraints**.
    We would like to adhere to them as much as possible, and a solution that contains
    no violations or fewer violations of these constraints is considered better than
    one that contains more violations. However, a violation of these constraints does
    not invalidate the solution.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，护士的偏好可以视为**软约束**。我们希望尽可能遵守这些偏好，包含没有违规或较少违规这些约束的解被认为优于包含更多违规的解。然而，违反这些约束并不会使解无效。
- en: In the case of the N-Queens problem, all the constraints – row, column, and
    diagonal – were hard constraints. Had we not found a solution where the number
    of violations was zero, we would not have a valid solution for the problem. Here,
    on the other hand, we are looking for a solution that will not violate any of
    the hospital rules while minimizing the number of breaches to the nurses’ preferences.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 对于N皇后问题，所有的约束——行、列和对角线——都是硬约束。如果我们没有找到一个违规数为零的解，那么我们就没有有效的解。而在这里，我们寻求一个既不会违反任何医院规则，又能最小化护士偏好违规次数的解。
- en: 'While dealing with soft constraints is similar to what we do in any optimization
    problem – that is, we strive to minimize them – how do we deal with the hard constraints
    that accompany them? There are several possible strategies:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 处理软约束与我们在任何优化问题中所做的类似——也就是说，我们努力将它们最小化——那么，我们该如何处理伴随其产生的硬约束呢？有几种可能的策略：
- en: Find a particular representation (coding) of the solution that **eliminates
    the possibility** of a hard constraint violation. When solving the N-Queens problem,
    we were able to represent a solution in a way that eliminated the possibility
    for two of the three constraints – row and column – which considerably simplified
    our solution. But generally, such coding may be difficult to find.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 找到一种特定的解的表示（编码），**消除**硬约束违规的可能性。在解决N皇后问题时，我们能够以一种消除两个约束（行和列）违规可能性的方式表示解，这大大简化了我们的解法。但一般来说，这种编码可能很难找到。
- en: When evaluating the solutions, **discard** candidate solutions that violate
    any hard constraint. The disadvantage of this approach is the loss of information
    contained in these solutions, which may be valuable for the problem. This could
    considerably slow down the optimization process.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在评估解时，**丢弃**违反任何硬约束的候选解。这种方法的缺点是丢失这些解中包含的信息，而这些信息对问题可能是有价值的。这可能会显著减慢优化过程。
- en: When evaluating the solutions, **repair** candidate solutions that violate any
    hard constraint. In other words, find a way to manipulate the solution and modify
    it so that it will no longer violate the constraint(s). Creating such a repair
    procedure can prove difficult or impossible for most problems, and at the same
    time, the repair process may result in a significant loss of information.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在评估解时，**修复**违反任何硬约束的候选解。换句话说，找到一种方法来操作解并修改它，使其不再违反约束条件。为大多数问题创建这样的修复过程可能会很困难甚至不可能，同时，修复过程可能会导致大量信息丢失。
- en: When evaluating the solutions, **penalize** candidate solutions that violate
    any hard constraint. This will degrade the solution’s score and make it less desirable,
    but will not eliminate it completely, so the information contained in it is not
    lost. Effectively, this leads to a hard constraint to be considered similar to
    a soft constraint, but with a heavier penalty. When using this method, the challenge
    may be to find the appropriate extent of the penalty. Too harsh a penalty may
    lead to a de facto elimination of such solutions, while a penalty that’s too small
    may lead to these solutions appearing as optimal.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在评估解时，**惩罚**违反任何硬约束的候选解。这将降低解的得分，使其不那么理想，但不会完全排除该解，因此其中包含的信息没有丢失。实际上，这使得硬约束被视为类似于软约束，但惩罚更重。使用这种方法时，挑战可能是找到适当的惩罚幅度。惩罚过重可能会导致这些解实际上被排除，而惩罚过轻则可能使这些解看起来像是最优解。
- en: In our case, we chose to apply the fourth approach and penalize the violations
    of the hard constraints to a larger degree than those of the soft constraints.
    We did this by creating a cost function, where the cost of a hard constraint violation
    is greater than that of a soft constraint violation. The total cost is then used
    as the fitness function to be minimized. This is implemented within the problem
    representation that will be discussed in the next subsection.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们选择应用第四种方法，并对硬约束的违规行为施加比软约束更大的惩罚。我们通过创建一个成本函数来实现这一点，其中硬约束违规的成本大于软约束违规的成本。然后，使用总成本作为要最小化的适应度函数。这是在接下来的子节中将讨论的“问题表示”中实现的。
- en: Python problem representation
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python问题表示
- en: To encapsulate the nurse scheduling problem we described at the beginning of
    this section, we’ve created a Python class called `NurseSchedulingProblem`. This
    class is contained in the `nurses.py` file, which can be found at [https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_05/nurses.py](https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_05/nurses.py).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 为了封装我们在本节开始时描述的护士排班问题，我们创建了一个名为`NurseSchedulingProblem`的Python类。该类位于`nurses.py`文件中，可以在[https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_05/nurses.py](https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_05/nurses.py)找到。
- en: 'The class constructor accepts the `hardConstraintPenalty` parameter, which
    represents the penalty factor for a hard constraint violation (while the penalty
    of a soft constraint violation is fixed to 1). Then, it continues to initialize
    the various parameters, describing the scheduling problem:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 该类构造函数接受`hardConstraintPenalty`参数，该参数表示硬约束违规的惩罚因子（而软约束违规的惩罚固定为1）。然后，它继续初始化描述排班问题的各种参数：
- en: '[PRE14]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The class uses the following method to convert the given schedule into a dictionary
    with a separate schedule for each nurse:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 该类使用以下方法将给定的排班转换为每个护士的单独排班字典：
- en: '**getNurseShifts(schedule)**'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**getNurseShifts(schedule)**'
- en: 'The following methods are used to count the various types of violations:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 以下方法用于计算各种类型的违规行为：
- en: '**countConsecutiveShiftViolations(nurseShiftsDict)**'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**countConsecutiveShiftViolations(nurseShiftsDict)**'
- en: '**countShiftsPerWeekViolations(nurseShiftsDict)**'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**countShiftsPerWeekViolations(nurseShiftsDict)**'
- en: '**countNursesPerShiftViolations(nurseShiftsDict)**'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**countNursesPerShiftViolations(nurseShiftsDict)**'
- en: '**countShiftPreferenceViolations(nurseShiftsDict)**'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**countShiftPreferenceViolations(nurseShiftsDict)**'
- en: 'In addition, the class provides the following public methods:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，该类还提供了以下公共方法：
- en: '**getCost(schedule)**: Calculates the total cost of the various violations
    in the given schedule. This method uses the value of the **hardConstraintPenalty**
    variable.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**getCost(schedule)**：计算给定排班中各种违规行为的总成本。该方法使用**hardConstraintPenalty**变量的值。'
- en: '**printScheduleInfo(schedule)**: Prints the schedule and violation details.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**printScheduleInfo(schedule)**：打印排班和违规详情。'
- en: 'The main method of the class exercises the class’ methods by creating an instance
    of the nurse scheduling problem and testing a randomly generated solution for
    it. The resulting output may look as follows, with the value of `hardConstraintPenalty`
    set to `10`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 该类的主要方法通过创建护士排班问题的实例并测试随机生成的解决方案来执行该类的方法。生成的输出可能如下所示，其中`hardConstraintPenalty`的值设置为`10`：
- en: '[PRE15]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As is evident from these results, a randomly generated solution is likely to
    yield a large number of violations, and consequently a large cost value. In the
    next subsection, we’ll attempt to minimize the cost and eliminate all hard constraint
    violations using a genetic algorithm-based solution.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些结果可以明显看出，随机生成的解决方案很可能会导致大量违规行为，从而产生较大的成本值。在下一个子节中，我们将尝试通过基于遗传算法的解决方案来最小化成本并消除所有硬约束违规。
- en: Genetic algorithms solution
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 遗传算法解决方案
- en: To solve the nurse scheduling problem using a genetic algorithm, we’ve created
    a Python program called `02-solve-nurses.py`, which is located at [https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_05/02_solve_nurses.py](https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_05/02_solve_nurses.py).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用遗传算法解决护士排班问题，我们创建了一个名为`02-solve-nurses.py`的Python程序，该程序位于[https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_05/02_solve_nurses.py](https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_05/02_solve_nurses.py)。
- en: Since the solution representation we chose for this problem is a list (or an
    array) of binary values, we were able to use the same genetic approach we used
    for several problems we have solved already, such as the 0-1 knapsack problem
    we described in [*Chapter 4*](B20851_04.xhtml#_idTextAnchor155), *Combinatorial
    Optimization*.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们为这个问题选择的解表示方法是一个二进制值的列表（或数组），我们能够使用我们已经用于解决多个问题的相同遗传算法方法，例如我们在[*第4章*](B20851_04.xhtml#_idTextAnchor155)中描述的0-1背包问题，*组合优化*。
- en: 'The main parts of our solution are described in the following steps:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们解决方案的主要部分在以下步骤中描述：
- en: 'Our program starts by creating an instance of the **NurseSchedulingProblem**
    class with the desired value for **hardConstraintPenalty**, which is set by the
    **HARD_CONSTRAINT_PENALTY** constant:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的程序首先创建一个**NurseSchedulingProblem**类的实例，并为**hardConstraintPenalty**设置期望值，该值由**HARD_CONSTRAINT_PENALTY**常量设置：
- en: '[PRE16]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Since our goal is to minimize the cost, we must define a single objective,
    minimizing the fitness strategy:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们的目标是最小化成本，我们必须定义一个单一目标，即最小化适应度策略：
- en: '[PRE17]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Since the solution is represented by a list of 0 or 1 values, we must use the
    following toolbox definitions to create the initial population:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于解表示为0或1值的列表，我们必须使用以下工具箱定义来创建初始种群：
- en: '[PRE18]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The actual fitness function is set to calculate the cost of the various violations
    in the schedule, represented by each solution:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实际的适应度函数设置为计算排班中各种违规的成本，由每个解决方案表示：
- en: '[PRE19]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As for the genetic operators, we must use tournament selection with a tournament
    size of **2**, along with two-point crossover and flip-bit mutation, since this
    is suitable for binary lists:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 至于遗传算子，我们必须使用**2**的锦标赛选择，并结合两点交叉和翻转位变异，因为这适用于二进制列表：
- en: '[PRE20]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We keep using the elitist approach, where HOF members – the current best individuals
    – are always passed untouched to the next generation:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们继续使用精英主义方法，其中HOF成员——当前最优秀的个体——始终被无修改地传递到下一代：
- en: '[PRE21]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'When the algorithm concludes, we print the details of the best solution that
    was found:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当算法完成时，我们打印出找到的最佳解决方案的详细信息：
- en: '[PRE22]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Before we run the program, let’s set the algorithm constants, as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行程序之前，我们设置算法常量，如下所示：
- en: '[PRE23]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In addition, let’s start by setting the penalty for violating hard constraints
    to a value of `1`, which makes the cost of violating a hard constraint similar
    to that of violating a soft constraint:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，让我们从将违反硬约束的惩罚设置为`1`开始，这使得违反硬约束的成本与违反软约束的成本相似：
- en: '[PRE24]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Running the program with these settings yields the following output:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些设置运行程序会产生以下输出：
- en: '[PRE25]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This may seem like a good result since we ended up with only three constraint
    violations. However, one of them is a **shift-per-week violation** – nurse B was
    scheduled with six shifts for the week, exceeding the maximum allowed of five.
    This is enough to make the entire solution unacceptable.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来是一个不错的结果，因为我们最终只出现了三次约束违规。然而，其中一个是**每周轮班违规**—护士B被安排了六个班次，超过了每周最多五个班次的限制。这足以使整个解决方案不可接受。
- en: 'In an attempt to eliminate this kind of violation, we’ll proceed to increase
    the hard constraint penalty value to `10`:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 为了消除这种类型的违规，我们将继续将硬约束惩罚值增加到`10`：
- en: '[PRE26]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, the result is as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，结果如下：
- en: '[PRE27]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Again, we got three violations, but this time, they were all soft constraint
    violations, which makes this solution valid.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们得到了三次违规，但这次它们都是软约束违规，这使得这个解决方案有效。
- en: 'The following graph, which depicts the minimum and average fitness over the
    generations, indicates that over the first 40-50 generations, the algorithm was
    able to eliminate all hard constraint violations, and from there on there were
    only small incremental improvements, which occurred whenever another soft constraint
    was eliminated:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了代际间的最小和平均适应度，表明在前40-50代中，算法成功消除了所有硬约束违规，从那时起只有少量的增量改进，发生在每次消除一个软约束时：
- en: '![Figure 5.8: Stats of the program solving the nurse scheduling problem](img/B20851_05_08.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![图5.8：解决护士排班问题的程序统计数据](img/B20851_05_08.jpg)'
- en: 'Figure 5.8: Stats of the program solving the nurse scheduling problem'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.8：解决护士排班问题的程序统计数据
- en: It seems that, in our case, it was enough to set a 10-fold penalty on hard constraint
    violations. In other problems, higher values may be required. You are encouraged
    to experiment by altering the problem’s definitions, as well as the genetic algorithm’s
    settings.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来，在我们的情况下，仅对硬约束违规设置10倍的惩罚就足够了。在其他问题中，可能需要更高的值。建议你通过改变问题的定义以及遗传算法的设置进行实验。
- en: The same trade-off we have just seen between soft and hard constraints is going
    to play a part in the next task we take on – the graph coloring problem.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才看到的软约束和硬约束之间的权衡将在我们接下来的任务——图着色问题中发挥作用。
- en: Solving the graph coloring problem
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 求解图着色问题
- en: 'In the mathematical branch of graph theory, a **graph** is a structured collection
    of objects that represents the relationships between pairs of these objects. The
    objects appear as **vertices** (or nodes) in the graph, while the relation between
    a pair of objects is represented using an **edge**. A common way of illustrating
    a graph is by drawing the vertices as circles and the edges as connecting lines,
    as depicted in the following diagram of the *Petersen graph*, named after the
    Danish mathematician Julius Petersen:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在图论的数学分支中，**图**是一个结构化的对象集合，表示这些对象对之间的关系。图中的对象表现为**顶点**（或节点），而对象对之间的关系则通过**边**表示。常见的图形表示方式是将顶点画为圆圈，边画为连接线，如下图所示，这是一幅*彼得森图*，以丹麦数学家尤利乌斯·彼得森的名字命名：
- en: '![Figure 5.9: Petersen graph](img/B20851_05_09.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.9：彼得森图](img/B20851_05_09.jpg)'
- en: 'Figure 5.9: Petersen graph'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.9：彼得森图
- en: 'Source: [https://commons.wikimedia.org/wiki/File:Petersen1_tiny.svg](https://commons.wikimedia.org/wiki/File:Petersen1_tiny.svg)'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 来源：[https://commons.wikimedia.org/wiki/File:Petersen1_tiny.svg](https://commons.wikimedia.org/wiki/File:Petersen1_tiny.svg)
- en: Image by Leshabirukov.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图片来自Leshabirukov。
- en: Graphs are remarkably useful objects as they can represent and help us research
    an overwhelming variety of real-life structures, patterns, and relationships,
    such as social networks, power grid layouts, website structures, linguistic compositions,
    computer networks, atomic structures, migration patterns, and more.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图是非常有用的对象，因为它们可以表示并帮助我们研究各种现实生活中的结构、模式和关系，例如社交网络、电网布局、网站结构、语言构成、计算机网络、原子结构、迁徙模式等。
- en: The **graph coloring** task is used to assign a color for every node in the
    graph in such a way that no pair of connected (adjacent) nodes will share the
    same color. This is also known as the **proper coloring** of the graph.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '**图着色**任务是为图中的每个节点分配颜色，确保任何一对连接（相邻）节点不会共享相同的颜色。这也被称为图的**正确着色**。'
- en: 'The following diagram shows the same Petersen graph, but this time colored
    properly:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了相同的彼得森图，但这次进行了正确的着色：
- en: '![Figure 5.10: Proper coloring of the Petersen graph](img/B20851_05_10.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.10：彼得森图的正确着色](img/B20851_05_10.jpg)'
- en: 'Figure 5.10: Proper coloring of the Petersen graph'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.10：彼得森图的正确着色
- en: 'Source: [https://en.wikipedia.org/wiki/File:Petersen_graph_3-coloring.svg](https://en.wikipedia.org/wiki/File:Petersen_graph_3-coloring.svg).'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 来源：[https://en.wikipedia.org/wiki/File:Petersen_graph_3-coloring.svg](https://en.wikipedia.org/wiki/File:Petersen_graph_3-coloring.svg)
- en: The color assignment is often accompanied by an optimization requirement – use
    the **minimum possible** number of colors. For example, the Peterson graph can
    be properly colored using three colors, as demonstrated in the preceding diagram.
    But it would be impossible to color it properly using only two colors. In graph
    theory terms, this means that the *chromatic number* of this graph is three.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 着色分配通常伴随着优化要求——使用**最少的颜色**。例如，彼得森图可以使用三种颜色进行正确着色，如前面的图示所示。但如果只使用两种颜色，正确着色是不可能的。从图论的角度来看，这意味着该图的*色数*为三。
- en: Why would we care about coloring the nodes of the graph? Many real-life problems
    can be translated into a graph representation in such a way that the graph coloring
    will stand for a solution – for example, scheduling classes for a student, or
    shifts for an employee can be translated into a graph, where adjacent nodes represent
    classes or shifts that cause a conflict. Such a conflict can be classes that fall
    at the same time or shifts that are consecutive (sound familiar?). Due to this
    conflict, assigning the same person to both classes (or both shifts) will invalidate
    the schedule. If each color represents a different person, assigning different
    colors to adjacent nodes will solve the conflicts. The N-Queen problem we encountered
    at the beginning of this chapter can be represented as a graph coloring problem,
    where every node in the graph represents a square on the chessboard, and every
    pair of nodes that share a row, a column, or a diagonal is connected by an edge.
    Other relevant examples include frequency assignments to radio stations, power
    grid redundancy planning, traffic light timing, and even Sudoku puzzle-solving.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们要关心图的节点着色？许多现实生活中的问题可以通过图的表示来转换，其中图的着色代表一个解决方案——例如，为学生安排课程或为员工安排班次都可以转换为一个图，其中相邻的节点代表存在冲突的课程或班次。这样的冲突可能是同一时间段的课程，或是连续的班次（是不是很熟悉？）。由于这种冲突，将同一个人分配到两门课程（或两班次）中会使得时间表无效。如果每种颜色代表不同的人，那么将不同的颜色分配给相邻节点就能解决冲突。本章开始时遇到的N皇后问题可以表示为一个图着色问题，其中图中的每个节点代表棋盘上的一个方格，每一对共享同一行、列或对角线的节点通过一条边相连。其他相关的例子还包括为广播电台分配频率、电网冗余规划、交通信号灯时序，甚至是数独解题。
- en: Hopefully, this has convinced you that graph coloring is a problem worth solving.
    As usual, we will start by formulating an appropriate representation of a possible
    solution for this problem.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 希望这已经说服你，图着色是一个值得解决的问题。像往常一样，我们将从制定一个合适的可能解法表示开始。
- en: Solution representation
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解法表示
- en: Expanding on the commonly used binary list (or array) representation, we can
    employ a list of integers, where each integer represents a unique color, while
    each element of the list matches one of the graph’s nodes.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在常用的二进制列表（或数组）表示法的基础上，我们可以使用整数列表，每个整数代表一种独特的颜色，而列表中的每个元素对应图中的一个节点。
- en: For example, since the Petersen graph has 10 nodes, we can assign each node
    an index between 0 and 9\. Then, we can represent the node coloring for that graph
    using a list of 10 elements.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，由于彼得森图有10个节点，我们可以为每个节点分配一个从0到9之间的索引。然后，我们可以使用一个包含10个元素的列表来表示该图的节点着色。
- en: 'For example, let’s have a look at what we have in this particular representation:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们看看在这个特定的表示法中我们得到了什么：
- en: '[PRE28]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Let’s talk about what we have here in detail:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细讨论一下这里的内容：
- en: Four colors are used, represented by the integers **0**, **1**, **2**, and **3**
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用了四种颜色，分别由整数**0**、**1**、**2**和**3**表示
- en: The first, seventh, and tenth nodes of the graph are colored with the first
    color (**0**)
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图的第一个、第七个和第十个节点被涂上了第一种颜色（**0**）
- en: The third and fifth nodes are colored with the second color (**1**)
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三和第五个节点被涂上了第二种颜色（**1**）
- en: The second and sixth nodes are colored with the third color (**2**)
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二和第六个节点被涂上了第三种颜色（**2**）
- en: The fourth, eighth, and ninth nodes are colored with the fourth color (**3**)
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第四、第八和第九个节点被涂上了第四种颜色（**3**）
- en: To evaluate the solution, we need to iterate over each pair of adjacent nodes
    and check if they share the same color. If they do, this is a coloring violation,
    and we seek to minimize the number of violations to zero to achieve the proper
    coloring of the graph.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 为了评估解法，我们需要遍历每一对相邻节点，检查它们是否有相同的颜色。如果有相同的颜色，就发生了着色冲突，我们需要尽量减少冲突的数量，直到为零，从而实现图的正确着色。
- en: However, you may recall that we also wish to minimize the number of colors that
    are used. If we happen to already know this number, we can just use as many integer
    values as the known number of colors. But what if we don’t? One way to go about
    this is to start with an estimate (or just a guess) for the number of colors used.
    If we find a proper solution using this number, we can reduce the number and try
    again. If no solution is found, we can increase the number and try again until
    we have the smallest number we can find a solution with. However, we may be able
    to get to this number faster by using soft and hard constraints, as described
    in the next subsection.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你可能记得我们还希望最小化使用的颜色数。如果我们已经知道这个数字，我们可以直接使用与已知颜色数相等的整数值。但如果我们不知道呢？一种方法是从一个估计值（或只是猜测）开始。如果我们使用这个数字找到一个合适的解决方案，我们可以减少这个数字并重试。如果没有找到解决方案，我们可以增加数字并继续尝试，直到找到最小的数字。虽然如此，通过使用软约束和硬约束，我们可能能更快地找到这个数字，正如下一小节中所描述的。
- en: Using hard and soft constraints for the graph coloring problem
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用硬约束和软约束解决图着色问题
- en: When solving the nurse scheduling problem earlier in this chapter, we noted
    the difference between hard constraints – those we have to adhere to for the solution
    to be considered valid – and soft constraints – those we strive to minimize to
    get the best solution. In the graph coloring problem, the **color assignment**
    requirement – where no two adjacent nodes can have the same color – is a **hard
    constraint**. We have to minimize the number of violations of this constraint
    to zero to achieve a valid solution.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章早些时候解决护士排班问题时，我们注意到硬约束——即我们必须遵守的约束才能使解决方案有效——和软约束——即我们尽力最小化的约束，以便获得最佳解决方案。图着色问题中的**颜色分配**要求——即相邻的两个节点不能具有相同的颜色——是一个**硬约束**。为了实现有效的解决方案，我们必须将此约束的违背次数最小化为零。
- en: Minimizing the **number of colors** used, however, can be introduced as a **soft
    constraint**. We would like to minimize this number, but not at the expense of
    violating the hard constraint.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，最小化**使用的颜色数**可以作为**软约束**引入。我们希望最小化这个数字，但不能以违反硬约束为代价。
- en: This will allow us to launch the algorithm with several colors higher than our
    estimate and let the algorithm minimize it until – ideally – it reaches the actual
    minimal color count.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这将允许我们使用比估计值更多的颜色启动算法，并让算法最小化直到——理想情况下——达到实际的最小颜色数。
- en: As we did for the nurse scheduling problem, we will implement this approach
    by creating a cost function, where the cost of a hard constraint violation is
    greater than the cost induced by using more colors. The total cost will then be
    used as the fitness function to be minimized. This functionality can be incorporated
    into the Python class and will be described in the next subsection.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在护士排班问题中做的那样，我们将通过创建一个成本函数来实现这个方法，其中硬约束违背的成本大于使用更多颜色所带来的成本。总成本将作为目标函数进行最小化。此功能可以集成到Python类中，并将在下一小节中描述。
- en: Python problem representation
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python问题表示
- en: To encapsulate the graph coloring problem, we’ve created a Python class called
    `GraphColoringProblem`. This class can be found in the `graphs.py` file, which
    can be found at [https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_05/graphs.py](https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_05/graphs.py).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 为了封装图着色问题，我们创建了一个名为`GraphColoringProblem`的Python类。此类可以在`graphs.py`文件中找到，文件链接为[https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_05/graphs.py](https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_05/graphs.py)。
- en: To implement this class, we’ll utilize the open source Python package `graph`
    class. Instead of creating this graph from scratch, we can take advantage of the
    numerous preexisting graphs contained in this library, such as the *Petersen graph*
    we saw earlier.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这个类，我们将利用开源的Python包`graph`类。我们可以利用这个库中已有的许多图形，而不是从头创建图形，比如我们之前看到的*佩特森图*。
- en: The constructor of the `GraphColoringProblem` class accepts the graph to be
    colored as a parameter. In addition, it accepts the `hardConstraintPenalty` parameter,
    which represents the penalty factor for a hard constraint violation.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`GraphColoringProblem`类的构造函数接受作为参数的要着色的图。此外，它还接受`hardConstraintPenalty`参数，表示硬约束违背的惩罚因子。'
- en: 'The constructor then creates a list of the graph’s nodes, as well as an adjacency
    matrix, that allows us to quickly find out if any two nodes in the graph are adjacent:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数接着创建了一个图的节点列表以及一个邻接矩阵，这使我们可以快速判断图中任意两个节点是否相邻：
- en: '[PRE29]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This class uses the following method to calculate the number of coloring violations
    in the given color arrangement:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 该类使用以下方法计算给定颜色排列中的着色违规数量：
- en: '**getViolationsCount****(colorArrangement)**'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**getViolationsCount****(colorArrangement)**'
- en: 'The following method is used to calculate the number of colors used by the
    given color arrangement:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 以下方法用于计算给定颜色排列所使用的颜色数量：
- en: '**getNumberOfColors****(colorArrangement)**'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**getNumberOfColors****(colorArrangement)**'
- en: 'In addition, the class provides the following public methods:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，该类提供了以下公共方法：
- en: '**getCost****(colorArrangement)**: This calculates the total cost of the given
    color arrangement'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**getCost****(colorArrangement)**：计算给定颜色排列的总成本'
- en: '**plotGraph****(colorArrangement)**: This plots the graph with the nodes colored
    according to the given color arrangement'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**plotGraph****(colorArrangement)**：根据给定的颜色排列绘制图形，节点按给定颜色排列着色'
- en: 'The main method of the class exercises the class’ methods by creating a Petersen
    graph instance and testing a randomly generated color arrangement for it, containing
    up to five colors. In addition, it sets the value of `hardConstraintPenalty` to
    `10`:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 该类的主要方法通过创建一个彼得森图实例并测试一个随机生成的颜色排列来执行类的方法，该排列最多包含五种颜色。此外，它将`hardConstraintPenalty`的值设置为`10`：
- en: '[PRE30]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The resulting output may look as follows:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 结果输出可能如下所示：
- en: '[PRE31]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Since this particular random solution uses five colors and causes one coloring
    violation, the calculated cost is 15.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个特定的随机解决方案使用了五种颜色并导致了一个着色违规，因此计算出的成本为15。
- en: The plot for this solution is as follows – can you spot the single coloring
    violation?
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 该解决方案的图示如下——你能找到唯一的着色违规吗？
- en: '![Figure 5.11: Petersen graph improperly colored with five colors](img/B20851_05_11.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.11：五种颜色错误着色的彼得森图](img/B20851_05_11.jpg)'
- en: 'Figure 5.11: Petersen graph improperly colored with five colors'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.11：五种颜色错误着色的彼得森图
- en: In the next subsection, we’ll apply a genetic algorithm-based solution in an
    attempt to eliminate any coloring violations while also minimizing the number
    of colors that are used.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个小节中，我们将应用基于遗传算法的解决方案，尝试消除任何着色违规，同时最小化使用的颜色数量。
- en: Genetic algorithms solution
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 遗传算法解决方案
- en: To solve the graph coloring problem using a genetic algorithm, we’ve created
    a Python program called `03-solve-graphs.py`, which is located at [https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_05/03_solve_graphs.py](https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_05/03_solve_graphs.py).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决图着色问题，我们创建了一个名为`03-solve-graphs.py`的Python程序，程序位于[https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_05/03_solve_graphs.py](https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_05/03_solve_graphs.py)。
- en: Since the solution representation we chose for this problem is a list of integers,
    we need to expand the genetic approach of using a binary list.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们为这个问题选择的解决方案表示方式是一个整数列表，我们需要扩展遗传算法方法，改为使用二进制列表。
- en: 'The following steps describe the main points of our solution:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤描述了我们解决方案的主要步骤：
- en: 'The program starts by creating an instance of the **GraphColoringProblem**
    class with the desired *NetworkX* graph to be solved – the familiar *Petersen
    graph* in this case – and the desired value for **hardConstraintPenalty**, which
    is set by the **HARD_CONSTRAINT_PENALTY** constant:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 程序通过创建一个**GraphColoringProblem**类的实例开始，使用要解决的*NetworkX*图（在此案例中为熟悉的*彼得森图*）和所需的**hardConstraintPenalty**值，该值由**HARD_CONSTRAINT_PENALTY**常量设置：
- en: '[PRE32]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Since our goal is to minimize the cost, we’ll define a single objective, minimizing
    fitness strategy:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们的目标是最小化成本，我们将定义一个单一目标，即最小化适应度策略：
- en: '[PRE33]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Since the solution is represented by a list of integer values representing
    the participating colors, we need to define a random generator that creates an
    integer between 0 and the number of colors minus 1\. This random integer represents
    one of the participating colors. Then, we must define a solution (individual)
    creator that generates a list of these random integers that match the given graph
    in length – this is how we randomly assign a color for each node in the graph.
    Finally, we must define an operator that creates an entire population of individuals:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于解决方案是由表示参与颜色的整数值列表表示的，我们需要定义一个随机生成器，它会生成一个介于0和颜色数减1之间的整数。这个随机整数表示参与颜色之一。然后，我们必须定义一个解决方案（个体）创建器，生成一个与给定图长度匹配的这些随机整数的列表——这就是我们如何为图中的每个节点随机分配颜色。最后，我们必须定义一个操作符，创建一个完整的个体种群：
- en: '[PRE34]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The fitness evaluation function is set to calculate the combined cost of the
    coloring violations and the number of colors used, which is associated with each
    solution, by calling the **getCost()** method of the **GraphColoringProblem**
    class:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 适应度评估函数被设置为通过调用**GraphColoringProblem**类的**getCost()**方法，计算与每个解决方案相关的着色违规成本和使用颜色数量的组合：
- en: '[PRE35]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'As for the genetic operators, we can still use the same *selection* and *crossover*
    operations we used for binary lists; however, the mutation operation needs to
    change. The *flip-bit mutation* that’s used for binary lists flips between values
    of 0 and 1, while here, we need to change a given integer to another – randomly
    generated – integer in the allowed range. The **mutUniformInt** operator does
    just that – we just need to set the range similar to what we did with the preceding
    integers operator:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 至于遗传操作符，我们仍然可以使用我们为二进制列表使用的相同*选择*和*交叉*操作；然而，变异操作需要改变。用于二进制列表的*翻转位变异*会在0和1之间翻转，而在这里，我们需要将给定的整数变换为另一个——随机生成的——整数，且该整数在允许的范围内。**mutUniformInt**操作符正是执行这个操作——我们只需像前面的整数操作符一样设置范围：
- en: '[PRE36]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We keep using the *elitist approach*, where the HOF members – the current best
    individuals – are always passed untouched to the next generation:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们继续使用*精英策略*，即HOF成员——当前最优秀的个体——总是无任何改动地传递到下一代：
- en: '[PRE37]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: When the algorithm concludes, we print the details of the best solution that
    was found before plotting the graphs.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当算法结束时，我们会打印出找到的最佳解决方案的详细信息，然后再绘制图表。
- en: '[PRE38]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Before we run the program, let’s set the algorithm constants, as follows:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行程序之前，让我们设置算法常量，如下所示：
- en: '[PRE39]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In addition, we need to set a penalty for violating hard constraints to a value
    of `10` and the number of colors to `10`:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们需要将违反硬约束的惩罚设置为`10`，并将颜色数量设置为`10`：
- en: '[PRE40]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Running the program with these settings yields the following output:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些设置运行程序会输出以下结果：
- en: '[PRE41]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This means that the algorithm was able to find a proper coloring for the graph
    using three colors, denoted by the integers `0`, `5`, and `6`. As we mentioned
    previously, the actual integer values don’t matter – it’s the distinction between
    them that does. Three is indeed the known chromatic number of the Petersen graph.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着算法能够使用三种颜色为图着色，分别由整数`0`、`5`和`6`表示。如前所述，实际的整数值并不重要——重要的是它们之间的区分。三是已知的Petersen图的色数。
- en: 'The preceding code creates the following plot, which illustrates the solution’s
    validity:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码生成了以下图表，说明了解决方案的有效性：
- en: '![Figure 5.12: A plot of the Petersen graph properly colored by the program
    using three colors](img/B20851_05_12.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![图5.12：由程序使用三种颜色正确着色的Petersen图的绘图](img/B20851_05_12.jpg)'
- en: 'Figure 5.12: A plot of the Petersen graph properly colored by the program using
    three colors'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.12：由程序使用三种颜色正确着色的Petersen图的绘图
- en: 'The following graph, which depicts the minimum and average fitness over the
    generations, indicates that the algorithm reached the solution rather quickly
    since the Petersen graph is relatively small:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了每代的最小和平均适应度，表明算法很快就达到了解决方案，因为Petersen图相对较小：
- en: '![Figure 5.13: Stats of the program solving the graph coloring problem for
    the Petersen graph](img/B20851_05_13.jpg)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![图5.13：程序解决Petersen图着色问题的统计数据](img/B20851_05_13.jpg)'
- en: 'Figure 5.13: Stats of the program solving the graph coloring problem for the
    Petersen graph'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.13：程序解决Petersen图着色问题的统计数据
- en: 'To try a larger graph, let’s replace the *Petersen graph* with a *Mycielski
    graph* of order `5`. This graph contains 23 nodes and 71 edges, and is known to
    have a chromatic number of 5:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 为了尝试更大的图形，我们将*彼得森图*替换为一个阶数为`5`的*梅西尔斯基图*。该图包含23个节点和71条边，并且已知其染色数为5：
- en: '[PRE42]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Using the same parameters as before, including the setting of 10 colors, we
    get the following results:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 使用与之前相同的参数，包括设置为10种颜色，我们得到了以下结果：
- en: '[PRE43]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Since we happen to know that the chromatic number for this graph is 5, this
    is not the optimal solution, although it’s close. How can we get there? And what
    if we didn’t know the chromatic number beforehand? One way to go about this is
    to change the parameters of the genetic algorithm – for example, we could increase
    the population size (and possibly the HOF size) and/or increase the number of
    generations. Another approach would be to start the same search again but with
    a reduced number of colors. Since the algorithm found a solution with six colors,
    let’s reduce the maximum number of colors to `5` and see if the algorithm can
    still find a valid solution:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们知道该图的染色数为5，虽然这接近最优解，但这并不是最优解。我们该如何获得最优解呢？如果我们事先不知道染色数该怎么办？一种方法是改变遗传算法的参数——例如，我们可以增加种群规模（并可能增加HOF大小）和/或增加代数。另一种方法是重新开始相同的搜索，但减少颜色数量。由于算法找到了六色解决方案，我们将最大颜色数减少到`5`，看看算法是否仍然能够找到有效解：
- en: '[PRE44]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Why would the algorithm find a five-color solution now if it didn’t find one
    in the first place? As we lower the number of colors from 10 to 5, the search
    space is considerably reduced – in this case, from 10 23 to 5 23 (since we have
    23 nodes in the graph) – and the algorithm has a better chance of finding the
    optimal solution(s), even with a short run and a limited population size. So,
    while the first run of the algorithm may get us close to the solution, it could
    be good practice to keep decreasing the number of colors until the algorithm can’t
    find a better solution.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么算法现在能够找到一个五色解决方案，而在第一次时没有找到？随着我们将颜色数量从10减少到5，搜索空间大大缩小——在这种情况下，从10^23到5^23（因为图中有23个节点）——即使在短时间运行和有限的种群规模下，算法找到最优解的机会也大大增加。因此，虽然算法的第一次运行可能已经接近解决方案，但将颜色数量不断减少，直到算法无法找到更好的解决方案，可能是一个好的做法。
- en: 'In our case, when started with five colors, the algorithm was able to find
    a five-color solution rather easily:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，当从五种颜色开始时，算法能够相对容易地找到一个五色解决方案：
- en: '[PRE45]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The plot of the colored graph looks as follows:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 着色图的图形如下所示：
- en: '![Figure 5.14: A plot of the Mycielski graph properly colored by the program
    using five colors](img/B20851_05_14.jpg)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![图5.14：程序用五种颜色正确着色的梅西尔斯基图](img/B20851_05_14.jpg)'
- en: 'Figure 5.14: A plot of the Mycielski graph properly colored by the program
    using five colors'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.14：程序用五种颜色正确着色的梅西尔斯基图
- en: Now, if we attempt to decrease the maximum number of colors to four, we will
    always get at least one violation.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们尝试将最大颜色数减少到四种，我们将始终得到至少一个违反条件的情况。
- en: You are encouraged to try out other graphs and experiment with the various settings
    of the algorithm.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 鼓励你尝试其他图形，并实验算法的各种设置。
- en: Summary
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, you were introduced to constraint satisfaction problems, which
    are close relatives of the previously studied combinatorial optimization problems.
    Then, we explored three classic constraint satisfaction cases – the *N-Queen*
    problem, the *nurse scheduling* problem, and the *graph coloring* problem. For
    each of these problems, we followed the now-familiar process of finding an appropriate
    representation for a solution, creating a class that encapsulates the problem
    and evaluates a given solution, and creating a genetic algorithm solution that
    utilizes that class. We ended up with valid solutions for the problems while getting
    acquainted with the concept of **hard constraints** versus **soft constraints**.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了约束满足问题，它们是之前研究的组合优化问题的亲戚。然后，我们探讨了三种经典的约束满足问题——*N皇后*问题、*护士排班*问题和*图着色*问题。对于每个问题，我们遵循了现在熟悉的过程：为解决方案找到合适的表示，创建一个封装该问题并评估给定解决方案的类，并创建一个利用该类的遗传算法解决方案。最终，我们得到了这些问题的有效解决方案，同时了解了**硬约束**与**软约束**的概念。
- en: So far, we have been looking into discrete search problems consisting of states
    and state transitions. In the next chapter, we will study search problems in a
    continuous space, to demonstrate the versatility of the genetic algorithms approach.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在研究由状态和状态转移组成的离散搜索问题。在下一章，我们将研究连续空间中的搜索问题，以展示遗传算法方法的多功能性。
- en: Further reading
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入阅读
- en: 'For more information on the topics that were covered in this chapter, please
    refer to the following resources:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 如需了解本章涉及的更多主题，请参考以下资源：
- en: '*Constraint Satisfaction Problems*, from the book *Artificial Intelligence
    with Python*, by Prateek Joshi, January 2017'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*约束满足问题*，摘自Prateek Joshi的书籍《*Python人工智能*》，2017年1月'
- en: '*Introduction to graph theory*, from the book *Python Data Science Essentials
    – Second Edition*, by Alberto Boschetti, Luca Massaron, October 2016'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*图论入门*，摘自Alberto Boschetti和Luca Massaron的书籍《*Python数据科学基础 - 第二版*》，2016年10月'
- en: 'NetworkX tutorial: [https://networkx.github.io/documentation/stable/tutorial.html](https://networkx.github.io/documentation/stable/tutorial.html)'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'NetworkX教程: [https://networkx.github.io/documentation/stable/tutorial.html](https://networkx.github.io/documentation/stable/tutorial.html)'
