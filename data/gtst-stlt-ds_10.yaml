- en: '*Chapter 8*: Deploying Streamlit Apps with Heroku and AWS'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 8 章*：使用 Heroku 和 AWS 部署 Streamlit 应用'
- en: 'In [*Chapter 5*](B16864_05_Final_VK_ePub.xhtml#_idTextAnchor056), *Deploying
    Streamlit with Streamlit Sharing*, we learned how to deploy our Streamlit applications
    with Streamlit Sharing. Streamlit Sharing is quick, easy, and very effective for
    most applications but has a few downsides, mainly that we are limited by only
    being able to host three free applications at once and that we also are limited
    in the computational power at hand. The following excerpt is from the Streamlit
    Sharing page:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 5 章*](B16864_05_Final_VK_ePub.xhtml#_idTextAnchor056)中，*使用 Streamlit Sharing
    部署 Streamlit*，我们学习了如何使用 Streamlit Sharing 部署我们的 Streamlit 应用。Streamlit Sharing
    快速、简便，对于大多数应用都非常有效，但也有一些缺点，主要是我们只能同时托管三个免费的应用，并且计算能力也有限。以下摘自 Streamlit Sharing
    页面：
- en: Apps get up to 1 CPU, 800 MB of RAM, and 800 MB of dedicated storage in a shared
    execution environment.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序最多可使用 1 个 CPU、800 MB 的 RAM 和 800 MB 的专用存储，且都在共享执行环境中运行。
- en: If you are in a situation where you want to deploy more than three applications
    at a time, or you want more compute as you run, for example, more complex ML models
    that would benefit from a GPU or more RAM, then this chapter is for you! We will
    cover how to set up accounts with AWS and Heroku and how to fully deploy your
    Streamlit applications there.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你处于一个需要同时部署超过三个应用，或者需要更多计算能力的情况，例如运行更复杂的机器学习模型（需要 GPU 或更多 RAM），那么本章就是为你准备的！我们将介绍如何在
    AWS 和 Heroku 上设置账户，并如何在那里完全部署你的 Streamlit 应用。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Choosing between AWS, Streamlit Sharing, and Heroku
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 AWS、Streamlit Sharing 和 Heroku 之间选择
- en: Deploying Streamlit with Heroku
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Heroku 部署 Streamlit
- en: Deploying Streamlit with AWS
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 AWS 部署 Streamlit
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Here is a list of installments required for this chapter:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这是本章所需安装项的清单：
- en: '**Heroku account**: Heroku is a popular platform that data scientists and software
    engineers use to host their applications, models, and APIs (application programming
    interfaces), and is owned by Salesforce. To get a Heroku account, please head
    over to [https://signup.heroku.com](https://signup.heroku.com) to make your free
    account.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Heroku 账户**：Heroku 是一个受欢迎的平台，数据科学家和软件工程师用它来托管他们的应用、模型和 API（应用程序接口），并且它是由
    Salesforce 所拥有。要获取 Heroku 账户，请前往 [https://signup.heroku.com](https://signup.heroku.com)
    创建一个免费账户。'
- en: '**Heroku Command-Line Interface** (**CLI**): To use Heroku effectively, we
    will need to download the Heroku CLI, which will allow us to run Heroku commands.
    To download this, please follow the instructions listed here: [https://devcenter.heroku.com/articles/heroku-cli](https://devcenter.heroku.com/articles/heroku-cli).'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Heroku 命令行界面** (**CLI**)：要有效使用 Heroku，我们需要下载 Heroku CLI，这样我们才能运行 Heroku 命令。要下载它，请按照此处列出的说明操作：[https://devcenter.heroku.com/articles/heroku-cli](https://devcenter.heroku.com/articles/heroku-cli)。'
- en: '**Amazon Web Services** (**AWS**) **account**: Before we can use AWS, we first
    need to sign up for our own Amazon account, which you can do at [https://aws.amazon.com/free](https://aws.amazon.com/free).
    Thankfully, there is a generous free tier available for students with .edu accounts,
    for start-up founders and entrepreneurs, and also for non-profits. Once you do
    this, I would strongly recommend setting billing alerts on your account (see [https://console.aws.amazon.com/billing/home?#preferences](https://console.aws.amazon.com/billing/home?#preferences)
    for more details) to make sure that you do not overshoot your free tier, and when
    you have deployed your own app, to make sure you are not spending more than desired.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**亚马逊网络服务** (**AWS**) **账户**：在使用 AWS 之前，我们首先需要注册一个自己的 Amazon 账户，你可以通过 [https://aws.amazon.com/free](https://aws.amazon.com/free)
    完成注册。幸运的是，学生（持 .edu 账户）、创业公司创始人和非营利组织有一个慷慨的免费套餐可以使用。一旦注册成功，我强烈建议你在账户中设置账单提醒（详情见
    [https://console.aws.amazon.com/billing/home?#preferences](https://console.aws.amazon.com/billing/home?#preferences)），确保你不会超出免费套餐，并且在你部署自己的应用时，确保不会花费超过预期。'
- en: '**PuTTy** (Windows only): If you are using Windows, you will need to download
    and install the PuTTY program, which allows Windows OSes to use a protocol called
    **Secure Shell** (**SSH**). To download PuTTY, head over to [https://www.putty.org/](https://www.putty.org/)
    and follow the installation instructions. Then, wherever we are using SSH in this
    chapter, open PuTTY and follow the directions as normal!'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PuTTy**（仅限 Windows）：如果你使用 Windows，你需要下载并安装 PuTTY 程序，它允许 Windows 操作系统使用一种叫做
    **安全外壳协议**（**SSH**）的协议。要下载 PuTTY，请前往 [https://www.putty.org/](https://www.putty.org/)
    并按照安装说明进行操作。然后，在本章中每次使用 SSH 时，打开 PuTTY 并按常规步骤进行操作！'
- en: Now that we have the requirements, let's begin!
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了需求，让我们开始吧！
- en: Choosing between AWS, Streamlit Sharing, and Heroku
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择 AWS、Streamlit Sharing 和 Heroku 之间的权衡
- en: At a high level, whenever we are trying to deploy our Streamlit application
    such that users on the internet can see our applications, what we are really doing
    is renting a computer owned by someone else (such as Amazon) and giving that computer
    a set of instructions to start up our application. Choosing which platform to
    use is difficult to know how to do without either having a background in deploying
    systems or without trying each option out first, but there are a few heuristics
    that should help you out. The two most important factors for this decision are
    the flexibility of the system and the time it takes to get up and running. Note
    that these two factors directly trade off with one another. If you are using Streamlit
    Sharing, you cannot say "I want this to run on a macOS, and I want to add two
    GPUs to this app," and so on, but in return, you get a wildly simple process where
    you can simply point Streamlit Sharing to your GitHub repository, and it will
    take care of all the other little decisions that need to be made.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 从高层次来看，当我们试图部署 Streamlit 应用，使得互联网上的用户能够看到我们的应用时，实际上我们在做的是租用一台由其他人（如 Amazon）拥有的计算机，并向这台计算机提供一系列启动我们应用的指令。选择使用哪个平台，如果没有系统部署的背景或者没有先试过每个选项，是很难决定的，但有几个启发式方法可以帮助你。这个决策的两个最重要因素是系统的灵活性和启动所需的时间。请注意，这两个因素是相互权衡的。如果你使用
    Streamlit Sharing，你不能说“我想在 macOS 上运行，并且我想给这个应用加两个 GPU”等等，但作为回报，你获得了一个极其简单的过程，你只需要将
    Streamlit Sharing 指向你的 GitHub 仓库，它会处理所有其他需要做的小决策。
- en: 'On the other hand, AWS and Heroku give you much more flexibility but take time
    to set up (as you will find out!). The biggest difference between the two is that
    Heroku is a *Platform as a Service product*, while Amazon is an *Infrastructure
    as a Service product*, which means, in practical terms, that Heroku gives you
    more flexibility than Streamlit Sharing by allowing you to do things such as provide
    more computational resources, and is faster to deploy than AWS, as you can see
    in the following graphic:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，AWS 和 Heroku 给你提供了更多的灵活性，但需要时间来设置（正如你将发现的那样！）。这两者之间最大的区别在于，Heroku 是一个 *平台即服务产品*，而
    Amazon 是一个 *基础设施即服务产品*，这意味着从实际操作上来说，Heroku 相比 Streamlit Sharing 提供了更多的灵活性，允许你做一些事情，比如提供更多的计算资源，并且比
    AWS 更快部署，正如你在下图中所看到的：
- en: '![Figure 8.1 – Heroku versus AWS versus Sharing'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.1 – Heroku 与 AWS 与 Sharing'
- en: '](img/B16864_08_1.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16864_08_1.jpg)'
- en: Figure 8.1 – Heroku versus AWS versus Sharing
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1 – Heroku 与 AWS 与 Sharing
- en: The AWS advantage, however, is in its extreme flexibility. AWS will let you
    choose between Ubuntu, macOS, Windows, and Red Hat Linux, between dozens of different
    database types, and is seemingly infinitely customizable. When you are making
    your Streamlit applications, if you want to get out a quick prototype to test
    out an idea, Streamlit Sharing is perfect for you. For full-fledged public applications
    that need more compute, Heroku might be the best call. And if you require ultimate
    flexibility for a complex ML application, or if you are running a business entirely
    on Streamlit, then AWS might be the best call. Throughout the rest of this chapter,
    we will dive into how to deploy your own app on both AWS and Heroku, as we have
    covered Streamlit Sharing directly in [*Chapter 5*](B16864_05_Final_VK_ePub.xhtml#_idTextAnchor056),
    *Deploying Streamlit with Streamlit Sharing*. Let's get started with Heroku!
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，AWS的优势在于其极高的灵活性。AWS允许你在Ubuntu、macOS、Windows和Red Hat Linux之间进行选择，支持多种不同类型的数据库，并且似乎是无限可定制的。当你在构建Streamlit应用时，如果你想快速制作一个原型来测试某个想法，Streamlit
    Sharing是非常适合你的。如果你需要一个功能完善的公共应用，并且需要更多计算资源，那么Heroku可能是最佳选择。如果你需要为复杂的机器学习应用提供终极灵活性，或者你的业务完全依赖于Streamlit，那么AWS可能是最佳选择。在本章的其余部分，我们将深入探讨如何在AWS和Heroku上部署你自己的应用，因为我们已经在[*第5章*](B16864_05_Final_VK_ePub.xhtml#_idTextAnchor056)中直接介绍了Streamlit
    Sharing的内容，*使用Streamlit Sharing部署Streamlit*。让我们从Heroku开始吧！
- en: Deploying Streamlit with Heroku
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Heroku部署Streamlit
- en: 'Heroku is slightly faster and simpler than AWS, and more cumbersome than Streamlit
    Sharing. But if you have run out of your Streamlit Sharing repositories, or need
    some more compute than Sharing has to offer but require fewer configuration options
    than the infinite ones provided by AWS, then Heroku is the place for you. One
    other win is that you can get custom URLs for your apps with Heroku, which Streamlit
    Sharing does not support (yet!). To deploy our Streamlit apps on Heroku, we need
    to do the following:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Heroku比AWS稍微更快、更简洁，但比Streamlit Sharing更繁琐。不过，如果你的Streamlit Sharing仓库已经用完，或者你需要更多计算资源，但不想要AWS提供的无限配置选项，那么Heroku就是适合你的地方。另一个优点是，你可以为应用设置自定义URL，而Streamlit
    Sharing目前不支持这一点（至少目前还不支持）。要在Heroku上部署我们的Streamlit应用，我们需要执行以下步骤：
- en: Set up and log in to Heroku.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置并登录Heroku。
- en: Clone and configure our local repository.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 克隆并配置我们的本地仓库。
- en: Deploy to Heroku.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署到Heroku。
- en: Let's look at each of these steps in detail!
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细看看每个步骤！
- en: Setting up and logging in to Heroku
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置和登录Heroku
- en: 'In the *Technical requirements* section of this chapter, we covered how to
    download Heroku and create an account. Now, we need to log in to our Heroku from
    our command line by running the following command and logging in when prompted:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的*技术要求*部分，我们介绍了如何下载Heroku并创建账户。现在，我们需要通过命令行登录Heroku，运行以下命令，并在提示时进行登录：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This will take us to the Heroku page, and once we log in, we will be good to
    go. This command will keep you logged in on your machine indefinitely unless your
    password changes or you purposely log out of Heroku.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把我们带到Heroku页面，一旦我们登录，就可以开始了。这个命令将使你在机器上保持登录状态，直到密码更改或你故意退出Heroku。
- en: Cloning and configuring our local repository
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 克隆并配置我们的本地仓库
- en: 'Next, we need to change our directory to where the penguin machine learning
    app is located. My app folder is inside my `Documents` folder, so the following
    command takes me there, but your folder might be different:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要切换到企鹅机器学习应用所在的目录。我的应用文件夹在`Documents`文件夹内，因此以下命令将我带到该文件夹，但你的文件夹可能不同：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If you do not already have the repository downloaded locally with a corresponding
    repository on GitHub, go ahead and stop by [*Chapter 5*](B16864_05_Final_VK_ePub.xhtml#_idTextAnchor056),
    *Deploying Streamlit with Streamlit Sharing*, to see how to get started with GitHub.
    Instead, you can also run the following command to download the repository locally
    from my personal GitHub, just as we did with deploying from AWS:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有将仓库下载到本地，并且在GitHub上没有相应的仓库，可以去看看[*第5章*](B16864_05_Final_VK_ePub.xhtml#_idTextAnchor056)，*使用Streamlit
    Sharing部署Streamlit*，了解如何开始使用GitHub。或者，你也可以运行以下命令，从我个人的GitHub上下载仓库，就像我们在从AWS部署时所做的那样：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: It is highly encouraged that you practice with your own GitHub repository, as
    this is much better practice than cloning an app from me to use to deploy to Heroku.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 强烈建议你使用自己的GitHub仓库进行实践，因为这比从我这里克隆应用并将其部署到Heroku要好得多。
- en: Now we need to create a Heroku app with a unique name for our app with the next
    command (the app will be deployed as this name with `.heroku.com` appended to
    the end of it). Mine will be `penguin-machine-learning`, but go ahead and pick
    your own!
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要使用下一个命令为我们的应用创建一个唯一名称的 Heroku 应用（该应用将作为此名称进行部署，后缀为 `.heroku.com`）。我的名称是
    `penguin-machine-learning`，你可以自己选择一个！
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Once we have this, we need to explicitly make the connection between our Git
    repository and the Heroku app we have just created, which can be done with the
    following command:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了这些，我们需要显式地将我们的 Git 仓库与刚创建的 Heroku 应用连接，这可以通过以下命令来完成：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'And finally, we are going to add two files to our repository that are needed
    to start up with Heroku, the `Procfile` file and the `streamlit_setup.sh` file.
    Heroku uses something called a `streamlit run` command to launch our app. Let''s
    start by creating the `streamlit_setup.sh` file using the following command:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将添加两个文件到仓库中，它们是启动 Heroku 所必需的：`Procfile` 文件和 `streamlit_setup.sh` 文件。Heroku
    使用名为 `streamlit run` 的命令来启动我们的应用。我们先通过以下命令创建 `streamlit_setup.sh` 文件：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We can open this file with our text editor and put the following lines inside
    it, which creates our familiar `config.toml` file in the base directory:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用文本编辑器打开这个文件，并将以下内容添加进去，这样就能在根目录下创建我们熟悉的 `config.toml` 文件：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Once we save this file, we need to create a Procfile that runs this `streamlit_setup.sh`
    file and then also runs our Streamlit app:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 保存此文件后，我们需要创建一个 Procfile，运行 `streamlit_setup.sh` 文件，并启动我们的 Streamlit 应用：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Within the `Procfile` file we just created, we will next add the following
    line:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们刚刚创建的 `Procfile` 文件中，我们接下来将添加以下内容：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now that we have our Streamlit app all set up, our final step is to deploy to
    Heroku!
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好 Streamlit 应用，最后一步就是将其部署到 Heroku！
- en: Deploying to Heroku
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署到 Heroku
- en: 'Before we deploy, we have a couple of new files on our app, so we need to add
    those to our Git repository using the following commands:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在部署之前，我们的应用中有几个新的文件，所以我们需要通过以下命令将它们添加到 Git 仓库中：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'And now, our final step in this chapter is to push to Heroku, which we can
    do with this next command:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，本章的最后一步是将应用推送到 Heroku，我们可以通过以下命令来完成：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This will kick off the Heroku build, and soon enough we will see our Penguin
    app deployed to Heroku for anyone to go and view. The app we have been working
    on and just deployed can be found at the following link (with a screenshot attached!),
    [https://penguin-machine-learning.herokuapp.com/](https://penguin-machine-learning.herokuapp.com/),
    and the GitHub repository for this app can be found at [https://github.com/tylerjrichards/penguin_ml](https://github.com/tylerjrichards/penguin_ml).
    It is the same as the app we deployed on AWS earlier in the chapter, shown in
    the following screenshot:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动 Heroku 构建，不久我们就会看到我们的企鹅应用被部署到 Heroku，任何人都可以查看。我们一直在开发并刚刚部署的应用可以通过以下链接找到（附带截图！），[https://penguin-machine-learning.herokuapp.com/](https://penguin-machine-learning.herokuapp.com/)，该应用的
    GitHub 仓库可以在 [https://github.com/tylerjrichards/penguin_ml](https://github.com/tylerjrichards/penguin_ml)
    找到。它与我们在本章早些时候部署到 AWS 的应用相同，如下图所示：
- en: '![Figure 8.2 – Heroku App deployment'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.2 – Heroku 应用部署'
- en: '](img/B16864_08_2.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16864_08_2.jpg)'
- en: Figure 8.2 – Heroku App deployment
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.2 – Heroku 应用部署
- en: We have now successfully deployed one of our Streamlit apps on the Heroku platform,
    but if we need more control over the types of servers behind our app, we need
    to build directly on AWS, as demonstrated in the next section!
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功地将一个 Streamlit 应用部署到 Heroku 平台，但如果我们需要更多控制权，想要更灵活地管理应用背后的服务器，我们需要直接在 AWS
    上构建，如下节所示！
- en: Deploying Streamlit with AWS
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 AWS 部署 Streamlit
- en: 'In comparison to deploying with Heroku, deploying apps on AWS is significantly
    more cumbersome but has seemingly infinite options. There are a few steps to deploying
    your own apps with AWS, and these include the following:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 相比于 Heroku，AWS 部署应用的过程要复杂得多，但它提供了几乎无限的选项。部署自己的应用到 AWS 需要几个步骤，包括以下内容：
- en: Selecting and launching a virtual machine
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择并启动虚拟机
- en: Installing the necessary software
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装必要的软件
- en: Cloning and running your app
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 克隆并运行你的应用
- en: Long-term AWS deployment
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 长期的 AWS 部署
- en: We will run through these sequentially!
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将按顺序逐步进行！
- en: Selecting and launching a virtual machine
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择并启动虚拟机
- en: 'AWS has literally hundreds of service options for everything from deploying
    ML models to compute resources to everything in between. In this book so far,
    we have referred to the services listed in the following screenshot under the
    central name *AWS*, but to be more precise, we are going to be using **Amazon
    Elastic Compute Cloud**, or **Amazon EC2** for short. This next screenshot shows
    the breadth of services available just for compute resources, which does not include
    any of the services available for machine learning, business applications, or
    storage:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: AWS 几乎拥有成百上千种服务选项，涵盖从部署机器学习模型、计算资源到各种其他应用。在本书中，我们提到了以下截图中的服务，这些服务都被统一归类为 *AWS*，但更准确地说，我们将使用
    **Amazon Elastic Compute Cloud**，简称 **Amazon EC2**。下面的截图展示了仅针对计算资源的服务范围，这不包括任何与机器学习、业务应用或存储相关的服务：
- en: '![Figure 8.3 – AWS Compute'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.3 – AWS 计算'
- en: '](img/B16864_08_3.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16864_08_3.jpg)'
- en: Figure 8.3 – AWS Compute
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.3 – AWS 计算
- en: Amazon EC2 is a dynamic, pay-as-you-go service that will scale automatically
    based on use. If there are 10, 100, or 10,000 concurrent users of your Streamlit
    app, EC2 will change the compute resources given to your application to accommodate
    the users. You pay for what you use!
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Amazon EC2 是一种动态的、按需付费的服务，会根据使用情况自动扩展。如果你的 Streamlit 应用有 10、100 或 10,000 个并发用户，EC2
    会自动调整分配给应用的计算资源，以满足用户需求。你只需为实际使用的资源付费！
- en: 'To get started, head over to [https://console.aws.amazon.com/ec2/v2/home](https://console.aws.amazon.com/ec2/v2/home)
    and click the button that says **Launch instance**, as shown in the following
    screenshot. Your default region may be different than mine, which is totally fine!
    AWS regions allow you to select where you want the compute to be physically located,
    in case your app needs low latency, or there are regulatory reasons for where
    your data is hosted (for example, because of **General Data Privacy Regulation**
    (**GDPR**), in the European Union). The overwhelming majority of the time, the
    default region AWS puts you in is perfectly fine:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用，前往 [https://console.aws.amazon.com/ec2/v2/home](https://console.aws.amazon.com/ec2/v2/home)
    并点击显示 **Launch instance** 的按钮，如下截图所示。你的默认区域可能与我的不同，完全没问题！AWS 区域允许你选择计算资源的物理位置，以便满足低延迟需求，或者满足由于法规要求而必须选择特定地区的数据托管（例如，**通用数据保护条例**（**GDPR**）要求在欧盟地区）。大多数情况下，AWS
    为你选择的默认区域已经足够适用：
- en: '![Figure 8.4 – EC2 launch'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.4 – EC2 启动'
- en: '](img/B16864_08_4.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16864_08_4.jpg)'
- en: Figure 8.4 – EC2 launch
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.4 – EC2 启动
- en: 'Once you launch your instance, there are seven tabs:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你启动了实例，将会有七个标签：
- en: '**Choose AMI** (Amazon Machine Image) or the OS used by your virtual machine'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选择 AMI**（亚马逊机器镜像）或你的虚拟机使用的操作系统'
- en: '**Choose Instance Type** (choosing the compute/memory/storage of your virtual
    machine)'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选择实例类型**（选择虚拟机的计算/内存/存储配置）'
- en: '**Configure Instance**'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置实例**'
- en: '**Add Storage**'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**添加存储**'
- en: '**Add Tags**'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**添加标签**'
- en: '**Configure Security Group**'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置安全组**'
- en: '**Review**'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复习**'
- en: 'You might be starting to understand what I was talking about earlier when I
    mentioned flexibility versus speed! Luckily, we only really need to start with
    a few of these, starting with choosing our AMI from a list of options. When we
    click the **Launch instance** button, we will see options including, but not limited
    to, the following:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能开始理解我之前提到的“灵活性与速度”之间的权衡了！幸运的是，我们只需要从这些选项中选择其中几个，首先从选取我们的 AMI 开始。当我们点击 **Launch
    instance** 按钮时，我们将看到包括但不限于以下选项：
- en: Amazon Linux 2 AMI
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Amazon Linux 2 AMI
- en: This option is Amazon's own option, is free tier-eligible, and is designed to
    work well with EC2\.
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是亚马逊自有的选项，适用于免费套餐，并且与 EC2 的兼容性很好。
- en: Red Hat Enterprise Linux
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Red Hat 企业版 Linux
- en: This option is an enterprise version of Linux created by the Red Hat foundation,
    which creates open source enterprise solutions ([https://www.redhat.com/en](https://www.redhat.com/en)).
    There are a variety of options depending on versions and volume type.
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个选项是由红帽基金会创建的企业版 Linux，红帽基金会专注于开源企业解决方案 ([https://www.redhat.com/en](https://www.redhat.com/en))。根据版本和卷类型的不同，提供了多种选项。
- en: Ubuntu Server
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ubuntu Server
- en: Ubuntu is another open source OS built on Linux similar to Red Hat. They also
    have a variety of free and paid options, the same as Red Hat.
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Ubuntu 是另一个基于 Linux 构建的开源操作系统，类似于 Red Hat。它们也有各种免费和付费选项，与 Red Hat 类似。
- en: I would recommend selecting the OS that you are most comfortable with already.
    If you have already used Ubuntu servers, try the newest Ubuntu option, which is,
    in this case, Ubuntu Server 20.04\. The most commonly used AMI options are all
    based on Linux, which is an open source OS with many flavors, including Red Hat,
    Debian, and Ubuntu.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议选择你最熟悉的操作系统。如果你已经使用过 Ubuntu 服务器，可以尝试最新的 Ubuntu 选项，在这种情况下是 Ubuntu Server 20.04。最常用的
    AMI 选项都基于 Linux，这是一个开源操作系统，有很多变种，包括 Red Hat、Debian 和 Ubuntu。
- en: 'To follow along with this chapter, select the default Amazon option, **Amazon
    Linux 2**. When you check this option and are taken to the **Choose Instance Type**
    page, select any type that is free tier-eligible, as shown in the following screenshot.
    Of course, if you would like to pay for more memory or vCPUs you absolutely can,
    but they are not necessary at this time:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟上本章内容，选择默认的 Amazon 选项**Amazon Linux 2**。选中此选项后，你会进入**选择实例类型**页面，选择任何符合免费套餐条件的类型，如下图所示。当然，如果你想为更多内存或虚拟
    CPU 付费也是可以的，但此时并不必要：
- en: '![Figure 8.5 – AWS AMI options'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.5 – AWS AMI 选项'
- en: '](img/B16864_08_5.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16864_08_5.jpg)'
- en: Figure 8.5 – AWS AMI options
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.5 – AWS AMI 选项
- en: 'Next, we can skip past the next few options until you get to the sixth tab
    entitled **Configure Security Group**. There are a few edits that we need to make
    here:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以跳过接下来的几个选项，直到你看到第六个标签，名为**配置安全组**。在这里，我们需要做几个编辑：
- en: TCP Rule
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TCP 规则
- en: We need to set our `8501`, the custom Streamlit port.
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们需要设置我们的 `8501`，即自定义的 Streamlit 端口。
- en: Access Source
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问源
- en: 'We also need to allow anyone to access our app, so we will also set the source
    to **Anywhere**, as shown in the following screenshot:'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们还需要允许任何人访问我们的应用，因此我们也将源设置为**任何地方**，如下图所示：
- en: '![Figure 8.6 – Security settings'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.6 – 安全设置'
- en: '](img/B16864_08_6.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16864_08_6.jpg)'
- en: Figure 8.6 – Security settings
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.6 – 安全设置
- en: 'Now, we are ready to launch! Head over to the seventh tab, **Review**, and
    click the **Launch** button if everything looks correct. What will pop up next
    is a way to create a public and private key, one held by AWS and the other held
    by you, to allow you to access this new virtual computer from your command line,
    as shown in the following screenshot:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备启动了！前往第七个标签**审查**，如果一切看起来正常，就点击**启动**按钮。接下来会弹出一个创建公私钥的方式，一把由 AWS 持有，另一把由你持有，以便你能够通过命令行访问这个新的虚拟计算机，如下图所示：
- en: '![ Figure 8.7 – Key-value pairs'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.7 – 键值对'
- en: '](img/B16864_08_7.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16864_08_7.jpg)'
- en: Figure 8.7 – Key-value pairs
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.7 – 键值对
- en: Think of it like a unique password that is downloaded as its own file. You can
    keep this file wherever is easiest and most secure for you, but make sure to never
    upload this file to a public location, such as a GitHub repository, otherwise,
    others could come and access your virtual machine! Now that we have launched our
    EC2 instance, we can access it from our command line and download our app.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 把它想象成一个独特的密码，它以文件的形式下载。你可以把这个文件保存在最方便和最安全的地方，但一定要确保从不将这个文件上传到公共位置，比如 GitHub
    仓库，否则其他人可能会来访问你的虚拟机！现在，我们已经启动了 EC2 实例，可以通过命令行访问它并下载我们的应用。
- en: Installing the necessary software
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装必要的软件
- en: For this example, we are going to try and deploy the penguin ML app that we
    created in [*Chapter 4*](B16864_04_Final_VK_ePub.xhtml#_idTextAnchor049), *Using
    Machine Learning with Streamlit*, and deployed in [*Chapter 5*](B16864_05_Final_VK_ePub.xhtml#_idTextAnchor056),
    *Deploying Streamlit with Streamlit Sharing*, on Streamlit Sharing. Now that we
    have our virtual machine and our objective, we need to access our virtual machine
    from our command line. To begin, we need to first find out the AWS instance's
    public DNS. Locate your AWS instance using this link, [https://console.aws.amazon.com/ec2/v2/home#Instances](https://console.aws.amazon.com/ec2/v2/home#Instances),
    and look for `ec2-10-857-84-485.compute-1.amazonaws.com`. I made up those numbers,
    but yours should be close to this.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将尝试部署我们在[*第 4 章*](B16864_04_Final_VK_ePub.xhtml#_idTextAnchor049)《*使用
    Streamlit 进行机器学习*》中创建的企鹅 ML 应用，并在[*第 5 章*](B16864_05_Final_VK_ePub.xhtml#_idTextAnchor056)《*通过
    Streamlit Sharing 部署 Streamlit*》中进行部署，部署到 Streamlit Sharing 上。现在我们已经有了虚拟机和目标，接下来需要通过命令行访问我们的虚拟机。首先，我们需要找出
    AWS 实例的公共 DNS。使用这个链接定位你的 AWS 实例，[https://console.aws.amazon.com/ec2/v2/home#Instances](https://console.aws.amazon.com/ec2/v2/home#Instances)，并查找
    `ec2-10-857-84-485.compute-1.amazonaws.com`。这些数字是我随便编的，但你的应该与此类似。
- en: 'Now, we can access our virtual machine using SSH, which is the Secure Shell
    Protocol, using the following command, which combines our password and our public
    DNS:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过SSH访问我们的虚拟机，SSH是安全外壳协议，使用以下命令来结合密码和公有DNS：
- en: '[PRE11]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Often, AWS commands feel like magic incantations, especially when you are first
    getting started. After some experience, you will certainly get more comfortable
    with this. At this point, AWS may ask you some questions on the command line about
    allowing certain types of access depending on how your security settings are set
    up on your local machine, and after you confirm that you would like to connect,
    you will know that you are connected if you see something similar to the following
    screenshot:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 经常，AWS命令会让人感觉像是魔法咒语，尤其是当你刚开始时。经过一段时间的实践，你会变得更加熟练。此时，AWS可能会在命令行中询问你一些问题，关于是否允许某些类型的访问，这取决于你的本地机器上安全设置的配置。在你确认希望连接后，如果你看到类似下图的内容，就知道你已经连接成功：
- en: '![Figure 8.8 – AWS login'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.8 – AWS登录'
- en: '](img/B16864_08_8.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16864_08_8.jpg)'
- en: Figure 8.8 – AWS login
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.8 – AWS登录
- en: 'This is your own new virtual computer! There are no programs, folders, or really
    almost anything else on this computer; it is brand new right out of the Amazon
    box. Each computer that we rent out using `ec2` starts out with next to nothing,
    so we have to download all that we need for this project. There are a good number
    of ways in which to do this. We can do the following:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你自己的新虚拟计算机！这台计算机上没有任何程序、文件夹，几乎没有其他东西；它就是从亚马逊的盒子里出来的全新机器。我们通过`ec2`租用的每台计算机，起初几乎什么也没有，因此我们需要下载项目所需的一切。有很多方法可以做到这一点。我们可以执行以下操作：
- en: Install everything manually.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动安装所有内容。
- en: Install a prepackaged installer such as Anaconda or Miniconda.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装一个预打包的安装程序，如Anaconda或Miniconda。
- en: Use Docker to create a set of installation instructions.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Docker创建一组安装指令。
- en: I would advise going with the second option for most use cases, as Anaconda
    or Miniconda are designed to handle all the difficulties that come with installing
    Python, dealing with our path, and also with installing various Python and R packages.
    Anaconda, and its bootstrapped (that is, smaller) version, Miniconda, are notorious
    for making installation difficult outside of their environment on your computer.
    If you require other installations of Python on your virtual or local machine,
    I would advocate either *option 1* or *option 3*.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议在大多数使用案例中选择第二个选项，因为Anaconda或Miniconda设计用来处理安装Python时遇到的所有困难，包括路径设置问题，并且能够安装各种Python和R包。Anaconda及其精简版（即更小的）Miniconda，以其在非自带环境下安装困难而著名。如果你需要在虚拟机或本地计算机上安装其他Python版本，我建议选择*选项1*或*选项3*。
- en: 'For installing and setting up Miniconda on our virtual machine, we can run
    the following commands, which use `wget` to download Miniconda to the file location,
    `~/miniconda.sh`, then run the installation file using `bash`, and then change
    our path so that we can use `conda` more easily to download packages:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 对于在虚拟机上安装和设置Miniconda，我们可以运行以下命令，使用`wget`下载Miniconda到文件位置`~/miniconda.sh`，然后使用`bash`运行安装文件，最后更改我们的路径，以便可以更轻松地使用`conda`下载包：
- en: '[PRE12]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Great! Now we have the latest versions of `python`, `pip`, and a whole host
    of Python packages. Miniconda does not come with Streamlit, however, so we will
    use the next command to download, install, and test the installation of Streamlit
    by launching the Streamlit demo app:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！现在我们有了最新版本的`python`、`pip`以及一大堆Python包。然而，Miniconda本身并不包含Streamlit，因此我们将使用下一个命令来下载、安装并通过启动Streamlit演示应用来测试Streamlit的安装：
- en: '[PRE13]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'When we run this command, we should see the following in our terminal (albeit
    with different network and external URLs):'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行此命令时，应该会在终端中看到以下内容（尽管网络和外部网址可能不同）：
- en: '![Figure 8.9 – First Streamlit command'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.9 – 第一个Streamlit命令'
- en: '](img/B16864_08_9.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16864_08_9.jpg)'
- en: Figure 8.9 – First Streamlit command
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.9 – 第一个Streamlit命令
- en: 'When you head over to the external URL from any browser, you will see the Streamlit
    demo app, as shown in the following screenshot:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当你从任何浏览器访问外部网址时，你将看到Streamlit演示应用，如下图所示：
- en: '![Figure 8.10 – Streamlit demo'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.10 – Streamlit演示'
- en: '](img/B16864_08_10.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16864_08_10.jpg)'
- en: Figure 8.10 – Streamlit demo
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.10 – Streamlit演示
- en: We have now deployed our very first Streamlit app from AWS. Now, to deploy a
    Streamlit app that we have built.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经从AWS部署了第一个Streamlit应用。现在，要部署我们构建的Streamlit应用。
- en: Cloning and running your app
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 克隆并运行你的应用
- en: 'We now have a virtual machine that can run Streamlit, and our next step is
    to download our own app onto our machine. The most straightforward method for
    doing this is by using Git and cloning the repository where your penguin machine
    learning app is held. If you have not already done this in [*Chapter 5*](B16864_05_Final_VK_ePub.xhtml#_idTextAnchor056),
    *Deploying Streamlit with Streamlit Sharing*, feel free to use my GitHub repository
    at [https://github.com/tylerjrichards/penguin_ml.git](https://github.com/tylerjrichards/penguin_ml.git).
    The following code downloads `git` and then downloads our app from GitHub:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有了一个可以运行Streamlit的虚拟机，接下来的步骤是将我们自己的应用下载到机器上。最直接的方法是使用Git并克隆存储你企鹅机器学习应用的仓库。如果你还没有在[*第5章*](B16864_05_Final_VK_ePub.xhtml#_idTextAnchor056)《使用Streamlit
    Sharing部署Streamlit》中完成这一步，可以随时使用我的GitHub仓库：[https://github.com/tylerjrichards/penguin_ml.git](https://github.com/tylerjrichards/penguin_ml.git)。以下代码下载`git`并从GitHub下载我们的应用：
- en: '[PRE14]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This will make a new folder in our current directory called `penguin_ml`, which
    contains all the files for the Streamlit app. This app requires a few more libraries
    than come from Miniconda, such as Seaborn and scikit-learn, so we need to download
    them before we run our app. We have already placed the names of these libraries
    into a file called `requirements.txt`, so we need to point `pip` to the file using
    the next set of commands:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这将会在我们当前的目录下创建一个名为`penguin_ml`的新文件夹，里面包含Streamlit应用的所有文件。这个应用比Miniconda自带的库需要更多的库，比如Seaborn和scikit-learn，因此我们需要在运行应用之前下载这些库。我们已经将这些库的名称放入一个名为`requirements.txt`的文件中，因此我们需要使用下一组命令将`pip`指向这个文件：
- en: '[PRE15]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, our final step is to run our Streamlit app:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的最后一步是运行我们的Streamlit应用：
- en: '[PRE16]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'When we go to the external URL in our AWS terminal, we will see our Streamlit
    app fully functioning there, as shown in the following screenshot:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在AWS终端访问外部URL时，我们会看到我们的Streamlit应用在那里完全正常运行，如下图所示：
- en: '![Figure 8.11 – AWS Penguin app'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.11 – AWS企鹅应用'
- en: '](img/B16864_08_11.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16864_08_11.jpg)'
- en: Figure 8.11 – AWS Penguin app
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.11 – AWS企鹅应用
- en: And there we go! We now have our app running on AWS, visible to the entire world.
    From this point, we can link to our app from a personal website you may already
    have or send it to others who may be interested in classifying their own set of
    penguins.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！我们的应用现在已经在AWS上运行，可以被全世界看到。从这个点开始，我们可以通过你可能已经拥有的个人网站链接到我们的应用，或者将其发送给那些可能对分类自己的一组企鹅感兴趣的人。
- en: Long-term AWS deployment
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 长期AWS部署
- en: 'Our final problem is that the SSH session we have running to connect our local
    machine to AWS needs to be running in order for the Streamlit app to stay up.
    For most use cases, this will not work as you will ideally want the user to interact
    with your Streamlit app if your local computer disconnects from AWS. Enter `tmux`,
    or the terminal mutiplexer, which can keep a terminal session going regardless
    of our local connection to it. To download `tmux`, we can run the following command
    while connected to our AWS virtual machine:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们面临的最后一个问题是，连接我们本地计算机与AWS的SSH会话必须保持运行，Streamlit应用才能持续运行。在大多数使用场景下，这种方式不可行，因为你通常希望用户能够在本地计算机与AWS断开连接时，仍能与Streamlit应用进行交互。于是，`tmux`（终端复用器）就派上了用场，它可以保持终端会话持续运行，而不受本地连接的影响。要下载`tmux`，我们可以在连接到AWS虚拟机时运行以下命令：
- en: '[PRE17]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'And now, we can begin a new `tmux` session and kick off our Streamlit app by
    running these next commands:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以开始一个新的`tmux`会话，并通过运行以下命令启动我们的Streamlit应用：
- en: '[PRE18]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If our connection to AWS gets disconnected, `tmux` will keep our app running.
    We can leave the `tmux` session at any time by pressing *Ctrl + D* and can re-enter
    the session by running `tmux attach`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们与AWS的连接断开，`tmux`将保持我们的应用运行。我们可以随时按*Ctrl + D*退出`tmux`会话，并通过运行`tmux attach`重新进入会话。
- en: And that covers deploying Streamlit with AWS! As you can see, Streamlit Sharing
    handles the majority of these difficulties out of the box, so I would make an
    effort to make Streamlit Sharing work whenever possible. However, this session
    should have given you an appreciation for the true breadth of options and configuration
    controls in front of us when we use AWS, which may come in handy in the future.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就完成了Streamlit与AWS的部署！正如你所见，Streamlit Sharing可以开箱即用地解决大部分这些难题，因此我会尽量让Streamlit
    Sharing在可能的情况下工作。然而，这一会话应该让你更好地了解当我们使用AWS时所面临的广泛选项和配置控制，这在将来可能会派上用场。
- en: Summary
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 总结
- en: This has been by far the most technical of our chapters so far, so congratulations
    on making it through! Deploying applications is notoriously difficult and time-consuming,
    and requires skills from software engineering and DevOps, along with often requiring
    experience with version control software (such as Git) and Unix-style commands
    and systems. This is part of the reason why Streamlit Sharing is such a crucial
    innovation, but in this chapter, we have learned how to push the edge of Streamlit
    deployment through renting our own virtual machines and deploying these on AWS
    and Heroku. We have also learned how to figure out what the right deployment strategy
    is before starting out, which will save hours or days of work (nothing is worse
    than finishing the deployment of an app and finding out you need to use another
    platform!).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，这一章是我们所有章节中最具技术性的，所以恭喜你坚持了下来！部署应用程序通常既困难又耗时，并且需要软件工程和DevOps方面的技能，还常常需要具备版本控制软件（如Git）和Unix风格命令与系统的经验。这也是为什么Streamlit
    Sharing如此重要的创新之一，但在本章中，我们已经学习了如何通过租用自己的虚拟机，并在AWS和Heroku上进行部署，推动Streamlit部署的前沿。我们还学习了如何在开始之前确定正确的部署策略，这将节省数小时甚至数天的工作（没有什么比完成应用程序部署后发现需要使用另一个平台更糟糕的了！）。
- en: Next, we'll be moving on to the third and final section of this book, which
    will focus on the various applications of Streamlit, starting with improving job
    applications with Streamlit. This next chapter will focus on impressing hiring
    managers and recruiters with Streamlit applications, on using Streamlit apps within
    actual job application sections, such as the infamous take-home portion of many
    interviews, and also on proof-of-skill data projects for improving on the data
    science résumé.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将进入本书的第三部分，也是最后一部分，重点讨论Streamlit的各种应用，首先是如何通过Streamlit提升求职申请。下一章将重点讲解如何通过Streamlit应用打动招聘经理和招聘人员，如何在实际求职申请环节中使用Streamlit应用程序，比如许多面试中臭名昭著的带回家部分，以及如何通过数据项目证明技能，来提升数据科学简历。
