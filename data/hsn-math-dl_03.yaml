- en: Vector Calculus
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向量微积分
- en: Most of you will likely have had some exposure to calculus in the past, be it
    in high school, college, or university, and were likely hoping to never have to
    deal with it again. However, calculus is not only one of the most profound discoveries
    in mathematics; it also plays a vital role in deep learning.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 你们大多数人可能在过去接触过一些微积分，无论是在高中、大学还是大学里，可能希望再也不碰它。然而，微积分不仅是数学上最深刻的发现之一，它还在深度学习中发挥着至关重要的作用。
- en: In this chapter, we will start by introducing core concepts of calculus using
    single variable calculus, and then we will move on to multivariable calculus and
    extend everything we learned in multivariable calculus to gain an understanding
    of vector calculus and its relation to deep learning.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将从介绍单变量微积分的核心概念开始，然后我们将继续学习多变量微积分，并将我们在多变量微积分中学到的内容扩展到向量微积分，并理解它与深度学习的关系。
- en: 'This chapter will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Single variable calculus
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单变量微积分
- en: Multivariable calculus
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多变量微积分
- en: Vector calculus
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向量微积分
- en: Single variable calculus
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单变量微积分
- en: At its core, calculus is nothing more than the study of relationships and change.
    Having a keen grasp of calculus will help you better understand how deep learning
    algorithms work and how to make them work better for you as a practitioner.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，微积分无非是研究关系和变化。对微积分有深刻的理解将帮助你更好地理解深度学习算法的工作原理，并在作为实践者时帮助你让它们更有效地为你服务。
- en: Let's move on to understanding what makes calculus such a powerful tool. We
    start with single variable calculus, which is about functions that take in a single
    input and produce a single output.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续了解一下微积分为什么是一个如此强大的工具。我们从单变量微积分开始，它涉及到那些接受单一输入并产生单一输出的函数。
- en: Derivatives
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导数
- en: 'To start with, let''s imagine a straight line with the following equation:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们想象一条直线，方程如下：
- en: '![](img/aa7984ce-3f61-4ad0-8d7c-43312df9eb75.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![](img/aa7984ce-3f61-4ad0-8d7c-43312df9eb75.png)'
- en: 'In the equation, the following aspects apply:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方程中，以下几点适用：
- en: '*y* is a function of *x*, often written simply as *f(x)* (which is the notation
    we will be predominantly using in the remainder of the book). In the preceding
    equation, the output value *y* is dependent on the input value *x*.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*y* 是 *x* 的函数，通常简写为 *f(x)*（这是我们在本书剩余部分将主要使用的符号）。在前面的方程中，输出值 *y* 依赖于输入值 *x*。'
- en: The *m* value is the gradient, which tells us how steep the straight line is,
    or what its rate of change is (that is, how much does a change in the *x* value
    affect the *y* value).
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*m* 值是梯度，告诉我们直线的陡峭程度，或者说它的变化率（即 *x* 值的变化对 *y* 值的影响有多大）。'
- en: The ![](img/3eaebf0e-13b1-4078-b90a-89c4597d7c98.png) value tells us whether
    the line is moving upward or downward.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该值 [![](img/3eaebf0e-13b1-4078-b90a-89c4597d7c98.png)] 告诉我们直线是向上还是向下移动。
- en: The ![](img/f242110e-d2e4-44f8-802a-a9411a28f0ea.png) value tells us by how
    much the line is above or below the origin.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该值 [![](img/f242110e-d2e4-44f8-802a-a9411a28f0ea.png)] 告诉我们直线相对于原点的位置是向上还是向下。
- en: The *m* and *b* values in a straight line are constant throughout.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直线中的 *m* 和 *b* 值在整个过程中是常量。
- en: Now that you know what the equation of a straight line looks like, you're probably
    wondering how to find it for an arbitrary straight line.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了直线方程的样子，你可能会想知道如何找到任意直线的方程。
- en: We start by first picking two points, (*x[1], y[1]*) and (*x[2], y[2]*), that
    lay on the line, and plug their values into the formula [![](img/1d707d49-6ca6-4819-8282-a6e05a6659b1.png)].
    After having found the value for *m*, we find the value of *b* by using the line
    equation and plugging into it the value for *m* and one (*x, y*) point on the
    line, and solve for *b*.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先选择两点，(*x[1], y[1]*) 和 (*x[2], y[2]*), 它们位于直线上，然后将它们的值代入公式中 [![](img/1d707d49-6ca6-4819-8282-a6e05a6659b1.png)]。在找到了
    *m* 的值后，我们通过使用直线方程并代入 *m* 的值和其中一个 (*x, y*) 点的值，来求解 *b*。
- en: 'Well, that was very simple and straightforward. However, there are far more
    complex equations out there that aren''t as straightforward—those that relate
    to curves (nonlinear functions), as illustrated in the following image:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这非常简单直接。然而，外面还有许多复杂的方程并不像这样直接——比如那些与曲线（非线性函数）相关的方程，如下图所示：
- en: '![](img/9952e1b9-a429-42ed-a380-4535e0eb0596.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9952e1b9-a429-42ed-a380-4535e0eb0596.png)'
- en: Imagine a picture of a couple of hills or camel humps. If you trace the surface
    of them, you will have a curve, and as you may have no doubt noticed, they go
    up and then down and then back up, and the process repeats itself.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下几座山丘或骆驼背的图片。如果你沿着它们的表面描绘，你将得到一条曲线，正如你可能已经注意到的那样，它会上升，然后下降，再上升，过程不断重复。
- en: From the preceding image of the curve, you can easily tell that the gradient
    is not constant, as it was in the previous example with the straight line. We
    could sketch straight lines along the curve and calculate their slopes to understand
    how the curve moves. However, there is a simpler method than this tedious one.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面曲线的图像中，你可以很容易看出，梯度不是常数，正如在前面的直线示例中看到的那样。我们可以沿着曲线画出直线并计算它们的斜率来理解曲线如何变化。然而，比这种繁琐方法更简单的方法是存在的。
- en: 'At the very core of calculus are two concepts, as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 微积分的核心有两个概念，如下所示：
- en: '**Differentiation** helps us understand how much a function output changes
    with respect to changing input.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**微分**帮助我们理解函数输出相对于输入变化的变化量。'
- en: '**Integration** helps us understand the impact of this change in inputs between
    certain points.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**积分**帮助我们理解在某些点之间输入变化的影响。'
- en: 'We will begin initially by taking an in-depth look at differentiation. The
    primary equation for finding the derivative of a function is shown here:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先深入研究微分。求导数的基本方程如下所示：
- en: '![](img/f9062c7a-3330-4e38-91dd-65eb66be81d8.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f9062c7a-3330-4e38-91dd-65eb66be81d8.png)'
- en: 'I know there are a few new symbols here and it looks complicated, but it''s
    really very simple. What this equation is doing is finding the derivative of the
    function *f* with respect to the variable in the denominator *x*. This isn''t
    too different from the earlier equation we saw (which we used to calculate the
    gradient of a straight line). We subtract two values, *f(x+h)* and *f(x), *and
    divide it by its difference, *h*. But what does [![](img/7254965b-6a3e-4c66-ba4c-ffda679af62f.png)] have
    to do with this? This tells us that we want the two points on the curve to be
    as close to each other as possible so that when we are sketching the gradient
    on the curve, it looks like a straight line at one point on the curve. This allows
    us to better visualize and understand the effect of the change, as can be seen
    in the following screenshot:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道这里有一些新的符号，看起来很复杂，但其实非常简单。这个方程做的是求函数*f*对于分母中的变量*x*的导数。这与我们之前看到的方程（我们用来计算直线的梯度）并没有太大区别。我们减去两个值，*f(x+h)*
    和 *f(x)*，然后除以它们的差值，*h*。但[![](img/7254965b-6a3e-4c66-ba4c-ffda679af62f.png)]与这个有什么关系呢？这告诉我们，我们希望曲线上的两点尽可能靠近，以便当我们在曲线上绘制梯度时，它看起来像是在某一点上的一条直线。这样，我们就能更好地可视化并理解变化的效果，正如下面的截图所示：
- en: '![](img/af7f06c7-704a-4aea-947a-d511e68a65e9.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/af7f06c7-704a-4aea-947a-d511e68a65e9.png)'
- en: 'See the following example:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 请看以下示例：
- en: '![](img/8edacc96-ce9a-4bda-8048-509329c9b4ad.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8edacc96-ce9a-4bda-8048-509329c9b4ad.png)'
- en: Now that we understand what a derivative is and how to find it for any function,
    let's move on to some important rules of differentiation.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经理解了导数是什么以及如何为任何函数找到导数，让我们继续了解一些重要的微分规则。
- en: Sum rule
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 求和法则
- en: 'The sum rule states that the derivative of the sum of two functions is the
    same as the sum of the individual derivatives of the two functions, as can be
    seen in the following equation:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 求和法则表明，两个函数的和的导数等于这两个函数的导数之和，具体如下方程所示：
- en: '![](img/e1bd1f1b-f172-4bfc-9801-3e118806dcab.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e1bd1f1b-f172-4bfc-9801-3e118806dcab.png)'
- en: Let's suppose we have [![](img/5a7475a2-1ddf-4c79-baa1-c03def2552f8.png)] and [![](img/f5f9a3bc-4187-453d-bb88-9a84ad8cc88d.png)].
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有[![](img/5a7475a2-1ddf-4c79-baa1-c03def2552f8.png)] 和 [![](img/f5f9a3bc-4187-453d-bb88-9a84ad8cc88d.png)]。
- en: From this, we can see that the following equation, [![](img/ebd0bf36-1a99-47e0-9957-f3d760aeec73.png)],
    is the same as this one:[![](img/05df891e-9156-4259-bb4a-aa9e2953286c.png)].
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个，我们可以看到以下方程，[![](img/ebd0bf36-1a99-47e0-9957-f3d760aeec73.png)]，与这个方程是相同的：[![](img/05df891e-9156-4259-bb4a-aa9e2953286c.png)]。
- en: Power rule
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 幂法则
- en: 'The power rule helps to find the derivative of a function where the variable
    has an exponent. Simply put, you multiply the power by the constant in front of
    the variable, and reduce the power by 1\. Let''s see what an example of this looks
    like, using the power rule [![](img/257032ca-20f4-4eb2-a68f-5f13ae02ba40.png)],
    as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 幂法则有助于找到变量具有指数的函数的导数。简而言之，你将幂次与变量前的常数相乘，并将幂次减小 1。让我们来看一个使用幂法则的例子 [![](img/257032ca-20f4-4eb2-a68f-5f13ae02ba40.png)]，如下所示：
- en: '![](img/6dd27b33-072d-449f-887d-14860524e576.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6dd27b33-072d-449f-887d-14860524e576.png)'
- en: Note that not every function will have a derivative, at least not in the function's
    domain.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，并非每个函数都有导数，至少在该函数的定义域内没有。
- en: There are certain functions—such as [![](img/b70ba598-b44e-4cb5-8b06-cd31db7e2c3d.png)] or [![](img/cb8aa930-34d3-4ee1-89ef-9edea0b4ecb7.png)] —that
    are not as straightforward as the ones we saw earlier. The function [![](img/72973c05-d123-4d46-bfbb-10e4a90310b2.png)] is
    not differentiable at *x = 0* because its value is undefined. This is known as
    **discontinuity**.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 有些函数——例如 [![](img/b70ba598-b44e-4cb5-8b06-cd31db7e2c3d.png)] 或 [![](img/cb8aa930-34d3-4ee1-89ef-9edea0b4ecb7.png)] ——不像我们之前看到的那些函数那样简单。函数 [![](img/72973c05-d123-4d46-bfbb-10e4a90310b2.png)] 在
    *x = 0* 处不可导，因为其值是未定义的。这被称为**不连续性**。
- en: The same applies to [![](img/db449b88-f018-41d4-b761-122781d99dfe.png)]; however, *e* (known
    as **Euler's number**) has a very interesting property whereby the function is
    equal to its derivative—that is, [![](img/4ad4557a-efd4-4123-b67d-49c892a2a78e.png)].
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 同样适用于 [![](img/db449b88-f018-41d4-b761-122781d99dfe.png)]；然而，*e*（即**欧拉常数**）具有一个非常有趣的特性，即该函数等于其导数——也就是说， [![](img/4ad4557a-efd4-4123-b67d-49c892a2a78e.png)]。
- en: Trigonometric functions
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 三角函数
- en: 'In high school or university, you likely studied trigonometry and encountered
    the sine, cosine, and tangent functions. More important to us are the sine and
    cosine functions, which you will encounter often and which we will look at here.
    These functions can be seen in the following image:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在高中或大学，你可能学习过三角学，并遇到过正弦、余弦和正切函数。对我们来说，更重要的是正弦和余弦函数，你将经常遇到这两者，我们将在这里进行讨论。这些函数可以在以下图片中看到：
- en: '![](img/9180e689-9902-4707-8156-29175f938c29.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9180e689-9902-4707-8156-29175f938c29.png)'
- en: Here, sine is [![](img/77570f27-f16c-42eb-a904-fbd41087473f.png)] and cosine
    is [![](img/91ef94ec-c6f4-4668-b9c0-07e860896e0a.png).]
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，正弦是 [![](img/77570f27-f16c-42eb-a904-fbd41087473f.png)]，余弦是 [![](img/91ef94ec-c6f4-4668-b9c0-07e860896e0a.png)]。
- en: The sine and cosine functions are related, and the derivative will show us how.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 正弦和余弦函数是相关的，导数将向我们展示这种关系。
- en: If [![](img/0caf5d22-1868-4c84-9637-07062b3f708c.png)], then [![](img/ca5654f3-9661-4b7a-954a-0b42f5d4b10d.png)].
    However, if [![](img/f53ab3f8-feef-49f3-b828-d91f204c481d.png)], then [![](img/cdd675b8-f811-4fab-9f27-3cc6779be414.png)].
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 [![](img/0caf5d22-1868-4c84-9637-07062b3f708c.png)]，则 [![](img/ca5654f3-9661-4b7a-954a-0b42f5d4b10d.png)]。然而，如果 [![](img/f53ab3f8-feef-49f3-b828-d91f204c481d.png)]，则 [![](img/cdd675b8-f811-4fab-9f27-3cc6779be414.png)]。
- en: 'The derivatives create a loop, which we can see as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 导数形成一个循环，我们可以通过以下方式看到：
- en: '![](img/02d28816-e09e-49c6-b82e-180903528446.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/02d28816-e09e-49c6-b82e-180903528446.png)'
- en: First and second derivatives
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一阶和二阶导数
- en: Now that we know how to find the derivative of a function, it is important to
    know that we can take the derivative more than once.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们知道如何找到函数的导数，那么接下来需要知道的是，我们可以对函数进行多次求导。
- en: 'The first derivative, as we know, gives us the gradient (slope of the tangent
    line) of a function at any given point (*x*) on the curve—in other words, whether
    the curve''s altitude (that is, *y* or *f(x)*) is increasing or decreasing. A
    positive slope tells us *f(x)* is increasing as *x* increases and a negative slope
    tells us *f(x)* is decreasing as *x* increases, and a slope of 0 tells us nothing
    about the curve''s direction, other than that it is likely at a turning point
    (local minimum or local maximum). This can be written as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，第一导数给出了函数在任意给定点 (*x*) 处的梯度（切线的斜率）——换句话说，就是该曲线的高度（即 *y* 或 *f(x)*) 是在增加还是在减少。正斜率告诉我们
    *f(x)* 随着 *x* 增加而增加，负斜率告诉我们 *f(x)* 随着 *x* 增加而减少，斜率为 0 则告诉我们无法确定曲线的方向，只能推测它可能处于转折点（局部最小值或局部最大值）。这可以写成如下形式：
- en: If [![](img/d86125d6-30d9-41e3-9f73-cbf7baa85925.png)], then *f(x)* is increasing
    at *x = t*.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 [![](img/d86125d6-30d9-41e3-9f73-cbf7baa85925.png)]，则 *f(x)* 在 *x = t* 处是递增的。
- en: If [![](img/80ce76bf-3eb6-44e4-aba4-acbf744fdea2.png)], then *f(x)* is decreasing
    at *x = t*.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 [![](img/80ce76bf-3eb6-44e4-aba4-acbf744fdea2.png)]，则 *f(x)* 在 *x = t* 处是递减的。
- en: If [![](img/ec3149ab-956c-4b9b-9d54-2a6a63938657.png)], then *x=t* is a critical
    point of *f(x)*.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果[![](img/ec3149ab-956c-4b9b-9d54-2a6a63938657.png)]，那么 *x=t* 是 *f(x)* 的一个临界点。
- en: 'For example, let [![](img/5f0e7e76-62c0-4d8d-a361-bfbb43ca4f46.png)]. The derivative
    of this function is shown here:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，设[![](img/5f0e7e76-62c0-4d8d-a361-bfbb43ca4f46.png)]。该函数的导数如下所示：
- en: '![](img/a7b22566-1a2e-4aff-82aa-6c6f099c85c4.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a7b22566-1a2e-4aff-82aa-6c6f099c85c4.png)'
- en: At *x = 0*, the derivative is 9, which tells us the function is increasing at
    this point. But at *x = 1* the derivative is -3 telling us that the function is
    decreasing at this point.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *x = 0* 时，导数为9，这告诉我们函数在这一点是递增的。但在 *x = 1* 时，导数为-3，说明函数在这一点是递减的。
- en: The second derivative is the derivative of the derivative of the function. We
    write this as [![](img/b626c2af-5a48-437d-9bc5-9cdad7f73bfe.png)] or [![](img/c97b55b5-c095-4e4d-a50d-b32ff8677660.png)].
    As before, where the first derivative told us whether the function was increasing
    or decreasing, the second derivative gives us the same information about the first
    derivative—whether it is increasing or decreasing.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 二阶导数是函数导数的导数。我们将其表示为[![](img/b626c2af-5a48-437d-9bc5-9cdad7f73bfe.png)] 或 [![](img/c97b55b5-c095-4e4d-a50d-b32ff8677660.png)]。如同之前，第一导数告诉我们函数是增是减，二阶导数则告诉我们第一导数的增减情况。
- en: If the second derivative is positive, then as *x* increases, the first derivative
    is increasing; and if the second derivative is negative, then as *x* increases, the
    first derivative is decreasing.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果二阶导数为正，那么随着 *x* 的增大，第一导数也在增大；如果二阶导数为负，则随着 *x* 的增大，第一导数在减小。
- en: 'To help us visualize this, when the second derivative is positive, the curve
    is concave up (parabola open upward) at a point, whereas when it is negative,
    the curve is concave down (parabola open downward). And as before, when the second
    derivative is equal to zero, we learn nothing new. This point could be a local
    maximum, a local minimum, or an inflection point. This is written as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助我们可视化，当二阶导数为正时，曲线在某点是向上的凹曲线（抛物线朝上开口）；而当二阶导数为负时，曲线是向下的凹曲线（抛物线朝下开口）。正如之前所说，当二阶导数为零时，我们不会获得新的信息。这个点可能是局部最大值、局部最小值或拐点。可以写成如下形式：
- en: If [![](img/c18fb859-0682-4ff4-9f87-ef62eb38be89.png)], then *f(x)* is concave
    up at *x=t*.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果[![](img/c18fb859-0682-4ff4-9f87-ef62eb38be89.png)]，那么在 *x=t* 时，*f(x)* 是向上的凹曲线。
- en: If [![](img/f81a65d5-84cd-4bd4-b09d-3352b9f1f3c8.png)], then *f(x)* is concave
    down at *x=t*.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果[![](img/f81a65d5-84cd-4bd4-b09d-3352b9f1f3c8.png)]，那么 *f(x)* 在 *x=t* 处是向下凹的。
- en: If [![](img/0f9c7cda-5ccc-4b95-9562-725fc46747d4.png)], then at *x=t* we obtain
    no new information about *f(x)*.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果[![](img/0f9c7cda-5ccc-4b95-9562-725fc46747d4.png)]，那么在 *x=t* 处，我们无法获得关于 *f(x)*
    的新信息。
- en: 'For example, let''s take the second derivative of the same function we used,
    as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以对之前使用的相同函数求二阶导数，结果如下：
- en: '![](img/58fa95b6-5228-49f2-8b75-5282c90782eb.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/58fa95b6-5228-49f2-8b75-5282c90782eb.png)'
- en: At *x = 0*, the second derivative is -24, which tells us the function is concave
    down here. But at *x = 2*, it is equal to 24, telling us the function is concave
    up.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *x = 0* 时，二阶导数为-24，这告诉我们函数在这一点是向下凹的。但在 *x = 2* 时，二阶导数为24，说明函数在这一点是向上凹的。
- en: 'Earlier, we learned that when *x* is a critical point of a function we learn
    nothing new about the function at that point, but we can use it to find out whether
    it is a local maximum or a local minimum. These rules can be written as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 之前我们学到，当 *x* 是函数的临界点时，我们在该点无法得到关于函数的新信息，但我们可以用它来判断该点是局部最大值还是局部最小值。这些规则可以写成如下形式：
- en: If [![](img/f41bc72b-726c-466d-a9b8-eda08e92612b.png)] and [![](img/9893df9d-c62e-48a5-9346-8d9803dec297.png)],
    then *f(x)* has a local minimum at *x=t*.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果[![](img/f41bc72b-726c-466d-a9b8-eda08e92612b.png)] 和 [![](img/9893df9d-c62e-48a5-9346-8d9803dec297.png)]，那么
    *f(x)* 在 *x=t* 处有一个局部最小值。
- en: If [![](img/26ad0c1e-e9ef-47ec-ab47-3da7f453a19e.png)] and [![](img/259c824b-df4e-493b-9c71-bcd5be72c704.png)],
    then *f(x)* has a local maximum at *x=t*.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果[![](img/26ad0c1e-e9ef-47ec-ab47-3da7f453a19e.png)] 和 [![](img/259c824b-df4e-493b-9c71-bcd5be72c704.png)]，那么
    *f(x)* 在 *x=t* 处有一个局部最大值。
- en: If [![](img/65ee9469-3f8b-4065-bf94-920277d88181.png)] and [![](img/38599662-9046-4b09-85f8-46705527c1ae.png)],
    then at *x=t* we learn nothing new about *f(x)*.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果[![](img/65ee9469-3f8b-4065-bf94-920277d88181.png)] 和 [![](img/38599662-9046-4b09-85f8-46705527c1ae.png)]，那么在
    *x=t* 处我们无法获得关于 *f(x)* 的新信息。
- en: Product rule
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 积分法则
- en: The product rule gives us a straightforward method to find the derivative of
    the product of two functions. Let's take two arbitrary functions, *f(x)* and *g(x), *and
    multiply them. So, [![](img/de194b8d-ea89-4e64-b8fd-ae93468a4413.png)]. The derivative
    is [![](img/a1078065-6639-471a-975b-3ac15be2479f.png)].
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 积分法则为我们提供了一种直接的方法来求两个函数的乘积的导数。假设我们有两个任意函数，*f(x)* 和 *g(x)*，并将它们相乘。所以，[![](img/de194b8d-ea89-4e64-b8fd-ae93468a4413.png)]。其导数为
    [![](img/a1078065-6639-471a-975b-3ac15be2479f.png)]。
- en: 'Let''s explore this in more detail to understand how this works. Have a look
    at the following equation:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地探讨一下，看看它是如何工作的。请看下面的方程：
- en: '![](img/0cf58109-75ff-4cf3-9018-aff26a026420.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0cf58109-75ff-4cf3-9018-aff26a026420.png)'
- en: 'We can rewrite the derivative, as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将导数重写为如下形式：
- en: '![](img/77772ea4-8854-4058-92b8-a4e79825b65b.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/77772ea4-8854-4058-92b8-a4e79825b65b.png)'
- en: This can be further simplified as [![](img/2db03584-1427-4c51-ab85-09fd8085fb06.png)],
    which is the same as before.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以进一步简化为 [![](img/2db03584-1427-4c51-ab85-09fd8085fb06.png)]，其结果与之前相同。
- en: Quotient rule
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 商法则
- en: The quotient rule allows us to find the derivative of a function that is being
    divided by another function. This can be derived from the product rule. As before,
    we take two functions *f(x)* and *g(x)*, but now, we will divide them. So, [![](img/b231fb61-5dcf-4683-8b9f-7df5c6f4e275.png)].
    The derivative is [![](img/0d9122c5-410e-4abb-8598-5a8ea7508373.png)].
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 商法则使我们能够求出一个函数与另一个函数相除时的导数。这可以通过积分法则推导出来。和之前一样，我们取两个函数 *f(x)* 和 *g(x)*，但现在我们将它们相除。所以，[![](img/b231fb61-5dcf-4683-8b9f-7df5c6f4e275.png)]。其导数为
    [![](img/0d9122c5-410e-4abb-8598-5a8ea7508373.png)]。
- en: 'Suppose we have [![](img/824bc5f5-c4af-4bfa-a3f2-b0bcc8a1ab02.png)] and [![](img/04eaba54-d29b-4cba-9d23-5ebd2657faaf.png)].
    Then, we have the following:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有 [![](img/824bc5f5-c4af-4bfa-a3f2-b0bcc8a1ab02.png)] 和 [![](img/04eaba54-d29b-4cba-9d23-5ebd2657faaf.png)]。那么我们得到如下结果：
- en: '![](img/64cf49f5-d145-4b82-95ab-588e93df7968.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/64cf49f5-d145-4b82-95ab-588e93df7968.png)'
- en: 'By finding the derivatives of *f(x)* and *g(x)* and plugging them into the
    preceding equation, we get the following:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 通过求出 *f(x)* 和 *g(x)* 的导数，并将它们代入前面的方程，我们得到以下结果：
- en: '![](img/68168e9d-53b4-44df-a5cf-bf27ba9af5f5.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/68168e9d-53b4-44df-a5cf-bf27ba9af5f5.png)'
- en: If we expand it, we find the derivative.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们扩展它，就能求出导数。
- en: Chain rule
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链式法则
- en: The chain rule applies to functions that take in another function as input.
    Let's consider [![](img/ed41b349-9489-4391-9581-99c220927654.png)], which is often
    written as [![](img/6b296cca-7a66-4f08-ae53-70347d20eafa.png)] and read as *f* of
    *g* of *x*. This means that the output of *g(x)* will become the input to the
    function *f*.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 链式法则适用于输入是另一个函数的函数。我们考虑 [![](img/ed41b349-9489-4391-9581-99c220927654.png)]，通常写作
    [![](img/6b296cca-7a66-4f08-ae53-70347d20eafa.png)]，表示 *f* 是 *g* 的 *x* 的函数。这意味着
    *g(x)* 的输出将成为函数 *f* 的输入。
- en: 'The derivative of this will be written as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这个导数将写成如下形式：
- en: '![](img/d4b250a5-7a46-4a8a-8bb9-e97f84b43d46.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d4b250a5-7a46-4a8a-8bb9-e97f84b43d46.png)'
- en: This is the same as [![](img/f60f19bf-a078-42e8-9f8c-eadd6eef2276.png)].
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这与 [![](img/f60f19bf-a078-42e8-9f8c-eadd6eef2276.png)] 相同。
- en: For example, suppose we have [![](img/0f2ecc29-f74e-4a9c-86ac-945a4ee45215.png)] and
    [![](img/58b5b56c-5a21-4ec1-a5c6-2db52c30fc28.png)]. We then differentiate the
    two functions and get [![](img/af10bf17-de2b-4b15-b893-dae3366107eb.png)] and
    [![](img/891ac83b-ad63-49a8-abe1-d9619abe1085.png)].
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们有 [![](img/0f2ecc29-f74e-4a9c-86ac-945a4ee45215.png)] 和 [![](img/58b5b56c-5a21-4ec1-a5c6-2db52c30fc28.png)]。我们对这两个函数进行求导，得到
    [![](img/af10bf17-de2b-4b15-b893-dae3366107eb.png)] 和 [![](img/891ac83b-ad63-49a8-abe1-d9619abe1085.png)]。
- en: By plugging this into the preceding formula, we get [![](img/583fbb30-d59c-4345-bfb7-7c22ddddd08c.png)].
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 将这个代入之前的公式，我们得到 [![](img/583fbb30-d59c-4345-bfb7-7c22ddddd08c.png)]。
- en: Antiderivative
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反导数
- en: We now know what derivatives are and how to find them, but now, suppose we know
    the rate of change (*F*) of the population (*f*), and we want to find what the
    population will be at some point in time. What we have to do is find a function
    *F* whose derivative is *f*. This is known as the **antiderivative**, and we define
    it formally as a function *F* is called an antiderivative of *f* on [![](img/635f7faa-5a7a-4d61-87aa-99728032b763.png)] if [![](img/33eb577d-55b4-4446-944d-f57bb6394223.png)] for
    all ![](img/f213a601-0421-4be1-865d-053761e776a4.png).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在知道了什么是导数以及如何求导，但现在假设我们知道了人口 (*f*) 的变化率 (*F*)，并且我们想找出某一时刻的具体人口数量。我们需要做的是找到一个函数
    *F*，使得它的导数是 *f*。这就是所谓的**反导数**，我们正式定义它为，如果在 [![](img/635f7faa-5a7a-4d61-87aa-99728032b763.png)]
    上，*f* 的反导数 *F* 满足 [![](img/33eb577d-55b4-4446-944d-f57bb6394223.png)] 对所有 ![](img/f213a601-0421-4be1-865d-053761e776a4.png)
    成立。
- en: Suppose we have a function [![](img/ee867575-1177-49b7-babb-0d4e20150490.png)],
    then [![](img/fba25894-337d-4156-9808-a141a57b0480.png)] (where *c* is some constant),
    from which we can confirm that [![](img/4ac163f8-f9b2-4b60-8331-a7724a5bd656.png)].
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个函数[![](img/ee867575-1177-49b7-babb-0d4e20150490.png)]，然后是[![](img/fba25894-337d-4156-9808-a141a57b0480.png)]（其中*c*是某个常数），由此我们可以确认[![](img/4ac163f8-f9b2-4b60-8331-a7724a5bd656.png)]。
- en: 'The following table shows some important functions and their antiderivatives
    that we will encounter often:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了我们将经常遇到的一些重要函数及其反导数：
- en: '| **Function** | **Antiderivative** |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| **函数** | **反导数** |'
- en: '| ![](img/4a4df447-7c22-476e-bc54-a869bff13d1b.png) | ![](img/264a83db-2125-48f5-8e56-19423fee8167.png)
    |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| ![](img/4a4df447-7c22-476e-bc54-a869bff13d1b.png) | ![](img/264a83db-2125-48f5-8e56-19423fee8167.png)
    |'
- en: '| ![](img/d0ecb407-ec75-4cde-b9d5-7394b87bc069.png) | ![](img/6e2e7819-764f-4fe8-a372-4ae76a498ba3.png)
    |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| ![](img/d0ecb407-ec75-4cde-b9d5-7394b87bc069.png) | ![](img/6e2e7819-764f-4fe8-a372-4ae76a498ba3.png)
    |'
- en: '| ![](img/b8e0a0d0-6ae2-4e2f-90d1-7a522cb1760b.png) | ![](img/f7c0b9fa-b845-4564-b1ff-48f15b6c940c.png)
    |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| ![](img/b8e0a0d0-6ae2-4e2f-90d1-7a522cb1760b.png) | ![](img/f7c0b9fa-b845-4564-b1ff-48f15b6c940c.png)
    |'
- en: '| ![](img/0d2197f2-cf35-4034-a2dc-41a80cf1390e.png) | ![](img/a500fee4-160c-411c-ada0-8c148a350a8a.png)
    |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| ![](img/0d2197f2-cf35-4034-a2dc-41a80cf1390e.png) | ![](img/a500fee4-160c-411c-ada0-8c148a350a8a.png)
    |'
- en: '| ![](img/df9ccc18-4b6d-4638-a5af-341e610765d5.png) | ![](img/28b6ebf4-c52f-4b04-aae8-b8f757731794.png)
    |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| ![](img/df9ccc18-4b6d-4638-a5af-341e610765d5.png) | ![](img/28b6ebf4-c52f-4b04-aae8-b8f757731794.png)
    |'
- en: '| ![](img/1e01b7fd-74b6-40fa-8017-e8f21c41527d.png) | ![](img/41a34e31-dd91-48a6-b360-9111145b56dd.png)
    |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| ![](img/1e01b7fd-74b6-40fa-8017-e8f21c41527d.png) | ![](img/41a34e31-dd91-48a6-b360-9111145b56dd.png)
    |'
- en: '| ![](img/a446e722-0db7-4983-bd67-dfd732784be7.png) | ![](img/c1534e87-0946-4590-92a4-c6045ce6ecad.png)
    |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| ![](img/a446e722-0db7-4983-bd67-dfd732784be7.png) | ![](img/c1534e87-0946-4590-92a4-c6045ce6ecad.png)
    |'
- en: '| ![](img/557e24dd-070d-4a15-add4-c472d34ebe69.png) | ![](img/3a9b6fd3-1f92-420c-9cdd-dc6297982a86.png)
    |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| ![](img/557e24dd-070d-4a15-add4-c472d34ebe69.png) | ![](img/3a9b6fd3-1f92-420c-9cdd-dc6297982a86.png)
    |'
- en: '| ![](img/c6369ea0-9427-4ef9-9c2c-78be0b132426.png) | ![](img/3a4c33ac-1018-406f-89f1-d9bd893a87d9.png)
    |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| ![](img/c6369ea0-9427-4ef9-9c2c-78be0b132426.png) | ![](img/3a4c33ac-1018-406f-89f1-d9bd893a87d9.png)
    |'
- en: 'Let''s suppose we have the following function:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有以下函数：
- en: '![](img/b57b3099-0063-40f6-8785-6ba53e65d1a1.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b57b3099-0063-40f6-8785-6ba53e65d1a1.png)'
- en: We want to find its antiderivative. I know this probably looks like a difficult
    equation, but by using the preceding table, we can make this very easy for ourselves.
    Let's see how.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要找到它的反导数。我知道这看起来可能是一个复杂的方程，但通过使用前面的表格，我们可以让这一过程变得非常简单。让我们看看如何做。
- en: 'First, we rewrite the function so it becomes the following:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将函数重写为如下形式：
- en: '![](img/050a81e0-a8a5-46ee-8951-0c1228927d8e.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](img/050a81e0-a8a5-46ee-8951-0c1228927d8e.png)'
- en: 'And so, the antiderivative is as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，反导数如下所示：
- en: '![](img/f5dd52fc-900f-4d4f-b519-4575004b1bde.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f5dd52fc-900f-4d4f-b519-4575004b1bde.png)'
- en: 'To make things easier, we rewrite this, as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化，我们将其重写如下：
- en: '![](img/2b074ce1-0d0f-4dc5-95aa-f799edb57054.png).'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/2b074ce1-0d0f-4dc5-95aa-f799edb57054.png)。'
- en: And there you have it.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。
- en: You may now be wondering whether or not we can find what the value of *c* is,
    and if so, how. Let's go through another example, and see how.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可能会想知道我们是否能找到*c*的值，如果能，应该怎么找。让我们通过另一个例子，看看如何操作。
- en: 'Suppose we have a function that is the second derivative, and we want to find
    the antiderivative of the antiderivative—that is, the original function. We have
    the following:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个是二阶导数的函数，我们想找到反导数的反导数——也就是原始函数。我们有以下内容：
- en: '![](img/d0755649-4af0-4fbc-ba12-3d1878d463cf.png) and ![](img/8bff1025-e006-49fd-9e76-2d0776b1daec.png) and ![](img/e9232ae9-dd37-4c8a-9435-5f9068d5f7e3.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d0755649-4af0-4fbc-ba12-3d1878d463cf.png) 和 ![](img/8bff1025-e006-49fd-9e76-2d0776b1daec.png)
    和 ![](img/e9232ae9-dd37-4c8a-9435-5f9068d5f7e3.png)'
- en: 'Then, the first antiderivative is as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，第一个反导数如下所示：
- en: '![](img/5f4ed156-2651-484a-aabd-f5f2fc8d1c64.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5f4ed156-2651-484a-aabd-f5f2fc8d1c64.png)'
- en: 'And so, the second antiderivative is as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，二阶反导数如下所示：
- en: '![](img/2ff2b47a-ff55-49cc-8417-3640de5e3ab6.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2ff2b47a-ff55-49cc-8417-3640de5e3ab6.png)'
- en: 'Here, we want to find the values of *c* and *d*. We can do this simply by plugging
    in the preceding values and solving for the unknowns, as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们想要找出*c*和*d*的值。我们可以通过代入前面的值并解出未知数，简单地做到这一点，如下所示：
- en: '![](img/9b78cb2c-bf66-43f0-9081-8920db7503f7.png); therefore, ![](img/0458a1e5-6874-4de9-9f04-541ba171cdd9.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9b78cb2c-bf66-43f0-9081-8920db7503f7.png)；因此，![](img/0458a1e5-6874-4de9-9f04-541ba171cdd9.png)'
- en: 'We can also do this:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以这样做：
- en: '![](img/7370788f-724f-4bb0-99d0-fbf3345dee0e.png); therefore, ![](img/2fc29d8e-c90d-439e-9ef2-2ce8eb6bfd1a.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7370788f-724f-4bb0-99d0-fbf3345dee0e.png)；因此， ![](img/2fc29d8e-c90d-439e-9ef2-2ce8eb6bfd1a.png)'
- en: 'Thus, our function looks like this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的函数看起来像这样：
- en: '![](img/80ea4eb4-1eed-4d16-a511-ec89e75d792c.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80ea4eb4-1eed-4d16-a511-ec89e75d792c.png)'
- en: Integrals
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 积分
- en: So far, we have studied derivatives, which is a method for extracting information
    about the rate of change of a function. But as you may have realized, integration
    is the reverse of the earlier problems.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了导数，这是一种提取函数变化率的信息的方法。但正如你可能已经意识到的，积分是之前问题的逆过程。
- en: In integration, we find the area underneath a curve. For example, if we have
    a car and our function gives us its velocity, the area under the curve will give
    us the distance it has traveled between two points.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在积分中，我们找到曲线下方的面积。例如，如果我们有一辆车且我们的函数给出了它的速度，曲线下方的面积将告诉我们它在两个点之间行驶的距离。
- en: 'Let''s suppose we have the curve [![](img/112ab104-760c-4ac2-97b4-b254d08f9f9a.png)],
    and the area under the curve between *x = a* (the lower limit) and *x = b* (the
    upper limit, also written as [*a, b*]) is S. Then, we have the following:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有如下曲线 [![](img/112ab104-760c-4ac2-97b4-b254d08f9f9a.png)]，曲线下方在 *x = a*（下限）和
    *x = b*（上限，亦可写作 [*a, b*]）之间的面积为 S。那么，我们得到以下公式：
- en: '![](img/15d05293-5a13-481b-9954-f5c81029bfde.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](img/15d05293-5a13-481b-9954-f5c81029bfde.png)'
- en: 'The diagramatical representation of the curve is as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 曲线的图示如下：
- en: '![](img/1e4dc6a3-a3cb-43d3-aa51-20234d07d01c.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1e4dc6a3-a3cb-43d3-aa51-20234d07d01c.png)'
- en: 'This can also be written as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这也可以写成如下形式：
- en: '![](img/ee572d5a-5e62-46f1-8022-9a8b29b23c20.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ee572d5a-5e62-46f1-8022-9a8b29b23c20.png)'
- en: In the preceding function, the following applies: [![](img/b1dc159f-9f35-487d-9c90-6d8a4b351e44.png)],
    and ![](img/17457674-cd90-4a0a-8e80-fa5b0ac06bea.png) is in the subinterval [![](img/642b9214-4c5d-4791-a9b9-a4840a37f971.png)].
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的函数中，以下适用：[![](img/b1dc159f-9f35-487d-9c90-6d8a4b351e44.png)]，且 ![](img/17457674-cd90-4a0a-8e80-fa5b0ac06bea.png)
    位于子区间 [![](img/642b9214-4c5d-4791-a9b9-a4840a37f971.png)] 中。
- en: 'The function looks like this:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数看起来像这样：
- en: '![](img/d68f33bd-9e7d-4ca3-beae-281243535f89.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d68f33bd-9e7d-4ca3-beae-281243535f89.png)'
- en: 'The integral gives us an approximation of the area under the curve such that
    for some, ε > 0 (ε is assumed to be a small value), the following formula applies:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 积分给我们提供了一个关于曲线下方面积的近似值，以至于对于某些 ε > 0（ε 假定为一个很小的值），适用以下公式：
- en: '![](img/76c13e50-7190-4a54-910c-3c77e438e6ea.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](img/76c13e50-7190-4a54-910c-3c77e438e6ea.png)'
- en: 'Now, let''s suppose our function lies both above and below the *x* axis, thus
    taking on positive and negative values, like so:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们的函数既在 *x* 轴上方也在 *x* 轴下方，因此它既有正值也有负值，如下所示：
- en: '![](img/31767c94-5e84-48a4-9460-17f2cdde39ca.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](img/31767c94-5e84-48a4-9460-17f2cdde39ca.png)'
- en: 'As we can see from the preceding screenshot, the portions above the *x* axis
    (*A[1]*) have a positive area, and the portions below the *x* axis (*A[2]*) have
    a negative area. Therefore, the following formula applies:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们从前面的截图中看到的，*x* 轴上方的部分 (*A[1]*) 具有正面积，而* x* 轴下方的部分 (*A[2]*) 具有负面积。因此，以下公式适用：
- en: '![](img/6f180dcc-26b4-4780-9dd7-dc9668edd17a.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6f180dcc-26b4-4780-9dd7-dc9668edd17a.png)'
- en: 'Working with sums is an important part of evaluating integrals, and understanding
    this requires some new rules for sums. Look at the following examples:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 与和的运算是评估积分的重要部分，理解这一点需要一些新的和的规则。看下面的例子：
- en: '[![](img/3e84708c-5e54-457e-b11a-8f4f9af5d0fd.png)]'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[![](img/3e84708c-5e54-457e-b11a-8f4f9af5d0fd.png)]'
- en: '[![](img/4b45c9f0-619b-4842-8f93-bbeadce8a681.png)]'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[![](img/4b45c9f0-619b-4842-8f93-bbeadce8a681.png)]'
- en: '[![](img/b45cc14c-4dac-4ab0-a87f-3213941cfa93.png)]'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[![](img/b45cc14c-4dac-4ab0-a87f-3213941cfa93.png)]'
- en: '[![](img/215c696d-38af-471b-bca8-6872bac94ebd.png)]'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[![](img/215c696d-38af-471b-bca8-6872bac94ebd.png)]'
- en: '[![](img/633a79aa-35bf-4eea-9d6d-b83b2e105e4f.png)]'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[![](img/633a79aa-35bf-4eea-9d6d-b83b2e105e4f.png)]'
- en: '[![](img/f8b5c7a0-95bb-4a78-99d4-18d5a4d16cdd.png)]'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[![](img/f8b5c7a0-95bb-4a78-99d4-18d5a4d16cdd.png)]'
- en: '[![](img/401fb9fc-bae0-447c-a699-80998c30a06e.png)]'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[![](img/401fb9fc-bae0-447c-a699-80998c30a06e.png)]'
- en: 'Now, let''s explore some of the important properties of integrals, which will
    help us as we go deeper into the chapter. Look at the following examples:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们探讨积分的一些重要属性，这将帮助我们在深入本章时更好理解。看下面的例子：
- en: '[![](img/9c0d1263-8db3-446a-bf81-5af06a246904.png)]'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[![](img/9c0d1263-8db3-446a-bf81-5af06a246904.png)]'
- en: '![](img/d5b3a394-1c0a-46d0-9b82-fac1f45547ce.png), when [![](img/9fe44f8b-e606-4190-9cfa-fc50eee21ac3.png)]'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![](img/d5b3a394-1c0a-46d0-9b82-fac1f45547ce.png)，当 [![](img/9fe44f8b-e606-4190-9cfa-fc50eee21ac3.png)]'
- en: '[![](img/6ee6c8b1-4c72-4d24-8d27-e2cfae17d8e7.png)], where *c* is a constant'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[![](img/6ee6c8b1-4c72-4d24-8d27-e2cfae17d8e7.png)]，其中 *c* 是常数'
- en: '[![](img/da5d0899-abdb-4b30-84f4-a40851b8965f.png)]'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[![](img/da5d0899-abdb-4b30-84f4-a40851b8965f.png)]'
- en: '[![](img/b167d886-a9bd-4f27-b3e5-e65c8096d262.png)]'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[![](img/b167d886-a9bd-4f27-b3e5-e65c8096d262.png)]'
- en: '[![](img/a3752f24-4fa4-4852-b92f-d2c3afd12d50.png)]'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[![](img/a3752f24-4fa4-4852-b92f-d2c3afd12d50.png)]'
- en: 'Now, suppose we have the function [![](img/606575fe-4ab6-4e57-82c3-76a87f7fe184.png)],
    which looks like this:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们有一个函数 [![](img/606575fe-4ab6-4e57-82c3-76a87f7fe184.png)]，它看起来是这样的：
- en: '![](img/0fbf3c73-00a3-494b-bf14-dc09907579df.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0fbf3c73-00a3-494b-bf14-dc09907579df.png)'
- en: 'Then, we get the following property:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们得到以下性质：
- en: '![](img/e734a2be-251f-4190-8a3d-775cc1d80941.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e734a2be-251f-4190-8a3d-775cc1d80941.png)'
- en: This property only works for functions that are continuous and have adjacent
    intervals.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这个性质只适用于连续且具有相邻区间的函数。
- en: The fundamental theorem of calculus
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微积分基本定理
- en: The fundamental theorem of calculus is the most important theorem in calculus
    and is named very appropriately since it establishes a relationship between differential
    calculus and integral calculus. Let's see how.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 微积分基本定理是微积分中最重要的定理，名字也非常恰当，因为它建立了微分学和积分学之间的关系。我们来看看是如何做到的。
- en: 'Suppose that *f(x)* is continuous on [*a, b*] and differentiable at (*a, b*),
    and that *F(x)* is the antiderivative of *f(x)*. Then, we have the following:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 *f(x)* 在 [*a, b*] 上是连续的，并且在 (*a, b*) 内可导，且 *F(x)* 是 *f(x)* 的原函数。那么，我们得到以下结果：
- en: '![](img/a6711a17-581a-4a77-ada8-3f44f91423fc.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a6711a17-581a-4a77-ada8-3f44f91423fc.png)'
- en: 'Let''s rewrite the preceding equation a bit so it becomes this equation:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们稍微重写一下前面的方程，使它变成以下形式：
- en: '![](img/5e704612-aa00-44c4-84a9-17c644d2ed64.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5e704612-aa00-44c4-84a9-17c644d2ed64.png)'
- en: 'All we have done here is replace *x* with *t* and *b* with *x*. And we know
    that *F(x)-F(a)* is also a function. From this, we can derive the following property:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的只是将 *x* 替换为 *t*，并将 *b* 替换为 *x*。而且我们知道 *F(x)-F(a)* 也是一个函数。由此，我们可以推导出以下性质：
- en: '![](img/d357ce0d-925c-4388-80c6-9ac8bbb38341.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d357ce0d-925c-4388-80c6-9ac8bbb38341.png)'
- en: We can derive the preceding property since *F(a)* is a constant and thus has
    the derivative zero.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以推导出前面的性质，因为 *F(a)* 是常数，因此它的导数为零。
- en: 'By shifting our point of view a bit, we get the following function:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 通过稍微改变我们的视角，我们得到以下函数：
- en: '![](img/469c5399-2588-4c5d-805e-5e480168fe10.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](img/469c5399-2588-4c5d-805e-5e480168fe10.png)'
- en: Therefore, we get ![](img/d74d4c9a-2d0b-4c93-b890-b9e9bd4007cd.png).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们得到 ![](img/d74d4c9a-2d0b-4c93-b890-b9e9bd4007cd.png)。
- en: In summary, if we integrate our function *f* and then differentiate it, we end
    up with the original function *f*.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，如果我们对函数 *f* 进行积分，然后再对其求导，我们最终会得到原函数 *f*。
- en: Substitution rule
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代换法则
- en: 'Obviously, being able to find the antiderivative of a function is important,
    but the anti-differentiation formulas do not tell us how to evaluate every type
    of integral—for example, what to do when we have functions such as the following
    one:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，能够找到一个函数的原函数是非常重要的，但反积分公式并没有告诉我们如何计算每种类型的积分——例如，当我们遇到如下的函数时该如何处理：
- en: '![](img/482474f9-c0c3-4c3e-a415-e46d0fac49b2.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](img/482474f9-c0c3-4c3e-a415-e46d0fac49b2.png)'
- en: This isn't as straightforward as the examples we saw earlier. In this case,
    we need to introduce a new variable to help us out and make the problem more manageable.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不像我们之前看到的例子那么简单。在这种情况下，我们需要引入一个新的变量来帮助我们，使问题变得更加可管理。
- en: 'Let''s make our new variable *u*, and ![](img/19f8ee20-b90e-4fd6-8f10-e8cb83d42de4.png),
    and the differential of *u* is then ![](img/e6006c36-cbdf-4c48-abd6-1774b725a865.png).
    This changes the problem into the following:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们设定一个新的变量 *u*，并且 ![](img/19f8ee20-b90e-4fd6-8f10-e8cb83d42de4.png)，那么 *u*
    的微分就是 ![](img/e6006c36-cbdf-4c48-abd6-1774b725a865.png)。这将问题转化为以下形式：
- en: '![](img/388f09d4-e250-4305-93f8-23cc5c3e9ac5.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](img/388f09d4-e250-4305-93f8-23cc5c3e9ac5.png)'
- en: 'This is clearly a lot simpler. The antiderivative of this becomes the following:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这显然要简单得多。它的原函数变为以下形式：
- en: '![](img/2a27ca99-9c6e-46a8-9f81-88c90fe53fcd.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2a27ca99-9c6e-46a8-9f81-88c90fe53fcd.png)'
- en: 'And by plugging in the original value ![](img/88197e12-4ec6-4db2-8782-5942162d3233.png),
    we get the following:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，代入原始值 ![](img/88197e12-4ec6-4db2-8782-5942162d3233.png)，我们得到以下结果：
- en: '![](img/1157bd53-54d2-4bac-a00b-54575380879b.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1157bd53-54d2-4bac-a00b-54575380879b.png)'
- en: And there we have it.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。
- en: 'This method is very useful, and works when we have problems that can be written
    in the following form:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法非常有用，当我们遇到以下形式的问题时，它是有效的：
- en: '![](img/76b23ba9-216c-4318-8699-4b812d91d773.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![](img/76b23ba9-216c-4318-8699-4b812d91d773.png)'
- en: 'If [![](img/ed09ae3b-2eb7-4d42-816b-851c2cf4cba8.png)], then the following
    applies:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 [![](img/ed09ae3b-2eb7-4d42-816b-851c2cf4cba8.png)]，那么以下公式适用：
- en: '![](img/91b4ed55-cb15-4367-8a72-e33acc5b266c.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![](img/91b4ed55-cb15-4367-8a72-e33acc5b266c.png)'
- en: That equation might be looking somewhat similar to you. And it should. It is
    the chain rule from differentiation.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 那个方程可能看起来对你来说有些相似。它应该是的。这是微分法中的链式法则。
- en: Areas between curves
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 曲线之间的面积
- en: 'We know that integration gives us the ability to find the area underneath a
    curve between two points. But now, suppose we want to find the area that lies
    between two graphs, as in the following screenshot:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道，积分让我们能够找到两点之间曲线下方的面积。但现在，假设我们想找到两个图形之间的面积，如下图所示：
- en: '![](img/823a8488-5a2d-45ce-93ea-3c2341ae7f3f.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![](img/823a8488-5a2d-45ce-93ea-3c2341ae7f3f.png)'
- en: 'Our region *S*, as we can see, lies between the curves *f(x)* and *g(x)* in
    between the two vertical lines *x = a* and *x = b*. Therefore, we can take an
    approximation of the area between the curves to be the following:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的区域*S*，如图所示，位于曲线*f(x)*和*g(x)*之间，夹在两条竖直线*x = a*和*x = b*之间。因此，我们可以将曲线之间的面积近似为以下公式：
- en: '![](img/faaa6614-1128-4790-ae3e-89e5f53ee617.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![](img/faaa6614-1128-4790-ae3e-89e5f53ee617.png)'
- en: 'We can rewrite this as an integral, in the following form:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将其重写为如下积分形式：
- en: '![](img/29533d2e-fb17-493e-b8c1-c20174201a75.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![](img/29533d2e-fb17-493e-b8c1-c20174201a75.png)'
- en: 'To visualize this better and create an intuition of what is happening, we have
    the following image:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地可视化并形成直觉，我们有以下图像：
- en: '![](img/dea92838-066b-4ec4-be9f-1ed245297494.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dea92838-066b-4ec4-be9f-1ed245297494.png)'
- en: Integration by parts
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分部积分法
- en: By now, we know that for every rule in differentiation, there is a corresponding
    rule in integration since they have an inverse relationship.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们知道每一个微分法则都有对应的积分法则，因为它们之间存在反向关系。
- en: In the earlier section on differentiation, we encountered the product rule.
    In integration, the corresponding rule is known as integration by parts.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的微分部分，我们遇到了乘积法则。在积分中，对应的法则称为分部积分法。
- en: 'As a recap, the product rule states that if *f* and *g* are differentiable,
    then the following applies:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾一下，乘积法则表明，如果*f*和*g*是可微的，则以下公式适用：
- en: '![](img/c88be3f5-0b11-41ea-b631-9ca184eb0761.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c88be3f5-0b11-41ea-b631-9ca184eb0761.png)'
- en: 'And so, in integration, this becomes the following:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在积分时，这变成了以下形式：
- en: '![](img/f981a162-de56-414f-b4d6-197d3cb77b84.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f981a162-de56-414f-b4d6-197d3cb77b84.png)'
- en: 'We can rewrite this, as follows:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按如下方式重写这个公式：
- en: '![](img/81725a0d-9c73-4247-877d-7916f0731a05.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![](img/81725a0d-9c73-4247-877d-7916f0731a05.png)'
- en: 'We can combine this formula with the fundamental theorem of calculus and obtain
    the following equation:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这个公式与微积分基本定理结合，得到以下方程：
- en: '![](img/cd0eb6dd-8f53-4fea-b151-6ab66c34f745.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cd0eb6dd-8f53-4fea-b151-6ab66c34f745.png)'
- en: We can use this to evaluate the integral between the interval [*a, b*].
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用这一点来计算区间[*a, b*]之间的积分。
- en: '**Note**: The term [![](img/31029f3c-de81-4781-aee8-1cf85f090b40.png) ]merely
    states that we plug in the value *b* in place of *x* and evaluate it, and then
    subtract it from the evaluation at *a*.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：术语 [![](img/31029f3c-de81-4781-aee8-1cf85f090b40.png) ]仅表示我们将值*b*代入*x*并进行计算，然后从*a*的计算结果中减去它。'
- en: 'We can also use the preceding substitution method for integration by parts
    to make our lives easier when calculating the integral. We make [![](img/18be32d3-4434-4982-8ab6-36ba3548e529.png)] and [![](img/58b26dd3-447c-4ebe-b314-0fe72c383978.png)];
    then, the differentials are [![](img/ec51ec39-f497-4131-91a3-0fb26c3a8bfc.png)] and [![](img/1a940e5f-2e1e-44a9-80ee-e9e283f66b7c.png)].
    And so, the formula becomes this:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用之前的替代法来简化分部积分法中的积分计算。我们进行 [![](img/18be32d3-4434-4982-8ab6-36ba3548e529.png)] 和 [![](img/58b26dd3-447c-4ebe-b314-0fe72c383978.png)]，然后，微分是 [![](img/ec51ec39-f497-4131-91a3-0fb26c3a8bfc.png)] 和 [![](img/1a940e5f-2e1e-44a9-80ee-e9e283f66b7c.png)]。于是，公式变为：
- en: '![](img/3ceb179d-9272-41d8-807e-215833675629.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3ceb179d-9272-41d8-807e-215833675629.png)'
- en: Multivariable calculus
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多变量微积分
- en: Now that we have gone through single variable calculus and understand what calculus
    is about, it is time for us to go a step deeper and look at multivariable calculus.
    Multivariable calculus has a lot of similarities with single variable calculus,
    except—as the name suggests—here, we will be dealing with functions that accept
    two or more variables as input.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经学习了单变量微积分并理解了微积分的基本概念，是时候深入一点，看看多变量微积分了。多变量微积分与单变量微积分有许多相似之处，唯一的区别是——正如其名字所示——在这里，我们将处理接受两个或更多变量作为输入的函数。
- en: Multivariable calculus is used everywhere in the real world and has applications
    in every field and industry, from healthcare to economics, to finance, to robotics,
    to aerospace, and so on. An example of this could be trying to model how air curves
    around an airplane, to understand how aerodynamic it is and where the design of
    the airplane body can be improved. This is something we would not be able to do
    with single variable calculus.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 多元微积分在现实世界中被广泛应用，几乎所有领域和行业都有涉及，从医疗保健到经济学，再到金融、机器人学、航空航天等等。一个例子是，尝试模拟空气如何绕过飞机，以了解飞机的空气动力学性能以及飞机机身设计在哪些方面可以改进。这是我们在单变量微积分中无法做到的。
- en: Partial derivatives
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 偏导数
- en: A partial derivative is a method we use to find the derivative of a function
    that depends on more than one variable, with respect to one of its variables,
    while keeping the others constant. This allows us to understand how a function
    is affected by a single variable instead of by all of them. Suppose we are modeling
    the price of a stock item, and the price depends on a number of different factors.
    We can vary one variable at a time to determine how much this change will affect
    the price of the stock item. This is different from taking a total derivative,
    where all the variables vary.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 偏导数是我们用来求解依赖于多个变量的函数的导数的方法，这个导数是关于其中一个变量的偏导数，同时保持其他变量不变。通过这种方法，我们可以了解一个函数是如何受单一变量影响的，而不是所有变量的影响。假设我们在建模某个商品的价格，并且该价格依赖于多个不同的因素。我们可以逐个改变每个变量，来确定这种变化会如何影响商品的价格。这与求总导数不同，总导数是所有变量都变化时的导数。
- en: 'A multivariate function can have as many variables as you would look like,
    but to keep things simple, we will look at a function with two variables, as follows:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 多元函数可以包含任意多个变量，但为了简化问题，我们将以一个包含两个变量的函数为例，如下所示：
- en: '![](img/49317bbb-48f4-47d2-89f3-c8d8be7d3591.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![](img/49317bbb-48f4-47d2-89f3-c8d8be7d3591.png)'
- en: This function looks a lot more complicated than the ones we have previously
    dealt with. Let's break it down. When we take the partial derivative of a function
    with respect to *x*, we find the rate of change of *z* as *x* varies, while keeping
    *y* constant. The same applies when we differentiate with respect to any other
    variable.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数看起来比我们之前处理的要复杂得多。让我们分解一下。当我们对一个函数关于 *x* 求偏导数时，我们得到的是 *z* 随着 *x* 变化的变化率，同时保持
    *y* 不变。对其他变量求导时也是如此。
- en: Let's visually imagine the *xy*-plane (a flat surface) as being the set of acceptable
    points that can be used as input to our function. The output, *z*, can be thought
    of as how much we are elevated (or the height) from the *xy*-plane.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们直观地想象 *xy* 平面（一个平面）作为可接受的输入点集。这些点可以作为我们函数的输入。输出 *z* 可以理解为我们距离 *xy* 平面的高度。
- en: 'Let''s start by first differentiating the function with respect to ![](img/0b2dac96-00d5-4af1-87b9-d4a54051ecba.png),
    as follows:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先对函数关于 ![](img/0b2dac96-00d5-4af1-87b9-d4a54051ecba.png) 求导，如下所示：
- en: '![](img/0f8712f5-2b14-4290-a5c8-baac7fcec4d7.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0f8712f5-2b14-4290-a5c8-baac7fcec4d7.png)'
- en: 'This gives us the following:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们带来了以下结果：
- en: '![](img/04024c91-c5ae-4c9a-9fbf-02b9d01e66ad.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![](img/04024c91-c5ae-4c9a-9fbf-02b9d01e66ad.png)'
- en: 'Now, we will differentiate with respect to *y*, as follows:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将对 *y* 进行求导，如下所示：
- en: '![](img/fbd57942-7492-4165-8e3e-f3b179a10a45.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fbd57942-7492-4165-8e3e-f3b179a10a45.png)'
- en: 'This gives us the following:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们带来了以下结果：
- en: '![](img/3501ca6d-2b68-4800-a026-353cb16c51b7.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3501ca6d-2b68-4800-a026-353cb16c51b7.png)'
- en: 'As we saw earlier, in single variable differentiation, we can take second derivatives
    of functions (within reason, of course), but in multivariable calculus, we can
    also take mixed partial derivatives, as illustrated here:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所见，在单变量微分中，我们可以对函数求二阶导数（当然是合理的情况下），但在多元微积分中，我们还可以进行混合偏导数的求解，如下所示：
- en: '![](img/655b50f4-ea62-490e-9788-c5dad3ab8f08.png)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![](img/655b50f4-ea62-490e-9788-c5dad3ab8f08.png)'
- en: You may have noticed that when we take a mixed partial derivative, the order
    of the variables does not matter, and we get the same result whether we first
    differentiate with respect to *x* and then with respect to *y*, or vice versa.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，当我们进行混合偏导数时，变量的顺序并不重要，无论我们是先对 *x* 求导，再对 *y* 求导，还是反过来，结果都是相同的。
- en: 'We can also write this in another form that is often more convenient, and this
    is what we will be using in this book, going forward. The function is illustrated
    here:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以以另一种形式来写这个表达式，这种形式通常更为方便，并且我们将在本书中继续使用这种方式。函数如下所示：
- en: '![](img/685ffa19-a0fd-4d99-ba56-8fbe912ad858.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![](img/685ffa19-a0fd-4d99-ba56-8fbe912ad858.png)'
- en: Chain rule
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链式法则
- en: 'Let''s take an arbitrary function *f* that takes variables *x* and *y* as input,
    and there is some change in either variable so that [![](img/ca1ff359-479b-4057-90c8-a882ece7af6a.png)].
    Using this, we can find the change in *f* using the following:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们取一个任意的函数 *f*，它以变量 *x* 和 *y* 为输入，并且某一个变量发生变化，从而得到[![](img/ca1ff359-479b-4057-90c8-a882ece7af6a.png)]。利用这一点，我们可以通过以下方式找到
    *f* 的变化：
- en: '![](img/b77f4dbf-7a64-4ed0-b736-45daeeff4a34.png)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b77f4dbf-7a64-4ed0-b736-45daeeff4a34.png)'
- en: 'This leads us to the following equation:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这将我们带入如下方程：
- en: '![](img/85c8797e-e2af-4dbf-9621-fd060d37d0c3.png)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![](img/85c8797e-e2af-4dbf-9621-fd060d37d0c3.png)'
- en: Then, by taking the limit of the function as [![](img/91e4e54f-ec5a-4655-83d2-35d5ed41a518.png)],
    we can derive the chain rule for partial derivatives.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过取函数的极限[![](img/91e4e54f-ec5a-4655-83d2-35d5ed41a518.png)]，我们可以推导出偏导数的链式法则。
- en: 'We express this as follows:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将其表示如下：
- en: '![](img/b0459ebf-42e3-4555-ab42-fd7aae96b3ed.png)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b0459ebf-42e3-4555-ab42-fd7aae96b3ed.png)'
- en: 'We now divide this equation by an additional small quantity (*t*) on which
    *x* and *y* are dependent, to find the gradient along [![](img/2c7e949d-030d-4521-9171-1d7279d7482e.png)].
    The preceding equation then becomes this one:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在通过一个额外的小量（*t*），其中 *x* 和 *y* 依赖于 *t*，来除以这个方程，以找到沿[![](img/2c7e949d-030d-4521-9171-1d7279d7482e.png)]的梯度。前面的方程变为如下：
- en: '![](img/866e0098-a54a-4cef-bc69-bf8d0e0e19bf.png)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![](img/866e0098-a54a-4cef-bc69-bf8d0e0e19bf.png)'
- en: The differentiation rules that we came across earlier still apply here and can
    be extended to the multivariable case.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前遇到的微分规则在这里仍然适用，并且可以扩展到多变量的情况。
- en: Integrals
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 积分
- en: 'As in the single variable case, we have antiderivatives and integrals for functions
    that depend on multiple variables as well. Earlier, we learned that an integral
    gives us the area under a curve [![](img/7acd24aa-85a0-44b8-9bda-f3aa4a16e818.png)] between
    an interval [*a, b*]. Now, instead of finding the area over an interval, we will
    be finding the volume under the graph [![](img/b95a54d1-f946-45ab-b528-284f70f82050.png)] over
    a region. The equation looks like this:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 和单变量情况一样，对于依赖多个变量的函数，我们也有反导数和积分。之前我们学到，积分给出了曲线[![](img/7acd24aa-85a0-44b8-9bda-f3aa4a16e818.png)]下的面积，位于区间[*a,
    b*]之间。现在，我们不再寻找区间上的面积，而是寻找图形[![](img/b95a54d1-f946-45ab-b528-284f70f82050.png)]下的体积，位于某个区域内。方程如下：
- en: '![](img/540405b4-b445-4ccf-9ac9-c04d3b348304.png)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![](img/540405b4-b445-4ccf-9ac9-c04d3b348304.png)'
- en: 'In the preceding equation, *R* is a region in the *xy*-plane. Think of *R* as
    being cut into multiple small rectangular regions, denoted Δ*A.* Then, we can
    approximate the volume as follows:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的方程中，*R* 是 *xy* 平面上的一个区域。可以将 *R* 看作被切割成多个小矩形区域，记为 Δ*A*。然后，我们可以按如下方式近似体积：
- en: '![](img/dc69db3c-edf2-47e2-885d-ec0b44dd7ecd.png)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dc69db3c-edf2-47e2-885d-ec0b44dd7ecd.png)'
- en: Additionally, [![](img/1d593af0-f0af-4c55-93de-f0a25bf3ce1e.png);] thus, [![](img/8821d935-1ebd-454f-9c25-89be013cc69b.png)].
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，[![](img/1d593af0-f0af-4c55-93de-f0a25bf3ce1e.png);]因此，[![](img/8821d935-1ebd-454f-9c25-89be013cc69b.png)]。
- en: '**Note**: A double integral is not the same as taking an integral twice.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：双重积分并不等同于对积分进行两次计算。'
- en: Now, instead of calculating over small rectangular regions, let's divide the
    region into long, thin slices of a fixed width Δ*x*. Sound familiar? It should,
    as this is very similar to what we did earlier in single variable integration.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们不再计算小矩形区域，而是将区域划分为宽度为 Δ*x* 的长且薄的切片。听起来熟悉吗？它应该很熟悉，因为这和我们在单变量积分中做的非常相似。
- en: 'Let''s assign [![](img/1f2a4e61-beb2-4c8b-b219-2ec8d4d46c37.png)], and now,
    our integral takes the following form:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们分配[![](img/1f2a4e61-beb2-4c8b-b219-2ec8d4d46c37.png)]，于是我们的积分变成了如下形式：
- en: '![](img/ad381372-6c96-4d98-ba5a-b0ec5d05a8d5.png)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ad381372-6c96-4d98-ba5a-b0ec5d05a8d5.png)'
- en: We then multiply the result by Δ*x*.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将结果乘以 Δ*x*。
- en: 'We can now rewrite the integral, as follows:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将积分重写为如下形式：
- en: '![](img/c7688812-32f9-45d9-be9c-ad07a8d3507e.png)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c7688812-32f9-45d9-be9c-ad07a8d3507e.png)'
- en: Here, [![](img/059c7dc0-8dda-4ea5-98cf-fad68596779d.png)] and [![](img/348bd2bf-f7ec-4cf6-a671-d76f137d3cb7.png)].
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，[![](img/059c7dc0-8dda-4ea5-98cf-fad68596779d.png)] 和 [![](img/348bd2bf-f7ec-4cf6-a671-d76f137d3cb7.png)]。
- en: 'Suppose that we have the function [![](img/c61f3181-8c5e-4e0a-8d57-9bbcda8df208.png)] and
    the boundaries of the region are defined over [![](img/45cd31fb-bb39-48cc-af21-198902cc6188.png)] and [![](img/273110de-82bf-401e-a318-60fa2c14723d.png)].
    Then, the integral is as follows:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个函数[![](img/c61f3181-8c5e-4e0a-8d57-9bbcda8df208.png)]，并且区域的边界定义在[![](img/45cd31fb-bb39-48cc-af21-198902cc6188.png)]和[![](img/273110de-82bf-401e-a318-60fa2c14723d.png)]上。那么，积分为：
- en: '![](img/9922169b-a119-4039-852d-4da4e59c96c7.png)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9922169b-a119-4039-852d-4da4e59c96c7.png)'
- en: 'And by evaluating the inner integral, we get the following:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 通过计算内积分，我们得到如下结果：
- en: '![](img/17115c30-bb32-4e01-85fb-d4485bc65613.png)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![](img/17115c30-bb32-4e01-85fb-d4485bc65613.png)'
- en: 'And by evaluating the outer integral, we get the following:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 通过计算外部积分，我们得到如下结果：
- en: '![](img/60e815a1-85d4-4c46-962f-778e95704725.png)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![](img/60e815a1-85d4-4c46-962f-778e95704725.png)'
- en: And there you have it. That is how we find integrals of multivariable functions.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。这就是我们如何找到多变量函数的积分。
- en: 'Let''s now suppose that we have a function [![](img/b34be4a4-e527-4bbd-a05f-1b11575129d6.png)],
    and we evaluate the integral over the region where [![](img/059c7dc0-8dda-4ea5-98cf-fad68596779d.png)] and [![](img/348bd2bf-f7ec-4cf6-a671-d76f137d3cb7.png)].
    Then, we have the following:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设我们有一个函数 [![](img/b34be4a4-e527-4bbd-a05f-1b11575129d6.png)]，我们在区域内对其进行积分，其中 [![](img/059c7dc0-8dda-4ea5-98cf-fad68596779d.png)] 和 [![](img/348bd2bf-f7ec-4cf6-a671-d76f137d3cb7.png)]。然后，我们得到如下结果：
- en: '![](img/1889bd7c-a91e-4118-b998-bf7b2c3bd4b5.png)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1889bd7c-a91e-4118-b998-bf7b2c3bd4b5.png)'
- en: This is a direct result of the distributive law.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这是分配律的直接结果。
- en: The region we have been integrating over so far has been rectangular, but this
    most likely will not always be the case. If the region is an irregular shape,
    then the limits of integration will vary at each slice.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止所计算的区域是矩形的，但这不一定总是这样。如果区域是一个不规则的形状，那么每一片的积分限将会有所不同。
- en: The best way to deal with this is to write it as a function of the variable
    we are not integrating.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的最佳方法是将其写成我们没有进行积分的变量的函数。
- en: 'Let''s suppose that we have [![](img/a5bc1222-27e0-467f-9f15-c0b6fa8ba798.png)],
    and the set of points it exists on is [![](img/f8676e09-4660-4e3d-88ad-a8f35eb3e361.png)], which
    tells us [![](img/d34ce71b-fa77-4f08-9013-2f941f66d70a.png)] and [![](img/a573c00d-bdf8-4a3d-a686-109e19ffd7e7.png)].
    We can now write this in the following form:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有 [![](img/a5bc1222-27e0-467f-9f15-c0b6fa8ba798.png)]，且它存在的点集是 [![](img/f8676e09-4660-4e3d-88ad-a8f35eb3e361.png)]，这告诉我们 [![](img/d34ce71b-fa77-4f08-9013-2f941f66d70a.png)] 和 [![](img/a573c00d-bdf8-4a3d-a686-109e19ffd7e7.png)]。现在我们可以写成以下形式：
- en: '![](img/031bf82e-ac78-4220-8c64-3fef3dfa3fad.png)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![](img/031bf82e-ac78-4220-8c64-3fef3dfa3fad.png)'
- en: Here, as we can see, *x* is defined on the interval [*a, b*], and *y* exists
    between two functions of *x—**g(x)* and *h(x)*.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，*x* 定义在区间[*a, b*]上，*y* 介于两条* x*的函数之间——**g(x)** 和**h(x)**。
- en: We know from trigonometry, particularly the Pythagorean theorem, that the smallest
    value for *y* will be [![](img/53feae41-cc88-42b6-b143-635a407374af.png)]and the
    largest value will be [![](img/80008ff2-f60c-41ee-9122-1769fbe2d6f8.png)].
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道从三角学，特别是毕达哥拉斯定理，*y*的最小值将是 [![](img/53feae41-cc88-42b6-b143-635a407374af.png)]，最大值将是 [![](img/80008ff2-f60c-41ee-9122-1769fbe2d6f8.png)]。
- en: 'We can now proceed to rewrite the preceding set of points, as follows:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以继续重写前面的一组点，如下所示：
- en: '![](img/f3109bfc-d343-4a60-9d9c-9856c8c2291f.png)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f3109bfc-d343-4a60-9d9c-9856c8c2291f.png)'
- en: Changing it up and writing it this way slices the unit disk into vertical lines
    spaced apart by a fixed width.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这样写和改变写法，将单位圆盘切成了间隔固定宽度的竖直线。
- en: 'Then, our integral becomes this one:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们的积分变成了这样：
- en: '![](img/35f179f9-865d-45eb-8d0d-af813394bdf8.png)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![](img/35f179f9-865d-45eb-8d0d-af813394bdf8.png)'
- en: 'And because [![](img/1d8a39ee-0ac0-4f8e-a2c5-48575b4966cf.png)], we can rewrite
    the preceding integral, like so:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 [![](img/1d8a39ee-0ac0-4f8e-a2c5-48575b4966cf.png)]，我们可以像这样重写前面的积分：
- en: '![](img/e91a51cf-e4fe-4036-b05a-6088a9896e36.png)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e91a51cf-e4fe-4036-b05a-6088a9896e36.png)'
- en: 'We then proceed by evaluating the inner integral and then the outer integral,
    like so:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过计算内积分，再计算外积分，像这样继续：
- en: '![](img/3ad754b2-0a8d-4517-9644-bf842e7a1999.png)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3ad754b2-0a8d-4517-9644-bf842e7a1999.png)'
- en: We know this to be true from the area of a circle: [![](img/6077f9b6-feca-4d04-8f5d-f08c4b62ffdd.png)]
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从圆的面积中知道这是正确的： [![](img/6077f9b6-feca-4d04-8f5d-f08c4b62ffdd.png)]
- en: 'Some important properties for double integrals are shown in the following list:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 双重积分的一些重要性质如下所示：
- en: '[![](img/515db093-9981-42e4-8863-17a0b05a2d79.png)]'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[![](img/515db093-9981-42e4-8863-17a0b05a2d79.png)]'
- en: '[![](img/e783f387-7d27-42f0-864a-524e4afdee3a.png)] , where *c* is some constant'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[![](img/e783f387-7d27-42f0-864a-524e4afdee3a.png)]，其中*c*是一个常数'
- en: '[![](img/585a4b82-4409-491c-a8cc-6441d0017c09.png)] if the *R* can be split
    into two regions, *R[1]* and *R[2]*'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[![](img/585a4b82-4409-491c-a8cc-6441d0017c09.png)] 如果*R*可以分成两个区域，*R[1]* 和
    *R[2]*'
- en: '[![](img/e7c38ee1-ec4e-4b44-906b-bca50be88855.png)] when [![](img/182bc4ca-1bfd-467b-95be-8418aaf9765d.png)] for
    all [![](img/2650d259-2e72-4cb3-9b93-80720c70099e.png)]'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[![](img/e7c38ee1-ec4e-4b44-906b-bca50be88855.png)] 当 [![](img/182bc4ca-1bfd-467b-95be-8418aaf9765d.png)] 对于所有 [![](img/2650d259-2e72-4cb3-9b93-80720c70099e.png)] 成立'
- en: 'Let''s now suppose we have a cylinder with a spherical top, as in the following
    diagram, and we want to find its volume. The region under the sphere is [![](img/bff95499-a648-44c6-a736-36e07ce66d84.png)] and
    inside the cylinder [![](img/6a5fac7f-a81c-420a-98ff-757aa5f503c4.png)] and above
    *z = 0*, as follows:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们有一个带有球形顶部的圆柱体，如下图所示，我们想要求它的体积。球体下方的区域是[![](img/bff95499-a648-44c6-a736-36e07ce66d84.png)]，圆柱体内部是[![](img/6a5fac7f-a81c-420a-98ff-757aa5f503c4.png)]，并且在*z
    = 0*之上，如下所示：
- en: '![](img/e2000541-b7aa-4343-acc7-5c4276b28fad.png)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e2000541-b7aa-4343-acc7-5c4276b28fad.png)'
- en: 'We know that we find the volume of a region as follows:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道，求一个区域的体积的方法如下：
- en: '![](img/18738304-ab2a-4a7f-9668-f5cbeeeaa0f3.png)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![](img/18738304-ab2a-4a7f-9668-f5cbeeeaa0f3.png)'
- en: To evaluate this integral, we start by rewriting the equation of the sphere
    into [![](img/6f2b4703-ca8a-4f9a-9512-3e345313b518.png)], and the set of points
    where *x* and *y* are defined is [![](img/3980fe21-c852-4765-8fb6-9a36d3bdb1c8.png)].
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算这个积分，我们首先将球体的方程重写为[![](img/6f2b4703-ca8a-4f9a-9512-3e345313b518.png)]，并且*x*和*y*被定义的点集是[![](img/3980fe21-c852-4765-8fb6-9a36d3bdb1c8.png)]。
- en: 'We rewrite our points and define the limits of the region in terms of polar
    coordinates *θ* and the radius *r*, so that the equation looks like this:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我们重写我们的点，并用极坐标系中的*θ*和半径*r*来定义区域的边界，使得方程看起来如下：
- en: '![](img/918eabda-a108-417e-bd45-5076e30c61d2.png) and ![](img/8a539c2d-00c4-4a1e-855d-84060779733f.png)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![](img/918eabda-a108-417e-bd45-5076e30c61d2.png)和![](img/8a539c2d-00c4-4a1e-855d-84060779733f.png)'
- en: 'We can now rewrite *z*, as follows:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以重写*z*，如下所示：
- en: '![](img/b159ca1b-4e61-4b5f-9c49-219ba148608f.png)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b159ca1b-4e61-4b5f-9c49-219ba148608f.png)'
- en: 'So, the volume is as follows:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，体积如下所示：
- en: '![](img/684ef696-1257-424e-8218-3b95076d6d98.png)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
  zh: '![](img/684ef696-1257-424e-8218-3b95076d6d98.png)'
- en: 'And by evaluating the inner and outer integrals, we get the following:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 通过计算内外积分，我们得到以下结果：
- en: '![](img/8f3b3e61-d4c0-42c4-8e4f-25a9bdac6c97.png)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8f3b3e61-d4c0-42c4-8e4f-25a9bdac6c97.png)'
- en: 'We now know how to integrate our regions in ![](img/be1a346a-3930-4601-831f-2b50356df49d.png)and
    find the volume under the graph. But what about when we have regions in ![](img/d3408957-b006-4916-b42b-a1556c39659d.png)?
    Earlier, we used a double integral for two-dimensional regions; so, naturally,
    for a three-dimensional region, we will use three integrals. We write this as
    follows:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在知道如何在![](img/be1a346a-3930-4601-831f-2b50356df49d.png)中对区域进行积分并找到图形下的体积。但是当我们有![](img/d3408957-b006-4916-b42b-a1556c39659d.png)中的区域时怎么办呢？之前我们对二维区域使用了二重积分；所以，自然，对于三维区域，我们将使用三重积分。我们将其写成如下：
- en: '![](img/6643df1f-06f4-46f8-a9ee-6069c228ee26.png)'
  id: totrans-317
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6643df1f-06f4-46f8-a9ee-6069c228ee26.png)'
- en: 'Suppose now that the region we integrate over is defined by [![](img/e1e098bc-f518-4914-b23c-bfab40a61306.png)], [![](img/df14700a-c47b-4095-b4ee-e542809f2827.png)] and [![](img/2e3cc4b1-ff69-4b8c-8aab-7a7f138877e8.png)].
    The triple integral then becomes the following:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 假设现在我们积分的区域由[![](img/e1e098bc-f518-4914-b23c-bfab40a61306.png)]、[![](img/df14700a-c47b-4095-b4ee-e542809f2827.png)]和[![](img/2e3cc4b1-ff69-4b8c-8aab-7a7f138877e8.png)]定义。三重积分变成如下：
- en: '![](img/d74823b3-0240-49f9-8da5-9615d786ab8c.png)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d74823b3-0240-49f9-8da5-9615d786ab8c.png)'
- en: Earlier on, we came across something called substitution, where we made our
    function equal to a variable to make it easier for us to find the derivative.
    We can also do the same in integration.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 之前我们遇到了一种叫做替换的方法，我们将我们的函数设为一个变量，这样就更容易找到导数。我们在积分中也可以做同样的事情。
- en: 'Suppose we have the following integral:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有以下积分：
- en: '![](img/85a603b4-17c1-4b2b-8a6a-2d88a366688f.png)'
  id: totrans-322
  prefs: []
  type: TYPE_IMG
  zh: '![](img/85a603b4-17c1-4b2b-8a6a-2d88a366688f.png)'
- en: 'We can make [![](img/3181bf85-00b1-4212-b19b-4cf253bf53ad.png)], and the integral
    then becomes this:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以设[![](img/3181bf85-00b1-4212-b19b-4cf253bf53ad.png)]，然后积分变成这样：
- en: '![](img/c181f01c-467b-4770-a84d-068f1cf34219.png)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c181f01c-467b-4770-a84d-068f1cf34219.png)'
- en: Now, let's move on to double integrals, and see how we can transform regions
    to make them easier for us to deal with. To do this, we will need to call on our
    old friend the Jacobian matrix for help.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续研究二重积分，看看如何转化区域以便我们更容易处理。为此，我们需要请出我们熟悉的老朋友——雅可比矩阵来帮忙。
- en: 'As a refresher, suppose we have [![](img/01875f3d-69c9-4580-8595-3a6a34b9f357.png)] and [![](img/9411aa5d-5a9e-4023-8e85-44abb622d1a6.png).] Then,
    the Jacobian matrix is as follows:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 作为复习，假设我们有[![](img/01875f3d-69c9-4580-8595-3a6a34b9f357.png)]和[![](img/9411aa5d-5a9e-4023-8e85-44abb622d1a6.png)]。然后，雅可比矩阵如下所示：
- en: '![](img/bcfc4f85-904a-43c4-9e5f-36f41780011f.png)'
  id: totrans-327
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bcfc4f85-904a-43c4-9e5f-36f41780011f.png)'
- en: 'Also, recall that the Jacobian matrix can also be thought of as the determinant.
    So, we can rewrite the preceding equation as follows:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请记住，雅可比矩阵也可以被视为行列式。因此，我们可以将前面的方程重写为：
- en: '![](img/158f1b30-ba6b-42f6-af29-0b600946443e.png)'
  id: totrans-329
  prefs: []
  type: TYPE_IMG
  zh: '![](img/158f1b30-ba6b-42f6-af29-0b600946443e.png)'
- en: 'Suppose now that we want to integrate [![](img/abb6174b-993e-4c49-8188-ed0c8d3547c8.png)] over
    *R*. Now, let''s make [![](img/01ad860b-f5c2-4c9d-8103-bb668d1bad2f.png)] and [![](img/1a2b5769-2606-4d8b-a88a-d9de179cbb77.png)],
    and rename our region as *S*. The integral now looks like this:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 假设现在我们想对[![](img/abb6174b-993e-4c49-8188-ed0c8d3547c8.png)]在 *R* 上进行积分。现在，让我们做出[![](img/01ad860b-f5c2-4c9d-8103-bb668d1bad2f.png)]和[![](img/1a2b5769-2606-4d8b-a88a-d9de179cbb77.png)]，并将我们的区域重新命名为
    *S*。积分现在看起来像这样：
- en: '![](img/5cfe91ee-3bab-4679-b065-2b49edc0ce38.png)'
  id: totrans-331
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5cfe91ee-3bab-4679-b065-2b49edc0ce38.png)'
- en: From this, we can easily observe that [![](img/fb76b78b-ec61-4c06-ba0b-e7da27b5cca5.png)].
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 从中我们可以很容易地观察到[![](img/fb76b78b-ec61-4c06-ba0b-e7da27b5cca5.png)]。
- en: 'Let''s move on to triple integrals now. Suppose we have a function [![](img/9a3f9cdb-f071-46bd-a95c-1d6635a619aa.png)] and
    we want to integrate it over *R*. We start by making [![](img/6a69125c-a4fa-4d35-8a1e-87945d9193e5.png)], [![](img/490c9f57-b1a9-4196-86d2-ffc3afa99bef.png)],
    and [![](img/e5c53871-9aab-4b25-a862-1098f1f868dd.png)], and as before, we rename
    the new region as *S*. The Jacobian matrix is then the following one:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们继续讲解三重积分。假设我们有一个函数[![](img/9a3f9cdb-f071-46bd-a95c-1d6635a619aa.png)]，并且我们想对其在
    *R* 上进行积分。我们首先做出[![](img/6a69125c-a4fa-4d35-8a1e-87945d9193e5.png)]，[![](img/490c9f57-b1a9-4196-86d2-ffc3afa99bef.png)]，和[![](img/e5c53871-9aab-4b25-a862-1098f1f868dd.png)]，并像之前一样将新区域重新命名为
    *S*。雅可比矩阵随后是以下形式：
- en: '![](img/54edd27c-3db3-427f-b140-3321e8e42cc0.png)'
  id: totrans-334
  prefs: []
  type: TYPE_IMG
  zh: '![](img/54edd27c-3db3-427f-b140-3321e8e42cc0.png)'
- en: 'The triple integral now looks like this:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 三重积分现在看起来像这样：
- en: '![](img/c715df27-41f9-45ca-a206-0bca0ac3fa5e.png)'
  id: totrans-336
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c715df27-41f9-45ca-a206-0bca0ac3fa5e.png)'
- en: We now have a good enough understanding of multivariable calculus and are ready
    to dive into the wonderful world of vector calculus.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经对多变量微积分有了足够的理解，准备深入探索向量微积分的精彩世界。
- en: Vector calculus
  id: totrans-338
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向量微积分
- en: When we find derivatives of functions with respect to vectors, we need to be
    a lot more diligent. And as we will see in [Chapter 2](6a34798f-db83-4a32-9222-06ba717fc809.xhtml),
    *Linear Algebra*, vectors and matrices are noncommutative and behave quite differently
    from scalars, and so we need to find a different way to differentiate them.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们对关于向量的函数求导时，我们需要更加细心。如我们在[第2章](6a34798f-db83-4a32-9222-06ba717fc809.xhtml)《线性代数》中看到的那样，向量和矩阵是不可交换的，并且与标量的行为大不相同，因此我们需要找到一种不同的方式来对它们进行微分。
- en: Derivatives
  id: totrans-340
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导数
- en: Earlier, we saw that functions are differentiated by using the limit of the
    variable in the quotient. But vectors, as we know, are not like scalars in that
    we cannot divide by vectors, which creates the need for new definitions for vector-valued
    functions.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们看到通过使用变量在商中的极限来对函数求导。但如我们所知，向量与标量不同，我们不能对向量进行除法运算，这就需要对向量值函数进行新的定义。
- en: 'We can define a vector function as a function ![](img/baaa0c31-2440-4d95-af1c-0dc465738402.png)—that
    is, it takes in a scalar value as input and outputs a vector. So, the derivative
    of *F* is defined as follows:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将向量函数定义为一个函数！[](img/baaa0c31-2440-4d95-af1c-0dc465738402.png)，也就是说，它接受一个标量值作为输入，并输出一个向量。因此，*F*
    的导数定义如下：
- en: '![](img/73f17a07-fd96-41ff-84e2-9a01df882f69.png)'
  id: totrans-343
  prefs: []
  type: TYPE_IMG
  zh: '![](img/73f17a07-fd96-41ff-84e2-9a01df882f69.png)'
- en: 'In the preceding equation, δ*x* is a small perturbation on *x*. Additionally,
    *F* is only differentiable if the following applies:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的方程中，δ*x* 是对 *x* 的小扰动。此外，*F* 只有在以下条件下才可微分：
- en: '![](img/28debd64-9863-4c3d-8cdc-3f641b306439.png)'
  id: totrans-345
  prefs: []
  type: TYPE_IMG
  zh: '![](img/28debd64-9863-4c3d-8cdc-3f641b306439.png)'
- en: 'We can also write the preceding differential as follows:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将前面的微分写成如下形式：
- en: '![](img/2dd006ae-a223-4d7c-b707-10af669d9952.png)'
  id: totrans-347
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2dd006ae-a223-4d7c-b707-10af669d9952.png)'
- en: 'Generally, we differentiate vectors component-wise, so, the preceding differential
    becomes this:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们按分量对向量进行微分，因此，前面的微分变为：
- en: '![](img/b619f706-e26f-4434-8d29-12113e2a71e9.png)'
  id: totrans-349
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b619f706-e26f-4434-8d29-12113e2a71e9.png)'
- en: Here *e[i]* is an orthonormal basis vector.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的 *e[i]* 是一个正交归一基向量。
- en: 'Some rules for vector differentiation are shown in the following list:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 一些向量微分的规则如下所示：
- en: '[![](img/7b3211b2-bf03-4c31-a867-f286fbe81e5e.png)]'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[![](img/7b3211b2-bf03-4c31-a867-f286fbe81e5e.png)]'
- en: '[![](img/8317c958-a8d9-45a6-87b3-19cf67f2ec7d.png)]'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[![](img/8317c958-a8d9-45a6-87b3-19cf67f2ec7d.png)]'
- en: '[![](img/a644d6c9-9dd5-4728-b88f-f5775d9762c7.png)]'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[![](img/a644d6c9-9dd5-4728-b88f-f5775d9762c7.png)]'
- en: '[![](img/3f6ac63f-a704-48b3-a3ed-47355555c91d.png)]'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[![](img/3f6ac63f-a704-48b3-a3ed-47355555c91d.png)]'
- en: '[![](img/0aabed2a-0d4d-49fb-ab54-83e738dbb91d.png)]'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[![](img/0aabed2a-0d4d-49fb-ab54-83e738dbb91d.png)]'
- en: '[![](img/ff7680ac-a53a-4d1f-8d6b-3a0140d75994.png)]'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[![](img/ff7680ac-a53a-4d1f-8d6b-3a0140d75994.png)]'
- en: We know from earlier that we use the concept of limits to find the derivative
    of a function. So, let's see how we can find the limit of a vector. We use the
    concept of norms here. We say [![](img/7a930e9f-4bd6-4e79-bb69-4e828a091869.png)],
    and so, if [![](img/6c8151df-0a70-434f-8c1a-143626f33095.png)], then as ![](img/e4684acc-c400-4b7a-80b8-611c79274c47.png), [![](img/6dfc2246-e4d8-4b9d-b519-648ac878655f.png)].
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前知道，使用极限的概念来求解一个函数的导数。那么，接下来我们看看如何求解一个向量的极限。我们在这里使用范数的概念。我们说 [![](img/7a930e9f-4bd6-4e79-bb69-4e828a091869.png)]，因此，如果 [![](img/6c8151df-0a70-434f-8c1a-143626f33095.png)]，那么当 ![](img/e4684acc-c400-4b7a-80b8-611c79274c47.png)， [![](img/6dfc2246-e4d8-4b9d-b519-648ac878655f.png)]。
- en: 'Generally, the derivative is calculated in all possible directions. But what
    if we want to find it in only one particular direction *n* (unit vector)? Then,
    assuming *δr = hn*, we have the following:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，导数是在所有可能的方向上计算的。但如果我们只想在一个特定的方向 *n*（单位向量）上找到导数呢？那么，假设 *δr = hn*，我们得到如下结果：
- en: '![](img/732b2bd0-bc2a-49e1-8caf-9fcbc4476d77.png)'
  id: totrans-360
  prefs: []
  type: TYPE_IMG
  zh: '![](img/732b2bd0-bc2a-49e1-8caf-9fcbc4476d77.png)'
- en: 'From this, we can derive the directional derivative to be the following:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 从中我们可以推导出方向导数如下：
- en: '![](img/38e35a69-562b-4d7f-97f1-35dbaaca52ea.png)'
  id: totrans-362
  prefs: []
  type: TYPE_IMG
  zh: '![](img/38e35a69-562b-4d7f-97f1-35dbaaca52ea.png)'
- en: This gives us the rate of change of *f* in this direction.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 这给出了 *f* 在这个方向上的变化率。
- en: 'Suppose now that we have *n = e[i]*. Then, our directional derivative becomes
    the following:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 假设现在我们有 *n = e[i]*。那么，我们的方向导数变为以下：
- en: '![](img/851f69d9-e6e9-4e64-a869-2d51ffbbf41b.png)'
  id: totrans-365
  prefs: []
  type: TYPE_IMG
  zh: '![](img/851f69d9-e6e9-4e64-a869-2d51ffbbf41b.png)'
- en: 'Therefore, we have the following:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们得到以下结果：
- en: '![](img/c6dda802-9d49-4dd7-b1ff-995d80d6b7da.png)'
  id: totrans-367
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c6dda802-9d49-4dd7-b1ff-995d80d6b7da.png)'
- en: 'And so, the condition of differentiability now becomes the following:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，差分性条件现在变为以下：
- en: '![](img/9302ca7d-1848-4c3f-a19f-72a21777a9c7.png)'
  id: totrans-369
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9302ca7d-1848-4c3f-a19f-72a21777a9c7.png)'
- en: 'We can express this in differential notation, as follows:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用微分符号表示如下：
- en: '![](img/33b24343-477b-486d-9448-47805a69b0ce.png)'
  id: totrans-371
  prefs: []
  type: TYPE_IMG
  zh: '![](img/33b24343-477b-486d-9448-47805a69b0ce.png)'
- en: This looks very similar to something we encountered earlier. It's the chain
    rule for partial derivatives.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来与我们之前遇到的情况非常相似。它是偏导数的链式法则。
- en: 'Let''s now take a function [![](img/3c259100-6e23-44b3-923a-b4f4faff313d.png)] that
    takes in a vector input ![](img/f79cb4fb-e733-4673-9198-c8f53ede5072.png) such
    that [![](img/3093bed9-02a2-47d8-a59c-bd8395c64976.png)]. The partial derivatives
    of this function are written as follows:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们取一个函数 [![](img/3c259100-6e23-44b3-923a-b4f4faff313d.png)]，它接收一个向量输入 ![](img/f79cb4fb-e733-4673-9198-c8f53ede5072.png)，使得
    [![](img/3093bed9-02a2-47d8-a59c-bd8395c64976.png)]。该函数的偏导数表示如下：
- en: '![](img/32b5cfe8-6268-4037-b5da-edc66ab598de.png)'
  id: totrans-374
  prefs: []
  type: TYPE_IMG
  zh: '![](img/32b5cfe8-6268-4037-b5da-edc66ab598de.png)'
- en: 'We can then write this collectively as an ![](img/8fcea3db-709d-4595-9e05-a3d9a731be73.png) vector,
    which we write as follows:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以将其整体表示为一个 ![](img/8fcea3db-709d-4595-9e05-a3d9a731be73.png) 向量，我们写作如下：
- en: '![](img/9b85addc-9c3d-4ea8-9cd6-14a49fd41342.png)'
  id: totrans-376
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9b85addc-9c3d-4ea8-9cd6-14a49fd41342.png)'
- en: Let's go a step further and imagine a vector function made of *m* different
    scalar functions, which take the vector *x* as input. We will write this as *y
    = f(x)*.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更进一步，设想一个由 *m* 个不同标量函数组成的向量函数，这些函数接受向量 *x* 作为输入。我们将其写为 *y = f(x)*。
- en: 'Expanding *y = f(x)*, we get the following:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 展开 *y = f(x)*，我们得到以下：
- en: '![](img/ccc9f4ee-acbf-4f9f-a4d7-d0886d56c6f3.png)'
  id: totrans-379
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ccc9f4ee-acbf-4f9f-a4d7-d0886d56c6f3.png)'
- en: 'Let''s revisit the Jacobian matrix briefly. As you can see, it is simply an
    (*m×n*) matrix containing all the partial derivatives of the earlier vector function.
    We can see what this looks like here:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要回顾一下雅可比矩阵。正如你所见，它仅仅是一个包含所有早期向量函数的偏导数的 (*m×n*) 矩阵。我们可以看到它长什么样：
- en: '![](img/0efbc5a3-52f8-4eee-a0dc-451ea275d204.png)'
  id: totrans-381
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0efbc5a3-52f8-4eee-a0dc-451ea275d204.png)'
- en: 'Let''s go a step further and extend this definition to multiple functions.
    Here, we have *y*, which is the sum of two functions *f* and *g*, each taking
    in a different vectorial input, which gives us the following:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进一步扩展这个定义到多个函数。这里，我们有 *y*，它是两个函数 *f* 和 *g* 的和，每个函数接受一个不同的向量输入，从而得到以下结果：
- en: '![](img/6152b8e1-6d89-403f-be4f-0fabe95214bb.png)'
  id: totrans-383
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6152b8e1-6d89-403f-be4f-0fabe95214bb.png)'
- en: 'And for the sake of simplicity, *f*, *g*, *a*, and *b* are all *n*-dimensional,
    which results in an *n×n* matrix, as follows:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化，*f*、*g*、*a* 和 *b* 都是 *n* 维的，这会导致一个 *n×n* 矩阵，如下所示：
- en: '![](img/c3f6b60b-97de-4559-8739-74af67f45ef5.png)'
  id: totrans-385
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c3f6b60b-97de-4559-8739-74af67f45ef5.png)'
- en: We can differentiate this matrix with respect to *a* or *b* and find the Jacobian
    matrix(es) for each.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以对这个矩阵分别关于 *a* 或 *b* 求导，并找出每个的雅可比矩阵。
- en: 'By differentiating with respect to *a*, we get the following:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对 *a* 求导，我们得到以下结果：
- en: '![](img/577451d4-d89d-4fb6-aeb6-4d734198545a.png)'
  id: totrans-388
  prefs: []
  type: TYPE_IMG
  zh: '![](img/577451d4-d89d-4fb6-aeb6-4d734198545a.png)'
- en: 'By differentiating with respect to *b*, we get the following:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对 *b* 求导，我们得到以下结果：
- en: '![](img/55ccdff4-7e3c-4f36-8d35-883c3d9eefc2.png)'
  id: totrans-390
  prefs: []
  type: TYPE_IMG
  zh: '![](img/55ccdff4-7e3c-4f36-8d35-883c3d9eefc2.png)'
- en: We can do the same for any type of element-wise operation on the two functions.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以对两个函数进行任何类型的逐元素操作。
- en: As in single variable and multivariable calculus, we have a chain rule for vector
    differentiation as well.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 如同单变量和多变量微积分中一样，我们也有向量微分的链式法则。
- en: 'Let''s take the composition of two vector functions that take in a vector input [![](img/55234a66-e3ca-458f-bf8b-b96d1c553558.png)],
    and so the gradient of this will be [![](img/a26a06e2-32f9-4199-8676-ee745c44d543.png)],
    which looks similar to what we encountered before. Let''s expand this further,
    as follows:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑两个向量函数的组合，它们接受一个向量输入 [![](img/55234a66-e3ca-458f-bf8b-b96d1c553558.png)]，因此其梯度将是
    [![](img/a26a06e2-32f9-4199-8676-ee745c44d543.png)]，这看起来与我们之前遇到的相似。让我们进一步展开，如下所示：
- en: '![](img/cd154d02-0eb4-451c-8ff1-afe98b0df49e.png)'
  id: totrans-394
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cd154d02-0eb4-451c-8ff1-afe98b0df49e.png)'
- en: 'In the majority of cases, for arguments in the Jacobian matrix where *i ≠ j*,
    the argument tends to be zero, which leads us to the following definitions:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，对于雅可比矩阵中的参数，其中 *i ≠ j*，参数往往为零，这导致我们得出以下定义：
- en: '![](img/86ebc192-bf82-472a-b81e-238560ec44e6.png)'
  id: totrans-396
  prefs: []
  type: TYPE_IMG
  zh: '![](img/86ebc192-bf82-472a-b81e-238560ec44e6.png)'
- en: 'And so, the following applies:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，以下适用：
- en: '![](img/df26c76c-3949-4c97-848f-e78e0e9b4c0f.png)'
  id: totrans-398
  prefs: []
  type: TYPE_IMG
  zh: '![](img/df26c76c-3949-4c97-848f-e78e0e9b4c0f.png)'
- en: As we can see, this is a diagonal matrix.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，这是一个对角矩阵。
- en: Vector fields
  id: totrans-400
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向量场
- en: 'We define a vector field as a function ![](img/c9fd80cb-58a3-484e-9c45-059d1bba46c1.png),
    and it can only be differentiated if the following applies:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将向量场定义为一个函数 ![](img/c9fd80cb-58a3-484e-9c45-059d1bba46c1.png)，只有在以下条件下，它才能被微分：
- en: '![](img/1672512e-0333-4a77-8850-d37aa0227177.png)'
  id: totrans-402
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1672512e-0333-4a77-8850-d37aa0227177.png)'
- en: Here, ![](img/1e791f2f-4bed-4985-86bc-786ed37144cf.png) is the derivative of
    *F*.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，![](img/1e791f2f-4bed-4985-86bc-786ed37144cf.png) 是 *F* 的导数。
- en: 'We can think of *M* as a matrix that maps one vector to another, and we can
    now express *F* as follows:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将 *M* 看作是一个将一个向量映射到另一个向量的矩阵，现在我们可以将 *F* 表示为：
- en: '![](img/40ae9d86-ade8-4a53-86f3-bdb7cb4ba1a8.png)'
  id: totrans-405
  prefs: []
  type: TYPE_IMG
  zh: '![](img/40ae9d86-ade8-4a53-86f3-bdb7cb4ba1a8.png)'
- en: 'Here, [![](img/8a5ad17b-8451-478f-8945-f315e956e0be.png)] for all [![](img/c6f13406-4f09-4cac-9324-31f23e1487c1.png)],
    and therefore, the derivative of *F* is this:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 这里， [![](img/8a5ad17b-8451-478f-8945-f315e956e0be.png)] 对所有 [![](img/c6f13406-4f09-4cac-9324-31f23e1487c1.png)]
    都成立，因此，*F* 的导数是：
- en: '![](img/fc8e832a-f37e-4158-bd5b-859428967f5b.png)'
  id: totrans-407
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fc8e832a-f37e-4158-bd5b-859428967f5b.png)'
- en: Earlier on in single and multivariable calculus, we learned the importance of
    the chain rule, so it should be no surprise that we have it in vector calculus
    as well. And it goes as follows.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 在单变量和多变量微积分的早期，我们学习了链式法则的重要性，因此我们在向量微积分中也有它，这不足为奇。其原理如下：
- en: 'Suppose we have [![](img/c5134051-782a-4efb-91bf-82bdd5b4c2c5.png)] and [![](img/6bd65aa9-8332-4748-b5a3-f85212838074.png)] and
    the coordinates are [![](img/0010a03b-86af-4b1f-947f-ae563fdf9d01.png)], [![](img/b0db5aa4-7aca-4251-8980-648c6cd9aa99.png)], and [![](img/09af3d54-44c2-45c2-a0e5-ab3b56dd9a42.png)].
    Then, the chain rule gives us the following:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有 [![](img/c5134051-782a-4efb-91bf-82bdd5b4c2c5.png)] 和 [![](img/6bd65aa9-8332-4748-b5a3-f85212838074.png)]，并且坐标是
    [![](img/0010a03b-86af-4b1f-947f-ae563fdf9d01.png)]，[![](img/b0db5aa4-7aca-4251-8980-648c6cd9aa99.png)]
    和 [![](img/09af3d54-44c2-45c2-a0e5-ab3b56dd9a42.png)]。然后，链式法则给出了以下结果：
- en: '![](img/2ddd83c8-d02a-4cb0-9c8a-0a629c4c4afc.png)'
  id: totrans-410
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2ddd83c8-d02a-4cb0-9c8a-0a629c4c4afc.png)'
- en: 'We can rewrite this in matrix form, as follows:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将其改写为矩阵形式，如下所示：
- en: '![](img/dac75952-d318-486e-b1c1-e0b3e6683ce4.png)'
  id: totrans-412
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dac75952-d318-486e-b1c1-e0b3e6683ce4.png)'
- en: Inverse functions
  id: totrans-413
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逆函数
- en: 'Inverse functions are a rather fascinating class of functions in that if we
    have two functions and we apply them on each other, we receive the identity. Mathematically,
    we define this as follows:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 逆函数是一类非常有趣的函数，如果我们有两个函数，并将它们互相作用，我们会得到恒等式。在数学上，我们将其定义如下：
- en: Suppose we have [![](img/df0afc01-a820-471a-8a1c-069712ec8918.png)]. Then, they
    are only inverse functions if [![](img/1f43586d-7308-40b0-9ab0-83ae54133b02.png)].
    For example, we could have [![](img/933cf644-e772-4347-a255-aaf8c5dc70e3.png)] and [![](img/6b9d1fc1-0a0d-41a6-811d-7b3b81daf17e.png)].
    Therefore, [![](img/62ee60a8-4516-428e-9298-938b3f03204f.png)], which tells us
    that [![](img/e5a270c0-e9b6-44b3-9d72-4d4fa6d66e8c.png)].
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有[![](img/df0afc01-a820-471a-8a1c-069712ec8918.png)]。那么，只有当[![](img/1f43586d-7308-40b0-9ab0-83ae54133b02.png)]时，它们才是反函数。例如，我们可能有[![](img/933cf644-e772-4347-a255-aaf8c5dc70e3.png)]和[![](img/6b9d1fc1-0a0d-41a6-811d-7b3b81daf17e.png)]。因此，[![](img/62ee60a8-4516-428e-9298-938b3f03204f.png)]，这告诉我们[![](img/e5a270c0-e9b6-44b3-9d72-4d4fa6d66e8c.png)]。
- en: 'Here is another cool property that this has:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个很酷的属性：
- en: '![](img/106625a0-72e6-40d9-bf0f-df5310a346f0.png)'
  id: totrans-417
  prefs: []
  type: TYPE_IMG
  zh: '![](img/106625a0-72e6-40d9-bf0f-df5310a346f0.png)'
- en: Summary
  id: totrans-418
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: And with that, we conclude our chapter on calculus. So far, we have learned
    about the fundamental concepts of single variable, multivariable, and vector calculus,
    and what it is that makes them so useful.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这一部分，我们结束了微积分的章节。到目前为止，我们已经学习了单变量、多变量和向量微积分的基本概念，以及它们为何如此有用。
- en: In the next chapter, we will move on to probability and statistics, and see
    how what we learned in linear algebra and calculus carries over into these fields.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章节中，我们将进入概率与统计，并探讨我们在线性代数和微积分中学到的知识如何在这些领域中应用。
