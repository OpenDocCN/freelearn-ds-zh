- en: Data Visualization
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 数据可视化
- en: Data visualization is the initial move in the data analysis system toward easily
    understanding and communicating information. It represents information and data
    in graphical form using visual elements such as charts, graphs, plots, and maps.
    It helps analysts to understand patterns, trends, outliers, distributions, and
    relationships. Data visualization is an efficient way to deal with a large number
    of datasets.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 数据可视化是数据分析系统中帮助轻松理解和传达信息的初步步骤。它通过使用图表、图形、图表和地图等可视化元素将信息和数据以图形形式表示。这有助于分析师理解模式、趋势、异常值、分布和关系。数据可视化是一种有效处理大量数据集的方式。
- en: 'Python offers various libraries for data visualization, such as Matplotlib,
    Seaborn, and Bokeh. In this chapter, we will first focus on Matplotlib, which
    is the basic Python library for visualization. After Matplotlib, we will explore
    Seaborn, which uses Matplotlib and offers high-level and advanced statistical
    plots. In the end, we will work on interactive data visualization using Bokeh.
    We will also explore `pandas` plotting. The following is a list of topics that
    will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Python 提供了多种用于数据可视化的库，如 Matplotlib、Seaborn 和 Bokeh。在本章中，我们将首先关注 Matplotlib，它是用于可视化的基础
    Python 库。然后我们将探讨 Seaborn，Seaborn 基于 Matplotlib，并提供了高级的统计图表。最后，我们将使用 Bokeh 进行交互式数据可视化。我们还将探讨
    `pandas` 绘图。以下是本章将要涵盖的主题列表：
- en: Visualization using Matplotlib
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Matplotlib 进行可视化
- en: Advanced visualization using the Seaborn package
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Seaborn 包进行高级可视化
- en: Interactive visualization with Bokeh
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Bokeh 进行交互式可视化
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'This chapter has the following technical requirements:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章具有以下技术要求：
- en: 'You can find the code and the datasets at the following GitHub link: [https://github.com/PacktPublishing/Python-Data-Analysis-Third-Edition/tree/master/Chapter05](https://github.com/PacktPublishing/Python-Data-Analysis-Third-Edition/tree/master/Chapter05).'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在以下 GitHub 链接找到代码和数据集：[https://github.com/PacktPublishing/Python-Data-Analysis-Third-Edition/tree/master/Chapter05](https://github.com/PacktPublishing/Python-Data-Analysis-Third-Edition/tree/master/Chapter05)。
- en: All the code blocks are available in the `ch5.ipynb` file.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有代码块都可以在 `ch5.ipynb` 文件中找到。
- en: This chapter uses only one CSV file (`HR_comma_sep.csv`) for practice purposes.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章仅使用一个 CSV 文件（`HR_comma_sep.csv`）进行练习。
- en: In this chapter, we will use the Matplotlib, `pandas`, Seaborn, and Bokeh Python
    libraries.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用 Matplotlib、`pandas`、Seaborn 和 Bokeh Python 库。
- en: Visualization using Matplotlib
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Matplotlib 进行可视化
- en: As we know, a picture speaks a thousand words. Humans understand visual things
    better. Visualization helps to present things to any kind of audience and can
    easily explain a complex phenomenon in layman's terms. Python offers a couple
    of visualization libraries, such as Matplotlib, Seaborn, and Bokeh.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所知道的，一图胜千言。人类对视觉信息的理解更好。可视化有助于向任何类型的观众展示事物，并可以用通俗的语言轻松解释复杂的现象。Python 提供了几种可视化库，如
    Matplotlib、Seaborn 和 Bokeh。
- en: Matplotlib is the most popular Python module for data visualization. It is a
    base library for most of the advanced Python visualization modules, such as Seaborn.
    It offers flexible and easy-to-use built-in functions for creating figures and
    graphs.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Matplotlib 是最流行的 Python 数据可视化模块。它是大多数高级 Python 可视化模块（如 Seaborn）的基础库。它提供了灵活且易于使用的内置函数，用于创建图形和图表。
- en: In Anaconda, Matplotlib is already installed. If you still find an error, you
    can install it in the following ways.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Anaconda 中，Matplotlib 已经安装。如果你仍然遇到错误，可以通过以下方式安装它。
- en: 'We can install Matplotlib with `pip` as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过 `pip` 安装 Matplotlib，方法如下：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'For Python 3, we can use the following command:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Python 3，我们可以使用以下命令：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You can also simply install Matplotlib from your terminal or Command Prompt
    using the following command:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过终端或命令提示符使用以下命令简单地安装 Matplotlib：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: To create a very basic plot in Matplotlib, we need to invoke the `plot()` function
    in the `matplotlib.pyplot` subpackage. This function produces a two-dimensional
    plot for a single list or multiple lists of points with known *x* and *y* coordinates.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Matplotlib 中创建一个非常基础的图表，我们需要调用 `plot()` 函数，该函数位于 `matplotlib.pyplot` 子包中。此函数为已知
    *x* 和 *y* 坐标的单个列表或多个列表的点生成一个二维图表。
- en: 'The following demo code is in the `ch5.ipynb` file in this book''s code bundle,
    which you can find at the following GitHub link: [https://github.com/PacktPublishing/Python-Data-Analysis-Third-Edition/blob/master/Chapter05/Ch5.ipynb](https://github.com/PacktPublishing/Python-Data-Analysis-Third-Edition/blob/master/Chapter05/Ch5.ipynb).'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例代码位于本书代码包中的 `ch5.ipynb` 文件中，您可以通过以下 GitHub 链接找到该文件：[https://github.com/PacktPublishing/Python-Data-Analysis-Third-Edition/blob/master/Chapter05/Ch5.ipynb](https://github.com/PacktPublishing/Python-Data-Analysis-Third-Edition/blob/master/Chapter05/Ch5.ipynb)。
- en: 'Let''s see a small demo code for visualizing the line plot:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个小的示例代码，用于可视化折线图：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This results in the following output:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![](img/613c4c85-5c82-45fd-973a-38d2af386454.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](img/613c4c85-5c82-45fd-973a-38d2af386454.png)'
- en: In the preceding code block, first, we are importing the Matplotlib and NumPy
    modules. After this, we are creating the data using the `linespace()` function
    of NumPy and plotting this data using the `plot()` function of Matplotlib. Finally,
    we are displaying the figure using the `show()` function.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，首先，我们导入了 Matplotlib 和 NumPy 模块。之后，我们使用 NumPy 的 `linespace()` 函数创建数据，并使用
    Matplotlib 的 `plot()` 函数绘制这些数据。最后，我们使用 `show()` 函数显示图形。
- en: 'There are two basic components of a plot: the figure and the axes. The figure
    is a container on which everything is drawn. It contains components such as plots,
    subplots, axes, titles, and a legend. In the next section, we will focus on these
    components, which act like accessories for charts.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图表有两个基本组件：图形和坐标轴。图形是一个容器，所有内容都绘制在上面。它包含如图表、子图、坐标轴、标题和图例等组件。在下一节中，我们将重点介绍这些组件，它们就像图表的配件。
- en: Accessories for charts
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图表的配件
- en: In the `matplotlib` module, we can add titles and axes labels to a graph. We
    can add a title using `plt.title()` and labels using `plt.xlabel()` and `plt.ylabel()`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `matplotlib` 模块中，我们可以向图表添加标题和坐标轴标签。我们可以使用 `plt.title()` 添加标题，使用 `plt.xlabel()`
    和 `plt.ylabel()` 添加标签。
- en: 'Multiple graphs mean multiple objects, such as line, bar, and scatter. Points
    of different series can be shown on a single graph. Legends or graph series reflect
    the *y* axis. A legend is a box that appears on either the right or left side
    of a graph and shows what each element of the graph represents. Let''s see an
    example where we see how to use these accessories in our charts:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 多个图形意味着多个对象，如折线、柱状图和散点图。不同系列的点可以显示在同一个图表上。图例或图表系列反映 *y* 轴。图例是一个框，通常出现在图表的右侧或左侧，显示每个图形元素的含义。让我们看看一个示例，展示如何在图表中使用这些配件：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This results in the following output:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![](img/0a7a1c2c-2d44-4f82-8a8f-e7170c513546.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0a7a1c2c-2d44-4f82-8a8f-e7170c513546.png)'
- en: In the preceding graph, two lines are shown on a single graph. We have used
    two extra parameters – `label` and `color` – in the `plot()` function. The `label`
    parameter defines the name of the series and `color` defines the color of the
    line graph. In the upcoming sections, we will focus on different types of plots.
    We will explore a scatter plot in the next section.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图表中，两个折线显示在同一个图表上。我们在 `plot()` 函数中使用了两个额外的参数 —— `label` 和 `color`。`label`
    参数定义了系列的名称，`color` 定义了折线的颜色。在接下来的章节中，我们将重点介绍不同类型的图表。我们将在下一节中探讨散点图。
- en: Scatter plot
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 散点图
- en: 'Scatter plots draw data points using Cartesian coordinates to show the values
    of numerical values. They also represent the relationship between two numerial
    values. We can create a scatter plot in Matplotlib using the `scatter()` function,
    as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 散点图使用笛卡尔坐标绘制数据点，显示数值的大小。它们还表示两个数值之间的关系。我们可以使用 Matplotlib 中的 `scatter()` 函数创建散点图，如下所示：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This results in the following output:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![](img/00c7d96b-b3b3-4957-8fbd-3411ec219f66.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00c7d96b-b3b3-4957-8fbd-3411ec219f66.png)'
- en: 'In the preceding scatter plot, the `scatter()` function takes x-axis and y-axis
    values. In our example, we are plotting two lists: `x` and `y`. We can also use
    optional parameters such as `c` for color, `alpha` for the transparency of the
    markers, ranging between 0 and 1, and `marker` for the shape of the points in
    the scatter plot, such as `*`, `o`, or any other symbol. In the next section,
    we will focus on the line plot.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的散点图中，`scatter()` 函数接受 x 轴和 y 轴的值。在我们的示例中，我们绘制了两个列表：`x` 和 `y`。我们还可以使用一些可选参数，例如
    `c` 来设置颜色，`alpha` 来设置标记的透明度（范围从 0 到 1），以及 `marker` 来设置散点图中点的形状，如 `*`、`o` 或任何其他符号。在下一节中，我们将重点介绍折线图。
- en: Line plot
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 折线图
- en: 'A line plot is a chart that displays a line between two variables. It has a
    sequence of data points joined by a segment:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 折线图是一种显示两变量之间关系的图表，它由一系列数据点连接而成：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This results in the following output:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这会生成如下输出：
- en: '![](img/d4fe2dd4-3d3a-4999-88b1-be9b0fadee7e.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d4fe2dd4-3d3a-4999-88b1-be9b0fadee7e.png)'
- en: In the preceding line plot program, the `plot()` function takes x-axis and y-axis
    values. In the next section, we will learn how to plot a pie chart.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的折线图程序中，`plot()` 函数接受 x 轴和 y 轴的数值。在接下来的章节中，我们将学习如何绘制饼图。
- en: Pie plot
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 饼图
- en: 'A pie plot is a circular graph that is split up into wedge-shaped pieces. Each
    piece is proportionate to the value it represents. The total value of the pie
    is 100 percent:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 饼图是一个圆形图表，被分成楔形的部分。每一部分的大小与它所代表的数值成正比。饼图的总值为100百分比：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This results in the following output:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这会生成如下输出：
- en: '![](img/1d09425f-b30d-4870-a971-4b8d6f54fb61.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1d09425f-b30d-4870-a971-4b8d6f54fb61.png)'
- en: In the preceding code of the pie chart, we specified `values`, `labels`, `colors`,
    `startangle`, `shadow`, `explode`, and `autopct`. In our example, `values` is
    the scores of the student in four subjects and `labels` is the list of subject
    names. We can also specify the color list for the individual subject scores. The
    `startangle` parameter specifies the first value angle, which is 90 degrees; this
    means the first line is vertical.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的饼图代码中，我们指定了 `values`、`labels`、`colors`、`startangle`、`shadow`、`explode` 和
    `autopct`。在我们的例子中，`values` 是学生在四个科目中的成绩，`labels` 是科目名称的列表。我们还可以为每个科目的成绩指定颜色列表。`startangle`
    参数指定第一个值的角度，默认为 90 度；这意味着第一个线条是垂直的。
- en: Optionally, we can also use the `shadow` parameter to specify the shadow of
    the pie slice and the `explode` parameter to pull out a pie slice list of the
    binary value. If we want to pull out a second pie slice, then a tuple of values
    would be (0, 0.1, 0, 0). Let's now jump to the bar plot.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 可选地，我们还可以使用 `shadow` 参数来指定饼图切片的阴影，使用 `explode` 参数来突出显示某些饼图切片的二进制值。如果我们想突出显示第二个饼图切片，则值的元组为
    (0, 0.1, 0, 0)。接下来我们跳到条形图部分。
- en: Bar plot
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 条形图
- en: 'A bar plot is a visual tool to compare the values of various groups. It can
    be drawn horizontally or vertically. We can create a bar graph using the `bar()`
    function:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 条形图是一种比较不同组值的可视化工具，可以水平或垂直绘制。我们可以使用 `bar()` 函数创建条形图：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This results in the following output:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这会生成如下输出：
- en: '![](img/f04bf569-db9a-4dd8-ba18-9bfbd9a11cb3.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f04bf569-db9a-4dd8-ba18-9bfbd9a11cb3.png)'
- en: In the preceding bar chart program, the `bar()` function takes *x*-axis values,
    *y*-axis values, and a color. In our example, we are plotting movie ratings and
    their frequency. Movie ratings are on the *x* axis and the rating frequency is
    on the *y* axis. We can also specify the color of the bars in the bar graph using
    the `color` parameter. Let's see another variant of bar plot in the next subsection.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的条形图程序中，`bar()` 函数接受 *x* 轴值、*y* 轴值和颜色。在我们的例子中，我们绘制的是电影评分及其频率。电影评分位于 *x* 轴上，评分频率位于
    *y* 轴上。我们还可以使用 `color` 参数为条形图的条形指定颜色。接下来，让我们看看条形图的另一种变体。
- en: Histogram plot
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 直方图
- en: 'A histogram shows the distribution of a numeric variable. We create a histogram
    using the `hist()` method. It shows the probability distribution of a continuous
    variable. A histogram only works on a single variable while a bar graph works
    on two variables:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 直方图显示的是一个数值变量的分布情况。我们使用 `hist()` 方法创建直方图，它显示的是连续变量的概率分布。直方图只适用于单一变量，而条形图适用于两个变量：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This results in the following output:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这会生成如下输出：
- en: '![](img/7d029d49-dc00-4322-8022-af240ac0c396.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7d029d49-dc00-4322-8022-af240ac0c396.png)'
- en: In the preceding histogram, the `hist()` function takes `values`, `bins`, and
    `rwidth`. In our example, we are plotting the age of the employee and using a
    bin of 10 years. We are starting our bin from 20 to 60 with a 10 years bin size.
    We are using a relative bar width of 0.6, but you can choose any size for thicker
    and thinner width. Now it's time to jump to the bubble plot, which can handle
    multiple variables in a two-dimensional plot.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的直方图中，`hist()` 函数接受 `values`、`bins` 和 `rwidth`。在我们的例子中，我们绘制的是员工的年龄，并使用 10
    年的区间。我们从 20 岁到 60 岁开始，每个区间的大小为 10 年。我们使用 0.6 的相对条形宽度，但你可以选择任何大小来调整宽度的粗细。现在，我们将跳转到气泡图，它可以在二维图中处理多个变量。
- en: Bubble plot
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 气泡图
- en: 'A bubble plot is a type of scatter plot. It not only draws data points using
    Cartesian coordinates but also creates bubbles on data points. Bubble shows the
    third dimension of a plot. It shows three numerical values: two values are on
    the *x* and *y* axes and the third one is the size of data points (or bubbles):'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 气泡图是一种散点图。它不仅使用笛卡尔坐标绘制数据点，还在数据点上创建气泡。气泡显示了图表的第三维度。它展示了三个数值：两个数值位于 *x* 和 *y*
    轴上，第三个数值则是数据点（或气泡）的大小：
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This results in the following output:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![](img/2d66b28e-5b60-4c42-a234-eaa15a183e36.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2d66b28e-5b60-4c42-a234-eaa15a183e36.png)'
- en: In the preceding plot, a bubble chart is created using the scatter function.
    Here, the important thing is the `s` (size) parameter of the scatter function.
    We assigned a third variable, `scaled_gdp_per_capita`, to the `size` parameters.
    In the preceding bubble plot, countries are on the *x* axis, the population is
    on the *y* axis, and GDP per capita is shown by the size of the scatter point
    or bubble. We also assigned a random color to the bubbles to make it attractive
    and more understandable. From the bubble size, you can easily see that Qatar has
    the highest GDP per capita and Kuwait has the lowest GDP per capita. In all the
    preceding sections, we have focused on most of the Matplotlib plots and charts.
    Now, we will see how we can plot the charts using the `pandas` module.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图表中，使用散点图函数创建了一个气泡图。这里，重要的是散点图函数的 `s`（大小）参数。我们将第三个变量 `scaled_gdp_per_capita`
    分配给了 `size` 参数。在前面的气泡图中，国家位于 *x* 轴上，人口位于 *y* 轴上，而人均 GDP 通过散点或气泡的大小来展示。我们还为气泡分配了随机颜色，以使其更具吸引力并易于理解。从气泡的大小，可以很容易看出卡塔尔的人均
    GDP 最高，而科威特的人均 GDP 最低。在前面的所有部分中，我们集中讨论了大部分 Matplotlib 图表。现在，我们将看看如何使用 `pandas`
    模块绘制图表。
- en: pandas plotting
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: pandas 绘图
- en: 'The `pandas` library offers the `plot()` method as a wrapper around the Matplotlib
    library. The `plot()` method allows us to create plots directly on `pandas` DataFrames.
    The following `plot()` method parameters are used to create the plots:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`pandas` 库提供了 `plot()` 方法，它是 Matplotlib 库的封装。`plot()` 方法允许我们直接在 `pandas` DataFrame
    上创建图表。以下是用于创建图表的 `plot()` 方法参数：'
- en: '`kind`: A string parameter for the type of graph, such as line, bar, barh,
    hist, box, KDE, pie, area, or scatter.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kind`: 用于图表类型的字符串参数，例如：line、bar、barh、hist、box、KDE、pie、area 或 scatter。'
- en: '`figsize`: This defines the size for a figure in a tuple of (width, height).'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`figsize`: 这定义了图表的尺寸，采用 (宽度, 高度) 的元组形式。'
- en: '`title`: This defines the title for the graph.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`title`: 这定义了图表的标题。'
- en: '`grid`: Boolean parameter for the axis grid line.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`grid`: 布尔参数，表示轴的网格线。'
- en: '`legend`: This defines the legend.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`legend`: 这定义了图例。'
- en: '`xticks`: This defines the sequence of x-axis ticks.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`xticks`: 这定义了 x 轴刻度的序列。'
- en: '`yticks`: This defines the sequence of y-axis ticks.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`yticks`: 这定义了 y 轴刻度的序列。'
- en: 'Let''s create a scatter plot using the `pandas plot()` function:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 `pandas plot()` 函数创建一个散点图：
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This results in the following output:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![](img/7d5e58d4-dcc9-47bc-85b3-80dfffc93a5a.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7d5e58d4-dcc9-47bc-85b3-80dfffc93a5a.png)'
- en: 'In the preceding plot, the `plot()` function takes `kind`, `x`, `y`, `color`,
    and `title` values. In our example, we are plotting the scatter plot between age
    and income using the `kind` parameter as `''scatter''`. The `age` and `income`
    columns are assigned to the `x` and `y` parameters. The scatter point color and
    the title of the plot are assigned to the `color` and `title` parameters:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图表中，`plot()` 函数使用了 `kind`、`x`、`y`、`color` 和 `title` 参数。在我们的示例中，我们使用 `kind`
    参数为 `'scatter'` 来绘制年龄与收入之间的散点图。`age` 和 `income` 列分别分配给 `x` 和 `y` 参数。散点的颜色和图表的标题被分配给
    `color` 和 `title` 参数：
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This results in the following output:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![](img/fe1b8fcd-fd1a-44e1-adc2-2843c962f2d4.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fe1b8fcd-fd1a-44e1-adc2-2843c962f2d4.png)'
- en: In the preceding plot, the `plot()` function takes `kind`, `x`, `y`, `color`,
    and `title` values. In our example, we are plotting the bar plot between age and
    income using the `kind` parameter as `'bar'`. The `name` and `age` columns are
    assigned to the `x` and `y` parameters. The scatter point color is assigned to
    the `color` parameter. This is all about `pandas` plotting. Now, from the next
    section onward, we will see how to visualize the data using the Seaborn library.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图表中，`plot()` 函数使用 `kind`、`x`、`y`、`color` 和 `title` 参数。在我们的示例中，我们使用 `kind`
    参数为 `'bar'` 来绘制年龄与收入之间的柱状图。`name` 和 `age` 列分别分配给 `x` 和 `y` 参数。散点的颜色被分配给 `color`
    参数。这就是关于 `pandas` 绘图的内容。从下一部分开始，我们将看到如何使用 Seaborn 库可视化数据。
- en: Advanced visualization using the Seaborn package
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Seaborn 包进行高级可视化
- en: Visualization can be helpful to easily understand complex patterns and concepts.
    It represents the insights in pictorial format. In the preceding sections, we
    have learned about Matplotlib for visualization. Now, we will explore the new
    Seaborn library for high-level and advanced statistical plots. Seaborn is an open
    source Python library for high-level interactive and attractive statistical visualization.
    Seaborn uses Matplotlib as a base library and offers more simple, easy-to-understand,
    interactive, and attractive visualizations.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 可视化有助于轻松理解复杂的模式和概念。它以图像的形式表示洞察。在前面的部分中，我们学习了如何使用 Matplotlib 进行可视化。现在，我们将探索新的
    Seaborn 库，它可以进行高级统计图表的绘制。Seaborn 是一个开源的 Python 库，用于高阶互动性和吸引人的统计可视化。Seaborn 以 Matplotlib
    为基础库，提供了更简单、易懂、互动性强且美观的可视化效果。
- en: 'In the Anaconda software suite, you can install the Seaborn library in the
    following way:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Anaconda 软件包中，您可以通过以下方式安装 Seaborn 库：
- en: 'Install Seaborn with `pip`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `pip` 安装 Seaborn：
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'For Python 3, use the following command:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Python 3，请使用以下命令：
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You can simply install Seaborn from your terminal or Command Prompt using the
    following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过终端或命令提示符使用以下命令轻松安装 Seaborn：
- en: '[PRE15]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If you are installing it into the Jupyter Notebook, then you need to put the
    `!` sign before the `pip` command. Here is an example:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您是在 Jupyter Notebook 中安装，则需要在 `pip` 命令前加上 `!` 符号。以下是示例：
- en: '[PRE16]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Let's jump to the `lm` plot of Seaborn.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们跳转到 Seaborn 的 `lm` 图。
- en: lm plots
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: lm 图
- en: 'The `lm` plot plots the scatter and fits the regression model on it. A scatter
    plot is the best way to understand the relationship between two variables. Its
    output visualization is a joint distribution of two variables. `lmplot()` takes
    two column names – `x` and `y` – as a string and DataFrame variable. Let''s see
    the following example:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`lm` 图绘制了散点图并在其上拟合回归模型。散点图是理解两个变量之间关系的最佳方式。它的输出可视化表示了两个变量的联合分布。`lmplot()` 接受两个列名——`x`
    和 `y`——作为字符串和 DataFrame 变量。让我们来看以下示例：'
- en: '[PRE17]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This results in the following output:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![](img/17714774-b536-4968-85f7-4bc049be363a.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](img/17714774-b536-4968-85f7-4bc049be363a.png)'
- en: 'By default, `lmplot()` fits the regression line. We can also remove this by
    setting the `fit_reg` parameter as `False`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`lmplot()` 会拟合回归线。我们也可以通过将 `fit_reg` 参数设置为 `False` 来移除回归线：
- en: '[PRE18]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This results in the following output:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![](img/1e389c44-cd99-436e-a622-92f7f25557d9.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1e389c44-cd99-436e-a622-92f7f25557d9.png)'
- en: 'Let''s take a dataset of HR Analytics and try to plot `lmplot()`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 HR Analytics 数据集并尝试绘制 `lmplot()`：
- en: '[PRE19]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This results in the following output:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![](img/017df826-085a-4c23-b317-1c8aac44a89b.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](img/017df826-085a-4c23-b317-1c8aac44a89b.png)'
- en: In the preceding example, `last_evaluation` is the evaluated performance of
    the employee, `satisfaction_level` is the employee's satisfaction level in the
    company, and `left` means whether the employee left the company or not. `satisfaction_level`
    and `last_evaluation` were drawn on the *x* and *y* axes, respectively. The third
    variable left is passed in the `hue` parameter. The `hue` property is used for
    color shade. We are passing a `left` variable as `hue`. We can clearly see in
    the diagram that employees that have left are scattered into three groups. Let's
    now jump to bar plots.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`last_evaluation` 是员工的评估表现，`satisfaction_level` 是员工在公司的满意度，`left` 表示员工是否离开公司。`satisfaction_level`
    和 `last_evaluation` 分别绘制在 *x* 和 *y* 轴上。第三个变量 `left` 被传递到 `hue` 参数中。`hue` 属性用于颜色阴影。我们将
    `left` 变量作为 `hue`。从图表中我们可以清楚地看到，已经离职的员工分散成三组。接下来我们来看条形图。
- en: Bar plots
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 条形图
- en: '`barplot()` offers the relationship between a categorical and a continuous
    variable. It uses rectangular bars with variable lengths:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`barplot()` 显示了分类变量和连续变量之间的关系。它使用不同长度的矩形条形图：'
- en: '[PRE20]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This results in the following output:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![](img/22ef555d-5837-48a9-8dd8-88883321b131.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](img/22ef555d-5837-48a9-8dd8-88883321b131.png)'
- en: In the preceding example, the bar plot is created using the `bar()` function.
    It takes two columns – `x` and `y` – and a DataFrame as input. In the next section,
    we will see how to plot a distribution plot.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，条形图是通过 `bar()` 函数创建的。它接受两个列——`x` 和 `y`——以及一个 DataFrame 作为输入。在接下来的部分中，我们将看到如何绘制分布图。
- en: Distribution plots
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分布图
- en: 'This plots a univariate distribution of variables. It is a combination of a
    histogram with the default bin size and a **Kernel Density Estimation** (**KDE**)
    plot. In our example, `distplot()` will take the `satisfaction_level` input column
    and plot the distribution of it. Here, the distribution of `satisfaction_level`
    has two peaks:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这绘制了一个单变量的分布图。它是默认箱体大小的直方图与**核密度估计**（**KDE**）图的结合。在我们的示例中，`distplot()`将接受`satisfaction_level`输入列并绘制其分布。在这里，`satisfaction_level`的分布有两个峰值：
- en: '[PRE21]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This results in the following output:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![](img/5256c688-8301-464e-bad2-4108271a2d93.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5256c688-8301-464e-bad2-4108271a2d93.png)'
- en: In the preceding code block, we have created the distribution plot using `distplot()`.
    It's time to jump to the box plot diagram.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，我们使用`distplot()`创建了分布图。现在是时候跳转到箱型图了。
- en: Box plots
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 箱型图
- en: 'Box plot, aka box-whisker plot, is one of the best plots to understand the
    distribution of each variable with its quartiles. It can be horizontal or vertical.
    It shows quartile distribution in a box, which is known as a whisker. It also
    shows the minimum and maximum and outliers in the data. We can easily create a
    box plot using Seaborn:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 箱型图，又称箱形须图，是理解每个变量分布及其四分位数的最佳图表之一。它可以是水平的也可以是垂直的。它通过一个箱子显示四分位数分布，该箱子被称为须。它还显示数据的最小值、最大值和异常值。我们可以使用Seaborn轻松创建箱型图：
- en: '[PRE22]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This results in the following output:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![](img/5923cc3c-5649-4e02-acbe-0009b4d1a50b.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5923cc3c-5649-4e02-acbe-0009b4d1a50b.png)'
- en: In the preceding example, we have used two variables for the box plot. Here,
    the box plot indicates that the range of `satisfaction_level` is higher than `last_evaluation`
    (performance). Let's jump to the KDE plot in Seaborn.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们使用了两个变量来绘制箱型图。这里，箱型图表明`satisfaction_level`的范围高于`last_evaluation`（表现）。接下来，我们来看看Seaborn中的KDE图。
- en: KDE plots
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: KDE图
- en: 'The `kde()` function plots the probability density estimation of a given continuous
    variable. It is a non-parametric kind of estimator. In our example, the `kde()`
    function takes one parameter, `satisfaction_level`, and plots the KDE:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`kde()`函数绘制给定连续变量的概率密度估计。这是一种非参数估计方法。在我们的示例中，`kde()`函数接受一个参数`满意度`并绘制KDE：'
- en: '[PRE23]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This results in the following output:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![](img/a99ab7a8-9e47-47ad-96c8-e7dc804e65ec.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a99ab7a8-9e47-47ad-96c8-e7dc804e65ec.png)'
- en: In the preceding code block, we have created a density plot using `kdeplot()`.
    In the next section, we will see another distribution plot, which is a combination
    of a density and box plot, known as a violin plot.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，我们使用`kdeplot()`创建了一个密度图。在下一节中，我们将看到另一种分布图，它是密度图和箱型图的结合，称为小提琴图。
- en: Violin plots
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 小提琴图
- en: 'Violin plots are a combined form of box plots and KDE, which offer easy-to-understand
    analysis of the distribution:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 小提琴图是箱型图和KDE的结合形式，能够提供易于理解的分布分析：
- en: '[PRE24]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This results in the following output:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![](img/9a103c26-d7de-400a-b91b-c2c6840caec0.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9a103c26-d7de-400a-b91b-c2c6840caec0.png)'
- en: In the preceding example, we have used two variables for the violin plot. Here,
    we can conclude that the range of `satisfaction_level` is higher than `last_evaluation`
    (performance) and both the variables have two peaks in the distribution. After
    working on distribution plots, we will see how we can combine the `groupby` operation
    and box plot into a single plot using a count plot.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们使用了两个变量来绘制小提琴图。在这里，我们可以得出结论，`satisfaction_level`的范围高于`last_evaluation`（表现），且这两个变量的分布中都有两个峰值。完成分布图的分析后，我们将看到如何将`groupby`操作和箱型图结合成一个图表，使用计数图来展示。
- en: Count plots
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计数图
- en: '`countplot()` is a special type of bar plot. It shows the frequency of each
    categorical variable. It is also known as a histogram for categorical variables.
    It makes operations very simple compared to Matplotlib. In Matplotlib, to create
    a count plot, first we need to group by the category column and count the frequency
    of each class. After that, this count is consumed by Matplotlib''s bar plot. But
    the Seaborn count plot offers a single line of code to plot the distribution:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`countplot()`是一个特殊类型的条形图。它显示每个分类变量的频率。它也被称为分类变量的直方图。与Matplotlib相比，它简化了操作。在Matplotlib中，要创建一个计数图，首先需要按类别列进行分组，并计算每个类别的频率。之后，Matplotlib的条形图会使用这个计数。然而，Seaborn的计数图只需要一行代码就可以绘制分布：'
- en: '[PRE25]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This results in the following output:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![](img/5c32b145-c58f-48e3-920e-430f8f1ab04a.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5c32b145-c58f-48e3-920e-430f8f1ab04a.png)'
- en: 'In the preceding example, we are counting the `salary` variable. The `count()`
    function takes a single column and DataFrame. So, we can easily conclude from
    the graph that most of the employees have low and medium salaries. We can also
    use `hue` as the second variable. Let''s see the following example:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，我们正在统计`salary`变量。`count()`函数接受一个单列和DataFrame。因此，从图表中我们可以很容易地得出结论，大多数员工的工资都在低到中等范围内。我们还可以将`hue`作为第二个变量。让我们看看以下示例：
- en: '[PRE26]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This results in the following output:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![](img/7fa48cc3-20a7-4fb0-abe2-7d43cda6fec5.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7fa48cc3-20a7-4fb0-abe2-7d43cda6fec5.png)'
- en: In the preceding example, we can see that `left` is used as the hue or color
    shade. This indicates that most of the employees with the lowest salary left the
    company. Let's see another important plot for visualizing the relationship and
    distribution of two variables.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述示例中，我们可以看到`left`被用作色调或颜色阴影。这表明大多数薪资最低的员工离开了公司。接下来，我们来看另一个用于可视化两个变量关系和分布的重要图表。
- en: Joint plots
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 联合图
- en: 'The joint plot is a multi-panel visualization; it shows the bivariate relationship
    and distribution of individual variables in a single graph. We can also plot a
    KDE using the `kind` parameter of `jointplot()`. By setting the `kind` parameter
    as `"kde"`, we can draw the KDE plot. Let''s see the following example:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 联合图是一种多面板可视化，显示了双变量关系以及单个变量的分布。我们还可以使用`jointplot()`的`kind`参数绘制KDE图。通过将`kind`参数设置为`"kde"`，我们可以绘制KDE图。让我们看以下示例：
- en: '[PRE27]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This results in the following output:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![](img/f41ea0ea-fc2b-4abc-ad61-524a322e8e59.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f41ea0ea-fc2b-4abc-ad61-524a322e8e59.png)'
- en: In the preceding plot, we have created the joint plot using `jointplot()` and
    also added the `kde` plot using a `kind` parameter as `"kde"`. Let's jump to heatmaps
    for more diverse visualization.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述图中，我们使用`jointplot()`创建了联合图，并通过`kind`参数设置为`"kde"`来添加了`kde`图。接下来让我们来看热力图，进行更丰富的可视化。
- en: Heatmaps
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 热力图
- en: 'Heatmap offers two-dimensional grid representation. The individual cell of
    the grid contains a value of the matrix. The heatmap function also offers annotation
    on each cell:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 热力图提供了二维网格表示。网格的每个单元格包含矩阵的一个值。热力图功能还提供了对每个单元格的注释：
- en: '[PRE28]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This results in the following output:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![](img/fa30eaf5-0f91-4a9d-ad6c-2e5c01d31fb3.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fa30eaf5-0f91-4a9d-ad6c-2e5c01d31fb3.png)'
- en: 'In the preceding example, the Iris dataset is loaded using `load_dataset()`
    and the correlation is calculated using the `corr()` function. The `corr()` function
    returns the correlation matrix. This correlation matrix is plotted using the `heatmap()`
    function for the grid view of the correlation matrix. It takes two parameters:
    the correlation matrix and `annot`. The `annot` parameter is passed as `True`.
    In the plot, we can see a symmetric matrix, and all the values on the diagonal
    are ones, which indicates a perfect correlation of a variable with itself. We
    can also set a new color map using the `cmap` parameter for different colors:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述示例中，使用`load_dataset()`加载了Iris数据集，并通过`corr()`函数计算了相关性。`corr()`函数返回相关性矩阵。然后，使用`heatmap()`函数绘制相关性矩阵的网格视图。它接受两个参数：相关性矩阵和`annot`。`annot`参数设置为`True`。在图中，我们可以看到一个对称矩阵，所有对角线上的值都是1，这表示一个变量与自身的完美相关性。我们还可以通过`cmap`参数设置新的颜色映射以实现不同的颜色：
- en: '[PRE29]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This results in the following output:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![](img/9bde2842-cf24-496f-b49b-ace8bdc8ab4c.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9bde2842-cf24-496f-b49b-ace8bdc8ab4c.png)'
- en: In the preceding heatmap, we have changed the color map using the `cmap` parameter
    for different colors. Here, we are using the `YlGnBu` (yellow, green, and blue)
    combination for `cmap`. Now, we will move on to the pair plot for faster exploratory
    analysis.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述热力图中，我们通过`cmap`参数为不同的颜色设置了颜色映射。这里，我们使用了`YlGnBu`（黄色、绿色和蓝色）组合作为`cmap`。现在，我们将进入对角矩阵图（pair
    plot）以进行更快速的探索性分析。
- en: Pair plots
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对角矩阵图
- en: 'Seaborn offers quick exploratory data analysis with relationships and individual
    distribution using a pair plot. A pair plot offers a single distribution using
    a histogram and joint distribution using a scatter plot:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: Seaborn提供了快速的探索性数据分析，通过对角矩阵图展示变量间的关系以及单独的分布。对角矩阵图使用直方图显示单一分布，并通过散点图展示联合分布：
- en: '[PRE30]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This results in the following output:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![](img/3f3364c2-28ea-4ca1-8b03-35f622390a3b.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3f3364c2-28ea-4ca1-8b03-35f622390a3b.png)'
- en: In the preceding example, the Iris dataset is loaded using `load_dataset()`
    and that dataset is passed into the `pairplot()` function. In the plot, it creates
    an *n* by *n* matrix or a grid of graphs. The diagonal shows the distribution
    of the columns, and the non-diagonal elements of the grid show the scatter plot
    to understand the relationship among all the variables.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，Iris数据集是通过`load_dataset()`加载的，并将该数据集传递给`pairplot()`函数。在图表中，它创建了一个*n*乘*n*的矩阵或图形网格。对角线展示了各列的分布，网格的非对角元素展示了散点图，以便理解所有变量之间的关系。
- en: In the preceding few sections, we have seen how to use the Seaborn plots. Now,
    we will jump to another important visualization library, which is Bokeh. In the
    upcoming sections, we will draw interactive and versatile plots using the Bokeh
    library.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的几个部分中，我们已经看到了如何使用Seaborn绘图。现在，我们将转到另一个重要的可视化库——Bokeh。在接下来的部分中，我们将使用Bokeh库绘制互动和多功能的图表。
- en: Interactive visualization with Bokeh
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Bokeh进行互动式可视化
- en: Bokeh is an interactive, high-quality, versatile, focused, and more powerful
    visualization library for large-volume and streaming data. It offers interactive,
    rich charts, plots, layouts, and dashboards for modern web browsers. Its output
    can be mapped to a notebook, HTML, or server.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: Bokeh是一个互动性强、高质量、功能多样、专注且更强大的可视化库，适用于大数据量和流式数据。它为现代Web浏览器提供互动丰富的图表、图形、布局和仪表板。其输出可以映射到笔记本、HTML或服务器。
- en: Both the Matplotlib and Bokeh libraries have different intentions. Matplotlib
    focuses on static, simple, and fast visualization while Bokeh focuses on highly
    interactive, dynamic, web-based, and quality visualization. Matplotlib is generally
    used for publication images while Bokeh is for a web audience. In the remaining
    sections of this chapter, we will learn basic plotting using Bokeh. We can create
    more interactive visuals for data exploration using Bokeh.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: Matplotlib和Bokeh库有不同的用途。Matplotlib专注于静态、简单和快速的可视化，而Bokeh则专注于高度互动、动态、基于Web的高质量可视化。Matplotlib通常用于出版物中的图像，而Bokeh则面向Web用户。在本章的后续部分，我们将学习如何使用Bokeh进行基础绘图。我们可以利用Bokeh为数据探索创建更多互动的可视化效果。
- en: 'The simplest way to install the Bokeh library is with the Anaconda distribution
    package. To install Bokeh, use the following command:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Bokeh库的最简单方法是通过Anaconda发行包。要安装Bokeh，请使用以下命令：
- en: '[PRE31]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We can also install it using `pip`. To install Bokeh using `pip`, use the following
    command:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`pip`来安装它。要使用`pip`安装Bokeh，请使用以下命令：
- en: '[PRE32]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Plotting a simple graph
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘制一个简单的图形
- en: 'Let''s plot a first and simple plot using Bokeh. First, we need to import the
    basic `bokeh.plotting` module. The `output_notebook()` function defines that the
    plot will render on the Jupyter Notebook. The `figure` object is used as one of
    the core objects to draw charts and graphs. The `figure` object focuses on the
    plot title, size, label, grids, and style. The `figure` object also deals with
    plot style, title, axes labels, axes, grids, and various methods for adding data:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用Bokeh绘制一个简单的图形。首先，我们需要导入基本的`bokeh.plotting`模块。`output_notebook()`函数定义了图表将在Jupyter
    Notebook上渲染。`figure`对象是绘制图表和图形的核心对象之一。`figure`对象关注图表的标题、大小、标签、网格和样式。`figure`对象还处理图表样式、标题、坐标轴标签、坐标轴、网格以及添加数据的各种方法：
- en: '[PRE33]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This results in the following output:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生如下输出：
- en: '![](img/7ae25831-21b5-4559-87d4-5597bb34d3f1.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7ae25831-21b5-4559-87d4-5597bb34d3f1.png)'
- en: After setting up the `figure` object, we will create a scatter circle markers
    plot using a circle function. The `circle()` function will take `x` and `y` values.
    It also takes size, color, and alpha parameters. The `show()` function will finally
    plot the output once all the features and data are added to the plot.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置完`figure`对象后，我们将使用circle函数创建一个散点圆形标记图。`circle()`函数将接受`x`和`y`值。它还接受大小、颜色和透明度（alpha）参数。最后，`show()`函数将在所有特性和数据添加到图表后，绘制输出结果。
- en: Glyphs
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 符号
- en: 'Bokeh uses a visual glyph, which refers to the circles, lines, triangles, squares,
    bars, diamonds, and other shape graphs. The glyph is a unique symbol that is used
    to convey information in pictorial form. Let''s create a line plot using the `line()`
    function:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: Bokeh使用视觉符号（glyph），它指的是圆圈、线条、三角形、正方形、条形、菱形以及其他形状的图形。符号是一种独特的标记，用于以图像形式传达信息。让我们使用`line()`函数创建一条线性图：
- en: '[PRE34]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This results in the following output:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生如下输出：
- en: '![](img/186afe2d-4b28-4873-a0ce-a51a4bf80366.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![](img/186afe2d-4b28-4873-a0ce-a51a4bf80366.png)'
- en: In the preceding example, the `line()` function takes the *x*- and *y*-axis
    values. It also takes the `line_width` and `color` values of the line. In the
    next section, we will focus on the layouts for multiple plots.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，`line()` 函数接受*x*和*y*轴值。它还接受线的`line_width`和`color`值。在下一节中，我们将重点介绍多图表的布局。
- en: Layouts
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布局
- en: 'Bokeh offers layouts for organizing plots and widgets. Layouts organize more
    than one plot in a single panel for interactive visualizations. They also allow
    setting the sizing modes for resizing the plots and widgets based on panel size.
    The layout can be of the following types:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: Bokeh 提供了用于组织图和小部件的布局。布局将多个图表组织在单个面板中，用于交互式可视化。它们还允许根据面板大小设置调整图表和小部件的大小调整模式。布局可以是以下类型之一：
- en: '**Row layout**: This organizes all the plots in a row or in a horizontal fashion.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行布局**：这将所有图表以行或水平方式组织。'
- en: '**Column layout**: This organizes all the plots in a column or in a vertical
    fashion.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**列布局**：这将所有图表以列或垂直方式组织。'
- en: '**Nested layout**: This is a combination of row and column layouts.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**嵌套布局**：这是行和列布局的组合。'
- en: '**Grid layout**: This offers you a grid of matrices for arranging the plots
    in.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网格布局**：这为您提供了一个网格矩阵，用于排列图表。'
- en: 'Let''s see a row layout example:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个行布局的例子：
- en: '[PRE35]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This results in the following output:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致以下输出：
- en: '![](img/045edd8a-4c85-4a89-a200-aa5ad5a7b8af.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![](img/045edd8a-4c85-4a89-a200-aa5ad5a7b8af.png)'
- en: 'In this layout plot, we have imported the row and column layouts, loaded the
    Iris data from Bokeh sample data, instantiated the three `figure` objects with
    plot width and height, created the three scatter circle markers on each figure
    object, and created the row layout. This row layout will take the `figure` objects
    as input and is drawn using the `show()` function. We can also create a column
    layout by creating a column layout in place of a row layout, as shown:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在此布局图中，我们导入了行和列布局，从Bokeh示例数据加载了鸢尾花数据，用图表宽度和高度实例化了三个 `figure` 对象，在每个图表对象上创建了三个散点圆圈标记，并创建了行布局。此行布局将以
    `figure` 对象作为输入，并使用 `show()` 函数绘制。我们也可以通过创建列布局来创建列布局，如下所示：
- en: '[PRE36]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This results in the following output:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致以下输出：
- en: '![](img/29f71614-53d2-476e-9730-20d151492716.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![](img/29f71614-53d2-476e-9730-20d151492716.png)'
- en: In the preceding plot, we have created the column layout of three plots. Let's
    jump to the nested layouts for more powerful visualizations.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们创建了三个图表的列布局。让我们跳转到嵌套布局，以进行更强大的可视化。
- en: Nested layout using row and column layouts
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用行和列布局进行嵌套布局
- en: 'A nested layout is the combination of multiple row and column layouts. Let''s
    see the example given here for a better practical understanding:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套布局是多行和列布局的组合。让我们看看这里给出的示例，以便更好地实际理解：
- en: '[PRE37]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This results in the following output:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致以下输出：
- en: '![](img/82bfd6df-4a0e-46fa-867d-f35c9bab4452.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![](img/82bfd6df-4a0e-46fa-867d-f35c9bab4452.png)'
- en: Here, you can see the row layout has two rows. In the first, `fig1` is assigned
    and the second row has the column layout of `fig2` and `fig3`. So, this layout
    becomes a 2*2 layout, in which the first column has only one component and the
    second column has two components.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以看到行布局有两行。在第一行中，分配了 `fig1`，第二行有 `fig2` 和 `fig3` 的列布局。因此，此布局变为2*2布局，第一列仅有一个组件，第二列有两个组件。
- en: Multiple plots
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多个图表
- en: 'Multiple plots and objects can also be created using a grid layout. A grid
    layout arranges the plots and widget objects in a row-column matrix fashion. It
    takes a list of figure objects for each row. We can also use `None` as a placeholder:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以使用网格布局创建多个图表和对象。网格布局以行列矩阵方式排列图表和小部件对象。它接受每行的图形对象列表。我们还可以使用 `None` 作为占位符：
- en: '[PRE38]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This results in the following output:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致以下输出：
- en: '![](img/845b71f3-3c3a-4be5-a056-6433d52f602e.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![](img/845b71f3-3c3a-4be5-a056-6433d52f602e.png)'
- en: The preceding layout is similar to the nested layout. Here, we have imported
    `gridplot()`. It arranges the components in rows and columns. The grid plot has
    taken a list of row figures. The first items in the list are `fig1` and `fig2`.
    The second items are `None` and `fig3`. Each item is a row in the grid matrix.
    The `None` placeholder is used to leave the cell empty or without components.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的布局类似于嵌套布局。这里，我们导入了 `gridplot()`。它将组件排列在行和列中。网格图采用一列行图。列表中的第一项是 `fig1` 和 `fig2`。第二项是
    `None` 和 `fig3`。每个项目都是网格矩阵中的一行。`None` 占位符用于使单元格保持空白或没有组件。
- en: 'Sizing modes can help us to configure figures with resizing options. Bokeh
    offers the following sizing modes:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 尺寸模式可以帮助我们配置具有可调整大小选项的图形。Bokeh 提供了以下尺寸模式：
- en: '`fixed`: This retains the same original width and height.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fixed`：保持原始宽度和高度不变。'
- en: '`stretch_width`: This stretches to the available width based on the type of
    the other component. It doesn''t maintain the aspect ratio.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stretch_width`：根据其他组件的类型，拉伸到可用宽度。它不保持纵横比。'
- en: '`stretch_height`: This stretches to the available height based on the type
    of the other component. It doesn''t maintain the aspect ratio.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stretch_height`：根据其他组件的类型，拉伸到可用高度。它不保持纵横比。'
- en: '`stretch_both`: This stretches both the width and height based on the type
    of the other component without maintaining the original aspect ratio.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stretch_both`：根据其他组件的类型，拉伸宽度和高度，同时不保持原始纵横比。'
- en: '`scale_width`: This stretches to the available width based on the type of the
    other component while maintaining the original aspect ratio.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scale_width`：根据其他组件的类型，拉伸到可用宽度，同时保持原始纵横比。'
- en: '`scale_height`: This stretches to the available height based on the type of
    the other component while maintaining the original aspect ratio.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scale_height`：根据其他组件的类型，拉伸到可用高度，同时保持原始纵横比。'
- en: '`scale_both`: This stretches both the width and height based on the type of
    the other component while maintaining the original aspect ratio.'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scale_both`：根据其他组件的类型，拉伸宽度和高度，同时保持原始纵横比。'
- en: After learning about layouts and multiple plots, it's time to learn about interactions
    for interactive visualizations.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了布局和多个图表之后，接下来是学习互动可视化的交互。
- en: Interactions
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 交互
- en: Bokeh offers interactive legends for runtime-actionable graphs. Legends can
    be hidden or muted by clicking on glyph plots. We can activate these modes by
    activating the `click_policy` property and clicking on the legend entry.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: Bokeh 提供了交互式图例，用于运行时可操作的图表。可以通过点击符号图表来隐藏或静音图例。我们可以通过激活`click_policy`属性并点击图例项来启用这些模式。
- en: Hide click policy
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 隐藏点击策略
- en: 'Hide click policy hides the desirable glyphs by clicking on the legend entry.
    Let''s see an example of a hide click policy:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 隐藏点击策略通过点击图例项来隐藏所需的符号。让我们看一个隐藏点击策略的例子：
- en: '[PRE39]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This results in the following output:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![](img/92f05d68-5e04-42b0-ad96-d38eab3ffddf.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![](img/92f05d68-5e04-42b0-ad96-d38eab3ffddf.png)'
- en: Here, we can set the click policy with the `legend.click_policy` parameter of
    the `figure` object. Also, we need to run a `for` loop of each type of glyph or
    legend element on which you click. In our example, we are running a `for` loop
    for types of species and colors. On the click of any species in the legend, it
    will filter the data and hide that glyph.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以通过`figure`对象的`legend.click_policy`参数设置点击策略。此外，我们需要对每种类型的符号或图例元素运行`for`循环，在这些元素上进行点击。在我们的示例中，我们正在为物种和颜色类型运行`for`循环。在点击图例中的任何物种时，它会过滤数据并隐藏该符号。
- en: Mute click policy
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 静音点击策略
- en: 'Mute click policy mutes the glyph by clicking on a legend entry. Here, the
    following code shows the desirable glyph with high intensity and uninteresting
    glyphs using lower intensity instead of hiding the whole glyph. Let''s see an
    example of a mute click policy:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 静音点击策略通过点击图例项来静音符号。在这里，以下代码显示了高强度的所需符号，而不感兴趣的符号则使用较低强度，而不是隐藏整个符号。让我们看一个静音点击策略的例子：
- en: '[PRE40]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This results in the following output:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![](img/bd36ff08-ab1a-46e0-adf1-31f3d6c9b06d.png)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bd36ff08-ab1a-46e0-adf1-31f3d6c9b06d.png)'
- en: Here, we can set the mute click policy with the `legend.click_policy` parameter
    to mute figure objects. Also, we need to run the `for` loop of each type of glyph
    or legend element on which you click. In our example, we are running a `for` loop
    for types of species and colors. On the click of any species in the legend, it
    will filter the data and hide that glyph. In addition to that, we need to add
    a `muted_color` and `muted_alpha` parameter to the scatter circle marker.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以通过`legend.click_policy`参数设置静音点击策略来静音图形对象。此外，我们需要对每种类型的符号或图例元素运行`for`循环，在这些元素上进行点击。在我们的示例中，我们正在为物种和颜色类型运行`for`循环。在点击图例中的任何物种时，它会过滤数据并隐藏该符号。此外，我们需要为散点圆形标记添加`muted_color`和`muted_alpha`参数。
- en: Annotations
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注解
- en: 'Bokeh offers several annotations for supplementary information for visualizations.
    It helps the viewer by adding the following information:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: Bokeh 提供了多种注解，用于为可视化提供补充信息。它通过添加以下信息来帮助查看者：
- en: '**Titles**: This annotation provides a name to the plot.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标题**：这个注释为图表提供一个名称。'
- en: '**Axis labels**: This annotation provides labels to the axis. It helps us to
    understand what the *x* and *y* axes represent.'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**轴标签**：这个注释为轴提供标签，帮助我们理解*x*轴和*y*轴表示的内容。'
- en: '**Legends**: This annotation represents the third variable via color or shape
    and helps us to link features for easy interpretations.'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图例**：这个注释通过颜色或形状表示第三个变量，并帮助我们将特征链接在一起，便于解释。'
- en: '**Color bars**: Color bars are created using ColorMapper with the color palette.'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**颜色条**：颜色条是通过使用ColorMapper和颜色调色板创建的。'
- en: 'Let''s see an annotation example:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个注释的例子：
- en: '[PRE41]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This results in the following output:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成以下输出：
- en: '![](img/99f04a92-7d11-4c2f-a442-afa85a769048.png)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![](img/99f04a92-7d11-4c2f-a442-afa85a769048.png)'
- en: In the preceding example, `CategoricalColorMapper` is imported and objects are
    created by defining factors or unique items in iris species and their respective
    colors. A color dictionary is created by defining the `field` and `transform`
    parameters for the mapper. We need to define the figure title; `x_axis_label`
    and `y_axis_label` were defined inside the `figure` object. The legend is defined
    in the circle scatter marker function with the species column and its location
    is defined using the location attribute of the `figure` object with `top_left`.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，导入了`CategoricalColorMapper`并通过定义鸢尾花品种中的因子或唯一项及其相应的颜色来创建对象。通过为映射器定义`field`和`transform`参数来创建颜色字典。我们需要定义图表的标题；`x_axis_label`和`y_axis_label`是在`figure`对象中定义的。图例是在圆形散点标记函数中定义的，使用品种列并通过`figure`对象的`top_left`位置属性定义其位置。
- en: Hover tool
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 悬停工具
- en: 'The hover tool shows the related information whenever the mouse pointer is
    placed over a particular area. Let''s see examples to understand the hovering
    plots:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 悬停工具会在鼠标指针悬停在特定区域时显示相关信息。让我们看一些例子来理解悬浮图：
- en: '[PRE42]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This results in the following output:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成以下输出：
- en: '![](img/ce8e8bfd-6bbd-42a0-a272-c6c1eb6649ac.png)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ce8e8bfd-6bbd-42a0-a272-c6c1eb6649ac.png)'
- en: In the preceding example, we have imported `HoverTool` from `bokeh.models` and
    created its object by defining the information that will be shown on mouse hover.
    In our example, we have defined information in the list of tuples. Each tuple
    has two arguments. The first is for the string label and the second is for the
    actual value (preceded with `@`). This hover object is passed into the `figure`
    object's `tools` parameter.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们从`bokeh.models`导入了`HoverTool`并通过定义在鼠标悬停时显示的信息来创建它的对象。在我们的例子中，我们在元组列表中定义了信息。每个元组有两个参数，第一个是字符串标签，第二个是实际值（前面加上`@`）。这个悬停对象被传递到`figure`对象的`tools`参数中。
- en: Widgets
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 小部件
- en: 'Widgets offer real-time interaction on the frontend. Widgets have the capability
    to modify and update plots at runtime. They can run either a Bokeh server or a
    standalone HTML application. For using widgets, you need to specify the functionality.
    It can be nested inside the layout. There are two approaches to add the functionality
    of widgets into the program:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 小部件提供了前端的实时交互。小部件能够在运行时修改和更新图表。它们可以运行Bokeh服务器或独立的HTML应用程序。使用小部件时，您需要指定功能。它可以嵌套在布局中。将小部件功能添加到程序中有两种方法：
- en: CustomJS callback
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CustomJS 回调
- en: With the Bokeh server and setup event handler, such as `onclick` or `onchange
    event`
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Bokeh服务器和设置事件处理程序，如`onclick`或`onchange`事件
- en: Tab panel
  id: totrans-271
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 标签面板
- en: 'Tab panes allow us to create multiple plots and layouts in a single window.
    Let''s see an example of a tab panel:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 标签面板使我们能够在一个窗口中创建多个图表和布局。让我们看一个标签面板的例子：
- en: '[PRE43]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This results in the following output:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成以下输出：
- en: '![](img/a5c7ec44-0173-496d-8875-107e55997926.png)![](img/9fa9fdce-f755-4953-b135-330127ac4787.png)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a5c7ec44-0173-496d-8875-107e55997926.png)![](img/9fa9fdce-f755-4953-b135-330127ac4787.png)'
- en: In the preceding code, we have created the two panels by passing `figure` objects
    to a child parameter and `title` to a `title` parameter to `Panel`. Both panels
    are combined into a list and passed to the `Tabs` layout object. This `Tabs` object
    is shown by the `show()` function. You can change the tab by just clicking on
    it.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们通过将`figure`对象传递给`child`参数，并将`title`传递给`title`参数，创建了两个面板。两个面板被组合成一个列表，并传递给`Tabs`布局对象。通过`show()`函数显示此`Tabs`对象。您只需点击标签即可更改标签。
- en: Slider
  id: totrans-277
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 滑块
- en: 'A slider is a graphical track bar that controls the value by moving it on a
    horizontal scale. We can change the values of the graph without affecting its
    formatting. Let''s see an example of a slider:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 滑块是一个图形化的轨迹条，它通过在水平刻度上移动来控制值。我们可以在不影响图表格式的情况下更改图表的值。让我们来看一个滑块的例子：
- en: '[PRE44]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This results in the following output:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![](img/547ca4f5-0d95-4dcb-bfa4-11ac83724d45.png)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![](img/547ca4f5-0d95-4dcb-bfa4-11ac83724d45.png)'
- en: In the preceding code, the Bokeh `slider()` function takes `start`, `end`, `value`,
    `step`, `title`, and CustomJS callback as input. In our example, we are creating
    a line graph and changing its `y` variable by the power of the `x` variable using
    the slide bar. We can create the slider by passing `start`, `end`, `value`, `step`,
    `title`, and a CustomJS callback to the `Slider` object. We need to focus on the
    CustomJS callback. It takes the source DataFrame, gets the value of the slider
    using `cb_obj.value`, and updates its values using the `change.emit()` function.
    We are updating `y_value` in the `for` loop by finding its power using the slider
    value.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，Bokeh的`slider()`函数接受`start`、`end`、`value`、`step`、`title`和CustomJS回调作为输入。在我们的例子中，我们创建了一个折线图，并通过滑动条根据`x`变量的幂来改变其`y`值。我们可以通过将`start`、`end`、`value`、`step`、`title`和CustomJS回调传递给`Slider`对象来创建滑块。我们需要关注CustomJS回调。它获取源数据框，通过`cb_obj.value`获取滑块的值，并使用`change.emit()`函数更新其值。我们在`for`循环中更新`y_value`，通过找到其幂次来使用滑块值。
- en: Summary
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we discussed visualizing data using plotting with Matplotlib,
    `pandas`, Seaborn, and Bokeh. We covered various plots, such as line plots, pie
    plots, bar plots, histograms, scatter plots, box plots, bubble charts, heatmaps,
    KDE plots, violin plots, count plots, joint plots, and pair plots. We focused
    on accessories for charts, such as titles, labels, legends, layouts, subplots,
    and annotations. Also, we learned about interactive visualization using Bokeh
    layouts, interactions, hover tools, and widgets.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了如何使用Matplotlib、`pandas`、Seaborn和Bokeh进行数据可视化。我们介绍了各种图表类型，如折线图、饼图、条形图、直方图、散点图、箱线图、气泡图、热图、KDE图、提琴图、计数图、联合图和配对图。我们重点介绍了图表的附加功能，如标题、标签、图例、布局、子图和注释。此外，我们还学习了使用Bokeh布局、交互、悬停工具和小部件进行交互式可视化。
- en: The next chapter, [Chapter 6](0a7bfc74-e20e-4613-949f-715cc06574aa.xhtml), *Retrieving,
    Processing, and Storing Data*, will teach us skills of data reading and writing
    from various sources such as files, objects, and relational and NoSQL databases.
    Although some people don't consider these skills for data analysis, an independent
    or assistant data analyst must know how they can fetch data from various file
    formats and databases for analysis purposes.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章，[第六章](0a7bfc74-e20e-4613-949f-715cc06574aa.xhtml)，*数据的检索、处理与存储*，将教授我们如何从各种来源（如文件、对象、关系型数据库和NoSQL数据库）读取和写入数据的技能。虽然有些人认为这些技能不适用于数据分析，但独立或辅助的数据分析师必须了解如何从不同的文件格式和数据库中获取数据用于分析。
