- en: Chapter 3. CQL Data Types
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 3 章。CQL 数据类型
- en: In this chapter, we will have an overview of Cassandra Query Language and take
    a detailed look into the wealthy set of data types supported by Cassandra. We
    will walk through the data types to study what their internal storage structure
    looks like. If you want to know how Cassandra implements them behind the scenes,
    the Java source code of Cassandra can be referenced. For those of you who have
    not installed and set up Cassandra, you can refer to [Chapter 5](ch05.html "Chapter 5. First-cut
    Design and Implementation"), *First-cut Design and Implementation*, for a quick
    procedure.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将概述 Cassandra 查询语言，并详细探讨 Cassandra 支持的丰富数据类型集。我们将遍历数据类型，研究它们的内部存储结构。如果您想了解
    Cassandra 在幕后如何实现它们，可以参考 Cassandra 的 Java 源代码。对于那些尚未安装和设置 Cassandra 的读者，您可以参考
    [第 5 章](ch05.html "第 5 章。初步设计和实现")，*初步设计和实现*，以获取快速流程。
- en: Introduction to CQL
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CQL 简介
- en: Cassandra introduced Cassandra Query Language (CQL) in release 0.8 as a SQL-like
    alternative to the traditional Thrift RPC API. As of the time of this writing,
    the latest CQL version is 3.1.7\. I do not want to take you through all of its
    old versions and therefore, I will focus on version 3.1.7 only. It should be noted
    that CQL Version 3 is not backward compatible with CQL Version 2 and differs from
    it in many ways.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Cassandra 在 0.8 版本中引入了 Cassandra 查询语言（CQL），作为传统 Thrift RPC API 的 SQL 类似替代品。截至本文撰写时，最新的
    CQL 版本是 3.1.7。我不想带你们回顾所有旧版本，因此，我将只关注 3.1.7 版本。需要注意的是，CQL 版本 3 与 CQL 版本 2 不兼容，并且在许多方面有所不同。
- en: CQL statements
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CQL 语句
- en: 'CQL Version 3 provides a model very similar to SQL. Conceptually, it uses a
    table to store data in rows of columns. It is composed of three main types of
    statements:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: CQL 版本 3 提供了一个与 SQL 非常相似的模式。从概念上讲，它使用表格以列的行来存储数据。它由三种主要类型的语句组成：
- en: '**Data definition statements**: These are used to set and change how data is
    stored in Cassandra'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据定义语句**：这些语句用于设置和更改数据在 Cassandra 中的存储方式'
- en: '**Data manipulation statements**: These are used to create, delete, and modify
    data'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据操作语句**：这些语句用于创建、删除和修改数据'
- en: '**Query statements**: These are used to look up data'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**查询语句**：这些语句用于查找数据'
- en: CQL is case insensitive, unless the word is enclosed in double quotation marks.
    It defines a list of keywords that have a fixed meaning for the language. It distinguishes
    between reserved and non-reserved keywords. **Reserved** keywords cannot be used
    as identifiers. They are truly reserved for the language. **Non-reserved** keywords
    only have a specific meaning in certain contexts but can be used as identifiers.
    The list of CQL keywords is shown in DataStax's documentation at [http://www.datastax.com/documentation/cql/3.1/cql/cql_reference/keywords_r.html](http://www.datastax.com/documentation/cql/3.1/cql/cql_reference/keywords_r.html).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: CQL 不区分大小写，除非单词被双引号包围。它定义了一系列具有固定语言意义的保留词。它区分了保留词和非保留词。**保留**词不能用作标识符。它们确实是保留给语言的。**非保留**词仅在特定上下文中具有特定意义，但可以用作标识符。CQL
    关键词列表可以在 DataStax 的文档中找到，网址为 [http://www.datastax.com/documentation/cql/3.1/cql/cql_reference/keywords_r.html](http://www.datastax.com/documentation/cql/3.1/cql/cql_reference/keywords_r.html)。
- en: CQL command-line client – cqlsh
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CQL 命令行客户端 – cqlsh
- en: 'Cassandra bundles an interactive terminal supporting CQL, known as `cqlsh`.
    It is a Python-based command-line client used to run CQL commands. To start `cqlsh`,
    navigate to Cassandra''s `bin` directory and type the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Cassandra 包含了一个支持 CQL 的交互式终端，称为 `cqlsh`。它是一个基于 Python 的命令行客户端，用于运行 CQL 命令。要启动
    `cqlsh`，请导航到 Cassandra 的 `bin` 目录并输入以下命令：
- en: On Linux, type `./cqlsh`
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Linux 上，输入 `./cqlsh`
- en: On Windows, type `cqlsh.bat` or `python cqlsh`
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Windows 上，输入 `cqlsh.bat` 或 `python cqlsh`
- en: 'As shown in the following figure, `cqlsh` shows the cluster name, Cassandra,
    CQL, and Thrift protocol versions on startup:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下图所示，`cqlsh` 在启动时显示集群名称、Cassandra、CQL 和 Thrift 协议版本：
- en: '![CQL command-line client – cqlsh](img/8884OS_03_01.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![CQL 命令行客户端 – cqlsh](img/8884OS_03_01.jpg)'
- en: cqlsh connected to the Cassandra instance running on the local node
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: cqlsh 连接到本地节点上运行的 Cassandra 实例
- en: We can use `cqlsh` to connect to other nodes by appending the host (either hostname
    or IP address) and port as command-line parameters.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `cqlsh` 通过附加主机（无论是主机名还是 IP 地址）和端口号作为命令行参数来连接到其他节点。
- en: If we want to create a keyspace called `packt` using `SimpleStrategy` (which
    will be explained in [Chapter 6](ch06.html "Chapter 6. Enhancing a Version"),
    *Enhancing a Version*) as its replication strategy and setting the replication
    factor as one for a single-node Cassandra cluster, we can type the CQL statement,
    shown in the following screenshot, in `cqlsh`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想使用 `SimpleStrategy`（将在第 6 章“增强版本”中解释）作为其复制策略，并设置单个节点 Cassandra 集群的复制因子为
    1 来创建一个名为 `packt` 的 keyspace，我们可以在 `cqlsh` 中输入以下截图所示的 CQL 语句。
- en: 'This utility will be used extensively in this book to demonstrate how to use
    CQL to define the Cassandra data model:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本书将广泛使用此实用程序来演示如何使用 CQL 定义 Cassandra 数据模型：
- en: '![CQL command-line client – cqlsh](img/8884OS_03_02.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![CQL 命令行客户端 – cqlsh](img/8884OS_03_02.jpg)'
- en: Create keyspace packt in cqlsh
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在 cqlsh 中创建 keyspace packt
- en: Tip
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Downloading the example code**'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)and
    register to have the files e-mailed directly to you.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从您在 [http://www.packtpub.com](http://www.packtpub.com) 的账户下载您购买的所有 Packt
    书籍的示例代码文件。如果您在其他地方购买了这本书，您可以访问 [http://www.packtpub.com/support](http://www.packtpub.com/support)
    并注册，以便将文件直接通过电子邮件发送给您。
- en: Native data types
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原生数据类型
- en: 'CQL Version 3 supports many basic data types for columns. It also supports
    collection types and all data types available to Cassandra. The following table
    lists the supported basic data types and their corresponding meanings:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: CQL 版本 3 支持许多基本的列数据类型。它还支持集合类型和 Cassandra 可用的所有数据类型。以下表格列出了支持的基本数据类型及其对应含义：
- en: '| Type | Description |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 描述 |'
- en: '| --- | --- |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| ascii | ASCII character string |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| ascii | ASCII 字符串 |'
- en: '| bigint | 64-bit signed long |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| bigint | 64 位有符号长整型 |'
- en: '| blob | Arbitrary bytes (no validation) |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| blob | 随意字节（无验证）|'
- en: '| Boolean | `True` or `False` |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| Boolean | `True` 或 `False` |'
- en: '| counter | Counter column (64-bit signed value) |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| counter | 计数列（64 位有符号值）|'
- en: '| decimal | Variable-precision decimal |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| decimal | 可变精度十进制数 |'
- en: '| double | 64-bit IEEE 754 floating point |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| double | 64 位 IEEE 754 浮点数 |'
- en: '| float | 32-bit IEEE 754 floating point |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| float | 32 位 IEEE 754 浮点数 |'
- en: '| inet | An IP address that can be either 4 bytes long (IPv4) or 16 bytes long
    (IPv6) and should be inputted as a string |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| inet | 可以是 4 字节长（IPv4）或 16 字节长（IPv6）的 IP 地址，应作为字符串输入 |'
- en: '| int | 32-bit signed integer |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| int | 32 位有符号整数 |'
- en: '| text | UTF8 encoded string |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| text | UTF8 编码的字符串 |'
- en: '| timestamp | A timestamp in which string constants are allowed to input timestamps
    as dates |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| timestamp | 允许输入日期的字符串常量时间戳 |'
- en: '| timeuuid | Type 1 UUID that is generally used as a "conflict-free" timestamp
    |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| timeuuid | 通常用作“无冲突”时间戳的类型 1 UUID |'
- en: '| uuid | Type 1 or type 4 UUID |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| uuid | 类型 1 或类型 4 UUID |'
- en: '| varchar | UTF8-encoded string |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| varchar | UTF8 编码的字符串 |'
- en: '| varint | Arbitrary-precision integer |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| varint | 可变精度整型 |'
- en: Table 1\. CQL Version 3 basic data types
  id: totrans-45
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 表 1. CQL 版本 3 基本数据类型
- en: Cassandra implementation
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Cassandra 实现
- en: 'If we look into the Cassandra''s Java source code, the CQL Version 3 native
    data types are declared in an `enum` called `Native` in the `org.apache.cassandra.cql3.CQL3Type`
    interface, as shown in the following screenshot:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看 Cassandra 的 Java 源代码，CQL 版本 3 的原生数据类型在 `org.apache.cassandra.cql3.CQL3Type`
    接口中的 `Native` `enum` 中声明，如下截图所示：
- en: '![Cassandra implementation](img/8884OS_03_03.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![Cassandra 实现](img/8884OS_03_03.jpg)'
- en: Cassandra source code declaring CQL Version 3 native data types
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 声明 CQL 版本 3 原生数据类型的 Cassandra 源代码
- en: It is interesting to know that `TEXT` and `VARCHAR` are indeed both `UTF8Type`.
    The Java classes of `AsciiType`, `LongType`, `BytesType`, `DecimalType`, and so
    on are declared in the `org.apache.cassandra.db.marshal` package.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，`TEXT` 和 `VARCHAR` 确实都是 `UTF8Type`。`AsciiType`、`LongType`、`BytesType`、`DecimalType`
    等类的 Java 类在 `org.apache.cassandra.db.marshal` 包中声明。
- en: Note
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Cassandra source code is available on GitHub at [https://github.com/apache/cassandra](https://github.com/apache/cassandra).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Cassandra 源代码可在 GitHub 上找到，网址为 [https://github.com/apache/cassandra](https://github.com/apache/cassandra)。
- en: Knowing the Java implementation of the native data types allows us to have a
    deeper understanding of how Cassandra handles them. For example, Cassandra uses
    the `org.apache.cassandra.serializers.InetAddressSerializer` class and `java.net.InetAddress`
    class to handle the serialization/deserialization of the `INET` data type.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 了解原生数据类型的Java实现，使我们能够更深入地理解Cassandra如何处理它们。例如，Cassandra使用`org.apache.cassandra.serializers.InetAddressSerializer`类和`java.net.InetAddress`类来处理`INET`数据类型的序列化和反序列化。
- en: A not-so-long example
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个不太长的例子
- en: 'These native data types are used in CQL statements to specify the type of data
    to be stored in a column of a table. Now let us create an experimental table with
    columns of each native data type (except counter type since it requires a separate
    table), and then insert some data into it. We need to specify the keyspace, `packt`
    in this example, before creating the table called `table01`, as shown in the following
    screenshot:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这些原生数据类型用于CQL语句中，以指定要存储在表列中的数据类型。现在让我们创建一个实验性表，其中包含每种原生数据类型的列（除了计数器类型，因为它需要一个单独的表），然后向其中插入一些数据。在创建名为`table01`的表之前，我们需要指定键空间，在这个例子中是`packt`，如下截图所示：
- en: '![A not-so-long example](img/8884OS_03_04.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![一个不太长的例子](img/8884OS_03_04.jpg)'
- en: Create table01 to illustrate each native data type
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`table01`以说明每种原生数据类型
- en: 'We create the table using the default values, but, there are other options
    to configure the new table for optimizations, including compaction, compression,
    failure handling, and so on. The `PRIMARY KEY` clause, which is on only one column,
    could also be specified along with an attribute, that is, `rowkey ascii PRIMARY
    KEY`. Then insert a sample record into `table01`. We make it with an `INSERT`
    statement, as shown in the following screenshot:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用默认值创建表，但还有其他选项可以配置新表以进行优化，包括压缩、压缩、故障处理等。只有一个列的`PRIMARY KEY`子句也可以指定，即`rowkey
    ascii PRIMARY KEY`。然后向`table01`插入一个样本记录。我们使用`INSERT`语句来完成，如下截图所示：
- en: '![A not-so-long example](img/8884OS_03_05.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![一个不太长的例子](img/8884OS_03_05.jpg)'
- en: Insert a sample record into table01
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 向`table01`插入一个样本记录
- en: We now have data inside `table01`. We use `cqlsh` to query the table. For the
    sake of comparison, we also use another Cassandra command-line tool called Cassandra
    CLI to have a low-level view of the row. Let us open Cassandra CLI on a terminal.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在在`table01`中有数据。我们使用`cqlsh`来查询表。为了比较，我们还使用另一个名为Cassandra CLI的Cassandra命令行工具，以获得对行的底层视图。让我们在终端上打开Cassandra
    CLI。
- en: Note
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Cassandra CLI utility**'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**Cassandra CLI实用工具**'
- en: 'Cassandra CLI is used to set storage configuration attributes on a per-keyspace
    or per-table basis. To start it up, you navigate to Cassandra bin directory and
    type the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Cassandra CLI用于在单个键空间或单个表的基础上设置存储配置属性。要启动它，您需要导航到Cassandra bin目录并输入以下命令：
- en: On Linux, `./cassandra-cli`
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Linux上，`./cassandra-cli`
- en: On Windows, `cassandra.bat`
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Windows上，`cassandra.bat`
- en: Note that it was announced to be deprecated in Cassandra 3.0 and `cqlsh` should
    be used instead.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，它在Cassandra 3.0中被宣布为已弃用，应使用`cqlsh`代替。
- en: 'The results of the `SELECT` statement in `cqlsh` and the `list` command in
    Cassandra CLI are shown in the following screenshot. We will then walk through
    each column one by one:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了`cqlsh`中的`SELECT`语句和Cassandra CLI中的`list`命令的结果。然后我们将逐列进行说明：
- en: '![A not-so-long example](img/8884OS_03_06.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![一个不太长的例子](img/8884OS_03_06.jpg)'
- en: Comparison of the sample row in cqlsh and Cassandra CLI
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: cqlsh和Cassandra CLI中样本行的比较
- en: ASCII
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ASCII
- en: Internally, a data value `'ABC'` is stored as the byte values in hexadecimal
    representation of each individual character, `'A'`, `'B'`, and `'C'` as `0x41`,
    `0x42`, and `0x43` respectively.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，数据值`'ABC'`被存储为每个单独字符的十六进制表示的字节值，`'A'`、`'B'`和`'C'`分别表示为`0x41`、`0x42`和`0x43`。
- en: Bigint
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Bigint
- en: This one is simple; the hexadecimal representation of the number `1000000000`
    is `0x000000003b9aca00` of 64-bit length stored internally.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这个很简单；数字`1000000000`的十六进制表示为`0x000000003b9aca00`，长度为64位，内部存储。
- en: BLOB
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: BLOB
- en: A `BLOB` data type is used to store a large binary object. In our previous example,
    we inserted a text `'ABC'` as a `BLOB` into the `blobfield`. The internal representation
    is `414243`, which is just a stream of bytes in hexadecimal representation.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`BLOB`数据类型用于存储大型二进制对象。在我们之前的例子中，我们将文本`''ABC''`作为`BLOB`插入到`blobfield`中。其内部表示为`414243`，这只是一个十六进制表示的字节流。'
- en: Obviously, a `BLOB` field can accept all kinds of data, and because of this
    flexibility it cannot have validation on its data value. For example, a data value
    `2` may be interpreted as either an integer `2` or a text `'2'`. Without knowing
    the interpretation we want, a `BLOB` field can impose a check on the data value.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，`BLOB` 字段可以接受各种数据，正因为这种灵活性，它不能对其数据值进行验证。例如，数据值 `2` 可以解释为整数 `2` 或文本 `'2'`。如果不了解我们想要的解释，`BLOB`
    字段可以对数据值进行检查。
- en: Another interesting point of a `BLOB` field is that, as shown in the `SELECT`
    statement in the previous screenshot in `cqlsh`, the data value of `blobfield`
    returned is `0x414243` for `'ABC'` text. We know from the previous section that
    `0x41`, `0x42`, `0x43` are the byte values of `'A'`, `'B'`, and `'C'`, respectively.
    However, for a `BLOB` field, `cqlsh` prefixes its data value with `'0x'` to make
    it a so-called BLOB constant. A BLOB constant is a sequence of bytes in their
    hexadecimal values prefixed by `0[xX](hex)+` where `hex` is a hexadecimal character,
    such as `[0-9a-fA-F]`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`BLOB` 字段的另一个有趣之处在于，如前一个截图中的 `cqlsh` 中的 `SELECT` 语句所示，返回的 `blobfield` 数据值对于
    `''ABC''` 文本来说是 `0x414243`。我们知道从上一个部分，`0x41`、`0x42`、`0x43` 分别是 `''A''`、`''B''`
    和 `''C''` 的字节值。然而，对于 `BLOB` 字段，`cqlsh` 在其数据值前加上 `''0x''`，使其成为一个所谓的 BLOB 常量。BLOB
    常量是一系列字节，它们的十六进制值以 `0[xX](hex)+` 开头，其中 `hex` 是一个十六进制字符，例如 `[0-9a-fA-F]`。'
- en: CQL also provides a number of `BLOB` conversion functions to convert native
    data types into a `BLOB` and vice versa. For every `<native-type>` (except `BLOB`
    for an obvious reason) supported by CQL, the `<native-type>AsBlob` function takes
    an argument of type `<native-type>` and returns it as a `BLOB`. Contrarily, the
    `blobAs<Native-type>` function reverses the conversion from a `BLOB` back to a
    `<native-type>`. As demonstrated in the `INSERT` statement, we have used `textAsBlob()`
    to convert a `text` data type into a `BLOB`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: CQL 还提供了一些 `BLOB` 转换函数，用于将原生数据类型转换为 `BLOB`，反之亦然。对于 CQL 支持的每个 `<native-type>`（除了
    `BLOB`，原因很明显），`<native-type>AsBlob` 函数接受一个 `<native-type>` 类型的参数，并将其作为 `BLOB`
    返回。相反，`blobAs<Native-type>` 函数将 `BLOB` 转换回 `<native-type>`。如前一个截图中的 `INSERT` 语句所示，我们使用了
    `textAsBlob()` 将 `text` 数据类型转换为 `BLOB`。
- en: Note
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**BLOB constant**'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**BLOB 常量**'
- en: BLOB constants were introduced in CQL version 3.0.2 to allow users to input
    `BLOB` values. In older versions of CQL, inputting `BLOB` as string was supported
    for convenience. It is now deprecated and will be removed in a future version.
    It is still supported only to allow smoother transition to a `BLOB` constant.
    Updating the client code to switch to `BLOB` constants should be done as soon
    as possible.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: BLOB 常量是在 CQL 版本 3.0.2 中引入的，以便用户输入 `BLOB` 值。在 CQL 的旧版本中，为了方便起见，支持将 `BLOB` 作为字符串输入。现在这已被弃用，并将在未来版本中删除。它仍然被支持，只是为了允许更平滑地过渡到
    `BLOB` 常量。尽快更新客户端代码以切换到 `BLOB` 常量是必要的。
- en: Boolean
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布尔值
- en: A `boolean` data type is also very intuitive. It is merely a single byte of
    either `0x00`, which means `False`, or `0x01`, which means `True`, in the internal
    storage.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`boolean` 数据类型也非常直观。它仅仅是内部存储中的一个字节，可以是 `0x00`，表示 `False`，或者 `0x01`，表示 `True`。'
- en: Decimal
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 十进制
- en: A `decimal` data type can store a variable-precision decimal, basically a `BigDecimal`
    data type in Java.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`decimal` 数据类型可以存储可变精度的十进制数，基本上是 Java 中的 `BigDecimal` 数据类型。'
- en: Double
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 双精度
- en: The `double` data type is a double-precision 64-bit IEEE 754 floating point
    in its internal storage.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`double` 数据类型在其内部存储中是一个双精度 64 位 IEEE 754 浮点数。'
- en: Float
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 浮点数
- en: The `float` data type is a single-precision 32-bit IEEE 754 floating point in
    its internal storage.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`float` 数据类型在其内部存储中是一个单精度 32 位 IEEE 754 浮点数。'
- en: Note
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**BigDecimal, double, or float?**'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**BigDecimal、double 或 float？**'
- en: The difference between `double` and `float` is obviously the length of precision
    in the floating point value. Both `double` and `float` use binary representation
    of decimal numbers with a radix which is in many cases an approximation, not an
    absolute value. `double` is a 64-bit value while `float` is an even shorter 32-bit
    value. Therefore, we can say that double is more precise than float. However,
    in both cases, there is still a possibility of loss of precision which can be
    very noticeable when working with either very big numbers or very small numbers.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`double` 和 `float` 之间的区别显然是浮点数值的精度长度。`double` 和 `float` 都使用十进制数的二进制表示，其基数在很多情况下是一个近似值，而不是一个绝对值。`double`
    是一个 64 位值，而 `float` 是一个更短的 32 位值。因此，我们可以说 `double` 比浮点数更精确。然而，在这两种情况下，仍然存在精度损失的可能性，这在处理非常大的数字或非常小的数字时可能会非常明显。'
- en: On the contrary, `BigDecimal` is devised to overcome this loss of precision
    discrepancy. It is an exact way of representing numbers. Its disadvantage is slower
    runtime performance.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，`BigDecimal`是为了克服这种精度差异的损失而设计的。它是一种精确表示数字的方式。它的缺点是运行时性能较慢。
- en: Whenever you are dealing with money or precision is a must, `BigDecimal` is
    the best choice (or `decimal` in CQL native data types), otherwise `double` or
    `float` should be good enough.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 无论何时你处理金钱或精度是必须的，`BigDecimal`是最好的选择（或在CQL原生数据类型中为`decimal`），否则`double`或`float`应该足够好。
- en: Inet
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Inet
- en: The `inet` data type is designed for storing IP address values in **IP Version
    4** (**IPv4**) and **IP Version 6** (**IPv6**) format. The IP address, `192.168.0.1`,
    in the example record is stored as four bytes internally; `192` is stored as `0xc0`,
    `168` as `0xa8`, `0` as `0x00`, and `1` as `0x01`, respectively. It should be
    noted that regardless of the IP address being stored is IPv4 or IPv6, the port
    number is *not* stored. We need another column to store it if required.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`inet`数据类型是为了存储**IP版本4**（**IPv4**）和**IP版本6**（**IPv6**）格式的IP地址值而设计的。示例记录中的IP地址`192.168.0.1`在内部存储时被表示为四个字节；`192`被存储为`0xc0`，`168`为`0xa8`，`0`为`0x00`，`1`为`0x01`，分别。需要注意的是，无论存储的IP地址是IPv4还是IPv6，端口号都没有存储。如果需要，我们需要另一个列来存储它。'
- en: 'We can also store an IPv6 address value. The following `UPDATE` statement changes
    the `inetfield` to an IPv6 address `2001:0db8:85a3:0042:1000:8a2e:0370:7334`,
    as shown in the following screenshot:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以存储IPv6地址值。以下`UPDATE`语句将`inetfield`更改为IPv6地址`2001:0db8:85a3:0042:1000:8a2e:0370:7334`，如下面的截图所示：
- en: '![Inet](img/8884OS_03_07.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![Inet](img/8884OS_03_07.jpg)'
- en: Comparison of the sample row in cqlsh and Cassandra CLI in inetfield
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: cqlsh和Cassandra CLI中inetfield样本行的比较
- en: Note
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Note
- en: '**Internet Protocol Version 6**'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**互联网协议版本6**'
- en: Internet Protocol Version 6 (IPv6) is the latest version of the **Internet Protocol**
    (**IP**). It was developed by the IETF to deal with the long-anticipated problem
    of IPv4 address exhaustion.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网协议版本6（IPv6）是**互联网协议**（**IP**）的最新版本。它是由IETF开发的，以解决IPv4地址耗尽这一长期预期的难题。
- en: IPv6 uses a 128-bit address whereas IPv4 uses 32-bit address. The two protocols
    are not designed to be interoperable, making the transition to IPv6 complicated.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6使用128位地址，而IPv4使用32位地址。这两个协议不是为互操作性设计的，这使得向IPv6的过渡变得复杂。
- en: IPv6 addresses are usually represented as eight groups of four hexadecimal digits
    separated by colons, such as `2001:0db8:85a3:0042:1000:8a2e:0370:7334`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6地址通常表示为用冒号分隔的八组每组四个十六进制数字，例如`2001:0db8:85a3:0042:1000:8a2e:0370:7334`。
- en: In `cqlsh`, the leading zeros of each group of four hexadecimal digits are removed.
    In Cassandra's internal storage, the IPv6 address value consumes 16 bytes.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在`cqlsh`中，每组四个十六进制数字的前导零被移除。在Cassandra的内部存储中，IPv6地址值占用16字节。
- en: Int
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Int
- en: The `int` data type is a primitive 32-bit signed integer.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`int`数据类型是一个原始的32位有符号整数。'
- en: Text
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Text
- en: 'The `text` data type is a UTF-8 encoded string accepting Unicode characters.
    As shown previously, the byte values of "`ABC`", `0x41`, `0x42`, and `0x43`, are
    stored internally. We can test the `text` field with non-ASCII characters by updating
    the `textfield` as shown in the following screenshot:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`text`数据类型是一个UTF-8编码的字符串，接受Unicode字符。如前所述，"`ABC`"的字节值`0x41`、`0x42`和`0x43`被内部存储。我们可以通过更新`textfield`来测试`text`字段中的非ASCII字符，如下面的截图所示：'
- en: The `text` data type is a combination of non-ASCII and ASCII characters. The
    four non-ASCII characters are represented as their 3-byte UTF-8 values, `0xe8b584`,
    `0xe6ba90`, `0xe68f90`, and `0xe4be9b`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`text`数据类型是由非ASCII和ASCII字符组合而成的。四个非ASCII字符被表示为它们的3字节UTF-8值，分别是`0xe8b584`、`0xe6ba90`、`0xe68f90`和`0xe4be9b`。'
- en: 'However, the ASCII characters are still stored as byte values, as shown in
    the screenshot:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，ASCII字符仍然以字节值存储，如截图所示：
- en: '![Text](img/8884OS_03_08.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![Text](img/8884OS_03_08.jpg)'
- en: Experiment of the textfield data type
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: textfield数据类型的实验
- en: Timestamp
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 时间戳
- en: 'The value of the `timestampfield` is encoded as a 64-bit signed integer representing
    a number of milliseconds since the standard base time known as the *epoch*: January
    1, 1970, at 00:00:00 GMT. A `timestamp` data type can be entered as an integer
    for CQL input, or as a string literal in ISO 8601 formats. As shown in the following
    screenshot, the internal value of May 1, 2014, 16:02:03, in the +08:00 timezone
    is `0x00000145b6cdf878` or 1,398,931,323,000 milliseconds since the epoch:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`timestampfield`的值编码为一个64位有符号整数，表示自称为“纪元”的标准基准时间以来的毫秒数：1970年1月1日00:00:00 GMT。`timestamp`数据类型可以作为整数用于CQL输入，或作为ISO
    8601格式的字符串字面量。如下面的屏幕截图所示，2014年5月1日16:02:03在+08:00时区内的内部值为`0x00000145b6cdf878`或自纪元以来的1,398,931,323,000毫秒：'
- en: '![Timestamp](img/8884OS_03_13.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![时间戳](img/8884OS_03_13.jpg)'
- en: Experiment of the timestamp data type
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 时间戳数据类型的实验
- en: A `timestamp` data type contains a date portion and a time portion in which
    the time of the day can be omitted if only the value of the date is wanted. Cassandra
    will use 00:00:00 as the default for the omitted time of day.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`timestamp`数据类型包含一个日期部分和一个时间部分，如果只需要日期值，则可以省略一天中的时间。Cassandra将使用00:00:00作为省略时间部分的默认值。'
- en: Note
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**ISO 8601**'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**ISO 8601**'
- en: ISO 8601 is the international standard for representation of dates and times.
    Its full reference number is ISO 8601:1988 (E), and its title is "Data elements
    and interchange formats – Information interchange – Representation of dates and
    times."
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: ISO 8601是表示日期和时间的国际标准。其完整的参考编号是ISO 8601:1988（E），其标题为“数据元素和交换格式 – 信息交换 – 日期和时间的表示。”
- en: ISO 8601 describes a large number of date/time formats depending on the desired
    level of granularity. The formats are as follows. Note that the "T" appears literally
    in the string to indicate the beginning of the time element.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: ISO 8601根据所需的粒度级别描述了大量的日期/时间格式。格式如下。请注意，“T”在字符串中字面表示时间元素的开始。
- en: 'Year: YYYY (e.g. 1997)'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 年份：YYYY（例如，1997）
- en: 'Year and month: YYYY-MM (e.g. 1997-07)'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 年和月：YYYY-MM（例如，1997-07）
- en: 'Date: YYYY-MM-DD (e.g. 1997-07-16)'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日期：YYYY-MM-DD（例如，1997-07-16）
- en: 'Date plus hours and minutes: YYYY-MM-DDThh:mmTZD (e.g. 1997-07-16T19:20+01:00)'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日期加上小时和分钟：YYYY-MM-DDThh:mmTZD（例如，1997-07-16T19:20+01:00）
- en: 'Date plus hours, minutes and seconds: YYYY-MM-DDThh:mm:ssTZD (e.g. 1997-07-16T19:20:30+01:00)'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日期加上小时、分钟和秒：YYYY-MM-DDThh:mm:ssTZD（例如，1997-07-16T19:20:30+01:00）
- en: 'Date plus hours, minutes, seconds and a decimal fraction of a second: YYYY-MM-DDThh:mm:ss.sTZD
    (e.g. 1997-07-16T19:20:30.45+01:00)'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日期加上小时、分钟、秒和秒的十进制分数：YYYY-MM-DDThh:mm:ss.sTZD（例如，1997-07-16T19:20:30.45+01:00）
- en: 'Where:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 其中：
- en: YYYY = four-digit year
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: YYYY = 四位年份
- en: MM = two-digit month (01=January, etc.)
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MM = 月份的两位数字（01=一月，等等）
- en: DD = two-digit day of month (01 through 31)
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DD = 月份的两位数字（01至31）
- en: hh = two digits of hour (00 through 23) (am/pm NOT allowed)
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: hh = 小时的两位数字（00至23）（不允许am/pm）
- en: mm = two digits of minute (00 through 59)
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: mm = 分钟的两位数字（00至59）
- en: ss = two digits of second (00 through 59)
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ss = 秒的两位数字（00至59）
- en: s = one or more digits representing a decimal fraction of a second
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: s = 表示秒的十进制分数的一个或多个数字
- en: TZD = time zone designator (Z or +hh:mm or -hh:mm)
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TZD = 时区标识符（Z或+hh:mm或-hh:mm）
- en: Times are expressed either in **Coordinated Universal Time** (**UTC**) with
    a special UTC designator "Z" or in local time together with a time zone offset
    in hours and minutes. A time zone offset of "+/-hh:mm" indicates the use of a
    local time zone which is "hh" hours and "mm" minutes ahead/behind of UTC.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 时间可以表示为**协调世界时**（**UTC**）与特殊的UTC标识符“Z”或与小时和分钟的时区偏移量一起表示的本地时间。偏移量“+/-hh:mm”表示使用一个本地时区，该时区比UTC快“hh”小时和“mm”分钟或慢“hh”小时和“mm”分钟。
- en: If no time zone is specified, the time zone of the Cassandra coordinator node
    handing the write request is used. Therefore the best practice is to specify the
    time zone with the timestamp rather than relying on the time zone configured on
    the Cassandra nodes to avoid any ambiguities.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未指定时区，则使用处理写请求的Cassandra协调节点所在的时区。因此，最佳实践是使用时间戳指定时区，而不是依赖于Cassandra节点上配置的时区，以避免任何歧义。
- en: Timeuuid
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Timeuuid
- en: A value of the `timeuuid` data type is a Type 1 UUID which includes the time
    of its generation and is sorted by timestamp. It is therefore ideal for use in
    applications requiring conflict-free timestamps. A valid `timeuuid` uses the time
    in 100 intervals since 00:00:00.00 UTC (60 bits), a clock sequence number for
    prevention of duplicates (14 bits), and the IEEE 801 MAC address (48 bits) to
    generate a unique identifier, for example, `74754ac0-e13f-11e3-a8a3-a92bc9056ee6`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`timeuuid` 数据类型的值是一个包含其生成时间的Type 1 UUID，并按时间戳排序。因此，它非常适合需要无冲突时间戳的应用程序。一个有效的
    `timeuuid` 使用自00:00:00.00 UTC以来100个时间间隔的时间（60位），用于防止重复的时钟序列号（14位），以及IEEE 801 MAC地址（48位）来生成一个唯一的标识符，例如，`74754ac0-e13f-11e3-a8a3-a92bc9056ee6`。'
- en: 'CQL v3 offers a number of functions to make the manipulation of `timeuuid`
    handy:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: CQL v3 提供了多个函数，使 `timeuuid` 的操作变得方便：
- en: '**dateOf()**: This is used in a `SELECT` statement to extract the timestamp
    portion of a `timeuuid` column'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**dateOf()**：在 `SELECT` 语句中使用，用于提取 `timeuuid` 列的时间戳部分'
- en: '**now()**: This is used to generate a new unique `timeuuid`'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**now()**：用于生成一个新的唯一 `timeuuid`'
- en: '**minTimeuuid() and maxTimeuuid()**: These are used to return a result similar
    to a UUID given a conditional time component as its argument'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**minTimeuuid() 和 maxTimeuuid()**：这些用于根据条件时间组件作为其参数返回类似于UUID的结果'
- en: '**unixTimestampOf()**: This is used in a `SELECT` statement to extract the
    timestamp portion as a raw 64-bit integer timestamp of a `timeuuid` column'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**unixTimestampOf()**：在 `SELECT` 语句中使用，用于提取 `timeuuid` 列的时间戳部分作为原始的64位整数时间戳'
- en: 'The following figure uses `timeuuidfield` of `table01` to demonstrate the usage
    of these `timeuuid` functions:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 下图使用 `table01` 的 `timeuuidfield` 来演示这些 `timeuuid` 函数的使用：
- en: '![Timeuuid](img/8884OS_03_09.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![Timeuuid](img/8884OS_03_09.jpg)'
- en: Demonstration of timeuuid functions
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 时间UUID函数的演示
- en: Note
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Timestamp or Timeuuid?**'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**Timestamp 或 Timeuuid？**'
- en: Timestamp is suitable for storing date and time values. TimeUUID, however, is
    more suitable in those cases where a conflict free, unique timestamp is needed.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 时间戳适合存储日期和时间值。然而，在需要无冲突的唯一时间戳的情况下，时间UUID更为合适。
- en: UUID
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UUID
- en: The `UUID` data type is usually used to avoid collisions in values. It is a
    16-byte value that accepts a type 1 or type 4 UUID. CQL v3.1.6 or later versions
    provide a function called `uuid()` to easily generate random type 4 UUID values.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`UUID` 数据类型通常用于避免值冲突。它是一个16字节的值，接受类型1或类型4 UUID。CQL v3.1.6或更高版本提供了一个名为 `uuid()`
    的函数，可以轻松生成随机的类型4 UUID值。'
- en: Note
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Type 1 or type 4 UUID?**'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '**Type 1 或 type 4 UUID？**'
- en: Type 1 uses the MAC address of the computer that is generating the `UUID` data
    type and the number of 100-nanosecond intervals since the adoption of the Gregorian
    calendar, to generate UUIDs. Its uniqueness across computers is guaranteed if
    MAC addresses are not duplicated; however, given the speed of modern processors,
    successive invocations on the same machine of a naive implementation of a type
    1 generator might produce the same `UUID`, negating the property of uniqueness.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Type 1 使用生成 `UUID` 数据类型的计算机的MAC地址和自公历采用以来100纳秒间隔的数量来生成UUID。如果MAC地址没有重复，则保证跨计算机的唯一性；然而，考虑到现代处理器的速度，同一机器上对类型1生成器的简单实现进行连续调用可能会产生相同的
    `UUID`，从而否定唯一性的属性。
- en: Type 4 uses random or pseudorandom numbers. Therefore, it is the recommended
    type of `UUID` to be used.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Type 4 使用随机数或伪随机数。因此，它是推荐的 `UUID` 类型。
- en: Varchar
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Varchar
- en: Basically `varchar` is identical to `text` as evident by the same `UTF8Type`
    in the source code.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，`varchar` 与 `text` 相同，这在源代码中相同的 `UTF8Type` 中可以明显看出。
- en: Varint
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Varint
- en: A `varint` data type is used to store integers of arbitrary precision.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `varint` 数据类型来存储任意精度的整数。
- en: Counter
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Counter
- en: A `counter` data type is a special kind of column whose user-visible value is
    a 64-bit signed integer (though this is more complex internally) used to store
    a number that incrementally counts the occurrences of a particular event. When
    a new value is written to a given counter column, it is added to the previous
    value of the counter.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`counter` 数据类型是一种特殊的列，其用户可见的值是一个64位有符号整数（尽管在内部更为复杂），用于存储一个递增计数特定事件的数值。当向给定的计数器列写入新值时，它会被添加到计数器的上一个值。'
- en: A counter is ideal for counting things quickly in a distributed environment
    which makes it invaluable for real time analytical tasks. The `counter` data type
    was introduced in Cassandra Version 0.8\. Counter column tables must use `counter`
    data type. Counters can be stored in dedicated tables only, and you cannot create
    an index on a counter column.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 计数器非常适合在分布式环境中快速计数，这使得它在实时分析任务中非常有价值。`counter`数据类型是在Cassandra 0.8版本中引入的。计数器列表必须使用`counter`数据类型。计数器只能存储在专用表中，并且不能在计数器列上创建索引。
- en: Tip
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Counter type don''ts**'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '**计数器类型禁忌**'
- en: Don't assign the `counter` data type to a column that serves as the primary
    key
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要将`counter`数据类型分配给作为主键的列
- en: Don't use the `counter` data type in a table that contains anything other than
    `counter` data types and primary keys
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要在包含除`counter`数据类型和主键之外任何内容的表中使用`counter`数据类型
- en: Don't use the `counter` data type to generate sequential numbers for surrogate
    keys; use the `timeuuid` data type instead
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要使用`counter`数据类型为代理键生成顺序号；请使用`timeuuid`数据类型
- en: We use a `CREATE TABLE` statement to create a counter table. However, `INSERT`
    statements are not allowed on counter tables and so we must use an `UPDATE` statement
    to update the counter column as shown in the following screenshot.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`CREATE TABLE`语句创建计数器表。然而，不允许在计数器表上使用`INSERT`语句，因此我们必须使用`UPDATE`语句来更新计数器列，如下面的截图所示。
- en: Cassandra uses `counter` instead of `name` to indicate that the column is of
    a counter data type. The counter value is stored in the value of the column.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Cassandra使用`counter`而不是`name`来表示该列是计数器数据类型。计数器的值存储在该列的值中。
- en: This is a very good article that explains the internals of how a counter works
    in a distributed environment [http://www.datastax.com/dev/blog/whats-new-in-cassandra-2-1-a-better-implementation-of-counters](http://www.datastax.com/dev/blog/whats-new-in-cassandra-2-1-a-better-implementation-of-counters).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一篇非常好的文章，解释了在分布式环境中计数器是如何工作的内部机制。[http://www.datastax.com/dev/blog/whats-new-in-cassandra-2-1-a-better-implementation-of-counters](http://www.datastax.com/dev/blog/whats-new-in-cassandra-2-1-a-better-implementation-of-counters)。
- en: 'The following screenshot shows that counter value is stored in the value of
    the column:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示计数器的值存储在列的值中：
- en: '![Counter](img/8884OS_03_10.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![计数器](img/8884OS_03_10.jpg)'
- en: Experiment of the counter data type
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 计数器数据类型的实验
- en: Collections
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合
- en: 'Cassandra also supports collections in its data model to store a small amount
    of data. Collections are a complex type that can provide tremendous flexibility.
    Three collections are supported: Set, List, and Map. The type of data stored in
    each of these collections requires to be defined, for example, a set of timestamp
    is defined as `set<timestamp>`, a list of text is defined as `list<text>`, a map
    containing a text key and a text value is defined as `map<text, text>`, and so
    on. Also, only native data types can be used in collections.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Cassandra在其数据模型中也支持集合来存储少量数据。集合是一种复杂类型，可以提供极大的灵活性。支持三种集合：Set、List和Map。每个集合中存储的数据类型需要定义，例如，时间戳集合定义为`set<timestamp>`，文本列表定义为`list<text>`，包含文本键和文本值的映射定义为`map<text,
    text>`，等等。此外，集合中只能使用原生数据类型。
- en: Cassandra reads a collection in its entirety and the collection is not paged
    internally. The maximum number of items of a collection is 64K and the maximum
    size of an item is 64K.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Cassandra读取整个集合，并且集合在内部不进行分页。集合的最大项数是64K，最大项大小也是64K。
- en: 'To better demonstrate the CQL support on these collections, let us create a
    table in the `packt` keyspace with columns of each collection and insert some
    data into it, as shown in the following screenshot:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地展示这些集合上的CQL支持，让我们在`packt`键空间中创建一个表，其中包含每个集合的列，并向其中插入一些数据，如下面的截图所示：
- en: '![Collections](img/8884OS_03_11.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![集合](img/8884OS_03_11.jpg)'
- en: Experiment on collections
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在集合上进行实验
- en: Note
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**How to update or delete a collection?**'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '**如何更新或删除一个集合？**'
- en: CQL also supports updation and deletion of elements in a collection. You can
    refer to the relevant information in DataStax's documentation at [http://www.datastax.com/documentation/cql/3.1/cql/cql_using/use_collections_c.html](http://www.datastax.com/documentation/cql/3.1/cql/cql_using/use_collections_c.html).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: CQL也支持更新和删除集合中的元素。您可以参考DataStax文档中的相关信息，网址为[http://www.datastax.com/documentation/cql/3.1/cql/cql_using/use_collections_c.html](http://www.datastax.com/documentation/cql/3.1/cql/cql_using/use_collections_c.html)。
- en: As in the case of native data types, let us walk through each collection below.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 正如原生数据类型的情况一样，让我们逐一介绍以下每个集合。
- en: Set
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置
- en: CQL uses sets to keep a collection of unique elements. The benefit of a set
    is that Cassandra automatically keeps track of the uniqueness of the elements
    and we, as application developers, do not need to bother on it.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: CQL使用集合来保持唯一元素集合。集合的好处是Cassandra会自动跟踪元素的唯一性，我们作为应用程序开发者，无需为此烦恼。
- en: CQL uses curly braces (`{}`) to represent a set of values separated by commas.
    An empty set is simply `{}`. In the previous example, although we inserted the
    set as `{'Lemon', 'Orange', 'Apple'}`, the input order was not preserved. Why?
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: CQL使用花括号（`{}`）来表示由逗号分隔的值集合。一个空集合简单地表示为`{}`。在先前的例子中，尽管我们以`{'Lemon', 'Orange',
    'Apple'}`的形式插入集合，但输入顺序并未保留。为什么？
- en: The reason is in the mechanism of how Cassandra stores the set. Internally,
    Cassandra stores each element of the set as a single column whose column name
    is the original column name suffixed by a colon and the element value. As shown
    previously, the ASCII values of `'Apple'`, `'Lemon'`, and `'Orange'` are `0x4170706c65`,
    `0x4c656d6f6e`, and `0x4f72616e6765`, respectively. So they are stored in three
    columns with column names, `setfield:4170706c65`, `setfield:4c656d6f6e`, and `setfield:4f72616e6765`.
    By the built-in order column-name-nature of Cassandra, the elements of a set are
    sorted automatically.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 原因在于Cassandra存储集合的机制。内部，Cassandra将集合的每个元素存储为一个单独的列，其列名是原始列名后跟冒号和元素值。如前所述，`'Apple'`、`'Lemon'`和`'Orange'`的ASCII值分别是`0x4170706c65`、`0x4c656d6f6e`和`0x4f72616e6765`。因此，它们被存储在三个列中，列名为`setfield:4170706c65`、`setfield:4c656d6f6e`和`setfield:4f72616e6765`。由于Cassandra内置的列名排序特性，集合的元素会自动排序。
- en: List
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列表
- en: A list is ordered by the natural order of the type selected. Hence it is suitable
    when uniqueness is not required and maintaining order is required.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 列表按照所选类型的自然顺序排序。因此，当不需要唯一性且需要保持顺序时，它非常适用。
- en: CQL uses square brackets (`[]`) to represent a list of values separated by commas.
    An empty list is `[]`. In contrast to a set, the input order of a list is preserved
    by Cassandra. Cassandra also stores each element of the list as a column. But
    this time, the columns have the same name composed of the original column name
    (`listfield` in our example), a colon, and a UUID generated at the time of update.
    The element value of the list is stored in the value of the column.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: CQL使用方括号（`[]`）来表示由逗号分隔的值列表。一个空列表表示为`[]`。与集合不同，Cassandra会保留列表的输入顺序。Cassandra也会将列表的每个元素存储为一个列。但这次，列具有相同的名称，由原始列名（在我们的例子中为`listfield`），一个冒号和一个在更新时生成的UUID组成。列表的元素值存储在列的值中。
- en: Map
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 映射
- en: A map in Cassandra is a dictionary-like data structure with keys and values.
    It is useful when you want to store table-like data within a single Cassandra
    row.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: Cassandra中的映射是一个类似于字典的数据结构，具有键和值。当您想在单个Cassandra行中存储类似表的数据时，它非常有用。
- en: CQL also uses curly braces (`{}`) to represent a map of keys and values separated
    by commas. Each key-value pair is separated by a colon. An empty map is simply
    represented as `{}`. Conceivably, each key/value pair is stored in a column whose
    column name is composed of the original map column name followed by a colon and
    the key of that pair. The value of the pair is stored in the value of the column.
    Similar to a set, the map sorts its items automatically. As a result, a map can
    be imagined as a hybrid of a set and a list.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: CQL也使用花括号（`{}`）来表示由逗号分隔的键值映射。每个键值对由冒号分隔。一个空映射简单地表示为`{}`。可以想象，每个键/值对存储在一个列中，其列名由原始映射列名后跟冒号和该对的键组成。对的值存储在列的值中。类似于集合，映射会自动对其项目进行排序。因此，可以将映射想象为集合和列表的混合体。
- en: User-defined type and tuple type
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户定义类型和元组类型
- en: Cassandra 2.1 introduces support for **User-Defined Types** (**UDT**) and tuple
    types.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: Cassandra 2.1引入了对**用户定义类型**（**UDT**）和元组类型的支持。
- en: User-defined types are declared at the keyspace level. A user-defined type simplifies
    handling a group of related properties. We can define a group of related properties
    as a type and access them separately or as a single entity. We can map our UDTs
    to application entities. Another new type for CQL introduced by Cassandra 2.1
    is the tuple type. A tuple is a fixed-length set of typed positional fields without
    labels.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 用户定义的类型在键空间级别声明。用户定义的类型简化了处理一组相关属性。我们可以将一组相关属性定义为一种类型，并单独或作为一个单一实体访问它们。我们可以将我们的UDTs映射到应用程序实体。Cassandra
    2.1引入的另一种新类型是元组类型。元组是一个没有标签的、固定长度的类型化位置字段集合。
- en: We can use user-defined and tuple types in tables. However, to support future
    capabilities, a column definition of a user-defined or tuple type requires the
    `frozen` keyword. Cassandra serializes a frozen value having multiple components
    into a single value. This means we cannot update parts of a UDT value. The entire
    value must be overwritten. Cassandra treats the value of a frozen UDT like a `BLOB`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在表中使用用户定义和元组类型。然而，为了支持未来的功能，用户定义或元组类型的列定义需要使用`frozen`关键字。Cassandra将具有多个组件的冻结值序列化为一个单一值。这意味着我们无法更新UDT值的部分。整个值必须被覆盖。Cassandra将冻结UDT的值视为一个`BLOB`。
- en: We create a UDT called `contact` in the `packt` keyspace and use it to define
    `contactfield` in `table04`. Moreover, we have another column, `tuplefield`, to
    store a tuple in a row. Pay attention to the syntax of the `INSERT` statement
    for UDT and tuple. For UDT, we may use a dotted notation to retrieve a component
    of the UDT column, such as `contactfield.facebook` in our following example. As
    shown in `cassandra-cli`, `contactfield` is stored as a single value, `00000001620000000163000000076440642e636f6d`.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`packt`键空间中创建了一个名为`contact`的UDT（用户定义类型），并使用它来定义`table04`中的`contactfield`。此外，我们还有一个名为`tuplefield`的列，用于在行中存储一个元组。请注意UDT和元组的`INSERT`语句的语法。对于UDT，我们可能使用点符号来检索UDT列的组件，例如在我们下面的例子中的`contactfield.facebook`。如图所示在`cassandra-cli`中，`contactfield`被存储为一个单一值，`00000001620000000163000000076440642e636f6d`。
- en: 'The value concatenates each UDT component in sequence with the format, a length
    of 4 bytes indicating the length of the component value and the component value
    itself. So, for `contactfield.facebook`, `0x00000001` is the length and `0x62`
    is the byte value of `''a''`. Cassandra applies the same treatment to a tuple:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 值按照顺序将每个UDT组件以格式连接，格式为一个4字节的长度指示组件值的长度，以及组件值本身。因此，对于`contactfield.facebook`，`0x00000001`是长度，`0x62`是字符`'a'`的字节值。Cassandra对元组也应用相同的处理：
- en: '![User-defined type and tuple type](img/8884OS_03_12.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![用户定义类型和元组类型](img/8884OS_03_12.jpg)'
- en: Experiment of user-defined and tuple types
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 用户定义和元组类型的实验
- en: Note
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Further information can be found at DataStax''s documentation, available at
    the following links: [http://www.datastax.com/documentation/cql/3.1/cql/cql_using/cqlUseUDT.html](http://www.datastax.com/documentation/cql/3.1/cql/cql_using/cqlUseUDT.html)'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息可以在DataStax的文档中找到，文档可通过以下链接获取：[http://www.datastax.com/documentation/cql/3.1/cql/cql_using/cqlUseUDT.html](http://www.datastax.com/documentation/cql/3.1/cql/cql_using/cqlUseUDT.html)
- en: '[http://www.datastax.com/documentation/developer/python-driver/2.1/python-driver/reference/tupleTypes.html](http://www.datastax.com/documentation/developer/python-driver/2.1/python-driver/reference/tupleTypes.html)'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://www.datastax.com/documentation/developer/python-driver/2.1/python-driver/reference/tupleTypes.html](http://www.datastax.com/documentation/developer/python-driver/2.1/python-driver/reference/tupleTypes.html)'
- en: Summary
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter is the second part of Cassandra data modeling. We have learned
    the basics of Cassandra Query Language (CQL), which offers a SQL-like language
    to implement a Cassandra data model and operate the data inside. Then a very detailed
    walkthrough, with ample examples of native data types, more advanced collections,
    and new user-defined and tuple types, was provided to help you know how to select
    appropriate data types for your data models. The internal storage of each data
    type was also explained to let you know how Cassandra implements its data types.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是Cassandra数据模型的第二部分。我们已经学习了Cassandra查询语言（CQL）的基础，它提供了一个类似SQL的语言来实现Cassandra数据模型并在其中操作数据。然后提供了一个非常详细的说明，包括大量原生数据类型、更高级的集合以及新的用户定义和元组类型的示例，以帮助您了解如何为您的数据模型选择合适的数据类型。还解释了每种数据类型的内部存储，以便您了解Cassandra如何实现其数据类型。
- en: In the next chapter, we will learn another important element of a Cassandra
    query—indexes.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习Cassandra查询的另一个重要元素——索引。
