- en: Matplotlib in the Real World
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Matplotlib 在现实世界中的应用
- en: At this point, we hope you are equipped with the techniques of creating and
    customizing plots using Matplotlib. Let's build on top of the things we have learned
    so far, and begin our journey of understanding more advanced Matplotlib usage
    through real-world examples.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们希望你已经掌握了使用 Matplotlib 创建和定制图表的技巧。让我们在已有的基础上进一步深入，通过现实世界的例子开始我们的 Matplotlib
    高级用法之旅。
- en: First, we will cover how to fetch online data, which is commonly obtained through
    an **application programming interface** (**API**) or plain old web scraping techniques.
    Next, we will explore how to integrate Matplotlib 2.x with other scientific computing
    packages in Python for visualizations of different data types.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将介绍如何获取在线数据，这通常是通过 **应用程序编程接口** (**API**) 或传统的网页抓取技术获得的。接下来，我们将探索如何将 Matplotlib
    2.x 与 Python 中的其他科学计算包集成，用于不同数据类型的可视化。
- en: Typical API data formats
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见的 API 数据格式
- en: Many websites distribute data via their API, which bridges applications via
    standardized architecture. While we are not going to cover the details of using
    APIs here, we will cover the most common API data exchange formats, namely CSV
    and JSON.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 许多网站通过其 API 分发数据，API 通过标准化架构将应用程序连接起来。虽然我们在这里不会详细讨论如何使用 API，但我们会介绍最常见的 API 数据交换格式——CSV
    和 JSON。
- en: Interested readers can visit site-specific documentations for the use of APIs.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 感兴趣的读者可以访问特定网站的文档，了解如何使用 API。
- en: We have briefly covered parsing of CSV files in [Chapter 4](456b0dc2-84d5-40f9-bf63-1ab4635cbac8.xhtml), *Advanced
    Matplotlib*. To aid your understanding, we are going to represent the same data
    using both CSV and JSON.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第 4 章](456b0dc2-84d5-40f9-bf63-1ab4635cbac8.xhtml)，*高级 Matplotlib* 中简要介绍了
    CSV 文件的解析。为了帮助你更好地理解，我们将同时使用 CSV 和 JSON 来表示相同的数据。
- en: CSV
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CSV
- en: '**Comma-separated values** (**CSV**) is one of the oldest file formats, introduced
    long before the World Wide Web even existed. However, it is now becoming deprecated
    as other advanced formats such as JSON and XML are gaining popularity. As the
    name suggests, data values are separated by commas. The preinstalled `csv` package
    and the `pandas` package contain classes to read and write data in CSV format.
    The following CSV example defines a population table with two countries:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**逗号分隔值** (**CSV**) 是最早的文件格式之一，远在万维网存在之前就已被引入。然而，随着 JSON 和 XML 等先进格式的流行，CSV
    正在逐渐被淘汰。顾名思义，数据值是通过逗号分隔的。预安装的 `csv` 包和 `pandas` 包都包含了读取和写入 CSV 格式数据的类。以下 CSV 示例定义了一个包含两个国家的
    population（人口）表：'
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: JSON
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSON
- en: '**JavaScript Object Notation** (**JSON**) is gaining popularity these days
    due to its efficiency and simplicity. JSON allows the specification of number,
    string, Boolean, array, and object. Python provides the default `json` package
    for parsing JSON. Alternatively, the `pandas.read_json` class can be used to import
    JSON as a pandas DataFrame. The preceding population table can be represented
    as JSON as follows:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript 对象表示法** (**JSON**) 由于其高效性和简洁性，近年来越来越受欢迎。JSON 允许指定数字、字符串、布尔值、数组和对象。Python
    提供了默认的 `json` 包来解析 JSON。或者，`pandas.read_json` 类可以用来将 JSON 导入为 pandas DataFrame。前述的人口表可以用
    JSON 表示如下：'
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Importing and visualizing data from a JSON API
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从 JSON API 导入和可视化数据
- en: Now, let's learn how to parse financial data from Quandl's API to create insightful
    visualizations. Quandl is a financial and economic data warehouse, storing millions
    of datasets from hundreds of publishers. The best thing about Quandl is that these
    datasets are delivered via the unified API, without worrying about the procedures
    to parse the data correctly. Anonymous users can get up to 50 API calls per day,
    or up to 500 free API calls if registered. Readers can sign up for a free API
    key at [https://www.quandl.com/?modal=register](https://www.quandl.com/?modal=register.).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们学习如何解析来自 Quandl API 的金融数据，以创建有价值的可视化图表。Quandl 是一个金融和经济数据仓库，存储了来自数百个发布者的数百万数据集。Quandl
    的最大优点是，这些数据集通过统一的 API 提供，用户无需担心如何正确解析数据。匿名用户每天可以获得最多 50 次 API 调用，注册用户则可以获得最多 500
    次免费 API 调用。读者可以在 [https://www.quandl.com/?modal=register](https://www.quandl.com/?modal=register)
    上注册免费 API 密钥。
- en: At Quandl, every dataset is identified by a unique ID, as defined by the Quandl
    code on each search result web page. For example, the Quandl code `GOOG/NASDAQ_SWTX`
    defines the historical NASDAQ index data published by Google Finance. Every dataset
    is available in three different formats—CSV, JSON, and XML.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在Quandl中，每个数据集都有一个唯一的ID，由每个搜索结果网页上的Quandl代码定义。例如，Quandl代码`GOOG/NASDAQ_SWTX`定义了Google
    Finance发布的历史NASDAQ指数数据。每个数据集都提供三种不同的格式——CSV、JSON和XML。
- en: 'Although an official Python client library is available from Quandl, we are
    not going to use that, for the sake of demonstrating the general procedures of
    importing JSON data from an API. According to Quandl''s documentation, we can
    fetch JSON-formatted data tables through the following API call:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Quandl提供了官方的Python客户端库，我们不会使用它，而是为了演示从API导入JSON数据的通用流程。根据Quandl的文档，我们可以通过以下API调用获取JSON格式的数据表：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To begin with, let''s try to get the Big Mac index data from Quandl. The Big
    Mac index was invented by *The Economist* in 1986 as a lighthearted guide to whether
    currencies are at their **correct** level. It is based on the theory of **purchasing
    power parity** (**PPP**), and is considered an informal measure of currency exchange
    rates at PPP. It measures their value against a similar basket of goods and services,
    in this case a Big Mac. Differing prices at market exchange rates would imply
    that one currency is undervalued or overvalued:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们尝试从Quandl获取大麦克指数数据。大麦克指数由*经济学人*于1986年发明，作为一种轻松的方式来判断货币是否处于**正确**的水平。它基于**购买力平价**（**PPP**）理论，并被视为货币在购买力平价下的非正式汇率衡量标准。它通过将货币与一篮子类似的商品和服务进行比较来衡量其价值，在这种情况下是大麦克。市场汇率下的价格差异意味着某种货币被低估或高估：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here comes the expected result, which shows the first five rows of the data
    frame:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这是预期的结果，显示数据框的前五行：
- en: '|   | **0** | **1** | **2** | **3** | **4** |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '|   | **0** | **1** | **2** | **3** | **4** |'
- en: '| **Date** | 31-07-17 | 31-01-17 | 31-07-16 | 31-01-16 | 31-07-15 |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| **Date** | 31-07-17 | 31-01-17 | 31-07-16 | 31-01-16 | 31-07-15 |'
- en: '| **local_price** | 5.9 | 5.8 | 5.75 | 5.3 | 5.3 |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| **local_price** | 5.9 | 5.8 | 5.75 | 5.3 | 5.3 |'
- en: '| **dollar_ex** | 1.303016 | 1.356668 | 1.335738 | 1.415729 | 1.35126 |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| **dollar_ex** | 1.303016 | 1.356668 | 1.335738 | 1.415729 | 1.35126 |'
- en: '| **dollar_price** | 4.527955 | 4.27518 | 4.304737 | 3.743655 | 3.922265 |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| **dollar_price** | 4.527955 | 4.27518 | 4.304737 | 3.743655 | 3.922265 |'
- en: '| **dollar_ppp** | 1.113208 | 1.146245 | 1.140873 | 1.075051 | 1.106472 |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| **dollar_ppp** | 1.113208 | 1.146245 | 1.140873 | 1.075051 | 1.106472 |'
- en: '| **dollar_valuation** | -14.56689 | -15.510277 | -14.588542 | -24.06379 |
    -18.115553 |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| **dollar_valuation** | -14.56689 | -15.510277 | -14.588542 | -24.06379 |
    -18.115553 |'
- en: '| **dollar_adj_valuation** | -11.7012 | -11.9234 | -11.0236 | -28.1641 | -22.1691
    |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| **dollar_adj_valuation** | -11.7012 | -11.9234 | -11.0236 | -28.1641 | -22.1691
    |'
- en: '| **euro_adj_valuation** | -13.0262 | -10.2636 | -12.4796 | -22.2864 | -18.573
    |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| **euro_adj_valuation** | -13.0262 | -10.2636 | -12.4796 | -22.2864 | -18.573
    |'
- en: '| **sterling_adj_valuation** | 2.58422 | 7.43771 | 2.48065 | -22.293 | -23.1926
    |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| **sterling_adj_valuation** | 2.58422 | 7.43771 | 2.48065 | -22.293 | -23.1926
    |'
- en: '| **yen_adj_valuation** | 19.9417 | 9.99688 | 4.39776 | -4.0042 | 6.93893 |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| **yen_adj_valuation** | 19.9417 | 9.99688 | 4.39776 | -4.0042 | 6.93893 |'
- en: '| **yuan_adj_valuation** | -2.35772 | -5.82434 | -2.681 | -20.6755 | -14.1711
    |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| **yuan_adj_valuation** | -2.35772 | -5.82434 | -2.681 | -20.6755 | -14.1711
    |'
- en: '| **country** | AUS | AUS | AUS | AUS | AUS |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| **country** | AUS | AUS | AUS | AUS | AUS |'
- en: The code for parsing JSON from Quandl API is a bit complicated, and thus requires
    extra explanation. The first function, `get_bigmac_codes()`, parses the list of
    all available dataset codes in the Quandl Economist database as a pandas DataFrame.
    Meanwhile, the second function, `get_quandl_dataset(api_key, code)`, converts
    the JSON response of a Quandl dataset API query to a pandas DataFrame. All datasets
    obtained are concatenated into a single data frame using `pandas.concat()`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 解析Quandl API中的JSON数据的代码有点复杂，因此需要额外的解释。第一个函数`get_bigmac_codes()`解析Quandl经济学人数据库中所有可用数据集代码的列表，并将其转换为pandas
    DataFrame。同时，第二个函数`get_quandl_dataset(api_key, code)`将Quandl数据集API查询的JSON响应转换为pandas
    DataFrame。所有获取的数据集通过`pandas.concat()`合并为一个单独的数据框。
- en: We should bear in mind that the Big Mac index is not directly comparable between
    countries. Normally, we would expect commodities in poor countries to be cheaper
    than those in rich ones. To represent a fairer picture of the index, it would
    be better to show the relationship between Big Mac pricing and **gross domestic
    product** (**GDP**) per capita.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该记住，大麦克指数在不同国家之间并不直接可比。通常，我们会预期贫穷国家的商品价格低于富裕国家。为了更公平地展示指数，最好展示大麦克价格与**国内生产总值**（**GDP**）人均之间的关系。
- en: To that end, we are going to acquire the GDP dataset from Quandl's **World Bank
    World Development Indicators** (**WWDI**) database. Based on the previous code
    example of acquiring JSON data from Quandl, can you try to adapt it to download
    the GDP per capita dataset?
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为了达到这一目的，我们将从Quandl的**世界银行世界发展指标**（**WWDI**）数据库中获取GDP数据集。基于之前从Quandl获取JSON数据的代码示例，你能尝试将其修改为下载人均GDP数据集吗？
- en: 'For those who are impatient, here is the full code:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些急于查看的用户，以下是完整的代码：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The GDP data of several geographical regions is missing, but this should be
    handled gracefully by the `try...except` code block in the `get_gdp_dataset` function.
    This is what you are expecting to see after running the preceding code:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 几个地区的GDP数据缺失，但这应该可以通过`try...except`代码块在`get_gdp_dataset`函数中优雅地处理。运行前面的代码后，你应该看到如下内容：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '|  | **Date** | **Value** | **country** |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '|  | **日期** | **值** | **国家** |'
- en: '| **0** | 2016-12-31 | 55478.577294 | AUS |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| **0** | 2016-12-31 | 55478.577294 | AUS |'
- en: '| **1** | 2015-12-31 | 54800.366396 | AUS |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| **1** | 2015-12-31 | 54800.366396 | AUS |'
- en: '| **2** | 2014-12-31 | 54293.794205 | AUS |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| **2** | 2014-12-31 | 54293.794205 | AUS |'
- en: '| **3** | 2013-12-31 | 53732.003969 | AUS |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| **3** | 2013-12-31 | 53732.003969 | AUS |'
- en: '| **4** | 2012-12-31 | 53315.029915 | AUS |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| **4** | 2012-12-31 | 53315.029915 | AUS |'
- en: Next, we will merge the two pandas DataFrames that contain Big Mac Index or
    GDP per capita using `pandas.merge()`. The most recent record in WWDI's GDP per
    capita dataset was collected at the end of 2016, so let's pair that up with the
    closest Big Mac index dataset in January 2017.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用`pandas.merge()`合并包含“大麦指数”或人均GDP的两个pandas数据框。WWDI的最新人均GDP数据记录是在2016年底收集的，因此我们将其与2017年1月的最新大麦指数数据集配对。
- en: 'For those who are familiar with the SQL language, `pandas.merge()` supports
    four modes, namely left, right, inner, and outer joins. Since we are interested
    in rows that have matching countries in both pandas DataFrames only, we are going
    to choose inner join:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 对于熟悉SQL语言的人来说，`pandas.merge()`支持四种连接模式，分别是左连接、右连接、内连接和外连接。由于我们只关心在两个pandas数据框中都有匹配国家的行，因此我们将选择内连接：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here is the merged data frame:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这是合并后的数据框：
- en: '|   | **0** | **1** | **2** | **3** | **4** |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '|   | **0** | **1** | **2** | **3** | **4** |'
- en: '| **Date_x** | 31-01-17 | 31-01-17 | 31-01-17 | 31-01-17 | 31-01-17 |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| **日期_x** | 31-01-17 | 31-01-17 | 31-01-17 | 31-01-17 | 31-01-17 |'
- en: '| **local_price** | 5.8 | 16.5 | 3.09 | 2450 | 55 |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| **本地价格** | 5.8 | 16.5 | 3.09 | 2450 | 55 |'
- en: '| **dollar_ex** | 1.356668 | 3.22395 | 0.828775 | 672.805 | 15.8575 |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| **美元汇率** | 1.356668 | 3.22395 | 0.828775 | 672.805 | 15.8575 |'
- en: '| **dollar_price** | 4.27518 | 5.117945 | 3.728394 | 3.641471 | 3.46839 |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| **美元价格** | 4.27518 | 5.117945 | 3.728394 | 3.641471 | 3.46839 |'
- en: '| **dollar_ppp** | 1.146245 | 3.26087 | 0.610672 | 484.189723 | 10.869565 |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| **美元购买力平价** | 1.146245 | 3.26087 | 0.610672 | 484.189723 | 10.869565 |'
- en: '| **dollar_valuation** | -15.510277 | 1.145166 | -26.316324 | -28.034167 |
    -31.454736 |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| **美元估值** | -15.510277 | 1.145166 | -26.316324 | -28.034167 | -31.454736 |'
- en: '| **dollar_adj_valuation** | -11.9234 | 67.5509 | -18.0208 | 11.9319 | 6.26715
    |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| **美元调整估值** | -11.9234 | 67.5509 | -18.0208 | 11.9319 | 6.26715 |'
- en: '| **euro_adj_valuation** | -10.2636 | 70.7084 | -16.4759 | 14.0413 | 8.26976
    |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| **欧元调整估值** | -10.2636 | 70.7084 | -16.4759 | 14.0413 | 8.26976 |'
- en: '| **sterling_adj_valuation** | 7.43771 | 104.382 | 0 | 36.5369 | 29.6269 |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| **英镑调整估值** | 7.43771 | 104.382 | 0 | 36.5369 | 29.6269 |'
- en: '| **yen_adj_valuation** | 9.99688 | 109.251 | 2.38201 | 39.7892 | 32.7146 |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| **日元调整估值** | 9.99688 | 109.251 | 2.38201 | 39.7892 | 32.7146 |'
- en: '| **yuan_adj_valuation** | -5.82434 | 79.1533 | -12.3439 | 19.6828 | 13.6258
    |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| **人民币调整估值** | -5.82434 | 79.1533 | -12.3439 | 19.6828 | 13.6258 |'
- en: '| **Country** | AUS | BRA | GBR | CHL | ARG |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| **国家** | AUS | BRA | GBR | CHL | ARG |'
- en: '| **Date_y** | 31-12-16 | 31-12-16 | 31-12-16 | 31-12-16 | 31-12-16 |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| **日期_y** | 31-12-16 | 31-12-16 | 31-12-16 | 31-12-16 | 31-12-16 |'
- en: '| **Value** | 55478.5773 | 10826.2714 | 41981.3921 | 15019.633 | 10153.99791
    |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| **值** | 55478.5773 | 10826.2714 | 41981.3921 | 15019.633 | 10153.99791 |'
- en: Using Seaborn to simplify visualization tasks
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Seaborn简化可视化任务
- en: The scatter plot is one of the most common plots in the scientific and business
    worlds. It is particularly useful for displaying the relationship between two
    variables. While we can simply use `matplotlib.pyplot.scatter` to draw a scatterplot
    (see [Chapter 2](e1962b92-9e72-4c5a-bdd8-11b7ce29411b.xhtml), *Getting Started
    with Matplotlib*, and [Chapter 4](456b0dc2-84d5-40f9-bf63-1ab4635cbac8.xhtml),
    *Advanced Matplotlib*, for more details), we can also use Seaborn to build similar
    plots with more advanced features.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 散点图是科学和商业领域中最常见的图形之一。它特别适合用来展示两个变量之间的关系。虽然我们可以简单地使用 `matplotlib.pyplot.scatter`
    来绘制散点图（有关更多详细信息，请参见[第2章](e1962b92-9e72-4c5a-bdd8-11b7ce29411b.xhtml)，*Matplotlib
    入门* 和 [第4章](456b0dc2-84d5-40f9-bf63-1ab4635cbac8.xhtml)，*高级 Matplotlib*），我们也可以使用
    Seaborn 来构建具有更多高级功能的类似图形。
- en: The two functions, `seaborn.regplot()` and `seaborn.lmplot()`, display a linear
    relationship in the form of a scatter plot, a regression line, and the 95% confidence
    interval around the regression line. The main difference between the two functions
    is that `lmplot()` combines `regplot()` with `FacetGrid`, such that we can create
    color-coded or faceted scatter plots to show the interaction between three or
    more pairs of variables.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数，`seaborn.regplot()` 和 `seaborn.lmplot()`，通过散点图、回归线以及回归线周围的95%置信区间，展示了变量之间的线性关系。它们之间的主要区别在于，`lmplot()`
    将 `regplot()` 与 `FacetGrid` 结合在一起，允许我们创建带有颜色编码或分面显示的散点图，从而展示三个或更多变量对之间的交互关系。
- en: The simplest form of `seaborn.regplot()` supports NumPy arrays, pandas Series,
    or pandas DataFrames as input. The regression line and the confidence interval
    can be removed by specifying `fit_reg=False`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`seaborn.regplot()` 最简单的形式支持 NumPy 数组、pandas Series 或 pandas DataFrame 作为输入。可以通过指定
    `fit_reg=False` 来去除回归线和置信区间。'
- en: 'We are going to investigate the hypothesis that Big Macs are cheaper in countries
    with lower GDP, and vice versa. To that end, we will try to find out whether there
    is any correlation between the Big Mac index and GDP per capita:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将调查这样一个假设：在人均 GDP 较低的国家，巨无霸价格较便宜，反之亦然。为此，我们将尝试找出巨无霸指数与人均 GDP 之间是否存在相关性：
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The code will greet you with a good old scatter plot:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 代码将用一个经典的散点图来迎接你：
- en: '![](img/91b63fe9-f7d5-4405-a7f0-c8aaa756ba70.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/91b63fe9-f7d5-4405-a7f0-c8aaa756ba70.png)'
- en: 'So far so good! It looks like the Big Mac index is positively correlated with
    GDP per capita. Let''s turn the regression line back on and label a few countries
    that show extreme Big Mac index values (that is, ≥ 5 or ≤ 2). Meanwhile, the default
    plotting style is a bit plain; we can spice up the graph by running `sns.set(style="whitegrid")`.
    There are four other styles to choose from, namely `darkgrid`, `dark`, `white`,
    and `ticks`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利！看起来巨无霸指数与人均 GDP 呈正相关。我们将重新开启回归线，并标记出一些显示极端巨无霸指数值的国家（即 ≥ 5 或 ≤ 2）。同时，默认的绘图样式有些单调；我们可以通过运行
    `sns.set(style="whitegrid")` 来使图表更具活力。还有四种其他样式可供选择，分别是 `darkgrid`、`dark`、`white`
    和 `ticks`：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here is the labeled plot:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这是带标签的图：
- en: '![](img/99ebb967-73f2-42b8-8dde-6be3c98d6679.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/99ebb967-73f2-42b8-8dde-6be3c98d6679.png)'
- en: We can see that many countries fall within the confidence interval of the regression
    line. Given the GDP per capita level for each country, the linear regression model
    predicts the corresponding Big Mac index. The currency value shows signs of undervaluation
    or overvaluation if the actual index deviates from the regression model.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，许多国家的点都落在回归线的置信区间内。根据每个国家的人均 GDP，线性回归模型预测了相应的巨无霸指数。如果实际指数偏离回归模型，则货币价值可能表明其被低估或高估。
- en: By labeling the countries that show extremely high or low values, we can clearly
    see that the average price of a Big Mac in Brazil and Switzerland were overvalued,
    while it is undervalued in South Africa, Malaysia, Ukraine, and Egypt.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 通过标记出显示极高或极低值的国家，我们可以清楚地看到，巴西和瑞士的巨无霸价格被高估，而南非、马来西亚、乌克兰和埃及则被低估。
- en: 'Since Seaborn is not a package for statistical analysis, we need to use other
    packages, such as `scipy.stats` or `statsmodels`, to obtain the parameters of
    a regression model. In the next example, we are going to get the slope and intercept
    parameters from the regression model, and apply different colors for points that
    are above or below the regression line:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Seaborn 不是一个用于统计分析的包，我们需要使用其他包，例如 `scipy.stats` 或 `statsmodels`，来获得回归模型的参数。在下一个示例中，我们将从回归模型中获取斜率和截距参数，并为回归线上下的点应用不同的颜色：
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This screenshot shows the color-labeled plot:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这张截图展示了带有颜色标签的图：
- en: '![](img/d0f89ab5-681b-48b2-b00d-45410b8b3c33.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d0f89ab5-681b-48b2-b00d-45410b8b3c33.png)'
- en: Contrary to popular belief, it looks as if China's currency was not significantly
    undervalued in 2016, as the value lies within the 95% confidence interval of the
    regression line.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 与普遍看法相反，看起来中国的货币在2016年并没有显著低估，因为其价值位于回归线的95%置信区间内。
- en: 'We can also combine histograms of *x* and *y* values with a scatter plot using
    `seaborn.jointplot`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将*x*和*y*值的直方图与散点图结合，使用`seaborn.jointplot`：
- en: By additionally specifying the `kind` parameter in `jointplot` to any one of `reg`,
    `resid`, `hex`, or `kde`, we can quickly change the plot type to regression, residual,
    hex bin, or KDE contour plot, respectively.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在`jointplot`中额外指定`kind`参数为`reg`、`resid`、`hex`或`kde`中的任意一个，我们可以迅速将图表类型分别更改为回归图、残差图、六边形箱型图或KDE轮廓图。
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `jointplot` is as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`jointplot`如图所示：'
- en: '![](img/898e91c6-42bc-4ded-b51c-df3a52622124.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](img/898e91c6-42bc-4ded-b51c-df3a52622124.png)'
- en: Here is the big disclaimer. With all the data in our hands, it is still too
    early to make any conclusion about the valuation of currencies! Different business
    factors such as labor cost, rent, raw material costs, and taxation can all contribute
    to the pricing model of Big Mac, but this is beyond the scope of this book.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个重要的免责声明。即便我们手中有所有数据，现在依然为时过早，无法对货币估值做出任何结论！劳动力成本、租金、原材料成本和税收等不同的商业因素都可能影响“大麦”定价模型，但这超出了本书的范围。
- en: Scraping information from websites
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从网站抓取信息
- en: Governments or jurisdictions around the world are increasingly embracing the
    importance of open data, which aims to increase citizen involvement and informed
    decision-making, and also aims to make policies more open to public scrutiny.
    Some examples of open data initiatives around the world include [https://www.data.gov/](https://www.data.gov/)
    (United States of America), [https://data.gov.uk/](https://data.gov.uk/) (United
    Kingdom), and [https://data.gov.hk/en/](https://data.gov.hk/en/) (Hong Kong).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 世界各国的政府或司法管辖区越来越重视开放数据，这旨在增加公民参与和知情决策，并使政策更加开放，接受公众审查。全球一些开放数据倡议的例子包括[https://www.data.gov/](https://www.data.gov/)（美国）、[https://data.gov.uk/](https://data.gov.uk/)（英国）和[https://data.gov.hk/en/](https://data.gov.hk/en/)（香港）。
- en: These data portals often provide an API for programmatic access of data. However,
    an API is not available for some datasets, hence we need to rely on good old web
    scraping techniques to extract information from websites.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数据门户网站通常提供用于程序化访问数据的API。然而，并非所有数据集都提供API，因此我们需要依靠老式的网页抓取技术，从网站中提取信息。
- en: Beautiful Soup ([https://www.crummy.com/software/BeautifulSoup/](https://www.crummy.com/software/BeautifulSoup/))
    is an incredibly useful package for scraping information from websites. Basically,
    everything marked with an HTML tag can be scraped with this wonderful package.
    Scrapy is also a good package for web scraping, but it is more like a framework
    for writing powerful web crawlers. So if you just need to fetch a table from the
    page, Beautiful Soup offers simpler procedures.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Beautiful Soup ([https://www.crummy.com/software/BeautifulSoup/](https://www.crummy.com/software/BeautifulSoup/))
    是一个非常有用的抓取网站信息的包。基本上，所有带有HTML标签的内容都可以使用这个强大的包进行抓取。Scrapy也是一个不错的网页抓取包，但它更像是一个编写强大网络爬虫的框架。所以，如果你只是需要从页面抓取一个表格，Beautiful
    Soup提供了更简单的操作方式。
- en: 'We are going to use Beautiful Soup version 4.6 throughout this chapter. To
    install Beautiful Soup 4, we can once again rely on PyPI:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将使用Beautiful Soup版本4.6。要安装Beautiful Soup 4，我们可以再次通过PyPI来安装：
- en: '[PRE11]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The US unemployment rates and earnings by educational attainment data (2017)
    is available from the following website: [https://www.bls.gov/emp/ep_table_001.htm](https://www.bls.gov/emp/ep_table_001.htm).
    Currently, Beautiful Soup does not handle HTML requests. So we need to use the `urllib.request`
    or `requests` package to fetch a web page for us. Among the two options, the `requests` package
    is arguably easier to use due to its higher-level HTTP client interface. If `requests`
    is not available on your system, we can install that through PyPI:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 美国失业率和按教育程度划分的收入数据（2017年）可以通过以下网站获得：[https://www.bls.gov/emp/ep_table_001.htm](https://www.bls.gov/emp/ep_table_001.htm)。目前，Beautiful
    Soup不处理HTML请求。所以我们需要使用`urllib.request`或`requests`包来获取网页。在这两个选项中，`requests`包由于其更高层次的HTTP客户端接口，使用起来显得更加简便。如果你的系统中没有`requests`，我们可以通过PyPI安装：
- en: '[PRE12]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let''s take a look at the web page before we write the web scraping code. If
    we use Google Chrome to visit the Bureau of Labor Statistics website, we can inspect
    the HTML code corresponding to the table we need:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写网页爬取代码之前，让我们先看一下网页。如果我们使用 Google Chrome 访问劳动统计局网站，就可以检查对应我们需要的表格的 HTML 代码：
- en: '![](img/c8742c4c-8452-4001-919c-d192cb90aa89.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c8742c4c-8452-4001-919c-d192cb90aa89.png)'
- en: 'Next, expand `<div id="bodytext" class="verdana md">` until you can see `<table
    class="regular" cellspacing="0" cellpadding="0" xborder="1">...</table>`. When
    you put your mouse over the HTML code, the corresponding section on the page will
    be highlighted:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，展开`<div id="bodytext" class="verdana md">`，直到你能看到`<table class="regular"
    cellspacing="0" cellpadding="0" xborder="1">...</table>`。当你将鼠标悬停在 HTML 代码上时，页面中的对应部分会被高亮显示：
- en: '![](img/0b9378c6-61e9-4ff1-ba1f-41ec509516b0.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0b9378c6-61e9-4ff1-ba1f-41ec509516b0.png)'
- en: After further expanding the HTML code of the `<table>`, we can see that the
    column names are defined in the `<thead>...</thead>` section, while the table
    content is defined in the `<tbody>...</tbody>` section.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展`<table>`的 HTML 代码后，我们可以看到列名定义在`<thead>...</thead>`部分，而表格内容则定义在`<tbody>...</tbody>`部分。
- en: 'In order to instruct Beautiful Soup to scrape the information we need, we need
    to give clear directions to it. We can right-click on the relevant section in
    the code inspection window and copy the unique identifier in the format of a CSS
    selector:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了指示 Beautiful Soup 爬取我们需要的信息，我们需要给它明确的指示。我们可以右键单击代码检查窗口中的相关部分，复制格式为 CSS 选择器的唯一标识符：
- en: '![](img/6979cfd1-bddb-49c7-a9f3-945f6f9d5264.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6979cfd1-bddb-49c7-a9f3-945f6f9d5264.png)'
- en: 'Let''s try to get the CSS selectors for `thead` and `tbody`, and use the `BeautifulSoup.select()`
    method to scrape the respective HTML code:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试获取`thead`和`tbody`的 CSS 选择器，并使用`BeautifulSoup.select()`方法来爬取相应的 HTML 代码：
- en: '[PRE13]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You will be greeted by the HTML code of the table headers:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到表头的 HTML 代码：
- en: '[PRE14]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next, we are going to find all instances of `<th></th>`, which contains the
    name of each column. We will build a dictionary of lists with headers as keys
    to hold the data:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将找到所有包含每一列名称的`<th></th>`标签。我们将构建一个以列头为键的字典列表来保存数据：
- en: '[PRE15]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Finally, we parse the remaining rows of the table and convert the data to a
    pandas DataFrame:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们解析表格的剩余行，并将数据转换为 pandas DataFrame：
- en: '[PRE16]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We should now be able to reproduce the first few rows of the main table:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在应该能够重现主表格的前几行：
- en: '|  | **Educational attainment** | **Median usual weekly earnings ($)** | **Unemployment
    rate (%)** |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '|  | **学历** | **中位数通常每周收入（$）** | **失业率（%）** |'
- en: '| **0** | Doctoral degree | 1743.0 | 1.5 |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| **0** | 博士学位 | 1743.0 | 1.5 |'
- en: '| **1** | Professional degree | 1836.0 | 1.5 |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| **1** | 专业学位 | 1836.0 | 1.5 |'
- en: '| **2** | Master''s degree | 1401.0 | 2.2 |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| **2** | 硕士学位 | 1401.0 | 2.2 |'
- en: '| **3** | Bachelor''s degree | 1173.0 | 2.5 |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| **3** | 本科及以上学位 | 1173.0 | 2.5 |'
- en: '| **4** | Associate''s degree | 836.0 | 3.4 |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| **4** | 大专及以上学位 | 836.0 | 3.4 |'
- en: The main HTML table has been formatted as a structured pandas DataFrame. We
    can now proceed to visualize the data.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 主 HTML 表格已经被格式化为结构化的 pandas DataFrame。我们现在可以继续可视化数据了。
- en: Matplotlib graphical backends
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Matplotlib 图形后端
- en: The code for plotting graphs is considered the frontend in Matplotlib's terminology.
    We first mentioned backends in [Chapter 1](840a0403-49de-4053-adf9-bf389ed96cf5.xhtml), *Introduction
    to Matplotlib*, when we were talking about output formats. In reality, Matplotlib
    backends have much more differences than just support for graphical formats. Backends
    handle so many things behind the scenes! And that would determine the support
    of plotting capabilities. For example, the LaTeX text layout is supported only by
    Agg, PDF, PGF, and PS backends.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 绘图的代码被认为是 Matplotlib 中的前端部分。我们第一次提到后端是在[第 1 章](840a0403-49de-4053-adf9-bf389ed96cf5.xhtml)，*Matplotlib
    简介*，当时我们在谈论输出格式。实际上，Matplotlib 后端有着比仅仅支持图形格式更多的差异。后端在幕后处理了很多事情！这决定了绘图功能的支持。例如，LaTeX
    文本布局仅由 Agg、PDF、PGF 和 PS 后端支持。
- en: Non-interactive backends
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 非交互式后端
- en: We have been using several non-interactive backends so far, which include Agg,
    Cairo, GDK, PDF, PGF, PS, and SVG. Most of these backends work without extra dependencies,
    but Cairo and GDK require the Cairo graphics library or GIMP Drawing Kit, respectively,
    to work.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经使用了几种非交互式后端，包括 Agg、Cairo、GDK、PDF、PGF、PS 和 SVG。大多数后端无需额外依赖即可工作，但 Cairo
    和 GDK 分别需要 Cairo 图形库或 GIMP 绘图工具包才能运行。
- en: Non-interactive backends can be further classified into two groups—vector or
    raster. Vector graphics describe images in terms of points, paths, and shapes
    that are calculated using mathematical formulas. A vector graphic will always
    appear smooth irrespective of the scale, and its size is usually much smaller
    than the raster counterpart. PDF, PGF, PS, and SVG backends belong to the vector
    group.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 非交互式后端可以进一步分为两组——矢量或光栅。矢量图形通过点、路径和形状来描述图像，这些都是通过数学公式计算得出的。无论缩放多少，矢量图形总是显得平滑，并且其大小通常比光栅图形要小。PDF、PGF、PS
    和 SVG 后端属于矢量组。
- en: 'Raster graphics describe images in terms of a finite number of tiny color blocks
    (pixels). So if we zoom in enough, we start to see an *unsmooth* representation
    of the image, in other words, pixelation. By increasing the resolution or **dots
    per inch** (**DPI**) of the image, we are less likely to observe pixelation. Agg,
    Cairo, and GDK belong to this group of backends. The following table summarizes
    the key functionalities and differences among the non-interactive backends:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 光栅图形通过有限数量的微小颜色块（像素）来描述图像。所以，如果我们足够放大，就会看到图像的*不平滑*表现，换句话说，就是像素化。通过提高图像的分辨率或**每英寸点数**（**DPI**），我们不太可能观察到像素化现象。Agg、Cairo
    和 GDK 属于这一类后端。下表总结了非交互式后端的主要功能和差异：
- en: '| Backend | Vector or raster? | Output formats |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| 后端 | 矢量还是光栅？ | 输出格式 |'
- en: '| Agg | Raster | `.png` |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| Agg | 光栅 | `.png` |'
- en: '| Cairo | Vector/Raster | `.pdf`, `.png`, `.ps`, `.svg` |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| Cairo | 矢量/光栅 | `.pdf`, `.png`, `.ps`, `.svg` |'
- en: '| PDF | Vector | `.pdf` |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| PDF | 矢量 | `.pdf` |'
- en: '| PGF | Vector | `.pdf`, `.pgf` |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| PGF | 矢量 | `.pdf`, `.pgf` |'
- en: '| PS | Vector | `.ps` |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| PS | 矢量 | `.ps` |'
- en: '| SVG | Vector | `.svg` |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| SVG | 矢量 | `.svg` |'
- en: '| GDK* | Raster | `.png`, `.jpg`, `.tiff` |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| GDK* | 光栅 | `.png`, `.jpg`, `.tiff` |'
- en: '*Deprecated in Matplotlib 2.0.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '*Matplotlib 2.0 中已弃用。'
- en: 'Normally, we don''t need to manually select a backend, as the default choice
    would work great for most tasks. On the other hand, we can specify a backend through
    the `matplotlib.use()` method before importing `matplotlib.pyplot` for the **first**
    time:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们不需要手动选择后端，因为默认的选择适用于大多数任务。另一方面，我们可以通过在首次导入 `matplotlib.pyplot` 之前使用 `matplotlib.use()`
    方法指定后端：
- en: '[PRE17]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '![](img/09f26012-7935-4384-adc2-bcaf167d749f.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![](img/09f26012-7935-4384-adc2-bcaf167d749f.png)'
- en: Interactive backends
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 交互式后端
- en: Matplotlib can build interactive figures that are far more engaging for readers.
    Sometimes, a plot might be overwhelmed with graphical elements, making it hard
    to discern individual data points. On other occasions, some data points may appear
    so similar, in which it could be hard to spot the differences with our naked eyes.
    An interactive plot can address these two scenarios by allowing us to zoom in,
    zoom out, pan, and explore the plot in the way we want.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Matplotlib 可以构建比静态图形更具互动性的图形，这对于读者来说更具吸引力。有时，图形可能会被过多的图形元素淹没，使得难以分辨单独的数据点。在其他情况下，一些数据点可能看起来非常相似，肉眼很难察觉它们之间的差异。交互式图形可以通过允许我们缩放、平移和按照自己的方式探索图形来解决这两种情况。
- en: 'Through the use of interactive backends, plots in Matplotlib can be embedded
    in **graphical user interfaces** (**GUI**) applications. By default, Matplotlib
    supports the pairing of the Agg raster graphics renderer with a wide variety of
    GUI toolkits, including wxWidgets (Wx), GIMP Toolkit (GTK+), Qt and TkInter (Tk).
    As Tkinter is the de facto standard GUI for Python, which is built on top of Tcl/Tk,
    we can create an interactive plot with nothing more than calling `plt.show()`
    in a standalone Python script. Let''s try to copy the following code to a separate
    text file and name it `interactive.py`. After that, type `python interactive.py`
    in your Terminal (Mac/Linux) or Command Prompt (Windows). If you are unsure about
    how to open a Terminal or Command Prompt, please refer to [Chapter 1](840a0403-49de-4053-adf9-bf389ed96cf5.xhtml), *Introduction
    to Matplotlib*, for more details:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用交互式后端，Matplotlib 中的图形可以嵌入到**图形用户界面**（**GUI**）应用程序中。默认情况下，Matplotlib 支持将
    Agg 光栅图形渲染器与多种 GUI 工具包配对，包括 wxWidgets（Wx）、GIMP 工具包（GTK+）、Qt 和 TkInter（Tk）。由于 Tkinter
    是 Python 的事实标准 GUI，构建于 Tcl/Tk 之上，我们只需在独立的 Python 脚本中调用 `plt.show()` 就可以创建交互式图形。我们可以尝试将以下代码复制到单独的文本文件中，并命名为
    `interactive.py`。然后，在终端（Mac/Linux）或命令提示符（Windows）中输入 `python interactive.py`。如果你不确定如何打开终端或命令提示符，请参考[第1章](840a0403-49de-4053-adf9-bf389ed96cf5.xhtml)，*Matplotlib
    介绍*，以获取更多细节：
- en: '[PRE18]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We shall see a pop-up window similar to the following one. We can pan, zoom
    to selection, configure subplot margins, save, and go back and forth between different
    views by clicking on the buttons on the bottom toolbar. If we put our mouse over
    the plot, we can also observe the exact coordinates in the lower-right corner.
    This feature is extremely useful for dissecting data points that are close to
    each other:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到一个类似于以下的弹出窗口。我们可以平移、缩放以选择区域、配置子图边距、保存，并通过点击底部工具栏上的按钮在不同视图之间来回切换。如果我们将鼠标悬停在图表上，还可以在右下角观察到精确的坐标。这个功能对于剖析彼此接近的数据点非常有用：
- en: '![](img/6e180f63-ddca-4a58-ada0-43ed0d124acc.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6e180f63-ddca-4a58-ada0-43ed0d124acc.png)'
- en: 'Next, we are going to extend the application by adding a radio button widget
    on top of the figure, such that we can switch between the display of weekly earnings
    or unemployment rates. The radio button can be found in `matplotlib.widgets`,
    and we are going to attach a data updating function to the `.on_clicked()` event
    of the button. You can paste the following code right before the `plt.show()`
    line to the previous code example (`interactive.py`). Let''s see how it works:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将通过在图形上方添加一个单选按钮控件来扩展应用程序，从而可以在显示每周收入或失业率之间切换。单选按钮位于`matplotlib.widgets`中，我们将把一个数据更新函数附加到按钮的`.on_clicked()`事件上。你可以将以下代码粘贴到之前代码示例（`interactive.py`）中的`plt.show()`行之前。让我们看看它是如何工作的：
- en: '[PRE19]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You will be welcomed by a new radio selector box on top of the plot. Try switching
    between the two states and see if the figure would be updated accordingly. The
    complete code is also available in the code bundle:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到图表顶部出现一个新的单选框。尝试在两种状态之间切换，看看图形是否会相应更新。完整代码也可以在代码包中找到：
- en: '![](img/57ac5081-9361-4cc7-aa1b-8cea80ae2003.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](img/57ac5081-9361-4cc7-aa1b-8cea80ae2003.png)'
- en: 'Before we conclude this section, we are going to introduce one more interactive
    backend that is rarely covered by books. Starting with Matplotlib 1.4, there is
    an interactive backend specifically designed for Jupyter Notebook. To invoke that,
    we simply need to paste `%matplotlib notebook` at the start of your notebook.
    We are going to adapt one of the earlier examples in this chapter to use this
    backend:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束本节之前，我们将介绍一种很少在书籍中提及的交互式后端。从 Matplotlib 1.4 开始，提供了一种专为 Jupyter Notebook
    设计的交互式后端。要调用它，我们只需要在笔记本的开始处粘贴`%matplotlib notebook`。我们将调整本章早些时候的一个示例来使用这个后端：
- en: '[PRE20]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The following interactive plot will be embedded right into your Jupyter Notebook:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 以下交互式图表将嵌入到你的 Jupyter Notebook 中：
- en: '![](img/e06418fb-48b0-4652-943c-7e2b81d29a75.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e06418fb-48b0-4652-943c-7e2b81d29a75.png)'
- en: Creating animated plot
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建动画图
- en: Matplotlib was not designed as an animation package from the get-go, and thus
    it would appear sluggish in some advanced usages. For animation-centric applications,
    PyGame is a very good alternative ([https://www.pygame.org](https://www.pygame.org))
    which supports OpenGL- and Direct3D-accelerated graphics for the ultimate speed
    in animating objects. Nevertheless, Matplotlib has acceptable performance most
    of the time, and we will guide you through the steps to create animations that
    are more engaging than static plots.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Matplotlib 最初并不是为动画包设计的，因此在某些高级用途中它的表现可能显得有些迟缓。对于以动画为中心的应用程序，PyGame 是一个非常好的替代方案（[https://www.pygame.org](https://www.pygame.org)），它支持
    OpenGL 和 Direct3D 加速图形，提供极致的动画速度。不过，Matplotlib 在大多数时候的表现是可以接受的，我们将引导你完成创建比静态图更具吸引力的动画的步骤。
- en: Before we start making animations, we need to install either FFmpeg, avconv,
    mencoder, or ImageMagick on our system. These additional dependencies are not
    bundled with Matplotlib, and thus we need to install them separately. We are going
    to walk you through the steps of installing FFmpeg.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始制作动画之前，我们需要在系统上安装 FFmpeg、avconv、mencoder 或 ImageMagick 其中之一。这些附加依赖项没有与 Matplotlib
    捆绑在一起，因此我们需要单独安装它们。我们将带你逐步完成安装 FFmpeg 的步骤。
- en: For Debian-based Linux users, FFmpeg can be installed by simply issuing the
    following command in Terminal.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 对于基于 Debian 的 Linux 用户，只需在终端中输入以下命令即可安装 FFmpeg。
- en: '[PRE21]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: For Mac users, Homebrew ([https://brew.sh/](https://brew.sh/)) is the simplest
    way to search and install `ffmpeg` package. If you don't have Homebrew, you can
    paste the following code into your Terminal to install it.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Mac 用户，Homebrew（[https://brew.sh/](https://brew.sh/)）是搜索和安装`ffmpeg`软件包的最简单方式。如果你没有安装
    Homebrew，可以将以下代码粘贴到终端中进行安装。
- en: '[PRE22]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'After that, we can install FFmpeg by issuing the following command in the Terminal:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以通过在终端输入以下命令来安装 FFmpeg：
- en: '[PRE23]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Alternatively, you may install FFmpeg by copying the binaries ([https://evermeet.cx/ffmpeg/](https://evermeet.cx/ffmpeg/))
    to the system path (for example, `/usr/local/bin`).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，您也可以通过将二进制文件复制到系统路径（例如，`/usr/local/bin`）来安装 FFmpeg（[https://evermeet.cx/ffmpeg/](https://evermeet.cx/ffmpeg/)）。
- en: The installation for Windows users is quite a bit more involved, but luckily
    there is a detailed guide on wikiHow ([https://www.wikihow.com/Install-FFmpeg-on-Windows](https://www.wikihow.com/Install-FFmpeg-on-Windows)).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Windows 用户，安装过程稍微复杂一些，但幸运的是，wikiHow 上有一份详细的安装指南（[https://www.wikihow.com/Install-FFmpeg-on-Windows](https://www.wikihow.com/Install-FFmpeg-on-Windows)）。
- en: 'Matplotlib provides two main interfaces for creating animations: `TimedAnimation`
    and `FuncAnimation`. `TimedAnimation` is useful for creating time-based animation,
    while `FuncAnimation` can be used to create animation according to a custom-defined
    function. Given by the much higher level of flexibility offered by `FuncAnimation`,
    we will only explore the use of `FuncAnimation` in this section. Interested readers
    can refer to the official documentation ([https://matplotlib.org/api/animation_api.html](https://matplotlib.org/api/animation_api.html))
    for more information about `TimedAnimation`.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Matplotlib 提供了两种主要的动画创建接口：`TimedAnimation` 和 `FuncAnimation`。`TimedAnimation`
    适用于创建基于时间的动画，而 `FuncAnimation` 可以根据自定义函数来创建动画。由于 `FuncAnimation` 提供了更高的灵活性，我们将在本节中仅探讨
    `FuncAnimation` 的使用。有兴趣的读者可以参考官方文档（[https://matplotlib.org/api/animation_api.html](https://matplotlib.org/api/animation_api.html)）了解更多关于
    `TimedAnimation` 的信息。
- en: 'In the following example, we simulated the change in median weekly earnings
    by assuming a 5% annual increase. We are going to create a custom function—animate,
    which returns Matplotlib `Artist` objects that are changed in each frame. This
    function will be supplied to `animation.FuncAnimation()` together with a few more
    extra parameters:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们通过假设每年增加 5% 来模拟中位数周薪的变化。我们将创建一个自定义函数—animate，该函数返回在每一帧中发生变化的 Matplotlib
    `Artist` 对象。该函数将与一些额外的参数一起传递给 `animation.FuncAnimation()`：
- en: '[PRE24]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Here is the resultant video:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是生成的视频：
- en: '[https://github.com/PacktPublishing/Matplotlib-for-Python-Developers-Second-Edition/blob/master/extra_ch9/ch09_animation.mp4](https://github.com/PacktPublishing/Matplotlib-for-Python-Developers-Second-Edition/blob/master/extra_ch9/ch09_animation.mp4)'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Matplotlib-for-Python-Developers-Second-Edition/blob/master/extra_ch9/ch09_animation.mp4](https://github.com/PacktPublishing/Matplotlib-for-Python-Developers-Second-Edition/blob/master/extra_ch9/ch09_animation.mp4)'
- en: In the preceding example, we output animation in the form of MPEG-4 encoded
    videos. The video can also be embedded in Jupyter Notebook in the form of H.264
    encoded video. All you need to do is to call the `Animation.to_html5_video()` method,
    and supply the returned object to `IPython.display.HTML`. Video encoding and HTML5
    code generation will happen automagically behind the scenes.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们以 MPEG-4 编码视频的形式输出动画。该视频也可以以 H.264 编码视频的形式嵌入到 Jupyter Notebook 中。只需要调用
    `Animation.to_html5_video()` 方法，并将返回的对象传递给 `IPython.display.HTML`，视频编码和 HTML5
    代码生成会在后台自动完成。
- en: Starting from version 2.2.0, Matplotlib supports the creation of animated GIF
    writing via the Pillow imaging library and ImageMagick. As the WWW is never tired
    of GIFs, let's learn how to create one!
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本 2.2.0 开始，Matplotlib 支持通过 Pillow 图像库和 ImageMagick 创建动画 GIF。由于互联网对 GIF 的热爱永无止境，让我们来学习如何创建一个
    GIF 吧！
- en: Before we are able to create animated GIFs, we need to install ImageMagick first.
    The download links and the installation instructions for all major platforms can
    be found here: [https://www.imagemagick.org/script/download.php](https://www.imagemagick.org/script/download.php).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够创建动画 GIF 之前，我们需要先安装 ImageMagick。所有主要平台的下载链接和安装说明可以在此找到：[https://www.imagemagick.org/script/download.php](https://www.imagemagick.org/script/download.php)。
- en: Once the package is installed, we can generate animated GIFs by changing the
    line `anim.save('test.mp4')` to `anim.save('test.gif', writer='imagemagick', fps=10)`.
    The `fps` parameter denotes the frame rate of the animation.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 安装该包后，我们可以通过将 `anim.save('test.mp4')` 改为 `anim.save('test.gif', writer='imagemagick',
    fps=10)` 来生成动画 GIF。`fps` 参数表示动画的帧率。
- en: 'Here is the resultant animated GIF:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是生成的动画 GIF：
- en: '[https://github.com/PacktPublishing/Matplotlib-for-Python-Developers-Second-Edition/blob/master/extra_ch9/ch%2009_GIF.gif](https://github.com/PacktPublishing/Matplotlib-for-Python-Developers-Second-Edition/blob/master/extra_ch9/ch%2009_GIF.gif)'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Matplotlib-for-Python-Developers-Second-Edition/blob/master/extra_ch9/ch%2009_GIF.gif](https://github.com/PacktPublishing/Matplotlib-for-Python-Developers-Second-Edition/blob/master/extra_ch9/ch%2009_GIF.gif)'
- en: Summary
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, you learned how to parse online data in CSV or JSON formats
    using the versatile pandas package. You further learned how to filter, subset,
    merge, and process data into insights. Finally, you learned how to scrape information
    directly from websites. You have now equipped yourself with the knowledge to visualize
    time series, univariate, and bivariate data. The chapter concluded with a number
    of useful techniques to customize figure aesthetics for effective storytelling.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何使用多功能的pandas包解析在线的CSV或JSON格式数据。你还进一步学习了如何筛选、子集化、合并和处理数据以提取洞察。最后，你学会了如何直接从网站上抓取信息。现在，你已经掌握了可视化时间序列、单变量和双变量数据的知识。本章以一系列有用的技巧结束，这些技巧可以帮助你定制图形美学，以进行有效的故事讲述。
- en: Phew! We have just completed a long chapter, so go grab a burger, have a break,
    and relax.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 呼！我们刚刚完成了一个长章节，去吃个汉堡，休息一下，放松放松吧。
