- en: Chapter 5. SciPy for Signal Processing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章. SciPy信号处理
- en: We define a signal as data that measures either time-varying or spatially varying
    phenomena. Sound or electrocardiograms are excellent examples of time-varying
    quantities, while images embody the quintessential spatially varying cases. Moving
    images (movies or videos) are treated with the techniques of both types of signals,
    obviously.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将信号定义为测量时间变化或空间变化现象的数据。声音或心电图是时间变化量的优秀例子，而图像则体现了典型的空间变化情况。动态图像（电影或视频）显然使用了这两种信号类型的技术。
- en: The field of signal processing treats four aspects of this kind of data – its
    acquisition, quality improvement, compression, and feature extraction. SciPy has
    many routines to treat tasks effectively in any of the four fields. All these
    are included in two low-level modules (`scipy.signal` being the main one, with
    an emphasis in time-varying data, and `scipy.ndimage`, for images). Many of the
    routines in these two modules are based on Discrete Fourier Transform of the data.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 信号处理领域处理此类数据的四个方面——其获取、质量改进、压缩和特征提取。SciPy有许多例程可以有效地处理四个领域中的任何一项任务。所有这些都被包含在两个低级模块中（`scipy.signal`是主要的一个，侧重于时变数据，而`scipy.ndimage`用于图像）。这两个模块中的许多例程都是基于数据的离散傅里叶变换。
- en: 'In this chapter, we will cover the following things:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Definition of background algorithms, `scipy.fftpack`
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 背景算法的定义，`scipy.fftpack`
- en: Built-in functions for signal construction
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信号构建的内建函数
- en: Presentation of functions to filter spatial or time series signals
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数的展示，用于过滤空间或时间序列信号
- en: Additional details on the subject can be found in *Python for Signal Processing*,
    *Unpingco José*, *Springer Publishing*.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 关于该主题的更多详细信息可以在*Python for Signal Processing*，*Unpingco José*，*Springer Publishing*中找到。
- en: Discrete Fourier Transforms
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 离散傅里叶变换
- en: Discrete Fourier Transform (DFT) transforms any signal from its time/space domain
    into a related signal in frequency domain. This allows us not only to analyze
    the different frequencies of the data, but also enables faster filtering operations,
    when used properly. It is possible to turn a signal in frequency domain back to
    its time/spatial domain, thanks to the Inverse Fourier Transform (IFT). We will
    not go into details of the mathematics behind these operators, since we assume
    familiarity at some level with this theory. We will focus on syntax and applications
    instead.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 离散傅里叶变换（DFT）将任何信号从其时间/空间域转换到相关频率域的信号。这使我们不仅能够分析数据的不同频率，而且当正确使用时，还能实现更快的滤波操作。由于逆傅里叶变换（IFT）的存在，我们还可以将频率域中的信号转换回其时间/空间域。由于我们假设对这种理论有一定程度的熟悉，因此我们不会深入探讨这些算子背后的数学细节。我们将专注于语法和应用。
- en: 'The basic routines in the `scipy.fftpack` module compute the DFT and its inverse,
    for discrete signals in any dimension – `fft`, `ifft` (one dimension); `fft2`,
    `ifft2` (two dimensions); `fftn`, `ifftn` (any number of dimensions). All of these
    routines assume that the data is complex valued. If we know beforehand that a
    particular dataset is actually real valued, and should offer real-valued frequencies,
    we use `rfft` and `irfft` instead, for a faster algorithm. All these routines
    are designed so that composition with their inverses always yields the identity.
    The syntax is the same in all cases, as follows:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '`scipy.fftpack`模块中的基本例程计算DFT及其逆变换，适用于任何维度的离散信号——`fft`，`ifft`（一维）；`fft2`，`ifft2`（二维）；`fftn`，`ifftn`（任意维数）。所有这些例程都假设数据是复值。如果我们事先知道特定的数据集实际上是实值，并且应该提供实值频率，我们则使用`rfft`和`irfft`，以获得更快的算法。所有这些例程都设计得使得与它们的逆运算组合总是得到恒等变换。所有情况下的语法都是相同的，如下所示：'
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first parameter, `x`, is always the signal in any array-like form. Note
    that `fft` performs one-dimensional transforms. This means that if `x` happens
    to be two-dimensional, for example, `fft` will output another two-dimensional
    array where each row is the transform of each row of the original. We can use
    columns instead, with the optional parameter, `axis`. The rest of the parameters
    are also optional; `n` indicates the length of the transform and `overwrite_x`
    gets rid of the original data to save memory and resources. We usually play with
    the integer `n` when we need to pad the signal with zeros, or truncate it. For
    a higher dimension, `n` is substituted by `shape` (a tuple), and `axis` by `axes`
    (another tuple).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数，`x`，总是任何数组形式的信号。请注意，`fft`执行一维变换。这意味着如果`x`是二维的，例如，`fft`将输出另一个二维数组，其中每一行是原始每一行的变换。我们可以使用列代替，通过可选参数`axis`。其余参数也是可选的；`n`表示变换的长度，`overwrite_x`移除原始数据以节省内存和资源。我们通常在需要用零填充信号或截断它时玩整数`n`。对于更高维数，`n`由`shape`（一个元组）替换，`axis`由`axes`（另一个元组）替换。
- en: 'To better understand the output, it is often useful to shift the zero frequencies
    to the center of the output arrays with `fftshift`. The inverse of this operation,
    `ifftshift`, is also included in the module. The following code shows some of
    these routines in action when applied to a checkerboard image:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解输出，通常使用`fftshift`将零频率移到输出数组的中心是有用的。该操作的逆操作`ifftshift`也包含在该模块中。以下代码展示了当应用于棋盘图像时，这些例程的一些实际应用：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note how the first four rows of the one-dimensional transform are equal (and
    so are the last four), while the two-dimensional transform (once shifted) presents
    a peak at the origin and nice symmetries in the frequency domain.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 注意一维变换的前四行是相等的（后四行也是如此），而二维变换（一旦移位）在原点处呈现峰值，并在频域中表现出良好的对称性。
- en: 'In the following screenshot, which has been obtained from the previous code,
    the image on the left is `fft` and the one on the right is `fft2` of a 2 x 2 checkerboard
    signal:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下屏幕截图（由前面的代码获得）中，左边的图像是`fft`，右边的图像是2 x 2棋盘信号的`fft2`：
- en: '![Discrete Fourier Transforms](img/7702OS_05_01.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![离散傅里叶变换](img/7702OS_05_01.jpg)'
- en: The `scipy.fftpack` module also offers the Discrete Cosine Transform with its
    inverse (`dct`, `idct`) as well as many differential and pseudo-differential operators
    defined in terms of all these transforms – `diff` (for derivative/integral); `hilbert`,
    `ihilbert` (for the Hilbert transform); `tilbert`, `itilbert` (for the h-Tilbert
    transform of periodic sequences); and so on.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`scipy.fftpack`模块还提供了离散余弦变换及其逆变换（`dct`，`idct`），以及许多以所有这些变换为定义的微分和伪微分算子 – `diff`（用于导数/积分）；`hilbert`，`ihilbert`（用于希尔伯特变换）；`tilbert`，`itilbert`（用于周期序列的h-Tilbert变换）等等。'
- en: Signal construction
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 信号构造
- en: 'To aid the construction of signals with predetermined properties, the `scipy.signal`
    module has a nice collection of the most frequent one-dimensional waveforms in
    the literature – `chirp` and `sweep_poly` (for the frequency-swept cosine generator),
    `gausspulse` (a Gaussian modulated sinusoid), `sawtooth` and `square` (for the
    waveforms with those names). They all take as their main parameter a one-dimensional
    `ndarray` representing the times at which the signal is to be evaluated. Other
    parameters control the design of the signal according to frequency or time constraints.
    Let''s take a look into the following code snippet which illustrates the use of
    these one dimensional waveforms that we just discussed:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助构建具有预定属性的信号，`scipy.signal`模块提供了一系列文献中最常见的单维波形 – `chirp`和`sweep_poly`（用于频率扫描余弦发生器），`gausspulse`（高斯调制的正弦波），`sawtooth`和`square`（用于具有这些名称的波形）。它们都以一维`ndarray`作为主要参数，表示信号要评估的时间。其他参数根据频率或时间约束控制信号的设计。让我们看看以下代码片段，它说明了我们刚才讨论的这些一维波形的用法：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Generated by this code, the following diagram shows waveforms for `chirp`,
    `gausspulse`, `sawtooth`, and `square`:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 由此代码生成的以下图表显示了`chirp`，`gausspulse`，`sawtooth`和`square`的波形：
- en: '![Signal construction](img/7702OS_05_02.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![信号构造](img/7702OS_05_02.jpg)'
- en: 'The usual method of creating signals is to import them from a file. This is
    possible by using purely NumPy routines; for example, `fromfile`:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '创建信号的传统方法是从文件中导入它们。这可以通过使用纯NumPy例程来实现；例如，`fromfile`:'
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `file` argument may point to either a file or a string, the `count` argument
    is used to determine the number of items to read, and `sep` indicates what constitutes
    a separator in the original file/string. For images, we have the versatile routine,
    `imread` in in either the `scipy.ndimage` or `scipy.misc` module:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`file`参数可以指向一个文件或一个字符串，`count`参数用于确定要读取的项目数量，而`sep`表示原始文件/字符串中的分隔符。对于图像，我们有通用的例程`imread`，在`scipy.ndimage`或`scipy.misc`模块中：'
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `fname` argument is a string containing the location of an image. The routine
    infers the type of file, and reads the data into array accordingly. In case if
    the `flatten` argument is turned to `True`, the image is converted to gray scale.
    Note that, in order for `fromfile` and `imread` to work, the **Python Imaging
    Library** (**PIL**) needs to be installed.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`fname`参数是一个包含图像位置的字符串。例程推断文件类型，并相应地将数据读入数组。如果将`flatten`参数设置为`True`，则图像被转换为灰度。请注意，为了使`fromfile`和`imread`工作，需要安装**Python
    Imaging Library**（**PIL**）。'
- en: 'It is also possible to load `.wav` files for analysis, with the `read` and
    `write` routines from the `wavfile` submodule in the `scipy.io` module. For instance,
    the following line of code reads an audio file, say `audio.wav`, using the `read`
    routine:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以使用`read`和`write`例程从`scipy.io`模块中的`wavfile`子模块加载`.wav`文件进行分析。例如，以下代码行使用`read`例程读取一个音频文件，例如`audio.wav`：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The command assigns an integer value to the `rate` variable, indicating the
    sample rate of the file (in samples per second), and a NumPy `ndarray` to the
    `data` variable, containing the numerical values assigned to the different notes.
    If we wish to write some one-dimensional `ndarray data` into an audio file of
    this kind, with the sample rate given by the `rate` variable, we may do so by
    issuing the following command:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将一个整数值分配给`rate`变量，表示文件的采样率（以每秒样本数计），并将一个NumPy `ndarray`分配给`data`变量，其中包含分配给不同音符的数值。如果我们希望将一些一维`ndarray数据`写入这种类型的音频文件，采样率由`rate`变量给出，我们可以通过以下命令实现：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Filters
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过滤器
- en: A filter is an operation on signals that either removes features or extracts
    some component. SciPy has a complete set of known filters as well as the tools
    to allow construction of new ones. The complete list of filters in SciPy is long,
    and we encourage the reader to explore the help documents of the `scipy.signal`
    and `scipy.ndimage` modules for the complete picture. We will introduce in these
    pages, as an exposition, some of the most used filters in the treatment of audio
    or image processing.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 滤波器是对信号的操作，要么去除特征，要么提取某些成分。SciPy提供了一套完整的已知滤波器以及构建新滤波器的工具。SciPy中的滤波器列表很长，我们鼓励读者探索`scipy.signal`和`scipy.ndimage`模块的帮助文档以获得完整的信息。在这些页面上，我们将介绍一些在音频或图像处理中常用的滤波器。
- en: 'We start by creating a signal worth filtering:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个需要过滤的信号：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'First, we test the classical smoothing filter of **Wiener** and **Kolmogorov**,
    `wiener`. We present in a `plot` the original signal (in black) and the corresponding
    filtered data, with a choice of Wiener window of size 55 samples (in blue). Next
    we compare the result of applying the median filter, `medfilt`, with a kernel
    of the same size as before (in red):'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们测试了**Wiener**和**Kolmogorov**的经典平滑滤波器`wiener`。我们在`plot`中展示了原始信号（黑色）和相应的滤波数据，选择Wiener窗口大小为55个样本（蓝色）。接下来，我们比较了应用具有与之前相同大小的核的中值滤波器`medfilt`的结果（红色）：
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This gives us the following graph showing the comparison of smoothing filters
    (**Wiener**, in red, is the one that has its starting point just above **0.5**
    and **Medfilt**, in blue, has its starting point just below **0.5**):'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这给出了以下图表，显示了平滑滤波器（红色的是**Wiener**，其起点正好在**0.5**上方，蓝色的是**Medfilt**，其起点在**0.5**下方）的比较：
- en: '![Filters](img/7702OS_05_03.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![过滤器](img/7702OS_05_03.jpg)'
- en: 'Most of the filters in the `scipy.signal` module can be adapted to work with
    arrays of any dimension. But in the particular case of images, we prefer to use
    the implementations in the `scipy.ndimage` module, since they are coded with these
    objects in mind. For instance, to perform a median filter on an image for smoothing,
    we use `scipy.ndimage.median_filter`. Let us show an example. We will start by
    loading Lena to array, and corrupting the image with Gaussian noise (zero mean
    and standard deviation of 16):'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`scipy.signal`模块中的大多数滤波器都可以适应与任何维度的数组一起工作。但在图像的特定情况下，我们更倾向于使用`scipy.ndimage`模块中的实现，因为它们是针对这些对象编写的。例如，为了对图像执行中值滤波以平滑处理，我们使用`scipy.ndimage.median_filter`。让我们看一个例子。我们将首先将Lena加载为数组，并用高斯噪声（均值为零，标准差为16）对图像进行破坏：'
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The set of filters for images come in two flavors – statistical and morphological.
    For example, among the filters of statistical nature, we have the **Sobel** algorithm
    oriented to detection of edges (singularities along curves). Its syntax is as
    follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图像滤波器集有两种类型——统计和形态。例如，在具有统计性质的滤波器中，我们有**索贝尔**算法，该算法面向边缘检测（曲线上的奇点）。其语法如下：
- en: '[PRE10]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The optional parameter, `axis`, indicates the dimension in which the computations
    are performed. By default, this is always the last axis (-1). The `mode` parameter,
    which is one of the strings `''reflect''`, `''constant''`, `''nearest''`, `''mirror''`,
    or `''wrap''`, indicates how to handle the border of the image in case there is
    insufficient data to perform the computations there. In case `mode` is `''constant''`,
    we may indicate the value to use in the border with the `cval` parameter. Let''s
    look into the following code snippet which illustrates the use of `sobel` filter:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 可选参数`axis`表示计算所进行的维度。默认情况下，这始终是最后一个轴（-1）。`mode`参数，它可以是字符串`'reflect'`、`'constant'`、`'nearest'`、`'mirror'`或`'wrap'`之一，表示在数据不足无法进行计算时如何处理图像的边界。如果`mode`是`'constant'`，我们可以使用`cval`参数来指定用于边界的值。让我们看看以下代码片段，它说明了`sobel`滤波器的使用：
- en: '[PRE11]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The following screenshot illustrates the previous two filters in action—Lena
    (upper-left), noisy Lena (upper-right), edge map with sobel (lower-left), and
    median filter (lower-right):'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了前两个滤波器的实际应用——Lena（左上角）、噪声Lena（右上角）、索贝尔边缘图（左下角）和中值滤波器（右下角）：
- en: '![Filters](img/7702OS_05_04.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![滤波器](img/7702OS_05_04.jpg)'
- en: The LTI system theory
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: LTI系统理论
- en: To investigate the response of a time-invariant linear system to input signals,
    we have many resources in the `scipy.signal` module. As a matter of fact, to simplify
    representation of objects, we have an `lti` class (linear-time invariant class)
    with associated methods such as `bode` (to calculate bode magnitude and phase
    data), `impulse`, `output`, and `step`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了研究时不变线性系统对输入信号的响应，我们在`scipy.signal`模块中拥有许多资源。实际上，为了简化对象的表示，我们有一个`lti`类（线性时不变类），以及与之相关的方法，如`bode`（用于计算博德幅度和相位数据）、`impulse`、`output`和`step`。
- en: Whether we are working with continuous or discrete-time linear systems, we have
    routines to simulate such systems (`lsim` and `lsim2` for continuous, `dsim` for
    discrete), as well as compute impulses (`impulse` and `impulse2` for continuous,
    `dimpulse` for discrete) and steps (`step` and `step2` for continuous, `dstep`
    for discrete).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们是在处理连续时间还是离散时间线性系统，我们都有模拟此类系统（连续的`lsim`和`lsim2`，离散的`dsim`）、计算冲激（连续的`impulse`和`impulse2`，离散的`dimpulse`）和阶跃（连续的`step`和`step2`，离散的`dstep`）的例程。
- en: Transforming a system from continuous to discrete is possible with `cont2discrete`,
    but in either case we are able to provide for any system with any of its representations,
    as well as to convert from one to another. For instance, if we have the zeros
    `z`, poles `p`, and system gain `k` of the transfer function, we may obtain the
    polynomial representation (numerator first, then denominator) with `zpk2tf(z,p,k)`.
    If we have numerator (`num`) and denominator (`dem`) of the transfer function,
    we obtain the state-space with `tf2ss(num,dem)`. This operation is reversible
    with the `ss2tf` routine. The change of representation from zero-pole-gain to/from
    state-space is also contemplated in the (`zpk2ss`, `ss2zpk`) module.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`cont2discrete`可以将系统从连续转换为离散，但在任何情况下，我们都能为任何系统提供其任何表示形式，以及从一种表示形式转换为另一种表示形式。例如，如果我们有传递函数的零点`z`、极点`p`和系统增益`k`，我们可以使用`zpk2tf(z,p,k)`获得多项式表示（先分子后分母）。如果我们有传递函数的分子（`num`）和分母（`dem`），我们可以使用`tf2ss(num,dem)`获得状态空间。这个操作可以通过`ss2tf`例程进行逆操作。从零极增益到/从状态空间的表示形式变化也在（`zpk2ss`，`ss2zpk`）模块中考虑。
- en: Filter design
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过滤器设计
- en: There are routines in the `scipy.signal` module that allow the creation of different
    kinds of filters with diverse methods. For instance, the `bilinear` function returns
    a digital filter from an analog using a bilinear transform. **Finite impulse response**
    (**FIR**) filters can be designed by the window method with the `firwin` and `firwin2`
    routines. **Infinite impulse response** (**IIR**) filters can be designed in two
    different ways, via `iirdesign` or `iirfilter`. **Butterworth** filters can be
    designed with the `butter` routine. There are also routines to design filters
    of **Chebyshev** (`cheby1`, `cheby2`), **Cauer** (`ellip`), and Bessel (`bessel`).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`scipy.signal`模块中有一些例程允许使用不同的方法创建不同类型的过滤器。例如，`bilinear`函数使用双线性变换将模拟转换为数字滤波器。**有限脉冲响应**（**FIR**）滤波器可以通过`firwin`和`firwin2`例程使用窗口方法设计。**无限脉冲响应**（**IIR**）滤波器可以通过`iirdesign`或`iirfilter`以两种不同的方式设计。**巴特沃斯**滤波器可以通过`butter`例程设计。还有设计**切比雪夫**（`cheby1`，`cheby2`）、**卡乌尔**（`ellip`）和Bessel（`bessel`）滤波器的例程。'
- en: Window functions
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 窗口函数
- en: No signal processing computational system would be complete without an extensive
    list of windows—mathematical functions that are zero valued outside specific domains.
    In this section, we will use a few of the coded windows implemented in the `scipy.signal`
    module to design very simple smoothing filters by using convolution.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 没有广泛列表的窗口——在特定域外为零值的数学函数——的信号处理计算系统将是不完整的。在本节中，我们将使用`scipy.signal`模块中实现的一些编码窗口，通过卷积设计非常简单的平滑滤波器。
- en: We will be testing them on the same one-dimensional signal we employed before,
    for comparison.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在之前使用的相同一维信号上测试它们，以便进行比较。
- en: 'We start by showing the plot of four well-known window functions – Boxcar,
    Hamming, Blackman-Harris (Nuttall version), and triangular. We will use a size
    of 31 samples:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先展示四个著名的窗口函数的图表——箱形、汉明、布莱克曼-哈里斯（Nuttall版本）和三角形。我们将使用31个样本的大小：
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We need to extend the original signal by fifteen samples for plotting purposes:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为了绘图目的，我们需要将原始信号扩展十五个样本：
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The final step is the filter itself, which we perform by a simple convolution:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是过滤器本身，我们通过简单的卷积来实现：
- en: '[PRE14]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This produces the following output, showing convolution of a signal with different
    windows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这会产生以下输出，显示信号与不同窗口的卷积：
- en: '![Window functions](img/7702OS_05_05.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![窗口函数](img/7702OS_05_05.jpg)'
- en: Image interpolation
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图像插值
- en: The set of filters on images that performs some geometric manipulation of the
    input is classically termed image interpolation, since this numerical technique
    is the root of all the algorithms. As a matter of fact, SciPy collects all these
    under the submodule, `scipy.ndimage.interpolation`, for ease of access. This section
    is best explained through examples, going over the most meaningful routines for
    geometric transformation. The starting point is the image, Lena. We now assume
    that all functions from the submodule have been imported into the session.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 对图像进行某些几何操作的过滤器集合在经典上被称为图像插值，因为这种数值技术是所有算法的根源。实际上，SciPy将这些功能收集在子模块`scipy.ndimage.interpolation`下，以便于访问。本节最好通过示例来解释，涵盖几何变换中最有意义的例程。起点是图像，Lena。我们现在假设子模块中的所有函数都已导入会话中。
- en: 'We need to apply an affine transformation on the domain of the image, given
    in matrix form as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在图像的域上应用一个仿射变换，如下矩阵形式给出：
- en: '![Image interpolation](img/7702OS_05_06.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图像插值](img/7702OS_05_06.jpg)'
- en: 'To apply the transformation on the domain of the image we issue the `affine_transform`
    command (note that the syntax is self-explanatory):'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要在图像域上应用变换，我们发出`affine_transform`命令（请注意，语法是自解释的）：
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'For a general transformation, we use the `geometric_transform` routine with
    the following syntax:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一般变换，我们使用`geometric_transform`例程，其语法如下：
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We need to provide a rank-2 map from tuples to tuples as the parameter mapping.
    For instance, we desired to apply the **Möbius** transform for complex-valued
    number `z` (where we assume the values of `a`, `b`, `c`, and `d` are already defined
    and they are complex-valued numbers) in the following formula:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要提供一个从元组到元组的2阶映射作为参数映射。例如，我们希望对复数值`z`（假设`a`、`b`、`c`和`d`的值已经定义，并且它们是复数值）应用**莫比乌斯**变换，如下公式所示：
- en: '![Image interpolation](img/7702OS_05_07.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图像插值](img/7702OS_05_07.jpg)'
- en: 'We would have to code it in the following way:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须以以下方式编写代码：
- en: '[PRE17]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In both functions, the values of the grid that cannot be computed directly with
    the formula are inferred with spline interpolation. We may specify the order of
    this interpolation with the `order` parameter. The points outside the domain of
    definition are not interpolated, but filled according to some predetermined rule.
    We may impose this rule by passing a string to the `mode` option. The choices
    are – `'constant'`, to use a constant value that we may impose with the `cval`
    option; `'nearest'`, that continues the last value of the interpolation on each
    level line; and `'reflect'` or `'wrap'`, which are self-explanatory.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个函数中，无法直接用公式计算的网格值使用样条插值推断。我们可以使用`order`参数指定此插值的顺序。定义域外的点不进行插值，而是根据某些预定的规则填充。我们可以通过传递一个字符串到`mode`选项来强制执行此规则。选项有
    – `'constant'`，使用我们可以通过`cval`选项施加的常数值；`'nearest'`，在每个水平线上继续插值的最后一个值；和`'reflect'`或`'wrap'`，这些是自解释的。
- en: 'For example, for the values `a = 2**15*(1+1j)`, `b = 0`, `c = -2**8*(1-1j*2)`,
    and `d = 2**18-1j*2**14`, we obtain (after imposing the `reflect` mode) the result,
    as shown just after this line of code:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，对于值`a = 2**15*(1+1j)`、`b = 0`、`c = -2**8*(1-1j*2)`和`d = 2**18-1j*2**14`，在应用`reflect`模式后，我们得到的结果，如代码行之后所示：
- en: '[PRE18]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The following screenshot shows affine transformation (left) and geometric transformation
    (right):'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了仿射变换（左侧）和几何变换（右侧）：
- en: '![Image interpolation](img/7702OS_05_08.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图像插值](img/7702OS_05_08.jpg)'
- en: For special cases of rotations, shifts, or dilations, we have the syntactic
    sugar routines, `rotate(input,angle)`, `shift(input, offset)`, and `zoom(input,dilation_factor)`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 对于旋转、平移或缩放的特殊情况，我们有语法糖例程，`rotate(input,angle)`、`shift(input, offset)`和`zoom(input,dilation_factor)`。
- en: 'Given any image, we know the value of the array at pixel values (with integer
    coordinates) in the domain. But what would the corresponding value of a location
    be without integer coordinates? We may obtain that information with the valuable
    routine, map_coordinates. Note that the syntax may be confusing, especially with
    the `coordinates` parameter:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何图像，我们知道数组在域中像素值（具有整数坐标）的值。但没有整数坐标的位置对应的值是什么？我们可以使用有价值的例程`map_coordinates`来获取这些信息。请注意，语法可能令人困惑，特别是对于`coordinates`参数：
- en: '[PRE19]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'For instance, if we wish to evaluate Lena at the locations (10.5, 11.7) and
    (12.3, 1.4), we collect the coordinates as a sequence of sequences; the first
    internal sequence contains the `x` values, and the second, the `y` values. We
    may specify the order of splines used with `order`, and the interpolation scheme
    outside of the domain, if needed, as in the previous examples. Let''s evaluate
    Lena at the locations (which we just discussed in our example) using following
    code snippet:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们希望评估Lena在位置（10.5，11.7）和（12.3，1.4），我们收集坐标作为序列的序列；第一个内部序列包含`x`值，第二个，包含`y`值。我们可以使用`order`指定使用的样条顺序，如果需要，在域外指定插值方案，如前例所示。让我们使用以下代码片段评估Lena在（我们刚才在示例中讨论的位置）：
- en: '[PRE20]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The output is shown as:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE21]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Further, we evaluate Lena with `order=2` as shown in following line of code:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们使用`order=2`评估Lena，如下代码行所示：
- en: '[PRE22]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The output is shown as:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE23]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Morphology
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 形态学
- en: 'We also have the possibility of creating and applying filters to images based
    on mathematical morphology, both to binary and gray-scale images. The four basic
    morphological operations are opening (`binary_opening`), closing (`binary_closing`),
    dilation (`binary_dilation`), and erosion (`binary_erosion`). Note that the syntax
    of each of these filters is very simple, since we only need two ingredients –
    the signal to filter and the structuring element to perform the morphological
    operation. Let''s take a look into the general syntax for these morphological
    operations:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有可能基于数学形态学创建和应用图像过滤器，这些过滤器既可以应用于二值图像，也可以应用于灰度图像。四种基本的形态学操作是开运算（`binary_opening`）、闭运算（`binary_closing`）、膨胀（`binary_dilation`）和腐蚀（`binary_erosion`）。请注意，每个这些过滤器的语法都非常简单，因为我们只需要两个成分——要过滤的信号和执行形态学操作的结构元素。让我们来看看这些形态学操作的一般语法：
- en: '[PRE24]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We have illustrated the use some of these operations towards an application
    to obtain the structural model of an oxide, but we will postpone this example
    until we cover the notions of triangulations and Voronoi diagrams in [Chapter
    7](ch07.html "Chapter 7. SciPy for Computational Geometry"), *SciPy for Computational
    Geometry*.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经展示了这些操作在获取氧化物结构模型中的应用，但我们将把这个例子推迟到我们介绍[第7章](ch07.html "第7章。SciPy计算几何")中的三角剖分和Voronoi图概念时再进行。
- en: 'We may use combinations of these four basic morphological operations to create
    more complex filters for the removal of holes, hit-or-miss transforms (to find
    the location of specific patterns in binary images), denoising, edge detection,
    and many more. The module even provides us with some of the most common filters
    constructed this way. For instance, for the location of the letter e in a text
    (which we covered in [Chapter 2](ch02.html "Chapter 2. Working with the NumPy
    Array As a First Step to SciPy"), *Working with the NumPy Array As a First Step
    to SciPy*, as an application of correlation), we could use the following command
    instead:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这四种基本形态学操作的组合来创建更复杂的过滤器，用于去除孔洞、点中击或未击变换（用于在二值图像中找到特定模式的位置）、降噪、边缘检测等等。该模块甚至为我们提供了一些最常用的这种方式的过滤器。例如，对于文本中字母e的位置（我们已在[第2章](ch02.html
    "第2章。作为SciPy计算几何第一步的NumPy数组处理")中介绍过，*作为SciPy计算几何第一步的NumPy数组处理*，作为相关性的应用），我们可以使用以下命令代替：
- en: '[PRE25]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'For comparative purposes, let''s apply this command to the example from [Chapter
    2](ch02.html "Chapter 2. Working with the NumPy Array As a First Step to SciPy"),
    *Working with the NumPy Array As a First Step to SciPy*:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为了比较的目的，让我们将此命令应用于[第2章](ch02.html "第2章。作为SciPy计算几何第一步的NumPy数组处理")中的示例，*作为SciPy计算几何第一步的NumPy数组处理*：
- en: '[PRE26]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This generates the following output, which the reader should compare with the
    corresponding one on [Chapter 2](ch02.html "Chapter 2. Working with the NumPy
    Array As a First Step to SciPy"), *Working with the NumPy Array As a First Step
    to SciPy*:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成以下输出，读者应该将其与[第2章](ch02.html "第2章。作为SciPy计算几何第一步的NumPy数组处理")中的对应输出进行比较，*作为SciPy计算几何第一步的NumPy数组处理*：
- en: '![Morphology](img/7702OS_05_09.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![形态学](img/7702OS_05_09.jpg)'
- en: 'For gray-scale images, we may use a structuring element (`structuring_element`)
    or a footprint. The syntax is, therefore, a little different:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 对于灰度图像，我们可以使用结构元素（`structuring_element`）或足迹。因此，语法略有不同：
- en: '[PRE27]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If we desire to use a completely flat and rectangular structuring element (all
    *ones*), then it is enough to indicate the size as a tuple. For instance, to perform
    gray-scale dilation of a flat element of `size (15,15)` on our classical image
    of Lena, we issue the following command:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望使用一个完全平坦且矩形的结构元素（所有*1*），那么只需要用一个元组来表示其大小即可。例如，为了在我们的经典图像Lena上对`size (15,15)`的平坦元素进行灰度膨胀，我们发出以下命令：
- en: '[PRE28]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The last kind of morphological operations coded in the scipy.ndimage module
    perform distance and feature transforms. Distance transforms create a map that
    assigns to each pixel the distance to the nearest object. Feature transforms provide
    the index of the closest background element instead. These operations are used
    to decompose images into different labels. We may even choose different metrics
    such as Euclidean distance, chessboard distance, and **taxicab** distance. The
    syntax for the distance transform (`distance_transform`) using a brute force algorithm
    is as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: scipy.ndimage模块中编码的最后一种形态学操作执行距离和特征变换。距离变换创建一个映射，将每个像素分配到最近的对象的距离。特征变换则提供最近背景元素的索引。这些操作用于将图像分解为不同的标签。我们甚至可以选择不同的度量标准，如欧几里得距离、棋盘距离和**出租车**距离。使用暴力算法的距离变换（`distance_transform`）的语法如下：
- en: '[PRE29]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We indicate the metric with the strings such as `'euclidean'`, `'taxicab'`,
    or `'chessboard'`. If we desire to provide the feature transform instead, we switch
    `return_distances` to `False` and `return_indices` to `True`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用字符串如 `'euclidean'`、`'taxicab'` 或 `'chessboard'` 来指示度量标准。如果我们想提供特征变换，我们将 `return_distances`
    设置为 `False`，将 `return_indices` 设置为 `True`。
- en: Similar routines are available with more sophisticated algorithms – `distance_transform_cdt`
    (using chamfering for taxicab and chessboard distances). For Euclidean distance,
    we also have `distance_transform_edt`. All these use the same syntax.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 使用更复杂的算法，也有类似的程序可用 – `distance_transform_cdt`（使用 chamfering 计算出租车和棋盘距离）。对于欧几里得距离，我们也有
    `distance_transform_edt`。所有这些都使用相同的语法。
- en: Summary
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored signal processing (any dimensional), including
    the treatment of signals in frequency space, by means of their Discrete Fourier
    Transforms. These correspond to the `fftpack`, `signal`, and `ndimage` modules.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了信号处理（任何维度），包括通过它们的离散傅里叶变换来处理频域中的信号。这些对应于 `fftpack`、`signal` 和 `ndimage`
    模块。
- en: The [Chapter 6](ch06.html "Chapter 6. SciPy for Data Mining"), *SciPy for Data
    Mining*, will explore the tools included in SciPy to approach Statistical and
    Data Mining problems. In addition to standard statistical quantities, special
    topics like kernel estimation, statistical distances, and the clustering of big
    data sets will be presented.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '[第6章](ch06.html "第6章。SciPy数据挖掘"), *SciPy数据挖掘*，将探讨SciPy中包含的工具，以解决统计和数据挖掘问题。除了标准统计量之外，还将介绍特殊主题，如核估计、统计距离和大数据集的聚类。'
