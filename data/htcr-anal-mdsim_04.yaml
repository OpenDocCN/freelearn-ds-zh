- en: Computing Foundations – Databases
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算基础 - 数据库
- en: This chapter will introduce you to databases and the **Structured Query Language**
    (**SQL**). It is mainly for healthcare professionals and beginner data scientists
    and programmers who are interested in working with healthcare databases. By the
    end of the chapter, you will know what a database is and how to use basic SQL
    to extract and manipulate information in clinical databases. We will present an
    example task and SQL statements useful for manipulating data in a sample mini-database
    of five patients.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将向你介绍数据库和**结构化查询语言**（**SQL**）。这本书主要面向医疗专业人员和初学者数据科学家、程序员，他们有兴趣使用医疗数据库。通过本章学习，你将了解什么是数据库，并掌握如何使用基本的SQL从临床数据库中提取和操作信息。我们将展示一个任务示例，并给出对操作五个病人样本数据库数据有用的SQL语句。
- en: Introduction to databases
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库简介
- en: A **database** can be defined as a collection of related data (Elmasri and Navathe,
    2010). Databases are often subcategorized as **SQL databases** or **NoSQL databases**.
    In SQL databases, data is recorded in tables and consists of rows and columns.
    The related data may be distributed across several tables in a trade-off between
    efficient storage and convenience. The **database management system** (**DBMS**)
    is a piece of software that enables the database to serve several functions. For
    one thing, it allows for the *retrieval* of data using the SQL language (for SQL
    databases). Another function is to update the data when needed, also using SQL.
    Additional functions of a DBMS include protecting and securing the data.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据库**可以定义为一组相关数据的集合（Elmasri 和 Navathe, 2010）。数据库通常可以分为**SQL数据库**或**NoSQL数据库**。在SQL数据库中，数据以表格的形式记录，并由行和列组成。相关数据可能会分布在多个表格中，这是为了在存储效率和便捷性之间做出权衡。**数据库管理系统**（**DBMS**）是一种软件，它使得数据库能够执行多种功能。首先，它允许使用SQL语言来*检索*数据（适用于SQL数据库）。另一个功能是在需要时更新数据，同样使用SQL。DBMS的其他功能还包括保护和确保数据的安全。'
- en: Database management is a complex field of its own. In this book, we will place
    an emphasis on *using SQL to retrieve and update clinical data that is usually
    distributed across multiple related tables*. For additional comprehensive resources
    on databases, see the *References* section at the end of this chapter.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库管理是一个独立的复杂领域。在本书中，我们将重点讲解*使用SQL来检索和更新通常分布在多个相关表格中的临床数据*。有关数据库的更多全面资源，请参考本章末尾的*参考文献*部分。
- en: Data engineering with SQL – an example case
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SQL进行数据工程——一个案例示例
- en: For this chapter, let's pretend you secured a predictive analytics assignment
    with a cardiology practice located in the United States. The practice wants you
    to predict which patients are at risk of dying within 6 months of their visit
    to the clinic. They make their data available to you in the form of a database
    that includes six tables. For simplicity, we truncate the database to include
    the information for five patients only. Our task is to manipulate the data using
    the SQL language to consolidate it into a single table so that it can be used
    for machine learning. We will first go over the patients in the database and the
    database structure. Then, we will introduce basic SQL concepts for engineering
    and manipulate the data into a form amenable to machine learning.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章内容，假设你获得了一个预测分析的任务，任务对象是位于美国的心脏病科诊所。诊所希望你预测哪些病人在就诊后6个月内有死亡风险。他们以一个包含六个表格的数据库的形式将数据提供给你。为了简化，我们将数据库数据缩减为仅包含五位病人的信息。我们的任务是使用SQL语言对数据进行处理，将其合并成一个表格，以便用于机器学习。我们将首先介绍数据库中的病人和数据库结构。然后，我们将介绍基本的SQL概念，并操作数据使其适应机器学习的要求。
- en: Case details – predicting mortality for a cardiology practice
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 案例详情——预测心脏病科诊所的死亡率
- en: 'The cardiology practice you are working with has two physicians on staff: Dr.
    Johnson and Dr. Wu. While the practice has many patients, they are interested
    in identifying which patients who visit are at high risk of all-cause mortality
    within the next 6 months. Having an outpatient visit sometime in 2016 makes up
    the inclusion criteria for the analytics. The target variable is whether the patient
    passed away within 6 months of their visit.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你所工作的心脏病科诊所有两位医生：Johnson博士和Wu博士。虽然诊所有许多病人，他们有兴趣识别哪些在未来6个月内有较高全因死亡风险的病人。2016年曾有门诊访问的病人符合数据分析的纳入标准。目标变量是病人在就诊后6个月内是否去世。
- en: Now that we've reviewed the details of the modeling assignment, let's take a
    look at the five patients in the database. The preliminary data sent to you by
    the cardiology practice includes information on five patients, distributed across
    six tables. The following are case vignettes for each of the patients. Note that
    this section is heavy on clinical terminology related to cardiovascular diseases.
    We encourage you to use available online resources to answer your questions about
    this terminology. A comprehensive clinical reference is *Harrison's Principles
    of Internal Medicine* (Kasper et al., 2005), the information for which is given
    at the end of the chapter.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经回顾了建模任务的细节，接下来让我们看看数据库中的五个病人。由心脏病科诊所发送给您的初步数据包含了五个病人的信息，分布在六个表格中。以下是每个病人的病例简介。请注意，本部分包含了大量与心血管疾病相关的临床术语。我们建议您利用可用的在线资源来解答关于这些术语的问题。一本全面的临床参考书是*《哈里森内科学原理》*（Kasper
    等，2005），相关信息会在章节末尾提供。
- en: 'The following is the information about the patients:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是关于患者的信息：
- en: '**Patient ID-1**: Patient #1 in the database is a 65-year-old male who has
    **congestive heart failure** (**CHF**), a chronic condition in which the heart
    is unable to pump blood properly to the rest of the body. He also has hypertension
    (high blood pressure), which is a risk factor for CHF. He visited his cardiologist,
    Dr. Johnson, on 9/1/2016 and 17/1/2016\. On his January 9th visit, he was found
    to have an elevated BP (154/94) and an elevated B-natriuretic peptide (BNP) lab
    value of 350\. BNP is a marker of CHF severity. He was subsequently placed on
    lisinopril and furosemide, which are first-line treatments for CHF and hypertension.
    Unfortunately, he passed away on May 15th, 2016.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**患者 ID-1**：数据库中的患者 #1 是一名 65 岁的男性，患有**充血性心力衰竭**（**CHF**），这是一种慢性病，心脏无法有效地将血液泵送到身体其他部分。他还患有高血压（高血压是
    CHF 的一个危险因素）。他于 2016 年 9 月 1 日和 1 月 17 日分别就诊于心脏病专家约翰逊医生。在 1 月 9 日的就诊中，他的血压升高（154/94），并且脑钠肽（BNP）值为
    350，BNP 是 CHF 严重程度的标志。之后他开始服用利辛普利和呋塞米，这些是治疗 CHF 和高血压的一线药物。不幸的是，他于 2016 年 5 月 15
    日去世。'
- en: '**Patient ID-2**: Patient #2 is a 39-year-old female with a history of angina
    pectoris (cardiovascular-related chest pain upon exercising) and diabetes mellitus.
    Diabetes mellitus is a risk factor for myocardial infarction (heart attack; a
    late, often fatal manifestation of atherosclerotic heart disease), and angina
    pectoris can be seen as an early manifestation of atherosclerotic heart disease.
    She visited her cardiologist, Dr. Wu, on January 15th, 2016, at which time she
    was found to have an elevated blood glucose level of 225, a sign of uncontrolled
    diabetes. She was started on metformin for her diabetes, as well as nitroglycerin,
    aspirin, and metoprolol for her angina.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**患者 ID-2**：患者 #2 是一名 39 岁的女性，患有心绞痛（运动时出现的心脏相关胸痛）和糖尿病史。糖尿病是心肌梗死（心脏病发作，动脉粥样硬化性心脏病的晚期表现，常常致命）的一个危险因素，而心绞痛可视为动脉粥样硬化性心脏病的早期表现。她于
    2016 年 1 月 15 日就诊于她的心脏病专家吴医生，检查时发现她的血糖水平为 225，表明糖尿病控制不良。她开始服用二甲双胍治疗糖尿病，并且使用硝酸甘油、阿司匹林和美托洛尔治疗心绞痛。'
- en: '**Patient ID-3**: Patient #3 is a 32-year-old female who sees Dr. Johnson for
    management of her hypertension. During her visit on February 1st, 2016 her blood
    pressure was elevated at 161/100\. She was started on valsartan/hydrochlorothiazide,
    an anti-hypertensive combination.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**患者 ID-3**：患者 #3 是一名 32 岁的女性，因高血压接受约翰逊医生的治疗。在 2016 年 2 月 1 日的就诊中，她的血压升高，达到了
    161/100。她开始服用缬沙坦/氢氯噻吨合剂进行抗高血压治疗。'
- en: '**Patient ID: 4**: Patient #4 is a 51-year-old male who has severe CHF with
    pulmonary hypertension. He saw Dr. Wu on February 27th, 2016\. During that visit,
    his weight was 211 lbs and his blood pressure was slightly elevated at 143/84\.
    His BNP level was highly elevated at 1,000\. He was given lisinopril and furosemide
    for his CHF as well as diltiazem for his pulmonary hypertension. Unfortunately,
    he passed away on June 8th, 2016.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**患者 ID: 4**：患者 #4 是一名 51 岁的男性，患有严重的充血性心力衰竭（**CHF**）并伴有肺动脉高压。他于 2016 年 2 月
    27 日就诊于吴医生。在那次就诊时，他的体重为 211 磅，血压略有升高，为 143/84。其脑钠肽（BNP）水平显著升高，达到 1000。他被给予了利辛普利和呋塞米治疗心力衰竭，并且使用了地尔硫卓治疗肺动脉高压。不幸的是，他于
    2016 年 6 月 8 日去世。'
- en: '**Patient ID-5**: The last patient in our database, patient #5, is a 58-year-old
    male who presented to Dr. Wu on March 1st, 2016 with a history of CHF and diabetes
    mellitus Type 2\. During the visit, his glucose was elevated at 318 and BNP was
    moderately elevated at 400\. He was started on lisinopril and furosemide for his
    CHF and metformin for his diabetes.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**病人ID-5**：我们数据库中的最后一位病人，病人 #5，是一位58岁的男性，他于2016年3月1日就诊于吴医生，患有充血性心力衰竭（CHF）和2型糖尿病的病史。就诊时，他的血糖为318，BNP水平适度升高至400。他开始服用利辛普利和呋塞米治疗CHF，并服用二甲双胍治疗糖尿病。'
- en: The clinical database
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 临床数据库
- en: 'Now that we''ve gotten to know the five patients whose information is contained
    in our database, we can describe the table structure and fields contained in the
    database, for six mock tables: `PATIENT`, `VISIT`, `MEDICATIONS`, `LABS`, `VITALS`,
    and `MORT`. Although every clinical database is different, I''ve tried to use
    a structure that is commonly seen in healthcare. Typically, tables are presented
    by clinical domains (for an example of a research study that received tables in
    such a distributed format, see Basole et al., 2015). For example, there is often
    one table that contains demographic and personal information, one table for lab
    results, one for medications, and so on, so that is how we constructed the database
    in this example. They tend to be tied together by a common identifier, which in
    our case is the `Pid` field.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经了解了数据库中包含的五位病人信息，我们可以描述数据库中包含的表格结构和字段，这些字段来自六个模拟表格：`PATIENT`、`VISIT`、`MEDICATIONS`、`LABS`、`VITALS`和`MORT`。尽管每个临床数据库都有不同的结构，我尽量使用一个在医疗行业中常见的结构。通常，表格是按照临床领域呈现的（有关使用这种分布式格式的研究表格示例，请参见Basole等，2015）。例如，通常有一个表格包含人口统计学和个人信息，一个表格用于实验室结果，一个用于药物治疗，依此类推，这就是我们在本例中构建数据库的方式。表格通常通过一个共同的标识符（在我们这个例子中是`Pid`字段）将它们联系在一起。
- en: As we describe the tables, we must keep our end-goal of the data engineering
    phase in mind–to combine the relevant information from the six tables into a single
    table, whose columns include the target variable (mortality in this case) in addition
    to predictor variables, which should be useful for predicting the target variable.
    This will enable us to make a machine learning model with popular packages such
    as Python's `scikit-learn`. With this in mind, we will highlight selected fields
    that will be useful for our assignment.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在描述这些表格时，我们必须牢记数据工程阶段的最终目标——将六个表格中的相关信息合并成一个单一的表格，表格的列不仅包括目标变量（在本例中是死亡率），还包括预测变量，这些变量应有助于预测目标变量。这将使我们能够使用流行的机器学习包，如Python的`scikit-learn`，来创建机器学习模型。考虑到这一点，我们将重点介绍一些对任务有用的字段。
- en: The PATIENT table
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`PATIENT` 表格'
- en: 'In our example, the `PATIENT` table, which we can see in the following screenshot,
    contains the demographic and identifying information of our patients–their names,
    contact information, birthdays, and biological sex. In this example, there are
    only five observations and 11 columns; in real practice, this table would contain
    all of the patients affiliated with the healthcare organization. The number of
    rows in this table might range from hundreds to hundreds of thousands, while the
    table could potentially include dozens of columns containing detailed demographic
    information:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，`PATIENT`表格，如下图所示，包含了病人的人口统计学和识别信息——包括姓名、联系方式、生日和生物性别。在这个例子中，只有五个记录和11列；而在实际操作中，这个表格会包含所有与医疗机构相关的病人信息。这个表格的行数可能从几百行到几万行不等，同时表格可能包含几十列详细的人口统计学信息：
- en: '![](img/46661fa9-00b7-42a5-8c7b-ad93ecf6056c.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/46661fa9-00b7-42a5-8c7b-ad93ecf6056c.png)'
- en: In the database, every unique patient is assigned to an identifier (the field
    labeled as `Pid`), which in our case is simply numbered 1 - 5\. The `Pid` column
    allows us to keep track of the patients across different tables. Also, notice
    that there is one and only one entry for each distinct patient ID.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据库中，每个独特的病人都会被分配一个标识符（字段标记为`Pid`），在我们这个例子中，标识符简单地编号为1至5。`Pid`列让我们能够在不同表格之间跟踪病人。同时，注意每个独特的病人ID只会有一条记录。
- en: After identifying the indispensable identifer column, the focus should be on
    which variables to keep and which to discard. Certainly, age and sex are important
    demographic predictors of mortality. If race were in this table, that would be
    another important demographic variable.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在确定了必要的标识符列后，重点应该放在保留哪些变量和丢弃哪些变量上。当然，年龄和性别是死亡率的重要人口学预测因素。如果种族数据存在于此表格中，那将是另一个重要的人口学变量。
- en: Another notable variable in this table is the zip code. Increasingly, socioeconomic
    data is being used in machine learning analyses. The zip code can potentially
    be tied to publicly available census data; that data can then be joined to the
    data in this table on the zip code and could potentially provide information on
    the average education level, income, and healthcare coverage for each patient's
    zip code. There are even organizations who sell household-level information; however,
    with that data comes a great responsibility for privacy protection and data security.
    For this example, we will omit the zip code to keep our final table simple.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 该表中另一个值得注意的变量是邮政编码。越来越多的社会经济数据被用于机器学习分析。邮政编码可能与公开的普查数据相关联；这些数据可以与该表中的邮政编码进行联接，并可能提供有关每个患者所在邮政编码区域的平均教育水平、收入和医疗保障的信息。甚至有组织出售家庭级的信息；然而，使用这些数据时也伴随着对隐私保护和数据安全的重大责任。为了简化示例，我们将省略邮政编码。
- en: Information we'll leave out from our final table includes names, street addresses,
    and phone numbers. As long as we have the patient ID, these fields shouldn't have
    much of a predictive impact on our target variable.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终表格中将省略的信息包括姓名、街道地址和电话号码。只要我们有患者ID，这些字段对目标变量的预测影响应该不大。
- en: The VISIT table
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**就诊（VISIT）**表'
- en: 'While the `PATIENT` table contains basic administrative information about each
    patient, our assignment is to predict the mortality risk on the basis of each
    *visit*. The `VISIT` table contains one observation for each patient visit, along
    with some clinical information about each visit:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`PATIENT`表包含了每个患者的基本行政信息，但我们的任务是基于每次*就诊*预测死亡风险。`VISIT`表包含每次患者就诊的一个观察值，并包含一些关于每次就诊的临床信息：
- en: '![](img/4ba30aec-3223-4a93-af82-f720bd647816.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4ba30aec-3223-4a93-af82-f720bd647816.png)'
- en: 'Notice that the patient ID is no longer the primary identifier of this table,
    since Patient #1 had two visits; instead, there is a `Visit_id` field that is
    numbered from `10001` to `10006` in this example, with one distinct ID per visit.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，患者ID不再是该表的主要标识符，因为患者#1有两次就诊；相反，表中有一个`Visit_id`字段，示例中的编号从`10001`到`10006`，每次就诊对应一个独立的ID。
- en: This table also contains `Visit_date`. Since the cardiology practice indicated
    they want to know the mortality risk within 6 months of the patient visit, we
    will have to use this field later when we compute the target variable.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 该表还包含`Visit_date`字段。由于心脏病学科表示希望了解患者就诊后的6个月内死亡风险，因此在计算目标变量时，我们将需要使用该字段。
- en: Two of the fields in this table contain ICD (diagnosis) codes. Actual tables
    may contain dozens of codes for each visit. For each coded field, there is a corresponding
    name field that contains the name of the condition that the code represents. A
    popular approach in healthcare is to make, in the final table, a column for every
    clinical code we are interested in tracking (Futoma et al., 2015; Rajkomar et
    al., 2018). We will adopt this approach later in the chapter.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 该表中的两个字段包含了ICD（诊断）代码。实际的表格可能会包含每次就诊的数十个代码。对于每个编码字段，都有一个对应的名称字段，包含该代码所代表的病症名称。医疗行业中一种流行的方法是，在最终的表格中，为我们关注的每一个临床代码创建一个列（Futoma
    et al., 2015; Rajkomar et al., 2018）。我们将在本章后面采用这种方法。
- en: Finally, we note that the name of the attending physician is included, which
    can be used to measure physician performance.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们注意到表中包括了主治医生的名字，这可以用来衡量医生的绩效。
- en: The MEDICATIONS table
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**药物（MEDICATIONS）**表'
- en: 'The `MEDICATIONS` table contains one entry for every medication being taken
    by our five patients. In this example, there is no single column that serves as
    a primary key for this table. As we can see in the following screenshot, this
    table includes information about the medication name, dose, frequency, route,
    prescribing physician, and prescription date. The NDC code of each medication
    is also included; we covered NDC codes in [Chapter 2](71c31b0a-fa9e-4b31-8b58-f563a815e338.xhtml),
    *Healthcare Foundations*:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`MEDICATIONS`表包含了我们的五位患者每一项正在服用的药物的记录。在这个例子中，没有一个单独的列充当该表的主键。如以下截图所示，该表包括药物名称、剂量、频率、途径、开药医生和开药日期等信息。每种药物的NDC代码也被包括在内；我们在[第2章](71c31b0a-fa9e-4b31-8b58-f563a815e338.xhtml)，*医疗基础*中讲解了NDC代码：'
- en: '![](img/07e90df1-dec5-4169-988a-82198225d7ea.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/07e90df1-dec5-4169-988a-82198225d7ea.png)'
- en: Including medications in our final table will not be straightforward. For example,
    the information in the tables does not indicate the class of each medication.
    The NDC code is present, but the NDC code is even more granular than the medication
    name since it includes the route of administration and dosage in making each unique
    code; therefore, multiple forms of lisinopril could have different NDC codes.
    In order to make a column for each medication, we could potentially separately
    make a table for each medication, which contains all of the medications that compose
    it, and then merge that information into our table.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在最终表格中包含药物信息并不简单。例如，表格中的信息没有显示每种药物的类别。虽然有NDC代码，但NDC代码比药物名称更为详细，因为它包括了给药途径和剂量，从而使每个代码唯一；因此，不同剂型的依那普利可能会有不同的NDC代码。为了为每种药物创建一列，我们可以为每种药物分别创建一个表格，包含组成该药物的所有药物信息，然后将这些信息合并到我们的表格中。
- en: 'If we choose to include dosage information, that field will require some cleaning.
    Notice that Patient #3 is receiving an anti-hypertensive combination drug–the
    valsartan component has a dosage of 160 mg, while the hydrochlorothiazide component
    has a dosage of 12.5 mg. This could possibly be coded as two separate drugs, but
    creating a script that splits combination drugs into two rows is not trivial.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们选择包含剂量信息，该字段将需要一些清理。注意，病人#3正在服用一种抗高血压联合药物——缬沙坦成分的剂量为160毫克，而氢氯噻吨成分的剂量为12.5毫克。这可能被编码为两种不同的药物，但编写一个脚本将联合药物拆分为两行并不简单。
- en: The LABS table
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实验室表
- en: 'Laboratory information is an important part of clinical diagnostics, and many
    laboratory test results make for good predictor variables (Donze et al., 2013;
    Sahni et al., 2018). The `LABS` table includes fields that describe the laboratory
    test name, abbreviation, LOINC code, and result:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 实验室信息是临床诊断的重要部分，许多实验室测试结果是很好的预测变量（Donze et al., 2013；Sahni et al., 2018）。`LABS`表包含描述实验室测试名称、缩写、LOINC代码和结果的字段：
- en: '![](img/70660895-ce3a-4f59-a96c-3a7720579f59.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](img/70660895-ce3a-4f59-a96c-3a7720579f59.png)'
- en: There are some different approaches to including lab information in the final
    table. One way would be to include the raw lab result as a continuous variable.
    However, this leads to a problem because the result would be NULL for most labs.
    We could potentially navigate around this issue by imputing a value in the normal
    range when it is missing. Another approach would be to have a binary variable
    for a lab test result that is in the abnormal range. This solves the missing data
    problem, since if the result is missing it would be zero. However, a BNP value
    of 1,000 (which indicates severe CHF) would be no different than a BNP value of
    350 (which indicates mild CHF) with this method. We will demonstrate both approaches
    in this chapter.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 包含实验室信息的最终表格有几种不同的处理方式。一种方法是将原始实验室结果作为连续变量包含进来。然而，这会导致一个问题，因为大多数实验室的结果会是NULL。我们可以通过在缺失时填充一个正常范围的值来解决这个问题。另一种方法是为异常范围的实验室检测结果设置一个二进制变量。这解决了缺失数据的问题，因为如果结果缺失，它会显示为零。然而，使用这种方法，1,000的BNP值（表示严重CHF）与350的BNP值（表示轻度CHF）没有区别。本章将演示这两种方法。
- en: Also note that the `Lab_value` field sometimes contains special characters,
    for example in the troponin result. These will need to be removed and the lab
    values interpreted accordingly. Culture results (not included in this example)
    are completely textual, often naming specific bacterial strains instead of numbers.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，`Lab_value`字段有时包含特殊字符，例如在肌钙蛋白结果中。这些字符需要删除，实验室值也需要相应地进行解释。培养结果（在此示例中未包括）完全是文本的，通常会命名特定的细菌菌株，而不是数字。
- en: Again, we repeat that this is a simplified example and that many of the common
    labs that would be drawn for these patients (for example, WBC count, hemoglobin,
    sodium, potassium, and so on) are excluded here.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这是一个简化的示例，许多常见的实验室检查（例如，白细胞计数、血红蛋白、钠、钾等）在此示例中未包含。
- en: The VITALS table
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生命体征表
- en: Vital signs are important indicators of a patient's health status and can be
    good predictors in healthcare machine learning models (Sahni et al., 2018). Vital
    signs are typically taken at every patient visit, so they can easily be included
    in their raw (numerical) form to preserve granularity.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 生命体征是反映病人健康状态的重要指标，并且在医疗健康机器学习模型中可能是很好的预测变量（Sahni et al., 2018）。生命体征通常在每次病人就诊时都进行测量，因此可以很容易以原始（数值）形式包含进来，以保持数据的细粒度。
- en: 'In the following screenshot of the table, we notice that while height and weight
    are present, the **body mass index** (**BMI**) is missing. We will demonstrate
    the calculation of the BMI in [Chapter 5](12ee77f2-0655-4dc5-abb1-2868d6fcc386.xhtml),
    *Computing Foundations – Introduction to Python*. Second, Visit #10004 is missing
    a temperature reading. This is common in healthcare and may be caused by an oversight
    in care:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '在下方的表格截图中，我们注意到尽管身高和体重信息存在，但**身体质量指数**（**BMI**）缺失。我们将在[第五章](12ee77f2-0655-4dc5-abb1-2868d6fcc386.xhtml)《计算基础
    - Python 入门》中演示 BMI 的计算。其次，访问 #10004 缺少体温读数。在医疗中这很常见，可能是由于护理中的疏漏导致的：'
- en: '![](img/d0320c9d-5191-414e-b101-76ba65cc2243.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d0320c9d-5191-414e-b101-76ba65cc2243.png)'
- en: The VITALS table
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: VITALS 表
- en: Later in the chapter, we will impute the normal temperature for this visit.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章后面，我们将为这次就诊推算正常的体温。
- en: The MORT table
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MORT 表
- en: 'Finally, we come to the table that contains the target variable. The `MORT`
    table contains just two fields, the patient identifier, and the date the patient
    passed away. Patients not listed in this table can be assumed to be living:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们来到了包含目标变量的表。`MORT` 表仅包含两个字段：患者标识符和患者去世的日期。未列在此表中的患者可以假定为存活：
- en: '![](img/55885bd2-47e9-4317-992a-4dc302a4aee6.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/55885bd2-47e9-4317-992a-4dc302a4aee6.png)'
- en: Later, we will learn how to transfer the information from this table into a
    binary target variable.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后，我们将学习如何将这些表中的信息转移到一个二进制目标变量中。
- en: Starting an SQLite session
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动 SQLite 会话
- en: The database engine we will use to transform our database is **SQLite**. In
    [Chapter 1](b15b2b73-d2bb-410f-ab55-5f0f1e91730e.xhtml), *Introduction to Healthcare
    Analytics*, we went over installation instructions as well as basic SQLite commands.
    It should be mentioned that SQL comes in many variants, and the SQL specific to
    SQLite has minor differences to that specific to MySQL or SQL Server databases.
    However, the underlying principles remain constant across all SQL dialects.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将用于转换数据库的数据库引擎是**SQLite**。在[第一章](b15b2b73-d2bb-410f-ab55-5f0f1e91730e.xhtml)《医疗分析入门》中，我们讲解了安装说明以及基本的
    SQLite 命令。需要提到的是，SQL 有多种变体，而特定于 SQLite 的 SQL 与特定于 MySQL 或 SQL Server 数据库的 SQL
    有一些小的差异。然而，所有 SQL 方言的基本原理保持一致。
- en: 'At this time, do the following:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，执行以下操作：
- en: Navigate to the directory containing the `sqlite3.exe` program in your shell
    or command prompt (using the `cd` command).
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `cd` 命令，导航到包含 `sqlite3.exe` 程序的目录。
- en: 'Type `sqlite3 mortality.db` and press *Enter*. You should see a prompt that
    looks like the following: `sqlite>`. This prompt indicates that you are in the
    SQLite program.'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入 `sqlite3 mortality.db` 并按 *Enter* 键。你应该看到类似以下的提示符：`sqlite>`。这个提示符表明你已进入 SQLite
    程序。
- en: Throughout the remainder of this chapter, we are going to create some tables
    and execute some SQLite commands on them in the SQLite program.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本章剩余的部分，我们将创建一些表并在 SQLite 程序中执行一些 SQLite 命令。
- en: To exit the session at any time, type `.exit` and press *Enter*.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 随时退出会话，输入 `.exit` 并按 *Enter* 键。
- en: Data engineering, one table at a time with SQL
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据工程，一次一个表，使用 SQL
- en: Let's now look at how to perform data engineering with SQLite. First, we have
    to create our tables in the database. Then, we will manipulate them, one by one,
    to get the desired final table.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下如何使用 SQLite 执行数据工程。首先，我们需要在数据库中创建表。然后，我们将一个一个地操作这些表，直到获得最终的目标表。
- en: 'Query Set #0 – creating the six tables'
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '查询集 #0 – 创建六个表'
- en: In this mock assignment, let's pretend that the portal at which the data can
    be downloaded from the cardiology practice is not working. Instead, one of the
    technicians sends you SQLite commands that you can use to create the six tables.
    You can follow along with the book and type each command manually. Alternatively,
    you can go to the book's official code repository and download the commands from
    there.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个模拟任务中，假设下载心脏科诊所数据的门户网站无法使用。相反，技术人员会向你发送一些 SQLite 命令，你可以用这些命令来创建六个表。你可以跟着书中的步骤，一一手动输入每个命令。或者，你可以访问书籍的官方代码库，从那里下载命令。
- en: 'Query Set #0a – creating the PATIENT table'
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '查询集 #0a – 创建 PATIENT 表'
- en: 'One way to create a table in our database is to specify its schema manually.
    Let''s do that here with our first table, the `PATIENT` table:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 创建表的一种方法是手动指定其架构。让我们在这里使用第一个表 `PATIENT` 表来演示：
- en: '[PRE0]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding example, notice that the name of the table appears after the
    `CREATE TABLE` phrase. Following that, there is an open parenthesis, and on each
    line a new column is named (for example, `Pid` and `Fname`). On each line, following
    the column names, are the types of each column. We use `VARCHAR(![](img/132125d6-1eb7-42e6-9fb1-55b899cf2b65.png))`
    for most columns in this example, where ![](img/719756ac-ad5e-4df0-b962-c416cf4860ff.png) is
    the maximum number of characters that the column contains. A `CHAR` column contains
    just one character. Finally, some of the important fields (such as names and identifiers)
    we will not allow to be blank, and we specify that for those columns by using
    the `NOT NULL` phrase.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，请注意表名出现在`CREATE TABLE`短语之后。接下来是一个开括号，每一行命名一个新列（例如，`Pid`和`Fname`）。在每一行的列名后面，列出了每个列的数据类型。在本示例中，我们对大多数列使用`VARCHAR(![](img/132125d6-1eb7-42e6-9fb1-55b899cf2b65.png))`，其中![](img/719756ac-ad5e-4df0-b962-c416cf4860ff.png)是该列包含的最大字符数。`CHAR`列只包含一个字符。最后，对于一些重要字段（例如姓名和标识符），我们不允许其为空，并通过使用`NOT
    NULL`短语来指定这一点。
- en: 'Now that we created the schema of our table, the next step is to populate the
    table with data. As we said, in the database we just have five patients, therefore
    the `PATIENT` table will have five rows. We use an `INSERT` command to insert
    each row into the table as shown here:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了表的架构，下一步是向表中填充数据。正如我们所说，数据库中只有五个病人，因此`PATIENT`表将有五行。我们使用`INSERT`命令将每一行插入到表中，如下所示：
- en: '[PRE1]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Notice that the `INSERT` statements first specify that fields that will be inserted,
    before using the `VALUES` keyword, after which the actual data elements are listed.
    If `VARCHAR` or `CHAR` is used, the data elements should be surrounded by single
    quotes.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`INSERT`语句首先指定将要插入的字段，然后使用`VALUES`关键字，接着列出实际的数据元素。如果使用的是`VARCHAR`或`CHAR`，数据元素应该用单引号括起来。
- en: 'Query Set #0b – creating the VISIT table'
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '查询集 #0b – 创建 VISIT 表'
- en: 'Let''s now make the `VISIT` table. Again, first we use a `CREATE TABLE` statement,
    followed by six `INSERT` statements:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建`VISIT`表。同样，首先使用`CREATE TABLE`语句，然后是六个`INSERT`语句：
- en: '[PRE2]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Query Set #0c – creating the MEDICATIONS table'
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '查询集 #0c – 创建 MEDICATIONS 表'
- en: 'To create the `MEDICATIONS` table, use the following code:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建`MEDICATIONS`表，使用以下代码：
- en: '[PRE3]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Query Set #0d – creating the LABS table'
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '查询集 #0d – 创建 LABS 表'
- en: 'To create the `LABS` table, use the following code:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建`LABS`表，使用以下代码：
- en: '[PRE4]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Query Set #0e – creating the VITALS table'
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '查询集 #0e – 创建 VITALS 表'
- en: 'Notice that the `VITALS` table uses numeric types such as `FLOAT` and `INT`.
    To create the `VITALS` table, use the following code:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`VITALS`表使用了如`FLOAT`和`INT`等数值类型。要创建`VITALS`表，使用以下代码：
- en: '[PRE6]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Query Set #0f – creating the MORT table'
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '查询集 #0f – 创建 MORT 表'
- en: 'To create the `MORT` table, use the following code:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建`MORT`表，使用以下代码：
- en: '[PRE7]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Query Set #0g – displaying our tables'
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '查询集 #0g – 显示我们的表'
- en: 'To confirm that a table (for example, `PATIENT`) was made correctly, we can
    use the `SELECT * FROM PATIENT;` query (we will explain this syntax further in
    Query Set #2):'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '为了确认某个表（例如，`PATIENT`）是否正确创建，我们可以使用`SELECT * FROM PATIENT;`查询（我们将在查询集 #2 中进一步解释该语法）：'
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Query Set #1 – creating the MORT_FINAL table'
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '查询集 #1 – 创建 MORT_FINAL 表'
- en: The first query we write will create the table using a `CREATE TABLE` statement.
    In one version of a `CREATE TABLE` statement, each variable is spelled out with
    its corresponding datatype. We used this version to create our six tables from
    scratch in the previous examples. Alternatively, one can create a table by copying
    from an existing table. We will opt for the second option here.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写的第一个查询将使用`CREATE TABLE`语句创建表。在某种版本的`CREATE TABLE`语句中，每个变量都明确指定了其对应的数据类型。我们在前面的示例中使用了这种版本来从零开始创建我们的六个表。或者，也可以通过复制现有的表来创建一个新表。在这里我们选择第二种方式。
- en: 'Now that we''ve answered that question, a second one remains–which table should
    we copy from? It might be tempting to copy the patient information from the `PATIENT`
    table to our final table, since it contains one row for each patient, and it contains
    basic demographic information. However, we must remember that the use case is
    based on each *visit*, not patient. Therefore, if a patient has two visits (such
    as Patient #1), technically that patient will receive two risk scores: one for
    each visit. Therefore, we should start by copying information from the `VISIT`
    table. This will create a table with six rows, one for each visit.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经回答了这个问题，接下来还有第二个问题——我们应该从哪个表中复制数据？可能会有诱惑直接将来自`PATIENT`表的病人信息复制到我们的最终表格中，因为该表每行代表一个病人，且包含基本的病人信息。然而，我们必须记住，我们的用例是基于每次*就诊*，而不是病人。因此，如果一个病人有两次就诊（例如病人#1），从技术上讲，这个病人将会得到两个风险评分：每次就诊一个。于是，我们应该从`VISIT`表开始复制信息。这将创建一个包含六行的表格，每行代表一次就诊。
- en: 'So we start our query using a `CREATE TABLE` clause, with `MORT_FINAL` being
    the name of our new table. Then we use the `AS` keyword. The next two lines of
    the query specify which information to copy using a `SELECT-FROM-WHERE` construct:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们通过使用`CREATE TABLE`子句开始查询，`MORT_FINAL`是我们新表的名称。然后我们使用`AS`关键字。接下来的两行查询指定了要复制哪些信息，使用的是`SELECT-FROM-WHERE`构造：
- en: '[PRE9]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: A `SELECT-FROM-WHERE` statement is a systematic way of selecting the information
    we want from a table. The `SELECT` part acts as a *column* selector–following
    the `SELECT` keyword are the columns that we want to copy into the new table.
    Note that we left out the names of the diagnoses (`Pri_dx_name`, `Sec_dx_name`)
    since those technically aren't predictor variables, as long we have each code
    and we can refer to their meanings. The `FROM` keyword specifies the table name
    from which we wish to copy (`VISIT`, in this case). The `WHERE` keyword is an
    optional clause that allows us to select only those *rows* that meet certain conditions.
    For example, if we were interested in restricting our model to those visits in
    which the patient had heart failure, we could say `WHERE Pri_dx_code == 'I50.9'`.
    Because we are interested in including all visits in this example, we do not need
    a WHERE clause for this query. We will see the WHERE clause in action in the next
    query set.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`SELECT-FROM-WHERE`语句是一种系统化的方式，用来从表格中选择我们需要的信息。`SELECT`部分充当了*列*选择器——在`SELECT`关键字后面是我们希望复制到新表格中的列。请注意，我们省略了诊断名称（`Pri_dx_name`、`Sec_dx_name`），因为它们从技术上来说不是预测变量，只要我们有每个代码并能参考它们的含义即可。`FROM`关键字指定了我们希望从中复制数据的表格（在这种情况下是`VISIT`）。`WHERE`关键字是一个可选的子句，允许我们只选择那些符合特定条件的*行*。例如，如果我们只对那些病人有心力衰竭的就诊感兴趣，我们可以写`WHERE
    Pri_dx_code == ''I50.9''`。因为在本例中我们想包含所有就诊记录，所以这个查询不需要`WHERE`子句。我们将在下一个查询集看到`WHERE`子句的实际应用。'
- en: 'Query Set #2 – adding columns to MORT_FINAL'
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '查询集 #2 – 向 MORT_FINAL 添加列'
- en: In this section, we will demonstrate two ways to add additional columns. One
    method uses an `ALTER TABLE` statement, while the second method uses a `JOIN`
    operation.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将演示两种添加额外列的方法。一种方法使用`ALTER TABLE`语句，而第二种方法使用`JOIN`操作。
- en: 'Query Set #2a – adding columns using ALTER TABLE'
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '查询集 #2a – 使用 ALTER TABLE 添加列'
- en: Now that we've populated information from the `VISIT` table into the `MORT_FINAL`
    table, it's time to start integrating the other tables as well. We'll start with
    the `PATIENT` table; specifically, we would like to add in the birthdate and sex
    from this table. We start with the birthdate.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将来自`VISIT`表的信息填充到`MORT_FINAL`表中，接下来是时候开始整合其他表格了。我们将从`PATIENT`表开始；具体来说，我们想要将这个表中的出生日期和性别添加到我们的数据中。我们先从出生日期开始。
- en: 'In Query Set #2, we demonstrate the basic query pattern for adding a new column
    (the birthdate) to our table. We start with an `ALTER TABLE` statement, followed
    by the name of the table, the operation (`ADD COLUMN`, in this case), the name
    of our new column, and the variable type. Although standard SQL supports a `DATE`
    variable type for dates, in SQLite, we use the `TEXT` type. Dates are always specified
    in `YYYY-MM-DD` format.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '在查询集 #2 中，我们展示了为表格添加新列（出生日期）的基本查询模式。我们从`ALTER TABLE`语句开始，接着是表名，操作（在这种情况下是`ADD
    COLUMN`），新列的名称以及变量类型。尽管标准 SQL 支持使用`DATE`变量类型表示日期，但在 SQLite 中，我们使用`TEXT`类型。日期总是以`YYYY-MM-DD`格式指定。'
- en: After we've initialized the new column with our `ALTER TABLE` statement, the
    next step is to populate the actual birthdates from the `PATIENT` table. For this,
    we use an `UPDATE` statement. We specify the table we are updating, followed by
    a `SET` statement and the name of the column we are modifying, with an equals
    sign.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们通过 `ALTER TABLE` 语句初始化新列后，下一步是从 `PATIENT` 表中填充实际的出生日期。为此，我们使用 `UPDATE` 语句。我们指定要更新的表，然后是一个
    `SET` 语句和我们要修改的列名，后面跟着等号。
- en: 'The `SELECT-FROM-WHERE` block is the basic *retrieval* query of the SQL language.
    We are trying to *retrieve* information from the `PATIENT` table and populate
    into our new `Bdate` column, so we use a `SELECT-FROM-WHERE` statement, enclosed
    in parentheses, after the equals sign. Think of the SQL statement as issuing the
    following order to the database with its `SELECT` statement: "For every row in
    the `MORT_FINAL` table, find me the birthdate from the `PATIENT` table where the
    `Pid` in the `PATIENT` table equals the `Pid` in the `MORT_FINAL` table."'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`SELECT-FROM-WHERE` 块是 SQL 语言的基本*检索*查询。我们正在尝试从 `PATIENT` 表中*检索*信息，并将其填充到新的
    `Bdate` 列中，因此我们在等号后使用一个 `SELECT-FROM-WHERE` 语句，语句用括号括起来。可以把 SQL 语句看作是向数据库发出以下指令的
    `SELECT` 语句：“对于 `MORT_FINAL` 表中的每一行，找到 `PATIENT` 表中 `Pid` 等于 `MORT_FINAL` 表中 `Pid`
    的出生日期。”'
- en: 'Following the `UPDATE` statement for the `Bdate` column, we use the same sequence
    of queries (`ALTER TABLE` and `UPDATE`) to retrieve the `Sex` column from the
    `PATIENT` table:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在对 `Bdate` 列执行 `UPDATE` 语句后，我们使用相同的查询序列（`ALTER TABLE` 和 `UPDATE`）来从 `PATIENT`
    表中检索 `Sex` 列：
- en: '[PRE10]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Query Set #2b – adding columns using JOIN'
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '查询集 #2b – 使用 JOIN 添加列'
- en: While the `ALTER TABLE` and `UPDATE` sequence is a good way to add columns to
    a table one at a time, it can be tedious when you want to copy many columns from
    the same table. A `JOIN` operation gives us a second option for copying many columns
    from the same table.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `ALTER TABLE` 和 `UPDATE` 序列是逐一向表中添加列的好方法，但当你需要从同一表中复制多个列时，它可能会变得很繁琐。`JOIN`
    操作为我们提供了一个第二个选项，可以从同一表中复制多个列。
- en: In a `JOIN` operation, two tables are combined to produce a single table. In
    the following example query, the selected columns of the `VITALS` table are appended
    on the end of the `MORT_FINAL` table.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `JOIN` 操作中，两个表会被合并生成一个单一的表。在下面的示例查询中，`VITALS` 表中选定的列会被附加到 `MORT_FINAL` 表的末尾。
- en: 'However, the `MORT_FINAL` table and `VITALS` table both contain several rows.
    How does the query know which rows of each table correspond to each other? This
    is specified using an `ON` clause (at the end of the query). The `ON` clause says,
    "When joining the tables, combine those rows where the visit IDs are equal." So
    for each row of the `MORT_FINAL` table, there will be one and only one row of
    the `VISITS` table to which it corresponds: the row that has the same visit ID.
    This makes sense because we are interested in collecting the information from
    individual visits in their own separate rows.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`MORT_FINAL` 表和 `VITALS` 表都包含多个行。那么查询如何知道每个表中的哪一行对应彼此呢？这可以通过 `ON` 子句来指定（在查询的末尾）。`ON`
    子句表示：“当连接表时，合并那些访问 ID 相等的行。”因此，对于 `MORT_FINAL` 表的每一行，都将有且仅有一行 `VISITS` 表的行与其对应：该行具有相同的访问
    ID。这是合理的，因为我们关心的是从每个单独的访问中收集信息，并将其放入各自的独立行中。
- en: 'Another thing to know about JOINs is that there are four different JOIN types
    in standard SQL: LEFT JOINs, RIGHT JOINs, INNER JOINs, and OUTER JOINs. A LEFT
    JOIN (referred to as a LEFT OUTER JOIN in SQLite) is the type we use here; it
    says, "For every row of the first table (`MORT_FINAL`, in this case), add the
    corresponding VISIT columns where the visit IDs are equal, and add NULL values
    if there is no corresponding visit ID in the VISIT table." In other words, all
    of the rows of the first table are preserved, whether or not there is a corresponding
    row in the right table. Visits that have a row in the second table but are missing
    from the first table are discarded.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个关于 JOIN 的知识点是，标准 SQL 中有四种不同的 JOIN 类型：LEFT JOIN、RIGHT JOIN、INNER JOIN 和 OUTER
    JOIN。这里使用的是 LEFT JOIN（在 SQLite 中称为 LEFT OUTER JOIN）；它表示：“对于第一个表的每一行（在本例中为 `MORT_FINAL`），添加对应的
    VISIT 列，其中访问 ID 相等，如果在 VISIT 表中没有对应的访问 ID，则添加 NULL 值。”换句话说，第一个表的所有行都会被保留，无论第二个表中是否存在对应的行。那些在第二个表中有行但在第一个表中没有的访问将被丢弃。
- en: 'In a RIGHT JOIN, the opposite is true: unique visit IDs of the second table
    are preserved, and they are aligned to the corresponding visit IDs of the first
    table. Visit IDs present in the first table but missing in the second table are
    discarded. INNER JOINs include in the final result: only visit IDs that are present
    in both tables. OUTER JOINs include all rows of both tables and replace all missing
    entries with NULL values. As a note, we should add that RIGHT JOINs and OUTER
    JOINs are not supported in SQLite.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在RIGHT JOIN中，情况正好相反：第二个表中独特的访问ID被保留，并与第一个表中相应的访问ID对齐。在第一个表中出现但在第二个表中缺失的访问ID会被丢弃。INNER
    JOIN只会在最终结果中包括同时存在于两个表中的访问ID。OUTER JOIN包括两个表中的所有行，并用NULL值替换所有缺失的条目。需要注意的是，RIGHT
    JOIN和OUTER JOIN在SQLite中不被支持。
- en: So why did we choose a LEFT JOIN? Fundamentally, our job is to specify a prediction
    for every single visit, whether or not vital signs were recorded at that visit.
    Therefore, every visit ID present in the `MORT_FINAL` table should be in the final
    result, and the LEFT JOIN ensures that will be true.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 那么为什么选择了LEFT JOIN呢？从根本上讲，我们的任务是为每个访问记录指定一个预测，无论该访问是否记录了生命体征。因此，`MORT_FINAL`表中的每个访问ID都应该出现在最终结果中，而LEFT
    JOIN确保这一点。
- en: 'In the following code, we see that by using a JOIN, only one total query is
    needed to add eight columns of the `VITALS` table. What are the downsides of this
    method? For one thing, notice that a new table is created: `MORT_FINAL_2`. We
    cannot append to the old `MORT_FINAL` table; a new table must be created. Also,
    notice that we have to type out each column that we wish to preserve in the final
    result. In SQL, the asterisk (*) indicates to add *all* columns from both tables;
    we could have written `SELECT * FROM MORT_FINAL ...`. However, if we used an asterisk,
    there would be duplicate columns (for example, the `Visit_id` column would be
    present twice, since it is in both tables).'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我们看到通过使用JOIN，只需要一个总查询就能将`VITALS`表的八个列添加进来。那么这种方法有哪些缺点呢？首先，注意到创建了一个新表：`MORT_FINAL_2`。我们不能将数据追加到旧的`MORT_FINAL`表中；必须创建一个新表。此外，注意到我们必须列出所有希望在最终结果中保留的列。在SQL中，星号（*）表示添加*所有*列自两个表；我们本可以写成`SELECT
    * FROM MORT_FINAL ...`。然而，如果使用了星号，就会有重复的列（例如，`Visit_id`列会出现两次，因为它在两个表中都存在）。
- en: 'Then we would have to exclude the duplicate columns with a `SELECT` statement.
    Nevertheless, JOINs are useful when there are many columns in a second table that
    you would like to merge into a first table:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要通过`SELECT`语句排除重复的列。尽管如此，当第二个表中有许多列需要合并到第一个表时，JOIN仍然是非常有用的：
- en: '[PRE11]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Query Set #3 – date manipulation – calculating age'
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '查询集 #3 – 日期处理 – 计算年龄'
- en: 'So far, our `MORT_FINAL_2` table contains 16 columns: 6 from the `VISIT` table,
    2 from the `PATIENT` table, and 8 from the `VITALS` table (you can verify this
    by using the `SELECT * FROM MORT_FINAL_2;` command). In this query set, we transform
    one of these variables, the birthdate variable, into a usable form using date
    manipulation: we calculate the patients'' age.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的`MORT_FINAL_2`表包含16列：6列来自`VISIT`表，2列来自`PATIENT`表，8列来自`VITALS`表（你可以通过使用`SELECT
    * FROM MORT_FINAL_2;`命令来验证）。在这个查询集中，我们将其中一个变量，即出生日期变量，通过日期处理转化为可用的形式：我们计算了患者的年龄。
- en: 'As we said earlier in Query Set #2a, dates are stored in SQLite as `TEXT` variable
    types and are in the `YYYY-MM-DD` format. Calculating the age takes two calls
    to the `julianday()` function. In SQLite, the `julianday()` function takes a date
    in `YYYY-MM-DD` as input and returns the number of days since November 24th, 4714
    BC 12:00 PM as a float. By itself, it may not seem very useful, but when used
    in combination with another `julianday()` call and a subtraction sign, it allows
    you to find the number of days that have elapsed between two dates. Following
    that, we calculate the Julian day difference between the visit date and the birthdate
    and divide the result by 365.25 to give us the patient ages in years. We also
    apply the `ROUND()` function to this result and round to two places after the
    decimal point (which is what the `2` indicates before the final parentheses are
    closed):'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '正如我们在查询集 #2a 中所说的那样，日期在 SQLite 中存储为 `TEXT` 类型，并采用 `YYYY-MM-DD` 格式。计算年龄需要调用
    `julianday()` 函数两次。在 SQLite 中，`julianday()` 函数将 `YYYY-MM-DD` 格式的日期作为输入，并返回自公元前4714年11月24日12:00
    PM以来的天数（以浮动小数形式）。单独来看，这个值可能不太有用，但当与另一个 `julianday()` 调用和减号结合使用时，它可以帮助我们找出两日期之间的天数差。接下来，我们计算就诊日期与出生日期之间的儒略日差，并将结果除以
    365.25，以得到患者的年龄（单位：年）。我们还对结果应用 `ROUND()` 函数，将其四舍五入到小数点后两位（即 `2` 表示在最终括号闭合之前的位数）：'
- en: '[PRE12]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Query Set #4 – binning and aggregating diagnoses'
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '查询集 #4 – 分箱和聚合诊断'
- en: In our example database, the `VISIT` table contains the diagnostic codes for
    the visit. Although they didn't get their own table in our example, the diagnostic
    codes are among the most important pieces of information for many analytics problems.
    For one thing, they allow us to select the observations that are relevant to our
    model. For example, if we were building a model to predict malignant cancers,
    we would need the diagnosis codes to tell us which patients have cancer and to
    filter out the other patients. Second, they often serve as good predictor variables
    (Futoma et al., 2015). For example, as we will see in [Chapter 7](d029d858-9c6e-4bf0-b793-87cdc4395e86.xhtml), *Making
    Predictive Models in Healthcare*, many chronic diseases increase the likelihood
    of poor healthcare outcomes by a large amount. Clearly, we must leverage the information
    given to us in the diagnostic codes to optimize our predictive models.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例数据库中，`VISIT` 表格包含了就诊的诊断代码。尽管在我们的示例中这些诊断代码没有单独的表格，但它们是许多分析问题中最重要的信息之一。一方面，它们允许我们选择与模型相关的观测值。例如，如果我们正在构建一个预测恶性癌症的模型，我们需要诊断代码来告诉我们哪些患者患有癌症，并过滤掉其他患者。其次，它们通常是很好的预测变量（Futoma
    等，2015）。例如，正如我们将在[第七章](d029d858-9c6e-4bf0-b793-87cdc4395e86.xhtml) *医疗健康预测模型的构建*中看到的那样，许多慢性病大大增加了不良健康结果的可能性。显然，我们必须利用诊断代码中提供的信息来优化我们的预测模型。
- en: We will introduce two transformations for coded variables here. The first transformation,
    **binning**, converts the categorical variable to a series of binary variables
    for specific diagnoses. The second transformation, **aggregating**, groups many
    of the binary binned variables into a single binary or numerical variable. These
    transformations apply not only to diagnostic codes, but to the procedure, medication,
    and laboratory codes as well. The following are examples of both of these transformations.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这里介绍两种针对编码变量的转换。第一种转换，**分箱**，将分类变量转换为一系列二元变量，表示特定的诊断。第二种转换，**聚合**，将多个二元分箱变量组合为一个单一的二元或数值变量。这些转换不仅适用于诊断代码，还适用于程序、药物和实验室代码。以下是这两种转换的示例。
- en: 'Query Set #4a – binning diagnoses for CHF'
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '查询集 #4a – 针对充血性心力衰竭（CHF）的诊断分箱'
- en: 'Here, we see the binning transformation for congestive heart failure diagnoses.
    First, we initialize the new column, `Chf_dx`, as an integer using an `ALTER TABLE`
    statement. The `DEFAULT 0` statement means that all rows are initialized to be
    zero. Next, we set the column equal to 1 if and only if there is a code corresponding
    to CHF in the `Pri_dx_icd` column or the `Sec_dx_icd` column:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到充血性心力衰竭（CHF）诊断的分箱转换。首先，我们通过 `ALTER TABLE` 语句将新的列 `Chf_dx` 初始化为整数。`DEFAULT
    0` 语句意味着所有行都被初始化为零。接着，如果 `Pri_dx_icd` 列或 `Sec_dx_icd` 列中有与 CHF 对应的代码，我们将该列值设置为
    1：
- en: '[PRE13]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Query Set #4b – binning diagnoses for other diseases'
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '查询集 #4b – 针对其他疾病的诊断分箱'
- en: 'Here, we see the same type of transformation for every single diagnosis code
    in our five-patient dataset. The queries for binning hypertension, angina, diabetes,
    and pulmonary hypertension are as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到对于我们五名患者数据集中的每个诊断代码，都进行相同类型的转换。高血压、心绞痛、糖尿病和肺动脉高压的分箱查询如下：
- en: '[PRE14]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Query Set #4c – aggregating cardiac diagnoses using SUM'
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询集#4c – 使用SUM聚合心脏诊断
- en: 'While binning is important for separating out individual diagnoses, in practice,
    we often want to group similar or near-identical diagnostic codes together as
    a single variable. Aggregating combines two or more binary variables into a single
    binary/numeric variable. Here, we aggregate all cardiac diagnostic codes in our
    dataset (CHF, hypertension, and angina are cardiac diseases) using the `+` operator.
    The result is a count of the number of total cardiac diagnoses for each of the
    five patients:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管分箱在区分个别诊断时非常重要，但在实践中，我们通常希望将相似或几乎相同的诊断代码组合成一个单一变量。聚合将两个或多个二元变量合并为一个二元/数值变量。在这里，我们使用`+`运算符将数据集中所有的心脏诊断代码（CHF、
    hypertension和angina是心脏病）进行聚合。结果是统计每个五名患者的心脏诊断总数：
- en: '[PRE15]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Query Set #4d – aggregating cardiac diagnoses using COUNT'
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询集#4d – 使用COUNT聚合心脏诊断
- en: 'In Query Sets #4b and #4c, we binned and then aggregated three diagnostic codes
    using the `+` operator on the column names individually. However, we may be interested
    in binning and aggregating dozens, hundreds, or even thousands of diagnostic codes.
    The method of Query Sets #4b and #4c quickly becomes impractical for large aggregations.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在查询集#4b和#4c中，我们使用`+`运算符对列名分别进行分箱和聚合三个诊断代码。然而，我们可能会对分箱和聚合数十个、数百个甚至数千个诊断代码感兴趣。查询集#4b和#4c的方法对于大规模聚合来说很快变得不切实际。
- en: 'Here, we use the `COUNT` function and a supplemental table to aggregate the
    diagnostic codes listed in the table. We first use a `CREATE TABLE` statement
    to create a `CARDIAC_DX` table. The format of this `CREATE TABLE` statement is
    a bit different than that of Query Set #1\. In that example, we simply created
    a table by copying columns from an existing table. Here, we create the table from
    scratch by including parentheses and the column name, variable type, and `NOT
    NULL` statement enclosed in parentheses. If there were more than one column, they
    would be separated by commas within the parentheses.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`COUNT`函数和补充表格来聚合表格中列出的诊断代码。我们首先使用`CREATE TABLE`语句创建一个`CARDIAC_DX`表格。这个`CREATE
    TABLE`语句的格式与查询集#1中的略有不同。在那个示例中，我们只是通过从现有表格复制列来创建一个表格。这里，我们从头开始创建表格，包含括号、列名、变量类型和`NOT
    NULL`语句。如果有多个列，它们会在括号内用逗号分隔。
- en: 'After creating the table, we insert our three diagnostic codes into it using
    an `INSERT` statement: `I50.9`, `I10`, and `I20.9`. Then we add a column to our
    `MORT_FINAL_2` table called `Num_cardiac_dx_v2`.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 创建表格后，我们使用`INSERT`语句将三个诊断代码插入其中：`I50.9`、`I10`和`I20.9`。然后，我们在`MORT_FINAL_2`表中添加一个名为`Num_cardiac_dx_v2`的列。
- en: 'The final query updates the `Num_cardiac_dx_v2` column by adding the number
    of codes from the table that are present in the `Pri_dx_icd` or `Sec_dx_icd` column.
    It accomplishes that by using a `SELECT-FROM-WHERE` block for each column, inside
    the original `UPDATE` statement. Therefore, this type of query is called a *nested*
    query. Within each `SELECT` block, the `COUNT(*)` statement simply returns the
    number of rows of the resulting query as an integer. So for example, in Visit
    #10001, there is a cardiac code in the `Pri_dx_icd` column and there is also one
    match in the `Sec_dx_icd` column. The first `SELECT` block would return a value
    of `1`, since the query without `COUNT` would have returned a table with 1 row.
    By wrapping `COUNT` around `*`, `1` is returned as an integer. The second `SELECT`
    block also detects a match and returns a value of `1`. The `+` operator makes
    `2` the final result. By comparing the `Num_cardiac_dx` and `Num_cardiac_dx_2` columns,
    we see the result is exactly the same. So, which method is better? For small,
    simple aggregations, the first method is easier, because one simply has to make
    a column for each code and then aggregate them in a single statement with the
    + operator. However, in practice, you may wish to edit which codes are aggregated
    together to create features quite frequently. In this case, the second method
    is easier:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 最终查询通过在原始`UPDATE`语句中的每个列使用`SELECT-FROM-WHERE`块，更新`Num_cardiac_dx_v2`列，添加出现在`Pri_dx_icd`或`Sec_dx_icd`列中的代码数量。因此，这种类型的查询被称为*嵌套*查询。在每个`SELECT`块中，`COUNT(*)`语句简单地返回查询结果的行数作为整数。例如，在访问#10001中，`Pri_dx_icd`列中有一个心脏代码，`Sec_dx_icd`列中也有一个匹配项。第一个`SELECT`块将返回值`1`，因为如果没有`COUNT`，查询将返回一行的表格。通过将`COUNT`包裹在`*`周围，返回`1`作为整数。第二个`SELECT`块也检测到一个匹配项并返回值`1`。`+`运算符使最终结果为`2`。通过比较`Num_cardiac_dx`和`Num_cardiac_dx_2`列，我们发现结果完全相同。那么，哪种方法更好呢？对于小型、简单的聚合，第一个方法更容易，因为只需要为每个代码创建一个列，然后在一个语句中使用`+`运算符进行聚合。然而，在实践中，您可能希望频繁编辑哪些代码被一起聚合以创建特征。在这种情况下，第二种方法更容易：
- en: '[PRE16]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Query Set #5 – counting medications'
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询集#5 – 统计药物
- en: 'Now we''ll move on to the medications. Let''s add a feature that simply tallies
    the number of medications each patient is taking. In Query Set #5 (as follows)
    we first add the `Num_meds` column using an `ALTER TABLE` statement. Then, we
    use a `SELECT-FROM-WHERE` block inside of an `UPDATE` statement to find the number
    of medications for each patient. The query works by tallying, for each patient
    ID in the `MORT_FINAL_2` table, the number of rows in the `MEDICATIONS` table
    where the corresponding patient ID is equal. Again, we use the `COUNT` function
    to get the number of rows. We introduce a new function in this query, `DISTINCT`.
    `DISTINCT` removes any rows containing duplicate values for the column in parentheses.
    So for example, if `LISINOPRIL` was listed twice for a patient, the `DISTINCT(Rx_name)`
    function call would ensure it is only counted once:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将转到药物部分。我们将添加一个功能，简单地统计每个患者所服用的药物数量。在查询集#5（如下所示）中，我们首先使用`ALTER TABLE`语句添加`Num_meds`列。然后，我们在`UPDATE`语句中使用`SELECT-FROM-WHERE`块来查找每个患者所服用的药物数量。该查询通过统计`MORT_FINAL_2`表中每个患者ID的行数，其中`MEDICATIONS`表中的相应患者ID相等。同样，我们使用`COUNT`函数来获取行数。在此查询中，我们引入了一个新函数`DISTINCT`。`DISTINCT`会删除任何包含括号内列的重复值的行。例如，如果`LISINOPRIL`对某个患者列出了两次，`DISTINCT(Rx_name)`函数调用将确保只计数一次：
- en: '[PRE17]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Query Set #6 – binning abnormal lab results'
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询集#6 – 分类异常实验室结果
- en: Several research articles have found lab values to be important predictors for
    clinical outcomes such as readmission (Donze et al., 2013). Lab results are problematic,
    however, because they are missing in most patients. No lab result type will be
    present for every patient; for example, in our example, not every patient got
    blood drawn for lab tests during their visit. Indeed, of the three different types
    of lab tests present in our data, the most common test was the BNP, drawn in four
    out of six patients. What do we do with the other two patients?
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 一些研究文章发现，实验室值是临床结果（如再入院）的重要预测因素（Donze等，2013）。然而，实验室结果是有问题的，因为大多数患者缺失这些数据。没有一种实验室结果类型会出现在每个患者中；例如，在我们的例子中，并非每个患者在访问期间都进行了抽血检查。事实上，在我们数据中存在的三种不同类型的实验室检查中，最常见的检查是BNP，六个患者中的四个进行了此检查。那么，我们该如何处理另外两个患者呢？
- en: 'One way around this is to set up a "flag" for the presence of an abnormal result.
    This is accomplished in Query Set #6 for the glucose lab test. After the first
    query adds the `Abnml_glucose` column with an `ALTER TABLE` statement, the next
    query sets the result equal to the number of times that specific lab test exceeds
    a value of 200 for each patient visit. Notice the multiple `AND` clauses; they
    are necessary for selecting the right patient, date, and lab test of interest.
    So, only visits with an excessive result will have a value greater than zero for
    this feature. Notice we use the `CAST()` function to convert the values from `TEXT`
    to `FLOAT` before testing the value:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这一问题的一种方法是为异常结果的存在设置“标志”。在查询集#6中实现了这一点，用于葡萄糖实验。第一个查询通过`ALTER TABLE`语句添加了`Abnml_glucose`列，接下来的查询将结果设置为每次患者访问时该特定实验值超过200的次数。注意多个`AND`子句；它们对于选择正确的患者、日期和感兴趣的实验是必要的。因此，只有异常结果的访问才会有大于零的值。请注意，我们使用`CAST()`函数将值从`TEXT`类型转换为`FLOAT`类型，再进行值的测试：
- en: '[PRE18]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'While this solves the missing lab data problem, a limitation of this method
    is that it treats missing results and normal results as being the same. In Query
    Set #7, we will study basic methods for filling in missing values.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这解决了缺失实验数据的问题，但该方法的局限性在于它将缺失结果和正常结果视为相同。在查询集#7中，我们将研究填补缺失值的基本方法。
- en: 'Query Set #7 – imputing missing variables'
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询集#7 – 填补缺失的变量
- en: 'While the method presented in Query Set #6 solves the missing data problems
    for labs, all of the information contained in the actual lab values is discarded.
    For BNP, for example, only two of the patients don''t have a value, and for the
    temperature vital sign, only one patient is missing.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然查询集#6中呈现的方法解决了实验室缺失数据的问题，但实际实验值中的所有信息都被丢弃了。例如，对于BNP，只有两名患者没有值，而对于温度这一生命体征，只有一名患者缺失。
- en: Some previous studies have experimented with this principle and have obtained
    good results with predictive models while using it. In (Donze et al., 2013), some
    of the patient discharges (around 1%) had missing data. This data was filled in
    by assuming it was in the normal range.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 一些先前的研究已经实验过这一原理，并且在使用预测模型时取得了良好的效果。在（Donze等，2013）中，一些患者的出院数据（约1%）存在缺失。这些数据通过假设其在正常范围内来填补。
- en: In SQL, **single imputation** can easily be done. We demonstrate this here.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在SQL中，**单一填补**可以轻松实现。我们在这里演示这一点。
- en: 'Query Set #7a – imputing missing temperature values using normal-range imputation'
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询集#7a – 使用常规范围填补缺失的温度值
- en: 'Here, we use an `UPDATE` statement to set the temperature variable to `98.6`
    where it is missing:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`UPDATE`语句将温度变量设置为`98.6`，用于填补缺失值：
- en: '[PRE19]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Query Set #7b – imputing missing temperature values using mean imputation'
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询集#7b – 使用均值填补缺失的温度值
- en: 'Here, we use **mean imputation** instead of normal-value imputation to fill
    in the missing temperature value. As such, the `98.6` value from Query Set #7a
    is replaced with a `SELECT-FROM-WHERE` block that finds the mean of the temperature
    variable (`98.4`, in this case) where it is not missing. The `AVG()` function
    returns the mean of a collection of values. The `AVG()` function and similar functions
    (`MIN()`, `MAX()`, `COUNT()`, `SUM()`, and so on) are termed **aggregate functions**
    because they describe an aggregation of values using a single value:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用**均值填补**而不是常规值填补来填补缺失的温度值。因此，查询集#7a中的`98.6`值被一个`SELECT-FROM-WHERE`语句替换，该语句在温度变量（在此为`98.4`）不缺失的地方找到均值。`AVG()`函数返回一组值的平均值。`AVG()`函数和类似的函数（如`MIN()`、`MAX()`、`COUNT()`、`SUM()`等）被称为**聚合函数**，因为它们描述了通过一个单一值对一组值进行聚合的操作：
- en: '[PRE20]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Query Set #7c – imputing missing BNP values using a uniform distribution'
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询集#7c – 使用均匀分布填补缺失的BNP值
- en: 'While imputing the single missing temperature value was not difficult in our
    example, imputing the two missing BNP values is more problematic for a number
    of reasons:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在我们的示例中填补单个缺失的温度值并不困难，但填补两个缺失的BNP值却存在多个问题：
- en: There is a higher proportion of visits that have a missing BNP value.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缺失BNP值的访问比例较高。
- en: While the normal temperature range is simply 98.6, BNP has a huge normal range
    of 100 - 400 pg/mL. How do we select which value to impute when doing normal-value
    imputation?
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然正常体温范围简单地是98.6，但BNP有一个范围较大的正常值，介于100 - 400 pg/mL之间。在进行常规值填补时，我们如何选择要填补的值？
- en: The mean of the BNP values in our dataset is 462.5, which is, in fact, abnormal.
    This means that if we tried mean imputation with this variable, we would be imputing
    an abnormal value for all patients who didn't have blood drawn, a highly unlikely
    scenario.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们数据集中 BNP 值的均值为 462.5，实际上是异常的。这意味着如果我们对这个变量进行均值填补，我们将为所有没有抽血的患者填补一个异常值，这是一个极不可能的情景。
- en: 'While there is no perfect answer for this problem, if we do try to salvage
    the raw BNP values (which means imputing the missing values), in this query set,
    we impute from a uniform distribution of values in the normal range:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个问题没有完美的答案，但如果我们尝试恢复原始的 BNP 值（这意味着填补缺失值），在这个查询集中，我们会从正常范围的均匀分布中填补缺失值：
- en: '[PRE21]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Query Set #8 – adding the target variable'
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '查询集 #8 – 添加目标变量'
- en: 'We are almost done with our table. We''ve gone through all of the data. The
    only thing left to add is the target variable. See the following:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的表格几乎完成了。我们已经处理了所有数据。剩下要添加的就是目标变量。请看以下内容：
- en: '[PRE22]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Query Set #9 – visualizing the MORT_FINAL_2 table'
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '查询集 #9 – 可视化 MORT_FINAL_2 表'
- en: 'To visualize our end result, we can do the following:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 为了可视化我们的最终结果，我们可以执行以下操作：
- en: '[PRE23]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Summary
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned how to engineer healthcare data in a database format
    using SQL. We downloaded and installed SQLite, and wrote some SQL queries to get
    the data in a format that we want for modeling.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用 SQL 以数据库格式处理医疗保健数据。我们下载并安装了 SQLite，并编写了一些 SQL 查询，以便将数据转化为我们希望的模型格式。
- en: Next, in [Chapter 5](12ee77f2-0655-4dc5-abb1-2868d6fcc386.xhtml), *Computing
    Foundations – Introduction to Python*, we will continue our discussion of computing
    foundations with an exploration of the Python programming language.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在 [第5章](12ee77f2-0655-4dc5-abb1-2868d6fcc386.xhtml)，*计算基础 – Python 介绍*，我们将继续讨论计算基础，探索
    Python 编程语言。
- en: References and further reading
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考文献与进一步阅读
- en: 'Basole RC, Braunstein ML, Kumar V, Park H, Kahng M, Chau DH, Tamersoy A, Hirsh
    DA, Serban N, BostJ, Lesnick B, Schissel BL, Thompson M (2015). Understanding
    variations in pediatric asthma care processes in the emergency department using
    visual analytics. *Journal of the American Medical Informatics Association *22(2):
    318–323, [https://doi.org/10.1093/jamia/ocu016.](https://doi.org/10.1093/jamia/ocu016)'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 'Basole RC, Braunstein ML, Kumar V, Park H, Kahng M, Chau DH, Tamersoy A, Hirsh
    DA, Serban N, BostJ, Lesnick B, Schissel BL, Thompson M (2015)。在急诊科使用可视化分析理解儿科哮喘护理过程中的变异性。
    *Journal of the American Medical Informatics Association* 22(2): 318–323, [https://doi.org/10.1093/jamia/ocu016.](https://doi.org/10.1093/jamia/ocu016)'
- en: 'Donze J, Aujesky D, Williams D, Schnipper JL (2013). Potentially avoidable
    30-day hospital readmissions in medical patients: derivation and validation of
    a prediction model. *JAMA Intern Med *173(8): 632-638.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 'Donze J, Aujesky D, Williams D, Schnipper JL (2013). 可避免的30天住院再入院：医学患者的预测模型的推导与验证。
    *JAMA Intern Med* 173(8): 632-638。'
- en: 'Elmasri R, Navathe S (2010). Fundamentals of Database Systems, 6th Edition.
    Boston, MA: Addison Wesley.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: Elmasri R, Navathe S (2010)。数据库系统基础，第6版。波士顿，MA：Addison Wesley。
- en: 'Futoma J, Morris J, Lucas J (2015). A comparison of models for predicting early
    hospital readmissions. *Journal of Biomedical Informatics *56: 229-238.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 'Futoma J, Morris J, Lucas J (2015)。预测早期住院再入院的模型比较。 *Journal of Biomedical Informatics*
    56: 229-238。'
- en: 'Kasper DL, Braunwald E, Fauci AS, Hauser SL, Longo DL, Jameson JL (2005), eds. *Harrison''s
    Principles of Internal Medicine, *16e. New York, NY: McGraw-Hill.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Kasper DL, Braunwald E, Fauci AS, Hauser SL, Longo DL, Jameson JL (2005)，主编。
    *Harrison's Principles of Internal Medicine,* 第16版。纽约，NY：McGraw-Hill。
- en: Rajkomar A, Oren E, Chen K, Dai AM, Hajaj N, Hardt M, et al. (2018). Scalable
    and accurate deep learning with electronic health records. *npj Digital Medicine *1:18;
    doi:10.1038/s41746-018-0029-1.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Rajkomar A, Oren E, Chen K, Dai AM, Hajaj N, Hardt M, 等 (2018)。使用电子健康记录进行可扩展且准确的深度学习。
    *npj Digital Medicine* 1:18; doi:10.1038/s41746-018-0029-1。
- en: 'Sahni N, Simon G, Arora R (2018). *J Gen Intern Med* 33: 921\. [https://doi.org/10.1007/s11606-018-4316-y](https://doi.org/10.1007/s11606-018-4316-y)'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 'Sahni N, Simon G, Arora R (2018). *J Gen Intern Med* 33: 921\. [https://doi.org/10.1007/s11606-018-4316-y](https://doi.org/10.1007/s11606-018-4316-y)'
- en: SQLite Home Page. [http://www.sqlite.org/](http://www.sqlite.org/). Accessed
    04/03/2017.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 首页。 [http://www.sqlite.org/](http://www.sqlite.org/)。访问时间：04/03/2017。
