- en: NumPy and pandas
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 和 pandas
- en: Now that we have understood data analysis, its process, and its installation
    on different platforms, it's time to learn about NumPy arrays and `pandas` DataFrames.
    This chapter acquaints you with the fundamentals of NumPy arrays and `pandas`
    DataFrames. By the end of this chapter, you will have a basic understanding of
    NumPy arrays, and `pandas` DataFrames and their related functions.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经理解了数据分析、数据分析过程以及在不同平台上的安装，是时候学习 NumPy 数组和 `pandas` DataFrames 了。本章将带你了解
    NumPy 数组和 `pandas` DataFrames 的基础知识。在本章结束时，你将对 NumPy 数组、`pandas` DataFrames 及其相关函数有基本的理解。
- en: '`pandas` is named after panel data (an econometric term) and Python data analysis
    and is a popular open-source Python library. We shall learn about basic `pandas`
    functionalities, data structures, and operations in this chapter. The official
    `pandas` documentation insists on naming the project `pandas` in all lowercase
    letters. The other convention the `pandas` project insists on is the `import pandas
    as pd` import statement.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '`pandas` 以面板数据（一个计量经济学术语）和 Python 数据分析命名，是一个流行的开源 Python 库。在本章中，我们将学习 `pandas`
    的基本功能、数据结构和操作。官方的 `pandas` 文档坚持将该项目命名为全小写的 `pandas`。`pandas` 项目坚持的另一个惯例是使用 `import
    pandas as pd` 的导入语句。'
- en: 'In this chapter, our focus will be on the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将重点讨论以下主题：
- en: Understanding NumPy arrays
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 NumPy 数组
- en: NumPy array numerical data types
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NumPy 数组数值数据类型
- en: Manipulating array shapes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作数组形状
- en: The stacking of NumPy arrays
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NumPy 数组的堆叠
- en: Partitioning NumPy arrays
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 划分 NumPy 数组
- en: Changing the data type of NumPy arrays
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改 NumPy 数组的数据类型
- en: Creating NumPy views and copies
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 NumPy 视图和副本
- en: Slicing NumPy arrays
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 切片 NumPy 数组
- en: Boolean and fancy indexing
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布尔和花式索引
- en: Broadcasting arrays
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 广播数组
- en: Creating `pandas` DataFrames
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 `pandas` DataFrames
- en: Understanding `pandas` Series
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 `pandas` Series
- en: Reading and querying the Quandl data
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阅读和查询 Quandl 数据
- en: Describing `pandas` DataFrames
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述 `pandas` DataFrames
- en: Grouping and joining `pandas` DataFrames
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分组和连接 `pandas` DataFrames
- en: Working with missing values
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理缺失值
- en: Creating pivot tables
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建数据透视表
- en: Dealing with dates
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理日期
- en: Technical requirements
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'This chapter has the following technical requirements:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 本章具有以下技术要求：
- en: 'You can find the code and the dataset at the following GitHub link: [https://github.com/PacktPublishing/Python-Data-Analysis-Third-Edition/tree/master/Chapter02](https://github.com/PacktPublishing/Python-Data-Analysis-Third-Edition/tree/master/Chapter02).'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在以下 GitHub 链接找到代码和数据集：[https://github.com/PacktPublishing/Python-Data-Analysis-Third-Edition/tree/master/Chapter02](https://github.com/PacktPublishing/Python-Data-Analysis-Third-Edition/tree/master/Chapter02)。
- en: All the code blocks are available at `ch2.ipynb`.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有代码块都可以在 `ch2.ipynb` 中找到。
- en: This chapter uses four CSV files (`WHO_first9cols.csv`, `dest.csv`, `purchase.csv`,
    and `tips.csv`) for practice purposes.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章使用四个 CSV 文件（`WHO_first9cols.csv`、`dest.csv`、`purchase.csv` 和 `tips.csv`）进行练习。
- en: In this chapter, we will use the NumPy, `pandas`, and Quandl Python libraries.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章我们将使用 NumPy、`pandas` 和 Quandl Python 库。
- en: Understanding NumPy arrays
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 NumPy 数组
- en: NumPy can be installed on a PC using `pip` or `brew` but if the user is using
    the Jupyter Notebook, then there is no need to install it. NumPy is already installed
    in the Jupyter Notebook. I will suggest to you to please use the Jupyter Notebook
    as your IDE because we are executing all the code in the Jupyter Notebook. We
    have already shown in [Chapter 1](d6dfd6dc-2d6e-4984-a2d6-e205384cd2a8.xhtml),
    *Getting Started with Python Libraries*, how to install Anaconda, which is a complete
    suite for data analysis. NumPy arrays are a series of homogenous items. Homogenous
    means the array will have all the elements of the same data type. Let's create
    an array using NumPy. You can create an array using the `array()` function with
    a list of items. Users can also fix the data type of an array. Possible data types
    are `bool`, `int`, `float`, `long`, `double`, and `long double`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `pip` 或 `brew` 在 PC 上安装 NumPy，但如果用户使用 Jupyter Notebook，则无需安装。NumPy 已经预装在
    Jupyter Notebook 中。我建议你使用 Jupyter Notebook 作为 IDE，因为我们将在 Jupyter Notebook 中执行所有代码。我们在[第
    1 章](d6dfd6dc-2d6e-4984-a2d6-e205384cd2a8.xhtml)中，*Python 库入门*，已经展示了如何安装 Anaconda，这是一个完整的数据分析套件。NumPy
    数组是一系列同质的项目。同质意味着数组中的所有元素都是相同的数据类型。让我们使用 NumPy 创建一个数组。你可以使用 `array()` 函数结合一个项目列表来创建数组。用户还可以固定数组的数据类型。可能的数据类型有
    `bool`、`int`、`float`、`long`、`double` 和 `long double`。
- en: 'Let''s see how to create an empty array:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下如何创建一个空数组：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Another way to create a NumPy array is with `arange()`. It creates an evenly
    spaced NumPy array. Three values – start, stop, and step – can be passed to the
    `arange(start,[stop],step)` function. The start is the initial value of the range,
    the stop is the last value of the range, and the step is the increment in that
    range. The stop parameter is compulsory. In the following example, we have used
    `1` as the start and `11` as the stop parameter. The `arange(1,11)` function will
    return 1 to 10 values with one step because the step is, by default, 1\. The `arrange()`
    function generates a value that is one less than the stop parameter value. Let''s
    understand this through the following example:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 NumPy 数组的另一种方法是使用 `arange()`。它会创建一个均匀间隔的 NumPy 数组。可以传递三个值 —— start、stop 和
    step —— 给 `arange(start,[stop],step)` 函数。start 是范围的起始值，stop 是范围的结束值，而 step 是该范围内的增量。stop
    参数是必须的。在以下示例中，我们使用 `1` 作为起始值，`11` 作为结束值。`arange(1,11)` 函数将返回从 1 到 10 的值，步长默认为
    1。`arange()` 函数会生成一个比 stop 参数值小 1 的值。让我们通过以下示例来理解这一点：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Apart from the `array()` and `arange()` functions, there are other options,
    such as `zeros()`, `ones()`, `full()`, `eye()`, and `random()`, which can also
    be used to create a NumPy array, as these functions are initial placeholders.
    Here is a detailed description of each function:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `array()` 和 `arange()` 函数外，还有其他选项，如 `zeros()`、`ones()`、`full()`、`eye()` 和
    `random()`，这些也可以用来创建 NumPy 数组，因为这些函数是初始占位符。以下是每个函数的详细说明：
- en: '`zeros()`: The `zeros()`function creates an array for a given dimension with
    all zeroes.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`zeros()`: `zeros()` 函数为给定维度创建一个全为 0 的数组。'
- en: '`ones()`: The `ones()` function creates an array for a given dimension with
    all ones.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ones()`: `ones()` 函数为给定维度创建一个全为 1 的数组。'
- en: '`fulls()`: The `full()` function generates an array with constant values.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fulls()`: `full()` 函数生成一个具有常数值的数组。'
- en: '`eyes()`: The `eye()` function creates an identity matrix.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`eyes()`: `eye()` 函数创建一个单位矩阵。'
- en: '`random()`: The `random()` function creates an array with any given dimension.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`random()`: `random()` 函数创建一个具有任意给定维度的数组。'
- en: 'Let''s understand these functions through the following example:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下示例来理解这些函数：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This results in the following output:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding code, we have seen some built-in functions for creating arrays
    with all-zero values, all-one values, and all-constant values. After that, we
    have created the identity matrix using the `eye()` function and a random matrix
    using the `random.random()` function. Let's see some other array features in the
    next section.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们已经看到了一些用于创建全零值、全一值和全常数值数组的内置函数。之后，我们使用 `eye()` 函数创建了一个单位矩阵，并使用 `random.random()`
    函数创建了一个随机矩阵。接下来，我们将在下一节看到一些其他的数组特性。
- en: Array features
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组特性
- en: In general, NumPy arrays are a homogeneous kind of data structure that has the
    same types of items. The main benefit of an array is its certainty of storage
    size because of its same type of items. A Python list uses a loop to iterate the
    elements and perform operations on them. Another benefit of NumPy arrays is to
    offer vectorized operations instead of iterating each item and performing operations
    on it. NumPy arrays are indexed just like a Python list and start from 0\. NumPy
    uses an optimized C API for the fast processing of the array operations.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，NumPy 数组是一种同质的数据结构，所有项的类型相同。数组的主要优点是其存储大小的确定性，因为它们包含相同类型的项。Python 列表使用循环来迭代元素并对其执行操作。NumPy
    数组的另一个优点是提供矢量化操作，而不是逐个迭代每个项并对其进行操作。NumPy 数组的索引方式与 Python 列表一样，从 0 开始。NumPy 使用优化的
    C API 来加速数组操作的处理。
- en: 'Let''s make an array using the `arange()` function, as we did in the previous
    section, and let''s check its data type:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们像前面章节一样，使用 `arange()` 函数创建一个数组，并检查它的数据类型：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: When you use `type()`, it returns `numpy.ndarray`. This means that the `type()`
    function returns the type of the container. When you use `dtype()`, it will return
    `int64`, since it is the type of the elements. You may also get the output as
    `int32` if you are using 32-bit Python. Both cases use integers (32- and 64-bit).
    One-dimensional NumPy arrays are also known as vectors.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 `type()` 时，它会返回 `numpy.ndarray`。这意味着 `type()` 函数返回的是容器的类型。当你使用 `dtype()`
    时，它将返回 `int64`，因为它是元素的类型。如果你使用的是 32 位的 Python，你也可能得到 `int32` 作为输出。这两种情况都使用整数（32
    位和 64 位）。一维的 NumPy 数组也被称为向量。
- en: 'Let''s find out the shape of the vector that we produced a few minutes ago:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们找出几分钟前我们生成的向量的形状：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see, the vector has 10 elements with values ranging from 1 to 10\.
    The `shape` property of the array is a tuple; in this instance, it is a tuple
    of one element, which holds the length in each dimension.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，该向量有10个元素，值范围从1到10。数组的 `shape` 属性是一个元组；在这个例子中，它是一个包含一个元素的元组，表示每个维度的长度。
- en: Selecting array elements
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择数组元素
- en: 'In this section, we will see how to select the elements of the array. Let''s
    see an example of a 2*2 matrix:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将学习如何选择数组中的元素。让我们看一个 2*2 矩阵的例子：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding example, the matrix is created using the `array()` function
    with the input list of lists.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，矩阵是通过 `array()` 函数创建的，输入是一个包含列表的列表。
- en: 'Selecting array elements is pretty simple. We just need to specify the index
    of the matrix as `a[m,n]`. Here, `m` is the row index and `n` is the column index
    of the matrix. We will now select each item of the matrix one by one as shown
    in the following code:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 选择数组元素非常简单。我们只需要指定矩阵的索引 `a[m,n]`。这里，`m` 是行索引，`n` 是列索引。我们现在将按顺序选择矩阵中的每个元素，如下代码所示：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the preceding code sample, we have tried to access each element of an array
    using array indices. You can also understand this by the diagram mentioned here:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们尝试使用数组索引访问数组的每个元素。你也可以通过这里的图示理解这一点：
- en: '![](img/b919f96a-3be5-4592-821a-1f8494af6bbb.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b919f96a-3be5-4592-821a-1f8494af6bbb.png)'
- en: In the preceding diagram, we can see it has four blocks and each block represents
    the element of an array. The values written in each block show its indices.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图示中，我们可以看到它有四个块，每个块代表一个数组元素。每个块中的数值显示其索引。
- en: In this section, we have understood the fundamentals of arrays. Now, let's jump
    to arrays of numerical data types.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们已经了解了数组的基本概念。现在，让我们继续学习数值数据类型的数组。
- en: NumPy array numerical data types
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NumPy 数组数值数据类型
- en: 'Python offers three types of numerical data types: integer type, float type,
    and complex type. In practice, we need more data types for scientific computing
    operations with precision, range, and size. NumPy offers a bulk of data types
    with mathematical types and numbers. Let''s see the following table of NumPy numerical
    types:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Python 提供了三种数值数据类型：整数类型、浮点类型和复数类型。在实际应用中，我们需要更多的数据类型来进行科学计算操作，以确保精度、范围和大小。NumPy
    提供了大量的数学类型和数值类型。让我们看看下面的 NumPy 数值类型表格：
- en: '| **Data Type** | **Details** |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| **数据类型** | **详细信息** |'
- en: '| `bool` | This is a Boolean type that stores a bit and takes `True` or `False`
    values. |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `bool` | 这是一个布尔类型，存储一个比特，取值为 `True` 或 `False`。 |'
- en: '| `inti` | Platform integers can be either `int32` or `int64`. |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `inti` | 平台整数可以是 `int32` 或 `int64`。 |'
- en: '| `int8` | Byte store values range from `-128` to `127`. |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `int8` | 字节存储的值范围从 `-128` 到 `127`。 |'
- en: '| `int16` | This stores integers ranging from `-32768` to `32767`. |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `int16` | 该类型存储从 `-32768` 到 `32767` 的整数。 |'
- en: '| `int32` | This stores integers ranging from `-2 ** 31` to `2 ** 31 -1`. |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `int32` | 该类型存储从 `-2 ** 31` 到 `2 ** 31 -1` 的整数。 |'
- en: '| `int64` | This stores integers ranging from `-2 ** 63` to `2 ** 63 -1`. |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `int64` | 该类型存储从 `-2 ** 63` 到 `2 ** 63 -1` 的整数。 |'
- en: '| `uint8` | This stores unsigned integers ranging from `0` to `255`. |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `uint8` | 该类型存储无符号整数，范围从 `0` 到 `255`。 |'
- en: '| `uint16` | This stores unsigned integers ranging from `0` to `65535`. |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `uint16` | 该类型存储无符号整数，范围从 `0` 到 `65535`。 |'
- en: '| `uint32` | This stores unsigned integers ranging from `0` to `2 ** 32 – 1`.
    |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `uint32` | 该类型存储无符号整数，范围从 `0` 到 `2 ** 32 – 1`。 |'
- en: '| `uint64` | This stores unsigned integers ranging from `0` to `2 ** 64 – 1`.
    |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `uint64` | 该类型存储无符号整数，范围从 `0` 到 `2 ** 64 – 1`。 |'
- en: '| `float16` | Half-precision float; sign bit with 5 bits exponent and 10 bits
    mantissa. |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `float16` | 半精度浮点数；符号位，5位指数和10位尾数。 |'
- en: '| `float32` | Single-precision float; sign bit with 8 bits exponent and 23
    bits mantissa. |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `float32` | 单精度浮点数；符号位，8位指数和23位尾数。 |'
- en: '| `float64` or `float` | Double-precision float; sign bit with 11 bits exponent
    and 52 bits mantissa. |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `float64` 或 `float` | 双精度浮点数；符号位，11位指数和52位尾数。 |'
- en: '| `complex64` | Complex number stores two 32-bit floats: real and imaginary
    number. |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `complex64` | 复数类型存储两个 32 位浮点数：实数和虚数。 |'
- en: '| `complex128` or `complex` | Complex number stores two 64-bit floats: real
    and imaginary number. |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `complex128` 或 `complex` | 复数类型存储两个 64 位浮点数：实数和虚数。 |'
- en: 'For each data type, there exists a matching conversion function:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每种数据类型，都存在一个相应的转换函数：
- en: '[PRE8]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Many functions have a data type argument, which is frequently optional:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 许多函数都有一个数据类型参数，通常是可选的：
- en: '[PRE9]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'It is important to be aware that you are not allowed to change a complex number
    into an integer. If you try to convert complex data types into integers, then
    you will get `TypeError`. Let''s see the following example:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，你不能将复数转换为整数。如果尝试将复合数据类型转换为整数，将会遇到 `TypeError`。我们来看一下以下示例：
- en: '[PRE10]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This results in the following output:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![](img/dcf3bbd1-687f-456d-b900-f5dd18413eb2.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dcf3bbd1-687f-456d-b900-f5dd18413eb2.png)'
- en: You will get the same error if you try the conversion of a complex number into
    a floating point.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试将复数转换为浮点数，也会遇到同样的错误。
- en: 'But you can convert float values into complex numbers by setting individual
    pieces. You can also pull out the pieces using the `real` and `imag` attributes.
    Let''s see that using the following example:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，你可以通过设置各个部分，将浮动值转换为复数。你也可以通过 `real` 和 `imag` 属性提取这些部分。我们通过以下示例来看一下：
- en: '[PRE11]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding example, you have defined a complex number using the `complex()`
    method. Also, you have extracted the real and imaginary values using the `real`
    and `imag` attributes. Let's now jump to `dtype` objects.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，你已经使用 `complex()` 方法定义了一个复数。同时，你通过 `real` 和 `imag` 属性提取了实部和虚部。接下来，让我们来看看
    `dtype` 对象。
- en: dtype objects
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`dtype` 对象'
- en: 'We have seen in earlier sections of the chapter that `dtype` tells us the type
    of individual elements of an array. NumPy array elements have the same data type,
    which means that all elements have the same `dtype`. `dtype` objects are instances
    of the `numpy.dtype` class:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章的前面部分已经看到，`dtype` 告诉我们数组中单个元素的类型。NumPy 数组的元素具有相同的数据类型，这意味着所有元素都有相同的 `dtype`。`dtype`
    对象是 `numpy.dtype` 类的实例：
- en: '[PRE12]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`dtype` objects also tell us the size of the data type in bytes using the `itemsize`
    property:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`dtype` 对象还通过 `itemsize` 属性告诉我们数据类型的字节大小：'
- en: '[PRE13]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Data type character codes
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据类型字符代码
- en: 'Character codes are included for backward compatibility with Numeric. Numeric
    is the predecessor of NumPy. Its use is not recommended, but the code is supplied
    here because it pops up in various locations. You should use the `dtype` object
    instead. The following table lists several different data types and the character
    codes related to them:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 字符代码是为了与 Numeric 兼容。Numeric 是 NumPy 的前身。虽然不推荐使用它，但代码仍然被提供，因为它在不同的地方会出现。你应该使用
    `dtype` 对象。以下表格列出了几种不同的数据类型及其相关字符代码：
- en: '| **Type** | **Character Code** |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| **类型** | **字符代码** |'
- en: '| Integer | i |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| 整数 | i |'
- en: '| Unsigned integer | u |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| 无符号整数 | u |'
- en: '| Single-precision float | f |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| 单精度浮动 | f |'
- en: '| Double-precision float | d |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| 双精度浮动 | d |'
- en: '| Bool | b |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| 布尔值 | b |'
- en: '| Complex | D |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| 复数 | D |'
- en: '| String | S |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| 字符串 | S |'
- en: '| Unicode | U |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| Unicode | U |'
- en: '| Void | V |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| 空类型 | V |'
- en: 'Let''s take a look at the following code to produce an array of single-precision
    floats:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们来看以下代码，生成单精度浮动数组：
- en: '[PRE14]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Likewise, the following code creates an array of complex numbers:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，以下代码创建了一个复数数组：
- en: '[PRE15]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: dtype constructors
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`dtype` 构造函数'
- en: 'There are lots of ways to create data types using constructors. Constructors
    are used to instantiate or assign a value to an object. In this section, we will
    understand data type creation with the help of a floating-point data example:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多方法可以通过构造函数创建数据类型。构造函数用于实例化或赋值给对象。在本节中，我们将通过浮动数据类型的例子来理解数据类型的创建：
- en: 'To try out a general Python float, use the following:'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要尝试一个通用的 Python 浮动，请使用以下代码：
- en: '[PRE16]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To try out a single-precision float with a character code, use the following:'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要尝试带有字符代码的单精度浮动，请使用以下代码：
- en: '[PRE17]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To try out a double-precision float with a character code, use the following:'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要尝试带有字符代码的双精度浮动，请使用以下代码：
- en: '[PRE18]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To try out a `dtype` constructor with a two-character code, use the following:'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要尝试带有双字符代码的 `dtype` 构造函数，请使用以下代码：
- en: '[PRE19]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here, the first character stands for the type and a second character is a number
    specifying the number of bytes in the type, for example, 2, 4, or 8.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，第一个字符代表类型，第二个字符是指定类型字节数的数字，例如 2、4 或 8。
- en: dtype attributes
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`dtype` 属性'
- en: 'The `dtype` class offers several useful attributes. For example, we can get
    information about the character code of a data type using the `dtype` attribute:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`dtype` 类提供了多个有用的属性。例如，我们可以通过 `dtype` 属性获取数据类型的字符代码信息：'
- en: '[PRE20]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `type` attribute corresponds to the type of object of the array elements:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`type` 属性对应数组元素的对象类型：'
- en: '[PRE21]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now that we know all about the various data types used in NumPy arrays, let's
    start manipulating them in the next section.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了 NumPy 数组中使用的各种数据类型，让我们在下一节中开始操作它们。
- en: Manipulating array shapes
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作数组形状
- en: 'In this section, our main focus is on array manipulation. Let''s learn some
    new Python functions of NumPy, such as `reshape()`, `flatten()`, `ravel()`, `transpose()`,
    and `resize()`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们的主要关注点是数组操作。让我们学习一些 NumPy 的新 Python 函数，如 `reshape()`、`flatten()`、`ravel()`、`transpose()`
    和 `resize()`：
- en: '`reshape()` will change the shape of the array:'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reshape()` 会改变数组的形状：'
- en: '[PRE22]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Another operation that can be applied to arrays is `flatten()`. `flatten()`
    transforms an n-dimensional array into a one-dimensional array:'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一种可以应用于数组的操作是 `flatten()`。`flatten()` 将 n 维数组转换为一维数组：
- en: '[PRE23]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `ravel()` function is similar to the `flatten()` function. It also transforms
    an n-dimensional array into a one-dimensional array. The main difference is that
    `flatten()` returns the actual array while `ravel()` returns the reference of
    the original array. The `ravel()` function is faster than the `flatten()` function
    because it does not occupy extra memory:'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ravel()` 函数类似于 `flatten()` 函数。它也将 n 维数组转换为一维数组。主要区别在于，`flatten()` 返回的是实际的数组，而
    `ravel()` 返回的是原数组的引用。由于 `ravel()` 不占用额外的内存，它比 `flatten()` 更快：'
- en: '[PRE24]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `transpose()` function is a linear algebraic function that transposes the
    given two-dimensional matrix. The word transpose means converting rows into columns
    and columns into rows:'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`transpose()` 函数是一个线性代数函数，它将给定的二维矩阵进行转置。转置的意思是将行转化为列，将列转化为行：'
- en: '[PRE25]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `resize()` function changes the size of the NumPy array. It is similar
    to `reshape()` but it changes the shape of the original array:'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resize()` 函数改变 NumPy 数组的大小。它类似于 `reshape()`，但它会改变原数组的形状：'
- en: '[PRE26]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In all the code in this section, we have seen built-in functions such as `reshape()`,
    `flatten()`, `ravel()`, `transpose()`, and `resize()` for manipulating size. Now,
    it's time to learn about the stacking of NumPy arrays.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的所有代码中，我们看到了用于操作大小的内置函数，如 `reshape()`、`flatten()`、`ravel()`、`transpose()`
    和 `resize()`。现在，是时候学习 NumPy 数组的堆叠了。
- en: The stacking of NumPy arrays
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NumPy 数组的堆叠
- en: 'NumPy offers a stack of arrays. Stacking means joining the same dimensional
    arrays along with a new axis. Stacking can be done horizontally, vertically, column-wise,
    row-wise, or depth-wise:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 提供了数组堆叠功能。堆叠是指沿着新的轴将具有相同维度的数组连接。堆叠可以在水平方向、垂直方向、列方向、行方向或深度方向进行：
- en: '**Horizontal stacking**: In horizontal stacking, the same dimensional arrays
    are joined along with a horizontal axis using the `hstack()` and `concatenate()`
    functions. Let''s see the following example:'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**水平堆叠**：在水平堆叠中，具有相同维度的数组沿水平轴通过 `hstack()` 和 `concatenate()` 函数连接。让我们来看下面的例子：'
- en: '[PRE27]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We have created one 3*3 array; it''s time to create another 3*3 array:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了一个 3*3 的数组，现在是时候创建另一个 3*3 的数组了：
- en: '[PRE28]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'After creating two arrays, we will perform horizontal stacking:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 创建两个数组后，我们将进行水平堆叠：
- en: '[PRE29]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In the preceding code, two arrays are stacked horizontally along the *x* axis.
    The `concatenate()` function can also be used to generate the horizontal stacking
    with axis parameter value `1`:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，两个数组沿 *x* 轴被水平堆叠。`concatenate()` 函数也可以用来生成水平堆叠，设置轴参数值为 `1`：
- en: '[PRE30]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the preceding code, two arrays have been stacked horizontally using the `concatenate()`
    function.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，两个数组通过 `concatenate()` 函数被水平堆叠。
- en: '**Vertical stacking**: In vertical stacking, the same dimensional arrays are
    joined along with a vertical axis using the `vstack()` and `concatenate()` functions.
    Let''s see the following example:'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**垂直堆叠**：在垂直堆叠中，具有相同维度的数组沿垂直轴通过 `vstack()` 和 `concatenate()` 函数连接。让我们来看下面的例子：'
- en: '[PRE31]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In the preceding code, two arrays are stacked vertically along the *y* axis.
    The `concatenate()` function can also be used to generate vertical stacking with
    axis parameter value `0`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，两个数组沿 *y* 轴被垂直堆叠。`concatenate()` 函数也可以用来生成垂直堆叠，设置轴参数值为 `0`：
- en: '[PRE32]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In the preceding code, two arrays are stacked vertically using the `concatenate()`
    function.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，两个数组通过 `concatenate()` 函数被垂直堆叠。
- en: '**Depth stacking**: In depth stacking, the same dimensional arrays are joined
    along with a third axis (depth) using the `dstack()` function. Let''s see the
    following example:'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**深度堆叠**：在深度堆叠中，具有相同维度的数组沿第三个轴（深度）通过 `dstack()` 函数连接。让我们来看下面的例子：'
- en: '[PRE33]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In the preceding code, two arrays are stacked in depth along with a third axis
    (depth).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，两个数组沿着第三个轴（深度）进行堆叠。
- en: '**Column stacking**: Column stacking stacks multiple sequence one-dimensional
    arrays as columns into a single two-dimensional array. Let''s see an example of
    column stacking:'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**按列堆叠**：按列堆叠将多个一维数组按列堆叠成一个二维数组。让我们来看一个按列堆叠的例子：'
- en: '[PRE34]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In the preceding code block, we have created a one-dimensional NumPy array.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，我们创建了一个一维的 NumPy 数组。
- en: '[PRE35]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In the preceding code block, we have created another one-dimensional NumPy array.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，我们创建了另一个一维的 NumPy 数组。
- en: '[PRE36]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In the preceding code, we have created two one-dimensional arrays and stacked
    them column-wise.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了两个一维数组并按列堆叠它们。
- en: '**Row stacking**: Row stacking stacks multiple sequence one-dimensional arrays
    as rows into a single two-dimensional arrays. Let''s see an example of row stacking:'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**按行堆叠**：按行堆叠将多个一维数组按行堆叠成一个二维数组。让我们来看一个按行堆叠的例子：'
- en: '[PRE37]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In the preceding code, two one-dimensional arrays are stacked row-wise.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，两个一维数组按行堆叠。
- en: Let's now see how to partition a NumPy array into multiple sub-arrays.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下如何将一个 NumPy 数组划分为多个子数组。
- en: Partitioning NumPy arrays
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NumPy 数组的划分
- en: 'NumPy arrays can be partitioned into multiple sub-arrays. NumPy offers three
    types of split functionality: vertical, horizontal, and depth-wise. All the split
    functions by default split into the same size arrays but we can also specify the
    split location. Let''s look at each of the functions in detail:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 数组可以被划分为多个子数组。NumPy 提供了三种划分功能：垂直划分、水平划分和深度划分。所有的划分函数默认将数组划分为相同大小的子数组，但我们也可以指定划分位置。让我们详细了解每个函数：
- en: '**Horizontal splitting**: In horizontal split, the given array is divided into
    *N* equal sub-arrays along the horizontal axis using the `hsplit()` function.
    Let''s see how to split an array:'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**水平划分**：在水平划分中，给定数组沿水平方向被划分为 *N* 个相等的子数组，使用 `hsplit()` 函数。让我们看看如何划分一个数组：'
- en: '[PRE38]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In the preceding code, the `hsplit(arr, 3)` function divides the array into
    three sub-arrays. Each part is a column of the original array.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`hsplit(arr, 3)` 函数将数组划分为三个子数组。每个部分是原始数组的一列。
- en: '**Vertical splitting**: In vertical split, the given array is divided into
    *N* equal sub-arrays along the vertical axis using the `vsplit()` and `split()`
    functions. The `split` function with `axis=0` performs the same operation as the
    `vsplit()` function:'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**垂直划分**：在垂直划分中，给定数组沿垂直轴被划分为 *N* 个相等的子数组，使用 `vsplit()` 和 `split()` 函数。`split`
    函数在 `axis=0` 时执行的操作与 `vsplit()` 函数相同：'
- en: '[PRE39]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In the preceding code, the `vsplit(arr, 3)` function divides the array into
    three sub-arrays. Each part is a row of the original array. Let''s see another
    function, `split()`, which can be utilized as a vertical and horizontal split,
    in the following example:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`vsplit(arr, 3)` 函数将数组划分为三个子数组。每个部分是原始数组的一行。让我们看一下另一个可以用于垂直和水平划分的函数
    `split()`，以下是一个例子：
- en: '[PRE40]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In the preceding code, the `split(arr, 3)` function divides the array into three
    sub-arrays. Each part is a row of the original array. The split output is similar
    to the `vsplit()` function when `axis=0` and the split output is similar to the
    `hsplit()` function when `axis=1`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`split(arr, 3)` 函数将数组划分为三个子数组。每个部分是原始数组的一行。`split` 的输出在 `axis=0` 时类似于
    `vsplit()` 函数，而在 `axis=1` 时类似于 `hsplit()` 函数。
- en: Changing the data type of NumPy arrays
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更改 NumPy 数组的数据类型
- en: 'As we have seen in the preceding sections, NumPy supports multiple data types,
    such as `int`, `float`, and complex numbers. The `astype()` function converts
    the data type of the array. Let''s see an example of the `astype()` function:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，NumPy 支持多种数据类型，例如 `int`、`float` 和复数。`astype()` 函数可以将数组的数据类型转换。让我们来看一个 `astype()`
    函数的例子：
- en: '[PRE41]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In the preceding code, we have created one NumPy array and checked its data
    type using the `dtype` attribute.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了一个 NumPy 数组，并使用 `dtype` 属性检查它的数据类型。
- en: 'Let''s change the data type of an array using the `astype()` function:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 `astype()` 函数更改数组的数据类型：
- en: '[PRE42]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In the preceding code, we have changed the column data type from integer to
    float using `astype()`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用 `astype()` 将列的数据类型从整数更改为浮点数。
- en: 'The `tolist()` function converts a NumPy array into a Python list. Let''s see
    an example of the `tolist()` function:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`tolist()` 函数将 NumPy 数组转换为 Python 列表。让我们来看一个 `tolist()` 函数的例子：'
- en: '[PRE43]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In the preceding code, we have converted an array into a Python list object
    using the `tolist()` function.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用 `tolist()` 函数将数组转换为 Python 列表对象。
- en: Creating NumPy views and copies
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 NumPy 视图和副本
- en: 'Some of the Python functions return either a copy or a view of the input array.
    A Python copy stores the array in another location while a view uses the same
    memory content. This means copies are separate objects and treated as a deep copy
    in Python. Views are the original base array and are treated as a shallow copy.
    Here are some properties of copies and views:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 Python 函数返回输入数组的副本或视图。Python 的副本会将数组存储在另一个位置，而视图则使用相同的内存内容。这意味着副本是独立的对象，并在
    Python 中被视为深拷贝。视图是原始的基础数组，并被视为浅拷贝。以下是副本和视图的一些特点：
- en: Modifications in a view affect the original data whereas modifications in a
    copy do not affect the original array.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视图中的修改会影响原始数据，而副本中的修改则不会影响原始数组。
- en: Views use the concept of shared memory.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视图使用共享内存的概念。
- en: Copies require extra space compared to views.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与视图相比，副本需要额外的空间。
- en: Copies are slower than views.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 副本比视图慢。
- en: 'Let''s understand the concept of copy and view using the following example:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下示例来理解副本和视图的概念：
- en: '[PRE44]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'After creating a NumPy array, let''s perform object copy operations:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 NumPy 数组后，我们来进行对象复制操作：
- en: '[PRE45]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In the preceding example, you can see the original array and the assigned array
    have the same object ID, meaning both are pointing to the same object. Copies
    and views both have different object IDs; both will have different objects, but
    view objects will reference the same original array and a copy will have a different
    replica of the object.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，你可以看到原始数组和分配的数组具有相同的对象 ID，意味着它们指向相同的对象。副本和视图具有不同的对象 ID；两者会有不同的对象，但视图对象会引用相同的原始数组，而副本会有该对象的不同副本。
- en: 'Let''s continue with this example and update the values of the original array
    and check its impact on views and copies:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续这个示例，并更新原始数组的值，查看其对视图和副本的影响：
- en: '[PRE46]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In the preceding example, we can conclude from the results that the view is
    the original array. The values changed when we updated the original array and
    the copy is a separate object because its values remain the same.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们可以从结果得出结论：视图是原始数组。当我们更新原始数组时，值发生了变化，而副本是一个独立的对象，因为它的值保持不变。
- en: Slicing NumPy arrays
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 切片 NumPy 数组
- en: Slicing in NumPy is similar to Python lists. Indexing prefers to select a single
    value while slicing is used to select multiple values from an array.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 中的切片与 Python 列表类似。索引操作倾向于选择单一值，而切片用于从数组中选择多个值。
- en: 'NumPy arrays also support negative indexing and slicing. Here, the negative
    sign indicates the opposite direction and indexing starts from the right-hand
    side with a starting value of `-1`:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 数组也支持负索引和切片。这里，负号表示反向方向，索引从右侧开始，起始值为 `-1`：
- en: '![](img/af682864-72cd-48e8-873c-546195356d50.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![](img/af682864-72cd-48e8-873c-546195356d50.png)'
- en: 'Let''s check this out using the following code:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下代码来检查这个：
- en: '[PRE47]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'In the slice operation, we use the colon symbol to select the collection of
    values. Slicing takes three values: start, stop, and step:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在切片操作中，我们使用冒号符号来选择一组值。切片有三个值：起始、停止和步长：
- en: '[PRE48]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This can be represented as follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以表示如下：
- en: '![](img/0585afca-cac7-4b8c-8da9-a60acc19ff62.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0585afca-cac7-4b8c-8da9-a60acc19ff62.png)'
- en: 'In the preceding example, we have used `3` as the starting index and `6` as
    the stopping index:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们使用了 `3` 作为起始索引，`6` 作为停止索引：
- en: '[PRE49]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'In the preceding example, only the starting index is given. `3` is the starting
    index. This slice operation will select the values from the starting index to
    the end of the array:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，仅给出了起始索引。`3` 是起始索引。此切片操作将从起始索引开始，选择数组从该索引到数组末尾的值：
- en: '[PRE50]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'This can be represented as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以表示如下：
- en: '![](img/e19f5cd6-bb53-4eeb-8392-f0303183cd43.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e19f5cd6-bb53-4eeb-8392-f0303183cd43.png)'
- en: 'In the preceding example, the slice operation will select values from the third
    value from the right side of the array to the end of the array:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，切片操作将选择从数组右侧第三个值开始到数组末尾的值：
- en: '[PRE51]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This can be represented as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以表示如下：
- en: '![](img/61da429a-0f75-4f4a-b18a-61c8bf16dbfe.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![](img/61da429a-0f75-4f4a-b18a-61c8bf16dbfe.png)'
- en: In the preceding example, the start, stop, and step index are 2, 7, and 2, respectively.
    Here, the slice operation selects values from the second index to the sixth (one
    less than the stop value) index with an increment of 2 in the index value. So,
    the output will be 2, 4, and 6.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，起始、停止和步长索引分别为2、7和2。在这里，切片操作从第二个索引到第六个（停止值减一）索引选择值，索引值增加2。因此，输出将是2、4和6。
- en: Boolean and fancy indexing
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 布尔索引和花式索引
- en: 'Indexing techniques help us to select and filter elements from a NumPy array.
    In this section, we will focus on Boolean and fancy indexing. Boolean indexing
    uses a Boolean expression in the place of indexes (in square brackets) to filter
    the NumPy array. This indexing returns elements that have a true value for the
    Boolean expression:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 索引技术帮助我们从NumPy数组中选择和过滤元素。在本节中，我们将重点介绍布尔索引和花式索引。布尔索引在索引的地方使用布尔表达式（在方括号内）来过滤NumPy数组。此索引返回对布尔表达式为真的元素：
- en: '[PRE52]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Fancy indexing is a special type of indexing in which elements of an array
    are selected by an array of indices. This means we pass the array of indices in
    brackets. Fancy indexing also supports multi-dimensional arrays. This will help
    us to easily select and modify a complex multi-dimensional set of arrays. Let''s
    see an example as follows to understand fancy indexing:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 花式索引是一种特殊的索引类型，其中数组的元素由索引数组选择。这意味着我们在方括号中传递索引数组。花式索引还支持多维数组。这将帮助我们轻松地选择和修改复杂的多维数组集合。让我们看一个以下示例来理解花式索引：
- en: '[PRE53]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'In the preceding code, we have created a 5*4 matrix and selected the rows using
    integer indices. You can also visualize or internalize this output from the following
    diagram:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们创建了一个5*4的矩阵，并使用整数索引选择了行。您还可以从以下图表中可视化或内部化此输出：
- en: '![](img/bd8c91ee-2ea1-4af4-8120-632f0678b61d.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bd8c91ee-2ea1-4af4-8120-632f0678b61d.png)'
- en: 'We can see the code for this as follows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到其代码如下：
- en: '[PRE54]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The preceding example results in the first value, `[1,2]`, and second value,
    `[2,3]`, as the row and column index. The array will select the value at the first
    and second index values, which are 7 and 12.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例将结果作为第一个值`[1,2]`和第二个值`[2,3]`，作为行和列索引。数组将选择第一个和第二个索引值，分别为7和12。
- en: Broadcasting arrays
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 广播数组
- en: Python lists do not support direct vectorizing arithmetic operations. NumPy
    offers a faster-vectorized array operation compared to Python list loop-based
    operations. Here, all the looping operations are performed in C instead of Python,
    which makes it faster. Broadcasting functionality checks a set of rules for applying
    binary functions, such as addition, subtraction, and multiplication, on different
    shapes of an array.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: Python列表不支持直接向量化的算术操作。NumPy提供了比Python列表循环操作更快的向量化数组操作。在这里，所有的循环操作都是在C中执行而不是Python，这使得它更快。广播功能检查应用于数组不同形状的二进制函数（如加法、减法和乘法）的一组规则。
- en: 'Let''s see an example of broadcasting:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个广播的例子：
- en: '[PRE55]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'In all three preceding examples, we can see the addition of two arrays of the
    same size. This concept is known as broadcasting:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的三个示例中，我们可以看到两个大小相同数组的加法。这个概念称为广播：
- en: '[PRE56]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'In the preceding example, two matrices were multiplied. Let''s perform addition
    and multiplication with a scalar value:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，两个矩阵进行了乘法运算。让我们执行加法和乘法与标量值：
- en: '[PRE57]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: In the preceding two examples, the matrix is added and multiplied by a scalar
    value.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的两个示例中，矩阵被加和乘以一个标量值。
- en: Creating pandas DataFrames
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建pandas数据框
- en: 'The `pandas` library is designed to work with a panel or tabular data. `pandas`
    is a fast, highly efficient, and productive tool for manipulating and analyzing
    string, numeric, datetime, and time-series data. `pandas` provides data structures
    such as DataFrames and Series. A `pandas` DataFrame is a tabular, two-dimensional
    labeled and indexed data structure with a grid of rows and columns. Its columns
    are heterogeneous types. It has the capability to work with different types of
    objects, carry out grouping and joining operations, handle missing values, create
    pivot tables, and deal with dates. A `pandas` DataFrame can be created in multiple
    ways. Let''s create an empty DataFrame:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`pandas`库设计用于处理面板或表格数据。`pandas`是一个快速、高效且富有生产力的工具，用于处理和分析字符串、数字、日期时间和时间序列数据。`pandas`提供了如DataFrame和Series等数据结构。`pandas`
    DataFrame是一个二维的带标签和索引的表格数据结构，具有行和列的网格。它的列是异质类型。它能够处理不同类型的对象，进行分组和连接操作，处理缺失值，创建透视表，处理日期。可以通过多种方式创建`pandas`
    DataFrame。让我们创建一个空的DataFrame：'
- en: '[PRE58]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'In the preceding example, we have created an empty DataFrame. Let''s create
    a DataFrame using a dictionary of the list:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们创建了一个空的DataFrame。让我们使用字典列表来创建一个DataFrame：
- en: '[PRE59]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'In the preceding code, we have used a dictionary of the list to create a DataFrame.
    Here, the keys of the dictionary are equivalent to columns, and values are represented
    as a list that is equivalent to the rows of the DataFrame. Let''s create a DataFrame
    using the list of dictionaries:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用了一个字典列表来创建一个DataFrame。这里，字典的键相当于列，而值则表示为一个列表，相当于DataFrame的行。让我们使用字典列表创建一个DataFrame：
- en: '[PRE60]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'In the preceding code, the DataFrame is created using a list of dictionaries.
    In the list, each item is a dictionary. Each key is the name of the column and
    the value is the cell value for a row. Let''s create a DataFrame using a list
    of tuples:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，DataFrame是通过使用字典列表来创建的。在列表中，每个项是一个字典。每个键是列名，每个值是某一行的单元格值。让我们使用元组列表创建一个DataFrame：
- en: '[PRE61]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: In the preceding code, the DataFrame is created using a list of tuples. In the
    list, each item is a tuple and each tuple is equivalent to the row of columns.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，DataFrame是通过使用元组列表来创建的。在列表中，每个项是一个元组，每个元组相当于一行的列。
- en: Understanding pandas Series
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解pandas Series
- en: '`pandas` Series is a one-dimensional sequential data structure that is able
    to handle any type of data, such as string, numeric, datetime, Python lists, and
    dictionaries with labels and indexes. Series is one of the columns of a DataFrame.
    We can create a Series using a Python dictionary, NumPy array, and scalar value.
    We will also see the `pandas` Series features and properties in the latter part
    of the section. Let''s create some Python Series:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`pandas` Series是一个一维的顺序数据结构，能够处理任何类型的数据，如字符串、数字、日期时间、Python列表和字典，具有标签和索引。Series是DataFrame的其中一列。我们可以使用Python字典、NumPy数组和标量值来创建Series。我们还将在本节后面看到`pandas`
    Series的特性和属性。让我们创建一些Python Series：'
- en: '**Using a Python dictionary**: Create a dictionary object and pass it to the
    Series object. Let''s see the following example:'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用Python字典**：创建一个字典对象，并将其传递给Series对象。让我们看一下下面的示例：'
- en: '[PRE62]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '**Using a NumPy array**: Create a NumPy array object and pass it to the Series
    object. Let''s see the following example:'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用NumPy数组**：创建一个NumPy数组对象，并将其传递给Series对象。让我们看一下下面的示例：'
- en: '[PRE63]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '**Using a single scalar value**: To create a `pandas` Series with a scalar
    value, pass the scalar value and index list to a Series object:'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用单一标量值**：要创建一个包含标量值的`pandas` Series，可以将标量值和索引列表传递给Series对象：'
- en: '[PRE64]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Let''s explore some features of `pandas` Series:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索一下`pandas` Series的一些特性：
- en: 'We can also create a series by selecting a column, such as `country`, which
    happens to be the first column in the datafile. Then, show the type of the object
    currently in the local scope:'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们也可以通过选择一列来创建一个序列，例如`country`，它恰好是数据文件中的第一列。然后，显示当前本地作用域中的对象类型：
- en: '[PRE65]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'This results in the following output:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![](img/b78dd324-b22c-4f06-a72e-45d1a2b6763e.png)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b78dd324-b22c-4f06-a72e-45d1a2b6763e.png)'
- en: 'In the preceding code, we have read the `WHO_first9cols.csv` file using the
    `read_csv()` function. You can download this file from the following GitHub location:[https://github.com/PacktPublishing/Python-Data-Analysis-Third-Edition/tree/master/Chapter02](https://github.com/PacktPublishing/Python-Data-Analysis-Third-Edition/tree/master/Chapter02).
    In the output, you can see the top five records in the `WHO_first9cols` dataset
    using the `head()` function:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们使用`read_csv()`函数读取了`WHO_first9cols.csv`文件。您可以从以下GitHub位置下载此文件：[https://github.com/PacktPublishing/Python-Data-Analysis-Third-Edition/tree/master/Chapter02](https://github.com/PacktPublishing/Python-Data-Analysis-Third-Edition/tree/master/Chapter02)。在输出中，您可以看到使用`head()`函数查看的`WHO_first9cols`数据集中的前五条记录：
- en: '[PRE66]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The `pandas` Series data structure shares some of the common attributes of
    DataFrames and also has a `name` attribute. Explore these properties as follows:'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pandas` Series数据结构具有与DataFrame共享的一些共同属性，并且还具有一个`name`属性。按以下方式探索这些属性：'
- en: '[PRE67]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Let''s check the column list of a DataFrame:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们查看一下DataFrame的列列表：
- en: '[PRE68]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Let''s check the data types of DataFrame columns:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一下DataFrame列的数据类型：
- en: '[PRE69]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Let''s see the slicing of a `pandas` Series:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看`pandas` Series的切片操作：
- en: '[PRE70]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Now that we know how to use pandas Series, let's move on to using Quandl to
    work on databases.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何使用pandas Series，接下来让我们使用Quandl来处理数据库。
- en: Reading and querying the Quandl data
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取和查询Quandl数据
- en: In the last section, we saw `pandas` DataFrames that have a tabular structure
    similar to relational databases. They offer similar query operations on DataFrames.
    In this section, we will focus on Quandl. Quandl is a Canada-based company that
    offers commercial and alternative financial data for investment data analyst.
    Quandl understands the need for investment and financial quantitative analysts.
    It provides data using API, R, Python, or Excel.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一部分，我们看到了`pandas` DataFrame，它们具有类似关系数据库的表格结构。它们提供类似的查询操作。在本节中，我们将重点介绍Quandl。Quandl是一家总部位于加拿大的公司，提供用于投资数据分析师的商业和替代金融数据。Quandl理解投资和金融定量分析师的需求。它通过API、R、Python或Excel提供数据。
- en: In this section, we will retrieve the Sunspot dataset from Quandl. We can use
    either an API or download the data manually in CSV format.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将从Quandl中检索Sunspot数据集。我们可以使用API或手动下载CSV格式的数据。
- en: 'Let''s first install the Quandl package using `pip`:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用`pip`安装Quandl包：
- en: '[PRE71]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: If you want to install the API, you can do so by downloading installers from
    [https://pypi.python.org/pypi/Quandl](https://pypi.python.org/pypi/Quandl) or
    by running the preceding command.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想安装API，可以通过从[https://pypi.python.org/pypi/Quandl](https://pypi.python.org/pypi/Quandl)下载安装包，或通过运行上述命令来安装。
- en: Using the API is free, but is limited to 50 API calls per day. If you require
    more API calls, you will have to request an authentication key. The code in this
    tutorial does not use a key. It should be simple to change the code to either
    use a key or read a downloaded CSV file. If you have difficulties, refer to the
    *Where to find help and references* section in [Chapter 1,](https://docs.google.com/document/d/1BDrtOc3RwvX2ZzT42tRXvfrzPQ8EMJRy/edit#bookmark=id.4d34og8)
    *Getting Started with Python Libraries*, or search through the Python docs at
    [https://docs.python.org/2/](https://docs.python.org/2/).
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 使用该API是免费的，但每天限50次API调用。如果需要更多的API调用，您需要请求一个认证密钥。本教程中的代码没有使用密钥。应该很容易修改代码以使用密钥或读取已下载的CSV文件。如果遇到困难，请参考[第1章](https://docs.google.com/document/d/1BDrtOc3RwvX2ZzT42tRXvfrzPQ8EMJRy/edit#bookmark=id.4d34og8)中的*如何获取帮助和参考资料*部分，或浏览Python文档：[https://docs.python.org/2/](https://docs.python.org/2/)。
- en: 'Let''s take a look at how to query data in a `pandas` DataFrame:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在`pandas` DataFrame中查询数据：
- en: 'As a first step, we obviously have to download the data. After importing the
    Quandl API, get the data as follows:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步，显然我们需要下载数据。在导入Quandl API后，按照以下方式获取数据：
- en: '[PRE72]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The `head()` and `tail()` methods have a purpose similar to that of the Unix
    commands with the same name. Select the first *n* and last *n* records of a DataFrame,
    where *n* is an integer parameter:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`head()`和`tail()`方法的功能类似于Unix中具有相同名称的命令。选择DataFrame的前*n*和后*n*条记录，其中*n*是一个整数参数：'
- en: '[PRE73]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'This results in the following output:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![](img/d47b5e81-6d11-4ced-af56-0a425dca7c88.png)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d47b5e81-6d11-4ced-af56-0a425dca7c88.png)'
- en: 'Let''s check out the `tail` function as follows:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照如下方式查看`tail`函数：
- en: '[PRE74]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'This results in the following output:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![](img/5b1a1be7-57e0-4856-bd8e-8f040083cd8e.png)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5b1a1be7-57e0-4856-bd8e-8f040083cd8e.png)'
- en: The `head()` and `tail()` methods give us the first and last five rows of the
    Sunspot data, respectively.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '`head()` 和 `tail()` 方法分别返回 Sunspot 数据的前五行和最后五行。'
- en: '**Filtering columns**: `pandas` offers the ability to select columns. Let''s
    select columns in a `pandas` DataFrame:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**筛选列**：`pandas` 提供了选择列的功能。我们来选择 `pandas` DataFrame 中的列：'
- en: '[PRE75]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'This results in the following output:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![](img/a6c945a1-760f-42ba-a419-b90580d3f646.png)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a6c945a1-760f-42ba-a419-b90580d3f646.png)'
- en: '**Filtering rows**: `pandas` offers the ability to select rows. Let''s select
    rows in a `pandas` DataFrame:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**筛选行**：`pandas` 提供了选择行的功能。我们来选择 `pandas` DataFrame 中的行：'
- en: '[PRE76]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'This results in the following output:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![](img/b792113a-06be-4e84-8328-41459c913d76.png)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b792113a-06be-4e84-8328-41459c913d76.png)'
- en: '**Boolean filtering**: We can query data using Boolean conditions similar to
    the `WHERE` clause condition of SQL. Let''s filter the data greater than the arithmetic
    mean:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**布尔过滤**：我们可以使用类似于 SQL 中 `WHERE` 子句的布尔条件查询数据。我们来筛选出大于算术平均值的数据：'
- en: '[PRE77]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'This results in the following output:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![](img/df23803c-0e5b-40e3-b509-9bbcef800199.png)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
  zh: '![](img/df23803c-0e5b-40e3-b509-9bbcef800199.png)'
- en: Describing pandas DataFrames
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 描述 `pandas` DataFrame
- en: 'The `pandas` DataFrame has a dozen statistical methods. The following table
    lists these methods, along with a short description of each:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '`pandas` DataFrame 具有十几种统计方法。下表列出了这些方法，并简要描述了每种方法：'
- en: '| **Method** | **Description** |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **描述** |'
- en: '| `describes` | This method returns a small table with descriptive statistics.
    |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
  zh: '| `describes` | 此方法返回一个包含描述性统计信息的小表格。 |'
- en: '| `count` | This method returns the number of non-NaN items. |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
  zh: '| `count` | 此方法返回非 NaN 项的数量。 |'
- en: '| `mad` | This method calculates the mean absolute deviation, which is a robust
    measure similar to standard deviation. |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
  zh: '| `mad` | 此方法计算均值绝对偏差，这是类似于标准差的稳健度量。 |'
- en: '| `median` | This method returns the median. This is equivalent to the value
    at the 50^(th) percentile. |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
  zh: '| `median` | 此方法返回中位数。它等于第 50^(th) 百分位数的值。 |'
- en: '| `min` | This method returns the minimum value. |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
  zh: '| `min` | 此方法返回最小值。 |'
- en: '| `max` | This method returns the maximum value. |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
  zh: '| `max` | 此方法返回最大值。 |'
- en: '| `mode` | This method returns the mode, which is the most frequently occurring
    value. |'
  id: totrans-322
  prefs: []
  type: TYPE_TB
  zh: '| `mode` | 此方法返回众数，即最频繁出现的值。 |'
- en: '| `std` | This method returns the standard deviation, which measures dispersion.
    It is the square root of the variance. |'
  id: totrans-323
  prefs: []
  type: TYPE_TB
  zh: '| `std` | 此方法返回标准差，用于衡量数据的离散程度。它是方差的平方根。 |'
- en: '| `var` | This method returns the variance. |'
  id: totrans-324
  prefs: []
  type: TYPE_TB
  zh: '| `var` | 此方法返回方差。 |'
- en: '| `skew` | This method returns skewness. Skewness is indicative of the distribution
    symmetry. |'
  id: totrans-325
  prefs: []
  type: TYPE_TB
  zh: '| `skew` | 此方法返回偏度。偏度表示分布的对称性。 |'
- en: '| `kurt` | This method returns kurtosis. Kurtosis is indicative of the distribution
    shape. |'
  id: totrans-326
  prefs: []
  type: TYPE_TB
  zh: '| `kurt` | 此方法返回峰度。峰度表示分布的形状。 |'
- en: 'Using the same data used in the previous section, we will demonstrate these
    statistical methods:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上一节相同的数据，我们将展示这些统计方法：
- en: '[PRE78]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'This results in the following output:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![](img/6340853c-6e5b-4b2c-a4f2-17e208467c60.png)'
  id: totrans-330
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6340853c-6e5b-4b2c-a4f2-17e208467c60.png)'
- en: 'The `describe()` method will show most of the descriptive statistical measures
    for all columns:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '`describe()` 方法将展示所有列的绝大多数描述性统计量：'
- en: '[PRE79]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'This results in the following output:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![](img/a142316e-f8c3-4cce-8bcf-90d92c61b54f.png)'
  id: totrans-334
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a142316e-f8c3-4cce-8bcf-90d92c61b54f.png)'
- en: 'The `count()` method counts the number of observations in each column. It helps
    us to check the missing values in the dataset. Except for the initial three columns,
    all the columns have missing values. Similarly, you can compute the median, standard
    deviation, mean absolute deviation, variance, skewness, and kurtosis:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '`count()` 方法计算每一列中的观察值数量。它帮助我们检查数据集中的缺失值。除了最初的三列，其他列都有缺失值。类似地，你可以计算中位数、标准差、均值绝对偏差、方差、偏度和峰度：'
- en: '[PRE80]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'This results in the following output:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![](img/9b49ad6b-b2be-4ce5-8033-08fb2a7fb89d.png)'
  id: totrans-338
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9b49ad6b-b2be-4ce5-8033-08fb2a7fb89d.png)'
- en: 'We can compute deviation for all columns as follows:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按如下方式计算所有列的偏差：
- en: '[PRE81]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'This results in the following output:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![](img/61c3c45e-8bbe-4ea8-bf58-dc2a2149dc4e.png)'
  id: totrans-342
  prefs: []
  type: TYPE_IMG
  zh: '![](img/61c3c45e-8bbe-4ea8-bf58-dc2a2149dc4e.png)'
- en: The preceding code example is computing the standard deviation for each numeric
    column.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码示例正在计算每个数字列的标准差。
- en: Grouping and joining pandas DataFrame
  id: totrans-344
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对 `pandas` DataFrame 的分组与连接
- en: 'Grouping is a kind of data aggregation operation. The grouping term is taken
    from a relational database. Relational database software uses the `group by` keyword
    to group similar kinds of values in a column. We can apply aggregate functions
    on groups such as mean, min, max, count, and sum. The `pandas` DataFrame also
    offers similar kinds of capabilities. Grouping operations are based on the split-apply-combine
    strategy. It first divides data into groups and applies the aggregate operation,
    such as mean, min, max, count, and sum, on each group and combines results from
    each group:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 分组是数据聚合操作的一种。分组术语来源于关系型数据库。关系型数据库软件使用 `group by` 关键字将列中相似的值进行分组。我们可以对分组应用聚合函数，例如均值、最小值、最大值、计数和求和。`pandas`
    DataFrame 也提供了类似的功能。分组操作基于拆分-应用-合并策略。它首先将数据分成组，并对每个组应用聚合操作，如均值、最小值、最大值、计数和求和，然后将每个组的结果合并：
- en: '[PRE82]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'This results in the following output:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![](img/6c0e1cad-5051-4922-bdfc-4ae1665d7423.png)'
  id: totrans-348
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6c0e1cad-5051-4922-bdfc-4ae1665d7423.png)'
- en: 'Let''s now group the DataFrames based on literacy rates as well:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们根据文盲率对 DataFrame 进行分组：
- en: '[PRE83]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'This results in the following output:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![](img/68a9df18-74b9-420f-9c09-79831ab1fd81.png)'
  id: totrans-352
  prefs: []
  type: TYPE_IMG
  zh: '![](img/68a9df18-74b9-420f-9c09-79831ab1fd81.png)'
- en: In the preceding example, the continent-wise average adult literacy rate in
    percentage was computed. You can also group based on multiple columns by passing
    a list of columns to the `groupby()` function.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们计算了按大洲划分的成人文盲率百分比。你也可以通过将多个列的列表传递给 `groupby()` 函数来进行多列分组。
- en: Join is a kind of merge operation for tabular databases. The join concept is
    taken from the relational database. In relational databases, tables were normalized
    or broken down to reduce redundancy and inconsistency, and join is used to select
    the information from multiple tables. A data analyst needs to combine data from
    multiple sources. `pandas` also offers to join functionality to join multiple
    DataFrames using the `merge()` function.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 连接是一种用于表格数据库的合并操作。连接概念源自关系型数据库。在关系型数据库中，表被规范化或拆分以减少冗余和不一致性，连接用于从多个表中选择信息。数据分析师需要将来自多个来源的数据进行合并。`pandas`
    也提供了通过 `merge()` 函数连接多个 DataFrame 的功能。
- en: 'To understand joining, we will take a taxi company use case. We are using two
    files: `dest.csv` and `tips.csv`. Every time a driver drops any passenger at their
    destination, we will insert a record (employee number and destination) into the
    `dest.csv` file. Whenever drivers get a tip, we insert the record (employee number
    and tip amount) into the `tips.csv` file. You can download both the files from
    the following GitHub link: [https://github.com/PacktPublishing/Python-Data-Analysis-Third-Edition/tree/master/Python-Data-Analysis-Third-Edition/Ch2](https://github.com/PacktPublishing/Python-Data-Analysis-Third-Edition/tree/master/Python-Data-Analysis-Third-Edition/Ch2):'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解连接操作，我们将以一个出租车公司为例。我们使用两个文件：`dest.csv` 和 `tips.csv`。每当司机将乘客送到目的地时，我们会将一条记录（员工编号和目的地）插入
    `dest.csv` 文件中。每当司机获得小费时，我们会将记录（员工编号和小费金额）插入 `tips.csv` 文件中。你可以从以下 GitHub 链接下载这两个文件：[https://github.com/PacktPublishing/Python-Data-Analysis-Third-Edition/tree/master/Python-Data-Analysis-Third-Edition/Ch2](https://github.com/PacktPublishing/Python-Data-Analysis-Third-Edition/tree/master/Python-Data-Analysis-Third-Edition/Ch2)：
- en: '[PRE84]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'This results in the following output:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![](img/9eb01529-0df4-4aa2-9cf5-33c04e76e460.png)'
  id: totrans-358
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9eb01529-0df4-4aa2-9cf5-33c04e76e460.png)'
- en: 'In the preceding code block, we have read the `dest.csv` file using the `read_csv()`
    method:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，我们使用 `read_csv()` 方法读取了 `dest.csv` 文件：
- en: '[PRE85]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'This results in the following output:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![](img/45f599b5-2a83-4787-975e-b5fed56e3225.png)'
  id: totrans-362
  prefs: []
  type: TYPE_IMG
  zh: '![](img/45f599b5-2a83-4787-975e-b5fed56e3225.png)'
- en: 'In the preceding code block, we have read the `tips.csv` file using the `read_csv()`
    method. We will now check out the various types of joins as follows:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，我们使用 `read_csv()` 方法读取了 `tips.csv` 文件。接下来，我们将查看不同类型的连接操作：
- en: '**Inner join**: Inner join is equivalent to the intersection operation of a
    set. It will select only common records in both the DataFrames. To perform inner
    join, use the `merge()` function with both the DataFrames and common attribute
    on the parameter and inner value to show the parameter. The `on` parameter is
    used to provide the common attribute based on the join will be performed and `how`
    defines the type of join:'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内连接**：内连接相当于集合的交集操作。它只会选择两个 DataFrame 中的共同记录。要执行内连接，使用 `merge()` 函数，指定两个
    DataFrame 和公共属性作为参数，并设置 `how` 为 "inner" 来展示参数。`on` 参数用于提供连接所依据的公共属性，`how` 定义连接类型：'
- en: '[PRE86]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'This results in the following output:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 这会产生以下输出：
- en: '![](img/562d1827-9400-4c6b-baff-47754275b7a0.png)'
  id: totrans-367
  prefs: []
  type: TYPE_IMG
  zh: '![](img/562d1827-9400-4c6b-baff-47754275b7a0.png)'
- en: '**Full outer join**: Outer join is equivalent to a union operation of the set.
    It merges the right and left DataFrames. It will have all the records from both
    DataFrames and fills NaNs where the match will not be found:'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**全外连接**：外连接相当于集合的并操作。它将合并左右两个 DataFrame。它会包含两个 DataFrame 中的所有记录，并在没有匹配的地方填充
    NaN：'
- en: '[PRE87]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'This results in the following output:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 这会产生以下输出：
- en: '![](img/eebc7b2f-18f9-451f-a5e9-c2f60cd2f97f.png)'
  id: totrans-371
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eebc7b2f-18f9-451f-a5e9-c2f60cd2f97f.png)'
- en: '**Right outer join**: In the right outer join, all the records from the right
    side of the DataFrame will be selected. If the matched records cannot be found
    in the left DataFrame, then it is filled with NaNs:'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**右外连接**：在右外连接中，所有来自 DataFrame 右侧的记录都会被选中。如果在左侧 DataFrame 中找不到匹配的记录，则用 NaN
    填充：'
- en: '[PRE88]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'This results in the following output:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 这会产生以下输出：
- en: '![](img/5f2768a8-e08f-4f2e-9412-e758579c511e.png)'
  id: totrans-375
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5f2768a8-e08f-4f2e-9412-e758579c511e.png)'
- en: '**Left outer join**: In the left outer join, all the records from the left
    side of the DataFrame will be selected. If the matched records cannot be found
    in the right DataFrame, then it is filled with NaNs:'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**左外连接**：在左外连接中，所有来自 DataFrame 左侧的记录都会被选中。如果在右侧 DataFrame 中找不到匹配的记录，则用 NaN
    填充：'
- en: '[PRE89]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'This results in the following output:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 这会产生以下输出：
- en: '![](img/ae22b284-1120-404b-8c6d-6fa6253106f0.png)'
  id: totrans-379
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ae22b284-1120-404b-8c6d-6fa6253106f0.png)'
- en: We will now move on to checking out missing values in the datasets.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将继续检查数据集中的缺失值。
- en: Working with missing values
  id: totrans-381
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理缺失值
- en: 'Most real-world datasets are messy and noisy. Due to their messiness and noise,
    lots of values are either faulty or missing. `pandas` offers lots of built-in
    functions to deal with missing values in DataFrames:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数现实世界中的数据集都是杂乱无章且充满噪声的。由于其杂乱和噪声，许多值要么是错误的，要么是缺失的。`pandas` 提供了许多内置函数来处理 DataFrame
    中的缺失值：
- en: '**Check missing values in a DataFrame**: `pandas`'' `isnull()` function checks
    for the existence of null values and returns `True` or `False`, where `True` is
    for null and `False` is for not-null values. The `sum()` function will sum all
    the `True` values and returns the count of missing values. We have tried two ways
    to count the missing values; both show the same output:'
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**检查 DataFrame 中的缺失值**：`pandas` 的 `isnull()` 函数检查是否存在空值，并返回 `True` 或 `False`，其中
    `True` 表示空值，`False` 表示非空值。`sum()` 函数会将所有 `True` 值相加，返回缺失值的数量。我们尝试了两种方法来计算缺失值，两者显示的输出相同：'
- en: '[PRE90]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'The following is the second method:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是第二种方法：
- en: '[PRE91]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'This results in the following output:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 这会产生以下输出：
- en: '![](img/3d8d5ea8-250d-4c28-94d2-417bd627526b.png)'
  id: totrans-388
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3d8d5ea8-250d-4c28-94d2-417bd627526b.png)'
- en: '**Drop missing values**: A very naive approach to deal with missing values
    is to drop them for analysis purposes. `pandas` has the `dropna()` function to
    drop or delete such observations from the DataFrame. Here, the `inplace=True`
    attribute makes the changes in the original DataFrame:'
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**删除缺失值**：一种非常简单的处理缺失值的方法是删除它们以便进行分析。`pandas` 提供了 `dropna()` 函数来删除 DataFrame
    中的这些观察值。在这里，`inplace=True` 属性会在原始 DataFrame 中进行更改：'
- en: '[PRE92]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'This results in the following output:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 这会产生以下输出：
- en: '![](img/521ce6a9-094e-418a-98ba-3ec10d0c0d51.png)'
  id: totrans-392
  prefs: []
  type: TYPE_IMG
  zh: '![](img/521ce6a9-094e-418a-98ba-3ec10d0c0d51.png)'
- en: Here, the number of observations is reduced to 118 from 202.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，观察值的数量从 202 减少到 118。
- en: '**Fill the missing values**: Another approach is to fill the missing values
    with zero, mean, median, or constant values:'
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**填充缺失值**：另一种方法是用零、均值、中位数或常数值填充缺失值：'
- en: '[PRE93]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'This results in the following output:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 这会产生以下输出：
- en: '![](img/f523082f-2d4c-4beb-b9a3-ca4ce9b9439e.png)'
  id: totrans-397
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f523082f-2d4c-4beb-b9a3-ca4ce9b9439e.png)'
- en: Here, we have filled the missing values with 0\. This is all about handling
    missing values.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们用 0 填充了缺失值。这就是处理缺失值的全部内容。
- en: In the next section, we will focus on pivot tables.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将重点讨论数据透视表。
- en: Creating pivot tables
  id: totrans-400
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建数据透视表
- en: 'A pivot table is a summary table. It is the most popular concept in Excel.
    Most data analysts use it as a handy tool to summarize theire results. `pandas`
    offers the `pivot_table()` function to summarize DataFrames. A DataFrame is summarized
    using an aggregate function, such as mean, min, max, or sum. You can download
    the dataset from the following GitHub link: [https://github.com/PacktPublishing/Python-Data-Analysis-Third-Edition/tree/master/Python-Data-Analysis-Third-Edition/Ch2](https://github.com/PacktPublishing/Python-Data-Analysis-Third-Edition/tree/master/Python-Data-Analysis-Third-Edition/Ch2):'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 数据透视表是一个汇总表格，它是 Excel 中最流行的概念。大多数数据分析师将其作为一个方便的工具来总结他们的结果。`pandas` 提供了 `pivot_table()`
    函数来汇总 DataFrame。DataFrame 使用聚合函数进行汇总，例如均值、最小值、最大值或总和。你可以从以下 GitHub 链接下载数据集：[https://github.com/PacktPublishing/Python-Data-Analysis-Third-Edition/tree/master/Python-Data-Analysis-Third-Edition/Ch2](https://github.com/PacktPublishing/Python-Data-Analysis-Third-Edition/tree/master/Python-Data-Analysis-Third-Edition/Ch2)：
- en: '[PRE94]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'This results in the following output:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![](img/f93bf27f-dff2-4d72-aa5e-acd1de1de70e.png)'
  id: totrans-404
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f93bf27f-dff2-4d72-aa5e-acd1de1de70e.png)'
- en: In the preceding code block, we have read the `purchase.csv` file using the
    `read_csv()` method.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，我们使用 `read_csv()` 方法读取了 `purchase.csv` 文件。
- en: 'Now, we will summarize the dataframe using the following code:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用以下代码汇总 DataFrame：
- en: '[PRE95]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'This results in the following output:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![](img/3c2e812a-3151-48a1-b588-d13de92bfd17.png)'
  id: totrans-409
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3c2e812a-3151-48a1-b588-d13de92bfd17.png)'
- en: In the preceding example, the `purchase` DataFrame is summarized. Here, `index`
    is the `Weather` column, `columns` is the `Food` column, and `values` is the aggregated
    sum of the `Number` column. `aggfun` is initialized with the `np.sum` parameter.
    It's time to learn how to deal with dates in `pandas` DataFrames.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`purchase` DataFrame 被汇总。这里，`index` 是 `Weather` 列，`columns` 是 `Food`
    列，`values` 是 `Number` 列的聚合总和。`aggfun` 被初始化为 `np.sum` 参数。现在是时候学习如何在 `pandas` DataFrame
    中处理日期了。
- en: Dealing with dates
  id: totrans-411
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理日期
- en: Dealing with dates is messy and complicated. You can recall the Y2K bug, the
    upcoming 2038 problem, and time zones dealing with different problems. In time-series
    datasets, we come across dates. `pandas` offers date ranges, resamples time-series
    data, and performs date arithmetic operations.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 处理日期是繁琐而复杂的。你可以回想起 Y2K 问题、即将到来的 2038 问题以及时区处理的不同问题。在时间序列数据集中，我们会遇到日期。`pandas`
    提供了日期范围，重新采样时间序列数据，并执行日期算术操作。
- en: 'Create a range of dates starting from January 1, 2020, lasting for 45 days,
    as follows:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个从 2020 年 1 月 1 日开始的日期范围，持续 45 天，如下所示：
- en: '[PRE96]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: January has less than 45 days, so the end date falls in February, as you can
    check for yourself.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 1 月份的天数少于 45 天，因此结束日期落在了 2 月份，你可以自己检查。
- en: '`date_range()` freq parameters can take values such as `B` for business day
    frequency, `W` for weekly frequency, `H` for hourly frequency, `M` for minute
    frequency, `S` for second frequency, `L` for millisecond frequency, and `U` for
    microsecond frequency. For more details, you can refer to the official documentation
    at [https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html](https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html).'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '`date_range()` 的 freq 参数可以取值，例如 `B` 表示工作日频率，`W` 表示每周频率，`H` 表示每小时频率，`M` 表示每分钟频率，`S`
    表示每秒频率，`L` 表示每毫秒频率，`U` 表示每微秒频率。更多详情，请参考官方文档：[https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html](https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html)。'
- en: '**pandas date range:** The `date_range()` function generates sequences of date
    and time with a fixed-frequency interval:'
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**pandas 日期范围：** `date_range()` 函数生成具有固定频率间隔的日期和时间序列：'
- en: '[PRE97]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'This results in the following output:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![](img/e4093374-fb5b-482d-b37c-3ce27d243884.png)'
  id: totrans-420
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e4093374-fb5b-482d-b37c-3ce27d243884.png)'
- en: '`to_datetime()`: `to_datetime()` converts a timestamp string into datetime:'
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`to_datetime()`：`to_datetime()` 将时间戳字符串转换为 datetime：'
- en: '[PRE98]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'We can convert a timestamp string into a datetime object in the specified format:'
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以将时间戳字符串转换为指定格式的 datetime 对象：
- en: '[PRE99]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '**Handling an unknown format string**: Unknown input format can cause value
    errors. We can handle this by using an errors parameter with `coerce`. `coerce`
    will set invalid strings to NaT:'
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**处理未知格式字符串：** 未知的输入格式可能会导致值错误。我们可以通过使用带有 `coerce` 的 `errors` 参数来处理这种情况。`coerce`
    将无效的字符串设置为 NaT：'
- en: '[PRE100]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: In the preceding example, the second date is still not valid and cannot be converted
    into a datetime object. The errors parameter helped us to handle such errors by
    inputting the value `NaT` (not a time).
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，第二个日期仍然无效，无法转换为 datetime 对象。`errors` 参数帮助我们通过输入值 `NaT`（不是时间）来处理此类错误。
- en: Summary
  id: totrans-428
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have explored the NumPy and pandas libraries. Both libraries
    help deal with arrays and DataFrames. NumPy arrays have the capability to deal
    with n-dimensional arrays. We have learned about various array properties and
    operations. Our main focus is on data types, data type as an object, reshaping,
    stacking, splitting, slicing, and indexing.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了NumPy和pandas库。这两个库都用于处理数组和DataFrame。NumPy数组能够处理n维数组。我们学习了各种数组属性和操作。我们的主要关注点是数据类型、数据类型作为对象、重塑、堆叠、拆分、切片和索引。
- en: We also focused on the `pandas` library for Python data analysis. We saw how
    `pandas` mimics the relational database table functionality. It offers functionality
    to query, aggregate, manipulate, and join data efficiently.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还专注于用于Python数据分析的`pandas`库。我们看到了`pandas`如何模拟关系数据库表的功能。它提供了查询、聚合、操作和高效连接数据的功能。
- en: NumPy and `pandas` work well together as a tool and make it possible to perform
    basic data analysis. At this point, you might be tempted to think that `pandas`
    is all we need for data analysis. However, there is more to data analysis than
    meets the eye.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy和`pandas`作为工具协同工作，使得执行基本的数据分析成为可能。此时，您可能会认为`pandas`是我们进行数据分析所需的一切。然而，数据分析远不止于此。
- en: Having picked up the fundamentals, it's time to proceed to data analysis with
    the commonly used statistics functions in [Chapter 3](dec623f2-210e-4cb0-900b-7eb039a4fb91.xhtml),
    *Statistics*. This includes the usage of statistical concepts.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 在掌握了基础知识后，是时候进入使用[第3章](dec623f2-210e-4cb0-900b-7eb039a4fb91.xhtml)中常用统计函数进行数据分析的环节，*统计学*。这包括了统计概念的应用。
- en: You are encouraged to read the books mentioned in the *References* section for
    exploring NumPy and `pandas` in further detail and depth.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 鼓励您阅读*参考文献*部分中提到的书籍，深入探索NumPy和`pandas`。
- en: References
  id: totrans-434
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考文献
- en: Ivan Idris, *NumPy Cookbook – Second Edition*, Packt Publishing, 2015.
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ivan Idris, *NumPy Cookbook – 第二版*，Packt Publishing，2015年。
- en: Ivan Idris, *Learning NumPy Array*, Packt Publishing, 2014.
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ivan Idris, *学习NumPy数组*，Packt Publishing，2014年。
- en: 'Ivan Idris, *NumPy: Beginner''s Guide* *– Third Edition*, Packt Publishing,
    2015.'
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ivan Idris, *NumPy：初学者指南* *– 第三版*，Packt Publishing，2015年。
- en: L. (L.-H.) Chin and T. Dutta, *NumPy Essentials*, Packt Publishing, 2016.
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: L. (L.-H.) Chin 和 T. Dutta，*NumPy基础*，Packt Publishing，2016年。
- en: T. Petrou, *Pandas Cookbook*, Packt Publishing, 2017.
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: T. Petrou, *pandas Cookbook*，Packt Publishing，2017年。
- en: F. Anthony, *Mastering pandas*, Packt Publishing, 2015.
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: F. Anthony, *精通pandas*，Packt Publishing，2015年。
- en: M. Heydt, *Mastering pandas for Finance*, Packt Publishing, 2015.
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: M. Heydt, *金融领域的pandas精通*，Packt Publishing，2015年。
- en: T. Hauck, *Data-Intensive Apps with pandas How-to*, Packt Publishing, 2013.
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: T. Hauck, *使用pandas进行数据密集型应用的操作指南*，Packt Publishing，2013年。
- en: M. Heydt, *Learning pandas*, Packt Publishing, 2015.
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: M. Heydt, *学习pandas*，Packt Publishing，2015年。
