- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Graph Algorithms
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图算法
- en: Graphs offer a distinct way to represent data structures, especially when compared
    to structured or tabular data. While structured data, such as databases, excel
    at storing and querying static, uniform information, graphs shine in capturing
    intricate relationships and patterns that exist among entities. Think of Facebook,
    where every user is a node, and each friendship or interaction becomes a connecting
    edge; this web of connections can be best represented and analyzed using graph
    structures.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 图提供了一种独特的数据结构表示方式，尤其与结构化或表格数据相比。虽然结构化数据（如数据库）擅长存储和查询静态、统一的信息，但图在捕捉存在于实体之间的复杂关系和模式方面表现出色。以Facebook为例，每个用户都是一个节点，每个友谊或互动就是一个连接的边；这种连接的网络最好通过图结构来表示和分析。
- en: In the computational realm, certain problems, often those involving relationships
    and connections, are more naturally addressed using graph algorithms. At their
    core, these algorithms aim to understand the structure of the graph. This understanding
    involves figuring out how data points (or nodes) connect via links (or edges)
    and how to effectively navigate these connections to retrieve or analyze the desired
    data.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算领域，某些问题，尤其是涉及关系和连接的问题，更自然地通过图算法来解决。这些算法的核心目标是理解图的结构。理解这一结构意味着要弄清楚数据点（或节点）是如何通过连接（或边）相互关联的，以及如何有效地导航这些连接以提取或分析所需的数据。
- en: 'In this chapter, we’ll embark on a journey through the following territories:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将踏上以下领域的探索之旅：
- en: '**Graph representations**: Various ways to capture graphs.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图表示**：捕捉图的各种方式。'
- en: '**Network theory analysis**: The foundational theory behind network structures.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络理论分析**：网络结构背后的基础理论。'
- en: '**Graph traversals**: Techniques to efficiently navigate through a graph.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图遍历**：有效遍历图的技巧。'
- en: '**Case study**: Delving into fraud analytics using graph algorithms.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**案例研究**：通过图算法深入分析欺诈行为。'
- en: '**Neighborhood techniques**: Methods to ascertain and analyze localized regions
    within larger graphs.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**邻域技术**：确定和分析大型图中局部区域的方法。'
- en: Upon completion, we will have a robust grasp of graphs as data structures. We
    should be able to formulate complex relationships—both direct and indirect—and
    will be equipped to tackle complex, real-world problems using graph algorithms.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章后，我们将对图作为数据结构有一个坚实的理解。我们应当能够构建复杂的关系—无论是直接的还是间接的—并将能够使用图算法解决复杂的现实问题。
- en: 'Understanding graphs: a brief introduction'
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解图：简要介绍
- en: In the vast interconnected landscapes of modern data, beyond the confines of
    tabular models, graph structures emerge as powerful tools to encapsulate intricate
    relationships. Their rise isn’t merely a trend but a response to challenges posed
    by the digital world’s interwoven fabric. Historical strides in graph theory,
    like Leonhard Euler’s pioneering solution to the Seven Bridges of Königsberg problem,
    laid the foundation for understanding complex relationships. Euler’s method of
    translating real-world issues into graphical representations revolutionized how
    we perceive and navigate graphs.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代数据的广阔互联景观中，超越表格模型的局限，图结构作为强大的工具，能够 encapsulate（封装）复杂的关系。它们的崛起不仅仅是一个趋势，而是对数字世界错综复杂的结构所带来的挑战的回应。图论中的历史性进展，例如莱昂哈德·欧拉（Leonhard
    Euler）对柯尼斯堡七桥问题的开创性解决方案，为理解复杂关系奠定了基础。欧拉将现实世界问题转化为图形表示的方法，彻底改变了我们看待和操作图的方式。
- en: 'Graphs: the backbone of modern data networks'
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图：现代数据网络的支柱
- en: Graphs not only provide the backbone for platforms such as social media networks
    and recommendation engines but also serve as the key to unlocking patterns in
    seemingly unrelated sectors, like road networks, electrical circuits, organic
    molecules, ecosystems, and even the flow of logic in computer programs. What’s
    pivotal to graphs is their intrinsic capability to express both tangible and intangible
    interactions.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图不仅为社交媒体网络和推荐引擎等平台提供了支撑，还作为打开看似无关领域中模式的钥匙，例如道路网络、电路、分子、生态系统，甚至计算机程序中的逻辑流。图的关键在于它们内在的能力，能够表达有形和无形的互动。
- en: But why is this structure, with its nodes and edges, so central to modern computing?
    The answer lies in graph algorithms. Tailored for understanding and interpreting
    relationships, these mathematical algorithms are precisely designed to process
    connections. They establish clear steps to decode a graph, revealing both its
    overarching characteristics and intricate details.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么这种由节点和边组成的结构在现代计算中如此重要呢？答案就在于图算法。专门为理解和解析关系而设计的这些数学算法，精确地处理连接。它们通过明确的步骤解码图结构，揭示出图的总体特征以及复杂的细节。
- en: Before delving into representations of graphs, it’s crucial to establish a foundational
    understanding of the mechanics behind them. Graphs, rooted in the rich soil of
    mathematics and computer science, offer an illustrative method to depict relationships
    among entities.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入探讨图的表示方式之前，首先要建立对其背后机制的基础理解。图结构，根植于数学和计算机科学的丰富土壤，为描绘实体之间关系提供了一种形象的方法。
- en: Real-world applications
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 现实世界的应用
- en: 'The increasingly intricate patterns and connections observed in modern data
    find clarity in graph theory. Beyond the simple nodes and edges lie the solutions
    to some of the world’s most complex problems. When the mathematical precision
    of graph algorithms meets real-world challenges, the outcomes can be astonishingly
    transformative:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现代数据中日益复杂的模式和连接，在图论中找到了清晰的解释。简单的节点和边背后，蕴藏着解决世界上一些最复杂问题的答案。当图算法的数学精确性遇到现实世界的挑战时，其结果往往会带来令人惊讶的变革性影响。
- en: '**Fraud detection**: In the world of digital finance, fraudulent transactions
    can be deeply interconnected, often weaving a subtle web meant to deceive conventional
    detection systems. Graph theory is deployed to spot these patterns. For instance,
    a sudden spike in interconnected small transactions from a singular source to
    multiple accounts might be a hint at money laundering.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**欺诈检测**：在数字金融世界中，欺诈交易往往彼此紧密相连，构成一张微妙的网络，旨在欺骗传统的检测系统。图论被用来识别这些模式。例如，从单一来源到多个账户的相互连接的小额交易突然激增，可能是洗钱的迹象。'
- en: By charting out these transactions on a graph, analysts can identify unusual
    patterns, isolate suspicious nodes, and trace the origin of potential fraud, ensuring
    that digital economies remain secure.
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过将这些交易绘制成图，分析人员可以识别出异常模式，隔离可疑节点，并追溯潜在欺诈的来源，从而确保数字经济的安全。
- en: '**Air traffic control**: The skies are bustling with movement. Every aircraft
    must navigate a maze of routes while ensuring safe distances from others. Graph
    algorithms map the skies, treating each aircraft as a node and their flight paths
    as edges. The 2010 US air travel congestion events are a testament to the power
    of graph analytics. Scientists used graph theory to decipher systemic cascading
    delays, offering insights to optimize flight schedules and reduce the chances
    of such occurrences in the future.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**航空交通管制**：天空中充满了忙碌的航班。每架飞机必须在确保与其他航班保持安全距离的同时，穿越复杂的航线迷宫。图算法为天空绘制了路线，将每架飞机视为节点，其航线视为边。2010年美国空中交通拥堵事件证明了图分析的威力。科学家们使用图论解读了系统性级联延误，提供了优化航班安排的见解，减少未来此类事件的发生。'
- en: '**Disease spread modeling**: The proliferation of diseases, especially contagious
    ones, doesn’t happen randomly; they follow the invisible lines of human interaction
    and movement. Graph theory creates intricate models that mimic these patterns.
    By treating individuals as nodes and their interactions as edges, epidemiologists
    have successfully projected disease spread, identifying potential hotspots and
    enabling timely interventions. For instance, during the early days of the COVID-19
    pandemic, graph algorithms played a pivotal role in predicting potential outbreak
    clusters, helping to guide lockdowns and other preventive measures.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**疾病传播建模**：疾病，尤其是传染性疾病的传播，并非随机发生；它们遵循人类互动和流动的隐形轨迹。图论构建了复杂的模型来模拟这些模式。通过将个体视为节点，将他们的互动视为边，流行病学家成功地预测了疾病的传播，识别潜在的热点，并实施及时的干预。例如，在COVID-19疫情初期，图算法在预测潜在的爆发聚集区方面发挥了重要作用，帮助指导封锁和其他预防措施。'
- en: '**Social media recommendations**: Ever wondered how platforms like Facebook
    or Twitter suggest friends or content? Underlying these suggestions are vast graphs
    representing user interactions, interests, and behaviors. For example, if two
    users have multiple mutual friends or similar engagement patterns, there’s a high
    likelihood they might know each other or have aligned interests. Graph algorithms
    help decode these connections, enabling platforms to enhance user experience through
    relevant recommendations.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**社交媒体推荐**：曾想过像Facebook或Twitter这样的平台如何推荐朋友或内容吗？这些推荐背后潜藏着巨大的图，代表用户的互动、兴趣和行为。例如，如果两个用户有多个共同的朋友或相似的参与模式，他们可能彼此认识或有相同的兴趣。图算法帮助解码这些连接，使平台能够通过相关推荐增强用户体验。'
- en: 'The basics of a graph: vertices (or nodes)'
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图的基础：顶点（或节点）
- en: 'These are the individual entities or data points in the graph. Imagine each
    friend on your Facebook list as a separate vertex:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是图中的个体实体或数据点。想象一下你Facebook列表中的每个朋友都是一个独立的顶点：
- en: '**Edges (or links**): The connections or relationships between the vertices.
    When you become friends with someone on Facebook, an edge is formed between your
    vertex and theirs.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**边（或链接**）：顶点之间的连接或关系。当你在Facebook上添加朋友时，你的顶点和他们的顶点之间形成一条边。'
- en: '**Network**: A larger structure formed by the interconnected web of vertices
    and edges. For example, the entirety of Facebook, with all its users and their
    friendships, can be viewed as a colossal network.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络**：由顶点和边的互联网形成的更大结构。例如，整个Facebook，以及其所有用户及其友谊，可以被视为一个巨大的网络。'
- en: In *Figure 5.1*, **A**, **B**, and **C** represent vertices, while the lines
    connecting them are edges. It’s a simple representation of a graph, laying the
    groundwork for the more intricate structures and operations we’ll explore.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 5.1* 中，**A**、**B** 和 **C** 表示顶点，而连接它们的线条则是边。这是一个图的简单表示，为我们将要探索的更复杂的结构和操作奠定了基础。
- en: '![](img/B18046_05_01.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18046_05_01.png)'
- en: 'Figure 5.1: Graphic representation of a simple graph'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1：简单图的图形表示
- en: Graph theory and network analysis
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图论和网络分析
- en: Graph theory and network analysis, although intertwined, serve different functions
    in understanding complex systems. While graph theory is a branch of discrete mathematics
    that provides the foundational concepts of nodes (entities) and edges (relationships),
    network analysis is the application of these principles to study and interpret
    real-world networks. For instance, graph theory might define the structure of
    a social media platform where individuals are nodes and their friendships are
    edges; conversely, network analysis would delve into this structure to uncover
    patterns, like influencer hubs or isolated communities, thereby providing actionable
    insights into user behavior and platform dynamics.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图论和网络分析虽然交织在一起，但在理解复杂系统方面具有不同的功能。图论是离散数学的一个分支，提供节点（实体）和边（关系）的基本概念，而网络分析则是将这些原理应用于研究和解释现实世界网络的应用。例如，图论可以定义社交媒体平台的结构，其中个体是节点，而友谊是边；相反，网络分析则深入研究这种结构，揭示模式，如影响者中心或孤立社区，从而提供关于用户行为和平台动态的可操作见解。
- en: We will first start by looking into how we can mathematically and visually represent
    the graphs. Then we’ll harness the power of network analysis on these representations
    using a pivotal set of tools known as “graph algorithms.”
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先看看如何在数学上和视觉上表示这些图。然后，我们将利用一组被称为“图算法”的关键工具对这些表示进行网络分析。
- en: Representations of graphs
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图的表示方式
- en: A graph is a structure that represents data in terms of vertices and edges.
    A graph is represented as *a*[Graph] = (![](img/B18046_05_001.png), ![](img/B18046_05_002.png)),
    where ![](img/B18046_05_003.png) represents a set of vertices and ![](img/B18046_05_004.png)
    represents a set of edges. Note that *a*[Graph] has ![](img/B18046_05_005.png)
    vertices and ![](img/B18046_05_006.png) edges. It’s important to note that unless
    specified otherwise, an edge can be bidirectional, implying a two-way relationship
    between the connected vertices.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图是一种用顶点和边表示数据的结构。一个图被表示为 *a*[Graph] = (![](img/B18046_05_001.png), ![](img/B18046_05_002.png))，其中
    ![](img/B18046_05_003.png) 表示顶点集合，![](img/B18046_05_004.png) 表示边集合。请注意 *a*[Graph]
    有 ![](img/B18046_05_005.png) 个顶点和 ![](img/B18046_05_006.png) 条边。需要注意的是，除非另有说明，边可以是双向的，表示连接的顶点之间存在双向关系。
- en: 'A vertex, ![](img/B18046_05_007.png), represents a real-world object, such
    as a person, a computer, or an activity. An edge, ![](img/B18046_05_008.png),
    connects two vertices in a network:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 一个顶点，![](img/B18046_05_007.png)，代表一个现实世界的对象，如一个人、一台计算机或一个活动。一个边，![](img/B18046_05_008.png)，连接网络中的两个顶点：
- en: '![](img/B18046_05_009.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18046_05_009.png)'
- en: The preceding equation indicates that in a graph, all edges belong to a set,
    ![](img/B18046_05_004.png), and all vertices belong to a set, ![](img/B18046_05_001.png).
    Note that the notation ‘|’ used here is a symbolic representation indicating that
    an element belongs to a particular set, ensuring clarity in the relationship between
    edges, vertices, and their respective sets.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 上述方程表示，在图中，所有的边属于一个集合，![](img/B18046_05_004.png)，所有的顶点属于另一个集合，![](img/B18046_05_001.png)。请注意，符号‘|’表示某个元素属于特定的集合，从而确保了边、顶点及其相应集合之间关系的清晰性。
- en: A vertex symbolizes tangible entities like individuals or computers, whereas
    an edge, connecting two vertices, denotes a relationship. Such relationships can
    be friendships between individuals, online connections, physical links between
    devices, or participatory connections such as attending a conference.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 一个顶点象征着像个人或计算机等有形实体，而一条边，连接两个顶点，表示它们之间的关系。这种关系可以是个体之间的友谊、在线连接、设备之间的物理连接，或者是像参加会议这样的参与性连接。
- en: Graph mechanics and types
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图的机制与类型
- en: 'There are multiple types of graphs, each with its unique attributes:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图有多种类型，每种图都有其独特的属性：
- en: '**Simple graph**: A graph with no parallel edges or loops.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简单图**：没有平行边或自环的图。'
- en: '**Directed graph (DiGraph)**: A graph where each edge has a direction, indicating
    a one-way relationship.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有向图（DiGraph）**：每条边都有方向，表示单向关系的图。'
- en: '**Undirected graph**: A graph where edges don’t have a specific direction,
    suggesting a mutual relationship.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无向图**：一类边没有特定方向，表示相互关系的图。'
- en: '**Weighted graph**: A graph where each edge carries a weight, often representing
    distances, costs, etc.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**加权图**：一类每条边都有一个权重的图，通常代表距离、成本等。'
- en: 'In this chapter, we will use the `networkx` Python package to represent graphs.
    It can be downloaded from [https://networkx.org/](https://networkx.org/). Let’s
    try to create a simple graph using the `networtx` package in Python. A “simple
    graph,” as alluded to in graph theory, is a graph that has no parallel edges or
    loops. To begin with, let’s try to create an empty graph, `aGraph`, with no vertex
    or node:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用 `networkx` Python 包来表示图。可以从[https://networkx.org/](https://networkx.org/)下载。让我们尝试使用
    Python 中的 `networkx` 包来创建一个简单的图。所谓“简单图”，正如图论中所提到的，是指没有平行边或自环的图。首先，让我们尝试创建一个没有顶点或节点的空图，`aGraph`：
- en: '[PRE0]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let’s add a single vertex:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一个单独的顶点：
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can also add a series of vertices using a list:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过列表添加一系列顶点：
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We can also add one edge between the existing vertices, as shown here:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在现有顶点之间添加一条边，如下所示：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let’s now print the edges and avertices:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们打印边和顶点：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Please note that if we add an edge, this also leads to adding the associated
    vertices, if they do not already exist, as shown here:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果我们添加一条边，这也会导致添加相关的顶点，如果这些顶点尚不存在，如下所示：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If we print the list of nodes, the following is the output that we observe:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们打印节点列表，观察到的输出如下：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note that the request to add a vertex that already exists is silently ignored.
    The request is ignored or considered based on the type of graph we have created.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，添加已存在的顶点的请求会被默默忽略。请求会根据我们创建的图的类型被忽略或考虑。
- en: Ego-centered networks
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自我中心化网络
- en: At the heart of many network analyses lies a concept called the ego-centered
    network, or simply, the egonet. Imagine wanting to study not just an individual
    node but also its immediate surroundings. This is where the egonet comes into
    play.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 许多网络分析的核心概念是自我中心化网络，或简而言之，称为自我网络。想象一下，你不仅想研究一个单独的节点，还想研究它的周围环境。这时，自我网络就派上用场了。
- en: Basics of egonets
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自我网络的基础
- en: 'For a given vertex—let’s call it *m*—the surrounding nodes that are directly
    connected to *m* from its direct neighborhood. This neighborhood, combined with
    *m* itself, constitutes the egonet of *m*. In this context:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个给定的顶点——我们称其为 *m*——与 *m* 直接连接的周围节点构成了 *m* 的直接邻域。这个邻域，加上 *m* 本身，就构成了 *m* 的自我网络。在这个语境下：
- en: '*m* is referred to as the *ego*.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*m* 被称为 *自我*。'
- en: The directly connected nodes are termed *one-hop neighbors* or simply *alters*.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接连接的节点被称为 *一跳邻居* 或简单称为 *替代节点*。
- en: One-hop, two-hop, and beyond
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一跳、二跳及更远的节点
- en: When we say “one-hop neighbors,” we refer to nodes that are directly connected
    to our node of interest. Think of it as a single step or “hop” from one node to
    the next. If we were to consider nodes that are two steps away, they’d be termed
    “two-hop neighbors,” and so on. This nomenclature can extend to any number of
    hops, paving the way to understanding *n*-degree neighborhoods.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们说“单跳邻居”时，我们指的是与我们关注的节点直接相连的节点。可以把它看作是从一个节点到下一个节点的一步或“一跳”。如果我们考虑两个跳跃之远的节点，那么它们被称为“二跳邻居”，以此类推。这种命名法可以扩展到任意数量的跳跃，帮助我们理解*n*度邻域。
- en: 'The ego network of a particular node, **3**, is shown in the following graph:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 特定节点**3**的自我网络如下图所示：
- en: '![Diagram  Description automatically generated](img/B18046_05_02.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图示 说明自动生成](img/B18046_05_02.png)'
- en: 'Figure 5.2: Egonet of node 3, showcasing the ego and its one-hop neighbors'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2：节点 3 的自我网络，展示了自我和它的单跳邻居
- en: Applications of egonets
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自我网络的应用
- en: Egonets are widely utilized in social network analysis. They are pivotal in
    understanding local structures in large networks and can offer insights into individual
    behaviors, based on their immediate network surroundings.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 自我网络在社会网络分析中被广泛使用。它们对于理解大规模网络中的局部结构至关重要，并能基于个体的即时网络环境提供关于个体行为的见解。
- en: For instance, in online social platforms, egonets can help detect influential
    nodes or understand information dissemination patterns within localized network
    regions.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在在线社交平台中，自我网络可以帮助检测有影响力的节点，或理解信息在局部网络区域内的传播模式。
- en: Introducing network analysis theory
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入网络分析理论
- en: Network analysis allows us to delve into data that’s interconnected, presenting
    it in the form of a network. It involves studying and employing methodologies
    to examine data that’s arranged in this network format. Here, we’ll break down
    the core elements and concepts related to network analysis.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 网络分析使我们能够深入研究互联的数据，并将其呈现为网络形式。它涉及研究和应用方法论，以检查这种网络格式中排列的数据。在这里，我们将分解与网络分析相关的核心要素和概念。
- en: At the heart of a network lies the “vertex,” serving as the fundamental unit.
    Picture a network as a web; vertices are the points of this web, while the links
    connecting them represent relationships between different entities under study.
    Notably, different relationships can exist between two vertices, implying that
    edges can be labeled to denote various kinds of relationships. Imagine two people
    being connected as “friends” and “colleagues”; both are different relationships
    but link the same individuals.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 网络的核心是“顶点”，它作为基本单元存在。可以把网络想象成一个网状结构；顶点是这个网的节点，而连接它们的边表示不同实体之间的关系。值得注意的是，两个顶点之间可能存在不同的关系，这意味着边可以被标记为表示不同类型的关系。比如，假设有两个人，他们可以通过“朋友”或“同事”关系相连；这两者都是不同的关系，但连接的是同样的个体。
- en: To fully harness the potential of network analysis, it’s vital to gauge the
    significance of a vertex within a network, especially concerning the problem at
    hand. Multiple techniques exist to aid us in ascertaining this significance.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 为了充分利用网络分析的潜力，至关重要的是评估顶点在网络中的重要性，尤其是针对具体问题。存在多种技术可以帮助我们确认这一重要性。
- en: Let’s look at some of the important concepts used in network analysis theory.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下网络分析理论中一些重要的概念。
- en: Understanding the shortest path
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解最短路径
- en: In graph theory, a “path” is defined as a sequence of nodes, connecting a starting
    node to an ending node, without revisiting any node in between. Essentially, a
    path outlines the route between two chosen vertices. The “length” of this path
    is determined by counting the number of edges it contains. Among the various paths
    possible between two nodes, the one with the least number of edges is termed the
    “shortest path.”
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在图论中，“路径”被定义为一系列节点，连接起始节点和结束节点，且不经过任何中间节点的重复。简而言之，路径描绘了两者之间的路线。这条路径的“长度”是通过计算其中包含的边数来确定的。在两个节点之间的各种路径中，包含边数最少的路径被称为“最短路径”。
- en: Identifying the shortest path is a fundamental task in many graph algorithms.
    However, its determination isn’t always straightforward. Over time, multiple algorithms
    have been developed to tackle this problem, with Dijkstra’s algorithm, introduced
    in the late 1950s, being one of the most renowned. This algorithm is designed
    to pinpoint the shortest distance in a graph and has found its way into applications
    like GPS devices, which rely on it to deduce the minimal distance between two
    points. In the realm of network routing, Dijkstra’s method again proves invaluable.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 确定最短路径是许多图算法中的一项基本任务。然而，这一任务并非总是简单明了的。随着时间的推移，已经开发了多种算法来解决这个问题，其中最著名的之一就是20世纪50年代末提出的迪杰斯特拉算法。该算法旨在找出图中的最短距离，并已广泛应用于GPS设备等领域，依赖它来推算两个点之间的最短距离。在网络路由领域，迪杰斯特拉方法再次证明了它的宝贵价值。
- en: Big tech companies like Google and Apple are in a continuous race, especially
    when it comes to enhancing their map services. The goal is not just to identify
    the shortest route but to do so swiftly, often in mere seconds.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 像谷歌和苹果这样的科技公司正在进行一场持续的竞争，特别是在增强它们的地图服务方面。目标不仅是识别最短路线，还要快速完成，通常在几秒钟内。
- en: Later in this chapter, we’ll explore the **breadth-first search** (**BFS**)
    algorithm, a method that can serve as a foundation for Dijkstra’s algorithm. The
    standard BFS assumes equal costs to traverse any path in a graph. However, Dijkstra’s
    takes into account varying traversal costs. To adapt BFS into Dijkstra’s, we need
    to integrate these varying traversal costs.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面，我们将探讨**广度优先搜索**（**BFS**）算法，这是一种可以作为迪杰斯特拉算法基础的方法。标准BFS假设图中任何路径的遍历成本相等。然而，迪杰斯特拉算法考虑了不同的遍历成本。为了将BFS转化为迪杰斯特拉算法，我们需要整合这些不同的遍历成本。
- en: Lastly, while Dijkstra’s algorithm focuses on identifying the shortest path
    from a single source to all other vertices, if one aims to determine the shortest
    paths between every pair of vertices in a graph, the Floyd-Warshall algorithm
    is more suitable.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，尽管迪杰斯特拉算法侧重于从单一源点到所有其他顶点的最短路径识别，但如果目标是确定图中每对顶点之间的最短路径，则弗洛伊德-沃尔沙尔算法更为适合。
- en: Creating a neighborhood
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建邻域
- en: When diving into graph algorithms, the term “neighborhood” frequently emerges.
    So, what do we imply by a neighborhood in this setting? Think of it as a close-knit
    community centered around a specific node. This “community” comprises nodes that
    either have a direct connection or are closely associated with the focal node.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入研究图算法时，“邻域”这一术语经常出现。那么，在这种情况下，我们所说的“邻域”是什么意思呢？可以把它想象成围绕某个特定节点的紧密社区。这个“社区”由那些直接连接或与焦点节点密切相关的节点组成。
- en: As an analogy, envision a city map where landmarks represent nodes. The landmarks
    in the immediate vicinity of a notable place form its “neighborhood.”
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 作为类比，想象一个城市地图，其中地标代表节点。位于某一显著地点附近的地标形成其“邻域”。
- en: A widely adopted approach to demarcate these neighborhoods is through the *k*-order
    strategy. Here, we determine a node’s neighborhood by pinpointing vertices that
    lie *k* hops away. For a hands-on understanding, at *k*=*1*, the neighborhood
    houses all nodes linked directly to the focal node. For *k*=*2*, it broadens to
    include nodes connected to these immediate neighbors, and the pattern continues.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 划分这些邻域的广泛采用的方法是通过*k*-阶策略。在这里，我们通过确定距离节点*k*跳远的顶点来界定一个节点的邻域。为了更直观的理解，当*k*=*1*时，邻域包含所有与焦点节点直接相连的节点。对于*k*=*2*，它扩展到包括那些与这些直接邻居相连的节点，模式继续下去。
- en: Imagine a central dot within a circle as our target vertex. At *k*=*1*, any
    dot connected directly to this central figure is its neighbor. As we increment
    *k* the circle’s radius grows, encapsulating dots situated further away.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个圆圈中的中心点作为我们的目标顶点。当*k*=*1*时，任何与这个中心点直接连接的点就是它的邻居。随着*k*的增加，圆圈的半径增大，包含了距离更远的点。
- en: Harnessing and interpreting neighborhoods is important for graph algorithms,
    as it identifies key analysis zones.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 利用和解释邻域对于图算法来说是重要的，因为它帮助识别关键的分析区域。
- en: 'Let’s look at the various criteria to create neighborhoods:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下创建邻域的各种标准：
- en: Triangles
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 三角形
- en: Density
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 密度
- en: Let us look into them in more detail.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地探讨这些内容。
- en: Triangles
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 三角形
- en: In the expansive world of graph theory, pinpointing vertices that share robust
    interconnections can unveil critical insights. A classic approach is to spot triangles—
    subgraphs where three nodes maintain direct connections among themselves.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在广阔的图论世界中，识别那些具有强大互联关系的顶点可以揭示重要的洞察。经典的方法是寻找三角形——即三个节点彼此之间保持直接连接的子图。
- en: Let’s explore this through a tangible use case, fraud detection, which we’ll
    dissect in more detail in this chapter’s case study. Imagine a scenario where
    there’s an interconnected web – an “egonet” – revolving around a central person—let’s
    name him Max. In this egonet, apart from Max, there are two individuals, Alice
    and Bob. Now, this trio forms a “triangle” - Max is our primary figure (or “ego”),
    while Alice and Bob are the secondary figures (or “alters”).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过一个实际的应用案例——欺诈检测来探索这个问题，接下来的案例研究中将对此进行更详细的分析。想象一个相互连接的网络——一个“自我网络”——围绕一个中心人物展开——我们称他为马克斯。在这个自我网络中，除了马克斯之外，还有两个人，爱丽丝和鲍勃。现在，这三人形成了一个“三角形”——马克斯是我们的核心人物（或“自我”），而爱丽丝和鲍勃是次要人物（或“他者”）。
- en: 'Here’s where it gets interesting: if Alice and Bob have past records of fraudulent
    activities, it raises red flags about Max’s credibility. It’s like discovering
    two of your close friends have been involved in dubious deeds - it naturally puts
    you under scrutiny. However, if only one of them has a questionable past, then
    Max’s situation becomes ambiguous. We can’t label him outright but would need
    deeper investigation.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这时事情变得有趣了：如果爱丽丝和鲍勃有过欺诈活动的记录，那么这就引起了对马克斯可信度的质疑。这就像发现你的两个亲密朋友曾参与可疑的行为——自然会让你处于审视之下。然而，如果其中只有一个人有可疑的过去，那么马克斯的情况就变得模糊了。我们不能直接给他贴上标签，而需要更深入的调查。
- en: To visualize, picture Max at the center of a triangle, with Alice and Bob at
    the other vertices. Their interrelationships, especially if they carry negative
    connotations, can influence the perception of Max’s integrity.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更直观地理解，想象马克斯处于一个三角形的中心，爱丽丝和鲍勃位于另外两个顶点。它们之间的相互关系，特别是如果带有负面含义时，可以影响人们对马克斯诚信的看法。
- en: Density
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 密度
- en: 'In the realm of graph theory, density is a metric that quantifies how closely
    knit a network is. Specifically, it’s the ratio of the number of edges present
    in the graph to the maximum possible number of edges. Mathematically, for a simple
    undirected graph, density is defined as:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在图论中，密度是衡量网络紧密程度的一个指标。具体来说，它是图中实际存在的边数与最大可能的边数之比。在数学上，对于一个简单的无向图，密度定义为：
- en: '![](img/B18046_05_012.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18046_05_012.png)'
- en: 'To put this into perspective, let’s consider an example:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这一点，让我们来看一个例子：
- en: 'Suppose we are part of a book club with five members: Alice, Bob, Charlie,
    Dave, and Eve. If every member knows and has interacted with every other member,
    there would be a total of 10 connections (or edges) among them (Alice-Bob, Alice-Charlie,
    Alice-Dave, Alice-Eve, Bob-Charlie, and so on). In this case, the maximum number
    of possible connections or edges is 10\. If all these connections exist, then
    the density is:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们是一个有五个成员的书籍俱乐部成员：爱丽丝、鲍勃、查理、戴夫和伊芙。如果每个成员都认识并与其他每个成员都有互动，那么他们之间将总共有10条连接（或边）（爱丽丝-鲍勃、爱丽丝-查理、爱丽丝-戴夫、爱丽丝-伊芙、鲍勃-查理，等等）。在这种情况下，最大可能的连接数或边数是10。如果这些连接都存在，那么密度就是：
- en: '![](img/B18046_05_013.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18046_05_013.png)'
- en: This indicates a perfectly dense or fully connected network.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明一个完全密集或完全连接的网络。
- en: 'However, let’s assume Alice knows only Bob and Charlie, Bob knows Alice and
    Dave, and Charlie knows only Alice. Dave and Eve, although members, haven’t interacted
    with anyone yet. In this scenario, there are only three actual connections: Alice-Bob,
    Alice-Charlie, and Bob-Dave. Let’s calculate the density:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，假设爱丽丝只认识鲍勃和查理，鲍勃认识爱丽丝和戴夫，查理只认识爱丽丝。戴夫和伊芙虽然是成员，但尚未与任何人互动。在这种情况下，实际上只有三条连接：爱丽丝-鲍勃、爱丽丝-查理和鲍勃-戴夫。让我们来计算密度：
- en: '![](img/B18046_05_014.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18046_05_014.png)'
- en: This value, being less than 1, shows that the book club’s interaction network
    isn’t fully connected; many potential interactions (edges) haven’t occurred yet.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这个值小于1，表明书籍俱乐部的互动网络并没有完全连接；许多潜在的互动（边）尚未发生。
- en: In essence, a density close to 1 indicates a tightly connected network, while
    a value closer to 0 suggests sparse interactions. Understanding density can help
    in various scenarios, from analyzing social networks to optimizing infrastructure
    planning, by gauging how interconnected the elements of the system are.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，接近1的密度表示网络连接紧密，而接近0的值则表明互动稀疏。理解密度有助于多种场景，从分析社交网络到优化基础设施规划，通过评估系统元素的互联程度。
- en: Understanding centrality measures
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解中心性度量
- en: Centrality measures offer a window into understanding the significance of individual
    nodes within a graph. Think of centrality to identify key players or hubs in a
    network. For instance, in a social setting, it can help pinpoint influencers or
    central figures that hold sway. In urban planning, centrality might indicate pivotal
    buildings or junctions that play a critical role in traffic flow or accessibility.
    Understanding centrality is essential because it reveals nodes that are crucial
    for the functioning, cohesion, or influence within a network.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 中心性度量提供了一个了解图中各个节点重要性的窗口。可以将中心性看作是识别网络中关键角色或枢纽的工具。例如，在社交环境中，它有助于确定具有影响力的人物或核心人物。在城市规划中，中心性可能表明在交通流动或可达性方面发挥关键作用的建筑物或交汇点。理解中心性至关重要，因为它揭示了网络中对功能、凝聚力或影响力至关重要的节点。
- en: 'The most employed centrality metrics in graph analysis encompass:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在图分析中最常用的中心性指标包括：
- en: '**Degree**: Reflects the direct connections a node has.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**度数**：反映一个节点的直接连接。'
- en: '**Betweenness**: Indicates how often a node acts as a bridge along the shortest
    path between two other nodes.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**介数**：表示一个节点在两其他节点之间的最短路径上充当桥梁的频率。'
- en: '**Closeness**: Represents how close a node is to all other nodes in the network.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**紧密度**：表示一个节点距离网络中所有其他节点的远近。'
- en: '**Eigenvector**: Measures a node’s influence based on the quality of its connections,
    not just the quantity.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**特征向量**：根据节点连接的质量而非数量来衡量节点的影响力。'
- en: Note that centrality measures apply to all graphs. As we know, graphs are a
    general representation of objects (vertices or nodes) and their relationships
    (edges), and centrality measures help identify the importance or influence of
    these nodes within the graph. Recall that networks are specific realizations or
    applications of graphs, often representing real-world systems like social networks,
    transportation systems, or communication networks. So, while the centrality measures
    discussed can be applied universally across all types of graphs, they are often
    highlighted in the context of networks due to their practical implications in
    understanding and optimizing real-world systems.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，中心性度量适用于所有图。正如我们所知，图是对象（顶点或节点）及其关系（边）的通用表示形式，中心性度量有助于识别这些节点在图中的重要性或影响力。回想一下，网络是图的特定实现或应用，通常表示像社交网络、交通系统或通信网络这样的现实世界系统。因此，虽然讨论的中心性度量可以广泛应用于所有类型的图，但它们常常在网络的上下文中得到强调，因为它们在理解和优化现实世界系统中具有实际意义。
- en: Let’s delve deeper into these metrics to better appreciate their utility and
    nuances.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更深入地探讨这些指标，以更好地理解它们的实用性和细微差别。
- en: Degree
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 度数
- en: The number of edges connected to a particular vertex is called its **degree**.
    It can indicate how well connected a particular vertex is and its ability to quickly
    spread a message across a network.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 连接到特定顶点的边的数量称为其**度数**。它可以表示一个特定顶点的连接程度以及其在网络中快速传播消息的能力。
- en: 'Let’s consider *a*[Graph] = (![](img/B18046_05_001.png), ![](img/B18046_05_016.png)),
    where ![](img/B18046_05_017.png) represents a set of vertices and ![](img/B18046_05_016.png)
    represents a set of edges. Recall that *a*[Graph] has ![](img/B18046_05_019.png)
    vertices and ![](img/B18046_05_020.png) edges. If we divide the degree of a node
    by (![](img/B18046_05_021.png)), it is called degree centrality:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑 *a*[图] = (![](img/B18046_05_001.png), ![](img/B18046_05_016.png))，其中 ![](img/B18046_05_017.png)
    代表一组顶点，![](img/B18046_05_016.png) 代表一组边。回想一下，*a*[图] 有 ![](img/B18046_05_019.png)
    个顶点和 ![](img/B18046_05_020.png) 条边。如果我们将节点的度数除以 (![](img/B18046_05_021.png))，这就是度数中心性：
- en: '![](img/B18046_05_022.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18046_05_022.png)'
- en: 'Now, let’s look at a specific example. Consider the following graph:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一个具体的例子。考虑以下图：
- en: '![A picture containing text, indoor, device  Description automatically generated](img/B18046_05_03.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![包含文字的图片，室内，设备 描述自动生成](img/B18046_05_03.png)'
- en: 'Figure 5.3: A sample graph illustrating the concept of degree and degree centrality'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3：一个示例图，说明了度数和度数中心性的概念
- en: 'Now, in the preceding graph, vertex *C* has a degree of 4\. Its degree centrality
    can be calculated as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在前面的图中，顶点 *C* 的度为4。它的度中心性可以通过以下方式计算：
- en: '![](img/B18046_05_023.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18046_05_023.png)'
- en: Betweenness
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 介数
- en: Betweenness centrality is a key measure that gauges the significance of a vertex
    within a graph. When applied to social media contexts, it assesses the likelihood
    that an individual plays a crucial role in communications within a specific subgroup.
    In terms of computer networks, where a vertex symbolizes a computer, betweenness
    offers insights into the potential impact on communications between nodes if a
    particular computer (or vertex) were to fail.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 介数中心性是衡量图中顶点重要性的关键指标。在社交媒体背景下，它评估一个人在特定子群体中进行通信的关键角色的可能性。在计算机网络中，当顶点代表计算机时，介数可以提供关于如果某个计算机（或顶点）发生故障时，它对节点间通信的潜在影响的见解。
- en: 'To calculate the betweenness of vertex *a* in a certain *a*[Graph] = (![](img/B18046_05_001.png),
    ![](img/B18046_05_016.png)), follow these steps:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 计算顶点 *a* 的介数，给定 *a*[图] = (![](img/B18046_05_001.png), ![](img/B18046_05_016.png))，按以下步骤进行：
- en: Compute the shortest paths between each pair of vertices in *a*[Graph]. Let’s
    represent this with ![](img/B18046_05_026.png)
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算 *a*[图] 中每对顶点之间的最短路径。我们可以用 ![](img/B18046_05_026.png) 来表示。
- en: From![](img/B18046_05_027.png), count the number of shortest paths that pass
    through vertex *a*. Let’s represent this with ![](img/B18046_05_028.png)
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从![](img/B18046_05_027.png)中，计算通过顶点 *a* 的最短路径数量。我们可以用 ![](img/B18046_05_028.png)
    来表示。
- en: 'Calculate the betweenness with:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过以下方式计算介数：
- en: '![](img/B18046_05_029.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18046_05_029.png)'
- en: Fairness and closeness
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 公平性与接近度
- en: In graph theory, we often want to determine how central or how distant a specific
    vertex is in relation to other vertices. One way to quantify this is by calculating
    a metric known as “fairness.” For a given vertex, say “a,” in a graph “g,” the
    fairness is determined by adding up the distances from vertex “a” to every other
    vertex in the graph. Essentially, it gives us a sense of how “spread out” or “far”
    a vertex is from its neighbors. This concept ties in closely with the idea of
    centrality, where the centrality of a vertex measures its overall distance from
    all other vertices.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在图论中，我们通常希望确定一个特定顶点与其他顶点之间的中心性或距离。一种量化此概念的方法是计算一个称为“公平性”的指标。对于给定的顶点“a”和图“g”，公平性通过将顶点“a”到图中每个其他顶点的距离相加来确定。本质上，它让我们了解一个顶点与其邻居之间的“分布”或“远近”。这个概念与中心性密切相关，中心性衡量的是一个顶点与所有其他顶点之间的整体距离。
- en: Conversely, “closeness” can be thought of as the opposite of fairness. While
    it might be intuitive to think of closeness as the negative sum of a vertex’s
    distances from other vertices, that’s not technically accurate. Instead, closeness
    measures how near a vertex is to all other vertices in a graph, often calculated
    by taking the reciprocal of the sum of its distances to others.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，接近度可以被视为公平性的对立面。虽然直觉上可能认为接近度是顶点与其他顶点距离之和的负值，但从技术上讲并不准确。接近度衡量的是一个顶点与图中所有其他顶点的接近程度，通常通过取其到其他顶点距离之和的倒数来计算。
- en: Both fairness and closeness are essential metrics in network analysis. They
    provide insight into how information might flow within a network or how influential
    a particular node might be. By understanding these metrics, one can derive a deeper
    comprehension of network structures and their underlying dynamics.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 公平性和接近度是网络分析中至关重要的指标。它们提供了有关信息如何在网络中流动或某个特定节点可能有多大影响力的洞察。通过理解这些指标，可以深入理解网络结构及其潜在的动态。
- en: Eigenvector centrality
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 特征向量中心性
- en: Eigenvector centrality is a metric that evaluates the significance of nodes
    within a graph. Rather than just considering the number of direct connections
    a node has, it takes into account the quality of those connections. In simple
    terms, a node is considered important if it is connected to other nodes that are
    themselves significant within the network.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 特征向量中心性是一种评估图中节点重要性的指标。它不仅考虑节点的直接连接数，还考虑这些连接的质量。简而言之，如果一个节点与其他在网络中具有重要地位的节点相连接，那么这个节点就被视为重要。
- en: 'To give this a bit more mathematical context, imagine each node *v* has a centrality
    score *x*(*v*). For every node *v*, its eigenvector centrality is calculated based
    on the sum of the centrality scores of its neighbors, scaled by a factor ![](img/B18046_05_030.png)
    (eigenvector’s associated eigenvalue):'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给这个问题增加一些数学背景，假设每个节点 *v* 都有一个中心性得分 *x*(*v*)。对于每个节点 *v*，它的特征向量中心性是基于它的邻居节点的中心性得分之和，并按一个因子进行缩放！[](img/B18046_05_030.png)（特征向量的相关特征值）：
- en: '![](img/B18046_05_031.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18046_05_031.png)'
- en: where *M*(*v*) denotes the neighbors of *v*.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *M*(*v*) 表示 *v* 的邻居节点。
- en: This idea of weighing the importance of a node based on its neighbors was foundational
    for Google when they developed the PageRank algorithm. The algorithm assigns a
    rank to every web page on the internet, signifying its importance, and is heavily
    influenced by the concept of eigenvector centrality.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 根据节点的邻居加权节点重要性这一思想，为谷歌开发 PageRank 算法时奠定了基础。该算法为互联网上的每个网页分配一个排名，表示其重要性，且深受特征向量中心性概念的影响。
- en: For readers interested in our upcoming watchtower example, understanding the
    essence of eigenvector centrality will provide deeper insights into the workings
    of sophisticated network analysis techniques.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 对于有兴趣了解我们即将展示的瞭望塔示例的读者，理解特征向量中心性的本质将为复杂网络分析技术的运作提供更深入的见解。
- en: Calculating centrality metrics using Python
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Python 计算中心性指标
- en: Let’s create a network and then try to calculate its centrality metrics.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个网络，然后尝试计算它的中心性指标。
- en: '1\. Setting the foundation: libraries and data'
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1\. 建立基础：库和数据
- en: 'This includes importing necessary libraries and defining our data:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这包括导入必要的库和定义我们的数据：
- en: '[PRE9]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'For our sample, we’ve considered a set of vertices and edges:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的示例，我们考虑了一组顶点和边：
- en: '[PRE10]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this setup, vertices represent individual points or nodes in our network.
    The edges signify the relationships or links between these nodes.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个设置中，顶点代表网络中的单个点或节点。边则表示这些节点之间的关系或链接。
- en: 2\. Crafting the graph
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2\. 构建图形
- en: 'With the foundation set, we proceed to craft our graph. This involves feeding
    our data (vertices and edges) into the graph structure:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 基础设置完成后，我们继续构建我们的图形。这涉及将我们的数据（顶点和边）输入到图结构中：
- en: '[PRE11]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, the `Graph()` function initiates an empty graph. The subsequent methods,
    `add_nodes_from` and `add_edges_from`, populate this graph with our defined nodes
    and edges.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`Graph()` 函数初始化一个空图。随后的方法 `add_nodes_from` 和 `add_edges_from` 将我们的定义的节点和边添加到这个图中。
- en: '3\. Painting a picture: visualizing the graph'
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3\. 描绘图像：可视化图形
- en: 'A graphical representation often speaks louder than raw data. Visualization
    not only aids comprehension but also offers a snapshot of the graph’s overall
    structure:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图形表示通常比原始数据更具表达力。可视化不仅有助于理解，还能提供图形整体结构的快照：
- en: '[PRE12]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This code paints the graph for us. The `with_labels=True` method ensures each
    node is labeled, `node_color` provides a distinct color, and `node_size` adjusts
    the node’s size for clarity.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码为我们绘制图形。`with_labels=True` 方法确保每个节点都有标签，`node_color` 提供不同的颜色，`node_size`
    调整节点大小以提高可读性。
- en: '![A picture containing device  Description automatically generated](img/B18046_05_04.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![设备包含的图片  描述自动生成](img/B18046_05_04.png)'
- en: 'Figure 5.4: A schematic representation of the graph, showcasing nodes and their
    inter-relationships'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4：图形的示意表示，展示了节点及其相互关系
- en: Once our graph is established, the next pivotal step is to compute and understand
    the centrality measures of each node. Centrality measures, as previously discussed,
    gauge the importance of nodes in the network.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的图形建立完成，下一步关键是计算并理解每个节点的中心性度量。正如前面所讨论的，中心性度量衡量了节点在网络中的重要性。
- en: '**Degree centrality**: This measure gives the fraction of nodes that a particular
    node is connected to. In simpler terms, if a node has a high degree centrality,
    it’s connected to many other nodes in a graph. The function `nx.degree_centrality(graph)`
    returns a dictionary with nodes as keys and their respective degree centrality
    as values:'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**度中心性**：这个度量值给出了一个特定节点连接的节点的比例。简单来说，如果一个节点具有高的度中心性，它就与图中的许多其他节点相连。`nx.degree_centrality(graph)`
    函数返回一个字典，字典的键是节点，值是它们相应的度中心性：'
- en: '[PRE13]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '**Betweenness centrality**: This metric indicates the number of shortest paths
    passing through a particular node. Nodes with high betweenness centrality can
    be seen as “bridges” or “bottlenecks” between different parts of a graph. The
    function `nx.betweenness_centrality(graph)` computes this for each node:'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**介数中心性**：这一度量表示通过特定节点的最短路径数量。具有高介数中心性的节点可以视为图中不同部分之间的“桥梁”或“瓶颈”。函数`nx.betweenness_centrality(graph)`可以为每个节点计算这一度量：'
- en: '[PRE15]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '**Closeness centrality**: This represents how close a node is to all other
    nodes in a graph. A node with high closeness centrality can quickly interact with
    all other nodes, making it centrally located. This measure is calculated with
    `nx.closeness_centrality(graph)`:'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接近中心性**：这表示一个节点与图中所有其他节点的接近程度。具有高接近中心性的节点能够迅速与所有其他节点进行互动，因此位于图的中心。这个衡量标准通过`nx.closeness_centrality(graph)`计算：'
- en: '[PRE17]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '**Eigenvector centrality**: Unlike the degree centrality, which counts direct
    connections, the eigenvector centrality considers the quality or strength of these
    connections. Nodes connected to other high-scoring nodes get a boost, making it
    a measure of influential nodes. We further sort these centrality values for ease
    of interpretation:'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**特征向量中心性**：与度中心性通过计算直接连接的数量不同，特征向量中心性考虑了这些连接的质量或强度。与其他高得分节点连接的节点会得到加权，从而成为影响力节点的衡量标准。为了便于解释，我们进一步对这些中心性值进行排序：'
- en: '[PRE19]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note that the metrics of centrality are expected to give the centrality measure
    of a particular vertex in a graph or subgraph. Looking at the graph, the vertex
    labeled *7* seems to have the most central location. Vertex 7 has the highest
    values in all four metrics of centrality, thus reflecting its importance in this
    context.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，中心性度量值预计将给出图或子图中特定顶点的中心性度量。通过查看图形，标记为*7*的顶点似乎处于最中心的位置。顶点7在所有四个中心性度量中具有最高的值，因此反映了它在此上下文中的重要性。
- en: Now let’s look into how we can retrieve information from the graphs. Graphs
    are complex data structures with lots of information stored both in vertices and
    edges. Let’s look at some strategies that can be used to navigate through graphs
    efficiently, in order to gather information from them to answer queries.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下如何从图中获取信息。图是复杂的数据结构，包含了存储在顶点和边中的大量信息。我们将探讨一些有效的策略，帮助我们高效地在图中导航，以便收集信息来回答查询。
- en: Social network analysis
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 社会网络分析
- en: '**Social Network Analysis** (**SNA**) stands out as a significant application
    within graph theory. At its core, an analysis qualifies as SNA when it adheres
    to the following criteria:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '**社会网络分析**（**SNA**）作为图论中的一个重要应用脱颖而出。其核心是，当分析符合以下标准时，就可以被认为是社会网络分析：'
- en: Vertices in a graph symbolize individuals.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图中的顶点代表个体。
- en: Edges signify social connections between these individuals, which include friendships,
    shared interests, familial ties, differences in opinions, and more.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 边表示这些个体之间的社会连接，包括友谊、共同兴趣、家庭纽带、意见差异等。
- en: The primary objective of graph analysis leans toward understanding a pronounced
    social context.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图分析的主要目标是理解显著的社会背景。
- en: One intriguing facet of SNA is its capacity to shed light on patterns linked
    to criminal behavior. By mapping out relationships and interactions, it’s feasible
    to pinpoint patterns or anomalies that might indicate fraudulent activities or
    behaviors. For instance, analyzing the connectivity patterns might reveal unusual
    connections or frequent interactions in specific locations, hinting at potential
    criminal hotspots or networks.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 社会网络分析（SNA）一个有趣的方面是它能揭示与犯罪行为相关的模式。通过绘制关系和互动，可以识别出可能表明欺诈行为或异常活动的模式。例如，分析连接模式可能揭示出在特定地点存在不寻常的连接或频繁的互动，暗示潜在的犯罪热点或网络。
- en: LinkedIn has contributed a lot to the research and development of new techniques
    related to SNA. In fact, LinkedIn can be thought of as a pioneer of many algorithms
    in this area.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: LinkedIn在社会网络分析（SNA）相关新技术的研究和发展中做出了巨大贡献。实际上，LinkedIn可以被看作是该领域许多算法的开创者。
- en: Thus, SNA—due to its inherent distributed and interconnected architecture of
    social networks—is one of the most powerful use cases for graph theory. Another
    way to abstract a graph is by considering it as a network and applying an algorithm
    designed for networks. This whole area is called network analysis theory, which
    we will discuss next.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，SNA（社会网络分析）——由于其固有的分布式和互联架构——是图论最强大的应用之一。抽象图形的另一种方式是将其视为一个网络，并应用针对网络设计的算法。这个领域被称为网络分析理论，我们接下来将讨论它。
- en: Understanding graph traversals
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解图遍历
- en: To make use of graphs, information needs to be mined from them. Graph traversal
    is defined as the strategy used to make sure that every vertex and edge is visited
    in an orderly manner. An effort is made to make sure that each vertex and edge
    is visited exactly once—no more and no less. Broadly, there can be two different
    ways of traveling a graph to search the data in it.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 为了利用图形，必须从中挖掘信息。图遍历被定义为一种策略，用来确保每个顶点和边都按顺序访问。我们的目标是确保每个顶点和边都被访问一次且仅一次——既不多也不少。大致上，遍历图形搜索其中数据的方式可以有两种不同的方式。
- en: Earlier in this chapter we learned that going by breadth is called **breadth-first
    search** (**BFS**) – going by depth is called **depth-first search** (**DFS**).
    Let’s look at them one by one.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章前面我们学到，通过宽度进行遍历叫做**广度优先搜索**（**BFS**）——通过深度进行遍历叫做**深度优先搜索**（**DFS**）。让我们逐一了解它们。
- en: BFS
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: BFS
- en: BFS works best when there is a concept of layers or levels of neighborhoods
    in the *a*[Graph] we deal with. For example, when the connections of a person
    on LinkedIn are expressed as a graph, there are first-level connections and then
    there are second-level connections, which directly translate to the layers.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们处理的*图形*（a）具有邻居层级或级别的概念时，BFS 效果最佳。例如，当一个人在 LinkedIn 上的连接以图的形式表示时，首先是一级连接，然后是二级连接，这直接转化为层次。
- en: The BFS algorithm starts from a root vertex and explores the vertices in the
    neighborhood vertices. It then moves to the next neighborhood level and repeats
    the process.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: BFS 算法从根顶点开始，探索邻域中的顶点。然后它移动到下一个邻域层级并重复这个过程。
- en: 'Let’s look at a BFS algorithm. For that, let’s first consider the following
    undirected graph:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下 BFS 算法。首先，考虑以下无向图：
- en: '![Diagram  Description automatically generated](img/B18046_05_05.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![图表 描述自动生成](img/B18046_05_05.png)'
- en: 'Figure 5.5: An undirected graph demonstrating personal connections'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.5：展示个人连接的无向图
- en: Constructing the adjacency list
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建邻接表
- en: 'In Python, the dictionary data structure lends itself conveniently to representing
    the adjacency list of a graph. Here’s how we can define an undirected graph:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，字典数据结构非常适合表示图的邻接表。下面是我们如何定义一个无向图：
- en: '[PRE21]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: To implement it in Python, we will proceed as follows.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在 Python 中实现它，我们将按如下步骤进行。
- en: We will first explain the initialization and then the main loop.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先解释初始化，然后是主循环。
- en: BFS algorithm implementation
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: BFS 算法实现
- en: 'The algorithm implementation will involve two main phases: the initialization
    and the main loop.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 算法实现将涉及两个主要阶段：初始化和主循环。
- en: Initialization
  id: totrans-207
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 初始化
- en: 'Our traversal through the graph relies on two key data structures:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遍历图形的过程依赖于两个关键的数据结构：
- en: '**visited**: A set that will hold all the vertices we’ve explored. It starts
    empty.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**visited**：一个集合，用于存储我们已探索的所有顶点。它开始时为空。'
- en: '**queue**: A list used to hold vertices pending exploration. Initially, it
    will contain just our starting vertex.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**queue**：一个列表，用来存储待探索的顶点。最初，它只包含我们的起始顶点。'
- en: Main loop
  id: totrans-211
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 主循环
- en: 'The primary logic of BFS revolves around exploring nodes layer by layer:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: BFS 的主要逻辑围绕着逐层探索节点展开：
- en: 'Remove the first node from the queue and consider it as the current node for
    the iteration:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从队列中移除第一个节点，并将其视为当前迭代的节点：
- en: '[PRE22]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If the node hasn’t been visited, mark it as visited and fetch its neighbors:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果节点没有被访问过，标记为已访问并获取其邻居：
- en: '[PRE23]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Append unvisited neighbors to the queue:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将未访问的邻居添加到队列中：
- en: '[PRE24]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Once the main loop is complete, the `visited` data structure is returned, which
    contains all the nodes traversed.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦主循环完成，返回`visited`数据结构，它包含了所有已遍历的节点。
- en: Complete BFS code implementation
  id: totrans-220
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 完整的 BFS 代码实现
- en: 'The complete code, with both initialization and the main loop, will be as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的代码，包括初始化和主循环，将如下所示：
- en: '[PRE25]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The BFS traversal mechanism is as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: BFS 遍历机制如下：
- en: The process starts at level one, represented by the node “Amin.”
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 过程从第一层开始，由节点“Amin”表示。
- en: It then expands to level two, visiting “Wasim’,” “Nick,” and “Mike.”
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它接着扩展到第二层，访问“Wasim”、“Nick”和“Mike”。
- en: Subsequently, BFS delves into levels three and four, visiting “Imran” and “Faras,”
    respectively.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 随后，BFS深入到第三层和第四层，分别访问“Imran”和“Faras”。
- en: By the time BFS completes its traversal, all nodes have been accounted for in
    the visited set, and the queue is empty.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 当BFS完成遍历时，所有节点都已记录在已访问集合中，队列为空。
- en: Using BFS for specific searches
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用BFS进行特定搜索
- en: 'To practically understand BFS in action, let’s use our implemented function
    to find a path to a specific person in our graph:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解BFS的实际操作，我们将使用已实现的函数来查找图中到特定人的路径：
- en: '![Diagram  Description automatically generated](img/B18046_05_06.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![图示  自动生成的描述](img/B18046_05_06.png)'
- en: 'Figure 5.6: Layered traversal of a graph using BFS'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.6：使用BFS对图进行层级遍历
- en: 'Now, let’s try to find a specific person from this graph using BFS. Let’s specify
    the data that we are searching for and observe the results:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试使用BFS从这个图中找到某个特定的人。我们来指定要搜索的数据，并观察结果：
- en: '[PRE26]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This signifies the sequence of nodes accessed when BFS starts from `Amin`.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这表示BFS从`Amin`开始时访问的节点顺序。
- en: Now let’s look into the DFS algorithm.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下DFS算法。
- en: DFS
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DFS
- en: '**DFS** offers an alternative approach to graph traversal than **BFS**. While
    BFS seeks to explore the graph level by level, focusing on immediate neighbors
    first, DFS ventures as deep as possible down a path before backtracking.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '**DFS** 提供了与 **BFS** 不同的图遍历方式。BFS按层级逐层探索图，首先关注邻近的节点，而DFS则尽可能深入某条路径，直到回溯再继续探索其他路径。'
- en: Imagine a tree. Starting from the root, DFS dives down to the furthest leaf
    on a branch, marks all nodes along that branch as visited, then backtracks to
    explore other branches in a similar manner. The idea is to reach the furthest
    leaf node on a given branch before considering other branches. “Leaf” is a term
    used to refer to nodes in a tree that don’t have any child nodes or, in a graph
    context, any unvisited adjacent nodes.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一棵树。从根部开始，DFS会深入到某个分支的最远叶子节点，标记沿着该分支的所有节点为已访问，然后回溯以类似的方式探索其他分支。这个思想是先到达给定分支上的最远叶节点，再考虑其他分支。“叶子”是指树中没有任何子节点的节点，或者在图的上下文中，指没有被访问的相邻节点。
- en: To ensure that the traversal doesn’t get stuck in a loop, especially in cyclic
    graphs, DFS employs a Boolean flag. This flag indicates whether a node has been
    visited, preventing the algorithm from revisiting nodes and getting trapped in
    infinite cycles.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保遍历不会陷入死循环，特别是在有环图中，DFS使用了一个布尔标志。该标志表示某个节点是否已经被访问，从而防止算法重新访问已访问的节点，避免陷入无限循环。
- en: 'To implement DFS, we will use a stack data structure, which was discussed in
    detail in *Chapter 2*, *Data Structures Used in Algorithms*. Remember that a stack
    is based on the **Last In, First Out** (**LIFO**) principle. This contrasts with
    a queue, as used for BFS, which works on the **First In, First Out** (**FIFO**)
    principle:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现DFS，我们将使用栈数据结构，这在*第2章*中已经详细讨论过，*算法中的数据结构*。记住，栈遵循**后进先出**（**LIFO**）原则。这与队列不同，队列用于BFS时遵循**先进先出**（**FIFO**）原则：
- en: 'The following code is used for DFS:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码用于DFS：
- en: '[PRE28]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Let’s again use the following code to test the `dfs` function defined previously:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次使用以下代码来测试先前定义的`dfs`函数：
- en: '[PRE29]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If we run this algorithm, the output will look like the following:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行此算法，输出将如下所示：
- en: '[PRE30]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Let’s look at the exhaustive traversal pattern of this graph using the DFS
    methodology:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下使用DFS方法遍历这个图的完整模式：
- en: The iteration starts from the top node, Amin.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 迭代从顶层节点Amin开始。
- en: Then, it moves to level two, Wasim. From there, it moves toward the lower levels
    until it reaches the end, which is the Imran and Fares nodes.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，它移动到第二层节点Wasim。从那里，它继续向下，直到到达末尾，即Imran和Fares节点。
- en: After completing the first full branch, it backtracks and then goes to level
    two to visit Nick and Mike.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成第一个完整的分支后，它回溯并转到第二层，访问Nick和Mike。
- en: 'The traversal pattern is shown in *Figure 5.7*:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历模式如*图5.7*所示：
- en: '![Diagram  Description automatically generated](img/B18046_05_07.png)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![图示  自动生成的描述](img/B18046_05_07.png)'
- en: 'Figure 5.7: A visual representation of DFS traversal'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.7：DFS遍历的可视化表示
- en: Note that DFS can be used in trees as well.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，DFS也可以在树中使用。
- en: Let’s now look at a case study, which explains how the concepts we have discussed
    so far in this chapter can be used to solve a real-world problem.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一个案例研究，解释我们到目前为止在本章中讨论的概念如何应用于解决现实世界的问题。
- en: 'Case study: fraud detection using SNA'
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 案例研究：使用社会网络分析（SNA）进行欺诈检测
- en: Introduction
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍
- en: Humans are inherently social, and their behavior often reflects the company
    they keep. In the realm of fraud analytics, a principle called “homophily” signifies
    the likelihood of individuals having associations based on shared attributes or
    behaviors. A homophilic network, for instance, might comprise people from the
    same hometown, university, or with shared hobbies. The underlying principle is
    that individuals’ behavior, including fraudulent activity, might be influenced
    by their immediate connections. This is also sometimes referred to as “guilt by
    association.”
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 人类天生具有社交性，他们的行为通常反映了他们的社交圈。在欺诈分析领域，一个叫做“同质性”的原则表示个体之间可能会基于共同的属性或行为而建立联系。例如，一个同质网络可能由来自同一故乡、同一大学或有共同爱好的人组成。其基本原则是，个体的行为，包括欺诈行为，可能会受到他们直接联系的影响。这也有时被称为“通过联系而定罪”。
- en: What is fraud in this context?
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在此背景下，什么是欺诈？
- en: In the context of this case study, fraud refers to deceptive activities that
    may include impersonation, credit card theft, fake check submission, or any other
    illicit activities that can be represented and analyzed in a network of relationships.
    In an effort to understand the process, let’s first look at a simple case. For
    that, let’s use a network with nine vertices and eight edges. In this network,
    four of the vertices are known fraud cases and are classified as **fraud** (**F**).
    Five of the remaining people have no fraud-related history and are classified
    as **non-fraud** (**NF**).
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在本案例研究的背景下，欺诈是指可能包括冒充、信用卡盗窃、伪造支票提交或任何其他可以在关系网络中表示和分析的非法活动。为了理解这个过程，首先让我们看一个简单的案例。为此，我们将使用一个包含九个顶点和八条边的网络。在这个网络中，四个顶点是已知的欺诈案例，并被分类为**欺诈**（**F**）。其余五个人没有欺诈相关的历史，分类为**非欺诈**（**NF**）。
- en: 'We will write code with the following steps to generate this graph:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过以下步骤编写代码来生成这个图形：
- en: 'Let’s import the packages that we need:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们导入所需的包：
- en: '[PRE31]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Define the data structures of `vertices` and `edges`:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`顶点`和`边`的数据结构：
- en: '[PRE32]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Instantiate the graph:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例化图形：
- en: '[PRE33]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, draw the graph:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，绘制图形：
- en: '[PRE34]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Let’s define the NF nodes:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们定义NF节点：
- en: '[PRE35]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, let’s create the nodes that are known to be involved in fraud:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建已知涉及欺诈的节点：
- en: '[PRE36]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Finally, create labels for the nodes:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，为节点创建标签：
- en: '[PRE37]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Once the preceding code runs, it will show us a graph like this:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦上述代码运行，它将显示如下图形：
- en: '![Chart  Description automatically generated](img/B18046_05_08.png)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![图表 描述自动生成](img/B18046_05_08.png)'
- en: 'Figure 5.8: Initial network representation showing both fraudulent and non-fraudulent
    nodes'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.8：初始网络表示，展示了欺诈节点和非欺诈节点
- en: 'Note that we have already conducted a detailed analysis to classify each node
    as a graph or non-graph. Let’s assume that we add another vertex, named *q*, to
    the network, as shown in the following figure. We have no prior information about
    this person and whether this person is involved in fraud or not. We want to classify
    this person as NF or F based on their links to the existing members of the social
    network:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们已经进行过详细的分析，将每个节点分类为图形节点或非图形节点。假设我们将添加一个新的顶点，命名为*q*，如下面的图所示。我们没有关于这个人是否涉及欺诈的先前信息。我们希望根据这个人与社交网络中现有成员的联系，将此人分类为NF或F：
- en: '![Diagram  Description automatically generated](img/B18046_05_09.png)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![图示 描述自动生成](img/B18046_05_09.png)'
- en: 'Figure 5.9: Introduction of a new node to the existing network'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.9：向现有网络引入新节点
- en: 'We have devised two ways to classify this new person, represented by node *q*,
    as F or NF:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设计了两种方法来将这个新加入的人（由节点*q*表示）分类为F或NF：
- en: Using a simple method that does not use centrality metrics and additional information
    about the type of fraud
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用一个简单的方法，不使用中心性度量和关于欺诈类型的附加信息
- en: Using a watchtower methodology, which is an advanced technique that uses the
    centrality metrics of the existing nodes, as well as additional information about
    the type of fraud
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用一种瞭望塔方法，这是一种高级技术，利用现有节点的中心性度量，以及关于欺诈类型的附加信息
- en: We will discuss each method in detail.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将详细讨论每种方法。
- en: Conducting simple fraud analytics
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进行简单的欺诈分析
- en: The simple technique of fraud analytics is based on the assumption that in a
    network, the behavior of a person is affected by the people they are connected
    to. In a network, two vertices are more likely to have similar behavior if they
    are associated with each other.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的欺诈分析技术基于这样一个假设：在一个网络中，个人的行为受到他们所连接的人影响。在一个网络中，两个顶点如果相互连接，它们更可能表现出相似的行为。
- en: 'Based on this assumption, we will devise a simple technique. If we want to
    find the probability that a certain node, *a*, belongs to *F*, the probability
    is represented by *P(F/q)* and is calculated as follows:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这个假设，我们将设计一个简单的技术。如果我们想找出某个特定节点*a*属于*F*的概率，该概率表示为*P(F/q)*，其计算方法如下：
- en: '![](img/B18046_05_032.png)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18046_05_032.png)'
- en: Let’s apply this to the preceding figure, where *Neighborhood*[n] represents
    the neighborhood of vertex *n* and *w*(*n*, *n*[j]) represents the weight of the
    connection between *n* and *n*[j]. Also, *DOS*[normalized] is the value of the
    *degree* of suspicion normalized between 0 and 1\. Finally, *degree*[q] is the
    degree of node *q*.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将其应用到前面的图中，其中*Neighborhood*[n]表示顶点*n*的邻域，*w*(*n*, *n*[j])表示*n*与*n*[j]之间连接的权重。另外，*DOS*[normalized]是怀疑程度的标准化值，介于0和1之间。最后，*degree*[q]是节点*q*的度数。
- en: 'The probability is calculated as follows:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 概率的计算方法如下：
- en: '![](img/B18046_05_033.png)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18046_05_033.png)'
- en: Based on this analysis, the likelihood of this person being involved in fraud
    is 67%. We need to set a threshold. If the threshold is 30%, then this person
    is above the threshold value, and we can safely flag them as *F*.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这一分析，这个人涉及欺诈的可能性为67%。我们需要设置一个阈值。如果阈值是30%，那么此人超过了阈值，我们可以放心地将其标记为*F*。
- en: Note that this process needs to be repeated for each of the new nodes in the
    network.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这一过程需要对网络中的每个新节点重复进行。
- en: Now, let’s look at an advanced way of conducting fraud analytics.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看进行欺诈分析的高级方法。
- en: Presenting the watchtower fraud analytics methodology
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 展示瞭望塔欺诈分析方法
- en: 'The previous simple fraud analytics technique has the following two limitations:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的简单欺诈分析技术有以下两个局限性：
- en: It does not evaluate the importance of each vertex in the social network. A
    connection to a hub that is involved in fraud may have different implications
    than a relationship with a remote, isolated person.
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它并未评估社交网络中每个顶点的重要性。与涉及欺诈的中心节点的连接可能比与一个远离的孤立个体的关系具有不同的含义。
- en: When labeling someone as a known case of fraud in an existing network, we do
    not consider the severity of the crime.
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在将某人标记为已知的欺诈案例时，我们不考虑犯罪的严重性。
- en: The watchtower fraud analytics methodology addresses these two limitations.
    First, let’s look at a couple of concepts.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 瞭望塔欺诈分析方法解决了这两个局限性。首先，让我们看一下几个概念。
- en: Scoring negative outcomes
  id: totrans-302
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 负面结果评分
- en: If a person is known to be involved in fraud, we say that there is a negative
    outcome associated with this individual. Not every negative outcome is of the
    same severity or seriousness. A person known to be impersonating another person
    will have a more serious type of negative outcome associated with them, compared
    to someone who is just trying to use an expired $20 gift card in a creative way
    to make it valid.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 如果已知某人涉及欺诈，我们称该人有一个负面结果。并非每个负面结果的严重性相同。已知冒充他人的人，其负面结果会比仅仅尝试用过期的$20礼品卡以某种创意方式使其有效的人更为严重。
- en: 'From a score of 1 to 10, we will rate various negative outcomes as follows:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 从1到10的评分中，我们将不同的负面结果评分如下：
- en: '| **Negative outcome** | **Negative outcome score** |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '| **负面结果** | **负面结果评分** |'
- en: '| Impersonation | 10 |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
  zh: '| 冒充身份 | 10 |'
- en: '| Involvement in credit card theft | 8 |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '| 参与信用卡盗窃 | 8 |'
- en: '| Fake check submission | 7 |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '| 虚假支票提交 | 7 |'
- en: '| Criminal record | 6 |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '| 犯罪记录 | 6 |'
- en: '| No record | 0 |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '| 无记录 | 0 |'
- en: Note that these scores will be based on our analysis of fraud cases and their
    impact from historical data.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这些分数将基于我们对欺诈案件及其对历史数据的影响的分析。
- en: Degree of suspicion
  id: totrans-312
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 怀疑程度
- en: The **degree of suspicion** (**DOS**) quantifies our level of suspicion that
    a person may be involved in fraud. A DOS value of 0 means that this is a low-risk
    person, and a DOS value of 9 means that this is a high-risk person.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '**怀疑程度**（**DOS**）量化了我们对某人可能涉及欺诈的怀疑程度。DOS值为0表示该人风险较低，DOS值为9表示该人风险较高。'
- en: Analysis of historical data shows that professional fraudsters have important
    positions in their social networks. To incorporate this, we first calculate all
    of the four centrality metrics of each vertex in our network. We then take the
    average of these vertices. This translates to the importance of that particular
    person in the network.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 历史数据分析表明，职业诈骗犯在其社交网络中占有重要位置。为了考虑这一点，我们首先计算网络中每个节点的四个中心性指标。然后，我们取这些节点的平均值。这反映了该特定个体在网络中的重要性。
- en: If a person associated with a vertex is involved in fraud, we illustrate this
    negative outcome by scoring the person using the pre-determined values shown in
    the preceding table. This is done so that the severity of the crime is reflected
    in the value of each individual DOS.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 如果与某个节点关联的人涉及诈骗，我们通过使用前述表格中预设的值对该人进行评分，从而展示该负面结果。这是为了确保犯罪的严重性体现在每个个体的DOS值中。
- en: Finally, we multiply the average of the centrality metrics and the negative
    outcome score to get the value of the DOS. We normalize the DOS by dividing it
    by the maximum value of the DOS in the network.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将中心性指标的平均值与负面结果分数相乘，以获得DOS值。然后，通过将其除以网络中最大DOS值来标准化DOS。
- en: 'Let’s calculate the DOS for each of the nine nodes in the previous network:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们计算前述网络中九个节点的DOS：
- en: '|  | **Node 1** | **Node 2** | **Node 3** | **Node 4** | **Node 5** | **Node
    6** | **Node 7** | **Node 8** | **Node 9** |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
  zh: '|  | **节点 1** | **节点 2** | **节点 3** | **节点 4** | **节点 5** | **节点 6** | **节点
    7** | **节点 8** | **节点 9** |'
- en: '| **Degree of centrality** | 0.25 | 0.5 | 0.25 | 0.25 | 0.25 | 0.13 | 0.63
    | 0.13 | 0.13 |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
  zh: '| **中心度** | 0.25 | 0.5 | 0.25 | 0.25 | 0.25 | 0.13 | 0.63 | 0.13 | 0.13 |'
- en: '| **Betweenness** | 0.25 | 0.47 | 0 | 0 | 0 | 0 | 0.71 | 0 | 0 |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
  zh: '| **介数中心性** | 0.25 | 0.47 | 0 | 0 | 0 | 0 | 0.71 | 0 | 0 |'
- en: '| **Closeness** | 0.5 | 0.61 | 0.53 | 0.47 | 0.47 | 0.34 | 0.72 | 0.4 | 0.4
    |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
  zh: '| **接近度** | 0.5 | 0.61 | 0.53 | 0.47 | 0.47 | 0.34 | 0.72 | 0.4 | 0.4 |'
- en: '| **Eigenvector** | 0.24 | 0.45 | 0.36 | 0.32 | 0.32 | 0.08 | 0.59 | 0.16 |
    0.16 |'
  id: totrans-322
  prefs: []
  type: TYPE_TB
  zh: '| **特征向量** | 0.24 | 0.45 | 0.36 | 0.32 | 0.32 | 0.08 | 0.59 | 0.16 | 0.16 |'
- en: '| **Average of centrality Metrics** | 0.31 | 0.51 | 0.29 | 0.26 | 0.26 | 0.14
    | 0.66 | 0.17 | 0.17 |'
  id: totrans-323
  prefs: []
  type: TYPE_TB
  zh: '| **中心性指标的平均值** | 0.31 | 0.51 | 0.29 | 0.26 | 0.26 | 0.14 | 0.66 | 0.17 | 0.17
    |'
- en: '| **Negative outcome score** | 0 | 6 | 0 | 0 | 7 | 8 | 10 | 0 | 0 |'
  id: totrans-324
  prefs: []
  type: TYPE_TB
  zh: '| **负面结果分数** | 0 | 6 | 0 | 0 | 7 | 8 | 10 | 0 | 0 |'
- en: '| **DOS** | 0 | 3 | 0 | 0 | 1.82 | 1.1 | 6.625 | 0 | 0 |'
  id: totrans-325
  prefs: []
  type: TYPE_TB
  zh: '| **DOS** | 0 | 3 | 0 | 0 | 1.82 | 1.1 | 6.625 | 0 | 0 |'
- en: '| **Normalized DOS** | 0 | 0.47 | 0 | 0 | 0.27 | 0.17 | 1 | 0 | 0 |'
  id: totrans-326
  prefs: []
  type: TYPE_TB
  zh: '| **标准化DOS** | 0 | 0.47 | 0 | 0 | 0.27 | 0.17 | 1 | 0 | 0 |'
- en: 'Each of the nodes and their normalized DOS is shown in the following figure:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 每个节点及其标准化的DOS在下图中展示：
- en: '![A screenshot of a game  Description automatically generated with low confidence](img/B18046_05_10.png)'
  id: totrans-328
  prefs: []
  type: TYPE_IMG
  zh: '![游戏截图，描述自动生成，信心较低](img/B18046_05_10.png)'
- en: 'Figure 5.10: Visualization of nodes with their calculated DOS values'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.10：展示具有计算DOS值的节点
- en: 'In order to calculate the DOS of the new node that has been added, we will
    use the following formula:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算新增节点的DOS，我们将使用以下公式：
- en: '![](img/B18046_05_034.png)'
  id: totrans-331
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18046_05_034.png)'
- en: 'Using the relevant values, we will calculate the DOS as follows:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 使用相关值，我们将按如下方式计算DOS：
- en: '![](img/B18046_05_035.png)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18046_05_035.png)'
- en: 'This will indicate the risk of fraud associated with this new node added to
    the system. It means that on a scale of 0 to 1, this person has a DOS value of
    `0.42`. We can create different risk bins for the DOS, as follows:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示与该新节点相关的欺诈风险。这意味着，在0到1的范围内，这个人的DOS值为`0.42`。我们可以为DOS创建不同的风险区间，如下所示：
- en: '| **Value of the DOS** | **Risk classification** |'
  id: totrans-335
  prefs: []
  type: TYPE_TB
  zh: '| **DOS值** | **风险分类** |'
- en: '| DOS = 0 | No risk |'
  id: totrans-336
  prefs: []
  type: TYPE_TB
  zh: '| DOS = 0 | 无风险 |'
- en: '| 0<DOS<=0.10 | Low risk |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
  zh: '| 0<DOS<=0.10 | 低风险 |'
- en: '| 0.10<DOS<=0.3 | Medium risk |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
  zh: '| 0.10<DOS<=0.3 | 中等风险 |'
- en: '| DOS>0.3 | High risk |'
  id: totrans-339
  prefs: []
  type: TYPE_TB
  zh: '| DOS>0.3 | 高风险 |'
- en: Based on these criteria, it can be seen that the new individual is a high-risk
    person and should be flagged.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这些标准，可以看出新的个体是一个高风险人员，应当标记为高风险。
- en: Usually, a time dimension is not involved when conducting such an analysis.
    But now, there are some advanced techniques that look at the growth of a graph
    as time progresses. This allows researchers to look at the relationship between
    vertices as the network evolves. Although such time-series analysis on graphs
    will increase the complexity of the problem many times over, it may give additional
    insight into the evidence of fraud that was not possible otherwise.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在进行此类分析时不涉及时间维度。但现在有一些先进的技术可以随着时间的推移观察图的增长。这使得研究人员可以查看随着网络演化而变化的顶点关系。尽管对图的时间序列分析会大大增加问题的复杂性，但它可能提供额外的欺诈证据，这在其他情况下是无法获得的。
- en: Summary
  id: totrans-342
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about graph-based algorithms. This chapter used
    different techniques of representing, searching, and processing data represented
    as graphs. We also developed skills to be able to calculate the shortest distance
    between two vertices, and we built neighborhoods in our problem space. This knowledge
    should help us use graph theory to address problems such as fraud detection.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们学习了基于图的算法。本章使用了不同的技术来表示、搜索和处理表示为图的数据。我们还培养了计算两个顶点之间最短距离的技能，并在问题空间中构建了邻域。这些知识将帮助我们使用图论来解决诸如欺诈检测等问题。
- en: In the next chapter, we will focus on different unsupervised machine learning
    algorithms. Many of the use-case techniques discussed in this chapter complement
    unsupervised learning algorithms, which will be discussed in detail in the next
    chapter. Finding evidence of fraud in a dataset is an example of such use cases.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将重点介绍不同的无监督机器学习算法。本章讨论的许多应用案例技术与无监督学习算法相辅相成，这些内容将在下一章中详细讨论。在数据集中找到欺诈证据就是这样的应用案例之一。
- en: Learn more on Discord
  id: totrans-345
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Discord上了解更多
- en: 'To join the Discord community for this book – where you can share feedback,
    ask questions to the author, and learn about new releases – follow the QR code
    below:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 要加入本书的Discord社区——在这里你可以分享反馈、向作者提问并了解新版本——请扫描下面的二维码：
- en: '[https://packt.link/WHLel](https://packt.link/WHLel)'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/WHLel](https://packt.link/WHLel)'
- en: '![](img/QR_Code1955211820597889031.png)'
  id: totrans-348
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code1955211820597889031.png)'
