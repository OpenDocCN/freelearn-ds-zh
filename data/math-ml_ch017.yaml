- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Functions
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 函数
- en: '”Mathematicians are like Frenchmen: whatever you say to them they translate
    into their own language and forthwith it is something entirely different.”'
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “数学家就像法国人：你对他们说的任何话，他们都会翻译成自己的语言，立刻就变成完全不同的东西。”
- en: ''
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: — Johann Wolfgang von Goethe
  id: totrans-4
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ——约翰·沃尔夫冈·冯·歌德
- en: 'It’s time we tackle the next big subject of machine-learning-math: functions
    and calculus. What do we have to do with functions?'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候处理机器学习数学中的下一个大主题了：函数与微积分。我们与函数有何关系？
- en: As we’ve seen before, a predictive model is nothing but a multivariate parametric
    function. Linear regression? Ax. Logistic regression? σ(Ax). Neural networks?
    A sequence of σ(Ax)-s, and a multitude of other layers.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所见，预测模型无非就是一个多变量参数函数。线性回归？Ax。逻辑回归？σ(Ax)。神经网络？一系列σ(Ax)层，以及其他无数层。
- en: But it’s not just the description of models, it’s fitting them to the data.
    Say, for a simple linear regression model, “training” is minimizing the mean squared
    error; that is, finding
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 但这不仅仅是对模型的描述，它还包括将模型拟合到数据。比如，对于一个简单的线性回归模型，“训练”就是最小化均方误差；也就是说，寻找
- en: '![ n 1-∑ 2 argmina,b∈ℝn (axi + b − yi), i=1 ](img/file851.png)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![ n 1-∑ 2 argmina,b∈ℝn (axi + b − yi), i=1 ](img/file851.png)'
- en: where x[i] is the training data, and y[i] is the ground truth. This is done
    via differentiation, one of humanity’s most essential inventions. (Whether we
    can call mathematical discoveries inventions is a matter of constant debate.)
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 其中x[i]是训练数据，y[i]是实际标签。这是通过微分完成的，微分是人类最重要的发明之一。（我们是否可以称数学发现为发明，始终是一个持续争论的问题。）
- en: For a function f(x), its derivative at x[0] is defined by
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个函数f(x)，它在x[0]处的导数定义为
- en: '![f ′(x0) = lim f-(x)−-f(x0), x→x0 x − x0 ](img/file852.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![f ′(x0) = lim f-(x)−-f(x0), x→x0 x − x0 ](img/file852.png)'
- en: 'describing the rate of change in terms of x . There’s a lot to unravel: what
    is that strange lim[x→x[0]] symbol? What do the ratio ![f(x)−f(x0)- x−x0](img/file853.png)
    represent? We’ll get to all of it in due time. The gist is, differentiation is
    the driving force of gradient descent, the number one algorithm for training neural
    networks.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 描述x的变化率。这里有很多需要解开的谜团：那个奇怪的lim[x→x[0]]符号是什么意思？比率![f(x)−f(x0)- x−x0](img/file853.png)表示什么？我们会在适当的时候详细解答。这一切的要点是，微分是梯度下降的推动力，而梯度下降是训练神经网络的首选算法。
- en: 'But it does not end here either. Differentiation has an equally important counterpart:
    integration. The formula'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 但事情并没有到此为止。微分有一个同样重要的对立面：积分。公式
- en: '![∫ b f(x)dx a ](img/file854.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![∫ b f(x)dx a ](img/file854.png)'
- en: is called the integral of f(x), describing the signed area under its graph.
    Integration is not as prevalent in practice, but it’s an essential tool for theory.
    For instance, half of probability theory is built around it. Say, the famous expected
    value is defined in terms of an integral; as are several notable probability distributions.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 被称为f(x)的积分，描述了其图形下方的有符号面积。积分在实践中并不那么普遍，但它是理论中的一项重要工具。例如，概率论的一半是围绕它构建的。比如，著名的期望值就是通过积分定义的；多个重要的概率分布也是如此。
- en: In the next couple of chapters, we’ll dive deep into calculus, the theory of
    univariate functions. Why? Because even though machine learning is multivariate,
    the ideas we develop here will serve as the foundations for all the math to come.
    Let’s get to work!
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几章中，我们将深入探讨微积分，即单变量函数的理论。为什么？因为尽管机器学习是多变量的，但我们在这里发展出的思想将为后续所有数学内容奠定基础。让我们开始吧！
- en: 9.1 Functions in theory
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.1 理论中的函数
- en: Everyone has an intuitive understanding of what functions are. At one point
    or another, all of us have encountered this concept. For most of us, a function
    is a curve drawn with a continuous line onto a representation of the Cartesian
    coordinate system.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 每个人对于函数都有一种直观的理解。在某个时刻，我们所有人都接触过这个概念。对大多数人来说，函数就是在笛卡尔坐标系上画出的用连续线条表示的曲线。
- en: '![PIC](img/file855.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file855.png)'
- en: 'Figure 9.1: Definitely looks like a function'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.1：显然看起来像一个函数
- en: 'However, in mathematics, intuitions can often lead us to false conclusions.
    Often, there is a difference between what something is and how you think about
    it – what your mental models are. To give an example from a real-life scenario
    in machine learning, consider the following piece of code:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在数学中，直觉往往会引导我们得出错误的结论。很多时候，事物的本质与你对它的思考方式之间存在差异——也就是你的心理模型。举个机器学习中实际场景的例子，考虑以下这段代码：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Suppose that you wrote this function, and it is in your codebase somewhere.
    Depending on our needs, we might think of it as cross-entropy loss, but in reality,
    this is a 579-character-long string in the Python language, eventually processed
    by an interpreter. However, when working with it, we often use a mental model
    that compacts this information into easily usable chunks, like the three words
    cross-entropy loss. When we reason about high-level processes like training a
    neural network, abstractions such as this allow us to move further and step bigger.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你写了这个函数，它现在位于你的代码库的某个地方。根据我们的需求，我们可能会将它视为交叉熵损失，但实际上，它是 Python 语言中一个 579 个字符长的字符串，最终由解释器处理。然而，在使用它时，我们通常会运用一个将这些信息压缩成易于使用的块的心理模型，就像“交叉熵损失”这三个词一样。当我们思考高层次的过程，比如训练神经网络时，像这样的抽象帮助我们走得更远、迈得更大。
- en: But sometimes, things don’t go our way. When this function throws an error and
    crashes the computations, cross-entropy loss will not cut it. Then, it is time
    to unravel the definition and put everything under a magnifying glass. What could
    have hindered your thinking before is now essential.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 但是有时候，事情并不会按照我们的预期进行。当这个函数抛出错误并导致计算崩溃时，交叉熵损失将无法解决问题。这时，我们需要解开定义，并将一切放大来看。之前可能阻碍你思考的东西，现在却变得至关重要。
- en: These principles are also true for theory, not just for practice. Mathematics
    is a balancing act between logical precision and a clear understanding, two often
    contradicting objectives.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这些原则不仅对实践适用，同样对理论也适用。数学是在逻辑精确性和清晰理解之间找到平衡的艺术，这两者常常是互相矛盾的目标。
- en: 'Let’s go back to our starting point: functions in a mathematical sense. One
    possible mental model, as mentioned, is a curve drawn with a continuous line.
    It allows us to reason about functions visually and intuitively answer some questions.
    However, this particular mental model can go very wrong.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到最初的起点：数学意义上的函数。正如前面提到的，一种可能的心理模型是通过连续的线条绘制的曲线。这使我们能够直观地思考函数，并回答一些问题。然而，这种特定的心理模型也可能大错特错。
- en: To give an example, does Figure 9.2 depict a function?
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，图 9.2 描述的是一个函数吗？
- en: '![PIC](img/file856.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file856.png)'
- en: 'Figure 9.2: Is this a function?'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.2：这是一种函数吗？
- en: Even though this curve is drawn with a continuous line, this is not a function,
    as there are values with multiple images, which cannot happen. To avoid confusion
    later, we have to build the foundations of our discussion if we were to talk about
    mathematical objects. In this chapter, our goal is to establish a basic dictionary
    to properly understand the objects we are working with in machine learning.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这条曲线是用连续的线段绘制的，但这并不是一个函数，因为存在多个值对应同一个像，这在函数中是不能发生的。为了避免以后的混淆，我们必须在讨论数学对象时，先打好基础。本章的目标是建立一个基本的词汇表，帮助我们正确理解在机器学习中所使用的对象。
- en: 9.1.1 The mathematical definition of a function
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1.1 函数的数学定义
- en: Let’s dive straight into the deep water and see the exact mathematical definition
    of functions! (Don’t worry if you don’t understand it for the first read. I’ll
    explain everything in detail. This is the usual experience when encountering a
    definition for the first time.)
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们直接深入探讨函数的精确定义！ （如果第一次阅读时不理解，也不用担心，我会详细解释。这是第一次遇到定义时常有的体验。）
- en: Definition 35\. (Functions)
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 35. （函数）
- en: Let X and Y be two sets. The subset f ⊆X ×Y is a function if for every x ∈X,
    there is at most one y ∈Y such that (x,y) ∈f.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 设 X 和 Y 是两个集合。如果对于每个 x ∈X，最多有一个 y ∈Y 使得 (x,y) ∈f，那么子集 f ⊆X ×Y 就是一个函数。
- en: (The set X ×Y denotes the Cartesian product of X and Y . If you are not familiar
    with the concept, check out Appendix C.)
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: （集合 X ×Y 表示 X 和 Y 的笛卡尔积。如果你不熟悉这个概念，可以查看附录 C。）
- en: For simplicity, we introduce the notation
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简便，我们引入符号
- en: '![f : X → Y, ](img/file857.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![f : X → Y, ](img/file857.png)'
- en: which is short for f is a function from X to Y .
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 f 是从 X 到 Y 的函数的简写。
- en: Note that X and Y can be any set. In the examples we encounter, these are usually
    the set of real numbers or vectors, but there is no such restriction.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，X 和 Y 可以是任何集合。在我们遇到的示例中，这些通常是实数集或向量集，但并没有这样的限制。
- en: To visualize the definition, we can draw two sets and arrows pointing from elements
    of X to elements of Y . Each element (x,y) ∈f represents an arrow, pointing from
    x to y.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为了形象地展示定义，我们可以画出两个集合，并用箭头指向 X 的元素到 Y 的元素。每个元素 (x,y) ∈f 代表一根箭头，指向从 x 到 y。
- en: '![PIC](img/file858.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file858.png)'
- en: 'Figure 9.3: A function, as arrows between two sets'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.3：作为集合间箭头的函数
- en: The only criteria is that there can be at most one arrow starting from any x
    ∈X. This is why Figure 9.2 is not a function.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的标准是任何 x ∈X 处最多只能有一根箭头起始。这就是为什么图 9.2 不是一个函数的原因。
- en: Defining a function as a subset is mathematically precise but very low level.
    To be more useful, we can introduce an abstraction by defining functions with
    formulas, such as
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 将函数定义为一个子集在数学上是精确的，但非常基础。为了更有用，我们可以通过用公式定义函数来引入抽象，例如：
- en: '![f : ℝ → ℝ, x ↦→ x2, ](img/file859.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![f : ℝ → ℝ, x ↦→ x², ](img/file859.png)'
- en: or simply f(x) = x² in short. This is how most of us think about functions when
    working with them.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 或简写为 f(x) = x²。我们大多数人在处理函数时都会这样思考。
- en: Now that we are familiar with the definition, we should get to know some of
    the most basic structural properties of functions.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经熟悉了定义，我们应该了解一些函数最基本的结构性质。
- en: 9.1.2 Domain and image
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1.2 定义域和值域
- en: We saw that, in essence, functions are arrows between sets. At this point, we
    don’t know anything useful about them. When is a function invertible? How can
    we find their minima and maxima? Why should we even care? Probably you have a
    bunch of questions here. Slowly but surely, we will cover all of these.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到，本质上，函数是集合之间的箭头。在这一点上，我们对它们没有任何有用的了解。什么时候一个函数是可逆的？我们如何找到它们的最小值和最大值？为什么我们要关心这些？你可能有一堆问题。我们将慢慢地、一步一步地解决这些问题。
- en: 'The first steps in our journey are concerned with the sets from which arrows
    start and point. There are two important sets in a function’s life: its domain
    and image.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们旅程的第一步是关注箭头起始和指向的集合。函数的生命中有两个重要的集合：它的定义域和值域。
- en: Definition 36\. (Domain and image of functions)
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 36．（函数的定义域和值域）
- en: 'Let f : X →Y be a function. The sets'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '设 f : X →Y 为一个函数。集合'
- en: '![domf := {x ∈ X : there is an y ∈ Y such that f(x) = y} ⊆ X ](img/file860.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![domf := {x ∈ X : there is an y ∈ Y such that f(x) = y} ⊆ X ](img/file860.png)'
- en: and
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 和
- en: '![im f := {y ∈ Y : there is an x ∈ X such that f(x) = y} ⊆ Y ](img/file861.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![im f := {y ∈ Y : there is an x ∈ X such that f(x) = y} ⊆ Y ](img/file861.png)'
- en: are respectively called the domain and image of f.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 分别称为 f 的定义域和值域。
- en: In other words, the domain is the subset of X where arrows start; the image
    is the subset of Y where arrows point.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，定义域是箭头起始的 X 的子集；值域是箭头指向的 Y 的子集。
- en: '![PIC](img/file862.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file862.png)'
- en: 'Figure 9.4: The domain and image of a function'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.4：函数的定义域和值域
- en: Why is this important? For one, these are directly related to the invertibility
    of a function. If you consider the ”points and arrows” mental representation,
    inverting a function is as simple as flipping the direction of the arrows. When
    can we do it? In some cases, doing this might not even result in a function, as
    Figure 9.5 shows.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么这很重要？首先，这些直接与函数的可逆性相关。如果你考虑“点和箭头”的心理表征，反转一个函数就像简单地反转箭头的方向一样。当我们什么时候能做这件事？在某些情况下，做这件事甚至可能无法得到一个函数，如图
    9.5 所示。
- en: '![PIC](img/file863.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file863.png)'
- en: 'Figure 9.5: This function is not invertible, as reversing the arrows doesn’t
    give a well-defined function'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.5：该函数不可逆，因为反转箭头并不能得到一个定义良好的函数。
- en: To put the study of functions on top of solid theoretical foundations, we introduce
    the concept of injective, surjective and bijective functions.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将函数的研究建立在坚实的理论基础上，我们引入了单射、满射和双射函数的概念。
- en: Definition 37\. (Surjective, injective, and bijective functions)
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 37．（满射、单射和双射函数）
- en: 'Let f : X →Y be an arbitrary function.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '设 f : X →Y 为一个任意的函数。'
- en: (a) f is injective if for every y ∈Y there is at most one x ∈X such that f(x)
    = y. (We often say that an injective f is a one-to-one function.)
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: (a) 如果对于每个 y ∈Y，最多只有一个 x ∈X 使得 f(x) = y，则 f 是单射。（我们常说一个单射 f 是一对一函数。）
- en: (b) f is surjective if for every y ∈Y there is an x ∈X such that f(x) = y. (We
    often say that a surjective f maps X onto Y .)
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: (b) 如果对于每个 y ∈Y，存在一个 x ∈X 使得 f(x) = y，则 f 是满射。（我们常说一个满射 f 将 X 映射到 Y 上。）
- en: (c) f is bijective if it is injective and surjective.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: (c) 如果 f 同时是单射和满射，则 f 是双射。
- en: In terms of arrows, injectivity means that every element of the image has at
    most one arrow pointing to it, while surjectivity is that every element indeed
    has at least one arrow. When both are satisfied, we have a bijective function,
    one that can be inverted properly. When the inverse f^(−1) exists, it is unique.
    Both f^(−1) ∘f and f ∘f^(−1) equal to the identity function in their respective
    domains.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 从箭头的角度看，单射意味着值域中的每个元素最多只有一个箭头指向它，而满射意味着每个元素确实至少有一个箭头指向它。当两者都满足时，我们就得到一个双射函数，一个可以被正确反转的函数。当逆函数
    f^(−1) 存在时，它是唯一的。f^(−1) ∘f 和 f ∘f^(−1) 在各自的定义域中都等于恒等函数。
- en: Let’s see some concrete examples! For instance,
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一些具体的例子！例如，
- en: '![f : ℝ → ℝ, f(x) = x2 ](img/file864.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![f : ℝ → ℝ, f(x) = x2 ](img/file864.png)'
- en: is not injective nor surjective. (Ponder on this a bit if you don’t understand
    it right away. It helps if you draw a figure.)
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 既不是单射也不是满射。（如果你一时不理解，可以稍作思考。画个图会有帮助。）
- en: '![PIC](img/file865.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file865.png)'
- en: 'Figure 9.6: Injective, surjective, and bijective functions'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.6：单射、满射和双射函数
- en: On the contrary,
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，
- en: '![ 3 g : ℝ → ℝ, g(x) = x ](img/file866.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![ 3 g : ℝ → ℝ, g(x) = x ](img/file866.png)'
- en: is both, so it is bijective and invertible with inverse g^(−1)(x) = x^(1∕3).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 它是双射和可逆的，反函数是 g^(−1)(x) = x^(1∕3)。
- en: Invertible functions behave nicely, and from a certain perspective, they are
    much better to work with.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 可逆函数表现良好，从某种角度来看，它们更容易处理。
- en: 9.1.3 Operations with functions
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1.3 函数的运算
- en: Functions, just like numbers, have operations defined on them. Two numbers can
    be multiplied and added together, but can you do the same with functions? Without
    any difficulty, they can be added together and multiplied with a scalar as
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 就像数字一样，函数也有操作定义。两个数字可以相乘或相加，但你能对函数做同样的操作吗？没有任何困难，它们可以相加，并且可以与标量相乘，如下所示
- en: '![(f + g)(x) := f(x)+ g(x ), (cf)(x) := cf(x), ](img/file867.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![(f + g)(x) := f(x)+ g(x ), (cf)(x) := cf(x), ](img/file867.png)'
- en: where c is some scalar.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 c 是一个标量。
- en: '![PIC](img/file868.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file868.png)'
- en: 'Figure 9.7: Composing functions'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.7：函数的组合
- en: Another essential operation is composition. Let’s consider the famous logistic
    regression for a minute! The estimator itself is defined by
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的操作是组合。让我们考虑一下著名的逻辑回归吧！估计器本身是通过以下方式定义的
- en: '![f(x) = σ(ax + b), ](img/file869.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![f(x) = σ(ax + b), ](img/file869.png)'
- en: where
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 其中
- en: '![σ(x) = ---1--- 1 + e−x ](img/file870.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![σ(x) = ---1--- 1 + e−x ](img/file870.png)'
- en: 'is the sigmoid function. The estimator f(x) is the composition of two functions:
    l(x) = ax + b and the sigmoid function, so'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 是 sigmoid 函数。估计器 f(x) 是两个函数的组合：l(x) = ax + b 和 sigmoid 函数，因此
- en: '![f(x) = σ(l(x)). ](img/file871.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![f(x) = σ(l(x)). ](img/file871.png)'
- en: As σ maps ℝ onto [0,1], we can think about f(x) as the probability that x belongs
    to the positive class.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 σ 将 ℝ 映射到 [0,1]，我们可以将 f(x) 看作 x 属于正类的概率。
- en: Figure 9.7 shows the points-and-arrows illustration of function composition.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.7 展示了函数组合的点和箭头示意图。
- en: To give one more example, a neural network with several hidden layers is just
    the composition of a bunch of functions. The output of each layer is fed into
    the next one, which is exactly how composition is defined.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 再举一个例子，一个拥有多个隐藏层的神经网络实际上是多个函数的组合。每一层的输出被送入下一层，这正是函数组合的定义。
- en: 'In general, if f : Y →Z and g : X →Y are two functions, then their composition
    is formally defined by'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '通常，如果 f : Y →Z 和 g : X →Y 是两个函数，则它们的组合形式定义为'
- en: '![f ∘ g : X → Z, x ↦→ f (g(x )). ](img/file872.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![f ∘ g : X → Z, x ↦→ f (g(x )). ](img/file872.png)'
- en: Note that in (f ∘g)(x) = f(g(x)), the function g is applied first. The order
    of application is often a point of confusion, so keep this in mind.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在 (f ∘g)(x) = f(g(x)) 中，函数 g 是先应用的。应用顺序通常是一个困扰点，所以要记住这一点。
- en: Remark 8\. (Function addition as composition)
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 备注 8\. （函数加法作为组合）
- en: Given the functions
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 给定这些函数
- en: '![f : X → ℝ, g : X → ℝ, ](img/file873.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![f : X → ℝ, g : X → ℝ, ](img/file873.png)'
- en: we can define their sum by
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下方式定义它们的和
- en: '![(f + g)(x) := f(x)+ g(x ). ](img/file874.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![(f + g)(x) := f(x)+ g(x ). ](img/file874.png)'
- en: Believe it or not, this is yet another form of function composition. Why? Define
    the function add by
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 信不信由你，这又是函数组合的另一种形式。为什么？定义加法函数为
- en: '![add : X × X → ℝ, add(x1,x2) = x1 + x2\. ](img/file875.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![add : X × X → ℝ, add(x1,x2) = x1 + x2\. ](img/file875.png)'
- en: Now we can write addition as
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以写出加法为
- en: '![(f + g )(x) = add(f(x),g(x)). ](img/file876.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![(f + g )(x) = add(f(x),g(x)). ](img/file876.png)'
- en: Composition is an extremely powerful tool. In fact, so powerful that given a
    small set of cleverly defined building blocks, “almost every function” can be
    obtained as the composition of these blocks. (I put “almost every function” in
    quotes because if we want to stay mathematically precise here, long detours are
    needed. To keep ourselves focused, let’s allow ourselves to be a little hand-wavy
    here.)
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 组合是一个极其强大的工具。事实上，它如此强大，以至于给定一小组巧妙定义的构建块，“几乎所有的函数”都可以通过这些块的组合得到。（我把“几乎所有的函数”放在引号中，因为如果我们要保持数学精确性，需要进行长时间的绕道。为了保持专注，我们在这里可以稍微放松一下。）
- en: 9.1.4 Mental models of functions
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1.4 函数的思维模型
- en: So far, we have seen that functions are defined as arrows drawn between elements
    of two sets. This, although being mathematically rigorous, does not give us useful
    mental models to reason about them. As you’ll surely see by the end of our journey,
    in mathematics, the key is often to find the right way to look at things.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到，函数可以被定义为从两个集合的元素之间绘制的箭头。尽管这种定义在数学上是严谨的，但它没有为我们提供有效的思维模型来推理这些函数。正如你在我们旅程结束时必定会看到的，在数学中，关键通常是找到合适的视角来看待事物。
- en: Regarding functions, one of the most common and useful mental models is their
    graph.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 关于函数，最常见且有用的思维模型之一就是它们的图形。
- en: 'If f : ℝ →ℝ is a function mapping a real number to a real number, we can visualize
    it using its graph, defined by'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 f : ℝ → ℝ 是一个将实数映射到实数的函数，我们可以通过它的图形来可视化它，图形定义为：'
- en: '![graph(f) := {(x,f(x)) : x ∈ ℝ }. ](img/file877.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![graph(f) := {(x,f(x)) : x ∈ ℝ }. ](img/file877.png)'
- en: This set of points can be drawn in the two-dimensional plane. For instance,
    in the case of the famous rectified linear unit (ReLU)
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这一组点可以在二维平面上绘制。例如，著名的修正线性单元（ReLU）的情况。
- en: '![ ( |{ ReLU (x ) = 0 if x <0 |( x if 0 ≤ x, ](img/file878.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![ ( |{ ReLU (x ) = 0 如果 x <0 |( x 如果 0 ≤ x, ](img/file878.png)'
- en: the graph looks like this.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 该图看起来是这样的。
- en: '[PRE1]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '![PIC](img/file879.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/file879.png)'
- en: 'Figure 9.8: Graph of the ReLU function'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.8：ReLU 函数的图形
- en: Although identifying functions with their graphs can be useful, it is not generalizable
    for more complex mappings. Visualizing it is challenging if the function’s domain
    and image are not the set of real numbers.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然通过图形识别函数是有用的，但对于更复杂的映射，这种方法并不可推广。如果函数的定义域和映像不是实数集，直观地表示它将会很具挑战性。
- en: '![PIC](img/file880.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/file880.png)'
- en: 'Figure 9.9: Functions as a transformation of the space. Here, the vectors of
    the space are rotated around the origin'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.9：作为空间变换的函数。在这里，空间的向量围绕原点旋转。
- en: When dealing with neural networks, probably the best way to think about functions
    (that is, layers in this context) is as transformations of the underlying feature
    space. A simple example is a rotation in the two-dimensional Euclidean plane,
    as Figure 9.9 shows.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理神经网络时，关于函数（在此上下文中即为层）最好的思考方式是将其视为对底层特征空间的变换。一个简单的例子是二维欧几里得平面中的旋转，如图 9.9 所示。
- en: '![PIC](img/file881.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/file881.png)'
- en: 'Figure 9.10: Examplar applications of image transformations available in Albumenations'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.10：Albumentations 中的图像变换示例应用
- en: Image transformations provide a set of more complex examples. You rarely think
    about image blur as a transformation between spaces, but this is the case. After
    all, an image is just a huge vector in some vector space.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图像变换提供了一组更复杂的示例。你很少将图像模糊视为空间之间的变换，但事实就是如此。毕竟，图像只是某个向量空间中的一个巨大的向量。
- en: 'Image operations as transformations, as done by the Albumentations ( [https://albumentations.ai/](https://albumentations.ai/))
    library. Source of the image: Albumentations: Fast and Flexible Image Augmentations
    by Alexander Buslaev, Vladimir I. Iglovikov, Eugene Khvedchenya, Alex Parinov,
    Mikhail Druzhinin and Alexandr A. Kalinin ( [https://www.mdpi.com/2078-2489/11/2/125](https://www.mdpi.com/2078-2489/11/2/125)).'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图像操作作为变换，由 Albumentations ([https://albumentations.ai/](https://albumentations.ai/))
    库执行。图片来源：Albumentations：快速灵活的图像增强，作者：Alexander Buslaev, Vladimir I. Iglovikov,
    Eugene Khvedchenya, Alex Parinov, Mikhail Druzhinin 和 Alexandr A. Kalinin ([https://www.mdpi.com/2078-2489/11/2/125](https://www.mdpi.com/2078-2489/11/2/125))。
- en: In essence, a neural network is simply a stack of transformations, each taking
    its input from the output of the previous one. As you’ll see, what makes them
    special is that the transformations are not hand-engineered but learned from the
    data.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，神经网络仅仅是一个变换堆栈，每一层都从前一层的输出中获取输入。如你所见，神经网络之所以特殊，是因为这些变换并非手工设计，而是从数据中学习得到的。
- en: 9.2 Functions in practice
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.2 实践中的函数
- en: In our study of functions, we started from arrows between sets and ended up
    with mental models such as formulas and graphs. For pure mathematical purposes,
    these models are perfectly enough to conduct thorough investigations. However,
    once we leave the realm of theory and start putting things into practice, we must
    think about how functions are represented in programming languages.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们对函数的研究中，我们从集合之间的箭头出发，最终得到了像公式和图形这样的思维模型。对于纯数学目的，这些模型足够用来进行深入的研究。然而，一旦我们离开理论领域，开始将其付诸实践时，我们就必须考虑函数在编程语言中的表示方式。
- en: In Python, functions are defined using a straightforward syntax. For instance,
    this is how the square(x) = x² function can be implemented.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，函数使用简单的语法来定义。例如，平方函数 square(x) = x² 可以这样实现。
- en: '[PRE2]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The result is an object of type function. (In Python, everything is an object.)
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个类型为函数的对象。（在 Python 中，一切都是对象。）
- en: '[PRE3]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Functions are called using the () operator.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `()` 操作符来调用函数。
- en: '[PRE5]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Python is well-known for its simplicity, and functions are no exception. However,
    this doesn’t mean that they are limited in features – quite the contrary: you
    can achieve a lot with the clever use of functions.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Python 以简洁著称，函数也不例外。然而，这并不意味着它们的功能受限——恰恰相反，通过巧妙使用函数，你可以实现很多功能。
- en: 9.2.1 Operations on functions
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.1 函数操作
- en: 'There are three operations that we want to do on functions: composition, addition,
    multiplication. The easiest way is to call the functions themselves and fall back
    to the operations defined for the number types. To see an example, let’s implement
    the cube(x) = x³ function and add/multiply/compose it with square.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想对函数执行三种操作：组合、加法、乘法。最简单的方法是直接调用函数本身，然后回退到为数字类型定义的操作。为了看到一个例子，让我们实现立方函数 cube(x)
    = x³，并将其与平方函数相加、相乘或组合。
- en: '[PRE7]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: However, there is a major problem. If you take another look at the function
    operations, you can notice that they take functions and return functions. For
    instance, the composition is defined by
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，存在一个主要问题。如果你再看一下函数操作，你会发现它们接受函数并返回函数。例如，组合由以下公式定义：
- en: '![compose : f,g ↦→ (x ↦→ f(g(x))) , ◟-----◝◜----◞ the composed function ](img/file882.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![组合：f,g ↦→ (x ↦→ f(g(x))) ，◟-----◝◜----◞ 组合后的函数](img/file882.png)'
- en: with a function as a result. We did no such thing by simply passing the return
    value to the outer function. There is no function object to represent the composition.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将返回值传递给外部函数，我们并没有做这种事情。没有函数对象来表示这种组合。
- en: In Python, functions are first-class objects, meaning that we can pass them
    to other functions and return them from functions. (This is an absolutely fantastic
    feature, but if this is the first time you’ve encountered this, it might take
    some time to get used to.)
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，函数是第一类对象，这意味着我们可以将它们传递给其他函数并从函数中返回它们。（这是一个绝妙的特性，但如果这是你第一次遇到这个概念，可能需要一些时间来适应。）
- en: Thus, we can implement the compose function above by using the first-class function
    feature.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以通过使用第一类函数特性来实现上面的组合函数。
- en: '[PRE13]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Addition and multiplication can be done just like this. (They are even assigned
    as an exercise problem Section [9.4](ch017.xhtml#problems8).)
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 加法和乘法可以像这样完成。（它们甚至作为练习题在[9.4](ch017.xhtml#problems8)节中被分配。）
- en: 9.2.2 Functions as callable objects
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.2 函数作为可调用对象
- en: 'The standard way of doing function definitions is not a good fit for an application
    that is essential for us: parametrized functions. Think about the case of linear
    functions of the form ax + b, where a and b are parameters. On the first try,
    we can do something like this.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 标准的函数定义方式并不适合我们需要的应用：带参数的函数。想一下线性函数 ax + b 的情况，其中 a 和 b 是参数。在第一次尝试时，我们可以这样做：
- en: '[PRE15]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Passing the parameters as arguments seems to work, but there are serious underlying
    issues. For instance, functions can have a lot of parameters. Even if we compact
    parameters into multidimensional arrays, we might need to deal with dozens of
    such arrays. Passing them around manually is error-prone, and we usually have
    to work with multiple functions. For example, neural networks are composed of
    several layers. Each layer is a parameterized function, and their composition
    yields a predictive model.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 将参数作为参数传递似乎是可行的，但存在一些严重的潜在问题。例如，函数可能有很多参数。即使我们将参数压缩成多维数组，我们也可能需要处理几十个这样的数组。手动传递这些参数容易出错，而且我们通常需要与多个函数一起工作。例如，神经网络由多个层组成。每一层都是一个带参数的函数，它们的组合会产生一个预测模型。
- en: We can solve this issue by applying the classical object-oriented principle
    of encapsulation, implementing functions as callable objects. In Python, we can
    do this by implementing the magic __call__ method for the class.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过应用经典的面向对象封装原则来解决这个问题，将函数实现为可调用对象。在 Python 中，我们可以通过为类实现魔法方法 `__call__`
    来做到这一点。
- en: '[PRE16]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This way, we can store, access, and modify the parameters using attributes.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们可以使用属性来存储、访问和修改参数。
- en: '[PRE18]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Since there can be a lot of parameters, we should implement a method that collects
    them together in a dictionary.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 由于可能会有很多参数，我们应该实现一个方法，将它们收集到一个字典中。
- en: '[PRE20]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Interactivity is one of the most useful features of Python. In practice, we
    frequently find ourselves working in the REPL, inspecting objects and calling
    functions by hand. We often add a concise string representation for our classes
    for these situations.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 交互性是 Python 最有用的特性之一。在实践中，我们经常在 REPL 环境中工作，检查对象并手动调用函数。我们通常会为我们的类添加简洁的字符串表示，以应对这些情况。
- en: By default, printing a Linear instance results in a cryptic message.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，打印一个 `Linear` 实例会显示一条晦涩的信息。
- en: '[PRE23]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This is not very useful. Besides the class name and its location in the memory,
    we haven’t received any information. We can change this by implementing the __repr__
    method responsible for returning the string representation for our object.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是非常有用。除了类名和它在内存中的位置，我们没有获得任何信息。我们可以通过实现负责返回我们对象字符串表示的`__repr__`方法来改变这一点。
- en: '[PRE25]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This looks much better! Adding a pretty string representation seems like a small
    thing, but this can go a long way when doing machine learning engineering in the
    trenches.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来好多了！添加一个漂亮的字符串表示看似是一件小事，但在做机器学习工程时，这可以起到很大的作用。
- en: 9.2.3 Function base class
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.3 `Function` 基类
- en: The Linear class that we have just seen is only the tip of the iceberg. There
    are hundreds of function families that are used in machine learning. We’ll implement
    many of them eventually, and to keep the interfaces consistent, we are going to
    add a base class from which all others will be inherited.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚看到的 `Linear` 类只是冰山一角。在机器学习中，有成百上千个函数族。我们最终会实现其中的许多，为了保持接口的一致性，我们将添加一个基类，所有其他类都将从这个基类继承。
- en: '[PRE27]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: With this, we can implement functions and function families in the following
    way.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们可以以以下方式实现函数和函数族。
- en: '[PRE28]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Even though we haven’t implemented the parameters method for the Sigmoid class,
    it is inherited from the base class.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们还没有为 `Sigmoid` 类实现 `parameters` 方法，它还是继承自基类。
- en: '[PRE30]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: For now, let’s keep the base class as simple as possible. During the course
    of this book, we’ll progressively enhance the Function base class to cover all
    the methods a neural network and its layers need. (For instance, gradients.)
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们保持基类尽可能简单。在本书的过程中，我们会逐步增强 `Function` 基类，以涵盖神经网络及其层所需的所有方法。（例如，梯度。）
- en: 9.2.4 Composition in the object-oriented way
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.4 面向对象的组合方式
- en: 'Recall how we did function composition (in Section [9.2.1](ch017.xhtml#operations-on-functions))
    when working with plain Python functions? Syntactically, that can work with our
    Function class as well, although there is a huge issue: the return value is not
    a Function type.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下我们在处理纯 Python 函数时是如何进行函数组合的（在第[9.2.1](ch017.xhtml#operations-on-functions)节中）？从语法上讲，这也可以与我们的
    `Function` 类一起使用，尽管有一个巨大的问题：返回值不是 `Function` 类型。
- en: '[PRE32]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This kind of composition doesn’t inherit the interface we need.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这种组合方式并没有继承我们需要的接口。
- en: '[PRE36]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'To fix the issue, we implement function composition as a child of the Function
    base class. Recall that composition is a function, taking two functions as input
    and returning one:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们将函数组合实现为 `Function` 基类的一个子类。回忆一下，组合是一个函数，接受两个函数作为输入并返回一个函数：
- en: '![compose : f, g ↦→ (◟x-↦→-f◝(g◜-(x-)))◞ . the composed function ](img/file889.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![compose : f, g ↦→ (◟x-↦→-f◝(g◜-(x-)))◞ . 组合后的函数](img/file889.png)'
- en: Keeping this in mind, this is how we can do composition.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 记住这一点，这就是我们如何进行组合的方式。
- en: '[PRE38]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: (Note that due to how composition is defined, we iterate through the list of
    functions in the reverse order. That’s because (f ∘g)(x) = f(g(x)), we apply g
    first.)
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: （注意，由于组合是这样定义的，我们以相反的顺序遍历函数列表。这是因为 `(f ∘ g)(x) = f(g(x))`，我们首先应用 `g`。）
- en: '[PRE39]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This way, we get to keep the Function interface.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们可以保持 `Function` 接口。
- en: '[PRE41]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 9.3 Summary
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.3 小结
- en: Now that we’ve learned what functions really are, I bet your world is a bit
    shaken. Functions as graphs drawn with continuous lines, sure. Maybe even expressions
    like f(x) = x² + 1\. But functions as dots and arrows?
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了函数的真正含义，我敢打赌你的世界有些动摇了。函数作为由连续线条绘制的图形，当然可以。也许甚至是像 `f(x) = x² + 1` 这样的表达式。但作为点和箭头的函数呢？
- en: Surprisingly, the dot-and-arrow representation is the closest to the true definition.
    Graphs and expressions come after that. This is what we’ve learned in this chapter,
    and by now, I feel like a magician. I’ve shown you mathematical objects and revealed
    that, deep inside, they are not what you think. We did this with vectors, matrices,
    and now, with functions.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 出人意料的是，点和箭头表示法最接近真实定义。图表和表达式紧随其后。这是我们在本章学到的内容，到目前为止，我感觉自己像个魔术师。我向你展示了数学对象，并揭示了它们深藏的本质并非你所想象的那样。我们用向量、矩阵，现在又用函数做到了这一点。
- en: Along with the “what’s behind the curtain?” tricks, putting theory into practice
    also became an established pattern for us. So, we’ve used object-oriented Python
    to get a taste of what a function is like.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 除了“幕后秘密”的技巧外，将理论付诸实践也成为我们的一种惯例。因此，我们使用面向对象的 Python 来了解函数的实现。
- en: Next, we’ll turn our lenses to an even higher level of magnification. For us,
    the most important functions map numbers to numbers. But what’s a number? Even
    in programming languages, we have several different number types, like int-s,
    float-s, double-s, and so on. These are deeply rooted in math, and familiarity
    with the structure of numbers is a must for every developer and engineer.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将把目光转向更高层次的视角。对于我们来说，最重要的函数将数字映射到数字。但是，什么是数字？即使在编程语言中，我们也有几种不同的数字类型，如整数、浮点数、双精度数等等。这些深深植根于数学中，熟悉数字结构对每个开发者和工程师都是必需的。
- en: See you in the next chapter!
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章见！
- en: 9.4 Problems
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.4 问题
- en: Problem 1\. Which of these functions are injective, surjective, or bijective?
    Find the inverse of bijective functions.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 问题1\. 这些函数中哪些是单射、满射或双射？找到双射函数的反函数。
- en: '(a) f : ℝ → (0,∞), x→e^x (b) g : ℝ → [0,∞), x→x² (c) h : [0,∞) → [0,∞), x→x²
    (d) sin : ℝ → [0,1], x→sin(x) (e) tan : ℝ →ℝ, x→tan(x),'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '(a) f : ℝ → (0,∞)，x→e^x (b) g : ℝ → [0,∞)，x→x² (c) h : [0,∞) → [0,∞)，x→x² (d)
    sin : ℝ → [0,1]，x→sin(x) (e) tan : ℝ →ℝ，x→tan(x)，'
- en: 'Problem 2\. Find a function f : ℝ →ℝ such that (f ∘f)(x) = −x.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '问题2\. 找到一个函数 f : ℝ →ℝ，使得 (f ∘f)(x) = −x。'
- en: 'Problem 3\. Can any real function g : ℝ →ℝ be obtained as g = f ∘f for some
    f : ℝ →ℝ?'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '问题3\. 任何实函数 g : ℝ →ℝ 都能通过 g = f ∘f 的形式得到吗？'
- en: Problem 4\. Following the example of the composition Section [9.2.1](ch017.xhtml#operations-on-functions),
    implement
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 问题4\. 在函数组合章节 [9.2.1](ch017.xhtml#operations-on-functions) 的示例之后，实现
- en: the add function, taking f and g, returning f + g,
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加法函数，接受 f 和 g，并返回 f + g，
- en: the mul function, taking f and g, returning fg,
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 乘法函数，接受 f 和 g，并返回 fg，
- en: and the div function, taking f and g, returning f∕g.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以及除法函数，接受 f 和 g，并返回 f∕g。
- en: Join our community on Discord
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 社群
- en: Read this book alongside other users, Machine Learning experts, and the author
    himself. Ask questions, provide solutions to other readers, chat with the author
    via Ask Me Anything sessions, and much more. Scan the QR code or visit the link
    to join the community. [https://packt.link/math](https://packt.link/math)
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他用户、机器学习专家和作者一起阅读这本书。提问，为其他读者提供解决方案，通过问答环节与作者交流，以及更多内容。扫描二维码或访问链接加入社群。[https://packt.link/math](https://packt.link/math)
- en: '![PIC](img/file1.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file1.png)'
