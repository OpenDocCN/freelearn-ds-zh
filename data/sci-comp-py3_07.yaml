- en: Chapter 7. Functions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章 函数
- en: This chapter introduces functions, a fundamental building block in programming.
    We show how to define them, how to handle input and output, how to properly use
    them, and how to treat them as objects.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了函数，这是编程中的基本构建块。我们展示了如何定义它们，如何处理输入和输出，如何正确使用它们，以及如何将它们视为对象。
- en: Basics
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基础
- en: In mathematics, a function is written as a map that uniquely assigns an element
    *y* from the range *R* to every element *x* from the domain *D*.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在数学中，函数被写成一种映射，它将范围 *R* 中的元素 *y* 唯一地分配给定义域 *D* 中的每个元素 *x*。
- en: 'This is expressed by *f : D → R*'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '这可以用 *f : D → R* 来表示'
- en: 'Alternatively, when considering particular elements *x* and *y*, one writes *f
    : x → y*'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '或者，在考虑特定的元素 *x* 和 *y* 时，可以写成 *f : x → y*'
- en: Here, *f* is called the name of the function and *f(x)* is its value when applied
    to *x*. Here, *x* is sometimes called the argument of *f.* Let's first look at
    an example before considering functions in Python.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，*f* 被称为函数的名称，*f(x)* 是将其应用于 *x* 时的值。在这里，*x* 有时被称为 *f* 的参数。在我们考虑 Python 中的函数之前，让我们先看看一个例子。
- en: For example, *D =* ℝ x ℝ  and *y = f(x[1], x[2]) = x[1] - x[2]*. This function
    maps two real numbers to their difference.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，*D =* ℝ x ℝ，*y = f(x[1], x[2]) = x[1] - x[2]*。这个函数将两个实数映射到它们的差。
- en: 'In mathematics, functions can have numbers, vectors, matrices, and even other
    functions as arguments. Here is an example of a function with mixed arguments:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在数学中，函数可以有数字、向量、矩阵，甚至其他函数作为参数。以下是一个具有混合参数的函数示例：
- en: '![Basics](img/B05511_07_01-1.jpg).'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '![基础](img/B05511_07_01-1.jpg).'
- en: 'In this case, a number is returned. When working with functions, we have to
    distinguish between two different steps:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，返回一个数字。当与函数一起工作时，我们必须区分两个不同的步骤：
- en: The definition of the function
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数的定义
- en: The evaluation of the function, that is, the computation of *f(x) *for a given
    value of *x*
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数的评估，即对于给定的 *x* 计算 *f(x)*
- en: 'The first step is done once, while the second can be performed many times for
    various arguments. Functions in programming languages follow the same concept
    and apply it to a wide range of types of input arguments, for example, strings,
    lists, or any object. We demonstrate a definition of the function by considering
    the given example again:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步只做一次，而第二步可以针对各种参数多次执行。编程语言中的函数遵循相同的概念，并将其应用于广泛的输入参数类型，例如字符串、列表或任何对象。我们通过考虑给定的示例来演示函数的定义：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The keyword `def`  indicates that we are going to define a function. `subtract`
    is the function’s name and `x1` and  `*x2*` are its parameters. The colon indicates
    that we are using a block command and the value that is returned by the function
    follows the `return` keyword. Now, we can evaluate this function. This function
    is called with its parameters replaced by input arguments:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字 `def` 表示我们将要定义一个函数。`subtract` 是函数的名称，`x1` 和 `*x2*` 是其参数。冒号表示我们正在使用块命令，函数返回的值位于
    `return` 关键字之后。现在，我们可以评估这个函数。这个函数通过用输入参数替换其参数来调用：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The result 0.7 is computed and assigned to the `r` variable.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 计算结果 0.7 并将其分配给 `r` 变量。
- en: Parameters and arguments
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参数和参数
- en: When defining a function, its input variables are called the parameters of the
    function. The input used when executing the function is called its argument.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 定义函数时，其输入变量被称为函数的参数。在执行函数时使用的输入称为其参数。
- en: Passing arguments - by position and by keyword
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过位置和关键字传递参数
- en: We will consider the previous example again, where the function takes two parameters,
    namely `x1` and `x2`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再次考虑之前的示例，其中函数接受两个参数，即 `x1` 和 `x2`。
- en: 'Their names serve to distinguish the two numbers, which in this case cannot
    be interchanged without altering the result. The first parameter defines the number
    from which the second parameter is subtracted. When `subtract` is called, every
    parameter is replaced by an argument. Only the order of the arguments matters;
    the arguments can be any objects. For instance, we may call the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 它们的名字用于区分这两个数字，在这种情况下，如果不改变结果则不能互换。第一个参数定义了从第二个参数中减去的数字。当调用 `subtract` 时，每个参数都被替换为参数。只有参数的顺序很重要；参数可以是任何对象。例如，我们可以调用以下内容：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Besides this standard way of calling a function, which is by passing the arguments
    by position, it might sometimes be convenient to pass arguments using keywords.
    The names of the parameters are the keywords; consider the following instance:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 除了通过位置传递参数的标准调用函数的方式之外，有时使用关键字传递参数可能更方便。参数的名称是关键字；考虑以下实例：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here, the arguments are assigned to the parameters by name and not by position
    in the call. Both ways of calling a function can be combined so that the arguments
    given by position come first and the arguments given by keyword follow last. We
    show this by using the function `plot`, which was described in [Chapter 6](ch06.html
    "Chapter 6. Plotting"), *Plotting*:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，参数是通过名称而不是调用中的位置分配给参数的。两种调用函数的方式可以结合使用，使得按位置提供的参数先于按关键字提供的参数。我们通过使用在[第6章](ch06.html
    "第6章。绘图")*绘图*中描述的`plot`函数来展示这一点：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Changing arguments
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更改参数
- en: 'The purpose of parameters is to provide the function with the necessary input
    data. Changing the value of the parameter inside the function normally has no
    effect on its value outside the function:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 参数的目的是为函数提供必要的输入数据。在函数内部更改参数的值通常不会对其函数外部的值产生影响：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This applies to all immutable arguments, such as strings, numbers, and tuples.
    The situation is different if mutable arguments, such as lists or dictionaries,
    are changed.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这适用于所有不可变参数，例如字符串、数字和元组。如果可变参数，如列表或字典，被更改，则情况不同。
- en: 'For example, passing mutable input arguments to a function and changing them
    inside the function can change them outside the function too:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，将可变输入参数传递给函数并在函数内部更改它们也会在函数外部更改它们：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Such a function misuses its arguments to return results. We strongly dissuade
    you from such constructions and recommend that you do not change input arguments
    inside the function (for more information refer to *Default Arguments* section).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的函数滥用其参数以返回结果。我们强烈建议您不要采用这种结构，并建议您不要在函数内部更改输入参数（更多信息请参阅*默认参数*部分）。
- en: Access to variables defined outside the local namespace
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问局部命名空间外定义的变量
- en: 'Python allows functions to access variables defined in any of its enclosing
    program units. These are called global variables, in contrast to local variables.
    The latter are only accessible within the function. For example, consider the
    following code:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Python允许函数访问其任何封装程序单元中定义的变量。这些被称为全局变量，与局部变量相对。后者仅在函数内部可访问。例如，考虑以下代码：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This feature should not be abused. The following code is an example of what
    not to do:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这种特性不应被滥用。以下代码是一个不应该做的例子：
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'When changing the variable `a` the function, `multiply` tacitly changes its
    behavior:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当更改变量`a`的函数`multiply`时，它隐式地改变了其行为：
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'It is much better in that case to provide the variable as a parameter through
    the argument list:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在那种情况下，最好通过参数列表将变量作为参数提供：
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Global variables can be useful when working with closures. Namespaces and scopes
    are discussed more extensively in [Chapter 11](ch11.html "Chapter 11. Namespaces,
    Scopes, and Modules"), *Namespaces, Scopes, and Modules*.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用闭包工作时，全局变量可能很有用。命名空间和作用域在[第11章](ch11.html "第11章。命名空间、作用域和模块")*命名空间、作用域和模块*中讨论得更为详细。
- en: Default arguments
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 默认参数
- en: Some functions can have many parameters, and among them some might only be of
    interest in nonstandard situations. It would be practical if arguments could automatically
    be set to standard (default) values. We demonstrate the use of default arguments
    by looking at the command `norm` in the `scipy.linalg` module. It computes various
    norms of matrices and vectors.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一些函数可能有多个参数，其中一些可能在非标准情况下才有兴趣。如果参数可以自动设置为标准（默认）值，那就实用了。我们通过查看`scipy.linalg`模块中的`norm`命令来演示默认参数的使用。它计算矩阵和向量的各种范数。
- en: 'The following snippet calls for computing the **Frobenius norm ** of the *3 ×
    3* identity matrix are equivalent (more on matrix norms can be found in [[10]](apa.html
    "Appendix . References") ):'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '以下代码片段要求计算**Frobenius范数**的*3×3*单位矩阵是等效的（有关矩阵范数的更多信息，请参阅[[10]](apa.html "附录。参考文献"))):'
- en: '[PRE11]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note that in the first call, no information about the `ord` keyword is given.
    How does Python know that it should compute the Frobenius norm and not another
    norm, for example, the Euclidean 2-norm?
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在第一次调用中，没有提供关于`ord`关键字的信息。Python是如何知道应该计算Frobenius范数而不是另一个范数，例如欧几里得2范数的？
- en: The answer to the previous question is the use of default values. A default
    value is a value already given by the function definition. If the function is
    called without providing this argument, Python uses the value that the programmer
    provided when the function was defined.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 之前问题的答案是使用默认值。默认值是函数定义中已经给出的值。如果函数调用时没有提供此参数，Python将使用程序员在定义函数时提供的值。
- en: 'Suppose we call the function `subtract` only one argument; we get an error
    message:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们只给`subtract`函数传递一个参数；我们会得到一个错误信息：
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To allow the omission of the argument `x2`, the definition of the function
    has to provide a default value, for example:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许省略参数`x2`，函数的定义必须提供一个默认值，例如：
- en: '[PRE13]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: To summarize, arguments can be given as positional arguments and keyword arguments.
    All positional arguments have to be given first. You do not need to provide all
    keyword arguments as long as those omitted arguments have default values in the
    function definition.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，参数可以作为位置参数和关键字参数提供。所有位置参数都必须首先提供。只要省略的参数在函数定义中有默认值，就不需要提供所有关键字参数。
- en: Beware of mutable default arguments
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小心可变默认参数
- en: 'The default arguments are set upon function definition. Changing mutable arguments
    inside a function has a side effect when working with default values, for example:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 默认参数是在函数定义时设置的。在处理默认值时，在函数内部更改可变参数会有副作用，例如：
- en: '[PRE14]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Variable number of arguments
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可变数量的参数
- en: 'Lists and dictionaries may be used to define or call functions with a variable
    number of arguments. Let''s define a list and a dictionary as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 列表和字典可以用来定义或调用具有可变数量参数的函数。让我们如下定义一个列表和一个字典：
- en: '[PRE15]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then we can call the `plot` function using starred (`*`) arguments:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用带星号的（`*`）参数调用`plot`函数：
- en: '[PRE16]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'A variable name prefixed by `*` , such as `*data` in the preceding example,
    means that a list that gets unpacked in the function call is provided. In this
    way, a list generates positional arguments. Similarly, a variable name prefixed
    by `**`, such as `**style` in the example, unpacks a dictionary to keyword arguments.
    Refer to the following figure (*Figure 7.1*):'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 以`*`开头的前缀变量名，例如前一个例子中的`*data`，表示在函数调用中提供的列表被解包。这样，列表生成位置参数。同样，以`**`开头的前缀变量名，例如例子中的`**style`，将字典解包为关键字参数。参考以下图示（*图7.1*）：
- en: '![Variable number of arguments](img/starred_arguments_on_call.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![变量数量参数](img/starred_arguments_on_call.jpg)'
- en: 'Figure 7.1: Starred arguments in function calls'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1：函数调用中的带星号参数
- en: You might also want to use the reverse process, where all given positional arguments
    are packed into a list and all keyword arguments are packed into a dictionary
    when passed to a function.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还想使用相反的过程，即当传递给函数时，所有给定的位置参数被打包成一个列表，所有关键字参数被打包成一个字典。
- en: In the function definition, this is indicated by parameters prefixed by `*` 
    and `**`, respectively. You will often find the `*args` and `**kwargs` parameters
    in code documentation, refer *Figure 7.2*.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数定义中，这通过分别以`*`和`**`开头的前缀参数来表示。你经常在代码文档中找到`*args`和`**kwargs`参数，参考*图7.2*。
- en: '![Variable number of arguments](img/starred_arguments_at_definition.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![变量数量参数](img/starred_arguments_at_definition.jpg)'
- en: 'Figure 7.2: Starred arguments in function definitions'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2：函数定义中的带星号参数
- en: Return values
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 返回值
- en: A function in Python always returns a single object. If a function has to return
    more than one object, these are packed and returned as a single tuple object.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的函数总是返回一个单一的对象。如果一个函数必须返回多个对象，这些对象会被打包并作为一个单一的元组对象返回。
- en: 'For instance, the following function takes a complex number *z* and returns
    its polar coordinate representation as magnitude *r* and angle ![Return values](img/varphi.jpg)
    according to Euler’s formula:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下函数接受一个复数*z*，并返回其极坐标表示，即模*r*和角度![返回值](img/varphi.jpg)，根据欧拉公式：
- en: '![Return values](img/euler.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![返回值](img/euler.jpg)'
- en: 'And the Python counterpart would be this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 而Python的对应写法会是这样的：
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, we used the `sqrt(x)` NumPy function for the square root of a number `x`
    and `arctan2(x,y)` for the expression tan^(-1)(*x/y*).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了NumPy的`sqrt(x)`函数来计算数字`x`的平方根，以及`arctan2(x,y)`来表示tan^(-1)(*x/y*)的表达式。
- en: 'Let us try our function:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试我们的函数：
- en: '[PRE18]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The last three statements can be written more elegantly in a single line:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 最后三个语句可以更优雅地写在一行中：
- en: '[PRE19]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We can test our function by calling `polar_to_comp`; refer to *Exercise 1*.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过调用`polar_to_comp`来测试我们的函数；参考*练习1*。
- en: 'If a function has no `return` statement, it returns the value `None`. There
    are many cases where a function does not need to return any value. This could
    be because the variables passed to a function may be subject to modification.
    Consider, for instance, the following function:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个函数没有 `return` 语句，它返回值 `None`。有许多情况下函数不需要返回任何值。这可能是因为传递给函数的变量可能受到修改。例如，考虑以下函数：
- en: '[PRE20]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The preceding function does not return anything because it modifies one of the
    objects that is given as an argument. We mentioned in *Parameters and Arguments*
    section why this is useful. There are many methods that behave in the same way.
    To mention the list methods only, the `append`, `extend`, `reverse`, and `sort`
    methods do not return anything (that is, they return `None` ). When an object
    is modified by a method in this way, the modification is called in-place. It is
    difficult to know whether a method changes an object, except by looking at the
    code or the documentation.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数不返回任何内容，因为它修改了作为参数给出的对象之一。我们在 *参数和参数* 部分提到了为什么这很有用。有许多方法以相同的方式表现。仅举列表方法为例，`append`、`extend`、`reverse`
    和 `sort` 方法不返回任何内容（即，它们返回 `None`）。当一个对象以这种方式被方法修改时，这种修改被称为就地修改。很难知道一个方法是否改变了对象，除非查看代码或文档。
- en: Another reason for a function, or a method, not to return anything is when it
    prints out a message or writes to a file.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 函数或方法不返回任何内容的另一个原因是当它打印消息或写入文件时。
- en: 'The execution stops at the first occurring `return` statement. Lines after
    that statement are dead code, which will never be executed:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 执行在第一个出现的 `return` 语句处停止。该语句之后的行是死代码，永远不会被执行：
- en: '[PRE21]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Recursive functions
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 递归函数
- en: In mathematics, many functions are defined recursively. In this section, we
    will show how this concept can be used even when programming a function. This
    makes the relation of the program to its mathematical counterpart very clear,
    which may ease the readability of the program.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在数学中，许多函数都是通过递归定义的。在本节中，我们将展示即使在编程一个函数时，这个概念也可以被使用。这使得程序与其数学对应物之间的关系非常清晰，这可能会使程序的可读性变得更容易。
- en: Nevertheless, we recommend that you use this programming technique with care,
    especially within scientific computing. In most applications, the more straightforward
    iterative approach is more efficient. This will become immediately clear from
    the following example.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，我们建议您在使用这种编程技术时要小心，尤其是在科学计算中。在大多数应用中，更直接的迭代方法更有效。这一点可以从下面的例子中立即看出。
- en: 'Chebyshev polynomials are defined by a three-term recursion:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 切比雪夫多项式通过一个三项递归定义：
- en: '![Recursive functions](img/chebychev.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![递归函数](img/chebychev.jpg)'
- en: Such a recursion needs to be initialized, that is, *T*[0](*x*) =1, *T*[1](*x*)
    = *x.*
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这种递归需要初始化，即 *T*[0](*x*) =1, *T*[1](*x*) = *x*。
- en: 'In Python, this three term recursion can be realized by the following function
    definition:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，这个三项递归可以通过以下函数定义实现：
- en: '[PRE22]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The function is then called like this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的调用方式如下：
- en: '[PRE23]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This example also illustrates the risk of dramatically wasting computation time.
    The number of function evaluations increases exponentially with the recursion
    level and most of these evaluations are just duplicates of previous computations.
    While it might be tempting to use recursive programs for demonstrating the strong
    relation between code and mathematical definition, a production code will avoid
    this programming technique (refer to *Exercise* 6). We also refer to a technique
    called memoization (refer to [[22]](apa.html "Appendix . References") for more
    details*)* that combines recursive programming with a caching technique to save
    replicated function evaluations.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子也说明了大量浪费计算时间的风险。函数评估的数量随着递归层级的增加而呈指数增长，其中大部分评估只是先前计算的重复。虽然使用递归程序来展示代码与数学定义之间强烈的关系可能很有吸引力，但生产代码将避免这种编程技术（参考
    *练习* 6）。我们还提到了一种称为记忆化的技术（参考 [[22]](apa.html "附录 . 参考文献") 以获取更多详细信息），它将递归编程与缓存技术相结合，以节省重复的函数评估。
- en: 'A recursive function usually has a level parameter. In the previous example,
    it is *n.* It is used to control the function''s  two main parts:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 递归函数通常有一个层级参数。在前面的例子中，它是 *n*。它用于控制函数的两个主要部分：
- en: The base case, here, the first two `if` branches
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本情况，这里的前两个 `if` 分支
- en: The recursive body, in which the function itself is called once or several times
    with smaller level parameters.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归体，其中函数本身一次或多次以较小的层级参数被调用。
- en: 'The number of levels passed by an execution of a recursive function is called
    the recursion depth. This quantity should not be too large; otherwise the computation
    might no longer be effective and in the ultimate case, the following error will
    be raised:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 递归函数执行过程中传递的层数称为递归深度。这个数量不应该太大；否则计算可能不再有效，在最终情况下，将引发以下错误：
- en: '[PRE24]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The maximal recursion depth depends on the memory of the computer you use. This
    error also occurs when the initialization step is missing in the function definition.
    We encourage the use of recursive programs for very small recursion depths (for
    more information, refer to the section *Infinite Iteration* of [Chapter 9](ch09.html
    "Chapter 9. Iterating"), *Iterating*.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 最大递归深度取决于您使用的计算机的内存。当函数定义中缺少初始化步骤时，也会发生此错误。我们鼓励在非常小的递归深度上使用递归程序（更多信息，请参阅第 9
    章 *无限迭代* 的 *迭代* 部分）。
- en: Function documentation
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数文档
- en: 'You should document your functions using a string at the beginning. This is
    called docstring:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该使用字符串在函数开头进行文档说明。这被称为文档字符串：
- en: '[PRE25]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'When calling `help(newton)`, you get this docstring displayed together with
    the call of this function:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用 `help(newton)` 时，您将看到此文档字符串与该函数的调用一起显示：
- en: '[PRE26]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The docstring is internally saved as an attribute, `__doc__`, of the given function.
    In the example, it's `newton.__doc__`. The minimal information you should provide
    in a docstring is the purpose of the function and the description of the input
    and output objects. There are tools to automatically generate full code documentation
    by collecting all docstrings in your program (for more information refer to [[32]](apa.html
    "Appendix . References")).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 文档字符串在内部被保存为给定函数的一个属性，`__doc__`。在示例中，它是 `newton.__doc__`。在文档字符串中，您应该提供的最基本信息是函数的目的以及输入和输出对象的描述。有工具可以自动通过收集程序中的所有文档字符串来生成完整的代码文档（更多信息请参阅
    [[32]](apa.html "附录 . 参考文献")）。
- en: Functions are objects
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数是对象
- en: 'Functions are objects, like everything else in Python. One may pass functions
    as arguments, change their names, or delete them. For example:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是对象，就像 Python 中的其他一切一样。可以传递函数作为参数，更改它们的名称，或者删除它们。例如：
- en: '[PRE27]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Passing functions as arguments is very common when applying algorithms in scientific
    computing. The functions `fsolve`  in `scipy.optimize` for computing a zero of
    a given function or `quad` in `scipy.integrate` for computing integrals are typical
    examples.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在科学计算中应用算法时，将函数作为参数传递是非常常见的。`scipy.optimize` 中的 `fsolve` 函数用于计算给定函数的零点，或者 `scipy.integrate`
    中的 `quad` 函数用于计算积分，这些都是典型的例子。
- en: A function itself can have a different number of arguments with differing types.
    So, when passing your function `f` to another function `g` as argument, make sure
    that `f` has exactly the form described in the docstring of `g`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 函数本身可以有不同数量的参数，这些参数类型不同。因此，当将您的函数 `f` 作为参数传递给另一个函数 `g` 时，请确保 `f` 的形式与 `g` 的文档字符串中描述的完全一致。
- en: 'The docstring of `fsolve`  gives information about its `func` parameter:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`fsolve` 的文档字符串提供了关于其 `func` 参数的信息：'
- en: '[PRE28]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Partial application
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部分应用
- en: Let's start with an example of a function with two variables.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从具有两个变量的函数的例子开始。
- en: 'The function ![Partial application](img/fullsine.jpg)can be viewed as a function
    in two variables. Often one considers ω not as a free variable but as a fixed
    parameter of a family of functions *f*[ω]:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 ![部分应用](img/fullsine.jpg) 可以被视为一个关于两个变量的函数。通常，人们将 ω 不视为一个自由变量，而是将作为一个函数族
    *f*[ω] 的固定参数：
- en: '![Partial application](img/partialsine.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![部分应用](img/partialsine.jpg)'
- en: This interpretation reduces a function in two variables to a function in one
    variable, `t`, given a fixed parameter value *ω*. The process of defining a new
    function by fixing (freezing) one or several parameters of a function is called
    partial application.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这种解释将两个变量的函数简化为一个变量 `t` 的函数，给定一个固定的参数值 *ω*。通过固定（冻结）函数的一个或多个参数来定义新函数的过程称为部分应用。
- en: 'Partial applications are easily created using the Python module `functools`,
    which provides a function called `partial` for precisely this purpose. We illustrate
    this by constructing a function that returns a sine for a given frequency:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Python 模块 `functools` 可以轻松创建部分应用，该模块提供了一个名为 `partial` 的函数，专门为此目的。我们通过构建一个返回给定频率的正弦函数的函数来说明这一点：
- en: '[PRE29]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Using Closures
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用闭包
- en: 'Using the view that functions are objects, partial applications can be realized
    by writing a function, which itself returns a new function, with a reduced number
    of input arguments. For instance, the function could be defined as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 使用函数是对象的观点，可以通过编写一个函数，该函数本身返回一个新的函数，具有较少的输入参数来实现部分应用。例如，该函数可以定义为以下形式：
- en: '[PRE30]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In this example the inner function `mysine` has access to the variable `freq`;
    it is neither a local variable of this function nor is it passed to it via the
    argument list. Python allows such a construction (refer to *Namespaces* section
    in [Chapter 11](ch11.html "Chapter 11. Namespaces, Scopes, and Modules"), *Namespaces,
    Scopes, and Modules*).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，内部函数`mysine`可以访问变量`freq`；它既不是该函数的局部变量，也不是通过参数列表传递给它的。Python允许这种构造（请参阅[第11章](ch11.html
    "第11章。命名空间、作用域和模块")中的*命名空间*部分，*命名空间、作用域和模块*）。
- en: Anonymous functions - the  lambda keyword
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 匿名函数 - lambda 关键字
- en: The keyword lambda is used in Python to define anonymous functions, that is;
    functions without a name and described by a single expression. You might just
    want to perform an operation on a function that can be expressed by a simple expression
    without naming this function and without defining this function by a lengthy `def`
    block.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，关键字lambda用于定义匿名函数，即没有名称且由单个表达式描述的函数。你可能只想对一个可以用简单表达式表示的操作进行操作，而不需要命名这个函数，也不需要通过冗长的`def`块来定义这个函数。
- en: Note
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The name *lambda* originates from a special branch of calculus and mathematical
    logic, the ![Anonymous functions - the  lambda keyword](img/lambda.jpg)-calculus.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 名称*lambda*起源于微积分和数学逻辑的一个特殊分支，即![匿名函数 - lambda 关键字](img/lambda.jpg)-微积分。
- en: 'For instance, to compute the following expression, we may use SciPy’s function
    `quad`, which requires the function to be integrated as its first argument and
    the integration bounds as the next two arguments:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要计算以下表达式，我们可以使用SciPy的函数`quad`，它需要将待积分的函数作为第一个参数，积分界限作为接下来的两个参数：
- en: '![Anonymous functions - the  lambda keyword](img/B05511_07_02.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![匿名函数 - lambda 关键字](img/B05511_07_02.jpg)'
- en: 'Here, the function to integrate is just a simple one-liner and we use the `lambda`
    keyword to define it:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，要积分的函数只是一个简单的单行函数，我们使用`lambda`关键字来定义它：
- en: '[PRE31]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The syntax is as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 语法如下：
- en: '[PRE32]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The definition of the `lambda` function can only consist of a single expression
    and in particular, cannot contain loops. `lambda` functions are, just like other
    functions, objects and can be assigned to variables:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`lambda`函数的定义只能由一个表达式组成，并且特别不能包含循环。`lambda`函数就像其他函数一样，是对象，可以被分配给变量：'
- en: '[PRE33]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The lambda construction is always replaceable
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: lambda 构造总是可以替换的
- en: 'It is important to note that lambda construction is only syntactic sugar in
    Python. Any lambda construction may be replaced by an explicit function definition:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，lambda 构造在Python中只是语法糖。任何lambda构造都可以用显式的函数定义来替换：
- en: '[PRE34]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The main reason to use a construction is for very simple functions, when a full
    function definition would be too cumbersome.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种构造的主要原因是对于非常简单的函数，当完整的函数定义过于繁琐时。
- en: '`lambda` functions provide a third way to make closures as we demonstrate by
    continuing with the previous example:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`lambda`函数提供了一种创建闭包的第三种方法，正如我们在上一个示例中继续展示的那样：'
- en: 'We use the `sin_omega` function to compute the integral of the sine function
    for various frequencies:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`sin_omega`函数来计算不同频率的正弦函数的积分：
- en: '[PRE35]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Functions as decorators
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数作为装饰器
- en: 'In the partial application section, we saw how a function can be used to modify
    another function. A decorator is a syntax element in Python that conveniently
    allows us to alter the behavior of a function without changing the definition
    of the function itself. Let us start with the following situation:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在部分应用部分，我们看到了如何使用一个函数来修改另一个函数。装饰器是Python中的一个语法元素，它方便地允许我们改变函数的行为，而无需更改函数本身的定义。让我们从一个以下情况开始：
- en: 'Assume that we have a function that determines the degree of sparsity of a
    matrix:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个函数，用于确定矩阵的稀疏程度：
- en: '[PRE36]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This function returns an error if it is not called with an array object as
    input. More precisely, it will not work with an object that does not implement
    the `reshape` method. For instance, the `how_sparse` function will not work with
    a list, because lists have no `reshape` method. The following helper function
    modifies any function with one input parameter so that it tries to make a type
    conversion to an array:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个函数不是用数组对象作为输入调用，它将返回错误。更确切地说，它将无法与不实现 `reshape` 方法的对象一起工作。例如，`how_sparse`
    函数将无法与列表一起工作，因为列表没有 `reshape` 方法。以下辅助函数修改任何只有一个输入参数的函数，使其尝试将类型转换为数组：
- en: '[PRE37]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Thus, the modified function `how_sparse = cast2array(how_sparse)` can be applied
    to any object that can be cast to an array. The same functionality is achieved
    if the definition of `how_sparse` is decorated with the type conversion function.
    It is recommend also to consider the `functools.wraps` (refer to [[8]](apa.html
    "Appendix . References") for more details):'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，修改后的函数 `how_sparse = cast2array(how_sparse)` 可以应用于任何可以转换为数组的对象。如果 `how_sparse`
    的定义用类型转换函数装饰，也可以实现相同的功能。还建议考虑使用 `functools.wraps`（有关更多详细信息，请参阅 [[8]](apa.html
    "附录 . 参考文献"))：
- en: '[PRE38]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'To define a decorator, you need a callable object such as a function that modifies
    the definition of the function to be decorated. The main purposes are:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义一个装饰器，你需要一个可调用对象，例如一个函数，它修改要装饰的函数的定义。主要目的是：
- en: To increase code readability by separating parts from a function that do not
    directly serve its functionality (for example, memoizing)
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将不直接服务于函数功能的部分（例如，缓存）从函数中分离出来，可以增加代码的可读性。
- en: To put common preamble and epilogue parts of a family of similar functions in
    a common place (for example, type checking)
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将一组类似函数的共同前导和后置部分放在一个共同的地方（例如，类型检查）。
- en: To be able to easily switch off and on additional functionalities of a function
    (for example, test prints, tracing)
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够轻松地开启和关闭函数的附加功能（例如，测试打印，跟踪）。
- en: Summary
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Functions are not only the ideal tools for making your program modular, but
    they also reflect mathematical thinking. You learned the syntax of function definitions
    and to distinguish between defining and calling a function.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 函数不仅是使你的程序模块化的理想工具，而且也反映了数学思维。你学习了函数定义的语法，以及如何区分定义和调用函数。
- en: We considered functions as objects that can be modified by other functions.
    When working with functions, it is important to be familiar with the notion of
    the scope of a variable and how information is passed into a function by parameters.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将函数视为可以被其他函数修改的对象。在处理函数时，了解变量的作用域以及信息如何通过参数传递到函数中是很重要的。
- en: Sometimes, it is convenient to define functions on the fly with so-called anonymous
    functions. For this, we introduced the keyword lambda.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，使用所谓的匿名函数动态定义函数是很方便的。为此，我们引入了关键字 lambda。
- en: Exercises
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: '**Ex 1** → Write a function `polar_to_comp`, which takes two arguments *r*
    and ![Exercises](img/varphi.jpg) and returns the complex number ![Exercises](img/euler.jpg)
    Use the NumPy function `exp` for the exponential function.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '**例 1** → 编写一个函数 `polar_to_comp`，它接受两个参数 *r* 和 ![Exercises](img/varphi.jpg)，并返回复数
    ![Exercises](img/euler.jpg)。使用 NumPy 函数 `exp` 进行指数函数。'
- en: '**Ex 2** → In the description of the Python module `functools`, (refer to [[8]](apa.html
    "Appendix . References") for more detail on functools) you find the following
    Python function:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '**例 2** → 在 Python 模块 `functools` 的描述中（有关 `functools` 的更多详细信息，请参阅 [[8]](apa.html
    "附录 . 参考文献"))，你可以找到以下 Python 函数：'
- en: '[PRE39]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Explain and test this function.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 解释并测试这个函数。
- en: '**Ex 3** → Write a decorator for the function `how_sparse`,  which cleans the
    input matrix *A* by setting the elements that are less than 1.e-16 to zero (consider
    example in section *Function as decorators*).'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '**例 3** → 为函数 `how_sparse` 编写一个装饰器，该装饰器通过将小于 1.e-16 的元素设置为零来清理输入矩阵 *A*（考虑 *函数作为装饰器*
    部分的示例）。'
- en: '**Ex 4** → A continuous function *f* with *f*(*a*)*f*(*b*) < 0 changes its
    sign in the interval [*a, b*] and has at least one root (zero) in this interval.
    Such a root can be found with the bisection method. This method starts from the
    given interval. Then it investigates the sign changes in the subintervals,'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '**例 4** → 一个连续函数 *f*，其中 *f*(*a*)*f*(*b*) < 0 在区间 [*a, b*] 内改变其符号，并且在这个区间内至少有一个根（零）。这样的根可以用二分法找到。这种方法从给定的区间开始。然后它调查子区间中的符号变化，'
- en: '![Exercises](img/subintervals.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![Exercises](img/subintervals.jpg)'
- en: 'If the sign changes in the first subinterval *b* is redefined to be:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果第一个子区间 *b* 中的符号变化被重新定义为：
- en: '![Exercises](img/B05511_07_05.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![练习](img/B05511_07_05.jpg)'
- en: 'Otherwise, it is redefined in the same manner to:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，它将以相同的方式重新定义：
- en: '![Exercises](img/B05511_07_06.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![练习](img/B05511_07_06.jpg)'
- en: And the process is repeated until the *b-a* is less than a given tolerance.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 并且重复这个过程，直到 *b-a* 小于给定的容差。
- en: 'Implement this method as a function that takes as arguments:'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将此方法实现为一个函数，该函数接受以下参数：
- en: – the function *f*
  id: totrans-179
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: – 函数 *f*
- en: – the initial interval [*a, b*]
  id: totrans-180
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: – 初始区间 [*a, b*]
- en: – the tolerance
  id: totrans-181
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: – 容差
- en: This function `bisec` should return the final interval and its midpoint.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个函数 `bisec` 应该返回最终区间及其中点。
- en: Test the method with the function `arctan` and also with the polynomial *f(x)
    = 3 x² -5* in the interval [1.1, 1.4]*,* and alternatively in [1.3, 1.4].
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用函数 `arctan` 和多项式 *f(x) = 3 x² -5* 在区间 [1.1, 1.4]*，*以及交替在 [1.3, 1.4]。
- en: '**Ex. 5** → The greatest common divisor of two integers can be computed with
    Euclid’s algorithm described by the following recursion:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '**例 5** → 两个整数的最大公约数可以使用以下递归描述的欧几里得算法计算：'
- en: '![Exercises](img/B05511_07_07.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![练习](img/B05511_07_07.jpg)'
- en: 'Write a function that computes the greatest common divisor of two integers.
    Write another function that computes the least common multiple of these numbers
    using the relation:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个函数，计算两个整数的最大公约数。再编写另一个函数，使用以下关系计算这些数的最小公倍数：
- en: '![Exercises](img/B05511_07_08.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![练习](img/B05511_07_08.jpg)'
- en: '**Ex. 6** → Study the recursive implementation of Chebyshev polynomials, consider
    the example in section *Recursive Function*. Rewrite the program in a non-recursive
    way and study computation time versus polynomial degree (see also the `timeit`
    module).'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '**例 6** → 研究切比雪夫多项式的递归实现，考虑 *递归函数* 章节中的例子。将程序以非递归方式重写，并研究计算时间与多项式次数的关系（也请参阅
    `timeit` 模块）。'
