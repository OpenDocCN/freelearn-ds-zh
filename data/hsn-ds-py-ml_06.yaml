- en: Recommender Systems
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 推荐系统
- en: Let's talk about my personal area of expertiseâ€”recommender systems, so systems
    that can recommend stuff to people based on what everybody else did. We'll look
    at some examples of this and a couple of ways to do it. Specifically, two techniques
    called user-based and item-based collaborative filtering. So, let's dive in.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们谈谈我个人的专业领域——推荐系统，即可以根据其他人的行为向人们推荐东西的系统。我们将看一些例子以及几种方法。具体来说，两种叫做基于用户和基于物品的协同过滤技术。所以，让我们深入了解一下。
- en: 'I spent most of my career at [amazon.com](http://amazon.com) and [imdb.com](http://imdb.com),
    and a lot of what I did there was developing recommender systems; things like
    *people who bought this also bought*, or *recommended for you*, and things that
    did movie recommendations for people. So, this is something I know a lot about
    personally, and I hope to share some of that knowledge with you. We''ll walk through,
    step by step, covering the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我在[amazon.com](http://amazon.com)和[imdb.com](http://imdb.com)大部分职业生涯都在那里度过，我在那里做的很多工作都是开发推荐系统；比如*购买这个的人也购买了*，或者*为你推荐*，以及为人们推荐电影的东西。所以，这是我个人非常了解的东西，我希望能与你们分享一些这方面的知识。我们将逐步讲解以下主题：
- en: What are recommender systems?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是推荐系统？
- en: User-based collaborative filtering
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于用户的协同过滤
- en: Item-based collaborative filtering
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于物品的协同过滤
- en: Finding movie similarities
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寻找电影的相似之处
- en: Making movie recommendations to people
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向人们推荐电影
- en: Improving the recommender's results
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改进推荐系统的结果
- en: What are recommender systems?
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是推荐系统？
- en: Well, like I said Amazon is a great example, and one I'm very familiar with.
    So, if you go to their recommendations section, as shown in the following image,
    you can see that it will recommend things that you might be interested in purchasing
    based on your past behavior on the site.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，就像我说的，亚马逊是一个很好的例子，我对此非常熟悉。所以，如果你去他们的推荐部分，就像下面的图片所示，你会看到它会根据你在网站上的过去行为推荐你可能感兴趣的购买物品。
- en: '![](img/e3f5a477-dc07-4d71-91b0-2e162b81c327.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e3f5a477-dc07-4d71-91b0-2e162b81c327.png)'
- en: The recommender system might include things that you've rated, or things that
    you bought, and other data as well. I can't go into the details because they'll
    hunt me down, and you know, do bad things to me. But, it's pretty cool. You can
    also think of the *people who bought this also bought* feature on Amazon as a
    form of recommender system.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 推荐系统可能包括你评价过的东西，或者你购买过的东西，以及其他数据。我不能详细说明，因为他们会追捕我，你知道，对我做坏事。但是，这很酷。你也可以把亚马逊上的*购买这个的人也购买了*功能看作是一种推荐系统。
- en: The difference is that the recommendations you're seeing on your Amazon recommendations
    page are based on all of your past behavior, whereas people *who bought this also
    bought* or *people who viewed this also viewed*, things like that, are just based
    on the thing you're looking at right now, and showing you things that are similar
    to it that you might also be interested in. And, it turns out, what you're doing
    right now is probably the strongest signal of your interest anyhow.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 不同之处在于你在亚马逊推荐页面上看到的推荐是基于你的所有过去行为，而*购买这个的人也购买了*或*浏览这个的人也浏览了*之类的东西，只是基于你现在正在看的东西，向你展示与之相似的东西，你可能也会感兴趣。而且，结果表明，你现在正在做的事情可能是你兴趣最强烈的信号。
- en: 'Another example is from Netflix, as shown in the following image (the following
    image is a screenshot from Netflix):'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子来自Netflix，就像下面的图片所示（下面的图片是Netflix的截图）：
- en: '![](img/f8319d5d-76ea-47f6-9d37-d54a0170f30b.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f8319d5d-76ea-47f6-9d37-d54a0170f30b.png)'
- en: They have various features that try to recommend new movies or other movies
    you haven't seen yet, based on the movies that you liked or watched in the past
    as well, and they break that down by genre. They have kind of a different spin
    on things, where they try to identify the genres or the types of movies that they
    think you're enjoying the most and they then show you more results from those
    genres. So, that's another example of a recommender system in action.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 他们有各种功能，试图根据你以前喜欢或观看的电影来推荐新电影或其他你还没有看过的电影，并且他们会按类型进行分类。他们有一种不同的方式，他们试图确定你最喜欢的电影类型，然后向你展示更多来自这些类型的结果。所以，这是推荐系统在行动中的另一个例子。
- en: The whole point of it is to help you discover things you might not know about
    before, so it's pretty cool. You know, it gives individual movies, or books, or
    music, or whatever, a chance to be discovered by people who might not have heard
    about them before. So, you know, not only is it cool technology, it also kind
    of levels the playing field a little bit, and helps new items get discovered by
    the masses. So, it plays a very important role in today's society, at least I'd
    like to think so! There are few ways of doing this, and we'll look at the main
    ones in this chapter.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 它的整个目的是帮助你发现以前可能不知道的东西，所以这很酷。你知道，它给了个别电影、书籍、音乐或其他东西一个被那些以前可能没有听说过的人发现的机会。所以，你知道，它不仅是很酷的技术，它也在某种程度上平衡了竞争，帮助新物品被大众发现。所以，它在当今社会扮演着非常重要的角色，至少我是这么认为的！有几种方法可以做到这一点，我们将在本章中看到主要的方法。
- en: User-based collaborative filtering
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于用户的协同过滤
- en: 'First, let''s talk about recommending stuff based on your past behavior. One
    technique is called user-based collaborative filtering, and here''s how it works:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们谈谈基于你过去行为推荐东西的方法。一种技术叫做基于用户的协同过滤，它是这样工作的：
- en: Collaborative filtering, by the way, is just a fancy name for saying recommending
    stuff based on the combination of what you did and what everybody else did, okay?
    So, it's looking at your behavior and comparing that to everyone else's behavior,
    to arrive at the things that might be interesting to you that you haven't heard
    of yet.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，协同过滤只是一个花哨的说法，意思是根据你的行为和其他人的行为的组合来推荐东西，好吗？所以，它是在研究你的行为并将其与其他人的行为进行比较，以得出可能对你感兴趣但你还没有听说过的东西。
- en: The idea here is we build up a matrix of everything that every user has ever
    bought, or viewed, or rated, or whatever signal of interest that you want to base
    the system on. So basically, we end up with a row for every user in our system,
    and that row contains all the things they did that might indicate some sort of
    interest in a given product. So, picture a table, I have users for the rows, and
    each column is an item, okay? That might be a movie, a product, a web page, whatever;
    you can use this for many different things.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里的想法是我们建立一个矩阵，记录每个用户曾经购买、查看、评分或者其他你想要基于的兴趣信号的一切。所以基本上，我们的系统中有一个用户的行，该行包含了他们可能对某个产品感兴趣的所有事情。所以，想象一张表，我有用户的行，每一列是一个项目，好吗？这可能是一部电影，一个产品，一个网页，无论什么；你可以用这个做很多不同的事情。
- en: I then use that matrix to compute the similarity between different users. So,
    I basically treat each row of this as a vector and I can compute the similarity
    between each vector of users, based on their behavior.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我使用该矩阵来计算不同用户之间的相似性。所以，我基本上将这个矩阵的每一行都视为一个向量，我可以根据他们的行为计算用户之间的相似性。
- en: Two users who liked mostly the same things would be very similar to each other
    and I can then sort this by those similarity scores. If I can find all the users
    similar to you based on their past behavior, I can then find the users most similar
    to me, and recommend stuff that they liked that I didn't look at yet.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 大部分喜欢相同东西的两个用户会非常相似，然后我可以根据这些相似性分数进行排序。如果我可以找到所有与你相似的用户，基于他们的过去行为，我就可以找到与我最相似的用户，并推荐他们喜欢但我还没看过的东西。
- en: 'Let''s look at a real example, and it''ll make a little bit more sense:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个真实的例子，这样可能会更有意义：
- en: '![](img/6934cbac-7e47-42d5-b5ab-de9465b3144d.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6934cbac-7e47-42d5-b5ab-de9465b3144d.png)'
- en: Let's say that this nice lady in the preceding image watched Star Wars and The
    Empire Strikes Back and she loved them both. So, we have a user vector, of this
    lady, giving a 5-star rating to Star Wars and The Empire Strikes Back.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 假设在前面的例子中，这位可爱的女士看了《星球大战》和《帝国反击战》，她都很喜欢。所以，我们有一个用户向量，这位女士给《星球大战》和《帝国反击战》都打了5星的评分。
- en: Let's also say Mr. Edgy Mohawk Man comes along and he only watched Star Wars.
    That's the only thing he's seen, he doesn't know about The Empire Strikes Back
    yet, somehow, he lives in some strange universe where he doesn't know that there
    are actually many, many Star Wars movies, growing every year in fact.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 假设Edgy Mohawk先生来了，他只看了《星球大战》。这是他唯一看过的东西，他不知道《帝国反击战》还没有看过，不知何故，他生活在一个奇怪的宇宙里，他不知道实际上有很多很多《星球大战》电影，事实上每年都在增加。
- en: We can of course say that this guy's actually similar to this other lady because
    they both enjoyed Star Wars a lot, so their similarity score is probably fairly
    good and we can say, okay, well, what has this lady enjoyed that he hasn't seen
    yet? And, The Empire Strikes Back is one, so we can then take that information
    that these two users are similar based on their enjoyment of Star Wars, find that
    this lady also liked The Empire Strikes Back, and then present that as a good
    recommendation for Mr. Edgy Mohawk Man.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以说这个家伙实际上与另一个女士相似，因为他们都非常喜欢《星球大战》，所以他们的相似性分数可能相当高，我们可以说，好吧，这位女士喜欢的他还没看过什么？《帝国反击战》就是其中之一，所以我们可以根据他们对《星球大战》的喜爱找到这位女士也喜欢《帝国反击战》，然后将其作为对Edgy
    Mohawk先生的良好推荐。
- en: We can then go ahead and recommend The Empire Strikes Back to him and he'll
    probably love it, because in my opinion, it's actually a better film! But I'm
    not going to get into geek wars with you here.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以向他推荐《帝国反击战》，他可能会喜欢，因为在我看来，这实际上是一部更好的电影！但我不打算在这里和你进行极客之争。
- en: Limitations of user-based collaborative filtering
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于用户的协同过滤的限制
- en: 'Now, unfortunately, user-based collaborative filtering has some limitations.
    When we think about relationships and recommending things based on relationships
    between items and people and whatnot, our mind tends to go on relationships between
    people. So, we want to find people that are similar to you and recommend stuff
    that they liked. That''s kind of the intuitive thing to do, but it''s not the
    best thing to do! The following is the list of some limitations of user-based
    collaborative filtering:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，基于用户的协同过滤有一些限制。当我们考虑基于物品和人之间的关系来推荐东西时，我们的思维往往会转向人与人之间的关系。所以，我们想要找到与你相似的人，并推荐他们喜欢的东西。这似乎是直观的做法，但并不是最好的做法！以下是基于用户的协同过滤的一些限制：
- en: One problem is that people are fickle; their tastes are always changing. So,
    maybe that nice lady in the previous example had sort of a brief science fiction
    action film phase that she went through and then she got over it, and maybe later
    in her life she started getting more into dramas or romance films or romcoms.
    So, what would happen if my Edgy Mohawk guy ended up with a high similarity to
    her just based on her earlier sci-fi period, and we ended up recommending romantic
    comedies to him as a result? That would be bad. I mean, there is some protection
    against that in terms of how we compute the similarity scores to begin with, but
    it still pollutes our data that people's tastes can change over time. So, comparing
    people to people isn't always a straightforward thing to do, because people change.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个问题是人们喜新厌旧；他们的口味总是在变化。所以，也许在前面的例子中，这位可爱的女士经历了一段短暂的科幻动作电影阶段，然后她克服了这一阶段，也许后来她开始更喜欢戏剧或者浪漫电影或者爱情喜剧。所以，如果我的Edgy
    Mohawk先生基于她早期的科幻时期与她有很高的相似性，然后我们因此向他推荐了浪漫喜剧，那将是糟糕的。我的意思是，在我们计算相似性分数的方式上，对此有一些保护，但人们的口味随时间变化仍然会污染我们的数据。所以，比较人与人之间并不总是一件简单的事情，因为人们会改变。
- en: The other problem is that there's usually a lot more people than there are things
    in your system, so 7 billion people in the world and counting, there's probably
    not 7 billion movies in the world, or 7 billion items that you might be recommending
    out of your catalog. The computational problem finding all the similarities between
    all of the users in your system is probably much greater than the problem of finding
    similarities between the items in your system. So, by focusing the system on users,
    you're making your computational problem a lot harder than it might need to be,
    because you have a lot of users, at least hopefully you do if you're working for
    a successful company.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个问题是在你的系统中通常会有比物品更多的人，全球有70亿人口，而且还在增加，世界上可能并不会有70亿部电影，或者你的目录中可能不会有70亿个物品需要推荐。在你的系统中找到所有用户之间的相似性可能比找到物品之间的相似性更困难。因此，通过将系统重点放在用户上，你让计算问题变得更加困难，因为你有很多用户，至少希望如此，如果你在一家成功的公司工作的话。
- en: The final problem is that people do bad things. There's a very real economic
    incentive to make sure that your product or your movie or whatever it is gets
    recommended to people, and there are people who try to game the system to make
    that happen for their new movie, or their new product, or their new book, or whatever.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一个问题是人们会做坏事。确保你的产品、电影或其他任何东西被推荐给人们有着非常现实的经济激励，有些人会试图操纵系统，让他们的新电影、新产品或新书等被推荐。
- en: It's pretty easy to fabricate fake personas in the system by creating a new
    user and having them do a sequence of events that likes a lot of popular items
    and then likes your item too. This is called a **shilling attack**, and we want
    to ideally have a system that can deal with that.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在系统中制造假身份非常容易，只需创建一个新用户，让他们执行一系列喜欢很多流行物品的事件，然后也喜欢你的物品。这被称为**炒作攻击**，我们希望能够拥有一个能够处理这种情况的系统。
- en: There is research around how to detect and avoid these shilling attacks in user-based
    collaborative filtering, but an even better approach would be to use a totally
    different approach entirely that's not so susceptible to gaming the system.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 关于如何检测和避免基于用户的协同过滤中的炒作攻击有研究，但更好的方法是使用一种完全不容易被操纵系统的全新方法。
- en: That's user-based collaborative filtering. Again, it's a simple concept-you
    look at similarities between users based on their behavior, and recommend stuff
    that a user enjoyed that was similar to you, that you haven't seen yet. Now, that
    does have its limitations as we talked about. So, let's talk about flipping the
    whole thing on its head, with a technique called item-based collaborative filtering.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是基于用户的协同过滤。再次强调，这是一个简单的概念-你根据用户的行为相似性来推荐东西，推荐那些你还没有看过但与你喜欢的东西相似的东西。正如我们所讨论的，这也有其局限性。因此，让我们来谈谈用一种称为基于物品的协同过滤的技术来颠覆整个概念。
- en: Item-based collaborative filtering
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于物品的协同过滤
- en: Let's now try to address some of the shortcomings in user-based collaborative
    filtering with a technique called item-based collaborative filtering, and we'll
    see how that can be more powerful. It's actually one of the techniques that Amazon
    uses under the hood, and they've talked about this publicly so I can tell you
    that much, but let's see why it's such a great idea. With user-based collaborative
    filtering we base our recommendations on relationships between people, but what
    if we flip that and base them on relationships between items? That's what item-based
    collaborative filtering is.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们尝试用一种称为基于物品的协同过滤的技术来解决基于用户的协同过滤的一些缺点，我们将看到这种技术是如何更加强大的。实际上，这是亚马逊在幕后使用的技术之一，他们公开谈论过这一点，所以我可以告诉你这么多，但让我们看看为什么这是一个如此好的主意。基于用户的协同过滤是基于人与人之间的关系来进行推荐的，但如果我们将其转变为基于物品之间的关系呢？这就是基于物品的协同过滤。
- en: Understanding item-based collaborative filtering
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解基于物品的协同过滤
- en: This is going to draw on a few insights. For one thing, we talked about people
    being fickle-their tastes can change over time, so comparing one person to another
    person based on their past behavior becomes pretty complicated. People have different
    phases where they have different interests, and you might not be comparing the
    people that are in the same phase to each other. But, an item will always be whatever
    it is. A movie will always be a movie, it's never going to change. Star Wars will
    always be Star Wars, well until George Lucas tinkers with it a little bit, but
    for the most part, items do not change as much as people do. So, we know that
    these relationships are more permanent, and there's more of a direct comparison
    you can make when computing similarity between items, because they do not change
    over time.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这将涉及到一些见解。首先，我们谈到人们喜新厌旧，他们的口味会随时间改变，因此基于他们的过去行为来比较一个人和另一个人变得非常复杂。人们有不同的阶段，他们有不同的兴趣，你可能不会将处于相同阶段的人进行比较。但是，物品永远是什么它是的。一部电影永远是一部电影，它永远不会改变。星球大战永远是星球大战，至少在乔治·卢卡斯稍微改动一下之前是这样的，但总的来说，物品不会像人一样改变。因此，我们知道这些关系更加持久，而且在计算物品之间的相似性时可以进行更直接的比较，因为它们随时间不会改变。
- en: The other advantage is that there are generally fewer things that you're trying
    to recommend than there are people you're recommending to. So again, 7 billion
    people in the world, you're probably not offering 7 billion things on your website
    to recommend to them, so you can save a lot of computational resources by evaluating
    relationships between items instead of users, because you will probably have fewer
    items than you have users in your system. That means you can run your recommendations
    more frequently, make them more current, more up-to-date, and better! You can
    use more complicated algorithms because you have less relationships to compute,
    and that's a good thing!
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个优势是，通常你要推荐的东西比你要推荐给的人要少。所以，全世界有70亿人，你的网站上可能并不会有70亿个推荐的东西，所以通过评估物品之间的关系而不是用户之间的关系，你可以节省大量的计算资源，因为你的系统中物品的数量可能比用户的数量要少。这意味着你可以更频繁地运行推荐，使它们更加及时、更加更新、更好！你可以使用更复杂的算法，因为你需要计算的关系更少，这是一件好事！
- en: It's also harder to game the system. So, we talked about how easy it is to game
    a user-based collaborative filtering approach by just creating some fake users
    that like a bunch of popular stuff and then the thing you're trying to promote.
    With item-based collaborative filtering that becomes much more difficult. You
    have to game the system into thinking there are relationships between items, and
    since you probably don't have the capability to create fake items with fake ties
    to other items based on many, many other users, it's a lot harder to game an item-based
    collaborative filtering system, which is a good thing.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 操纵系统也更难。我们谈到了通过创建一些喜欢流行东西的假用户然后推广你想要推广的东西来操纵基于用户的协同过滤方法是多么容易。但是基于物品的协同过滤变得更加困难。你必须让系统相信物品之间存在关系，而且由于你可能没有能力根据许多其他用户创建假物品并与其他物品建立虚假关系，操纵基于物品的协同过滤系统就变得更加困难，这是一件好事。
- en: While I'm on the topic of gaming the system, another important thing is to make
    sure that people are voting with their money. A general technique for avoiding
    shilling attacks or people trying to game your recommender system, is to make
    sure that the signal behavior is based on people actually spending money. So,
    you're always going to get better and more reliable results when you base recommendations
    on what people actually bought, as opposed to what they viewed or what they clicked
    on, okay?
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当我谈到操纵系统时，另一件重要的事情是确保人们用自己的钱投票。避免刷单攻击或人们试图操纵你的推荐系统的一般技术是确保信号行为是基于人们实际花钱的。因此，当你基于人们实际购买的东西而不是他们浏览或点击的东西进行推荐时，你总是会得到更好、更可靠的结果，明白吗？
- en: How item-based collaborative filtering works?
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于物品的协同过滤是如何工作的？
- en: Alright, let's talk about how item-based collaborative filtering works. It's
    very similar to user-based collaborative filtering, but instead of users, we're
    looking at items.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，让我们来谈谈基于物品的协同过滤是如何工作的。它与基于用户的协同过滤非常相似，但我们不是看用户，而是看物品。
- en: So, let's go back to the example of movie recommendations. The first thing we
    would do is find every pair of movies that is watched by the same person. So,
    we go through and find every movie that was watched by identical people, and then
    we measure the similarity of all those people who viewed that movie to each other.
    So, by this means we can compute similarities between two different movies, based
    on the ratings of the people who watched both of those movies.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们回到电影推荐的例子。我们首先要做的是找到每一对被同一个人观看的电影。然后，我们测量所有观看过这部电影的人之间的相似性。通过这种方式，我们可以根据观看过这两部电影的人的评分来计算两部不同电影之间的相似性。
- en: So, let's presume I have a movie pair, okay? Maybe Star Wars and The Empire
    Strikes Back. I find a list of everyone who watched both of those movies, then
    I compare their ratings to each other, and if they're similar then I can say these
    two movies are similar, because they were rated similarly by people who watched
    both of them. That's the general idea here. That's one way to do it, there's more
    than one way to do it!
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，假设我有一对电影，好吧？也许是《星球大战》和《帝国反击战》。我找到了所有观看过这两部电影的人的名单，然后我比较他们对这两部电影的评分，如果他们相似，那么我可以说这两部电影是相似的，因为观看过它们的人对它们的评分相似。这是这里的一般想法。这是一种方法，有多种方法可以做到！
- en: And then I can just sort everything by the movie, and then by the similarity
    strength of all the similar movies to it, and there's my results for *people who
    liked also liked*, or *people who rated this highly also rated this highly* and
    so on and so forth. And like I said, that's just one way of doing it.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我可以按电影对一切进行排序，然后按相似电影的相似度强度进行排序，这就是我得到的*喜欢这个也喜欢那个*或*给这个高评分的人也给这个高评分*等等的结果。就像我说的，这只是一种方法。
- en: 'That''s step one of item-based collaborative filtering-first I find relationships
    between movies based on the relationships of the people who watched every given
    pair of movies. It''ll make more sense when we go through the following example:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这是基于物品的协同过滤的第一步-首先我根据观看每一对电影的人之间的关系来找到电影之间的关系。当我们通过以下示例时，这将更加清晰：
- en: '![](img/74684baa-3636-45ba-b60d-f47a02bc9bd2.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: （图片）
- en: For example, let's say that our nice young lady in the preceding image watched
    Star Wars and The Empire Strikes Back and liked both of them, so rated them both
    five stars or something. Now, along comes Mr. Edgy Mohawk Man who also watched
    Star Wars and The Empire Strikes Back and also liked both of them. So, at this
    point we can say there's a relationship, there is a similarity between Star Wars
    and The Empire Strikes Back based on these two users who liked both movies.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们假设在上图中的这位年轻女士观看了《星球大战》和《帝国反击战》，并且喜欢这两部电影，所以给了它们五星或者其他什么评分。现在，又来了一个叫Edgy
    Mohawk Man的人，他也观看了《星球大战》和《帝国反击战》，并且也喜欢这两部电影。所以，此时我们可以说这两部电影之间存在关系，基于这两位喜欢这两部电影的用户。
- en: What we're going to do is look at each pair of movies. We have a pair of Star
    Wars and Empire Strikes Back, and then we look at all the users that watched both
    of them, which are these two guys, and if they both liked them, then we can say
    that they're similar to each other. Or, if they both disliked them we can also
    say they're similar to each other, right? So, we're just looking at the similarity
    score of these two users' behavior related to these two movies in this movie pair.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的是查看每一对电影。我们有一对《星球大战》和《帝国反击战》，然后我们查看所有观看这两部电影的用户，这两个人，如果他们都喜欢这两部电影，那么我们可以说它们彼此相似。或者，如果他们都不喜欢，我们也可以说它们彼此相似，对吧？所以，我们只是在查看这两个用户与这对电影的相似度得分。
- en: So, along comes Mr. Moustachy Lumberjack Hipster Man and he watches The Empire
    Strikes Back and he lives in some strange world where he watched The Empire Strikes
    Back, but had no idea that Star Wars the first movie existed.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 然后来了一个留着小胡子的伐木工艺师，他看了《帝国反击战》，他生活在一个奇怪的世界，他看了《帝国反击战》，但不知道《星球大战》这部第一部电影的存在。
- en: '![](img/2729d221-c540-4873-aed9-f90fde537c91.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2729d221-c540-4873-aed9-f90fde537c91.png)'
- en: 'Well that''s fine, we computed a relationship between The Empire Strikes Back
    and Star Wars based on the behavior of these two people, so we know that these
    two movies are similar to each other. So, given that Mr. Hipster Man liked The
    Empire Strikes Back, we can say with good confidence that he would also like Star
    Wars, and we can then recommend that back to him as his top movie recommendation.
    Something like the following illustration:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我们根据这两个人的行为计算了《帝国反击战》和《星球大战》之间的关系，所以我们知道这两部电影彼此相似。因此，鉴于小胡子先生喜欢《帝国反击战》，我们可以有信心地说他也会喜欢《星球大战》，然后我们可以将这部电影推荐给他作为他的首选电影推荐。就像下面的插图一样：
- en: '![](img/bfd19c04-77f4-45d7-a7f5-b37501dde222.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bfd19c04-77f4-45d7-a7f5-b37501dde222.png)'
- en: You can see that you end up with very similar results in the end, but we've
    kind of flipped the whole thing on its head. So, instead of focusing the system
    on relationships between people, we're focusing them on relationships between
    items, and those relationships are still based on the aggregate behavior of all
    the people that watch them. But fundamentally, we're looking at relationships
    between items and not relationships between people. Got it?
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到最终结果非常相似，但我们已经颠覆了整个事情的本质。所以，我们不再把系统的重点放在人与人之间的关系上，而是放在物品之间的关系上，而这些关系仍然是基于所有观看它们的人的集体行为。但从根本上讲，我们正在研究物品之间的关系，而不是人与人之间的关系。明白了吗？
- en: Collaborative filtering using Python
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Python进行协同过滤
- en: Alright, so let's do it! We have some Python code that will use Pandas, and
    all the various other tools at our disposal, to create movie recommendations with
    a surprisingly little amount of code.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，让我们开始吧！我们有一些Python代码，将使用Pandas和我们可以使用的各种其他工具，用非常少的代码创建电影推荐。
- en: The first thing we're going to do is show you item-based collaborative filtering
    in practice. So, we'll build up *people who watched also watched* basically, you
    know, *people who rated things highly also rated this thing highly*, so building
    up these movie to movie relationships. So, we're going to base it on real data
    that we got from the MovieLens project. So, if you go to MovieLens.org, there's
    actually an open movie recommender system there, where people can rate movies
    and get recommendations for new movies.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的第一件事是向你展示基于物品的协同过滤的实践。所以，我们将建立“看过这个电影的人也看过”的关系，基本上就是“喜欢某些东西的人也喜欢这个东西”，所以我们将基于我们从MovieLens项目中获得的真实数据来构建这些电影之间的关系。所以，如果你去MovieLens.org，那里实际上有一个开放的电影推荐系统，人们可以对电影进行评分，并获得新电影的推荐。
- en: 'And, they make all the underlying data publicly available for researchers like
    us. So, we''re going to use some real movie ratings data-it is a little bit dated,
    it''s like 10 years old, so keep that in mind, but it is real behavior data that
    we''re going to be working with finally here. And, we will use that to compute
    similarities between movies. And, that data in and of itself is useful. You can
    use that data to say *people who liked also liked*. So, let''s say I''m looking
    at a web page for a movie. the system can then say: *if you liked this movie,
    and given that you''re looking at it you''re probably interested in it, then you
    might also like these movies*. And that''s a form of a recommender system right
    there, even though we don''t even know who you are.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 他们将所有的基础数据公开供研究人员使用。因此，我们将使用一些真实的电影评分数据-它有点过时，大约是10年前的，所以请记住这一点，但这是我们最终要使用的真实行为数据。我们将使用这些数据来计算电影之间的相似性。这些数据本身就很有用。你可以使用这些数据来说“喜欢这部电影的人也喜欢……”。所以，假设我正在查看一部电影的网页。系统可以说：“如果你喜欢这部电影，并且考虑到你正在查看它，你可能也会喜欢这些电影。”即使我们不知道你是谁，这就是一种推荐系统的形式。
- en: Now, it is real-world data, so we're going to encounter some real-world problems
    with it. Our initial set of results aren't going to look good, so we're going
    to spend a little bit of extra time trying to figure out why, which is a lot of
    what you spend your time doing as a data scientist-correct those problems, and
    go back and run it again until we get results that makes sense.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这是真实世界的数据，所以我们将遇到一些真实世界的问题。我们最初的结果看起来不太好，所以我们将花一点额外的时间来尝试弄清楚原因，这正是作为数据科学家所花费时间的很大一部分-纠正这些问题，然后重新运行，直到得到有意义的结果。
- en: And finally, we'll actually do item-based collaborative filtering in its entirety,
    where we actually recommend movies to individuals based on their own behavior.
    So, let's do this, let's get started!
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将完全进行基于物品的协同过滤，根据个人的行为向他们推荐电影。所以，让我们开始吧！
- en: Finding movie similarities
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 寻找电影的相似性
- en: Let's apply the concept of item-based collaborative filtering. To start with,
    movie similarities-figure out what movies are similar to other movies. In particular,
    we'll try to figure out what movies are similar to Star Wars, based on user rating
    data, and we'll see what we get out of it. Let's dive in!
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们应用基于物品的协同过滤的概念。首先，找出电影之间的相似性-找出哪些电影与其他电影相似。特别是，我们将尝试找出哪些电影与星球大战相似，基于用户评分数据，我们将看看我们得到了什么。让我们深入研究一下！
- en: Okay so, let's go ahead and compute the first half of item-based collaborative
    filtering, which is finding similarities between items. Download and open the
    `SimilarMovies.ipynb` file.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们继续计算基于物品的协同过滤的前半部分，即找到物品之间的相似性。下载并打开`SimilarMovies.ipynb`文件。
- en: '![](img/0b57996b-9e77-449f-970c-42b1ca7f3f16.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0b57996b-9e77-449f-970c-42b1ca7f3f16.jpg)'
- en: In this case, we're going to be looking at similarities between movies, based
    on user behavior. And, we're going to be using some real movie rating data from
    the GroupLens project. GroupLens.org provides real movie ratings data, by real
    people who are using the [MovieLens.org](http://MovieLens.org) website to rate
    movies and get recommendations back for new movies that they want to watch.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将根据用户行为来查看电影之间的相似性。我们将使用GroupLens项目的一些真实电影评分数据。GroupLens.org提供了真实的电影评分数据，由真正使用[MovieLens.org](http://MovieLens.org)网站给电影评分并获得推荐的人提供。
- en: We have included the data files that you need from the GroupLens dataset with
    the course materials, and the first thing we need to do is import those into a
    Pandas DataFrame, and we're really going to see the full power of Pandas in this
    example. It's pretty cool stuff!
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在课程资料中包含了您需要的GroupLens数据集的数据文件，我们需要做的第一件事是将其导入Pandas DataFrame中，我们将在这个示例中真正看到Pandas的全部功能。这很酷！
- en: Understanding the code
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解代码
- en: The first thing we're going to do is import the `u.data` file as part of the
    MovieLens dataset, and that is a tab-delimited file that contains every rating
    in the dataset.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的第一件事是导入MovieLens数据集中的`u.data`文件，这是一个包含数据集中每个评分的制表符分隔文件。
- en: '[PRE0]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note that you'll need to add the path here to where you stored the downloaded
    MovieLens files on your computer. So, the way that this works is even though we're
    calling `read_csv` on Pandas, we can specify a different separator than a comma.
    In this case, it's a tab.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您需要在这里添加路径，指向您在计算机上存储下载的MovieLens文件的位置。因此，即使我们在Pandas上调用`read_csv`，我们也可以指定一个不同于逗号的分隔符。在这种情况下，它是一个制表符。
- en: 'We''re basically saying take the first three columns in the `u.data` file,
    and import it into a new DataFrame, with three columns: `user_id`, `movie_id`,
    and `rating`.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们基本上是在说，从`u.data`文件中取前三列，并将其导入一个新的DataFrame，有三列：`user_id`，`movie_id`和`rating`。
- en: What we end up with here is a DataFrame that has a row for every `user_id`,
    which identifies some person, and then, for every movie they rated, we have the
    `movie_id`, which is some numerical shorthand for a given movie, so Star Wars
    might be movie 53 or something, and their rating, you know, 1 to 5 stars. So,
    we have here a database, a DataFrame, of every user and every movie they rated,
    okay?
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终得到的是一个DataFrame，对于每个`user_id`，都有一行，用于标识某个人，然后，对于他们评价的每部电影，我们有`movie_id`，这是给定电影的一些数字缩写，因此星球大战可能是第53部电影之类的，以及他们的评分，1到5星。因此，我们在这里有一个数据库，一个DataFrame，包含每个用户和他们评价的每部电影，好吗？
- en: Now, we want to be able to work with movie titles, so we can interpret these
    results more intuitively, so we're going to use their human-readable names instead.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们希望能够使用电影标题，这样我们可以更直观地解释这些结果，所以我们将使用它们的可读名称。
- en: If you're using a truly massive dataset, you'd save that to the end because
    you want to be working with numbers, they're more compact, for as long as possible.
    For the purpose of example and teaching, though, we'll keep the titles around
    so you can see what's going on.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是真正庞大的数据集，您会将其保存到最后，因为您希望尽可能长时间地使用数字，它们更紧凑。不过，出于示例和教学的目的，我们将保留标题，这样您就可以看到发生了什么。
- en: '[PRE1]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'There''s a separate data file with the MovieLens dataset called `u.item`, and
    it is pipe-delimited, and the first two columns that we import will be the `movie_id`
    and the `title` of that movie. So, now we have two DataFrames: `r_cols` has all
    the user ratings and `m_cols` has all the titles for every `movie_id`. We can
    then use the magical `merge` function in Pandas to mush it all together.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: MovieLens数据集中有一个名为`u.item`的单独数据文件，它是以管道分隔的，我们导入的前两列将是`movie_id`和该电影的`title`。因此，现在我们有两个DataFrame：`r_cols`包含所有用户评分，`m_cols`包含每个`movie_id`的所有标题。然后，我们可以使用Pandas中神奇的`merge`函数将它们全部合并在一起。
- en: '[PRE2]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Let's add a `ratings.head()` command and then run those cells. What we end up
    with is something like the following table. That was pretty quick!
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一个`ratings.head()`命令，然后运行这些单元格。我们最终得到的是类似以下表格的东西。那很快！
- en: '![](img/7e72bc4a-10dd-4530-a3a9-692349d14998.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7e72bc4a-10dd-4530-a3a9-692349d14998.jpg)'
- en: We end up with a new DataFrame that contains the `user_id` and rating for each
    movie that a user rated, and we have both the `movie_id` and the `title` that
    we can read and see what it really is. So, the way to read this is `user_id` number
    `308` rated the `Toy Story (1995)` movie `4` stars, `user_id` number `287` rated
    the `Toy Story (1995)` movie `5` stars, and so on and so forth. And, if we were
    to keep looking at more and more of this DataFrame, we'd see different ratings
    for different movies as we go through it.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终得到了一个新的DataFrame，其中包含每个用户评价的`user_id`和电影评分，并且我们既有`movie_id`又有`title`，可以阅读并了解它是什么。因此，读取这个数据的方式是`user_id`号`308`给`Toy
    Story (1995)`电影评了`4`星，`user_id`号`287`给`Toy Story (1995)`电影评了`5`星，依此类推。如果我们继续查看更多的这个DataFrame，我们会看到不同的电影的不同评分。
- en: 'Now the real magic of Pandas comes in. So, what we really want is to look at
    relationships between movies based on all the users that watched each pair of
    movies, so we need, at the end, a matrix of every movie, and every user, and all
    the ratings that every user gave to every movie. The `pivot_table` command in
    Pandas can do that for us. It can basically construct a new table from a given
    DataFrame, pretty much any way that you want it. For this, we can use the following
    code:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在Pandas的真正魔力显现出来了。因此，我们真正想要的是根据观看每对电影的所有用户之间的关系来查看电影之间的关系，因此最终我们需要一个包含每部电影、每个用户以及每个用户对每部电影的所有评分的矩阵。Pandas中的`pivot_table`命令可以为我们做到这一点。它基本上可以根据给定的DataFrame构建一个新表，几乎任何你想要的方式。为此，我们可以使用以下代码：
- en: '[PRE3]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: So, what we're saying with this code is-take our ratings DataFrame and create
    a new DataFrame called `movieRatings` and we want the index of it to be the user
    IDs, so we'll have a row for every `user_id`, and we're going to have every column
    be the movie title. So, we're going to have a column for every title that we encounter
    in that DataFrame, and each cell will contain the `rating` value, if it exists.
    So, let's go ahead and run it.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这段代码的意思是-取出我们的评分DataFrame并创建一个名为`movieRatings`的新DataFrame，我们希望它的索引是用户ID，所以我们将为每个`user_id`有一行，并且我们将每一列都是电影标题。因此，我们将为在该DataFrame中遇到的每个标题都有一列，并且如果存在的话，每个单元格将包含`rating`值。让我们继续运行它。
- en: 'And, we end up with a new DataFrame that looks like the following table:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们得到了一个新的DataFrame，看起来像下表：
- en: '![](img/2be0e510-8351-4be3-93c1-210bf6a1edef.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2be0e510-8351-4be3-93c1-210bf6a1edef.jpg)'
- en: It's kind of amazing how that just put it all together for us. Now, you'll see
    some `NaN` values, which stands for **Not a Number**, and its just how Pandas
    indicates a missing value. So, the way to interpret this is, `user_id` number
    `1`, for example, did not watch the movie `1-900 (1994)`, but `user_id` number
    `1` did watch `101 Dalmatians (1996)` and rated it `2` stars. The `user_id` number
    `1` also watched `12 Angry Men (1957)` and rated it `5` stars, but did not watch
    the movie `2 Days in the Valley (1996)`, for example, okay? So, what we end up
    with here is a sparse matrix basically, that contains every user, and every movie,
    and at every intersection where a user rated a movie there's a rating value.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这真是太神奇了，现在你会看到一些`NaN`值，代表**不是一个数字**，这就是Pandas表示缺失值的方式。因此，解释这个的方法是，例如，`user_id`编号`1`没有观看电影`1-900（1994）`，但`user_id`编号`1`观看了《101斑点狗》（1996）并给了它`2`星的评价。`user_id`编号`1`还观看了《愤怒的公牛》（1957）并给了它`5`星的评价，但没有观看电影《2天在山谷（1996）》，例如，明白了吗？因此，我们最终得到的是一个稀疏矩阵，其中包含了每个用户和每部电影，以及每个用户对每部电影的评分值。
- en: So, you can see now, we can very easily extract vectors of every movie that
    our user watched, and we can also extract vectors of every user that rated a given
    movie, which is what we want. So, that's useful for both user-based and item-based
    collaborative filtering, right? If I wanted to find relationships between users,
    I could look at correlations between these user rows, but if I want to find correlations
    between movies, for item-based collaborative filtering, I can look at correlations
    between columns based on the user behavior. So, this is where the real *flipping
    things on its head for user versus item-based similarities* comes into play.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，现在你可以看到，我们可以非常容易地提取出用户观看的每部电影的向量，也可以提取出每个评价了给定电影的用户的向量，这正是我们想要的。所以，这对基于用户和基于物品的协同过滤都很有用，对吧？如果我想要找到用户之间的关系，我可以查看这些用户行之间的相关性，但如果我想要找到电影之间的相关性，对于基于物品的协同过滤，我可以根据用户行为查看列之间的相关性。这就是真正*颠覆用户与基于物品相似性的*实现的地方。
- en: 'Now, we''re going with item-based collaborative filtering, so we want to extract
    columns, to do this let''s run the following code:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们要进行基于物品的协同过滤，所以我们要提取列，为此让我们运行以下代码：
- en: '[PRE4]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, with the help of that, let''s go ahead and extract all the users who rated
    `Star Wars (1977)`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，借助这个，让我们继续提取所有评价了《星球大战（1977）》的用户：
- en: '![](img/a35302db-1296-42e7-aaee-6c24f1bb2954.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a35302db-1296-42e7-aaee-6c24f1bb2954.jpg)'
- en: And, we can see most people have, in fact, watched and rated `Star Wars (1977)`
    and everyone liked it, at least in this little sample that we took from the head
    of the DataFrame. So, we end up with a resulting set of user IDs and their ratings
    for `Star Wars (1977)`. The user ID `3` did not rate `Star Wars (1977)` so we
    have a `NaN` value, indicating a missing value there, but that's okay. We want
    to make sure that we preserve those missing values so we can directly compare
    columns from different movies. So, how do we do that?
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到大多数人实际上都观看并评价了《星球大战（1977）》，并且每个人都喜欢它，至少在我们从DataFrame的开头取出的这个小样本中是这样。因此，我们得到了一组用户ID及其对《星球大战（1977）》的评分。用户ID`3`没有对《星球大战（1977）》进行评分，因此我们有一个`NaN`值，表示那里有一个缺失值，但没关系。我们希望确保保留这些缺失值，以便我们可以直接比较不同电影的列。那么我们该如何做呢？
- en: The corrwith function
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: corrwith函数
- en: 'Well, Pandas keeps making it easy for us, and has a `corrwith` function that
    you can see in the following code that we can use:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，Pandas一直让我们很容易，它有一个`corrwith`函数，你可以在下面的代码中看到，我们可以使用它：
- en: '[PRE5]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'That code will go ahead and correlate a given column with every other column
    in the DataFrame, and compute the correlation scores and give that back to us.
    So, what we''re doing here is using `corrwith` on the entire `movieRatings` DataFrame,
    that''s that entire matrix of user movie ratings, correlating it with just the
    `starWarsRatings` column, and then dropping all of the missing results with `dropna`.
    So, that just leaves us with items that had a correlation, where there was more
    than one person that viewed it, and we create a new DataFrame based on those results
    and then display the top 10 results. So again, just to recap:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码将对给定的列与DataFrame中的每一列进行相关性计算，并计算相关性得分并将其返回给我们。所以，我们在这里做的是在整个`movieRatings`
    DataFrame上使用`corrwith`，这是用户电影评分的整个矩阵，将其与`starWarsRatings`列进行相关性计算，然后使用`dropna`删除所有缺失的结果。这样我们就只剩下了有相关性的项目，有多于一个人观看的项目，然后我们基于这些结果创建一个新的DataFrame，然后显示前10个结果。所以，再次回顾一下：
- en: We're going to build the correlation score between Star Wars and every other
    movie.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将建立《星球大战》与每部其他电影之间的相关性得分。
- en: Drop all the `NaN` values, so that we only have movie similarities that actually
    exist, where more than one person rated it.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除所有的`NaN`值，这样我们只有实际存在的电影相似性，有多于一个人对其进行了评分。
- en: And, we're going to construct a new DataFrame from the results and look at the
    top 10 results.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将从结果中构建一个新的DataFrame，并查看前10个结果。
- en: 'And here we are with the results shown in the following screenshot:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的截图中，我们看到了结果：
- en: '![](img/c4971b0b-0ab9-4c7c-b956-336877569bb4.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c4971b0b-0ab9-4c7c-b956-336877569bb4.jpg)'
- en: We ended up with this result of correlation scores between each individual movie
    for Star Wars and we can see, for example, a surprisingly high correlation score
    with the movie `'Til There Was You (1997)`, a negative correlation with the movie
    `1-900 (1994)`, and a very weak correlation with `101 Dalmatians (1996)`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了《星球大战》与每部电影之间的相关性得分结果，例如，与电影《直到有了你（1997）》有惊人的高相关性得分，与电影《1-900（1994）》有负相关性，与《101斑点狗（1996）》有非常弱的相关性。
- en: Now, all we should have to do is sort this by similarity score, and we should
    have the top movie similarities for Star Wars, right? Let's go ahead and do that.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要按相似性得分排序，我们就可以得到《星球大战》的前十个电影相似性了，对吧？让我们继续做吧。
- en: '[PRE6]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Just call `sort_values` on the resulting DataFrame, again Pandas makes it really
    easy, and we can say `ascending=False`, to actually get it sorted in reverse order
    by correlation score. So, let''s do that:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 只需在生成的DataFrame上调用`sort_values`，Pandas使这变得非常容易，我们可以说`ascending=False`，实际上按相关性得分的倒序排序。所以，让我们这样做：
- en: '![](img/c3283e10-bc89-4e89-b2df-228c29a90a9a.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c3283e10-bc89-4e89-b2df-228c29a90a9a.jpg)'
- en: 'Okay, so `Star Wars (1977)` came out pretty close to top, because it is similar
    to itself, but what''s all this other stuff? What the heck? We can see in the
    preceding output, some movies such as: `Full Speed (1996)`, `Man of the Year (1995)`,
    `The Outlaw (1943)`. These are all, you know, fairly obscure movies, that most
    of them I''ve never even heard of, and yet they have perfect correlations with
    Star Wars. That''s kinda weird! So, obviously we''re doing something wrong here.
    What could it be?'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，《星球大战（1977）》排名靠前，因为它与自身相似，但其他的是什么？这是怎么回事？我们可以在前面的输出中看到一些电影，比如：《全速前进（1996）》、《年度人物（1995）》、《亡命之徒（1943）》。这些都是，你知道的，相当晦涩的电影，其中大多数我甚至从未听说过，但它们与《星球大战》有完美的相关性。这有点奇怪！显然我们在这里做错了什么。可能是什么呢？
- en: Well, it turns out there's a perfectly reasonable explanation, and this is a
    good lesson in why you always need to examine your results when you're done with
    any sort of data science task-question the results, because often there's something
    you missed, there might be something you need to clean in your data, there might
    be something you did wrong. But you should also always look skeptically at your
    results, don't just take them on faith, okay? If you do so, you're going to get
    in trouble, because if I were to actually present these as recommendations to
    people who liked Star Wars, I would get fired. Don't get fired! Pay attention
    to your results! So, let's dive into what went wrong in our next section.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，有一个完全合理的解释，这是一个很好的教训，为什么你在完成任何数据科学任务时总是需要检查你的结果-质疑结果，因为通常会有一些你忽略的东西，可能需要清理数据，可能你做错了什么。但你也应该怀疑地看待你的结果，不要只是盲目接受，好吗？如果你这样做，你会惹麻烦的，因为如果我真的把这些作为喜欢《星球大战》的人的推荐，我会被解雇的。不要被解雇！注意你的结果！所以，让我们深入研究下一节中出现的问题。
- en: Improving the results of movie similarities
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改进电影相似性的结果
- en: Let's figure out what went wrong with our movie similarities there. We went
    through all this exciting work to compute correlation scores between movies based
    on their user ratings vectors, and the results we got kind of sucked. So, just
    to remind you, we looked for movies that are similar to Star Wars using that technique,
    and we ended up with a bunch of weird recommendations at the top that had a perfect
    correlation.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们弄清楚我们的电影相似性出了什么问题。我们经历了所有这些令人兴奋的工作，计算了基于用户评分向量的电影之间的相关性得分，但我们得到的结果有点糟糕。只是为了提醒你，我们使用了这种技术寻找与《星球大战》相似的电影，结果我们得到了一堆怪异的推荐，排在前面的电影与《星球大战》有完美的相关性。
- en: And, most of them were very obscure movies. So, what do you think might be going
    on there? Well, one thing that might make sense is, let's say we have a lot of
    people watch Star Wars and some other obscure film. We'd end up with a good correlation
    between these two movies because they're tied together by Star Wars, but at the
    end of the day, do we really want to base our recommendations on the behavior
    of one or two people that watch some obscure movie?
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数都是非常晦涩的电影。那么，你认为可能发生了什么？嗯，可能有一个讲得通的解释，假设我们有很多人观看了《星球大战》和其他一些晦涩的电影。我们最终会得到这两部电影之间的很好的相关性，因为它们都与《星球大战》联系在一起，但归根结底，我们真的想要基于观看某些晦涩电影的一两个人的行为来做推荐吗？
- en: Probably not! I mean yes, the two people in the world, or whatever it is, that
    watch the movie Full Speed, and both liked it in addition to Star Wars, maybe
    that is a good recommendation for them, but it's probably not a good recommendation
    for the rest of the world. We need to have some sort of confidence level in our
    similarities by enforcing a minimum boundary of how many people watched a given
    movie. We can't make a judgment that a given movie is good just based on the behavior
    of one or two people.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 可能不是！我的意思是，是的，世界上的两个人，或者无论是什么，看了电影《全速前进》，并且都喜欢它，除了《星球大战》，也许这对他们来说是一个很好的推荐，但对世界其他人来说可能不是一个很好的推荐。我们需要对相似性有一定的信心水平，通过强制执行观看给定电影的人数的最低限制来实现。我们不能仅仅基于一两个人的行为来判断一部电影是否好看。
- en: 'So, let''s try to put that insight into action using the following code:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们尝试将这一见解付诸行动，使用以下代码：
- en: '[PRE7]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: What we're going to do is try to identify the movies that weren't actually rated
    by many people and we'll just throw them out and see what we get. So, to do that
    we're going to take our original ratings DataFrame and we're going to say `groupby('title')`,
    again Pandas has all sorts of magic in it. And, this will basically construct
    a new DataFrame that aggregates together all the rows for a given title into one
    row.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的是尝试识别那些实际上没有被很多人评价的电影，然后我们将它们排除，看看我们会得到什么。因此，为了做到这一点，我们将取得我们原始的评分DataFrame，并且我们将说`groupby('title')`，同样Pandas在其中有各种魔法。这将基本上构建一个新的DataFrame，将给定标题的所有行聚合成一行。
- en: 'We can say that we want to aggregate specifically on the rating, and we want
    to show both the size, the number of ratings for each movie, and the mean average
    score, the mean rating for that movie. So, when we do that, we end up with something
    like the following:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以说，我们想要特别聚合评分，并且我们想要显示每部电影的大小，即每部电影的评分人数，以及平均平均分数，即该电影的平均评分。因此，当我们这样做时，我们最终得到类似以下的东西：
- en: '![](img/4dd625f7-1287-4e3e-bdbb-2980fd513f4c.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4dd625f7-1287-4e3e-bdbb-2980fd513f4c.jpg)'
- en: This is telling us, for example, for the movie `101 Dalmatians (1996)`, `109`
    people rated that movie and their average rating was 2.9 stars, so not that great
    of a score really! So, if we just eyeball this data, we can say okay well, movies
    that I consider obscure, like `187 (1997)`, had `41` ratings, but `101 Dalmatians
    (1996)`, I've heard of that, you know `12 Angry Men (1957)`, I've heard of that.
    It seems like there's sort of a natural cutoff value at around 100 ratings, where
    maybe that's the magic value where things start to make sense.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这告诉我们电影《101斑点狗（1996年）》有109人评价了这部电影，他们的平均评分是2.9颗星，所以实际上并不是很高的分数！因此，如果我们仅凭眼力观察这些数据，我们可以说好吧，我认为比较不知名的电影，比如《187（1997年）》，有41个评分，但《101斑点狗（1996年）》，我听说过，你知道《愤怒的公牛（1957年）》，我也听说过。似乎在大约100个评分处有一种自然的截止值，也许这是一个魔法值，事情开始变得有意义。
- en: 'Let''s go ahead and get rid of movies rated by fewer than 100 people, and yes,
    you know I''m kind of doing this intuitively at this point. As we''ll talk about
    later, there are more principled ways of doing this, where you could actually
    experiment and do train/test experiments on different threshold values, to find
    the one that actually performs the best. But initially, let''s just use our common
    sense and filter out movies that were rated by fewer than 100 people. Again, Pandas
    makes that really easy to do. Let''s figure it out with the following example:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续摆脱少于100人评分的电影，是的，你知道我在这一点上有点凭直觉。正如我们稍后将讨论的，有更有原则的方法来做到这一点，你实际上可以进行实验，并在不同的阈值上进行训练/测试实验，找到实际表现最好的那个。但最初，让我们只是用常识来过滤掉少于100人评分的电影。同样，Pandas使这变得非常容易。让我们通过以下示例来弄清楚：
- en: '[PRE8]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We can just say `popularMovies`, a new DataFrame, is going to be constructed
    by looking at `movieStats` and we're going to only take rows where the rating
    size is greater than or equal to `100`, and I'm then going to sort that by `mean`
    rating, just for fun, to see the top rated, widely watched movies.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以说`popularMovies`，一个新的DataFrame，将通过查看`movieStats`构建，我们只会取评分大小大于或等于100的行，然后我将按`mean`评分排序，只是为了好玩，看看最受欢迎的广泛观看的电影。
- en: '![](img/990a039d-2541-4504-af34-cd6d9c7320de.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](img/990a039d-2541-4504-af34-cd6d9c7320de.jpg)'
- en: What we have here is a list of movies that were rated by more than 100 people,
    sorted by their average rating score, and this in itself is a recommender system.
    These are highly-rated popular movies. `A Close Shave (1995)`, apparently, was
    a really good movie and a lot of people watched it and they really liked it.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这里有一份由100多人评分的电影列表，按其平均评分分数排序，这本身就是一个推荐系统。这些都是受欢迎的高评分电影。《剃须刀奇遇记（1995年）》，显然是一部非常好的电影，很多人看过并且非常喜欢。
- en: So again, this is a very old dataset, from the late 90s, so even though you
    might not be familiar with the film `A Close Shave (1995)`, it might be worth
    going back and rediscovering it; add it to your Netflix! `Schindler's List (1993)`
    not a big surprise there, that comes up on the top of most top movies lists. `The
    Wrong Trousers (1993)`, another example of an obscure film that apparently was
    really good and was also pretty popular. So, some interesting discoveries there
    already, just by doing that.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这是一个非常古老的数据集，来自90年代末，所以即使你可能不熟悉电影《剃须刀奇遇记（1995年）》，回头去重新发现它可能是值得的；把它加入你的Netflix！《辛德勒的名单（1993年）》并不是一个大惊喜，在大多数顶级电影列表中都会出现。《错误的裤子（1993年）》，另一个例子，是一部不知名的电影，显然非常好看，也很受欢迎。因此，通过这样做，已经有一些有趣的发现了。
- en: Things look a little bit better now, so let's go ahead and basically make our
    new DataFrame of Star Wars recommendations, movies similar to Star Wars, where
    we only base it on movies that appear in this new DataFrame. So, we're going to
    use the `join` operation, to go ahead and join our original `similarMovies` DataFrame
    to this new DataFrame of only movies that have greater than 100 ratings, okay?
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在情况看起来好多了，所以让我们继续制作我们的新DataFrame，其中包含与《星球大战》相似的电影，我们只基于出现在这个新DataFrame中的电影。所以，我们将使用`join`操作，将我们原始的`similarMovies`
    DataFrame与这个只有超过100个评分的电影的新DataFrame进行连接，好吗？
- en: '[PRE9]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this code, we create a new DataFrame based on `similarMovies` where we extract
    the `similarity` column, join that with our `movieStats` DataFrame, which is our
    `popularMovies` DataFrame, and we look at the combined results. And, there we
    go with that output!
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们基于`similarMovies`创建了一个新的DataFrame，从中提取了`similarity`列，将其与我们的`movieStats`
    DataFrame（即我们的`popularMovies` DataFrame）进行了连接，并查看了合并的结果。然后，我们就有了输出！
- en: '![](img/d6cd490d-abff-4766-9c8c-f0aebddb1ead.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d6cd490d-abff-4766-9c8c-f0aebddb1ead.jpg)'
- en: 'Now we have, restricted only to movies that are rated by more than 100 people,
    the similarity score to Star Wars. So, now all we need to do is sort that using
    the following code:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只限制了那些被100多人评价的电影，与《星球大战》的相似度得分。所以，现在我们需要做的就是使用以下代码对其进行排序：
- en: '[PRE10]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here, we''re reverse sorting it and we''re just going to take a look at the
    first 15 results. If you run that now, you should see the following:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将对其进行逆向排序，并只查看前15个结果。如果你现在运行它，你应该会看到以下内容：
- en: '![](img/906e7c92-d6fd-439f-b4e0-8878d5f3d4b1.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](img/906e7c92-d6fd-439f-b4e0-8878d5f3d4b1.jpg)'
- en: This is starting to look a little bit better! So, `Star Wars (1977)` comes out
    on top because it's similar to itself, `The Empire Strikes Back (1980)` is number
    2, `Return of the Jedi (1983)` is number 3, `Raiders of the Lost Ark (1981)`,
    number 4\. You know, it's still not perfect, but these make a lot more sense,
    right? So, you would expect the three Star Wars films from the original trilogy
    to be similar to each other, this data goes back to before the next three films,
    and `Raiders of the Lost Ark (1981)` is also a very similar movie to Star Wars
    in style, and it comes out as number 4\. So, I'm starting to feel a little bit
    better about these results. There's still room for improvement, but hey! We got
    some results that make sense, whoo-hoo!
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 情况开始好转了！《星球大战》（1977）因为与自己相似，所以排在第一位，《帝国反击战》（1980）排在第二位，《绝地归来》（1983）排在第三位，《夺宝奇兵》（1981）排在第四位。你知道，它还不完美，但这些更有意义，对吧？所以，你会期望原始三部曲的三部《星球大战》电影相互之间相似，这些数据还是在下一部三部曲之前，而《夺宝奇兵》（1981）也是一部风格非常相似的电影，排在第四位。所以，我对这些结果开始感到有点满意。还有改进的空间，但嘿！我们得到了一些有意义的结果，哇呜！
- en: 'Now, ideally, we''d also filter out Star Wars, you don''t want to be looking
    at similarities to the movie itself that you started from, but we''ll worry about
    that later! So, if you want to play with this a little bit more, like I said 100
    was sort of an arbitrary cutoff for the minimum number of ratings. If you do want
    to experiment with different cutoff values, I encourage you to go back and do
    so. See what that does to the results. You know, you can see in the preceding
    table that the results that we really like actually had much more than 100 ratings
    in common. So, we end up with `Austin Powers: International Man of Mystery (1997)`
    coming in there pretty high with only `130` ratings so maybe 100 isn''t high enough!
    `Pinocchio (1940)` snuck in at `101`, not very similar to Star Wars, so, you might
    want to consider an even higher threshold there and see what it does.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，理想情况下，我们还应该过滤掉《星球大战》，你不想看到与你开始的电影本身的相似性，但我们以后再担心这个！所以，如果你想再玩一下，就像我说的，100是最低评分的一个任意截止点。如果你确实想尝试不同的截止值，我鼓励你回去尝试一下。看看它对结果有什么影响。你知道，在前面的表中，我们真正喜欢的结果实际上有更多的共同评分超过100。所以，我们最终得到了《奥斯汀·鲍尔的国际人质》（1997）的评分相当高，只有130个评分，所以也许100还不够高！《木偶奇遇记》（1940）以101分进入，与《星球大战》不太相似，所以，你可能需要考虑更高的阈值，看看它会有什么影响。
- en: Please keep in mind too, this is a very small, limited dataset that we used
    for experimentation purposes, and it's based on very old data, so you're only
    going to see older movies. So, interpreting these results intuitively might be
    a little bit challenging as a result, but not bad results.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这是一个非常小的、用于实验目的的有限数据集，它基于非常旧的数据，所以你只会看到较旧的电影。因此，从直觉上解释这些结果可能会有点具有挑战性，但结果并不差。
- en: Now let's move on and actually do full-blown item-based collaborative filtering
    where we recommend movies to people using a more complete system, we'll do that
    next.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们继续，实际上进行全面的基于物品的协同过滤，通过使用更完整的系统向人们推荐电影，我们将在下一步中进行。
- en: Making movie recommendations to people
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向人们推荐电影
- en: Okay, let's actually build a full-blown recommender system that can look at
    all the behavior information of everybody in the system, and what movies they
    rated, and use that to actually produce the best recommendation movies for any
    given user in our dataset. Kind of amazing and you'll be surprised how simple
    it is. Let's go!
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们实际构建一个完整的推荐系统，它可以查看系统中每个人的所有行为信息，以及他们评价的电影，并利用这些信息为数据集中的任何用户实际生成最佳推荐电影。这有点令人惊讶，你会对它有多简单感到惊讶。让我们开始吧！
- en: 'Let''s begin using the `ItemBasedCF.ipynb` file and let''s start off by importing
    the MovieLens dataset that we have. Again, we''re using a subset of it that just
    contains 100,000 ratings for now. But, there are larger datasets you can get from
    GroupLens.org-up to millions of ratings; if you''re so inclined. Keep in mind
    though, when you start to deal with that really big data, you''re going to be
    pushing the limits of what you can do in a single machine and what Pandas can
    handle. Without further ado, here''s the first block of code:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始使用`ItemBasedCF.ipynb`文件，首先导入我们拥有的MovieLens数据集。同样，我们现在只使用其中包含10万个评分的子集。但是，你可以从GroupLens.org获得更大的数据集-高达数百万个评分；如果你愿意的话。但是请记住，当你开始处理真正大的数据时，你将会推动单台机器和Pandas所能处理的极限。话不多说，这是第一段代码：
- en: '[PRE11]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Just like earlier, we're going to import the `u.data` file that contains all
    the individual ratings for every user and what movie they rated, and then we're
    going to tie that together with the movie titles, so we don't have to just work
    with numerical movie IDs. Go ahead and hit the run cell button, and we end up
    with the following DataFrame.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 就像之前一样，我们将导入包含每个用户的所有个人评分以及他们评分的电影的`u.data`文件，然后将其与电影标题联系起来，这样我们就不必只使用数字电影ID。点击运行单元格按钮，我们得到以下DataFrame。
- en: '![](img/d21be30a-3a4f-417e-a1eb-abc86facef19.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d21be30a-3a4f-417e-a1eb-abc86facef19.jpg)'
- en: The way to read this is, for example, `user_id` number `308` rated `Toy Story
    (1995)` a `4` star, and `user_id` number `66` rated `Toy Story (1995)` a `3` star.
    And, this will contain every rating, for every user, for every movie.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`user_id`编号`308`给`玩具总动员（1995）`评了4星，`user_id`编号`66`给`玩具总动员（1995）`评了3星。而且，这将包含每个用户对每部电影的每个评分。
- en: 'And again, just like earlier, we use the wonderful `pivot_table` command in
    Pandas to construct a new DataFrame based on the information:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，就像之前一样，我们使用Pandas中的`pivot_table`命令来基于信息构建一个新的DataFrame：
- en: '[PRE12]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here, each row is the `user_id`, the columns are made up of all the unique
    movie titles in my dataset, and each cell contains a rating:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，每行是`user_id`，列由数据集中所有独特的电影标题组成，每个单元格包含一个评分：
- en: '![](img/fb55cd2e-1591-44f9-8ca7-5eccca6cbdbe.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fb55cd2e-1591-44f9-8ca7-5eccca6cbdbe.jpg)'
- en: What we end up with is this incredibly useful matrix shown in the preceding
    output, that contains users for every row and movies for every column. And we
    have basically every user rating for every movie in this matrix. So, `user_id`
    number `1`, for example, gave `101 Dalmatians (1996)` a 2-star rating. And, again
    all these `NaN` values represent missing data. So, that just indicates, for example,
    `user_id` number `1` did not rate the movie `1-900 (1994)`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到的是前面输出中显示的非常有用的矩阵，其中每行都有用户，每列都有电影。而且我们在这个矩阵中基本上有每部电影的每个用户评分。例如，`user_id`编号`1`给`101斑点狗（1996）`评了2星。而且，所有这些`NaN`值代表缺失的数据。这只是表示，例如，`user_id`编号`1`没有对电影`1-900（1994）`进行评分。
- en: Again, it's a very useful matrix to have. If we were doing user-based collaborative
    filtering, we could compute correlations between each individual user rating vector
    to find similar users. Since we're doing item-based collaborative filtering, we're
    more interested in relationships between the columns. So, for example, doing a
    correlation score between any two columns, which will give us a correlation score
    for a given movie pair. So, how do we do that? It turns out that Pandas makes
    that incredibly easy to do as well.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常有用的矩阵。如果我们正在进行基于用户的协同过滤，我们可以计算每个单独用户评分向量之间的相关性以找到相似的用户。由于我们正在进行基于物品的协同过滤，我们更感兴趣的是列之间的关系。因此，例如，计算任意两列之间的相关性分数，这将为给定电影对给出相关性分数。那么，我们该如何做呢？事实证明，Pandas也使这变得非常容易。
- en: It has a built-in `corr` function that will actually compute the correlation
    score for every column pair found in the entire matrix-it's almost like they were
    thinking of us.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 它有一个内置的`corr`函数，实际上会计算整个矩阵中找到的每一对列的相关性分数-这几乎就像它们在为我们考虑。
- en: '[PRE13]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Let's go ahead and run the preceding code. It's a fairly computationally expensive
    thing to do, so it will take a moment to actually come back with a result. But,
    there we have it!
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续运行前面的代码。这是一个计算量相当大的事情，所以实际上需要一些时间才能得出结果。但是，我们得到了！
- en: '![](img/0780a7b9-67fc-4abf-b9f2-980fd8d6d900.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0780a7b9-67fc-4abf-b9f2-980fd8d6d900.jpg)'
- en: So, what do we have in the preceding output? We have here a new DataFrame where
    every movie is on the row, and in the column. So, we can look at the intersection
    of any two given movies and find their correlation score to each other based on
    this `userRatings` data that we had up here originally. How cool is that? For
    example, the movie `101 Dalmatians (1996)` is perfectly correlated with itself
    of course, because it has identical user rating vectors. But, if you look at `101
    Dalmatians (1996)` movie's relationship to the movie `12 Angry Men (1957)`, it's
    a much lower correlation score because those movies are rather dissimilar, makes
    sense, right?
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，在前面的输出中我们有什么？我们在这里有一个新的DataFrame，其中每部电影都在行上，列中。因此，我们可以查看任意两部电影的交集，并根据我们最初拥有的`userRatings`数据找到它们之间的相关性分数。这有多酷呢？例如，电影`101斑点狗（1996）`与自己完全相关，因为它具有相同的用户评分向量。但是，如果你看看`101斑点狗（1996）`电影与`十二怒汉（1957）`电影的关系，它的相关性分数要低得多，因为这些电影相当不相似，这是有道理的，对吧？
- en: I have this wonderful matrix now that will give me the similarity score of any
    two movies to each other. It's kind of amazing, and very useful for what we're
    going to be doing. Now just like earlier, we have to deal with spurious results.
    So, I don't want to be looking at relationships that are based on a small amount
    of behavior information.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我有了一个很棒的矩阵，可以给出任意两部电影之间的相似度分数。这有点令人惊讶，并且对我们即将要做的事情非常有用。就像之前一样，我们必须处理虚假的结果。所以，我不想看到基于少量行为信息的关系。
- en: It turns out that the Pandas `corr` function actually has a few parameters you
    can give it. One is the actual correlation score method that you want to use,
    so I'm going to say use `pearson` correlation.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 原来Pandas的`corr`函数实际上有一些参数可以给它。其中一个是你想要使用的实际相关性评分方法，所以我要说使用`pearson`相关性。
- en: '[PRE14]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You''ll notice that it also has a `min_periods` parameter you can give it,
    and that basically says I only want you to consider correlation scores that are
    backed up by at least, in this example, 100 people that rated both movies. Running
    that will get rid of the spurious relationships that are based on just a handful
    of people. The following is the matrix that we get after running the code:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到它还有一个`min_periods`参数，你可以给它，基本上是说我只想要你考虑至少，例如在这个例子中，有100人评分过两部电影的相关性评分。运行这个将消除那些只基于少数人的虚假关系。运行代码后得到的矩阵如下：
- en: '![](img/be91ed35-4a07-404c-888f-8997bbad50fd.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](img/be91ed35-4a07-404c-888f-8997bbad50fd.jpg)'
- en: It's a little bit different to what we did in the item similarities exercise
    where we just threw out any movie that was rated by less than 100 people. What
    we're doing here, is throwing out movie similarities where less than 100 people
    rated both of those movies, okay? So, you can see in the preceding matrix that
    we have a lot more `NaN` values.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们在项目相似性练习中所做的有点不同，那里我们只是扔掉了少于100人评分的任何电影。我们在这里所做的是，扔掉了少于100人评分两部电影的电影相似性，好吗？所以，你可以看到在前面的矩阵中我们有更多的`NaN`值。
- en: In fact, even movies that are similar to themselves get thrown out, so for example,
    the movie `1-900 (1994)` was, presumably, watched by fewer than 100 people so
    it just gets tossed entirely. The movie, `101 Dalmatians (1996)` however, survives
    with a correlation score of `1`, and there are actually no movies in this little
    sample of the dataset that are different from each other that had 100 people in
    common that watched both. But, there are enough movies that survive to get meaningful
    results.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，甚至与自己相似的电影也被排除了，所以例如，电影`1-900 (1994)`，据推测，被少于100人观看，所以它被完全抛弃了。然而，电影`101斑点狗
    (1996)`以相关性评分`1`幸存下来，而在这个数据集的这个小样本中，没有一部电影与另一部有100个共同观看的人不同。但是，有足够多的电影幸存下来以获得有意义的结果。
- en: Understanding movie recommendations with an example
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过示例了解电影推荐
- en: So, what we do with this data? Well, what we want to do is recommend movies
    for people. The way we do that is we look at all the ratings for a given person,
    find movies similar to the stuff that they rated, and those are candidates for
    recommendations to that person.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们用这些数据做什么呢？嗯，我们想要为人们推荐电影。我们这样做的方式是，我们查看给定人的所有评分，找到与他们评分相似的电影，这些电影就是向该人推荐的候选电影。
- en: 'Let''s start by creating a fake person to create recommendations for. I''ve
    actually already added a fake user by hand, ID number `0`, to the MovieLens dataset
    that we''re processing. You can see that user with the following code:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个虚拟人来为其创建推荐开始。我实际上已经手动添加了一个虚拟用户，ID号为`0`，到我们正在处理的MovieLens数据集中。你可以用以下代码看到该用户：
- en: '[PRE15]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This gives the following output:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这给出了以下输出：
- en: '![](img/723e6a27-f98b-476f-9fa4-a86eb43705e6.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](img/723e6a27-f98b-476f-9fa4-a86eb43705e6.jpg)'
- en: That kind of represents someone like me, who loved Star Wars and The Empire
    Strikes Back, but hated the movie Gone with the Wind. So, this represents someone
    who really loves Star Wars, but does not like old style, romantic dramas, okay?
    So, I gave a rating of `5` star to `The Empire Strikes Back (1980)` and `Star
    Wars (1977)`, and a rating of `1` star to `Gone with the Wind (1939)`. So, I'm
    going to try to find recommendations for this fictitious user.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这有点像我这样的人，我喜欢《星球大战》和《帝国反击战》，但讨厌《飘》。所以，这代表着一个真正喜欢《星球大战》的人，但不喜欢老式的浪漫戏剧，好吗？所以，我给《帝国反击战
    (1980)》和《星球大战 (1977)》评了`5`星，给《飘 (1939)》评了`1`星。所以，我要为这个虚构的用户找到推荐。
- en: So, how do I do that? Well, let's start by creating a series called `simCandidates`
    and I'm going to go through every movie that I rated.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我怎么做呢？嗯，让我们从创建一个名为`simCandidates`的系列开始，我将浏览我评分的每一部电影。
- en: '[PRE16]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: For `i` in range `0` through the number of ratings that I have in `myRatings`,
    I am going to add up similar movies to the ones that I rated. So, I'm going to
    take that `corrMatrix` DataFrame, that magical one that has all of the movie similarities,
    and I am going to create a correlation matrix with `myRatings`, drop any missing
    values, and then I am going to scale that resulting correlation score by how well
    I rated that movie.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`i`在范围`0`到我在`myRatings`中拥有的评分数量，我将把我评分的相似电影加起来。所以，我将拿那个`corrMatrix` DataFrame，那个神奇的包含所有电影相似性的，然后我将用`myRatings`创建一个相关性矩阵，删除任何缺失值，然后我将按我对那部电影的评分来缩放结果的相关性评分。
- en: So, the idea here is I'm going to go through all the similarities for The Empire
    Strikes Back, for example, and I will scale it all by 5, because I really liked
    The Empire Strikes Back. But, when I go through and get the similarities for Gone
    with the Wind, I'm only going to scale those by 1, because I did not like Gone
    with the Wind. So, this will give more strength to movies that are similar to
    movies that I liked, and less strength to movies that are similar to movies that
    I did not like, okay?
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的想法是，我将浏览例如《帝国反击战》的所有相似之处，然后将其全部缩放5倍，因为我真的很喜欢《帝国反击战》。但是，当我浏览《飘》的相似之处时，我只会将其缩放1倍，因为我不喜欢《飘》。所以，这将使与我喜欢的电影相似的电影更有力量，而与我不喜欢的电影相似的电影则更弱一些，好吗？
- en: 'So, I just go through and build up this list of similarity candidates, recommendation
    candidates if you will, sort the results and print them out. Let''s see what we
    get:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我只是浏览并建立了这个相似候选列表，如果你愿意的话，就是推荐候选，对结果进行排序并打印出来。让我们看看我们得到了什么：
- en: '![](img/0178ab85-f77e-49f4-8fc6-84cad1b327ac.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0178ab85-f77e-49f4-8fc6-84cad1b327ac.jpg)'
- en: Hey, those don't look too bad, right? So, obviously `The Empire Strikes Back
    (1980)` and `Star Wars (1977)` come out on top, because I like those movies explicitly,
    I already watched them and rated them. But, bubbling up to the top of the list
    is `Return of the Jedi (1983)`, which we would expect and `Raiders of the Lost
    Ark (1981)`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 嘿，这些看起来不错，对吧？显然，《帝国反击战》（1980）和《星球大战》（1977）排在前面，因为我明确喜欢这些电影，我已经看过并评分了。但是，排在榜单前列的还有《绝地归来》（1983），这是我们预料到的，《亚马逊探险记》（1981）也是。
- en: Let's start to refine these results a little bit more. We're seeing that we're
    getting duplicate values back. If we have a movie that was similar to more than
    one movie that I rated, it will come back more than once in the results, so we
    want to combine those together. If I do in fact have the same movie, maybe that
    should get added up together into a combined, stronger recommendation score. Return
    of the Jedi, for example, was similar to both Star Wars and The Empire Strikes
    Back. How would we do that?
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始进一步完善这些结果。我们发现我们得到了重复的值。如果有一部电影与我评分的多部电影相似，它将在结果中出现多次，所以我们希望将它们合并在一起。如果我确实有相同的电影，也许应该将它们加在一起，形成一个更强大的推荐分数。例如，《绝地归来》实际上与《星球大战》和《帝国反击战》都很相似。我们该怎么做呢？
- en: Using the groupby command to combine rows
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用groupby命令来合并行
- en: 'We''ll go ahead and explore that. We''re going to use the `groupby` command
    again to group together all of the rows that are for the same movie. Next, we
    will sum up their correlation score and look at the results:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续探索。我们将再次使用`groupby`命令来将所有属于同一部电影的行分组在一起。接下来，我们将总结它们的相关分数并查看结果：
- en: '[PRE17]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Following is the result:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是结果：
- en: '![](img/e89d095e-95a3-4e15-91f4-246750914a92.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e89d095e-95a3-4e15-91f4-246750914a92.jpg)'
- en: Hey, this is looking really good!
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 嘿，这看起来真的很不错！
- en: So `Return of the Jedi (1983)` comes out way on top, as it should, with a score
    of 7, `Raiders of the Lost Ark (1981)` a close second at 5, and then we start
    to get to `Indiana Jones and the Last Crusade (1989)`, and some more movies, `The
    Bridge on the River Kwai (1957)`, `Back to the Future (1985),``The Sting (1973`).
    These are all movies that I would actually enjoy watching! You know, I actually
    do like old-school Disney movies too, so `Cinderella (1950)` isn't as crazy as
    it might seem.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，《绝地归来》（1983）得分最高，得分为7，紧随其后的是《亚马逊探险记》（1981），得分为5，然后我们开始看到《印第安纳琼斯：最后的十字军东征》（1989）和一些其他电影，《桂河大桥》（1957），《回到未来》（1985），《刺激》（1973）。这些都是我真的会喜欢看的电影！你知道，我其实也喜欢老式的迪士尼电影，所以《灰姑娘》（1950）并不像看起来那么疯狂。
- en: The last thing we need to do is filter out the movies that I've already rated,
    because it doesn't make sense to recommend movies you've already seen.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的最后一件事是过滤掉我已经评分过的电影，因为推荐你已经看过的电影是没有意义的。
- en: Removing entries with the drop command
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用删除命令删除条目
- en: 'So, I can quickly drop any rows that happen to be in my original ratings series
    using the following code:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我可以使用以下代码快速删除任何出现在我的原始评分系列中的行：
- en: '[PRE18]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Running that will let me see the final top 10 results:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这个命令让我看到最终的前10个结果：
- en: '![](img/d3be67f7-7bc8-4daf-8fe9-6f1d17e304ec.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d3be67f7-7bc8-4daf-8fe9-6f1d17e304ec.jpg)'
- en: And there we have it! `Return of the Jedi (1983)`, `Raiders of the Lost Ark
    (1981)`, `Indiana Jones and the Last Crusade (1989)`, all the top results for
    my fictitious user, and they all make sense. I'm seeing a few family-friendly
    films, you know, `Cinderella (1950)`, `The Wizard of Oz (1939)`, `Dumbo (1941)`,
    creeping in, probably based on the presence of Gone with the Wind in there, even
    though it was weighted downward it's still in there, and still being counted.
    And, there we have our results, so. There you have it! Pretty cool!
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！《绝地归来》（1983），《亚马逊探险记》（1981），《印第安纳琼斯：最后的十字军东征》（1989），这些都是我虚构用户的前几个推荐结果，而且都很合理。我看到了一些适合家庭观看的电影，你知道，《灰姑娘》（1950），《绿野仙踪》（1939），《小飞象》（1941），可能是因为《飘》的存在，即使它的权重被降低了，但它仍然在其中，仍然被计算在内。所以，这就是我们的结果。就是这样！挺酷的！
- en: We have actually generated recommendations for a given user and we could do
    that for any user in our entire DataFrame. So, go ahead and play with that if
    you want to. I also want to talk about how you can actually get your hands dirty
    a little bit more, and play with these results; try to improve upon them.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上我们已经为特定用户生成了推荐，我们可以为数据框中的任何用户这样做。所以，如果你愿意的话，可以尝试一下。我还想谈谈你如何更深入地参与其中，玩弄这些结果；试着改进它们。
- en: There's a bit of an art to this, you know, you need to keep iterating and trying
    different ideas and different techniques until you get better and better results,
    and you can do this pretty much forever. I mean, I made a whole career out of
    it. So, I don't expect you to spend the next, you know, 10 years trying to refine
    this like I did, but there are some simple things you can do, so let's talk about
    that.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这其实是一门艺术，你知道，你需要不断迭代，尝试不同的想法和不同的技术，直到你得到越来越好的结果，你可以一直这样做。我的意思是，我把整个职业都建立在这个基础上。所以，我不指望你像我一样花10年的时间来完善这个，但是有一些简单的事情你可以做，所以让我们谈谈这个。
- en: Improving the recommendation results
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改进推荐结果
- en: As an exercise, I want to challenge you to go and make those recommendations
    even better. So, let's talk about some ideas I have, and maybe you'll have some
    of your own too that you can actually try out and experiment with; get your hands
    dirty, and try to make better movie recommendations.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个练习，我想挑战你去让这些推荐变得更好。所以，让我们谈谈我有的一些想法，也许你也有一些自己的想法，可以尝试和实验一下；动手尝试，努力做出更好的电影推荐。
- en: Okay, there's a lot of room for improvement still on these recommendation results.
    There's a lot of decisions we made about how to weigh different recommendation
    results based on your rating of that item that it came from, or what threshold
    you want to pick for the minimum number of people that rated two given movies.
    So, there's a lot of things you can tweak, a lot of different algorithms you can
    try, and you can have a lot of fun with trying to make better movie recommendations
    out of the system. So, if you're feeling up to it, I'm challenging you to go and
    do just that!
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这些推荐结果仍然有很大的改进空间。我们在如何根据你对物品的评分来权衡不同的推荐结果，或者你想要为两部给定电影评分的人数选择最低阈值等方面做出了很多决定。所以，有很多事情你可以调整，很多不同的算法你可以尝试，你可以尝试通过系统来做出更好的电影推荐。所以，如果你感兴趣，我挑战你去做到这一点！
- en: Here are some ideas on how you might actually try to improve upon the results
    in this chapter. First, you can just go ahead and play with the `ItembasedCF.ipynb`
    file and tinker with it. So, for example, we saw that the correlation method actually
    had some parameters for the correlation computation, we used Pearson in our example,
    but there are other ones you can look up and try out, see what it does to your
    results. We used a minimum period value of 100, maybe that's too high, maybe it's
    too low; we just kind of picked it arbitrarily. What happens if you play with
    that value? If you were to lower that for example, I would expect you to see some
    new movies maybe you've never heard of, but might still be a good recommendation
    for that person. Or, if you were to raise it higher, you would see, you know nothing
    but blockbusters.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些关于如何实际上尝试改进本章结果的想法。首先，你可以直接去玩`ItembasedCF.ipynb`文件并对其进行调整。例如，我们发现相关性方法实际上有一些相关性计算的参数，我们在示例中使用了Pearson，但还有其他方法可以查找和尝试，看看它对你的结果有什么影响。我们使用了最小周期值为100，也许这个值太高了，也许太低了；我们只是随意选择的。如果你调整这个值会发生什么？例如，如果你将它降低，我预计你会看到一些你从未听说过的新电影，但可能仍然是对那个人的一个很好的推荐。或者，如果你将它提高，你会看到，你知道，只有大片。
- en: Sometimes you have to think about what the result is that you want out of a
    recommender system. Is there a good balance to be had between showing people movies
    that they've heard of and movies that they haven't heard of? How important is
    discovery of new movies to these people versus having confidence in the recommender
    system by seeing a lot of movies that they have heard of? So again, there's sort
    of an art to that.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你必须考虑一下你想从推荐系统中得到什么结果。在向人们展示他们听说过的电影和他们没听说过的电影之间，是否有一个很好的平衡？对于这些人来说，发现新电影有多重要，与通过看到许多他们听说过的电影来对推荐系统产生信心有多重要？所以，这确实是一种艺术。
- en: We can also improve upon the fact that we saw a lot of movies in the results
    that were similar to Gone with the Wind, even though I didn't like Gone with the
    Wind. You know we weighted those results lower than similarities to movies that
    I enjoyed, but maybe those movies should actually be penalized. If I hated Gone
    with the Wind that much, maybe similarities to Gone with the Wind, like The Wizard
    of Oz, should actually be penalized and, you know lowered in their score instead
    of raised at all.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以改进一下，因为我们在结果中看到了很多与《飘》相似的电影，尽管我不喜欢《飘》。你知道，我们将这些结果的权重低于我喜欢的电影的相似性，但也许这些电影实际上应该受到惩罚。如果我那么讨厌《飘》，也许与《飘》相似的电影，比如《绿野仙踪》，实际上应该受到惩罚，你知道，它们的得分应该降低而不是提高。
- en: That's another simple modification you can make and play around with. There
    are probably some outliers in our user rating dataset, what if I were to throw
    away people that rated some ridiculous number of movies? Maybe they're skewing
    everything. You could actually try to identify those users and throw them out,
    as another idea. And, if you really want a big project, if you really want to
    sink your teeth into this stuff, you could actually evaluate the results of this
    recommender engine by using the techniques of train/test. So, what if instead
    of having an arbitrary recommendation score that sums up the correlation scores
    of each individual movie, actually scale that down to a predicted rating for each
    given movie.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个简单的修改，你可以尝试一下。我们的用户评分数据集中可能有一些异常值，如果我把那些评价了大量电影的人排除掉会怎么样？也许他们在影响一切。你实际上可以尝试识别这些用户并将他们排除在外，这是另一个想法。而且，如果你真的想要一个大项目，如果你真的想要深入研究这些东西，你实际上可以通过使用训练/测试的技术来评估这个推荐引擎的结果。所以，如果不是使用每部电影的相关性得分的任意推荐得分，而是将其缩小到每部电影的预测评分，会怎么样呢？
- en: If the output of my recommender system were a movie and my predicted rating
    for that movie, in a train/test system I could actually try to figure out how
    well do I predict movies that the user has in fact watched and rated before? Okay?
    So, I could set aside some of the ratings data and see how well my recommender
    system is able to predict the user's ratings for those movies. And, that would
    be a quantitative and principled way to measure the error of this recommender
    engine. But again, there's a little bit more of an art than a science to this.
    Even though the Netflix prize actually used that error metric, called root-mean-square
    error is what they used in particular, is that really a measure of a good recommender
    system?
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我的推荐系统的输出是一部电影和我对那部电影的预测评分，在一个训练/测试系统中，我实际上可以尝试弄清楚我有多好地预测了用户实际上观看并评价过的电影？好吗？所以，我可以留出一些评分数据，看看我的推荐系统能够多好地预测用户对这些电影的评分。这将是一种定量和有原则的方法来衡量这个推荐引擎的误差。但是，这里比科学更多一点艺术。即使Netflix奖实际上使用了那个误差度量，称为均方根误差，这是他们特别使用的，但这真的是一个好的推荐系统的衡量标准吗？
- en: Basically, you're measuring the ability of your recommender system to predict
    the ratings of movies that a person already watched. But isn't the purpose of
    a recommender engine to recommend movies that a person hasn't watched, that they
    might enjoy? Those are two different things. So unfortunately, it's not very easy
    to measure the thing you really want to be measuring. So sometimes, you do kind
    of have to go with your gut instinct. And, the right way to measure the results
    of a recommender engine is to measure the results that you're trying to promote
    through it.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，你正在衡量你的推荐系统预测一个人已经观看的电影的能力。但是推荐引擎的目的不是推荐一个人尚未观看但可能会喜欢的电影吗？这是两回事。所以不幸的是，很难衡量你真正想要衡量的东西。有时，你确实必须凭直觉行事。而且，衡量推荐引擎结果的正确方式是衡量你试图通过它来推广的结果。
- en: Maybe I'm trying to get people to watch more movies, or rate new movies more
    highly, or buy more stuff. Running actual controlled experiments on a real website
    would be the right way to optimize for that, as opposed to using train/test. So,
    you know, I went into a little bit more detail there than I probably should have,
    but the lesson is, you can't always think about these things in black and white.
    Sometimes, you can't really measure things directly and quantitatively, and you
    have to use a little bit of common sense, and this is an example of that.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 也许我试图让人们观看更多电影，或者更高评价新电影，或者购买更多东西。在真实网站上运行实际的控制实验将是优化的正确方式，而不是使用训练/测试。所以，你知道，我在那里详细介绍了一点，但教训是，你不能总是以黑白思维来考虑这些事情。有时，你不能直接和定量地衡量事物，你必须运用一点常识，这就是一个例子。
- en: Anyway, those are some ideas on how to go back and improve upon the results
    of this recommender engine that we wrote. So, please feel free to tinker around
    with it, see if you can improve upon it however you wish to, and have some fun
    with it. This is actually a very interesting part of the book, so I hope you enjoy
    it!
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，这些是一些关于如何回头改进我们编写的推荐引擎结果的想法。所以，请随意尝试一下，看看你是否可以按照自己的意愿改进它，并且玩得开心。这实际上是书中非常有趣的部分，所以我希望你会喜欢它！
- en: Summary
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: So, go give it a try! See if you can improve on our initial results there. There's
    some simple ideas there to try to make those recommendations better, and some
    much more complicated ones too. Now, there's no right or wrong answer; I'm not
    going to ask you to turn in your work, and I'm not going to review your work.
    You know, you decide to play around with it and get some familiarity with it,
    and experiment, and see what results you get. That's the whole point - just to
    get you more familiar with using Python for this sort of thing, and get more familiar
    with the concepts behind item-based collaborative filtering.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，去尝试一下吧！看看你是否可以改进我们的初始结果。有一些简单的想法可以尝试使这些推荐更好，还有一些更复杂的想法。现在，没有对错答案；我不会要求你交作业，也不会审查你的工作。你知道，你决定玩弄它并熟悉一下，进行实验，看看你得到什么结果。这就是整个目的-只是让你更熟悉使用Python进行这种工作，并更熟悉基于物品的协同过滤背后的概念。
- en: We've looked at different recommender systems in this chapter-we ruled out a
    user-based collaborative filtering system and dove straight in to an item-based
    system. We then used various functions from pandas to generate and refine our
    results, and I hope you've seen the power of pandas here.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看了不同的推荐系统-我们排除了基于用户的协同过滤系统，直接进入了基于物品的系统。然后，我们使用了pandas的各种函数来生成和完善我们的结果，我希望你在这里看到了pandas的强大之处。
- en: In the next chapter, we'll take a look at more advanced data mining and machine
    learning techniques including K-nearest neighbors. I look forward to explaining
    those to you and seeing how they can be useful.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入研究更高级的数据挖掘和机器学习技术，包括K最近邻算法。我期待着向你解释这些内容，并看看它们如何有用。
