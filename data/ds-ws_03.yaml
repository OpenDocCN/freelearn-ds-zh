- en: 3\. Binary Classification
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3. 二元分类
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we will be using a real-world dataset and a supervised learning
    technique called classification to generate business outcomes.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用一个现实世界的数据集，并使用一种名为分类的监督学习技术来生成商业结果。
- en: By the end of this chapter, you will be able to formulate a data science problem
    statement from a business perspective; build hypotheses from various business
    drivers influencing a use case and verify the hypotheses using exploratory data
    analysis; derive features based on intuitions that are derived from exploratory
    analysis through feature engineering; build binary classification models using
    a logistic regression function and analyze classification metrics and formulate
    action plans for the improvement of the model.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够从商业角度制定数据科学问题陈述；根据影响使用案例的各种商业驱动因素建立假设，并通过探索性数据分析验证这些假设；通过特征工程基于探索性分析中的直觉派生特征；使用逻辑回归函数建立二元分类模型，并分析分类指标，制定模型改进的行动计划。
- en: Introduction
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In previous chapters, where an introduction to machine learning was covered,
    you were introduced to two broad categories of machine learning; supervised learning
    and unsupervised learning. Supervised learning can be further divided into two
    types of problem cases, regression and classification. In the last chapter, we
    covered regression problems. In this chapter, we will peek into the world of classification problems.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，介绍了机器学习的两个广泛类别；监督学习和无监督学习。监督学习可以进一步细分为两种类型的问题：回归和分类。在上一章中，我们讨论了回归问题。在本章中，我们将窥探分类问题的世界。
- en: 'Take a look at the following *Figure 3.1*:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下的*图3.1*：
- en: '![Figure 3.1: Overview of machine learning algorithms'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.1：机器学习算法概述'
- en: '](img/B15019_03_01.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15019_03_01.jpg)'
- en: 'Figure 3.1: Overview of machine learning algorithms'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1：机器学习算法概述
- en: 'Classification problems are the most prevalent use cases you will encounter
    in the real world. Unlike regression problems, where a real numbered value is
    predicted, classification problems deal with associating an example to a category.
    Classification use cases will take forms such as the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 分类问题是你在现实世界中最常遇到的用例。与回归问题不同，回归问题预测的是一个实际数值，而分类问题则处理将一个示例与一个类别关联。分类用例将呈现以下几种形式：
- en: Predicting whether a customer will buy the recommended product
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预测客户是否会购买推荐的产品
- en: Identifying whether a credit transaction is fraudulent
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定信用交易是否为欺诈性交易
- en: Determining whether a patient has a disease
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定患者是否患有某种疾病
- en: Analyzing images of animals and predicting whether the image is of a dog, cat,
    or panda
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析动物的图像并预测图像是狗、猫还是熊猫
- en: Analyzing text reviews and capturing the underlying emotion such as happiness,
    anger, sorrow, or sarcasm
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析文本评论并捕捉潜在的情绪，如幸福、愤怒、悲伤或讽刺
- en: 'If you observe the preceding examples, there is a subtle difference between
    the first three and the last two. The first three revolve around binary decisions:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果观察前述示例，会发现前三个和最后两个之间有一个微妙的区别。前三个围绕二元决策：
- en: Customers can either buy the product or not.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户可以选择购买产品或不购买。
- en: Credit card transactions can be fraudulent or legitimate.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信用卡交易可能是欺诈性的或合法的。
- en: Patients can be diagnosed as positive or negative for a disease.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 患者可以被诊断为疾病的阳性或阴性。
- en: Use cases that align with the preceding three genres where a binary decision
    is made are called binary classification problems. Unlike the first three, the
    last two associate an example with multiple classes or categories. Such problems
    are called multiclass classification problems. This chapter will deal with binary
    classification problems. Multiclass classification will be covered next in *Chapter
    4*, *Multiclass Classification with RandomForest*.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 与前述三种类型对齐的用例，其中做出二元决策的问题称为二元分类问题。与前三者不同，后两者将一个示例与多个类别或类别关联。这类问题被称为多类别分类问题。本章将讨论二元分类问题。多类别分类将在*第4章*中介绍，*随机森林的多类别分类*。
- en: Understanding the Business Context
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解商业背景
- en: The best way to work using a concept is with an example you can relate to. To
    understand the business context, let's, for instance, consider the following example.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 使用一个与你相关的示例来理解概念是最好的方法。为了理解商业背景，我们可以考虑以下示例。
- en: The marketing head of the bank where you are a data scientist approaches you
    with a problem they would like to be addressed. The marketing team recently completed
    a marketing campaign where they have collated a lot of information on existing
    customers. They require your help to identify which of these customers are likely
    to buy a term deposit plan. Based on your assessment of the customer base, the
    marketing team will chalk out strategies for target marketing. The marketing team
    has provided access to historical data of past campaigns and their outcomes—that
    is, whether the targeted customers really bought the term deposits or not. Equipped
    with the historical data, you have set out on the task to identify the customers
    with the highest propensity (an inclination) to buy term deposits.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你作为一名数据科学家，所在银行的营销负责人找到你，希望解决一个问题。最近，营销团队完成了一项营销活动，他们已经收集了关于现有客户的大量信息。他们需要你帮助确定哪些客户可能会购买定期存款计划。根据你对客户群体的评估，营销团队将制定目标营销策略。营销团队提供了过去营销活动及其结果的历史数据，即目标客户是否真的购买了定期存款。凭借历史数据，你已经开始了识别具有最高购买倾向（倾向）的客户的任务。
- en: Business Discovery
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 业务发现
- en: The first process when embarking on a data science problem like the preceding
    is the business discovery process. This entails understanding various drivers
    influencing the business problem. Getting to know the business drivers is important
    as it will help in formulating hypotheses about the business problem, which can
    be verified during the **exploratory data analysis** (**EDA**). The verification
    of hypotheses will help in formulating intuitions for feature engineering, which
    will be critical for the veracity of the models that we build.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，像前述这样从事数据科学问题的第一个过程是业务发现过程。这包括理解影响业务问题的各种驱动因素。了解业务驱动因素很重要，因为这将有助于制定关于业务问题的假设，在探索性数据分析（EDA）期间可以进行验证。验证假设将有助于制定特征工程的直觉，这对我们构建的模型的准确性至关重要。
- en: 'Let''s understand this process in detail from the context of our use case.
    The problem statement is to identify those customers who have a propensity to
    buy term deposits. As you might be aware, term deposits are bank instruments where
    your money will be locked for a certain period, assuring higher interest rates
    than saving accounts or interest-bearing checking accounts. From an investment
    propensity perspective, term deposits are generally popular among risk-averse
    customers. Equipped with the business context, let''s look at some questions on
    business factors influencing a propensity to buy term deposits:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从我们用例的背景详细了解这个过程。问题陈述是识别那些有购买定期存款倾向的客户。如你所知，定期存款是一种银行工具，您的资金将被锁定一段时间，提供比储蓄账户或带息支票账户更高的利率。从投资倾向的角度来看，定期存款通常受到风险厌恶型客户的欢迎。有了业务背景，让我们看看一些影响购买定期存款倾向的业务因素的问题：
- en: Would age be a factor, with more propensity shown by the elderly?
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 年龄会是一个因素吗？老年人显示更高的购买倾向吗？
- en: Is there any relationship between employment status and the propensity to buy
    term deposits?
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 就业状态与购买定期存款的倾向之间是否存在任何关系？
- en: Would the asset portfolio of a customer—that is, house, loan, or higher bank
    balance—influence the propensity to buy?
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 顾客的资产组合（即房屋、贷款或更高的银行存款）会影响购买的倾向吗？
- en: Will demographics such as marital status and education influence the propensity
    to buy term deposits? If so, how are demographics correlated to a propensity to buy?
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 人口统计信息，如婚姻状况和教育水平，会影响购买定期存款的倾向吗？如果会，人口统计数据与购买倾向之间如何相关？
- en: Formulating questions on the business context is critical as this will help
    in arriving at various trails that we can take when we do exploratory analysis.
    We will deal with that in the next section. First, let's explore the data related
    to the preceding business problem.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行探索性分析时，制定有关业务背景的问题至关重要。在我们进行探索性分析时，这将有助于我们找出可以采取的各种路径。让我们先来探索与前述业务问题相关的数据。
- en: 'Exercise 3.01: Loading and Exploring the Data from the Dataset'
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 3.01：从数据集中加载和探索数据
- en: In this exercise, we will load the dataset in our Colab notebook and do some
    basic explorations such as printing the dimensions of the dataset using the `.shape()`
    function and generating summary statistics of the dataset using the `.describe()` function.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在本次练习中，我们将在Colab笔记本中加载数据集，并进行一些基本的探索，如使用`.shape()`函数打印数据集的维度，并使用`.describe()`函数生成数据集的汇总统计信息。
- en: Note
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The dataset for this exercise is the bank dataset, courtesy of S. Moro, P.
    Cortez and P. Rita: A Data-Driven Approach to Predict the Success of Bank Telemarketing.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 本次练习使用的数据集是银行数据集，感谢S. Moro、P. Cortez和P. Rita提供：《一种数据驱动方法预测银行电话营销的成功》。
- en: 'It is from the UCI Machine Learning Repository: [https://packt.live/2MItXEl](https://packt.live/2MItXEl)
    and can be downloaded from our GitHub at: [https://packt.live/2Wav1nJ](https://packt.live/2Wav1nJ).'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 数据集来源于UCI机器学习库：[https://packt.live/2MItXEl](https://packt.live/2MItXEl)，并且可以从我们的GitHub上下载：[https://packt.live/2Wav1nJ](https://packt.live/2Wav1nJ)。
- en: 'The following steps will help you to complete this exercise:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助你完成本次练习：
- en: Open a new Colab notebook.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的Colab笔记本。
- en: 'Now, `import` `pandas` as `pd` in your Colab notebook:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在你的Colab笔记本中，`import` `pandas` 为`pd`：
- en: '[PRE0]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Assign the link to the dataset to a variable called `file_url`
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将数据集的链接分配给一个名为`file_url`的变量
- en: '[PRE1]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, read the file using the `pd.read_csv()` function from the pandas DataFrame:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用`pd.read_csv()`函数读取文件，来自pandas的DataFrame：
- en: '[PRE2]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You should get the following output:'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该获得以下输出：
- en: '![Figure 3.2: Loading data into a Colab notebook'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图3.2：将数据加载到Colab笔记本中'
- en: '](img/B15019_03_02.jpg)'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15019_03_02.jpg)'
- en: 'Figure 3.2: Loading data into a Colab notebook'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图3.2：将数据加载到Colab笔记本中
- en: Here, we loaded the `CSV` file and then stored it as a pandas DataFrame for
    further analysis.
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里，我们加载了`CSV`文件并将其存储为pandas DataFrame，以便进一步分析。
- en: 'Next, print the shape of the dataset, as mentioned in the following code snippet:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，打印数据集的形状，如以下代码片段所示：
- en: '[PRE3]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: (45211, 17)
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: (45211, 17)
- en: '[PRE4]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, find the summary of the numerical raw data as a table output using the
    `.describe()` function in pandas, as mentioned in the following code snippet:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用pandas中的`.describe()`函数，以表格输出的方式查找数值原始数据的摘要，如以下代码片段所示：
- en: '[PRE5]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You should get the following output:'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该获得以下输出：
- en: '![Figure 3.3: Loading data into a Colab notebook'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图3.3：将数据加载到Colab笔记本中'
- en: '](img/B15019_03_03.jpg)'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15019_03_03.jpg)'
- en: 'Figure 3.3: Loading data into a Colab notebook'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3：将数据加载到Colab笔记本中
- en: As seen from the shape of the data, the dataset has `45211` examples with `17`
    variables. The variable set has both categorical and numerical variables. The
    preceding summary statistics are derived only for the numerical data.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 从数据的形状来看，数据集有`45211`个样本，包含`17`个变量。变量集包括分类变量和数值变量。前面的汇总统计值仅针对数值数据得出。
- en: Note
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/31UQhAU](https://packt.live/31UQhAU).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问这一特定部分的源代码，请参考[https://packt.live/31UQhAU](https://packt.live/31UQhAU)。
- en: You can also run this example online at [https://packt.live/2YdiSAF](https://packt.live/2YdiSAF).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在[https://packt.live/2YdiSAF](https://packt.live/2YdiSAF)在线运行这个示例。
- en: You have completed the first tasks that are required before embarking on our
    journey. In this exercise, you have learned how to load data and to derive basic
    statistics, such as the summary statistics, from the dataset. In the subsequent
    dataset, we will take a deep dive into the loaded dataset.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经完成了开始我们旅程之前所需的第一项任务。在本次练习中，你学习了如何加载数据并从数据集中得出基本统计数据，如汇总统计值。在随后的数据集中，我们将深入分析加载的数据集。
- en: Testing Business Hypotheses Using Exploratory Data Analysis
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用探索性数据分析测试业务假设
- en: In the previous section, you approached the problem statement from a domain
    perspective, thereby identifying some of the business drivers. Once business drivers
    are identified, the next step is to evolve some hypotheses about the relationship
    of these business drivers and the business outcome you have set out to achieve.
    These hypotheses need to be verified using the data you have. This is where **exploratory
    data analysis** (**EDA**) plays a big part in the data science life cycle.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，你从领域的角度接近了问题的陈述，识别了一些业务驱动因素。一旦识别出业务驱动因素，下一步是提出一些关于这些业务驱动因素与所设定的业务结果之间关系的假设。这些假设需要使用你所拥有的数据进行验证。**探索性数据分析**（**EDA**）在数据科学生命周期中发挥了重要作用。
- en: Let's return to the problem statement we are trying to analyze. From the previous
    section, we identified some business drivers such as age, demographics, employment
    status, and asset portfolio, which we feel will influence the propensity for buying
    a term deposit. Let's go ahead and formulate our hypotheses on some of these business
    drivers and then verify them using EDA.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们试图分析的问题。从上一节中，我们识别了一些商业驱动因素，如年龄、人口统计学、就业状况和资产组合，这些因素可能会影响购买定期存款的倾向。现在让我们根据这些商业驱动因素提出假设，并通过EDA进行验证。
- en: Visualization for Exploratory Data Analysis
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索性数据分析的可视化
- en: 'Visualization is imperative for EDA. Effective visualization helps in deriving
    business intuitions from the data. In this section, we will introduce some of
    the visualization techniques that will be used for EDA:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 可视化是探索性数据分析（EDA）中的关键。有效的可视化有助于从数据中提取商业直觉。在本节中，我们将介绍一些用于EDA的可视化技术：
- en: '**Line graphs**: Line graphs are one of the simplest forms of visualization.
    Line graphs are the preferred method for revealing trends in the data. These types
    of graphs are mostly used for continuous data. We will be generating this graph
    in *Exercise 3.02*, *Business Hypothesis Testing for Age versus Propensity for
    a Term Loan*.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**折线图**：折线图是最简单的可视化形式之一。折线图是揭示数据趋势的首选方法。这种图表通常用于展示连续数据。我们将在*练习3.02*中生成这种图表，即*关于年龄与定期贷款倾向的商业假设检验*。'
- en: 'Here is what a line graph looks like:'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下面是折线图的示例：
- en: '![Figure 3.4: Example of a line graph'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图3.4：折线图示例](img/B15019_03_05.jpg)'
- en: '](img/B15019_03_04.jpg)'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15019_03_04.jpg)'
- en: 'Figure 3.4: Example of a line graph'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4：折线图示例
- en: '**Histograms**: Histograms are plots of the proportion of data along with some
    specified intervals. They are mostly used for visualizing the distribution of
    data. Histograms are very effective for identifying whether data distribution
    is symmetric and for identifying outliers in data. We will be looking at histograms
    in much more detail later in this chapter.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**直方图**：直方图是显示数据比例与指定区间的图表。它们通常用于可视化数据的分布。直方图非常有效，用于识别数据分布是否对称，以及识别数据中的异常值。我们将在本章后面更详细地讨论直方图。'
- en: 'Here is what a histogram looks like:'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下面是直方图的示例：
- en: '![Figure 3.5: Example of a histogram'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图3.5：直方图示例](img/B15019_03_06.jpg)'
- en: '](img/B15019_03_05.jpg)'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15019_03_05.jpg)'
- en: 'Figure 3.5: Example of a histogram'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5：直方图示例
- en: '**Density plots**: Like histograms, density plots are also used for visualizing
    the distribution of data. However, density plots give a smoother representation
    of the distribution. We will be looking at this later in this chapter.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**密度图**：像直方图一样，密度图也用于可视化数据的分布。然而，密度图提供了更平滑的分布表现。我们将在本章稍后讨论这一点。'
- en: 'Here is what a density plot looks like:'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下面是密度图的示例：
- en: '![Figure 3.6: Example of a density plot'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图3.6：密度图示例](img/B15019_03_06.jpg)'
- en: '](img/B15019_03_06.jpg)'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15019_03_06.jpg)'
- en: 'Figure 3.6: Example of a density plot'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6：密度图示例
- en: '`Yes` and `No`, on a single bar. This can be done using the stacked bar chart,
    which cannot be done on the other charts.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Yes`和`No`，在同一条条形图上。这可以通过堆叠条形图实现，而其他图表则无法做到这一点。'
- en: Let's create some dummy data and generate a stacked bar chart to check the proportion
    of jobs in different sectors.
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们创建一些虚拟数据并生成堆叠条形图，以检查不同领域中的职位比例。
- en: '[PRE6]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, create some sample data detailing a list of jobs:'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接下来，创建一些样本数据，详细列出职位列表：
- en: '[PRE7]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Each job will have two categories to be plotted, `yes` and `No`, with some
    proportion between `yes` and `No`. These are detailed as follows:'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每个职位将有两个类别需要绘制，`yes`和`No`，它们之间存在某种比例。具体细节如下：
- en: '[PRE8]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the next steps, the length of the job list is taken for plotting `xlabels`
    and then they are arranged using the `np.arange()` function:'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在接下来的步骤中，将计算职位列表的长度来绘制`xlabels`，然后使用`np.arange()`函数进行排列：
- en: '[PRE9]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next, let''s define the width of each bar and do the plotting. In the plot,
    `p2`, we define that when stacking, `yes` will be at the bottom and `No` at top:'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接下来，定义每个条形的宽度并进行绘图。在图表`p2`中，我们定义堆叠时，`yes`位于底部，`No`位于顶部：
- en: '[PRE10]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Define the labels for the *Y* axis and the title of the plot:'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 定义*Y*轴的标签和图表标题：
- en: '[PRE11]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The indexes for the *X* and *Y* axes are defined next. For the *X* axis, the
    list of jobs are given, and, for the *Y* axis, the indices are in proportion from
    `0` to `100` with an increment of `10` (0, 10, 20, 30, and so on):'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接下来定义*X*轴和*Y*轴的索引。对于*X*轴，列出各个职位，而对于*Y*轴，索引是从`0`到`100`的比例，增量为`10`（0, 10, 20,
    30，依此类推）：
- en: '[PRE12]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The last step is to define the legends and to rotate the axis labels to `90`
    degrees. The plot is finally displayed:'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后一步是定义图例并将坐标轴标签旋转至`90`度。最终显示图表：
- en: '[PRE13]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here is what a stacked bar chart looks like based on the preceding example:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是基于前面示例的堆叠条形图的样子：
- en: '![Figure 3.7: Example of a stacked bar plot'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.7：堆叠条形图示例](img/B15019_03_07.jpg)'
- en: '](img/B15019_03_07.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15019_03_08.jpg)'
- en: 'Figure 3.7: Example of a stacked bar plot'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.7：堆叠条形图示例
- en: Let's use these graphs in the following exercises and activities.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在接下来的练习和活动中使用这些图表。
- en: 'Exercise 3.02: Business Hypothesis Testing for Age versus Propensity for a
    Term Loan'
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 3.02：年龄与定期贷款购买倾向的商业假设验证
- en: The goal of this exercise is to define a hypothesis to check the propensity
    for an individual to purchase a term deposit plan against their age. We will be
    using a line graph for this exercise.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习的目标是定义一个假设，检查个人购买定期存款计划的倾向与他们的年龄之间的关系。我们将在这个练习中使用折线图。
- en: 'The following steps will help you to complete this exercise:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助你完成这个练习：
- en: Begin by defining the hypothesis.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从定义假设开始。
- en: The first step in the verification process will be to define a hypothesis about
    the relationship. A hypothesis can be based on your experiences, domain knowledge,
    some published pieces of knowledge, or your business intuitions.
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 验证过程的第一步是定义一个关于关系的假设。假设可以基于你的经验、领域知识、一些已发布的知识或你的商业直觉。
- en: 'Let''s first define our hypothesis on age and propensity to buy term deposits:'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 首先，我们定义关于年龄与购买定期存款倾向的假设：
- en: '*The propensity to buy term deposits is more with elderly customers compared
    to younger ones*. This is our hypothesis.'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*老年客户比年轻客户更倾向于购买定期存款*。这是我们的假设。'
- en: Now that we have defined our hypothesis, it is time to verify its veracity with
    the data. One of the best ways to get business intuitions from data is by taking
    cross-sections of our data and visualizing them.
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们已经定义了假设，是时候用数据来验证它的真实性了。通过从数据中提取横截面并进行可视化，是从数据中获得商业直觉的最佳方式之一。
- en: 'Import the pandas and altair packages:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`pandas`和`altair`包：
- en: '[PRE14]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next, you need to load the dataset, just like you loaded the dataset in *Exercise
    3.01*, *Loading and Exploring the Data from the Dataset*:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，你需要加载数据集，就像在*练习 3.01*中加载数据集一样，*加载和探索数据集中的数据*：
- en: '[PRE15]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: '*Steps 2-3* will be repeated in the following exercises for this chapter.'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*步骤 2-3*将在本章的后续练习中重复进行。'
- en: We will be verifying how the purchased term deposits are distributed by age.
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将验证购买定期存款的情况如何按年龄分布。
- en: Next, we will count the number of records for each age group. We will be using
    the combination of `.groupby()`, `.agg()`, `.reset_index()` methods from `pandas`.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将统计每个年龄组的记录数量。我们将使用`pandas`中的`.groupby()`、`.agg()`、`.reset_index()`方法的组合。
- en: '[PRE16]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We first take the pandas `DataFrame`, `bankData`, which we loaded in *Exercise
    3.01*, *Loading and Exploring the Data from the Dataset* and then filter it for
    all cases where the term deposit is yes using the mask `bankData['y'] == 'yes'`.
    These cases are grouped through the `groupby()` method and then aggregated according
    to age through the `agg()` method. Finally we need to use `.reset_index()` to
    get a well-structure DataFrame that will be stored in a new `DataFrame` called
    `bankSub1`.
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们首先取出在*练习 3.01*中加载的`pandas` `DataFrame`，`bankData`，然后使用掩码`bankData['y'] ==
    'yes'`筛选出所有定期存款为“是”的案例。这些案例通过`groupby()`方法进行分组，然后通过`agg()`方法根据年龄进行聚合。最后，我们需要使用`.reset_index()`获取一个结构良好的`DataFrame`，并将其存储在一个新的`DataFrame`中，称为`bankSub1`。
- en: 'Now, plot a line chart using altair and the `.Chart().mark_line().encode()`
    methods and we will define the `x` and `y` variables, as shown in the following
    code snippet:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用`altair`和`.Chart().mark_line().encode()`方法绘制折线图，我们将定义`x`和`y`变量，如下所示的代码片段：
- en: '[PRE17]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You should get the following output:'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该得到以下输出：
- en: '![Figure 3.8: Relationship between age and propensity to purchase'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 3.8：年龄与购买倾向之间的关系](img/B15019_03_07.jpg)'
- en: '](img/B15019_03_08.jpg)'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15019_03_08.jpg)'
- en: 'Figure 3.8: Relationship between age and propensity to purchase'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 3.8：年龄与购买倾向之间的关系
- en: From the plot, we can see that the highest number of term deposit purchases
    are done by customers within an age range between 25 and 40, with the propensity
    to buy tapering off with age.
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从图表中我们可以看到，定期存款购买的数量在年龄范围为 25 至 40 岁之间的客户中最高，且购买倾向随着年龄的增长逐渐减弱。
- en: This relationship is quite counterintuitive from our assumptions in the hypothesis,
    right? But, wait a minute, aren't we missing an important point here? We are taking
    the data based on the absolute count of customers in each age range. If the proportion
    of banking customers is higher within the age range of 25 to 40, then we are very
    likely to get a plot like the one that we have got. What we really should plot
    is the proportion of customers, within each age group, who buy a term deposit.
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个关系和我们在假设中的预期相反，对吧？但是，等一下，难道我们没有忽略一个重要的点吗？我们是根据每个年龄段客户的绝对数量来处理数据的。如果25到40岁年龄段的银行客户比例较高，那么我们很可能会得到类似我们当前得到的图表。我们真正应该绘制的是每个年龄段内，购买定期存款的客户比例。
- en: Let's look at how we can represent the data by taking the proportion of customers.
    Just like you did in the earlier steps, we will aggregate the customer propensity
    with respect to age, and then divide each category of buying propensity by the
    total number of customers in that age group to get the proportion.
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们看看如何通过获取客户比例来表示数据。就像您在之前的步骤中所做的那样，我们将根据年龄对客户购买倾向进行汇总，然后将每个购买倾向类别除以该年龄组内的总客户数，从而得到比例。
- en: 'Group the data per age using the `groupby()` method and find the total number
    of customers under each age group using the `agg()` method:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`groupby()`方法按年龄对数据进行分组，并使用`agg()`方法找到每个年龄组内客户的总数：
- en: '[PRE18]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The output is as follows:'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 3.9: Customers per age group'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 3.9：各年龄段客户'
- en: '](img/B15019_03_09.jpg)'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15019_03_09.jpg)'
- en: 'Figure 3.9: Customers per age group'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 3.9：各年龄段客户
- en: 'Now, group the data by both age and propensity of purchase and find the total
    counts under each category of propensity, which are `yes` and `no`:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，按年龄和购买倾向对数据进行分组，并找到每个购买倾向类别（`yes`和`no`）下的总计数：
- en: '[PRE19]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The output is as follows:'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 3.10: Propensity by age group'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 3.10：各年龄段购买倾向'
- en: '](img/B15019_03_10.jpg)'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15019_03_10.jpg)'
- en: 'Figure 3.10: Propensity by age group'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 3.10：各年龄段购买倾向
- en: 'Merge both of these DataFrames based on the `age` variable using the `pd.merge()`
    function, and then divide each category of propensity within each age group by
    the total customers in the respective age group to get the proportion of customers,
    as shown in the following code snippet:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`pd.merge()`函数根据`age`变量合并这两个DataFrame，然后将每个年龄组内的购买倾向类别除以该年龄组内的总客户数，从而得到客户比例，如以下代码片段所示：
- en: '[PRE20]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The output is as follows:'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 3.11: Merged DataFrames with proportion of customers by age group'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 3.11：按年龄组合并的DataFrame及客户比例'
- en: '](img/B15019_03_11.jpg)'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15019_03_11.jpg)'
- en: 'Figure 3.11: Merged DataFrames with proportion of customers by age group'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 3.11：按年龄组合并的DataFrame及客户比例
- en: 'Now, display the proportion where you plot both categories (yes and no) as
    separate plots. This can be achieved through a method within `altair` called `facet()`:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，显示比例图表，分别将`yes`和`no`类别作为单独的图表进行绘制。这可以通过`altair`中的`facet()`方法实现：
- en: '[PRE21]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This function makes as many plots as there are categories within the variable.
    Here, we give the `''y''` variable, which is the variable name for the `yes` and
    `no` categories to the `facet()` function, and we get two different plots: one
    for `yes` and another for `no`.'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个函数会根据变量中类别的数量生成相应数量的图表。在这里，我们将`'y'`变量（即表示`yes`和`no`类别的变量名称）传递给`facet()`函数，得到两个不同的图表：一个表示`yes`，另一个表示`no`。
- en: 'You should get the following output:'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您应该得到以下输出：
- en: '![Figure 3.12: Visualizing normalized relationships'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 3.12：可视化标准化关系'
- en: '](img/B15019_03_12.jpg)'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15019_03_12.jpg)'
- en: 'Figure 3.12: Visualizing normalized relationships'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.12：可视化标准化关系
- en: By the end of this exercise, you were able to get two meaningful plots showing
    the propensity of people to buy term deposit plans. The final output for this
    exercise shows two graphs in which the left graph shows the proportion of people
    who do not buy term deposits and the right one shows those customers who buy term
    deposits.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在本次练习结束时，您应该能够得到两个有意义的图表，展示人们购买定期存款计划的倾向。该练习的最终输出展示了两个图表，左侧图表显示的是没有购买定期存款的人群比例，右侧图表显示的是购买定期存款的客户。
- en: We can see, in the first graph, with the age group beginning from `22` to `60`,
    individuals would not be inclined to purchase the term deposit. However, in the
    second graph, we see the opposite, where the age group of `60` and over are much
    more inclined to purchase the term deposit plan.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，在第一个图表中，年龄从`22`岁到`60`岁之间的个体并不倾向于购买定期存款。然而，在第二个图表中，我们看到相反的情况，`60`岁及以上的群体更倾向于购买定期存款计划。
- en: Note
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/3iOw7Q4](https://packt.live/3iOw7Q4).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 若要访问此部分的源代码，请参考[https://packt.live/3iOw7Q4](https://packt.live/3iOw7Q4)。
- en: This section does not currently have an online interactive example, but can
    be run as usual on Google Colab.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 本节目前没有在线互动示例，但可以像往常一样在Google Colab上运行。
- en: In the following section, we will begin to analyze our plots based on our intuitions.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将开始基于我们的直觉分析我们的图表。
- en: Intuitions from the Exploratory Analysis
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索性分析中的直觉
- en: What are the intuitions we can take out of the exercise that we have done so
    far? We have seen two contrasting plots by taking the proportion of users and
    without taking the proportions. As you can see, taking the proportion of users
    is the right approach to get the right perspective in which we must view data.
    This is more in line with the hypothesis that we have evolved. We can see from
    the plots that the propensity to buy term deposits is low for age groups from
    `22` to around `60`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们从这个练习中能提取出哪些直觉？我们通过考虑用户的比例和不考虑比例的两种不同情形看到了两种对比的图表。正如你所看到的，考虑用户比例是获取正确视角的正确方法，这是我们假设所要求的视角。我们从图表中可以看出，从`22`岁到大约`60`岁之间的年龄段，定期存款的购买倾向较低。
- en: After `60`, we see a rising trend in the demand for term deposits. Another interesting
    fact we can observe is the higher proportion of term deposit purchases for ages
    younger than `20`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在`60`岁之后，我们看到定期存款需求呈上升趋势。另一个有趣的事实是，`20`岁以下的群体有较高的定期存款购买比例。
- en: In *Exercise 3.02*, *Business Hypothesis Testing for Age versus Propensity for
    a Term Loan* we discovered how to develop our hypothesis and then verify the hypothesis
    using EDA. After the following activity, we will delve into another important
    step in the journey, Feature Engineering.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在*练习3.02*中，*关于年龄与定期贷款倾向的商业假设检验*，我们发现了如何发展我们的假设，然后使用EDA验证这个假设。在接下来的活动中，我们将深入探讨旅程中的另一个重要步骤——特征工程。
- en: 'Activity 3.01: Business Hypothesis Testing to Find Employment Status versus
    Propensity for Term Deposits'
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动3.01：商业假设检验，找出就业状态与定期存款倾向的关系
- en: You are working as a data scientist for a bank. You are provided with historical
    data from the management of the bank and are asked to try to formulate a hypothesis
    between employment status and the propensity to buy term deposits.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 你正在为一家银行担任数据科学家。你收到了来自银行管理层的历史数据，并被要求尝试建立就业状态与定期存款购买倾向之间的假设。
- en: In *Exercise 3.02*, *Business Hypothesis Testing for Age versus Propensity for
    a Term Loan* we worked on a problem to find the relationship between age and the
    propensity to buy term deposits. In this activity, we will use a similar route
    and verify the relationship between employment status and term deposit purchase
    propensity.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在*练习3.02*中，*关于年龄与定期贷款倾向的商业假设检验*，我们解决了一个问题，旨在寻找年龄与定期存款购买倾向之间的关系。在这个活动中，我们将采用类似的路线，并验证就业状态与定期存款购买倾向之间的关系。
- en: 'The steps are as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤如下：
- en: 'Formulate the hypothesis between employment status and the propensity for term
    deposits. Let the hypothesis be as follows: *High paying employees prefer term
    deposits than other categories of employees*.'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建关于就业状态和定期存款倾向之间的假设。假设如下：*高薪员工比其他类别的员工更倾向于选择定期存款*。
- en: Open a Colab notebook file similar to what was used in *Exercise 3.02*, *Business
    Hypothesis Testing for Age versus Propensity for a Term Loan* and install and
    import the necessary libraries such as `pandas` and `altair`.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个类似于*练习3.02*中使用的Colab笔记本文件，并安装和导入必要的库，如`pandas`和`altair`。
- en: From the banking DataFrame, `bankData`, find the distribution of employment
    status using the `.groupby()`, `.agg()` and `.reset_index()` methods.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从银行数据框`bankData`中，使用`.groupby()`、`.agg()`和`.reset_index()`方法查找就业状态的分布。
- en: Group the data with respect to employment status using the `.groupby()` method
    and find the total count of propensities for each employment status using the
    `.agg()` method.
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用`.groupby()`方法按就业状态对数据进行分组，并使用`.agg()`方法查找每种就业状态的倾向总数。
- en: Now, merge both DataFrames using the `pd.merge()` function and then find the
    propensity count by calculating the proportion of propensity for each type of
    employment status. When creating the new variable for finding the propensity proportion.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用`pd.merge()`函数合并两个DataFrame，然后通过计算每种就业状态的倾向比例来找到倾向计数。在创建新变量以找到倾向比例时。
- en: Plot the data and summarize intuitions from the plot using `matplotlib`. Use
    the stacked bar chart for this activity.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`matplotlib`绘制数据并总结图表中的直觉。此活动使用堆叠条形图。
- en: Note
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: The `bank-full.csv` dataset to be used in this activity can be found at [https://packt.live/2Wav1nJ](https://packt.live/2Wav1nJ).
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 用于此活动的`bank-full.csv`数据集可以在[https://packt.live/2Wav1nJ](https://packt.live/2Wav1nJ)找到。
- en: 'Expected output: The final plot of the propensity to buy with respect to employment
    status will be similar to the following plot:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 预期输出：关于购买倾向与就业状态的最终图表将类似于以下图表：
- en: '![Figure 3.13: Visualizing propensity of purchase by job'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.13：按职业可购买倾向的可视化'
- en: '](img/B15019_03_13.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15019_03_13.jpg)'
- en: 'Figure 3.13: Visualizing propensity of purchase by job'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.13：按职业可购买倾向的可视化
- en: Note
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The solution to this activity can be found at the following address: [https://packt.live/2GbJloz](https://packt.live/2GbJloz).'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动的解决方案可以通过以下地址找到：[https://packt.live/2GbJloz](https://packt.live/2GbJloz)。
- en: Now that we have seen EDA, let's dive into feature engineering.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了EDA，让我们深入探讨特征工程。
- en: Feature Engineering
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特征工程
- en: In the previous section, we traversed the process of EDA. As part of the earlier
    process, we tested our business hypotheses by slicing and dicing the data and
    through visualizations. You might be wondering where we will use the intuitions
    that we derived from all of the analysis we did. The answer to that question will
    be addressed in this section.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们遍历了EDA的过程。作为早期过程的一部分，我们通过切片、切分数据和可视化来测试我们的业务假设。你可能会想知道我们会在哪里使用从所有分析中得出的直觉。这个问题的答案将在本节中解决。
- en: Feature engineering is the process of transforming raw variables to create new
    variables and this will be covered later in the chapter. Feature engineering is
    one of the most important steps that influence the accuracy of the models that
    we build.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 特征工程是将原始变量转换为新变量的过程，本章稍后将详细讨论。特征工程是影响我们构建的模型准确性的重要步骤之一。
- en: 'There are two broad types of feature engineering:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 特征工程大致分为两类：
- en: Here, we transform raw variables based on intuitions from a business perspective.
    These intuitions are what we build during the exploratory analysis.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们根据业务角度的直觉来转换原始变量。这些直觉是在探索性分析过程中建立的。
- en: The transformation of raw variables is done from a statistical and data normalization
    perspective.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 原始变量的转换是从统计学和数据规范化的角度进行的。
- en: We will look into each type of feature engineering next.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们将探讨每种特征工程类型。
- en: Note
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Feature engineering will be covered in much more detail in *Chapter 12*, *Feature
    Engineering*. In this section you will see the purpose of learning about classification.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 特征工程将在*第12章*，*特征工程*中详细讲解。在本节中，您将看到学习分类的目的。
- en: Business-Driven Feature Engineering
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于业务驱动的特征工程
- en: Business-driven feature engineering is the process of transforming raw variables
    based on business intuitions that were derived during the exploratory analysis.
    It entails transforming data and creating new variables based on business factors
    or drivers that influence a business problem.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 基于业务驱动的特征工程是根据在探索性分析过程中得出的业务直觉，转换原始变量的过程。它涉及根据影响业务问题的业务因素或驱动因素，转化数据并创建新变量。
- en: In the previous exercises on exploratory analysis, we explored the relationship
    of a single variable with the dependent variable. In this exercise, we will combine
    multiple variables and then derive new features. We will explore the relationship
    between an asset portfolio and the propensity for term deposit purchases. An asset
    portfolio is the combination of all assets and liabilities the customer has with
    the bank. We will combine assets and liabilities such as bank balance, home ownership,
    and loans to get a new feature called an **asset** index.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的探索性分析练习中，我们探讨了单一变量与因变量之间的关系。在本练习中，我们将结合多个变量并推导出新特征。我们将探索资产组合与购买定期存款的倾向之间的关系。资产组合是客户在银行的所有资产和负债的组合。我们将结合银行余额、房产所有权和贷款等资产与负债，得到一个名为**资产**的指数。
- en: These feature engineering steps will be split into two exercises. In *Exercise
    3.03*, *Feature Engineering – Exploration of Individual Features*, we explore
    individual variables such as balance, housing, and loans to understand their relationship
    to a propensity for term deposits.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这些特征工程步骤将分为两个练习。在*练习 3.03*，*特征工程 – 单独特征的探索*中，我们将探索平衡、住房和贷款等单个变量，以了解它们与定期存款倾向的关系。
- en: In *Exercise 3.04*, *Feature Engineering – Creating New Features from Existing
    Ones,* we will transform individual variables and then combine them to form a
    new feature.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在*练习 3.04*，*特征工程 – 从现有特征创建新特征*中，我们将转化单个变量并将它们组合成一个新特征。
- en: 'Exercise 3.03: Feature Engineering – Exploration of Individual Features'
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 3.03：特征工程 – 单独特征的探索
- en: In this exercise, we will explore the relationship between two variables, which
    are whether an individual owns a house and whether an individual has a loan, to
    the propensity for term deposit purchases by these individuals.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在本练习中，我们将探索两个变量之间的关系，即一个人是否拥有房屋以及是否有贷款，这些与这些人购买定期存款的倾向有关。
- en: 'The following steps will help you to complete this exercise:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助你完成本练习：
- en: Open a new Colab notebook.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的Colab笔记本。
- en: Import the `pandas` package.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`pandas`包。
- en: '[PRE22]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Assign the link to the dataset to a variable called `file_url`:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将数据集的链接赋值给名为`file_url`的变量：
- en: '[PRE23]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Read the banking dataset using the `.read_csv()` function:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`.read_csv()`函数读取银行数据集：
- en: '[PRE24]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Next, we will find a relationship between housing and the propensity for term
    deposits, as mentioned in the following code snippet:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将找到住房与定期存款倾向之间的关系，如以下代码片段所示：
- en: '[PRE25]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You should get the following output:'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该得到以下输出：
- en: '![Figure 3.14: Housing status versus propensity to buy term deposits'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 3.14：住房状况与购买定期存款的倾向'
- en: '](img/B15019_03_14.jpg)'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15019_03_14.jpg)'
- en: 'Figure 3.14: Housing status versus propensity to buy term deposits'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 3.14：住房状况与购买定期存款的倾向
- en: 'The first part of the code is to group customers based on whether they own
    a house or not. The count of customers under each category is calculated with
    the `.agg()` method. From the values, we can see that the propensity to buy term
    deposits is much higher for people who do not own a house compared with those
    who do own one: `( 3354 / ( 3354 + 16727) = 17% to 1935 / ( 1935 + 23195) = 8%)`.'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 代码的第一部分是根据客户是否拥有房屋将其分组。使用`.agg()`方法计算每个类别下的客户数量。从这些值中我们可以看到，购买定期存款的倾向在没有房屋的客户中明显高于有房屋的客户：`(3354
    / (3354 + 16727) = 17% 与 1935 / (1935 + 23195) = 8%)`。
- en: 'Explore the `''loan''` variable to find its relationship with the propensity
    for a term deposit, as mentioned in the following code snippet:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 探索`'loan'`变量，以找出它与定期存款倾向之间的关系，如以下代码片段所示：
- en: '[PRE26]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'You should get the following output:'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该得到以下输出：
- en: '![Figure 3.15: Loan versus term deposit propensity'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 3.15：贷款与定期存款倾向'
- en: '](img/B15019_03_15.jpg)'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15019_03_15.jpg)'
- en: 'Figure 3.15: Loan versus term deposit propensity'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 3.15：贷款与定期存款倾向
- en: 'In the case of loan portfolios, the propensity to buy term deposits is higher
    for customers without loans: `( 4805 / ( 4805 + 33162) = 12 % to 484/ ( 484 +
    6760) = 6%)`.'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于贷款组合，购买定期存款的倾向在没有贷款的客户中较高：`(4805 / (4805 + 33162) = 12% 与 484 / (484 + 6760)
    = 6%)`。
- en: Housing and loans were categorical data and finding a relationship was straightforward.
    However, bank balance data is numerical and to analyze it, we need to have a different
    strategy. One common strategy is to convert the continuous numerical data into
    ordinal data and look at how the propensity varies across each category.
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 住房和贷款是分类数据，找到它们之间的关系是直接的。然而，银行余额数据是数值型的，要分析它，我们需要采用不同的策略。一个常见的策略是将连续的数值数据转换为有序数据，并观察各类别之间的倾向性如何变化。
- en: 'To convert numerical values into ordinal values, we first find the quantile
    values and take them as threshold values. The quantiles are obtained using the
    following code snippet:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了将数值值转换为有序值，我们首先找到分位数值并将它们作为阈值。分位数是使用以下代码片段获得的：
- en: '[PRE27]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'You should get the following output:'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您应该得到以下输出：
- en: '![Figure 3.16: Quantiles for bank balance data'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 3.16：银行余额数据的分位数'
- en: '](img/B15019_03_16.jpg)'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15019_03_16.jpg)'
- en: '[PRE28]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, convert the numerical values of bank balances into categorical values,
    as mentioned in the following code snippet:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将银行余额的数值转换为分类值，如以下代码片段所示：
- en: '[PRE29]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You should get the following output:'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您应该得到以下输出：
- en: '![Figure 3.17: New features from bank balance data'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 3.17：来自银行余额数据的新特征'
- en: '](img/B15019_03_17.jpg)'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15019_03_17.jpg)'
- en: 'Figure 3.17: New features from bank balance data'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 3.17：来自银行余额数据的新特征
- en: We did this is by looking at the quantile thresholds we took in the *Step 4*,
    and categorizing the numerical data into the corresponding quantile class. For
    example, all values lower than the 25th quantile value, 72, were classified as
    `Quant1`, values between 72 and 448 were classified as `Quant2`, and so on. To
    store the quantile categories, we created a new feature in the bank dataset called
    `balanceClass` and set its default value to `Quan1`. After this, based on each
    value threshold, the data points were classified to the respective quantile class.
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们通过查看在*步骤 4*中采取的分位数阈值，将数值数据分类到相应的分位数类别。例如，所有低于第25分位数值72的值被分类为`Quant1`，介于72和448之间的值被分类为`Quant2`，依此类推。为了存储分位数类别，我们在银行数据集中创建了一个名为`balanceClass`的新特征，并将其默认值设置为`Quan1`。之后，根据每个值的阈值，数据点被分类到相应的分位数类别。
- en: 'Next, we need to find the propensity of term deposit purchases based on each
    quantile the customers fall into. This task is similar to what we did in *Exercise
    3.02*, *Business Hypothesis Testing for Age versus Propensity for a Term Loan*:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要根据客户所属的每个分位数来寻找定期存款购买的倾向性。这个任务类似于我们在*练习 3.02*中做的内容，即*年龄与定期贷款倾向性之间的商业假设测试*：
- en: '[PRE30]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'You should get the following output:'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您应该得到以下输出：
- en: '![Figure 3:18: Classification based on quantiles'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 3.18：基于分位数的分类'
- en: '](img/B15019_03_18.jpg)'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15019_03_18.jpg)'
- en: 'Figure 3:18: Classification based on quantiles'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 3.18：基于分位数的分类
- en: 'Calculate the total number of customers categorized by quantile and propensity
    classification, as mentioned in the following code snippet:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算按分位数和倾向性分类的客户总数，如以下代码片段所示：
- en: '[PRE31]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You should get the following output:'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您应该得到以下输出：
- en: '![Figure 3.19: Total number of customers categorized by quantile'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 3.19：按分位数分类的客户总数'
- en: and propensity classification
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以及倾向性分类
- en: '](img/B15019_03_19.jpg)'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15019_03_19.jpg)'
- en: 'Figure 3.19: Total number of customers categorized by quantile and propensity
    classification'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 3.19：按分位数和倾向性分类的客户总数
- en: 'Now, `merge` both DataFrames:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，`merge`两个数据框：
- en: '[PRE32]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'You should get the following output:'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您应该得到以下输出：
- en: '![Figure 3.20: Propensity versus balance category'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 3.20：倾向性与余额类别'
- en: '](img/B15019_03_20.jpg)'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15019_03_20.jpg)'
- en: 'Figure 3.20: Propensity versus balance category'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.20：倾向性与余额类别
- en: From the distribution of data, we can see that, as we move from Quantile 1 to
    Quantile 4, the proportion of customers who buy term deposits keeps on increasing.
    For instance, of all of the customers who belong to `Quant 1`, 7.25% have bought
    term deposits (we get this percentage from `catProp`). This proportion increases
    to 10.87 % for `Quant 2` and thereafter to 12.52 % and 16.15% for `Quant 3` and
    `Quant4`, respectively. From this trend, we can conclude that individuals with
    higher balances have more propensity for term deposits.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 从数据的分布情况来看，我们可以看到，当从第1分位数移动到第4分位数时，购买定期存款的客户比例持续增加。例如，在所有属于`Quant 1`的客户中，7.25%购买了定期存款（我们从`catProp`中得到这个百分比）。这个比例在`Quant
    2`中增加到10.87%，然后在`Quant 3`和`Quant4`中分别增加到12.52%和16.15%。从这个趋势可以得出结论，余额较高的个人更倾向于购买定期存款。
- en: In this exercise, we explored the relationship of each variable to the propensity
    for term deposit purchases. The overall trend that we can observe is that people
    with more cash in hand (no loans and a higher balance) have a higher propensity
    to buy term deposits.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们探讨了每个变量与定期存款购买倾向之间的关系。我们可以观察到的总体趋势是，手头现金更多（没有贷款且余额较高）的人，购买定期存款的倾向较高。
- en: Note
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/3g7rK0w](https://packt.live/3g7rK0w).
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参考[https://packt.live/3g7rK0w](https://packt.live/3g7rK0w)。
- en: You can also run this example online at [https://packt.live/2PZbcNV](https://packt.live/2PZbcNV).
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以在[https://packt.live/2PZbcNV](https://packt.live/2PZbcNV)上在线运行这个示例。
- en: In the next exercise, we will use these intuitions to derive a new feature.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，我们将使用这些直觉推导出一个新的特征。
- en: 'Exercise 3.04: Feature Engineering – Creating New Features from Existing Ones'
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 3.04：特征工程——从现有特征中创建新特征
- en: In this exercise, we will combine the individual variables we analyzed in *Exercise
    3.03*, *Feature Engineering – Exploration of Individual Features* to derive a
    new feature called an asset index. One methodology to create an asset index is
    by assigning weights based on the asset or liability of the customer.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将结合在*练习 3.03*中分析的各个变量，*特征工程——单独特征的探索*，推导出一个新的特征，叫做资产指数。创建资产指数的一种方法是根据客户的资产或负债来分配权重。
- en: 'For instance, a higher bank balance or home ownership will have a positive
    bearing on the overall asset index and, therefore, will be assigned a higher weight.
    In contrast, the presence of a loan will be a liability and, therefore, will have
    to have a lower weight. Let''s give a weight of 5 if the customer has a house
    and 1 in its absence. Similarly, we can give a weight of 1 if the customer has
    a loan and 5 in case of no loans:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，较高的银行余额或房产拥有权将对总体资产指数产生积极影响，因此会被分配更高的权重。相反，贷款的存在将是负债，因此需要分配较低的权重。如果客户有房子，我们赋予权重为5，若没有则为1。类似地，如果客户有贷款，我们赋予权重为1，如果没有贷款，则为5：
- en: Open a new Colab notebook.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的Colab笔记本。
- en: 'Import the pandas and numpy package:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入pandas和numpy包：
- en: '[PRE33]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Assign the link to the dataset to a variable called 'file_url'.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将数据集的链接赋值给一个名为'file_url'的变量。
- en: '[PRE34]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Read the banking dataset using the `.read_csv()` function:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`.read_csv()`函数读取银行数据集：
- en: '[PRE35]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The first step we will follow is to normalize the numerical variables. This
    is implemented using the following code snippet:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将遵循的第一步是标准化数值变量。可以通过以下代码片段来实现：
- en: '[PRE36]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'As the bank balance dataset contains numerical values, we need to first normalize
    the data. The purpose of normalization is to bring all of the variables that we
    are using to create the new feature into a common scale. One effective method
    we can use here for the normalizing function is called `MinMaxScaler()`, which
    converts all of the numerical data between a scaled range of 0 to 1\. The `MinMaxScaler`
    function is available within the `preprocessing` method in `sklearn`:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于银行余额数据集包含数值数据，我们需要先对数据进行标准化。标准化的目的是将我们用于创建新特征的所有变量转换到一个共同的尺度。我们可以在这里使用的有效标准化方法叫做`MinMaxScaler()`，它将所有数值数据转换到0到1的范围内。`MinMaxScaler`函数可以在`sklearn`的`preprocessing`方法中找到：
- en: '[PRE37]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Transform the balance data by normalizing it with `minmaxScaler`:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`minmaxScaler`对余额数据进行标准化转换：
- en: '[PRE38]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In this step, we created a new feature called `'balanceTran'` to store the normalized
    bank balance values.
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这一步中，我们创建了一个名为`'balanceTran'`的新特征，用来存储标准化的银行余额值。
- en: 'Print the head of the data using the `.head()` function:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`.head()`函数打印数据的前几行：
- en: '[PRE39]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'You should get the following output:'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该得到以下输出：
- en: '![Figure 3.21: Normalizing the bank balance data'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 3.21：标准化银行余额数据'
- en: '](img/B15019_03_21.jpg)'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15019_03_21.jpg)'
- en: 'Figure 3.21: Normalizing the bank balance data'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 3.21：标准化银行余额数据
- en: 'After creating the normalized variable, add a small value of `0.001` so as
    to eliminate the 0 values in the variable. This is mentioned in the following
    code snippet:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建标准化变量后，添加一个小值`0.001`，以消除变量中的0值。这个在以下代码片段中提到：
- en: '[PRE40]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The purpose of adding this small value is because, in the subsequent steps,
    we will be multiplying three transformed variables together to form a composite
    index. The small value is added to avoid the variable values becoming 0 during
    the multiplying operation.
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 添加这个小值的目的是因为，在后续步骤中，我们将把三个转化后的变量相乘以形成一个综合指数。为了避免变量值在乘法运算中变为0，我们加上了这个小值。
- en: 'Now, add two additional columns for introducing the transformed variables for
    loans and housing, as per the weighting approach discussed at the start of this exercise:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，按照开始此练习时讨论的加权方法，为贷款和住房引入转换变量的两列附加列：
- en: '[PRE41]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'You should get the following output:'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该得到以下输出：
- en: '![Figure 3.22: Additional columns with the transformed variables'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 3.22：包含转换变量的附加列'
- en: '](img/B15019_03_22.jpg)'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15019_03_22.jpg)'
- en: 'Figure 3.22: Additional columns with the transformed variables'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 3.22：包含转换变量的附加列
- en: We transformed values for the loan data as per the weighting approach. When
    a customer has a loan, it is given a weight of `1`, and when there's no loan,
    the weight assigned is `5`. The value of `1` and `5` are intuitive weights we
    are assigning. What values we assign can vary based on the business context you
    may be provided with.
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们根据加权方法对贷款数据进行了转换。当客户有贷款时，赋予权重`1`，没有贷款时，赋予权重`5`。`1`和`5`是我们赋予的直观权重。我们所赋予的权重可以根据你所提供的业务背景有所不同。
- en: 'Now, transform values for the `Housing data`, as mentioned here:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，转换`Housing 数据`中的数值，如下所示：
- en: '[PRE42]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Give a weight of `1` if the customer has a house and print the results, as
    mentioned in the following code snippet:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果客户有房产，则赋予权重`1`并打印结果，如以下代码片段所示：
- en: '[PRE43]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'You should get the following output:'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该得到以下输出：
- en: '![Figure 3.23: Transforming loan and housing data'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 3.23：转换贷款和住房数据'
- en: '](img/B15019_03_23.jpg)'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15019_03_23.jpg)'
- en: 'Figure 3.23: Transforming loan and housing data'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 3.23：转换贷款和住房数据
- en: Once all the transformed variables are created, we can multiply all of the transformed
    variables together to create a new index called `assetIndex`. This is a composite
    index that represents the combined effect of all three variables.
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦所有转换后的变量都创建完成，我们可以将所有转换后的变量相乘，生成一个新的指数，称为`assetIndex`。这是一个综合指数，表示所有三个变量的综合效果。
- en: 'Now, create a new variable, which is the product of all of the transformed variables:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个新的变量，这是所有转换后变量的乘积：
- en: '[PRE44]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'You should get the following output:'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该得到以下输出：
- en: '![Figure 3.24: Creating a composite index'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 3.24：创建综合指数'
- en: '](img/B15019_03_24.jpg)'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15019_03_24.jpg)'
- en: 'Figure 3.24: Creating a composite index'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 3.24：创建综合指数
- en: Explore the propensity with respect to the composite index.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 探索相对于综合指数的倾向性。
- en: 'We observe the relationship between the asset index and the propensity of term
    deposit purchases. We adopt a similar strategy of converting the numerical values
    of the asset index into ordinal values by taking the quantiles and then mapping
    the quantiles to the propensity of term deposit purchases, as mentioned in *Exercise
    3.03*, *Feature Engineering – Exploration of Individual Features*:'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们观察资产指数与定期存款购买倾向之间的关系。我们采用类似的策略，将资产指数的数值转换为序数值，通过分位数将数值映射到定期存款购买的倾向性上，如*练习
    3.03*中所述，*特征工程 – 探索单个特征*：
- en: '[PRE45]'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'You should get the following output:'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该得到以下输出：
- en: '![Figure 3.25: Conversion of numerical values into ordinal values'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 3.25：将数值转换为序数值'
- en: '](img/B15019_03_25.jpg)'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15019_03_25.jpg)'
- en: 'Figure 3.25: Conversion of numerical values into ordinal values'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 3.25：将数值转换为序数值
- en: 'Next, create quantiles from the `assetindex` data, as mentioned in the following
    code snippet:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，根据以下代码片段从`assetindex`数据创建分位数：
- en: '[PRE46]'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'You should get the following output:'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该得到以下输出：
- en: '![Figure 3.26: Quantiles for the asset index'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 3.26：资产指数的分位数'
- en: '](img/B15019_03_26.jpg)'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15019_03_26.jpg)'
- en: 'Figure 3.26: Quantiles for the asset index'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 3.26：资产指数的分位数
- en: 'Calculate the total of each asset class and the category-wise counts, as mentioned
    in the following code snippet:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算每个资产类别的总额及类别计数，如以下代码片段所示：
- en: '[PRE47]'
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Next, merge both DataFrames:'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，合并两个数据框：
- en: '[PRE48]'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'You should get the following output:'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该得到以下输出：
- en: '![Figure 3.27: Composite index relationship mapping'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 3.27：综合指数关系映射'
- en: '](img/B15019_03_27.jpg)'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15019_03_27.jpg)'
- en: 'Figure 3.27: Composite index relationship mapping'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.27：综合指数关系映射
- en: From the new feature we created, we can see that 18.88% (we get this percentage
    from `catProp`) of customers who are in `Quant2` have bought term deposits compared
    to 10.57 % for `Quant1`, 8.78% for `Quant3`, and 9.28% for `Quant4`. Since `Quant2`
    has the highest proportion of customers who have bought term deposits, we can
    conclude that customers in `Quant2` have higher propensity to purchase the term
    deposits than all other customers.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们创建的新特征中可以看到，18.88%（我们从`catProp`中得到这个百分比）在`Quant2`中的客户购买了定期存款，而`Quant1`为10.57%，`Quant3`为8.78%，`Quant4`为9.28%。由于`Quant2`中购买定期存款的客户比例最高，我们可以得出结论，`Quant2`中的客户购买定期存款的倾向高于其他所有客户。
- en: Note
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/316hUrO](https://packt.live/316hUrO).
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参见[https://packt.live/316hUrO](https://packt.live/316hUrO)。
- en: You can also run this example online at [https://packt.live/3kVc7Ny](https://packt.live/3kVc7Ny).
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以在[https://packt.live/3kVc7Ny](https://packt.live/3kVc7Ny)上运行这个示例。
- en: Similar to the exercise that we just completed, you should think of new variables
    that can be created from the existing variables based on business intuitions.
    Creating new features based on business intuitions is the essence of business-driven
    feature engineering. In the next section, we will look at another type of feature
    engineering called data-driven feature engineering.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们刚完成的练习类似，你应该根据业务直觉考虑从现有变量中创建的新变量。基于业务直觉创建新特征是基于业务的特征工程的核心。在下一节中，我们将介绍另一种特征工程类型——基于数据的特征工程。
- en: Data-Driven Feature Engineering
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于数据的特征工程
- en: The previous section dealt with business-driven feature engineering. In addition
    to features we can derive from the business perspective, it would also be imperative
    to transform data through feature engineering from the perspective of data structures.
    We will look into different methods of identifying data structures and take a
    peek into some data transformation techniques.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节讨论了基于业务的特征工程。除了从业务角度推导出的特征外，从数据结构的角度进行特征工程转换也是至关重要的。我们将探讨识别数据结构的不同方法，并快速了解一些数据转换技术。
- en: A Quick Peek at Data Types and a Descriptive Summary
  id: totrans-341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 快速查看数据类型和描述性总结
- en: 'Looking at the data types such as categorical or numeric and then deriving
    summary statistics is a good way to take a quick peek into data before you do
    some of the downstream feature engineering steps. Let''s take a look at an example
    from our dataset:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 查看数据类型，如类别型或数值型，然后推导出汇总统计数据，是在进行一些后续特征工程步骤之前快速浏览数据的好方法。我们来看看来自我们数据集的一个示例：
- en: '[PRE49]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'You should get the following output:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该得到以下输出：
- en: '![Figure 3.28: Output showing the different data types in the dataset'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.28：显示数据集中不同数据类型的输出'
- en: '](img/B15019_03_28.jpg)'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15019_03_28.jpg)'
- en: 'Figure 3.28: Output showing the different data types in the dataset'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.28：显示数据集中不同数据类型的输出
- en: In the preceding output, you see the different types of information in the dataset
    and its corresponding data types. For instance, `age` is an integer and so is
    `day`.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中，你可以看到数据集中不同类型的信息及其对应的数据类型。例如，`age`是整数，`day`也是整数。
- en: 'The following output is that of a descriptive summary statistic, which displays
    some of the basic measures such as `mean`, `standard deviation`, `count`, and
    the `quantile values` of the respective features:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 以下输出是描述性总结统计数据，显示了各特征的一些基本度量，如`均值`、`标准差`、`计数`和相应的`分位数值`：
- en: '![Figure 3.29: Data types and a descriptive summary'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.29：数据类型和描述性总结'
- en: '](img/B15019_03_29.jpg)'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15019_03_29.jpg)'
- en: 'Figure 3.29: Data types and a descriptive summary'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.29：数据类型和描述性总结
- en: The purpose of a descriptive summary is to get a quick feel of the data with
    respect to the distribution and some basic statistics such as mean and standard
    deviation. Getting a perspective on the summary statistics is critical for thinking
    about what kind of transformations are required for each variable.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 描述性总结的目的是快速了解数据的分布情况和一些基本统计信息，如均值和标准差。了解汇总统计数据对思考每个变量需要进行什么样的转换至关重要。
- en: For instance, in the earlier exercises, we converted the numerical data into
    categorical variables based on the quantile values. Intuitions for transforming
    variables would come from the quick summary statistics that we can derive from
    the dataset.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在前面的练习中，我们根据分位数值将数值数据转换为分类变量。转换变量的直觉来自于我们从数据集中可以推导出的快速汇总统计。
- en: In the following sections, we will be looking at the correlation matrix and
    visualization.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将查看相关性矩阵和可视化。
- en: Correlation Matrix and Visualization
  id: totrans-356
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相关性矩阵与可视化
- en: Correlation, as you know, is a measure that indicates how two variables fluctuate
    together. Any correlation value of 1, or near 1, indicates that those variables
    are highly correlated. Highly correlated variables can sometimes be damaging for
    the veracity of models and, in many circumstances, we make the decision to eliminate
    such variables or to combine them to form composite or interactive variables.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，相关性是一个度量，用于表示两个变量是如何一起波动的。任何接近 1 或为 1 的相关性值，表示这两个变量之间有很强的相关性。高度相关的变量有时可能会影响模型的准确性，在许多情况下，我们会决定消除这些变量或将它们合并成复合变量或交互变量。
- en: Let's look at how data correlation can be generated and then visualized in the
    following exercise.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在接下来的练习中看看如何生成并可视化数据的相关性。
- en: 'Exercise 3.05: Finding the Correlation in Data to Generate a Correlation Plot
    Using Bank Data'
  id: totrans-359
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 3.05：利用银行数据生成相关性图并找到数据中的相关性
- en: In this exercise, we will be creating a correlation plot and analyzing the results
    of the bank dataset.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建一个相关性图并分析银行数据集的结果。
- en: 'The following steps will help you to complete the exercise:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助你完成练习：
- en: 'Open a new Colab notebook, install the `pandas` packages and load the banking data:'
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的 Colab 笔记本，安装 `pandas` 包并加载银行数据：
- en: '[PRE50]'
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now, `import` the `set_option` library from `pandas`, as mentioned here:'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，按照此处的说明，从 `pandas` 导入 `set_option` 库：
- en: '[PRE51]'
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The `set_option` function is used to define the display options for many operations.
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`set_option` 函数用于定义许多操作的显示选项。'
- en: 'Next, create a variable that would store numerical variables such as `''age'',''balance'',''day'',''duration'',''campaign'',''pdays'',''previous'',`
    as mentioned in the following code snippet. A correlation plot can be extracted
    only with numerical data. This is why the numerical data has to be extracted separately:'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个变量来存储诸如 `'age','balance','day','duration','campaign','pdays','previous'`
    等数值变量，如以下代码片段所示。相关性图只能通过数值数据提取。这就是为什么必须单独提取数值数据：
- en: '[PRE52]'
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Now, use the `.corr()` function to find the correlation matrix for the dataset:'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用 `.corr()` 函数找到数据集的相关性矩阵：
- en: '[PRE53]'
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'You should get the following output:'
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该得到以下输出：
- en: '![Figure 3.30: Correlation matrix'
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 3.30：相关性矩阵'
- en: '](img/B15019_03_30.jpg)'
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15019_03_30.jpg)'
- en: 'Figure 3.30: Correlation matrix'
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 3.30：相关性矩阵
- en: The method we use for correlation is the **Pearson** correlation coefficient.
    We can see from the correlation matrix that the diagonal elements have a correlation
    of 1\. This is because the diagonals are a correlation of a variable with itself,
    which will always be 1\. This is the Pearson correlation coefficient.
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用的相关性方法是**皮尔逊**相关系数。从相关性矩阵中可以看到，主对角线上的元素的相关性为 1\。这是因为对角线元素表示的是变量与自身的相关性，显然永远为
    1\。这就是皮尔逊相关系数。
- en: 'Now, plot the data:'
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，绘制数据：
- en: '[PRE54]'
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'You should get the following output:'
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该得到以下输出：
- en: '![Figure 3.31: Correlation plot'
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 3.31：相关性图'
- en: '](img/B15019_03_31.jpg)'
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15019_03_31.jpg)'
- en: 'Figure 3.31: Correlation plot'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.31：相关性图
- en: We used many plotting parameters in this code block. `pyplot.figure()` is the
    plotting class that is instantiated. `.add_subplot()` is a grid parameter for
    the plotting. For example, 111 means a 1 x 1 grid for the first subplot. The `.matshow()`
    function is to display the plot, and the `vmin` and `vmax` arguments are for normalizing
    the data in the plot.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码块中，我们使用了许多绘图参数。`pyplot.figure()` 是要实例化的绘图类。`.add_subplot()` 是绘图的网格参数。例如，111
    表示第一个子图的 1 x 1 网格。`.matshow()` 函数用于显示图形，`vmin` 和 `vmax` 参数用于规范化图中的数据。
- en: Let's look at the plot of the correlation matrix to visualize the matrix for
    quicker identification of correlated variables. Some obvious candidates are the
    high correlation between `'balance'` and `'balanceTran'` and the `'asset index'`
    with many of the transformed variables that we created in the earlier exercise.
    Other than that, there aren't many variables that are highly correlated.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下相关矩阵的图，以便更快速地识别相关变量。几个明显的候选变量包括`'balance'`和`'balanceTran'`之间的高相关性，以及`'asset
    index'`与我们在之前练习中创建的许多转换变量之间的高相关性。除此之外，没有太多变量高度相关。
- en: Note
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/3kXr9SK](https://packt.live/3kXr9SK).
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问这一特定部分的源代码，请参考[https://packt.live/3kXr9SK](https://packt.live/3kXr9SK)。
- en: You can also run this example online at [https://packt.live/3gbfbkR](https://packt.live/3gbfbkR).
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在[https://packt.live/3gbfbkR](https://packt.live/3gbfbkR)上在线运行这个示例。
- en: In this exercise, we developed a correlation plot that allows us to visualize
    the correlation between variables.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 在本次练习中，我们开发了一个相关性图，帮助我们可视化变量之间的相关性。
- en: Skewness of Data
  id: totrans-388
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据的偏度
- en: Another area for feature engineering is skewness. Skewed data means data that
    is shifted in one direction or the other. Skewness can cause machine learning
    models to underperform. Many machine learning models assume normally distributed
    data or data structures to follow the Gaussian structure. Any deviation from the
    assumed Gaussian structure, which is the popular bell curve, can affect model
    performance. A very effective area where we can apply feature engineering is by
    looking at the skewness of data and then correcting the skewness through normalization
    of the data. Skewness can be visualized by plotting the data using histograms
    and density plots. We will investigate each of these techniques.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个特征工程的领域是偏度。偏斜数据是指数据在某个方向上发生了偏移。偏度可能会导致机器学习模型的性能下降。许多机器学习模型假设数据是正态分布的，或者数据结构遵循高斯结构。任何偏离高斯结构的情况（即著名的钟形曲线）都可能影响模型的表现。一个非常有效的特征工程方法是通过观察数据的偏度，并通过对数据进行归一化来纠正偏度。我们可以通过绘制直方图和密度图来可视化偏度。我们将研究这些技术中的每一个。
- en: 'Let''s take a look at the following example. Here, we use the `.skew()` function
    to find the skewness in data. For instance, to find the skewness of data in our
    `bank-full.csv` dataset, we perform the following:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下下面的示例。在这里，我们使用`.skew()`函数来查找数据的偏度。例如，为了查找我们`bank-full.csv`数据集中数据的偏度，我们可以执行以下操作：
- en: '[PRE55]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Note
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This code refers to the `bankNumeric` data, so you should ensure you are working
    in the same notebook as the previous exercise.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码涉及到`bankNumeric`数据，因此你应该确保在与前面练习相同的笔记本中进行操作。
- en: 'You should get the following output:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该获得如下输出：
- en: '![Figure 3.32: Degree of skewness'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.32：偏度的程度'
- en: '](img/B15019_03_32.jpg)'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15019_03_32.jpg)'
- en: 'Figure 3.32: Degree of skewness'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.32：偏度的程度
- en: The preceding matrix is the skewness index. Any value closer to 0 indicates
    a low degree of skewness. Positive values indicate right skew and negative values,
    left skew. Variables that show higher values of right skew and left skew are candidates
    for further feature engineering by normalization. Let's now visualize the skewness
    by plotting histograms and density plots.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 上述矩阵为偏度指标。任何接近0的值表示偏度较低。正值表示右偏，负值表示左偏。显示出较高右偏和左偏的变量是进一步通过归一化进行特征工程的候选变量。现在让我们通过绘制直方图和密度图来可视化偏度。
- en: Histograms
  id: totrans-399
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 直方图
- en: 'Histograms are an effective way to plot the distribution of data and to identify
    skewness in data, if any. The histogram outputs of two columns of `bankData` are
    listed here. The histogram is plotted with the `pyplot` package from `matplotlib`
    using the `.hist()` function. The number of subplots we want to include is controlled
    by the `.subplots()` function. `(1,2)` in subplots would mean one row and two
    columns. The titles are set by the `set_title()` function:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 直方图是绘制数据分布并识别数据偏度（如果有的话）的有效方法。这里列出了`bankData`两个列的直方图输出。直方图是使用`matplotlib`中的`pyplot`包通过`.hist()`函数绘制的。我们希望包含的子图数量由`.subplots()`函数控制。子图中的`(1,2)`表示一行两列。标题通过`set_title()`函数设置：
- en: '[PRE56]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'You should get the following output:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该获得如下输出：
- en: '![Figure 3.33: Code showing the generation of histograms'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.33：显示生成直方图的代码'
- en: '](img/B15019_03_33.jpg)'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15019_03_33.jpg)'
- en: 'Figure 3.33: Code showing the generation of histograms'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.33：显示生成直方图的代码
- en: From the histogram, we can see that the `age` variable has a distribution closer
    to the bell curve with a lower degree of skewness. In contrast, the asset index
    shows a relatively higher right skew, which makes it a more probable candidate
    for normalization.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 从直方图中我们可以看到，`age`变量的分布接近钟形曲线，偏态较低。相比之下，资产指数显示出较高的右偏，意味着它是归一化的更有可能的候选者。
- en: Density Plots
  id: totrans-407
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 密度图
- en: 'Density plots help in visualizing the distribution of data. A density plot
    can be created using the `kind = ''density''` parameter:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 密度图有助于可视化数据的分布。可以使用`kind = 'density'`参数来创建密度图：
- en: '[PRE57]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'You should get the following output:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到以下输出：
- en: '![Figure 3.34: Code showing the generation of a density plot'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.34：展示生成密度图的代码'
- en: '](img/B15019_03_34.jpg)'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15019_03_34.jpg)'
- en: 'Figure 3.34: Code showing the generation of a density plot'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.34：展示生成密度图的代码
- en: Density plots help in getting a smoother visualization of the distribution of
    the data. From the density plot of Age, we can see that it has a distribution
    similar to a bell curve.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 密度图有助于更平滑地展示数据的分布。从年龄的密度图中，我们可以看到它的分布类似于钟形曲线。
- en: Other Feature Engineering Methods
  id: totrans-415
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他特征工程方法
- en: So far, we were looking at various descriptive statistics and visualizations
    that are precursors for applying many feature engineering techniques on data structures.
    We investigated one such feature engineering technique in *Exercise 3.02*, *Business
    Hypothesis Testing for Age versus Propensity for a Term Loan* where we applied
    the **min max** scaler for normalizing data.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在查看各种描述性统计和可视化方法，这些都是对数据结构应用许多特征工程技术的前奏。在*练习 3.02*，*关于年龄与定期贷款倾向的商业假设测试*中，我们使用了**最小-最大**缩放器对数据进行归一化，探讨了其中一种特征工程技术。
- en: We will now look into two other similar data transformation techniques, namely,
    standard scaler and normalizer. Standard scaler standardizes data to a mean of
    0 and standard deviation of 1\. The mean is the average of the data and the standard
    deviation is a measure of the spread of data. By standardizing to the same mean
    and standard deviation, comparison across different distributions of data is enabled.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将介绍另外两种类似的数据转换技术，即标准化缩放器和归一化器。标准化缩放器将数据标准化为均值为0，标准差为1。均值是数据的平均值，标准差是衡量数据分布程度的指标。通过将数据标准化为相同的均值和标准差，可以实现不同数据分布之间的比较。
- en: 'The normalizer function normalizes the length of data. This means that each
    value in a row is divided by the normalization of the row vector to normalize
    the row. The normalizer function is applied on the rows while standard scaler
    is applied columnwise. The normalizer and standard scaler functions are important
    feature engineering steps that are applied to the data before downstream modeling
    steps. Let''s look at both of these techniques:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 归一化器函数对数据的长度进行归一化。这意味着每行中的每个值都会被该行向量的归一化值除以，从而实现对该行的归一化。归一化器函数应用于行，而标准化缩放器应用于列。归一化器和标准化缩放器是应用于数据的关键特征工程步骤，在下游建模步骤之前需要对数据进行处理。让我们来看看这两种技术：
- en: '[PRE58]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'You should get the following output:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到以下输出：
- en: '![Figure 3.35: Output from standardizing the data'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.35：标准化数据后的输出'
- en: '](img/B15019_03_35.jpg)'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15019_03_35.jpg)'
- en: 'Figure 3.35: Output from standardizing the data'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.35：标准化数据后的输出
- en: 'The following code uses the normalizer data transmission techniques:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了使用归一化器数据传输技术：
- en: '[PRE59]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'You should get the following output:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到以下输出：
- en: '![Figure 3.36 Output by the normalizer'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.36：归一化器的输出'
- en: '](img/B15019_03_36.jpg)'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15019_03_36.jpg)'
- en: Figure 3.36 Output by the normalizer
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.36：归一化器的输出
- en: The output from standard scaler is normalized along the columns. The output
    would have 11 columns corresponding to 11 numeric columns (age, balance, day,
    duration, and so on). If we observe the output, we can see that each value along
    a column is normalized so as to have a mean of 0 and standard deviation of 1\.
    By transforming data in this way, we can easily compare across columns.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 标准化缩放器的输出在列之间进行了归一化。输出将有11列，对应于11个数值列（年龄、余额、天数、持续时间等）。如果观察输出，我们可以看到每一列的值都已经标准化，使得均值为0，标准差为1。通过这种方式转换数据，我们可以轻松地进行列间比较。
- en: For instance, in the `age` variable, we have data ranging from 18 up to 95\.
    In contrast, for the balance data, we have data ranging from -8,019 to 102,127\.
    We can see that both of these variables have different ranges of data that cannot
    be compared. The standard scaler function converts these data points at very different
    scales into a common scale so as to compare the distribution of data. Normalizer
    rescales each row so as to have a vector with a length of 1\.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在`age`变量中，我们的数据范围从18到95\. 相比之下，余额数据的范围从-8,019到102,127\. 我们可以看到这两个变量的数据范围不同，无法直接比较。标准化函数将这些尺度差异很大的数据点转换为共同的尺度，从而能够比较数据的分布。归一化则将每一行重新调整，使其成为长度为1的向量。
- en: The big question we have to think about is why do we have to standardize or
    normalize data? Many machine learning algorithms converge faster when the features
    are of a similar scale or are normally distributed. Standardizing is more useful
    in algorithms that assume input variables to have a Gaussian structure. Algorithms
    such as linear regression, logistic regression, and linear discriminate analysis
    fall under this genre. Normalization techniques would be more congenial for sparse
    datasets (datasets with lots of zeros) when using algorithms such as k-nearest
    neighbor or neural networks.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须思考的一个大问题是：为什么我们必须对数据进行标准化或归一化？许多机器学习算法在特征具有相似的尺度或呈正态分布时会更快收敛。标准化在假设输入变量具有高斯结构的算法中更为有用。线性回归、逻辑回归和线性判别分析等算法都属于这一类。归一化技术更适合处理稀疏数据集（包含大量零值的数据集），特别是在使用诸如k最近邻或神经网络的算法时。
- en: Summarizing Feature Engineering
  id: totrans-433
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特征工程总结
- en: 'In this section, we investigated the process of feature engineering from a
    business perspective and data structure perspective. Feature engineering is a
    very important step in the life cycle of a data science project and helps determine
    the veracity of the models that we build. As seen in *Exercise 3.02*, *Business
    Hypothesis Testing for Age versus Propensity for a Term Loan* we translated our
    understanding of the domain and our intuitions to build intelligent features.
    Let''s summarize the processes that we followed:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们从商业角度和数据结构角度研究了特征工程的过程。特征工程是数据科学项目生命周期中非常重要的一步，有助于确定我们构建模型的真实性。如在*练习
    3.02*中所见，*年龄与定期贷款倾向的商业假设检验*，我们将对领域的理解和直觉转化为智能特征。让我们总结一下我们遵循的过程：
- en: We obtain intuitions from a business perspective through EDA
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过EDA从商业角度获得了直觉。
- en: Based on the business intuitions, we devised a new feature that is a combination
    of three other variables.
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基于商业直觉，我们设计了一个新特性，它是三个其他变量的组合。
- en: We verified the influence of constituent variables of the new feature and devised
    an approach for weights to be applied.
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们验证了新特征的组成变量的影响，并设计了应用权重的方法。
- en: Converted ordinal data into corresponding weights.
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将有序数据转换为相应的权重。
- en: Transformed numerical data by normalizing them using an appropriate normalizer.
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用适当的归一化方法对数值数据进行转换。
- en: Combined all three variables into a new feature.
  id: totrans-440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有三个变量组合成一个新特征。
- en: Observed the relationship between the composite index and the propensity to
    purchase term deposits and derived our intuitions.
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 观察了综合指数与购买定期存款倾向之间的关系，并从中得出了我们的直觉。
- en: Explored techniques for visualizing and extracting summary statistics from data.
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 探索了从数据中可视化和提取汇总统计信息的技术。
- en: Identified techniques for transforming data into feature engineered data structures.
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定了将数据转化为特征工程数据结构的技术。
- en: Now that we have completed the feature engineering step, the next question is
    where do we go from here and what is the relevance of the new feature we created?
    As you will see in the subsequent sections, the new features that we created will
    be used for the modeling process. The preceding exercises are an example of a
    trail we can follow in creating new features. There will be multiple trails like
    these, which should be thought of as based on more domain knowledge and understanding.
    The veracity of the models that we build will be dependent on all such intelligent
    features we can build by translating business knowledge into data.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了特征工程步骤，接下来的问题是我们接下来怎么做，我们创建的新特征的相关性是什么？正如您将在后续章节中看到的，我们创建的新特征将用于建模过程中。前述练习是我们可以遵循的创建新特征的示例。将会有多条类似的线索，这些应该被视为基于更多的领域知识和理解。我们构建的模型的真实性将依赖于我们可以通过将业务知识转化为数据来构建的所有这些智能特征。
- en: Building a Binary Classification Model Using the Logistic Regression Function
  id: totrans-445
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建二元分类模型使用逻辑回归函数
- en: The essence of data science is about mapping a business problem into its data
    elements and then transforming those data elements to get our desired business
    outcomes. In the previous sections, we discussed how we do the necessary transformation
    on the data elements. The right transformation of the data elements can highly
    influence the generation of the right business outcomes by the downstream modeling
    process.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 数据科学的核心是将业务问题映射到其数据元素，然后转换这些数据元素以获得我们期望的业务结果。在前面的章节中，我们讨论了如何对数据元素进行必要的转换。数据元素的正确转换可以通过下游建模过程大大影响正确业务结果的生成。
- en: Let's look at the business outcome generation process from the perspective of
    our use case. The desired business outcome, in our use case, is to identify those
    customers who are likely to buy a term deposit. To correctly identify which customers
    are likely to buy a term deposit, we first need to learn the traits or features
    that, when present in a customer, helps in the identification process. This learning
    of traits is what is achieved through machine learning.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从我们使用案例的角度来看业务结果生成过程。在我们的使用案例中，期望的业务结果是识别那些有可能购买定期存款的客户。要正确识别哪些客户有可能购买定期存款，我们首先需要学习当客户拥有时在识别过程中有帮助的特征或特性。通过机器学习来学习这些特性就是我们所达到的目标。
- en: 'By now, you may have realized that the goal of machine learning is to estimate
    a mapping function (*f*) between an output variable and input variables. In mathematical
    form, this can be written as follows:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，您可能已经意识到机器学习的目标是估计输出变量和输入变量之间的映射函数（*f*）。在数学形式上，这可以写成如下形式：
- en: '![Figure 3.37: A mapping function in mathematical form'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.37：数学形式中的映射函数'
- en: '](img/B15019_03_37.jpg)'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15019_03_37.jpg)'
- en: 'Figure 3.37: A mapping function in mathematical form'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.37：数学形式中的映射函数
- en: Let's look at this equation from the perspective of our use case.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从我们使用案例的角度来看这个方程。
- en: '*Y* is the dependent variable, which is our prediction as to whether a customer
    has the probability to buy a term deposit or not.'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: '*Y* 是因变量，即我们预测客户是否有购买定期存款的可能性。'
- en: '*X* is the independent variable(s), which are those attributes such as age,
    education, and marital status and are part of the dataset.'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: '*X* 是独立变量，即诸如年龄、教育和婚姻状况等属性，是数据集的一部分。'
- en: '*f()* is a function that connects various attributes of the data to the probability
    or whether a customer will buy a term deposit or not. This function is learned
    during the machine learning process. This function is a combination of different
    coefficients or parameters applied to each of the attributes to get the probability
    of term deposit purchases. Let''s unravel this concept using a simple example
    of our bank data use case.'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: '*f()* 是一个连接数据各种属性到客户是否购买定期存款的概率的函数。这个函数是在机器学习过程中学习的。这个函数是应用于每个属性的不同系数或参数的组合，以获得定期存款购买的概率。让我们用银行数据使用案例的简单例子来揭开这个概念。'
- en: 'For simplicity, let''s assume that we have only two attributes, age and bank
    balance. Using these, we have to predict whether a customer is likely to buy a
    term deposit or not. Let the age be 40 years and the balance $1,000\. With all
    of these attribute values, let''s assume that the mapping equation is as follows:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化起见，我们假设只有两个属性，年龄和银行余额。基于这些，我们需要预测客户是否可能购买定期存款。假设年龄为 40 岁，余额为 $1,000。根据所有这些属性值，假设映射方程如下：
- en: '![Figure 3.38: Updated mapping equation'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.38：更新后的映射方程'
- en: '](img/B15019_03_38.jpg)'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15019_03_38.jpg)'
- en: 'Figure 3.38: Updated mapping equation'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.38：更新后的映射方程
- en: 'Using the preceding equation, we get the following:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面的方程，我们得到：
- en: '*Y = 0.1 + 0.4 * 40 + 0.002 * 1000*'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: '*Y = 0.1 + 0.4 * 40 + 0.002 * 1000*'
- en: '*Y = 18.1*'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: '*Y = 18.1*'
- en: Now, you might be wondering, we are getting a real number and how does this
    represent a decision of whether a customer will buy a term deposit or not? This
    is where the concept of a decision boundary comes in. Let's also assume that,
    on analyzing the data, we have also identified that if the value of *Y* goes above
    15 (an assumed value in this case), then the customer is likely to buy the term
    deposit, otherwise they will not buy a term deposit. This means that, as per this
    example, the customer is likely to buy a term deposit.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可能会问，我们得到的是一个实数，这如何代表一个客户是否会购买定期存款的决策呢？这就是决策边界概念的所在。我们还假设，在分析数据时，我们已经确定，如果
    *Y* 的值超过 15（在这个例子中假设的值），那么客户可能会购买定期存款，否则他们不会购买定期存款。这意味着，根据这个例子，客户很可能会购买定期存款。
- en: Let's now look at the dynamics in this example and try to decipher the concepts.
    The values such as 0.1, 0.4, and 0.002, which are applied to each of the attributes,
    are the coefficients. These coefficients, along with the equation connecting the
    coefficients and the variables, are the functions that we are learning from the
    data. The essence of machine learning is to learn all of these from the provided
    data. All of these coefficients along with the functions can also be called by
    another common name called the **model**. A model is an approximation of the data
    generation process. During machine learning, we are trying to get as close to
    the real model that has generated the data we are analyzing. To learn or estimate
    the data generating models, we use different machine learning algorithms.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一下这个例子中的动态，并尝试解读其中的概念。像 0.1、0.4 和 0.002 这样应用于每个属性的值是系数。这些系数与连接系数和变量的方程一起，构成了我们从数据中学习的函数。机器学习的本质就是从提供的数据中学习这些内容。所有这些系数和函数也可以被称为另一个常见的名称——**模型**。模型是数据生成过程的近似。在机器学习过程中，我们试图尽可能接近生成我们所分析的数据的真实模型。为了学习或估计数据生成模型，我们使用不同的机器学习算法。
- en: Machine learning models can be broadly classified into two types, parametric
    models and non-parametric models. Parametric models are where we assume the form
    of the function we are trying to learn and then learn the coefficients from the
    training data. By assuming a form for the function, we simplify the learning process.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 机器学习模型可以大致分为两种类型，参数模型和非参数模型。参数模型是我们假设我们试图学习的函数的形式，然后从训练数据中学习系数。通过假设函数的形式，我们简化了学习过程。
- en: 'To understand the concept better, let''s take the example of a linear model.
    For a linear model, the mapping function takes the following form:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这个概念，让我们以线性模型为例。对于线性模型，映射函数的形式如下：
- en: '![Figure 3.39: Linear model mapping function'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.39：线性模型映射函数'
- en: '](img/B15019_03_39.jpg)'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15019_03_39.jpg)'
- en: 'Figure 3.39: Linear model mapping function'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.39：线性模型映射函数
- en: The terms *C**0*, *M**1*, and *M**2* are the coefficients of the line that influences
    the intercept and slope of the line. *X**1* and *X**2* are the input variables.
    What we are doing here is that we assume that the data generating model is a linear
    model and then, using the data, we estimate the coefficients, which will enable
    the generation of the predictions. By assuming the data generating model, we have
    simplified the whole learning process. However, these simple processes also come
    with their pitfalls. Only if the underlying function is linear or similar to linear
    will we get good results. If the assumptions about the form are wrong, we are
    bound to get bad results.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: '*C**0*、*M**1* 和 *M**2* 是影响直线截距和斜率的系数。*X**1* 和 *X**2* 是输入变量。我们在这里做的是假设数据生成模型是线性模型，然后利用数据估计系数，从而生成预测。通过假设数据生成模型，我们简化了整个学习过程。然而，这些简单的过程也有其陷阱。只有当潜在函数是线性或类似线性时，我们才能获得好的结果。如果关于模型形式的假设是错误的，我们注定会得到不好的结果。'
- en: 'Some examples of parametric models include:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 一些参数模型的例子包括：
- en: Linear and logistic regression
  id: totrans-472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线性回归与逻辑回归
- en: Naïve Bayes
  id: totrans-473
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 朴素贝叶斯
- en: Linear support vector machines
  id: totrans-474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线性支持向量机
- en: Perceptron
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 感知机
- en: 'Machine learning models that do not make strong assumptions on the function
    are called non-parametric models. In the absence of an assumed form, non-parametric
    models are free to learn any functional form from the data. Non-parametric models
    generally require a lot of training data to estimate the underlying function.
    Some examples of non-parametric models include the following:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 不对函数做强假设的机器学习模型被称为非参数模型。在没有假设形式的情况下，非参数模型可以自由地从数据中学习任何函数形式。非参数模型通常需要大量的训练数据来估计潜在函数。一些非参数模型的例子包括：
- en: Decision trees
  id: totrans-477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 决策树
- en: K –nearest neighbors
  id: totrans-478
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: K-近邻
- en: Neural networks
  id: totrans-479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 神经网络
- en: Support vector machines with Gaussian kernels
  id: totrans-480
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持向量机与高斯核
- en: Logistic Regression Demystified
  id: totrans-481
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逻辑回归揭秘
- en: 'Logistic regression is a linear model similar to the linear regression that
    was covered in the previous chapter. At the core of logistic regression is the
    sigmoid function, which quashes any real-valued number to a value between 0 and
    1, which renders this function ideal for predicting probabilities. The mathematical
    equation for a logistic regression function can be written as follows:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑回归是一个类似于前一章中讨论的线性回归的线性模型。逻辑回归的核心是 Sigmoid 函数，它将任何实数值压缩到 0 到 1 之间，这使得该函数非常适合用来预测概率。逻辑回归函数的数学表达式可以写成如下形式：
- en: '![Figure 3.40: Logistic regression function'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.40: 逻辑回归函数'
- en: '](img/B15019_03_40.jpg)'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15019_03_40.jpg)'
- en: 'Figure 3.40: Logistic regression function'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: '图 3.40: 逻辑回归函数'
- en: Here, *Y* is the probability of whether a customer is likely to buy a term deposit
    or not.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，*Y* 是顾客是否可能购买定期存款的概率。
- en: 'The terms *C0 + M1 * X1 + M2 * X2* are very similar to the ones we have seen
    in the linear regression function, covered in an earlier chapter. As you would
    have learned by now, a linear regression function gives a real-valued output.
    To transform the real-valued output into a probability, we use the logistic function,
    which has the following form:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: '*C0 + M1 * X1 + M2 * X2* 这一表达式与我们在前一章中看到的线性回归函数非常相似。正如你现在所学的，线性回归函数给出的是实数值输出。为了将实数值输出转换为概率，我们使用逻辑函数，它的形式如下：'
- en: '![Figure 3.41: An expression to transform the real-valued output to a probability'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.41: 将实数值输出转换为概率的表达式'
- en: '](img/B15019_03_41.jpg)'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15019_03_41.jpg)'
- en: 'Figure 3.41: An expression to transform the real-valued output to a probability'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: '图 3.41: 将实数值输出转换为概率的表达式'
- en: Here, *e* is the natural logarithm. We will not dive deep into the math behind
    this; however, let's realize that, using the logistic function, we can transform
    the real-valued output into a probability function.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，*e* 是自然对数。我们不会深入探讨背后的数学原理；然而，应该意识到，使用逻辑函数，我们可以将实数值输出转换为概率函数。
- en: 'Let''s now look at the logistic regression function from the business problem
    that we are trying to solve. In the business problem, we are trying to predict
    the probability of whether a customer would buy a term deposit or not. To do that,
    let''s return to the example we derived from the problem statement:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下我们试图解决的业务问题中的逻辑回归函数。在这个业务问题中，我们正在尝试预测顾客是否会购买定期存款的概率。为了做到这一点，让我们回到我们从问题陈述中推导出的例子：
- en: '![Figure 3.42: The logistic regression function updated with'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.42：更新后的逻辑回归函数'
- en: the business problem statement
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 业务问题陈述
- en: '](img/B15019_03_42.jpg)'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15019_03_42.jpg)'
- en: 'Figure 3.42: The logistic regression function updated with the business problem
    statement'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.42：更新后的逻辑回归函数，结合了业务问题陈述
- en: Adding the following values, we get *Y = 0.1 + 0.4 * 40 + 0.002 * 100*.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 添加以下数值后，我们得到*Y = 0.1 + 0.4 * 40 + 0.002 * 100*。
- en: 'To get the probability, we must transform this problem statement using the
    logistic function, as follows:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得概率，我们必须使用逻辑函数来转化这个问题陈述，如下所示：
- en: '![Figure 3.43: Transformed problem statement to find the probability'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.43：转化后的问题陈述，用于计算概率'
- en: of using the logistic function
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 使用逻辑函数
- en: '](img/B15019_03_43.jpg)'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15019_03_43.jpg)'
- en: 'Figure 3.43: Transformed problem statement to find the probability of using
    the logistic function'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.43：使用逻辑函数计算概率的转化问题陈述
- en: In applying this, we get a value of *Y = 1*, which is a 100% probability that
    the customer will buy the term deposit. As discussed in the previous example,
    the coefficients of the model such as 0.1, 0.4, and 0.002 are what we learn using
    the logistic regression algorithm during the training process.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 应用此方法后，我们得到一个*Y = 1*的值，这表示客户购买定期存款的概率为100%。正如前面例子所讨论的那样，模型的系数如0.1、0.4和0.002是我们通过逻辑回归算法在训练过程中学习到的。
- en: Metrics for Evaluating Model Performance
  id: totrans-504
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 评估模型性能的度量指标
- en: As a data scientist, you always have to make decisions on the models you build.
    These evaluations are done based on various metrics on the predictions. In this
    section, we introduce some of the important metrics that are used for evaluating
    the performance of models.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 作为数据科学家，你总是需要对你构建的模型做出决策。这些评估是基于对预测结果的各种度量来完成的。在这一部分，我们介绍一些用于评估模型性能的重要度量指标。
- en: Note
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Model performance will be covered in much more detail in *Chapter 6*, *How to
    Assess Performance*. This section provides you with an introduction to work with
    classification models.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 模型性能将在*第6章*中更详细地讲解，*如何评估性能*。这一部分为你介绍了如何处理分类模型。
- en: Confusion Matrix
  id: totrans-508
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 混淆矩阵
- en: 'As you will have learned, we evaluate a model based on its performance on a
    test set. A test set will have its labels, which we call the ground truth, and,
    using the model, we also generate predictions for the test set. The evaluation
    of model performance is all about comparison of the ground truth and the predictions.
    Let''s see this in action with a dummy test set:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你将会学到的，我们根据模型在测试集上的表现来评估它。测试集有其标签，我们称之为真实标签，使用模型后，我们还会为测试集生成预测结果。模型性能的评估就是对比真实标签和预测结果。让我们通过一个虚拟的测试集来看这个过程：
- en: '![Figure 3.44: Confusion matrix generation'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.44：生成混淆矩阵'
- en: '](img/B15019_03_44.jpg)'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15019_03_44.jpg)'
- en: 'Figure 3.44: Confusion matrix generation'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.44：生成混淆矩阵
- en: The preceding table shows a dummy dataset with seven examples. The second column
    is the ground truth, which are the actual labels, and the third column contains
    the results of our predictions. From the data, we can see that four have been
    correctly classified and three were misclassified.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的表格展示了一个包含七个示例的虚拟数据集。第二列是实际标签（真实标签），第三列包含我们的预测结果。从数据中可以看出，四个示例被正确分类，三个示例被错误分类。
- en: 'A confusion matrix generates the resultant comparison between prediction and
    ground truth, as represented in the following table:'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 混淆矩阵生成了预测与实际标签之间的对比，如下表所示：
- en: '![Figure 3.45: Confusion matrix'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.45：混淆矩阵'
- en: '](img/B15019_03_45.jpg)'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15019_03_45.jpg)'
- en: 'Figure 3.45: Confusion matrix'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.45：混淆矩阵
- en: As you can see from the table, there are five examples whose labels (ground
    truth) are `Yes` and the balance is two examples that have the labels of `No`.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 从表格中可以看出，有五个示例的标签（真实标签）为`Yes`，剩下的两个示例标签为`No`。
- en: The first row of the confusion matrix is the evaluation of the label `Yes`.
    `True positive` shows those examples whose ground truth and predictions are `Yes`
    (examples 1, 3, and 5). `False negative` shows those examples whose ground truth
    is `Yes` and who have been wrongly predicted as `No` (examples 2 and 7).
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 混淆矩阵的第一行是对标签`Yes`的评估。`True positive`表示那些真实标签和预测标签均为`Yes`的示例（示例 1、3 和 5）。`False
    negative`表示那些真实标签为`Yes`，但被错误预测为`No`的示例（示例 2 和 7）。
- en: Similarly, the second row of the confusion matrix evaluates the performance
    of the label `No`. `False positive` are those examples whose ground truth is `No`
    and who have been wrongly classified as `Yes` (example 6). `True negative` examples
    are those examples whose ground truth and predictions are both `No` (example 4).
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，混淆矩阵的第二行评估标签`No`的表现。`假正例`是指那些真实标签为`No`，但被错误分类为`Yes`的示例（示例6）。`真负例`是指那些真实标签和预测值都为`No`的示例（示例4）。
- en: The generation of a confusion matrix is used for calculating many of the matrices
    such as accuracy and classification reports, which are explained later. It is
    based on metrics such as accuracy or other detailed metrics shown in the classification
    report such as precision or recall the models for testing. We generally pick models
    where these metrics are the highest.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 混淆矩阵的生成用于计算许多矩阵，如准确性和分类报告，后续将详细解释。它基于像准确性或其他分类报告中显示的详细指标（如精确度或召回率）等度量标准，用于测试模型。我们通常选择这些指标值最高的模型。
- en: Accuracy
  id: totrans-522
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准确性
- en: 'Accuracy is the first level of evaluation, which we will resort to in order
    to have a quick check on model performance. Referring to the preceding table,
    accuracy can be represented as follows:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 准确性是评估的第一级，我们将依赖它来快速检查模型的表现。参考前面的表格，准确性可以表示如下：
- en: '![Figure 3.46: A function that represents accuracy'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.46：表示准确性的函数'
- en: '](img/B15019_03_46.jpg)'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15019_03_46.jpg)'
- en: 'Figure 3.46: A function that represents accuracy'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.46：表示准确性的函数
- en: Accuracy is the proportion of correct predictions out of all of the predictions.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 准确性是指所有预测中正确预测的比例。
- en: Classification Report
  id: totrans-528
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分类报告
- en: 'A classification report outputs three key metrics: **precision**, **recall**,
    and the **F1 score**.'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 分类报告输出三个关键指标：**精确度**、**召回率**和**F1分数**。
- en: 'Precision is the ratio of true positives to the sum of true positives and false
    positives:'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 精确度是指真正例数与真正例数和假正例数之和的比例：
- en: '![Figure 3.47: The precision ratio'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.47：精确度比例'
- en: '](img/B15019_03_47.jpg)'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15019_03_47.jpg)'
- en: 'Figure 3.47: The precision ratio'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.47：精确度比例
- en: Precision is the indicator that tells you, out of all of the positives that
    were predicted, how many were true positives.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 精确度是衡量在所有预测为正的实例中，实际为正的实例所占的比例。
- en: 'Recall is the ratio of true positives to the sum of true positives and false
    negatives:'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 召回率是指真正例数与真正例数和假负例数之和的比例：
- en: '![Figure 3.48: The recall ratio'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.48：召回率'
- en: '](img/B15019_03_48.jpg)'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15019_03_48.jpg)'
- en: 'Figure 3.48: The recall ratio'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.48：召回率
- en: Recall manifests the ability of the model to identify all true positives.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 召回率表现了模型识别所有真正例的能力。
- en: The F1 score is a weighted score of both precision and recall. An F1 score of
    1 indicates the best performance and 0 indicates the worst performance.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: F1分数是精确度和召回率的加权得分。F1分数为1表示最佳表现，0表示最差表现。
- en: In the next section, let's take a look at data preprocessing, which is an important
    process to work with data and come to conclusions in data analysis.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将深入了解数据预处理，这是处理数据并得出结论时的重要过程。
- en: Data Preprocessing
  id: totrans-542
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据预处理
- en: Data preprocessing has an important role to play in the life cycle of data science
    projects. These processes are often the most time-consuming part of the data science
    life cycle. Careful implementation of the preprocessing steps is critical and
    will have a strong bearing on the results of the data science project.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 数据预处理在数据科学项目的生命周期中起着重要作用。这些过程通常是数据科学生命周期中最耗时的部分。谨慎实施预处理步骤至关重要，将对数据科学项目的结果产生重大影响。
- en: 'The various preprocessing steps include the following:'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 各种预处理步骤包括以下内容：
- en: '**Data loading**: This involves loading the data from different sources into
    the notebook.'
  id: totrans-545
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据加载**：这涉及将数据从不同的来源加载到笔记本中。'
- en: '**Data cleaning**: Data cleaning process entails removing anomalies, for instance,
    special characters, duplicate data, and identification of missing data from the
    available dataset. Data cleaning is one of the most time-consuming steps in the
    data science process.'
  id: totrans-546
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据清洗**：数据清洗过程包括移除异常数据，例如特殊字符、重复数据，并识别数据集中缺失的部分。数据清洗是数据科学过程中最耗时的步骤之一。'
- en: '**Data imputation**: Data imputation is filling missing data with new data
    points.'
  id: totrans-547
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据插补**：数据插补是用新的数据点填补缺失数据。'
- en: '**Converting data types**: Datasets will have different types of data such
    as numerical data, categorical data, and character data. Running models will necessitate
    the transformation of data types.'
  id: totrans-548
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**转换数据类型**：数据集将包含不同类型的数据，如数值数据、类别数据和字符数据。运行模型时需要对数据类型进行转换。'
- en: Note
  id: totrans-549
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: Data processing will be covered in depth in the following chapters of this book.
  id: totrans-550
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 数据处理将在本书接下来的章节中详细讨论。
- en: We will implement some of these preprocessing steps in the subsequent sections
    and in *Exercise 3.06*, *A Logistic Regression Model for Predicting the Propensity
    of Term Deposit Purchases in a Bank*.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后续部分以及*练习 3.06*中实现其中一些预处理步骤，*《用于预测银行定期存款购买倾向的逻辑回归模型》*。
- en: 'Exercise 3.06: A Logistic Regression Model for Predicting the Propensity of
    Term Deposit Purchases in a Bank'
  id: totrans-552
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 3.06：用于预测银行定期存款购买倾向的逻辑回归模型
- en: In this exercise, we will build a logistic regression model, which will be used
    for predicting the propensity of term deposit purchases. This exercise will have
    three parts. The first part will be the preprocessing of the data, the second
    part will deal with the training process, and the last part will be spent on prediction,
    analysis of metrics, and deriving strategies for further improvement of the model.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 在本次练习中，我们将构建一个逻辑回归模型，用于预测定期存款购买的倾向。这个练习分为三个部分。第一部分是数据预处理，第二部分处理训练过程，最后一部分将用于预测、指标分析以及制定进一步改进模型的策略。
- en: You begin with data preprocessing.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 你从数据预处理开始。
- en: 'In this part, we will first load the data, convert the ordinal data into dummy
    data, and then split the data into training and test sets for the subsequent training
    phase:'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分中，我们将首先加载数据，将有序数据转换为虚拟变量数据，然后将数据拆分为训练集和测试集，以便进入随后的训练阶段：
- en: 'Open a Colab notebook, mount the drives, install necessary packages, and load
    the data, as in previous exercises:'
  id: totrans-556
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个 Colab 笔记本，挂载驱动器，安装必要的包，并加载数据，方法与之前的练习相同：
- en: '[PRE60]'
  id: totrans-557
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Now, load the library functions and data:'
  id: totrans-558
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，加载库函数和数据：
- en: '[PRE61]'
  id: totrans-559
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Now, find the data types:'
  id: totrans-560
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，找出数据类型：
- en: '[PRE62]'
  id: totrans-561
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'You should get the following output:'
  id: totrans-562
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该得到以下输出：
- en: '![Figure 3.49: Data types'
  id: totrans-563
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 3.49：数据类型'
- en: '](img/B15019_03_49.jpg)'
  id: totrans-564
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15019_03_49.jpg)'
- en: 'Figure 3.49: Data types'
  id: totrans-565
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 3.49：数据类型
- en: Convert the ordinal data into dummy data.
  id: totrans-566
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将有序数据转换为虚拟变量数据。
- en: 'As you can see in the dataset, we have two types of data: the numerical data
    and the ordinal data. Machine learning algorithms need numerical representation
    of data and, therefore, we must convert the ordinal data into a numerical form
    by creating dummy variables. The dummy variable will have values of either 1 or
    0 corresponding to whether that category is present or not. The function we use
    for converting ordinal data into numerical form is `pd.get_dummies()`. This function
    converts the data structure into a long form or horizontal form. So, if there
    are three categories in a variable, there will be three new variables created
    as dummy variables corresponding to each of the categories.'
  id: totrans-567
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 正如你在数据集中看到的，我们有两种类型的数据：数值数据和有序数据。机器学习算法需要数据的数值表示，因此我们必须通过创建虚拟变量将有序数据转换为数值形式。虚拟变量的值为1或0，取决于该类别是否存在。我们用于将有序数据转换为数值形式的函数是`pd.get_dummies()`。这个函数将数据结构转换为长格式或横向格式。所以，如果一个变量有三个类别，就会创建三个新的虚拟变量，分别对应每个类别。
- en: 'The value against each variable would be either 1 or 0, depending on whether
    that category was present in the variable as an example. Let''s look at the code
    for doing that:'
  id: totrans-568
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每个变量的值将是1或0，具体取决于该类别是否在变量中作为示例出现。我们来看一下执行此操作的代码：
- en: '[PRE63]'
  id: totrans-569
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'You should get the following output:'
  id: totrans-570
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该得到以下输出：
- en: '[PRE64]'
  id: totrans-571
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: We now have a new subset of the data corresponding to the categorical data that
    was converted into numerical form. Also, we had some numerical variables in the
    original dataset, which did not need any transformation. The transformed categorical
    data and the original numerical data have to be combined to get all of the original
    features. To combine both, let's first extract the numerical data from the original
    DataFrame.
  id: totrans-572
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，我们有了一个新的数据子集，对应于已经转换为数值形式的类别数据。此外，原始数据集中还有一些数值变量，它们不需要任何转换。转换后的类别数据和原始的数值数据需要合并，以获取所有的原始特征。为了合并这两者，让我们首先从原始数据框中提取数值数据。
- en: 'Now, separate the numerical variables:'
  id: totrans-573
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，分离数值变量：
- en: '[PRE65]'
  id: totrans-574
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'You should get the following output:'
  id: totrans-575
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该得到以下输出：
- en: '[PRE66]'
  id: totrans-576
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Now, prepare the `X` and `Y` variables and print the `Y` shape. The `X` variable
    is the concatenation of the transformed categorical variable and the separated
    numerical data:'
  id: totrans-577
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，准备`X`和`Y`变量，并打印`Y`的形状。`X`变量是转换后的类别变量和分离出的数值数据的连接：
- en: '[PRE67]'
  id: totrans-578
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The output shown below is truncated:'
  id: totrans-579
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下方显示的输出已被截断：
- en: '![Figure 3.50 Combining categorical and numerical DataFrames'
  id: totrans-580
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 3.50 合并类别和数值数据框'
- en: '](img/B15019_03_50.jpg)'
  id: totrans-581
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15019_03_50.jpg)'
- en: Figure 3.50 Combining categorical and numerical DataFrames
  id: totrans-582
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 3.50 合并类别和数值数据框
- en: Once the DataFrame is created, we can split the data into training and test
    sets. We specify the proportion in which the DataFrame must be split into training
    and test sets.
  id: totrans-583
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦DataFrame创建完成，我们可以将数据分割为训练集和测试集。我们指定DataFrame应该以什么样的比例分割成训练集和测试集。
- en: 'Split the data into training and test sets:'
  id: totrans-584
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将数据分割为训练集和测试集：
- en: '[PRE68]'
  id: totrans-585
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Now, the data is all prepared for the modeling task. Next, we begin with modeling.
  id: totrans-586
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，数据已经为建模任务做好了准备。接下来，我们开始建模。
- en: In this part, we will train the model using the training set we created in the
    earlier step. First, we call the `logistic regression` function and then fit the
    model with the training set data.
  id: totrans-587
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这一部分，我们将使用之前创建的训练集来训练模型。首先，我们调用`logistic regression`函数，然后用训练集数据拟合模型。
- en: 'Define the `LogisticRegression` function:'
  id: totrans-588
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`LogisticRegression`函数：
- en: '[PRE69]'
  id: totrans-589
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'You should get the following output:'
  id: totrans-590
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该得到以下输出：
- en: '![Figure 3.51: Parameters of the model that fits'
  id: totrans-591
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 3.51：拟合模型的参数'
- en: '](img/B15019_03_51.jpg)'
  id: totrans-592
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15019_03_51.jpg)'
- en: 'Figure 3.51: Parameters of the model that fits'
  id: totrans-593
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 3.51：拟合模型的参数
- en: 'Now, that the model is created, use it for predicting on the test sets and
    then getting the accuracy level of the predictions:'
  id: totrans-594
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，模型已经创建，使用它对测试集进行预测，然后获取预测的准确度：
- en: '[PRE70]'
  id: totrans-595
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'You should get the following output:'
  id: totrans-596
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该得到以下输出：
- en: '![Figure 3.52: Prediction with the model'
  id: totrans-597
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 3.52：使用模型进行预测'
- en: '](img/B15019_03_52.jpg)'
  id: totrans-598
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15019_03_52.jpg)'
- en: 'Figure 3.52: Prediction with the model'
  id: totrans-599
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 3.52：使用模型进行预测
- en: 'From an initial look, an accuracy metric of 90% gives us the impression that
    the model has done a decent job of approximating the data generating process.
    Or is it otherwise? Let''s take a closer look at the details of the prediction
    by generating the metrics for the model. We will use two metric-generating functions,
    the confusion matrix and classification report:'
  id: totrans-600
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从初步来看，90%的准确度给人一种模型已经很好地逼近数据生成过程的印象。真的是这样吗？让我们通过生成模型的指标，仔细看看预测的细节。我们将使用两个生成指标的函数，混淆矩阵和分类报告：
- en: '[PRE71]'
  id: totrans-601
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'You should get the following output in the following format; however, the values
    can vary as the modeling task will involve variability:'
  id: totrans-602
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该得到以下格式的输出；然而，由于建模任务的随机性，数值可能有所不同：
- en: '![Figure 3.53: Generation of the confusion matrix'
  id: totrans-603
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 3.53：生成混淆矩阵'
- en: '](img/B15019_03_53.jpg)'
  id: totrans-604
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15019_03_53.jpg)'
- en: 'Figure 3.53: Generation of the confusion matrix'
  id: totrans-605
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 3.53：生成混淆矩阵
- en: Note
  id: totrans-606
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: The end results that you get will be different from what you see here as it
    depends on the system you are using. This is because the modeling part is stochastic
    in nature and there will always be differences.
  id: totrans-607
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你得到的最终结果将与这里看到的不同，因为这取决于你使用的系统。这是因为建模部分具有随机性，结果总会有所不同。
- en: 'Next, let''s generate a `classification_report`:'
  id: totrans-608
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们生成一个`classification_report`：
- en: '[PRE72]'
  id: totrans-609
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'You should get a similar output; however, with different values due to variability
    in the modeling process:'
  id: totrans-610
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该得到类似的输出；然而，由于建模过程中的变异性，数值会有所不同：
- en: '![Figure 3.54: Confusion matrix and classification report'
  id: totrans-611
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 3.54：混淆矩阵和分类报告'
- en: '](img/B15019_03_54.jpg)'
  id: totrans-612
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15019_03_54.jpg)'
- en: 'Figure 3.54: Confusion matrix and classification report'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.54：混淆矩阵和分类报告
- en: Note
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/2CGFYYU](https://packt.live/2CGFYYU).
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参考[https://packt.live/2CGFYYU](https://packt.live/2CGFYYU)。
- en: You can also run this example online at [https://packt.live/3aDq8KX](https://packt.live/3aDq8KX).
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在[https://packt.live/3aDq8KX](https://packt.live/3aDq8KX)上在线运行这个例子。
- en: From the metrics, we can see that, out of the total 11,998 examples of `no`,
    11,754 were correctly classified as `no` and the balance, 244, were classified
    as `yes`. This gives a recall value of *11,754/11,998*, which is nearly 98%. From
    a precision perspective, out of the total 12,996 examples that were predicted
    as `no`, only 11,754 of them were really `no`, which takes our precision to 11,754/12,996
    or 90%.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 从指标中可以看出，在总共11,998个`no`的样本中，有11,754个被正确分类为`no`，剩下的244个被错误分类为`yes`。这给出的召回率是*11,754/11,998*，接近98%。从精度的角度来看，在总共12,996个被预测为`no`的样本中，只有11,754个是真正的`no`，这使得我们的精度为11,754/12,996，或者90%。
- en: However, the metrics for `yes` give a different picture. Out of the total 1,566
    cases of `yes`, only 324 were correctly identified as `yes`. This gives us a recall
    of *324/1,566 = 21%*. The precision is *324 / (324 + 244) = 57%*.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`yes`的指标给出了不同的结果。在总共1,566个`yes`的样本中，只有324个被正确识别为`yes`。这给出的召回率是*324/1,566
    = 21%*。精度是*324 / (324 + 244) = 57%*。
- en: 'From an overall accuracy level, this can be calculated as follows: correctly
    classified *examples / total examples = (11754 + 324) / 13564 = 89%*.'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 从整体准确度的角度来看，可以通过以下公式计算：正确分类的*样本 / 总样本 = (11754 + 324) / 13564 = 89%*。
- en: The metrics might seem good when you look only at the accuracy level. However,
    looking at the details, we can see that the classifier, in fact, is doing a poor
    job of classifying the `yes` cases. The classifier has been trained to predict
    mostly `no` values, which from a business perspective is useless. From a business
    perspective, we predominantly want the `yes` estimates, so that we can target
    those cases for focused marketing to try to sell term deposits. However, with
    the results we have, we don't seem to have done a good job in helping the business
    to increase revenue from term deposit sales.
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 当你只看准确度时，指标可能看起来不错。然而，仔细看细节，我们可以看到分类器实际上在分类`yes`样本时表现不佳。该分类器已被训练为主要预测`no`值，而从业务角度来看，这是没有用的。从业务角度来看，我们主要希望预测到`yes`的样本，以便能够将这些样本作为目标进行精准营销，尝试销售定期存款。然而，凭借当前的结果，我们似乎未能很好地帮助业务通过定期存款销售增加收入。
- en: In this exercise, we have preprocessed data, then we performed the training
    process, and finally, we found useful prediction, analysis of metrics, and deriving
    strategies for further improvement of the model.
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 在本练习中，我们进行了数据预处理，然后进行了训练过程，最后，我们得到了有用的预测结果、指标分析，并提出了进一步改进模型的策略。
- en: What we have now built is the first model or a benchmark model. The next step
    is to try to improve on the benchmark model through different strategies. One
    such strategy is to feature engineer variables and build new models with new features.
    Let's achieve that in the next activity.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在构建的模型是第一个模型，或者说是基准模型。下一步是通过不同的策略尝试改进基准模型。一个这样的策略是进行特征工程，构建包含新特征的新模型。让我们在下一活动中实现这一点。
- en: 'Activity 3.02: Model Iteration 2 – Logistic Regression Model with Feature Engineered
    Variables'
  id: totrans-623
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 3.02：模型迭代2——使用特征工程变量的逻辑回归模型
- en: As the data scientist of the bank, you created a benchmark model to predict
    which customers are likely to buy a term deposit. However, management wants to
    improve the results you got in the benchmark model. In *Exercise 3.04*, *Feature
    Engineering – Creating New Features from Existing Ones,* you discussed the business
    scenario with the marketing and operations teams and created a new variable, `assetIndex`,
    by feature engineering three raw variables. You are now fitting another logistic
    regression model on the feature engineered variables and are trying to improve
    the results.
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 作为银行的数据科学家，你创建了一个基准模型来预测哪些客户可能会购买定期存款。然而，管理层希望改善基准模型中的结果。在*练习 3.04*中，*特征工程——从现有特征创建新特征*，你与营销和运营团队讨论了业务场景，并通过特征工程创建了一个新变量`assetIndex`，该变量由三个原始变量组成。现在，你正在对特征工程后的变量拟合另一个逻辑回归模型，并努力改进结果。
- en: In this activity, you will be feature engineering some of the variables to verify
    their effects on the predictions.
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 在此活动中，你将进行一些变量的特征工程，以验证它们对预测结果的影响。
- en: 'The steps are as follows:'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤如下：
- en: Open the Colab notebook used for the feature engineering in *Exercise 3.04*,
    *Feature Engineering – Creating New Features from Existing Ones,* and execute
    all of the steps from that exercise.
  id: totrans-627
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开用于*练习 3.04*中*特征工程——从现有特征创建新特征*的Colab笔记本，并执行该练习中的所有步骤。
- en: Create dummy variables for the categorical variables using the `pd.get_dummies()`
    function. Exclude original raw variables such as loan and housing, which were
    used to create the new variable, `assetIndex`.
  id: totrans-628
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`pd.get_dummies()`函数为分类变量创建虚拟变量。排除诸如贷款和住房等原始变量，它们用于创建新的变量`assetIndex`。
- en: Select the numerical variables including the new feature engineered variable,
    `assetIndex`, that was created.
  id: totrans-629
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择数值变量，包括创建的新特征变量`assetIndex`。
- en: Transform some of the numerical variables by normalizing them using the `MinMaxScaler()`
    function.
  id: totrans-630
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用`MinMaxScaler()`函数对一些数值变量进行标准化处理。
- en: Concatenate the numerical variables and categorical variables using the `pd.concat()`
    function and then create `X` and `Y` variables.
  id: totrans-631
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`pd.concat()`函数连接数值变量和分类变量，然后创建`X`和`Y`变量。
- en: Split the dataset using the `train_test_split()` function and then fit a new
    model using the `LogisticRegression()` model on the new features.
  id: totrans-632
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`train_test_split()`函数拆分数据集，然后使用`LogisticRegression()`模型在新特征上拟合一个新模型。
- en: Analyze the results after generating the confusion matrix and classification report.
  id: totrans-633
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在生成混淆矩阵和分类报告后分析结果。
- en: 'You should get the following output:'
  id: totrans-634
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该获得以下输出：
- en: '![Figure 3.55: Expected output with the classification report'
  id: totrans-635
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图3.55：包含分类报告的预期输出](img/B15019_03_55.jpg)'
- en: '](img/B15019_03_55.jpg)'
  id: totrans-636
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15019_03_55.jpg)'
- en: 'Figure 3.55: Expected output with the classification report'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.55：包含分类报告的预期输出
- en: The classification report will be similar to the one shown here. However, the
    values can differ due to the variability in the modeling process.
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 分类报告将类似于这里展示的报告。然而，由于建模过程中的变动，数值可能会有所不同。
- en: Note
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The solution to this activity can be found at the following address: [https://packt.live/2GbJloz](https://packt.live/2GbJloz).'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 本活动的解决方案可以在以下地址找到：[https://packt.live/2GbJloz](https://packt.live/2GbJloz)。
- en: Let's now discuss the next steps that need to be adopted in order to improve
    upon the metrics we got from our two iterations.
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们讨论接下来需要采取的步骤，以改进我们从两次迭代中得到的度量。
- en: Next Steps
  id: totrans-642
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 下一步
- en: 'The next obvious question we can ask is where do we go from all of the processes
    that we have implemented in this chapter? Let''s discuss strategies that we can
    adopt for further improvement:'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以问的下一个明显问题是，在本章中我们已经实现的所有过程之后，我们应该走向哪里？让我们讨论可以采取的策略以进一步改进：
- en: '`no` class. When there are class imbalances, there is a high likelihood that
    the classifier overfits to the majority class. This is what we have seen in our
    example. This is also the reason why we shouldn''t draw our conclusions on the
    performance of our classifier by only looking at the accuracy values.'
  id: totrans-644
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`no`类别。当类别不平衡时，分类器很可能会对多数类过拟合。这在我们的示例中也得到了验证。这也是为什么我们不应该仅仅通过查看准确率来得出分类器性能结论的原因。'
- en: Class imbalance is very prevalent in many use cases such as fraud detection,
    medical diagnostics, and customer churn, to name a few. There are different strategies
    for addressing use cases where there are class imbalances. We will deal with class
    imbalance scenarios in *Chapter 13*, *Imbalanced Datasets*.
  id: totrans-645
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 类别不平衡在许多应用场景中都很常见，如欺诈检测、医疗诊断和客户流失等。针对类别不平衡问题有不同的解决策略。我们将在*第13章*，*不平衡数据集*中处理类别不平衡的场景。
- en: '**Feature engineering**: Data science is an iterative science. Getting the
    desired outcome will depend on the variety of experiments we undertake. One big
    area to make improvements in the initial model is to make changes to the raw variables
    through feature engineering. We dealt with feature engineering and built a model
    using feature engineered variables. In building the new features, we followed
    a trail of creating a new feature related to the asset portfolio. Similarly, there
    would be other trails that we could follow from a business perspective, which
    have the potential to yield more features similar to what we created. Identification
    of such trails would depend on extending the business knowledge we apply through
    the hypotheses we formulate and the exploratory analysis we do to validate those
    business hypotheses. A very potent way to improve the veracity of the models is
    to identify more business trails and then build models through innovative feature
    engineering.'
  id: totrans-646
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**特征工程**：数据科学是一门迭代的科学。获得理想的结果将取决于我们进行的各种实验。改进初始模型的一个重要方向是通过特征工程对原始变量进行修改。我们进行了特征工程，并使用特征工程变量建立了模型。在创建新特征的过程中，我们跟随了一条与资产组合相关的新特征创建路径。同样，从业务角度出发，可能会有其他路径可以追踪，这些路径有可能会生成与我们创建的特征类似的更多特征。识别这些路径将取决于通过我们制定的假设以及我们进行的探索性分析来验证这些业务假设，从而扩展我们应用的业务知识。一种有效提升模型准确性的方法是识别更多的业务路径，然后通过创新的特征工程来构建模型。'
- en: '**Model selection strategy**: When we discussed parametric and non-parametric
    models, we touched upon the point that if the real data generation process is
    not similar to the model that we have assumed, we will get poor results. In our
    case, we assumed linearity and, therefore, adopted a linear model. What if the
    real data generation process is not linear? Or, what if there are other parametric
    or non-parametric models that are much more suitable for this use case? These
    are all considerations when we try to analyze results and try to improve the model.
    We must adopt a strategy called model spot checking, which entails working out
    the use case with different models and checking the initial metrics before adopting
    a model for the use case. In subsequent chapters, we will discuss other modeling
    techniques and it will be advisable to try out this use case with other types
    of models to spot check which modeling technique is more apt for this use case.'
  id: totrans-647
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型选择策略**：当我们讨论参数模型和非参数模型时，我们提到如果真实的数据生成过程与我们假设的模型不一致，那么结果将会很差。在我们的案例中，我们假设了线性关系，因此采用了线性模型。如果真实的数据生成过程不是线性的呢？或者，是否存在其他更适合此用例的参数模型或非参数模型？这些都是在分析结果并尝试改进模型时需要考虑的问题。我们必须采取一种叫做模型抽查的策略，即使用不同的模型来处理用例，并在采用模型之前检查初始指标。在后续的章节中，我们将讨论其他建模技术，建议尝试使用其他类型的模型来抽查哪个建模技术更适合此用例。'
- en: Summary
  id: totrans-648
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned about binary classification using logistic regression
    from the perspective of solving a use case. Let's summarize our learnings in this
    chapter. We were introduced to classification problems and specifically binary
    classification problems. We also looked at the classification problem from the
    perspective of predicting term deposit propensity through a business discovery
    process. In the business discovery process, we identified different business drivers
    that influence business outcomes.
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们从解决一个实际案例的角度学习了使用逻辑回归进行二分类。让我们总结一下本章的学习内容。我们介绍了分类问题，特别是二分类问题。我们还从通过业务发现过程预测定期存款倾向的角度来审视分类问题。在业务发现过程中，我们识别了影响业务结果的不同业务驱动因素。
- en: Intuitions derived from the exploratory analysis were used to create new features
    from the raw variables. A benchmark logistic regression model was built, and the
    metrics were analyzed to identify a future course of action, and we iterated on
    the benchmark model by building a second model by incorporating the feature engineered
    variables.
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 从探索性分析中得出的直觉被用来从原始变量中创建新特征。我们建立了一个基准逻辑回归模型，并分析了指标，以确定未来的行动方向，然后通过引入特征工程变量建立第二个模型，对基准模型进行了迭代。
- en: Having equipped yourselves to solve binary classification problems, it is time
    to take the next step forward. In the next chapter, you will deal with multiclass
    classification, where you will be introduced to different techniques for solving
    such problems.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 在掌握了解决二分类问题的技巧后，是时候迈出下一步了。在下一章中，你将处理多分类问题，并会介绍不同的解决这些问题的技术。
