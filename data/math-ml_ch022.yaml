- en: '14'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '14'
- en: Integration
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 积分
- en: When we first encountered the concept of derivatives in Chapter [12](ch020.xhtml#differentiation),
    we introduced it through an example from physics. As Newton created it, the derivative
    describes the velocity of a moving object as calculated from its time-distance
    graph. In other words, the velocity can be derived from the time-distance information.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在第[12](ch020.xhtml#differentiation)章首次遇到导数的概念时，我们通过物理学中的一个例子进行了介绍。正如牛顿所创建的，导数描述了通过时间-距离图计算出的物体的速度。换句话说，速度可以从时间-距离信息中推导出来。
- en: Can the distance be reconstructed given the velocity? In a sense, this is the
    inverse of differentiation.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 给定速度能否重构出距离？从某种意义上说，这正是微分的逆过程。
- en: Questions such as these are hard to answer if we only look at the most general
    case, so let’s consider a special one. Suppose that our object is moving with
    a constant velocity v(t) = v[0]![ms-](img/file1312.png), for a duration of T seconds.
    With some elementary logic, we can conclude that the total distance traveled is
    v[0]T meters.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题如果我们仅仅从最一般的角度来看，很难回答，因此我们考虑一个特殊的情况。假设我们的物体以恒定速度v(t) = v[0]![ms-](img/file1312.png)运动，持续时间为T秒。通过一些基本的逻辑推理，我们可以得出总的移动距离是v[0]T米。
- en: When taking a look at the time-velocity plot, we can immediately see that the
    distance is the area under the time-velocity function graph v(t) = v[0].
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看时间-速度图时，可以立即看到，距离就是时间-速度函数图v(t) = v[0]下的面积。
- en: The graph of v(t) describes a rectangle with width v[0] and length T, hence
    its area is indeed v[0]T.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: v(t)的图像描述了一个宽度为v[0]，长度为T的矩形，因此它的面积确实是v[0]T。
- en: '![PIC](img/file1313.png)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file1313.png)'
- en: 'Figure 14.1: Time-velocity plot of an object, moving with constant velocity'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.1：物体的时间-速度图，物体以恒定速度运动
- en: Does the area under v(t) equal the distance traveled in the general case? For
    instance, what happens when the time-velocity plot looks something like this?
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在一般情况下，v(t)下的面积是否等于行驶的距离？例如，当时间-速度图像看起来像这样时会发生什么？
- en: '![PIC](img/file1314.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file1314.png)'
- en: 'Figure 14.2: Time-velocity plot of an object, moving with a changing velocity'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.2：物体的时间-速度图，物体以变化的速度运动
- en: 'The speed is not constant here. In this case, we can do a simple trick: partition
    the time interval [0,T] into smaller ones and approximate the object’s motion
    as a constant-speed motion on each of these intervals.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这里速度不是恒定的。在这种情况下，我们可以做一个简单的技巧：将时间区间[0,T]划分为更小的区间，并在这些区间上将物体的运动近似为匀速运动。
- en: '![PIC](img/file1315.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file1315.png)'
- en: 'Figure 14.3: Approximating with a constant velocity motion'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.3：用匀速运动进行近似
- en: If the time intervals [t[i],t[i+1]] are sufficiently granular, the distance
    traveled will roughly match a constant velocity motion with the average velocity
    at [t[i],t[i+1]]. That is, if we introduce the notation
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果时间区间[t[i],t[i+1]]足够精细，所行驶的距离将大致匹配以平均速度进行的匀速运动，即，如果我们引入符号
- en: '![vi := average velocity during the time interval [ti−1,ti], i = 1,2,...,n,](img/file1316.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![vi := 在时间区间[ti−1,ti]内的平均速度，i = 1,2,...,n,](img/file1316.png)'
- en: we should have
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该有
- en: '![∑n vi(ti − ti−1) ≈ total distance traveled during [0,T]. i=1 ](img/file1317.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![∑n vi(ti − ti−1) ≈ 在[0,T]期间的总行驶距离。 i=1](img/file1317.png)'
- en: Let’s think about this whole process as approximating the function v(t) with
    a stepwise constant function v[approx](t). From this angle, we have
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将整个过程看作用阶梯常数函数v[approx](t)来逼近v(t)。从这个角度来看，我们有
- en: '![ n ∑ vi(ti − ti−1) = area under vapprox(t), i=1 ](img/file1318.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![ n ∑ vi(ti − ti−1) = vapprox(t)下的面积，i=1](img/file1318.png)'
- en: and
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 和
- en: '![area under vapprox(t) ≈ area under v(t). ](img/file1319.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![vapprox(t)下的面积 ≈ v(t)下的面积。](img/file1319.png)'
- en: (Very) loosely speaking, if the granularity of the time intervals [t[i],t[i+1]]
    gets infinitesimally small, the approximations turn into equality. Thus,
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: (非常)粗略地说，如果时间区间[t[i],t[i+1]]的粒度变得极其小，近似值将变成等式。因此，
- en: '![total distance traveled during [0,T ] = area under v(t) in [0,T ]. ](img/file1320.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![在[0,T]期间的总行驶距离 = v(t)在[0,T]中的面积。](img/file1320.png)'
- en: 'There are two key points that we need to remember: if s(t) is the distance
    traveled and v(t) is the velocity, then'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要记住两个关键点：如果s(t)是行驶的距离，v(t)是速度，那么
- en: v(t) is the derivative s^′(t),
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: v(t)是导数s^′(t)，
- en: and s(T) is the area under the graph v(t) between 0 and T.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 而s(T)是图形v(t)在0和T之间的面积。
- en: In other words, calculating the area under the curve is the same as inverting
    differentiation. This process is called integration.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，计算曲线下的面积就相当于反向微分。这个过程称为积分。
- en: Unfortunately, things are not as simple as they seem. We missed a lot of mathematical
    detail in the above discussion. For one, does the sum
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，事情并不像看上去那么简单。我们在上述讨论中错过了很多数学细节。比如，和下面的和
- en: '![∑n vi(ti − ti−1) i=1 ](img/file1321.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![∑n vi(ti − ti−1) i=1 ](img/file1321.png)'
- en: converge if the partition of [0,T] gets more granular? Does the limit depend
    on the partitions? Can we even define the area under the “graph” for all functions?
    Like the Dirichlet function, defined by
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 [0,T] 的划分变得更细，极限会收敛吗？极限是否依赖于划分？我们能否为所有函数定义“图形”下的面积？像 Dirichlet 函数，由
- en: '![L(U,V ) = {f : U → V | f is linear}](img/equation_(20).png)(14.1)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![L(U,V ) = {f : U → V | f is linear}](img/equation_(20).png)(14.1)'
- en: How do we calculate limits of ∑ [i=1]^nv[i](t[i] −t[i−1]) in practice? In addition,
    what does all of this have to do with machine learning?
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何在实践中计算 ∑ [i=1]^nv[i](t[i] −t[i−1]) 的极限？此外，这一切与机器学习有什么关系？
- en: Fasten your seatbelts! Here comes the rigorous study of integration, clearing
    up all of these questions.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 系好安全带！接下来是对积分的严谨研究，解答所有这些问题。
- en: 14.1 Integration in theory
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.1 理论中的积分
- en: 'Let’s build a solid theoretical foundation for the intuitive explanation! Let
    f : [a,b] →ℝ be an arbitrary bounded function, and our goal is to calculate the
    signed area under the graph. (Note that the signed area is negative if the graph
    goes below the x axis. In the time-speed graph example above, this is equivalent
    to moving backward, thus decreasing the distance traveled from the starting point.)'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们为直观的解释构建一个坚实的理论基础！设 f : [a,b] →ℝ 为一个任意有界函数，我们的目标是计算图形下方的有符号面积。（注意，如果图形低于
    x 轴，则有符号面积为负。在上述的时间-速度图例中，这相当于倒退，从而减少从起点出发的行进距离。）'
- en: Let a = x[0]/span>x[1]/span>…/span>x[n] = b an arbitrary partition of the interval
    [a,b].
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 设 a = x[0]/span>x[1]/span>…/span>x[n] = b 为区间 [a,b] 的一个任意划分。
- en: For notational convenience, we’ll denote this partition as X = {x[0],…,x[n]}
    as well. The granularity (or mesh) of X is defined by
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了便于记号，我们也将这个划分记为 X = {x[0],…,x[n]}。X 的粒度（或网格）由
- en: '![|X | := max |xi − xi−1|, i=1,...,n ](img/file1323.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![|X | := max |xi − xi−1|, i=1,...,n ](img/file1323.png)'
- en: which is the length of the biggest gap in X. Note that the partition is not
    necessarily uniform, so jx[i] −x[i−1]j is not constant.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 X 中最大间隔的长度。请注意，划分不一定是均匀的，因此 jx[i] −x[i−1]j 不是常数。
- en: We are going to use an argument similar to the squeeze principle (Corollary [3](ch018.xhtml#x1-167012r3))
    to make the approximation idea rigorous. (You know, the one where we replaced
    the speed of a moving object with a piecewise constant one.) Instead of using
    the averages of f(x) on each interval [x[i−1],x[i]], we are going to provide an
    upper and lower estimation by using
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用类似于挤压原理的论证（推论 [3](ch018.xhtml#x1-167012r3)）来使得这个近似思想更加严谨。（你知道的，就是我们用分段常数函数代替了移动物体的速度的那个原理。）我们将不再使用
    f(x) 在每个区间 [x[i−1],x[i]] 上的平均值，而是通过使用上下估算来提供估算值。
- en: '![mi := inf f (x ) x∈[xi−1,xi] ](img/file1324.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![mi := inf f (x ) x∈[xi−1,xi] ](img/file1324.png)'
- en: and
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 以及
- en: '![Mi := sup f(x). x∈ [xi− 1,xi] ](img/file1325.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![Mi := sup f(x). x∈ [xi− 1,xi] ](img/file1325.png)'
- en: Mathematically speaking, the infimum and the supremum are much easier to work
    with than the average. Now we can approximate f(x) with a piecewise constant function
    from both above and below. This is visualized by Figure [14.4](#).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 从数学角度来看，极小值和极大值比平均值更容易处理。现在我们可以通过从上方和下方用分段常数函数来近似 f(x)。这一点通过图 [14.4](#) 进行了可视化。
- en: '![PIC](img/file1326.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file1326.png)'
- en: 'Figure 14.4: Estimating the area under the curve of f using the partition X'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.4：使用划分 X 估算函数 f 曲线下的面积
- en: Our plan is to squeeze the area between the lower and upper sums
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的计划是将面积挤压在上下和之间。
- en: L[f, X] := ∑[i=1]^n m[i](x[i] − x[i−1]) (14.2)
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: L[f, X] := ∑[i=1]^n m[i](x[i] − x[i−1]) (14.2)
- en: and
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 以及
- en: U[f, X] := ∑[i=1]^n M[i](x[i] − x[i−1]), (14.3)
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: U[f, X] := ∑[i=1]^n M[i](x[i] − x[i−1])，(14.3)
- en: then study if these two match. (As usual, the dependence on f and X will be
    omitted if it is clear from the context.)
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 然后研究这两个是否匹配。（如常，如果从上下文中能够清楚看出，则可以省略对 f 和 X 的依赖。）
- en: It is clear from the construction that
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 从构造中可以清楚地看出，
- en: '![L[f,X ] ≤ area under the graph ≤ U [f,X ] ](img/file1327.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![L[f,X ] ≤ area under the graph ≤ U [f,X ] ](img/file1327.png)'
- en: holds for any partition X.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 是否对任何划分 X 都成立？
- en: As the granularity of the partition X goes to zero, hopefully, both L[f,X] and
    U[f,X] will converge to the same number. Intuitively, this common limit should
    be the “area under the function graph,” but currently, our notion of the area
    is not general enough to make such bold statements. For instance, how would you
    define the “area” under the Dirichlet function, defined by ([14.1](#))? As we
    shall see soon, integration will generalize our heuristic notion of area. To get
    to that point, we have a lot to do. First, we’ll take a closer look at the partitions.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 随着划分 X 的粒度趋近于零，理想情况下，L[f,X] 和 U[f,X] 都将收敛到相同的数值。直观地，这个共同的极限应该是“函数图下的面积”，但目前我们对面积的理解还不够通用，无法做出如此大胆的声明。例如，如何定义
    Dirichlet 函数下的“面积”，它由 ([14.1](#)) 定义？正如我们很快将看到的，积分将会推广我们对面积的启发式理解。为了达到这一点，我们还有很多工作要做。首先，我们需要更仔细地观察划分。
- en: 14.1.1 Partitions and their refinements
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.1.1 划分及其细化
- en: We need to introduce some basic facts about refining partitions to construct
    mathematically correct arguments regarding the convergence of the approximating
    sums L[f,X] and U[f,X].
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要引入一些关于细化划分的基本事实，以便构建关于逼近和 L[f,X] 和 U[f,X] 收敛性的数学正确论证。
- en: Definition 63\. (Refinement of partitions)
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 63\.（划分的细化）
- en: Let X = {x[0],…,x[n]} and Y = {y[0],…,y[m]} be two partitions of [a,b]. We say
    that Y is a refinement of X if X ⊆Y .
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 设 X = {x[0],…,x[n]} 和 Y = {y[0],…,y[m]} 为 [a,b] 的两个划分。我们说 Y 是 X 的细化，当且仅当 X ⊆Y。
- en: We can visualize this easily.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以很容易地将其可视化。
- en: '![PIC](img/file1328.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file1328.png)'
- en: 'Figure 14.5: The partition Y , as a refinement of X'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.5：划分 Y，作为 X 的细化
- en: Refinements are vital for understanding why integration works. One of the core
    reasons is the following result.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 细化对理解积分的工作原理至关重要。核心原因之一就是以下结果。
- en: Definition 64\. Monotonicity of upper and lower sums
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 64\. 上和与下和的单调性
- en: 'Let f : [a,b] →ℝ be a bounded function and X and Y be two partitions of [a,b].
    Suppose that Y is a refinement of X. Then'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '设 f : [a,b] →ℝ 为有界函数，X 和 Y 为 [a,b] 的两个划分。假设 Y 是 X 的细化。则'
- en: L[f, X] ≤ L[f, Y] (14.4)
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: L[f, X] ≤ L[f, Y] （14.4）
- en: and
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 和
- en: U[f, Y] ≤ U[f, X]. (14.5)
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: U[f, Y] ≤ U[f, X]。（14.5）
- en: Proof. We are going to show L[f,X] ≤ L[f,Y ], as ([14.5](ch022.xhtml#x1-233006r64))
    follows from a similar argument. Suppose that x[i−1] ≤ y[j] ≤ ⋅⋅⋅ ≤ y[l] ≤ x[i].
    Mathematically speaking, we have
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。我们将证明 L[f,X] ≤ L[f,Y ]，如 ([14.5](ch022.xhtml#x1-233006r64)) 所示，推理类似。假设 x[i−1]
    ≤ y[j] ≤ ⋅⋅⋅ ≤ y[l] ≤ x[i]。从数学上讲，我们有
- en: '![ inf f(x) ≤ inf f(x), k = j + 1,...,l. x∈[xi−1,xi] x∈[yk−1,yk] ](img/file1330.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![ inf f(x) ≤ inf f(x), k = j + 1,...,l. x∈[xi−1,xi] x∈[yk−1,yk] ](img/file1330.png)'
- en: Since x[i] −x[i−1] = ∑ [k=j+1]^ly[k] −y[k−1], the above implies that
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 x[i] − x[i−1] = ∑ [k=j+1]^ly[k] − y[k−1]，上述推论意味着
- en: '![L(U,V ) = {f : U → V | f is linear}](img/file1331.png)(14.6)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![L(U,V ) = {f : U → V | f 是线性的}](img/file1331.png)(14.6)'
- en: Don’t worry if these mathematical formalisms make this hard to follow. Just
    take a look at Figure [14.6](#) below, which summarizes all that we have done
    so far.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些数学形式让你很难跟上，不用担心。只要看看下面的图 [14.6](#)，它总结了我们到目前为止所做的所有工作。
- en: '![PIC](img/file1332.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file1332.png)'
- en: 'Figure 14.6: Refinement of lower sums'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.6：下和的细化
- en: Since L[f,X] and L[f,Y ] are composed from parts like in ([14.6](ch022.xhtml)),
    summing over i in the above immediately yields L[f,X] ≤L[f,Y ].
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 L[f,X] 和 L[f,Y ] 由类似于 ([14.6](ch022.xhtml)) 的部分组成，对 i 求和，立即得出 L[f,X] ≤ L[f,Y
    ]。
- en: 'We are almost there. There is one thing left for us to show: that for any two
    partitions, the lower sum is always smaller than the upper sum. Hence, the squeeze
    principle (Corollary [3](ch018.xhtml#x1-167012r3)) could be applied to show that
    the lower and upper sums converge to the same limit in some instances.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们快到了。我们只剩下一件事要展示：对于任意两个划分，下和总是小于上和。因此，可以应用挤压原理（推论 [3](ch018.xhtml#x1-167012r3)）来证明，在某些情况下，下和和上和会收敛到相同的极限。
- en: For that, we need a simple but fundamental fact about partitions.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们需要一个关于划分的简单但重要的事实。
- en: Proposition 3\.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 命题 3\.
- en: Let ![X ](img/file1333.png) and ![Y ](img/file1334.png) be two partitions of
    ![[a,b] ](img/file1335.png). Then there exists a partition ![Z ](img/file1336.png)
    that is a refinement of both ![X ](img/file1337.png) and ![Y ](img/file1338.png).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 设 ![X ](img/file1333.png) 和 ![Y ](img/file1334.png) 为 [a,b] 的两个划分。则存在一个划分 ![Z
    ](img/file1336.png)，它是 ![X ](img/file1337.png) 和 ![Y ](img/file1338.png) 的细化。
- en: Proof. It is easy to see that ![Z = X ∪Y ](img/file1339.png) satisfies our requirements.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。很容易看出 ![Z = X ∪Y ](img/file1339.png) 满足我们的要求。
- en: The above Z is called a mutual refinement of X and Y . We can show a fundamental
    relation between the upper and lower sums with this idea.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 上述 Z 被称为 X 和 Y 的互细化。通过这个概念，我们可以展示上和下和之间的一个基本关系。
- en: Proposition 4\.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 命题 4.
- en: 'Let f : [a,b] → ℝ be a bounded real function and let X and Y be two partitions
    of the interval [a,b]. Then'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '设 f : [a,b] → ℝ 是一个有界实函数，且 X 和 Y 是区间 [a,b] 的两个分割。那么'
- en: '![L [f,X ] ≤ U[f,Y ] ](img/file1340.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![L [f,X ] ≤ U[f,Y ] ](img/file1340.png)'
- en: holds.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 成立。
- en: Proof. Let Z be a mutual refinement of X and Y , as guaranteed by the previous
    result. Then, ([14.4](ch022.xhtml#x1-233006r64)) and ([14.5](ch022.xhtml#x1-233006r64))
    imply that
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。设Z是X和Y的互细化，正如前述结果所保证的那样。那么，([14.4](ch022.xhtml#x1-233006r64)) 和 ([14.5](ch022.xhtml#x1-233006r64))
    说明
- en: '![L[f,X ] ≤ L [f,Z ] ≤ U [f,Z ] ≤ U [f,Y], ](img/file1341.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![L[f,X ] ≤ L [f,Z ] ≤ U [f,Z ] ≤ U [f,Y], ](img/file1341.png)'
- en: which is what we wanted to show.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是我们要证明的。
- en: 14.1.2 The Riemann integral
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.1.2 里曼积分
- en: 'Let’s denote the set of all partitions on [a,b] by ℱ[a,b]:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将区间 [a,b] 上所有分割的集合表示为 ℱ[a,b]：
- en: '![ℱ [a,b] = {X : X is a partition of [a,b]}. ](img/file1342.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![ℱ [a,b] = {X : X 是 [a,b] 的一个分割}。](img/file1342.png)'
- en: Now we are ready to define the integral of the function as the single value
    that separates upper and lower sums.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好定义函数的积分为将上和下和的界限分开的单一值。
- en: Definition 65\. (Riemann-integrability)
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 65. （里曼可积性）
- en: 'Let f : [a,b] → ℝ be a bounded function. We say that f is Riemann-integrable
    (or just integrable) on [a,b] if'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '设 f : [a,b] → ℝ 是一个有界函数。如果'
- en: '![X∈suℱp[a,b]L[f,X ] = X i∈nℱf[a,b]U [f,X ]. ](img/file1343.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![X∈suℱp[a,b]L[f,X ] = X i∈nℱf[a,b]U [f,X ]. ](img/file1343.png)'
- en: This value is called the Riemann integral (or just the integral) of f over [a,b],
    denoted by
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这个值被称为 f 在 [a,b] 上的里曼积分（或简称积分），表示为
- en: '![∫ b f (x )dx. a ](img/file1344.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![∫ b f (x )dx. a ](img/file1344.png)'
- en: The function f in ∫ [a]^bf(x)dx is called the integrand. How do we calculate
    the integral itself? The hard way is to define a sequence of partitions X[n] and
    show that
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ∫ [a]^b f(x)dx 中的函数 f 被称为被积函数。我们如何计算积分本身？最困难的方法是定义一个分割序列 X[n] 并证明
- en: '![ lim L[f,Xn ] = lim U[f,Xn ], n→ ∞ n→ ∞ ](img/file1345.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![ lim L[f,Xn ] = lim U[f,Xn ], n→ ∞ n→ ∞ ](img/file1345.png)'
- en: so this number is necessarily ∫ [a]^bf(x)dx. We’ll see the easy way soon, but
    let’s see an example demonstrating this process.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这个数必定是 ∫ [a]^b f(x)dx。我们很快会看到简单的方法，但先来看一个示例，演示这个过程。
- en: Let’s calculate ∫ [0]¹x²dx!
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们计算 ∫ [0]¹ x² dx！
- en: The simplest is to use the uniform partition X[n] = i∕n[i=0]^n, obtaining
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的方法是使用均匀分割 X[n] = i∕n [i=0]^n，从而得到
- en: '![ ∑n i − 1 21 L[x2,Xn ] = (-----) -- i=1 n n 1 ∑n = -3- (i− 1)2\. n i=1 ](img/file1346.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![ ∑n i − 1 21 L[x2,Xn ] = (-----) -- i=1 n n 1 ∑n = -3- (i− 1)2\. n i=1 ](img/file1346.png)'
- en: Since ∑ [k=1]^nk² = ![n(n+1)6(2n+1)](img/file1347.png) (as it can be shown by
    induction), it is easy to see that
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 ∑ [k=1]^n k² = ![n(n+1)6(2n+1)](img/file1347.png)（可以通过归纳法证明），很容易看出
- en: '![ 2 1 nli→m∞ L[x ,Xn ] = 3\. ](img/file1348.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![ 2 1 nli→m∞ L[x ,Xn ] = 3\. ](img/file1348.png)'
- en: With a similar argument, you can check that lim[n→∞]U[x²,X[n]] = ![1 3](img/file1349.png)
    as well, thus, ∫ [0]¹x²dx exists and
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 通过类似的论证，你也可以检查到 lim[n→∞] U[x², X[n]] = ![1 3](img/file1349.png)，因此，∫ [0]¹ x²
    dx 存在并且
- en: '![∫ 1 1 x2dx = -. 0 3 ](img/file1350.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![∫ 1 1 x² dx = -. 0 3 ](img/file1350.png)'
- en: Although this method works for simple cases such as f(x) = x², it breaks down
    for more complex functions, as calculating limits of upper and lower sums can
    be difficult. In addition, selecting the right partition is also a challenge.
    For instance, can you calculate ∫ [0]^π sin(x)dx by the definition?
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这种方法适用于像 f(x) = x² 这样简单的情况，但对于更复杂的函数，它会出现问题，因为计算上下和的极限可能很困难。此外，选择合适的分割也是一个挑战。例如，你能通过定义计算
    ∫ [0]^π sin(x)dx 吗？
- en: Because we are lazy (just like any good mathematician), we want to find a general
    method to calculate integrals. Lower and upper sums are needed to make the notion
    of an integral mathematically precise. Combined with the squeeze principle (Corollary [3](ch018.xhtml#x1-167012r3)),
    they are used to provide a definition.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们懒（就像任何好的数学家一样），我们想找到一种通用方法来计算积分。上下和的引入使得积分的概念在数学上更加精确。结合挤压原理（推论[3](ch018.xhtml#x1-167012r3)），它们用于提供定义。
- en: However, other tools become available once we know that a function is integrable.
    Such as the general approximating sum, as we are about to see next.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一旦我们知道一个函数是可积的，其他工具就可以使用了。例如，常见的近似和方法，正如我们接下来要看到的那样。
- en: 'Theorem 91\. Let ![f : ℝ → ℝ ](img/file1351.png) be an arbitrary bounded function,
    and let ![Xn = {x0,n,...,xn,n} ](img/file1352.png) be a sequence of partitions
    on ![[a,b] ](img/file1353.png) such that ![|Xn | → 0 ](img/file1354.png). Then
    ![f ](img/file1355.png) is integrable if and only if the limit'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '定理 91\. 设 ![f : ℝ → ℝ ](img/file1351.png) 为任意有界函数，且 ![Xn = {x0,n,...,xn,n}
    ](img/file1352.png) 为 ![[a,b] ](img/file1353.png) 上的划分序列，满足 ![|Xn | → 0 ](img/file1354.png)。则当且仅当极限'
- en: '![ ∑n lim f(ξi)(xi,n − xi− 1,n) n→∞ i=1 ](img/file1356.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![ ∑n lim f(ξi)(xi,n − xi− 1,n) n→∞ i=1 ](img/file1356.png)'
- en: exists and in this case,
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 存在，在这种情况下，
- en: '![ ∑n ∫ b nl→im∞ f (ξi)(xi,n − xi−1,n) = f(x)dx i=1 a ](img/file1357.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![ ∑n ∫ b nl→im∞ f (ξi)(xi,n − xi−1,n) = f(x)dx i=1 a ](img/file1357.png)'
- en: holds, where ξ[i] ∈ [x[i−1,n],x[i,n]].
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 成立，其中 ξ[i] ∈ [x[i−1,n],x[i,n]]。
- en: (Note that jX[n]j → 0 means that the length of the largest subinterval of X[n]
    gets extremely small. In other words, the resolution of X[n] gets extremely large.)
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: （注意 jX[n]j → 0 意味着 X[n] 的最大子区间的长度变得非常小。换句话说，X[n] 的分辨率变得非常大。）
- en: 'We will not prove the above theorem, as the proof is technical and doesn’t
    provide any valuable insight. However, the point is clear: local infima and suprema
    in lower and upper sums can be replaced with any local value.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会证明上述定理，因为证明过程较为技术性，且不提供有价值的见解。然而，关键点很明确：在下和和上和中的局部最小值和最大值可以被任何局部值替代。
- en: For simplicity, we’ll denote this sum by
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简便，我们将这个和表示为
- en: S[f, X, \xi_X] = \sum_{i=1}^n f(\xi_i)(x_i - x_{i-1}) (14.7)
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: S[f, X, \xi_X] = \sum_{i=1}^n f(\xi_i)(x_i - x_{i-1}) (14.7)
- en: for any X = {x[0],…,x[n]} and ξ[X] = {ξ[1],…,ξ[n]} with ξ[i] ∈ [x[i−1],x[i]].
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任意的 X = {x[0],…,x[n]} 和 ξ[X] = {ξ[1],…,ξ[n]}，其中 ξ[i] ∈ [x[i−1],x[i]]。
- en: 14.1.3 Integration as the inverse of differentiation
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.1.3 积分作为微分的逆操作
- en: 'Now that we understand the mathematical definition of the integral, it is time
    to find some tools that enable its use in practice. The most important result
    is the Newton-Leibniz formula, named after Isaac Newton and Gottfried Wilhelm
    Leibniz, the inventors of calculus. (Fun fact: these men discovered calculus independently
    and were mortal enemies throughout their lives.)'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们理解了积分的数学定义，是时候找到一些实际使用的工具了。最重要的结果是牛顿-莱布尼茨公式，它以牛顿和莱布尼茨的名字命名，他们是微积分的发明者。（有趣的事实：这两位科学家是独立发现微积分的，并且终生是死对头。）
- en: Theorem 92\. (The fundamental theorem of calculus, a.k.a. the Newton-Leibniz
    formula)
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 92\. （微积分基本定理，亦称牛顿-莱布尼茨公式）
- en: 'Let f : ℝ →ℝ a function that is integrable on [a,b] and suppose that there
    is an F : ℝ →ℝ such that F^′(x) = f(x). Then'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '设 f : ℝ →ℝ 为在 [a,b] 上可积的函数，且存在一个 F : ℝ →ℝ，使得 F^′(x) = f(x)。则'
- en: ∫ₐᵇ f(x) dx = F(b) − F(a) (14.8)
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: ∫ₐᵇ f(x) dx = F(b) − F(a) (14.8)
- en: holds.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 成立。
- en: In other words, by defining x→F(a) + ∫ [a]^xf(x)dx, we can effectively reconstruct
    a function from its derivative.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，通过定义 x→F(a) + ∫ [a]^xf(x)dx，我们可以有效地从导数重构一个函数。
- en: Proof. Let ![a = x0 <x1 <⋅⋅⋅ <xn = b ](img/file1359.png) be an arbitrary partition
    of ![[a,b] ](img/file1360.png). According to Lagrange’s mean value theorem (Theorem [89](ch021.xhtml#x1-215010r89)),
    there exists a ![ξi ∈ (xi−1,xi) ](img/file1361.png) for all ![i = 1,...,n ](img/file1362.png)
    such that
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。设 ![a = x0 <x1 <⋅⋅⋅ <xn = b ](img/file1359.png) 为任意的 ![[a,b] ](img/file1360.png)
    划分。根据拉格朗日中值定理（定理 [89](ch021.xhtml#x1-215010r89)），对于所有 ![i = 1,...,n ](img/file1362.png)，存在一个
    ![ξi ∈ (xi−1,xi) ](img/file1361.png)，使得
- en: '![ ′ F(xi)− F (xi−1) = F (ξi)(xi − xi−1) = f (ξ )(x − x ). i i i−1 ](img/file1363.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![ ′ F(xi)− F (xi−1) = F (ξi)(xi − xi−1) = f (ξ )(x − x ). i i i−1 ](img/file1363.png)'
- en: 'Thus, we can sum these numbers up, eliminating all but the first and last elements:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以将这些数相加，去除除了第一个和最后一个元素之外的所有元素：
- en: '![∑n ∑n f(ξi)(xi − xi−1) = F(xi)− F (xi− 1) i=1 i=1 = F (b)− F (a ). ](img/file1364.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![∑n ∑n f(ξi)(xi − xi−1) = F(xi)− F (xi− 1) i=1 i=1 = F (b)− F (a ). ](img/file1364.png)'
- en: On the other hand, due to the properties of lower and upper sums, we have
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，由于下和上和的性质，我们有
- en: '![ ∑n L[f,X ] ≤ f(ξ)(x − x ) ≤ U[f,X ] i=1 i i i−1 ](img/file1365.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![ ∑n L[f,X ] ≤ f(ξ)(x − x ) ≤ U[f,X ] i=1 i i i−1 ](img/file1365.png)'
- en: Since f is integrable, the squeeze principle (Corollary [3](ch018.xhtml#x1-167012r3))
    and Theorem [91](ch022.xhtml#x1-234006r91) imply that
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 f 可积，挤压原理（推论 [3](ch018.xhtml#x1-167012r3)）和定理 [91](ch022.xhtml#x1-234006r91)
    表明
- en: '![∫ b ∑n f (x )dx = f(ξi)(xi − xi− 1) = F (b) − F(a) a i=1 ](img/file1366.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![∫ b ∑n f (x )dx = f(ξi)(xi − xi− 1) = F (b) − F(a) a i=1 ](img/file1366.png)'
- en: must hold. This is what we had to show.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 必须成立。这就是我们需要证明的内容。
- en: Remark 10\. (Increments of functions)
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 备注 10\. （函数的增量）
- en: For simplicity, the increments of a function F on the interval [a,b] is also
    denoted by
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化，函数 F 在区间 [a,b] 上的增量也表示为
- en: '![ x=b [F(x)]x=a := F (b)− F (a ). ](img/file1367.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![ x=b [F(x)]x=a := F (b)− F (a ). ](img/file1367.png)'
- en: Thus, according to the fundamental theorem of calculus (Theorem [92](ch022.xhtml#x1-235004r92)),
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，根据微积分基本定理（定理 [92](ch022.xhtml#x1-235004r92)），
- en: '![∫ b f(x)dx = [F (x)]x=x=ba a ](img/file1368.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![∫ b f(x)dx = [F (x)]x=x=ba a ](img/file1368.png)'
- en: holds if F^′(x) = f(x).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 F^′(x) = f(x)，则成立。
- en: 'Note that integration is insensitive towards changing the values of f(x) at
    countably many points. To be more precise, suppose that f : ℝ →ℝ is a function
    that is integrable on [ − 1,1]. Let’s change its value at a single point and define'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '请注意，积分对 f(x) 在可数多个点处的值的改变是无关的。更准确地说，假设 f : ℝ →ℝ 是在 [ − 1,1] 上可积的函数。让我们在一个单一的点上改变它的值并定义'
- en: '![ ( |{ f(0)+ 1 if x = 0 f∗(x) = |( f(x) otherwise. ](img/file1369.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![ ( |{ f(0)+ 1 如果 x = 0 f∗(x) = |( f(x) 否则。 ](img/file1369.png)'
- en: If a partition is given by −1 = x[0]/span>…/span>x[k−1] ≤ 0/span>x[k]/span>…/span>x[n]
    = 1, then
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果给定一个划分 −1 = x[0]/span>…/span>x[k−1] ≤ 0/span>x[k]/span>…/span>x[n] = 1，那么
- en: '![|L[f,X] − L[f∗,X ]| = | inf f (x)− inf f∗(x)|(xk − xk− 1) x∈[xk−1,xk] x∈[xk−1,xk]
    ◟------------=◝:◜m--------------◞ k ](img/file1370.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![|L[f,X] − L[f∗,X ]| = | inf f (x)− inf f∗(x)|(xk − xk− 1) x∈[xk−1,xk] x∈[xk−1,xk]
    ◟------------=◝:◜m--------------◞ k ](img/file1370.png)'
- en: and
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 且
- en: '![ ∗ ∗ |U [f,X] − U[f ,X ]| = |x∈s[xukp−1,xk]f(x)− x∈[sxuk−p1,xk]f (x )|(xk
    − xk −1) ◟-------------◝◜--------------◞ =:Mk ](img/file1371.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![ ∗ ∗ |U [f,X] − U[f ,X ]| = |x∈s[xukp−1,xk]f(x)− x∈[sxuk−p1,xk]f (x )|(xk
    − xk −1) ◟-------------◝◜--------------◞ =:Mk ](img/file1371.png)'
- en: holds. We can select the partition such that ![xk − xk−1 <𝜀 ](img/file1372.png)
    for some arbitrary ![𝜀 >0 ](img/file1373.png), thus,
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以选择一个划分，使得 ![xk − xk−1 <𝜖 ](img/file1372.png) 对于某个任意的 ![𝜖 >0 ](img/file1373.png)，因此，
- en: '![|L[f,X ]− L[f∗,X ]| and |U [f,X ]− U[f∗,X ]| ](img/file1374.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![|L[f,X ]− L[f∗,X ]| 和 |U [f,X ]− U[f∗,X ]| ](img/file1374.png)'
- en: can be made as small as needed. This implies that
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 可以根据需要使其变得任意小。这意味着
- en: '![∫ b ∫ b f(x)dx = f∗(x)dx. a a ](img/file1375.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![∫ b ∫ b f(x)dx = f∗(x)dx. a a ](img/file1375.png)'
- en: Hence, saying that integration is the inverse of differentiation is mathematically
    a bit imprecise. Given a differentiable function F(x), its derivative is unique,
    but there are infinitely many functions whose integral F(a) + ∫ [a]^xg(y)dy reconstructs
    F.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，说积分是微分的逆操作在数学上稍显不精确。对于一个可微函数 F(x)，它的导数是唯一的，但有无限多种函数的积分 F(a) + ∫ [a]^xg(y)dy
    可以重建 F。
- en: The fundamental theorem of calculus allows us to formulate Lagrange’s mean value
    theorem (Theorem [89](ch021.xhtml#x1-215010r89)) in terms of integrals.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 微积分基本定理使我们能够用积分的形式表述拉格朗日均值定理（定理 [89](ch021.xhtml#x1-215010r89)）。
- en: Theorem 93\. (The mean value theorem for definite integrals)
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 定理93.（定积分的均值定理）
- en: 'Let f : ℝ →ℝ a function that is continuous on [a,b]. Then there exists an ξ
    ∈ [a,b] such that'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '设 f : ℝ →ℝ 是在 [a,b] 上连续的函数。那么存在一个 ξ ∈ [a,b]，使得'
- en: '![∫ b f(x)dx = (b− a)f(ξ). a ](img/file1376.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![∫ b f(x)dx = (b− a)f(ξ). a ](img/file1376.png)'
- en: Proof. According to the fundamental theorem of calculus (Theorem [92](ch022.xhtml#x1-235004r92)),
    the function
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。根据微积分基本定理（定理 [92](ch022.xhtml#x1-235004r92)），该函数
- en: '![ ∫ t F (t) = a f(x)dx ](img/file1377.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![ ∫ t F (t) = a f(x)dx ](img/file1377.png)'
- en: is differentiable on [a,b] and F^′(t) = f(t).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [a,b] 上是可微的，且 F^′(t) = f(t)。
- en: Thus, Lagrange’s mean value theorem (Theorem [89](ch021.xhtml#x1-215010r89))
    gives that
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，拉格朗日均值定理（定理 [89](ch021.xhtml#x1-215010r89)）给出了
- en: '![F-(b)−-F-(a-) b− a = f (ξ) ](img/file1378.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![F-(b)−-F-(a-) b− a = f (ξ) ](img/file1378.png)'
- en: for some ξ ∈ (a,b), from which
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某个 ξ ∈ (a,b)，由此得出
- en: '![∫ b f(x)dx = F(b)− F (a) a = (b− a)f(ξ) ](img/file1379.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![∫ b f(x)dx = F(b)− F (a) a = (b− a)f(ξ) ](img/file1379.png)'
- en: follows. This is what we had to show.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如此。这就是我们需要证明的。
- en: 'After all this theory, you might ask: what does integration have to do with
    machine learning? Without being mathematically rigorous, here is a (very) brief
    overview of what’s to come.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在经历了这些理论之后，你可能会问：积分和机器学习有什么关系？虽然不进行严格的数学推导，以下是一个（非常）简要的概述。
- en: First, you can think about integration as a continuous generalization of the
    arithmetic mean. As you can see, for equidistant partitions, an approximating
    sum
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你可以将积分看作是算术平均数的连续推广。正如你所见，对于等距划分，近似求和
- en: '![ ∑n S[f,X,ξ] = 1- f(ξi) n i=1 ](img/file1380.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![ ∑n S[f,X,ξ] = 1- f(ξi) n i=1 ](img/file1380.png)'
- en: 'is exactly the average of f(ξ[1]),…,f(ξ[n]). In machine learning, averages
    are frequently used to express various quantities, like the mean-squared error.
    Think about it: loss functions are often averages of certain individual losses.
    On a fine enough scale, averages become integrals.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 恰好是 f(ξ[1]),…,f(ξ[n]) 的平均值。在机器学习中，平均值常常用来表示各种量，比如均方误差。想一想：损失函数通常是某些单个损失的平均值。在足够细的尺度上，平均值变成了积分。
- en: Along with linear algebra and calculus, the central pillar of machine learning
    is probability theory and statistics, which gives us a way to model the world
    based on our observations. Probability and statistics are the logic of science
    and decision-making. There, integration is used to express probabilities, expected
    value, information, and much more. Without a rigorous theory of integration, we
    cannot build probabilistic models beyond a certain point.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 与线性代数和微积分一起，机器学习的核心支柱是概率论和统计学，它为我们提供了一种基于观察结果建模世界的方法。概率和统计是科学与决策的逻辑。在这其中，积分被用来表示概率、期望值、信息等多种概念。如果没有严格的积分理论，我们无法在某些阶段构建更复杂的概率模型。
- en: 14.2 Integration in practice
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.2 实际中的积分
- en: Even though we understand what an integral is, we are far from computing them
    in practice. As opposed to differentiation, analytically evaluating integrals
    can be really difficult and sometimes downright impossible. The formula ([92](ch022.xhtml#x1-235004r92))
    suggests that the key is to find the function whose derivative is the integrand,
    called the antiderivative or primitive function. This is harder than you think.
    Nevertheless, there are several tools for this, and we are going to devote this
    section to studying the most important ones.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们理解积分的含义，但在实际中计算它们仍然非常困难。与微分不同，解析地评估积分通常非常困难，有时几乎不可能。公式 ([92](ch022.xhtml#x1-235004r92))
    表示，关键在于找到其导数为被积函数的函数，称为反导数或原始函数。这比你想象的要难得多。不过，还是有一些工具可以帮助我们，接下来我们将专注于研究最重要的这些工具。
- en: Often, the key is finding the antiderivative, so we introduce the notation
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，关键在于找到反导数，因此我们引入符号
- en: '![ ∫ F(x) = f (x)dx, ](img/file1381.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![ ∫ F(x) = f (x)dx, ](img/file1381.png)'
- en: for the functions where F^′ = f. (Sometimes we abbreviate this to F = ∫ fdx.)
    Note that since (F + some constant)^′ = F^′, the antiderivative ∫ f(x)dx is not
    uniquely determined. However, this is not an issue for us, as the Newton-Leibniz
    formula states that
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 对于满足 F^′ = f 的函数。（有时我们简写为 F = ∫ fdx。）请注意，由于 (F + 常数)^′ = F^′，因此反导数 ∫ f(x)dx
    不是唯一确定的。然而，这对我们来说不是问题，因为牛顿-莱布尼茨公式指出：
- en: '![∫ b f (x )dx = F (b)− F (a). a ](img/file1382.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![∫ b f (x )dx = F (b)− F (a). a ](img/file1382.png)'
- en: Thus, any additional constants would be eliminated.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，任何额外的常数都会被消除。
- en: With this under our belt, we are ready to dig deep into evaluating integrals
    in practice.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 掌握了这一点后，我们准备深入实际评估积分。
- en: 14.2.1 Integrals and operations
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.2.1 积分与操作
- en: As we have seen this several times (for instance, when discussing the rules
    of differentiation in Theorem [80](ch020.xhtml#x1-202002r80)), the relations of
    an operation with addition, multiplication, and possibly others are extremely
    useful for gaining insight and developing practical tools.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在多次讨论中所见（例如，在定理 [80](ch020.xhtml#x1-202002r80)中讨论微分法则时），操作与加法、乘法以及其他操作之间的关系对于深入理解和开发实际工具非常有用。
- en: This is the same for integration as well. Similar to before, the linearity of
    the integral is our main tool to evaluate it.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 积分也是如此。与之前类似，积分的线性性质是我们评估它的主要工具。
- en: Theorem 94\. (Linearity of the Riemann integral)
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 94.（黎曼积分的线性）
- en: 'Let f,g : ℝ →ℝ be two functions that are integrable on [a,b]. Then'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '设 f,g : ℝ → ℝ 是在 [a,b] 上可积的两个函数。那么'
- en: (a) ∫ [a]^b(f(x) + g(x))dx = ∫ [a]^bf(x)dx + ∫ [a]^bg(x)dx,
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: （a）∫ [a]^b(f(x) + g(x))dx = ∫ [a]^bf(x)dx + ∫ [a]^bg(x)dx，
- en: (b) ∫ [a]^bcf(x)dx = c∫ [a]^bf(x)dx.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: （b）∫ [a]^bcf(x)dx = c∫ [a]^bf(x)dx。
- en: Proof. (a) If f and g are integrable, then for any 𝜀 >0, there are partitions
    X[f],X[g] such that
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 证明：（a）如果 f 和 g 可积，那么对于任何 𝜖 > 0，都存在分割 X[f]、X[g]，使得：
- en: '![∫ ∫ b b a f(x)dx− 𝜀 ≤ L [f,Xf ] ≤ U [f,Xf] ≤ a f(x)dx + 𝜀 ](img/file1385.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![∫ ∫ b b a f(x)dx− 𝜖 ≤ L [f,Xf ] ≤ U [f,Xf] ≤ a f(x)dx + 𝜖 ](img/file1385.png)'
- en: and
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 和
- en: '![∫ b ∫ b g(x)dx− 𝜀 ≤ L [g,Xg ] ≤ U [g,Xg ] ≤ g(x )dx + 𝜀, a a ](img/file1386.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![∫ b ∫ b g(x)dx− 𝜖 ≤ L [g,Xg ] ≤ U [g,Xg ] ≤ g(x )dx + 𝜖, a a ](img/file1386.png)'
- en: where the lower and upper sums are defined by ([14.2](#)) and ([14.3](#)). So,
    for the mutual refinement X = X[f] ∪X[g], we have
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，较低和较高的和分别由([14.2](#))和([14.3](#))定义。因此，对于互相细化的X = X[f] ∪ X[g]，我们有：
- en: '![L[f,Xf ] ≤ L [f,X ], L [g,Xg ] ≤ L [g,X ], U[f,X ] ≤ U [f,Xf ], U[g,X ] ≤
    U [g,X ] g ](img/file1387.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![L[f,Xf ] ≤ L [f,X ], L [g,Xg ] ≤ L [g,X ], U[f,X ] ≤ U [f,Xf ], U[g,X ] ≤
    U [g,X ] g ](img/file1387.png)'
- en: due to the Proposition [4](ch022.xhtml#x1-233014r4). Thus,
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 由于命题 [4](ch022.xhtml#x1-233014r4)的存在。因此，
- en: '![∫ ∫ b b f(x)dx+ g(x)dx− 2𝜀 ≤ L [f,Xf ]+ L [g,Xg ] a a ≤ L [f,X ]+ L [g,X
    ] ≤ S [f,X, ξX]+ S[g,X,ξX ] ≤ U [f, X]+ U[g,X ] ≤ U [f, Xf]+ U [g,Xg] ∫ ∫ b b
    ≤ a f (x)dx+ a g(x )dx + 2𝜀, ](img/file1388.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![∫ ∫ b b f(x)dx+ g(x)dx− 2𝜀 ≤ L [f,Xf ]+ L [g,Xg ] a a ≤ L [f,X ]+ L [g,X
    ] ≤ S [f,X, ξX]+ S[g,X,ξX ] ≤ U [f, X]+ U[g,X ] ≤ U [f, Xf]+ U [g,Xg] ∫ ∫ b b
    ≤ a f (x)dx+ a g(x )dx + 2𝜀, ](img/file1388.png)'
- en: where S is defined by ([14.7](#)). From this definition, it can also be seen
    that
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 S 的定义见([14.7](#))。从这个定义也可以看出，
- en: '![S[f + g,X, ξX ] = S[f,X, ξX]+ S [g,X, ξX]. ](img/file1389.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![S[f + g,X, ξX ] = S[f,X, ξX]+ S [g,X, ξX]. ](img/file1389.png)'
- en: Thus,
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，
- en: '![ ](img/file1390.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![ ](img/file1390.png)'
- en: implying that
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着
- en: '![ ](img/file1391.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![ ](img/file1391.png)'
- en: Theorem [91](ch022.xhtml#x1-234006r91) regarding the approximating sum S implies
    that f + g is integrable on [a,b] and
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 [91](ch022.xhtml#x1-234006r91) 关于近似和 S 的求和公式表明，f + g 在 [a,b] 上是可积的，并且
- en: '![ ](img/file1392.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![ ](img/file1392.png)'
- en: (b) This follows from the fact that S[cf,X,ξ[X]] = cS[f,X,ξ[X]].
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: (b) 这可以从事实得出，S[cf,X,ξ[X]] = cS[f,X,ξ[X]]。
- en: 14.2.2 Integration by parts
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.2.2 分部积分法
- en: As we have learned when studying the rules of differentiation (Theorem [80](ch020.xhtml#x1-202002r80)),
    for an arbitrary f and g, we have
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在学习求导法则时所了解到的（定理 [80](ch020.xhtml#x1-202002r80)），对于任意的 f 和 g，我们有
- en: '![(fg)′ = f ′g + fg′. ](img/file1393.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![(fg)′ = f ′g + fg′. ](img/file1393.png)'
- en: Applying this logic to the antiderivatives,
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 将此逻辑应用于不定积分，
- en: '![ ∫ f g = (f ′g + fg′)dx ](img/file1394.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![ ∫ f g = (f ′g + fg′)dx ](img/file1394.png)'
- en: 'holds. Rearranging the equation a bit, we obtain the formula of integration
    by parts:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 等式成立。稍微调整方程，我们得到分部积分法的公式：
- en: ∫ f′g dx = fg − ∫ fg′ dx. 14.9
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: ∫ f′g dx = fg − ∫ fg′ dx. 14.9
- en: This is summed up in the following theorem.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过以下定理总结。
- en: Theorem 95\. (Integration by parts)
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 95.（分部积分法）
- en: 'Let f,g : ℝ →ℝ be two functions. If both are differentiable on the interval
    [a,b], then'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '设 f,g : ℝ →ℝ 是两个函数。如果它们在区间 [a,b] 上都可微，那么'
- en: '![∫ b ∫ b f′(x)g(x)dx = [f(x)g(x)]x=b − f(x)g′(x)dx a x=a a ](img/file1395.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![∫ b ∫ b f′(x)g(x)dx = [f(x)g(x)]x=b − f(x)g′(x)dx a x=a a ](img/file1395.png)'
- en: holds.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这个等式成立。
- en: How is this useful for us? Consider a situation where finding the antiderivative
    of f and the derivative of g is easy, but the antiderivative of the product fg
    is hard. For example, can you quickly calculate the following?
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这对我们有什么用处呢？考虑一种情况，其中 f 的不定积分和 g 的导数容易求得，但 fg 的不定积分却很难求。例如，您能快速计算以下积分吗？
- en: '![∫ x log xdx ](img/file1396.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![∫ x log xdx ](img/file1396.png)'
- en: Applying ([14.9](ch022.xhtml#integration-by-parts)) with the roles f^′(x) =
    x and g(x) = log x immediately yields
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 应用 ([14.9](ch022.xhtml#integration-by-parts)) 时，取 f^′(x) = x 和 g(x) = log x
    可立即得出
- en: '![∫ ∫ 1-2 1- x log x = 2x log x− 2xdx 1 1 = -x2log |x|− -x2 + C, 2 4 ](img/file1397.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![∫ ∫ 1-2 1- x log x = 2x log x− 2xdx 1 1 = -x2log |x|− -x2 + C, 2 4 ](img/file1397.png)'
- en: where C ∈ℝ is an arbitrary constant.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 C ∈ℝ 是任意常数。
- en: 14.2.3 Integration by substitution
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.2.3 代换积分法
- en: As the integration by parts formula is the “opposite” of the differentiation
    rule for products, there is an analogue for the chain formula as well. Recall
    that for two differentiable functions, we had
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 由于分部积分法公式是“对立”于乘积的求导规则，因此也有类似的链式法则。回想一下，对于两个可微函数，我们有
- en: '![(f ∘ g)′(x) = f′(g(x ))g′(x). ](img/file1398.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![(f ∘ g)′(x) = f′(g(x ))g′(x). ](img/file1398.png)'
- en: Translating this to the language of integrals, we obtain the following result.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 将其转化为积分的语言，我们可以得到以下结果。
- en: Theorem 96\. (Integration by substitution)
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 96.（代换积分法）
- en: 'Let f,g : ℝ → ℝ be integrable functions on [a,b]. Suppose that f is continuous
    and g is differentiable. Then'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '设 f,g : ℝ → ℝ 是 [a,b] 区间上的可积函数。假设 f 是连续的，g 是可微的。那么，'
- en: '![∫ b ∫ g(b) f(g(y))g′(y)dy = f(x)dx a g(a) ](img/file1399.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![∫ b ∫ g(b) f(g(y))g′(y)dy = f(x)dx a g(a) ](img/file1399.png)'
- en: holds.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 等式成立。
- en: This is called integration by substitution. To give you an example of its use,
    consider
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这称为代换积分法。为了给你一个应用示例，考虑
- en: '![∫ 2 x sin(x )dx. ](img/file1400.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![∫ 2 x sin(x )dx. ](img/file1400.png)'
- en: With the roles y(x) = x², we have
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 当 y(x) = x² 时，我们有
- en: '![∫ 1∫ xsin(x2 )dx = -- sin ydy 2 = − 1-cosy + C 2 = − 1-cos(x2)+ C, 2 ](img/file1401.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![∫ 1∫ xsin(x2 )dx = -- sin ydy 2 = − 1-cosy + C 2 = − 1-cos(x2)+ C, 2 ](img/file1401.png)'
- en: where C ∈ℝ is an arbitrary constant.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 C ∈ℝ 是任意常数。
- en: 'Integration by parts and substitution are our main weapons for calculating
    integrals on paper. Most of the integrals one might encounter can be solved with
    the creative (and possibly iterated) application of these two rules. The recipe
    is simple: find the antiderivative, then use the Newton-Leibniz formula (Theorem [92](ch022.xhtml#x1-235004r92))
    to compute the value of the integral.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 分部积分法和代换法是我们在纸面上计算积分的主要工具。大多数我们可能遇到的积分都可以通过这两条规则的创造性（并可能是迭代的）应用来求解。其步骤很简单：找到反导数，然后使用牛顿-莱布尼茨公式（定理 [92](ch022.xhtml#x1-235004r92)）来计算积分值。
- en: 'However, there is a serious issue: antiderivatives can be extremely hard to
    find, maybe even impossible. This makes integrals difficult to compute symbolically.
    For instance, consider'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这里存在一个严重的问题：反导数可能极难找到，甚至可能无法找到。这使得积分在符号计算中变得非常困难。例如，考虑
- en: '![∫ −x2 e dx, ](img/file1402.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![∫ −x2 e dx, ](img/file1402.png)'
- en: where the function e^(−x²) describes the well-known Gaussian bell curve. As
    surprising as it is, ∫ e^(−x²) dx cannot be described with a closed formula! (That
    is, one that uses a finite number of operations and only elementary functions.)
    It’s not that mathematicians were not clever enough to find a closed formula for
    the antiderivative; this doesn’t exist.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，函数e^(−x²)描述了著名的高斯钟形曲线。令人惊讶的是，∫ e^(−x²) dx无法用闭式公式表示！（也就是说，不能用有限的运算和仅有的初等函数表示。）并不是说数学家们不够聪明，找不到反导数的闭式公式；实际上，这种公式不存在。
- en: Thus, computing integrals is much simpler to do numerically. This is in stark
    contrast with differentiation, which is easy to do symbolically but hard numerically.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，计算积分在数值上要简单得多。这与微分形成鲜明对比，微分在符号计算中很容易，但在数值计算中却很难。
- en: 14.2.4 Numerical integration
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.2.4 数值积分
- en: 'Instead of using symbolic computation to get the exact value of an integral,
    we will resolve to approximation once again. Previously, Theorem [91](ch022.xhtml#x1-234006r91)
    showed us that an integral is the limit of the Riemann-sums:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再次采用近似方法，而不是使用符号计算来获取积分的精确值。之前的定理 [91](ch022.xhtml#x1-234006r91)向我们展示了积分是黎曼和的极限：
- en: ∫[a]^b f(x) dx = lim[n→∞] ∑[i=1]^n f(ξ[i]) (x[i,n] − x[i−1,n]), (14.10)
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: ∫[a]^b f(x) dx = lim[n→∞] ∑[i=1]^n f(ξ[i]) (x[i,n] − x[i−1,n]), (14.10)
- en: where X[n] = {x[0,n],…,x[n,n]} is a partition of [a,b] and ξ[i] ∈ [x[i−1,n],x[i,n]]
    are arbitrary intermediate values.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 X[n] = {x[0,n],…,x[n,n]} 是区间[a,b]的划分，ξ[i] ∈ [x[i−1,n],x[i,n]] 是任意的中间值。
- en: 'In other words, if n is large enough, the sum ∑ [i=1]^nf(ξ[i])(x[i,n] −x[i−1,n])
    is close to ∫ [a]^bf(x)dx. There are two crucial issues: first, how to select
    the partition and the intermediate values; second, how fast is the convergence?'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，如果n足够大，那么和∑ [i=1]^n f(ξ[i])(x[i,n] − x[i−1,n])就接近于∫ [a]^b f(x) dx。这里有两个关键问题：首先，如何选择划分和中间值；其次，收敛速度有多快？
- en: If we want to make ([14.11](ch022.xhtml#numerical-integration)) useful, we have
    to devise a concrete method that prescribes the x[i]-s, ξ[i]-s, and tells us how
    large of an n we should select. This is an extremely rich subject that has been
    the focus of studies ever since the introduction of integration. So, there is
    a lot to talk about here. To keep things simple, let’s just focus on the essentials.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想使得([14.11](ch022.xhtml#numerical-integration))方法有效，我们必须设计一个具体的方法，规定x[i]、ξ[i]的取值，并告诉我们应该选择多大的n。这是一个极其丰富的主题，自从积分被引入以来，学者们一直在关注这一领域。因此，这里有很多内容需要讨论。为了简单起见，我们只关注核心要点。
- en: The most straightforward method is to select a uniform partition, then approximate
    the area under the function curve with a sequence of trapezoids.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 最直接的方法是选择均匀划分，然后用一系列梯形来近似函数曲线下的面积。
- en: That is, let X = {a,a + ![b−a n](img/file1403.png),a + 2![b−a n](img/file1404.png),…,b}
    be an equidistant partition, which we’ll use to estimate the integral via calculating
    the areas determined by the trapezoids given by the partition and the graph, as
    illustrated in Figure [14.7](#).
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，设 X = {a, a + ![b−a n](img/file1403.png), a + 2![b−a n](img/file1404.png),…,
    b} 为一个等距划分，我们将利用该划分通过计算由划分和图形确定的梯形的面积来估算积分，如图[14.7](#)所示。
- en: '![PIC](img/file1405.png)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file1405.png)'
- en: 'Figure 14.7: Approximating the area under a function with successive trapezoids'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.7：用连续梯形近似函数下的面积
- en: As the trapezoid’s area is given by h![a+2b](img/file1406.png), the area under
    the curve in [x[i−1],x[i]] is approximated by
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 由于梯形的面积为h![a+2b](img/file1406.png)，因此区间[x[i−1],x[i]]下的面积近似为
- en: '![ f (xi) + f(xi− 1) b− a (xi − xi−1)------2-------= -2n-(f(xi)+ f (xi− 1))
    ](img/file1407.png)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![ f (xi) + f(xi− 1) b− a (xi − xi−1)------2-------= -2n-(f(xi)+ f (xi− 1))
    ](img/file1407.png)'
- en: and we have the approximation
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 并且我们有近似值
- en: '![L(U,V ) = {f : U → V | f is linear}](img/file1408.png)(14.11)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![L(U,V ) = {f : U → V | f is linear}](img/file1408.png)(14.11)'
- en: This is the trapezoidal rule. It might seem complicated, but ([14.11](ch022.xhtml))
    is just a weighted sum of the f(x[i]) values.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是梯形法则。它可能看起来很复杂，但（[14.11](ch022.xhtml)）只是 f(x[i]) 值的加权和。
- en: Its rate of convergence is quadratic, as stated by the following theorem.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 它的收敛速度是二次的，如以下定理所述。
- en: Theorem 97\. (Trapezoidal rule)
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 97.（梯形法则）
- en: 'Let f : [a,b] →ℝ be a twicely differentiable function, and let'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '设 f : [a,b] →ℝ 是一个二次可微的函数，并且设'
- en: '![ n I := 1-∑ f(xi−-1)+-f(xi)- n n 2 i=1 ](img/file1409.png)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![ n I := 1-∑ f(xi−-1)+-f(xi)- n n 2 i=1 ](img/file1409.png)'
- en: be the approximation given by the trapezoidal rule. Then
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这是由梯形法则给出的近似值。然后
- en: '![ ∫ b 3 | f (x )dx − In| = O((b-−-a)-). a n2 ](img/file1410.png)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![ ∫ b 3 | f (x )dx − In| = O((b-−-a)-). a n2 ](img/file1410.png)'
- en: 'There are other methods, for instance, Simpson’s rule approximates the function
    with a piecewise quadratic one. (Instead of a piecewise linear one, like the trapezoidal
    rule.) Since the approximation is more accurate, the convergence is also faster:
    Simpson’s rule converges at a O(n^(−4)) rate. Without going into details, it is
    given by'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他方法，例如辛普森法则，它通过分段二次函数来近似该函数。（而不是像梯形法则那样使用分段线性函数。）由于近似更精确，收敛速度也更快：辛普森法则以 O(n^(−4))
    的速度收敛。无需深入细节，它由下式给出
- en: S[n] = ![b − a ----- 3n](img/file1411.png) ∑[i=1]^(⌊n/2⌋) ( f(x[2i−2]) + 4f(x[2i−1])
    + f(x[2i]) ), (14.12)
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: S[n] = ![b − a ----- 3n](img/file1411.png) ∑[i=1]^(⌊n/2⌋) ( f(x[2i−2]) + 4f(x[2i−1])
    + f(x[2i]) ), (14.12)
- en: with error
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 误差为
- en: '![ ∫ b 5 | f(x)dx − S | = O((b-−-a)-), a n n4 ](img/file1414.png)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![ ∫ b 5 | f(x)dx − S | = O((b-−-a)-), a n n4 ](img/file1414.png)'
- en: where x[i] is again the equidistant partition x[i] = a + i![b−na](img/file1415.png).
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 x[i] 再次是等距划分 x[i] = a + i![b−na](img/file1415.png)。
- en: 'The formula ([14.12](#)) can be difficult to unpack, but the essence remains
    the same: we compute the function’s values at given points, then take their weighted
    sum.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 公式（[14.12](#)）可能难以理解，但其本质保持不变：我们在给定点上计算函数值，然后取它们的加权和。
- en: 14.2.5 Implementing the trapezoidal rule
  id: totrans-267
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.2.5 实现梯形法则
- en: To show you how straightforward the trapezoidal rule is, let’s implement it
    in practice! To keep it simple, we are implementing this as a function that takes
    another function as its input.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示梯形法则是多么简单，我们来实践一下！为了保持简单，我们将其实现为一个接收另一个函数作为输入的函数。
- en: '[PRE0]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This can be made even simpler with NumPy, but I’ll leave this to you as an exercise.
    Let’s test it on an example instead!
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 NumPy 甚至可以更简单地实现这一点，不过我会把这留给你作为练习。我们来通过一个例子测试一下吧！
- en: With the use of the Newton-Leibniz formula (Theorem [92](ch022.xhtml#x1-235004r92)),
    you can verify that
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 使用牛顿-莱布尼茨公式（定理 [92](ch022.xhtml#x1-235004r92)），你可以验证
- en: '![∫ 1 x2dx = 1\. 0 3 ](img/file1416.png)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![∫ 1 x2dx = 1\. 0 3 ](img/file1416.png)'
- en: (We even computed this with our bare hands, using lower and upper sums.) After
    plugging the function lambda x: x**2 into trapezoidal_rule, we can see that this
    method is indeed correct.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: （我们甚至用手工计算过，使用了下和上和。）将函数 lambda x: x**2 代入 trapezoidal_rule 后，我们可以看到这种方法确实是正确的。
- en: '[PRE1]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '![PIC](img/file1417.png)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file1417.png)'
- en: 'Figure 14.8: The trapezoidal rule'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.8：梯形法则
- en: 14.3 Summary
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.3 总结
- en: In this chapter, we have learned about integration, one of the technically most
    challenging subjects so far. Intuitively, the integral of a function describes
    the signed area under its graph, but mathematically, it is given by the limit
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了积分，这是迄今为止技术上最具挑战性的主题之一。从直观上看，一个函数的积分描述了其图形下方的有符号面积，但从数学上讲，它由极限给出
- en: '![∫ b ∑n f(x)dx = lim (xi − xi− 1)f (xi), a n→∞ k=1 ](img/file1418.png)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![∫ b ∑n f(x)dx = lim (xi − xi− 1)f (xi), a n→∞ k=1 ](img/file1418.png)'
- en: 'where a = x[0]/span>x[1]/span>…/span>x[n] = b is a partition of the interval
    [a,b]. Of course, we don’t often calculate integrals by the definition; we have
    the Newton-Leibniz formula for that:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 a = x[0]/span>x[1]/span>…/span>x[n] = b 是区间 [a,b] 的划分。当然，我们不常按定义来计算积分；我们有牛顿-莱布尼茨公式来处理这个问题：
- en: '![∫ b f (x )dx = F (b)− F (a), a ](img/file1419.png)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![∫ b f (x )dx = F (b)− F (a), a ](img/file1419.png)'
- en: where F is the so-called antiderivative, satisfying F^′(x) = f(x). This is why
    integration is thought of as the inverse of differentiation.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 F 是所谓的反导数，满足 F^′(x) = f(x)。这就是为什么积分被认为是微分的逆过程。
- en: 'As one of my professors used to say, symbolic differentiation is easy, numeric
    differentiation is hard. It’s the opposite for integrals: symbolic integration
    is hard, and numeric integration is easy. We’ve learned a couple of tricks to
    pin down the symbolic part, namely the integration by parts formula'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我的一位教授曾经说的，符号微分很容易，数值微分很难。对于积分来说，情况正好相反：符号积分很难，数值积分很容易。我们已经学到了一些技巧来掌握符号部分，即分部积分法公式
- en: '![∫ ∫ b ′ x=b b ′ a f(x)g(x)dx = [f(x)g(x)]x=a − a f(x)g (x)dx ](img/file1420.png)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![∫ ∫ b ′ x=b b ′ a f(x)g(x)dx = [f(x)g(x)]x=a − a f(x)g (x)dx ](img/file1420.png)'
- en: and the integration by substitution formula
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 以及代换积分公式
- en: '![∫ b ∫ g(b) f(g(y))g′(y)dy = f(x)dx. a g(a) ](img/file1421.png)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![∫ b ∫ g(b) f(g(y))g′(y)dy = f(x)dx. a g(a) ](img/file1421.png)'
- en: When symbolic integration is hard (and it’s almost always hard), we can resort
    to numerical methods, such as the Simpson’s rule, given by
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 当符号积分困难时（几乎总是很困难），我们可以借助数值方法，比如辛普森法则，它由以下公式给出
- en: '![∫ b b − a⌊n∑∕2⌋ f(x)dx ∼ ----- (f(x2i−2) + 4f(x2i− i) + f(x2i)). a 3n i=1
    ](img/file1422.png)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
  zh: '![∫ b b − a⌊n∑∕2⌋ f(x)dx ∼ ----- (f(x2i−2) + 4f(x2i− i) + f(x2i)). a 3n i=1
    ](img/file1422.png)'
- en: Although integration is quite technical and complicated, its proper exposition
    is extremely important if you want to understand mathematics. The idea of approximating
    complex shapes with a sequence of rectangles (as shown in Figure [14.3](#)) is
    the foundation of measure theory, which, in turn, is the foundation of probability
    theory. (Hell, the idea of approximating complex objects with simpler ones is
    the foundation of mathematics.)
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管积分技术性很强且复杂，但如果你想理解数学，正确的阐述方式是极其重要的。用一系列矩形来近似复杂形状（如图[14.3](#)所示）是测度理论的基础，而测度理论又是概率论的基础。（实际上，用简单的东西来近似复杂对象是数学的基础。）
- en: 'By now, we have mastered differentiation and integration for single-variable
    functions. However, univariate functions are rare in practice: in machine learning,
    we often deal with millions or billions of variables. To handle them in practice,
    we’ll generalize all we’ve learned to higher dimensions. This is the subject of
    multivariable calculus, our next big milestone. Let’s get to it!'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经掌握了单变量函数的微分和积分。然而，单变量函数在实际中很少出现：在机器学习中，我们常常处理数百万或数十亿个变量。为了在实际中处理这些变量，我们将把我们所学的知识推广到更高维度。这就是多变量微积分的主题，我们的下一个重大里程碑。让我们开始吧！
- en: 14.4 Problems
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.4 问题
- en: Problem 1\. Use integration by parts to find the following antiderivates.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 问题1\. 使用分部积分法求以下反导数。
- en: (a) ∫ sin(x)cos(x)dx (b) ∫ xe^xdx (c) ∫ x²e^xdx (d) ∫ e^x sinxdx
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: (a) ∫ sin(x)cos(x)dx (b) ∫ xe^xdx (c) ∫ x²e^xdx (d) ∫ e^x sinxdx
- en: Problem 2\. Use integration by substitution to find the following antiderivatives.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 问题2\. 使用代换积分法求以下反导数。
- en: (a) ∫ xcos(x²)dx (b) ∫ sin(x)e^({-x)2}dx (c) ∫ ![sinx cosx-](img/file1423.png)
    (d) ∫ x![√x2-+-1](img/file1424.png)dx
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: (a) ∫ xcos(x²)dx (b) ∫ sin(x)e^({-x)2}dx (c) ∫ ![sinx cosx-](img/file1423.png)
    (d) ∫ x![√x2-+-1](img/file1424.png)dx
- en: 'Problem 3\. Let f : [a,b] →ℝ be an integrable function. Show that'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '问题3\. 设 f : [a,b] →ℝ 为一个可积函数。证明'
- en: '![∫ b ∫ b | f(x)dx| ≤ |f(x)|dx. a a ](img/file1425.png)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![∫ b ∫ b | f(x)dx| ≤ |f(x)|dx. a a ](img/file1425.png)'
- en: 'Problem 4\. Let f,g : [a,b] →ℝ be two integrable functions such that jfj² and
    jgj² are integrable as well. Show that'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '问题4\. 设 f,g : [a,b] →ℝ 为两个可积函数，并且 jfj² 和 jgj² 也可积。证明'
- en: '![ ∫ ∫ ∫ b 2 b 2 b 2 | a f(x)g(x)dx| ≤ a |f(x)| dx a |g(x)| dx. ](img/file1426.png)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![ ∫ ∫ ∫ b 2 b 2 b 2 | a f(x)g(x)dx| ≤ a |f(x)| dx a |g(x)| dx. ](img/file1426.png)'
- en: 'Hint: revisit Chapter 2 about normed spaces, and find an inequality that feels
    similar to this one.'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：回顾第二章关于规范空间的内容，找出一个与此不等式类似的结论。
- en: Problem 5\. The famous Dirichlet function is defined by
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 问题5\. 著名的狄里赫勒函数定义为
- en: '![ ( |{ 1 if x ∈ ℚ, D (x) = |( 0 otherwise. ](img/file1427.png)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![ ( |{ 1 if x ∈ ℚ, D (x) = |( 0 otherwise. ](img/file1427.png)'
- en: Is D(x) integrable?
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: D(x) 可积吗？
- en: Join our community on Discord
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加入我们的Discord社区
- en: Read this book alongside other users, Machine Learning experts, and the author
    himself. Ask questions, provide solutions to other readers, chat with the author
    via Ask Me Anything sessions, and much more. Scan the QR code or visit the link
    to join the community. [https://packt.link/math](https://packt.link/math)
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他用户、机器学习专家以及作者本人一起阅读本书。提出问题，向其他读者提供解决方案，通过“问我任何问题”环节与作者交流，还有更多精彩内容。扫描二维码或访问链接加入社区。[https://packt.link/math](https://packt.link/math)
- en: '![PIC](img/file1.png)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file1.png)'
