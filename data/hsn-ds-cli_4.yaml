- en: Bash Functions and Data Visualization
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Bash 函数与数据可视化
- en: So far, we've been working with bash interactively and had to rely on the bash `history` for
    what we've done. Wouldn't it be nice if you had a portable way to share and store
    the commands you want to run? Well, that functionality exists in the form of shell
    scripts composed of shell functions.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在与 bash 交互式工作，并且需要依赖 bash 的 `history` 来回顾我们做过的事情。要是有一个便捷的方式来分享和存储你希望执行的命令，岂不更好？其实，这种功能存在，就是通过包含
    shell 函数的 shell 脚本实现的。
- en: We're going to extend the history we covered in [Chapter 1](d26c5d26-6302-4b9d-b6ce-62b1ab13db0d.xhtml),
    *Data Science at the Command Line and Setting It Up*. Terminals originated as
    text-only devices and evolved graphical support for simple drawing primitives,
    such as rendering enclosed cells in tabular data. The pinnacle of Terminal graphics
    was made by DEC with canvas and vector-graphic support in the form of SIXEL and
    REGIS graphics, respectively. As physical Terminals became a thing of the past,
    lightweight Terminal emulators regressed to being text-only. A renaissance in
    graphics support from Terminal emulators has been occurring with the alacritty,
    wsltty, xterm, mlterm, st, iTerm2, and hterm emulators.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将扩展在[第 1 章](d26c5d26-6302-4b9d-b6ce-62b1ab13db0d.xhtml)中介绍的历史内容，*命令行中的数据科学及其设置*。终端最初是作为纯文本设备诞生的，并逐步发展为支持简单绘图原语的图形模式，例如渲染表格数据中的封闭单元格。终端图形的巅峰之作是由
    DEC 实现的，分别通过 SIXEL 和 REGIS 图形支持画布和矢量图形。随着物理终端逐渐消失，轻量级的终端模拟器退化为仅支持文本的模式。现在，终端模拟器的图形支持正经历一次复兴，alacritty、wsltty、xterm、mlterm、st、iTerm2
    和 hterm 等模拟器都在提供图形支持。
- en: We recommend wsltty with SIXEL support for Windows users, xterm or mlterm with
    SIXEL support for Linux users, and iTerm2 on macOS with PNG rendering (SIXEL support
    may be added in the future).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们推荐 Windows 用户使用带有 SIXEL 支持的 wsltty，Linux 用户使用带有 SIXEL 支持的 xterm 或 mlterm，macOS
    用户使用支持 PNG 渲染的 iTerm2（未来可能会添加 SIXEL 支持）。
- en: 'With a recommended Terminal emulator, we will show off canvas-style graphical
    rendering in the Terminal, and of course, include text mode support for DUMB Terminals.
    We''ll only mention that ascii-art libraries exists, `aalib` (**ascii art lib**),
    `libcaca`, and braille fonts that attempt to render graphics to the Terminal using
    font characters only. Here, we''ll work with SIXEL for Linux/Windows and PNG for
    macOS, and leave DUMB Terminal output for all advanced alternatives as an adventure
    for the reader. In this chapter, we''ll cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 使用推荐的终端模拟器，我们将展示在终端中进行画布样式的图形渲染，当然也包括对 DUMB 终端的文本模式支持。我们只提到存在 ascii-art 库，如
    `aalib` (**ascii art lib**)、`libcaca`，以及尝试仅使用字体字符将图形渲染到终端的盲文字体。这里，我们将使用 Linux/Windows
    上的 SIXEL 和 macOS 上的 PNG，DUMB 终端输出则留给读者作为所有高级替代方案的冒险。在本章中，我们将介绍以下主题：
- en: How to execute a script
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何执行脚本
- en: Function arguments/parameters
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数参数/参数
- en: Advanced shell scripting
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级 shell 脚本编写
- en: How to configure your Terminal for graphics mode
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何配置终端以支持图形模式
- en: Data mining graphable data
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据挖掘可绘图数据
- en: Graphing data with gnuplot
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 gnuplot 绘制数据图
- en: My first shell script
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我的第一个 shell 脚本
- en: Our first shell script will cover the basics of how to tell the computer to
    run the shell script.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个 shell 脚本将介绍如何告诉计算机运行 shell 脚本的基础知识。
- en: She bangs, she bangs!
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 她唱得真棒，唱得真棒！
- en: 'We''re not talking about that popular Ricky Martin song. We''re talking about
    what every bash script needs in order to run. If you''ve worked with other programming
    languages, you may have noticed the first line always starts with a `#!`. This
    tells the system which interpreter to use. For example, if you''ve worked with
    Python before, you''ve probably seen `#!/usr/bin/env python2.7` in a script. With
    bash, it''s no different. Let''s go ahead and create a new file named `hello_world.sh`
    and enter the following:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们并不是在谈论那首热门的 Ricky Martin 歌曲，而是我们在谈论每个 bash 脚本运行所需的内容。如果你曾经使用过其他编程语言，可能会注意到第一个行总是以
    `#!` 开头。这告诉系统应该使用哪个解释器。例如，如果你之前使用过 Python，可能已经在脚本中见过 `#!/usr/bin/env python2.7`。对于
    bash 来说，也没有什么不同。接下来，我们将创建一个名为 `hello_world.sh` 的新文件，并输入以下内容：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: File editors are the new, hip thing to debate about on the Internet. For example,
    search for `vim` versus `emacs` or `nano` versus `pico`. If you don't have a favorite
    editor, we won't force your selection, but you should use a Very Immensely Method
    to find your one true editor.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 文件编辑器是互联网上新的热门争论话题。例如，可以搜索 `vim` 与 `emacs`，或 `nano` 与 `pico`。如果你没有特别喜欢的编辑器，我们不会强迫你选择，但你应该采用一种非常深刻的方法来找到属于你的终极编辑器。
- en: 'Go ahead and save this file as `hello_world.sh` and then let''s make the script
    executable:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 请将此文件保存为`hello_world.sh`，然后使脚本可执行：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, you can run the script like so:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以这样运行脚本：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Let's break this down. The first line is the shebang that we mentioned. Our
    functions are called `greet_everyone` and `greet_yourself`. Inside the curly brackets, `{
    }`, we can run as many commands as we want. Finally, the functions are called
    below it. Also, notice the `${USER}` variable inside the script. You might be
    wondering how bash was smart enough to print out your username without you defining
    it. Every bash environment has a set of preconfigured variables that you can view.
    Go ahead and run the `printenv` command to see what's available.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们拆解一下。第一行是我们提到过的shebang。我们的函数叫做`greet_everyone`和`greet_yourself`。在大括号`{ }`内，我们可以执行任意数量的命令。最后，函数在下面被调用。另请注意脚本中的`${USER}`变量。你可能会想，bash是如何聪明到在没有你定义的情况下打印出你的用户名的呢？每个bash环境都有一组预配置的变量，你可以查看这些变量。请运行`printenv`命令，看看有哪些可用的变量。
- en: This is great if we want to greet the entire world and use your username. But,
    what if we want to take this further?
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想向全世界问好并使用你的用户名，这样很好。但如果我们想更进一步呢？
- en: Function arguments, positional parameters, and IFS
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数参数、位置参数和IFS
- en: Functional arguments, positional parameters, and the **IFS** (**internal field
    separator**) are advanced list-processing mechanics in bash. We'll cover each
    of them in turn to ensure a base knowledge of how the shell interacts with them.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 函数参数、位置参数和**IFS**（**内部字段分隔符**）是bash中的高级列表处理机制。我们将依次讲解它们，以确保对shell与它们的交互有基本的了解。
- en: Prompt me baby one more time
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 再来一次，宝贝
- en: 'We discussed how to invoke our function, but how do we prompt our users for
    input? The computer can''t read your mind—it can only read your keyboard input!
    For bash to read input, you''ll have to use the (you guessed it) `read` command.
    Let''s expand our function''s capabilities. Go ahead and modify your `hello_world.sh` script
    from the previous section with the following:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了如何调用我们的函数，但我们怎么提示用户输入呢？计算机不能读心——它只能读取你的键盘输入！为了让bash读取输入，你必须使用（你猜对了）`read`命令。让我们扩展我们函数的能力。请修改你在上一节中的`hello_world.sh`脚本，添加如下内容：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We''ve added the `read name` code, replaced the `${USER}` variable with `${1:-$USER}` in
    the `greet_yourself` function, and added our first argument to our `greet_yourself
    $name` function call. When `$name` is passed into the `greet_yourself` function,
    it''s assigned to the `$1` variable. That `${1:-$USER}` magic variable is saying
    expand `$1`; if empty, replace with `$USER` retaining the same output behavior
    of our original function if no username is provided by just pressing the `enter` key.
    Run it again to see the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了`read name`代码，将`${USER}`变量替换为`${1:-$USER}`在`greet_yourself`函数中，并将我们的第一个参数添加到`greet_yourself
    $name`函数调用中。当`$name`被传递到`greet_yourself`函数时，它会被赋值给`$1`变量。那个`${1:-$USER}`魔法变量的意思是展开`$1`；如果为空，则替换为`$USER`，保留原函数的输出行为，如果没有提供用户名，仅按下`enter`键时依然如此。再次运行它，看看结果：
- en: '![](img/32e846b5-c3ab-410b-b248-70fe7b413b65.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/32e846b5-c3ab-410b-b248-70fe7b413b65.png)'
- en: 'Let''s focus on just our function. Paste the following code into your shell:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们专注于我们的函数。将以下代码粘贴到你的shell中：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is a fancy means of creating the `greetlib.sh` file. The `<<EOF` here is
    doc redirection that indicates that we want to specify the standard input to `cat`
    and redirect its standard output to `greetlib.sh`. Everything after that first
    line is shell-interpreted content that's to be concatenated to the end of our
    output file until `EOF` is read. Shell-interpreted content means that variables
    are replaced with values from your current shell environment, we've escaped our
    shell variables with `\$` so that they will be rendered into the `greetlib.sh`
    file as `$` and not interpreted into actual values. Finally, we can source our
    function into our current shell environment and invoke it. We'll practice that
    in the next section.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这是创建`greetlib.sh`文件的一种高级方式。这里的`<<EOF`是文档重定向，表示我们想将标准输入指定给`cat`，并将其标准输出重定向到`greetlib.sh`。此行之后的所有内容是shell解释的内容，会被连接到我们的输出文件末尾，直到读取到`EOF`。Shell解释的内容意味着变量会被替换为当前shell环境中的值，我们使用`\$`转义了shell变量，这样它们会被渲染成`$`，而不是被解析为实际的值。最后，我们可以将函数导入当前的shell环境并调用它。我们将在下一节练习这个。
- en: Feed the function input!
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 给函数提供输入！
- en: 'Our shell function accepts arguments, known as positional parameters, which
    are the equivalent of ARGV from a POSIX C runtime. Function arguments are automatically
    assigned by their numeric position to variables in this form: `$1, $2, $3, ..,
    $9`. The `$0` variable exists, but contains the name that was used to invoke the
    shell. Some inquiring minds might wonder what happens after the ninth argument.
    Well we need to use the full variable dereferencing syntax, for the tenth and
    eleventh variables, `${10}` and `${11}`, respectively. So what does that all look
    like? Check it out:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 shell 函数接受参数，称为位置参数，它们相当于 POSIX C 运行时中的 ARGV。函数参数会根据其数字位置自动分配给变量，格式为：`$1,
    $2, $3, .., $9`。`$0` 变量存在，但包含用于调用 shell 的名称。一些好奇的人可能会想知道第九个参数之后会发生什么。其实我们需要使用完整的变量解引用语法，对于第十个和第十一个变量，分别是
    `${10}` 和 `${11}`。那么这看起来是什么样子呢？来看一下：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `.` operator is used to read and evaluate a shell script in your current
    execution environment, as though you had typed all of `greetlib.sh` into the command
    line and pressed the `enter` key. This calls the `greet_yourself` function with
    the first positional parameter, `"Joey"`, assigned to `$1`. To jump ahead, we
    have types of positional parameters: options (covered at the end of the chapter)
    and arguments. Options come in short and long forms and are identified by a single
    hyphen or double-hyphen, respectively. Short options are single characters and
    long options are full semantic words that describe values to set. If an argument
    needs a literal hyphen at the start of its value, it needs to be distinguished
    from options by proceeding with a double-hyphen. Hypothetically, this is gobbledygook
    looks like this:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`.` 运算符用于在当前执行环境中读取并评估 shell 脚本，就像你将 `greetlib.sh` 的所有内容输入命令行并按下 `enter` 键一样。这会调用
    `greet_yourself` 函数，并将第一个位置参数 `"Joey"` 分配给 `$1`。跳到后面，我们有几种位置参数类型：选项（在章节末尾讲解）和参数。选项有短格式和长格式，分别由单个连字符或双连字符标识。短选项是单个字符，长选项是描述要设置的值的完整语义词。如果一个参数的值以连字符开头，它需要通过使用双连字符来与选项区分开来。假设情况如下所示：'
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: These examples showcase how options and arguments can be passed to a function,
    because the options are just positional parameters. In the first greeting call,
    we assign `--capitalize` to the first positional parameter, `$1`, and `--name=”Joey”` to
    the second positional parameter, `$2`. In the second greeting call, we assign `--lowercase` to
    `$1`, `--` to `$2`, and `-RoBoT1` to `$3`. Our function is basic and lacks the
    ability to process the `--capitalize` and `--lowercase` options as function features.
    We pretend the first greeting call should output `"JOEY"`, and the second greeting
    `-robot1`. Some may wonder how a command can distinguish options that begin with
    a hyphen from an argument, such as `-RoBoT1`. The bare double-hyphen `--` indicates
    that all following positional parameters are to be treated as arguments and not
    processed as options. Again, we'll dig into option processing at the end of the
    chapter, but it's easiest to show function invocations all at once.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例展示了如何将选项和参数传递给函数，因为选项实际上只是位置参数。在第一次问候调用中，我们将 `--capitalize` 分配给第一个位置参数 `$1`，并将
    `--name="Joey"` 分配给第二个位置参数 `$2`。在第二次问候调用中，我们将 `--lowercase` 分配给 `$1`，`--` 分配给
    `$2`，`-RoBoT1` 分配给 `$3`。我们的函数很基础，无法将 `--capitalize` 和 `--lowercase` 选项作为函数功能处理。我们假装第一次问候调用应输出
    `"JOEY"`，第二次问候输出 `-robot1`。有人可能会想知道，命令如何区分以连字符开头的选项和参数，如 `-RoBoT1`。裸双连字符 `--`
    表示所有后续位置参数应被视为参数，而不是选项。我们将在章节末尾深入讨论选项处理，但最简单的方式是一次性展示函数调用。
- en: Down the rabbit hole of IFS and bash arrays
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入了解 IFS 和 bash 数组
- en: 'Positional parameters are created from the arguments to a shell script, function,
    or the `set` command. The assignment of words to positional variables is accomplished
    by splitting the unquoted string along any of the delimiters contained within
    the IFS variable. The IFS variable defaults to the string, which consists of a
    space, tab, and newline characters. Since the IFS is a variable, it''s possible
    to modify this variable, which is useful when iterating over non-space-delimited
    text:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 位置参数是由 shell 脚本、函数或 `set` 命令的参数创建的。将单词分配给位置变量是通过将未加引号的字符串按 IFS 变量中包含的任意定界符拆分来实现的。IFS
    变量的默认值是包含空格、制表符和换行符的字符串。由于 IFS 是一个变量，因此可以修改此变量，这在遍历非空格分隔的文本时非常有用：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The preceding code exemplifies how the PATH variable, which consists minimally
    of `/bin:/usr/bin`, can be split with a colon delimiter so that each path segment
    can be manipulated. We expect the reader can extrapolate how this might be useful
    for iterating over comma-separated lists, or similar simply delimited datasets.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码展示了如何将最基本的 `/bin:/usr/bin` 组成的 PATH 变量通过冒号分隔符拆分，以便可以操作每个路径段。我们期望读者能够推测出，这种方法如何有助于遍历逗号分隔的列表或类似的简单分隔数据集。
- en: 'Due to limitations in modifying positional parameters, bash 4 introduced arrays.
    In the event that your shell scripts become sufficiently complex to require arrays,
    we encourage you to consider upgrading to a full-fledged scripting language, such
    as Perl, Python, or Ruby, that''s better-suited to handling various list iterations
    that bash doesn''t natively support. Delving in, bash arrays are zero-indexed,
    and are accessed with the `${ARRAY[#]}` special syntax, where the `#` sign should
    be replaced by the integer array index or the special values of `@` or `*`, which
    represent the quoted elements or unquoted elements converted into a string. Here''s
    some code as an example of bash arrays:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 由于修改位置参数的限制，bash 4 引入了数组。如果您的 Shell 脚本变得足够复杂，需要数组的支持，我们建议您考虑升级到一个完整的脚本语言，如 Perl、Python
    或 Ruby，这些语言更适合处理 bash 不原生支持的各种列表迭代。深入了解，bash 数组是零索引的，可以使用 `${ARRAY[#]}` 特殊语法进行访问，其中
    `#` 符号应替换为整数数组索引或 `@` 或 `*` 的特殊值，这些值表示转换为字符串的引号元素或非引号元素。以下是一个 bash 数组的示例代码：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Advanced shell scripting magic
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级 Shell 脚本魔法
- en: This is the dark magic section of the chapter. It will demonstrate advanced
    shell scripting by taking the preceding lessons and features, and converting them
    into what could be considered a small program.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这是本章的黑魔法部分。它将通过将前面的课程和特性结合起来，展示高级 Shell 脚本，并将其转换为可以视为一个小程序的形式。
- en: Here be dragons, ye be warned
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 此处有龙，谨慎前行
- en: A simple piece of introductory code is great to get a feel for the flavor of
    a language, but we're going to introduce some dark magic in the form of some complex
    utility functions that can be helpful in everyday situations. We'll use a `lineinfile` function
    to insert arbitrary text into a file—it's not a full-featured application, just
    enough to help ensure some simple text is injected into a file. The second function, `ncz`,
    leverages bash IP networking (yes, bash4 can support IP networking YMMV with your
    distro) to perform a socket test equivalent to what `netcat -z` does. Additionally,
    it shows how to make a function behave like a command-line program by parsing
    simple argument flags.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 一段简单的入门代码非常适合让你感受语言的风味，但我们将引入一些黑魔法，形式为一些复杂的工具函数，这些函数在日常情况下非常有用。我们将使用 `lineinfile`
    函数将任意文本插入到文件中——它不是一个功能完整的应用程序，只是足够确保一些简单的文本被注入到文件中。第二个函数 `ncz` 利用 bash IP 网络功能（是的，bash4
    可以支持 IP 网络，与你的发行版相关）执行类似于 `netcat -z` 的套接字测试。此外，它展示了如何通过解析简单的参数标志，使函数表现得像一个命令行程序。
- en: Text injection of text files
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文本文件的文本注入
- en: 'We''re going to create a function that can inject text into an existing file.
    Here''s our function:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个可以将文本注入到现有文件中的函数。以下是我们的函数：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The intended usage is as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 预期的用法如下：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`lineinfile` starts off with the standard `function() {}` definition template.
    It reads the first positional parameter passed to the function, `$1`, into the `FILE` variable,
    and shifts the positional parameters so that each parameter''s index is decremented
    by one, so `$2` becomes `$1`, `$3` becomes `$2`, and so on. The second parameter
    is assigned to the `LINE` variable and we prefix it with the regular expression
    start of line `^` and end of line `$` delimiters to indicate that the string being
    injected must match an entire line (sorry, there''s no advanced regex support
    in this simple function). The third parameter looks for context so that we can
    inject the line after the context. Again no ability to specify injecting before
    the context, just after the context if it exists. The fourth parameter is the
    operating mode of our `lineinfile` function to either `add` (adding text is the
    default behavior) or to delete (use the `del` mode).'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`lineinfile`从标准的`function() {}`定义模板开始。它将传递给函数的第一个位置参数`$1`读取到`FILE`变量中，并将位置参数向左移动，使得每个参数的索引减少1，`$2`变为`$1`，`$3`变为`$2`，以此类推。第二个参数被赋值给`LINE`变量，并且我们用正则表达式的行首`^`和行尾`$`定界符为其加上前缀，以指示要插入的字符串必须匹配整行（抱歉，这个简单的函数不支持高级正则表达式）。第三个参数用于查找上下文，以便我们可以在上下文之后插入该行。再次说明，不能指定在上下文之前插入，只能在上下文之后插入（如果存在的话）。第四个参数是我们的`lineinfile`函数的操作模式，可以是`add`（默认行为是添加文本）或者是删除模式（使用`del`模式）。'
- en: Bash networks for fun and profit!
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Bash 网络，用于娱乐和盈利！
- en: 'Sometimes, we need to interact with network services or APIs. Here, we''ll
    introduce some complete code that tests TCP endpoints, which is useful for checking
    whether an API service is listening and available. This code can be pasted into
    your Terminal, or saved to a file and loaded into your shell environment with
    the `.` operator:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们需要与网络服务或API进行交互。在这里，我们将介绍一些完整的代码，用于测试TCP端点，这对于检查API服务是否在监听并且可用非常有用。您可以将这段代码粘贴到终端中，或者保存到一个文件中，并使用`.`操作符将其加载到您的Shell环境中：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now, this code has some minor magic. `getopts` is a function that parses positional
    parameters, according to POSIX processing into options, and assigns the next option
    to the variable specified, in this case opt. It supports short and long options,
    and options can have parameters; parameters would be stored in `OPTARG`. This
    example uses a trivial option string of `:hv`. The colon character indicates that
    invalid option flags should be denoted with the question mark character, `?`.
    The `h` option is for our help flag and `v` is used so we can set a `VERBOSE` flag.
    The `while` loop calls the `getopts` function, which modifies the positional parameters.
    When the `getopts` function completes, it's necessary to shift the processed positional
    parameters out so that we can treat non-options as function arguments. `OPTIND` is
    the index of the last option parsed, so subtracting one from that and shifting
    the positional parameters by that amount ensures that we only proper arguments
    remain in our positional parameters.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这段代码有一些小魔法。`getopts`是一个函数，用于解析位置参数，根据POSIX处理将其转换为选项，并将下一个选项分配给指定的变量，在这个例子中是
    opt。它支持短选项和长选项，并且选项可以有参数；这些参数会被存储在`OPTARG`中。这个例子使用了一个简单的选项字符串`:hv`。冒号字符表示无效的选项标志应该用问号字符`?`表示。`h`选项是我们的帮助标志，`v`用于设置`VERBOSE`标志。`while`循环调用`getopts`函数，它会修改位置参数。当`getopts`函数完成后，必须将已处理的位置信息移除，以便我们将非选项当作函数参数处理。`OPTIND`是最后一个解析的选项的索引，因此从中减去1并按该数量移动位置参数，确保我们的位置参数中只剩下正确的参数。
- en: The code attempts to support accepting arguments in the form of `host:port`
    or `host port`. The support for single-parameter or two-parameter arguments is
    handled by always using the second argument as the port, and if there's no second
    argument, defaults to splitting the first parameter on the colon character using
    prefix and suffix removal. The `HOST=${1%:*}` assignment attempts to extract a
    host component from a `host:port` argument by expanding the first positional argument,
    stripping all trailing characters (`%` is a reverse-substitution match) to the
    first colon character (the delimiter between `host:port`) so that we're left with
    just the host portion of the variable. If the reverse match fails, which indicates
    no port components, the unmodified expansion of `$1` will be assigned. To get
    the port, we look at the second argument. If it doesn't exist, we default to the
    port extracted from the first positional argument by stripping the `host:` portion
    of `$1`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码尝试支持接受`host:port`或`host port`形式的参数。对于单参数或双参数的支持通过始终将第二个参数用作端口来处理，如果没有第二个参数，则默认通过使用前缀和后缀删除符号将第一个参数拆分。在`HOST=${1%:*}`赋值中，它尝试通过扩展第一个位置参数，剥离所有尾部字符（`%`为反向替代匹配）直到第一个冒号字符（`host:port`中的分隔符），从而提取出主机部分。如果反向匹配失败，表示没有端口组件，则将未修改的
    `$1` 展开并赋值。为了获取端口，我们查看第二个参数。如果不存在第二个参数，则默认从第一个位置参数中提取端口，通过剥离`host:`部分。
- en: The real dark magic involves file descriptors and bash's IP network support.
    We open file descriptor 6 inside a subshell. We attach the input/output of the
    socket created by `/dev/tcp/$HOST/$PORT` to this file descriptor. Anything written
    to the file descriptor will be sent via a TCP socket to `tcp://$HOST:$PORT`, and
    any responses can be read from the same file descriptor. As network connections
    can error, we capture the return code of the socket open to the `RC` (that’s short
    for return code) variable. We then evaluate whether output is desired from a verbose
    option flag and the status of the return code, printing success/failure according
    to the return code. In C programs, a return code of 0 indicates success, so `true0` indicates
    that the function has invoked to request the verbose mode and a successful socket
    connection was made. Finally, the return code is returned from the function so
    that the status of the remote socket can be evaluated via a shell pipeline.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 真实的黑魔法涉及文件描述符和 Bash 的 IP 网络支持。我们在子Shell中打开文件描述符6。我们将通过`/dev/tcp/$HOST/$PORT`创建的套接字的输入/输出附加到该文件描述符。任何写入该文件描述符的数据将通过
    TCP 套接字发送到`tcp://$HOST:$PORT`，并且任何响应都可以从同一文件描述符中读取。由于网络连接可能会出错，我们将套接字打开的返回码捕获到`RC`变量（即返回码的缩写）中。然后，我们评估是否需要根据详细选项标志和返回码的状态输出，按照返回码打印成功/失败。在
    C 程序中，返回码为 0 表示成功，因此`true0`表示该函数已被调用以请求详细模式，并且成功地建立了套接字连接。最后，返回码会从函数中返回，以便通过 Shell
    管道评估远程套接字的状态。
- en: 'Here''s a self-explanatory invocation of the preceding explanation:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对前述解释的自我解释调用：
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: From dumb Terminal to glam Terminal
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从简单终端到炫酷终端
- en: 'We''re going to use gnuplot to render dumb text graphics and canvas-style plots
    inside our Terminal. To begin, we need some basic configuration for our gnuplot
    startup. Put the following in `~/.gnuplot`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 gnuplot 在终端中渲染简单的文本图形和画布风格的图表。首先，我们需要为 gnuplot 启动一些基本配置。将以下内容放入`~/.gnuplot`中：
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, we need a wrapper around gnuplot to get some fancy graphical output.
    This wrapper looks at the `GNUTERM` environment variable of your current shell
    and does some calculations on the Terminal''s width and height so that gnuplot
    knows how big a window it has. The wrapper will update our `~/.gnuplot` configuration
    with the graphics capabilities specified for our Terminal. We aren''t going to
    delve into the wrapper, but just use it as another command. Here it is:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要一个围绕 gnuplot 的包装器来获得一些花哨的图形输出。这个包装器查看你当前 shell 的`GNUTERM`环境变量，并对终端的宽度和高度进行一些计算，以便
    gnuplot 知道它窗口的大小。该包装器将更新我们的`~/.gnuplot`配置，指定终端的图形能力。我们不会深入研究这个包装器，而是将它作为另一个命令使用。它是这样的：
- en: '[PRE14]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Depending on your OS and Terminal, you'll need to specify the correct graphics
    backend for your Terminal.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的操作系统和终端，你需要为终端指定正确的图形后端。
- en: 'Windows users with wsltty, and Linux users with mlterm or xterm, should set
    the following environment variable:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 wsltty 的 Windows 用户和使用 mlterm 或 xterm 的 Linux 用户应该设置以下环境变量：
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'macOS users with iTerm2 should use this environment variable:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 iTerm2 的 macOS 用户应该使用以下环境变量：
- en: '[PRE16]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Let's verify that we're able to plot a graphical test pattern. If your dumb
    Terminal doesn't support graphical mode, we include a text mode test afterwards.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们验证我们能够绘制一个图形测试模式。如果您的愚蠢终端不支持图形模式，则随后进行文本模式测试。
- en: 'For the graphical test, run the following:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 对于图形测试，请运行以下命令：
- en: '[PRE17]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This should result in a graphical Terminal output like this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会产生类似以下的终端图形输出：
- en: '![](img/f360f088-ca0a-4844-b573-c8ca23660da6.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f360f088-ca0a-4844-b573-c8ca23660da6.png)'
- en: Some quick callouts to the test output are important for styling your output
    graphs. The line type on the far right of the test graphic is abbreviated as `lt`
    and provides the visual marker for the plotted tics (or points) of the plot, for
    example, *, +, and x. The linewidth, abbreviated to `lw`, is on the bottom left
    and sets the line's thickness for the plotted line.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 对于样式化输出图形，快速调用测试输出很重要。图形测试中最右侧的线型简写为`lt`，提供绘制刻度（或点）的视觉标记，例如`*`、`+`和`x`。线宽，简写为`lw`，位于左下角，并设置绘制线条的线条厚度。
- en: 'If your Terminal doesn''t support graphics mode, text plotting can be used.
    Invoke the text test:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的终端不支持图形模式，可以使用文本绘图。调用文本测试：
- en: '[PRE18]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Which should result in a Terminal output like this:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会产生如下终端输出：
- en: '![](img/82efbc34-3db3-4731-809c-4972c4515e58.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](img/82efbc34-3db3-4731-809c-4972c4515e58.png)'
- en: 'Finally, we need an `alias` to invoke our function with the `GNUTERM` environment
    variable that''s set to an acceptable graphics backend. Run the following alias
    with the `GNUTERM` variable set as determined to work with your Terminal:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要一个`alias`，以调用我们的函数，并使用设置为可接受的图形后端的`GNUTERM`环境变量。在您的终端中运行以下别名，并设置`GNUTERM`变量以确保正常工作：
- en: '[PRE19]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Who, what, where, why, how?
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 谁、什么、哪里、为什么、如何？
- en: 'Let''s return to our book data and start to pare it down to the interesting
    bits. Let''s look at just a little bit of our data:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的书籍数据，并开始将其精简为有趣的部分。让我们只看一小部分我们的数据：
- en: '[PRE20]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'That spat out a bunch of data with very long lines. Let''s try again—maybe
    we really only care about the headers, so let''s try this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出一堆非常长的数据行。让我们再试一次 —— 或许我们真的只关心标题，所以让我们试试这个：
- en: '[PRE21]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Since there''s a lot of text, let''s remove the text fields and focus on numeric
    data by removing `product_title`, `review_headline`, and `review_body`, which
    correspond to fields 6,13, and 14\. Since we''re looking at pseudo big data, let''s
    take all the numerical or Boolean flag fields and dump all the text reviews (we
    can leave that for the natural-language processing folks to analyze), try this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 由于有大量文本，让我们移除文本字段，只关注数值数据，通过删除`product_title`、`review_headline`和`review_body`，它们对应字段
    6、13 和 14。因为我们正在研究伪大数据，让我们获取所有数值或布尔标志字段，并转储所有文本评论（留给自然语言处理专家分析），尝试这个：
- en: '[PRE22]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Just like that, we''ve reduced our data size from 6.3 GB to 383 MB of pruned
    `test.tsv` data, which is much more manageable. Now, let''s import this into a
    SQL database to make aggregating tabular data as easy as a SQL query:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 就像这样，我们将数据大小从 6.3 GB 减少到了 383 MB 的修剪后的`test.tsv`数据，这样更易管理。现在，让我们将其导入 SQL 数据库，以便像执行
    SQL 查询一样聚合表格数据：
- en: '[PRE23]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Let''s find the products with the most reviews:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们找出评论最多的产品：
- en: '[PRE24]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The following output (counts may differ) should be displayed:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 应显示以下输出（计数可能有所不同）：
- en: '[PRE25]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '54,000 reviews seems like something we could plot some interesting data for,
    so let''s focus on the product ID `B00L9B7IKE`. For plotting, we know which product
    ID we''re looking at, so let''s adjust our query to not report the product ID
    and just focus on the dates, star rating, and counts:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 54,000 条评论看起来可以为我们绘制一些有趣的数据，所以让我们专注于产品 ID `B00L9B7IKE`。对于绘图，我们知道我们正在查看哪个产品 ID，所以让我们调整我们的查询，不报告产品
    ID，只关注日期、星级评分和计数：
- en: '[PRE26]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The following output will be displayed:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 将显示以下输出：
- en: '[PRE27]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: That's some plottable data if I've ever seen some. We can track how many reviews
    we're getting by day or month, and when we graph this, we can look for anomalies,
    such as an exceptional number of five-star reviews on a single day when prior
    days didn't stick out so much.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我看到了一些可绘制的数据，那真是太好了。我们可以通过日或月跟踪评价的数量，当我们绘制时，我们可以寻找异常，例如在一天内有异常数量的五星级评价，而前几天并没有如此突出。
- en: 'Our data still isn''t quite right; for plotting, we want to group the star
    ratings by date in a single row, so we''ll need to perform another translation
    on the data. We also drop the `-` column option so we get condensed output, and
    we can pipe this through `tr` when we''re ready to pass the data to gnuplot. We''ll
    also save this output into `clusterchart.dat` so that our plotting commands are
    short and simple:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数据仍然不完全正确；为了绘图，我们需要按日期将星级评分分组为单行，因此我们需要对数据进行另一次转换。我们还去掉了`-`列选项，以便得到简洁的输出，并且在准备将数据传递给gnuplot时，我们可以通过`tr`来管道这些数据。我们还会将此输出保存到`clusterchart.dat`，这样我们的绘图命令就可以简短而简单：
- en: '[PRE28]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Finally, here''s our condensed output for graphing with gnuplot:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这就是我们用于绘图的简洁输出，使用gnuplot生成图表：
- en: '[PRE29]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Enter the mind's eye
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进入思维的视野
- en: 'Let''s check out what this looks like. Run the following code:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个效果。运行以下代码：
- en: '[PRE30]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This should produce the following in your Terminal:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在终端中产生以下内容：
- en: '![](img/bb22fb88-dc2a-4844-89f6-40bb2eb7f1b7.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bb22fb88-dc2a-4844-89f6-40bb2eb7f1b7.png)'
- en: 'Let''s do the exact same operation, but output the `dumb` output:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们做同样的操作，但输出`dumb`格式：
- en: '[PRE31]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We get a text-based output:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到一个基于文本的输出：
- en: '![](img/e7cfea49-063b-4a16-bd4a-d70bc566458c.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e7cfea49-063b-4a16-bd4a-d70bc566458c.png)'
- en: 'To break down what we did, check out the following code:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为了分解我们所做的操作，看看以下代码：
- en: '[PRE32]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The first step is to set `GNUTERM`, which should default to what we set in `~/.bash_profile`.
    This tells our gnuplot wrapper which output backend to use. For `GNUTERM=dumb`,
    it will be a text backend. The next part is `gnuplot` with the `-e` expression
    argument. The expression is `gnuplot` syntax. We first set our plots to histograms
    instead of line graphs with `set style data histograms`. Next, we specify the
    bar color by setting it to a flood fill with a solid border and use linetype `-1` as
    the default linetype. After we've defined our plot style, we tell gnuplot to plot
    our data with `plot 'clusterchart.dat'`. Each comma-separated parameter to plot
    represents a column to plot for each row of data in `clusterchart.dat`. We specify
    that the first column in our plot should use the second column of data and use
    the first column of data as our x-label, as denoted by `2:xtic(1) ti col`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是设置`GNUTERM`，它应该默认使用我们在`~/.bash_profile`中设置的内容。这告诉我们的gnuplot包装器使用哪个输出后端。对于`GNUTERM=dumb`，它将使用文本后端。接下来的部分是带有`-e`表达式参数的`gnuplot`。表达式是`gnuplot`的语法。我们首先使用`set
    style data histograms`将图表设置为柱状图，而不是折线图。接下来，我们通过设置为填充填色并使用实线边框来指定柱子的颜色，并使用`-1`作为默认的线条类型。在定义了绘图样式后，我们告诉gnuplot用`plot
    'clusterchart.dat'`绘制我们的数据。每个逗号分隔的参数表示`clusterchart.dat`中每行数据的绘图列。我们指定图表的第一列应使用第二列的数据，并使用第一列数据作为x标签，这通过`2:xtic(1)
    ti col`来表示。
- en: The second column in our plot uses the same `clusterchart.dat` as input by indicating
    the same with two concatenated single quotes and specifies the use of the third
    data column for tick data. The third, fourth, and fifth columns use the same notation
    as the second column, which is to indicate the reuse of `clusterchart.dat` and
    to specify the data column to extract the y-tick data.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图表中的第二列使用相同的`clusterchart.dat`作为输入，通过两个连续的单引号来表示相同，并指定使用第三列数据作为刻度数据。第三、第四和第五列采用与第二列相同的表示法，即表示重用`clusterchart.dat`并指定提取y轴刻度数据的列。
- en: 'If we want to get a little fancier, we can use rowstacking instead of clustered
    bar graphs so we can visualize our data more compactly. Try this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想让它更炫酷一些，我们可以使用行堆叠，而不是聚类柱状图，这样我们可以更紧凑地可视化数据。试试看：
- en: '[PRE33]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We get a stacked bar chart:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了一个堆叠柱状图：
- en: '![](img/9e5dfc76-990e-4092-89cb-6656d7d648f2.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9e5dfc76-990e-4092-89cb-6656d7d648f2.png)'
- en: 'Now, if we want to see percentages, we can use our `barchart` wrapper in stacked
    mode. It''s nice to see the discrepancy between different data segments. Try invoking
    the following code:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们想查看百分比，可以在堆叠模式下使用我们的`barchart`包装器。这样可以清晰地看到不同数据段之间的差异。尝试运行以下代码：
- en: '[PRE34]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'It produces the following output:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 它会产生如下输出：
- en: '![](img/0a907dd3-adbb-4195-adba-75a14599e1b8.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0a907dd3-adbb-4195-adba-75a14599e1b8.png)'
- en: This is using our bar chart wrapper in stacked mode (`-s`), and specifying our
    `clusterchart.dat` input file, with the gnuplot script as the last parameter.
    For gnuplot, we're telling it to perform a single iterative plot for `i=2` to
    `6`. The `$data` variable is being set by the bar chart wrapper to the content
    of `clusterchart.dat`. The using parameter is multiplying our fraction by `100`
    to create the percentage of the bar chart for each element, `i`, of the total
    from column `7`. `xtic(1)` is setting the `xtic` mark titles to the contents of
    column 1 for each row of data graphed in a column. In this example, we need to
    add the `column(i)` title to get the key title set properly to the column headers,
    instead of using the last referenced `column(7)` header.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用我们的条形图包装器以堆叠模式（`-s`）并指定我们的`clusterchart.dat`输入文件，最后一个参数为gnuplot脚本。对于gnuplot，我们告诉它对`i=2`到`6`进行一次单独的迭代绘图。`$data`变量由条形图包装器设置为`clusterchart.dat`的内容。`using`参数将我们的分数乘以`100`，以为每个元素`i`创建条形图的百分比，这个元素来自第`7`列的总和。`xtic(1)`将`xtic`标记标题设置为每行数据图表中第1列的内容。在这个示例中，我们需要添加`column(i)`标题，以便正确设置关键标题为列标题，而不是使用最后引用的`column(7)`标题。
- en: Summary
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: With the ability to reuse bash code, a collection of scripts can be cobbled
    together to enhance your command-line productivity. And with the ability to visualize
    results, you can peer into datasets and perform data mining tasks more quickly.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 通过重用bash代码的能力，您可以将一系列脚本组合在一起，从而提高命令行的生产力。并且，通过可视化结果，您可以更快速地分析数据集并执行数据挖掘任务。
- en: In the next chapter, we'll dig deeper into bash control flow to create richer
    functions.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将深入探讨bash控制流，以创建更丰富的函数。
