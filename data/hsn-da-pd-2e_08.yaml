- en: '*Chapter 6*: Plotting with Seaborn and Customization Techniques'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第6章*：使用Seaborn绘图及定制技巧'
- en: In the previous chapter, we learned how to create many different visualizations
    using `matplotlib` and `pandas` on wide-format data. In this chapter, we will
    see how we can make visualizations from long-format data, using `seaborn`, and
    how to customize our plots to improve their interpretability. Remember that the
    human brain excels at finding patterns in visual representations; by making clear
    and meaningful data visualizations, we can help others (not to mention ourselves)
    understand what the data is trying to say.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何使用`matplotlib`和`pandas`在宽格式数据上创建多种不同的可视化。在本章中，我们将看到如何使用`seaborn`从长格式数据中制作可视化，并如何定制我们的图表以提高它们的可解释性。请记住，人类大脑擅长在视觉表示中发现模式；通过制作清晰且有意义的数据可视化，我们可以帮助他人（更不用说我们自己）理解数据所传达的信息。
- en: Seaborn is capable of making many of the same plots we created in the previous
    chapter; however, it also makes quick work of long-format data, allowing us to
    use subsets of our data to encode additional information into our visualizations,
    such as facets and/or colors for different categories. We will walk through some
    implementations of what we did in the previous chapter that are easier (or just
    more aesthetically pleasing) using `seaborn`, such as heatmaps and pair plots
    (the `seaborn` equivalent of the scatter plot matrix). In addition, we will explore
    some new plot types that `seaborn` provides to address issues that other plot
    types may be susceptible to.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Seaborn能够绘制我们在上一章中创建的许多相同类型的图表；然而，它也可以快速处理长格式数据，使我们能够使用数据的子集将额外的信息编码到可视化中，如不同类别的面板和/或颜色。我们将回顾上一章中的一些实现，展示如何使用`seaborn`使其变得更加简便（或更加美观），例如热图和配对图（`seaborn`的散点矩阵图等价物）。此外，我们将探索`seaborn`提供的一些新图表类型，以解决其他图表类型可能面临的问题。
- en: Afterward, we will change gears and begin our discussion on customizing the
    appearance of our data visualizations. We will walk through the process of creating
    annotations, adding reference lines, properly labeling our plots, controlling
    the color palette used, and tailoring the axes to meet our needs. This is the
    final piece we need to make our visualizations ready to present to others.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将转换思路，开始讨论如何定制我们数据可视化的外观。我们将逐步讲解如何创建注释、添加参考线、正确标注图表、控制使用的调色板，并根据需求调整坐标轴。这是我们使可视化准备好呈现给他人的最后一步。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Utilizing seaborn for more advanced plot types
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用seaborn进行更高级的绘图类型
- en: Formatting plots with matplotlib
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用matplotlib格式化图表
- en: Customizing visualizations
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定制可视化
- en: Chapter materials
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本章材料
- en: The materials for this chapter can be found on GitHub at [https://github.com/stefmolin/Hands-On-Data-Analysis-with-Pandas-2nd-edition/tree/master/ch_06](https://github.com/stefmolin/Hands-On-Data-Analysis-with-Pandas-2nd-edition/tree/master/ch_06).
    We will be working with three datasets once again, all of which can be found in
    the `data/` directory. In the `fb_stock_prices_2018.csv` file, we have Facebook's
    stock price for all trading days in 2018\. This data is the OHLC data (opening,
    high, low, and closing price), along with the volume traded. It was gathered using
    the `stock_analysis` package, which we will build in [*Chapter 7*](B16834_07_Final_SK_ePub.xhtml#_idTextAnchor146),
    *Financial Analysis – Bitcoin and the Stock Market*. The stock market is closed
    on the weekends, so we only have data for the trading days.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的资料可以在GitHub上找到，网址是[https://github.com/stefmolin/Hands-On-Data-Analysis-with-Pandas-2nd-edition/tree/master/ch_06](https://github.com/stefmolin/Hands-On-Data-Analysis-with-Pandas-2nd-edition/tree/master/ch_06)。我们将再次使用三个数据集，所有数据集都可以在`data/`目录中找到。在`fb_stock_prices_2018.csv`文件中，我们有Facebook在2018年所有交易日的股价数据。这些数据包括OHLC数据（开盘价、最高价、最低价和收盘价），以及成交量。这些数据是通过`stock_analysis`包收集的，我们将在[*第7章*](B16834_07_Final_SK_ePub.xhtml#_idTextAnchor146)中构建该包，*金融分析
    - 比特币与股市*。股市在周末休市，因此我们只有交易日的数据。
- en: The `earthquakes.csv` file contains earthquake data pulled from the `mag` column),
    the scale it was measured on (the `magType` column), when (the `time` column),
    and where (the `place` column) it occurred; we also have the `parsed_place` column,
    which indicates the state or country in which the earthquake occurred (we added
    this column back in [*Chapter 2*](B16834_02_Final_SK_ePub.xhtml#_idTextAnchor035),
    *Working with Pandas DataFrames*). Other unnecessary columns have been removed.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '`earthquakes.csv` 文件包含从 `mag` 列提取的地震数据，包括它的震级（`magType` 列）、发生时间（`time` 列）和地点（`place`
    列）；我们还包含了 `parsed_place` 列，表示地震发生的州或国家（我们在 [*第2章*](B16834_02_Final_SK_ePub.xhtml#_idTextAnchor035)《使用
    Pandas 数据框架》时添加了这个列）。其他不必要的列已被删除。'
- en: 'In the `covid19_cases.csv` file, we have an export from the *daily number of
    new reported cases of COVID-19 by country worldwide* dataset provided by the **European
    Centre for Disease Prevention and Control** (**ECDC**), which can be found at
    [https://www.ecdc.europa.eu/en/publications-data/download-todays-data-geographic-distribution-covid-19-cases-worldwide](https://www.ecdc.europa.eu/en/publications-data/download-todays-data-geographic-distribution-covid-19-cases-worldwide).
    For scripted or automated collection of this data, the ECDC makes the current
    day''s CSV file available via this link: [https://opendata.ecdc.europa.eu/covid19/casedistribution/csv](https://opendata.ecdc.europa.eu/covid19/casedistribution/csv).
    The snapshot we will be using was collected on September 19, 2020 and contains
    the number of new COVID-19 cases per country from December 31, 2019 through September
    18, 2020 with partial data for September 19, 2020\. For this chapter, we will
    look at the 8-month span from January 18, 2020 through September 18, 2020.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `covid19_cases.csv` 文件中，我们有一个来自**欧洲疾病预防控制中心**（**ECDC**）提供的 *全球各国每日新增 COVID-19
    报告病例数* 数据集的导出，数据集可以在 [https://www.ecdc.europa.eu/en/publications-data/download-todays-data-geographic-distribution-covid-19-cases-worldwide](https://www.ecdc.europa.eu/en/publications-data/download-todays-data-geographic-distribution-covid-19-cases-worldwide)
    找到。为了实现此数据的脚本化或自动化收集，ECDC 提供了当天的 CSV 文件下载链接：[https://opendata.ecdc.europa.eu/covid19/casedistribution/csv](https://opendata.ecdc.europa.eu/covid19/casedistribution/csv)。我们将使用的快照是2020年9月19日收集的，包含了2019年12月31日至2020年9月18日的每个国家新增
    COVID-19 病例数，并包含部分2020年9月19日的数据。在本章中，我们将查看2020年1月18日至2020年9月18日这8个月的数据。
- en: Throughout this chapter, we will be working through three Jupyter Notebooks.
    These are all numbered according to their order of use. We will begin exploring
    the capabilities of `seaborn` in the `1-introduction_to_seaborn.ipynb` notebook.
    Next, we will move on to the `2-formatting_plots.ipynb` notebook as we discuss
    formatting and labeling our plots. Finally, in the `3-customizing_visualizations.ipynb`
    notebook, we will learn how to add reference lines, shade regions, include annotations,
    and customize our visualizations. The text will prompt us when to switch notebooks.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用三个 Jupyter 笔记本。它们按使用顺序进行编号。我们将首先在 `1-introduction_to_seaborn.ipynb`
    笔记本中探索 `seaborn` 的功能。接下来，我们将在 `2-formatting_plots.ipynb` 笔记本中讨论如何格式化和标记我们的图表。最后，在
    `3-customizing_visualizations.ipynb` 笔记本中，我们将学习如何添加参考线、阴影区域、包括注释，并自定义我们的可视化效果。文本会提示我们何时切换笔记本。
- en: Tip
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: The supplementary `covid19_cases_map.ipynb` notebook walks through an example
    of plotting data on a map using COVID-19 cases worldwide. It can be used to get
    started with maps in Python and also builds upon some of the formatting we will
    discuss in this chapter.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 附加的 `covid19_cases_map.ipynb` 笔记本通过一个示例演示了如何使用全球 COVID-19 病例数据在地图上绘制数据。它可以帮助你入门
    Python 中的地图绘制，并在一定程度上构建了我们将在本章讨论的格式化内容。
- en: 'In addition, we have two Python (`.py`) files that contain functions we will
    use throughout the chapter: `viz``.py` and `color_utils.py`. Let''s get started
    by exploring `seaborn`.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们有两个 Python（`.py`）文件，包含我们将在本章中使用的函数：`viz.py` 和 `color_utils.py`。让我们首先通过探索
    `seaborn` 开始。
- en: Utilizing seaborn for advanced plotting
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 seaborn 进行高级绘图
- en: As we saw in the previous chapter, `pandas` provides implementations for most
    visualizations we would want to create; however, there is another library, `seaborn`,
    that provides additional functionality for more involved visualizations and makes
    creating visualizations with long-format data much easier than `pandas`. These
    also tend to look much nicer than standard visualizations generated by `matplotlib`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在上一章中看到的，`pandas` 提供了大多数我们想要创建的可视化实现；然而，还有一个库 `seaborn`，它提供了更多的功能，可以创建更复杂的可视化，并且比
    `pandas` 更容易处理长格式数据的可视化。这些可视化通常比 `matplotlib` 生成的标准可视化效果要好看得多。
- en: 'For this section, we will be working with the `1-introduction_to_seaborn.ipynb`
    notebook. First, we must import `seaborn`, which is traditionally aliased as `sns`:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本节内容我们将使用 `1-introduction_to_seaborn.ipynb` notebook。首先，我们需要导入 `seaborn`，通常将其别名为
    `sns`：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let''s also import `numpy`, `matplotlib.pyplot`, and `pandas`, and then read
    in the CSV files for the Facebook stock prices and earthquake data:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要导入 `numpy`、`matplotlib.pyplot` 和 `pandas`，然后读取 Facebook 股票价格和地震数据的 CSV
    文件：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: While `seaborn` offers alternatives to many of the plot types we covered in
    the previous chapter, for the most part, we will only cover new types that `seaborn`
    makes possible and leave learning about the rest as an exercise. Additional available
    functions using the `seaborn` API can be found at [https://seaborn.pydata.org/api.html](https://seaborn.pydata.org/api.html).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `seaborn` 提供了许多我们在上一章中讨论的图表类型的替代方案，但大多数情况下，我们将仅介绍 `seaborn` 使得可能的新的图表类型，其余的学习可以作为练习。更多使用
    `seaborn` API 的可用函数可以参考 [https://seaborn.pydata.org/api.html](https://seaborn.pydata.org/api.html)。
- en: Categorical data
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类别数据
- en: There was a devastating tsunami in Indonesia on September 28, 2018; it came
    after a 7.5 magnitude earthquake occurred near Palu, Indonesia ([https://www.livescience.com/63721-tsunami-earthquake-indonesia.html](https://www.livescience.com/63721-tsunami-earthquake-indonesia.html)).
    Let's create a visualization to understand which magnitude types are used in Indonesia,
    the range of magnitudes recorded, and how many of the earthquakes were accompanied
    by a tsunami. To do this, we need a way to plot relationships in which one of
    the variables is categorical (`magType`) and the other is numeric (`mag`).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 2018年9月28日，印尼发生了一次毁灭性的海啸；它是在印尼帕卢附近发生了7.5级地震后发生的 ([https://www.livescience.com/63721-tsunami-earthquake-indonesia.html](https://www.livescience.com/63721-tsunami-earthquake-indonesia.html))。让我们创建一个可视化图表，了解印尼使用了哪些震级类型，记录的震级范围，以及有多少地震伴随了海啸。为此，我们需要一种方法来绘制一个变量是类别型（`magType`），另一个是数值型（`mag`）的关系图。
- en: Important note
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Information on the different magnitude types can be found at [https://www.usgs.gov/natural-hazards/earthquake-hazards/science/magnitude-types](https://www.usgs.gov/natural-hazards/earthquake-hazards/science/magnitude-types).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 有关不同震级类型的信息，请访问 [https://www.usgs.gov/natural-hazards/earthquake-hazards/science/magnitude-types](https://www.usgs.gov/natural-hazards/earthquake-hazards/science/magnitude-types)。
- en: When we discussed scatter plots in [*Chapter 5*](B16834_05_Final_SK_ePub.xhtml#_idTextAnchor106),
    *Visualizing Data with Pandas and Matplotlib*, we were limited to both variables
    being numeric; however, with `seaborn`, we have two additional plot types at our
    disposal that allow us to have one categorical and one numeric variable. The first
    is the `stripplot()` function, which plots the points in strips that denote each
    category. The second is the `swarmplot()` function, which we will see later.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在[*第五章*](B16834_05_Final_SK_ePub.xhtml#_idTextAnchor106)“使用 Pandas 和 Matplotlib
    可视化数据”中讨论散点图时，我们限制了两个变量都必须是数值型；然而，使用 `seaborn`，我们可以使用另外两种图表类型，使得一个变量是类别型，另一个是数值型。第一个是
    `stripplot()` 函数，它将数据点绘制成代表各类别的条带。第二个是 `swarmplot()` 函数，我们稍后会看到。
- en: 'Let''s create this visualization with `stripplot()`. We pass the subset of
    earthquakes occurring in Indonesia to the `data` parameter, and specify that we
    want to put `magType` on the *x*-axis (`x`), magnitudes on the *y*-axis (`y`),
    and color the points by whether the earthquake was accompanied by a tsunami (`hue`):'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 `stripplot()` 创建这个可视化。我们将发生在印尼的地震子集传递给 `data` 参数，并指定将 `magType` 放置在 *x*
    轴（`x`），将震级放置在 *y* 轴（`y`），并根据地震是否伴随海啸（`hue`）为数据点上色：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Using the resulting plot, we can see that the earthquake in question is the
    highest orange point in the `mww` column (don''t forget to call `plt.show()` if
    not using the Jupyter Notebook provided):'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看生成的图表，我们可以看到该地震是 `mww` 列中最高的橙色点（如果没有使用提供的 Jupyter Notebook，别忘了调用 `plt.show()`）：
- en: '![Figure 6.1 – Seaborn''s strip plot'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.1 – Seaborn 的条形图'
- en: '](img/fig_6.1.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/fig_6.1.jpg)'
- en: Figure 6.1 – Seaborn's strip plot
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1 – Seaborn 的条形图
- en: 'For the most part, the tsunamis occurred with higher magnitude earthquakes,
    as we would expect; however, due to the high concentration of points at lower
    magnitudes, we can''t really see all the points. We could try to adjust the `jitter`
    argument, which controls how much random noise to add to the point in an attempt
    to reduce overlaps, or the `alpha` argument for transparency, as we did in the
    previous chapter; fortunately, there is another function, `swarmplot()`, that
    will reduce the overlap as much as possible, so we will use that instead:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分情况下，海啸发生在较高震级的地震中，正如我们所预期的那样；然而，由于在较低震级区域有大量点的集中，我们无法清晰地看到所有的点。我们可以尝试调整 `jitter`
    参数，它控制要添加多少随机噪声来减少重叠，或者调整 `alpha` 参数以控制透明度，正如我们在上一章所做的那样；幸运的是，还有一个函数 `swarmplot()`，它会尽可能减少重叠，因此我们将使用这个函数：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `mb` column:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`mb` 列：'
- en: '![Figure 6.2 – Seaborn''s swarm plot'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.2 – Seaborn 的蜂群图'
- en: '](img/fig_6.2.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/fig_6.2.jpg)'
- en: Figure 6.2 – Seaborn's swarm plot
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.2 – Seaborn 的蜂群图
- en: 'In the *Plotting with pandas* section in the previous chapter, when we discussed
    how to visualize distributions, we discussed the box plot. Seaborn provides an
    enhanced box plot for large datasets, which shows additional quantiles for more
    information on the shape of the distribution, particularly in the tails. Let''s
    use the enhanced box plot to compare earthquake magnitudes across different magnitude
    types, as we did in [*Chapter 5*](B16834_05_Final_SK_ePub.xhtml#_idTextAnchor106),
    *Visualizing Data with Pandas and Matplotlib*:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章的 *使用 pandas 绘图* 部分中，我们讨论了如何可视化分布，并介绍了箱形图。Seaborn 为大数据集提供了增强型箱形图，它展示了更多的分位数，以便提供关于分布形状的更多信息，特别是尾部部分。让我们使用增强型箱形图来比较不同震级类型的地震震中，就像我们在
    [*第 5 章*](B16834_05_Final_SK_ePub.xhtml#_idTextAnchor106) 中所做的那样，*使用 Pandas 和
    Matplotlib 可视化数据*：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This results in the following plot:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下图表：
- en: '![Figure 6.3 – Seaborn''s enhanced box plot'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.3 – Seaborn 的增强型箱形图'
- en: '](img/fig_6.3.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/fig_6.3.jpg)'
- en: Figure 6.3 – Seaborn's enhanced box plot
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.3 – Seaborn 的增强型箱形图
- en: Tip
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'The enhanced box plot was introduced in the paper *Letter-value plots: Boxplots
    for large data,* by Heike Hofmann, Karen Kafadar, and Hadley Wickham, which can
    be found at [https://vita.had.co.nz/papers/letter-value-plot.html](https://vita.had.co.nz/papers/letter-value-plot.html).'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '增强型箱形图首次出现在 Heike Hofmann、Karen Kafadar 和 Hadley Wickham 合著的论文 *Letter-value
    plots: Boxplots for large data* 中，您可以在 [https://vita.had.co.nz/papers/letter-value-plot.html](https://vita.had.co.nz/papers/letter-value-plot.html)
    找到该文。'
- en: 'Box plots are great for visualizing the quantiles of our data, but we lose
    information about the distribution. As we saw, an enhanced box plot is one way
    to address this—another strategy is to use a violin plot, which combines a kernel
    density estimate (estimation of the underlying distribution) and a box plot:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 箱形图非常适合可视化数据的分位数，但我们失去了关于分布的信息。正如我们所见，增强型箱形图是解决这个问题的一种方法——另一种策略是使用小提琴图，它结合了核密度估计（即基础分布的估计）和箱形图：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The box plot portion runs through the center of each violin plot; the **kernel
    density estimate** (**KDE**) is then drawn on both sides using the box plot as
    its *x*-axis. We can read the KDE from either side of the box plot since it is
    symmetrical:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 箱形图部分穿过每个小提琴图的中心；然后，在以箱形图作为 *x* 轴的基础上，分别在两侧绘制 **核密度估计**（**KDE**）。由于它是对称的，我们可以从箱形图的任一侧读取
    KDE：
- en: '![Figure 6.4 – Seaborn''s violin plot'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.4 – Seaborn 的小提琴图'
- en: '](img/fig_6.4.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/fig_6.4.jpg)'
- en: Figure 6.4 – Seaborn's violin plot
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.4 – Seaborn 的小提琴图
- en: The `seaborn` documentation also lists out the plotting functions by the type
    of data being plotted; the full offering of categorical plots is available at
    [https://seaborn.pydata.org/api.html#categorical-plots](https://seaborn.pydata.org/api.html#categorical-plots).
    Be sure to check out the `countplot()` and `barplot()` functions for variations
    on the bar plots we created with `pandas` in the previous chapter.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`seaborn` 文档还根据绘图数据类型列出了不同的绘图函数；完整的分类图表列表可以在[https://seaborn.pydata.org/api.html#categorical-plots](https://seaborn.pydata.org/api.html#categorical-plots)找到。一定要查看
    `countplot()` 和 `barplot()` 函数，它们是我们在上一章使用 `pandas` 创建条形图的变体。'
- en: Correlations and heatmaps
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关性和热图
- en: 'As promised, let''s learn an easier way to generate heatmaps compared to what
    we had to do in [*Chapter 5*](B16834_05_Final_SK_ePub.xhtml#_idTextAnchor106),
    *Visualizing Data with Pandas and Matplotlib*. Once again, we will make a heatmap
    of the correlations between the OHLC stock prices, the log of volume traded, and
    the daily difference between the highest and lowest prices (`max_abs_change`);
    however, this time, we will use `seaborn`, which gives us the `heatmap()` function
    for an easier way to produce this visualization:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如约定的那样，今天我们将学习一个比在 [*第五章*](B16834_05_Final_SK_ePub.xhtml#_idTextAnchor106) 中使用
    Pandas 和 Matplotlib 可视化数据时更简单的热图生成方法。这一次，我们将使用 `seaborn`，它提供了 `heatmap()` 函数，帮助我们更轻松地生成这种可视化图表：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Tip
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: When using `seaborn`, we can still use functions from `matplotlib`, such as
    `plt.savefig()` and `plt.tight_layout()`. Note that if there are issues with `plt.tight_layout()`,
    pass `bbox_inches='tight'` to `plt.savefig()` instead.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `seaborn` 时，我们仍然可以使用 `matplotlib` 中的函数，如 `plt.savefig()` 和 `plt.tight_layout()`。请注意，如果
    `plt.tight_layout()` 存在问题，可以改为将 `bbox_inches='tight'` 传递给 `plt.savefig()`。
- en: 'We pass in `center=0` so that `seaborn` puts values of `0` (no correlation)
    at the center of the colormap it uses. In order to set the bounds of the color
    scale to that of the correlation coefficient, we need to provide `vmin=-1` and
    `vmax=1` as well. Notice that we also passed in `annot=True` to write the correlation
    coefficients in each box—we get the benefit of the numerical data and the visual
    data all in one plot with a single function call:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传入 `center=0`，这样 `seaborn` 会将 `0`（无相关性）放置在它使用的色图的中心。为了将色标的范围设置为相关系数的范围，我们还需要提供
    `vmin=-1` 和 `vmax=1`。注意，我们还传入了 `annot=True`，这样每个框内会显示相关系数——我们可以通过一次函数调用，既获得数值数据又获得可视化数据：
- en: '![Figure 6.5 – Seaborn''s heatmap'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.5 – Seaborn 的热图'
- en: '](img/fig_6.5.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/fig_6.5.jpg)'
- en: Figure 6.5 – Seaborn's heatmap
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.5 – Seaborn 的热图
- en: 'Seaborn also provides us with an alternative to the `scatter_matrix()` function
    provided in the `pandas.plotting` module, called `pairplot()`. We can use this
    to see the correlations between the columns in the Facebook data as scatter plots
    instead of the heatmap:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Seaborn 还为我们提供了 `pandas.plotting` 模块中提供的 `scatter_matrix()` 函数的替代方案，叫做 `pairplot()`。我们可以使用这个函数将
    Facebook 数据中各列之间的相关性以散点图的形式展示，而不是热图：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This result makes it easy to understand the near-perfect positive correlation
    between the OHLC columns shown in the heatmap, while also showing us histograms
    for each column along the diagonal:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结果使我们能够轻松理解 OHLC 各列之间在热图中几乎完美的正相关关系，同时还展示了沿对角线的每一列的直方图：
- en: '![Figure 6.6 – Seaborn''s pair plot'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.6 – Seaborn 的配对图'
- en: '](img/fig_6.6.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/fig_6.6.jpg)'
- en: Figure 6.6 – Seaborn's pair plot
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.6 – Seaborn 的配对图
- en: 'Facebook''s performance in the latter half of 2018 was markedly worse than
    in the first half, so we may be interested to see how the distribution of the
    data changed each quarter of the year. As with the `pandas.plotting.scatter_matrix()`
    function, we can specify what to do along the diagonal with the `diag_kind` argument;
    however, unlike `pandas`, we can easily color everything based on other data with
    the `hue` argument. To do so, we just add the `quarter` column and then provide
    it to the `hue` argument:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Facebook 在 2018 年下半年表现显著不如上半年，因此我们可能想了解数据在每个季度的分布变化情况。与 `pandas.plotting.scatter_matrix()`
    函数类似，我们可以使用 `diag_kind` 参数来指定对角线的处理方式；然而，与 `pandas` 不同的是，我们可以轻松地通过 `hue` 参数基于其他数据为图形着色。为此，我们只需要添加
    `quarter` 列，并将其提供给 `hue` 参数：
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We can now see how the distributions of the OHLC columns had lower standard
    deviations (and, subsequently, lower variances) in the first quarter and how the
    stock price lost a lot of ground in the fourth quarter (the distribution shifts
    to the left):'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以看到，OHLC 各列的分布在第一季度的标准差较小（因此方差也较小），而股价在第四季度大幅下跌（分布向左偏移）：
- en: '![Figure 6.7 – Utilizing the data to determine plot colors'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.7 – 利用数据来确定绘图颜色'
- en: '](img/fig_6.7.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/fig_6.7.jpg)'
- en: Figure 6.7 – Utilizing the data to determine plot colors
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.7 – 利用数据来确定绘图颜色
- en: Tip
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: We can also pass `kind='reg'` to `pairplot()` to show regression lines.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将 `kind='reg'` 传递给 `pairplot()` 来显示回归线。
- en: 'If we only want to compare two variables, we can use `jointplot()`, which will
    give us a scatter plot along with the distribution of each variable along the
    side. Let''s look once again at how the log of volume traded correlates with the
    difference between the daily high and low prices in Facebook stock, as we did
    in [*Chapter 5*](B16834_05_Final_SK_ePub.xhtml#_idTextAnchor106), *Visualizing
    Data with Pandas and Matplotlib*:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只想比较两个变量，可以使用`jointplot()`，它会给我们一个散点图，并在两侧展示每个变量的分布。让我们再次查看交易量的对数与 Facebook
    股票的日内最高价和最低价差异之间的关联，就像我们在[*第 5 章*](B16834_05_Final_SK_ePub.xhtml#_idTextAnchor106)中所做的那样，*使用
    Pandas 和 Matplotlib 可视化数据*：
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Using the default value for the `kind` argument, we get histograms for the
    distributions and a plain scatter plot in the center:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`kind`参数的默认值，我们会得到分布的直方图，并在中心显示一个普通的散点图：
- en: '![Figure 6.8 – Seaborn''s joint plot'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.8 – Seaborn 的联合图'
- en: '](img/fig_6.8.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/fig_6.8.jpg)'
- en: Figure 6.8 – Seaborn's joint plot
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.8 – Seaborn 的联合图
- en: 'Seaborn gives us plenty of alternatives for the `kind` argument. For example,
    we can use hexbins because there is a significant overlap when we use the scatter
    plot:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Seaborn 为`kind`参数提供了许多替代选项。例如，我们可以使用 hexbins，因为当我们使用散点图时，会有显著的重叠：
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can now see the large concentration of points in the lower-left corner:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以看到左下角有大量的点集中：
- en: '![Figure 6.9 – Joint plot using hexbins'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.9 – 使用 hexbins 的联合图'
- en: '](img/fig_6.9.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/fig_6.9.jpg)'
- en: Figure 6.9 – Joint plot using hexbins
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.9 – 使用 hexbins 的联合图
- en: 'Another way of viewing the concentration of values is to use `kind=''kde''`,
    which gives us a **contour plot** to represent the joint density estimate along
    with KDEs for each of the variables:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种查看值集中度的方法是使用`kind='kde'`，这会给我们一个**等高线图**，以表示联合密度估计，并同时展示每个变量的 KDEs：
- en: '[PRE11]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Each curve in the contour plot contains points of a given density:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 等高线图中的每条曲线包含给定密度的点：
- en: '![Figure 6.10 – Joint distribution plot'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.10 – 联合分布图'
- en: '](img/fig_6.10.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/fig_6.10.jpg)'
- en: Figure 6.10 – Joint distribution plot
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.10 – 联合分布图
- en: 'Furthermore, we can plot a regression in the center and get KDEs in addition
    to histograms along the sides:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还可以在中心绘制回归图，并在两侧获得 KDEs 和直方图：
- en: '[PRE12]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This results in a linear regression line being drawn through the scatter plot,
    along with a confidence band surrounding the line in a lighter color:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致回归线通过散点图绘制，并且在回归线周围绘制了一个较浅颜色的置信带：
- en: '![Figure 6.11 – Joint plot with linear regression and KDEs'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.11 – 带有线性回归和 KDEs 的联合图'
- en: '](img/fig_6.11.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/fig_6.11.jpg)'
- en: Figure 6.11 – Joint plot with linear regression and KDEs
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.11 – 带有线性回归和 KDEs 的联合图
- en: 'The relationship appears to be linear, but we should look at the `kind=''resid''`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 关系看起来是线性的，但我们应该查看`kind='resid'`：
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Notice that the residuals appear to be getting further away from zero at higher
    quantities of volume traded, which could mean this isn''t the right way to model
    this relationship:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，随着交易量的增加，残差似乎越来越远离零，这可能意味着这不是建模这种关系的正确方式：
- en: '![Figure 6.12 – Joint plot showing linear regression residuals'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.12 – 显示线性回归残差的联合图'
- en: '](img/fig_6.12.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/fig_6.12.jpg)'
- en: Figure 6.12 – Joint plot showing linear regression residuals
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.12 – 显示线性回归残差的联合图
- en: We just saw that we can use `jointplot()` to get a regression plot or a residuals
    plot; naturally, `seaborn` exposes functions to make these directly without the
    overhead of creating the entire joint plot. Let's discuss those next.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚看到，我们可以使用`jointplot()`来生成回归图或残差图；自然，`seaborn`提供了直接生成这些图形的函数，无需创建整个联合图。接下来我们来讨论这些。
- en: Regression plots
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回归图
- en: The `regplot()` function will calculate a regression line and plot it, while
    the `residplot()` function will calculate the regression and plot only the residuals.
    We can write a function to combine these for us, but first, some setup.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`regplot()`函数会计算回归线并绘制它，而`residplot()`函数会计算回归并仅绘制残差。我们可以编写一个函数将这两者结合起来，但首先需要一些准备工作。'
- en: Our function will plot all permutations of any two columns (as opposed to combinations;
    order matters with permutations, for example, `(open, close)` is not equivalent
    to `(close, open)`). This allows us to see each column as the regressor and as
    the dependent variable; since we don't know the direction of the relationship,
    we let the viewer decide after calling the function. This generates many subplots,
    so we will create a new dataframe with just a few columns from our Facebook data.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的函数将绘制任意两列的所有排列（与组合不同，排列的顺序很重要，例如，`(open, close)`不等同于`(close, open)`）。这使我们能够将每一列作为回归变量和因变量来看待；由于我们不知道关系的方向，因此在调用函数后让查看者自行决定。这会生成许多子图，因此我们将创建一个只包含来自Facebook数据的少数几列的新数据框。
- en: 'We''ll be looking at the logarithm of the volume traded (`log_volume`) and
    the daily difference between the highest and lowest price of Facebook stock (`max_abs_change`).
    Let''s use `assign()` to create these new columns and save them in a new dataframe
    called `fb_reg_data`:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将查看交易量的对数（`log_volume`）和Facebook股票的日最高价与最低价之间的差异（`max_abs_change`）。我们使用`assign()`来创建这些新列，并将它们保存在一个名为`fb_reg_data`的新数据框中：
- en: '[PRE14]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next, we need to import `itertools`, which is part of the Python standard library
    ([https://docs.python.org/3/library/itertools.html](https://docs.python.org/3/library/itertools.html)).
    When writing plotting functions, `itertools` can be extremely helpful; it makes
    it very easy to create efficient iterators for things such as permutations, combinations,
    and infinite cycles or repeats:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要导入`itertools`，它是Python标准库的一部分（[https://docs.python.org/3/library/itertools.html](https://docs.python.org/3/library/itertools.html)）。在编写绘图函数时，`itertools`非常有用；它可以非常轻松地创建高效的迭代器，用于排列、组合和无限循环或重复等操作：
- en: '[PRE15]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '**Iterables** are objects that can be iterated over. When we start a loop,
    an **iterator** is created from the iterable. At each iteration, the iterator
    provides its next value, until it is exhausted; this means that once we complete
    a single iteration through all its items, there is nothing left, and it can''t
    be reused. Iterators are iterables, but not all iterables are iterators. Iterables
    that aren''t iterators can be used repeatedly.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**可迭代对象**是可以被迭代的对象。当我们启动一个循环时，会从可迭代对象中创建一个**迭代器**。每次迭代时，迭代器提供它的下一个值，直到耗尽；这意味着，一旦我们完成了一次对所有项的迭代，就没有剩余的元素，它不能再次使用。迭代器是可迭代对象，但并非所有可迭代对象都是迭代器。不是迭代器的可迭代对象可以被重复使用。'
- en: 'The iterators we get back when using `itertools` can only be used once through:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`itertools`时返回的迭代器只能使用一次：
- en: '[PRE16]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'A list, on the other hand, is an iterable; we can write something that loops
    over all the elements in the list, and we will still have a list for later reuse:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，列表是一个可迭代对象；我们可以编写一个循环遍历列表中的所有元素，之后仍然可以得到一个列表用于后续使用：
- en: '[PRE17]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now that we have some background on `itertools` and iterators, let''s write
    the function for our regression and residuals permutation plots:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对`itertools`和迭代器有了一些了解，接下来我们来编写回归和残差排列图的函数：
- en: '[PRE18]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In this function, we can see that all the material covered so far in this chapter
    and from the previous chapter is coming together; we calculate how many subplots
    we need, and since we will have two plots for each permutation, we just need the
    number of permutations to determine the row count. We take advantage of the `zip()`
    function, which gives us values from multiple iterables at once in tuples, and
    tuple unpacking to easily iterate over the permutation tuples and the 2D NumPy
    array of `Axes` objects. Take some time to make sure you understand what is going
    on here; there are also resources on `zip()` and tuple unpacking in the *Further
    reading* section at the end of this chapter.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们可以看到到目前为止本章以及上一章中涉及的所有内容都已融合在一起；我们计算需要多少个子图，并且由于每种排列会有两个图表，我们只需要排列的数量来确定行数。我们利用了`zip()`函数，它可以一次性从多个可迭代对象中获取值并以元组形式返回，再通过元组解包轻松地遍历排列元组和二维的`Axes`对象数组。花些时间确保你理解这里发生了什么；本章末尾的*进一步阅读*部分也有关于`zip()`和元组解包的资源。
- en: Important note
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: If we provide different length iterables to `zip()`, we will only get a number
    of tuples equal to the shortest length. For this reason, we can use infinite iterators,
    such as those we get when using `itertools.repeat()`, which repeats the same value
    infinitely (when we don't specify the number of times to repeat the value), and
    `itertools.cycle()`, which cycles between all the values provided infinitely.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们提供不同长度的可迭代对象给`zip()`，我们将只得到与最短长度相等数量的元组。因此，我们可以使用无限迭代器，如使用`itertools.repeat()`时获得的，它会无限次重复相同的值（当我们没有指定重复次数时），以及`itertools.cycle()`，它会在所有提供的值之间无限循环。
- en: 'Calling our function is effortless, with only a single parameter:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 调用我们的函数非常简单，只需要一个参数：
- en: '[PRE19]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The first row of subsets is what we saw earlier with the joint plots, and the
    second row is the regression when flipping the `x` and `y` variables:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行的子集是我们之前在联合图中看到的，而第二行则是翻转`x`和`y`变量时的回归：
- en: '![Figure 6.13 – Seaborn linear regression and residual plots'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.13 – Seaborn 线性回归和残差图'
- en: '](img/fig_6.13.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/fig_6.13.jpg)'
- en: Figure 6.13 – Seaborn linear regression and residual plots
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.13 – Seaborn 线性回归和残差图
- en: Tip
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: The `regplot()` function supports polynomial and logistic regression through
    the `order` and `logistic` parameters, respectively.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`regplot()`函数通过`order`和`logistic`参数分别支持多项式回归和逻辑回归。'
- en: Seaborn also makes it easy to plot regressions across different subsets of our
    data with `lmplot()`. We can split our regression plots with `hue`, `col`, and
    `row`, which will color by values in a given column, make a new column for each
    value, and make a new row for each value, respectively.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Seaborn还使得在数据的不同子集上绘制回归变得简单，我们可以使用`lmplot()`来分割回归图。我们可以使用`hue`、`col`和`row`来分割回归图，分别通过给定列的值进行着色、为每个值创建一个新列以及为每个值创建一个新行。
- en: 'We saw that Facebook''s performance was different across each quarter of the
    year, so let''s calculate a regression per quarter with the Facebook stock data,
    using the volume traded and the daily difference between the highest and lowest
    price, to see whether this relationship also changes:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到Facebook的表现因每个季度而异，因此让我们使用Facebook股票数据计算每个季度的回归，使用交易量和每日最高与最低价格之间的差异，看看这种关系是否也发生变化：
- en: '[PRE20]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Notice that the regression line in the fourth quarter has a much steeper slope
    than previous quarters:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，第四季度的回归线比前几个季度的斜率要陡得多：
- en: '![Figure 6.14 – Seaborn linear regression plots with subsets'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.14 – Seaborn 带有子集的线性回归图'
- en: '](img/fig_6.14.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/fig_6.14.jpg)'
- en: Figure 6.14 – Seaborn linear regression plots with subsets
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.14 – Seaborn 带有子集的线性回归图
- en: Note that the result of running `lmplot()` is a `FacetGrid` object, which is
    a powerful feature of `seaborn`. Let's now discuss how we can make these directly
    with any plot inside.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，运行`lmplot()`的结果是一个`FacetGrid`对象，这是`seaborn`的一个强大功能。接下来，我们将讨论如何在其中直接使用任何图形进行绘制。
- en: Faceting
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分面
- en: Faceting allows us to plot subsets (facets) of our data across subplots. We
    already saw a few as a result of some `seaborn` functions; however, we can easily
    make them for ourselves for use with any plotting function. Let's create a visualization
    that will allow us to compare the distributions of earthquake magnitudes in Indonesia
    and Papua New Guinea depending on whether there was a tsunami.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 分面允许我们在子图上绘制数据的子集（分面）。我们已经通过一些`seaborn`函数看到了一些分面；然而，我们也可以轻松地为自己制作分面，以便与任何绘图函数一起使用。让我们创建一个可视化，比较印尼和巴布亚新几内亚的地震震级分布，看看是否发生了海啸。
- en: 'First, we create a `FacetGrid` object with the data we will be using and define
    how it will be subset with the `row` and `col` arguments:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用将要使用的数据创建一个`FacetGrid`对象，并通过`row`和`col`参数定义如何对子集进行划分：
- en: '[PRE21]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Then, we use the `FacetGrid.map()` method to run a plotting function on each
    of the subsets, passing along any necessary arguments. We will make histograms
    with KDEs for the location and tsunami data subsets using the `sns.histplot()`
    function:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`FacetGrid.map()`方法对每个子集运行绘图函数，并传递必要的参数。我们将使用`sns.histplot()`函数为位置和海啸数据子集制作带有KDE的直方图：
- en: '[PRE22]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'For both locations, we can see that tsunamis occurred when the earthquake magnitude
    was 5.0 or greater:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这两个位置，我们可以看到，当地震震级达到5.0或更大时，发生了海啸：
- en: '![Figure 6.15 – Plotting with facet grids'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.15 – 使用分面网格绘图'
- en: '](img/fig_6.15.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/fig_6.15.jpg)'
- en: Figure 6.15 – Plotting with facet grids
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.15 – 使用分面网格绘图
- en: This concludes our discussion of the plotting capabilities of `seaborn`; however,
    I encourage you to check out the API ([https://seaborn.pydata.org/api.html](https://seaborn.pydata.org/api.html))
    to see additional functionality. Also, be sure to consult the *Choosing the appropriate
    visualization* section in the *Appendix* as a reference when looking to plot some
    data.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这结束了我们关于`seaborn`绘图功能的讨论；不过，我鼓励你查看API（[https://seaborn.pydata.org/api.html](https://seaborn.pydata.org/api.html)）以了解更多功能。此外，在绘制数据时，务必查阅*附录*中的*选择合适的可视化方式*部分作为参考。
- en: Formatting plots with matplotlib
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用matplotlib格式化图表
- en: A big part of making our visualizations presentable is choosing the right plot
    type and having them well labeled so they are easy to interpret. By carefully
    tuning the final appearance of our visualizations, we make them easier to read
    and understand.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 使我们的可视化图表具有表现力的一个重要部分是选择正确的图表类型，并且为其添加清晰的标签，以便易于解读。通过精心调整最终的可视化外观，我们使其更容易阅读和理解。
- en: 'Let''s now move to the `2-formatting_plots.ipynb` notebook, run the setup code
    to import the packages we need, and read in the Facebook stock data and COVID-19
    daily new cases data:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们转到`2-formatting_plots.ipynb`笔记本，运行设置代码导入所需的包，并读取Facebook股票数据和COVID-19每日新增病例数据：
- en: '[PRE23]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the next few sections, we will discuss how to add titles, axis labels, and
    legends to our plots, as well as how to customize the axes. Note that everything
    in this section needs to be called before running `plt.show()` or within the same
    Jupyter Notebook cell if using the `%matplotlib inline` magic command.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几个章节中，我们将讨论如何为图表添加标题、坐标轴标签和图例，以及如何自定义坐标轴。请注意，本节中的所有内容需要在运行`plt.show()`之前调用，或者如果使用`%matplotlib
    inline`魔法命令，则需要在同一个Jupyter Notebook单元格中调用。
- en: Titles and labels
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标题和标签
- en: Some of the visualizations we have created thus far didn't have titles or axis
    labels. We know what is going on in the figure, but if we were to present them
    to others, there could be some confusion. It's good practice to be explicit with
    our labels and titles.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 迄今为止，我们创建的某些可视化图表没有标题或坐标轴标签。我们知道图中的内容，但如果我们要向他人展示这些图表，可能会引起一些混淆。为标签和标题提供明确的说明是一种良好的做法。
- en: 'We saw that, when plotting with `pandas`, we could add a title by passing the
    `title` argument to the `plot()` method, but we can also do this with `matplotlib`
    using `plt.title()`. Note that we can pass `x`/`y` values to `plt.title()` to
    control the placement of our text. We can also change the font and its size. Labeling
    our axes is just as easy; we can use `plt.xlabel()` and `plt.ylabel()`. Let''s
    plot the Facebook closing price and label everything using `matplotlib`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到，当使用`pandas`绘图时，可以通过将`title`参数传递给`plot()`方法来添加标题，但我们也可以通过`matplotlib`的`plt.title()`来实现这一点。请注意，我们可以将`x`/`y`值传递给`plt.title()`以控制文本的位置。我们还可以更改字体及其大小。为坐标轴添加标签也同样简单；我们可以使用`plt.xlabel()`和`plt.ylabel()`。让我们绘制Facebook的收盘价，并使用`matplotlib`添加标签：
- en: '[PRE24]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This results in the following plot:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致以下图表：
- en: '![Figure 6.16 – Labeling plots with matplotlib'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.16 – 使用matplotlib为图表添加标签'
- en: '](img/fig_6.16.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/fig_6.16.jpg)'
- en: Figure 6.16 – Labeling plots with matplotlib
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.16 – 使用matplotlib为图表添加标签
- en: 'When working with subplots, we have to take a different approach. To see this
    firsthand, let''s make subplots of Facebook stock''s OHLC data and use `plt.title()`
    to give the entire plot a title, along with `plt.ylabel()` to give each subplot''s
    *y*-axis a label:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理子图时，我们需要采取不同的方法。为了直观地了解这一点，让我们绘制Facebook股票的OHLC数据的子图，并使用`plt.title()`为整个图表添加标题，同时使用`plt.ylabel()`为每个子图的*y*-轴添加标签：
- en: '[PRE25]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Using `plt.title()` puts the title on the last subplot, instead of being the
    title for the plots as a whole, as we intended. The same thing happens to the
    *y*-axis label:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`plt.title()`将标题放置在最后一个子图上，而不是像我们预期的那样为整个图表添加标题。*y*-轴标签也会出现同样的问题：
- en: '![Figure 6.17 – Labeling subplots can be confusing'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.17 – 为子图添加标签可能会引起混淆'
- en: '](img/fig_6.17.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/fig_6.17.jpg)'
- en: Figure 6.17 – Labeling subplots can be confusing
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.17 – 为子图添加标签可能会引起混淆
- en: 'In the case of subplots, we want to give the entire figure a title; therefore,
    we use `plt.suptitle()` instead. Conversely, we want to give each subplot a *y*-axis
    label, so we use the `set_ylabel()` method on each of the `Axes` objects returned
    by the call to `plot()`. Note that the `Axes` objects are returned in a NumPy
    array of the same dimensions as the subplot layout, so for easier iteration, we
    call `flatten()`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在子图的情况下，我们希望给整个图表添加标题；因此，我们使用 `plt.suptitle()`。相反，我们希望给每个子图添加 *y*-轴标签，因此我们在
    `plot()` 返回的每个 `Axes` 对象上使用 `set_ylabel()` 方法。请注意，`Axes` 对象会以与子图布局相同维度的 NumPy
    数组返回，因此为了更方便地迭代，我们调用 `flatten()`：
- en: '[PRE26]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This results in a title for the plot as a whole and *y*-axis labels for each
    of the subplots:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这样会为整个图表添加一个标题，并为每个子图添加*y*-轴标签：
- en: '![Figure 6.18 – Labeling subplots'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.18 – 标注子图'
- en: '](img/fig_6.18.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/fig_6.18.jpg)'
- en: Figure 6.18 – Labeling subplots
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.18 – 标注子图
- en: Note that the `Figure` class also has a `suptitle()` method and that the `Axes`
    class's `set()` method lets us label the axes, title the plot, and much more in
    a single call, for example, `set(xlabel='…', ylabel='…', title='…', …)`. Depending
    on what we are trying to do, we may need to call methods on `Figure` or `Axes`
    objects directly, so it's important to be aware of them.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`Figure` 类也有一个 `suptitle()` 方法，而 `Axes` 类的 `set()` 方法允许我们标注坐标轴、设置图表标题等，所有这些都可以通过一次调用来完成，例如，`set(xlabel='…',
    ylabel='…', title='…', …)`。根据我们想做的事情，我们可能需要直接调用 `Figure` 或 `Axes` 对象的方法，因此了解这些方法很重要。
- en: Legends
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图例
- en: 'Matplotlib makes it possible to control many aspects of the legend through
    the `plt.legend()` function and the `Axes.legend()` method. For example, we can
    specify the legend''s location and format how the legend looks, including customizing
    the fonts, colors, and much more. Both the `plt.legend()` function and the `Axes.legend()`
    method can also be used to show a legend when the plot doesn''t have one initially.
    Here is a sampling of some commonly used parameters:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Matplotlib 使得可以通过 `plt.legend()` 函数和 `Axes.legend()` 方法控制图例的许多方面。例如，我们可以指定图例的位置，并格式化图例的外观，包括自定义字体、颜色等。`plt.legend()`
    函数和 `Axes.legend()` 方法也可以用于在图表最初没有图例的情况下显示图例。以下是一些常用参数的示例：
- en: '![Figure 6.19 – Helpful parameters for legend formatting'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.19 – 图例格式化的有用参数'
- en: '](img/fig_6.19.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/fig_6.19.jpg)'
- en: Figure 6.19 – Helpful parameters for legend formatting
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.19 – 图例格式化的有用参数
- en: 'The legend will use the label of each object that was plotted. If we don''t
    want something to show up, we can make its label an empty string. However, if
    we simply want to alter how something shows up, we can pass its display name through
    the `label` argument. Let''s plot Facebook stock''s closing price and the 20-day
    moving average, using the `label` argument to provide a descriptive name for the
    legend:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图例将使用每个绘制对象的标签。如果我们不希望某个对象显示图例，可以将它的标签设置为空字符串。但是，如果我们只是想修改某个对象的显示名称，可以通过 `label`
    参数传递它的显示名称。我们来绘制 Facebook 股票的收盘价和 20 天移动平均线，使用 `label` 参数为图例提供描述性名称：
- en: '[PRE27]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'By default, `matplotlib` tries to find the best location for the plot, but
    sometimes it covers up parts of the plot as in this case. Therefore, we chose
    to place the legend in the lower-left corner of the plot. Note that the text in
    the legend is what we provided in the `label` argument to `plot()`:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`matplotlib` 会尝试为图表找到最佳位置，但有时它会遮挡图表的部分内容，就像在这个例子中一样。因此，我们选择将图例放在图表的左下角。请注意，图例中的文本是我们在
    `plot()` 的 `label` 参数中提供的内容：
- en: '![Figure 6.20 – Moving the legend'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.20 – 移动图例'
- en: '](img/fig_6.20.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/fig_6.20.jpg)'
- en: Figure 6.20 – Moving the legend
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.20 – 移动图例
- en: 'Notice that we passed a string to the `loc` argument to specify the legend
    location; we also have the option of passing the code as an integer or a tuple
    for the `(x, y)` coordinates to draw the lower-left corner of the legend box.
    The following table contains the possible location strings:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们传递了一个字符串给 `loc` 参数来指定图例的位置；我们也可以传递代码作为整数或元组，表示图例框左下角的 `(x, y)` 坐标。下表包含了可能的位置信息字符串：
- en: '![Figure 6.21 – Common legend locations'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.21 – 常见图例位置'
- en: '](img/fig_6.21.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/fig_6.21.jpg)'
- en: Figure 6.21 – Common legend locations
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.21 – 常见图例位置
- en: 'Let''s now take a look at styling the legend with the `framealpha`, `ncol`,
    and `title` arguments. We will plot the percentage of the world''s daily new COVID-19
    cases that occurred in Brazil, China, Italy, Spain, and the USA over the 8-month
    period from January 18, 2020 through September 18, 2020\. In addition, we will
    remove the top and right spines of the plot to make it look cleaner:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看如何使用 `framealpha`、`ncol` 和 `title` 参数来设置图例的样式。我们将绘制2020年1月18日至2020年9月18日期间，巴西、中国、意大利、西班牙和美国的世界每日新增
    COVID-19 病例占比。此外，我们还会移除图表的顶部和右侧框线，使其看起来更简洁：
- en: '[PRE28]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Our legend is neatly arranged in two columns and contains a title. We also
    increased the transparency of the legend''s border:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的图例已整齐地排列为两列，并且包含了一个标题。我们还增加了图例边框的透明度：
- en: '![Figure 6.22 – Formatting the legend'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.22 – 格式化图例'
- en: '](img/fig_6.22.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/fig_6.22.jpg)'
- en: Figure 6.22 – Formatting the legend
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.22 – 格式化图例
- en: Tip
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Don't get overwhelmed trying to memorize all of the available options. It is
    easier if we don't try to learn every possible customization, but rather look
    up the functionality that matches what we have in mind for our visualization when
    needed.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 不要被试图记住所有可用选项而感到不知所措。如果我们不试图学习每一种可能的自定义，而是根据需要查找与我们视觉化目标相匹配的功能，反而会更容易。
- en: Formatting axes
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 格式化轴
- en: 'Back in [*Chapter 1*](B16834_01_Final_SK_ePub.xhtml#_idTextAnchor015), *Introduction
    to Data Analysis*, we discussed how our axis limits can make for misleading plots
    if we aren''t careful. We have the option of passing this as a tuple to the `xlim`/`ylim`
    arguments when using the `plot()` method from `pandas`. Alternatively, with `matplotlib`,
    we can adjust the limits of each axis with the `plt.xlim()`/`plt.ylim()` function
    or the `set_xlim()`/`set_ylim()` method on an `Axes` object. We pass values for
    the minimum and maximum, separately; if we want to keep what was automatically
    generated, we can pass in `None`. Let''s modify the previous plot of the percentage
    of the world''s daily new COVID-19 cases per country to start the *y*-axis at
    zero:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第1章*](B16834_01_Final_SK_ePub.xhtml#_idTextAnchor015)《数据分析简介》中，我们讨论了如果我们不小心，轴的限制可能会导致误导性的图表。我们可以通过将轴的限制作为元组传递给
    `xlim`/`ylim` 参数来使用 `pandas` 的 `plot()` 方法。或者，使用 `matplotlib` 时，我们可以通过 `plt.xlim()`/`plt.ylim()`
    函数或 `Axes` 对象上的 `set_xlim()`/`set_ylim()` 方法调整每个轴的限制。我们分别传递最小值和最大值；如果我们想保持自动生成的限制，可以传入
    `None`。让我们修改之前的图表，将世界各国每日新增 COVID-19 病例的百分比的 *y* 轴从零开始：
- en: '[PRE29]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Notice that the *y*-axis now begins at zero:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，*y* 轴现在从零开始：
- en: '![Figure 6.23 – Updating axis limits with matplotlib'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.23 – 使用 matplotlib 更新轴限制'
- en: '](img/fig_6.23.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/fig_6.23.jpg)'
- en: Figure 6.23 – Updating axis limits with matplotlib
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.23 – 使用 matplotlib 更新轴限制
- en: If we instead want to change the scale of the axis, we can use `plt.xscale()`/`plt.yscale()`
    and pass the type of scale we want. So, `plt.yscale('log')`, for example, will
    use the log scale for the *y*-axis; we saw how to do this with `pandas` in the
    previous chapter.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想改变轴的刻度，可以使用 `plt.xscale()`/`plt.yscale()` 并传入我们想要的刻度类型。例如，`plt.yscale('log')`
    将会为 *y* 轴使用对数刻度；我们在前一章中已经学过如何使用 `pandas` 实现这一点。
- en: 'We can also control which tick marks show up and what they are labeled as by
    passing in the tick locations and labels to `plt.xticks()` or `plt.yticks()`.
    Note that we can also call these functions to obtain the tick locations and labels.
    For example, since our data starts and ends on the 18th of the month, let''s move
    the tick marks in the previous plot to the 18th of each month and then label the
    ticks accordingly:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过将刻度位置和标签传递给 `plt.xticks()` 或 `plt.yticks()` 来控制显示哪些刻度线以及它们的标签。请注意，我们也可以调用这些函数来获取刻度位置和标签。例如，由于我们的数据从每个月的18日开始和结束，让我们将前一个图表中的刻度线移到每个月的18日，然后相应地标记刻度：
- en: '[PRE30]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'After moving the tick marks, we have a tick label on the first data point in
    the plot (January 18, 2020) and on the last (September 18, 2020):'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 移动刻度线后，图表的第一个数据点（2020年1月18日）和最后一个数据点（2020年9月18日）都有刻度标签：
- en: '![Figure 6.24 – Editing tick labels'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.24 – 编辑刻度标签'
- en: '](img/fig_6.24.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/fig_6.24.jpg)'
- en: Figure 6.24 – Editing tick labels
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.24 – 编辑刻度标签
- en: 'We are currently representing the percentages as decimals, but we may wish
    to format the labels to be written using the percent sign. Note that there is
    no need to use the `plt.yticks()` function to do so; instead, we can use the `PercentFormatter`
    class from the `matplotlib.ticker` module:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当前将百分比表示为小数，但可能希望将标签格式化为使用百分号。请注意，不需要使用`plt.yticks()`函数来做到这一点；相反，我们可以使用`matplotlib.ticker`模块中的`PercentFormatter`类：
- en: '[PRE31]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'By specifying `xmax=1`, we are indicating that our values should be divided
    by 1 (since they are already percentages), before multiplying by 100 and appending
    the percent sign. This results in percentages along the *y*-axis:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 通过指定`xmax=1`，我们表示我们的值应该先除以1（因为它们已经是百分比），然后乘以100并附加百分号。这将导致*y*轴上显示百分比：
- en: '![Figure 6.25 – Formatting tick labels as percentages'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.25 – 将刻度标签格式化为百分比'
- en: '](img/fig_6.25.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/fig_6.25.jpg)'
- en: Figure 6.25 – Formatting tick labels as percentages
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.25 – 将刻度标签格式化为百分比
- en: 'Another useful formatter is the `EngFormatter` class, which will automatically
    handle formatting numbers as thousands, millions, and so on using **engineering
    notation**. Let''s use this to plot the cumulative COVID-19 cases per continent
    in millions:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的格式化器是`EngFormatter`类，它会自动将数字格式化为千位、百万位等，采用**工程计数法**。让我们用它来绘制每个大洲的累计COVID-19病例（单位：百万）：
- en: '[PRE32]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Notice that we didn''t need to divide the cumulative case counts by 1 million
    to get these numbers—the `EngFormatter` object that we passed to `set_major_formatter()`
    automatically figured out that it should use millions (M) based on the data:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们不需要将累计病例数除以100万来得到这些数字——我们传递给`set_major_formatter()`的`EngFormatter`对象自动计算出应该使用百万（M）单位来表示数据：
- en: '![Figure 6.26 – Formatting tick labels with engineering notation'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.26 – 使用工程计数法格式化刻度标签'
- en: '](img/fig_6.26.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/fig_6.26.jpg)'
- en: Figure 6.26 – Formatting tick labels with engineering notation
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.26 – 使用工程计数法格式化刻度标签
- en: 'Both the `PercentFormatter` and `EngFormatter` classes format the tick labels,
    but sometimes we want to change the location of the ticks rather than format them.
    One way of doing so is with the `MultipleLocator` class, which makes it easy for
    us to place the ticks at multiples of a number of our choosing. To illustrate
    how we could use this, let''s take a look at the daily new COVID-19 cases in New
    Zealand from April 18, 2020 through September 18, 2020:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`PercentFormatter`和`EngFormatter`类都可以格式化刻度标签，但有时我们希望更改刻度的位置，而不是格式化它们。实现这一点的一种方法是使用`MultipleLocator`类，它可以轻松地将刻度设置为我们选择的倍数。为了演示我们如何使用它，来看一下2020年4月18日至2020年9月18日新西兰的每日新增COVID-19病例：'
- en: '[PRE33]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Without us intervening with the tick locations, `matplotlib` is showing the
    ticks in increments of 2.5\. We know that there is no such thing as half of a
    case, so it makes more sense to show this data with only integer ticks:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不干预刻度位置，`matplotlib`将以2.5为间隔显示刻度。我们知道没有半个病例，因此最好以整数刻度显示该数据：
- en: '![Figure 6.27 – Default tick locations'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.27 – 默认刻度位置'
- en: '](img/fig_6.27.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/fig_6.27.jpg)'
- en: Figure 6.27 – Default tick locations
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.27 – 默认刻度位置
- en: 'Let''s fix this by using the `MultipleLocator` class. Here, we aren''t formatting
    the axis labels, but rather controlling which ones are shown; for this reason,
    we have to call the `set_major_locator()` method instead of `set_major_formatter()`:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用`MultipleLocator`类来修正这个问题。在这里，我们并没有格式化轴标签，而是控制显示哪些标签；因此，我们必须调用`set_major_locator()`方法，而不是`set_major_formatter()`：
- en: '[PRE34]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Since we passed in `base=3`, our *y*-axis now contains integers in increments
    of three:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们传入了`base=3`，因此我们的*y*轴现在包含每隔三的整数：
- en: '![Figure 6.28 – Using integer tick locations'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.28 – 使用整数刻度位置'
- en: '](img/fig_6.28.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/fig_6.28.jpg)'
- en: Figure 6.28 – Using integer tick locations
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.28 – 使用整数刻度位置
- en: These were only three of the features provided with the `matplotlib.ticker`
    module, so I highly recommend you check out the documentation for more information.
    There is also a link in the *Further reading* section at the end of this chapter.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是`matplotlib.ticker`模块提供的三个功能，因此我强烈建议你查看文档以获取更多信息。在本章末尾的*进一步阅读*部分中也有相关链接。
- en: Customizing visualizations
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义可视化
- en: So far, all of the code we've learned for creating data visualizations has been
    for making the visualization itself. Now that we have a strong foundation, we
    are ready to learn how to add reference lines, control colors and textures, and
    include annotations.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们学到的所有创建数据可视化的代码都是为了制作可视化本身。现在我们已经打下了坚实的基础，准备学习如何添加参考线、控制颜色和纹理，以及添加注释。
- en: 'In the `3-customizing_visualizations.ipynb` notebook, let''s handle our imports
    and read in the Facebook stock prices and earthquake datasets:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在`3-customizing_visualizations.ipynb`笔记本中，让我们处理导入库并读取 Facebook 股票价格和地震数据集：
- en: '[PRE35]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Tip
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Changing the style in which the plots are created is an easy way to change their
    look and feel without setting each aspect separately. To set the style for `seaborn`,
    use `sns.set_style()`. With `matplotlib`, we can use `plt.style.use()` to specify
    the stylesheet(s) we want to use. These will be used for all visualizations created
    in that session. If, instead, we only want it for a single plot, we can use `sns.set_context()`
    or `plt.style.context()`. Available styles for `seaborn` can be found in the documentation
    of the aforementioned functions and in `matplotlib` by taking a look at the values
    in `plt.style.available`.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 更改绘图样式是改变其外观和感觉的一种简单方法，无需单独设置每个方面。要设置`seaborn`的样式，可以使用`sns.set_style()`。对于`matplotlib`，我们可以使用`plt.style.use()`来指定我们要使用的样式表。这些样式会应用于该会话中创建的所有可视化。如果我们只想为某个单一图表设置样式，可以使用`sns.set_context()`或`plt.style.context()`。可以在前述函数的文档中找到`seaborn`的可用样式，或在`matplotlib`中查看`plt.style.available`中的值。
- en: Adding reference lines
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加参考线
- en: Quite often, we want to draw attention to a specific value on our plot, perhaps
    as a boundary or turning point. We may be interested in whether the line gets
    crossed or serves as a partition. In finance, horizontal reference lines may be
    drawn on top of the line plot of a stock's price, marking the support and resistance.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 很常见，我们希望在图表上突出显示某个特定的值，可能是一个边界或转折点。我们可能关心这条线是否被突破，或是否作为一个分界线。在金融领域，可能会在股票价格的折线图上绘制水平参考线，标记出支撑位和阻力位。
- en: The **support** is a price level at which a downward trend is expected to reverse
    because the stock is now at a price level at which buyers are more enticed to
    purchase, driving the price up and away from this point. On the flip side, the
    **resistance** is the price level at which an upward trend is expected to reverse
    since the price is an attractive selling point; thus, the price falls down and
    away from this point. Of course, this is not to say these levels don't get surpassed.
    Since we have Facebook stock data, let's add the support and resistance reference
    lines to our line plot of the closing price.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '**支撑位**是一个预期下行趋势将会反转的价格水平，因为股票此时处于一个买家更倾向于购买的价格区间，推动价格向上并远离此点。相对地，**阻力位**是一个预期上行趋势将会反转的价格水平，因为该价格是一个吸引人的卖出点；因此，价格会下跌并远离此点。当然，这并不意味着这些水平永远不会被突破。由于我们有
    Facebook 的股票数据，让我们在收盘价的折线图上添加支撑位和阻力位参考线。'
- en: Important note
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Going over how support and resistance are calculated is beyond the scope of
    this chapter, but [*Chapter 7*](B16834_07_Final_SK_ePub.xhtml#_idTextAnchor146),
    *Financial Analysis – Bitcoin and the Stock Market*, will include some code for
    calculating these using pivot points. Also, be sure to check out the *Further
    reading* section for a more in-depth introduction to support and resistance.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 计算支撑位和阻力位的方法超出了本章的范围，但在[*第7章*](B16834_07_Final_SK_ePub.xhtml#_idTextAnchor146)，*财务分析——比特币与股票市场*中，将包括一些使用枢轴点计算这些的代码。此外，请务必查看*进一步阅读*部分，以获得关于支撑位和阻力位的更深入介绍。
- en: 'Our two horizontal reference lines will be at the support of $124.46 and the
    resistance of $138.53\. Both these numbers were derived using the `stock_analysis`
    package, which we will build in [*Chapter 7*](B16834_07_Final_SK_ePub.xhtml#_idTextAnchor146),
    *Financial Analysis – Bitcoin and the Stock Market*. We simply need to create
    an instance of the `StockAnalyzer` class to calculate these metrics:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的两条水平参考线将分别位于支撑位$124.46和阻力位$138.53。这两个数字是通过使用`stock_analysis`包计算得出的，我们将在[*第7章*](B16834_07_Final_SK_ePub.xhtml#_idTextAnchor146)，*财务分析——比特币与股票市场*中构建该包。我们只需要创建`StockAnalyzer`类的一个实例来计算这些指标：
- en: '[PRE36]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We will use the `plt.axhline()` function for this task, but note that this
    will also work on the `Axes` object. Remember that the text we provide to the
    `label` arguments will be populated in the legend:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `plt.axhline()` 函数来完成这项任务，但请注意，这也适用于 `Axes` 对象。记住，我们提供给 `label` 参数的文本将会出现在图例中：
- en: '[PRE37]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We should already be familiar with the f-string format from earlier chapters,
    but notice the additional text after the variable name here (`:,.2f`). The support
    and resistance are stored as floats in the `support` and `resistance` variables,
    respectively. The colon (`:`) precedes the `format_spec`), which tells Python
    how to format that variable; in this case, we are formatting it as a decimal (`f`)
    with a comma as the thousands separator (`,`) and two digits of precision after
    the decimal (`.2`). This will also work with the `format()` method, in which case
    it would look like `''{:,.2f}''.format(resistance)`. This formatting makes for
    an informative legend in our plot:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该已经熟悉之前章节中的 f-string 格式，但请注意这里在变量名之后的额外文本（`:,.2f`）。支持位和阻力位分别以浮动点存储在 `support`
    和 `resistance` 变量中。冒号（`:`）位于 `format_spec` 前面，它告诉 Python 如何格式化该变量；在这种情况下，我们将其格式化为小数（`f`），以逗号作为千位分隔符（`,`），并且小数点后保留两位精度（`.2`）。这种格式化也适用于
    `format()` 方法，在这种情况下，它将类似于 `'{:,.2f}'.format(resistance)`。这种格式化使得图表中的图例更加直观：
- en: '![Figure 6.29 – Creating horizontal reference lines with matplotlib'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.29 – 使用 matplotlib 创建水平参考线'
- en: '](img/fig_6.29.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/fig_6.29.jpg)'
- en: Figure 6.29 – Creating horizontal reference lines with matplotlib
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.29 – 使用 matplotlib 创建水平参考线
- en: Important note
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Those with personal investment accounts will likely find some literature there
    on support and resistance when looking to place limit orders or stop losses based
    on the stock hitting a certain price point since these can help inform the feasibility
    of the target price. In addition, these reference lines may be used by traders
    to analyze the stock's momentum and decide whether it is time to buy/sell the
    stock.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有个人投资账户的人在寻找基于股票达到某一价格点来下限价单或止损单时，可能会发现一些关于支撑位和阻力位的文献，因为这些可以帮助判断目标价格的可行性。此外，交易者也可能使用这些参考线来分析股票的动能，并决定是否是时候买入/卖出股票。
- en: 'Turning back to the earthquake data, let''s use `plt.axvline()` to draw vertical
    reference lines for the number of standard deviations from the mean on the distribution
    of earthquake magnitudes in Indonesia. The `std_from_mean_kde()` function located
    in the `viz.py` module in the GitHub repository uses `itertools` to easily make
    the combinations of the colors and values we need to plot:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 回到地震数据，我们将使用 `plt.axvline()` 绘制垂直参考线，用于表示印尼地震震级分布中的标准差个数。位于 GitHub 仓库中 `viz.py`
    模块的 `std_from_mean_kde()` 函数使用 `itertools` 来轻松生成我们需要绘制的颜色和值的组合：
- en: '[PRE38]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `product()` function from `itertools` will give us all combinations of items
    from any number of iterables. Here, we have zipped the colors, multipliers, and
    line styles since we always want a green dotted line for a multiplier of 1; an
    orange dot-dashed line for a multiplier of 2; and a red dashed line for a multiplier
    of 3\. When `product()` uses these tuples, we get positive- and negative-signed
    combinations for everything. To keep our legend from getting too crowded, we only
    label each color once using the ± sign. Since we have combinations between a string
    and a tuple at each iteration, we unpack the tuple in our `for` statement for
    easier use.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`itertools` 中的 `product()` 函数将为我们提供来自任意数量可迭代对象的所有组合。在这里，我们将颜色、乘数和线型打包在一起，因为我们总是希望乘数为
    1 时使用绿色虚线；乘数为 2 时使用橙色点划线；乘数为 3 时使用红色虚线。当 `product()` 使用这些元组时，我们得到的是正负符号的所有组合。为了避免图例过于拥挤，我们仅使用
    ± 符号为每种颜色标注一次。由于在每次迭代中字符串和元组之间有组合，我们在 `for` 语句中解包元组，以便更容易使用。'
- en: Tip
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: We can use LaTeX math symbols ([https://www.latex-project.org/](https://www.latex-project.org/))
    to label our plots if we follow a certain pattern. First, we must mark the string
    as `raw` by preceding it with the `r` character. Then, we must surround the LaTeX
    with `$` symbols. For example, we used `r'$\mu$'` for the Greek letter μ in the
    preceding code.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 LaTeX 数学符号（[https://www.latex-project.org/](https://www.latex-project.org/)）为我们的图表标注，只要我们遵循一定的模式。首先，我们必须通过在字符串前加上
    `r` 字符来将其标记为 `raw`。然后，我们必须用 `$` 符号将 LaTeX 包围。例如，我们在前面的代码中使用了 `r'$\mu$'` 来表示希腊字母
    μ。
- en: 'Let''s use the `std_from_mean_kde()` function to see which parts of the estimated
    distribution of earthquake magnitudes in Indonesia are within one, two, or three
    standard deviations from the mean:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`std_from_mean_kde()`函数，看看印度尼西亚地震震级的估算分布中哪些部分位于均值的一个、两个或三个标准差内：
- en: '[PRE39]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Notice the KDE is right-skewed—it has a longer tail on the right side, and
    the mean is to the right of the mode:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，KDE呈右偏分布——右侧的尾部更长，均值位于众数的右侧：
- en: '![Figure 6.30 – Including vertical reference lines'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.30 – 包含垂直参考线'
- en: '](img/fig_6.30.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/fig_6.30.jpg)'
- en: Figure 6.30 – Including vertical reference lines
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.30 – 包含垂直参考线
- en: Tip
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 小提示
- en: To make a straight line of arbitrary slope, simply pass the endpoints of the
    line as two `x` values and two `y` values (for example, `[0, 2]` and `[2, 0]`)
    to `plt.plot()` using the same `Axes` object. For lines that aren't straight,
    `np.linspace()` can be used to create a range of evenly-spaced points on `[start,
    stop)`, which can be used for the `x` values and to calculate the `y` values.
    As a reminder, when specifying a range, square brackets mean inclusive of both
    endpoints and round brackets are exclusive, so [0, 1) goes from 0 to as close
    to 1 as possible without being 1\. We see these when using `pd.cut()` and `pd.qcut()`
    if we don't name the buckets.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 要绘制任意斜率的直线，只需将线段的两个端点作为两个`x`值和两个`y`值（例如，`[0, 2]` 和 `[2, 0]`）传递给`plt.plot()`，使用相同的`Axes`对象。对于非直线，`np.linspace()`可以用来创建在`[start,
    stop)`区间内均匀分布的点，这些点可以作为`x`值并计算相应的`y`值。作为提醒，指定范围时，方括号表示包含端点，圆括号表示不包含端点，因此[0, 1)表示从0到接近1但不包括1。我们在使用`pd.cut()`和`pd.qcut()`时，如果不命名桶，就会看到这种情况。
- en: Shading regions
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 填充区域
- en: 'In some cases, the reference line itself isn''t so interesting, but the area
    between two of them is; for this purpose, we have `axvspan()` and `axhspan()`.
    Let''s revisit the support and resistance of Facebook stock''s closing price.
    We can use `axhspan()` to shade the area that falls between the two:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，参考线本身并不那么有趣，但两条参考线之间的区域更有意义；为此，我们有`axvspan()`和`axhspan()`。让我们重新审视Facebook股票收盘价的支撑位和阻力位。我们可以使用`axhspan()`来填充两者之间的区域：
- en: '[PRE40]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Note that the color of the shaded region is determined by the `facecolor` argument.
    For this example, we accepted the default:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，阴影区域的颜色由`facecolor`参数决定。在这个例子中，我们接受了默认值：
- en: '![Figure 6.31 – Adding a horizontal shaded region'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.31 – 添加一个水平阴影区域'
- en: '](img/fig_6.31.jpg)'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/fig_6.31.jpg)'
- en: Figure 6.31 – Adding a horizontal shaded region
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.31 – 添加一个水平阴影区域
- en: 'When we are interested in shading the area between two curves, we can use the
    `plt.fill_between()` and `plt.fill_betweenx()` functions. The `plt.fill_between()`
    function accepts one set of `x` values and two sets of `y` values; we can use
    `plt.fill_betweenx()` if we require the opposite. Let''s shade the area between
    Facebook''s high price and low price each day of the fourth quarter using `plt.fill_between()`:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们感兴趣的是填充两条曲线之间的区域时，可以使用`plt.fill_between()`和`plt.fill_betweenx()`函数。`plt.fill_between()`函数接受一组`x`值和两组`y`值；如果需要相反的效果，可以使用`plt.fill_betweenx()`。让我们使用`plt.fill_between()`填充Facebook每个交易日的高价和低价之间的区域：
- en: '[PRE41]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This gives us a better idea of the variation in price on a given day; the taller
    the vertical distance, the higher the fluctuation:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这能让我们更清楚地了解某一天价格的波动情况；垂直距离越高，波动越大：
- en: '![Figure 6.32 – Shading between two curves'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.32 – 在两条曲线之间填充阴影'
- en: '](img/fig_6.32.jpg)'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/fig_6.32.jpg)'
- en: Figure 6.32 – Shading between two curves
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.32 – 在两条曲线之间填充阴影
- en: 'By providing a Boolean mask to the `where` argument, we can specify when to
    fill the area between the curves. Let''s fill in only December from the previous
    example. We will add dashed lines for the high price curve and the low price curve
    throughout the time period to see what is happening:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 通过为`where`参数提供布尔掩码，我们可以指定何时填充曲线之间的区域。让我们只填充上一个例子中的12月。我们将在整个时间段内为高价曲线和低价曲线添加虚线，以便查看发生了什么：
- en: '[PRE42]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This results in the following plot:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下图表：
- en: '![Figure 6.33 – Selectively shading between two curves'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.33 – 在两条曲线之间选择性地填充阴影'
- en: '](img/fig_6.33.jpg)'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/fig_6.33.jpg)'
- en: Figure 6.33 – Selectively shading between two curves
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.33 – 在两条曲线之间选择性地填充阴影
- en: With reference lines and shaded regions, we are able to draw attention to certain
    areas, and can even label them in the legend, but we are limited in the text we
    can use to explain them. Let's now discuss how to annotate our plot for additional
    context.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 通过参考线和阴影区域，我们能够引起对特定区域的注意，甚至可以在图例中标注它们，但在用文字解释这些区域时，我们的选择有限。现在，让我们讨论如何为我们的图表添加更多的上下文注释。
- en: Annotations
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注释
- en: 'We will often find the need to annotate specific points in our visualizations
    either to point out events, such as the days on which Facebook''s stock price
    dropped due to certain news stories breaking, or to label values that are important
    for comparisons. For example, let''s use the `plt.annotate()` function to label
    the support and resistance:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常需要在可视化中标注特定的点，以便指出事件，例如 Facebook 股票因某些新闻事件而下跌的日期，或者标注一些重要的值以供比较。例如，让我们使用
    `plt.annotate()` 函数标注支撑位和阻力位：
- en: '[PRE43]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Notice the annotations are different; when we annotated the resistance, we
    only provided the text for the annotation and the coordinates of the point being
    annotated with the `xy` argument. However, when we annotated the support, we also
    provided values for the `xytext` and `arrowprops` arguments; this allowed us to
    put the text somewhere other than where the value occurred and add an arrow indicating
    where it occurred. By doing so, we avoid obscuring the last few days of data with
    our label:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，注释有所不同；当我们注释阻力位时，只提供了注释文本和通过 `xy` 参数注释的点的坐标。然而，当我们注释支撑位时，我们还为 `xytext` 和
    `arrowprops` 参数提供了值；这使得我们可以将文本放置在不同于数据出现位置的地方，并添加箭头指示数据出现的位置。通过这种方式，我们避免了将标签遮挡在最后几天的数据上：
- en: '![Figure 6.34 – Including annotations'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.34 – 包含注释'
- en: '](img/fig_6.34.jpg)'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/fig_6.34.jpg)'
- en: Figure 6.34 – Including annotations
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.34 – 包含注释
- en: 'The `arrowprops` argument gives us quite a bit of customization over the type
    of arrow we want, although it might be difficult to get it perfect. As an example,
    let''s annotate the big decline in the price of Facebook in July with the percentage
    drop:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '`arrowprops` 参数为我们提供了相当多的定制选项，可以选择我们想要的箭头类型，尽管要做到完美可能有些困难。举个例子，让我们用百分比的下降幅度标注出
    Facebook 在七月价格的大幅下跌：'
- en: '[PRE44]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Notice that we were able to format the `pct_drop` variable as a percentage
    with two digits of precision by using `.2%` in the format specifier of the f-string.
    In addition, by specifying `va=''center''`, we tell `matplotlib` to vertically
    center our annotation in the middle of the arrow:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们能够通过在 f-string 的格式说明符中使用 `.2%` 将 `pct_drop` 变量格式化为具有两位精度的百分比。此外，通过指定 `va='center'`，我们告诉
    `matplotlib` 将我们的注释垂直居中显示在箭头的中间：
- en: '![Figure 6.35 – Customizing the annotation''s arrow'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.35 – 自定义注释的箭头'
- en: '](img/fig_6.35.jpg)'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/fig_6.35.jpg)'
- en: Figure 6.35 – Customizing the annotation's arrow
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.35 – 自定义注释的箭头
- en: Matplotlib provides a lot of flexibility to customize these annotations—we can
    pass any option that the `Text` class in `matplotlib` supports ([https://matplotlib.org/api/text_api.html#matplotlib.text.Text](https://matplotlib.org/api/text_api.html#matplotlib.text.Text)).
    To change colors, simply pass the desired color in the `color` argument. We can
    also control font size, weight, family, and style through the `fontsize`, `fontweight`,
    `fontfamily`, and `fontstyle` arguments, respectively.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: Matplotlib 提供了高度灵活的选项来定制这些标注——我们可以传递任何 `matplotlib` 中 `Text` 类所支持的选项 ([https://matplotlib.org/api/text_api.html#matplotlib.text.Text](https://matplotlib.org/api/text_api.html#matplotlib.text.Text))。要改变颜色，只需在
    `color` 参数中传递所需的颜色。我们还可以通过 `fontsize`、`fontweight`、`fontfamily` 和 `fontstyle`
    参数分别控制字体大小、粗细、家族和样式。
- en: Colors
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 颜色
- en: For the sake of consistency, the visualizations we produce should stick to a
    color scheme. Companies and academic institutions alike often have custom color
    palettes for presentations. We can easily adopt the same color palette in our
    visualizations too.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持一致性，我们制作的可视化图表应该遵循一个颜色方案。公司和学术机构通常会为演示文稿制定定制的调色板。我们也可以轻松地在可视化中采用相同的调色板。
- en: So far, we have either been providing colors to the `color` argument with their
    single character names, such as `'b'` for blue and `'k'` for black, or their names
    (`'blue'` or `'black'`). We have also seen that `matplotlib` has many colors that
    can be specified by name; the full list can be found in the documentation at [https://matplotlib.org/examples/color/named_colors.html](https://matplotlib.org/examples/color/named_colors.html).
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们要么使用单个字符名称为 `color` 参数提供颜色，例如 `'b'` 表示蓝色，`'k'` 表示黑色，或者使用它们的名称（`'blue'`
    或 `'black'`）。我们还看到 `matplotlib` 有许多可以用名称指定的颜色；完整列表可以在文档中找到，地址是 [https://matplotlib.org/examples/color/named_colors.html](https://matplotlib.org/examples/color/named_colors.html)。
- en: Important note
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Remember that if we are providing a color with the `style` argument, we are
    limited to the colors that have a single-character abbreviation.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，如果我们使用 `style` 参数提供颜色，我们只能使用具有单个字符缩写的颜色。
- en: In addition, we can provide a hex code for the color we want; those who have
    worked with HTML or CSS in the past will no doubt be familiar with these as a
    way to specify the exact color (regardless of what different places call it).
    For those unfamiliar with a hex color code, it specifies the amount of red, green,
    and blue used to make the color in question in the `#RRGGBB` format. Black is
    `#000000` and white is `#FFFFFF` (case-insensitive). This may be confusing because
    `F` is most definitely not a number; however, these are hexadecimal numbers (base
    16, not the base 10 we traditionally use), where `0-9` still represents `0-9`,
    but `A-F` represents `10-15`.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，我们可以提供一个十六进制的颜色码来指定我们想要的颜色；那些之前在 HTML 或 CSS 中工作过的人无疑会熟悉这种方式，它可以精确指定颜色（无论不同的地方称其为何种颜色）。对于不熟悉十六进制颜色码的人来说，它指定了用于制作所需颜色的红色、绿色和蓝色的数量，格式为
    `#RRGGBB`。黑色是 `#000000`，白色是 `#FFFFFF`（大小写不敏感）。这可能会令人困惑，因为 `F` 显然不是一个数字；但这些是十六进制数（基数为
    16，而不是我们传统使用的十进制数），其中 `0-9` 仍然表示 `0-9`，但 `A-F` 表示 `10-15`。
- en: 'Matplotlib accepts hex codes as a string to the `color` argument. To illustrate
    this, let''s plot Facebook''s opening price in `#8000FF`:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: Matplotlib 将十六进制码作为字符串接受到 `color` 参数中。为了说明这一点，让我们以 `#8000FF` 绘制 Facebook 的开盘价：
- en: '[PRE45]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This results in a purple line plot:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了一个紫色线图：
- en: '![Figure 6.36 – Changing line color'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.36 – 改变线条颜色'
- en: '](img/fig_6.36.jpg)'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/fig_6.36.jpg)'
- en: Figure 6.36 – Changing line color
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.36 – 改变线条颜色
- en: 'Alternatively, we may be given the values in RGB or `color` argument as a tuple.
    If we don''t provide the alpha, it will default to `1` for opaque. One thing to
    note here is that, while we will find these numbers presented in the range [0,
    255], `matplotlib` requires them to be in the range [0, 1], so we must divide
    each by 255\. The following code is equivalent to the preceding example, except
    we use the RGB tuple instead of the hex code:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以将值以 RGB 或 `color` 参数的元组给出。如果我们不提供 alpha 值，默认值为不透明的 `1`。这里需要注意的一件事是，虽然这些数值以
    [0, 255] 范围呈现，但 `matplotlib` 要求它们在 [0, 1] 范围内，因此我们必须将每个值除以 255。以下代码与前面的示例相同，只是我们使用
    RGB 元组而不是十六进制码：
- en: '[PRE46]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In the previous chapter, we saw several examples in which we needed many different
    colors for the varying data we were plotting, but where do these colors come from?
    Well, `matplotlib` has numerous colormaps that are used for this purpose.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章中，我们看到了几个示例，我们在绘制变化数据时需要许多不同的颜色，但这些颜色从哪里来？嗯，`matplotlib` 有许多颜色映射用于此目的。
- en: Colormaps
  id: totrans-324
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 颜色映射
- en: 'Rather than having to specify all the colors we want to use upfront, `matplotlib`
    can take a colormap and cycle through the colors there. When we discussed heatmaps
    in the previous chapter, we considered the importance of using the proper class
    of colormap for the given task. There are three types of colormaps, each with
    its own purpose, as shown in the following table:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是必须预先指定我们要使用的所有颜色，`matplotlib` 可以使用一个颜色映射并循环遍历其中的颜色。在前一章中讨论热图时，我们考虑了根据给定任务使用适当的颜色映射类别的重要性。以下表格显示了三种类型的颜色映射，每种都有其自己的用途：
- en: '![Figure 6.37 – Types of colormaps'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.37 – 颜色映射类型'
- en: '](img/fig_6.37.jpg)'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/fig_6.37.jpg)'
- en: Figure 6.37 – Types of colormaps
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.37 – 颜色映射类型
- en: Tip
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Browse colors by name, hex, and RGB values at [https://www.color-hex.com/](https://www.color-hex.com/),
    and find the full color spectrum for the colormaps at [https://matplotlib.org/gallery/color/colormap_reference.html](https://matplotlib.org/gallery/color/colormap_reference.html).
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览颜色名称、十六进制和 RGB 值，请访问 [https://www.color-hex.com/](https://www.color-hex.com/)，并在
    [https://matplotlib.org/gallery/color/colormap_reference.html](https://matplotlib.org/gallery/color/colormap_reference.html)
    上找到颜色映射的完整颜色光谱。
- en: 'In Python, we can obtain a list of all the available colormaps by running the
    following:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，我们可以通过运行以下代码获取所有可用色图的列表：
- en: '[PRE47]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Notice that some of the colormaps are present twice where one is in the reverse
    order, signified by the `_r` suffix on the name. This is very helpful since we
    don't have to invert our data to map the values to the colors we want. Pandas
    accepts these colormaps as strings or `matplotlib` colormaps with the `colormap`
    argument of the `plot()` method, meaning we can pass in `'coolwarm_r'`, `cm.get_cmap('coolwarm_r')`,
    or `cm.coolwarm_r` and get the same result.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，有些色图出现了两次，其中一个是反向的，名称后缀带有 `_r`。这非常有用，因为我们无需将数据反转，就能将值映射到我们想要的颜色。Pandas 接受这些色图作为字符串或
    `matplotlib` 色图，可以通过 `plot()` 方法的 `colormap` 参数传入 `'coolwarm_r'`、`cm.get_cmap('coolwarm_r')`
    或 `cm.coolwarm_r`，得到相同的结果。
- en: 'Let''s use the `coolwarm_r` colormap to show how Facebook stock''s closing
    price oscillates between the 20-day rolling minimum and maximum prices:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 `coolwarm_r` 色图来展示 Facebook 股票的收盘价如何在 20 天滚动最小值和最大值之间波动：
- en: '[PRE48]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Notice how easy it was to get red to represent hot performance (rolling maximum)
    and blue for cold (rolling minimum), by using the reversed colormap, rather than
    trying to make sure `pandas` plotted the rolling minimum first:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，使用反转的色图将红色表示为热性能（滚动最大值），蓝色表示为冷性能（滚动最小值）是多么简单，而不是试图确保 `pandas` 首先绘制滚动最小值：
- en: '![Figure 6.38 – Working with colormaps'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.38 – 使用色图'
- en: '](img/fig_6.38.jpg)'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/fig_6.38.jpg)'
- en: Figure 6.38 – Working with colormaps
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.38 – 使用色图
- en: 'The `colormap` object is a callable, meaning we can pass it values in the range
    [0, 1] and it will tell us the RGBA value for that point on the colormap, which
    we can use for the `color` argument. This gives us more fine-tuned control over
    the colors that we use from the colormap. We can use this technique to control
    how we spread the colormap across our data. For example, we can ask for the midpoint
    of the `ocean` colormap to use with the `color` argument:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '`colormap` 对象是一个可调用的，这意味着我们可以传递[0, 1]范围内的值，它会告诉我们该点在色图上的 RGBA 值，我们可以将其用于 `color`
    参数。这使得我们能更精确地控制从色图中使用的颜色。我们可以使用这种技巧来控制色图如何在我们的数据上展开。例如，我们可以请求 `ocean` 色图的中点，并将其用于
    `color` 参数：'
- en: '[PRE49]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Tip
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: There's an example of using a colormap as a callable in the `covid19_cases_map.ipynb`
    notebook, where COVID-19 case counts are mapped to colors, with darker colors
    indicating more cases.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `covid19_cases_map.ipynb` 笔记本中有一个示例，展示了如何将色图作为可调用对象使用，在该示例中，COVID-19 的病例数被映射到颜色上，颜色越深表示病例数越多。
- en: 'Despite the wealth of colormaps available, we may find the need to create our
    own. Perhaps we have a color palette we like to work with or have some requirement
    that we use a specific color scheme. We can make our own colormaps with `matplotlib`.
    Let''s make a blended colormap that goes from purple (`#800080`) to yellow (`#FFFF00`)
    with orange (`#FFA500`) in the center. All the functions we need for this are
    in `color_utils.py`. We can import the functions like this if we are running Python
    from the same directory as the file:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有大量的色图可供选择，我们可能还是需要创建自己的色图。也许我们有自己喜欢使用的颜色调色板，或者有某些需求需要使用特定的色彩方案。我们可以使用 `matplotlib`
    创建自己的色图。让我们创建一个混合色图，它从紫色（`#800080`）到黄色（`#FFFF00`），中间是橙色（`#FFA500`）。我们所需要的所有功能都在
    `color_utils.py` 中。如果我们从与该文件相同的目录运行 Python，我们可以这样导入这些函数：
- en: '[PRE50]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'First, we need to translate these hex colors to their RGB equivalents, which
    is what the `hex_to_rgb_color_list()` function will do. Note that this function
    can also handle the shorthand hex codes of three digits when the RGB values use
    the same hexadecimal digit for both of the digits (for example, `#F1D` is the
    shorthand equivalent of `#FF11DD`):'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要将这些十六进制颜色转换为 RGB 等效值，这正是 `hex_to_rgb_color_list()` 函数所做的。请注意，这个函数还可以处理当
    RGB 值的两个数字使用相同的十六进制数字时的简写十六进制代码（例如，`#F1D` 是 `#FF11DD` 的简写形式）：
- en: '[PRE51]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Tip
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Take a look at the `enumerate()` function; this lets us grab the index and the
    value at that index when we iterate, rather than looking up the value in the loop.
    Also, notice how easy it is for Python to convert base 10 numbers to hexadecimal
    numbers with the `int()` function by specifying the base. (Remember that `//`
    is integer division—we have to do this since `int()` expects an integer and not
    a float.)
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下 `enumerate()` 函数；它允许我们在迭代时获取索引和值，而不必在循环中查找值。另外，注意 Python 如何通过 `int()` 函数指定基数，轻松地将十进制数转换为十六进制数。（记住
    `//` 是整数除法——我们必须这样做，因为 `int()` 期望的是整数，而不是浮点数。）
- en: 'The next function we need is one to take those RGB colors and create the values
    for the colormap. This function will need to do the following:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的下一个函数是将这些 RGB 颜色转换为色图值的函数。此函数需要执行以下操作：
- en: Create a 4D NumPy array with 256 slots for color definitions. Note that we don't
    want to change the transparency, so we will leave the fourth dimension (alpha)
    alone.
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个具有 256 个槽位的 4D NumPy 数组用于颜色定义。请注意，我们不想改变透明度，因此我们将保持第四维（alpha）不变。
- en: For each dimension (red, green, and blue), use the `np.linspace()` function
    to create even transitions between the target colors (that is, transition from
    the red component of color 1 to the red component of color 2, then to the red
    component of color 3, and so on, before repeating this process with the green
    components and finally the blue components).
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个维度（红色、绿色和蓝色），使用 `np.linspace()` 函数在目标颜色之间创建均匀过渡（即，从颜色 1 的红色分量过渡到颜色 2 的红色分量，再到颜色
    3 的红色分量，以此类推，然后重复此过程处理绿色分量，最后是蓝色分量）。
- en: Return a `ListedColormap` object that we can use when plotting.
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回一个 `ListedColormap` 对象，我们可以在绘图时使用它。
- en: 'This is what the `blended_cmap()` function does:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 `blended_cmap()` 函数的功能：
- en: '[PRE52]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We can use the `draw_cmap()` function to draw a colorbar, which allows us to
    visualize our colormap:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `draw_cmap()` 函数绘制色条，帮助我们可视化我们的色图：
- en: '[PRE53]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'This function makes it easy for us to add a colorbar with a custom colormap
    for any visualization we choose; the `covid19_cases_map.ipynb` notebook has an
    example using COVID-19 cases plotted on a world map. For now, let''s use these
    functions to create and visualize our colormap. We will be using them by importing
    the module (which we did earlier):'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数使我们可以轻松地为任何可视化添加一个带有自定义色图的色条；`covid19_cases_map.ipynb` 笔记本中有一个示例，展示了如何使用
    COVID-19 病例在世界地图上绘制。现在，让我们使用这些函数来创建并可视化我们的色图。我们将通过导入模块来使用它们（我们之前已经做过了）：
- en: '[PRE54]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'This results in the following colorbar showing our colormap:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致显示我们的色图的色条：
- en: '![Figure 6.39 – Custom blended colormap'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.39 – 自定义混合色图'
- en: '](img/fig_6.39.jpg)'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/fig_6.39.jpg)'
- en: Figure 6.39 – Custom blended colormap
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.39 – 自定义混合色图
- en: Tip
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Seaborn also provides additional color palettes, along with handy utilities
    for picking colormaps and making custom ones for use with `matplotlib` interactively
    in a Jupyter Notebook. Check out the *Choosing color palettes* tutorial ([https://seaborn.pydata.org/tutorial/color_palettes.html](https://seaborn.pydata.org/tutorial/color_palettes.html))
    for more information. The notebook also contains a short example.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: Seaborn 还提供了额外的颜色调色板，以及一些实用工具，帮助用户选择色图并交互式地为 `matplotlib` 创建自定义色图，可以在 Jupyter
    Notebook 中使用。更多信息请查看 *选择颜色调色板* 教程（[https://seaborn.pydata.org/tutorial/color_palettes.html](https://seaborn.pydata.org/tutorial/color_palettes.html)），该笔记本中也包含了一个简短的示例。
- en: 'As we have seen in the colorbar we created, these colormaps have the ability
    to show different gradients of the colors to capture values on a continuum. If
    we merely want each line in our line plot to be a different color, we most likely
    want to cycle between different colors. For that, we can use `itertools.cycle()`
    with a list of colors; they won''t be blended, but we can cycle through them endlessly
    because it will be an infinite iterator. We used this technique earlier in the
    chapter to define our own colors for the regression residuals plots:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在创建的色条中看到的，这些色图能够显示不同的颜色渐变，以捕捉连续值。如果我们仅希望每条线在折线图中显示为不同的颜色，我们很可能希望在不同的颜色之间进行循环。为此，我们可以使用
    `itertools.cycle()` 与一个颜色列表；它们不会被混合，但我们可以无限循环，因为它是一个无限迭代器。我们在本章早些时候使用了这种技术来为回归残差图定义自己的颜色：
- en: '[PRE55]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Even simpler would be the case where we have a list of colors somewhere, but
    rather than putting that in our plotting code and storing another copy in memory,
    we can write a simple `return`, it uses `yield`. The following snippet shows a
    mock-up for this scenario, which is similar to the `itertools` solution; however,
    it is not infinite. This just goes to show that we can find many ways to do something
    in Python; we have to find the implementation that best meets our needs:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 更简单的情况是，我们在某个地方有一个颜色列表，但与其将其放入我们的绘图代码并在内存中存储另一个副本，不如写一个简单的 `return`，它使用 `yield`。以下代码片段展示了这种情况的一个模拟示例，类似于
    `itertools` 解决方案；然而，它并不是无限的。这只是说明了我们可以在 Python 中找到多种方式来做同一件事；我们必须找到最适合我们需求的实现：
- en: '[PRE56]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Using `matplotlib`, the alternative would be to instantiate a `ListedColormap`
    object with the color list and define a large value for `N` so that it repeats
    for long enough (if we don''t provide it, it will only go through the colors once):'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`matplotlib`时，另一种选择是实例化一个`ListedColormap`对象，并传入颜色列表，同时为`N`定义一个较大的值，以确保颜色足够多次重复（如果不提供，它将只经过一次颜色列表）：
- en: '[PRE57]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Note that we can also use `cycler` from the `matplotlib` team, which adds additional
    flexibility by allowing us to define combinations of colors, line styles, markers,
    line widths, and more to cycle through. The API details the available functionality
    and can be found at [https://matplotlib.org/cycler/](https://matplotlib.org/cycler/).
    We will see an example of this in [*Chapter 7*](B16834_07_Final_SK_ePub.xhtml#_idTextAnchor146),
    *Financial Analysis – Bitcoin and the Stock Market*.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们还可以使用`matplotlib`团队的`cycler`，它通过允许我们定义颜色、线条样式、标记、线宽等的组合来增加额外的灵活性，能够循环使用这些组合。API文档详细介绍了可用功能，您可以在[https://matplotlib.org/cycler/](https://matplotlib.org/cycler/)找到。我们将在[*第7章*](B16834_07_Final_SK_ePub.xhtml#_idTextAnchor146)《金融分析——比特币与股市》中看到一个例子。
- en: Conditional coloring
  id: totrans-373
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 条件着色
- en: Colormaps make it easy to vary color according to the values in our data, but
    what happens if we only want to use a specific color when certain conditions are
    met? In that case, we need to build a function around color selection.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 颜色映射使得根据数据中的值变化颜色变得简单，但如果我们只想在特定条件满足时使用特定颜色该怎么办？在这种情况下，我们需要围绕颜色选择构建一个函数。
- en: 'We can write a generator to determine plot color based on our data and only
    calculate it when it is asked for. Let''s say we wanted to assign colors to years
    from 1992 to 200018 (no, that''s not a typo) based on whether they are leap years,
    and distinguish why they aren''t leap years (for example, we want a special color
    for years divisible by 100 but not 400, which aren''t leap years). We certainly
    don''t want to keep a list this size in memory, so we create a generator to calculate
    the color on demand:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以编写一个生成器，根据数据确定绘图颜色，并且仅在请求时计算它。假设我们想要根据年份（从1992年到200018年，没错，这不是打字错误）是否为闰年来分配颜色，并区分哪些年份不是闰年（例如，我们希望为那些能被100整除但不能被400整除的年份指定特殊颜色，因为它们不是闰年）。显然，我们不想在内存中保留如此庞大的列表，所以我们创建一个生成器按需计算颜色：
- en: '[PRE58]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Important note
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The **modulo operator** (%) returns the remainder of a division operation. For
    example, 4 % 2 equals 0 because 4 is divisible by 2\. However, since 4 is not
    divisible by 3, 4 % 3 is non-zero; it is 1 because we can fit 3 into 4 once and
    will have 1 left over (4 - 3). The modulo operator can be used to check the divisibility
    of one number by another and is often used to check whether a number is odd or
    even. Here, we are using it to see whether the conditions for being a leap year
    (which depend on divisibility) are met.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '**取余运算符**（%）返回除法操作的余数。例如，4 % 2 等于0，因为4可以被2整除。然而，由于4不能被3整除，4 % 3 不为0，它是1，因为我们可以将3放入4一次，剩下1（4
    - 3）。取余运算符可以用来检查一个数字是否能被另一个数字整除，通常用于判断数字是奇数还是偶数。这里，我们使用它来查看是否满足闰年的条件（这些条件依赖于能否被整除）。'
- en: 'Since we defined `year_colors` as a generator, Python will remember where we
    are in this function and resume when `next()` is called:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将`year_colors`定义为生成器，Python将记住我们在此函数中的位置，并在调用`next()`时恢复执行：
- en: '[PRE59]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Simpler generators can be written with **generator expressions**. For example,
    if we don''t care about the special case anymore, we can use the following:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 更简单的生成器可以通过**生成器表达式**来编写。例如，如果我们不再关心特殊情况，可以使用以下代码：
- en: '[PRE60]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Those not coming from Python might find it strange that our Boolean conditions
    in the previous code snippet are actually numbers (`year % 400` results in an
    integer). This is taking advantage of Python's *truthy*/*falsey* values; values
    that have zero value (such as the number `0`) or are empty (such as `[]` or `''`)
    are *falsey*. Therefore, while in the first generator, we wrote `year % 400 !=
    0` to show exactly what was going on, the more `year % 400`, since if there is
    no remainder (evaluates to 0), the statement will be evaluated as `False`, and
    vice versa. Obviously, we will have times where we must choose between readability
    and being Pythonic, but it's good to be aware of how to write Pythonic code, as
    it will often be more efficient.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不来自 Python 的人来说，我们之前代码片段中的布尔条件实际上是数字（`year % 400` 的结果是一个整数），这可能会让人感到奇怪。这是利用了
    Python 的*真值*/*假值*，即具有零值（例如数字`0`）或为空（如`[]`或`''`）的值被视为*假值*。因此，在第一个生成器中，我们写了 `year
    % 400 != 0` 来准确显示发生了什么，而 `year % 400` 的更多含义是：如果没有余数（即结果为 0），语句将被评估为 `False`，反之亦然。显然，在某些时候，我们必须在可读性和
    Pythonic 之间做出选择，但了解如何编写 Pythonic 代码是很重要的，因为它通常会更高效。
- en: Tip
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Run `import this` in Python to see **the Zen of Python**, which gives some ideas
    of what it means to be Pythonic.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中运行 `import this` 来查看**Python 之禅**，它给出了关于如何写 Pythonic 代码的一些思路。
- en: Now that we have some exposure to working with colors in `matplotlib`, let's
    consider another way we can make our data stand out. Depending on what we are
    plotting or how our visualization will be used (for example, in black and white),
    it might make sense to use textures along with, or instead of, colors.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了一些在 `matplotlib` 中使用颜色的方法，让我们考虑另一种让数据更突出的方法。根据我们要绘制的内容或可视化的使用场景（例如黑白打印），使用纹理与颜色一起或代替颜色可能会更有意义。
- en: Textures
  id: totrans-387
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 纹理
- en: 'In addition to customizing the colors used in our visualizations, `matplotlib`
    also makes it possible to include textures with a variety of plotting functions.
    This is achieved via the `hatch` argument, which `pandas` will pass down for us.
    Let''s create a bar plot of weekly volume traded in Facebook stock during Q4 2018
    with textured bars:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 除了定制我们在可视化中使用的颜色，`matplotlib` 还使得在各种绘图函数中包含纹理成为可能。这是通过 `hatch` 参数实现的，`pandas`
    会为我们传递该参数。让我们绘制一个 2018 年 Q4 Facebook 股票每周交易量的条形图，并使用纹理条形图：
- en: '[PRE61]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'With `hatch=''*''`, our bars are filled with stars. Notice that we also set
    the color for each of the bars, so there is a lot of flexibility here:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `hatch='*'`，我们的条形图将填充星号。请注意，我们还为每个条形图设置了颜色，因此这里有很多灵活性：
- en: '![Figure 6.40 – Using textured bars'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.40 – 使用纹理条形图'
- en: '](img/fig_6.40.jpg)'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/fig_6.40.jpg)'
- en: Figure 6.40 – Using textured bars
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.40 – 使用纹理条形图
- en: 'Textures can also be combined to make new patterns and repeated to intensify
    the effect. Let''s revisit the `plt.fill_between()` example where we colored the
    December section only (*Figure 6.33*). This time we will use textures to distinguish
    between each month, rather than only shading December; we will fill October with
    rings, November with slashes, and December with small dots:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 纹理还可以组合起来形成新的图案，并通过重复来增强效果。让我们回顾一下 `plt.fill_between()` 的示例，其中我们仅为 12 月部分上色（*图
    6.33*）。这次我们将使用纹理来区分每个月，而不仅仅是为 12 月添加阴影；我们将用环形纹理填充 10 月，用斜线填充 11 月，用小点填充 12 月：
- en: '[PRE62]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Using `hatch=''o''` would yield thin rings, so we used `''oo''` to get thicker
    rings for October. For November, we wanted a crisscross pattern, so we combined
    two forward slashes and two backslashes (we actually have four backslashes because
    they must be escaped). To achieve the small dots for December, we used three periods—the
    more we add, the denser the texture becomes:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `hatch='o'` 会生成细环，因此我们使用 `'oo'` 来为 10 月生成更粗的环形纹理。对于 11 月，我们希望得到交叉图案，因此我们结合了两个正斜杠和两个反斜杠（我们实际上用了四个反斜杠，因为它们需要转义）。为了在
    12 月实现小点纹理，我们使用了三个句点——添加得越多，纹理就越密集：
- en: '![Figure 6.41 – Combining textures'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.41 – 结合纹理'
- en: '](img/fig_6.41.jpg)'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/fig_6.41.jpg)'
- en: Figure 6.41 – Combining textures
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.41 – 结合纹理
- en: This concludes our discussion of plot customizations. By no means was this meant
    to be complete, so be sure to explore the `matplotlib` API for more.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们对图表定制化的讨论总结。这并非完整的讨论，因此请确保探索 `matplotlib` API，了解更多内容。
- en: Summary
  id: totrans-401
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Whew, that was a lot! We learned how to create impressive and customized visualizations
    using `matplotlib`, `pandas`, and `seaborn`. We discussed how we can use `seaborn`
    for additional plotting types and cleaner versions of some familiar ones. Now
    we can easily make our own colormaps, annotate our plots, add reference lines
    and shaded regions, finesse the axes/legends/titles, and control most aspects
    of how our visualizations will appear. We also got a taste of working with `itertools`
    and creating our own generators.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 呼，真多啊！我们学习了如何使用`matplotlib`、`pandas`和`seaborn`创建令人印象深刻且自定义的可视化图表。我们讨论了如何使用`seaborn`绘制其他类型的图表，并清晰地展示一些常见图表。现在，我们可以轻松地创建自己的颜色映射、标注图表、添加参考线和阴影区域、调整坐标轴/图例/标题，并控制可视化外观的大部分方面。我们还体验了使用`itertools`并创建我们自己的生成器。
- en: Take some time to practice what we've discussed with the end-of-chapter exercises.
    In the next chapter, we will apply all that we have learned to finance, as we
    build our own Python package and compare bitcoin to the stock market.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 花些时间练习我们讨论的内容，完成章节末的练习。在下一章中，我们将把所学的知识应用到金融领域，创建自己的Python包，并将比特币与股票市场进行比较。
- en: Exercises
  id: totrans-404
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'Create the following visualizations using what we have learned so far in this
    book and the data from this chapter. Be sure to add titles, axis labels, and legends
    (where appropriate) to the plots:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们迄今为止在本书中学到的知识和本章的数据，创建以下可视化图表。确保为图表添加标题、轴标签和图例（适当时）。
- en: Using `seaborn`, create a heatmap to visualize the correlation coefficients
    between earthquake magnitude and whether there was a tsunami for earthquakes measured
    with the `mb` magnitude type.
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`seaborn`创建热图，显示地震震级与是否发生海啸之间的相关系数，地震测量使用`mb`震级类型。
- en: Create a box plot of Facebook volume traded and closing prices, and draw reference
    lines for the bounds of a Tukey fence with a multiplier of 1.5\. The bounds will
    be at *Q*1 *− 1.5 × IQR* and *Q*3 *+ 1.5 × IQR*. Be sure to use the `quantile()`
    method on the data to make this easier. (Pick whichever orientation you prefer
    for the plot, but make sure to use subplots.)
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个Facebook交易量和收盘价格的箱线图，并绘制Tukey围栏范围的参考线，乘数为1.5。边界将位于*Q*1 *− 1.5 × IQR*和*Q*3
    *+ 1.5 × IQR*。确保使用数据的`quantile()`方法以简化这一过程。（选择你喜欢的图表方向，但确保使用子图。）
- en: Plot the evolution of cumulative COVID-19 cases worldwide, and add a dashed
    vertical line on the date that it surpassed 1 million. Be sure to format the tick
    labels on the *y*-axis accordingly.
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制全球累计COVID-19病例的变化趋势，并在病例超过100万的日期上添加一条虚线。确保*y*轴的刻度标签相应地格式化。
- en: Use `axvspan()` to shade a rectangle from `'2018-07-25'` to `'2018-07-31'`,
    which marks the large decline in Facebook price on a line plot of the closing
    price.
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`axvspan()`在收盘价的折线图中，从`'2018-07-25'`到`'2018-07-31'`标记Facebook价格的大幅下降区域。
- en: 'Using the Facebook stock price data, annotate the following three events on
    a line plot of the closing price:'
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Facebook股价数据，在收盘价的折线图上标注以下三个事件：
- en: a) **Disappointing user growth announced after close** on July 25, 2018
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a) **2018年7月25日收盘后宣布用户增长令人失望**
- en: b) **Cambridge Analytica story breaks** on March 19, 2018 (when it affected
    the market)
  id: totrans-412
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b) **剑桥分析公司丑闻爆发** 2018年3月19日（当时影响了市场）
- en: c) **FTC launches investigation** on March 20, 2018
  id: totrans-413
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: c) **FTC启动调查** 2018年3月20日
- en: Modify the `reg_resid_plots()` function to use a `matplotlib` colormap instead
    of cycling between two colors. Remember, for this use case, we should pick a qualitative
    colormap or make our own.
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`reg_resid_plots()`函数，使用`matplotlib`的颜色映射，而不是在两种颜色之间循环。记住，在这种情况下，我们应该选择定性颜色映射或创建自己的颜色映射。
- en: Further reading
  id: totrans-415
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Check out the following resources for more information on the topics covered
    in this chapter:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下资源，了解更多关于本章所涉及主题的信息：
- en: '*Choosing Colormaps*: [https://matplotlib.org/tutorials/colors/colormaps.html](https://matplotlib.org/tutorials/colors/colormaps.html)'
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*选择颜色映射（Colormaps）*: [https://matplotlib.org/tutorials/colors/colormaps.html](https://matplotlib.org/tutorials/colors/colormaps.html)'
- en: '*Controlling figure aesthetics (seaborn)*: [https://seaborn.pydata.org/tutorial/aesthetics.html](https://seaborn.pydata.org/tutorial/aesthetics.html)'
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*控制图形美学（seaborn）*: [https://seaborn.pydata.org/tutorial/aesthetics.html](https://seaborn.pydata.org/tutorial/aesthetics.html)'
- en: '*Customizing Matplotlib with style sheets and rcParams*: [https://matplotlib.org/tutorials/introductory/customizing.html](https://matplotlib.org/tutorials/introductory/customizing.html)'
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用样式表和rcParams自定义Matplotlib*: [https://matplotlib.org/tutorials/introductory/customizing.html](https://matplotlib.org/tutorials/introductory/customizing.html)'
- en: '*Format String Syntax*: [https://docs.python.org/3/library/string.html#format-string-syntax](https://docs.python.org/3/library/string.html#format-string-syntax)'
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*格式化字符串语法*： [https://docs.python.org/3/library/string.html#format-string-syntax](https://docs.python.org/3/library/string.html#format-string-syntax)'
- en: '*Generator Expressions (PEP 289)*: [https://www.python.org/dev/peps/pep-0289/](https://www.python.org/dev/peps/pep-0289/)'
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*生成器表达式（PEP 289）*： [https://www.python.org/dev/peps/pep-0289/](https://www.python.org/dev/peps/pep-0289/)'
- en: '*Information Dashboard Design: Displaying Data for At-a-Glance Monitoring,
    Second Edition, by Stephen Few*: [https://www.amazon.com/Information-Dashboard-Design-At-Glance/dp/1938377001/](https://www.amazon.com/Information-Dashboard-Design-At-Glance/dp/1938377001/)'
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*信息仪表板设计：用于一目了然监控的数据展示（第二版），Stephen Few 著*： [https://www.amazon.com/Information-Dashboard-Design-At-Glance/dp/1938377001/](https://www.amazon.com/Information-Dashboard-Design-At-Glance/dp/1938377001/)'
- en: '*Matplotlib Named Colors*: [https://matplotlib.org/examples/color/named_colors.html](https://matplotlib.org/examples/color/named_colors.html)'
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Matplotlib 命名颜色*： [https://matplotlib.org/examples/color/named_colors.html](https://matplotlib.org/examples/color/named_colors.html)'
- en: '*Multiple assignment and tuple unpacking improve Python code readability*:
    [https://treyhunner.com/2018/03/tuple-unpacking-improves-python-code-readability/](https://treyhunner.com/2018/03/tuple-unpacking-improves-python-code-readability/)'
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*多重赋值和元组拆包提高 Python 代码可读性*： [https://treyhunner.com/2018/03/tuple-unpacking-improves-python-code-readability/](https://treyhunner.com/2018/03/tuple-unpacking-improves-python-code-readability/)'
- en: '*Python: range is not an iterator!*: [https://treyhunner.com/2018/02/python-range-is-not-an-iterator/](https://treyhunner.com/2018/02/python-range-is-not-an-iterator/)'
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Python: range 不是一个迭代器!*： [https://treyhunner.com/2018/02/python-range-is-not-an-iterator/](https://treyhunner.com/2018/02/python-range-is-not-an-iterator/)'
- en: '*Python zip() function*: [https://www.journaldev.com/15891/python-zip-function](https://www.journaldev.com/15891/python-zip-function)'
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Python zip() 函数*： [https://www.journaldev.com/15891/python-zip-function](https://www.journaldev.com/15891/python-zip-function)'
- en: '*Seaborn API reference*: [https://seaborn.pydata.org/api.html](https://seaborn.pydata.org/api.html)'
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Seaborn API 参考*： [https://seaborn.pydata.org/api.html](https://seaborn.pydata.org/api.html)'
- en: '*Show Me the Numbers: Designing Tables and Graphs to Enlighten, by Stephen
    Few*: [https://www.amazon.com/gp/product/0970601972/](https://www.amazon.com/gp/product/0970601972/)'
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*给我看数字：设计表格和图表以便一目了然，Stephen Few 著*： [https://www.amazon.com/gp/product/0970601972/](https://www.amazon.com/gp/product/0970601972/)'
- en: '*Style sheets reference (Matplotlib)*: [https://matplotlib.org/gallery/style_sheets/style_sheets_reference.html](https://matplotlib.org/gallery/style_sheets/style_sheets_reference.html)'
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*样式表参考（Matplotlib）*： [https://matplotlib.org/gallery/style_sheets/style_sheets_reference.html](https://matplotlib.org/gallery/style_sheets/style_sheets_reference.html)'
- en: '*Support and Resistance Basics*: [https://www.investopedia.com/trading/support-and-resistance-basics/](https://www.investopedia.com/trading/support-and-resistance-basics/)'
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*支撑位与阻力位基础知识*： [https://www.investopedia.com/trading/support-and-resistance-basics/](https://www.investopedia.com/trading/support-and-resistance-basics/)'
- en: '*The Iterator Protocol: How "For Loops" Work in Python*: [https://treyhunner.com/2016/12/python-iterator-protocol-how-for-loops-work/](https://treyhunner.com/2016/12/python-iterator-protocol-how-for-loops-work/)'
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*迭代器协议：Python 中 "for 循环" 是如何工作的*： [https://treyhunner.com/2016/12/python-iterator-protocol-how-for-loops-work/](https://treyhunner.com/2016/12/python-iterator-protocol-how-for-loops-work/)'
- en: '*The Visual Display of Quantitative Information, by Edward R. Tufte*: [https://www.amazon.com/Visual-Display-Quantitative-Information/dp/1930824130](https://www.amazon.com/Visual-Display-Quantitative-Information/dp/1930824130)'
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*定量信息的视觉展示，Edward R. Tufte 著*： [https://www.amazon.com/Visual-Display-Quantitative-Information/dp/1930824130](https://www.amazon.com/Visual-Display-Quantitative-Information/dp/1930824130)'
- en: '*Tick formatters*: [https://matplotlib.org/gallery/ticks_and_spines/tick-formatters.html](https://matplotlib.org/gallery/ticks_and_spines/tick-formatters.html)'
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*刻度格式化器*： [https://matplotlib.org/gallery/ticks_and_spines/tick-formatters.html](https://matplotlib.org/gallery/ticks_and_spines/tick-formatters.html)'
- en: '*What does Pythonic mean?*: [https://stackoverflow.com/questions/25011078/what-does-pythonic-mean](https://stackoverflow.com/questions/25011078/what-does-pythonic-mean)'
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*什么是 Pythonic?*： [https://stackoverflow.com/questions/25011078/what-does-pythonic-mean](https://stackoverflow.com/questions/25011078/what-does-pythonic-mean)'
