- en: Chapter 1. Fundamentals of the Python Language for ArcGIS
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 1 章：ArcGIS 的 Python 语言基础
- en: Python supports many of the programming constructs found in other languages.
    In this chapter, we'll cover many of the basic language constructs found in Python.
    Initially, we'll cover how to create new Python scripts and edit existing scripts.
    From there, we'll delve into language features, such as adding comments to your
    code, creating and assigning data to variables, and built-in variable typing with
    Python, which makes coding with Python easy and compact.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Python 支持许多在其他语言中找到的编程结构。在本章中，我们将介绍 Python 中许多基本语言结构。最初，我们将介绍如何创建新的 Python 脚本和编辑现有脚本。从那里，我们将深入研究语言特性，例如在您的代码中添加注释，创建和分配数据到变量，以及
    Python 的内置变量类型，这使得使用 Python 编码变得简单且紧凑。
- en: Next, we'll look at the various built-in data types that Python offers, such
    as strings, numbers, lists, and dictionaries. Classes and objects are a fundamental
    concept in object-oriented programming and in the Python language. We'll introduce
    you to these complex data structures, which you'll use extensively when you write
    geoprocessing scripts with ArcGIS.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将查看 Python 提供的各种内置数据类型，例如字符串、数字、列表和字典。类和对象是面向对象编程和 Python 语言中的基本概念。我们将向您介绍这些复杂的数据结构，您将在使用
    ArcGIS 编写地理处理脚本时广泛使用它们。
- en: 'In addition to this, we''ll cover statements, including decision support and
    looping structures to make decisions in your code, and/or looping through a code
    block multiple times along with the `with` statement, which is used extensively
    with the `cursor` objects from the ArcPy data access module that are used to insert,
    search, and update data. Finally, you''ll learn how to access modules that provide
    additional functionality to the Python language. By the end of this chapter, you
    will have learned the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些，我们还将涵盖语句，包括决策支持和循环结构，以便在您的代码中做出决策，以及/或使用 `with` 语句多次遍历代码块，`with` 语句与 ArcPy
    数据访问模块中的 `cursor` 对象广泛使用，这些对象用于插入、搜索和更新数据。最后，您将学习如何访问为 Python 语言提供额外功能的模块。到本章结束时，您将学习以下内容：
- en: How to create and edit new Python scripts in IDLE
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在 IDLE 中创建和编辑新的 Python 脚本
- en: How to create and edit scripts in the ArcGIS Python window
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在 ArcGIS Python 窗口中创建和编辑脚本
- en: The language features of Python
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 的语言特性
- en: Comments and data variables
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注释和数据变量
- en: Built-in data types (strings, numbers, lists, and dictionaries)
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内置数据类型（字符串、数字、列表和字典）
- en: Complex data structures
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复杂数据结构
- en: Looping structures
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 循环结构
- en: Additional Python functionalities
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 额外的 Python 功能
- en: Using IDLE for Python script development
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 IDLE 进行 Python 脚本开发
- en: As mentioned in the preface, when you install ArcGIS for Desktop, Python is
    also installed along with a tool called **IDLE** that allows you to write your
    own code. IDLE stands for **Integrated DeveLopment Environment**. Since it is
    available with every ArcGIS for Desktop installation, we'll use IDLE for many
    of the scripts that we write in this book along with the Python window embedded
    in ArcGIS for Desktop. As you progress as a programmer, you may find other development
    tools that you prefer over IDLE. There are many other development environments
    that you may want to consider, including PyScripter, Wingware, Komodo, and others.
    The development environment you choose is really a matter of preference. You can
    write your code in any of these tools.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如前言所述，当您安装 ArcGIS for Desktop 时，Python 也会安装，并附带一个名为 **IDLE** 的工具，允许您编写自己的代码。IDLE
    代表 **Integrated DeveLopment Environment**。由于它与每个 ArcGIS for Desktop 安装一起提供，因此我们将使用
    IDLE 来编写本书中的许多脚本，以及 ArcGIS for Desktop 中嵌入的 Python 窗口。随着您作为程序员的进步，您可能会发现比 IDLE
    更喜欢的其他开发工具。还有许多其他开发环境可以考虑，包括 PyScripter、Wingware、Komodo 等。您选择哪种开发环境完全是个人喜好问题。您可以使用这些工具中的任何一个来编写代码。
- en: The Python shell window
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python 命令行窗口
- en: To start the IDLE development environment for Python, you can navigate to **Start**
    | **All Programs** | **ArcGIS** | **Python 2.7** | **IDLE**. Please note that
    the version of Python installed with ArcGIS will differ depending upon the ArcGIS
    version that you have installed. For example, ArcGIS 10.3 uses Python 2.7, whereas
    ArcGIS 10.0 uses version 2.6 of Python.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动 Python 开发环境，您可以导航到 **开始** | **所有程序** | **ArcGIS** | **Python 2.7** | **IDLE**。请注意，ArcGIS
    安装的 Python 版本将根据您安装的 ArcGIS 版本而有所不同。例如，ArcGIS 10.3 使用 Python 2.7，而 ArcGIS 10.0
    使用 Python 2.6 版本。
- en: 'A Python shell window similar to this screenshot will be displayed:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 将显示与以下截图类似的 Python 命令行窗口：
- en: '![The Python shell window](img/B04314_01_1.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![Python 外壳窗口](img/B04314_01_1.jpg)'
- en: The Python shell window is used for output and error messages generated by scripts.
    A common mistake for beginners is to assume that the geoprocessing scripts will
    be written in this shell window. This is not the case. You will need to create
    a separate code window to hold your scripts.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Python 外壳窗口用于显示脚本生成的输出和错误消息。初学者常见的错误是假设地理处理脚本将写入此外壳窗口。这不是事实。您需要创建一个单独的代码窗口来保存您的脚本。
- en: Although the shell window isn't used to write entire scripts, it can be used
    to interactively write code and get immediate feedback. ArcGIS has a built-in
    Python shell window that you can use in a similar way. We'll examine the ArcGIS
    Python window in the next chapter.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然外壳窗口不用于编写整个脚本，但它可以用于交互式编写代码并立即获得反馈。ArcGIS 有一个内置的 Python 外壳窗口，您可以使用类似的方式使用它。我们将在下一章中检查
    ArcGIS Python 窗口。
- en: The Python script window
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python 脚本窗口
- en: 'Your scripts will be written in IDLE inside a separate window known as the
    **Python script window**. To create a new code window, navigate to **File** |
    **New Window** from the IDLE shell window. A window similar to this will be displayed:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 您的脚本将写入 IDLE 中的单独窗口，称为 **Python 脚本窗口**。要创建新的代码窗口，从 IDLE 壳窗口导航到 **文件** | **新建窗口**。将显示类似以下窗口：
- en: '![The Python script window](img/B04314_01_2.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![Python 脚本窗口](img/B04314_01_2.jpg)'
- en: Your Python scripts will be written inside this new code window. Each script
    will need to be saved to a local or network drive. By default, scripts are saved
    with a `.py` file extension to signify that it is a Python script.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 您的 Python 脚本将写入这个新的代码窗口。每个脚本都需要保存到本地或网络驱动器。默认情况下，脚本以 `.py` 文件扩展名保存，以表示它是一个 Python
    脚本。
- en: Editing existing Python scripts
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编辑现有的 Python 脚本
- en: 'Existing Python script files can be opened by selecting **File** | **Open**
    from the IDLE shell window. Additionally, a Python script can be opened from Windows
    Explorer by right-clicking on the file and selecting **Edit with IDLE**, which
    brings up a new shell window along with the script loaded in the Python script
    editor. You can see an example of this in the following screenshot:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过从 IDLE 壳窗口选择 **文件** | **打开** 来打开现有的 Python 脚本文件。此外，您还可以通过在 Windows 资源管理器中右键单击文件并选择
    **使用 IDLE 编辑** 来打开 Python 脚本，这将打开一个新的外壳窗口以及加载到 Python 脚本编辑器中的脚本。您可以在下面的屏幕截图中看到示例：
- en: '![Editing existing Python scripts](img/B04314_01_3.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![编辑现有的 Python 脚本](img/B04314_01_3.jpg)'
- en: 'In this instance, we have loaded the `ListFeatureClasses.py` script with IDLE.
    The code is loaded inside the script window:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们已使用 IDLE 加载了 `ListFeatureClasses.py` 脚本。代码加载在脚本窗口中：
- en: '![Editing existing Python scripts](img/B04314_01_4.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![编辑现有的 Python 脚本](img/B04314_01_4.jpg)'
- en: Now that the code window is open, you can begin writing or editing code. You
    can also perform some basic script debugging with the IDLE interface. Debugging
    is the process of identifying and fixing errors in your code.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在代码窗口已打开，您可以从头开始编写或编辑代码。您还可以使用 IDLE 界面进行一些基本的脚本调试。调试是识别和修复代码中错误的过程。
- en: Executing scripts from IDLE
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从 IDLE 执行脚本
- en: Once you've written a geoprocessing script in the IDLE code window or opened
    an existing script, you can execute the code from the interface. IDLE does provide
    functionality that allows you to check the syntax of your code before running
    the script. In the code window, navigate to **Run** | **Check Module** to perform
    a syntax check of your code.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您在 IDLE 代码窗口中编写了地理处理脚本或打开了现有脚本，您就可以从界面中执行代码。IDLE 提供了允许您在运行脚本之前检查代码语法的功能。在代码窗口中，导航到
    **运行** | **检查模块** 来执行代码的语法检查。
- en: Any syntax errors will be displayed in the shell window. If there aren't any
    syntax errors, you should just see the prompt in the shell window. While the IDLE
    interface can be used to check for syntax errors, it doesn't provide a way to
    check for logical errors in your code nor does it provide more advanced debugging
    tools found in other development environments, such as PyScripter or Wingware.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 任何语法错误都会在外壳窗口中显示。如果没有语法错误，您应该只看到外壳窗口中的提示。虽然 IDLE 界面可以用来检查语法错误，但它不提供检查代码中逻辑错误的方法，也不提供其他开发环境中找到的更高级的调试工具，例如
    PyScripter 或 Wingware。
- en: 'Once you''re satisfied that no syntax errors exist in your code, you can run
    the script. Navigate to **Run** | **Run Module** to execute the script:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您确认代码中没有语法错误，您就可以运行脚本。导航到 **运行** | **运行模块** 来执行脚本：
- en: '![Executing scripts from IDLE](img/B04314_01_7.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![从 IDLE 执行脚本](img/B04314_01_7.jpg)'
- en: Any error messages will be written to the shell window along with the output
    from the `print` statements and system-generated messages. The `print` statement
    simply outputs text to the shell window. It is often used to update the status
    of a running script or to debug the code.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 任何错误信息都将写入壳窗口，与 `print` 语句的输出和系统生成的消息一起。`print` 语句只是将文本输出到壳窗口。它通常用于更新正在运行的脚本的状态或用于调试代码。
- en: Using the ArcGIS Python window
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 ArcGIS Python 窗口
- en: In this recipe, you'll learn how to use the ArcGIS Python window. In the last
    section, you learned how to use the IDLE development environment for Python, so
    this section will give you an alternative to write your geoprocessing scripts.
    Either development environment can be used, but it is common for people to start
    writing scripts with the ArcGIS for Desktop Python window and then move on to
    IDLE or another development environment when scripts become more complex.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，您将学习如何使用 ArcGIS Python 窗口。在上一个部分，您学习了如何使用 Python 的 IDLE 开发环境，因此本部分将为您提供另一种编写地理处理脚本的替代方法。两种开发环境都可以使用，但人们通常会在
    ArcGIS for Desktop Python 窗口中开始编写脚本，然后在脚本变得复杂时转向 IDLE 或其他开发环境。
- en: The ArcGIS Python window
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ArcGIS Python 窗口
- en: The ArcGIS Python window is an embedded, interactive Python window in ArcGIS
    for Desktop 10.x. It is newer and ideal for testing small blocks of code, learning
    Python basics, building quick and easy workflows, and executing geoprocessing
    tools. For new programmers, the ArcGIS Python window is a great place to start!
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: ArcGIS Python 窗口是 ArcGIS for Desktop 10.x 中嵌入的交互式 Python 窗口。它较新，非常适合测试小块代码、学习
    Python 基础知识、构建快速简便的工作流程以及执行地理处理工具。对于新手程序员来说，ArcGIS Python 窗口是一个很好的起点！
- en: The ArcGIS Python window has a number of capabilities in addition to being the
    location to write your code. You can save the content of the window to a Python
    script file on a disk or load an existing Python script into the window. The window
    can be either pinned or floating. While floating, the window can be expanded or
    contracted as you wish. The window can also be pinned to various parts of the
    ArcGIS display. You can also format the font and text colors displayed in the
    window by right-clicking on the window and selecting **Format**.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 除了是编写代码的位置之外，ArcGIS Python 窗口还具有许多功能。您可以将窗口的内容保存到磁盘上的 Python 脚本文件中，或者将现有的 Python
    脚本加载到窗口中。窗口可以是固定的或浮动的。在浮动状态下，窗口可以按您的意愿扩展或收缩。窗口还可以固定在 ArcGIS 显示的各个部分。您还可以通过右键单击窗口并选择
    **格式** 来格式化窗口中显示的字体和文本颜色。
- en: Displaying the ArcGIS Python window
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示 ArcGIS Python 窗口
- en: 'The Python window can be opened by clicking on the Python window button on
    the Standard ArcGIS for Desktop toolbar, as seen in the screenshot. This is a
    floating window, so you can resize as needed and also dock it at various places
    on the **ArcMap** interface:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过点击标准 ArcGIS for Desktop 工具栏上的 Python 窗口按钮来打开 Python 窗口，如图所示。这是一个浮动窗口，因此您可以按需调整大小，也可以将其停靠在
    **ArcMap** 界面的各个位置：
- en: '![Displaying the ArcGIS Python window](img/B04314_01_8.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![显示 ArcGIS Python 窗口](img/B04314_01_8.jpg)'
- en: The Python window is essentially a shell window that allows you to type in statements
    one line at a time, just after the `>>>` line input characters. On the right-hand
    side of the divider, you will find a help window.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Python 窗口本质上是一个允许您逐行输入语句的壳窗口，就在 `>>>` 行输入字符之后。在分隔符的右侧，您将找到一个帮助窗口。
- en: 'You can load an existing script by right-clicking inside the Python window
    and selecting **Load…** from the menu. You can also format the font and text colors
    displayed in the window by right-clicking on the window and selecting **Format**.
    You will be provided with White and Black themes; you can select fonts and colors
    individually:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在 Python 窗口内部右键单击并从菜单中选择 **加载…** 来加载现有的脚本。您还可以通过右键单击窗口并选择 **格式** 来格式化窗口中显示的字体和文本颜色。您将提供白色和黑色主题；您可以单独选择字体和颜色：
- en: '![Displaying the ArcGIS Python window](img/B04314_01_09.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![显示 ArcGIS Python 窗口](img/B04314_01_09.jpg)'
- en: 'Click on the **Set Black Theme** button to see an example. If you spend a lot
    of time writing code, you may find that darker themes are easier on your eyes:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 **设置黑色主题** 按钮查看示例。如果您花很多时间编写代码，您可能会发现较暗的主题对眼睛更容易接受：
- en: '![Displaying the ArcGIS Python window](img/B04314_01_10.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![显示 ArcGIS Python 窗口](img/B04314_01_10.jpg)'
- en: 'The ArcGIS Python window also provides code-completion functionalities that
    make your life as a programmer much easier. You can try this functionality by
    opening the ArcGIS Python Window and typing `arcpy` followed by a dot on the first
    line. ArcPy is a module-oriented package, which means that you access the properties
    and methods of an object using a dot notation. Notice that a drop-down list of
    available items is provided. These are the tools, functions, classes, and extensions
    that are available for this particular object. All objects have their own associated
    items, so the list of items presented will differ depending on the object that
    you have currently selected:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: ArcGIS Python 窗口还提供了代码自动补全功能，这使程序员的编程生活变得更加容易。你可以通过打开 ArcGIS Python 窗口，在第一行输入
    `arcpy` 后跟一个点来尝试这个功能。ArcPy 是一个面向模块的包，这意味着你使用点符号来访问对象的属性和方法。注意，提供了一个可下拉的物品列表。这些是可用于特定对象的工具、函数、类和扩展。所有对象都有它们自己的相关物品，因此展示的物品列表将根据你当前选择的对象而有所不同：
- en: '![Displaying the ArcGIS Python window](img/B04314_01_11.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![显示 ArcGIS Python 窗口](img/B04314_01_11.jpg)'
- en: 'This is an auto-filtering list, so as you begin typing the name of the tool,
    function, class, or extension, the list will be filtered according to what you
    have typed:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个自动过滤的列表，所以当你开始输入工具、函数、类或扩展的名称时，列表将根据你输入的内容进行过滤：
- en: '![Displaying the ArcGIS Python window](img/B04314_01_12.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![显示 ArcGIS Python 窗口](img/B04314_01_12.jpg)'
- en: You can choose to have the Python window auto-complete the text for you by selecting
    an item from the list using your mouse or by using the arrow keys to highlight
    your choice, and then using the *Tab* key to enter the command. This autocompletion
    feature makes you a faster, more efficient programmer. Not only is it easy to
    use, but it also dramatically cuts down the number of typos in your code.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以选择让 Python 窗口自动为你补全文本，通过使用鼠标从列表中选择一个项目，或者使用箭头键突出显示你的选择，然后使用 *Tab* 键输入命令。这个自动补全功能使你成为一个更快、更高效的程序员。这不仅易于使用，而且还能显著减少你代码中的错误。 '
- en: Python language fundamentals
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python 语言基础
- en: To effectively write geoprocessing scripts for ArcGIS, you are going to need
    to understand at least the basic constructs of the Python language. Python is
    easier to learn than most other programming languages, but it does take some time
    to learn and effectively use it. This section will teach you how to create variables,
    assign various data types to variables, understand the different types of data
    that can be assigned to variables, use different types of statements, use objects,
    read and write files, and import third-party Python modules.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有效地编写 ArcGIS 的地理处理脚本，你需要至少了解 Python 语言的基本结构。Python 语言比大多数其他编程语言更容易学习，但学习并有效使用它仍需要一些时间。本节将教会你如何创建变量，将各种数据类型分配给变量，理解可以分配给变量的不同类型的数据，使用不同类型的语句，使用对象，读写文件，以及导入第三方
    Python 模块。
- en: Commenting code
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注释代码
- en: 'Python scripts should follow a common structure. It is a commonly accepted
    practice that the beginning of each script should serve as documentation, detailing
    the script name, author, and a general description of the processing provided
    by the script. This introductory documentation will help you and other programmers
    in the future to quickly scan the details and purpose of a script. This documentation
    is accomplished in Python through the use of comments. Comments are lines of code
    that you add to your script that serve as a documentation of what functionality
    the script provides. These lines of code begin with a single pound sign (`#`)
    or a double pound sign (`##`), and are followed by whatever text you need to document
    the code. The Python interpreter does not execute these lines of code. They are
    simply used to document your code. In the next screenshot, the commented lines
    of code are displayed with a single pound sign that prefixes the line of code.
    You should also strive to include comments throughout your script to describe
    important sections of your script. This will be useful to you (or another programmer)
    when the time comes to update your scripts:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Python 脚本应遵循一个常见的结构。通常的做法是，每个脚本的开始部分应作为文档，详细说明脚本名称、作者以及脚本提供的处理功能的一般描述。这份介绍性文档将帮助您和其他未来的程序员快速扫描脚本的细节和目的。这份文档通过在
    Python 中使用注释来完成。注释是您添加到脚本中的代码行，用作脚本提供的功能的文档。这些代码行以单个井号（`#`）或双井号（`##`）开头，后面跟着您需要用来记录代码的任何文本。Python
    解释器不会执行这些代码行。它们只是用来记录您的代码。在下一张屏幕截图中，带有单个井号的注释代码行显示了代码行。您还应该努力在脚本中包含注释，以描述脚本的重要部分。当您需要更新脚本时，这对您（或另一位程序员）将非常有用：
- en: '![Commenting code](img/B04314_01_13.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![注释代码](img/B04314_01_13.jpg)'
- en: Tip
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Downloading the example code**'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.PacktPub.com](http://www.PacktPub.com). If you
    have purchased this book elsewhere, you can visit [http://www.PacktPub.com/support](http://www.PacktPub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从您在 [http://www.PacktPub.com](http://www.PacktPub.com) 的账户中下载您购买的所有 Packt
    书籍的示例代码文件。如果您在其他地方购买了这本书，您可以访问 [http://www.PacktPub.com/support](http://www.PacktPub.com/support)
    并注册，以便将文件直接通过电子邮件发送给您。
- en: Importing modules
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导入模块
- en: 'Although Python includes many built-in functions, you will frequently need
    to access specific bundles of functionality, which are stored in external modules.
    For instance, the `Math` module stores specific functions related to processing
    numeric values and the `R` module provides statistical analysis functions. We
    haven''t discussed the topic of functions yet, but basically functions are a named
    block of code that execute when called. Modules are imported through the use of
    the `import` statement. When writing geoprocessing scripts with ArcGIS, you will
    always need to import the `arcpy` module, which is the Python package that is
    used to access GIS tools and functions provided by ArcGIS. The `import` statements
    will be the first lines of code (not including comments) in your scripts. The
    following line of code imports the `arcpy` and `os` modules. The Python `os` module
    provides a way of interfacing with the underlying operating system:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Python 包含许多内置函数，但您将经常需要访问存储在外部模块中的特定功能包。例如，`Math` 模块存储与处理数值相关的特定函数，而 `R`
    模块提供统计分析函数。我们尚未讨论函数的话题，但基本上函数是在调用时执行的命名代码块。模块通过使用 `import` 语句导入。当使用 ArcGIS 编写地理处理脚本时，您始终需要导入
    `arcpy` 模块，这是用于访问 ArcGIS 提供的 GIS 工具和函数的 Python 包。`import` 语句将是您脚本中的第一行代码（不包括注释）。以下代码行导入了
    `arcpy` 和 `os` 模块。Python 的 `os` 模块提供了一种与底层操作系统的接口方式：
- en: '[PRE0]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Variables
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量
- en: 'At a high level, you can think of a variable as an area in your computer''s
    memory that is reserved to store values while the script is running. Variables
    that you define in Python are given a name and a value. The values assigned to
    variables can then be accessed by different areas of your script as needed, simply
    by referring to the variable name. For example, you might create a variable that
    contains a feature class name, which is then used by the **Buffer** tool to create
    a new output dataset. To create a variable, simply give it a name followed by
    the assignment operator, which is just an equals sign (=), and then a value:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 从高层次来看，你可以将变量视为在脚本运行期间为存储值而保留的计算机内存区域。在 Python 中定义的变量被赋予一个名称和一个值。分配给变量的值可以通过引用变量名来访问脚本的不同部分。例如，你可能创建一个包含要素类名称的变量，然后由
    **Buffer** 工具使用该变量创建新的输出数据集。要创建变量，只需给它一个名称，后跟赋值运算符（即等号 `=`），然后是一个值：
- en: '[PRE1]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The following table illustrates the variable name and value assigned to the
    variable using the preceding code example:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格展示了使用前面的代码示例中变量名和分配给变量的值：
- en: '| Variable name | Variable value |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| 变量名 | 变量值 |'
- en: '| --- | --- |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `fcParcels` | `Parcels` |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `fcParcels` | `Parcels` |'
- en: '| `fcStreets` | `Streets` |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `fcStreets` | `Streets` |'
- en: 'There are certain naming rules that you must follow when creating variables,
    including the following:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建变量时，你必须遵循某些命名规则，包括以下内容：
- en: It can contain letters, numbers, and underscores
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以包含字母、数字和下划线
- en: The first character must be a letter
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个字符必须是一个字母
- en: No special characters can be used in a variable name other an underscore
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量名中除了下划线外不能使用特殊字符
- en: Python keywords and spaces are not permitted
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 关键字和空格是不允许的
- en: There are a few dozen Python keywords that must be avoided, including `class`,
    `if`, `for`, `while`, and others. These keywords are typically highlighted in
    a different font color from other Python statements.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些 Python 关键字必须避免，包括 `class`、`if`、`for`、`while` 以及其他一些。这些关键字通常与其他 Python 语句使用不同的字体颜色突出显示。
- en: 'Here are some examples of legal variable names in Python:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些 Python 中合法变量名的示例：
- en: '`featureClassParcel`'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`featureClassParcel`'
- en: '`fieldPopulation`'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fieldPopulation`'
- en: '`field2`'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`field2`'
- en: '`ssn`'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ssn`'
- en: '`my_name`'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`my_name`'
- en: 'These are some examples of illegal variable names in Python:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是 Python 中非法变量名的示例：
- en: '`class` (Python keyword)'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`class`（Python 关键字）'
- en: '`return` (Python keyword)'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`return`（Python 关键字）'
- en: '`$featureClass` (illegal character, must start with a letter)'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$featureClass`（非法字符，必须以字母开头）'
- en: '`2fields` (must start with a letter)'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2fields`（必须以字母开头）'
- en: '`parcels&Streets` (illegal character)'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parcels&Streets`（非法字符）'
- en: 'Python is a case-sensitive language, so pay particular attention to the capitalization
    and naming of variables in your scripts. Case-sensitivity issues are probably
    the most common source of errors for new Python programmers, so always consider
    this as a possibility when you encounter errors in your code. Let''s look at an
    example. The following is a list of three variables; note that although each variable
    name is the same, the casing is different, resulting in three distinct variables:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Python 是一种区分大小写的语言，因此在脚本中注意变量的大小写和命名非常重要。区分大小写的问题可能是新 Python 程序员最常见的错误来源，因此在遇到代码中的错误时，始终考虑这一点作为可能性。让我们看一个例子。以下是一个包含三个变量的列表；请注意，尽管每个变量名相同，但大小写不同，因此产生了三个不同的变量：
- en: '`mapsize = "22x34"`'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mapsize = "22x34"`'
- en: '`MapSize = "8x11"`'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MapSize = "8x11"`'
- en: '`Mapsize = "36x48"`'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Mapsize = "36x48"`'
- en: 'If you print these variables, you will get the following output:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打印这些变量，你将得到以下输出：
- en: '[PRE2]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Python variable names need to be consistent throughout the script. The best
    practice is to use camel casing, wherein the first word of a variable name is
    all lowercase and then each successive word begins with an uppercase letter. This
    concept is illustrated in the following example with the `fieldOwnerName` variable
    name. The first word (`field`) is all lowercase followed by an uppercase letter
    for the second word (`Owner`) and third word (`Name`):'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Python 变量名在整个脚本中需要保持一致。最佳实践是使用驼峰命名法，即变量名的第一个单词全部小写，然后每个后续单词以大写字母开头。以下示例中的 `fieldOwnerName`
    变量名展示了这一概念：第一个单词（`field`）全部小写，第二个单词（`Owner`）和第三个单词（`Name`）以大写字母开头：
- en: '[PRE3]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In Python, variables are dynamically typed. **Dynamic typing** means that you
    can define a variable and assign data to it without specifically defining that
    a variable name will contain a specific type of data. Commonly used data types
    that can be assigned to variables include the following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，变量是动态类型的。**动态类型**意味着你可以定义一个变量并给它分配数据，而不必明确指定变量名将包含特定类型的数据。可以分配给变量的常用数据类型包括以下几种：
- en: '| Data type | Example value | Code example |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| 数据类型 | 示例值 | 代码示例 |'
- en: '| --- | --- | --- |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| String | `"Streets"` | `fcName = "Streets"` |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| 字符串 | `"Streets"` | `fcName = "Streets"` |'
- en: '| Number | `3.14` | `percChange = 3.14` |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| 数字 | `3.14` | `percChange = 3.14` |'
- en: '| Boolean | `True` | `ftrChanged = True` |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| 布尔值 | `True` | `ftrChanged = True` |'
- en: '| List | `"Streets", "Parcels", "Streams"` | `lstFC = ["Streets", "Parcels",
    "Streams"]` |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| 列表 | `"Streets", "Parcels", "Streams"` | `lstFC = ["Streets", "Parcels",
    "Streams"]` |'
- en: '| Dictionary | `''0'':Streets,''1'':Parcels` | `dictFC = {''0'':Streets,''1'':Parcels]`
    |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| 字典 | `''0'':Streets,''1'':Parcels` | `dictFC = {''0'':Streets,''1'':Parcels}`
    |'
- en: '| Object | `Extent` | `spatialExt = map.extent` |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| 对象 | `Extent` | `spatialExt = map.extent` |'
- en: We will discuss each of these data types in greater detail in the coming sections.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的章节中更详细地讨论这些数据类型。
- en: For instance, in C#, you would need to define a variable's name and type before
    using it. This is not necessary in Python. To use a variable, simply give it a
    name and value, and you can begin using it right away. Python does the work behind
    the scenes to figure out what type of data is being held in the variable.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在 C# 中，在使用变量之前，你需要定义变量的名称和类型。在 Python 中这不是必需的。要使用变量，只需给它一个名称和值，你就可以立即开始使用它。Python
    会幕后工作以确定变量中存储的数据类型。
- en: 'In the following C# code example, we''ve created a new variable called `aTouchdown`,
    which is defined as an integer variable, meaning that it can contain only integer
    data. We then assign the `6` value to the variable:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的 C# 代码示例中，我们创建了一个名为 `aTouchdown` 的新变量，它被定义为整数变量，这意味着它只能包含整数数据。然后我们将 `6`
    的值分配给这个变量：
- en: '[PRE4]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In Python, this variable can be created and assigned data through dynamic typing.
    The Python interpreter is tasked with dynamically figuring out what type of data
    is assigned to the variable:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，可以通过动态类型创建和分配数据。Python 解释器负责动态确定分配给变量的数据类型：
- en: '[PRE5]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'There may be times when you know that your script will need a variable, but
    don''t necessarily know ahead of time what data will be assigned to the variable.
    In these cases, you could simply define a variable without assigning data to it.
    Here, you will find a code example that depicts creating a variable without assigning
    data:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你可能知道你的脚本将需要一个变量，但事先并不一定知道将分配什么数据给这个变量。在这些情况下，你可以简单地定义一个变量而不给它分配数据。在这里，你将找到一个代码示例，展示了如何创建一个未分配数据的变量：
- en: '[PRE6]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Data that is assigned to the variable can also be changed while the script is
    running.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本运行时，分配给变量的数据也可以更改。
- en: Variables can hold many different kinds of data, including primitive data types,
    such as strings and numbers, along with more complex data, such as lists, dictionaries,
    and even objects. We're going to examine the different types of data that can
    be assigned to a variable along with various functions that are provided by Python
    to manipulate the data.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 变量可以存储许多不同类型的数据，包括原始数据类型，如字符串和数字，以及更复杂的数据，如列表、字典甚至对象。我们将检查可以分配给变量的不同数据类型，以及
    Python 提供的用于操作数据的各种函数。
- en: Built-in data types
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内置数据类型
- en: Python has a number of built-in data types. The first built-in type that we
    will discuss is the `string` data type. We've already seen several examples of
    `string` variables, but these types of variables can be manipulated in a lot of
    ways, so let's take a closer look at this data type.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Python 有许多内置数据类型。我们将首先讨论的内置类型是 `string` 数据类型。我们已经看到了几个 `string` 变量的例子，但这类变量可以以多种方式操作，所以让我们更仔细地看看这个数据类型。
- en: Strings
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串
- en: Strings are ordered collections of characters that store and represent text-based
    information. This is a rather dry way of saying that string variables hold text.
    String variables are surrounded by single or double quotes when being assigned
    to a variable. Examples could include a name, feature class name, a `Where` clause,
    or anything else that can be encoded as text.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串是有序字符集合，用于存储和表示基于文本的信息。这可以说是一种相当枯燥的说法，即字符串变量持有文本。当将文本赋给变量时，字符串变量被单引号或双引号包围。示例可能包括姓名、要素类名称、`Where`子句或任何可以编码为文本的内容。
- en: String manipulation
  id: totrans-122
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 字符串操作
- en: 'Strings can be manipulated in a number of ways in Python. String concatenation
    is one of the more commonly used functions and is simple to accomplish. The `+`
    operator is used with `string` variables on either side of the operator to produce
    a new `string` variable that ties the two string variables together:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，字符串可以通过多种方式进行操作。字符串连接是更常用的函数之一，并且实现简单。使用`+`运算符与操作符两边的`string`变量一起使用，以产生一个新的`string`变量，将两个字符串变量连接在一起：
- en: '[PRE7]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Running this code example produces the following result:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码示例会产生以下结果：
- en: '[PRE8]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'String equality can be tested using Python''s `==` operator, which is simply
    two equals signs placed together. Don''t confuse the equality operator with the
    assignment operator, which is a single equals sign. The equality operator tests
    two variables for equality, while the assignment operator assigns a value to a
    variable:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用Python的`==`运算符测试字符串的相等性，该运算符简单地放置了两个等号。不要将相等运算符与赋值运算符混淆，赋值运算符是一个单独的等号。相等运算符测试两个变量是否相等，而赋值运算符将值赋给变量：
- en: '[PRE9]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Running this code example produces the following result because the `firstName`
    and `lastName` variables are not equal:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码示例会产生以下结果，因为`firstName`和`lastName`变量不相等：
- en: '[PRE10]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Strings can be tested for containment using the `in` operator, which returns
    `True` if the first operand is contained in the second:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`in`运算符测试字符串是否包含，如果第一个操作数包含在第二个操作数中，则返回`True`：
- en: '[PRE11]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: I have briefly mentioned that strings are an ordered collection of characters.
    What does this mean? It simply means that we can access individual characters
    or a series of characters from the string and that the order of the characters
    will remain the same until we change them. Some collections, such as a dictionary,
    do not maintain a set order. In Python, this is referred to as **indexing** in
    the case of accessing an individual character, and **slicing** in the case of
    accessing a series of characters.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我简要地提到过字符串是一个有序字符集合。这意味着什么？这仅仅意味着我们可以从字符串中访问单个字符或一系列字符，并且字符的顺序将保持不变，直到我们改变它们。某些集合，如字典，不保持一定的顺序。在Python中，这种情况被称为访问单个字符时的**索引**，以及访问一系列字符时的**切片**。
- en: 'Characters in a string are obtained by providing the numeric offset contained
    within square brackets after a string. For example, you could obtain the first
    string character in the `fc` variable by using the `fc[0]` syntax. Python is a
    zero-based language, meaning the first item in a list is `0`. Negative offsets
    can be used to search backwards from the end of a string. In this case, the last
    character in a string is stored at the `-1` index. Indexing always creates a new
    variable to hold the character:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在字符串后提供方括号内的数字偏移量，可以获取字符串中的字符。例如，您可以使用`fc[0]`语法获取`fc`变量中的第一个字符串字符。Python是一种零基语言，意味着列表中的第一个项是`0`。可以使用负偏移量从字符串的末尾向前搜索。在这种情况下，字符串中的最后一个字符存储在`-1`索引处。索引始终创建一个新的变量来保存字符：
- en: '[PRE12]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The following image illustrates how strings are an ordered collection of characters
    with the first character occupying the **0** position, the second character occupying
    the **1** position, and each successive character occupying the next index number:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像说明了字符串是有序字符集合，第一个字符占据**0**位置，第二个字符占据**1**位置，每个后续字符占据下一个索引号：
- en: '![String manipulation](img/B04314_01_14.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![字符串操作](img/B04314_01_14.jpg)'
- en: While string indexing allows you to obtain a single character from a `string`
    variable, string slicing enables you to extract a contiguous sequence of strings.
    The format and syntax is similar to indexing, but with the addition of a second
    offset, which is used to tell Python which characters to return.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然字符串索引允许您从`string`变量中获取单个字符，但字符串切片允许您提取连续的字符串序列。其格式和语法与索引类似，但增加了第二个偏移量，用于告诉Python返回哪些字符。
- en: 'The following code example provides an example of string slicing. The `theString`
    variable has been assigned a value of `Floodplain.shp`. To obtain a sliced variable
    with the contents of Flood, you would use the `theString[0:5]` syntax:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例提供了一个字符串切片的例子。`theString`变量已被分配值为`Floodplain.shp`。要获取包含Flood内容的切片变量，您可以使用`theString[0:5]`语法：
- en: '[PRE13]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Python slicing returns the characters beginning with the first offset up to,
    but not including, the second offset. This can be particularly confusing for new
    Python programmers and is a common source of errors. In our example, the returned
    variable will contain the `Flood` characters. The first character, which occupies
    the `0` position, is `F`. The last character returned is the `4` index, which
    corresponds to the `d` character. Notice the `5` index number is not included
    since Python slicing only returns characters up to, but not including, the second
    offset
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的切片操作返回从第一个偏移量开始的字符，直到但不包括第二个偏移量。这对新 Python 程序员来说可能特别令人困惑，并且是错误的一个常见来源。在我们的示例中，返回的变量将包含
    `Flood` 字符。第一个字符，占据 `0` 位置，是 `F`。返回的最后一个字符是 `4` 索引，对应于 `d` 字符。请注意，`5` 索引号不包括在内，因为
    Python 的切片操作只返回到但不包括第二个偏移量的字符。
- en: Either of the offsets can be left off. This, in effect, creates a wild card.
    In the case of `theString[1:]`, you are telling Python to return all characters
    starting from the second character to the end of the string. In the second case,
    `theString[:-1]`, you are telling Python to start at character zero and return
    all characters except the last.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 可以省略任一偏移量。这实际上创建了一个通配符。在 `theString[1:]` 的情况下，您告诉 Python 返回从第二个字符开始到字符串末尾的所有字符。在第二种情况下，`theString[:-1]`，您告诉
    Python 从字符零开始，返回除了最后一个字符之外的所有字符。
- en: 'Python is an excellent language to manipulate strings and there are many additional
    functions that you can use to process this type of data. Most of these are beyond
    the scope of this text, but in general, all the following string manipulation
    functions are available:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Python 是一种非常出色的字符串操作语言，并且有许多额外的函数可以用来处理这类数据。大多数这些函数超出了本文的范围，但一般来说，以下所有的字符串操作函数都是可用的：
- en: String length
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串长度
- en: Casing functions for conversion to upper and lowercase
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大小写转换函数
- en: The removal of leading and trailing whitespace
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移除前导和尾随空白
- en: Finding a character within a string
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在字符串中查找字符
- en: The replacement of text
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本替换
- en: Splitting into a list of words based on a delimiter
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据分隔符分割成单词列表
- en: Formatting
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 格式化
- en: Your Python geoprocessing scripts for ArcGIS will often need to reference the
    location of a dataset on your computer or, perhaps, a shared server. References
    to these datasets will often consist of paths stored in a variable. In Python,
    pathnames are a special case that deserve some extra mention. The backslash character
    in Python is a reserved escape character and a line continuation character, thus
    there is a need to define paths using two back slashes, a single forward slash,
    or a regular single backslash prefixed with `r`. These pathnames are always stored
    as strings in Python. You'll see an example of this in the following section.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 您的 ArcGIS Python 地理处理脚本通常会需要引用您计算机上或可能是一个共享服务器上的数据集位置。对这些数据集的引用通常由存储在变量中的路径组成。在
    Python 中，路径名是一个特殊情况，值得特别提及。Python 中的反斜杠字符是一个保留的转义字符和行续行字符，因此需要使用两个反斜杠、一个正斜杠或以
    `r` 前缀的常规单个反斜杠来定义路径。这些路径名在 Python 中始终以字符串的形式存储。您将在下一节中看到一个示例。
- en: 'The example for an illegal path reference is as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 非法路径引用的示例如下：
- en: '[PRE14]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The example for legal path references are as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 合法路径引用的示例如下：
- en: '[PRE15]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Numbers
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数字
- en: Python also has built-in support for numeric data, including `int`, `long`,
    `float`, and `complex` values. Numbers are assigned to variables in much the same
    way as strings, with the exception that you do not enclose the value in quotes
    and obviously, it must be a numeric value.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Python 还内置了对数值数据类型（包括 `int`、`long`、`float` 和 `complex`）的支持。数值的赋值方式与字符串类似，只是不需要在值周围加上引号，并且显然它必须是一个数值。
- en: Python supports all the commonly used numeric operators, including addition,
    subtraction, multiplication, division, and modulus or remainder. In addition to
    this, functions used to return the absolute value, conversion of strings to numeric
    data types, and rounding are also available.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Python 支持所有常用的数值运算符，包括加法、减法、乘法、除法和取模或余数。除此之外，还有用于返回绝对值、将字符串转换为数值数据类型和四舍五入的函数。
- en: 'Although Python provides a few built-in mathematical functions, the math module
    can be used to access a wide variety of more advanced `math` functions. To use
    these functions, you must specifically import the `math` module as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Python 提供了一些内置的数学函数，但可以使用 `math` 模块来访问更多高级的 `math` 函数。要使用这些函数，您必须按照以下方式明确导入
    `math` 模块：
- en: '[PRE16]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Functions provided by the `math` module include those that return the ceiling
    and floor of a number, the absolute value, trigonometric functions, logarithmic
    functions, angular conversion, and hyperbolic functions. It is worth noting that
    there is no simple function to calculate mean or average and these will have to
    be coded to be calculated. More details about the `math` module can be found by
    navigating to **All Programs** | **ArcGIS** | **Python 2.7** | **Python Manuals**.
    After opening the python manual, navigate to **Python Standard Library** | **Numeric
    and Mathematical Modules**. You can also reference this for any data types, syntax,
    built-in functions, and other things that you wish to understand in more detail,
    of which there are too many to be covered here.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`math` 模块提供的函数包括返回数字的上限和下限、绝对值、三角函数、对数函数、角度转换和双曲函数。值得注意的是，没有简单的函数可以计算平均值或平均数，这些必须编写代码来计算。有关
    `math` 模块的更多详细信息，可以通过导航到 **所有程序** | **ArcGIS** | **Python 2.7** | **Python 手册**
    来找到。在打开 Python 手册后，导航到 **Python 标准库** | **数值和数学模块**。你也可以参考这个来了解任何数据类型、语法、内置函数以及其他你希望详细了解的内容，其中有很多内容无法在此处涵盖。'
- en: Lists
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 列表
- en: 'A third built-in data type provided by Python is lists. A list is an ordered
    collection of elements that can hold any type of data supported by Python as well
    as being able to hold multiple data types at the same time. This could be numbers,
    strings, other lists, dictionaries, or objects. So, for instance, a list variable
    could hold numeric and string data at the same time. Lists are zero-based, with
    the first element in the list occupying the **0** position. This is illustrated
    here:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Python 提供的第三种内置数据类型是列表。列表是有序元素集合，可以存储 Python 支持的任何类型的数据，同时还能同时存储多种数据类型。这可以包括数字、字符串、其他列表、字典或对象。例如，一个列表变量可以同时存储数字和字符串数据。列表是基于零的，列表中的第一个元素占据**0**的位置。这一点在此处得到了说明：
- en: '![Lists](img/B04314_01_15.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![列表](img/B04314_01_15.jpg)'
- en: Each successive object in the list is incremented by one. Additionally, lists
    have the special capability of dynamically growing and shrinking.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中的每个后续对象都会增加一个。此外，列表还具有动态增长和收缩的特殊能力。
- en: 'Lists are created by assigning a series of values enclosed by brackets. To
    pull a value from a list, simply use an integer value in brackets along with the
    variable name. The following code example provides an illustration of this:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 列表是通过分配一系列括号内的值来创建的。要从列表中提取值，只需在变量名旁边使用括号内的整数值即可。以下代码示例提供了这一点的说明：
- en: '[PRE17]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You can add a new item to an existing list by using the `append()` method,
    as seen in this code example:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用 `append()` 方法向现有列表中添加新项目，如下面的代码示例所示：
- en: '[PRE18]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You can also use slicing with lists to return multiple values. To slice a list,
    you can provide two offset values separated by a colon, as seen in the following
    code example. The first offset indicates the starting index number and the second
    indicates the stopping point. The second index number will not be returned. **Slicing**
    a list always returns a new list:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用切片与列表来返回多个值。要切片一个列表，你可以提供两个由冒号分隔的偏移量值，如下面的代码示例所示。第一个偏移量表示起始索引号，第二个表示停止点。第二个索引号将不会返回。**切片**列表始终返回一个新的列表：
- en: '[PRE19]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Lists are dynamic in nature, meaning that you can add and remove items from
    an existing list as well as change the existing contents. This is all done without
    the need to create a new copy of the list. Changing values in a list can be accomplished
    either through indexing or slicing. Indexing allows you to change a single value,
    while slicing allows you to change multiple list items.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 列表本质上是动态的，这意味着你可以向现有列表中添加和删除项目，以及更改现有内容，而无需创建列表的新副本。在列表中更改值可以通过索引或切片完成。索引允许你更改单个值，而切片允许你更改多个列表项。
- en: Lists have a number of methods that allow you to manipulate the values that
    are part of the list. You can sort the contents of the list in either an ascending
    or descending order through the use of the `sort()` method. Items can be added
    to a list with the `append()` method, which adds an object to the end of the list,
    and with the `insert()` method, which inserts an object at a position within the
    list. Items can be removed from a list with the `remove()` method, which removes
    the first occurrence of a value from the list, or the `pop()` method, which removes
    and returns the object at the end of the list. The contents of the list can also
    be reversed with the `reverse()` method.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 列表有许多方法可以让你操作列表中的值。你可以通过使用`sort()`方法以升序或降序对列表的内容进行排序。你可以使用`append()`方法向列表中添加项，该方法将对象添加到列表的末尾，以及使用`insert()`方法在列表中的某个位置插入对象。你可以使用`remove()`方法从列表中删除项，该方法从列表中删除第一个出现的值，或者使用`pop()`方法删除并返回列表末尾的对象。你还可以使用`reverse()`方法反转列表的内容。
- en: Tuples
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 元组
- en: 'Tuples are similar to lists but with some important differences. Just like
    lists, tuples contain a sequence of values. The contents of a tuple can include
    any type of data just like lists. However, unlike lists, the contents of a tuple
    are static. After a tuple has been created, you can''t make any changes to the
    sequence of the values nor can you add or remove values. This can be a good thing
    for situations where you want data to always occupy a specific position. Creating
    a tuple is as simple as placing a number of comma-separated values inside parentheses,
    as shown in the following code example:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 元组与列表类似，但有一些重要的区别。就像列表一样，元组包含一系列值。元组的内容可以包括任何类型的数据，就像列表一样。然而，与列表不同，元组的内容是静态的。一旦创建了元组，你就不能更改值的序列，也不能添加或删除值。这在需要数据始终占据特定位置的情况下可能是个好事。创建元组就像在圆括号内放置一些用逗号分隔的值一样简单，如下面的代码示例所示：
- en: '[PRE20]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You've probably noticed that creating a tuple is very similar to creating a
    list. The only difference is the use of parentheses instead of square braces around
    the values.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到创建元组与创建列表非常相似。唯一的区别是，在值周围使用圆括号而不是方括号。
- en: 'Similar to lists, tuple indices start with an index value of `0`. Access to
    values stored in a tuple occurs in the same way as lists. This is illustrated
    in the following code example:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 与列表类似，元组的索引从`0`开始。访问存储在元组中的值的方式与列表相同。这将在下面的代码示例中说明：
- en: '[PRE21]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Tuples are typically used in place of a list when it is important for the contents
    of the structure to be static. You can't ensure this with a list, but you can
    with a tuple.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当结构的内容需要是静态的时候，通常使用元组来代替列表。你不能通过列表来确保这一点，但你可以通过元组来确保。
- en: Dictionaries
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字典
- en: 'Dictionaries are a second type of collection object in Python. They are similar
    to lists, except that dictionaries are an unordered collection of objects. Instead
    of fetching objects from the collection through the use of an offset, items in
    a dictionary are stored and fetched by a key. Each key in a dictionary has an
    associated value, as seen here:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 字典是Python中的第二种集合对象类型。它们与列表类似，但字典是一个无序的对象集合。不是通过使用偏移量从集合中检索对象，而是通过键来存储和检索字典中的项。每个字典中的键都有一个关联的值，如下所示：
- en: '![Dictionaries](img/B04314_01_16.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![字典](img/B04314_01_16.jpg)'
- en: 'Similar to lists, dictionaries can grow and shrink in place through the use
    of methods on `dictionary.` In the following code example, you will learn to create
    and populate a dictionary and see how values can be accessed through the use of
    a key. Dictionaries are created with the use of curly braces. Inside these braces,
    each key is followed by a colon and then a value is associated with the key. These
    key/value pairs are separated by commas:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 与列表类似，字典可以通过使用`dictionary`上的方法在原地增长和缩小。在下面的代码示例中，你将学习如何创建和填充字典，并看到如何通过使用键来访问值。字典是通过使用花括号创建的。在这些括号内，每个键后面跟着一个冒号，然后与键关联一个值。这些键/值对由逗号分隔：
- en: '[PRE22]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Basic `dictionary` operations include getting the number of items in a dictionary,
    acquiring a value using a key, determining if the key exists, converting the keys
    to a list, and getting a list of values. The `dictionary` objects can be changed,
    expanded, and shrunk in place. What this means is that Python does not have to
    create a new `dictionary` object to hold the altered version of the dictionary.
    Assigning values to a `dictionary` key can be accomplished by stating the key
    value in brackets and setting it equal to some value.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的`字典`操作包括获取字典中的项目数量、使用键获取值、确定键是否存在、将键转换为列表以及获取值的列表。`字典`对象可以在原地更改、扩展和缩小。这意味着Python不需要创建一个新的`字典`对象来保存字典的更改版本。通过在方括号中声明键值并将其设置为某个值，可以完成对`字典`键的赋值。
- en: Tip
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Unlike lists, dictionaries can't be sliced due to the fact that their contents
    are unordered. Should you have the need to iterate over all the values in a dictionary,
    simply use the `keys()` method, which returns a collection of all the keys in
    the dictionary and can then be used individually to set or get their value.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 与列表不同，由于字典的内容是无序的，因此不能进行切片。如果你需要遍历字典中的所有值，只需使用`keys()`方法，它返回字典中所有键的集合，然后可以单独使用它们来设置或获取它们的值。
- en: Classes and objects
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类和对象
- en: Classes and objects are a fundamental concept in object-oriented programming.
    While Python is more of a procedural language, it also supports object-oriented
    programming. In object-oriented programming, classes are used to create object
    instances. You can think of classes as blueprints for the creation of one or more
    objects. Each object instance has the same properties and methods, but the data
    contained in an object can and usually will differ. Objects are complex data types
    in Python composed of properties and methods, and can be assigned to variables
    just like any other data type. Properties contain data associated with an object,
    while methods are actions that an object can perform.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 类和对象是面向对象编程的基本概念。虽然Python更偏向于过程式语言，但它也支持面向对象编程。在面向对象编程中，类用于创建对象实例。你可以把类看作是创建一个或多个对象的蓝图。每个对象实例都有相同的属性和方法，但对象中包含的数据可以并且通常会有所不同。对象是Python中的复杂数据类型，由属性和方法组成，可以像任何其他数据类型一样分配给变量。属性包含与对象相关的数据，而方法则是对象可以执行的操作。
- en: 'These concepts are best illustrated with an example. In ArcPy, the `extent`
    class is a rectangle specified by providing the coordinate of the lower-left corner
    and the coordinate of the upper-right corner in map units. The `extent` class
    contains a number of properties and methods. Properties include `XMin`, `XMax`,
    `YMin`, `YMax`, `spatialReference`, and others. The minimum and maximum of `x`
    and `y` properties provide the coordinates for the extent rectangle. The `spatialReference`
    property holds a reference to a `spatialReference` object for `extent`. Object
    instances of the `extent` class can be used both to set and get the values of
    these properties through dot notation. An example of this is seen in the following
    code example:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这些概念最好通过一个例子来解释。在ArcPy中，`extent`类是通过提供地图单位中左下角和右上角的坐标来指定矩形的类。`extent`类包含许多属性和方法。属性包括`XMin`、`XMax`、`YMin`、`YMax`、`spatialReference`等。`x`和`y`属性的极大值提供了范围矩形的坐标。`spatialReference`属性持有`extent`的`spatialReference`对象的引用。`extent`类的对象实例既可以用来设置也可以用来通过点表示法获取这些属性的值。以下代码示例展示了这一点：
- en: '[PRE23]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Running this script yields the following output:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此脚本会产生以下输出：
- en: '[PRE24]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `extent` class also has a number of methods, which are actions that an object
    can perform. In the case of this particular object, most of the methods are related
    to performing some sort of geometric test between the `extent` object and another
    geometry. Examples include `contains()`, `crosses()`, `disjoint()`, `equals()`,
    `overlaps()`, `touches()`, and `within()`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`extent`类也有许多方法，这些是对象可以执行的操作。对于这个特定的对象，大多数方法都与在`extent`对象和另一个几何体之间执行某种几何测试相关。例如包括`contains()`、`crosses()`、`disjoint()`、`equals()`、`overlaps()`、`touches()`和`within()`。'
- en: One additional object-oriented concept that you need to understand is **dot
    notation**. Dot notation provides a way of accessing the properties and methods
    of an object. It is used to indicate that a property or method belongs to a particular
    class.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要理解的一个额外的面向对象的概念是**点表示法**。点表示法提供了一种访问对象属性和方法的方式。它用于表示一个属性或方法属于特定的类。
- en: 'The syntax for using dot notation includes an object instance followed by a
    dot and then the property or method. The syntax is the same regardless of whether
    you''re accessing a property or a method. A parenthesis and zero or more parameters
    at the end of the word following the dot indicates that a method is being accessed.
    Here are a couple of examples to better illustrate this concept:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 使用点符号的语法包括一个对象实例，后面跟着一个点，然后是属性或方法。无论您是访问属性还是方法，语法都是相同的。在点后面的单词末尾的括号和零个或多个参数表示正在访问一个方法。以下是一些示例，以更好地说明这一概念：
- en: '[PRE25]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Statements
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 语句
- en: 'Each line of code that you write with Python is known as a **statement**. There
    are many different kinds of statements, including those that create and assign
    data to variables, decision support statements that branch your code based on
    a test, looping statements that execute a code block multiple times, and others.
    There are various rules that your code will need to follow as you create the statements
    that are part of your script. You''ve already encountered one type of statement:
    variable creation and assignment.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 您用Python编写的每一行代码都称为**语句**。有各种不同类型的语句，包括创建和分配数据到变量的语句、基于测试分支代码的决策支持语句、执行代码块多次的循环语句等。在创建脚本中的语句时，您的代码需要遵循各种规则。您已经遇到了一种类型的语句：变量创建和赋值。
- en: Decision support statements
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 决策支持语句
- en: 'The `if`/`elif`/`else` statement is the primary decision-making statement in
    Python and tests for a `True`/`False` condition. Decision statements enable you
    to control the flow of your programs. Here are some example decisions that you
    can make in your code: if the variable holds a point feature class, get the `X`,
    `Y` coordinates; if the feature class name equals `Roads`, then get the `Name`
    field.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`/`elif`/`else`语句是Python中的主要决策语句，用于测试`True`/`False`条件。决策语句使您能够控制程序的流程。以下是一些您可以在代码中做出的决策示例：如果变量包含点要素类，获取`X`、`Y`坐标；如果要素类名称等于`Roads`，则获取`Name`字段。'
- en: 'Decision statements, such as `if`/`elif`/`else`, test for a `True`/`False`
    condition. In Python, a `True` value means any nonzero number or nonempty object.
    A `False` value indicates *not true* and is represented in Python with a zero
    number or empty object. Comparison tests return values of one or zero (true or
    false). Boolean and/or operators return a true or false operand value:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 决策语句，如`if`/`elif`/`else`，测试`True`/`False`条件。在Python中，`True`值表示任何非零数字或非空对象。`False`值表示`not
    true`，在Python中用零数字或空对象表示。比较测试返回一个或零（真或假）的值。布尔和/or运算符返回真或假的操作数值：
- en: '[PRE26]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The Python code must follow certain syntax rules. Statements execute one after
    another until your code branches. Branching typically occurs through the use of
    `if`/`elif`/`else`. In addition to this, the use of looping structures, such as
    `for` and `while`, can alter the statement flow. Python automatically detects
    statement and block boundaries, so there is no need for braces or delimiters around
    your blocks of code. Instead, indentation is used to group statements in a block.
    Many languages terminate statements with the use of a semicolon, but Python simply
    uses the end of line character to mark the end of a statement. Compound statements
    include a "`:`" character. Compound statements follow this pattern, that is, header
    terminated by a colon. Blocks of code are then written as individual statements
    and are indented underneath the header.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: Python代码必须遵循某些语法规则。语句依次执行，直到您的代码分支。分支通常通过使用`if`/`elif`/`else`来实现。此外，使用循环结构，如`for`和`while`，可以改变语句流程。Python自动检测语句和代码块边界，因此不需要在代码块周围使用大括号或分隔符。相反，缩进用于将语句分组到代码块中。许多语言使用分号来终止语句，但Python只是使用行尾字符来标记语句的结束。复合语句包括一个"`:`"字符。复合语句遵循以下模式，即以冒号结束的标题。然后，代码块作为单个语句编写，并缩进在标题下方。
- en: Looping statements
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 循环语句
- en: 'Looping statements allow your program to repeat lines of code over and over
    as necessary. `The while` loops repeatedly execute a block of statements as long
    as the test at the top of the loop evaluates to `True`. When the condition test
    evaluates to `False`, Python begins interpreting code immediately after the `while`
    loop. In the next code example, a value of `10` has been assigned to the `x` variable.
    The test for the `while` loop then checks to see if `x` is less than `100`. If
    `x` is less than `100`, the current value of `x` is printed to the screen and
    the value of x is incremented by `10`. Processing then continues with the `while`
    loop test. The second time, the value of `x` will be `20`; so the test evaluates
    to `True` once again. This process continues until `x` is equal to or greater
    than `100`. At this time, the test will evaluate to `False` and processing will
    stop. It is very important that `the while` statements have some way of breaking
    out of the loop. Otherwise, you will wind up in an infinite loop. An infinite
    loop is a sequence of instructions in a computer program that loops endlessly,
    either due to the loop having no terminating condition, having one that can never
    be met, or one that causes the loop to start over:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 循环语句允许你的程序根据需要重复执行代码行。`while`循环会重复执行循环顶部的测试评估为`True`的语句块。当条件测试评估为`False`时，Python开始立即解释`while`循环之后的代码。在下一个代码示例中，`10`的值已被分配给`x`变量。`while`循环的测试检查`x`是否小于`100`。如果`x`小于`100`，则将`x`的当前值打印到屏幕上，并将`x`的值增加`10`。然后，处理继续进行`while`循环测试。第二次，`x`的值将是`20`；因此，测试再次评估为`True`。这个过程会一直持续到`x`等于或大于`100`。此时，测试将评估为`False`，处理将停止。非常重要的一点是`while`语句必须有一种方法跳出循环。否则，你将陷入无限循环。无限循环是计算机程序中的一系列指令，它无限循环，要么是因为循环没有终止条件，要么是因为有一个永远无法满足的条件，或者是因为它导致循环重新开始：
- en: '[PRE27]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `for` loops execute a block of statements a predetermined number of times.
    They come in two varieties—a counted loop to run a block of code a set number
    of times, and a list loop that enables you to loop through all the objects in
    a list. The list loop in the following example executes once for each value in
    the dictionary and then stops looping:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环执行一个预定的次数的语句块。它们有两种类型——一个计数循环，用于执行固定次数的代码块，和一个列表循环，它允许你遍历列表中的所有对象。以下示例中的列表循环对字典中的每个值执行一次，然后停止循环：'
- en: '[PRE28]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: There are times when it will be necessary for you to break out of the execution
    of a loop. The `break` and `continue` statements can be used to do this. The `break`
    jumps out of the closest enclosing loop, while `continue` jumps back to the top
    of the closest enclosing loop. These statements can appear anywhere inside the
    block of code.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你可能需要从循环的执行中跳出。`break`和`continue`语句可以用来做到这一点。`break`跳出最近的封闭循环，而`continue`跳回到最近的封闭循环的顶部。这些语句可以出现在代码块中的任何位置。
- en: Try statements
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 尝试语句
- en: A `try` statement is a complete, compound statement that is used to handle exceptions.
    Exceptions are a high-level control device used primarily for error interception
    or triggering. Exceptions in Python can either be intercepted or triggered. When
    an error condition occurs in your code, Python automatically triggers an exception,
    which may or may not be handled by your code. It is up to you as a programmer
    to catch an automatically triggered exception. Exceptions can also be triggered
    manually by your code. In this case, you would also need to provide an exception
    handling routine to catch these manually triggered exceptions.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`try`语句是一个完整的、复合语句，用于处理异常。异常是一种高级控制设备，主要用于错误拦截或触发。Python中的异常可以被拦截或触发。当你的代码中出现错误条件时，Python会自动触发一个异常，这个异常可能或可能不会被你的代码处理。作为程序员，你有责任捕获自动触发的异常。异常也可以通过你的代码手动触发。在这种情况下，你还需要提供一个异常处理例程来捕获这些手动触发的异常。'
- en: 'There are two basic types of `try` statements: `try`/`except`/`else` and `try`/`finally`.
    The basic `try` statement starts with a `try` header line followed by a block
    of indented statements. Then, this is followed by one or more optional `except`
    clauses that name the exceptions that are to be caught. After this, you will find
    an optional `else` clause at the end:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`try`语句有两种基本类型：`try`/`except`/`else`和`try`/`finally`。基本的`try`语句从`try`标题行开始，后面跟着一个缩进的语句块。然后，这后面跟着一个或多个可选的`except`子句，这些子句命名了要捕获的异常。之后，你将在末尾找到一个可选的`else`子句：'
- en: '[PRE29]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `try`/`except`/`else` statement works as follows. Once inside a `try` statement,
    Python marks the fact that you are in a `try` block and knows that any exception
    condition that occurs at this point will be sent to the various `except` statements
    for handling. If a matching exception is found, the code block inside the `except`
    block is executed. The code then picks up the full `try` statement, which will
    be mentioned shortly. The `else` statements are not executed in this case. Each
    statement inside the `try` block is executed. Assuming that no exception conditions
    occur, the code pointer will then jump to the `else` statement and execute the
    code block contained by the `else` statement before moving to the next line of
    code that follows the try block.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`try`/`except`/`else` 语句的工作原理如下。一旦进入 `try` 语句块，Python 会标记你处于 `try` 块中，并且知道在此点发生的任何异常条件都将被发送到各个
    `except` 语句进行处理。如果找到匹配的异常，则执行 `except` 块内的代码块。然后代码会继续执行完整的 `try` 语句，这将在稍后提到。在这种情况下，`else`
    语句不会执行。`try` 块内的每个语句都会执行。假设没有发生异常条件，代码指针将跳转到 `else` 语句并执行 `else` 语句包含的代码块，然后再移动到
    `try` 块之后的下一行代码。'
- en: The other type of `try` statement is the `try`/`finally` statement, which allows
    for finalization actions. When a `finally` clause is used in a `try` statement,
    its block of statements always run at the very end, whether an error condition
    occurs or not.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种类型的 `try` 语句是 `try`/`finally` 语句，它允许执行最终化操作。当在 `try` 语句中使用 `finally` 子句时，其语句块总是在最后执行，无论是否发生错误条件。
- en: 'Here is how the `try`/`finally` statement works: if an exception occurs, Python
    runs the `try` block, then the `except` block, followed by the `finally` block,
    and then execution continues past the entire `try` statement. If an exception
    does not occur during execution, Python runs the `try` block, then the `finally`
    block. This is useful when you want to make sure an action happens after a code
    block runs, regardless of whether an error condition occurs. Cleanup operations,
    such as closing a file or a connection to a database, are commonly placed inside
    a `finally` block to ensure that they are executed regardless of whether an exception
    occurs in your code:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 `try`/`finally` 语句的工作方式：如果发生异常，Python 会运行 `try` 块，然后是 `except` 块，接着是 `finally`
    块，然后继续执行 `try` 语句之后的代码。如果在执行过程中没有发生异常，Python 会运行 `try` 块，然后是 `finally` 块。这在你想要确保代码块运行后发生某个动作时很有用，无论是否发生错误条件。清理操作，如关闭文件或数据库连接，通常放置在
    `finally` 块中，以确保无论代码中是否发生异常都会执行：
- en: '[PRE30]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: With statements
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`with` 语句'
- en: The `with` statement is handy when you have two related operations that need
    to be executed as a pair with a block of code in between. A common scenario to
    use the `with` statements is opening, reading, and closing a file. Opening and
    closing a file are the related operations, and reading a file and doing something
    with the contents is the block of code in between. When writing geoprocessing
    scripts with ArcGIS, the new `cursor` objects introduced with version 10.1 of
    ArcGIS are ideal when using the `with` statements. We'll discuss the `cursor`
    objects in great detail in a later chapter, but I'll briefly describe these objects
    now. Cursors are an in-memory copy of records from the attribute table of a feature
    class or table. There are various types of cursors. Insert cursors allow you to
    insert new records, search cursors are a read-only copy of records, and update
    cursors allow you to edit or delete records. Cursor objects are opened, processed
    in some way, and closed automatically using a `with` statement.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有两个相关的操作需要作为一个代码块中的配对执行时，`with` 语句就很有用。使用 `with` 语句的常见场景是打开、读取和关闭文件。打开和关闭文件是相关操作，而读取文件和对其内容进行处理是中间的代码块。在编写
    ArcGIS 的地理处理脚本时，使用 ArcGIS 10.1 版本引入的新 `cursor` 对象非常适合使用 `with` 语句。我们将在稍后的章节中详细讨论
    `cursor` 对象，但现在我将简要描述这些对象。游标是特征类或表属性表的记录的内存副本。游标有多种类型。插入游标允许你插入新记录，搜索游标是记录的只读副本，而更新游标允许你编辑或删除记录。使用
    `with` 语句可以自动打开、以某种方式处理并关闭游标对象。
- en: 'The closure of a file or cursor object is handled automatically by the `with`
    statement, resulting in cleaner, more efficient coding. It''s basically like using
    a `try`/`finally` block, but with fewer lines of code. In the following code example,
    the `with` block is used to create a new search cursor, read information from
    the cursor, and implicitly close the cursor:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 文件或游标对象的关闭由 `with` 语句自动处理，从而实现更简洁、更高效的编码。这基本上就像使用 `try`/`finally` 块，但代码行数更少。在下面的代码示例中，`with`
    块用于创建一个新的搜索游标，从游标中读取信息，并隐式关闭游标：
- en: '[PRE31]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Statement indentation
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 语句缩进
- en: Statement indentation deserves a special mention as it is critical to the way
    Python interprets code. Compound statements in Python use indentation to create
    a group of statements. This includes the `if`/`then`, `for`, `while`, `try`, and
    `with` statements. The Python interpreter uses indentation to detect these code
    blocks. The beginning of a compound statement is defined through the use of a
    colon. All lines following the beginning of the compound statement should be indented
    the same distance. You can use any number of spaces to define the indentation,
    but you should use the same indentation level for each statement. A common practice
    is to define indentation through the use of a tab. When the Python interpreter
    encounters a line that is less indented, it will assume that the code block has
    ended. The following code illustrates this concept through the use of a `try`
    statement. Notice that there is a colon after the `try` statement. This indicates
    that the statements that follow are part of a compound statement and should be
    indented. These statements will form a code block.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 语句缩进值得特别提及，因为它对于 Python 解释代码的方式至关重要。Python 中的复合语句使用缩进来创建一组语句。这包括 `if`/`then`、`for`、`while`、`try`
    和 `with` 语句。Python 解释器使用缩进来检测这些代码块。复合语句的开始是通过冒号的使用来定义的。所有跟在复合语句开始之后的行都应该缩进相同的距离。你可以使用任意数量的空格来定义缩进，但你应该为每个语句使用相同的缩进级别。一个常见的做法是通过使用制表符来定义缩进。当
    Python 解释器遇到一个缩进较少的行时，它将假设代码块已结束。以下代码通过使用 `try` 语句说明了这个概念。注意，在 `try` 语句之后有一个冒号。这表示随后的语句是复合语句的一部分，应该缩进。这些语句将形成一个代码块。
- en: 'Also, an `if` statement is inside the `try` statement. This too is a compound
    statement as defined by the colon at the end of the statement. Therefore, any
    statements that are part of the `if` statement should be further indented. You
    should also notice that there is a statement that is not indented inside the `if`
    statement, but is rather at the same level. This `statement4` is part of the `try`
    code block but not part of the `if` code block:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，一个 `if` 语句位于 `try` 语句内部。这也被视为一个复合语句，这是通过语句末尾的冒号定义的。因此，任何属于 `if` 语句的语句都应该进一步缩进。你也应该注意到，`if`
    语句内部有一个没有缩进的语句，但它处于同一级别。这个 `statement4` 是 `try` 代码块的一部分，但不是 `if` 代码块的一部分：
- en: '[PRE32]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Many languages, including JavaScript, Java, and .NET, use curly braces to indicate
    a group of statements. Python uses indentation instead of curly braces in an attempt
    to cut down on the amount of code you have to write and to make code more readable.
    Anyone who has ever used these other languages can attest to the difficulty in
    reading code that contains many curly braces. However, indentation does take some
    getting used to and is critical to the way that Python executes lines of code.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 许多语言，包括 JavaScript、Java 和 .NET，使用花括号来表示一组语句。Python 通过使用缩进来代替花括号，试图减少你不得不编写的代码量，并使代码更易于阅读。任何使用过这些其他语言的人都可以证实，阅读包含许多花括号的代码是多么困难。然而，缩进确实需要一些习惯，并且对于
    Python 执行代码行的方式至关重要。
- en: File I/O
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件输入输出
- en: You will often find it necessary to retrieve or write information to files on
    your computer. Python has a built-in object type that provides a way to access
    files for many tasks. We're only going to cover a small subset of the file manipulation
    functionality provided, but we'll touch on the most commonly used functions, including
    opening and closing files, and reading and writing data to a file.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 你经常会发现需要从你的计算机上的文件中检索或写入信息。Python 有一个内置的对象类型，它提供了一种访问文件以执行许多任务的方法。我们只将涵盖文件操作功能的一小部分，但我们将涉及最常用的函数，包括打开和关闭文件，以及将数据读取和写入文件。
- en: 'Python''s `open()` function creates a file object, which serves as a link to
    a file residing on your computer. You must call the `open()` function on a file
    before reading and/or writing data to a file. The first parameter for the `open()`
    function is a path to the file you''d like to open. The second parameter corresponds
    to a mode, which is typically read (`r`), write (`w`), or append (`a`). A value
    of `r` indicates that you''d like to open the file for read-only operations, while
    a value of `w` indicates you''d like to open the file for write operations. In
    the event that you open a file that already exists for write operations, this
    will overwrite any data currently in the file, so you must be careful with the
    write mode. The append mode (`a`) will open a file for write operations, but instead
    of overwriting any existing data, it will append the new data to the end of the
    file. The following code example shows the use of the `open()` function to open
    a text file in a read-only mode:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的 `open()` 函数创建一个文件对象，该对象作为你电脑上文件的一个链接。在读取和/或写入文件数据之前，必须在文件上调用 `open()`
    函数。`open()` 函数的第一个参数是你想要打开的文件的路径。第二个参数对应于一个模式，通常是读取（`r`）、写入（`w`）或追加（`a`）。`r` 的值表示你想要以只读方式打开文件，而
    `w` 的值表示你想要以写入方式打开文件。如果你以写入方式打开一个已存在的文件，这将覆盖文件中现有的任何数据，所以你必须小心使用写入模式。追加模式（`a`）将以写入方式打开文件，但不会覆盖任何现有数据，而是将新数据追加到文件末尾。以下代码示例展示了如何使用
    `open()` 函数以只读模式打开一个文本文件：
- en: '[PRE33]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Notice that we have also used the `with` keyword to open the file, ensuring
    that the file resource will be *cleaned up* after the code that uses it has finished
    executing.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们同样使用了 `with` 关键字来打开文件，确保在使用该文件的代码执行完毕后，文件资源将被 *清理*。
- en: After a file has been opened, data can be read from it in a number of ways and
    using various methods. The most typical scenario would be to read data one line
    at a time from a file through the `readline()` method. The `readline()` function
    can be used to read the file one line at a time into a string variable. You would
    need to create a looping mechanism in your Python code to read the entire file
    line by line. If you would prefer to read the entire file into a variable, you
    can use the `read()` method, which will read the file up to the **End Of File**
    (**EOF**) marker. You can also use the `readlines()` method to read the entire
    contents of a file, separating each line into individual strings, until the EOF
    is found.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 文件打开后，可以使用多种方式和多种方法从中读取数据。最典型的情况是使用 `readline()` 方法逐行从文件中读取数据。`readline()` 函数可以将文件逐行读入一个字符串变量中。你需要在
    Python 代码中创建一个循环机制来逐行读取整个文件。如果你希望将整个文件读入一个变量中，可以使用 `read()` 方法，该方法将读取文件直到 **文件结束标记**
    (**EOF**)。你也可以使用 `readlines()` 方法来读取文件的全部内容，将每一行分割成单独的字符串，直到找到 EOF。
- en: 'In the following code example, we have opened a text file called `Wildfires.txt`
    in the read-only mode and used the `readlines()` method on the file to read its
    entire contents into a variable called `lstFires`, which is a Python list containing
    each line of the file as a separate string value in the list. In this case, the
    `Wildfire.txt` file is a comma-delimited text file containing the latitude and
    longitude of the fire along with the confidence values for each fire. We then
    loop through each line of text in `lstFires` and use the `split()` function to
    extract the values based on a comma as the delimiter, including the latitude,
    longitude, and confidence values. The latitude and longitude values are used to
    create a new `Point` object, which is then inserted into the feature class using
    an insert cursor:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码示例中，我们以只读模式打开了一个名为 `Wildfires.txt` 的文本文件，并使用 `readlines()` 方法将文件的全部内容读入一个名为
    `lstFires` 的变量中，该变量是一个 Python 列表，包含文件中的每一行作为一个单独的字符串值。在这种情况下，`Wildfire.txt` 文件是一个以逗号分隔的文本文件，包含火灾的纬度和经度以及每个火灾的置信度值。然后我们遍历
    `lstFires` 中的每一行文本，并使用 `split()` 函数根据逗号作为分隔符提取值，包括纬度、经度和置信度值。纬度和经度值用于创建一个新的 `Point`
    对象，然后使用插入游标将其插入到要素类中：
- en: '[PRE34]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Just as is the case with reading files, there are a number of methods that
    you can use to write data to a file. The `write()` function is probably the easiest
    to use and takes a single string argument and writes it to a file. The `writelines()`
    function can be used to write the contents of a list structure to a file. In the
    following code example, we have created a list structure called `fcList`, which
    contains a list of feature classes. We can write this list to a file using the
    `writelines()` method:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 就像读取文件一样，有几种方法可以将数据写入文件。`write()` 函数可能是最容易使用的，它接受一个字符串参数并将其写入文件。`writelines()`
    函数可以用来将列表结构的内容写入文件。在下面的代码示例中，我们创建了一个名为 `fcList` 的列表结构，其中包含一系列要素类。我们可以使用 `writelines()`
    方法将此列表写入文件：
- en: '[PRE35]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Summary
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered some of the fundamental Python programming concepts
    that you'll need to understand before you can write effective geoprocessing scripts.
    We began the chapter with an overview of the IDLE development environment to write
    and debug Python scripts. You learned how to create a new script, edit existing
    scripts, check for syntax errors, and execute scripts. We also covered the basic
    language constructs, including importing modules, creating and assigning variables,
    if/else statements, looping statements, and the various data-types including strings,
    numbers, Booleans, lists, dictionaries, and objects. You also learned how to read
    and write text files.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了一些基本的 Python 编程概念，这些概念是在你能够编写有效的地理处理脚本之前需要理解的。我们以 IDLE 开发环境的概述开始本章，用于编写和调试
    Python 脚本。你学习了如何创建新脚本、编辑现有脚本、检查语法错误以及执行脚本。我们还涵盖了基本语言结构，包括导入模块、创建和分配变量、if/else
    语句、循环语句以及各种数据类型，包括字符串、数字、布尔值、列表、字典和对象。你还学习了如何读取和写入文本文件。
