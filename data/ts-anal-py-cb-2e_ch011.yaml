- en: 10 Building Univariate Time Series Models Using Statistical Methods
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10 使用统计方法构建单变量时间序列模型
- en: Join our book community on Discord
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加入我们的书籍社区，加入 Discord
- en: '![](img/file0.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](img/file0.png)'
- en: '[https://packt.link/zmkOY](https://packt.link/zmkOY)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/zmkOY](https://packt.link/zmkOY)'
- en: In *Chapter 9*, *Exploratory Data Analysis and Diagnosis*, you were introduced
    to several concepts to help you understand the time series process. Such recipes
    included *Decomposing time series data*, *Detecting time series stationarity*,
    *Applying power transformations,* and *Testing for autocorrelation in time series
    data*. These techniques will come in handy in the statistical modeling approach
    that will be discussed in this chapter.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第9章*，*探索性数据分析与诊断*中，你已经接触了帮助你理解时间序列过程的几个概念。这些方法包括*时间序列数据分解*、*检测时间序列的平稳性*、*应用幂次变换*和*测试时间序列数据的自相关性*。这些技术将在本章讨论的统计建模方法中派上用场。
- en: When working with time series data, different methods and models can be used,
    depending on whether the time series you are working with is **univariate** or
    **multivariate**, **seasonal** or **non-seasonal**, **stationary** or **non-stationary**,
    and **linear** or **nonlinear**. If you list the assumptions you need to consider
    and examine – for example, stationarity and autocorrelation – it will become apparent
    why time series data is deemed to be complex and challenging. Thus, to model such
    a complex system, your goal is to get a good enough approximation that captures
    the critical factors of interest. These factors will vary by industry domain and
    the study's objective, such as forecasting, analyzing a process, or detecting
    abnormalities.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理时间序列数据时，可以根据你所处理的时间序列是**单变量**还是**多变量**、**季节性**还是**非季节性**、**平稳**还是**非平稳**、**线性**还是**非线性**，采用不同的方法和模型。如果你列出需要考虑和检查的假设——例如平稳性和自相关性——就会明显看出，为什么时间序列数据被认为是复杂和具有挑战性的。因此，为了建模这样一个复杂的系统，你的目标是获得一个足够好的近似，捕捉到关键的兴趣因素。这些因素会根据行业领域和研究目标的不同而有所变化，例如预测、分析过程或检测异常。
- en: Some popular statistical modeling methods include **Exponential Smoothing**,
    **Autoregressive Integrated Moving Average** (**ARIMA**), **Seasonal ARIMA** (**SARIMA**),
    **Vector Autoregressive** (**VAR**), and other variants of these models such as
    ARIMAX, SARIMAX, VARX, and VARMA. Many practitioners, such as economists and data
    scientists, still use such statistical “classical” models. Additionally, these
    models can be found in popular software packages such as EViews, MATLAB, Orange,
    KNIME, and Alteryx, as well as libraries in Python and R.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 一些流行的统计建模方法包括**指数平滑**、**自回归积分滑动平均**（**ARIMA**）、**季节性ARIMA**（**SARIMA**）、**向量自回归**（**VAR**）以及这些模型的其他变种，如
    ARIMAX、SARIMAX、VARX 和 VARMA。许多实践者，如经济学家和数据科学家，仍然使用这些统计“经典”模型。此外，这些模型可以在流行的软件包中找到，如
    EViews、MATLAB、Orange、KNIME 和 Alteryx，以及 Python 和 R 的库中。
- en: In this chapter, you will learn how to build these statistical models in Python.
    In other words, I will only provide a brief introduction to the theory and math
    since the focus is on the implementation. I will provide references where it makes
    sense if you are interested in diving deeper into the math and theory of such
    models.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何在 Python 中构建这些统计模型。换句话说，我只会简要介绍理论和数学，因为重点在于实现。如果你对这些模型的数学和理论感兴趣，我会在适当的地方提供参考文献，供你深入研究。
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Plotting ACF and PACF
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绘制 ACF 和 PACF
- en: Forecasting univariate time series data with exponential smoothing
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用指数平滑法预测单变量时间序列数据
- en: Forecasting univariate time series data with non-seasonal ARIMA
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用非季节性 ARIMA 预测单变量时间序列数据
- en: Forecasting univariate time series data with seasonal ARIMA
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用季节性 ARIMA 预测单变量时间序列数据
- en: Forecasting univariate time series data with Auto_Arima
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Auto_Arima 预测单变量时间序列数据
- en: Before diving into these recipes, pay special attention to the upcoming *Technical
    requirements* section, in which you will perform upfront preparation. This will
    remove any distractions and repetitive coding so that you can focus on the recipe's
    core goals and the concepts behind each implementation.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入这些方法之前，请特别注意即将到来的*技术要求*部分，在这一部分你将进行前期准备。这将消除任何干扰和重复编码，以便你可以专注于方法的核心目标以及每个实现背后的概念。
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You can download the Jupyter Notebooks and necessary datasets from this book''s
    GitHub repository:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从本书的 GitHub 仓库下载 Jupyter Notebooks 和必要的数据集：
- en: 'Jupyter Notebook: [https://github.com/PacktPublishing/Time-Series-Analysis-with-Python-Cookbook./blob/main/code/Ch10/Chapter%2010.ipynb](https://github.com/PacktPublishing/Time-Series-Analysis-with-Python-Cookbook./blob/main/code/Ch10/Chapter%2010.ipynb)'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Jupyter Notebook: [https://github.com/PacktPublishing/Time-Series-Analysis-with-Python-Cookbook./blob/main/code/Ch10/Chapter%2010.ipynb](https://github.com/PacktPublishing/Time-Series-Analysis-with-Python-Cookbook./blob/main/code/Ch10/Chapter%2010.ipynb)'
- en: 'Datasets: [https://github.com/PacktPublishing/Time-Series-Analysis-with-Python-Cookbook./tree/main/datasets/Ch10](https://github.com/PacktPublishing/Time-Series-Analysis-with-Python-Cookbook./tree/main/datasets/Ch10)'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '数据集: [https://github.com/PacktPublishing/Time-Series-Analysis-with-Python-Cookbook./tree/main/datasets/Ch10](https://github.com/PacktPublishing/Time-Series-Analysis-with-Python-Cookbook./tree/main/datasets/Ch10)'
- en: 'Before you start working through the recipes in this chapter, please run the
    following code to load the datasets and functions that will be referenced throughout:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始学习本章的配方之前，请运行以下代码以加载将在全章中引用的数据集和函数：
- en: 'Start by importing the basic libraries that will be shared across all the recipes
    in this chapter:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先导入本章所有配方中将共享的基本库：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You will be working with two datasets throughout this chapter: `Life Expectancy
    from Birth` and `Monthly Milk Production`. Import these datasets, which are stored
    in CSV format (`life_expectancy_birth.csv`, and `milk_production.csv`), into pandas
    DataFrames. Each dataset comes from a different time series process, so they will
    contain a different trend or seasonality. Once you''ve imported the datasets,
    you will have two DataFrames called `life` and `milk`:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 本章中您将使用两个数据集：`Life Expectancy from Birth` 和 `Monthly Milk Production`。将这两个以CSV格式存储（`life_expectancy_birth.csv`
    和 `milk_production.csv`）的数据集导入到 pandas DataFrame 中。每个数据集来自不同的时间序列过程，因此它们将包含不同的趋势或季节性。一旦导入数据集，您将得到两个名为
    `life` 和 `milk` 的数据框：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Inspect the data visually and observe if the time series contains any trend
    or seasonality. You can always come back to the plots shown in this section for
    reference:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 直观地检查数据，观察时间序列是否包含任何趋势或季节性。您可以随时返回本节中展示的图表作为参考：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This should display two time series plots:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示两个时间序列图：
- en: '![Figure 10.1: Time series plots for Annual Life Expectancy and Monthly Milk
    Production](img/file152.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.1：年度预期寿命和每月牛奶生产的时间序列图](img/file152.png)'
- en: 'Figure 10.1: Time series plots for Annual Life Expectancy and Monthly Milk
    Production'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.1：年度预期寿命和每月牛奶生产的时间序列图
- en: The preceding figure shows a time series plot for the `life expectancy` DataFrame
    showing a positive (upward) trend and no seasonality. The life expectancy data
    contains *annual* life expectancy records at birth from 1960 to 2018 (59 years).
    The original dataset contained records for each country, but you will be working
    with *world* records in this chapter.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 上图展示了`life expectancy` 数据框的时间序列图，显示了一个积极（向上）的趋势，且没有季节性。该预期寿命数据包含了1960年至2018年（59年）的每年出生时的预期寿命记录。原始数据集包含了各国的记录，但在本章中，您将使用*全球*的记录。
- en: The time series plot for the `monthly milk production` DataFrame shows a positive
    (upward) trend and a repeating seasonality (every summer). The milk production
    data is recorded monthly from January 1962 to December 1975 (168 months). The
    seasonal magnitudes and variations over time seem to be steady, indicating an
    additive nature. Having a seasonal decomposition that specifies the level, trend,
    and season of an additive model will reflect this as well.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`monthly milk production` 数据框的时间序列图显示了一个积极（向上）的趋势，并且呈现出周期性（每年夏季）。该牛奶生产数据从1962年1月到1975年12月每月记录（共168个月）。季节性幅度和随时间变化的波动似乎保持稳定，表明其为加法模型。季节性分解明确了加法模型的水平、趋势和季节性，也能反映这一点。'
- en: For more insight on seasonal decomposition, please review the *Decomposing time
    series data* recipe in *Chapter 9*, *Exploratory Data Analysis and Diagnosis*.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如需深入了解季节性分解，请参考*第9章*中的*季节性分解时间序列数据*配方，位于*探索性数据分析与诊断*部分。
- en: You will need to split the data into `test` and `train` datasets. You will train
    the models (fitting) on the training dataset and use the test dataset to evaluate
    the model and compare your predictions. A forecast that's created on the data
    that is used in training is called an **in-sample** forecast, while forecasting
    for unseen data such as a test set is called an **out-of-sample** forecast. When
    you're evaluating the different models, you will be using the out-of-sample or
    test sets.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你需要将数据分割成 `test` 和 `train` 数据集。你将在训练数据集上训练模型（拟合），并使用测试数据集来评估模型并比较预测结果。基于用于训练的数据所创建的预测称为**样本内**预测，而对未见数据（如测试集）进行的预测称为**样本外**预测。在评估不同模型时，你将使用样本外或测试集。
- en: 'Create a generalized function, `split_data`, which splits the data based on
    a test split factor. This way, you can experiment on different splits as well.
    We will be referencing this function throughout this chapter:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个通用函数 `split_data`，根据测试拆分因子分割数据。这样，你也可以尝试不同的拆分方式。我们将在本章中引用这个函数：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Call the `split_data` function to split the two DataFrames into `test` and
    `train` datasets (start with 15% test and 85% train). You can always experiment
    with different split factors:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `split_data` 函数，将两个数据框分割为 `test` 和 `train` 数据集（开始时使用 15% 测试集和 85% 训练集）。你可以随时尝试不同的拆分因子：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You will be checking for stationarity often since it is an essential assumption
    for many of the models you will build. For example, in *Chapter 9*, *Exploratory
    Data Analysis and Diagnosis*, in the *Detecting time series stationarity* recipe,
    we discussed the importance of testing for stationarity and using the **Augmented
    Dickey-Fuller** test. Create a function that you can refer to throughout this
    chapter to perform the test and interpret the results:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将经常检查平稳性，因为这是你将构建的许多模型的一个基本假设。例如，在*第9章*，*探索性数据分析与诊断*，在*检测时间序列平稳性*的食谱中，我们讨论了检验平稳性的重要性以及使用**扩展的迪基-富勒（Augmented
    Dickey-Fuller）**检验。创建一个可以在本章中引用的函数，用于执行检验并解释结果：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: There will be recipes in which you will run multiple variations of a model as
    you search for the optimal configuration, a practice commonly called **hyperparameter
    tuning**. For example, you may train an ARIMA model with different parameter values
    and thus produce multiple variations of the ARIMA model (multiple models).
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在某些食谱中，你将运行模型的多个变体，寻找最优配置，这一做法通常被称为**超参数调优**。例如，你可以训练一个 ARIMA 模型并使用不同的参数值，从而生成多个
    ARIMA 模型的变体（多个模型）。
- en: The `get_top_models_df` function will compare the different models – for example,
    multiple ARIMA models – to select the best model and the set of parameters associated
    with that model. The `get_top_models_df` function will take a dictionary that
    contains the produced models, the associated parameters, and the scores for each
    model. It returns a DataFrame detailing the top performing models, for easier
    comparison. The function allows you to specify the number of top models to return
    and the `criterion` for their selection, such as Root Mean Squared Percentage
    Error (**RMSPE**), Root Mean Square Error (**RMSE**), Mean Absolute Percentage
    Error (**MAPE**), Akaike's Information Criteria (**AIC**), Corrected Akaike's
    Information Criteria (**AICc**), or Bayesian Information Criteria (**BIC**). These
    metrics can be crucial in determining the most suitable model for your data analysis
    needs.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_top_models_df` 函数将比较不同的模型——例如，多个 ARIMA 模型——以选择最佳模型及其相关的参数集。`get_top_models_df`
    函数将接受一个字典，包含生成的模型、相关的参数和每个模型的评分。它返回一个数据框，详细列出表现最好的模型，便于比较。该函数允许你指定返回的最佳模型数量和用于选择模型的
    `criterion`，例如均方根百分比误差（**RMSPE**）、均方根误差（**RMSE**）、平均绝对百分比误差（**MAPE**）、赤池信息量准则（**AIC**）、修正赤池信息量准则（**AICc**）或贝叶斯信息量准则（**BIC**）。这些指标在确定最适合你的数据分析需求的模型时至关重要。'
- en: For example, you may opt to evaluate the models based on their AIC scores by
    default, but you can easily switch to another metric like RMSPE or RMSE if these
    are more relevant to your specific situation. This flexibility ensures that you
    can tailor the model selection process to best fit the analytical demands and
    complexity of your data.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，默认情况下你可能会选择根据 AIC 分数评估模型，但如果 RMSPE 或 RMSE 更适合你的具体情况，你可以轻松切换到这些指标。这种灵活性确保你可以根据数据的分析需求和复杂性量身定制模型选择过程。
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Create the `plot_forecast` function, which takes a model object that you have
    trained, a starting position, and both the train and test datasets to create a
    plot that compares the forecast (predicted values) against actuals. This will
    become clearer as you dive into this chapter''s recipes:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`plot_forecast`函数，该函数接受你已经训练的模型对象、起始位置以及训练和测试数据集，生成一个将预测值与实际值进行比较的图表。当你深入本章的配方时，情况将变得更加清晰：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Lastly, create a `combinator` utility function that takes a list of parameter
    values and returns a **cartesian product** of these choices. You will use this
    when performing a grid search for hyperparameter tuning. In grid search, you specify
    a combination of parameter values to train multiple models on each set and then
    evaluate the winning model using the `get_top_models_df` function. For example,
    suppose your list contains three possible values for three different parameters.
    In such a case, the `combinator` function will return a list containing 3x3 or
    nine possible combinations. This will become clearer as you dive into this chapter''s
    recipes:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，创建一个`combinator`工具函数，该函数接受一组参数值并返回这些选择的**笛卡尔积**。在进行超参数调优时，你将使用这个函数进行网格搜索。在网格搜索中，你会指定一组参数值的组合，分别训练多个模型，然后使用`get_top_models_df`函数评估最佳模型。例如，假设你的列表中包含三个不同参数的三个可能值。在这种情况下，`combinator`函数将返回一个包含3x3或九种可能组合的列表。当你深入本章的配方时，情况将变得更加清晰：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We can represent the overall flow as in *Figure 10.2* which shows how you will
    be utilizing the functions you just created.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像*图10.2*中所示的那样表示整体流程，图中展示了你如何利用刚刚创建的函数。
- en: '![Figure 10.2: The overall process in this Chapter utilizing the prepared helper
    functions created](img/file153.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图10.2：本章利用已准备好的辅助函数创建的整体过程](img/file153.jpg)'
- en: 'Figure 10.2: The overall process in this Chapter utilizing the prepared helper
    functions created'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.2：本章利用已准备好的辅助函数创建的整体过程
- en: Now, let's dive into the recipes.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解这些配方。
- en: In the first recipe, you will be introduced to the **ACF** and **PACF** plots,
    which are used to evaluate model fit, check stationarity, and determine the **orders**
    (**parameters**) for some of the models that will be used in this chapter, such
    as the ARIMA model.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个配方中，你将接触到**ACF**和**PACF**图，它们用于评估模型拟合、检查平稳性，并确定本章中将使用的一些模型（如ARIMA模型）的**阶数**（**参数**）。
- en: Plotting ACF and PACF
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘制ACF和PACF
- en: Before building any statistical forecasting models such as **AR** (AutoRegressive),
    **MA** (Moving Average), **ARMA** (AutoRegressive Moving Average), **ARIMA** (AutoRegressive
    Integrated Moving Average), or **SARIMA** (Seasonal AutoRegressive Integrated
    Moving Average), you will need to determine the most suitable type of time series
    model for your data. Additionally, you will need to identify the values for some
    required parameters, known as orders. More specifically, these include the lag
    orders for the autoregressive (AR) or moving average (MA) components. This process
    will be explored further in the *'Forecasting Univariate Time Series Data with
    ARIMA'* section of this chapter. For example, an Autoregressive Moving Average
    (ARMA) model is denoted as `ARMA(p, q)`, where `'p'` represents the autoregressive
    order, or AR(p) component, and `'q'` represents the moving average order, or MA(q)
    component. Hence, an ARMA model combines an AR(p) and an MA(q) model.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建任何统计预测模型之前，如**自回归**（AR）、**移动平均**（MA）、**自回归移动平均**（ARMA）、**自回归积分移动平均**（ARIMA）或**季节性自回归积分移动平均**（SARIMA），你需要确定最适合你数据的时间序列模型类型。此外，你还需要确定一些必需参数的值，这些参数称为阶数。更具体地说，这些包括自回归（AR）或移动平均（MA）成分的滞后阶数。这个过程将在本章的*“使用ARIMA预测单变量时间序列数据”*部分进一步探讨。例如，自回归移动平均（ARMA）模型表示为`ARMA(p,
    q)`，其中`'p'`表示自回归阶数或AR(p)成分，`'q'`表示移动平均阶数或MA(q)成分。因此，ARMA模型结合了AR(p)和MA(q)模型。
- en: The core idea behind these models is built on the assumption that the current
    value of a particular variable,![](img/file154.png), can be estimated from past
    values of itself. For example, in an autoregressive model of order `p` or `AR(p)`,
    we assume that the current value,![](img/file155.png), at time![](img/file156.png)can
    be estimated from its past values (![](img/file157.png)) up to `p`, where `p`
    determines how many lags (steps back) we need to go. If![](img/file158.png), this
    means we must use two previous periods![](img/file159.png)) to predict![](img/file160.png).
    Depending on the granularity of your time series data, `p=2` can be 2 hours, 2
    days, 2 months, 2 quarters, or 2 years.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这些模型的核心思想基于这样一个假设：可以通过过去的数值来估计当前特定变量的值！[](img/file154.png)。例如，在一个自回归模型（AR）中，假设当前值！[](img/file155.png)，在时间！[](img/file156.png)可以通过其过去的值（![](img/file157.png)）估算，直到`p`，其中`p`决定了我们需要回溯多少个时间步。如果！[](img/file158.png)，这意味着我们必须使用前两个周期！[](img/file159.png)来预测！[](img/file160.png)。根据时间序列数据的粒度，`p=2`可能代表2小时、2天、2个月、2季度或2年。
- en: To build an ARMA(p,q) model, you will need to provide values for the `p` and
    `q` orders (known as lags). These are considered **hyperparameters** since they
    are supplied by you to influence the model.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建ARMA(p,q)模型，你需要提供`p`和`q`阶数（即滞后）。这些被视为**超参数**，因为它们是由你提供的，用于影响模型。
- en: The terms parameters and hyperparameters are sometimes used interchangeably.
    However, they have different interpretations and you need to understand the distinction.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 参数和超参数这两个术语有时被交替使用。然而，它们有不同的解释，你需要理解它们之间的区别。
- en: PARAMETERS VERSUS HYPERPARAMETERS
  id: totrans-57
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 参数与超参数
- en: ''
  id: totrans-58
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: When training an ARMA or an ARIMA model, the outcome will produce a set of parameters
    called coefficients – for example, a coefficient value for AR Lag 1 or sigma –
    that are estimated by the algorithm during the model training process and are
    used for making predictions. They are referred to as the model's parameters.
  id: totrans-59
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在训练ARMA或ARIMA模型时，结果将生成一组被称为系数的参数——例如，AR滞后1的系数值或sigma——这些系数是算法在模型训练过程中估算出来的，并用于进行预测。它们被称为模型的参数。
- en: ''
  id: totrans-60
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: On the other hand, the (p, d, q) parameters are the ARIMA(p, q, d) orders for
    AR, differencing, and MA, respectively. These are called hyperparameters. They
    are provided during training and influence the model’s parameters that are produced
    (for example, the coefficients). These hyperparameters, can be tuned using grid
    search, for example, to find the best set of values that produce the best model.
  id: totrans-61
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 另一方面，（p，d，q）参数是ARIMA(p，q，d)中的AR、差分和MA的阶数。这些被称为超参数。它们在训练过程中提供，并影响模型生成的参数（例如系数）。这些超参数可以通过网格搜索等方法进行调优，以找到生成最佳模型的最佳参数组合。
- en: Now, you might be asking yourself, how do I find the significant lag values
    for AR and MA models?
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可能会问，如何找到AR和MA模型的显著滞后值？
- en: This is where the **Autocorrelation Function** (**ACF**) and the **Partial Autocorrelation
    Function** (**PACF**) and their plots come into play. The ACF and PACF can be
    plotted to help you identify if the time series process is an AR, MA, or an ARMA
    process (if both are present) and the *significant* lag values (for `p` and `q`).
    Both PACF and ACF plots are referred to as **correlograms** since the plots represent
    the **correlation** statistics.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是**自相关函数**（**ACF**）和**偏自相关函数**（**PACF**）以及它们的图形发挥作用的地方。可以绘制ACF和PACF图，以帮助你识别时间序列过程是AR、MA还是ARMA过程（如果两者都存在），并识别*显著的*滞后值（对于`p`和`q`）。ACF和PACF图都被称为**相关图**，因为这些图表示**相关性**统计。
- en: The difference between an ARMA and ARIMA, written as `ARIMA(p, d, q)`, is in
    the stationarity assumption. The `d` parameter in ARIMA is for the differencing
    order. An ARMA model assumes a **stationary** process, while an ARIMA model does
    not since it handles differencing. An ARIMA model is a more generalized model
    since it can satisfy an ARMA model by making the differencing factor `d=0`. Hence,
    an `ARIMA(1,0,1)` is `ARMA(1,1)`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: ARMA和ARIMA的区别，在于平稳性假设。ARIMA中的`d`参数用于差分阶数。ARMA模型假设过程是**平稳的**，而ARIMA模型则不假设，因为它处理差分问题。ARIMA模型是一个更为广泛的模型，因为通过将差分因子`d=0`，它可以满足ARMA模型的需求。因此，`ARIMA(1,0,1)`就是`ARMA(1,1)`。
- en: '**AR** ORDER VERSUS **MA** ORDER'
  id: totrans-65
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**AR**阶数与**MA**阶数'
- en: ''
  id: totrans-66
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: You will use the PACF plot to estimate the AR order and the ACF plot to estimate
    the MA order. Both the ACF and PACF plots show values that range from `-1` to
    `1` on the vertical axis (y-axis), while the horizontal axis (x-axis) indicates
    the size of the lag. A *significant* lag is any lag that goes outside the shaded
    confidence interval, as you shall see from the plots.
  id: totrans-67
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你将使用 PACF 图来估计 AR 阶数，并使用 ACF 图来估计 MA 阶数。ACF 和 PACF 图的纵轴（y 轴）显示从 `-1` 到 `1` 的值，横轴（x
    轴）表示滞后的大小。*显著*的滞后是任何超出阴影置信区间的滞后，正如你在图中看到的。
- en: 'The **statsmodels** library provides two functions: `acf_plot` and `pacf_plot`.
    The correlation (for both ACF and PACF) at lag zero is always *one* (since it
    represents autocorrelation of the first observation on itself). Hence, both functions
    provide the `zero` parameter, which takes a Boolean. Therefore, to exclude the
    zero lag in the visualization, you can pass `zero=False` instead.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**statsmodels** 库提供了两个函数：`acf_plot` 和 `pacf_plot`。零滞后的相关性（对于 ACF 和 PACF）始终为
    *1*（因为它表示第一个观测值与自身的自相关）。因此，这两个函数提供了 `zero` 参数，该参数接受一个布尔值。因此，为了在可视化中排除零滞后，可以传递
    `zero=False`。'
- en: In *Chapter 9*, *Exploratory Data Analysis and Diagnosis*, in the *Testing autocorrelation
    in time series data* recipe, you used the **Ljung-Box** test to evaluate autocorrelation
    on the residuals. In this recipe, you will also learn how to use the ACF plot
    to examine **residual autocorrelation** visually as well.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第 9 章*，*探索性数据分析与诊断* 中，*测试时间序列数据中的自相关* 配方中，你使用了 **Ljung-Box** 测试来评估残差的自相关。在本例中，你还将学习如何使用
    ACF 图来直观地检查 **残差自相关**。
- en: How to do it…
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'In this recipe, you will explore `acf_plot` and `pacf_plot` from the `statsmodels`
    library. Let''s get started:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，你将探索 `statsmodels` 库中的 `acf_plot` 和 `pacf_plot`。我们开始吧：
- en: You will use the life expectancy data in this recipe. As shown in *Figure 10.1*,
    the data is not stationary due to the presence of a long-term trend. In such a
    case, you will need to difference (detrend) the time series to make it stationary
    **before** applying the ACF and PACF plots.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将在本例中使用寿命预期数据。如 *图 10.1* 所示，由于存在长期趋势，数据不是平稳的。在这种情况下，你需要对时间序列进行差分（去趋势），使其平稳，**然后**才能应用
    ACF 和 PACF 图。
- en: 'Start by differencing and then create the plots without the zero lag:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 从差分开始，然后创建不包含零滞后的图：
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This should produce the following two plots:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成以下两个图：
- en: '![Figure 10.3: The ACF and PACF plots for the life expectancy data after differencing](img/file161.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.3：差分后寿命预期数据的 ACF 和 PACF 图](img/file161.png)'
- en: 'Figure 10.3: The ACF and PACF plots for the life expectancy data after differencing'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.3：差分后寿命预期数据的 ACF 和 PACF 图
- en: 'If you want to see the calculated PACF and ACF for more lags you can update
    the `lags` parameter as shown:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想查看更多滞后的计算 PACF 和 ACF，可以更新 `lags` 参数，如下所示：
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This should produce the following two plots:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成以下两个图：
- en: '![Figure 10.4: The ACF and PACF for the first 25 lags](img/file162.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.4：前 25 个滞后的 ACF 和 PACF 图](img/file162.png)'
- en: 'Figure 10.4: The ACF and PACF for the first 25 lags'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.4：前 25 个滞后的 ACF 和 PACF 图
- en: The ACF plot shows a significant spike at lag (order) 1\. Significance is represented
    when a lag (vertical line) goes above or below the shaded area. The shaded area
    represents the confidence interval, which is set to `95%` by default. In the ACF
    plot, only the first lag is significant, which is below the lower confidence interval,
    and then *cuts off* right after. All the remaining lags are not significant. This
    indicates a moving average of order one or MA(1).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: ACF 图在滞后（阶数）1 处显示了一个显著的峰值。当滞后（垂直线）超出阴影区域时，表示显著性。阴影区域代表置信区间，默认设置为 `95%`。在 ACF
    图中，只有第一个滞后显著，低于下置信区间，并且在此之后 *迅速消失*。其余的滞后均不显著。这表明是一个一阶移动平均 MA(1)。
- en: The PACF plot shows a *gradual* decay with oscillation. Generally, if PACF shows
    a gradual decay, it indicates a moving average model. For example, if you are
    using an ARMA or ARIMA model, it would be represented as `ARMA(0, 1)` once the
    data has been differenced to make it stationary, or `ARIMA(0, 1, 1)`, indicating
    a first-order differencing with `d=1`. In both ARMA and ARIMA, the AR order is
    `p=0`, and the MA order is `q=1`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: PACF 图呈现 *渐变* 衰减并伴随震荡。通常，如果 PACF 显示渐变衰减，表示使用了移动平均模型。例如，如果你使用 ARMA 或 ARIMA 模型，一旦数据差分使其平稳后，它将表现为
    `ARMA(0, 1)` 或 `ARIMA(0, 1, 1)`，表示一阶差分，`d=1`。在 ARMA 和 ARIMA 模型中，AR 阶数为 `p=0`，MA
    阶数为 `q=1`。
- en: 'Now, let''s see how PACF and ACF can be used with a more complex dataset containing
    strong trends and seasonality. In *Figure 10.1*, the `Monthly Milk Production`
    plot shows an annual seasonal effect and a positive upward trend indicating a
    non-stationary time series. It is more suitable with a SARIMA model. In a SARIMA
    model, you have two components: a non-seasonal and a seasonal component. For example,
    in addition to the AR and MA processes for the non-seasonal components represented
    by lower case `p` and `q`, which you saw earlier, you will have AR and MA orders
    for the seasonal component, which are represented by upper case `P` and `Q`, respectively.
    This can be written as `SARIMA(p,d,q)(P,D,Q,S)`. You will learn more about the
    SARIMA model in the *Forecasting univariate time series data with seasonal ARIMA*
    recipe.'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何将PACF和ACF用于包含强烈趋势和季节性的更复杂的数据集。在*图10.1*中，`月度牛奶生产`图显示了年度季节性效应和一个正向上升的趋势，表示这是一个非平稳时间序列。它更适合使用SARIMA模型。在SARIMA模型中，你有两个部分：非季节性部分和季节性部分。例如，除了之前看到的表示非季节性部分的AR和MA过程（分别由小写`p`和`q`表示），你还会有季节性部分的AR和MA阶数，分别由大写`P`和`Q`表示。这个模型可以表示为`SARIMA(p,d,q)(P,D,Q,S)`。你将在*使用季节性ARIMA预测单变量时间序列数据*的食谱中了解更多关于SARIMA模型的内容。
- en: 'To make such time series stationary, you will need to start with seasonal differencing
    to remove the seasonal effect. Since the observations are taken monthly, the seasonal
    effects are observed annually (every 12 months or period):'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使此类时间序列平稳，你需要从季节性差分开始，以去除季节性效应。由于观测是按月进行的，因此季节性效应是按年观察的（每12个月或每个周期）：
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Use the `check_stationarity` function that you created earlier in this chapter
    to perform an Augmented Dickey-Fuller test to check for stationarity:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你在本章早些时候创建的`check_stationarity`函数，执行增广的迪基-富勒（Augmented Dickey-Fuller）检验以检查平稳性：
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The differenced time series is still not stationary, so you still need to perform
    a second differencing. This time, you must perform first-order differencing (detrend).
    When the time series data contains seasonality and trend, you may need to difference
    it twice to make it stationary. Store the resulting DataFrame in the `milk_diff_12_1`
    variable and run `check_stationarity` again:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 差分后的时间序列仍然不是平稳的，因此你仍然需要进行第二次差分。这一次，你必须执行一阶差分（去趋势）。当时间序列数据包含季节性和趋势时，你可能需要进行两次差分才能使其平稳。将结果存储在`milk_diff_12_1`变量中，并再次运行`check_stationarity`：
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Great – now, you have a stationary process.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了——现在，你有了一个平稳过程。
- en: 'Plot ACF and PACF for the stationary time series in `milk_diff_12_1`:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制`milk_diff_12_1`中平稳时间序列的ACF和PACF图：
- en: '[PRE14]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This should produce the following ACF and PACF plots:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会生成以下ACF和PACF图：
- en: '![Figure 10.5: PACF and ACF for Monthly Milk Production after differencing](img/file163.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.5: 经差分后的月度牛奶生产的PACF和ACF图](img/file163.png)'
- en: 'Figure 10.5: PACF and ACF for Monthly Milk Production after differencing'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '图 10.5: 经差分后的月度牛奶生产的PACF和ACF图'
- en: For the seasonal orders, `P` and `Q`, you should diagnose spikes or behaviors
    at lags `s`, `2s`, `3s`, and so on, where `s` is the number of periods in a season.
    For example, in the milk production data, `s=12` (since there are 12 monthly periods
    in a season). Then, we observe for significance at 12 (s), 24 (2s), 36 (3s), and
    so on.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 对于季节性阶数`P`和`Q`，你应该诊断在滞后`s`、`2s`、`3s`等位置的峰值或行为，其中`s`是一个季节中的周期数。例如，在牛奶生产数据中，`s=12`（因为一个季节有12个月）。然后，我们观察12（s）、24（2s）、36（3s）等位置的显著性。
- en: 'Starting with the ACF plot, there is a significant spike at lag 1, which represents
    the *non-seasonal* order for the MA process as `q=1`. The spike at lag 12 represents
    the *seasonal* order for the MA process as `Q=1`. Notice that there is a cut-off
    right after lag 1, then a spike at lag 12, followed by a cut-off (no other significant
    lags afterward). These indicate a moving average model: an MA(1) for the non-seasonal
    component and an MA(1) for the seasonal component. The PACF plot confirms this
    as well; an exponential decay at lags 12, 24, and 36 indicates an MA model. So,
    the SARIMA model would be `ARIMA (0, 1,1)(0, 1, 1, 12)`.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 从自相关函数（ACF）图开始，滞后1处有一个显著的峰值，表示MA过程的*非季节性*阶数为`q=1`。滞后12处的峰值表示MA过程的*季节性*阶数为`Q=1`。注意，在滞后1之后有一个截断，然后在滞后12处有一个峰值，之后又是截断（没有其他显著的滞后）。这些现象表明该模型是一个移动平均模型：非季节性部分是MA(1)，季节性部分是MA(1)。偏自相关函数（PACF）图也证实了这一点；在滞后12、24和36处的指数衰减表明这是一个MA模型。因此，SARIMA模型应该是`ARIMA
    (0, 1,1)(0, 1, 1, 12)`。
- en: Though using ACF and PACF plots can be useful for identifying the ARIMA orders
    p and q, it should not be used alone. There are different techniques that you
    will explore in this chapter to help you determine the orders such as model selection
    techniques using AIC and BIC.
  id: totrans-100
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 尽管使用 ACF 和 PACF 图对于识别 ARIMA 阶数 p 和 q 很有用，但不应单独使用。在本章中，您将探索不同的技术，帮助您通过 AIC 和
    BIC 等模型选择技术来确定阶数。
- en: How it works…
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 工作原理…
- en: The ACF and PACF plots can help you understand the strength of the linear relationship
    between past observations and their significance at different lags.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: ACF 和 PACF 图可以帮助您理解过去观测值之间线性关系的强度以及在不同滞后期的显著性。
- en: The ACF and PACF plots show significant autocorrelation or partial autocorrelation
    above the **confidence interval**. The shaded portion represents the confidence
    interval, which is controlled by the `alpha` parameter in both `pacf_plot` and
    `acf_plot` functions. The default value for `alpha` in `statsmodels` is `0.05`
    (at a 95% confidence interval). Being significant could be in either direction;
    strongly positive the closer to `1` (above) or strongly negative the closer to
    `-1` (below).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: ACF 和 PACF 图显示出显著的自相关或部分自相关，超出了 **置信区间**。阴影部分表示置信区间，它由 `pacf_plot` 和 `acf_plot`
    函数中的 `alpha` 参数控制。`statsmodels` 中 `alpha` 的默认值是 `0.05`（95% 置信区间）。显著性可以是任意方向；如果自相关强烈为正，它会接近
    `1`（上方），如果强烈为负，则会接近 `-1`（下方）。
- en: 'The following table shows an example guide for identifying the stationary AR
    and MA orders from PACF and ACF plots:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 下表展示了一个示例指南，用于从 PACF 和 ACF 图中识别平稳的 AR 和 MA 阶数：
- en: '![](img/file164.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/file164.jpg)'
- en: 'Table 10.1: Identifying the AR, MA, and ARMA models using ACF and PACF plots'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 表 10.1：使用 ACF 和 PACF 图识别 AR、MA 和 ARMA 模型
- en: There's more...
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 还有更多…
- en: In this recipe, you used ACF and PACF plots to try and estimate what order values
    (lags) to use for the seasonal and non-seasonal ARIMA models.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，您使用了 ACF 和 PACF 图来估计应该为季节性和非季节性 ARIMA 模型使用哪些阶数（滞后）。
- en: 'Let''s see how ACF plots can be used to diagnose the model''s **residuals**.
    Inspecting a model’s residuals is an integral part of evaluating a model. The
    assumption here is quite simple: if the model captured all the necessary information
    correctly, then the residuals should not include any correlated data points at
    any lags (no autocorrelation). Hence, you would expect an ACF plot of the residuals
    to show autocorrelations closer to zero.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 ACF 图如何用于诊断模型的 **残差**。检查模型的残差是评估模型的重要组成部分。这里的假设很简单：如果模型正确地捕捉到了所有必要的信息，那么残差中不应该包含任何在任意滞后期有相关性的点（即没有自相关）。因此，您会期望残差的
    ACF 图显示出接近零的自相关。
- en: 'Let''s build the Seasonal ARIMA model we identified earlier in this recipe
    as `SARIMA(0,1,1)(0,1,1,12)`, then use the ACF to diagnose the residuals. If the
    model captured all the information that''s been embedded within the time series,
    you would expect the residuals to have *no autocorrelation*:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建之前在本食谱中识别的季节性 ARIMA 模型 `SARIMA(0,1,1)(0,1,1,12)`，然后使用 ACF 来诊断残差。如果模型捕捉到了时间序列中嵌入的所有信息，您会期望残差
    *没有自相关*：
- en: '[PRE15]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This should produce the following autocorrelation plot:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成以下自相关图：
- en: '![Figure 10.6: Autocorrelation plot of the SARIMA residuals](img/file165.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.6：SARIMA 残差的自相关图](img/file165.png)'
- en: 'Figure 10.6: Autocorrelation plot of the SARIMA residuals'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.6：SARIMA 残差的自相关图
- en: Overall, the `SARIMA(0,1,1)(0,1,1,12)` did a good job at capturing the necessary
    information, and yet there might be some opportunity for improvement. There is
    one significant lag (at lag=12 above the confidence threshold) indicating the
    existence of some autocorrelation in the residuals.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 总体来说，`SARIMA(0,1,1)(0,1,1,12)` 很好地捕捉到了必要的信息，但仍然有提升的空间。存在一个显著的滞后期（在滞后=12 时，超出了置信阈值），表明残差中存在某些自相关。
- en: You can further tune the model and experiment with other values for the seasonal
    and non-seasonal orders. In this chapter and later recipes, you will explore a
    grid search method for selecting the best hyperparameters to find the best model.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以进一步调整模型并尝试不同的季节性和非季节性阶数。在本章及后续食谱中，您将探索一种网格搜索方法来选择最佳的超参数，以找到最优模型。
- en: 'If you want to further diagnose your model’s residuals you can do so using
    the `plot_diagnostics` method:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想进一步诊断模型的残差，您可以使用 `plot_diagnostics` 方法进行：
- en: '[PRE16]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This should produce the following plots:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成以下图形：
- en: '![Figure 10.7: Residual analysis using plot_diagnostics method](img/file166.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.7：使用 plot_diagnostics 方法进行残差分析](img/file166.png)'
- en: 'Figure 10.7: Residual analysis using plot_diagnostics method'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.7：使用plot_diagnostics方法进行的残差分析
- en: Note that the diagnostic plots produced are based on the standardized residuals,
    a common technique that makes comparing residuals between models easier because
    they are normalized and expressed in terms of standard deviations.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，生成的诊断图是基于标准化残差的，这是一种常见的技术，因为它使得在不同模型之间比较残差更加容易，因为它们是归一化的，并以标准差的形式表示。
- en: 'You can replicate the same diagrams by accessing the `model.standardized_forecasts_error`
    as shown below:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过访问`model.standardized_forecasts_error`来复制相同的图表，如下所示：
- en: '[PRE17]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: and
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 和
- en: '[PRE18]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The two plots produced should resemble the following figures, illustrating
    the autocorrelation and time series pattern of the standardized residuals:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的两个图应类似于以下图形，展示标准化残差的自相关和时间序列模式：
- en: '![Figure 10.8: ACF plot of the standardized residuals of the SARIMA model](img/file167.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.8：SARIMA模型标准化残差的ACF图](img/file167.png)'
- en: 'Figure 10.8: ACF plot of the standardized residuals of the SARIMA model'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.8：SARIMA模型标准化残差的ACF图
- en: '![Figure 10.9: Standardized residuals plot of the SARIMA model](img/file168.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.9：SARIMA模型标准化残差图](img/file168.png)'
- en: 'Figure 10.9: Standardized residuals plot of the SARIMA model'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.9：SARIMA模型标准化残差图
- en: The difference between *Figure 10.6* and *Figure 10.8* is due to scale normalization.
    Standardization can reduce the impact of outliers, as the residuals are scaled
    down. This is why the autocorrelation at Lag 12, though still visible in both
    figures, is at the border of the confidence interval in Figure 10.8, as opposed
    to *Figure 10.6*. At the same time, standardization can amplify smaller autocorrelations
    that may not be initially visible in the original ACF plot. Throughout the recipes,
    you will rely on the `plot_diagnostics method for residual diagnosis.`
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10.6*与*图 10.8*之间的差异是由于尺度归一化。标准化可以减少异常值的影响，因为残差被缩小。这就是为什么在图 10.8 中，尽管Lag
    12的自相关在两张图中都可见，但它位于置信区间的边界，而在*图 10.6*中则明显不同。同时，标准化可能会放大一些较小的自相关，这些自相关在原始的ACF图中可能最初是不可见的。在整个食谱中，你将依赖于`plot_diagnostics`方法进行残差诊断。'
- en: See also
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 另见
- en: To learn more about ACF plots, visit the official documentation at [https://www.statsmodels.org/dev/generated/statsmodels.graphics.tsaplots.plot_acf.html.](https://www.statsmodels.org/dev/generated/statsmodels.graphics.tsaplots.plot_acf.html.)
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 若要了解更多关于ACF图的内容，请访问官方文档 [https://www.statsmodels.org/dev/generated/statsmodels.graphics.tsaplots.plot_acf.html.](https://www.statsmodels.org/dev/generated/statsmodels.graphics.tsaplots.plot_acf.html.)
- en: To learn more about PACF plots, visit the official documentation at [https://www.statsmodels.org/dev/generated/statsmodels.graphics.tsaplots.plot_pacf.html](https://www.statsmodels.org/dev/generated/statsmodels.graphics.tsaplots.plot_pacf.html).
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 若要了解更多关于PACF图的内容，请访问官方文档 [https://www.statsmodels.org/dev/generated/statsmodels.graphics.tsaplots.plot_pacf.html](https://www.statsmodels.org/dev/generated/statsmodels.graphics.tsaplots.plot_pacf.html).
- en: With that, you know how to use ACF and PACF plots when building an ARIMA model
    and its variants – for example, an ARMA or SARIMA model. In the next recipe, you
    will be introduced to this chapter's first time series forecasting technique.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，你就知道在构建ARIMA模型及其变体（例如，ARMA或SARIMA模型）时，如何使用ACF和PACF图。在接下来的食谱中，你将学习本章的第一个时间序列预测技术。
- en: Forecasting univariate time series data with exponential smoothing
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用指数平滑法预测单变量时间序列数据
- en: 'In this recipe, you will explore the **exponential smoothing** technique using
    the `statsmodels` library, which offers functionality similar to popular implementations
    from the R `forecast` package, such as `ets()` and `HoltWinters()`. In statsmodels,
    there are three different implementations (*classes*) of exponential smoothing,
    depending on the nature of the data you are working with:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，你将探索使用`statsmodels`库的**指数平滑**技术，它提供了与R语言`forecast`包中的流行实现（如`ets()`和`HoltWinters()`）类似的功能。在statsmodels中，指数平滑有三种不同的实现（*类*），具体取决于你所处理数据的性质：
- en: '**SimpleExpSmoothing**: Simple exponential smoothing is used when the time
    series process lacks seasonality and trend. This is also referred to as single
    exponential smoothing.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SimpleExpSmoothing**：当时间序列过程缺乏季节性和趋势时，使用简单指数平滑法。这也被称为单一指数平滑法。'
- en: '**Holt**: Holt''s exponential smoothing is an enhancement of the simple exponential
    smoothing and is used when the time series process contains only trend (but no
    seasonality). It is referred to as double exponential smoothing.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Holt**：Holt 指数平滑是简单指数平滑的增强版本，用于处理只包含趋势（但没有季节性）的时间序列过程。它被称为双指数平滑。'
- en: '**ExponentialSmoothing**: Holt-Winters'' exponential smoothing is an enhancement
    of Holt''s exponential smoothing and is used when the time series process has
    both seasonality and trend. It is referred to as triple exponential smoothing.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ExponentialSmoothing**：Holt-Winters 指数平滑是 Holt 指数平滑的增强版本，用于处理同时具有季节性和趋势的时间序列过程。它被称为三重指数平滑。'
- en: '**You can import the classes as shown:**'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '**你可以像下面这样导入这些类：**'
- en: '[PRE19]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `statsmodels` implementation adheres to the definitions found in *Forecasting:
    principles and practice, by Hyndman, Rob J., and George Athanasopoulos*, which
    you can reference here: [https://otexts.com/fpp3/expsmooth.html](https://otexts.com/fpp3/expsmooth.html).'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`statsmodels` 的实现遵循*《预测：原理与实践》（作者：Hyndman, Rob J., and George Athanasopoulos）*中的定义，你可以在这里参考：[https://otexts.com/fpp3/expsmooth.html](https://otexts.com/fpp3/expsmooth.html)。'
- en: How to do it…
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何实现…
- en: 'In this recipe, you will perform exponential smoothing on the two datasets
    introduced earlier in the chapter (*Technical Requirements*). Since the `Holt`
    class and the `SimpleExpSmoothing` class are restricted versions of the `ExponentialSmoothing`
    class, you will be using the latter for simplicity. Instead of using all three,
    you can use the `ExponentialSmoothing` class to run the three different types
    since `ExponentialSmoothing` is a more generic implementation. This approach allows
    you to manage different types of time series—whether they exhibit trend, seasonality,
    or both—using a single, more versatile implementation. Let''s get started:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，你将对本章介绍的两个数据集进行指数平滑处理（*技术要求*）。由于`Holt`类和`SimpleExpSmoothing`类是`ExponentialSmoothing`类的简化版本，因此你可以使用后者来进行简单操作。与使用这三者不同，你可以使用`ExponentialSmoothing`类运行这三种不同类型，因为`ExponentialSmoothing`是更通用的实现。这种方法允许你使用单一更多功能的实现来管理不同类型的时间序列，无论它们是否表现出趋势、季节性或两者都有。让我们开始吧：
- en: 'Import the `ExponentialSmoothing` class:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`ExponentialSmoothing`类：
- en: '[PRE20]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You will start with the life expectancy dataset and use the `ExponentialSmoothing`
    class.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将从寿命数据集开始，并使用`ExponentialSmoothing`类。
- en: 'The `ExponentialSmoothing` takes several parameters (referred to as hyperparameters)
    and can be broken into two types: those specified when constructing the model
    and those specified while fitting the model.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExponentialSmoothing` 需要多个参数（称为超参数），可以分为两种类型：在构建模型时指定的参数和在拟合模型时指定的参数。'
- en: '**Model Construction:**'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**模型构建：**'
- en: '`trend`: Choose from ‘`multiplicative’` (alias ‘`mul`’), ''`additive`'' (alias
    ''`add`''), or `None`.'
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`trend`：选择从‘`multiplicative`’（别名‘`mul`’）、‘`additive`’（别名‘`add`’）或 `None` 中进行选择。'
- en: '`seasonal`: Choose from ‘`multiplicative’` (alias ‘`mul`’), ''`additive`''
    (alias ''`add`''), or `None`.'
  id: totrans-153
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`seasonal`：选择从‘`multiplicative`’（别名‘`mul`’）、‘`additive`’（别名‘`add`’）或 `None`
    中进行选择。'
- en: '`seasonal_periods`: An integer representing the seasonality period; for example,
    use 12 for monthly data or 4 for quarterly data.'
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`seasonal_periods`：代表季节周期的整数；例如，对于月度数据使用12，季度数据使用4。'
- en: '`damped_trend`: A Boolean value (`True` or `False`) to specify if the trend
    should be damped.'
  id: totrans-155
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`damped_trend`：布尔值（`True` 或 `False`），指定趋势是否应该被阻尼。'
- en: '`use_boxcox`: A Boolean value (`True` or `False`) to determine if a Box-Cox
    transform should be applied.'
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`use_boxcox`：布尔值（`True` 或 `False`），确定是否应用 Box-Cox 变换。'
- en: '**Model Fitting:**'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**模型拟合：**'
- en: '`smoothing_level`: A float specifying the smoothing factor for the level known
    as **alpha** ('
  id: totrans-158
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`smoothing_level`：浮点数，指定作为**alpha**的平滑水平的平滑因子。'
- en: '![](img/file169.png)'
  id: totrans-159
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/file169.png)'
- en: ), with valid values between 0 and 1 (
  id: totrans-160
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: ), 其有效值在 0 和 1 之间 (
- en: '![](img/file170.png)'
  id: totrans-161
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/file170.png)'
- en: ).
  id: totrans-162
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: ).
- en: '`smoothing_trend`: A float specifying the smoothing factor for the trend known
    as **beta** ('
  id: totrans-163
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`smoothing_trend`：浮点数，指定作为**beta**的趋势的平滑因子 ('
- en: '![](img/file171.png)'
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/file171.png)'
- en: ), with valid values between 0 and 1 (
  id: totrans-165
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: ), 其有效值在 0 和 1 之间 (
- en: '![](img/file172.png)'
  id: totrans-166
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/file172.png)'
- en: ).
  id: totrans-167
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: ).
- en: '`smoothing_seasonal`: A float specifying the smoothing factor for the seasonal
    trend known as *gamma* ('
  id: totrans-168
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`smoothing_seasonal`：浮点数，指定作为*gamma*的季节性趋势的平滑因子。'
- en: '![](img/file173.png)'
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/file173.png)'
- en: ), with valid values between 0 and 1 (
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: ), 其有效值在 0 和 1 之间 (
- en: '![](img/file174.png)'
  id: totrans-171
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/file174.png)'
- en: ).
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: ).
- en: Later, in the *How it works…* section, you will explore the **Holt-Winters'**
    formulas for level, trend, and seasonality and how these parameters are applied.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在后续的*如何运作...*部分，你将探索**霍尔特-温特斯（Holt-Winters）**的水平、趋势和季节性公式，以及这些参数是如何应用的。
- en: Create a list that contains different combinations of values for the **hyperparameters**.
    This way, in the next step you get to evaluate different combination of hyperparameter
    values in each run. Essentially, you will train a different model and capture
    its scores during each iteration. Once every combination has been evaluated, you
    will use the `get_top_models_df` function (from the *Technical requirements* section)
    to determine the best-performing model and its optimal hyperparameter values through
    this exhaustive grid search. This process can be a time-consuming process, but
    fortunately, there is an alternative hybrid technique to shorten the search.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含不同超参数值组合的列表。这样，在下一步中，你可以在每次运行中评估不同的超参数值组合。从本质上讲，你将训练不同的模型，并在每次迭代中记录其得分。一旦每个组合都被评估，你将使用`get_top_models_df`函数（来自*技术要求*部分）来确定表现最好的模型及其最佳超参数值，通过这个详尽的网格搜索过程。这个过程可能需要耗费一些时间，但幸运的是，有一种混合技术可以缩短搜索时间。
- en: You can use the `ExponentialSmoothing` class to find the optimal values for
    `alpha`, `beta`, and `gamma` (![](img/file175.png)). This approach eliminates
    the need to specify these values in your grid (although you still do so if you
    prefer to control the process). This simplification means that you only need to
    provide values for the remaining hyperparameters like `trend` and `seasonal`.
    You can initially attempt to identify whether the components are multiplicative
    or additive by plotting their decomposition using the `seasonal_decompose()` function.
    If you're still uncertain, the exhaustive grid search remains a viable alternative.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`ExponentialSmoothing`类来找到`alpha`、`beta`和`gamma`的最佳值（![](img/file175.png)）。这种方法无需在网格中指定这些值（尽管如果你更愿意控制过程，仍然可以指定）。这种简化意味着你只需提供剩余超参数的值，如`trend`和`seasonal`。你可以通过使用`seasonal_decompose()`函数绘制它们的分解，初步判断这些组件是乘法型还是加法型。如果仍不确定，详尽的网格搜索仍然是一个可行的替代方案。
- en: 'For the `life` DataFrame, you only have *trend*, so you only need to explore
    different values for the *two* parameters; that is, `trend` and `damped`:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`life`数据框，只有*trend*，因此你只需要探索*两个*参数的不同值；即`trend`和`damped`：
- en: '[PRE21]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here, we have two parameters that take two different values, each providing
    us with a 2x2 or four total combinations to evaluate for.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有两个参数，每个参数有两个不同的值，这为我们提供了2x2或四个总的组合来评估。
- en: 'Loop through the combination list and train (fit) a different model at each
    iteration. Capture the evaluation metrics in a dictionary to compare the results
    later. Example scores you will capture include RMSE, RMSPE, MAPE, AIC, and BIC,
    to name a few. Keep in mind that most automated tools and software will use the
    AIC and BIC scores behind the scenes to determine the best model:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遍历组合列表，并在每次迭代中训练（拟合）一个不同的模型。将评估指标捕捉到字典中，以便稍后比较结果。你将捕捉到的示例得分包括RMSE、RMSPE、MAPE、AIC和BIC等。请记住，大多数自动化工具和软件会在后台使用AIC和BIC分数来确定最佳模型：
- en: '[PRE22]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the previous function, you used `life_train` for training the different models,
    and `life_test` for evaluating the error metrics such as RMSPE, RMSE, and MAPE.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的函数中，你使用`life_train`来训练不同的模型，使用`life_test`来评估错误度量，如RMSPE、RMSE和MAPE。
- en: 'To retrieve the top models using the `get_top_models_df` function, just pass
    the scores dictionary. For now, keep the default criteria set to `c=AIC` to be
    consistent:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`get_top_models_df`函数获取前几个模型，只需传递得分字典。目前，保持默认标准设置为`c=AIC`以保持一致性：
- en: '[PRE23]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `get_top_models_df` function will return a DataFrame displaying the top
    models (up to 5 by default), ranked based on the criterion selected, such as the
    AIC score in this case. The DataFrame not only includes all additional scores
    but also stores the model instances themselves in a column labeled 'model'.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`get_top_models_df`函数将返回一个DataFrame，显示排名前五的模型（默认为5），根据所选标准进行排名，例如在此案例中是AIC分数。DataFrame不仅包含所有附加得分，还将模型实例本身存储在名为''model''的列中。'
- en: 'To view the ranking and the various scores, you can execute the following line:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看排名和各种得分，你可以执行以下代码：
- en: '[PRE24]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The preceding code excludes the last column which contains the model instances,
    thus displaying a DataFrame that includes columns for each of the evaluation metrics
    such as AIC, BIC, RMSE, etc
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码排除了最后一列，该列包含模型实例，因此显示的 DataFrame 包括 AIC、BIC、RMSE 等每个评估指标的列。
- en: '![Figure 10.10: Exponential Smoothing models for the Life Expectancy data ranked
    based on AIC scores](img/file176.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.10：基于 AIC 分数排名的寿命预期数据的指数平滑模型](img/file176.png)'
- en: 'Figure 10.10: Exponential Smoothing models for the Life Expectancy data ranked
    based on AIC scores'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.10：基于 AIC 分数排名的寿命预期数据的指数平滑模型
- en: 'Generally, for model selection based on information criteria such as AIC, BIC,
    and AICc, lower values are better, indicating a more optimal balance between model
    fit and complexity. In our case we opted to use AIC. If you inspect the DataFrame
    in figure 10.10 there are a few observations you can make:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，对于基于信息准则（如 AIC、BIC 和 AICc）进行的模型选择，较低的值更好，表示模型拟合和复杂度之间的更优平衡。在我们的案例中，我们选择使用
    AIC。如果您检查图 10.10 中的 DataFrame，会发现一些可以观察到的现象：
- en: 'If prioritizing information criteria (AIC, BIC, AICc), **Model 1** (trend:
    additive, damped: False) would be considered the best model as it scores the lowest
    across all three information criteria. This model likely offers the best trade-off
    between model complexity and fit.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果优先考虑信息准则（AIC、BIC、AICc），**模型 1**（趋势：加性，阻尼：False）会被视为最佳模型，因为它在所有三个信息准则中得分最低。该模型可能在模型复杂度和拟合度之间提供了最佳的折衷。
- en: 'If prioritizing error metrics (RMSPE, RMSE, MAPE), which measure prediction
    accuracy, **Model 0** (trend: additive, damped: True) would be considered superior
    due to its lower prediction errors.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果优先考虑误差指标（RMSPE、RMSE、MAPE），这些指标用于衡量预测精度，**模型 0**（趋势：加性，阻尼：True）会被认为是更优的，因为它的预测误差较小。
- en: Selecting the "winning" model will depend on your specific goals and the context
    in which the model will be used. If you need a balance between both approaches,
    you might consider other factors or further validation to decide between Models
    1 and 0.
  id: totrans-193
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 选择“获胜”模型将取决于您的具体目标和模型将被使用的上下文。如果您需要两者之间的平衡，您可能需要考虑其他因素或进一步验证，以决定选择模型 1 还是模型
    0。
- en: We will continue with the AIC as our selection criteria.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续使用 AIC 作为我们的选择标准。
- en: 'The models stored in the DataFrame are an instance of the `HoltWintersResultsWrapper`
    class. You can access the top model directly from the DataFrame, which allows
    you to utilize additional methods and attributes associated with the model, such
    as `summary`, `predict`, and `forecast`. To extract and interact with the winning
    model in the first row, use the following code:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 存储在 DataFrame 中的模型是 `HoltWintersResultsWrapper` 类的实例。您可以直接从 DataFrame 访问顶部模型，这样可以利用与该模型相关的其他方法和属性，如
    `summary`、`predict` 和 `forecast`。要提取并与第一行的获胜模型进行交互，请使用以下代码：
- en: '[PRE25]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You can access the `summary()` method as shown:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以像下面这样访问 `summary()` 方法：
- en: '[PRE26]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The preceding code will produce a summary output that provides a tabular layout
    detailing the model—for example, the parameter values that were used and the coefficients
    calculated:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将生成一个总结输出，提供一个表格布局，详细展示模型——例如，使用的参数值和计算出的系数：
- en: '![Figure 10.11: Exponential Smoothing summary for the life expectancy data](img/file177.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.11：寿命预期数据的指数平滑总结](img/file177.png)'
- en: 'Figure 10.11: Exponential Smoothing summary for the life expectancy data'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.11：寿命预期数据的指数平滑总结
- en: The summary will show key information such as the optimal values for **alpha**
    (*smoothing_level*) and **beta** (*smoothing_trend*) that have been automatically
    deduced by the fitting process.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 总结将显示关键的信息，例如通过拟合过程自动推导出的**alpha**（*平滑水平*）和**beta**（*平滑趋势*）的最佳值。
- en: 'You can forecast future values using the `forecast` method and then evaluate
    the results against the test set (unseen data by the model). The `plot_forecast()`
    function, which we introduced earlier in this chapter in the *Technical requirements*
    section, will be used to generate and plot the forecast results alongside the
    test data. To perform this visualization, pass the model object stored in `top_model`
    along with both the `training` and `test` datasets to `plot_forecast()`:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以使用 `forecast` 方法预测未来的值，然后将结果与测试集（模型未见过的数据）进行比较。我们在本章的*技术要求*部分介绍的 `plot_forecast()`
    函数将用于生成并绘制预测结果，同时显示测试数据。要执行此可视化，将存储在 `top_model` 中的模型对象与 `training` 和 `test` 数据集一起传递给
    `plot_forecast()`：
- en: '[PRE27]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `start` argument in the `plot_forecast` function slices the data from that
    point forward to make it easier to compare the results. Think of it as zooming
    in on a specific segment of the timeline. For example, instead of displaying data
    spanning from 1960 to 2018 (59 months), you request only the segment starting
    from the year 2000.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`plot_forecast`函数中的`start`参数将数据从该点开始切片，以便更容易比较结果。可以将其视为聚焦于时间线的特定片段。例如，不是显示1960到2018年（59个月）的数据，而是只请求从2000年开始的这一段数据。'
- en: 'This should produce a plot with the x-axis starting from the year 2000\. There
    should be three lines: One line representing the training data, another line for
    the test data, and a third line depicting the forecast (predicted values):'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成一个图，其中x轴从2000年开始。应有三条线：一条线表示训练数据，另一条线表示测试数据，还有一条线表示预测值（预测值）：
- en: '![Figure 10.12: Plotting the exponential smoothing forecast versus the actual
    data for the life expectancy dataset](img/file178.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![图10.12：将指数平滑预测与生命预期数据集的实际数据进行对比](img/file178.jpg)'
- en: 'Figure 10.12: Plotting the exponential smoothing forecast versus the actual
    data for the life expectancy dataset'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.12：将指数平滑预测与生命预期数据集的实际数据进行对比
- en: The forecast from the simple exponential smoothing produced a straight line
    extending the upward trend from the trained data.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 简单指数平滑的预测结果是延伸自训练数据的上升趋势的直线。
- en: Replicate the same process as earlier but with the `milk` DataFrame. Keep in
    mind that the most significant difference here is the addition of the seasonal
    parameters. This means you will be adding two additional hyperparameters to evaluate
    for – that is, `seasonal` and `seasonal_periods`.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复之前的过程，但使用`milk`数据框。请记住，这里最重要的区别是添加了季节性参数。这意味着你将添加两个额外的超参数来进行评估——即`seasonal`和`seasonal_periods`。
- en: 'Build a cartesian product for the different options. For `seasonal_periods`,
    you can explore three periods – 4, 6, and 12 months. This should give you a total
    of 24 models that you will need to evaluate for:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 为不同选项构建笛卡尔积。对于`seasonal_periods`，你可以探索三个周期——4、6和12个月。这应该会给你提供24个需要评估的模型：
- en: '[PRE28]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Loop through the list of combinations to train multiple models and capture
    their scores:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 循环遍历组合列表，训练多个模型并捕获它们的得分：
- en: '[PRE29]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Upon training completion, run the `get_top_models_df` function to identify
    the top models based on the AIC score:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 训练完成后，运行`get_top_models_df`函数，根据AIC得分识别出最佳模型：
- en: '[PRE30]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This should display the following DataFrame:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示以下数据框：
- en: '![Figure 10.13: Top 5 Exponential Smoothing models for the Milk Production
    data ranked based on AIC scores](img/file179.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![图10.13：基于AIC得分排名的牛奶生产数据前5个指数平滑模型](img/file179.png)'
- en: 'Figure 10.13: Top 5 Exponential Smoothing models for the Milk Production data
    ranked based on AIC scores'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.13：基于AIC得分排名的牛奶生产数据前5个指数平滑模型
- en: To determine the winning model from the results, you typically look at various
    metrics like AIC, BIC, AICc (which are information criteria), and error metrics
    such as RMSPE, RMSE, and MAPE. Lower values in AIC, BIC, and AICc indicate a model
    with a better balance between goodness of fit and complexity. Lower values in
    RMSPE, RMSE, and MAPE indicate better predictive accuracy.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 要从结果中确定获胜模型，通常会查看各种度量标准，如AIC、BIC、AICc（信息准则）以及误差度量，如RMSPE、RMSE和MAPE。AIC、BIC和AICc的较低值表示模型在拟合优度和复杂性之间有更好的平衡。RMSPE、RMSE和MAPE的较低值表示更好的预测精度。
- en: 'If you inspect the DataFrame in Figure 10.13 there are a few observations you
    can make:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你检查图10.13中的数据框，你会发现有一些观察结果：
- en: 'If prioritizing information criteria (AIC, BIC, AICc), **Model 8** (trend:
    additive, damped: False) appears to be the best model as it has the lowest values
    across all information criteria. This suggests that it provides a favorable balance
    between fitting the data well and maintaining simplicity.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如果优先考虑信息准则（AIC、BIC、AICc），**模型8**（趋势：加性，阻尼：False）似乎是最佳模型，因为它在所有信息准则中具有最低的值。这表明它在很好地拟合数据和保持简单性之间提供了一个有利的平衡。
- en: 'If prioritizing error metrics (RMSPE, RMSE, MAPE), **Model 2** (trend: additive,
    damped: True) is superior in terms of prediction accuracy. This model has the
    lowest error rates, indicating it predicts future values most accurately among
    the models listed.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果优先考虑误差度量（RMSPE、RMSE、MAPE），**模型2**（趋势：加性，阻尼：True）在预测精度方面表现更好。该模型具有最低的误差率，表明它在列出的模型中最准确地预测了未来值。
- en: Selecting the "winning" model will depend on your specific goals and the context
    in which the model will be used. If you need a balance between both approaches,
    you might consider other factors or further validation to decide between Models
    8 and 2.
  id: totrans-224
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 选择“获胜”模型将取决于您的具体目标以及模型将用于的上下文。如果您需要在两种方法之间找到平衡，您可能需要考虑其他因素或进一步验证，以决定选择模型 8 还是模型
    2。
- en: We will continue with the AIC as our selection criteria.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续使用 AIC 作为选择标准。
- en: 'You can display the best model''s summary with the following:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令显示最佳模型的汇总信息：
- en: '[PRE31]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This should produce a tabular layout summarizing the best model – for example,
    the parameter values that were used to build the model and the calculated coefficients:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该生成一个汇总最佳模型的表格布局——例如，构建模型时使用的参数值和计算出的系数：
- en: '![Figure 10.14: Exponential Smoothing summary for the Monthly Milk Production
    data](img/file180.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.14：月度牛奶生产数据的指数平滑总结](img/file180.png)'
- en: 'Figure 10.14: Exponential Smoothing summary for the Monthly Milk Production
    data'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.14：月度牛奶生产数据的指数平滑总结
- en: Notice the optimal combination of hyperparameter values for `Trend`, `Seasonal`,
    and `Seasonal Periods`. The optimal `Seasonal Periods` was at 12 months or lags.
    The summary results table will show the coefficients for all those lags, and it
    will be a long list. The preceding screenshot only shows the top section.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`趋势`、`季节性`和`季节周期`的超参数值的最佳组合。最佳的 `季节周期` 为 12 个月或滞后期。汇总结果表将显示所有这些滞后的系数，并且这将是一个很长的列表。前面的截图仅显示了顶部部分。
- en: Additionally, the summary will show key information such as the optimal values
    for alpha (*smoothing_level*), beta (*smoothing_trend*), and gamma (*smoothing_seasonal*).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，汇总还将显示关键的优化信息，如 alpha（*平滑水平*）、beta（*平滑趋势*）和 gamma（*平滑季节性*）的最佳值。
- en: Recall that the best model is selected based on the AIC score. Therefore, you
    should explore different metrics that have been captured, for example, using `get_top_models_df(score,
    'MAPE', top_n=5)`.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，最佳模型是根据 AIC 分数选定的。因此，您应探索已捕捉到的不同指标，例如使用 `get_top_models_df(score, 'MAPE',
    top_n=5)`。
- en: 'Compare your forecast using the best model against the test data:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您使用最佳模型的预测与测试数据进行比较：
- en: '[PRE32]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This should result in a plot starting from the year 1969, featuring three lines
    representing the training data, test data, and the forecast (predicted values):'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会生成一个从 1969 年开始的图表，展示三条线，分别表示训练数据、测试数据和预测（预测值）：
- en: '![Figure 10.15: Plotting the exponential smoothing forecast versus the actual
    Monthly Milk Production data](img/file181.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.15：绘制指数平滑预测与实际月度牛奶生产数据的对比](img/file181.png)'
- en: 'Figure 10.15: Plotting the exponential smoothing forecast versus the actual
    Monthly Milk Production data'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.15：绘制指数平滑预测与实际月度牛奶生产数据的对比
- en: Overall, the model effectively captured both the trend and seasonality, closely
    aligning with the actual values from the test set.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，模型有效地捕捉了趋势和季节性，且与测试集中的实际值高度吻合。
- en: How it works…
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: There are various techniques for smoothing time series data, including the simple
    moving average, simple exponential smoothing, Holt's exponential smoothing, and
    Holt-Winter's exponential smoothing.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 平滑时间序列数据有多种方法，包括简单移动平均法、简单指数平滑法、霍尔特指数平滑法和霍尔特-温特指数平滑法。
- en: The moving average model treats past values equally, while exponential smoothing
    models place greater emphasis (weight) on more recent observations. In exponential
    smoothing, the influence of older observations decreases (weight decay) exponentially,
    hence the term "exponential". This approach is based on the logical assumption
    that more recent events are likely to be more significant than older ones. For
    instance, in a daily time series, occurrences from yesterday or the day before
    are generally more relevant than those from two months ago.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 移动平均模型将过去的值视为相同，而指数平滑模型则更加注重（加权）最近的观察数据。在指数平滑中，较早观察数据的影响逐渐减少（加权衰减），因此得名“指数”。这一方法基于这样一个逻辑假设：较新的事件通常比较旧的事件更为重要。例如，在日常时间序列中，昨天或前天的事件通常比两个月前的事件更为相关。
- en: 'The formula for simple exponential smoothing (single), ideal for time series
    processes without trend or seasonality, is as follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 简单指数平滑（单一）的公式，适用于没有趋势或季节性的时间序列过程，如下所示：
- en: '![](img/file182.jpg)Here, the `ExponentialSmoothing` class aims to find the
    optimal value for the smoothing parameter **alpha** (![](img/file183.png)). In
    this formula,![](img/file184.png)represents the expected (smoothed) level at the
    current time![](img/file185.png),![](img/file186.png)is the previous smoothed
    level value at time![](img/file187.png), and![](img/file188.png)is the observed
    value at the current time![](img/file189.png). The alpha (![](img/file190.png))
    parameter is critical, serving as the level smoothing parameter and plays a role
    in determining whether the model should trust the past (![](img/file191.png))
    versus the present (![](img/file192.png)). Hence, as![](img/file193.png)gets closer
    to zero, the first term,![](img/file194.png), gets closer to zero, and more weight
    is put on the past. And as![](img/file195.png)gets closer to one, then the![](img/file196.png)term
    gets closer to zero and more emphasis or weight is put on the present. Several
    factors influence the choice of![](img/file197.png), including the degree of randomness
    in the system. The output value for the coefficient![](img/file197.png)determines
    how the model weighs current and past observations to forecast future events![](img/file198.png).'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/file182.jpg)这里，`ExponentialSmoothing` 类的目标是找到平滑参数 **alpha** 的最佳值（![](img/file183.png)）。在这个公式中，![](img/file184.png)
    代表当前时刻的期望（平滑）水平，![](img/file185.png) 和 ![](img/file186.png) 分别是当前时刻和之前时刻的平滑水平值，![](img/file188.png)
    是当前时刻的观测值（![](img/file189.png)）。alpha（![](img/file190.png)）参数至关重要，它作为水平平滑参数，决定了模型是否更信任过去（![](img/file191.png)）还是当前（![](img/file192.png)）。因此，当![](img/file193.png)
    趋近于零时，第一项（![](img/file194.png)）趋近于零，更多的权重会被放在过去；而当![](img/file195.png) 趋近于一时，![](img/file196.png)
    项趋近于零，更多的权重则会放在当前。选择![](img/file197.png) 的因素有很多，包括系统中的随机性程度。系数![](img/file197.png)
    的输出值决定了模型如何加权当前和过去的观测值来预测未来事件（![](img/file198.png)）。'
- en: This explanation aligns with the theme present throughout similar formulae;
    while we won't delve into every detail, the overarching concept remains consistent.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解释与类似公式中所呈现的主题一致；虽然我们不会深入探讨每个细节，但整体概念保持一致。
- en: The formula for Holt's exponential smoothing (double) incorporates the addition
    of the trend (![](img/file199.png)) and its smoothing parameter, beta (![](img/file200.png)).
    Hence, once a trend is included, the model will output the values for both coefficients
    – that is, **alpha** and **beta** (![](img/file201.png)):![](img/img_chapter10_image53.jpg)The
    Holt-Winters exponential smoothing (triple) formula incorporates both trend (![](img/img_chapter10_image56.png))
    and seasonality (![](img/file202.png)). The following equation shows **multiplicative**
    seasonality as an example:![](img/img_chapter10_image58.jpg)When using `ExponentialSmoothing`
    to find the best![](img/file203.png)parameter values, it does so by minimizing
    the error rate (the **Sum of Squared Error** or **SSE**). So, every time in the
    loop you were passing new parameters values (for example, damped as either `True`
    or `False`), the model was solving for the optimal set of values for the![](img/file203.png)coefficients
    by minimizing for SSE. This can be written as follows:![](img/img_chapter10_image64.jpg)
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: Holt 的指数平滑（双重）公式包含了趋势（![](img/file199.png)）及其平滑参数 beta（![](img/file200.png)）。因此，一旦加入趋势，模型将输出两个系数的值——即
    **alpha** 和 **beta**（![](img/file201.png)）：![](img/img_chapter10_image53.jpg)
    Holt-Winters 指数平滑（三重）公式同时包含趋势（![](img/img_chapter10_image56.png)）和季节性（![](img/file202.png)）。以下公式展示了
    **乘法** 季节性作为示例：![](img/img_chapter10_image58.jpg) 当使用 `ExponentialSmoothing` 寻找最佳![](img/file203.png)参数值时，它是通过最小化误差率（**误差平方和**
    或 **SSE**）来实现的。因此，在每次循环中，你传入新参数值（例如，damped 为 `True` 或 `False`），模型通过最小化 SSE 来求解最优的![](img/file203.png)
    系数值。这个过程可以写成如下公式：![](img/img_chapter10_image64.jpg)
- en: In some textbooks, you will see different letters used for level, trend, and
    seasonality, but the overall structure of the formulas holds.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些教科书中，你会看到不同的字母用于表示水平、趋势和季节性，但公式的整体结构是相同的。
- en: Generally, exponential smoothing is a fast and effective technique for smoothing
    a time series for improved analysis, dealing with outliers, data imputation, and
    forecasting (prediction).
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，指数平滑是一种快速且有效的技术，用于平滑时间序列以改善分析，处理异常值、数据插补和预测（预测）。
- en: There's more…
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 还有更多…
- en: An exciting library known as **Darts** offers a `ExponentialSmoothing` class
    that is a wrapper on top of statsmodels's `ExponentialSmoothing` class.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 一个名为 **Darts** 的令人兴奋的库提供了一个 `ExponentialSmoothing` 类，它是基于 statsmodels 的 `ExponentialSmoothing`
    类的封装。
- en: 'To install Darts using `pip`, run the following command:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `pip` 安装 Darts，请运行以下命令：
- en: '[PRE33]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'To install using `conda`, run the following command:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `conda` 安装，请运行以下命令：
- en: '[PRE34]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Load the `ExponentialSmoothing` and `TimeSeries` classes:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 加载 `ExponentialSmoothing` 和 `TimeSeries` 类：
- en: '[PRE35]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '**Darts** expects the data to be an instance of the `TimeSeries` class, so
    you need to convert your pandas DataFrame before using it to train the model.
    The `TimeSeries` class provides the `from_dataframe` method, which you will be
    using:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '**Darts** 期望数据是 `TimeSeries` 类的一个实例，因此在使用它来训练模型之前，你需要先将 pandas DataFrame 转换为
    `TimeSeries`。`TimeSeries` 类提供了 `from_dataframe` 方法，你将在其中使用：'
- en: '[PRE36]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'When creating the `TimeSeries` object, you must specify which column name is
    the date and which column contains the observations (values). You can train the
    model using the `.fit()` method. Once trained, you can forecast using the `.predict()`
    method. To plot the results, you can use the `.plot()` method:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建 `TimeSeries` 对象时，你必须指定哪一列是日期，哪一列包含观测值（数据）。你可以使用 `.fit()` 方法训练模型。一旦训练完成，你可以使用
    `.predict()` 方法进行预测。要绘制结果，可以使用 `.plot()` 方法：
- en: '[PRE37]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '![Figure 10.16: ExponentialSmoothing forecast for the Monthly Milk Production
    data using Darts](img/file204.png)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.16：使用 Darts 对每月牛奶生产数据进行 ExponentialSmoothing 预测](img/file204.png)'
- en: 'Figure 10.16: ExponentialSmoothing forecast for the Monthly Milk Production
    data using Darts'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.16：使用 Darts 对每月牛奶生产数据进行 ExponentialSmoothing 预测
- en: 'The `darts` library automated the evaluation process to find the optimal configuration
    (hyperparameters). Darts'' `ExponentialSmoothing` class is a wrapper to statsmodels''s
    `ExponentialSmoothing` class, which means you have access to familiar methods
    and attributes, such as the `summary()` method:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`darts` 库自动化了评估过程，以找到最佳配置（超参数）。Darts 的 `ExponentialSmoothing` 类是 statsmodels
    的 `ExponentialSmoothing` 类的封装，这意味着你可以访问熟悉的方法和属性，例如 `summary()` 方法：'
- en: '[PRE38]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This should produce the familiar statsmodels tabular summary of the model and
    the optimized parameter values. As a challenge, compare the summary using Dart
    with the results shown in *Figure 10.14*. Though you will notice you achieved
    similar results, it was with less effort using Darts. It automatically picked
    the best hyperparameters as those established in Figure 10.14.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会生成熟悉的 statsmodels 表格总结和优化后的参数值。作为挑战，请比较 Dart 的总结与 *图 10.14* 中的结果。尽管你会发现你达到了类似的结果，但使用
    Darts 时付出的努力更少。它自动选择了 *图 10.14* 中确定的最佳超参数。
- en: The Darts library features another useful class called **StatsForecastAutoETS**,
    which draws its functionality from the AutoETS implementation in the StatsForecast
    library. Compared to the traditional **ExponentialSmoothing** class, AutoETS is
    often lauded for its faster performance.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: Darts 库还包含另一个有用的类，名为 **StatsForecastAutoETS**，其功能来源于 StatsForecast 库中的 AutoETS
    实现。与传统的 **ExponentialSmoothing** 类相比，AutoETS 通常因其更快的性能而受到赞扬。
- en: 'To explore the capabilities of **StatsForecastAutoETS**, consider the following
    code snippet:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 要探索 **StatsForecastAutoETS** 的功能，可以参考以下代码片段：
- en: '[PRE39]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '![Figure 10.17: AutoETS forecast for the Monthly Milk Production data using
    Darts](img/file204.png)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.17：使用 Darts 对每月牛奶生产数据进行 AutoETS 预测](img/file204.png)'
- en: 'Figure 10.17: AutoETS forecast for the Monthly Milk Production data using Darts'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.17：使用 Darts 对每月牛奶生产数据进行 AutoETS 预测
- en: 'You can compare the two forecasts, ExponentialSmoothing and StatsForecastAutoETS,
    using the following code:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下代码比较两个预测方法，ExponentialSmoothing 和 StatsForecastAutoETS：
- en: '[PRE40]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '![Figure 10.18: Comparing AutoETS and ExponentialSmothing](img/file206.png)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.18：比较 AutoETS 和 ExponentialSmoothing](img/file206.png)'
- en: 'Figure 10.18: Comparing AutoETS and ExponentialSmothing'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.18：比较 AutoETS 和 ExponentialSmoothing
- en: The top line represents the `ExponentialSmoothing` forecast, while the bottom
    line represents the `StatsForecastAutoETS` forecast.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的线表示 `ExponentialSmoothing` 预测结果，而下面的线表示 `StatsForecastAutoETS` 预测结果。
- en: '**Exponential Smoothing versus ETS**'
  id: totrans-276
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**指数平滑与 ETS**'
- en: ''
  id: totrans-277
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ETS and Exponential Smoothing are very closely related, as they both use smoothing
    of past data points for forecasting time series data. However, they differ in
    their approach. Exponential Smoothing estimates the parameters by minimizing the
    Sum of Squared Errors, while ETS maximizes the likelihood. Additionally, Exponential
    Smoothing provides point forecasts (predictions). ETS also provides the same point
    forecasts but with added prediction intervals
  id: totrans-278
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ETS 和指数平滑密切相关，因为它们都使用过去数据点的平滑方法来预测时间序列数据。然而，它们在方法上有所不同。指数平滑通过最小化平方误差和来估计参数，而
    ETS 则通过最大化似然估计。此外，指数平滑提供点预测（预测值），ETS 也提供相同的点预测，但附带预测区间。
- en: See also
  id: totrans-279
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参见
- en: To learn more about the `ExponentialSmoothing` class, you can visit statsmodels's
    official documentation at [https://www.statsmodels.org/dev/generated/statsmodels.tsa.holtwinters.ExponentialSmoothing.html](https://www.statsmodels.org/dev/generated/statsmodels.tsa.holtwinters.ExponentialSmoothing.html).
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多有关 `ExponentialSmoothing` 类的信息，您可以访问 statsmodels 的官方文档：[https://www.statsmodels.org/dev/generated/statsmodels.tsa.holtwinters.ExponentialSmoothing.html](https://www.statsmodels.org/dev/generated/statsmodels.tsa.holtwinters.ExponentialSmoothing.html)。
- en: Did you notice that you did not have to test for stationarity with exponential
    smoothing? Exponential smoothing is only appropriate for non-stationary time series
    (for example, a time series with trend or seasonality).
  id: totrans-281
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 您是否注意到在指数平滑中无需进行平稳性检验？指数平滑仅适用于非平稳时间序列（例如具有趋势或季节性的时间序列）。
- en: In the next section, while building an ARIMA model, you will be testing for
    stationarity to determine the differencing factor and leverage the ACF and PACF
    plots that were discussed earlier in this chapter.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一部分，在构建 ARIMA 模型时，您将进行平稳性检验，以确定差分阶数，并利用本章前面讨论过的 ACF 和 PACF 图。
- en: Forecasting univariate time series data with ARIMA
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 ARIMA 进行单变量时间序列数据预测
- en: 'In this recipe, you will explore ARIMA, using the **statsmodels** package for
    implementation. ARIMA stands for Autoregressive Integrated Moving Average, which
    combines three principal components: the **autoregressive** or `AR(p)` model,
    the **moving average** or `MA(q)` model, and an **integrated** process or `I(d)`
    which applies differencing to the data.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，您将探索 ARIMA，使用 **statsmodels** 包进行实现。ARIMA 代表自回归集成滑动平均（Autoregressive Integrated
    Moving Average），它结合了三种主要成分：**自回归**或 `AR(p)` 模型、**滑动平均**或 `MA(q)` 模型和一个**集成**过程或
    `I(d)`，它对数据应用差分。
- en: An ARIMA model is characterized by the `p`, `d`, and `q` parameters, an ARIMA
    model for a non-seasonal time series is described by the notation `ARIMA(p, d,
    q)`. The `p` and `q` parameters denote the **orders or lags**; for example, an
    AR of order `p` and MA of order `q`. They are called lags as they represent the
    number of “past” periods we need to consider. You may also come across another
    reference for `p` and `q`, namely **polynomial degrees**.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: ARIMA 模型通过 `p`、`d` 和 `q` 参数来表征，非季节性时间序列的 ARIMA 模型用符号 `ARIMA(p, d, q)` 来描述。`p`
    和 `q` 参数表示**阶数或滞后**；例如，`AR` 的阶数为 `p`，`MA` 的阶数为 `q`。它们被称为滞后，因为它们表示我们需要考虑的“过去”时期的数量。您可能还会遇到另一种关于
    `p` 和 `q` 的称呼，即**多项式的阶数**。
- en: ARIMA models can handle non-stationary time series data through differencing,
    a time series transformation technique, to make a non-stationary time series stationary.
    The integration or order of differencing, `d`, is one of the parameters that you
    will need to pick a value for when building the model. For a refresher on stationarity,
    please refer to the *Detecting time series stationarity recipe in Chapter 9, Exploratory
    Data Analysis and Diagnosis*.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: ARIMA 模型通过差分（一种时间序列转换技术）来处理非平稳时间序列数据，从而使非平稳时间序列变为平稳。差分的阶数或集成阶数 `d` 是构建模型时需要选择的参数之一。有关平稳性的复习，请参阅
    *第9章，探索性数据分析与诊断中的检测时间序列平稳性配方*。
- en: While ARIMA models are designed to handle trends by utilizing the integrated
    factor '*d*', they traditionally assume the absence of seasonality within the
    dataset. However, should seasonality be a factor, the Seasonal ARIMA, or SARIMA,
    model is the appropriate alternative, as it extends ARIMA to include seasonal
    differencing.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 ARIMA 模型通过利用集成因子 '*d*' 设计用于处理趋势，但它们传统上假设数据集中没有季节性。然而，如果季节性是一个因素，那么季节性 ARIMA（SARIMA）模型就是合适的替代方案，因为它扩展了
    ARIMA，包含季节性差分。
- en: Getting ready
  id: totrans-288
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Start by loading this recipe''s necessary classes and functions from the `statsmodels`
    library:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，从 `statsmodels` 库加载本配方所需的类和函数：
- en: '[PRE41]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: How to do it…
  id: totrans-291
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何操作……
- en: Different time series models are suited to various kinds of data. Therefore,
    it is crucial to choose a model that aligns with the characteristics of your dataset
    and the specific problem you're addressing. In this recipe, you will use the `life`
    DataFrame, which exhibits a trend but no seasonality.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的时间序列模型适用于各种类型的数据。因此，选择一个与数据集的特征以及你所解决的具体问题相符合的模型至关重要。在本例中，你将使用`life`数据框，它呈现出趋势但没有季节性。
- en: 'You will combine visual inspection (using the ACF and PACF plots) and statistical
    tests to make an informed decision for the AR and MA components of the model -
    known as the `p` and `q` orders. These methods were covered in *Chapter 9*, *Exploratory
    Data Analysis and Diagnosis*, in the *Testing data for autocorrelation*, *Decomposing
    time series data*, and *Detecting time series stationarity* recipes. Let''s get
    started:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 你将结合视觉检查（使用ACF和PACF图）和统计检验，以便做出关于AR和MA模型成分（即`p`和`q`阶数）的明智决策。这些方法在*第9章*，*探索性数据分析与诊断*中已有介绍，包括*自相关性检验*、*时间序列数据分解*和*时间序列平稳性检测*的相关内容。让我们开始吧：
- en: 'Begin by **decomposing** the dataset to separate it into its three principal
    components: trend, seasonality, and residual (often considered as noise). You
    can achieve this using the `seasonal_decompose` function'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先通过**分解**数据集，将其分为三个主要成分：趋势、季节性和残差（通常被认为是噪声）。你可以使用`seasonal_decompose`函数来实现这一点。
- en: '[PRE42]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'You can see the plot as follows:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到以下图表：
- en: '![Figure 10.19: Decomposition of life expectancy data](img/file205.png)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.19：生命预期数据的分解](img/file205.png)'
- en: 'Figure 10.19: Decomposition of life expectancy data'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.19：生命预期数据的分解
- en: Observe that the decomposition shows a positive (upward) trend within the dataset.
    This indicates a consistent increase over time. However, there is no observable
    seasonality effect, which aligns with our expectations for the **life** dataset.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 观察到分解结果显示数据集中有一个正向（上升）趋势。这表明数据随时间的一致增长。然而，数据中没有明显的季节性效应，这与我们对**生命**数据集的预期一致。
- en: 'You will need to detrend the data first. Perform a first-order differencing
    and then test for stationarity by using the `check_stationarity` function you
    created earlier in this chapter:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你需要首先对数据进行去趋势处理。进行一次差分，然后使用本章前面创建的`check_stationarity`函数测试数据的平稳性：
- en: '[PRE43]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Now, the data is *stationary*. The p-value is significant, and you can reject
    the null hypothesis. Note that the default `periods` value for `diff()` is `1`.
    Generally, `diff(periods=n)` is the difference between the current observation
    at period `t` and its lagged version at period `t-n`. In the case of `diff(1)`
    or `diff()`, the lagged version is `t-1` (for example, the prior month's observation).
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，数据是*平稳的*。p值显著，可以拒绝原假设。请注意，`diff()`的默认`periods`值为`1`。通常，`diff(periods=n)`表示当前时期`t`的观测值与其滞后版本`t-n`之间的差异。对于`diff(1)`或`diff()`，滞后版本是`t-1`（例如，前一个月的观测值）。
- en: 'You can plot the differenced time series data using the `plot` method:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`plot`方法绘制差分后的时间序列数据：
- en: '[PRE44]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This should produce the following plot:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成以下图表：
- en: '![Figure 10.20: First-order differencing for life expectancy data (detrending)](img/file207.png)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.20：生命预期数据的一阶差分（去趋势）](img/file207.png)'
- en: 'Figure 10.20: First-order differencing for life expectancy data (detrending)'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.20：生命预期数据的一阶差分（去趋势）
- en: Next, you will need to determine the `p` and `q` orders for the ARIMA (p, d,
    q) model.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要确定ARIMA（p, d, q）模型的`p`和`q`阶数。
- en: 'The ACF and PACF plots will help you estimate the appropriate `p` and `q` values
    for the AR and MA models, respectively. Use `plot_acf` and `plot_pacf` on the
    stationary `life_df1` data:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ACF和PACF图将帮助你估计AR和MA模型的合适`p`和`q`值。对平稳化后的`life_df1`数据使用`plot_acf`和`plot_pacf`：
- en: '[PRE45]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'It produces the following plots:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 它会生成以下图表：
- en: '![](img/file208.png)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
  zh: '![](img/file208.png)'
- en: 'Figure 10.21: ACF and PACF plot for life expectancy data after differencing'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.21：差分后的生命预期数据的ACF和PACF图
- en: In the preceding example, the zero lag is included in the plot to help you visually
    compare it against past lags. The ACF and PACF at lag(0) are always one; they
    are sometimes omitted from plots because they does not provide any meaningful
    information. Therefore, it’s more important to focus on lag(1) and subsequent
    lags to determine their significance.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，零滞后值被包含在图表中，以帮助你将其与过去的滞后期进行可视化比较。滞后期为0时，ACF和PACF的值总是为1；它们有时会被从图表中省略，因为它们并不提供有意义的信息。因此，更重要的是关注滞后期1及之后的滞后期，以确定它们的显著性。
- en: The ACF plot helps identify significant lags for the MA(q) component. The ACF
    plot shows a cut-off after lag 1, indicating an MA(1) model. Conversely, the PACF
    plot helps determine the significant lags for the AR(p) component. You can observe
    a gradual decay with oscillation after lag 1, indicating an MA model at lag 1
    or MA(1). This indicates a lack of an AR process, so the `p` order is zero or
    AR(0). Please refer to *Table 10.1* for more details.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: ACF图有助于识别MA(q)组件的重要滞后。ACF图在滞后1后显示截断，表示MA(1)模型。相反，PACF图有助于确定AR(p)组件的重要滞后。你可以观察到滞后1后逐渐衰减并有振荡，表明在滞后1处是MA模型或MA(1)。这表示没有AR过程，因此`p`阶数为零或AR(0)。有关更多细节，请参考*表10.1*。
- en: An MA(1) process is also called a first-order moving average process, and implies
    that the current value (at time `t`) is influenced by the value immediately preceding
    it (at time `t-1`).
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: MA(1)过程也叫做一阶移动平均过程，意味着当前值（在时间`t`时刻）受紧接其前一个值（在时间`t-1`时刻）的影响。
- en: Now, you can construct an ARIMA(p, d, q) model using p=0, q=1, and d=1 specifications
    , resulting in an `ARIMA(0,1,1)`. Often, the optimal lag values (orders) for p
    and q are not immediately apparent, so you will need to experiment by evaluating
    multiple ARIMA models using different p, d, and q parameters. This can be archived
    through approaches like grid-search, similar to the method described and used
    in the *Forecasting univariate time series data with Exponential Smoothing* recipe.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以使用p=0，q=1，d=1的配置构建ARIMA(p, d, q)模型，从而得到`ARIMA(0,1,1)`。通常，p和q的最佳滞后值（阶数）并不一目了然，因此你需要通过评估多个ARIMA模型并使用不同的p、d、q参数来进行实验。这可以通过网格搜索等方法实现，类似于*使用指数平滑法预测单变量时间序列数据*中描述的方法。
- en: 'Train the ARIMA model on the training set, `life_train`, and inspect the model''s
    summary. It is important not to use the previously differenced `life_df1` for
    this, since ARIMA internally applies differencing based on the value of the `d`
    parameter. In this example, since first-order differencing (d=1) was satisfactory
    to detrend and make the data stationary, and you will set `d=1` in the model initialization:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在训练集`life_train`上训练ARIMA模型，并查看模型的摘要。重要的是不要使用之前差分过的`life_df1`，因为ARIMA内部会根据`d`参数的值进行差分。在这个例子中，由于一阶差分（d=1）足以去趋势并使数据平稳，你将设置模型初始化中的`d=1`：
- en: '[PRE46]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'You will see the summary as follows:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到如下摘要：
- en: '![Figure 10.22: Summary of ARIMA(0,1,1) for the life expectancy data](img/img_chapter10_image71.jpg)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
  zh: '![图10.22：ARIMA(0,1,1)模型在预期寿命数据上的摘要](img/img_chapter10_image71.jpg)'
- en: 'Figure 10.22: Summary of ARIMA(0,1,1) for the life expectancy data'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.22：ARIMA(0,1,1)模型在预期寿命数据上的摘要
- en: Notice that the AIC and BIC scores are provided in the model summary. While
    these scores are useful, they are most meaningful when used to compare multiple
    models, as they help in assessing model fit while penalizing excessive complexity.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在模型摘要中提供了AIC和BIC评分。虽然这些评分很有用，但它们在用于比较多个模型时最有意义，因为它们有助于评估模型拟合度，同时惩罚过度复杂的模型。
- en: In this example, the ARIMA model is primarily an MA process with an integration
    (differencing) factor of `d=1`, the summary results provide the coefficient values
    for the MA(1) component only. More on that in the *How it works…* section.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，ARIMA模型主要是一个MA过程，差分因子（d=1），摘要结果仅提供了MA(1)组件的系数值。有关更多信息，请参阅*如何工作…*部分。
- en: 'You will need to validate the model''s residuals to determine if the ARIMA(0,
    1, 1) model adequately captured the information in the time series. You would
    assume the residuals from the model''s prediction are random (noise) and do not
    follow a pattern. More specifically, you would expect no autocorrelation in the
    residuals. You can start with the `acorr_ljungbox` test followed by the autocorrelation
    (ACF) plot on the residuals. Ideally, if the model was good you would expect no
    autocorrelation:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你需要验证模型的残差，以确定ARIMA(0, 1, 1)模型是否充分捕捉了时间序列中的信息。你会假设模型预测的残差是随机的（噪声），并且不遵循任何模式。更具体地说，你期望残差中没有自相关。你可以从`acorr_ljungbox`检验开始，然后查看残差的自相关函数（ACF）图。如果模型效果良好，你应该不期望看到任何自相关：
- en: '[PRE47]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The result shows `0`, which is an aggregate of the results for the first 25
    lags, indicating no autocorrelation.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 结果显示`0`，这是前25个滞后的结果的汇总，表示没有自相关。
- en: 'Try the ACF plot as well:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以尝试查看ACF图：
- en: '[PRE48]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This should produce an ACF plot. Here you would expect the plot to show no
    significant lags. In other words, all the vertical lines should be closer to zero
    or at zero for all lags:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该生成一个ACF图。在这里，你应该期望图表不会显示出显著的滞后。换句话说，所有垂直线应该更接近零，或者对于所有滞后都应该为零：
- en: '![Figure 10.23: ACF plot showing no autocorrelation for the residuals](img/file209.png)'
  id: totrans-331
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.23：显示残差没有自相关的ACF图](img/file209.png)'
- en: 'Figure 10.23: ACF plot showing no autocorrelation for the residuals'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.23：显示残差没有自相关的ACF图
- en: This plot confirms no signs of autocorrelation (visually).
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 该图表确认了没有自相关的迹象（视觉上）。
- en: 'You can also inspect the distribution of the residuals. For example, you would
    expect normally distributed residuals with a mean of zero. You can use the QQPlot
    and **Kernel Density Estimation** (**KDE**) plot to observe the distribution and
    assess normality. You can accomplish this with the `plot_diagnostics` method:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你还可以检查残差的分布。例如，你应该期望残差符合正态分布，均值为零。你可以使用QQ图和**核密度估计**（**KDE**）图来观察分布并评估正态性。你可以使用`plot_diagnostics`方法来实现：
- en: '[PRE49]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The preceding code will produce following plots:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码将生成以下图表：
- en: '![Figure 10.24: Visual diagnostics for the ARIMA(0,1,1) model](img/file210.png)'
  id: totrans-337
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.24：ARIMA(0,1,1)模型的视觉诊断](img/file210.png)'
- en: 'Figure 10.24: Visual diagnostics for the ARIMA(0,1,1) model'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.24：ARIMA(0,1,1)模型的视觉诊断
- en: The plots show a slight deviation from a normal distribution. For example, a
    perfect normally distributed dataset will have a perfect bell-curved KDE plot
    and all the points will be perfectly aligned on the line in the QQPlot.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 这些图表显示了与正态分布的轻微偏差。例如，一个完美的正态分布数据集将具有完美的钟形KDE图，并且所有点将在QQ图中完美对齐在直线上。
- en: So far, the results and diagnostics indicate a decent model, though there might
    be room for improvements. Remember, building an ARIMA model is often an iterative
    process involving multiple rounds of testing and adjustments to achieve the best
    results.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，结果和诊断表明模型表现良好，尽管可能还有改进的空间。记住，构建ARIMA模型通常是一个迭代过程，涉及多轮测试和调整，以达到最佳结果。
- en: 'The final step in the ARIMA modeling process is to forecast future values and
    compare these predictions with your test dataset, which represents unseen or out-of-sample
    data. Use the `plot_forecast()` function, which you created earlier in this chapter
    in the *Technical requirements* section:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ARIMA建模过程中的最后一步是预测未来的数值，并将这些预测与测试数据集进行比较，测试数据集代表的是未见过的或超出样本的数据。使用`plot_forecast()`函数，这个函数是在本章*技术要求*部分中创建的：
- en: '[PRE50]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Executing this function will generate a plot where the x-axis starts from the
    year 1998\. The plot will display three lines: the actual data is split into two
    lines, one for the training data (`orig_train`) and another for the test data
    (`orig_test`), and a third line for the `forecast` (predicted values).'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此函数将生成一个图表，其中x轴从1998年开始。图表将显示三条线：实际数据分为两条线，一条是训练数据（`orig_train`），另一条是测试数据（`orig_test`），还有一条是`forecast`（预测值）。
- en: This visual representation helps in assessing how well the ARIMA model has captured
    the underlying patterns of the dataset and how accurately it forecasts future
    values.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 这种视觉表现有助于评估ARIMA模型是否成功捕捉了数据集的潜在模式，以及它对未来数值的预测有多准确。
- en: '![Figure 10.25: ARIMA(0,1,1) forecast versus the actual life expectancy data](img/Picture9.jpg)'
  id: totrans-345
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.25：ARIMA(0,1,1)预测与实际预期寿命数据的对比](img/Picture9.jpg)'
- en: 'Figure 10.25: ARIMA(0,1,1) forecast versus the actual life expectancy data'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.25：ARIMA(0,1,1)预测与实际预期寿命数据的对比
- en: The dashed line (forecast) doesn't seem to align with the expected trend, unlike
    the results from the exponential smoothing model shown in Figure 10.6, which demonstrated
    better performance. To address this, you can run multiple ARIMA models with varying
    (p, d, q) values and compare their RMSE, MAPE, AIC, or BIC scores to pick the
    best-fitted model. You will explore this option in the *There's more...* section.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 虚线（预测）似乎与预期的趋势不符，这与图 10.6 中的指数平滑模型结果不同，后者表现更好。为了解决这个问题，你可以运行多个具有不同(p, d, q)值的ARIMA模型，并比较它们的RMSE、MAPE、AIC或BIC分数，从而选择最佳拟合模型。你将在*后续内容...*部分探索这一选项。
- en: How it works…
  id: totrans-348
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'An autoregressive model or AR(p) is a linear model that uses observations from
    previous time steps as inputs into a regression equation to determine the predicted
    value of the next step. Hence, the *auto* part in autoregression indicates *self*
    and can be described as the regression of a variable on a past version of itself.
    A typical linear regression model will have this equation:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 自回归模型或 AR(p) 是一个线性模型，利用前几个时间步的观测值作为回归方程的输入，来确定下一个步骤的预测值。因此，自回归中的*auto*部分表示*自身*，可以描述为一个变量对其过去版本的回归。典型的线性回归模型将具有以下方程：
- en: '![](img/Picture1.jpg)Here,![](img/Picture2.png)is the predicted variable,![](img/file211.png)is
    the intercept,![](img/file212.png)are the features or independent variables, and![](img/file213.png)are
    the **coefficients** for each of the independent variables. In regression, your
    goal is to solve for these coefficients, including the intercept (think of them
    as weights), since they are later used to make predictions. The error term,![](img/file214.png),
    denotes the residual or noise (the unexplained portion of the model).'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/Picture1.jpg)这里，![](img/Picture2.png)是预测变量，![](img/file211.png)是截距，![](img/file212.png)是特征或独立变量，![](img/file213.png)是每个独立变量的**系数**。在回归分析中，你的目标是求解这些系数，包括截距（可以把它们当作权重），因为它们稍后会用于做预测。误差项，![](img/file214.png)，表示残差或噪声（模型中未解释的部分）。'
- en: 'Compare that with the autoregressive equation and you will see the similarities:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 将其与自回归方程进行比较，你将看到相似之处：
- en: '![](img/Picture3.jpg)This is an AR model of order `p` written as `AR(p)`. The
    main difference between an autoregressive and regression model is that the predicted
    variable is![](img/Picture4.jpg), which is![](img/file215.png)at the current time,![](img/file216.png),
    and that the![](img/file217.png)variables are lagged (previous) versions of![](img/file215.png).
    In this recipe, you used an ARIMA(0,1,1), which translates into an AR(0), indicating
    no autoregressive model being used.'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/Picture3.jpg)这是一个阶数为`p`的 AR 模型，表示为`AR(p)`。自回归模型与回归模型的主要区别在于预测变量是![](img/Picture4.jpg)，它是![](img/file215.png)当前时刻的值，![](img/file216.png)，而这些![](img/file217.png)变量是![](img/file215.png)的滞后（前）版本。在这个示例中，你使用了
    ARIMA(0,1,1)，即 AR(0)，表示没有使用自回归模型。'
- en: 'Unlike an autoregressive model that uses past values, the moving average or
    MA(q) uses past errors (from past estimates) to make a prediction:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用过去值的自回归模型不同，移动平均模型或 MA(q) 使用过去的误差（来自过去的估计）来进行预测：
- en: '![](img/Picture5.jpg)'
  id: totrans-354
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Picture5.jpg)'
- en: Combining the AR(p) and MA(q) models would produce an ARMA(p,q) model (autoregressive
    moving average). Both the AR and ARMA processes assume a stationary time series.
    However, suppose the time series is not stationary due to the presence of a trend.
    In that case, you cannot use the AR or ARMA models on non-stationary data, unless
    you perform some transformations, such as **differencing**. This was the case
    with the `life` data.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 将 AR(p) 和 MA(q) 模型结合会生成一个 ARMA(p,q) 模型（自回归滑动平均模型）。AR 和 ARMA 过程都假设时间序列是平稳的。然而，假设时间序列由于趋势的存在而不是平稳的，在这种情况下，除非进行一些转换，例如**差分**，否则不能在非平稳数据上使用
    AR 或 ARMA 模型。这正是`life`数据的情况。
- en: Differencing is just subtracting a current value from its previous (lagged)
    version. For example, a differencing order of one (lag=1) can be written as![](img/Picture6.png).
    In pandas, you used the `diff` method, which is set to `periods=1` by default.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 差分就是将当前值减去其前一个（滞后的）值。例如，差分阶数为一（lag=1）可以表示为![](img/Picture6.png)。在 pandas 中，你使用了`diff`方法，默认设置为`periods=1`。
- en: The ARIMA model improves on the ARMA model by adding an integrated (differencing)
    factor to make the time series stationary.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: ARIMA 模型通过添加一个集成（差分）因子来使时间序列平稳，从而改进了 ARMA 模型。
- en: You leveraged both ACF plots and PACF plots to estimate the order values for
    the AR and MA models. The autocorrelation function measures the correlation between
    a current observation and its lagged version. The purpose of the ACF plot is to
    determine how reliable past observations are in making predictions.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 你利用了 ACF 图和 PACF 图来估计 AR 和 MA 模型的阶数。自相关函数衡量当前观测值与其滞后版本之间的相关性。ACF 图的目的是确定过去的观测值在预测中的可靠性。
- en: On the other hand, a **partial autocorrelation function** (**PACF**) is like
    autocorrelation but with the relationships of intervening observations removed.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，**偏自相关函数**（**PACF**）类似于自相关，但去除了干预观测值之间的关系。
- en: ACF VERSUS PACF THROUGH AN EXAMPLE
  id: totrans-360
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ACF 与 PACF 通过示例对比
- en: ''
  id: totrans-361
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If there is a strong correlation between past observations at lags 1, 2, 3,
    and 4, this means that the correlation measure at lag 1 is influenced by the correlation
    with lag 2, lag 2 is influenced by the correlation with lag 3, and so on.
  id: totrans-362
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果在滞后1、2、3和4处存在强相关性，这意味着滞后1的相关性度量会受到与滞后2的相关性的影响，滞后2又会受到与滞后3的相关性的影响，依此类推。
- en: ''
  id: totrans-363
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The ACF measure at lag 1 will include these influences of prior lags if they
    are correlated. In contrast, a PACF at lag 1 will remove these influences to measure
    the pure relationship at lag 1 with the current observation.
  id: totrans-364
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在滞后1处的自相关函数（ACF）度量将包括这些先前滞后的影响，如果它们是相关的。相比之下，在滞后1处的偏自相关函数（PACF）会去除这些影响，以测量当前观察值与滞后1之间的纯关系。
- en: 'One of the reasons ARIMA is popular is because it generalizes to other simpler
    models, as follows:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: ARIMA之所以流行的原因之一是它能够推广到其他更简单的模型，如下所示：
- en: ARIMA(1, 0, 0) is a first-order autoregressive or AR(1) model
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ARIMA(1, 0, 0) 是一个一阶自回归或AR(1)模型
- en: ARIMA(1, 1, 0) is a *differenced* first-order autoregressive model
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ARIMA(1, 1, 0) 是一个*差分*的一级自回归模型
- en: ARIMA(0, 0, 1) is a first-order moving average or MA(1) model
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ARIMA(0, 0, 1) 是一个一阶移动平均或MA(1)模型
- en: ARIMA(1, 0, 1) is an ARMA (1,1) model
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ARIMA(1, 0, 1) 是一个ARMA(1,1)模型
- en: ARIMA(0, 1, 1) is a simple exponential smoothing model
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ARIMA(0, 1, 1) 是一个简单的指数平滑模型
- en: There's more…
  id: totrans-371
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 还有更多……
- en: Sometimes, it isn't easy to identify if the time series is an MA or AR process
    or determine the optimal order (lag) values for `p` or `q`. You can look at the
    following example of a naive grid search approach by trying different combinations
    for `p`, `d`, and `q` to train other ARIMA models before picking a winning model.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，很难确定时间序列是MA过程还是AR过程，或者确定`p`或`q`的最优阶数（滞后值）。你可以参考下面这个例子，使用一种朴素的网格搜索方法，通过尝试不同的`p`，`d`和`q`组合来训练其他ARIMA模型，然后再选择最优模型。
- en: 'Here, you will leverage the `combinator()` function that you created in the
    *Technical requirements* section. You will train multiple ARIMA models and then
    use `get_top_models_df()` to find the best model. As a starter, try a combination
    of (0,1,2) for each of the three hyperparameters (p, d, and q). You will be testing
    3x3x3 or 27 ARIMA models:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你将利用你在*技术要求*部分创建的`combinator()`函数。你将训练多个ARIMA模型，并使用`get_top_models_df()`来找到最佳模型。作为起点，尝试对三个超参数（p，d，q）进行(0,1,2)组合。你将测试3x3x3或27个ARIMA模型：
- en: '[PRE51]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This should produce a DataFrame sorted by AIC. The following table shows the
    first five models:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该生成一个按AIC排序的DataFrame。以下表格展示了前五个模型：
- en: '![Figure 10.26: Results from the 27 ARIMA models sorted by AIC score](img/Picture7.jpg)'
  id: totrans-376
  prefs: []
  type: TYPE_IMG
  zh: '![图10.26：根据AIC得分排序的27个ARIMA模型的结果](img/Picture7.jpg)'
- en: 'Figure 10.26: Results from the 27 ARIMA models sorted by AIC score'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.26：根据AIC得分排序的27个ARIMA模型的结果
- en: 'You can select the top model using the following:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下方法选择最佳模型：
- en: '[PRE52]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: If you run `best_m.summary()` to view the model's summary, you will notice that
    it is an `ARIMA(0,2, 2)`. This further confirms our earlier observation that this
    is a moving average (MA) process, but we missed the orders.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行`best_m.summary()`来查看模型摘要，你会注意到它是一个`ARIMA(0,2, 2)`模型。这进一步确认了我们之前的观察，这实际上是一个移动平均（MA）过程，但我们错过了阶数。
- en: 'The **Akaike Information Criterion** (**AIC**) is a metric that aims to find
    a balance between a model''s maximum likelihood and a model''s simplicity. Overly
    complex models can sometimes overfit, meaning they can look like they learned
    but once they are presented with unseen data, they perform poorly. The AIC score
    penalizes as the number of parameters increases since they increase complexity:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '**赤池信息量准则**（**AIC**）是一种衡量模型最大似然估计和模型简洁性之间平衡的指标。过于复杂的模型有时可能会过拟合，意味着它们看起来像是学习了，但一旦面对未见过的数据时，它们的表现会很差。AIC得分随着参数数量的增加而受到惩罚，因为它们增加了模型的复杂性：'
- en: '![](img/file219.jpg)'
  id: totrans-382
  prefs: []
  type: TYPE_IMG
  zh: '![](img/file219.jpg)'
- en: Here, *2k* is considered the penalty term.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，*2k* 被视为惩罚项。
- en: 'The **Bayesian Information Criteria** (**BIC**) is very similar to AIC but
    has a higher penalty term on the model''s complexity. In general, the BIC penalty
    term is more significant, so it can encourage models with fewer parameters than
    AIC does. Therefore, if you change the sorting or evaluation criteria from AIC
    to BIC, you may see different results. Simpler models are preferred more with
    BIC:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '**贝叶斯信息准则**（**BIC**）与AIC非常相似，但在模型的复杂性上有更高的惩罚项。通常，BIC的惩罚项更大，因此它倾向于鼓励具有较少参数的模型，相较于AIC。因此，如果你将排序或评估标准从AIC更改为BIC，你可能会看到不同的结果。BIC更偏向选择简单的模型：'
- en: '![](img/file220.jpg)Here,![](img/Picture8.png)is the maximum likelihood, *k*
    is the number of estimated parameters, and *n* is the number of data points.'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/file220.jpg)在这里，![](img/Picture8.png) 是最大似然估计，*k* 是估计的参数数量，*n* 是数据点的数量。'
- en: 'To plot a forecast using the best model, you can run the following command:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 若要使用最佳模型绘制预测图表，可以运行以下命令：
- en: '[PRE53]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'This should produce the following plot:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下图表：
- en: '![Figure 10.26: ARIMA(0,2,2) forecast versus the actual life expectancy data](img/file222.png)'
  id: totrans-389
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.26：ARIMA(0,2,2) 预测与实际的预期寿命数据对比](img/file222.png)'
- en: 'Figure 10.26: ARIMA(0,2,2) forecast versus the actual life expectancy data'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.26：ARIMA(0,2,2) 预测与实际的预期寿命数据对比
- en: Compare the output in *Figure 10.25* for ARIMA(0, 1, 1) model with *Figure 10.26*
    for the ARIMA(0,2,2). How do they compare with the Figure 10.12 using Exponential
    Smoothing?
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 比较 *图 10.25* 中 ARIMA(0, 1, 1) 模型的输出和 *图 10.26* 中 ARIMA(0,2,2) 模型的输出。它们与图 10.12
    中使用指数平滑法的结果相比如何？
- en: 'Before we proceed to the next recipe, let''s apply an ARIMA model to the Milk
    Production data, which, unlike the life expectancy data, exhibits both trend and
    seasonality:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续下一个示例之前，我们来对牛奶生产数据应用 ARIMA 模型，该数据与预期寿命数据不同，具有趋势和季节性：
- en: '[PRE54]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: After running the code and inspecting the top model with **model.summary()**,
    you will find that it identifies an ARIMA(2,2,2). The resulting forecast plot
    will likely show poor predictions overall, as depicted in Figure 10.27 – forecasting
    against actual Milk Production data
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码并检查 **model.summary()** 输出的顶级模型后，你会发现它识别为 ARIMA(2,2,2)。结果的预测图可能整体上表现较差，如图
    10.27 所示——预测与实际牛奶生产数据对比。
- en: '![Figure 10.27: ARIMA(2,2,2) forecast versus the actual Milk Production data](img/file223.png)'
  id: totrans-395
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.27：ARIMA(2,2,2) 预测与实际的牛奶生产数据对比](img/file223.png)'
- en: 'Figure 10.27: ARIMA(2,2,2) forecast versus the actual Milk Production data'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.27：ARIMA(2,2,2) 预测与实际的牛奶生产数据对比
- en: This outcome is expected since standard ARIMA models are not designed to handle
    seasonality. The next recipe will introduce SARIMA (Seasonal ARIMA), which is
    better equipped to model time series data with both seasonal patterns and trends.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结果是预期中的，因为标准的 ARIMA 模型并不设计用来处理季节性。下一个示例将介绍 SARIMA（季节性 ARIMA），它更适合建模具有季节模式和趋势的时间序列数据。
- en: See also
  id: totrans-398
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 另见
- en: To learn more about the ARIMA class, you can visit statsmodels's official documentation
    at [https://www.statsmodels.org/dev/generated/statsmodels.tsa.arima.model.ARIMA.html](https://www.statsmodels.org/dev/generated/statsmodels.tsa.arima.model.ARIMA.html).
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 若要了解更多关于 ARIMA 类的信息，你可以访问 statsmodels 的官方文档 [https://www.statsmodels.org/dev/generated/statsmodels.tsa.arima.model.ARIMA.html](https://www.statsmodels.org/dev/generated/statsmodels.tsa.arima.model.ARIMA.html)。
- en: How about the `milk` data, which has trend and seasonality? The next recipe
    will explore working with a SARIMA model to handle such data.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，具有趋势和季节性的 `milk` 数据怎么样呢？下一个示例将探索如何使用 SARIMA 模型处理此类数据。
- en: FORECAST VERSUS PREDICT METHODS
  id: totrans-401
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: FORECAST 与 PREDICT 方法的区别
- en: ''
  id: totrans-402
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In the `plot_forecast` function, we used the forecast method. In statsmodels,
    the SARIMA family of models, such as ARMA and ARIMA, have two methods for making
    predictions: `predict` and `forecast`.'
  id: totrans-403
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在 `plot_forecast` 函数中，我们使用了 forecast 方法。在 statsmodels 中，SARIMA 模型家族（如 ARMA 和
    ARIMA）有两种方法可以进行预测：`predict` 和 `forecast`。
- en: ''
  id: totrans-404
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The `predict` method allows you to include both **in-sample** (historical) and
    **out-of-sample** (future) predictions, hence why the method takes the `start`
    and `end` parameters. On the other hand, the `forecast` method only takes **steps**,
    which is the number of **out-of-sample** forecasts, starting from the end of the
    sample or the training set.
  id: totrans-405
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`predict` 方法允许你同时进行**样本内**（历史）和**样本外**（未来）的预测，因此该方法需要 `start` 和 `end` 参数。另一方面，`forecast`
    方法仅接受 **steps** 参数，表示**样本外**预测的步数，从样本或训练集的末尾开始。'
- en: Forecasting univariate time series data with Seasonal ARIMA
  id: totrans-406
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用季节性 ARIMA 进行单变量时间序列数据预测
- en: In this recipe, you will be introduced to an enhancement to the ARIMA model
    for handling seasonality, known as the **Seasonal Autoregressive Integrated Moving
    Average** or **SARIMA**. Like an ARIMA(p, d, q), a SARIMA model also requires
    (p, d, q) to represent non-seasonal orders. Additionally, a SARIMA model requires
    the orders for the seasonal component, which is denoted as (P, D, Q, s). Combining
    both components, the model can be written as a SARIMA(p, d, q)(P, D, Q, s). The
    letters still mean the same, and the letter case indicates which component. For
    example, the lowercase letters represent the non-seasonal orders, while the uppercase
    letters represent the seasonal orders. The new parameter, `s`, is the number of
    steps per cycle – for example, `s=12` for monthly data or `s=4` for quarterly
    data.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，你将接触到一种增强型 ARIMA 模型，用于处理季节性，称为**季节性自回归积分滑动平均模型**或 **SARIMA**。与 ARIMA(p,
    d, q) 类似，SARIMA 模型也需要(p, d, q)来表示非季节性阶数。此外，SARIMA 模型还需要季节性成分的阶数，表示为(P, D, Q, s)。将两者结合，模型可以写成
    SARIMA(p, d, q)(P, D, Q, s)。字母含义保持不变，字母的大小写表示不同的成分。例如，小写字母代表非季节性阶数，而大写字母代表季节性阶数。新参数`
    s `表示每个周期的步数——例如，对于月度数据，`s=12`，对于季度数据，`s=4`。
- en: In statsmodels, you will use the `SARIMAX` class to build a SARIMA model.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 在 statsmodels 中，你将使用 `SARIMAX` 类来构建 SARIMA 模型。
- en: In this recipe, you will be working with the `milk` data, which contains both
    trend and seasonality. This was prepared in the *Technical requirements* section.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，你将使用`milk`数据，该数据包含趋势性和季节性成分。此数据已在*技术要求*部分准备好。
- en: How to do it…
  id: totrans-410
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何实现…
- en: 'Follow these steps:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤操作：
- en: 'Start by importing the necessary libraries:'
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先导入必要的库：
- en: '[PRE55]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'From *Figure 10.1*, we determined that both seasonality and trend exist. We
    could also see that the seasonal effect is additive. The periodicity or number
    of periods in a season is 12 since the data is monthly. This can be confirmed
    with an ACF plot:'
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从*图 10.1*中，我们确定了季节性和趋势性都存在。我们还可以看到季节性效应是加性的。一个季节的周期或期数为 12，因为数据是按月收集的。这可以通过
    ACF 图进行确认：
- en: '[PRE56]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'This should produce an ACF plot for the `milk` data with a noticeable cyclical
    pattern of spikes at specific lags:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会生成一个`milk`数据集的 ACF 图，并在特定滞后处显示明显的周期性波动：
- en: '![Figure 10.28: ACF plot showing significant spikes at lags 1, 12, and 24](img/file224.png)'
  id: totrans-417
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.28: ACF 图显示滞后 1、12 和 24 时有显著的峰值](img/file224.png)'
- en: 'Figure 10.28: ACF plot showing significant spikes at lags 1, 12, and 24'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '图 10.28: ACF 图显示滞后 1、12 和 24 时有显著的峰值'
- en: 'Notice that there is a repeating pattern every 12 months (lags). If the pattern
    is not easy to spot, you can try the ACF plot after you difference the data –
    for example, detrend (first-order differencing) the data first, then plot the
    ACF plot:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，每 12 个月（滞后）会有一个重复的模式。如果这种模式不容易发现，可以尝试在差分数据后查看 ACF 图——例如，先对数据进行去趋势（一次差分），然后再绘制
    ACF 图：
- en: '[PRE57]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'This should produce an ACF plot on the differenced data that makes the seasonal
    spikes more apparent:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会生成一个差分数据的 ACF 图，使季节性峰值更加明显：
- en: '![Figure 10.29 – ACF plot after differencing shows significant spikes at lags
    1, 12, 24, and 36](img/file225.png)'
  id: totrans-422
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.29 – 差分后的 ACF 图显示在滞后 1、12、24 和 36 时有显著的峰值](img/file225.png)'
- en: Figure 10.29 – ACF plot after differencing shows significant spikes at lags
    1, 12, 24, and 36
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.29 – 差分后的 ACF 图显示在滞后 1、12、24 和 36 时有显著的峰值
- en: 'You can also extract the seasonal component and use that for the ACF plot,
    as shown in the following code:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以提取季节性成分并用其生成 ACF 图，如下代码所示：
- en: '[PRE58]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The ACF plot will show the autocorrelation using the seasonal component after
    decomposition and will tell a similar story to what's shown in *Figure 10.28*
    and *Figure 10.29*.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: ACF 图将显示经过分解后的季节性成分的自相关，并会讲述与*图 10.28*和*图 10.29*类似的故事。
- en: '![Figure 10.30: ACF on the seasonal component after decomposition shows significant
    spikes at lags 1, 12, 24, and 36](img/file226.png)'
  id: totrans-427
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.30: 分解后的季节性成分的 ACF 图显示在滞后 1、12、24 和 36 时有显著的峰值](img/file226.png)'
- en: 'Figure 10.30: ACF on the seasonal component after decomposition shows significant
    spikes at lags 1, 12, 24, and 36'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: '图 10.30: 分解后的季节性成分的 ACF 图显示在滞后 1、12、24 和 36 时有显著的峰值'
- en: Generally, you can assume a 12-month cycle when working with monthly data. For
    example, for the non-seasonal ARIMA portion, start with `d=1` for detrending,
    and for the seasonal ARIMA portion, start with `D=1` as well, given `s=12`.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，处理月度数据时可以假设一个 12 个月的周期。例如，对于非季节性 ARIMA 部分，可以从`d=1`开始去趋势化，对于季节性 ARIMA 部分，可以将
    `D=1` 作为起始值，前提是 `s=12`。
- en: Suppose you are not sure about the values for `d` (non-seasonal differencing)
    and `D` (seasonal differencing). In that case, you can use the `check_stationarity`
    function after differencing to determine if seasonal differencing was enough or
    not. In most cases, if the time series has both trend and seasonality, you may
    need to difference twice. First, you perform seasonal differencing, followed by
    a first-order differencing for detrending.
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设你不确定`d`（非季节性差分）和`D`（季节性差分）的值，在这种情况下，你可以在差分后使用`check_stationarity`函数来判断季节性差分是否足够。通常，如果时间序列既有趋势又有季节性，你可能需要进行两次差分。首先进行季节性差分，然后进行一阶差分以去除趋势。
- en: 'Start with seasonal differencing by using `diff(12)` (*deseasonalize*) and
    test if that is enough to make the time series stationarity. If not, then you
    will need to follow it with a first-order differencing, `diff()`:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`diff(12)`进行季节性差分（*去季节化*），并测试这是否足以使时间序列平稳。如果不够，那么你需要继续进行一阶差分`diff()`：
- en: '[PRE59]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'This should produce 2x2 subplots (two plots per row), where the extra subplot
    is hidden:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会生成2x2子图（每行两个图），其中额外的子图是隐藏的：
- en: '![Figure 10.31: Stationarity comparison for original, seasonally differenced,
    and differenced twice time series](img/file227.png)'
  id: totrans-434
  prefs: []
  type: TYPE_IMG
  zh: '![图10.31：原始数据、季节差分数据和两次差分数据的平稳性比较](img/file227.png)'
- en: 'Figure 10.31: Stationarity comparison for original, seasonally differenced,
    and differenced twice time series'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.31：原始数据、季节差分数据和两次差分数据的平稳性比较
- en: 'Now, you will need to estimate the AR and MA orders for the non-seasonal (p,
    q) and seasonal components (P, Q). To do this, you must use the ACF and PACF plots
    on the stationary data, which can be found in the `milk_dif_12_1` DataFrame:'
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你需要估计非季节性（p, q）和季节性（P, Q）分量的AR和MA阶数。为此，你必须使用平稳数据上的ACF和PACF图，这些图可以在`milk_dif_12_1`数据框中找到：
- en: '[PRE60]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'This should produce ACF and PACF plots on the same row:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会在同一行中生成ACF和PACF图：
- en: '![Figure 10.32: ACF and PACF plots for the milk data after becoming stationary](img/file228.png)'
  id: totrans-439
  prefs: []
  type: TYPE_IMG
  zh: '![图10.32：乳制品数据变为平稳后的ACF和PACF图](img/file228.png)'
- en: 'Figure 10.32: ACF and PACF plots for the milk data after becoming stationary'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.32：乳制品数据变为平稳后的ACF和PACF图
- en: Starting with the ACF plot, there is a significant spike at lag 1, which represents
    the non-seasonal order for the MA process. The spike at lag 12 represents the
    seasonal order for the MA process. Notice that there is a cut-off right after
    lag 1, then a spike at lag 12, followed by another cut-off (no other significant
    lags afterward). These are indications of a moving average model – more specifically,
    an order of `q=1` and `Q=1`.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 从自相关函数（ACF）图开始，可以看到在滞后1处有一个显著的峰值，表示MA过程的非季节性阶数。滞后12处的峰值表示MA过程的季节性阶数。注意，在滞后1之后有一个截断，接着是滞后12的峰值，然后又是另一个截断（之后没有其他显著的滞后）。这些都是移动平均模型的指示——更具体地说，是`q=1`和`Q=1`的阶数。
- en: The PACF plot confirms this as well; an exponential decay at lags 12, 24, and
    36 indicates an MA model. Here, the seasonal ARIMA would be ARIMA(0, 1,1)(0, 1,
    1, 12).
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: PACF图也确认了这一点；在滞后12、24和36处的指数衰减表明是MA模型。在这里，季节性ARIMA将是ARIMA(0, 1,1)(0, 1, 1, 12)。
- en: 'Build the SARIMA model based on the initial information that was extracted
    for the AR and MA orders. The following code will fit a SARIMA(0, 1, 1)(0, 1,
    1, 12) model on the training dataset. Note that the results may differ from those
    shown in the *Plotting ACF and PACF* recipe since the data was not split in that
    recipe, but it has been split here:'
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据最初提取的AR和MA阶数信息构建SARIMA模型。以下代码将在训练数据集上拟合一个SARIMA(0, 1, 1)(0, 1, 1, 12)模型。请注意，结果可能与*绘制ACF和PACF*中的结果有所不同，因为在该配方中数据没有被拆分，但在这里已经拆分：
- en: '[PRE61]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Now, use the `plot_diagnostics` method, which becomes available after fitting
    the model:'
  id: totrans-445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用`plot_diagnostics`方法，它将在拟合模型后可用：
- en: '[PRE62]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'This will provide four plots – a standardized residual plot, a QQPlot, an ACF
    residual plot, and a histogram with kernel density plot:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 这将提供四个图——一个标准化残差图，一个QQ图，一个ACF残差图和一个带有核密度图的直方图：
- en: '![Figure 10.33: SARIMA(0,1,1)(0,1,1,12) diagnostic plots](img/file229.png)'
  id: totrans-448
  prefs: []
  type: TYPE_IMG
  zh: '![图10.33：SARIMA(0,1,1)(0,1,1,12)诊断图](img/file229.png)'
- en: 'Figure 10.33: SARIMA(0,1,1)(0,1,1,12) diagnostic plots'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.33：SARIMA(0,1,1)(0,1,1,12)诊断图
- en: The residual's ACF plot (correlogram) does not show autocorrelation (ignoring
    the spike at lag 0 since it is always 1). However, the histogram and QQPlot show
    that the residuals do not fit a perfectly normal distribution. These are not critical
    assumptions compared to random residuals (no autocorrelation). Overall, the results
    look very promising.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 残差的ACF图（相关图）未显示自相关（忽略滞后0处的尖峰，因为它总是1）。然而，直方图和QQ图显示残差并不符合完美的正态分布。与随机残差（无自相关）相比，这些假设并不关键。总体来说，结果非常有前景。
- en: 'You can obtain the summary using the `summary` method:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`summary`方法获取摘要：
- en: '[PRE63]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'This should print out additional information regarding the model in a tabular
    format including the coefficients for the seasonal and non-seasonal components.
    Recall, the diagnostic plots are based on the standardized residuals. You can
    plot ACF for the residuals without standardization:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该以表格格式打印出关于模型的附加信息，包括季节性和非季节性成分的系数。回想一下，诊断图是基于标准化残差的。你可以绘制残差的ACF图而不进行标准化：
- en: '[PRE64]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: This should produce the following ACF plot which shows a couple of lags beyond
    the threshold indicating some autocorrelation and potential for more improvements.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该生成如下的ACF图，其中显示了阈值之外的一些滞后，表明存在自相关，并且有改进的潜力。
- en: '![Figure 10.34: The residual ACF Plot for SARIMA(0,1,1)(0,1,1,12)](img/file230.png)'
  id: totrans-456
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.34：SARIMA(0,1,1)(0,1,1,12)的残差ACF图](img/file230.png)'
- en: 'Figure 10.34: The residual ACF Plot for SARIMA(0,1,1)(0,1,1,12)'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.34：SARIMA(0,1,1)(0,1,1,12)的残差ACF图
- en: 'Use the `plot_forecast` function to plot the forecast from the SARIMA model
    and compare it with the test set:'
  id: totrans-458
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`plot_forecast`函数绘制SARIMA模型的预测，并与测试集进行比较：
- en: '[PRE65]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'This should produce a plot with the x-axis starting from the year 1971:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该生成一个图表，x轴从1971年开始：
- en: '![Figure 10.35: Milk production forecast versus actual production using SARIMA(0,1,1)(0,1,1,12)](img/file231.png)'
  id: totrans-461
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.35：使用SARIMA(0,1,1)(0,1,1,12)的牛奶生产预测与实际生产对比](img/file231.png)'
- en: 'Figure 10.35: Milk production forecast versus actual production using SARIMA(0,1,1)(0,1,1,12)'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.35：使用SARIMA(0,1,1)(0,1,1,12)的牛奶生产预测与实际生产对比
- en: Overall, the SARIMA model did a decent job of capturing the seasonal and trend
    effects. You can always iterate and test different values for (p, q) and (P, Q)
    by evaluating the results using other metrics such as RMSE, MAPE, or AIC, to name
    a few. More on that in the *There’s more…* section.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，SARIMA模型在捕捉季节性和趋势效应方面表现得相当不错。你可以通过评估使用其他度量标准（例如RMSE、MAPE或AIC等）来迭代并测试(p,
    q)和(P, Q)的不同值。更多内容请参见*还有更多……*部分。
- en: How it works…
  id: totrans-464
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: The SARIMA model extends the ARIMA model by incorporating seasonality, requiring
    an additional set of seasonal parameters. For instance, a SARIMA model with non-seasonal
    order (1, 1, 1) and no seasonal components would be specified as SARIMA(1,1,1)(0,0,0,0),
    which essentially reduces to an ARIMA(1, 1, 1) model. To handle seasonality, you
    would set the seasonal order to non-zero values
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: SARIMA模型通过加入季节性来扩展ARIMA模型，因此需要额外的一组季节性参数。例如，一个没有季节性成分的非季节性顺序为(1, 1, 1)的SARIMA模型会被指定为SARIMA(1,1,1)(0,0,0,0)，这本质上简化为ARIMA(1,
    1, 1)模型。为了处理季节性，你需要将季节性顺序设置为非零值。
- en: In statsmodels, the `SARIMAX` class generalizes AR, MA, ARMA, ARIMA, and SARIMA
    models, allowing you to fit a model tailored to your time series data, whether
    it has seasonal components or not. Similarly, as discussed in the *Forecasting
    univariate time series data with Exponential Smoothing* recipe, the `ExponentialSmoothing`
    class serves as a generalized implementation for both `SimpleExpSmoothing` and
    `Holt`’s models.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 在statsmodels中，`SARIMAX`类将AR、MA、ARMA、ARIMA和SARIMA模型进行了一般化，使你能够拟合适合自己时间序列数据的模型，无论其是否具有季节性成分。同样，正如在*使用指数平滑法预测单变量时间序列数据*一节中所讨论的，`ExponentialSmoothing`类作为`SimpleExpSmoothing`和`Holt`模型的广义实现。
- en: There's more…
  id: totrans-467
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 还有更多……
- en: Similar to the approach in the *Forecasting univariate time series data with
    ARIMA* recipe, you can execute a naive grid search to evaluate different combinations
    of the non-seasonal (p, d, q) and seasonal (P, D, Q, s) parameters to identify
    the best SARIMA model.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于*使用ARIMA预测单变量时间序列数据*一节中的方法，你可以执行一个朴素的网格搜索，以评估不同的非季节性(p, d, q)和季节性(P, D, Q,
    s)参数组合，从而确定最佳的SARIMA模型。
- en: This can be done by leveraging the `combinator()` function to loop through all
    possible parameter combinations, fitting a SARIMA model at each iteration. To
    determine the top N models, you can use the `get_top_models_df` function.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过利用`combinator()`函数来实现，遍历所有可能的参数组合，在每次迭代中拟合一个SARIMA模型。要确定前N个模型，可以使用`get_top_models_df`函数。
- en: 'For instance, let’s consider testing all combinations where the non-seasonal
    (p, d, q) parameters each takes the values (0,1,2), and the seasonal (P, D, Q)
    parameters each takes the values (0,1), while keeping `s`, the seasonal period,
    at 12\. This setup would test a total of (3x3x3x2x2x2) = 216 SARIMA models. Although
    this brute force (naïve) approach can be computationally intensive, it is still
    a valid method. Automated time series libraries such as `Auto_ARIMA` often employ
    similar exhaustive grid searches to optimize model parameters:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑测试所有组合，其中非季节性（p, d, q）参数分别取值（0,1,2），季节性（P, D, Q）参数分别取值（0,1），同时将`s`（季节周期）保持为12。这种设置将测试总共（3x3x3x2x2x2）=
    216个SARIMA模型。虽然这种暴力（朴素）方法在计算上可能非常密集，但它仍然是有效的方法。像`Auto_ARIMA`这样的自动时间序列库通常也采用类似的穷举网格搜索来优化模型参数：
- en: '[PRE66]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'After executing the previous code, it should print a status output every 15
    iterations as shown:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 执行前面的代码后，它应该每15次迭代打印一次状态输出，如下所示：
- en: '[PRE67]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Notice the `enforce_stationarity=False` parameter to avoid a `LinAlgError` that
    may occur when running a naive grid search.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意`enforce_stationarity=False`参数，以避免在进行初始网格搜索时可能出现的`LinAlgError`。
- en: 'To identify the top 5 models sorted by AIC, you can run the `get_top_models_df`
    function:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 要识别按AIC排序的前5个模型，可以运行`get_top_models_df`函数：
- en: '[PRE68]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '![Figure 10.36: Top 5 SARIMA models ranked by AIC for the Milk Production data](img/file232.png)'
  id: totrans-477
  prefs: []
  type: TYPE_IMG
  zh: '![图10.36：按AIC排名的前5个SARIMA模型，针对牛奶生产数据](img/file232.png)'
- en: 'Figure 10.36: Top 5 SARIMA models ranked by AIC for the Milk Production data'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.36：按AIC排名的前5个SARIMA模型，针对牛奶生产数据
- en: Notice that the first two models have similar AIC scores. Generally, when two
    models have similar AIC scores, the simpler model is preferred. For example, a
    SARIMA(0,2,2)(0,1,1) model is simpler than a SARIMA(2,2,2)(0,1,1) model. There
    are also other metrics such as AICc and BIC, which in this case, would favor the
    second model (model_id=67) over the first model (model_id=211). Similarly, if
    you consider RMSPE or MAPE, you may end up selecting different models.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到前两个模型的AIC得分相似。通常，当两个模型的AIC得分相似时，较简单的模型更受偏好。例如，SARIMA(0,2,2)(0,1,1)模型比SARIMA(2,2,2)(0,1,1)模型更简单。还有其他指标，如AICc和BIC，在这种情况下，它们会更倾向于选择第二个模型（model_id=67），而不是第一个模型（model_id=211）。类似地，如果考虑RMSPE或MAPE，你可能会选择不同的模型。
- en: '**Occam''s Razor**'
  id: totrans-480
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**奥卡姆剃刀**'
- en: ''
  id: totrans-481
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Occam's Razor is a principal suggesting that when multiple models produce similar
    quality, in other words similarly produce good fit to the data, then the simpler
    model should be preferred. This principal is especially useful when evaluating
    several models, such as evaluating multiple SARIMA models. If a few models emerge
    as strong candidates, generally, the simplest model is favored, assuming all are
    equally likely candidates to begin with.
  id: totrans-482
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 奥卡姆剃刀原理表明，当多个模型产生相似的质量，换句话说，能同样良好地拟合数据时，应该偏好较简单的模型。这一原理在评估多个模型时尤其有用，比如在评估多个SARIMA模型时。如果一些模型脱颖而出成为强有力的候选者，通常来说，简单的模型更受青睐，假设最初这些模型是等可能的候选者。
- en: 'To sort the models based on BIC score, rerun the function:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 要根据BIC得分对模型进行排序，请重新运行该函数：
- en: '[PRE69]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Examine the results displayed in Figure 10.36 below, which shows the top 5 SARIMA
    models ranked by BIC for the Milk Production data.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看下图中的结果（图10.36），它展示了按BIC排名的前5个SARIMA模型，针对牛奶生产数据。
- en: '![Figure 10.37: Top 5 SARIMA models ranked by BIC for the Milk Production data](img/file233.png)'
  id: totrans-486
  prefs: []
  type: TYPE_IMG
  zh: '![图10.37：按BIC排名的前5个SARIMA模型，针对牛奶生产数据](img/file233.png)'
- en: 'Figure 10.37: Top 5 SARIMA models ranked by BIC for the Milk Production data'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.37：按BIC排名的前5个SARIMA模型，针对牛奶生产数据
- en: Comparing the results in Figure 10.36 and Figure 10.35, you will notice the
    third model in Figure 10.36 (model_id = 35), the SARIMA(0,1,1)(0,1,1) model, which
    was derived earlier.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 比较图10.36和图10.35中的结果，你会注意到图10.36中的第三个模型（model_id = 35），即之前推导出来的SARIMA(0,1,1)(0,1,1)模型。
- en: 'Now, let’s select the best model based on the BIC score:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们根据BIC得分选择最佳模型：
- en: '[PRE70]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Finally, you can visualize the model’s forecast alongside the actual data using
    the `plot_forecast` function:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以使用`plot_forecast`函数将模型的预测结果与实际数据一起可视化：
- en: '[PRE71]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'This should produce a plot with the x-axis starting from the year 1962, as
    shown in Figure 10.37:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该生成一个图表，x轴从1962年开始，如图10.37所示：
- en: '![Figure 10.38: Milk production forecast versus actual production using SARIMA(0,2,2)(0,1,1,12)](img/file234.png)'
  id: totrans-494
  prefs: []
  type: TYPE_IMG
  zh: '![图10.38：使用SARIMA(0,2,2)(0,1,1,12)的牛奶生产预测与实际生产对比](img/file234.png)'
- en: 'Figure 10.38: Milk production forecast versus actual production using SARIMA(0,2,2)(0,1,1,12)'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.38：使用SARIMA(0,2,2)(0,1,1,12)的牛奶生产预测与实际生产对比
- en: See also
  id: totrans-496
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参见
- en: To learn more about the SARIMAX class, you can visit statsmodels's official
    documentation at [https://www.statsmodels.org/dev/generated/statsmodels.tsa.statespace.sarimax.SARIMAX.html](https://www.statsmodels.org/dev/generated/statsmodels.tsa.statespace.sarimax.SARIMAX.html).
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于SARIMAX类的信息，可以访问statsmodels的官方文档：[https://www.statsmodels.org/dev/generated/statsmodels.tsa.statespace.sarimax.SARIMAX.html](https://www.statsmodels.org/dev/generated/statsmodels.tsa.statespace.sarimax.SARIMAX.html)。
- en: Forecasting univariate time series with auto_arima
  id: totrans-498
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`auto_arima`进行单变量时间序列预测
- en: For this recipe, you will need to install **pmdarima**, a Python library that
    includes `auto_arima` – a tool designed to automate the optimization and fitting
    of ARIMA models. The `auto_arima` implementation in Python is inspired by the
    popular `auto.arima` from the `forecast` package in R.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，你需要安装**pmdarima**，这是一个Python库，其中包括`auto_arima`——一个旨在自动化优化和拟合ARIMA模型的工具。Python中的`auto_arima`实现灵感来源于R中`forecast`包中的流行`auto.arima`。
- en: As you've seen in earlier recipes, determining the correct orders for the AR
    and MA components can be challenging. While techniques like examining ACF and
    PACF plots are helpful, finding the optimal model often involves training multiple
    models – a process known as **hypeparameter tuning**, which can be quite labor-intensive.
    This is where `auto_arima` shines as it simplifies the effort.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在前面的示例中看到的，确定AR和MA组件的正确阶数可能会很具挑战性。虽然像检查ACF和PACF图这样的技术很有帮助，但找到最优模型通常需要训练多个模型——这一过程称为**超参数调优**，可能非常耗时费力。这正是`auto_arima`的亮点，它简化了这个过程。
- en: 'Instead of the naïve, brute force, approach of manually conducting a grid search
    to try every parameter combination, auto_arima uses a more efficient approach
    to finding the optimal parameters. The `auto_arima` function uses a **stepwise**
    **algorithm** that is faster and more efficient than a full **grid search** or
    **random search**:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 与简单粗暴的手动网格搜索逐一尝试每种参数组合的方法不同，`auto_arima`使用了一种更高效的方法来寻找最优参数。`auto_arima`函数采用了一种**逐步**
    **算法**，其速度更快、效率更高，优于完整的**网格搜索**或**随机搜索**：
- en: By default, with `stepwise=True`, `auto_arima` conducts a stepwise search which
    iteratively refines the model parameters.
  id: totrans-502
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下，使用`stepwise=True`时，`auto_arima`会进行逐步搜索，逐步优化模型参数。
- en: If you set `stepwise=False`, it performs an exhaustive “brute-force” grid search
    across all parameter combinations.
  id: totrans-503
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你设置`stepwise=False`，它将执行全面的“蛮力”网格搜索，遍历所有参数组合。
- en: With `random=True`, it performs a random search.
  id: totrans-504
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`random=True`时，它会执行随机搜索。
- en: 'The **stepwise** **algorithm** was proposed in 2008 by Rob Hyndman and Yeasmin
    Khandakar in the paper *Automatic Time Series Forecasting: The forecast Package
    for R*, which was published in the Journal of Statistical Software 27, no. 3 (2008)
    ([https://doi.org/10.18637/jss.v027.i03](https://doi.org/10.18637/jss.v027.i03)).
    In a nutshell, **stepwise** is an optimization technique that utilizes grid search
    more efficiently. This is accomplished using **unit root tests** and minimizing
    information criteria (for example, **Akaike Information Criterion** (**AIC**)
    and **Maximum Likelihood Estimation** (**MLE**).'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: '**逐步** **算法**由Rob Hyndman和Yeasmin Khandakar于2008年在论文*Automatic Time Series
    Forecasting: The forecast Package for R*中提出，该论文发表在《统计软件杂志》27卷3期（2008年）（[https://doi.org/10.18637/jss.v027.i03](https://doi.org/10.18637/jss.v027.i03)）。简而言之，**逐步**是一种优化技术，它更高效地利用了网格搜索。这是通过使用**单位根检验**和最小化信息准则（例如，**赤池信息量准则**（**AIC**）和**最大似然估计**（**MLE**）来实现的）。'
- en: Further, `auto_arima` can handle both seasonal and non-seasonal ARIMA models.
    For seasonal models, set `seasonal=True` to enable optimization of the seasonal
    parameters (P, D, Q).
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`auto_arima`还可以处理季节性和非季节性的ARIMA模型。对于季节性模型，设置`seasonal=True`以启用季节性参数（P、D、Q）的优化。
- en: Getting ready
  id: totrans-507
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need to install `pmdarima` before you can proceed with this recipe.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续此示例之前，你需要安装`pmdarima`。
- en: 'To install it using `pip`, use the following command:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`pip`安装，可以使用以下命令：
- en: '[PRE72]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'To install it using `conda`, use the following command:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`conda`安装，可以使用以下命令：
- en: '[PRE73]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: You will use the Milk Production dataset which you prepared in the Technical
    Requirements section You will be using `milk_train` for training and `milk_test`
    for evaluation`.` Recall that the data contains both trend and seasonality, so
    you will be training a **SARIMA** model.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用在技术要求部分准备的“Milk Production”数据集。你将使用`milk_train`进行训练，使用`milk_test`进行评估。请回忆一下，数据包含了趋势和季节性，因此你将训练一个**SARIMA**模型。
- en: How to do it…
  id: totrans-514
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何做…
- en: The **pmdarima** library wraps over the **statsmodels** library, so you will
    encounter familiar methods and attributes. You will follow a similar process by
    loading the data, splitting the data into train and test sets, first training
    the model, and then evaluating the results. These steps were already completed
    in the *Technical Requirements* section.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: '**pmdarima**库封装了**statsmodels**库，因此你会遇到熟悉的方法和属性。你将遵循类似的流程，首先加载数据，将数据拆分为训练集和测试集，训练模型，然后评估结果。这些步骤已在*技术要求*部分完成。'
- en: Begin by importing the `pmdarima` library
  id: totrans-516
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先导入`pmdarima`库
- en: '[PRE74]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Utilize the `auto_arima` function from `pmdarima` to find the optimal configuration
    for your SARIMA model. Prior knowledge about the Milk Production dataset is key
    to obtaining the best results from `auto_arima`. You know the data exhibits seasonal
    patterns, so you will need to provide values for the *two parameters*: `seasonal=True`
    and `m=12`, which represents the number of periods in the season. Failing to set
    these parameters (`seasonal` and `m`) would limit the search to non-seasonal orders
    (p, d, q) only.'
  id: totrans-518
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`pmdarima`中的`auto_arima`函数来找到SARIMA模型的最佳配置。对Milk Production数据集的先验知识是从`auto_arima`获得最佳结果的关键。你知道数据存在季节性模式，因此需要为*两个参数*提供值：`seasonal=True`和`m=12`，其中`m`代表季节中的周期数。如果没有设置这些参数（`seasonal`和`m`），搜索将仅限于非季节性阶数(p,
    d, q)。
- en: 'The `test` parameter specifies the type of **unit root test** to use to detect
    stationarity to determine the differencing order (`d`). The default test is `kpss`.
    You will change the parameter to use `adf` instead (to be consistent with what
    you did in earlier recipes). Similarly, `seasonal_test` is used to determine the
    order (`D`) for seasonal differencing. The default `seasonal_test` is `OCSB`,
    which you will keep as-is:'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: '`test`参数指定用于检测平稳性并确定差分阶数(`d`)的**单位根检验**类型。默认的检验是`kpss`。你将把参数改为使用`adf`（以保持与之前配方一致）。类似地，`seasonal_test`用于确定季节性差分的阶数(`D`)。默认的`seasonal_test`是`OCSB`，你将保持不变：'
- en: '[PRE75]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The summary provides a detailed configuration of the chosen SARIMA model, including
    information criteria scores like AIC and BIC:'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 摘要提供了所选SARIMA模型的详细配置，包括信息准则得分，如AIC和BIC：
- en: '![Figure 10.39: Summary of the best SARIMA model selected using auto_arima](img/file235.png)'
  id: totrans-522
  prefs: []
  type: TYPE_IMG
  zh: '![图10.39：使用auto_arima选择的最佳SARIMA模型摘要](img/file235.png)'
- en: 'Figure 10.39: Summary of the best SARIMA model selected using auto_arima'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.39：使用auto_arima选择的最佳SARIMA模型摘要
- en: Interestingly, the selected model, SARIMA(0,1,1)(0,1,1,12), algins with the
    one you derived in the *Forecasting univariate time series data with seasonal
    ARIMA* recipe, where you estimated the non-seasonal order (p, q) and seasonal
    orders (P, Q) using the ACF and PACF plots.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，所选模型SARIMA(0,1,1)(0,1,1,12)与在*使用季节性ARIMA预测单变量时间序列数据*配方中推导出的模型一致，在该配方中，你通过ACF和PACF图估算了非季节性阶数(p,
    q)和季节性阶数(P, Q)。
- en: 'To monitor the performance of each model configuration evaluated during the
    stepwise search, enable the `trace=True` parameter in the `auto.arima` function:'
  id: totrans-525
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了监控在逐步搜索过程中评估的每个模型配置的性能，在`auto.arima`函数中启用`trace=True`参数：
- en: '[PRE76]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'This setting will print the AIC results for each SARIMA model tested by the
    step-wise algorithm, as shown in Figure 10.39:'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 该设置将打印由逐步算法测试的每个SARIMA模型的AIC结果，如图10.39所示：
- en: '![Figure 10.40: auto_arima evaluating different SARIMA models based on AIC](img/file236.png)'
  id: totrans-528
  prefs: []
  type: TYPE_IMG
  zh: '![图10.40：auto_arima基于AIC评估不同的SARIMA模型](img/file236.png)'
- en: 'Figure 10.40: auto_arima evaluating different SARIMA models based on AIC'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.40：auto_arima基于AIC评估不同的SARIMA模型
- en: 'The best model was selected based on AIC, which is determined by the `information_criterion`
    parameter. By default, this is set to `aic`, but it can be changed to one of the
    other supported criteria: `bic`, `hqic`, or `oob`.'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳模型是基于AIC选择的，AIC由`information_criterion`参数决定。默认情况下，设置为`aic`，但可以更改为其他支持的准则之一：`bic`、`hqic`或`oob`。
- en: In *Figure 10.39,* the two highlighted models have similar AIC scores but drastically
    different non-seasonal (p, q) orders. The preferred model (marked with number
    1) lacks a non-seasonal autoregressive AR(p) component and instead relies on a
    moving average MA(q) process. Conversely, the second highlighted model (marked
    with number 2) features only an AR(p) process for the non-seasonal component.
    This demonstrates, while `auto_arima` significantly aids in the model selection,
    careful judgement and analysis are still required to interpret and evaluate results
    effectively.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图10.39*中，两个突出的模型具有相似的AIC分数，但非季节性（p，q）阶数大相径庭。优选模型（标记为数字1）缺少非季节性自回归AR(p)成分，而是依赖于移动平均MA(q)过程。相反，第二个突出模型（标记为数字2）仅包含非季节性成分的AR(p)过程。这表明，尽管`auto_arima`显著有助于模型选择，但仍需小心判断和分析，以有效解释和评估结果。
- en: 'To explore how the choice of information criterion affects model selection,
    change the `information_criterion` to `bic` and rerun the code:'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 若要探索信息准则的选择如何影响模型选择，请将`information_criterion`更改为`bic`并重新运行代码：
- en: '[PRE77]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '![Figure 10.41: auto_arima evaluating different SARIMA models based on BIC](img/file237.png)'
  id: totrans-534
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.41：auto_arima根据BIC评估不同的SARIMA模型](img/file237.png)'
- en: 'Figure 10.41: auto_arima evaluating different SARIMA models based on BIC'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.41：auto_arima根据BIC评估不同的SARIMA模型
- en: As illustrated in Figure 10.40, this will produce output from each iteration
    based on BIC. Notably, the winning remains the same as the one selected based
    on AIC from Figure 10.39\. However, observe how the second model (marked with
    number 2), which was a close contender in Figure 10.39, is no longer as competitive
    under the BIC criterion.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 如图10.40所示，这将基于BIC从每次迭代中生成输出。值得注意的是，最终选择的模型与基于AIC从图10.39选择的模型相同。然而，请注意，第二个模型（标记为数字2），尽管在图10.39中是一个接近的竞争者，但在BIC标准下已不再具有竞争力。
- en: Evaluate the overall performance of the model using the `plot_diagnostics` method.
    This is the same method you used previously from statsmodels.
  id: totrans-537
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`plot_diagnostics`方法评估模型的整体表现。这是你之前在statsmodels中使用过的相同方法。
- en: '[PRE78]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'This should produce the diagnostic plots for residual analysis of the selected
    SARIMA model as shown in Figure 10.41:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会生成选定的SARIMA模型的残差分析诊断图，如图10.41所示：
- en: '![Figure 10.42: Diagnostic plots for residual analysis based on the selected
    SARIMA model](img/file238.png)'
  id: totrans-540
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.42：基于选定的SARIMA模型的残差分析诊断图](img/file238.png)'
- en: 'Figure 10.42: Diagnostic plots for residual analysis based on the selected
    SARIMA model'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.42：基于选定的SARIMA模型的残差分析诊断图
- en: 'To access the model summary, use the `summary` method. This will produce Figure
    10.42, showing the SARIMA model summary as selected by `auto_arima`:'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 若要访问模型摘要，请使用`summary`方法。这将生成图10.42，显示由`auto_arima`选择的SARIMA模型摘要：
- en: '![Figure 10.43: SARIMA model summary based on auto_arima selected model](img/file239.png)'
  id: totrans-543
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.43：基于auto_arima选择模型的SARIMA模型摘要](img/file239.png)'
- en: 'Figure 10.43: SARIMA model summary based on auto_arima selected model'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.43：基于auto_arima选择模型的SARIMA模型摘要
- en: 'To forecast future periods, utilize the `predict` method. You will need to
    specify the number of periods to forecast forward into the future:'
  id: totrans-545
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 若要预测未来的周期，请使用`predict`方法。你需要指定要预测的周期数：
- en: '[PRE79]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The produced plot, shown in Figure 10.43, compares the forecast with the test
    data:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的图形，如图10.43所示，比较了预测值与测试数据。
- en: '![Figure 10.44: Plotting the forecast from auto_arima against actual test data](img/file240.png)'
  id: totrans-548
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.44：将auto_arima的预测与实际测试数据进行对比](img/file240.png)'
- en: 'Figure 10.44: Plotting the forecast from auto_arima against actual test data'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.44：将auto_arima的预测与实际测试数据进行对比
- en: You can obtain the confidence intervals with the prediction by updating the
    `return_conf_int` parameter from `False` to `True`. This will allow you to plot
    the lower and upper confidence intervals using matplotlib's `fill_between` function.
    The default confidence interval is set to 95% (`alpha=0.05).`
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将`return_conf_int`参数从`False`更新为`True`来获得预测的置信区间。这将允许你使用matplotlib的`fill_between`函数绘制上下置信区间。默认的置信区间设置为95%（`alpha=0.05`）。
- en: 'The following code uses the `predict` method, returns the confidence intervals,
    and plots the predicted values against the test set:'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码使用`predict`方法，返回置信区间，并将预测值与测试集进行对比：
- en: '[PRE80]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: This should produce a plot with a shaded area representing the likelihood that
    the real values would lie within this range. Ideally, you would prefer a narrower
    confidence interval range.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该生成一个图，带有阴影区域，表示实际值落在此范围内的可能性。理想情况下，你会更倾向于选择较窄的置信区间范围。
- en: 'The shaded area is based on the lower and upper bounds of the confidence intervals
    as shown in Figure 10.44:'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 阴影区域基于图 10.44 中所示的置信区间的上下界：
- en: '![Figure 10.45: Plotting the forecast from auto_arima against actual test data
    with the confidence intervals](img/file241.png)'
  id: totrans-555
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.45：将来自 auto_arima 的预测与实际测试数据及置信区间进行对比的图示](img/file241.png)'
- en: 'Figure 10.45: Plotting the forecast from auto_arima against actual test data
    with the confidence intervals'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.45：将来自 auto_arima 的预测与实际测试数据及置信区间进行对比的图示
- en: Notice that the forecast line lies in the middle of the shaded area. This represents
    the mean of the upper and lower bounds.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，预测线位于阴影区域的中间位置，表示上下界的均值。
- en: 'The following code checks if the forecast values align with the mean of the
    confidence intervals:'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码检查预测值是否与置信区间的均值一致：
- en: '[PRE81]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: How it works…
  id: totrans-560
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 工作原理…
- en: 'The `auto_arima` function from the **pmdarima** library serves as a wrapper
    for the **statsmodels** SARIMAX class and aims to automate the process of identifying
    the best model and parameters. This function provides three primary methods to
    control the optimization of the training process, dictated by the `stepwise` and
    `random` parameters:'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: '**pmdarima** 库中的 `auto_arima` 函数作为 **statsmodels** SARIMAX 类的封装器，旨在自动化识别最佳模型和参数的过程。此函数提供了三种主要方法来控制训练过程的优化，这些方法由
    `stepwise` 和 `random` 参数决定：'
- en: '**Naive brute-force grid search**: Conducts a comprehensive grid search over
    all parameter combinations by setting `stepwise=False` and `random=False`. This
    method exhaustively evaluates each combination, which can be time-consuming but
    thorough.'
  id: totrans-562
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**朴素暴力网格搜索**：通过设置 `stepwise=False` 和 `random=False`，对所有参数组合进行全面的网格搜索。该方法对每种组合进行详尽评估，虽然耗时，但非常彻底。'
- en: '**Random grid search**: Activates a random search across the parameter space
    by setting `stepwise=False` and `random=True`. This approach randomly selects
    combinations to test, which can be faster and still effective, especially in large
    parameter spaces.'
  id: totrans-563
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**随机网格搜索**：通过设置 `stepwise=False` 和 `random=True` 来激活参数空间中的随机搜索。这种方法随机选择组合进行测试，尤其在大参数空间中，虽然是随机的，但仍然有效，且速度较快。'
- en: '**Stepwise search algorithm**: Enabled by default with `stepwise=True`, this
    method uses a heuristic to explore the parameter space step by step, adding or
    subtracting from each parameter based on the AIC or BIC scores from previous steps.
    It is generally faster and more efficient than the full grid search, as it intelligently
    narrows down the range of models to those most likely to provide the best fit.'
  id: totrans-564
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**逐步搜索算法**：默认启用 `stepwise=True`，此方法使用启发式算法逐步探索参数空间，基于前一步的 AIC 或 BIC 分数，逐个添加或减少每个参数。与全面网格搜索相比，它通常更快、更高效，因为它智能地缩小了模型范围，聚焦于最可能提供最佳拟合的模型。'
- en: There's more…
  id: totrans-565
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 还有更多…
- en: The `pmdarima` library offers a plethora of useful functions to help you make
    informed decisions so that you can understand the data you are working with.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: '**pmdarima** 库提供了大量有用的函数，帮助你做出明智的决策，使你能够更好地理解你所处理的数据。'
- en: For example, the `ndiffs` function performs stationarity tests to determine
    the differencing order, `d`, to make the time series stationary. The tests include
    the **Augmented Dickey-Fuller** (`adf`) test, the **Kwiatkowski–Phillips–Schmidt–Shin**
    (`kpss`) test, and the **Phillips-Perron** (`pp`) test.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`ndiffs` 函数执行平稳性检验，以确定差分阶数 `d`，使时间序列变得平稳。检验包括**增广迪基-富勒**（`adf`）检验、**克维亚茨科夫-菲利普斯-施密特-辛**（`kpss`）检验和**菲利普斯-佩龙**（`pp`）检验。
- en: 'Similarly, the `nsdiffs` function helps estimate the number of seasonal differencing
    orders (`D` ) that are needed. The implementation covers two tests – the **Osborn-Chui-Smith-Birchenhall**
    (`ocsb`) and **Canova-Hansen** (`ch`) tests:'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`nsdiffs` 函数有助于估算所需的季节性差分阶数（`D`）。该实现包括两个检验——**奥斯本-崔-史密斯-比尔钦霍尔**（`ocsb`）检验和**卡诺瓦-汉森**（`ch`）检验：
- en: '[PRE82]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The `auto_arima` function allows for detailed control over the model evaluation
    process by setting the minimum and maximum constraints on various parameters.
    For example, you can specify limits for the non-seasonal autoregressive order,
    `p`, or the seasonal moving average, `Q`. The following code example demonstrates
    how to set some of these parameters and constraints:'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: '`auto_arima`函数通过设置各种参数的最小和最大约束，允许对模型评估过程进行详细控制。例如，你可以指定非季节性自回归阶数`p`或季节性移动平均`Q`的限制。以下代码示例演示了如何设置一些参数和约束条件：'
- en: '[PRE83]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: If you run the preceding code, `auto_arima` will create different models for
    every combination of the parameter values based on the constraints you provided.
    Because *stepwise* is set to *False*, it becomes a brute-force **grid search**
    in which every permutation for the different variable combinations is tested one
    by one. Hence, this is generally a much slower process, but by providing these
    constraints, you can improve the search performance.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行前面的代码，`auto_arima`将根据你提供的约束条件，为每个参数值的组合创建不同的模型。由于*stepwise*被设置为*False*，这就变成了一种暴力的**网格搜索**，其中每种不同变量组合的排列都会逐一测试。因此，这通常是一个比较慢的过程，但通过提供这些约束条件，你可以提高搜索性能。
- en: By enabling `trace=True`, the AIC scores for each model configuration tested
    are displayed. Once completed, it should print out the best model.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 通过启用`trace=True`，可以显示测试的每个模型配置的AIC得分。完成后，应该会打印出最佳模型。
- en: The approach that was taken here, with `stepwise=False`, should resemble the
    approach you took in the *Forecasting univariate time series data with seasonal
    ARIMA* recipe, in the *There's more...* section.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 这里采取的方法，设置`stepwise=False`，应该与你在*使用季节性ARIMA进行单变量时间序列预测*教程中采取的方法类似，该教程位于*更多内容...*部分。
- en: Using Darts AutoArima
  id: totrans-575
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用Darts的AutoArima
- en: In *the Forecasting univariate time series data with exponential smoothing*
    recipe, you were introduced to the **Darts** library in the *There’s more…* section
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 在*使用指数平滑进行单变量时间序列预测*的教程中，你在*更多内容...*部分介绍了**Darts**库。
- en: 'The Darts library offers the `AutoArima` class, a thin wrapper around **pmdarima**’s
    **auto_arima**. The following code demonstrates how you can leverage Darts to
    perform the same functionality:'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: Darts库提供了`AutoArima`类，它是**pmdarima**的**auto_arima**的一个轻量级封装。以下代码演示了如何利用Darts执行相同的功能：
- en: '[PRE84]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'This code produces a plot showing the forecast, as displayed in Figure 10.45:'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码生成的图表展示了预测结果，如图10.45所示：
- en: '![Figure 10.46: Plotting the forecast using AutoARIMA from the Darts library](img/file242.png)'
  id: totrans-580
  prefs: []
  type: TYPE_IMG
  zh: '![图10.46：使用Darts库的AutoARIMA进行预测](img/file242.png)'
- en: 'Figure 10.46: Plotting the forecast using AutoARIMA from the Darts library'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.46：使用Darts库的AutoARIMA进行预测
- en: Using Darts StatsForecastAutoARIMA
  id: totrans-582
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用Darts的StatsForecastAutoARIMA
- en: 'Darts also provides a wrapper over **Statsforecasts**’ Auto_ARIMA which offers
    a potentially faster implementation than AutoArima. The following code demonstrates
    how you can use the `StatsForecastAutoARIMA` to perform the same functionality:'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: Darts还提供了一个**Statsforecasts**的包装器，封装了其Auto_ARIMA，提供了比AutoArima可能更快的实现。以下代码演示了如何使用`StatsForecastAutoARIMA`来执行相同的功能：
- en: '[PRE85]'
  id: totrans-584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'This code produces a plot comparing forecasts from AutoARIMA and StatsForecastAutoARIMA,
    as shown in Figure 10.47:'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码生成的图表展示了AutoARIMA和StatsForecastAutoARIMA的预测对比，如图10.47所示：
- en: '![Figure 10.47: Plotting the forecast using StatsForecastAutoARIMA from the
    Darts library](img/Picture10.jpg)'
  id: totrans-586
  prefs: []
  type: TYPE_IMG
  zh: '![图10.47：使用Darts库的StatsForecastAutoARIMA进行预测](img/Picture10.jpg)'
- en: 'Figure 10.47: Plotting the forecast using StatsForecastAutoARIMA from the Darts
    library'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.47：使用Darts库的StatsForecastAutoARIMA进行预测
- en: See also
  id: totrans-588
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 另见
- en: To learn more about the `auto_arima` implementation, please visit the official
    documentation at [https://alkaline-ml.com/pmdarima/modules/generated/pmdarima.arima.auto_arima.html](https://alkaline-ml.com/pmdarima/modules/generated/pmdarima.arima.auto_arima.html).
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 若要了解有关`auto_arima`实现的更多信息，请访问官方文档：[https://alkaline-ml.com/pmdarima/modules/generated/pmdarima.arima.auto_arima.html](https://alkaline-ml.com/pmdarima/modules/generated/pmdarima.arima.auto_arima.html)。
- en: In the next recipe, you will learn about a new algorithm that provides a simpler
    API for model tuning and optimization. In other words, there are far fewer parameters
    that you need to worry about.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个教程中，你将学习一种新的算法，该算法提供了一个更简单的API来进行模型调优和优化。换句话说，你需要关注的参数大大减少。
