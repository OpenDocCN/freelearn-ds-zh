- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: iSAX – The Required Theory
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: iSAX – 必要的理论
- en: Now that we know all about SAX, including normalization and computing the SAX
    representation of a subsequence, it is time to learn the theory behind the iSAX
    index, which, at the time of writing, is considered one of the best time-series
    indexes. Improved versions of iSAX that make iSAX faster and more compact exist,
    but the core ideas remain the same.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了SAX，包括归一化和计算子序列的SAX表示，现在是时候学习iSAX索引背后的理论了，在撰写本文时，它被认为是最好的时间序列索引之一。存在使iSAX更快、更紧凑的iSAX改进版本，但其核心思想保持不变。
- en: As you might have guessed from its name, iSAX depends on SAX in some way. Put
    simply, **the keys to every iSAX index are SAX representations**. Therefore, searching
    in an iSAX index depends on SAX representations.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从其名称中猜测的那样，iSAX在某些方面依赖于SAX。简单来说，**每个iSAX索引的关键是SAX表示**。因此，在iSAX索引中进行搜索依赖于SAX表示。
- en: At this point, I believe it would be good to provide more information about
    iSAX to help you while reading this chapter. An **iSAX index** is a tree-like
    structure where the root, and only the root, can have multiple children, and all
    the children of the root are binary trees underneath. Additionally, to create
    an iSAX index, we need a time series and a threshold value, which is the maximum
    number of subsequences that a leaf node (a terminal node in iSAX terminology)
    can store, as well as a segment value and a cardinality value. The last two parameters
    are related to the SAX representation. All of this is explained in more detail
    in this chapter, but it’s good to have the big picture in mind as early on as
    possible.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我相信提供更多关于iSAX的信息将有助于您在阅读本章时。**iSAX索引**是一个树状结构，其中根节点，且仅根节点，可以有多个子节点，而根节点的所有子节点都是二叉树。此外，为了创建iSAX索引，我们需要一个时间序列和一个阈值值，这是叶子节点（在iSAX术语中的终端节点）可以存储的最大子序列数，以及一个段值和一个基数值。后两个参数与SAX表示相关。所有这些都在本章中进行了更详细的解释，但尽早了解整体情况是很有帮助的。
- en: Additionally, in this chapter, we are going to manually construct a small iSAX
    index step by step to better understand the process, using lots of visualizations.
    Please make sure that you carry out this process on your own after you finish
    reading this chapter.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在本章中，我们将逐步手动构建一个小型的iSAX索引，并使用大量的可视化来更好地理解这个过程。请确保在阅读完本章后亲自进行这个过程。
- en: 'In this chapter, we are going to cover the following main topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Background information
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 背景信息
- en: Understanding how iSAX works
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解iSAX的工作原理
- en: How iSAX is constructed
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: iSAX是如何构建的
- en: Manually constructing an iSAX index
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动构建iSAX索引
- en: Updating the `counting.py` utility
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新`counting.py`实用工具
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The GitHub repository for this book can be found at [https://github.com/PacktPublishing/Time-Series-Indexing](https://github.com/PacktPublishing/Time-Series-Indexing).
    The code for each chapter is in its own directory. Therefore, the code for [*Chapter
    3*](B14769_03.xhtml#_idTextAnchor081) can be found in the `ch03` folder.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的GitHub仓库可以在[https://github.com/PacktPublishing/Time-Series-Indexing](https://github.com/PacktPublishing/Time-Series-Indexing)找到。每个章节的代码都在其自己的目录中。因此，[*第3章*](B14769_03.xhtml#_idTextAnchor081)的代码可以在`ch03`文件夹中找到。
- en: Background information
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 背景信息
- en: 'In this first section, we are going to learn about the basic definitions and
    concepts related to iSAX. But first, we are going to mention the research paper
    that describes the operation of iSAX. iSAX and its operation are described in
    *iSAX: disk-aware mining and indexing of massive time series datasets*, which
    was written by Jin Shieh and Eamonn Keogh. You do not have to read this paper
    from start to finish but, as we mentioned for the SAX research paper, it would
    benefit you to read its abstract and introduction section.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '在本节的第一部分，我们将学习与iSAX相关的基本定义和概念。但首先，我们将提及描述iSAX操作的学术论文。iSAX及其操作在由Jin Shieh和Eamonn
    Keogh所著的*iSAX: 大规模时间序列数据集的磁盘感知挖掘和索引*中进行了描述。您不必从头到尾阅读这篇论文，但正如我们之前提到的SAX研究论文一样，阅读其摘要和引言部分将有益于您。'
- en: 'Additionally, there have been various improvements to iSAX, mainly to make
    it faster, which are presented in the following research papers:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，对iSAX已经进行了各种改进，主要是使其更快，这些改进在以下研究论文中有所体现：
- en: '*iSAX 2.0: Indexing and Mining One Billion Time Series*, written by Alessandro
    Camerra, Themis Palpanas, Jin Shieh, and Eamonn Keogh'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*iSAX 2.0: 索引和挖掘十亿时间序列*，由Alessandro Camerra、Themis Palpanas、Jin Shieh和Eamonn
    Keogh所著'
- en: '*Beyond one billion time series: Indexing and mining very large time series
    collections with iSAX2+*, written by Alessandro Camerra, Jin Shieh, Themis Palpanas,
    Thanawin Rakthanmanon, and Eamonn Keogh'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《超过十亿个时间序列：使用iSAX2+索引和挖掘非常大的时间序列集合*》，作者：Alessandro Camerra、Jin Shieh、Themis
    Palpanas、Thanawin Rakthanmanon和Eamonn Keogh'
- en: '*DPiSAX: Massively Distributed Partitioned iSAX*, written by Djamel-Edine Yagoubi,
    Reza Akbarinia, Florent Masseglia, and Themis Palpanas'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《DPiSAX：大规模分布式分区iSAX*》，作者：Djamel-Edine Yagoubi、Reza Akbarinia、Florent Masseglia和Themis
    Palpanas'
- en: '*Evolution of a Data Series Index: The iSAX Family of Data Series Indexes:
    iSAX, iSAX2.0, iSAX2+, ADS, ADS+, ADS-Full, ParIS, ParIS+, MESSI, DPiSAX, ULISSE,
    Coconut-Trie/Tree, Coconut-LSM*, written by Themis Palpanas'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《数据系列索引的演变：iSAX数据系列索引家族：iSAX、iSAX2.0、iSAX2+、ADS、ADS+、ADS-Full、ParIS、ParIS+、MESSI、DPiSAX、ULISSE、Coconut-Trie/Tree、Coconut-LSM*》，作者：Themis
    Palpanas'
- en: We are not going to deal with the aforementioned research papers in this book
    as we are working with the initial version of the iSAX index. You do not have
    to read all these papers for the purposes of this book, but it would be a great
    exercise to have a look through them when you feel comfortable with iSAX.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会在本书中处理上述研究论文，因为我们正在使用iSAX索引的初始版本。你不需要为了本书的目的阅读所有这些论文，但在你对iSAX感到舒适时查看它们将是一项很好的练习。
- en: As iSAX is a tree, the next subsection presents basic information about trees
    and binary trees.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 由于iSAX是一种树，下一节将介绍有关树和二叉树的基本信息。
- en: Trees and binary trees
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 树和二叉树
- en: Let us begin by explaining what a directed graph is. A **directed graph** is
    a graph where the edges have a direction associated with them. A **directed acyclic
    graph** (**DAG**) is a directed graph with no cycles in it.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先解释什么是有向图。**有向图**是一种边具有方向的图。**有向无环图**（DAG）是一种没有环的有向图。
- en: 'In computer science, a **tree** is a DAG data structure that satisfies the
    following three principles:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机科学中，**树**是一种满足以下三个原则的DAG数据结构：
- en: It has a root node that is the entry point to the tree
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它有一个根节点，这是进入树的入口点
- en: Every vertex, except the root, has one and only one entry point
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了根节点外，每个顶点只有一个且仅有一个入口点
- en: There is a path that connects the root to each vertex
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存在一条路径连接根节点到每个顶点
- en: As already stated, the **root of a tree** is the first node of the tree. Each
    node can be connected to one or more nodes depending on the tree type. If each
    node leads to one and only one node, then the tree becomes a linked list! A leaf
    node is a node without any children. Leaves are also called external nodes, whereas
    a node with at least one child is called an internal node.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，树的**根**是树的第一节点。每个节点可以连接到一个或多个节点，具体取决于树类型。如果每个节点只连接到一个节点，那么这棵树就变成了链表！叶节点是没有子节点的节点。叶节点也被称为外部节点，而至少有一个子节点的节点称为内部节点。
- en: A **binary tree** is a tree where underneath each node, there are at most two
    more nodes. *At most* means that it can be connected to one, two, or no other
    nodes. The **depth**, which is also called the **height**, of a tree is defined
    as the longest path from the root node to a leaf, whereas the depth of a node
    is the number of edges from the node to the root node of the tree.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**二叉树**是一种树，其中每个节点下最多有两个额外的节点。"最多"意味着它可以连接到1个、2个或没有其他节点。树的**深度**，也称为**高度**，定义为从根节点到叶节点的最长路径，而节点的深度是从节点到树根节点的边数。'
- en: Keep in mind that if you create two binary trees using the same set of elements
    added in a different order, you are going to get two completely different trees.
    The simplest way to do that is by starting from a different root node. So, we
    do not know in advance the final shape of a tree.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，如果你使用相同的一组元素以不同的顺序创建两个二叉树，你将得到两个完全不同的树。最简单的方法是从不同的根节点开始。因此，我们事先不知道树的最终形状。
- en: A tree has internal nodes and leaf nodes. In iSAX terminology, these are called
    **inner nodes** and **terminal nodes**, respectively. *Inner nodes* have a parent
    and at least one child and *terminal nodes* have a parent node but no children
    of their own.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 树有内部节点和叶节点。在iSAX术语中，这些分别被称为**内部节点**和**终端节点**。**内部节点**有一个父节点和至少一个子节点，而**终端节点**有一个父节点但没有自己的子节点。
- en: A binary tree is considered a **balanced tree** when the difference between
    the longest length from the root node to a leaf node and the shortest such length
    is 0 or 1\. An **unbalanced tree** is a tree that is not balanced. Although the
    iSAX index can be characterized by its length, there is no point in finding out
    whether an iSAX index is balanced or not because this is not how indexes work
    and this mainly has to do with the data. However, having balanced trees is a good
    thing.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 二叉树在最长根节点到叶子节点的路径长度与最短路径长度之差为0或1时被认为是**平衡树**。**不平衡树**是指不满足平衡条件的树。尽管iSAX索引可以通过其长度来表征，但确定iSAX索引是否平衡并没有什么意义，因为索引的工作方式并非如此，这主要与数据有关。然而，拥有平衡树是一件好事。
- en: Therefore, although iSAX indexes are trees, we cannot apply all the binary tree
    rules to an iSAX index. However, it is good to know all these details to have
    a better understanding of why a particular iSAX index might be faster or slower
    than others.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，尽管iSAX索引是树，但我们不能将所有二叉树规则应用于iSAX索引。然而，了解所有这些细节有助于更好地理解为什么某个iSAX索引可能比其他索引更快或更慢。
- en: Balanced binary trees
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 平衡二叉树
- en: If a binary tree is balanced, its search, insert, and delete operations take
    about `log(n)` steps, where `n` is the total number of elements in the tree. Additionally,
    the height of a balanced binary tree is approximately `log`2`n`,  which means
    that a balanced tree with 10,000 elements has a height of 14, which is remarkably
    small. The height of a balanced tree with 100,000 elements will be 17 and the
    height of a balanced tree with 1,000,000 elements will be 20! In other words,
    putting a significantly large number of elements into a balanced binary tree does
    not change the search speed of the tree extremely. Put differently, you can reach
    any node in a balanced tree with 1,000,000 nodes in at most 20 steps!
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果二叉树是平衡的，其搜索、插入和删除操作大约需要`log(n)`步，其中`n`是树中元素的总数。此外，平衡二叉树的高度大约是`log2(n)`，这意味着具有10,000个元素的平衡树的高度为14，这非常小。具有100,000个元素的平衡树的高度将是17，具有1,000,000个元素的平衡树的高度将是20！换句话说，将大量元素放入平衡二叉树并不会极大地改变树的搜索速度。换句话说，你最多用20步就可以到达一个具有1,000,000个节点的平衡树中的任何节点！
- en: '*Figure 3**.1* shows a small iSAX index, which allows us to learn more about
    iSAX indexes without getting lost in the details. We are going to learn more about
    the details of an iSAX index starting in the next section.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3.1*展示了一个小型的iSAX索引，这使我们能够更深入地了解iSAX索引，而不会迷失在细节中。我们将在下一节中学习更多关于iSAX索引的细节。'
- en: '![Figure 3.1 – A small iSAX index](img/Figure_3.1_B14769.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图3.1 – 一个小的iSAX索引](img/Figure_3.1_B14769.jpg)'
- en: Figure 3.1 – A small iSAX index
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 – 一个小的iSAX索引
- en: So, what do we have here and what does it tell us?
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们在这里有什么，它告诉我们什么呢？
- en: As each node of the iSAX index has four SAX words, we know that the segment
    value is 4\. However, we cannot be sure about the cardinality as cardinalities
    begin from the smallest value and are increased when needed, that is, when there
    is a split. However, even on splits, only a single SAX word is promoted to a higher
    cardinality value. The root of this particular iSAX index has three children –
    we assume that the remaining children of the root node are empty. The terminal
    nodes are `[0 0 1 1]`, `[0 1 0 1]`, `[11 1 0 0]`, `[10 11 0 0]`, `[10 10 00 0]`,
    and `[10 10 01 0]`, and the inner nodes are `[1 1 0 0]`, `[10 1 0 0]`, and `[10
    10 0 0]`. We cannot make any assumptions about the threshold value.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 由于iSAX索引的每个节点都有四个SAX词，我们知道段值是4。然而，我们无法确定基数，因为基数从最小值开始，并在需要时增加，即当有分裂时。然而，即使在分裂时，也只有一个SAX词被提升到更高的基数值。这个特定的iSAX索引的根有三个子节点——我们假设根节点的其余子节点为空。终端节点是`[0
    0 1 1]`、`[0 1 0 1]`、`[11 1 0 0]`、`[10 11 0 0]`、`[10 10 00 0]`和`[10 10 01 0]`，内部节点是`[1
    1 0 0]`、`[10 1 0 0]`和`[10 10 0 0]`。我们无法对阈值值做出任何假设。
- en: '[*Chapter 6*](B14769_06.xhtml#_idTextAnchor145) is going to present techniques
    for visualizing iSAX indexes, which can be very handy when we are working with
    big iSAX indexes and want to have an overview of the indexes.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '[*第6章*](B14769_06.xhtml#_idTextAnchor145)将介绍可视化iSAX索引的技术，这在处理大型iSAX索引并希望对索引有一个概览时非常有用。'
- en: The next section will provide more details about iSAX.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将提供更多关于iSAX的详细信息。
- en: Understanding how iSAX works
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解iSAX的工作原理
- en: In this section, we will discuss the way iSAX works, which includes the construction
    phase as well as its usage and parameters. Apart from the required theory, we
    will also present a handy command-line utility that helps you understand how many
    subsequences an iSAX index can have, given its parameters.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论iSAX的工作方式，这包括构建阶段以及其使用和参数。除了必要的理论之外，我们还将展示一个实用的命令行工具，该工具可以帮助你理解给定其参数的情况下，iSAX索引可以有多少个子序列。
- en: How iSAX and SAX are related
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: iSAX与SAX的关系
- en: The way iSAX and the SAX representation are related is simple. The keys on all
    the nodes of an iSAX index, apart from the root node, which has no key, are all
    SAX representations. So, a big part of building and searching an iSAX index is
    based on SAX.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: iSAX与SAX表示之间的关系很简单。iSAX索引中所有节点（除了没有键的根节点）的键都是SAX表示。因此，构建和搜索iSAX索引的大部分工作都是基于SAX的。
- en: We do not delete or update elements in an iSAX index not because it is not possible
    but because this is not how an iSAX index works.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会在iSAX索引中删除或更新元素，不是因为不可能，而是因为这不是iSAX索引的工作方式。
- en: It is now time to discuss the parameters of an iSAX index because the construction
    of an iSAX depends on them.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候讨论iSAX索引的参数了，因为iSAX的构建依赖于它们。
- en: The cardinality parameter
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集合参数
- en: The `[1 000 0 11]` SAX representation and another one with the `[10001 00 0
    1]` SAX representation. The second difference is that we begin with a cardinality
    value of 2\. This means that all the children of the root node have a cardinality
    value of 2 in all their SAX words.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`[1 000 0 11]` SAX表示和另一个具有`[10001 00 0 1]` SAX表示的表示。第二个区别是我们从2的基数值开始。这意味着根节点的所有子节点在它们的SAX词中都具有2的基数值。'
- en: The segments parameter
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 段参数
- en: The **segments** parameter of an iSAX index works in completely the same way
    as in every SAX representation and defines *the number of SAX words* in each SAX
    representation.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: iSAX索引的**段**参数与每个SAX表示中的工作方式完全相同，并定义了每个SAX表示中的**SAX词**数量。
- en: The threshold parameter
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 阈值参数
- en: The **threshold** parameter is new and defines *the maximum number of subsequences*
    a terminal node can store. We cannot exceed that value. The threshold parameter
    defines when the split of a node is going to take place.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**阈值**参数是新的，定义了终端节点可以存储的**最大子序列数**。我们不能超过这个值。阈值参数定义了节点分割何时发生。'
- en: The next subsection presents a command line utility that computes the mean values
    of a normalized subsequence based on the number of segments because the mean values
    define the SAX words.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个子节将介绍一个命令行工具，该工具基于段的数量计算归一化子序列的平均值，因为平均值定义了SAX词。
- en: Computing the normalized mean values
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算归一化平均值
- en: This subsection presents a utility that outputs the mean values of all normalized
    subsequences of a time series based on the segment value. It would make no sense
    to count the mean values of all normalized subsequences without splitting them
    based on the segment value because after normalization, the mean value of a subsequence
    is very close to 0, which is one of the points of normalization.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了一个实用程序，该实用程序基于段值输出时间序列所有归一化子序列的平均值。如果不根据段值分割，计算所有归一化子序列的平均值就没有意义，因为归一化后，子序列的平均值非常接近0，这是归一化的一个要点。
- en: 'We will use the `meanValues.py` script in this example. Its code is as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们将使用`meanValues.py`脚本。其代码如下：
- en: '[PRE0]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Based on the number of segments, the utility splits each subsequence into parts
    and calculates the mean value of each part. The last part of the code is as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 根据段的数量，该实用程序将每个子序列分割成部分，并计算每个部分的平均值。代码的最后部分如下：
- en: '[PRE1]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The output of `meanValues.py` is the following (a big part of the output is
    omitted for brevity):'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`meanValues.py`的输出如下（为了简洁起见，省略了大部分输出）：'
- en: '[PRE2]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You can save the output and process it with a utility such as `histogram.py`,
    which was presented in the previous chapter.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将输出保存下来，并用如`histogram.py`这样的工具进行处理，该工具在上一章中已介绍。
- en: '*Figure 3**.2* shows the output of `histogram.py` from two different time series
    with about 500,000 elements each when processed with `meanValues.py` using a sliding
    window size of `1024` and 4 segments. Four segments means that for each subsequence,
    we have to compute four mean values because we split each subsequence into four
    parts. Therefore, a 500,000-element time series produces 2,000,000 mean values
    that go into the histogram.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3.2* 展示了使用`meanValues.py`处理两个不同时间序列（每个时间序列大约有500,000个元素）的`histogram.py`输出，使用了`1024`的滑动窗口大小和4个段。四个段意味着对于每个子序列，我们必须计算四个平均值，因为我们把每个子序列分成四个部分。因此，一个500,000个元素的时间序列会产生2,000,000个平均值，这些平均值将进入直方图。'
- en: '![Figure 3.2 – The output of histogram.py from two time series](img/Figure_3.2_B14769.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图3.2 – 来自两个时间序列的histogram.py输出](img/Figure_3.2_B14769.jpg)'
- en: Figure 3.2 – The output of histogram.py from two time series
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 – 来自两个时间序列的histogram.py输出
- en: What does *Figure 3**.2* tell us? The upper plot is of a time series named ECG
    and the lower histogram is of a time series named EEG. The vast majority (around
    2 million values) of the mean values of the ECG time series, *and therefore the
    cardinality values*, falls into the `-0.5` to `0.5` value range. This means that,
    based on the breakpoint values, many SAX words are going to be very similar to
    each other and therefore are going to fall into a small amount of iSAX branches,
    making *the iSAX index of the ECG dataset really unbalanced*. On the other hand,
    for the EEG dataset, the mean values are better distributed in the histogram,
    which means that the SAX words they are going to produce are going to be better
    distributed and the generated iSAX index is going to be more balanced.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3.2* 告诉我们什么？上面的图是名为ECG的时间序列，下面的直方图是名为EEG的时间序列。ECG时间序列的平均值（因此是基数值）的大多数（大约200万个值）都落在`-0.5`到`0.5`的值范围内。这意味着，基于断点值，许多SAX词将非常相似，因此将落入少量的iSAX分支中，使得*ECG数据集的iSAX索引非常不平衡*。另一方面，对于EEG数据集，平均值在直方图中分布得更好，这意味着它们将产生的SAX词将分布得更好，生成的iSAX索引将更加平衡。'
- en: If you want to find out more about the distribution of values in a histogram,
    you can increase the number of bins and get a more detailed output.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于直方图中值分布的信息，你可以增加bin的数量，以获得更详细的输出。
- en: The next subsection presents a command line utility that computes the maximum
    number of subsequences an iSAX index with the given parameters can store. Keep
    in mind that this is an **ideal case** where the iSAX index is completely balanced
    and all terminal nodes have the maximum number of subsequences, which is not usually
    the case.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个小节将介绍一个命令行实用程序，该实用程序计算给定参数的iSAX索引可以存储的最大子序列数。请记住，这是一个**理想情况**，其中iSAX索引完全平衡，所有终端节点都有最大数量的子序列，这通常不是情况。
- en: How big can an iSAX index get?
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个iSAX索引可以有多大？
- en: In this subsection, we are going to calculate the maximum number of subsequences
    an iSAX index can store in the ideal condition. As you already know, the root
    of an iSAX index can have more than two children, whereas all other inner nodes
    have one or two children, which can either be other inner nodes or terminal nodes.
    An inner node can have any combination of inner nodes and terminal nodes as children.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节中，我们将计算在理想条件下iSAX索引可以存储的最大子序列数。正如你所知，iSAX索引的根节点可以有超过两个子节点，而所有其他内部节点只有一个或两个子节点，这些子节点可以是其他内部节点或终端节点。一个内部节点可以有任意组合的内部节点和终端节点作为子节点。
- en: 'Now, let us do an exercise together: imagine that we want to find out the maximum
    number of nodes an iSAX with a cardinality of `4` and `2` segments can have. As
    we are interested in nodes, the threshold parameter does not play a key role in
    our discussion, so it is ignored for now. We are going to come back to the threshold
    parameter at the end of our discussion.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们一起来做一个练习：假设我们想要找出一个基数`4`和`2`个段的iSAX索引可以有多少个节点。由于我们关注的是节点，阈值参数在我们的讨论中并不起关键作用，所以现在忽略它。我们将在讨论结束时回到阈值参数。
- en: 'First, we are going to calculate the number of children of the root node. This
    only depends on the number of segments because all the children of the root have
    a cardinality of `2`. Therefore, if we have 2 segments, the maximum number of
    children of the root node is 4, which is 2 2\. These have the following SAX representations:
    `[0, 0]`, `[0, 1]`, `[1, 0]`, and `[1, 1]`. If you are familiar with the binary
    system, these are all values that can be represented with 2 bits.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将计算根节点的子节点数。这仅取决于段的数量，因为根节点的所有子节点都具有基数`2`。因此，如果我们有2个段，根节点的最大子节点数是4，即2的2次方。这些有以下的SAX表示：`[0,
    0]`、`[0, 1]`、`[1, 0]`和`[1, 1]`。如果你熟悉二进制系统，这些都可以用2位表示。
- en: 'If we have 3 segments, the maximum number of children of the root node is 8,
    which is 2 3\. These have the following SAX representations: `[0, 0, 0]`, `[0,
    0, 1]`, `[0, 1, 0]`, `[0, 1, 1]`, `[1, 0, 0]`, `[1, 0, 1]`, `[1, 1, 0]`, and `[1,
    1, 1]`. If you are familiar with the binary system, these are all values that
    can be represented with 3 bits. For each of these children of the root, each SAX
    word can be as big as the cardinality value.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有3个段，根节点的最大子节点数是8，即2的3次方。这些有以下的SAX表示：`[0, 0, 0]`、`[0, 0, 1]`、`[0, 1, 0]`、`[0,
    1, 1]`、`[1, 0, 0]`、`[1, 0, 1]`、`[1, 1, 0]`和`[1, 1, 1]`。如果你熟悉二进制系统，这些都可以用3位表示。对于根节点的每个子节点，每个SAX词的大小可以与基数值一样大。
- en: Now, back to our original problem, which is computing the maximum number of
    nodes an iSAX with a cardinality of 4 and 2 segments can have. As proved, when
    there are 2 segments, the number of children of the root node is 4\. Each segment
    can have as many values as the cardinality, which in this case is 4\. So, with
    2 segments, we can have 4 times 4 possible combinations, which is 16\. This is
    the maximum value of terminal nodes that this iSAX index can store. So, *when
    we have a cardinality of 4 and 2 segments, the maximum number of terminal nodes*
    *is 16*.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回到我们最初的问题，即计算一个基数值为4、2个段的iSAX索引可以拥有的最大节点数。正如证明的那样，当有2个段时，根节点的子节点数是4。每个段可以有的值数量与基数相同，在这个例子中是4。所以，有2个段，我们可以有4乘以4的可能组合，即16。这是这个iSAX索引可以存储的最大终端节点数。因此，当我们有基数值为4和2个段时，**最大终端节点数**是16。
- en: Now that we know the total number of terminal nodes, it is time to stop ignoring
    the threshold parameter and see what kind of information it can provide us. The
    threshold parameter can help us compute the maximum number of subsequences this
    iSAX index can hold in an **ideal situation**. The reason we are talking about
    an ideal situation is that most of the time, iSAX indexes are not balanced and
    there is no way of making sure that an iSAX index is going to be balanced. This
    is because this depends on the subsequences and the sliding window size.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了终端节点的总数，是时候停止忽略阈值参数，看看它能为我们的提供什么信息了。阈值参数可以帮助我们在**理想情况下**计算这个iSAX索引可以容纳的最大子序列数。我们之所以谈论理想情况，是因为大多数情况下，iSAX索引是不平衡的，而且没有办法确保一个iSAX索引将会是平衡的。这是因为这取决于子序列和滑动窗口的大小。
- en: Therefore, *when we have 64 terminal nodes and a threshold value of 100, the
    maximum number of subsequences that can be stored in an iSAX index in an ideal
    case* *is 6,400*.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当我们有64个终端节点和阈值值为100时，在理想情况下，一个iSAX索引可以存储的最大子序列数是**6,400**。
- en: 'With all that information in mind, we are going to develop a small Python script
    to do the calculations for us. The code for `maximumISAX.py` is as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑了所有这些信息之后，我们将开发一个小型的Python脚本来为我们进行计算。`maximumISAX.py`的代码如下：
- en: '[PRE3]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The output of `maximumISAX.py` is the following:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`maximumISAX.py`的输出如下：'
- en: '[PRE4]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: So, the previous output tells us that an iSAX index with 4 segments, a cardinality
    value of 4, and a threshold value of 100 can hold up to `25600` subsequences.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，前面的输出告诉我们，一个有4个段、基数值为4和阈值值为100的iSAX索引可以容纳多达`25600`个子序列。
- en: 'If we run `maximumISAX.py` with the same number of segments and a different
    cardinality, we are going to get the following output:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们用相同数量的段和不同的基数运行`maximumISAX.py`，我们将得到以下输出：
- en: '[PRE5]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: So, the previous output tells us that an iSAX index with 4 segments, a cardinality
    value of 16, and a threshold value of 100 can hold up to `6553600` subsequences
    despite the fact that the root node still has 16 children.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，前面的输出告诉我们，一个有4个段、基数值为16和阈值值为100的iSAX索引，尽管根节点仍有16个子节点，但可以容纳多达`6553600`个子序列。
- en: The next subsection will discuss what happens when there is no space to add
    a given subsequence to an iSAX index.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 下一小节将讨论当没有空间将给定的子序列添加到iSAX索引中时会发生什么。
- en: What happens when there is no space left for adding more subsequences to an
    iSAX index?
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 当没有空间为添加更多子序列到iSAX索引时会发生什么？
- en: 'An iSAX index can *overflow*. In practice, this means that an iSAX index might
    not have enough space to add more subsequences. This happens when one or more
    branches of an iSAX index have used the full cardinality for all segments and
    the threshold value has been reached in these terminal nodes. *Figure 3**.3* visualizes
    this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: iSAX索引可能会*溢出*。在实践中，这意味着iSAX索引可能没有足够的空间来添加更多的子序列。这种情况发生在iSAX索引的一个或多个分支已经使用了所有段的全部基数，并且这些终端节点达到了阈值值。*图3.3*展示了这一点：
- en: '![Figure 3.3 – iSAX overflow](img/Figure_3.3_B14769.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图3.3 – iSAX溢出](img/Figure_3.3_B14769.jpg)'
- en: Figure 3.3 – iSAX overflow
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3 – iSAX溢出
- en: Suppose that the nodes with SAX representations of `[10 10 00 00]` and `[10
    10 00 01]` are full and are using their full cardinality. This means that we cannot
    promote the nodes with the `[10 10 00 00]` and `[10 10 00 01]` SAX representations
    anymore unless we increase one or more relevant parameters of the iSAX index.
    So, if we have a subsequence with a SAX representation of either `[10 10 00 00]`
    or `[10 10 00 01]`, we do not know what to do with it, hence the overflow of the
    iSAX index.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 假设具有SAX表示`[10 10 00 00]`和`[10 10 00 01]`的节点已满，并且正在使用它们的全部基数。这意味着除非我们增加iSAX索引的一个或多个相关参数，否则我们不能再提升具有`[10
    10 00 00]`和`[10 10 00 01]`SAX表示的节点。所以，如果我们有一个具有`[10 10 00 00]`或`[10 10 00 01]`SAX表示的子序列，我们不知道如何处理它，因此iSAX索引发生了溢出。
- en: In this section, we learned basic information about iSAX. The next section discusses
    the iSAX construction in more detail.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了关于iSAX的基本信息。下一节将更详细地讨论iSAX的构建。
- en: How iSAX is constructed
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: iSAX是如何构建的
- en: 'This section is going to describe the way an iSAX index is constructed. All
    the presented information is based on the research paper that describes iSAX.
    The logical steps are as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将要描述iSAX索引是如何构建的。所有提供的信息都是基于描述iSAX的研究论文。逻辑步骤如下：
- en: We begin with a node that is the root of the iSAX index. The root contains no
    actual data (subsequences) but it contains pointers to all nodes with the specified
    segments value and a cardinality value of `2`, which is a single bit that can
    only have two values, `0` and `1`.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们从一个节点开始，这个节点是iSAX索引的根。根节点不包含实际数据（子序列），但它包含指向所有具有指定段值和`2`的基数值的节点的指针，这是一个只能有两个值的单比特，即`0`和`1`。
- en: After that, we construct the children of the root node, which at this initial
    point are all terminal nodes without any subsequences in them.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 之后，我们构建根节点的子节点，在这个初始点，它们都是终端节点，没有任何子序列。
- en: We now begin adding subsequences to the children of the root based on their
    SAX representation.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，我们开始根据它们的SAX表示向根节点的子节点添加子序列。
- en: When the threshold value of a terminal node is reached, we perform the splits,
    based on the specified **promotion strategy**, and we distribute the subsequences
    to the two newly created terminal nodes.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当终端节点的阈值值达到时，我们根据指定的**提升策略**进行分割，并将子序列分配到两个新创建的终端节点。
- en: The process goes on until all subsequences have been inserted into the iSAX
    index or there is no place left to add a subsequence.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个过程会一直进行，直到所有子序列都插入到iSAX索引中，或者没有地方可以添加子序列。
- en: The next section will explain how iSAX is searched in order to get a better
    idea of how the construction process is related to the search operation.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将解释如何搜索iSAX，以便更好地了解构建过程与搜索操作之间的关系。
- en: How iSAX is searched
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: iSAX是如何搜索的
- en: 'The search process of an iSAX index can be described as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: iSAX索引的搜索过程可以描述如下：
- en: First, we have a subsequence that we want to look for in an iSAX index.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们有一个子序列，我们想在iSAX索引中查找这个子序列。
- en: Then, we must compute the SAX representation of that subsequence, using the
    same parameters as the iSAX index.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们必须使用与iSAX索引相同的参数计算该子序列的SAX表示。
- en: After that, we use the SAX representation of the subsequence to find out the
    child of the root that it belongs to.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 之后，我们使用子序列的SAX表示来找出它属于根节点的哪个子节点。
- en: Then, we keep searching that binary tree until we find a node with the same
    SAX representation. Keep in mind that we might need to reduce some of the SAX
    words of the subsequence based on the iSAX nodes. If such a node does not exist,
    then the iSAX index does not contain that subsequence.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们继续在二叉树中搜索，直到找到一个具有相同SAX表示的节点。记住，我们可能需要根据iSAX节点减少子序列中的某些SAX词。如果不存在这样的节点，那么iSAX索引不包含该子序列。
- en: Last, we examine the subsequences of that node – provided that such a terminal
    node exists – and look for that specific subsequence.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们检查该节点的子序列 – 假设存在这样的终端节点 – 并寻找那个特定的子序列。
- en: Generally speaking, the process is the same as if we added that subsequence
    to the iSAX index up to the point where we found the node that it belongs to.
    After that, we search the subsequences of that node.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 一般而言，这个过程与我们将该子序列添加到iSAX索引中直到找到它所属的节点是相同的。之后，我们搜索该节点的子序列。
- en: The next subsection will discuss the promotion strategy, which has to do with
    which SAX word is going to get promoted when a split needs to happen.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个子节将讨论提升策略，这与在需要发生分割时哪个SAX词将被提升有关。
- en: Promotion strategy
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提升策略
- en: The term **promotion strategy** refers to the selection of the segment that
    is going to be updated to a higher cardinality when a split is about to happen.
    Splits happen when we are about to add a new subsequence to a terminal node that
    already holds a number of subsequences that is equal to the threshold value. *Only
    that terminal node is going to* *be split*.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**提升策略**这个术语指的是在即将发生分割时，将要更新为更高基数段的选取。分割发生在我们即将向一个已经包含等于阈值值的子序列的终端节点添加新的子序列时。*只有那个终端节点将要*
    *被分割*。'
- en: The threshold value
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 阈值值
- en: The only parameter that is responsible for the splitting of a terminal node
    is the threshold parameter. If the threshold parameter were limitless, then all
    iSAX indexes would have terminal nodes with a cardinality value of 2, which are
    the root children.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 负责终端节点分割的唯一参数是阈值参数。如果阈值参数是无限的，那么所有iSAX索引的终端节点都将具有2的基数值，即根子节点。
- en: 'There are two promotion strategies when splitting a node:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在分割节点时，有两种提升策略：
- en: '`[0 1 0 0]` SAX representation. For the first promotion that needs to take
    place, we promote the first SAX word and get `[00 1 0 0]` and `[01 1 0 0]`. In
    the next promotion, we are going to promote the second SAX word, even if this
    promotion takes place on a different SAX representation. So, if we need to promote
    `[1 1 0 1]`, then this is going to give us `[1 10 0 1]` and `[1 11` `0 1]`.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[0 1 0 0]` SAX表示。对于需要进行的第一次提升，我们提升第一个SAX词，得到`[00 1 0 0]`和`[01 1 0 0]`。在接下来的提升中，我们将提升第二个SAX词，即使这次提升发生在不同的SAX表示上。所以，如果我们需要提升`[1
    1 0 1]`，这将给我们`[1 10 0 1]`和`[1 11 0 1]`。'
- en: '`[00 1 0 0]` is going to give us `[000 1 0 0]` and `[001 1 0 0]`, given that
    we have a cardinality value of at least 8\. When the leftmost SAX word has reached
    its full cardinality, we continue with the next one to its right.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[00 1 0 0]`将给我们`[000 1 0 0]`和`[001 1 0 0]`，前提是我们有一个至少为8的基数值。当最左边的SAX词达到其满基数时，我们继续下一个右边的SAX词。'
- en: There is no right or wrong promotion strategy – use what you like best.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 没有正确或错误的提升策略 – 使用你最喜欢的方法。
- en: The next subsection presents an essential operation of iSAX, which is node splitting.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个子节将介绍iSAX的一个基本操作，即节点分割。
- en: Splitting nodes
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分割节点
- en: 'This subsection discusses the node-splitting process in more detail. Splitting
    happens in one case only: when a terminal node is about to have more subsequences
    than the ones permitted by the threshold value. In that case, **that terminal
    node becomes an inner node**. Then, two terminal nodes are created based on the
    promotion strategy, which are the children of the newly created inner node. Imagine
    having the iSAX index presented in *Figure 3**.4*, which currently stores 10 subsequences:
    S 0 to S 9.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将更详细地讨论节点分割过程。分割仅在一种情况下发生：当一个终端节点即将拥有比阈值值允许的更多子序列时。在这种情况下，**那个终端节点变成一个内部节点**。然后，根据提升策略创建两个终端节点，它们是新创建的内部节点的子节点。想象一下，iSAX索引在*图3**.4*中展示，目前存储了10个子序列：S 0到S 9。
- en: 'We now want to add the S 10 subsequence to that index, but `[10 10 00 0]` is
    full:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在想要将S 10子序列添加到该索引中，但`[10 10 00 0]`已满：
- en: '![Figure 3.4 – Before node splitting](img/Figure_3.4_B14769.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图3.4 – 分割节点前](img/Figure_3.4_B14769.jpg)'
- en: Figure 3.4 – Before node splitting
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4 – 分割节点前
- en: So, in order to add a subsequence with a SAX representation of `[10 10 00 01]`,
    we need to split the `[10 10 00 0]` terminal node, which now becomes an inner
    node with the same SAX representation, and `[10 10 00 00]` and `[10 10 00 01]`
    SAX representations, respectively. So, in that case, we promoted the last SAX
    word.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了添加一个SAX表示为`[10 10 00 01]`的子序列，我们需要分裂`[10 10 00 0]`终端节点，现在它变成了具有相同SAX表示的内节点，以及`[10
    10 00 00]`和`[10 10 00 01]`的SAX表示，分别。因此，在这种情况下，我们提升了最后一个SAX词。
- en: After that, we iterate all the subsequences that were previously stored in `[10
    10 00 0]` in order to put them in either `[10 10 00 00]` or `[10 10 00 01]` based
    on their promoted SAX representations. We are not going to go into more detail
    about how the subsequences are distributed after the splitting because this is
    explained in detail in the *Manually constructing an iSAX index* section that
    follows.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将迭代之前存储在`[10 10 00 0]`中的所有子序列，根据它们提升后的SAX表示，将它们放入`[10 10 00 00]`或`[10 10
    00 01]`。我们不会深入探讨分裂后子序列的分布情况，因为这已经在接下来的*手动构建iSAX索引*部分中详细解释了。
- en: What if splitting does not solve the issue?
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果分裂不能解决问题怎么办？
- en: In the previous example, S 10 is going to go to the `[10 10 00 01]` terminal
    node, *provided that there is enough space* there. In the rare case where the
    new subsequences as well as all previously stored ones go to the same terminal
    node, the splitting process keeps going until the situation is resolved on its
    own or there is an iSAX overflow.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，S10将进入`[10 10 00 01]`终端节点，*前提是有足够的空间*。在罕见的情况下，新的子序列以及所有之前存储的子序列都进入同一个终端节点，分裂过程将继续进行，直到问题自行解决或出现iSAX溢出。
- en: '*Figure 3**.5* shows the new version of the iSAX index, after the node splitting:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3.5*显示了节点分裂后的iSAX索引的新版本：'
- en: '![Figure 3.5 – After node splitting](img/Figure_3.5_B14769.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图3.5 – 节点分裂后](img/Figure_3.5_B14769.jpg)'
- en: Figure 3.5 – After node splitting
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5 – 节点分裂后
- en: In this section, we learned about the stages of the iSAX construction process.
    The following section will show the manual construction of an iSAX index using
    a real example and diagrams.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了iSAX构建过程的各个阶段。下一节将通过一个真实示例和图表展示如何手动构建iSAX索引。
- en: Manually constructing an iSAX index
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 手动构建iSAX索引
- en: In this section, we are going to manually create a small iSAX index. For a better
    understanding of the process, we are going to present all the steps and describe
    all the required computations.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将手动创建一个小型的iSAX索引。为了更好地理解这个过程，我们将展示所有步骤并描述所有必要的计算。
- en: 'If you recall from earlier on in this chapter, the steps for creating an iSAX
    index can be described as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还记得本章前面的内容，创建iSAX索引的步骤可以描述如下：
- en: Separate a time series into subsequences based on the given sliding window size.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据给定的滑动窗口大小将时间序列分割成子序列。
- en: For each subsequence, calculate its SAX representation, based on the given parameters.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个子序列，根据给定的参数计算其SAX表示。
- en: Begin inserting the subsequences of the time series into the iSAX index. In
    the beginning, all iSAX nodes are terminal nodes, apart from the root.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始将时间序列的子序列插入到iSAX索引中。最初，除了根节点外，所有iSAX节点都是终端节点。
- en: Once a terminal node is full – the threshold value has been reached – split
    that node by increasing the cardinality of one of its segments and create two
    new terminal nodes.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦终端节点满了——达到了阈值——通过增加其某个段的基数来分裂该节点，并创建两个新的终端节点。
- en: The original terminal node becomes an inner node, which is now the father of
    the new newly created terminal nodes.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 原始终端节点变成了一个内节点，现在它是新创建的终端节点的父节点。
- en: Split the subsequences of the original terminal node into the two new terminal
    nodes based on their SAX representation.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据它们的SAX表示，将原始终端节点的子序列分割成两个新的终端节点。
- en: Where does a subsequence go?
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 子序列去哪里？
- en: It is important to realize that a subsequence with the `[00 10 10 11]` SAX representation
    *must go* under the `[0 1 1 1]` child of the root. After that, the exact place
    (terminal node) depends on the promotion that is going to take place in the process,
    which can be `[00 10 10 1]`, `[00 1 1 11]`, `[0 1 10 11]`, and so on. However,
    if we use its full SAX representation, it can only go in the `[00 10 10 11]` terminal
    node.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要意识到，具有`[00 10 10 11]` SAX表示的子序列*必须*位于根的`[0 1 1 1]`子节点下。之后，确切的位置（终端节点）取决于在过程中将要发生的提升，可以是`[00
    10 10 1]`、`[00 1 1 11]`、`[0 1 10 11]`等等。然而，如果我们使用其完整的SAX表示，它只能进入`[00 10 10 11]`终端节点。
- en: We are going to use a small time series for the iSAX construction process to
    not take too long to finish. However, the principles remain the same. We are also
    going to need the help of the `ts2PAA.py` utility from the previous chapter to
    get the SAX representation of each subsequence – we do not want to calculate everything
    manually.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个小时序来进行iSAX构建过程，以便不会花费太长时间完成。然而，原则是相同的。我们还需要使用上一章中的`ts2PAA.py`实用工具来获取每个子序列的SAX表示——我们不希望手动计算一切。
- en: As we are dealing with a small time series, we are going to use a segment value
    of `2`, a cardinality value of `8`, which means that we are going to be using
    3 bits for the cardinality, and a threshold value of `15`. The sliding window
    size is `8`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们处理的是一个小时序，我们将使用`2`作为段值，`8`作为基数值，这意味着我们将使用3位来表示基数，以及`15`作为阈值值。滑动窗口大小为`8`。
- en: 'So, the output of `ts2PAA.py` when processing `ts1.gz` is as follows (we are
    ignoring the normalized part of the output at this point, which is omitted for
    brevity):'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`ts2PAA.py`处理`ts1.gz`时的输出如下（我们目前忽略输出的归一化部分，为了简洁省略）：
- en: '[PRE6]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As `ts1.gz` contains a time series with 50 elements, we are going to get 43
    subsequences from it. Given the previous output, we are going to assign a name
    to each one of the subsequences – the name is based on the starting index of the
    subsequence in the original time series – and associate that name with the SAX
    representation. So, the first subsequence is going to be named S 0, the second
    S 1, and so on. The last one is going to be called S 42.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`ts1.gz`包含一个包含50个元素的时序，我们将从中获取43个子序列。根据之前的输出，我们将为每个子序列分配一个名称——该名称基于子序列在原始时序中的起始索引——并将该名称与SAX表示关联。因此，第一个子序列将被命名为S 0，第二个S 1，以此类推。最后一个将被称为S 42。
- en: We begin by creating the structure presented in *Figure 3**.6*. In this structure,
    we have the root node and its children, which are currently empty. Those children
    are constructed by creating all SAX representations using the specified number
    of segments and a cardinality value of 2, which means that each SAX word has a
    single digit, which can be either `0` or `1`. At this point, all these children
    are terminal nodes. This is just the initial version of the iSAX index, which
    means that at the end of the day, *there might be children without any subsequences*
    (empty). However, this representation helps us programmatically. Also, bear in
    mind that *each child of the root node is the root node of its own* *binary tree*.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建*图3**.6*中所示的结构。在这个结构中，我们有根节点及其子节点，目前这些子节点都是空的。这些子节点是通过创建所有使用指定数量的段和基数值为2的SAX表示来构建的，这意味着每个SAX词只有一个数字，可以是`0`或`1`。在此阶段，所有这些子节点都是终端节点。这只是iSAX索引的初始版本，这意味着最终可能会有没有子序列的子节点（空）。然而，这种表示有助于我们编程。此外，请记住，*根节点的每个子节点都是其自己的*
    *二叉树* *的根节点*。
- en: 'At this point, all subsequences are associated with the *maximum cardinality*,
    based on the iSAX parameters. However, initially, this *maximum cardinality* is
    reduced to a cardinality value of 2 according to the rule presented in the *Reducing
    the cardinality of a SAX representation* subsection of [*Chapter 2*](B14769_02_MA.xhtml#_idTextAnchor053).
    Only after a split do we need to use a cardinality other than 2 – and this only
    happens for the subsequences that are part of the split. Of course, on big iSAX
    indexes, there are not many terminal nodes that use a *cardinality value of 2
    on all their segments* – it should be clear by now that such terminal nodes are
    directly connected to the root node. Refer to the following figure:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，所有子序列都根据 iSAX 参数与 *最大基数* 相关联。然而，最初，这个 *最大基数* 根据在 [*第 2 章*](B14769_02_MA.xhtml#_idTextAnchor053)
    中“减少 SAX 表示的基数”小节中提出的规则减少到 2 的基数值。只有在分裂之后，我们才需要使用除 2 以外的基数 – 而且这仅发生在分裂的子序列中。当然，在大
    iSAX 索引中，没有很多终端节点在其所有段上使用 *基数值为 2* – 到现在为止，应该很清楚这样的终端节点是直接连接到根节点的。参见图：
- en: '![Figure 3.6 – The initial version of iSAX with the root and its children](img/Figure_3.6_B14769.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.6 – iSAX 的初始版本，包括根及其子节点](img/Figure_3.6_B14769.jpg)'
- en: Figure 3.6 – The initial version of iSAX with the root and its children
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.6 – iSAX 的初始版本，包括根及其子节点
- en: So, first, we put subsequence S 0 into the index. Before doing that, we need
    to reduce its cardinality, which goes from `[011, 100]` to `[0, 1]`. At this point,
    we find its matching cardinality in the children of the root based on the reduced
    cardinality, and we put it there. Now, we put subsequence S 1into the index, which
    has the `[011, 100]` SAX representation, which becomes `[0, 1]`. Now, we put subsequence
    S 2 into the index, which has the `[100, 011]` SAX representation, which becomes
    `[1, 0]`. Then, we put subsequence S 3 into the index, which has the `[011, 100]`
    SAX representation, which becomes `[``0, 1]`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，首先，我们将子序列 S 0 放入索引中。在这样做之前，我们需要减少其基数，从 `[011, 100]` 变为 `[0, 1]`。此时，我们根据简化后的基数在根节点的子节点中找到匹配的基数，并将其放置在那里。现在，我们将子序列
    S 1 放入索引中，其 SAX 表示为 `[011, 100]`，变为 `[0, 1]`。现在，我们将子序列 S 2 放入索引中，其 SAX 表示为 `[100,
    011]`，变为 `[1, 0]`。然后，我们将子序列 S 3 放入索引中，其 SAX 表示为 `[011, 100]`，变为 `[0, 1]`。
- en: 'After that, we have an iSAX index that looks like the one presented in *Figure
    3**.7*:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们有一个看起来像 *图 3.7* 中所示的 iSAX 索引：
- en: '![Figure 3.7 – Adding four subsequences to the iSAX index](img/Figure_3.7_B14769.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.7 – 向 iSAX 索引中添加四个子序列](img/Figure_3.7_B14769.jpg)'
- en: Figure 3.7 – Adding four subsequences to the iSAX index
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.7 – 向 iSAX 索引中添加四个子序列
- en: Now, we put subsequence S 4 into the index, which has the `[011, 100]` SAX representation,
    which becomes `[``0, 1]`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将子序列 S 4 放入索引中，其 SAX 表示为 `[011, 100]`，变为 `[0, 1]`。
- en: Then, we put subsequence S 5 into the index, which has the `[100, 011]` SAX
    representation, which becomes `[``1, 0]`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将子序列 S 5 放入索引中，其 SAX 表示为 `[100, 011]`，变为 `[1, 0]`。
- en: After that, we insert subsequence S 6 into the index, which has the `[010, 101]`
    SAX representation, which when reduced becomes `[``0, 1]`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们插入子序列 S 6 到索引中，其 SAX 表示为 `[010, 101]`，经过简化后变为 `[0, 1]`。
- en: Now, we put subsequence S 7 into the index, which has the `[011, 100]` SAX representation,
    which when reduced is `[``0, 1]`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将子序列 S 7 放入索引中，其 SAX 表示为 `[011, 100]`，经过简化后变为 `[0, 1]`。
- en: Now, we put subsequence S 8 into the index, which has the `[011, 100]` SAX representation,
    which becomes `[``0, 1]`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将子序列 S 8 放入索引中，其 SAX 表示为 `[011, 100]`，变为 `[0, 1]`。
- en: Then, we put subsequence S 9 into the index, which has the `[010, 101]` SAX
    representation, which becomes `[``0, 1]`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将子序列 S 9 放入索引中，其 SAX 表示为 `[010, 101]`，变为 `[0, 1]`。
- en: Next, we put subsequence S 10 into the index, which has the `[011, 100]` SAX
    representation, which becomes `[``0, 1]`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将子序列 S 10 放入索引中，其 SAX 表示为 `[011, 100]`，变为 `[0, 1]`。
- en: Currently, the node with the SAX representation of `[0, 1]` has 9 subsequences
    (*Figure 3**.8*).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，具有 `[0, 1]` SAX 表示的节点有 9 个子序列（*图 3.8*）。
- en: '![Figure 3.8 – The iSAX index with 11 subsequences](img/Figure_3.8_B14769.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.8 – 包含 11 个子序列的 iSAX 索引](img/Figure_3.8_B14769.jpg)'
- en: Figure 3.8 – The iSAX index with 11 subsequences
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.8 – 包含 11 个子序列的 iSAX 索引
- en: Now, we put subsequence S 11 into the index, which has the `[011, 100]` SAX
    representation, which becomes `[0, 1]`. Then, we put subsequence S 12 into the
    index, which has the `[100, 011]` SAX representation, which becomes `[``1, 0]`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将子序列 S 11 放入索引中，其 SAX 表示为 `[011, 100]`，简化后变为 `[0, 1]`。然后，我们将子序列 S 12 放入索引中，其
    SAX 表示为 `[100, 011]`，简化后变为 `[1, 0]`。
- en: Now, we insert subsequence S 13 into the index, which has the `[101, 010]` SAX
    representation, which when reduced becomes `[1, 0]`. After that, we put subsequence
    S 14 into the index, which has the `[100, 011]` SAX representation, which when
    reduced is `[``1, 0]`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将子序列 S 13 插入索引中，其 SAX 表示为 `[101, 010]`，简化后变为 `[1, 0]`。之后，我们将子序列 S 14 放入索引中，其
    SAX 表示为 `[100, 011]`，简化后变为 `[1, 0]`。
- en: Now, we put subsequence S 15 into the index, which has the `[011, 100]` SAX
    representation, which becomes `[0, 1]`. Then, we put subsequence S 16 into the
    index, which has the `[010, 101]` SAX representation, which becomes `[``0, 1]`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将子序列 S 15 放入索引中，其 SAX 表示为 `[011, 100]`，简化后变为 `[0, 1]`。然后，我们将子序列 S 16 放入索引中，其
    SAX 表示为 `[010, 101]`，简化后变为 `[0, 1]`。
- en: Now, we put subsequence S 17 into the index, which has the `[010, 101]` SAX
    representation, which becomes `[0, 1]`. After that, we put subsequence S 18 into
    the index, which has the `[011, 100]` SAX representation, which becomes `[``0,
    1]`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将子序列 S 17 放入索引中，其 SAX 表示为 `[010, 101]`，简化后变为 `[0, 1]`。之后，我们将子序列 S 18 放入索引中，其
    SAX 表示为 `[011, 100]`，简化后变为 `[0, 1]`。
- en: Now, we put subsequence S 19 into the iSAX index, which has the `[100, 011]`
    SAX representation, which when reduced is `[1, 0]`. Then, we put subsequence S 20
    into the iSAX index, which has the `[101, 010]` SAX representation, which becomes
    `[``1, 0]`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将子序列 S 19 放入 iSAX 索引中，其 SAX 表示为 `[100, 011]`，经过简化后变为 `[1, 0]`。然后，我们将子序列
    S 20 放入 iSAX 索引中，其 SAX 表示为 `[101, 010]`，简化后变为 `[1, 0]`。
- en: Now, we put subsequence S 21 into the iSAX index, which has the `[100, 011]`
    SAX representation, which becomes `[``1, 0]`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将子序列 S 21 放入 iSAX 索引中，其 SAX 表示为 `[100, 011]`，简化后变为 `[1, 0]`。
- en: Then, we put subsequence S 22 into the iSAX index, which has the `[101, 010]`
    SAX representation, which becomes `[``1, 0]`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将子序列 S 22 放入 iSAX 索引中，其 SAX 表示为 `[101, 010]`，简化后变为 `[1, 0]`。
- en: Now, we put subsequence S 23 into the iSAX index, which has the `[100, 011]`
    SAX representation, which becomes `[``1, 0]`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将子序列 S 23 放入 iSAX 索引中，其 SAX 表示为 `[100, 011]`，简化后变为 `[1, 0]`。
- en: After that, we put subsequence S 24 into the iSAX index, which has the `[011,
    100]` SAX representation, which becomes `[0, 1]`. At this point, the iSAX node
    with the SAX representation of `[0, 1]` is full.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将子序列 S 24 放入 iSAX 索引中，其 SAX 表示为 `[011, 100]`，简化后变为 `[0, 1]`。此时，SAX 表示为
    `[0, 1]` 的 iSAX 节点已满。
- en: Next, we put subsequence S 25 into the iSAX index, which has the `[100, 011]`
    SAX representation, which becomes `[``1, 0]`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将子序列 S 25 放入 iSAX 索引中，其 SAX 表示为 `[100, 011]`，简化后变为 `[1, 0]`。
- en: '*Figure 3**.9* shows the current version of the iSAX index (the root node is
    omitted for brevity):'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3.9* 展示了当前版本的 iSAX 索引（为了简洁，省略了根节点）：'
- en: '![Figure 3.9 – Adding subsequences to the iSAX index](img/Figure_3.9_B14769.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.9 – 向 iSAX 索引添加子序列](img/Figure_3.9_B14769.jpg)'
- en: Figure 3.9 – Adding subsequences to the iSAX index
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.9 – 向 iSAX 索引添加子序列
- en: 'Now, we try to insert subsequence S 26 into the iSAX index, which has the `[011,
    100]` SAX representation, which becomes `[0, 1]`. At this point, we must perform
    a split of the `[0, 1]` terminal node. Therefore, `[0, 1]` becomes an inner node
    and two new terminal nodes are created, which become the children of `[0, 1]`:
    `[00, 1]` and `[``01, 1]`.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们尝试将子序列 S 26 插入 iSAX 索引中，其 SAX 表示为 `[011, 100]`，简化后变为 `[0, 1]`。此时，我们必须对
    `[0, 1]` 终端节点进行分割。因此，`[0, 1]` 成为一个内部节点，并创建了两个新的终端节点，它们成为 `[0, 1]` 的子节点：`[00, 1]`
    和 `[01, 1]`。
- en: Now, we must calculate the SAX representations of all the existing subsequences
    of `[0, 1]` according to the new cardinality in order to put them into one of
    the two newly created terminal nodes.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须根据新的基数计算 `[0, 1]` 所有现有子序列的 SAX 表示，以便将它们放入两个新创建的终端节点之一。
- en: 'The new SAX representations of the subsequences of the previous `[0, 1]` terminal
    node are as follows: S 0 --> `[01, 1]`, S 1 --> `[01, 1]`, S 3 --> `[01, 1]`,
    S 4 --> `[01, 1]`, S 6 --> `[01, 1]`, S 7 --> `[01, 1]`, S 8 --> `[01, 1]`, S 9
    --> `[01, 1]`, S 10 --> `[01, 1]`, S 11 --> `[01, 1]`, S 15 --> `[01, 1]`, S 16
    --> `[01, 1]`, S 17 --> `[01, 1]`, S 18 --> `[01, 1]`, S 24 --> `[01, 1]`, and
    S 26 --> `[01, 1]`. If you look closely, you are going to discover that the first
    SAX word in all previous subsequences is the same: `01`. This means that the split
    is not going to work and we are going to need to perform an additional split.
    For no particular reason, we are going to keep promoting the first SAX word. Therefore,
    `[01, 1]` is going to become an inner node and create two new terminal nodes:
    `[010, 1]` and `[011, 1]`. There is no need to promote the other terminal node
    (`[00, 1]`) as there is no issue there.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 之前 `[0, 1]` 终端节点的子序列的新 SAX 表示如下：S 0 --> `[01, 1]`，S 1 --> `[01, 1]`，S 3 -->
    `[01, 1]`，S 4 --> `[01, 1]`，S 6 --> `[01, 1]`，S 7 --> `[01, 1]`，S 8 --> `[01,
    1]`，S 9 --> `[01, 1]`，S 10 --> `[01, 1]`，S 11 --> `[01, 1]`，S 15 --> `[01, 1]`，S 16
    --> `[01, 1]`，S 17 --> `[01, 1]`，S 18 --> `[01, 1]`，S 24 --> `[01, 1]`，以及 S 26
    --> `[01, 1]`。如果你仔细观察，你会注意到所有先前子序列的第一个 SAX 词都是相同的：`01`。这意味着分裂将不会起作用，我们需要执行额外的分裂。没有特别的原因，我们将继续提升第一个
    SAX 词。因此，`[01, 1]` 将成为一个内部节点，并创建两个新的终端节点：`[010, 1]` 和 `[011, 1]`。没有必要提升其他终端节点（`[00,
    1]`），因为那里没有问题。
- en: 'So, here are the new SAX representations of the previous subsequences: S 0
    --> `[011, 1]`, S 1 --> `[011, 1]`, S 3 --> `[011, 1]`, S 4 --> `[011, 1]`, S 6
    --> `[010, 1]`, S 7 --> `[011, 1]`, S 8 --> `[011, 1]`, S 9 --> `[010, 1]`, S 10
    --> `[011, 1]`, S 11 --> `[011, 1]`, S 15 --> `[011, 1]`, S 16 --> `[010, 1]`,
    S 17 --> `[010, 1]`, S 18 --> `[011, 1]`, S 24 --> `[011, 1]`, and S 26 --> `[``011,
    1]`.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，以下是先前子序列的新 SAX 表示：S 0 --> `[011, 1]`，S 1 --> `[011, 1]`，S 3 --> `[011, 1]`，S 4
    --> `[011, 1]`，S 6 --> `[010, 1]`，S 7 --> `[011, 1]`，S 8 --> `[011, 1]`，S 9 -->
    `[010, 1]`，S 10 --> `[011, 1]`，S 11 --> `[011, 1]`，S 15 --> `[011, 1]`，S 16 -->
    `[010, 1]`，S 17 --> `[010, 1]`，S 18 --> `[011, 1]`，S 24 --> `[011, 1]`，以及 S 26
    --> `[011, 1]`。
- en: This split resolves the issue, so the subsequences are put into the appropriate
    terminal node. *Figure 3**.10* shows the latest version of the iSAX index (the
    root node is omitted for brevity).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这种分裂解决了问题，因此子序列被放入适当的终端节点。*图 3.10* 展示了 iSAX 索引的最新版本（为了简洁，省略了根节点）。
- en: '![Figure 3.10 – Node splitting of an iSAX index](img/Figure_3.10_B14769.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.10 – iSAX 索引的节点分裂](img/Figure_3.10_B14769.jpg)'
- en: Figure 3.10 – Node splitting of an iSAX index
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.10 – iSAX 索引的节点分裂
- en: As stated before, the reason for having to perform a split is that we do not
    want the number of subsequences stored in a terminal node to be greater than the
    threshold value.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，必须执行分裂的原因是我们不希望终端节点中存储的子序列数量超过阈值值。
- en: Now, we put subsequence S 27 into the index, which has the `[100, 011]` SAX
    representation, which becomes `[1, 0]`. Next, we insert subsequence S 28 into
    the index, which has the `[110, 001]` SAX representation, which becomes `[``1,
    0]`.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将子序列 S 27 放入索引中，其 SAX 表示为 `[100, 011]`，变为 `[1, 0]`。接下来，我们将子序列 S 28 放入索引中，其
    SAX 表示为 `[110, 001]`，变为 `[1, 0]`。
- en: Now, we put subsequence S 29 into the index, which has the `[101, 010]` SAX
    representation, which becomes `[1, 0]`. Next, we insert subsequence S 30 into
    the index, which has the `[101, 010]` SAX representation, which becomes `[``1,
    0]`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将子序列 S 29 放入索引中，其 SAX 表示为 `[101, 010]`，变为 `[1, 0]`。接下来，我们将子序列 S 30 放入索引中，其
    SAX 表示为 `[101, 010]`，变为 `[1, 0]`。
- en: 'Now, we put subsequence S 31 into the index, which has the `[100, 011]` SAX
    representation, which becomes `[1, 0]`. At this point, we must split the `[1,
    0]` terminal node, which becomes an inner node with two new terminal nodes as
    its children: `[10, 0]` and `[11, 0]`. Therefore, the new SAX representations
    of the subsequences that were stored in `[1, 0]` are as follows: S 2 --> `[10,
    0]`, S 5 --> `[10, 0]`, S 12 --> `[10, 0]`, S 13 --> `[10, 0]`, S 14 --> `[10,
    0]`, S 19 --> `[10, 0]`, S 20 --> `[10, 0]`, S 21 --> `[10, 0]`, S 22 --> `[10,
    0]`, S 23 --> `[10, 0]`, S 25 --> `[10, 0]`, S 27 --> `[10, 0``]`, S 28 --> `[11,
    0]`, S 29 --> `[10, 0]`, S 30 --> `[10, 0]`, and S 31 --> `[``10, 0]`.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将子序列 S 31 放入索引中，其 SAX 表示为 `[100, 011]`，变为 `[1, 0]`。此时，我们必须分裂 `[1, 0]` 终端节点，它成为一个具有两个新终端节点作为子节点的内部节点：`[10,
    0]` 和 `[11, 0]`。因此，存储在 `[1, 0]` 中的子序列的新 SAX 表示如下：S 2 --> `[10, 0]`，S 5 --> `[10,
    0]`，S 12 --> `[10, 0]`，S 13 --> `[10, 0]`，S 14 --> `[10, 0]`，S 19 --> `[10, 0]`，S 20
    --> `[10, 0]`，S 21 --> `[10, 0]`，S 22 --> `[10, 0]`，S 23 --> `[10, 0]`，S 25 -->
    `[10, 0]`，S 27 --> `[10, 0]`，S 28 --> `[11, 0]`，S 29 --> `[10, 0]`，S 30 --> `[10,
    0]`，以及 S 31 --> `[10, 0]`。
- en: '*Figure 3**.11* shows the latest version of the iSAX index (the root node is
    omitted for brevity). Notice that `[10, 0]` terminal node is full and cannot store
    any more subsequences.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3.11*展示了iSAX索引的最新版本（为了简洁，省略了根节点）。请注意，`[10, 0]`终端节点已满，无法存储更多子序列。'
- en: '![Figure 3.11 – More node splitting in the iSAX index](img/Figure_3.11_B14769.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![图3.11 – iSAX索引中的更多节点分裂](img/Figure_3.11_B14769.jpg)'
- en: Figure 3.11 – More node splitting in the iSAX index
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.11 – iSAX索引中的更多节点分裂
- en: Now, we put subsequence S 32 into the index, which has the `[011, 100]` SAX
    representation, which becomes `[011, 1]` (we reduce the cardinality according
    to our needs). Next, we insert subsequence S 33 into the index, which has the
    `[010, 101]` SAX representation, which when reduced becomes `[``010, 1]`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将子序列S 32放入索引中，其SAX表示为`[011, 100]`，变为`[011, 1]`（根据我们的需求减少基数）。接下来，我们将子序列S 33插入索引中，其SAX表示为`[010,
    101]`，当减少后变为`[010, 1]`。
- en: After that, we put subsequence S 34 into the index, which has the `[001, 110]`
    SAX representation, which becomes `[00, 1]`. Next, we insert subsequence S 35
    into the index, which has the `[010, 101]` SAX representation, which becomes `[``010,
    1]`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将子序列S 34放入索引中，其SAX表示为`[001, 110]`，变为`[00, 1]`。接下来，我们将子序列S 35插入索引中，其SAX表示为`[010,
    101]`，变为`[010, 1]`。
- en: 'After that, we put subsequence S 36 into the index, which has the `[011, 100]`
    SAX representation, which becomes `[011, 1]`. Next, we insert subsequence S 37
    into the index, which has the `[100, 011]` SAX representation, which when reduced
    becomes `[10, 0]`. The last subsequence causes a split to the `[10, 0]` node,
    which becomes an inner node with two children: `[100, 0]` and `[``101, 0]`.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将子序列S 36放入索引中，其SAX表示为`[011, 100]`，变为`[011, 1]`。接下来，我们将子序列S 37插入索引中，其SAX表示为`[100,
    011]`，当减少后变为`[10, 0]`。最后一个子序列导致`[10, 0]`节点分裂，变为一个具有两个子节点的内部节点：`[100, 0]`和`[101,
    0]`。
- en: 'Therefore, the new SAX representations of the subsequences that were stored
    in `[10, 0]` are as follows: S 2 --> `[100, 0]`, S 5 --> `[100, 0]`, S 12 -->
    `[100, 0]`, S 13 --> `[101, 0]`, S 14 --> `[100, 0]`, S 19 --> `[100, 0]`, S 20
    --> `[101, 0]`, S 21 --> `[100, 0]`, S 22 --> `[101, 0]`, S 23 --> `[100, 0]`,
    S 25 --> `[100, 0]`, S 27 --> `[100, 0]`, S 29 --> `[101, 0]`, S 30 --> `[101,
    0]`, S 31 --> `[100, 0]`, and S 37 --> `[``100, 0]`.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，存储在`[10, 0]`中的子序列的新SAX表示如下：S 2 --> `[100, 0]`，S 5 --> `[100, 0]`，S 12 -->
    `[100, 0]`，S 13 --> `[101, 0]`，S 14 --> `[100, 0]`，S 19 --> `[100, 0]`，S 20 -->
    `[101, 0]`，S 21 --> `[100, 0]`，S 22 --> `[101, 0]`，S 23 --> `[100, 0]`，S 25 -->
    `[100, 0]`，S 27 --> `[100, 0]`，S 29 --> `[101, 0]`，S 30 --> `[101, 0]`，S 31 -->
    `[100, 0]`，以及S 37 --> `[101, 0]`。
- en: '*Figure 3**.12* shows the updated iSAX index (the root node is omitted for
    brevity).'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3.12*展示了更新后的iSAX索引（为了简洁，省略了根节点）。'
- en: '![Figure 3.12 – Updated version of the iSAX index with 38 subsequences](img/Figure_3.12_B14769.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![图3.12 – 包含38个子序列的iSAX索引更新版本](img/Figure_3.12_B14769.jpg)'
- en: Figure 3.12 – Updated version of the iSAX index with 38 subsequences
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.12 – 包含38个子序列的iSAX索引更新版本
- en: Next, we put S 38 into the index, which has the `[110, 001]` SAX representation,
    which becomes `[11, 0]`. Then, we insert subsequence S 39 into the index, which
    has the `[100, 011]` SAX representation, which becomes `[``100, 0]`.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将S 38放入索引中，其SAX表示为`[110, 001]`，变为`[11, 0]`。然后，我们将子序列S 39插入索引中，其SAX表示为`[100,
    011]`，变为`[100, 0]`。
- en: Next, we put subsequence S 40 into the index, which has the `[100, 011]` SAX
    representation, which becomes `[100, 0]`. After that, we insert subsequence S 41,
    which becomes `[``100, 0]`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将子序列S 40放入索引中，其SAX表示为`[100, 011]`，变为`[100, 0]`。之后，我们插入子序列S 41，变为`[100,
    0]`。
- en: '*Figure 3**.13* shows the final version of the iSAX index. If you count the
    subsequences in the terminal nodes, you are going to find that they are 43, which
    is the correct number based on the sliding window size and the time series length.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3.13*展示了iSAX索引的最终版本。如果你计算终端节点中的子序列数量，你会发现它们是43个，这是基于滑动窗口大小和时间序列长度的正确数量。'
- en: '![Figure 3.13 – The final version of the iSAX index](img/Figure_3.13_B14769.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![图3.13 – iSAX索引的最终版本](img/Figure_3.13_B14769.jpg)'
- en: Figure 3.13 – The final version of the iSAX index
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.13 – iSAX索引的最终版本
- en: You should agree by now that creating an iSAX index manually is a tedious process
    and nobody should have to do that. This makes it a perfect candidate to be carried
    out using a computer.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你应该同意手动创建iSAX索引是一个繁琐的过程，没有人应该被迫这样做。这使得它成为使用计算机执行的完美候选者。
- en: Now that we know how to manually populate an iSAX index, it is time to update
    the `counting.py` utility from [*Chapter 2*](B14769_02_MA.xhtml#_idTextAnchor053).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了如何手动填充iSAX索引，是时候更新[*第2章*](B14769_02_MA.xhtml#_idTextAnchor053)中的`counting.py`实用程序了。
- en: Updating the counting.py utility
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新counting.py实用程序
- en: Remember the `counting.py` utility from [*Chapter 2*](B14769_02_MA.xhtml#_idTextAnchor053)?
    In this section, we are going to update it and use it for some important tasks.
    We are not going to completely change the existing functionality or throw away
    all the existing code. We are going to build on the existing code of the `counting.py`
    utility, which is a great and productive way to develop new software.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 记得[*第2章*](B14769_02_MA.xhtml#_idTextAnchor053)中的`counting.py`实用程序吗？在本节中，我们将更新它并使用它来完成一些重要的任务。我们不会完全改变现有的功能或丢弃所有现有的代码。我们将基于现有的`counting.py`实用程序代码进行构建，这是一种开发新软件的极好且富有成效的方式。
- en: 'The updated version of the utility can be used for the following tasks:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 更新版的实用程序可用于以下任务：
- en: Seeing whether a time series can fit into an iSAX index. This computation is
    based on the existing functionality of `counting.py` combined with a test of whether
    the values of all dictionary entries are smaller than the threshold value.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查时序是否可以适应iSAX索引。这个计算基于`counting.py`现有的功能，并结合测试所有字典条目的值是否小于阈值值。
- en: Seeing whether a time series can fit into an iSAX index using more segments
    or by increasing the threshold. Again, this computation is based on the existing
    functionality of `counting.py`, which is enhanced with some extra computations
    and testing.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查时序是否可以通过增加段数或提高阈值来适应iSAX索引。这个计算基于`counting.py`现有的功能，并增加了额外的计算和测试。
- en: Seeing whether an iSAX index is relatively balanced or not. This can have a
    great impact on the performance of the index. However, as you already know, indexes
    are not balanced in general. The idea behind this functionality is based on counting
    the number of subsequences that go under each child of the root. Put simply, we
    count the subsequences on nodes that have a cardinality value of 2 on all their
    SAX words because these are the children of the root, and we print the results
    on screen. Although this test is not conclusive, it gives us a good idea of how
    the subsequences are going to be distributed in the iSAX index. Keep in mind that
    if you use a segments value larger than 4, you are going to get a large amount
    of output from the utility.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查iSAX索引是否相对平衡。这可能会对索引的性能产生重大影响。然而，正如您已经知道的，索引通常是不平衡的。这个功能背后的想法是基于计算根的每个子节点下的子序列数量。简单来说，我们计算具有2个基数值的子序列在节点上的数量，因为这些是根的子节点，并且我们在屏幕上打印结果。尽管这个测试不是决定性的，但它给我们一个很好的想法，了解子序列在iSAX索引中的分布情况。请注意，如果您使用大于4的段值，您将从这个实用程序中获得大量的输出。
- en: 'The new version of the `counting.py` utility, which is called `countingv2.py`
    and has been refactored to include a function, contains the following code, which
    is presented in four parts. The first part is as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 新版的`counting.py`实用程序，称为`countingv2.py`，已经被重构以包含一个函数，包含以下代码，分为四个部分。第一部分如下：
- en: '[PRE7]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `calculate()` function, which computes the number of subsequences per SAX
    representation, is called multiple times and is what might slow down the script.
    Therefore, before seeing `countingv2.py` in action, let me warn you that the utility
    might become slow when processing time series with millions of elements.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`calculate()`函数，它计算每个SAX表示的子序列数量，被多次调用，这可能会使脚本变慢。因此，在看到`countingv2.py`的实际应用之前，让我提醒您，当处理包含数百万元素的时序数据时，实用程序可能会变得缓慢。'
- en: 'The second part is as follows:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分如下：
- en: '[PRE8]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The condition for an overflow is as follows: *if any node, which is identified
    by its SAX representation, has more subsequences than the threshold value, then
    we have an overflow*. Instead of checking all nodes, we get the maximum value
    of subsequences found in a node (`max(KEYS.values())`) and we compare that to
    the given threshold value.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 溢出的条件如下：*如果一个节点，通过其SAX表示来识别，其子序列数量超过阈值值，则我们有一个溢出*。我们不是检查所有节点，而是获取节点中找到的子序列的最大值（`max(KEYS.values())`），并将其与给定的阈值值进行比较。
- en: 'The third part contains the following Python code:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 第三部分包含以下Python代码：
- en: '[PRE9]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The previous code works as follows.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码工作如下。
- en: If we have an overflow, then the code doubles the value of the parameter that
    holds the number of segments while having in mind that the `segments` parameter
    cannot be greater than the sliding window size. This is going to keep happening
    as long as there is an overflow and the segments are not bigger than the sliding
    window size. If we do not have an overflow in the first place, the code tries
    to reduce the value of the `cardinality` parameter by half and see what happens.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发生溢出，代码将参数`segments`的值加倍，同时考虑到`segments`参数不能大于滑动窗口的大小。只要发生溢出且段的大小不超过滑动窗口的大小，这种情况就会持续发生。如果一开始就没有溢出，代码会尝试将`cardinality`参数的值减半，看看会发生什么。
- en: 'The last part is the following:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的部分是以下内容：
- en: '[PRE10]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This last part of the code uses **a cardinality value of 2** to find out under
    which child of the root each subsequence is going to be placed. In this case,
    we do not care about overflows.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的最后这部分使用**基数值为2**来确定每个子序列将被放置在根节点的哪个子节点下。在这种情况下，我们不在乎溢出。
- en: 'Let me now present you with some actual uses of `countingv2.py`. Imagine having
    a time series with 450,000 elements and you want to know whether it can fit into
    an iSAX index with 4 segments, a cardinality of `32`, and a threshold value of
    `1500` when using a sliding window of `1024`. If you want to perform this test,
    please create a time series with synthetic data using the `synthetic_data.py`
    script from [*Chapter 1*](B14769_01.xhtml#_idTextAnchor015). The output of `countingv2.py`
    is going to be as follows (your output is going to vary as we are not using the
    same time series):'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我将向您展示`countingv2.py`的一些实际用途。想象一下，有一个包含450,000个元素的时间序列，你想知道它是否可以放入一个有4个段、基数`32`和阈值值`1500`的iSAX索引中，当使用`1024`的滑动窗口时。如果你想进行这个测试，请使用来自[*第1章*](B14769_01.xhtml#_idTextAnchor015)的`synthetic_data.py`脚本创建一个包含合成数据的时间序列。`countingv2.py`的输出将如下所示（你的输出将因我们不是使用相同的时间序列而有所不同）：
- en: '[PRE11]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'What does the previous output tell us? The first line tells us that we could
    have used a threshold value of `317` with the original SAX parameters and the
    entire time series would have fit into the iSAX index – this means that *the time
    series can fit into the iSAX index*. However, when reducing the cardinality to
    `16`, the iSAX index cannot fit the entire time series using 4 segments and a
    threshold value of `1500`. Finally, the last lines tell us that `76534` subsequences
    belong to the `[1 1 0 0]` SAX representation and `11942` subsequences belong to
    the `[0 0 1 0]` SAX representation. The number of subsequences under the rest
    of the children of the root is between `76534` and `11942`. Generally speaking,
    this is not a bad subsequence distribution for an iSAX index, despite the fact
    that two of the potential children of the root do not appear in the output: `[0
    0 0 0]` and `[1 1` `1 1]`.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的输出告诉我们什么？第一行告诉我们，我们可以使用原始SAX参数的阈值值`317`，整个时间序列将适合iSAX索引——这意味着*时间序列可以放入iSAX索引中*。然而，当将基数减少到`16`时，iSAX索引无法使用4个段和阈值值`1500`来容纳整个时间序列。最后几行告诉我们，`76534`个子序列属于`[1
    1 0 0]` SAX表示，`11942`个子序列属于`[0 0 1 0]` SAX表示。根节点其他子节点下的子序列数量在`76534`和`11942`之间。一般来说，这并不是一个坏的子序列分布，尽管根节点有两个潜在的子节点没有出现在输出中：`[0
    0 0 0]`和`[1 1 1 1]`。
- en: 'Now, let us do the same test using the same sliding window length but this
    time using an iSAX index with 2 segments, a cardinality of `128`, and a threshold
    value of `1500`. This time, the output is as follows:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用相同的滑动窗口长度进行相同的测试，但这次使用一个有2个段的iSAX索引，基数`128`，阈值值`1500`。这次，输出如下：
- en: '[PRE12]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'What does the previous output tell us? It tells us that the given iSAX parameters
    are not enough for hosting the provided time series in an iSAX index. However,
    increasing the number of segments to 4 would do the trick. The last two lines
    show a part of the problem: all subsequences go to either `[0 1]` or `[1 0]`,
    which means that both the `[1 1]` and `[0 0]` children of the root node are not
    being used at all, which might be a bad situation. Apart from the data itself,
    this also depends on the sliding window size.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的输出告诉我们什么？它告诉我们给定的iSAX参数不足以在iSAX索引中容纳提供的时间序列。然而，将段的数量增加到4将解决问题。最后两行显示了一部分问题：所有子序列都去了`[0
    1]`或`[1 0]`，这意味着根节点的`[1 1]`和`[0 0]`子节点根本没有被使用，这可能会是一个不好的情况。除了数据本身，这也取决于滑动窗口的大小。
- en: Normalization and SAX representation
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 归一化和SAX表示
- en: After running `countingv2.py` many times, it came to my attention that it is
    very rare to get SAX representations with all zeros or all ones, especially when
    dealing with a cardinality of 2\. The main reason for this phenomenon is **normalization**.
    Due to normalization, the normalized values of a subsequence cannot fall entirely
    on the left side or right side of 0 unless we are working with a subsequence that
    is all zeros. In that case, the normalized version is the same as the original
    and the mean value is exactly 0\. According to our way of treating zero, which
    means that we must decide whether it going to be included in the left area or
    right area of the 0 breakpoint, we can easily have a SAX representation with all
    zeros or all ones. However, having both in the same iSAX index is extremely rare
    or not possible at all. Keep that in mind when interpreting the results of the
    presented utility.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在多次运行 `countingv2.py` 之后，我注意到，很难得到所有零或所有一的 SAX 表示，尤其是在处理基数 2 的情况下。这种现象的主要原因在于
    **归一化**。由于归一化，子序列的归一化值不能完全落在 0 的左侧或右侧，除非我们处理的是全零的子序列。在这种情况下，归一化版本与原始版本相同，平均值正好是
    0。根据我们处理零的方式，这意味着我们必须决定它是否包含在 0 断点的左侧或右侧区域，我们很容易得到全零或全一的 SAX 表示。然而，在同一个 iSAX 索引中同时拥有这两种情况是非常罕见的，甚至根本不可能。在解释所提供工具的结果时，请记住这一点。
- en: 'Last, let us do the same check using an iSAX index with 4 segments, a cardinality
    of `64`, and a threshold value of `250`:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们使用具有 4 个段、基数 `64` 和阈值 `250` 的 iSAX 索引进行相同的检查：
- en: '[PRE13]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The previous output informs us that the selected parameters create an iSAX index
    that can host all the subsequences of the time series, but we cannot reduce the
    cardinality to `32`. Additionally, as we are using the same number of segments,
    the results regarding the subsequence distribution are exactly the same as in
    the first example execution of `countingv2.py`.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的输出告诉我们，所选参数创建的 iSAX 索引可以容纳时间序列的所有子序列，但我们无法将基数减少到 `32`。另外，由于我们使用相同数量的段，关于子序列分布的结果与
    `countingv2.py` 的第一次执行结果完全相同。
- en: When you have such command-line utilities, it is good to experiment with them
    as much as you can in order to get a better insight into iSAX and how the parameters
    affect its shape.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 当你拥有这样的命令行工具时，最好尽可能多地实验它们，以便更好地了解 iSAX 以及参数如何影响其形状。
- en: So, in this last section of the chapter, we have improved the `counting.py`
    utility to make it even more useful.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这一章的最后部分，我们改进了 `counting.py` 工具，使其更加有用。
- en: Summary
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed the theory behind the iSAX index and how the SAX
    representation is related to the iSAX index. We also learned how to manually create
    an iSAX index given a time series and the required parameters. Additionally, we
    developed some handy command-line utilities that support iSAX indexes. We now
    understand the necessary theory behind iSAX and are ready to apply it.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了 iSAX 索引背后的理论以及 SAX 表示如何与 iSAX 索引相关。我们还学习了如何根据时间序列和所需的参数手动创建 iSAX
    索引。此外，我们开发了一些实用的命令行工具，以支持 iSAX 索引。我们现在理解了 iSAX 所需的理论，并准备好应用它。
- en: The next chapter uses this chapter as its foundation in order to develop a Python
    package for computing iSAX indexes.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将以此章为基础，开发一个用于计算 iSAX 索引的 Python 包。
- en: Useful links
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有用链接
- en: 'The web page of Eamonn Keogh: [https://www.cs.ucr.edu/~eamonn/](https://www.cs.ucr.edu/~eamonn/)'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Eamonn Keogh 的网页：[https://www.cs.ucr.edu/~eamonn/](https://www.cs.ucr.edu/~eamonn/)
- en: 'For research issues regarding time series, read the research paper titled *Big
    Sequence Management: A glimpse of the Past, the Present, and the Future* by Themis
    Palpanas'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '关于时间序列的研究问题，请阅读 Themis Palpanas 撰写的题为 *Big Sequence Management: A glimpse of
    the Past, the Present, and the Future* 的研究论文。'
- en: 'Themis Palpanas''s home page: [https://helios2.mi.parisdescartes.fr/~themisp/](https://helios2.mi.parisdescartes.fr/~themisp/)'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Themis Palpanas 的个人主页：[https://helios2.mi.parisdescartes.fr/~themisp/](https://helios2.mi.parisdescartes.fr/~themisp/)
- en: '*OK! So* was used for some of the diagrams in this chapter: [https://okso.app/](https://okso.app/)'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*OK! So* 被用于本章的一些图中：[https://okso.app/](https://okso.app/)'
- en: Exercises
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'Try to work through the following exercises:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试完成以下练习：
- en: Manually create an iSAX index for the `{1, 2, -2, 2, 0, 1, 3, 4}` time series
    with a sliding window of 4 and a SAX representation with 2 segments, a cardinality
    of 4, and a threshold value of 2.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动为 `{1, 2, -2, 2, 0, 1, 3, 4}` 时间序列创建一个滑动窗口为 4、SAX 表示有 2 个段、基数 4 和阈值 2 的 iSAX
    索引。
- en: Manually create an iSAX index for the `{1, 0, 0, 2, 0, 1, -3, 0}` time series
    with a sliding window of 4 and a SAX representation with 2 segments, a cardinality
    of 4, and a threshold value of 4.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动为时间序列 `{1, 0, 0, 2, 0, 1, -3, 0}` 创建一个 iSAX 索引，滑动窗口大小为 4，SAX 表示包含 2 个段，基数值为
    4，阈值值为 4。
- en: Manually create an iSAX index for the `{1, -1, -1, 2, 0, 1, -3, 0, 4, 6, 8,
    10}` time series with a sliding window of 6, a SAX representation with 2 segments,
    a cardinality value of 8, and a threshold value of 4.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动为时间序列 `{1, -1, -1, 2, 0, 1, -3, 0, 4, 6, 8, 10}` 创建一个 iSAX 索引，滑动窗口大小为 6，SAX
    表示包含 2 个段，基数值为 8，阈值值为 4。
- en: Manually create an iSAX index for the `{1, -1, -1, 2, 0, 1, -3, 0, 4, 6, 8,
    10}` time series with a sliding window of 4 and a SAX representation with 2 segments,
    a cardinality of 4, and a threshold value of 4.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动为时间序列 `{1, -1, -1, 2, 0, 1, -3, 0, 4, 6, 8, 10}` 创建一个 iSAX 索引，滑动窗口大小为 4，SAX
    表示包含 2 个段，基数值为 4，阈值值为 4。
- en: Manually create an iSAX index for the `{0, 0, 0, 0, 1, -1, -1, 2, 0, 1, -3,
    0, 4, 6, 8, 10, 0, 0}` time series with a sliding window of 4 and a SAX representation
    with 2 segments, a cardinality of 4, and a threshold value of 2.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动为时间序列 `{0, 0, 0, 0, 1, -1, -1, 2, 0, 1, -3, 0, 4, 6, 8, 10, 0, 0}` 创建一个 iSAX
    索引，滑动窗口大小为 4，SAX 表示包含 2 个段，基数值为 4，阈值值为 2。
- en: Create a sample time series with 2,000,000 elements and check whether it can
    theoretically fit into an iSAX index with 6 segments, a cardinality of 32, and
    a threshold value of 500.
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个包含 2,000,000 个元素的样本时间序列，并检查它理论上是否可以适应一个包含 6 个段、基数值为 32 和阈值值为 500 的 iSAX
    索引。
