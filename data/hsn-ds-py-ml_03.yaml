- en: Matplotlib and Advanced Probability Concepts
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Matplotlib和高级概率概念
- en: After going through some of the simpler concepts of statistics and probability
    in the previous chapter, we're now going to turn our attention to some more advanced
    topics that you'll need to be familiar with to get the most out of the remainder
    of this book. Don't worry, they're not too complicated. First of all, let's have
    some fun and look at some of the amazing graphing capabilities of the `matplotlib`
    library.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们已经介绍了一些统计学和概率的简单概念，现在我们将把注意力转向一些更高级的主题，这些主题是你需要熟悉的，以便充分利用本书的剩余部分。别担心，它们并不太复杂。首先，让我们来玩一玩，看看`matplotlib`库的一些惊人的绘图能力。
- en: 'We''ll be covering the following topics in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Using the `matplotlib` package to plot graphs
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`matplotlib`包绘制图表
- en: Understanding covariance and correlation to determine the relationship between
    data
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解协方差和相关性以确定数据之间的关系
- en: Understanding conditional probability with examples
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解条件概率及其示例
- en: Understanding Bayes' theorem and its importance
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解贝叶斯定理及其重要性
- en: A crash course in Matplotlib
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Matplotlib的速成课程
- en: Your data is only as good as you can present it to other people, really, so
    let's talk about plotting and graphing your data and how to present it to others
    and make your graphs look pretty. We're going to introduce Matplotlib more thoroughly
    and put it through its paces.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你的数据只有你能向他人呈现得好，所以让我们谈谈如何绘制和展示你的数据，以及如何向他人呈现你的图表并使其看起来漂亮。我们将更全面地介绍Matplotlib，并对其进行全面测试。
- en: I'll show you a few tricks on how to make your graphs as pretty as you can.
    Let's have some fun with graphs. It's always good to make pretty pictures out
    of your work. This will give you some more tools in your tool chest for visualizing
    different types of data using different types of graphs and making it look pretty.
    We'll use different colors, different line styles, different axes, things like
    that. It's not only important to use graphs and data visualization to try to find
    interesting patterns in your data, but it's also interesting to present your findings
    well to a non-technical audience. Without further ado, let's dive in to Matplotlib.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我会向你展示一些技巧，让你的图表尽可能漂亮。让我们用图表玩一玩。将你的工作做成漂亮的图片总是很好的。这将为你提供更多的工具，用不同类型的图表来可视化不同类型的数据，并使其看起来漂亮。我们将使用不同的颜色、不同的线条样式、不同的坐标轴等等。重要的不仅是使用图表和数据可视化来尝试在数据中找到有趣的模式，而且还要有趣地向非技术人员展示你的发现。话不多说，让我们开始学习Matplotlib吧。
- en: Go ahead and open up the `MatPlotLib.ipynb` file and you can play around with
    this stuff along with me. We'll start by just drawing a simple line graph.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 继续打开`MatPlotLib.ipynb`文件，你可以和我一起玩弄这些东西。我们将从绘制一个简单的折线图开始。
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: So in this example, I import `matplotlib.pyplot` as `plt`, and with this, we
    can refer to it as `plt` from now on in this notebook. Then, I use `np.arange(-3,
    3, 0.001)` to create an x-axis filled with values between `-3` and `3` at increments
    of 0.001, and use `pyplot`'s `plot()` function to plot `x`. The y function will
    be `norm.pdf(x)`. So I'm going to create a probability density function with a
    normal distribution based on the `x` values, and I'm using the `scipy.stats norm`
    package to do that.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 所以在这个例子中，我导入`matplotlib.pyplot`作为`plt`，然后我们可以在笔记本中从现在开始将其称为`plt`。然后，我使用`np.arange(-3,
    3, 0.001)`创建一个x轴，其中填充了在`-3`和`3`之间以0.001增量的值，并使用`pyplot`的`plot()`函数来绘制`x`。y函数将是`norm.pdf(x)`。所以我将根据`x`值创建一个正态分布的概率密度函数，并使用`scipy.stats
    norm`包来实现。
- en: 'So tying it back into last chapter''s look at probability density functions,
    here we are plotting a normal probability density function using `matplotlib`.
    So we just call `pyplot`''s `plot()` method to set up our plot, and then we display
    it using `plt.show()`. When we run the previous code, we get the following output:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 所以将其与上一章关于概率密度函数的内容联系起来，这里我们使用`matplotlib`绘制正态概率密度函数。我们只需调用`pyplot`的`plot()`方法来设置我们的图表，然后使用`plt.show()`显示它。当我们运行前面的代码时，我们得到以下输出：
- en: '![](img/ac909c54-d8e6-4437-bcbe-49aaace13bb8.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ac909c54-d8e6-4437-bcbe-49aaace13bb8.png)'
- en: 'That''s what we get: a pretty little graph with all the default formatting.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们得到的：一个漂亮的小图表，带有所有默认格式。
- en: Generating multiple plots on one graph
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在一个图表上生成多个图表
- en: 'Let''s say I want to plot more than one thing at a time. You can actually call
    plot multiple times before calling show to actually add more than one function
    to your graph. Let''s look at the following code:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我想一次绘制多个图表。在调用show之前，你实际上可以多次调用plot来添加多个函数到你的图表中。让我们看看下面的代码：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this example, I'm calling my original function of just a normal distribution,
    but I'm going to render another normal distribution here as well, with a mean
    around `1.0` and a standard deviation of `0.5`. Then, I'm going to show those
    two together so you can see how they compare to each other.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我调用了我的原始函数，只是一个正态分布，但我还要渲染另一个正态分布，均值约为`1.0`，标准差为`0.5`。然后，我会把这两个一起显示出来，这样你就可以看到它们彼此之间的比较。
- en: '![](img/86bcf451-c546-482c-81f0-7d32400aebff.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](img/86bcf451-c546-482c-81f0-7d32400aebff.png)'
- en: You can see that by default, `matplotlib` chooses different colors for each
    graph automatically for you, which is very nice and handy of it.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，默认情况下，`matplotlib`会自动为每个图形选择不同的颜色，这对你来说非常好和方便。
- en: Saving graphs as images
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将图表保存为图像
- en: 'If I want to save this graph to a file, maybe I want to include it in a document
    or something, I can do something like the following code:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我想把这个图表保存到文件中，也许我想把它包含在文档中，我可以像下面的代码一样做：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Instead of just calling `plt.show()`, I can call `plt.savefig()` with a path
    to where I want to save this file and what format I want it in.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅仅调用`plt.show()`，我可以调用`plt.savefig()`并指定我想要保存这个文件的路径以及我想要的格式。
- en: You'll want to change that to an actual path that exists on your machine if
    you're following along. You probably don't have a `Users\Frank` folder on your
    system. Remember too that if you're on Linux or macOS, instead of a backslash
    you're going to use forward slashes, and you're not going to have a drive letter.
    With all of these Python Notebooks, whenever you see a path like this, make sure
    that you change it to an actual path that works on your system. I am on Windows
    here, and I do have a `Users\Frank` folder, so I can go ahead and run that. If
    I check my file system under `Users\Frank`, I have a `MyPlot.png` file that I
    can open up and look at, and I can use that in whatever document I want.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在跟着做的话，你会想把它改成你的机器上实际存在的路径。你可能没有一个`Users\Frank`文件夹。还要记住，如果你在Linux或macOS上，你将使用正斜杠而不是反斜杠，并且你不会有一个驱动器号。对于所有这些Python笔记本，每当你看到这样的路径时，确保你将它改为在你的系统上有效的路径。我在Windows上，我有一个`Users\Frank`文件夹，所以我可以继续运行。如果我在`Users\Frank`下检查我的文件系统，我有一个`MyPlot.png`文件，我可以打开并查看，并且我可以在任何我想要的文档中使用它。
- en: '![](img/74064b37-2c98-42e6-af09-84e624a65d80.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](img/74064b37-2c98-42e6-af09-84e624a65d80.png)'
- en: That's pretty cool. One other quick thing to note is that depending on your
    setup, you may have permissions issues when you come to save the file. You'll
    just need to find the folder that works for you. On Windows, your `Users\Name`
    folder is usually a safe bet. Alright, let's move on.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这很酷。还有一件要注意的事情是，根据你的设置，当你保存文件时可能会遇到权限问题。你只需要找到适合你的文件夹。在Windows上，你的`Users\Name`文件夹通常是一个安全的选择。好了，让我们继续。
- en: Adjusting the axes
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调整坐标轴
- en: 'Let''s say that I don''t like the default choices of the axes of this value
    in the previous graph. It''s automatically fitting it to the tightest set of the
    axis values that you can find, which is usually a good thing to do, but sometimes
    you want things on an absolute scale. Look at the following code:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我不喜欢上一个图表中的轴的默认选择。它自动调整到你可以找到的最紧凑的轴值集，这通常是一个好事，但有时你希望按绝对比例来做。看看下面的代码：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this example, first I get the axes using `plt.axes`. Once I have these axes
    objects, I can adjust them. By calling `set_xlim`, I can set the x range from
    -5 to 5 and with set `set_ylim`, I set the y range from 0 to 1\. You can see in
    the below output, that my x values are ranging from `-5` to `5`, and y goes from
    0 to 1\. I can also have explicit control over where the tick marks on the axes
    are. So in the previous code, I'm saying I want the x ticks to be at `-5`, `-4`,
    `- 3`, etc., and y ticks from 0 to 1 at 0.1 increments using the `set_xticks()`
    and `set_yticks()` functions. Now I could use the `arange` function to do that
    more compactly, but the point is you have explicit control over where exactly
    those tick marks happen, and you can also skip some. You can have them at whatever
    increments you want or whatever distribution you want. Beyond that, it's the same
    thing.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，首先我使用`plt.axes`获取坐标轴。一旦我有了这些坐标轴对象，我就可以调整它们。通过调用`set_xlim`，我可以将x范围设置为-5到5，通过`set_ylim`，我将y范围设置为0到1。你可以在下面的输出中看到，我的x值范围从`-5`到`5`，y值从0到1。我还可以明确控制坐标轴上的刻度标记的位置。因此，在上面的代码中，我说我希望x刻度在`-5`，`-4`，`-3`等处，y刻度从0到1，间隔为0.1，使用`set_xticks()`和`set_yticks()`函数。现在我可以使用`arange`函数更紧凑地做到这一点，但关键是你可以明确控制这些刻度标记的位置，也可以跳过一些。你可以按照你想要的增量或分布来设置它们。除此之外，其他都是一样的。
- en: Once I've adjusted my axes, I just called `plot()` with the functions that I
    want to plot and called `show()` to display it. Sure enough, there you have the
    result.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我调整了我的坐标轴，我只需调用`plot()`和我想要绘制的函数，并调用`show()`来显示它。确实，你可以看到结果。
- en: '![](img/5f1b0b4c-ae5e-4f7b-8e82-91a816a80f2f.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5f1b0b4c-ae5e-4f7b-8e82-91a816a80f2f.png)'
- en: Adding a grid
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加网格
- en: What if I want grid lines in my graphs? Well, same idea. All I do is call `grid()`
    on the axes that I get back from `plt.axes()`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我想在图表中添加网格线呢？嗯，同样的道理。我只需要在从`plt.axes()`获取的坐标轴上调用`grid()`。
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: By executing the above code, I get nice little grid lines. That makes it a little
    bit easier to see where a specific point is, although it clutters things up a
    little bit. It's a little bit of a stylistic choice there.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 通过执行上面的代码，我得到了漂亮的小网格线。这样可以更容易看到特定点在哪里，尽管会使事情有点凌乱。这是一个小小的风格选择。
- en: '![](img/cbcc6628-6b51-448c-a8f7-1adadc53cef2.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cbcc6628-6b51-448c-a8f7-1adadc53cef2.png)'
- en: Changing line types and colors
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更改线型和颜色
- en: What if I want to play games with the line types and colors? You can do that
    too.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我想要玩线型和颜色的游戏呢？你也可以这样做。
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: So you see in the preceding code, there's actually an extra parameter on the
    `plot()` functions at the end where I can pass a little string that describes
    the style of a line. In this first example, what `b-` indicates is I want a blue,
    solid line. The `b` stands for blue, and the dash means a solid line. For my second
    `plot()` function, I'm going to plot it in red, that's what the `r` means, and
    the colon means I'm going to plot it with a dotted line.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 所以你可以看到在上面的代码中，`plot()`函数的末尾实际上有一个额外的参数，我可以传递一个描述线条样式的小字符串。在第一个例子中，`b-`表示我想要一个蓝色的实线。`b`代表蓝色，短线表示实线。对于我的第二个`plot()`函数，我将以红色绘制，这就是`r`的含义，冒号表示我将以虚线绘制。
- en: '![](img/ff115f9e-aafa-40cf-8c34-140780516fa6.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ff115f9e-aafa-40cf-8c34-140780516fa6.png)'
- en: If I run that, you can see in the above graph what it does, and you can change
    different types of line styles.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我运行它，你可以在上面的图表中看到它的效果，并且你可以改变不同类型的线型。
- en: In addition, you can do a double dash (`--`).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你可以做一个双虚线(`--`)。
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The preceding code gives you dashed red line as a line style as shown in the
    following graph image:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码给出了虚线红线作为线型，如下图所示：
- en: '![](img/5bd95715-c102-46e5-ae16-2732ec4c9640.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5bd95715-c102-46e5-ae16-2732ec4c9640.png)'
- en: I can also do a dash dot combination (`-.`).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我还可以做一个点划线组合(`-.`)。
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You get an output that looks like the following graph image:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你会得到一个看起来像下面的图表图像的输出：
- en: '![](img/252eb00e-7eed-40b8-8355-57fabd4e13bf.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/252eb00e-7eed-40b8-8355-57fabd4e13bf.png)'
- en: So, those are the different choices there. I could even make it green with vertical
    slashes (`g:`).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这些就是不同的选择。我甚至可以让它变成绿色并带有垂直斜杠（`g:`）。
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'I''ll get the following output:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我将得到以下输出：
- en: '![](img/98bce130-eb7a-4833-b107-388a6d8c09aa.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/98bce130-eb7a-4833-b107-388a6d8c09aa.png)'
- en: Have some fun with that if you want, experiment with different values, and you
    can get different line styles.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意，可以尝试一些有趣的东西，尝试不同的值，你可以得到不同的线条样式。
- en: Labeling axes and adding a legend
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 给坐标轴加标签和添加图例
- en: 'Something you''ll do more often is labeling your axes. You never want to present
    data in a vacuum. You definitely want to tell people what it represents. To do
    that, you can use the `xlabel()` and `ylabel()` functions on `plt` to actually
    put labels on your axes. I''ll label the x axis Greebles and the y axis Probability.
    You can also add a legend inset. Normally, this would be the same thing, but just
    to show that it''s set independently, I''m also setting up a legend in the following
    code:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你经常会做的一件事是给你的坐标轴加上标签。你绝对不想孤立地呈现数据。你肯定想告诉人们它代表什么。为了做到这一点，你可以使用`plt`上的`xlabel()`和`ylabel()`函数来实际在你的坐标轴上放置标签。我将x轴标记为Greebles，y轴标记为Probability。你还可以添加一个图例插图。通常情况下，这将是相同的事情，但为了显示它是独立设置的，我也在以下代码中设置了一个图例：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Into the legend, you pass in basically a list of what you want to name each
    graph. So, my first graph is going to be called Sneetches, and my second graph
    is going to be called Gacks, and the `loc` parameter indicates what location you
    want it at, where `4` represents the lower right-hand corner. Let''s go ahead
    and run the code, and you should see the following:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在图例中，你基本上传入了一个你想要为每个图表命名的列表。所以，我的第一个图表将被称为Sneetches，我的第二个图表将被称为Gacks，而`loc`参数表示你想要的位置，其中`4`代表右下角。让我们运行一下代码，你应该会看到以下内容：
- en: '![](img/987087bc-64bd-4573-85e6-763adff5de35.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](img/987087bc-64bd-4573-85e6-763adff5de35.png)'
- en: You can see that I'm plotting Greebles versus Probability for both Sneetches
    and Gacks. A little Dr. Seuss reference for you there. So that's how you set axes
    labels and legends.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到我正在为Sneetches和Gacks绘制Greebles与Probability的图表。这是一个小的苏斯博士的参考。这就是你设置坐标轴标签和图例的方法。
- en: A fun example
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个有趣的例子
- en: A little fun example here. If you're familiar with the webcomic XKCD, there's
    a little bit of an Easter egg in Matplotlib, where you can actually plot things
    in XKCD style. The following code shows how you can do that.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个小有趣的例子。如果你熟悉网络漫画XKCD，Matplotlib中有一个小彩蛋，你可以以XKCD风格绘制图表。以下代码显示了你可以这样做。
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In this example, you call `plt.xkcd()`, which puts Matplotlib in XKCD mode.
    After you do that, things will just have a style with kind of a comic book font
    and squiggly lines automatically. This little simple example will show a funny
    little graph where we are plotting your health versus time, where your health
    takes a steep decline once you realize you can cook bacon whenever you want to.
    All we''re doing there is using the `xkcd()` method to go into that mode. You
    can see the results below:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你调用了`plt.xkcd()`，这将Matplotlib置于XKCD模式。在这之后，事情将自动以一种漫画书字体和波浪线的风格呈现。这个简单的例子将展示一个有趣的小图表，其中我们绘制了你的健康与时间的关系，当你意识到你可以随时煮培根时，你的健康状况急剧下降。我们所做的就是使用`xkcd()`方法进入那种模式。你可以在下面看到结果：
- en: '![](img/72e7f5b8-3152-47a4-abf1-c47f038380f8.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](img/72e7f5b8-3152-47a4-abf1-c47f038380f8.png)'
- en: There's a little bit of interesting Python here in how we're actually putting
    this graph together. We're starting out by making a data line that is nothing
    but the value 1 across 100 data points. Then we use the old Python list slicing
    operator to take everything after the value of 70, and we subtract off from that
    sub-list of 30 items, the range of 0 through 30\. So that has the effect of subtracting
    off a larger value linearly as you get past 70, which results in that line heading
    downward down to 0 beyond the point 70.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一点有趣的Python，我们实际上是如何将这个图表放在一起的。我们首先制作了一个数据线，它只是在100个数据点上的值为1。然后我们使用旧的Python列表切片运算符来取出值为70之后的所有内容，并从这个30个项目的子列表中减去0到30的范围。这样做的效果是，随着超过70，线性地减去一个更大的值，导致该线在70之后向下倾斜到0。
- en: So, it's a little example of some Python list slicing in action there, and a
    little creative use of the `arange` function to modify your data.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这是Python列表切片的一个小例子，以及`arange`函数的一点创造性用法来修改你的数据。
- en: Generating pie charts
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成饼图
- en: Now, to go back to the real world, we can remove XKCD mode by calling `rcdefaults()`
    on Matplotlib, and we can get back to normal mode here.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回到现实世界，我们可以通过在Matplotlib上调用`rcdefaults()`来移除XKCD模式，并在这里回到正常模式。
- en: 'If you want a pie chart, all you have to do is call `plt.pie` and give it an
    array of your values, colors, labels, and whether or not you want items exploded,
    and if so, by how much. Here''s the code:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要一个饼图，你只需要调用`plt.pie`并给它一个包含你的值、颜色、标签以及是否要爆炸的数组，如果是的话，爆炸多少。以下是代码：
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You can see in this code that I''m creating a pie chart with the values `12`,
    `55`, `4`, `32`, and `14`. I''m assigning explicit colors to each one of those
    values, and explicit labels to each one of those values. I''m exploding out the
    Russian segment of the pie by 20%, and giving this plot a title of Student Locations
    and showing it. The following is the output you should see:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，你可以看到我正在创建一个饼图，其中包含值`12`、`55`、`4`、`32`和`14`。我为每个值分配了明确的颜色，并为每个值分配了明确的标签。我将饼图中的俄罗斯部分扩大了20%，并给这个图表加上了一个标题“学生位置”并显示出来。以下是你应该看到的输出：
- en: '![](img/46c057a3-e9a6-40da-8748-ff1b8107251e.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/46c057a3-e9a6-40da-8748-ff1b8107251e.png)'
- en: That's all there is to it.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。
- en: Generating bar charts
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成条形图
- en: If I want to generate a bar chart, that is also very simple. It's a kind of
    a similar idea to the pie chart. Let's look at the following code.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我想生成一个条形图，也是非常简单的。这是一种类似于饼图的想法。让我们看看以下代码。
- en: '[PRE12]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'I''ve defined an array of values and an array of colors, and just plot the
    data. The above code plots from the range of 0 to 5, using the y values from the
    `values` array and using the explicit list of colors listed in the `colors` array.
    Go ahead and show that, and there you have your bar chart:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我定义了一个值数组和一个颜色数组，然后绘制数据。上面的代码从0到5的范围绘制，使用`values`数组中的y值，并使用`colors`数组中列出的显式颜色列表。继续展示，你就会得到你的条形图：
- en: '![](img/bb70ed4a-96b3-4742-9d20-9f97247d41ed.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bb70ed4a-96b3-4742-9d20-9f97247d41ed.png)'
- en: Generating scatter plots
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成散点图
- en: A scatter plot is something we'll see pretty often in this book. So, say you
    have a couple of different attributes you want to plot for the same set of people
    or things. For example, maybe we're plotting ages against incomes for each person,
    where each dot represents a person and the axes represent different attributes
    of those people.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 散点图是我们在本书中经常看到的东西。所以，假设你有一些不同的属性，你想为同一组人或物体绘制图表。例如，也许我们正在为每个人绘制年龄与收入的散点图，其中每个点代表一个人，轴代表这些人的不同属性。
- en: The way you do that with a scatter plot is you call `plt.scatter()` using the
    two axes that you want to define, that is, the two attributes that contain data
    that you want to plot against each other.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 使用散点图的方法是调用`plt.scatter()`，使用包含你想要绘制的数据的两个轴，也就是包含你想要相互绘制的数据的两个属性。
- en: 'Let''s say I have a random distribution in `X` and `Y` and I scatter those
    on the scatter plot, and I show it:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我在`X`和`Y`中有一个随机分布，我把它们散点图上，然后展示出来：
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You get the following scatter plot as output:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 你会得到以下散点图作为输出：
- en: '![](img/216c10dd-6394-43a9-ac6b-f761a26acd83.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/216c10dd-6394-43a9-ac6b-f761a26acd83.png)'
- en: This is what it looks like, pretty cool. You can see the sort of a concentration
    in the center here, because of the normal distribution that's being used in both
    axes, but since it is random, there's no real correlation between those two.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是它的样子，非常酷。你可以看到中心的一种集中，因为在两个轴上都使用了正态分布，但由于它是随机的，所以这两者之间没有真正的相关性。
- en: Generating histograms
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成直方图
- en: 'Finally, we''ll remind ourselves how a histogram works. We''ve already seen
    this plenty of times in the book. Let''s look at the following code:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们会回顾一下直方图是如何工作的。我们在书中已经看到了很多次。让我们看看以下代码：
- en: '[PRE14]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this example, I call a normal distribution centered on 27,000, with a standard
    deviation of 15,000 with 10,000 data points. Then, I just call `pyplot`'s histogram
    function, that is, `hist()`, and specify the input data and the number of buckets
    that we want to group things into in our histogram. Then I call `show()` and the
    rest is magic.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我调用了一个以27000为中心，标准差为15000的正态分布，有10000个数据点。然后，我只是调用了`pyplot`的直方图函数，也就是`hist()`，并指定了输入数据和我们想要将事物分组到直方图中的桶的数量。然后我调用`show()`，剩下的就是魔术。
- en: '![](img/fdd1e7b6-d46c-4ff0-99d5-3c9390efc143.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fdd1e7b6-d46c-4ff0-99d5-3c9390efc143.png)'
- en: Generating box-and-whisker plots
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成盒须图
- en: Finally, let's look at box-and-whisker plots. Remember in the previous chapter,
    when we talked about percentiles I touched on this a little bit.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看盒须图。还记得在上一章中，当我们谈到百分位数时，我稍微提到了这一点。
- en: Again, with a box-and-whisker plot, the box represents the two inner quartiles
    where 50% of your data resides. Conversely, another 25% resides on either side
    of that box; the whiskers (dotted lines in our example) represent the range of
    the data except for outliers.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，使用盒须图，盒子代表了50%的数据所在的两个内四分位数。相反，另外25%分布在盒子的两侧；盒须（在我们的例子中是虚线）代表了除异常值外的数据范围。
- en: We define outliers in a box-and-whisker plot as anything beyond 1.5 times the
    interquartile range, or the size of the box. So, we take the size of the box times
    1.5, and up to that point on the dotted whiskers, we call those parts outer quartiles.
    But anything outside of the outer quartiles is considered an outlier, and that's
    what the lines beyond the outer quartiles represent. That's where we are defining
    outliers based on our definition with the box-and-whisker plot.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在盒须图中将异常值定义为超出1.5倍四分位距或盒子大小的任何值。因此，我们将盒子的大小乘以1.5，然后在虚线盒须上到那一点，我们称这些部分为外四分位数。但是在外四分位数之外的任何值都被视为异常值，这就是超出外四分位数的线所代表的。这就是我们根据盒须图的定义来定义异常值的地方。
- en: 'Some points to remember about box-and-whisker plots:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 关于盒须图的一些要点：
- en: They are useful for visualizing the spread and skew of data
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们用于可视化数据的分布和偏斜
- en: The line in the middle of the box represents the median of the data, and the
    box represents the bounds of the 1st and 3rd quartiles
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 盒子中间的线代表数据的中位数，盒子代表第1和第3四分位数的范围
- en: Half of the data exists within the box
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据的一半存在于盒子中
- en: The "whiskers" indicate the range of the data-except for outliers, which are
    plotted outside the whiskers.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “盒须”表示数据的范围，异常值除外，异常值绘制在盒须之外。
- en: Outliers are 1.5 times or more the interquartile range.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常值是四分位距的1.5倍或更多。
- en: 'Now, just to give you an example here, we have created a fake dataset. The
    following example creates uniformly distributed random numbers between -40 and
    60, plus a few outliers above `100` and below `-100`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了给你一个例子，我们创建了一个虚假数据集。以下示例创建了在-40和60之间均匀分布的随机数，再加上一些在`100`以上和`-100`以下的异常值：
- en: '[PRE15]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the code, we have a uniform random distribution of data (`uniformSkewed`).
    Then we added a few outliers on the high end (`high_outliers`) and a few negative
    outliers (`low_outliers`) as well. Then we concatenated these lists together and
    created a single dataset from these three different sets that we created using
    NumPy. We then took that combined dataset of uniform data and a few outliers and
    we plotted using `plt.boxplot()`, and that's how you get a box-and-whisker plot.
    Call `show()` to visualize it, and there you go.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，我们有一个均匀随机分布的数据（`uniformSkewed`）。然后我们在高端添加了一些异常值（`high_outliers`），也添加了一些负异常值（`low_outliers`）。然后我们将这些列表连接在一起，并使用NumPy从这三个不同的集合创建了一个单一的数据集。然后我们拿到了这个组合数据集，其中包括均匀数据和一些异常值，我们使用`plt.boxplot()`进行了绘制，这就是如何得到箱线图的。调用`show()`进行可视化，就完成了。
- en: '![](img/77d95176-b924-4737-b914-454a2ebca453.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](img/77d95176-b924-4737-b914-454a2ebca453.png)'
- en: You can see that the graph is showing the box that represents the inner 50%
    of all data, and then we have these outlier lines where we can see little crosses
    (they may be circles in your version) for each individual outlier that lies in
    that range.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到图表显示了代表所有数据内部50%的箱子，然后我们有这些异常值线，我们可以看到每个在该范围内的个体异常值的小叉（在你的版本中可能是圆圈）。
- en: Try it yourself
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自己试试
- en: Alright, that's your crash course in Matplotlib. Time to get your hands on it,
    and actually do some exercises here.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，这就是Matplotlib的速成课程。是时候动手操作了，在这里实际做一些练习。
- en: As your challenge, I want you to create a scatter plot that represents random
    data that you fabricate on age versus time spent watching TV, and you can make
    anything you want, really. If you have a different fictional data set in your
    head that you like to play with, have some fun with it. Create a scatter plot
    that plots two random sets of data against each other and label your axes. Make
    it look pretty, play around with it, have fun with it. Everything you need for
    reference and for examples should be in this IPython Notebook. It's kind of a
    cheat sheet, if you will, for different things you might need to do for generating
    different kinds of graphs and different styles of graphs. I hope it proves useful.
    Now it's time to get back to the statistics.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 作为挑战，我希望你创建一个散点图，代表你编造的年龄与看电视时间的随机数据，你可以随意制造任何你想要的东西。如果你脑海中有一个不同的虚构数据集，你想要玩玩，那就尽情玩吧。创建一个散点图，将两组随机数据相互绘制，并标记你的坐标轴。让它看起来漂亮一些，尝试一下，玩得开心一些。你需要的所有参考和示例都应该在这个IPython笔记本中。这是一种速查表，如果你愿意的话，可以用来生成不同类型的图表和不同风格的图表。希望它能够有所帮助。现在是时候回到统计学了。
- en: Covariance and correlation
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 协方差和相关性
- en: Next, we're going to talk about covariance and correlation. Let's say I have
    two different attributes of something and I want to see if they're actually related
    to each other or not. This section will give you the mathematical tools you need
    to do so, and we'll dive into some examples and actually figure out covariance
    and correlation using Python. These are ways of measuring whether two different
    attributes are related to each other in a set of data, which can be a very useful
    thing to find out.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论协方差和相关性。假设我有某个东西的两个不同属性，我想看看它们是否实际上与彼此相关。这一部分将为你提供你需要的数学工具，以便这样做，我们将深入一些示例，并使用Python实际计算协方差和相关性。这些是衡量两个不同属性在一组数据中是否相关的方法，这可能是一个非常有用的发现。
- en: Defining the concepts
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义概念
- en: Imagine we have a scatter plot, and each one of the data points represents a
    person that we measured, and we're plotting their age on one axis versus their
    income on another. Each one of these dots would represent a person, for example
    their x value represents their age and the y value represents their income. I'm
    totally making this up, this is fake data.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 想象我们有一个散点图，每个数据点代表我们测量的一个人，我们在一个轴上绘制他们的年龄，另一个轴上绘制他们的收入。每一个点代表一个人，例如他们的x值代表他们的年龄，y值代表他们的收入。我完全是在编造，这是虚假数据。
- en: '![](img/d09e1804-b7c3-4f94-ad47-af0d6695da76.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d09e1804-b7c3-4f94-ad47-af0d6695da76.png)'
- en: Now if I had a scatter plot that looks like the left one in the preceding image,
    you see that these values tend to lie all over the place, and this would tell
    you that there's no real correlation between age and income based on this data.
    For any given age, there can be a huge range of incomes and they tend to be clustered
    around the middle, but we're not really seeing a very clear relationship between
    these two different attributes of age and income. Now in contrast, in the scatter
    plot on the right you can see there's a very clear linear relationship between
    age and income.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我有一个散点图，看起来像前面图片中的左边那个，你会发现这些值倾向于分散在各个地方，这会告诉你基于这些数据，年龄和收入之间没有真正的相关性。对于任何给定的年龄，收入可能有很大的范围，它们倾向于聚集在中间，但我们并没有真正看到年龄和收入这两个不同属性之间非常明显的关系。相比之下，在右边的散点图中，你可以看到年龄和收入之间有一个非常明显的线性关系。
- en: So, covariance and correlation give us a means of measuring just how tight these
    things are correlated. I would expect a very low correlation or covariance for
    the data in the left scatter plot, but a very high covariance and correlation
    for the data in the right scatter plot. So that's the concept of covariance and
    correlation. It measures how much these two attributes that I'm measuring seem
    to depend on each other.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，协方差和相关性给了我们一种衡量这些关系有多紧密的方法。我期望左边散点图中的数据具有非常低的相关性或协方差，但右边散点图中的数据具有非常高的协方差和相关性。这就是协方差和相关性的概念。它衡量了我正在测量的这两个属性似乎彼此依赖的程度。
- en: Measuring covariance
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测量协方差
- en: 'Measuring covariance mathematically is a little bit hard, but I''ll try to
    explain it. These are the steps:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 数学上测量协方差有点困难，但我会尝试解释一下。以下是步骤：
- en: Think of the data sets for the two variables as high-dimensional vectors
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将两个变量的数据集想象成高维向量
- en: Convert these to vectors of variances from the mean
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将这些转换为与均值的方差向量。
- en: Take the dot product (cosine of the angle between them) of the two vectors
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 取两个向量的点积（它们之间的余弦值）
- en: Divide by the sample size
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除以样本大小
- en: It's really more important that you understand how to use it and what it means.
    To actually derive it, think of the attributes of the data as high dimensional
    vectors. What we're going to do on each attribute for each data point is compute
    the variance from the mean at each point. So now I have these high dimensional
    vectors where each data point, each person, if you will, corresponds to a different
    dimension.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是你理解如何使用它以及它的含义。实际上，想象数据的属性是高维向量。我们要做的是对每个数据点的每个属性计算均值的方差。现在我有了这些高维向量，其中每个数据点，每个人，对应不同的维度。
- en: I have one vector in this high dimensional space that represents all the variances
    from the mean for, let's say, age for one attribute. Then I have another vector
    that represents all the variances from the mean for some other attribute, like
    income. What I do then is I take these vectors that measure the variances from
    the mean for each attribute, and I take the dot product between the two. Mathematically,
    that's a way of measuring the angle between these high dimensional vectors. So
    if they end up being very close to each other, that tells me that these variances
    are pretty much moving in lockstep with each other across these different attributes.
    If I take that final dot product and divide it by the sample size, that's how
    I end up with the covariance amount.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个高维空间中，我有一个向量代表了所有属性（比如年龄）的方差与均值的差值。然后我有另一个向量代表了另一个属性（比如收入）的方差与均值的差值。然后我对这些测量每个属性的方差的向量进行点积。从数学上讲，这是一种衡量这些高维向量之间角度的方法。所以如果它们非常接近，那告诉我这些方差在不同属性上几乎是同步变化的。如果我将最终的点积除以样本大小，那就是协方差的量。
- en: Now you're never going to have to actually compute this yourself the hard way.
    We'll see how to do this the easy way in Python, but conceptually, that's how
    it works.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你永远不需要自己从头计算这个。我们将看到如何在Python中以简单的方式做到这一点，但从概念上讲，就是这样工作的。
- en: Now the problem with covariance is that it can be hard to interpret. If I have
    a covariance that's close to zero, well, I know that's telling me there's not
    much correlation between these variables at all, but a large covariance implies
    there is a relationship. But how large is large? Depending on the units I'm using,
    there might be very different ways of interpreting that data. That's a problem
    that correlation solves.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在协方差的问题在于它很难解释。如果我有一个接近零的协方差，那么我知道这告诉我这些变量之间几乎没有相关性，但是一个大的协方差意味着存在关系。但大到什么程度？根据我使用的单位不同，可能有非常不同的解释方式。这是相关性解决的问题。
- en: Correlation
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相关性
- en: Correlation normalizes everything by the standard deviation of each attribute
    (just divide the covariance by the standard deviations of both variables and that
    normalizes things). By doing so, I can say very clearly that a correlation of
    -1 means there's a perfect inverse correlation, so as one value increases, the
    other decreases, and vice versa. A correlation of 0 means there's no correlation
    at all between these two sets of attributes. A correlation of 1 would imply perfect
    correlation, where these two attributes are moving in exactly the same way as
    you look at different data points.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 相关性通过每个属性的标准差进行归一化（只需将协方差除以两个变量的标准差即可实现归一化）。通过这样做，我可以非常清楚地说，相关性为-1意味着完全的反向相关，因此一个值增加，另一个值减少，反之亦然。相关性为0意味着这两组属性之间根本没有相关性。相关性为1意味着完美的相关性，这两个属性在查看不同数据点时以完全相同的方式移动。
- en: Remember, correlation does not imply causation. Just because you find a very
    high correlation value does not mean that one of these attributes causes the other.
    It just means there's a relationship between the two, and that relationship could
    be caused by something completely different. The only way to really determine
    causation is through a controlled experiment, which we'll talk about more later.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，相关性并不意味着因果关系。仅仅因为你找到了一个非常高的相关性值，并不意味着其中一个属性导致了另一个属性。它只是意味着两者之间存在关系，而这种关系可能是由完全不同的东西引起的。真正确定因果关系的唯一方法是通过控制实验，我们稍后会更多地讨论。
- en: Computing covariance and correlation in Python
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Python中计算协方差和相关性
- en: Alright, let's get our hands dirty with covariance and correlation here with
    some actual Python code. So again, you can think conceptually of covariance as
    taking these multi-dimensional vectors of variances from the mean for each attribute
    and computing the angle between them as a measure of the covariance. The math
    for doing that is a lot simpler than it sounds. We're talking about high dimensional
    vectors. It sounds like Stephen Hawking stuff, but really, from a mathematical
    standpoint it's pretty straightforward.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，让我们用一些实际的Python代码来深入了解协方差和相关性。所以你可以从概念上将协方差看作是对每个属性的均值方差的多维向量，并计算它们之间的角度作为协方差的度量。做这件事的数学比听起来简单得多。我们谈论的是高维向量。听起来像是史蒂芬·霍金的东西，但从数学的角度来看，它非常直接。
- en: Computing correlation – The hard way
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算相关性 - 最困难的方式
- en: 'I''m going to start by doing this the hard way. NumPy does have a method to
    just compute the covariance for you, and we''ll talk about that later, but for
    now I want to show that you can actually do this from first principles:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我将从最困难的方式开始。NumPy确实有一个方法可以直接为你计算协方差，我们稍后会讨论，但现在我想展示你实际上可以从头原理开始做到这一点：
- en: '[PRE16]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Covariance, again, is defined as the dot product, which is a measure of the
    angle between two vectors, of a vector of the deviations from the mean for a given
    set of data and the deviations from the mean for another given set of data for
    the same data's data points. We then divide that by n - 1 in this case, because
    we're actually dealing with a sample.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 协方差再次被定义为点积，这是两个向量之间的角度的度量，对于给定数据集的偏差向量和另一个给定数据集的偏差向量，我们将其除以n-1，在这种情况下，因为我们实际上处理的是一个样本。
- en: So `de_mean()`, our deviation from the mean function is taking in a set of data,
    `x`, actually a list, and it's computing the mean of that set of data. The `return`
    line contains a little bit of Python trickery for you. The syntax is saying, I'm
    going to create a new list, and go through every element in `x`, call it `xi`,
    and then return the difference between `xi` and the mean, `xmean`, for that entire
    dataset. This function returns a new list of data that represents the deviations
    from the mean for each data point.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 所以`de_mean()`，我们的偏差函数接收一组数据`x`，实际上是一个列表，并计算该数据集的平均值。`return`行包含一些Python的技巧。语法是说，我将创建一个新的列表，并遍历`x`中的每个元素，称之为`xi`，然后返回整个数据集中`xi`和平均值`xmean`之间的差异。这个函数返回一个新的数据列表，表示每个数据点相对于平均值的偏差。
- en: My `covariance()` function will do that for both sets of data coming in, divided
    by the number of data points minus 1\. Remember that thing about sample versus
    population in the previous chapter? Well, that's coming into play here. Then we
    can just use those functions and see what happens.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我的`covariance()`函数将对进入的两组数据进行散点图绘制，除以数据点的数量减1。还记得上一章关于样本与总体的事情吗？嗯，这在这里起作用。然后我们可以使用这些函数，看看会发生什么。
- en: To expand this example, I'm going to fabricate some data that is going to try
    to find a relationship between page speeds, that, is how quickly a page renders
    on a website, and how much people spend. For example, at Amazon we were very concerned
    about the relationship between how quickly pages render and how much money people
    spend after that experience. We wanted to know if there is an actual relationship
    between how fast the website is and how much money people actually spend on the
    website. This is one way you might go about figuring that out. Let's just generate
    some normally distributed random data for both page speeds and purchase amounts,
    and since it's random, there's not going to be a real correlation between them.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 为了扩展这个例子，我将捏造一些数据，试图找到页面速度和人们花费的金额之间的关系。例如，在亚马逊，我们非常关心页面渲染速度和用户在体验之后实际花费的金额之间的关系。我们想知道网站速度和用户在网站上实际花费的金额之间是否存在实际关系。这是你可能会去解决这个问题的一种方式。让我们为页面速度和购买金额生成一些正态分布的随机数据，由于它是随机的，所以它们之间不会有真正的相关性。
- en: '[PRE17]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'So just as a sanity check here we''ll start off by scatter plotting this stuff:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，作为一个理智的检查，我们将从散点图开始：
- en: '![](img/e91f9ab7-f787-4d99-a8bd-20be4560b14b.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e91f9ab7-f787-4d99-a8bd-20be4560b14b.png)'
- en: You'll see that it tends to cluster around the middle because of the normal
    distribution on each attribute, but there's no real relationship between the two.
    For any given page speed is a wide variety of amount spent, and for any given
    amount spent there's a wide variety of page speeds, so no real correlation there
    except for ones that are coming out the randomness or through the nature of the
    normal distribution. Sure enough, if we compute the covariance in these two sets
    of attributes, we end up with a very small value, -0.07\. So that's a very small
    covariance value, close to zero. That implies there's no real relationship between
    these two things.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到它倾向于围绕中间聚集，因为每个属性上的正态分布，但两者之间没有真正的关系。对于任何给定的页面速度，花费的金额有很大的变化，对于任何给定的花费金额，页面速度也有很大的变化，所以除了通过随机性或正态分布的性质产生的相关性之外，没有真正的相关性。果然，如果我们计算这两组属性的协方差，我们最终得到一个非常小的值，-0.07。所以这是一个非常小的协方差值，接近于零。这意味着这两件事之间没有真正的关系。
- en: Now let's make life a little bit more interesting. Let's actually make the purchase
    amount a real function of page speed.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们让生活变得更有趣一点。让我们实际上使购买金额成为页面速度的一个真实函数。
- en: '[PRE18]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here, we are keeping things a little bit random, but we are creating a real
    relationship between these two sets of values. For a given user, there''s a real
    relationship between the page speeds they encounter and the amount that they spend.
    If we plot that out, we can see the following output:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们保持事情有点随机，但我们在这两组值之间建立了一个真实的关系。对于给定的用户，他们遇到的页面速度和他们花费的金额之间存在着真实的关系。如果我们绘制出来，我们可以看到以下输出：
- en: '![](img/a59c51cf-ff2b-457e-bf18-2bb1340e9fa4.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a59c51cf-ff2b-457e-bf18-2bb1340e9fa4.png)'
- en: You can see that there's actually this little curve where things tend to be
    tightly aligned. Things get a little bit wonky near the bottom, just because of
    how random things work out. If we compute the covariance, we end up with a much
    larger value, -8, and it's the magnitude of that number that matters. The sign,
    positive or negative, just implies a positive or negative correlation, but that
    value of 8 says that's a much higher value than zero. So there's something going
    on there, but again it's hard to interpret what 8 actually means.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到实际上有一个小曲线，事物倾向于紧密排列。在底部附近会有一些混乱，只是因为随机性的工作方式。如果我们计算协方差，我们最终得到一个更大的值，-8，这个数字的大小很重要。符号，正或负，只是意味着正相关或负相关，但8这个值表示比零大得多。所以有一些事情发生了，但是再次很难解释8实际上意味着什么。
- en: 'That''s where the correlation comes in, where we normalize everything by the
    standard deviations as shown in the following code:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是相关性的作用，我们通过以下代码将一切标准化：
- en: '[PRE19]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Again, doing that from first principles, we can take the correlation between
    two sets of attributes, compute the standard deviation of each, then compute the
    covariance between these two things, and divide by the standard deviations of
    each dataset. That gives us the correlation value, which is normalized to -1 to
    1\. We end up with a value of -0.4, which tells us there is some correlation between
    these two things in the negative direction:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，从第一原则出发，我们可以计算两组属性之间的相关性，计算每个属性的标准差，然后计算这两个属性之间的协方差，并除以每个数据集的标准差。这给我们提供了归一化到-1到1的相关值。我们得到了一个值为-0.4，这告诉我们这两个属性之间存在一些负相关的关系：
- en: '![](img/68d23ab2-f88b-4e59-9a50-ca99032fe2da.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](img/68d23ab2-f88b-4e59-9a50-ca99032fe2da.png)'
- en: It's not a perfect line, that would be -1, but there's something interesting
    going on there.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一个完美的线性关系，那将是-1，但其中有一些有趣的东西。
- en: A -1 correlation coefficient means perfect negative correlation, 0 means no
    correlation, and 1 means perfect positive correlation.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: -1的相关系数意味着完美的负相关，0表示没有相关性，1表示完美的正相关。
- en: Computing correlation – The NumPy way
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算相关性-NumPy的方式
- en: 'Now, NumPy can actually compute correlation for you using the `corrcoef()`
    function. Let''s look at the following code:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，NumPy实际上可以使用`corrcoef()`函数为您计算相关性。让我们看一下以下代码：
- en: '[PRE20]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This single line gives the following output:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行代码给出了以下输出：
- en: '[PRE21]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'So, if we wanted to do this the easy way, we could just use `np.corrcoef(pageSpeeds,
    purchaseAmount)`, and what that gives you back is an array that gives you the
    correlation between every possible combination of the sets of data that you pass
    in. The way to read the output is: the 1 implies there is a perfect correlation
    between comparing `pageSpeeds` to itself and `purchaseAmount` to itself, which
    is expected. But when you start comparing `pageSpeeds` to `purchaseAmount` or
    `purchaseAmount` to the `pageSpeeds`, you end up with the -0.4672 value, which
    is roughly what we got when we did it the hard way. There''s going to be little
    precision errors, but it''s not really important.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，如果我们想简单地做到这一点，我们可以使用`np.corrcoef(pageSpeeds, purchaseAmount)`，它会给你一个数组，其中包含了你传入的数据集的每一种可能的组合之间的相关性。输出的方式是：1表示在比较`pageSpeeds`和`purchaseAmount`自身时有完美的相关性，这是预期的。但当你开始比较`pageSpeeds`和`purchaseAmount`或`purchaseAmount`和`pageSpeeds`时，你得到了-0.4672的值，这大致是我们用较困难的方法得到的结果。会有一些精度误差，但这并不重要。
- en: 'Now we could force a perfect correlation by fabricating a totally linear relationship,
    so let''s take a look at an example of that:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过制造一个完全线性的关系来强制产生完美的相关性，所以让我们看一个例子：
- en: '[PRE22]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'And again, here we would expect the correlation to come out to -1 for a perfect
    negative correlation, and in fact, that''s what we end up with:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们期望相关性的结果为-1，表示完美的负相关，事实上，这就是我们得到的结果：
- en: '![](img/b671a29a-545d-4ae6-9a91-6f3c80106b6f.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b671a29a-545d-4ae6-9a91-6f3c80106b6f.png)'
- en: 'Again, a reminder: Correlation does not imply causality. Just because people
    might spend more if they have faster page speeds, maybe that just means that they
    can afford a better Internet connection. Maybe that doesn''t mean that there''s
    actually a causation between how fast your pages render and how much people spend,
    but it tells you there''s an interesting relationship that''s worth investigating
    more. You cannot say anything about causality without running an experiment, but
    correlation can tell you what experiments you might want to run.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 再次提醒：相关性并不意味着因果关系。只是因为人们可能会在页面速度更快时花费更多，也许这只是意味着他们能负担得起更好的互联网连接。也许这并不意味着页面渲染速度和人们花费的金额之间实际上存在因果关系，但它告诉你有一个值得进一步调查的有趣关系。你不能在没有进行实验的情况下说任何关于因果关系的事情，但相关性可以告诉你你可能想要进行的实验。
- en: Correlation activity
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相关性活动
- en: So get your hands dirty, roll up your sleeves, I want you to use the `numpy.cov()`
    function. That's actually a way to get NumPy to compute covariance for you. We
    saw how to compute correlation using the `corrcoef()` function. So go back and
    rerun these examples just using the `numpy.cov()` function and see if you get
    the same results or not. It should be pretty darn close, so instead of doing it
    the hard way with the covariance function that I wrote from scratch, just use
    NumPy and see if you can get the same results. Again, the point of this exercise
    is to get you familiar with using NumPy and applying it to actual data. So have
    at it, see where you get.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 所以动手做，卷起袖子，我希望你使用`numpy.cov()`函数。这实际上是让NumPy为你计算协方差的一种方法。我们看到了如何使用`corrcoef()`函数计算相关性。所以回去重新运行这些例子，只使用`numpy.cov()`函数，看看你是否得到了相同的结果。它应该非常接近，所以不要用我从头开始编写的协方差函数的较困难的方法，只需使用NumPy，看看你是否能得到相同的结果。再次强调，这个练习的目的是让你熟悉使用NumPy并将其应用到实际数据中。所以试试看，看看你能得到什么结果。
- en: And there you have it, covariance and correlation both in theory and in practice.
    A very useful technique to have, so definitely remember this section. Let's move
    on.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是协方差和相关性的理论和实践。这是一个非常有用的技术，所以一定要记住这一部分。让我们继续。
- en: Conditional probability
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 条件概率
- en: Next, we're going to talk about conditional probability. It's a very simple
    concept. It's trying to figure out the probability of something happening given
    that something else occurred. Although it sounds simple, it can be actually very
    difficult to wrap your head around some of the nuances of it. So get an extra
    cup of coffee, make sure your thinking cap's on, and if you're ready for some
    more challenging concepts here. Let's do this.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论条件概率。这是一个非常简单的概念。它试图找出在发生某事的情况下另一件事发生的概率。尽管听起来很简单，但实际上理解其中的一些细微差别可能会非常困难。所以多倒一杯咖啡，确保你的思维帽戴好了，如果你准备好接受一些更具挑战性的概念。让我们开始吧。
- en: Conditional probability is a way to measure the relationship between two things
    happening to each other. Let's say I want to find the probability of an event
    happening given that another event already happened. Conditional probability gives
    you the tools to figure that out.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 条件概率是衡量两件事相互发生关系的一种方法。假设我想找出在另一件事已经发生的情况下某个事件发生的概率。条件概率可以帮助你找出这个概率。
- en: What I'm trying to find out with conditional probability is if I have two events
    that depend on each other. That is, what's the probability that both will occur?
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我试图通过条件概率找出的是两个事件是否相互依赖。也就是说，两者都发生的概率是多少？
- en: In mathematical notation, the way we indicate things here is that *P(A,B)* represents
    the probability of both A and B occurring independent of each other. That is,
    what's the probability of both of these things happening irrespective of everything
    else.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在数学表示法中，我们表示这些事情的方式是 *P(A,B)* 表示A和B同时发生的概率，而与其他事情无关。也就是说，这两件事情发生的概率是多少，与其他一切无关。
- en: 'Whereas this notation, *P(B|A)*, is read as the probability of B given A. So,
    what is the probability of B given that event A has already occurred? It''s a
    little bit different, and these things are related like this:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 而这种表示法 *P(B|A)*，读作给定A的情况下B的概率。那么，在事件A已经发生的情况下，B发生的概率是多少？这有点不同，但这些事情是相关的，就像这样：
- en: '![](img/37e81c3a-f563-41db-b0ec-13cdf30b6947.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![](img/37e81c3a-f563-41db-b0ec-13cdf30b6947.png)'
- en: The probability of B given A is equal to the probability of A and B occurring
    over the probability of A alone occurring, so this teases out the probability
    of B being dependent on the probability of A.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 给定A的情况下B的概率等于A和B同时发生的概率除以A单独发生的概率，这就揭示了B的概率依赖于A的概率。
- en: It'll make more sense with an example here, so bear with me.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这里举个例子会更容易理解，所以请耐心等待。
- en: Let's say that I give you, my readers, two tests, and 60% of you pass both tests.
    Now the first test was easier, 80% of you passed that one. I can use this information
    to figure out what percentage of readers who passed the first test also passed
    the second. So here's a real example of the difference between the probability
    of B given A and the probability of A and B.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我给你们读者两个测试，60%的人都通过了两个测试。现在第一个测试比较容易，80%的人通过了。我可以利用这些信息来计算通过第一个测试的读者中有多少人也通过了第二个测试。这是一个真实的例子，说明了给定A的情况下B的概率和A和B的概率之间的差异。
- en: I'm going to represent A as the probability of passing the first test, and B
    as the probability of passing the second test. What I'm looking for is the probability
    of passing the second test given that you passed the first, that is, *P (B|A)*.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我将把A表示为通过第一个测试的概率，B表示通过第二个测试的概率。我要找的是在通过第一个测试的情况下通过第二个测试的概率，即 *P(B|A)*。
- en: '![](img/e4de6cdd-edda-437a-8e02-a49b596bf779.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e4de6cdd-edda-437a-8e02-a49b596bf779.png)'
- en: So the probability of passing the second test given that you passed the first
    is equal to the probability of passing both tests, *P(A,B)* (I know that 60% of
    you passed both tests irrespective of each other), divided by the probability
    of passing the first test, *P(A)*, which is 80%. It's worked out to 60% passed
    both tests, 80% passed the first test, therefore the probability of passing the
    second given that you passed the first works out to 75%.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，给定通过第一个测试的情况下通过第二个测试的概率等于通过两个测试的概率 *P(A,B)*（我知道60%的人通过了两个测试，而不考虑彼此的影响），除以通过第一个测试的概率
    *P(A)*，即80%。计算结果是通过了两个测试的概率为60%，通过了第一个测试的概率为80%，因此给定通过第一个测试的情况下通过第二个测试的概率为75%。
- en: OK, it's a little bit tough to wrap your head around this concept. It took me
    a little while to really internalize the difference between the probability of
    something given something and the probability of two things happening irrespective
    of each other. Make sure you internalize this example and how it's really working
    before you move on.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这个概念有点难以理解。我花了一点时间才真正理解了给定某事物的概率和两件事情发生的概率之间的差异。在继续之前，请确保你理解了这个例子以及它是如何运作的。
- en: Conditional probability exercises in Python
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python中的条件概率练习
- en: Alright, let's move on and do another more complicated example using some real
    Python code. We can then see how we might actually implement these ideas using
    Python.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们继续，用一些真实的Python代码来做另一个更复杂的例子。然后我们可以看看如何实际使用Python来实现这些想法。
- en: Let's put conditional probability into action here and use some of the ideas
    to figure out if there's a relationship between age and buying stuff using some
    fabricated data. Go ahead and open up the `ConditionalProbabilityExercise.ipynb`
    here and follow along with me if you like.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在这里把条件概率付诸实践，并使用一些想法来找出年龄和购买商品之间是否存在关系，使用一些虚构的数据。如果你愿意，可以打开`ConditionalProbabilityExercise.ipynb`并跟着我一起做。
- en: 'What I''m going to do is write a little bit of Python code that creates some
    fake data:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我要做的是写一些Python代码，创建一些虚假数据：
- en: '[PRE23]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: What I'm going to do is take 100,000 virtual people and randomly assign them
    to an age bracket. They can be in their 20s, their 30s, their 40s, their 50s,
    their 60s, or their 70s. I'm also going to assign them a number of things that
    they bought during some period of time, and I'm going to weight the probability
    of purchasing something based on their age.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我要做的是取10万个虚拟人，随机分配到一个年龄段。他们可以是20多岁、30多岁、40多岁、50多岁、60多岁或70多岁。我还要给他们分配一些在某段时间内购买的东西的数量，并根据他们的年龄来加权购买某物的概率。
- en: 'What this code ends up doing is randomly assigning each person to an age group
    using the `random.choice()` function from NumPy. Then I''m going to assign a probability
    of purchasing something, and I have weighted it such that younger people are less
    likely to buy stuff than older people. I''m going to go through 100,000 people
    and add everything up as I go, and what I end up with are two Python dictionaries:
    one that gives me the total number of people in each age group, and another that
    gives me the total number of things bought within each age group. I''m also going
    to keep track of the total number of things bought overall. Let''s go ahead and
    run that code.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码最终的作用是使用NumPy的`random.choice()`函数随机将每个人分配到一个年龄组。然后我将分配购买东西的概率，并且我已经加权，使得年轻人购买东西的可能性小于老年人。我将遍历10万人，并在遍历过程中将所有东西加起来，最终得到两个Python字典：一个给出了每个年龄组的总人数，另一个给出了每个年龄组内购买的总数。我还将跟踪总体购买的总数。让我们运行这段代码。
- en: If you want to take a second to kind of work through that code in your head
    and figure out how it works, you've got the IPython Notebook. You can go back
    into that later too. Let's take a look what we ended up with.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想花点时间在脑海中思考并弄清楚代码是如何工作的，你可以使用IPython Notebook。你以后也可以回头看。让我们看看我们最终得到了什么。
- en: '![](img/fb97b2f4-ffbe-47d4-b107-2562141edf4b.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fb97b2f4-ffbe-47d4-b107-2562141edf4b.png)'
- en: Our `totals` dictionary is telling us how many people are in each age bracket,
    and it's pretty evenly distributed, just like we expected. The amount purchased
    by each age group is in fact increasing by age, so 20-year-olds only bought about
    3,000 things and 70-year-olds bought about 11,000 things, and overall the entire
    population bought about 45,000 things.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`totals`字典告诉我们每个年龄段有多少人，这与我们预期的一样是相当均匀的。每个年龄组购买的数量实际上是随年龄增长而增加的，所以20岁的人只购买了大约3000件东西，70岁的人购买了大约11000件东西，总体上整个人口购买了大约45000件东西。
- en: Let's use this data to play around with the ideas of conditional probability.
    Let's first figure out what's the probability of buying something given that you're
    in your 30s. The notation for that will be *P(E|F)* if we're calling purchase
    E, and F as the event that you're in your 30s.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用这些数据来玩玩条件概率的概念。首先让我们弄清楚在你30岁时购买东西的概率是多少。如果我们将购买表示为E，将你30岁的事件表示为F，那么表示为*P(E|F)*。
- en: Now we have this fancy equation that gave you a way of computing *P(E|F)* given
    *P(E,F)*, and *P(E)*, but we don't need that. You don't just blindly apply equations
    whenever you see something. You have to think about your data intuitively. What
    is it telling us? I want to figure out the probability of purchasing something
    given that you're in your 30s. Well I have all the data I need to compute that
    directly.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了这个复杂的方程，它给出了一种计算*P(E|F)*给定*P(E,F)*和*P(E)*的方法，但我们不需要那个。你不能只是盲目地应用方程。你必须直观地思考你的数据。它告诉我们什么？我想要计算在你30岁时购买东西的概率。我有计算它所需的所有数据。
- en: '[PRE24]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'I have how much stuff 30-year-olds purchased in the purchases[30] bucket, and
    I know how many 30-year-olds there are. So I can just divide those two numbers
    to get the ratio of 30-year-old purchases over the number of 30-year-olds. I can
    then output that using the print command:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道30岁的人购买的东西在购买[30]桶中有多少，我也知道有多少30岁的人。所以我可以将这两个数字相除，得到30岁购买的比例与30岁人数的比率。然后我可以使用print命令输出这个比例：
- en: '[PRE25]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'I end up with a probability of purchasing something given that you''re in your
    30s of being about 30%:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 最终我得到了在你30岁时购买东西的概率大约为30%。
- en: '[PRE26]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Note that if you''re using Python 2, the print command doesn''t have the surrounding
    brackets, so it would be:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果你使用的是Python 2，print命令没有周围的括号，所以应该是：
- en: '[PRE27]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If I want to find *P(F)*, that''s just the probability of being 30 overall,
    I can take the total number of 30-year-olds divided by the number of people in
    my dataset, which is 100,000:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我想找到*P(F)*，那就是总体30岁的概率，我可以将30岁的总人数除以我的数据集中的人数，即10万：
- en: '[PRE28]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Again, remove those brackets around the print statement if you''re using Python
    2\. That should give the following output:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是Python 2，再次删除print语句周围的括号。这应该得到以下输出：
- en: '[PRE29]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: I know the probability of being in your `30s` is about 16%.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道在你`30岁`的概率大约是16%。
- en: 'We''ll now find out *P(E)*, which just represents the overall probability of
    buying something irrespective of your age:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在要找出*P(E)*，这只是代表不考虑年龄的总体购买概率：
- en: '[PRE30]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: That works out to be, in this example, about 45%. I can just take the total
    number of things purchased by everybody regardless of age and divide it by the
    total number of people to get the overall probability of purchase.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，这大约是45%。我只需将所有人购买的东西的总数除以总人数，就可以得到总体购买的概率。
- en: Alright, so what do I have here? I have the probability of purchasing something
    given that you're in your 30s being about 30%, and then I have the probability
    of purchasing something overall at about 45%.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，那么我有什么？我有在你30岁时购买东西的概率大约为30%，然后我有总体购买东西的概率大约为45%。
- en: Now if E and F were independent, if age didn't matter, then I would expect the
    *P(E|F)* to be about the same as *P(E)*. I would expect the probability of buying
    something given that you're in your 30s to be about the same as the overall probability
    of buying something, but they're not, right? And because they're different, that
    tells me that they are in fact dependent, somehow. So that's a little way of using
    conditional probability to tease out these dependencies in the data.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果E和F是独立的，如果年龄不重要，那么我期望*P(E|F)*大约等于*P(E)*。我期望在你30岁时购买东西的概率大约等于总体购买东西的概率，但事实并非如此，对吧？因为它们不同，这告诉我它们实际上是有依赖关系的。所以这是一种使用条件概率来揭示数据中这些依赖关系的方法。
- en: 'Let''s do some more notation stuff here. If you see something like *P(E)P(F)*
    together, that means multiply these probabilities together. I can just take the
    overall probability of purchase multiplied by the overall probability of being
    in your `30s`:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在这里做一些更多的符号表示。如果你看到像*P(E)P(F)*这样的东西在一起，那意味着将这些概率相乘在一起。我可以简单地取购买的总体概率乘以在你`30岁`的总体概率：
- en: '[PRE31]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: That worked out to about 7.5%.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这大约是7.5%。
- en: Just from the way probabilities work, I know that if I want to get the probability
    of two things happening together, that would be the same thing as multiplying
    their individual probabilities. So it turns out that *P(E,F)* happening, is the
    same thing as *P(E)P(F)*.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅从概率的工作方式来看，我知道如果我想要得到两件事情同时发生的概率，那就等同于将它们各自的概率相乘。所以结果是*P(E,F)*发生，就等同于*P(E)P(F)*。
- en: '[PRE32]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now because of the random distribution of data, it doesn't work out to be exactly
    the same thing. We're talking about probabilities here, remember, but they're
    in the same ballpark, so that makes sense, about 5% versus 7%, close enough.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在由于数据的随机分布，它并不完全相同。记住，我们在谈论概率，但它们大致相同，这是有道理的，大约5%与7%，足够接近。
- en: Now that is different again from *P(E|F)*, so the probability of both being
    in your `30s` and buying something is different than the probability of buying
    something given that you're in your `30s`.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这又不同于*P(E|F)*，所以在你`30岁`和购买某物的概率与在你`30岁`的情况下购买某物的概率是不同的。
- en: Now let's just do a little sanity check here. We can check our equation that
    we saw in the Conditional Probability section earlier, that said that the probability
    of buying something given that you're in your `30s` is the same as the probability
    of being in your `30s` and buying something over the probability of buying something.
    That is, we check if *P(E|F)=P(E,F)/P(F)*.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们做一个小小的检查。我们可以检查我们在之前的条件概率部分看到的方程式，即购买某物的概率，假设你是`30岁`，等同于在你`30岁`和购买某物的概率除以购买某物的概率。也就是说，我们检查*P(E|F)=P(E,F)/P(F)*。
- en: '[PRE33]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This gives us:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这给了我们：
- en: '[PRE34]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Sure enough, it does work out. If I take the probability of buying something
    given that you're in your `30s` over the overall probability, we end up with about
    30%, which is pretty much what we came up with originally for *P(E|F)*. So the
    equation works, yay!
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 果然，它起作用了。如果我取购买某物的概率，假设你是`30岁`，除以总体概率，我们最终得到大约30%，这几乎就是我们最初得出的*P(E|F)*。所以这个方程式是有效的，耶！
- en: Alright, it's tough to wrap your head around some of this stuff. It's a little
    bit confusing, I know, but if you need to, go through this again, study it, and
    make sure you understand what's going on here. I've tried to put in enough examples
    here to illustrate different combinations of thinking about this stuff. Once you've
    got it internalized, I'm going to challenge you to actually do a little bit of
    work yourself here.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，有些东西确实很难理解。我知道有点令人困惑，但如果需要的话，再看一遍，研究一下，确保你理解这里发生了什么。我尽量在这里放了足够的例子来说明不同的思考方式。一旦你内化了它，我要挑战你实际上在这里做一些工作。
- en: Conditional probability assignment
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 条件概率作业
- en: What I want you to do is modify the following Python code which was used in
    the preceding section.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望你修改以下Python代码，这些代码在前面的部分中使用过。
- en: '[PRE35]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Modify it to actually not have a dependency between purchases and age. Make
    that an evenly distributed chance as well. See what that does to your results.
    Do you end up with a very different conditional probability of being in your `30s`
    and purchasing something versus the overall probability of purchasing something?
    What does that tell you about your data and the relationship between those two
    different attributes? Go ahead and try that, and make sure you can actually get
    some results from this data and understand what's going on, and I'll run through
    my own solution to that exercise in just a minute.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 修改它以实际上不让购买和年龄之间存在依赖关系。同样让它成为均匀分布的机会。看看这对你的结果有什么影响。你最终得到了非常不同的在你`30岁`购买东西的条件概率和总体购买东西的概率吗？这告诉了你关于你的数据和这两个不同属性之间关系的什么？继续尝试一下，确保你实际上可以从这些数据中得到一些结果并理解发生了什么，我马上就会运行我的解决方案来解决这个问题。
- en: So that's conditional probability, both in theory and in practice. You can see
    there's a lot of little nuances to it and a lot of confusing notation. Go back
    and go through this section again if you need to wrap your head around it. I gave
    you a homework assignment, so go off and do that now, see if you can actually
    modify my code in that IPython Notebook to produce a constant probability of purchase
    for those different age groups. Come back and we'll take a look at how I solved
    that problem and what my results were.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这就是条件概率，无论是在理论上还是在实践中。你可以看到它有很多微妙之处，还有很多令人困惑的符号表示。如果需要，回过头再看一遍这一节。我给了你一个作业，所以现在去做吧，看看你是否真的可以修改我的代码在那个IPython笔记本中为不同年龄组产生一个恒定的购买概率。然后回来，我们将看看我是如何解决这个问题以及我的结果是什么。
- en: My assignment solution
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我的作业解决方案
- en: Did you do your homework? I hope so. Let's take a look at my solution to the
    problem of seeing how conditional probability tells us about whether there's a
    relationship between age and purchase probability in a fake dataset.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 你做完作业了吗？希望如此。让我们来看看我对在一个虚假数据集中如何使用条件概率来告诉我们年龄和购买概率之间是否存在关系的问题的解决方案。
- en: 'To remind you, what we were trying to do was remove the dependency between
    age and probability of purchasing and see if we could actually reflect that in
    our conditional probability values. Here''s what I''ve got:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 提醒一下，我们试图做的是消除年龄和购买概率之间的依赖关系，并看看我们是否能够在我们的条件概率值中实际反映出来。这是我得到的：
- en: '[PRE36]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: What I've done here is I've taken the original snippet of code for creating
    our dictionary of age groups and how much was purchased by each age group for
    a set of 100,000 random people. Instead of making purchase probability dependent
    on age, I've made it a constant probability of 40%. Now we just have people randomly
    being assigned to an age group, and they all have the same probability of buying
    something. Let's go ahead and run that.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里所做的是，我拿了原始的代码片段，用于创建我们的年龄组字典以及每个年龄组购买了多少，针对10万个随机人。我没有让购买概率依赖于年龄，而是让它成为40%的常数概率。现在我们只是随机地将人分配到一个年龄组，他们都有相同的购买某物的概率。让我们继续运行。
- en: Now this time, if I compute the *P(E|F)*, that is, the probability of buying
    something given that you're in your `30s`, I come up with about 40%.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这一次，如果我计算*P(E|F)*，也就是，给定你处于`30岁`的情况下购买某物的概率，我得到的结果大约是40%。
- en: '[PRE37]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: If I compare that to the overall probability of purchasing, that too is about
    40%.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我将其与总体购买概率进行比较，那也是大约40%。
- en: '[PRE38]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: I can see here that the probability of purchasing something given that you're
    in your `30s` is about the same as the probability of purchasing something irrespective
    of your age (that is, *P(E|F)* is pretty close to *P(E)*). That suggests that
    there's no real relationship between those two things, and in fact, I know there
    isn't from this data.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以看到，如果你处于`30岁`，购买某物的概率与不考虑你的年龄而言购买某物的概率大致相同（也就是，*P(E|F)*与*P(E)*非常接近）。这表明这两件事之间没有真正的关系，实际上，我知道从这些数据中并没有关系。
- en: Now in practice, you could just be seeing random chance, so you'd want to look
    at more than one age group. You'd want to look at more than one data point to
    see if there really is a relationship or not, but this is an indication that there's
    no relationship between age and probability of purchase in this sample data that
    we modified.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在实践中，你可能只是看到了随机的机会，所以你会想要观察不止一个年龄组。你会想要观察不止一个数据点，以查看是否真的存在关系，但这表明在我们修改的这个样本数据中，年龄和购买概率之间没有关系。
- en: So, that's conditional probability in action. Hopefully your solution was fairly
    close and had similar results. If not, go back and study my solution. It's right
    there in the data files for this book, ConditionalProbabilitySolution.ipynb, if
    you need to open it up and study it and play around with it. Obviously, the random
    nature of the data will make your results a little bit different and will depend
    on what choice you made for the overall purchase probability, but that's the idea.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这就是条件概率的作用。希望你的解决方案相当接近并且有类似的结果。如果不是，回去研究我的解决方案。这就在这本书的数据文件中，ConditionalProbabilitySolution.ipynb，如果你需要打开它并研究它并进行试验。显然，数据的随机性会使你的结果有些不同，并且会取决于你对总体购买概率的选择，但这就是这个想法。
- en: And with that behind us, let's move on to Bayes' theorem.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个背景，让我们继续讲贝叶斯定理。
- en: Bayes' theorem
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 贝叶斯定理
- en: Now that you understand conditional probability, you can understand how to apply
    Bayes' theorem, which is based on conditional probability. It's a very important
    concept, especially if you're going into the medical field, but it is broadly
    applicable too, and you'll see why in a minute.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你了解了条件概率，你就能理解如何应用贝叶斯定理，这是基于条件概率的。这是一个非常重要的概念，特别是如果你要进入医学领域，但它也是广泛适用的，你马上就会明白为什么。
- en: You'll hear about this a lot, but not many people really understand what it
    means or its significance. It can tell you very quantitatively sometimes when
    people are misleading you with statistics, so let's see how that works.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 你会经常听到这个，但并不是很多人真正理解它的意义。有时它可以非常定量地告诉你，当人们用统计数据误导你时，所以让我们看看它是如何起作用的。
- en: 'First, let''s talk about Bayes'' theorem at a high level. Bayes'' theorem is
    simply this: the probability of A given B is equal to the probability of A times
    the probability of B given A over the probability of B. So you can substitute
    A and B with whatever you want.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们从高层次来谈谈贝叶斯定理。贝叶斯定理就是：给定B的情况下A的概率等于A的概率乘以给定A的情况下B的概率除以B的概率。所以你可以用任何你想要的东西来替换A和B。
- en: '![](img/46d5e844-cd07-49ac-98ce-04f0cb662906.png)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![](img/46d5e844-cd07-49ac-98ce-04f0cb662906.png)'
- en: The key insight is that the probability of something that depends on B depends
    very much on the base probability of B and A. People ignore this all the time.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 关键的见解是，依赖于B的某事的概率很大程度上取决于B和A的基本概率。人们经常忽视这一点。
- en: One common example is drug testing. We might say, what's the probability of
    being an actual user of a drug given that you tested positive for it. The reason
    Bayes' theorem is important is that it calls out that this very much depends on
    both the probability of A and the probability of B. The probability of being a
    drug user given that you tested positive depends very much on the base overall
    probability of being a drug user and the overall probability of testing positive.
    The probability of a drug test being accurate depends a lot on the overall probability
    of being a drug user in the population, not just the accuracy of the test.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的例子是药物测试。我们可能会说，如果你对某种药物测试呈阳性，那么你是实际使用该药物的概率是多少。贝叶斯定理之所以重要，是因为它指出这在很大程度上取决于A和B的概率。在整个人群中，对于药物测试呈阳性的概率，实际上很大程度上取决于整体使用该药物的概率和整体测试呈阳性的概率。药物测试的准确性很大程度上取决于整体人群中使用该药物的概率，而不仅仅是测试的准确性。
- en: It also means that the probability of B given A is not the same thing as the
    probability of A given B. That is, the probability of being a drug user given
    that you tested positive can be very different from the probability of testing
    positive given that you're a drug user. You can see where this is going. That
    is a very real problem where diagnostic tests in medicine or drug tests yield
    a lot of false positives. You can still say that the probability of a test detecting
    a user can be very high, but it doesn't necessarily mean that the probability
    of being a user given that you tested positive is high. Those are two different
    things, and Bayes' theorem allows you to quantify that difference.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这也意味着在给定A的情况下B的概率并不等同于在给定B的情况下A的概率。也就是说，在测试呈阳性的情况下成为药物用户的概率可能与在成为药物用户的情况下测试呈阳性的概率非常不同。您可以看到这是一个非常现实的问题，在医学诊断测试或药物测试中会产生很多假阳性。您仍然可以说测试检测用户的概率可能非常高，但这并不一定意味着在测试呈阳性的情况下成为用户的概率很高。这是两回事，而贝叶斯定理允许您量化这种差异。
- en: Let's nail that example home a little bit more.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们举一个例子来更好地理解。
- en: Again, a drug test can be a common example of applying Bayes' theorem to prove
    a point. Even a highly accurate drug test can produce more false positives than
    true positives. So in our example here, we're going to come up with a drug test
    that can accurately identify users of a drug 99% of the time and accurately has
    a negative result for 99% of non-users, but only 0.3% of the overall population
    actually uses the drug in question. So we have a very small probability of actually
    being a user of a drug. What seems like a very high accuracy of 99% isn't actually
    high enough, right?
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，药物测试可以是应用贝叶斯定理证明观点的常见例子。即使高度准确的药物测试也可能产生比真阳性更多的假阳性。因此，在我们的例子中，我们将提出一种药物测试，该测试可以在99%的时间内准确识别药物用户，并且对非用户有99%的准确的阴性结果，但是实际上只有0.3%的总体人口实际使用该药物。因此，我们实际上成为药物用户的概率非常小。看起来非常高的99%的准确性实际上还不够高，对吧？
- en: 'We can work out the math as follows:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下方式计算出概率：
- en: Event A = is a user of the drug
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件A = 使用该药物的用户
- en: Event B = tested positively for the drug
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件B = 测试呈阳性
- en: So let event A mean that you're a user of some drug, and event B the event that
    you tested positively for the drug using this drug test.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 事件A表示您使用某种药物，事件B表示您使用此药物测试呈阳性。
- en: We need to work out the probability of testing positively overall. We can work
    that out by taking the sum of probability of testing positive if you are a user
    and the probability of testing positive if you're not a user. So, P(B) works out
    to 1.3% (0.99*0.003+0.01*0.997) in this example. So we have a probability of B,
    the probability of testing positively for the drug overall without knowing anything
    else about you.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要计算总体测试呈阳性的概率。我们可以通过计算用户测试呈阳性的概率和非用户测试呈阳性的概率的总和来计算出来。因此，在这个例子中，P(B)计算为1.3%（0.99*0.003+0.01*0.997）。因此，我们有了B的概率，即在不了解您的其他情况下，总体上测试呈阳性的概率。
- en: Let's do the math and calculate the probability of being a user of the drug
    given that you tested positively.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来计算一下，在测试呈阳性的情况下实际成为药物用户的概率。
- en: '![](img/dc189173-51c2-4167-9314-8c8d5e278215.png)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dc189173-51c2-4167-9314-8c8d5e278215.png)'
- en: So the probability of a positive test result given that you're actually a drug
    user works out as the probability of being a user of the drug overall *(P(A))*,
    which is 3% (you know that 3% of the population is a drug user) multiplied by
    *P(B|A)* that is the probability of testing positively given that you're a user
    divided by the probability of testing positively overall which is 1.3%. Again,
    this test has what sounds like a very high accuracy of 99%. We have 0.3% of the
    population which uses a drug multiplied by the accuracy of 99% divided by the
    probability of testing positively overall, which is 1.3%. So the probability of
    being an actual user of this drug given that you tested positive for it is only
    22.8%. So even though this drug test is accurate 99% of the time, it's still providing
    a false result in most of the cases where you're testing positive.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在实际成为药物用户的情况下测试呈阳性的概率计算为总体上成为药物用户的概率*(P(A))*，即3%（您知道3%的人口是药物用户），乘以*P(B|A)*，即在成为用户的情况下测试呈阳性的概率，除以总体上测试呈阳性的概率，即1.3%。再次，这个测试听起来非常准确，准确率为99%。我们有0.3%的人口使用药物，乘以99%的准确性，除以总体上测试呈阳性的概率，即1.3%。因此，您在测试呈阳性的情况下实际成为该药物用户的概率只有22.8%。因此，即使这种药物测试在99%的时间内准确，它仍然在大多数情况下提供了错误的结果。
- en: Even though *P(B|A)* is high (99%), it doesn't mean *P(A|B)* is high.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 即使*P(B|A)*很高（99%），也不意味着*P(A|B)*很高。
- en: People overlook this all the time, so if there's one lesson to be learned from
    Bayes' theorem, it is to always take these sorts of things with a grain of salt.
    Apply Bayes' theorem to these actual problems and you'll often find that what
    sounds like a high accuracy rate can actually be yielding very misleading results
    if you're dealing with a low overall incidence of a given problem. We see the
    same thing in cancer screening and other sorts of medical screening as well. That's
    a very real problem; there's a lot of people getting very, very real and very
    unnecessary surgery as a result of not understanding Bayes' theorem. If you're
    going into the medical profession with big data, please, please, please remember
    this theorem.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 人们经常忽视这一点，因此如果有一件事可以从贝叶斯定理中学到的，那就是始终要持怀疑态度。将贝叶斯定理应用于这些实际问题，您经常会发现，听起来高准确率实际上可能会产生非常误导性的结果，如果您处理的是某个问题的总体发生率很低的情况。我们在癌症筛查和其他类型的医学筛查中也看到了同样的情况。这是一个非常现实的问题；有很多人因为不理解贝叶斯定理而接受了非常真实且不必要的手术。如果您要从事医学行业的大数据工作，请，请，请记住这个定理。
- en: So that's Bayes' theorem. Always remember that the probability of something
    given something else is not the same thing as the other way around, and it actually
    depends a lot on the base probabilities of both of those two things that you're
    measuring. It's a very important thing to keep in mind, and always look at your
    results with that in mind. Bayes' theorem gives you the tools to quantify that
    effect. I hope it proves useful.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是贝叶斯定理。永远记住，给定某事物的概率并不等同于反过来，它实际上很大程度上取决于你正在测量的这两件事物的基本概率。这是一件非常重要的事情要牢记，并且始终要以此为依据来查看你的结果。贝叶斯定理为你提供了量化这种影响的工具。我希望它能够证明有用。
- en: Summary
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we talked about plotting and graphing your data and how to
    make your graphs look pretty using the `matplotlib` library in Python. We also
    walked through the concepts of covariance and correlation. We looked at some examples
    and figured out covariance and correlation using Python. We analyzed the concept
    of conditional probability and saw some examples to understand it better. Finally,
    we saw Bayes' theorem and its importance, especially in the medical field.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了如何绘制和图形化你的数据，以及如何使用Python中的`matplotlib`库使你的图形看起来漂亮。我们还介绍了协方差和相关性的概念。我们看了一些例子，并使用Python计算了协方差和相关性。我们分析了条件概率的概念，并看了一些例子以更好地理解它。最后，我们看到了贝叶斯定理及其重要性，特别是在医学领域。
- en: In the next chapter, we'll talk about predictive models.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论预测模型。
