- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Working with Genomes
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理基因组
- en: Many tasks in computational biology are dependent on the existence of reference
    genomes. If you are performing sequence alignment, finding genes, or studying
    the genetics of populations, you will be directly or indirectly using a reference
    genome. In this chapter, we will develop some recipes for working with reference
    genomes and dealing with references of varying quality, which can range from high
    quality (by high quality, we only refer to the state of the genome’s assembly,
    which is the focus of this chapter), as with the human genome, to problematic
    with non-model species. We will also learn how to deal with genome annotations
    (working with databases that will point us to interesting features in the genome)
    and extract sequence data using the annotation information. We will also try to
    find some gene orthologs across species. Finally, we will access a **Gene Ontology**
    (**GO**) database.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 计算生物学中的许多任务依赖于参考基因组的存在。如果你正在进行序列比对、寻找基因或研究种群遗传学，你将直接或间接使用参考基因组。在本章中，我们将开发一些处理参考基因组的技术，解决不同质量的参考基因组问题，这些基因组的质量可能从高质量（在这里，高质量仅指基因组组装的状态，这是本章的重点），如人类基因组，到存在问题的非模式物种基因组。我们还将学习如何处理基因组注释（处理能够指引我们发现基因组中有趣特征的数据库），并使用注释信息提取序列数据。我们还将尝试跨物种寻找基因同源物。最后，我们将访问**基因本体论**（**GO**）数据库。
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Working with high-quality reference genomes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理高质量参考基因组
- en: Dealing with low-quality reference genomes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理低质量参考基因组
- en: Traversing genome annotations
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遍历基因组注释
- en: Extracting genes from a reference using annotations
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用注释从参考基因组中提取基因
- en: Finding orthologues with the Ensembl REST API
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Ensembl REST API查找同源基因
- en: Retrieving gene ontology information from Ensembl
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从Ensembl获取基因本体信息
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: If you are running this chapter’s content via Docker, you can use the `tiagoantao/bioinformatics_genomes`
    image. If you are using Anaconda, the required software for this chapter will
    be introduced in each relevant section.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你通过Docker运行本章内容，你可以使用`tiagoantao/bioinformatics_genomes`镜像。如果你使用Anaconda，本章所需的软件将在每个相关部分介绍。
- en: Working with high-quality reference genomes
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理高质量参考基因组
- en: In this recipe, you will learn about a few general techniques to manipulate
    reference genomes. As an illustrative example, we will study the GC content –
    the fraction of the genome that is based on guanine-cytosine in *Plasmodium falciparum*,
    the most important parasite species that causes malaria. Reference genomes are
    normally made available as FASTA files.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习一些操作参考基因组的通用技术。作为一个示例，我们将研究*恶性疟原虫*的GC含量——即基因组中以鸟嘌呤-胞嘧啶为基础的部分，这是导致疟疾的最重要寄生虫物种。参考基因组通常以FASTA文件的形式提供。
- en: Getting ready
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Organism genomes come in widely different sizes, ranging from viruses such as
    HIV, which is 9.7 kbp, to bacteria such as *E. coli*, to protozoans such as *Plasmodium
    falciparum*, which has a 22 Mbp spread across 14 chromosomes, mitochondrion, and
    apicoplast, to the fruit fly with three autosomes, a mitochondrion, and X/Y sex
    chromosomes, to humans with their three Gbp pairs spread across 22 autosomes,
    X/Y chromosomes, and mitochondria, all the way up to *Paris japonica*, a plant
    with 150 Gbp of the genome. Along the way, you have different ploidy and sex chromosome
    organizations.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 生物体基因组的大小差异很大，从像HIV这样的病毒（其基因组为9.7 kbp）到像*大肠杆菌*这样的细菌，再到像*恶性疟原虫*这样的原生动物（其基因组跨越14条染色体、线粒体和顶体，大小为22
    Mbp），再到果蝇，具有三对常染色体、线粒体和X/Y性染色体，再到人类，其基因组由22对常染色体、X/Y染色体和线粒体组成，总大小为3 Gbp，一直到*日本巴黎*，一种植物，基因组大小为150
    Gbp。在这个过程中，你会遇到不同的倍性和性染色体组织。
- en: Tip
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: As you can see, different organisms have very different genome sizes. This difference
    can be of several orders of magnitude. This can have significant implications
    for your programming style. Working with a large genome will require you to be
    more conservative with memory. Unfortunately, larger genomes would benefit from
    more speed-efficient programming techniques (as you have much more data to analyze);
    these are conflicting requirements. The general rule is that you have to be much
    more careful with efficiency (both speed and memory) with larger genomes.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，不同的生物体有非常不同的基因组大小。这个差异可以达到几个数量级。这对你的编程风格有重大影响。处理一个大型基因组将要求你更加节省内存。不幸的是，更大的基因组将从更高效的编程技术中受益（因为你需要分析的数据更多）；这些是相互矛盾的要求。一般来说，对于较大的基因组，你必须更加小心地处理效率（无论是速度还是内存）。
- en: To make this recipe less of a burden, we will use a small eukaryotic genome
    from *Plasmodium falciparum*. This genome still has many typical features of larger
    genomes (for example, multiple chromosomes). Therefore, it’s a good compromise
    between complexity and size. Note that with a genome that’s the size of *Plasmodium
    falciparum*, it will be possible to perform many operations by loading the whole
    genome in memory. However, we opted for a programming style that can be used with
    bigger genomes (for example, mammals) so that you can use this recipe in a more
    general way, but feel free to use more memory-intensive approaches with small
    genomes like this.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让这个方法不那么繁琐，我们将使用*恶性疟原虫*的一个小型真核基因组。这个基因组仍然具有大基因组的一些典型特征（例如，多个染色体）。因此，它在复杂性和大小之间是一个很好的折衷。请注意，对于像*恶性疟原虫*这样大小的基因组，可以通过将整个基因组加载到内存中来执行许多操作。然而，我们选择了一种可以应用于更大基因组（例如，哺乳动物）的编程风格，这样你可以以更通用的方式使用这个方法，但如果是像这种小型基因组，也可以使用更依赖内存的方式。
- en: 'We will use Biopython, which you installed in [*Chapter 1*](B17942_01.xhtml#_idTextAnchor020),
    *Python and the Surrounding Software Ecology*. As usual, this recipe is available
    in this book’s Jupyter notebook as `Chapter05/Reference_Genome.py`, in the code
    bundle for this book. We will need to download the reference genome – you can
    find the up-to-date location in the aforementioned notebook. To generate the chart
    at the end of this recipe, we will need `reportlab`:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Biopython，这是你在[*第1章*](B17942_01.xhtml#_idTextAnchor020)，*Python与相关软件生态*中安装的。如往常一样，这个方法可以在本书的Jupyter笔记本中找到，路径为`Chapter05/Reference_Genome.py`，在本书的代码包中。我们需要下载参考基因组——你可以在上述笔记本中找到最新的下载地址。为了生成本方法最后的图表，我们还需要`reportlab`：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now, we’re ready to begin.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备开始。
- en: How to do it...
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤进行：
- en: 'We will start by inspecting the description of all of the sequences in the
    reference genome’s FASTA file:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先检查参考基因组FASTA文件中所有序列的描述：
- en: '[PRE1]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This code should look familiar from the previous chapter, [*Chapter 3*](B17942_03.xhtml#_idTextAnchor068),
    *Next-Generation Sequencing*. Let’s take a look at part of the output:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码应该很熟悉，来自上一章，[*第3章*](B17942_03.xhtml#_idTextAnchor068)，*下一代测序*。让我们来看一下部分输出：
- en: '![](img/B17942_05_001.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17942_05_001.jpg)'
- en: Figure 5.1 – The output showing the FASTA descriptions for the reference genome
    of Plasmodium falciparum
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 – 显示*恶性疟原虫*参考基因组的FASTA描述的输出
- en: Different genome references will have different description lines, but they
    will generally contain important information. In this example, you can see that
    we have chromosomes, mitochondria, and apicoplast. We can also view the chromosome
    sizes, but we will take the value from the sequence length instead.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的基因组参考将有不同的描述行，但它们通常包含重要信息。在这个示例中，你可以看到我们有染色体、线粒体和顶体。我们还可以查看染色体的大小，但我们将使用序列长度中的值。
- en: 'Let’s parse the description line to extract the chromosome number. We will
    retrieve the chromosome size from the sequence and compute the `GC` content across
    chromosomes on a window basis:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们解析描述行，以提取染色体编号。我们将从序列中获取染色体大小，并基于窗口计算每个染色体的`GC`含量：
- en: '[PRE2]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, we have performed a windowed analysis of all chromosomes, similar to what
    we did in [*Chapter 3*](B17942_03.xhtml#_idTextAnchor068), *Next-Generation Sequencing*.
    We started by defining a window size of 50 kbp. This is appropriate for *Plasmodium
    falciparum* (feel free to vary its size), but you will want to consider other
    values for genomes with chromosomes that are orders of magnitude different from
    this.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们对所有染色体进行了窗口分析，类似于我们在[*第3章*](B17942_03.xhtml#_idTextAnchor068)中所做的，*下一代测序*。我们从定义一个50
    kbp的窗口大小开始。这对于*Plasmodium falciparum*来说是合适的（你可以自由调整其大小），但对于那些染色体大小差异数量级较大的基因组，你会想考虑其他的数值。
- en: Note that we are re-reading the file. With such a small genome, it would have
    been feasible (in *Step 1*) to do an in-memory load of the whole genome. By all
    means, feel free to try this programming style for small genomes – it’s faster!
    However, our code is designed to be reused with larger genomes.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们正在重新读取文件。由于基因组如此之小，实际上在*步骤1*中可以将整个基因组加载到内存中。对于小型基因组来说，尝试这种编程风格是可行的——它更快！然而，我们的代码是为了可以在更大的基因组上复用而设计的。
- en: Note that in the `for` loop, we ignore the mitochondrion and apicoplast by parsing
    the `SO` entry to the description. The `chrom_sizes` dictionary will maintain
    the size of chromosomes.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，在`for`循环中，我们通过解析`SO`条目来忽略线粒体和顶体。`chrom_sizes`字典将维护染色体的大小。
- en: The `chrom_GC` dictionary is our most interesting data structure and will contain
    a list of a fraction of the `GC` content for each 50 kbp window. So, for chromosome
    1, which has a size of 640,851 bp, there will be 14 entries because this chromosome’s
    size is 14 blocks of 50 kbp.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`chrom_GC`字典是我们最有趣的数据结构，将包含每个50 kbp窗口中`GC`含量的一个分数的列表。所以，染色体1的大小为640,851 bp，它会有14个条目，因为该染色体的大小为14个50
    kbp的块。'
- en: 'Be aware of two unusual features of the *Plasmodium falciparum* genome: the
    genome is very AT-rich – that is, GC-poor. Therefore, the numbers that you will
    get will be very low. Also, chromosomes are ordered based on size (as is common)
    but starting with the smallest size. The usual convention is to start with the
    largest size (such as with genomes in humans).'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 注意*疟原虫*（*Plasmodium falciparum*）基因组的两个不寻常特征：该基因组非常富含AT，即GC贫乏。因此，你得到的数字会非常低。此外，染色体是按大小排序的（这很常见），但从最小的大小开始。通常的约定是从最大的大小开始（比如在人类基因组中）。
- en: 'Now, let’s create a genome plot of the `GC` distribution. We will use shades
    of blue for the `GC` content. However, for high outliers, we will use shades of
    red. For low outliers, we will use shades of yellow:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个`GC`分布的基因组图。我们将使用蓝色的不同色调表示`GC`含量。然而，对于高离群值，我们将使用红色的不同色调。对于低离群值，我们将使用黄色的不同色调：
- en: '[PRE3]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The first line converts the return of the `keys` method into a list. This was
    redundant in Python 2, but not in Python 3, where the `keys` method has a specific
    `dict_keys` return type.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行将`keys`方法的返回值转换为一个列表。在 Python 2 中这是多余的，但在 Python 3 中并非如此，因为`keys`方法的返回类型是特定的`dict_keys`类型。
- en: We draw the chromosomes in order (hence the sort). We need the size of the biggest
    chromosome (14, in *Plasmodium falciparum*) to make sure that the size of chromosomes
    is printed with the correct scale (the `biggest_chrom` variable).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们按顺序绘制染色体（因此需要排序）。我们需要最大的染色体的大小（在*Plasmodium falciparum*中为14）来确保染色体的大小以正确的比例打印（即`biggest_chrom`变量）。
- en: Then, we create an A4-sized representation of an organism with a PNG output.
    Note that we draw very small telomeres of 10 bp. This will produce a rectangular-like
    chromosome. You can make the telomeres bigger, giving them a roundish representation,
    or you may have the arguably better idea of using the correct telomere size for
    your species.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建一个A4大小的有机体表示，并输出为PNG文件。注意，我们绘制了非常小的端粒（10 bp）。这将产生一个类似矩形的染色体。你可以将端粒做得更大，给它们一个圆形的表示，或者你也可以选择使用适合你物种的端粒尺寸。
- en: We declare that anything with a `GC` content below 17.5% or above 22.0% will
    be considered an outlier. Remember that for most other species, this will be much
    higher.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明，任何`GC`含量低于17.5%或高于22.0%的都会被视为离群值。记住，对于大多数其他物种来说，这个值会更高。
- en: 'Then, we print these chromosomes: they are bounded by telomeres and composed
    of 50 kbp chromosome segments (the last segment is sized with the remainder).
    Each segment will be colored in blue, with a red-green component based on the
    linear normalization between two outlier values. Each chromosome segment will
    either be 50 kbp or potentially smaller if it’s the last one of the chromosome.
    The output is shown in the following diagram:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们打印这些染色体：它们被端粒限制，且由50 kbp的染色体片段组成（最后一个片段的大小为剩余部分）。每个片段将用蓝色表示，并基于两种极值之间的线性归一化，呈现红绿成分。每个染色体片段将为50
    kbp，或者如果它是染色体的最后一个片段，可能会更小。输出结果如下图所示：
- en: '![](img/B17942_05_002.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17942_05_002.jpg)'
- en: Figure 5.2 – The 14 chromosomes of Plasmodium falciparum, color-coded with the
    GC content (red is more than 22%, yellow less than 17%, and the blue shades represent
    a linear gradient between both numbers)
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2 – 疟原虫的14条染色体，用GC含量进行颜色编码（红色表示超过22%，黄色表示少于17%，蓝色阴影代表这两个数值之间的线性渐变）
- en: Tip
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Biopython code evolved before Python was such a fashionable language. In the
    past, the availability of libraries was quite limited. The usage of `reportlab`
    can be seen mostly as a legacy issue. I suggest that you learn just enough from
    it to use it with Biopython. If you are planning on learning a modern plotting
    library in Python, then the standard bearer is Matplotlib, as we learned in [*Chapter
    2*](B17942_02.xhtml#_idTextAnchor040)*, Getting to Know NumPy, pandas, Arrow,
    and Matplotlib*. Alternatives include Bokeh, HoloViews, or Python’s version of
    ggplot (or even more sophisticated visualization alternatives, such as Mayavi,
    **Visualization Toolkit** (**VTK**), and even the Blender API).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Biopython代码的演变发生在Python成为流行语言之前。过去，库的可用性非常有限。`reportlab`的使用大多可以视为遗留问题。我建议你只需学到足够的知识，能与Biopython配合使用。如果你计划学习现代的Python绘图库，那么标准的代表是Matplotlib，正如我们在[*第2章*](B17942_02.xhtml#_idTextAnchor040)*中所学的，《了解NumPy、pandas、Arrow和Matplotlib》。替代方案包括Bokeh、HoloViews，或Python版本的ggplot（甚至更复杂的可视化替代方案，如Mayavi、**可视化工具包**（**VTK**）甚至Blender
    API）。
- en: 'Finally, you can print the image inline in the notebook:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，你可以在笔记本中内嵌打印图像：
- en: '[PRE4]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: And that completes this recipe!
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样完成了这个方案！
- en: There’s more...
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多……
- en: '*Plasmodium falciparum* is a reasonable example of a eukaryote with a small
    genome that allows you to perform a small data exercise with enough features,
    while still being useful for most eukaryotes. Of course, there are no sex chromosomes
    (such as X/Y in humans), but these should be easy to process because reference
    genomes do not deal with ploidy issues.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*疟原虫*是一个合理的例子，它是一个基因组较小的真核生物，能够让你进行一个具有足够特征的小型数据练习，同时对于大多数真核生物仍然具有参考价值。当然，它没有性染色体（如人类的X/Y染色体），但这些应该容易处理，因为参考基因组并不涉及倍性问题。'
- en: '*Plasmodium falciparum* does have a mitochondrion, but we will not deal with
    it here due to space constraints. Biopython does have the functionality to print
    circular genomes, which you can also use with bacteria. With regards to bacteria
    and viruses, these genomes are much easier to process because their size is very
    small.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*疟原虫*确实有线粒体，但由于篇幅限制，我们在此不讨论它。Biopython确实具有打印圆形基因组的功能，你也可以将其用于细菌。关于细菌和病毒，这些基因组更容易处理，因为它们的大小非常小。'
- en: See also
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: 'Here are some sources you can learn more from:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些你可以深入了解的资源：
- en: You can find many reference genomes of model organisms in Ensembl at [http://www.ensembl.org/info/data/ftp/index.xhtml](http://www.ensembl.org/info/data/ftp/index.xhtml).
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在Ensembl网站上找到许多模式生物的参考基因组，网址是[http://www.ensembl.org/info/data/ftp/index.xhtml](http://www.ensembl.org/info/data/ftp/index.xhtml)。
- en: As usual, **National Center for Biotechnology Information** (**NCBI**) also
    provides a large list of genomes at [http://www.ncbi.nlm.nih.gov/genome/browse/](http://www.ncbi.nlm.nih.gov/genome/browse/).
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 像往常一样，**国家生物技术信息中心**（**NCBI**）也提供了一个庞大的基因组列表，网址是[http://www.ncbi.nlm.nih.gov/genome/browse/](http://www.ncbi.nlm.nih.gov/genome/browse/)。
- en: There are plenty of websites dedicated to a single organism (or a set of related
    organisms). Apart from PlasmoDB ([http://plasmodb.org/plasmo/](http://plasmodb.org/plasmo/)),
    which you downloaded the *Plasmodium falciparum* genome from, you will find VectorBase
    ([https://www.vectorbase.org/](https://www.vectorbase.org/)) in the next recipe
    for disease vectors. FlyBase ([http://flybase.org/](http://flybase.org/)) for
    *Drosophila melanogaster* is also worth mentioning, but do not forget to search
    for your organism of interest.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有许多网站专注于单一生物体（或一组相关生物体）。除了你从*Plasmodium falciparum*基因组下载的PlasmoDB（[http://plasmodb.org/plasmo/](http://plasmodb.org/plasmo/)），你还会在下一个关于病媒生物的食谱中找到VectorBase（[https://www.vectorbase.org/](https://www.vectorbase.org/)）。用于*果蝇（Drosophila
    melanogaster）*的FlyBase（[http://flybase.org/](http://flybase.org/)）也值得一提，但不要忘记搜索你感兴趣的生物体。
- en: Dealing with low-quality genome references
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理低质量的基因组参考
- en: Unfortunately, not all reference genomes will have the quality of *Plasmodium
    falciparum*. Apart from some model species (for example, humans, or the common
    fruit fly *Drosophila melanogaster*) and a few others, most reference genomes
    could use some improvement. In this recipe, we will learn how to deal with reference
    genomes of lower quality.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，并非所有参考基因组都具备*Plasmodium falciparum*那样的质量。除了某些模型物种（例如人类，或常见的果蝇*Drosophila
    melanogaster*）和少数其他物种外，大多数参考基因组仍有待改进。在本食谱中，我们将学习如何处理低质量的参考基因组。
- en: Getting ready
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In keeping with the malaria theme, we will use the reference genomes of two
    mosquitoes that are vectors of malaria: *Anopheles gambiae* (which is the most
    important vector of malaria and can be found in Sub-Saharan Africa) and *Anopheles
    atroparvus*, a malaria vector in Europe (while the disease has been eradicated
    in Europe, this vector is still around). The *Anopheles gambiae* genome is of
    reasonable quality. Most chromosomes have been mapped, although the Y chromosome
    still needs some work. There is a fairly large unknown chromosome, probably composed
    of bits of X and Y chromosomes, as well as midgut microbiota. This genome has
    a reasonable amount of positions that are not called (that is, you will find *N*s
    instead of ACTGs). The *Anopheles atroparvus* genome is still in the scaffold
    format. Unfortunately, this is what you will find for many non-model species.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 继续围绕疟疾主题，我们将使用两种疟疾传播蚊子的参考基因组：*Anopheles gambiae*（这是最重要的疟疾传播者，存在于撒哈拉以南的非洲）和*Anopheles
    atroparvus*，一种欧洲的疟疾传播者（尽管欧洲已经消除了该病，但该传播者依然存在）。*Anopheles gambiae*基因组质量较好，大多数染色体已经被映射，尽管Y染色体仍需要一些工作。还有一个相当大的未知染色体，可能由X和Y染色体的部分片段以及中肠微生物群组成。该基因组中有一些位置未被注释（即，你会看到*N*而不是ACTG）。*Anopheles
    atroparvus*基因组仍处于框架格式。遗憾的是，许多非模型物种的基因组都是这种情况。
- en: Note that we will up the ante a bit. The *Anopheles* genome is one order of
    magnitude bigger than the *Plasmodium falciparum* genome (but still one order
    of magnitude smaller than most mammals).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们将稍微提高难度。*Anopheles*基因组比*Plasmodium falciparum*基因组大一个数量级（但仍然比大多数哺乳动物小一个数量级）。
- en: We will use Biopython, which you installed in [*Chapter 1*](B17942_01.xhtml#_idTextAnchor020),
    *Python and the Surrounding Software Ecology*. As usual, this recipe is available
    in this book’s Jupyter notebook at `Chapter05/Low_Quality.py`, in the code bundle
    for this book. At the start of the notebook, you can find the most up-to-date
    location of both genomes, along with the code to download them.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用你在[*第1章*](B17942_01.xhtml#_idTextAnchor020)中安装的Biopython，*Python和周边软件生态*。像往常一样，本食谱可在本书的Jupyter笔记本中找到，路径为`Chapter05/Low_Quality.py`，在本书的代码包中。在笔记本的开始部分，你可以找到两个基因组的最新位置，以及下载它们的代码。
- en: How to do it...
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 请按照以下步骤操作：
- en: 'Let’s start by listing the chromosomes of the *Anopheles gambiae* genome:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从列出*Anopheles gambiae*基因组的染色体开始：
- en: '[PRE5]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This will produce an output that will include the organism chromosomes (along
    with a few unmapped supercontigs not depicted):'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生一个输出，其中包括生物体的染色体（以及一些未映射的超级重组片段，未显示）：
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The code is quite straightforward. We use the `gzip` module because the files
    of larger genomes are normally compressed. We can see four chromosome arms (`2L`,
    `2R`, `3L`, and `3R`), the mitochondria (`Mt`), the `X` chromosome, and the `Y`
    chromosome, which is quite small and has a name that all but indicates that it
    may not be in the best state. Also, the unknown (`UNKN`) chromosome is a large
    proportion of the reference genome, to the tune of a chromosome arm.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 代码非常简单。我们使用`gzip`模块，因为较大基因组的文件通常是压缩的。我们可以看到四个染色体臂（`2L`、`2R`、`3L` 和 `3R`）、线粒体（`Mt`）、`X`
    染色体和 `Y` 染色体，后者非常小，名字几乎表明它的状态可能不佳。此外，未知的（`UNKN`）染色体占参考基因组的较大比例，几乎相当于一个染色体臂的大小。
- en: Do not perform this with *Anopheles atroparvus*; otherwise, you will get more
    than a thousand entries, courtesy of the scaffold status.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 不要在*Anopheles atroparvus*上执行此操作；否则，您将得到超过一千个条目，这归功于 scaffolding 状态。
- en: 'Now, let’s check the uncalled positions (`Ns`) and their distribution for the
    *Anopheles gambiae* genome:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们检查一下未调用的位置（`Ns`）及其在*按蚊（Anopheles gambiae）*基因组中的分布：
- en: '[PRE7]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The preceding code will take some time to run, so please be patient; we will
    inspect every base pair of autosomes. As usual, we will reopen and re-read the
    file to save memory.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码将需要一些时间来运行，请耐心等待；我们将检查所有常染色体的每个碱基对。和往常一样，我们将重新打开并重新读取文件以节省内存。
- en: 'We have two dictionaries: one dictionary that contains chromosome sizes and
    another that contains the distribution of the sizes of runs of `Ns`. To calculate
    the runs of `Ns`, we must traverse all autosomes (noting when an `N` position
    starts and ends). Then, we must print the basic statistics of the distribution
    of `Ns`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两个字典：一个包含染色体大小，另一个包含 `Ns` 运行的大小分布。为了计算 `Ns` 运行，我们必须遍历所有常染色体（注意何时 `N` 位置开始和结束）。然后，我们必须打印
    `Ns` 分布的基本统计信息：
- en: '[PRE8]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: So, for the `2L` chromosome arm (with a size of 49 Mbp), 1.7% are `N` calls
    divided by `957` runs. The biggest run is `28884` bps. Note that the `X` chromosome
    has the highest fraction of positions with `Ns`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于 `2L` 染色体臂（大小为 49 Mbp），1.7% 是 `N` 调用，并且分布在 `957` 个运行中。最大的运行是 `28884` bp。请注意，`X`
    染色体具有最高的 `Ns` 位置比例。
- en: 'Now, let’s turn our attention to the *Anopheles Atroparvus* genome. Let’s count
    the number of scaffolds, along with the distribution of scaffold sizes:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们将注意力转向*Anopheles Atroparvus*基因组。让我们计算一下 scaffolds 的数量，并且查看 scaffold 大小的分布：
- en: '[PRE9]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This code is similar to what we looked at previously, but we print slightly
    more detailed statistics using NumPy, so we get the following:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与我们之前看到的相似，但我们使用 NumPy 打印了更详细的统计信息，因此我们得到了以下结果：
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Thus, we have `1371` scaffolds (against seven entries on the *Anopheles gambiae*
    genome) with a median size of `7811.5` (a mean of `17,0678.2`). The biggest scaffold
    is 5.8 Mbp, while the smallest scaffold is 1,004 bp. The tenth percentile for
    size is `1537.1`, while the ninetieth is `39644.7`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有 `1371` 个 scaffolds（与*Anopheles gambiae*基因组中的七个条目相比），中位大小为 `7811.5`（平均值为
    `17,0678.2`）。最大的 scaffold 为 5.8 Mbp，最小的 scaffold 为 1004 bp。大小的第十百分位为 `1537.1`，而第九十百分位为
    `39644.7`。
- en: 'Finally, let’s plot the fraction of the scaffold – that is, `N` – as a function
    of its size:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们绘制 scaffold 的比例 —— 即 `N` —— 作为其大小的函数：
- en: '[PRE11]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The preceding code will generate the output shown in the following diagram,
    in which we split the chart into three parts based on the scaffold size: one for
    scaffolds with less than 4,800 bp, one for scaffolds between 4,800 and 540,000
    bp, and one for larger ones. The fraction of `Ns` is very low for small scaffolds
    (always below 3.5%); for medium scaffolds, it has a large variance (sizes between
    0% and above 90%), and a tighter variance (between 0% and 25%) for the largest
    scaffolds:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码将生成如下图所示的输出，在该图中，我们将图表按 scaffold 大小分成三部分：一部分用于小于 4,800 bp 的 scaffolds，一部分用于介于
    4,800 和 540,000 bp 之间的 scaffolds，另一部分用于更大的 scaffolds。小型 scaffolds 的 `Ns` 比例非常低（始终低于
    3.5%）；中型 scaffolds 的 `Ns` 比例有较大变异（大小范围为 0% 至超过 90%）；而对于最大的 scaffolds，`Ns` 的变异性较小（在
    0% 至 25% 之间）。
- en: '![](img/B17942_05_003.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17942_05_003.jpg)'
- en: Figure 5.3 – The fraction of scaffolds that are N as a function of their size
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3 – 作为其大小函数的 N 片段比例
- en: There’s more...
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: 'Sometimes, reference genomes carry extra information. For example, the *Anopheles
    gambiae* genome is soft masked. This means that some procedures were run on the
    genome to identify areas of low complexity (which are normally more problematic
    to analyze). This can be annotated by capitalization: ACTG will be high complexity,
    whereas actg will be low.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，参考基因组携带额外的信息。例如，*按蚊*基因组是软屏蔽的。这意味着对基因组进行了某些操作，以识别低复杂度区域（这些区域通常更难分析）。这种情况可以通过大写字母注释：ACTG表示高复杂度，而actg表示低复杂度。
- en: Reference genomes with lots of scaffolds are more than an inconvenient hassle.
    For example, very small scaffolds (say, below 2,000 bp) may have mapping problems
    when using an aligner (such as **Burrows-Wheeler Aligner** (**BWA**)), especially
    at the extremes (most scaffolds will have mapping problems at their extremes,
    but these will be of a much larger proportion of the scaffold if it’s small).
    If you are using a reference genome like this to align, you will want to consider
    ignoring the pair information (assuming that you have paired-end reads) when mapping
    to small scaffolds, or at least measure the impact of the scaffold size on the
    performance of your aligner. In any case, the general idea is that you should
    be careful because the scaffold size and number will rear their ugly head from
    time to time.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有大量 scaffolds 的参考基因组不仅仅是麻烦。例如，非常小的 scaffold（比如小于 2000 bp）在使用比对工具时（如**Burrows-Wheeler
    比对器**（**BWA**））可能会出现比对问题，尤其是在极端位置（大多数scaffold在极端位置会有比对问题，但如果 scaffold 较小，这些问题将占据
    scaffold 更大的比例）。如果你使用这样的参考基因组进行比对，建议在比对到小 scaffold 时考虑忽略配对信息（假设你有双端读取），或者至少衡量
    scaffold 大小对比对工具性能的影响。无论如何，关键在于你应该小心，因为 scaffold 的大小和数量会时不时地带来麻烦。
- en: With these genomes, only complete ambiguity (`N`) was identified. Note that
    other genome assemblies will give you an intermediate code between the total **ambiguity
    and certainty** (**ACTG**).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些基因组，仅识别出完全模糊（`N`）。请注意，其他基因组组装可能会给出一个介于**模糊和确定性**（**ACTG**）之间的中间代码。
- en: See also
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: 'Here are some resources you can learn more from:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些你可以从中了解更多信息的资源：
- en: Tools such as RepeatMasker can be used to find areas of the genome with low
    complexity. Check out [http://www.repeatmasker.org/](http://www.repeatmasker.org/)
    for more information.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工具如 RepeatMasker 可以用来查找基因组中低复杂度的区域。了解更多信息，请访问[http://www.repeatmasker.org/](http://www.repeatmasker.org/)。
- en: IUPAC ambiguity codes may be useful to have in hand when processing other genomes.
    Check out [http://www.bioinformatics.org/sms/iupac.xhtml](http://www.bioinformatics.org/sms/iupac.xhtml)
    for more information.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在处理其他基因组时，IUPAC模糊码可能会非常有用。了解更多信息，请访问[http://www.bioinformatics.org/sms/iupac.xhtml](http://www.bioinformatics.org/sms/iupac.xhtml)。
- en: Traversing genome annotations
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 遍历基因组注释
- en: Having a genome sequence is interesting, but we will want to extract features
    from it, such as genes, exons, and coding sequences. This type of annotation information
    is made available in **Generic Feature Format** (**GFF**) and **General Transfer
    Format** (**GTF**) files. In this recipe, we will learn how to parse and analyze
    GFF files while using the annotation of the *Anopheles gambiae* genome as an example.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一个基因组序列很有趣，但我们还需要从中提取特征，例如基因、外显子和编码序列。这类注释信息通常以**通用特征格式**（**GFF**）和**通用转移格式**（**GTF**）文件的形式提供。在本教程中，我们将以*按蚊*基因组的注释为例，学习如何解析和分析GFF文件。
- en: Getting ready
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Use the `Chapter05/Annotations.py` notebook file, which is provided in the code
    bundle for this book. The up-to-date location of the GFF file that we will be
    using can be found at the top of the notebook.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 使用提供的`Chapter05/Annotations.py`笔记本文件，该文件包含在本书的代码包中。我们将使用的GFF文件的最新位置可以在笔记本顶部找到。
- en: 'You will need to install `gffutils`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要安装`gffutils`：
- en: '[PRE12]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now, we’re ready to start.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备开始了。
- en: How to do it...
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤操作：
- en: 'Let’s start by creating an annotation database with `gffutils`, based on our
    GFF file:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从创建一个基于GFF文件的注释数据库开始，使用`gffutils`：
- en: '[PRE13]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `gffutils` library creates a SQLite database to store annotations efficiently.
    Here, we will try to create the database, but if it already exists, we will use
    the existing one. This step can be time-consuming.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`gffutils`库创建一个SQLite数据库来高效存储注释信息。在这里，我们将尝试创建数据库，如果数据库已存在，则使用现有的。这一步可能需要一些时间。'
- en: 'Now, let’s list all the available feature types and count them:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们列出所有可用的特征类型并统计它们：
- en: '[PRE14]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: These features will include contigs, genes, exons, transcripts, and so on. Note
    that we will use the `gffutils` package’s `featuretypes` function. It will return
    a generator, but we will convert it into a list (it’s safe to do so here).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这些特征包括 contigs、基因、外显子、转录本等等。请注意，我们将使用 `gffutils` 包的 `featuretypes` 函数。它将返回一个生成器，但我们会将其转换为列表（在这里这样做是安全的）。
- en: 'Let’s list all seqids:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们列出所有的 seqids：
- en: '[PRE15]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This will show us that there is annotation information for all chromosome arms
    and sex chromosomes, mitochondrion, and the unknown chromosome.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示所有染色体臂和性染色体、线粒体以及未知染色体的注释信息。
- en: 'Now, let’s extract a lot of useful information per chromosome, such as the
    number of genes, number of transcripts per gene, number of exons, and so on:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们按染色体提取大量有用的信息，比如基因数量、每个基因的转录本数量、外显子数量等等：
- en: '[PRE16]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We will traverse all seqids while extracting all protein-coding genes (using
    `region`). In each gene, we count the number of alternative transcripts. If there
    are none (note that this is probably an annotation issue and not a biological
    one), we count the exons (`children`). If there are several transcripts, we count
    the exons per transcript. We also account for the span size to check for the gene
    that spans the largest region.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在提取所有蛋白质编码基因的同时遍历所有 seqids（使用 `region`）。在每个基因中，我们统计可变转录本的数量。如果没有（注意这可能是注释问题，而不是生物学问题），我们统计外显子数（`children`）。如果有多个转录本，我们统计每个转录本的外显子数。我们还会考虑跨度大小，以检查跨越最大区域的基因。
- en: We follow a similar procedure to find the gene and the largest number of exons.
    Finally, we print a dictionary that contains the distribution of the number of
    alternative transcripts per gene (`num_mRNAs`) and the distribution of the number
    of exons per transcript (`num_exons`).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遵循类似的步骤来查找基因和最大的外显子数。最后，我们打印一个字典，包含每个基因的可变转录本数量分布（`num_mRNAs`）和每个转录本的外显子数量分布（`num_exons`）。
- en: There’s more...
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There are many variations of the GFF/GTF format. There are different GFF versions
    and many unofficial variations. If possible, choose GFF version 3\. However, the
    ugly truth is that you will find it very difficult to process files. The `gffutils`
    library tries as best as it can to accommodate this. Indeed, much of the documentation
    for this library is concerned with helping you process all kinds of awkward variations
    (refer to [https://pythonhosted.org/gffutils/examples.xhtml](https://pythonhosted.org/gffutils/examples.xhtml)).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: GFF/GTF 格式有许多变种。不同的 GFF 版本和许多非官方的变体。如果可能的话，选择 GFF 版本 3。然而，残酷的事实是，你会发现处理这些文件非常困难。`gffutils`
    库尽可能地适应了这一点。事实上，许多关于这个库的文档都是帮助你处理各种尴尬变体的（参考 [https://pythonhosted.org/gffutils/examples.xhtml](https://pythonhosted.org/gffutils/examples.xhtml)）。
- en: There is an alternative to using `gffutils` (either because your GFF file is
    strange or because you do not like the library interface or its dependency on
    a SQL backend). Parse the file yourself manually. If you look at the format, you
    will notice that it’s not very complex. If you are only performing a one-off operation,
    then maybe manual parsing is good enough. Of course, one-off operations tend to
    not be that good in the long run.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `gffutils` 也有替代方案（无论是因为你的 GFF 文件有问题，还是你不喜欢这个库的接口或它依赖 SQL 后端）。自己手动解析文件。如果你看一下格式，你会发现它并不复杂。如果你只进行一次性操作，手动解析或许足够。当然，长期来看，一次性操作往往并不是最好的选择。
- en: Also, note that the quality of annotations tends to vary a lot. As the quality
    increases, so does the complexity. Just check the human annotation for an example
    of this. You can expect that, over time, as our knowledge of organisms evolves,
    the quality and complexity of annotations will increase.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，请注意，注释的质量往往差异很大。随着质量的提高，复杂性也会增加。只要看看人类注释，就能看到这一点的例子。可以预见，随着我们对生物体的认识不断深入，注释的质量和复杂性也会逐渐提升。
- en: See also
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参见
- en: 'Here are some resources you can learn more from:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些你可以学习更多资源：
- en: The GFF spec can be found at [https://www.sanger.ac.uk/resources/software/gff/spec.xhtml](https://www.sanger.ac.uk/resources/software/gff/spec.xhtml).
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GFF 规范可以在 [https://www.sanger.ac.uk/resources/software/gff/spec.xhtml](https://www.sanger.ac.uk/resources/software/gff/spec.xhtml)
    找到。
- en: Probably the best explanation of the GFF format, along with the most common
    versions and GTF, can be found at [http://gmod.org/wiki/GFF3](http://gmod.org/wiki/GFF3).
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于 GFF 格式的最佳解释，以及最常见的版本和 GTF，可以在 [http://gmod.org/wiki/GFF3](http://gmod.org/wiki/GFF3)
    找到。
- en: Extracting genes from a reference using annotations
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从参考基因组中提取基因信息
- en: In this recipe, we will learn how to extract a gene sequence with the help of
    an annotation file to get its coordinates against a reference FASTA. We will use
    the *Anopheles gambiae* genome, along with its annotation file (as per the previous
    two recipes). First, we will extract the **voltage-gated sodium channel** (**VGSC**)
    gene, which is involved in resistance to insecticides.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个步骤中，我们将学习如何借助注释文件提取基因序列，并将其与参考FASTA文件的坐标对齐。我们将使用 *Anopheles gambiae* 基因组及其注释文件（如前两个步骤所示）。首先，我们将提取
    **电压门控钠通道**（**VGSC**）基因，该基因与抗虫剂的抗性相关。
- en: Getting ready
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备开始
- en: 'If you have followed the previous two recipes, you will be ready. If not, download
    the *Anopheles gambiae* FASTA file, along with the GTF file. You also need to
    prepare the `gffutils` database:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经按照前两个步骤操作，你就准备好了。如果没有，下载 *Anopheles gambiae* 的FASTA文件和GTF文件。你还需要准备 `gffutils`
    数据库：
- en: '[PRE17]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As usual, you will find all of this in the `Chapter05/Getting_Gene.py` notebook
    file.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，你将会在 `Chapter05/Getting_Gene.py` 笔记本文件中找到所有这些内容。
- en: How to do it...
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤操作：
- en: 'Let’s start by retrieving the annotation information for our gene:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从获取基因的注释信息开始：
- en: '[PRE18]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`gene_id` was retrieved from VectorBase, an online database for the genomics
    of disease vectors. For other specific cases, you will need to know the ID of
    your gene (which will be dependent on the species and database). The output will
    be as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`gene_id` 是从 VectorBase 获取的，它是一个专门用于疾病传播媒介基因组学的在线数据库。对于其他特定情况，你需要知道你的基因ID（它将依赖于物种和数据库）。输出将如下所示：'
- en: '[PRE19]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note that the gene is on the `2L` chromosome arm and coded in the positive direction
    (the `+` strand).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 注意该基因位于 `2L` 染色体臂，并且是以正向方向编码的（`+` 链）。
- en: 'Let’s hold the sequence for the `2L` chromosome arm in memory (it’s just a
    single chromosome, so we will indulge):'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将 `2L` 染色体臂的序列保存在内存中（它只有一个染色体，所以我们可以稍微放松一些）：
- en: '[PRE20]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The output will be as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE21]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Let’s create a function to construct a gene sequence for a list of `CDSs`:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个函数来为一系列 `CDS` 构建基因序列：
- en: '[PRE22]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This function will receive a chromosome sequence (in our case, the `2L` arm),
    a list of coding sequences (retrieved from the annotation file), and the strand.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将接收一个染色体序列（在我们的案例中是 `2L` 臂），一个编码序列的列表（从注释文件中提取），以及链的信息。
- en: We have to be very careful with the start and end of the sequence (note that
    the GFF file is 1-based, whereas the Python array is 0-based). Finally, we return
    the reverse complement if the strand is negative.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须非常小心序列的起始和结束（注意GFF文件是基于1的，而Python数组是基于0的）。最后，如果链是负向的，我们将返回反向互补序列。
- en: 'Although we have the `gene_id` at hand, we only want one of the transcripts
    of the three available for this gene, so we need to choose one:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尽管我们已经得到了 `gene_id`，但我们只需要选择这个基因的三个转录本中的一个，因此需要选择一个：
- en: '[PRE23]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, let’s get the coding sequence for our transcript, then get the gene sequence,
    and translate it:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们获取转录本的编码序列，然后获取基因序列，并进行翻译：
- en: '[PRE24]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Let’s get the gene that is coded in the negative strand direction. We will
    just take the gene next to VGSC (which happens to be the negative strand):'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们获取以负链方向编码的基因。我们将提取VGSC旁边的基因（恰好是负链）。
- en: '[PRE25]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Here, I avoided getting all of the information about the gene and just hardcoded
    the transcript ID. The point is that you should make sure your code works, irrespective
    of the strand.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我避免了获取基因的所有信息，只是硬编码了转录本ID。关键是你需要确保你的代码无论在什么链上都能正常工作。
- en: There’s more...
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: This is a simple recipe that exercises several concepts that have been presented
    in this chapter and [*Chapter 3*](B17942_03.xhtml#_idTextAnchor068), *Next Generation
    Sequencing*. While it’s conceptually trivial, it’s unfortunately full of booby
    traps.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的步骤，涵盖了本章和 [*第3章*](B17942_03.xhtml#_idTextAnchor068)，《下一代测序》中介绍的几个概念。虽然它在概念上很简单，但不幸的是充满了陷阱。
- en: Tip
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: When using different databases, be sure that the genome assembly versions are
    synchronized. It would be a serious and potentially silent bug to use different
    versions. Remember that different versions (at least on the major version number)
    have different coordinates. For example, position 1,234 on chromosome 3 on build
    36 of the human genome will probably refer to a different SNP than 1,234 on build
    38\. With human data, you will probably find a lot of chips on build 36, and plenty
    of whole genome sequences on build 37, whereas the most recent human assembly
    is build 38\. With our *Anopheles* example, you will have versions 3 and 4 around.
    This will happen with most species. So, be aware!
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 使用不同的数据库时，确保基因组组装版本是同步的。使用不同版本可能会导致严重且潜在的隐性错误。请记住，不同版本（至少在主版本号上）有不同的坐标。例如，人在基因组36版本中3号染色体上的位置1,234可能与基因组38版本中的1,234不同，可能指向不同的SNP。在人类数据中，你可能会发现很多芯片使用的是基因组36版本，而整个基因组序列使用的是基因组37版本，而最新的人类组装版本是基因组38版本。对于我们的*Anopheles*示例，你将会看到3和4版本。大多数物种都会遇到这种情况，所以请注意！
- en: There is also the issue of 0-indexed arrays in Python versus 1-indexed genomic
    databases. Nonetheless, be aware that some genomic databases may also be 0-indexed.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个问题是Python中的0索引数组与1索引的基因组数据库之间的差异。不过，需要注意的是，一些基因组数据库可能也使用0索引。
- en: 'There are also two sources of confusion: the transcript versus the gene choice,
    as in more rich annotation databases. Here, you will have several alternative
    transcripts (if you want to look at a rich-to-the-point-of-confusing database,
    refer to the human annotation database). Also, fields tagged with `exon` will
    contain more information compared to the coding sequence. For this purpose, you
    will want the CDS field.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有两个容易混淆的点：转录本与基因选择，就像在更丰富的注释数据库中一样。在这里，你将有几个备选的转录本（如果你想查看一个复杂到让人迷惑的数据库，可以参考人类注释数据库）。另外，标记为`exon`的字段包含的信息比编码序列要多。为了这个目的，你将需要CDS字段。
- en: Finally, there is the strand issue, where you will want to translate based on
    the reverse complement.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，还有一个链条问题，你将需要基于反向互补进行翻译。
- en: See also
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: 'Here are some resources you can learn more from:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些资源，你可以从中获取更多信息：
- en: You can download MySQL tables for Ensembl at [http://www.ensembl.org/info/data/mysql.xhtml](http://www.ensembl.org/info/data/mysql.xhtml).
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在[http://www.ensembl.org/info/data/mysql.xhtml](http://www.ensembl.org/info/data/mysql.xhtml)下载Ensembl的MySQL表格。
- en: The UCSC genome browser can be found at [http://genome.ucsc.edu/](http://genome.ucsc.edu/).
    Be sure to check the download area at [http://hgdownload.soe.ucsc.edu/downloads.xhtml](http://hgdownload.soe.ucsc.edu/downloads.xhtml).
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UCSC基因组浏览器可以在[http://genome.ucsc.edu/](http://genome.ucsc.edu/)找到。务必查看[http://hgdownload.soe.ucsc.edu/downloads.xhtml](http://hgdownload.soe.ucsc.edu/downloads.xhtml)的下载区域。
- en: With a reference to genomes, you can find GTFs of model organisms in Ensembl
    at [http://www.ensembl.org/info/data/ftp/index.xhtml](http://www.ensembl.org/info/data/ftp/index.xhtml).
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过参考基因组，你可以在Ensembl找到模型生物的GTF文件，地址为[http://www.ensembl.org/info/data/ftp/index.xhtml](http://www.ensembl.org/info/data/ftp/index.xhtml)。
- en: A simple explanation of CDSs and exons can be found at [https://www.biostars.org/p/65162/](https://www.biostars.org/p/65162/).
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于CDS和外显子的简单解释可以在[https://www.biostars.org/p/65162/](https://www.biostars.org/p/65162/)找到。
- en: Finding orthologues with the Ensembl REST API
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Ensembl REST API查找同源基因
- en: In this recipe, we will learn how to look for orthologues for a certain gene.
    This simple recipe will not only introduce orthology retrieval but also how to
    use REST APIs on the web to access biological data. Last, but surely not least,
    it will serve as an introduction to how to access the Ensembl database using the
    programmatic API.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将学习如何为某个基因寻找同源基因。这个简单的食谱不仅介绍了同源性检索，还教你如何使用网页上的REST API来访问生物数据。最后，虽然不是最重要的，它将作为如何使用编程API访问Ensembl数据库的入门教程。
- en: In our example, we will try to find any orthologue for the human `horse` genome.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们将尝试为人类`horse`基因组寻找任何同源基因。
- en: Getting ready
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe will not require any pre-downloaded data, but since we are using
    web APIs, internet access will be needed. The amount of data that can be transferred
    will be limited.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱不需要任何预先下载的数据，但由于我们使用的是Web API，因此需要互联网访问。传输的数据量将受到限制。
- en: We will also make use of the `requests` library to access Ensembl. The request
    API is an easy-to-use wrapper for web requests. Of course, you can use the standard
    Python libraries, but these are much more cumbersome.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用`requests`库来访问Ensembl。请求API是一个易于使用的Web请求封装。自然，你也可以使用标准的Python库，但这些要麻烦得多。
- en: As usual, you can find this content in the `Chapter05/Orthology.py` notebook
    file.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，你可以在 `Chapter05/Orthology.py` 笔记本文件中找到这些内容。
- en: How to do it...
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤操作：
- en: 'We will start by creating a support function to perform a web request:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将从创建一个支持函数开始，以执行网络请求：
- en: '[PRE26]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We start by importing the `requests` library and specifying the root URL. Then,
    we create a simple function that will take the functionality to be called (see
    the following examples) and generate a complete URL. It will also add optional
    parameters and specify the payload to be of the JSON type (just to get a default
    JSON answer). It will return the response in JSON format. This is typically a
    nested Python data structure of lists and dictionaries.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先导入 `requests` 库并指定根 URL。然后，我们创建一个简单的函数，传入要调用的功能（参见以下示例），并生成完整的 URL。它还会添加可选参数，并指定负载类型为
    JSON（这样就能获取默认的 JSON 响应）。它将返回 JSON 格式的响应。通常这是一个嵌套的 Python 数据结构，包含列表和字典。
- en: 'Then, we will check all the available species on the server, which is around
    110 at the time of writing this book:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将检查服务器上所有可用的物种，写这本书时大约有 110 种物种：
- en: '[PRE27]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note that this will construct a URL starting with the `http://rest.ensembl.org/info/species`
    prefix for the REST request. The preceding link will not work on your browser,
    by the way; it should only be used via a REST API.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这将构造一个以 `http://rest.ensembl.org/info/species` 为前缀的 URL，用于 REST 请求。顺便说一下，前面的链接在你的浏览器中无法使用，它应该仅通过
    REST API 使用。
- en: 'Now, let’s try to find any `HGNC` databases on the server related to human
    data:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们尝试查找与人类数据相关的 `HGNC` 数据库：
- en: '[PRE28]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We restrict the search to human-related databases (`homo_sapiens`). We also
    filter databases starting with `HGNC` (this filtering uses the SQL notation).
    `HGNC` is the HUGO database. We want to make sure that it’s available because
    the HUGO database is responsible for curating human gene names and maintaining
    our LCT identifier.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将搜索限制为与人类相关的数据库（`homo_sapiens`）。我们还会筛选以 `HGNC` 开头的数据库（这个筛选使用 SQL 表达式）。`HGNC`
    是 HUGO 数据库。我们要确保它可用，因为 HUGO 数据库负责整理人类基因名称并维护我们的 LCT 标识符。
- en: 'Now that we know that the LCT identifier is probably available, we want to
    retrieve the Ensembl ID for the gene, as shown in the following code:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们知道 LCT 标识符可能可用，我们希望检索该基因的 Ensembl ID，如以下代码所示：
- en: '[PRE29]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Tip
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Different databases, as you probably know by now, will have different IDs for
    the same object. We will need to resolve our LCT identifier to the Ensembl ID.
    When you deal with external databases that relate to the same objects, ID translation
    between databases will probably be your first task.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你现在可能知道的，不同的数据库会为相同的对象分配不同的 ID。我们需要将我们的 LCT 标识符解析为 Ensembl ID。当你处理与相同对象相关的外部数据库时，数据库之间的
    ID 转换可能是你需要完成的第一项任务。
- en: 'Just for your information, we can now get the sequence of the area containing
    the gene. Note that this is probably the whole interval, so if you want to recover
    the gene, you will have to use a procedure similar to what we used in the previous
    recipe:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仅供参考，我们现在可以获取包含基因的区域的序列。请注意，这可能是整个区间，因此如果你想恢复基因，你需要使用类似于我们在前一个步骤中使用的方法：
- en: '[PRE30]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We can also inspect other databases known to Ensembl; refer to the following
    gene:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以检查 Ensembl 已知的其他数据库；参见以下基因：
- en: '[PRE31]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: You will find different kinds of databases, such as the **Vertebrate Genome
    Annotation** (**Vega**) project, UniProt (see [*Chapter 8*](B17942_08.xhtml#_idTextAnchor209),
    *Using the Protein Data Bank*), and WikiGene.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现不同种类的数据库，比如 **脊椎动物基因组注释** (**Vega**) 项目、UniProt（参见 [*第8章*](B17942_08.xhtml#_idTextAnchor209)，*使用蛋白质数据库*）和
    WikiGene。
- en: 'Let’s get the orthologues for this gene on the `horse` genome:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们获取这个基因在 `horse` 基因组上的同源基因：
- en: '[PRE32]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We could have acquired the orthologues directly for the `horse` genome by specifying
    a `target_species` parameter on `do_request`. However, this code allows you to
    inspect all the available orthologues.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以通过在 `do_request` 中指定 `target_species` 参数，直接获取 `horse` 基因组的同源基因。然而，这段代码允许你检查所有可用的同源基因。
- en: You will get quite a lot of information about an orthologue, such as the taxonomic
    level of orthology (Boreoeutheria – placental mammals is the closest phylogenetic
    level between humans and horses), the Ensembl ID of the orthologue, the dN/dS
    ratio (non-synonymous to synonymous mutations), and the CIGAR string (refer to
    the previous chapter, [*Chapter 3*](B17942_03.xhtml#_idTextAnchor068), *Next-Generation
    Sequencing*) of differences among sequences. By default, you will also get the
    alignment of the orthologous sequence, but I have removed it to unclog the output.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 你将获得关于同源基因的许多信息，例如同源性分类的分类学级别（Boreoeutheria—有胎盘哺乳动物是人类与马匹之间最近的系统发育级别）、同源基因的Ensembl
    ID、dN/dS比率（非同义突变与同义突变的比例），以及CIGAR字符串（请参见前一章，[*第3章*](B17942_03.xhtml#_idTextAnchor068)，*下一代测序*）来表示序列之间的差异。默认情况下，你还会得到同源序列的比对结果，但为了简化输出，我已经将其移除。
- en: 'Finally, let’s look for the `horse_id` Ensembl record:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们查找`horse_id`的Ensembl记录：
- en: '[PRE33]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: From this point onward, you can use the previous recipe methods to explore the
    LCT `horse` orthologue.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 从这一点开始，你可以使用之前配方中的方法来探索LCT `horse`同源基因。
- en: There’s more...
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: You can find a detailed explanation of all the functionalities available at
    [http://rest.ensembl.org/](http://rest.ensembl.org/). This includes all the interfaces
    and Python code snippets, among other languages.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[http://rest.ensembl.org/](http://rest.ensembl.org/)找到所有可用功能的详细解释。这包括所有接口和Python代码片段等语言。
- en: If you are interested in paralogues, this information can be retrieved quite
    trivially from the preceding recipe. On the call to `homology/id`, just replace
    the type with `paralogues`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对同源基因感兴趣，可以通过前面的步骤轻松地从之前的配方中获取这些信息。在调用`homology/id`时，只需将类型替换为`paralogues`。
- en: 'If you have heard of Ensembl, you have probably heard of an alternative service
    from UCSC: the Genome Browser ([http://genome.ucsc.edu/](http://genome.ucsc.edu/)).
    From the perspective of the user interface, they are on the same level. From a
    programmatic perspective, Ensembl is probably more mature. Accessing NCBI Entrez
    databases was covered in [*Chapter 3*](B17942_03.xhtml#_idTextAnchor068), *Next
    Generation Sequencing*.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你听说过Ensembl，那么你可能也听说过UCSC的一个替代服务：基因组浏览器([http://genome.ucsc.edu/](http://genome.ucsc.edu/))。从用户界面的角度来看，它们在同一层级。从编程的角度来看，Ensembl可能更加成熟。访问NCBI
    Entrez数据库在[*第3章*](B17942_03.xhtml#_idTextAnchor068)，*下一代测序*中有介绍。
- en: Another completely different strategy to interface programmatically with Ensembl
    will be to download raw tables and inject them into a local MySQL database. Be
    aware that this will be quite an undertaking in itself (you will probably just
    want to load a very small subset of tables). However, if you intend to be very
    intensive in terms of usage, you may have to consider creating a local version
    of part of the database. If this is the case, you may want to reconsider the UCSC
    alternative, as it’s as good as Ensembl from the local database perspective.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种完全不同的编程接口方式是下载原始数据表并将其导入到本地MySQL数据库中。请注意，这本身会是一个相当大的工程（你可能只想加载非常小的一部分数据表）。然而，如果你打算进行非常密集的使用，可能需要考虑创建部分数据库的本地版本。如果是这种情况，你可能需要重新考虑UCSC的替代方案，因为从本地数据库的角度来看，它和Ensembl一样优秀。
- en: Retrieving gene ontology information from Ensembl
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从Ensembl获取基因本体论信息
- en: 'In this recipe, you will learn how to use gene ontology information again by
    querying the Ensembl REST API. Gene ontologies are controlled vocabularies for
    annotating genes and gene products. These are made available as trees of concepts
    (with more general concepts near the top of the hierarchy). There are three domains
    for gene ontologies: the cellular component, the molecular function, and the biological
    process.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在本步骤中，你将再次学习如何通过查询Ensembl REST API来使用基因本体论信息。基因本体论是用于注释基因及基因产物的受控词汇。这些词汇以概念树的形式提供（越通用的概念在层次结构的顶部）。基因本体论有三个领域：细胞成分、分子功能和生物过程。
- en: Getting ready
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: As with the previous recipe, we do not require any pre-downloaded data, but
    since we are using web APIs, internet access will be needed. The amount of data
    that will be transferred will be limited.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的步骤一样，我们不需要任何预下载的数据，但由于我们使用的是Web API，因此需要互联网访问。传输的数据量将是有限的。
- en: 'As usual, you can find this content in the `Chapter05/Gene_Ontology.py` notebook
    file. We will make use of the `do_request` function, which was defined in *Step
    1* of the previous recipe (*Finding orthologues with the Ensembl REST API*). To
    draw GO trees, we will use `pygraphviz`, a graph-drawing library:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如常，你可以在`Chapter05/Gene_Ontology.py`笔记本文件中找到这些内容。我们将使用在前一部分(*使用Ensembl REST API查找直系同源基因*)中定义的`do_request`函数。为了绘制GO树，我们将使用`pygraphviz`，一个图形绘制库：
- en: '[PRE34]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: OK – we’re all set.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们准备好了。
- en: How to do it...
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤操作：
- en: 'Let’s start by retrieving all GO terms associated with the LCT gene (you learned
    how to retrieve the Ensembl ID in the previous recipe). Remember that you will
    need the `do_request` function from the previous recipe:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从检索与LCT基因相关的所有GO术语开始（你已经在前一部分学会了如何检索Ensembl ID）。记住，你需要使用前一部分中的`do_request`函数：
- en: '[PRE35]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Note the free-form definition and the varying namespace for each term. The
    first two of the reported items in the loop are as follows (this may change when
    you run it, because the database may have been updated):'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 注意自由格式的定义和每个术语的不同命名空间。在循环中报告的前两个项目如下（当你运行时，它可能会有所变化，因为数据库可能已经更新）：
- en: '[PRE36]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Let’s concentrate on the `lactase activity` molecular function and retrieve
    more detailed information about it (the following `go_id` comes from the previous
    step):'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们集中注意力在`乳糖酶活性`分子功能上，并获取更多关于它的详细信息（以下`go_id`来自前一步）：
- en: '[PRE37]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We print the `lactase activity` record (which is currently a node of the GO
    tree molecular function) and retrieve a list of potential parents. There is a
    single parent for this record. We retrieve it and print the number of children.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们打印出`乳糖酶活性`记录（它目前是GO树分子功能的一个节点），并检索潜在的父节点列表。此记录只有一个父节点。我们获取该父节点并打印出它的子节点数量。
- en: 'Let’s retrieve all the general terms for the `lactase activity` molecular function
    (again, the parent and all other ancestors):'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们检索所有与`乳糖酶活性`分子功能相关的一般术语（再次强调，父术语及所有其他祖先术语）：
- en: '[PRE38]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We retrieve the `ancestor` list by following the `is_a` relationship (refer
    to the GO sites in the *See also* section for more details on the types of possible
    relationships).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过遵循`is_a`关系来获取`祖先`列表（更多关于可能关系类型的详细信息请参考*另见*部分中的GO网站）。
- en: 'Let’s define a function that will create a dictionary with the ancestor relationship
    for a term, along with some summary information for each term returned in a pair:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们定义一个函数，该函数将创建一个包含术语的祖先关系字典，并返回每个术语的摘要信息，作为一个对：
- en: '[PRE39]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Finally, we will print a tree of relationships for the `lactase activity` term.
    For this, we will use the `pygraphivz` library:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将打印出`乳糖酶活性`术语的关系树。为此，我们将使用`pygraphivz`库：
- en: '[PRE40]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The following output shows the ontology tree for the `lactase activity` term:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 以下输出显示了`乳糖酶活性`术语的本体树：
- en: '![Figure 5.4 – An ontology tree for the “lactase activity” term (the terms
    at the top are more general); the top of the tree is molecular_function; for all
    ancestral nodes, the number of extra offspring is also noted (or enumerated, if
    less than three) ](img/B17942_05_004.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.4 – “乳糖酶活性”术语的本体树（顶部的术语更为一般）；树的顶部是molecular_function；对于所有祖先节点，还标注了额外后代的数量（如果少于三个，则进行列举）](img/B17942_05_004.jpg)'
- en: Figure 5.4 – An ontology tree for the “lactase activity” term (the terms at
    the top are more general); the top of the tree is molecular_function; for all
    ancestral nodes, the number of extra offspring is also noted (or enumerated, if
    less than three)
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4 – “乳糖酶活性”术语的本体树（顶部的术语更为一般）；树的顶部是molecular_function；对于所有祖先节点，还标注了额外后代的数量（如果少于三个，则进行列举）
- en: There’s more...
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: If you are interested in gene ontologies, your main port of call will be [http://geneontology.org](http://geneontology.org),
    where you will find much more information on this topic. Apart from `molecular_function`,
    gene ontology also has a *biological process* and a *cellular component*. In our
    recipes, we have followed the hierarchical relationship *is a*, but others do
    exist partially. For example, “mitochondrial ribosome” (GO:0005761) is a cellular
    component and is part of “mitochondrial matrix” (refer to [http://amigo.geneontology.org/amigo/term/GO:0005761#display-lineage-tab](http://amigo.geneontology.org/amigo/term/GO:0005761#display-lineage-tab)
    and click on **Graph Views**).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对基因本体论感兴趣，主要参考网站是[http://geneontology.org](http://geneontology.org)，在这里你会找到更多关于这个主题的信息。除了`molecular_function`，基因本体还包括*生物过程*和*细胞组分*。在我们的配方中，我们遵循了*is
    a*的分层关系，但也存在其他部分关系。例如，“线粒体核糖体”（GO:0005761）是一个细胞组分，是“线粒体基质”的一部分（参考[http://amigo.geneontology.org/amigo/term/GO:0005761#display-lineage-tab](http://amigo.geneontology.org/amigo/term/GO:0005761#display-lineage-tab)，点击**图形视图**）。
- en: As with the previous recipe, you can download the MySQL dump of a gene ontology
    database (you may prefer to interact with the data in that way). For this, see
    [http://geneontology.org/page/download-go-annotations](http://geneontology.org/page/download-go-annotations).
    Again, expect to allocate some time to understanding the relational database schema.
    Also, note that there are many alternatives to Graphviz for plotting trees and
    graphs. We will return to this topic later in this book.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的配方一样，你可以下载基因本体数据库的MySQL转储（你可能更喜欢以这种方式与数据交互）。有关详细信息，请参阅[http://geneontology.org/page/download-go-annotations](http://geneontology.org/page/download-go-annotations)。同样，请准备一些时间来理解关系数据库架构。此外，请注意，绘制树和图形有许多替代方案可用于Graphviz。我们将在本书后续章节回顾这个主题。
- en: See also
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: 'Here are some resources you can learn more from:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些可以进一步了解的资源：
- en: As mentioned previously, more so than Ensembl, the main resource for gene ontologies
    is [http://geneontology.org](http://geneontology.org).
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如前所述，相比Ensembl，基因本体的主要资源是[http://geneontology.org](http://geneontology.org)。
- en: For visualization, we are using the `pygraphviz` library, which is a wrapper
    on top of Graphviz ( [http://www.graphviz.org](http://www.graphviz.org)).
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可视化方面，我们使用的是`pygraphviz`库，它是Graphviz的一个包装器（[http://www.graphviz.org](http://www.graphviz.org)）。
- en: There are very good user interfaces for GO data, such as AmiGO ([http://amigo.geneontology.org](http://amigo.geneontology.org))
    and QuickGO ([http://www.ebi.ac.uk/QuickGO/](http://www.ebi.ac.uk/QuickGO/)).
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有很好的用户界面用于GO数据，例如AmiGO（[http://amigo.geneontology.org](http://amigo.geneontology.org)）和QuickGO（[http://www.ebi.ac.uk/QuickGO/](http://www.ebi.ac.uk/QuickGO/)）。
- en: One of the most common analyses performed with GO is gene enrichment analysis
    to check whether some GO terms are overexpressed or underexpressed in a certain
    gene set. The [geneontology.org](http://geneontology.org) server uses Panther
    ([http://go.pantherdb.org/](http://go.pantherdb.org/)), but other alternatives
    are available (such as DAVID, at [http://david.abcc.ncifcrf.gov/](http://david.abcc.ncifcrf.gov/)).
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GO（Gene Ontology）最常见的分析之一是基因富集分析，用于检查某些GO术语在特定基因集中是否过表达或低表达。服务器[基因本体论](http://geneontology.org)使用Panther（[http://go.pantherdb.org/](http://go.pantherdb.org/)），但也有其他选择（如DAVID，位于[http://david.abcc.ncifcrf.gov/](http://david.abcc.ncifcrf.gov/)）。
