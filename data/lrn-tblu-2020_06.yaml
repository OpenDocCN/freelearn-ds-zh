- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Diving Deep with Table Calculations
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入探讨表格计算
- en: '**Table calculations** are one of the most powerful features in Tableau. They
    enable solutions that really couldn''t be achieved any other way (short of writing
    a custom application or complex custom SQL scripts!). The features include the
    following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**表格计算**是 Tableau 中最强大的功能之一。它们能实现那些通过其他方式无法完成的解决方案（除非编写自定义应用程序或复杂的自定义 SQL 脚本！）。这些功能包括以下内容：'
- en: They make it possible to use data that isn't structured well and still get quick
    results without waiting for someone to fix the data at the source.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们使得即使数据结构不佳，依然能快速得出结果，而无需等待有人修复数据源中的数据。
- en: They make it possible to compare and perform calculations on aggregate values
    across rows of the resulting table.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们使得可以在结果表的各行之间比较并对聚合值进行计算。
- en: They open incredible possibilities for analysis and creative approaches to solving
    problems, highlighting insights, or improving the user experience.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们为分析、创造性地解决问题、突出洞察或改善用户体验打开了令人难以置信的可能性。
- en: 'Table calculations range in complexity, from incredibly easy to create (a couple
    of clicks) to extremely complex (requiring an understanding of **addressing**,
    **partitioning**, and **data densification**, for example). We''ll start off simple
    and move toward complexity in this chapter. The goal is to gain a solid foundation
    in creating and using table calculations, understanding how they work, and looking
    at some examples of how they can be used. We''ll consider these topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 表格计算的复杂度各异，从非常容易创建（只需几次点击）到极其复杂（例如，需要理解**定位**、**分区**和**数据密集化**等概念）。在本章中，我们将从简单的开始，逐步深入复杂的内容。目标是为创建和使用表格计算奠定坚实的基础，理解它们的工作原理，并查看一些使用示例。我们将探讨以下内容：
- en: An overview of table calculations
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表格计算概览
- en: Quick table calculations
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快速表格计算
- en: Scope and direction
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 范围和方向
- en: Addressing and partitioning
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定位和分区
- en: Custom table calculations
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义表格计算
- en: Practical examples
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实际示例
- en: The examples in this chapter will return to the sample `Superstore` data that
    we used in the first chapter. To follow along with the examples, use the `Chapter
    06 Starter.twbx` workbook.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的示例将使用我们在第一章中使用的 `Superstore` 示例数据。要跟随示例操作，请使用 `Chapter 06 Starter.twbx`
    工作簿。
- en: An overview of table calculations
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表格计算概览
- en: '**Table calculations** are different from all other calculations in Tableau.
    Row-level, aggregate calculations, and LOD expressions, which we explored in the
    previous chapters, are performed as part of the query to the data source. If you
    were to examine the queries sent to the data source by Tableau, you''d find the
    code for your calculations translated into whatever implementation of SQL the
    data source used.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**表格计算**与 Tableau 中的所有其他计算不同。行级、聚合计算和 LOD 表达式（我们在前几章中探讨过）是在查询数据源的过程中执行的。如果你检查
    Tableau 发送到数据源的查询，你会发现计算的代码已转换为数据源使用的任何 SQL 实现。'
- en: 'Table calculations, on the other hand, are performed after the initial query.
    Here''s a diagram that demonstrates how aggregated results are stored in Tableau''s
    cache:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，表格计算是在初始查询后执行的。这里有一个图表，展示了在 Tableau 缓存中如何存储聚合结果：
- en: '![](img/B16021_06_01.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16021_06_01.png)'
- en: 'Figure 6.1: Table calculations are computed in Tableau''s cache of aggregated
    data'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1：表格计算在 Tableau 的聚合数据缓存中计算
- en: 'Table calculations are performed on the aggregate table of data in Tableau''s
    cache right before the data visualization is rendered. As we''ll see, this is
    important to understand for multiple reasons, including the following:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 表格计算是在 Tableau 缓存中的聚合数据表上执行的，数据可视化渲染之前进行。如我们所见，这对于多个原因很重要，包括以下几点：
- en: '**Aggregation**: Table calculations operate on aggregate data. You cannot reference
    a field in a table calculation without referencing the field as an aggregate.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**聚合**：表格计算作用于聚合数据。在表格计算中，无法引用字段而不将其作为聚合字段来引用。'
- en: '**Filtering**: Regular filters will be applied before table calculations. This
    means that table calculations will only be applied to data returned from the source
    to the cache. You''ll need to avoid filtering any data necessary for the table
    calculation.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**筛选**：常规筛选器将在表格计算之前应用。这意味着表格计算仅会应用于从数据源返回到缓存的数据。你需要避免筛选掉任何对表格计算至关重要的数据。'
- en: '**Table calculation filtering** (sometimes called **late filtering**): Table
    calculations used as filters will be applied after the aggregate results are returned
    from the data source. The order is important: row-level and aggregate filters
    are applied first, the aggregate data is returned to the cache, and then the table
    calculation is applied as a filter that effectively hides data from the view.
    This allows some creative approaches to solving certain kinds of problems that
    we''ll consider in some of the examples later in the chapter.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**表格计算过滤**（有时称为**延迟过滤**）：作为过滤器使用的表格计算将在数据源返回聚合结果后应用。顺序很重要：行级和聚合级过滤器首先应用，聚合数据返回到缓存中，然后应用表格计算作为过滤器，从而有效地将数据从视图中隐藏。这允许一些创造性的方式来解决某些类型的问题，我们将在本章后面的示例中讨论这些问题。'
- en: '**Performance**: If you are using a live connection to an enterprise database
    server, then row-level and aggregate-level calculations will be taking advantage
    of enterprise-level hardware. Table calculations are performed in the cache, which
    means they will be performed on whatever machine is running Tableau. You will
    not likely need to be concerned if your table calculations are operating on a
    dozen or even hundreds of rows of aggregate data, or if you anticipate publishing
    to a powerful Tableau server. However, if you are getting back hundreds of thousands
    of rows of aggregate data on your local machine, then you''ll need to consider
    the performance of your table calculations. At the same time, there are cases
    where table calculations might be used to avoid an expensive filter or calculation
    at the source.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能**：如果你正在使用与企业数据库服务器的实时连接，则行级和聚合级计算将利用企业级硬件。表格计算是在缓存中执行的，这意味着它们将在运行 Tableau
    的机器上执行。如果你的表格计算是在十几行甚至数百行的聚合数据上运行，或者你预计会发布到强大的 Tableau 服务器上，那么你可能不需要担心性能问题。然而，如果你在本地机器上返回数十万行的聚合数据，那么你需要考虑表格计算的性能。同时，也有一些情况，表格计算可以用来避免在数据源处执行昂贵的过滤或计算。'
- en: With this overview of table calculations in mind, let's jump into understanding
    some options for creating table calculations.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 了解了表格计算的概述后，我们来看看一些创建表格计算的选项。
- en: Creating and editing table calculations
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建和编辑表格计算
- en: 'There are several ways to create table calculations in Tableau, including:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Tableau 中，有几种创建表格计算的方法，包括：
- en: Using the drop-down menu for any active field used as a numeric aggregate in
    the view, select **Quick Table Calculation** and then the desired calculation
    type.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在视图中，使用任何作为数值聚合的活动字段，选择**快速表格计算**，然后选择所需的计算类型。
- en: Using the drop-down menu for any active field that is used as a numeric aggregate
    in the view, select **Add Table Calculation**, then select the calculation type,
    and adjust any desired settings.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在视图中，使用任何作为数值聚合的活动字段，选择**添加表格计算**，然后选择计算类型，并调整任何所需的设置。
- en: Creating a calculated field and using one or more table calculation functions
    to write your own custom table calculations.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个计算字段，并使用一个或多个表格计算函数来编写你自己的自定义表格计算。
- en: The first two options create a quick table calculation, which can be edited
    or removed using the drop-down menu on the field and selecting **Edit Table Calculation...**
    or **Clear Table Calculation**. The third option creates a calculated field, which
    can be edited or deleted like any other calculated field.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个选项创建一个快速表格计算，可以通过字段上的下拉菜单编辑或删除，选择**编辑表格计算...** 或 **清除表格计算**。第三个选项创建一个计算字段，可以像编辑或删除其他计算字段一样进行编辑或删除。
- en: A field on a shelf in the view that is using a table calculation, or which is
    a calculated field using table calculation functions, will have a delta symbol
    icon (![](img/B16021_06_001.png)) visible, as follows.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在视图中的架子上使用表格计算的字段，或者使用表格计算函数的计算字段，将会显示增量符号图标（![](img/B16021_06_001.png)），如下所示。
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '![](img/B16021_06_02.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16021_06_02.png)'
- en: 'Figure 6.2: An active field without a table calculation applied'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.2：未应用表格计算的活动字段
- en: 'Following is the active field with a table calculation:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是应用了表格计算的活动字段：
- en: '![](img/B16021_06_03.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16021_06_03.png)'
- en: 'Figure 6.3: An active field with a table calculation applied includes the delta
    symbol'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.3：应用了表格计算的活动字段包括增量符号
- en: Most of the examples in this chapter will utilize text tables/cross tab reports
    as these most closely match the actual aggregate table in the cache. This makes
    it easier to see how the table calculations are working.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的大多数示例将使用文本表/交叉制表报告，因为这些最接近缓存中的实际聚合表。这样可以更容易地看到表格计算的工作方式。
- en: Table calculations can be used in any type of visualization. However, when building
    a view that uses table calculations, especially more complex ones, try using a
    table with all dimensions on the **Rows** shelf and then adding table calculations
    as discrete values on **Rows** to the right of the dimensions. Once you have all
    the table calculations working as desired, you can rearrange the fields in the
    view to give you the appropriate visualization.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 表格计算可用于任何类型的可视化。然而，在构建使用表格计算的视图时，特别是更复杂的视图时，请尝试在**行**架上使用具有所有维度的表格，然后在维度的右侧作为离散值添加表格计算。一旦您的所有表格计算按预期工作，您可以重新排列视图中的字段，以获得适当的可视化效果。
- en: We'll now move from the concept of creating table calculations to some examples.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将从创建表格计算的概念转移到一些示例。
- en: Quick table calculations
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速表格计算
- en: '**Quick table calculations** are predefined table calculations that can be
    applied to fields used as measures in the view. These calculations include common
    and useful calculations such as **Running Total**, **Difference**, **Percent Difference**,
    **Percent of Total**, **Rank**, **Percentile**, **Moving Average**, **YTD Total**
    (year-to-date total), **Compound Growth Rate**, **Year over Year Growth**, and
    **YTD Growth**. You''ll find applicable options on the drop-down list on a field
    used as a measure in the view, as shown in the following screenshot:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速表格计算**是预定义的可应用于视图中用作度量的字段的表格计算。这些计算包括常见且有用的计算，如**Running Total**、**Difference**、**Percent
    Difference**、**Percent of Total**、**Rank**、**Percentile**、**Moving Average**、**YTD
    Total**（年度总计）、**Compound Growth Rate**、**Year over Year Growth**和**YTD Growth**。您可以在视图中用作度量的字段的下拉列表中找到适用的选项，如下图所示：'
- en: '![](img/B16021_06_04.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16021_06_04.png)'
- en: 'Figure 6.4: Using the dropdown, you can create a quick table calculation from
    an aggregate field in the view'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.4：使用下拉菜单，您可以从视图中的聚合字段快速创建表格计算。
- en: 'Consider the following example using the sample `Superstore Sales` data:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下使用示例`Superstore Sales`数据的示例：
- en: '![](img/B16021_06_05.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16021_06_05.png)'
- en: 'Figure 6.5: The first SUM(Sales) field is a normal aggregate. The second has
    a quick table calculation of Running Total applied'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.5：第一个SUM(Sales)字段是普通聚合。第二个已应用了Running Total快速表格计算的SUM(Sales)字段。
- en: Here, **Sales** over time is shown. **Sales** has been placed on the **Rows**
    shelf twice and the second **SUM(Sales)** field has had the **running total**
    quick table calculation applied. Using the quick table calculation meant it was
    unnecessary to write any code.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在此处，显示了随时间变化的销售额。销售额已放置在**行**架上两次，并且第二个**SUM(Sales)**字段已应用了**running total**快速表格计算。使用快速表格计算意味着不需要编写任何代码。
- en: You can actually see the code that the quick table calculations uses by double-clicking
    the table calculation field in the view. This turns it into an ad hoc calculation.
    You can also drag an active field with a quick table calculation applied to the
    data pane, which will turn it into a calculated field that can be reused in other
    views.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过双击视图中的表格计算字段来查看快速表格计算使用的代码。这将其转换为临时计算。您还可以将应用了快速表格计算的活动字段拖动到数据窗格中，这将其转换为可以在其他视图中重复使用的计算字段。
- en: 'The following table demonstrates some of the quick table calculations:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格演示了一些快速表格计算：
- en: '![](img/B16021_06_06.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16021_06_06.png)'
- en: 'Figure 6.6: Sales in the first column is simply the SUM(Sales). The three additional
    columns show various table calculations applied (Running Sum, Difference, Rank)'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.6：第一列中的销售额简单是SUM(Sales)。另外三列显示应用的各种表格计算（Running Sum、Difference、Rank）。
- en: Although it is quite easy to create quick table calculations, it is essential
    to understand some fundamental concepts. We'll take a look at these next, starting
    with the difference between relative and fixed table calculations.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管创建快速表格计算非常容易，但理解一些基本概念是至关重要的。接下来我们将详细查看这些概念，首先从相对和固定表格计算之间的区别开始。
- en: Relative versus fixed
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相对与固定
- en: 'We''ll look at the details shortly, but first it is important to understand
    that table calculations may be computed in one of the two following ways:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 不久我们将详细查看细节，但首先重要的是理解表格计算可能以以下两种方式之一计算：
- en: '**Relative**: The table calculation will be computed relative to the layout
    of the table. They might move across or down the table. Rearranging dimensions
    in a way that changes the table will change the table calculation results. As
    we''ll see, the key for relative table calculations is **scope** and **direction**.
    When you set a table calculation to use a relative computation, it will continue
    to use the same relative scope and direction, even if you rearrange the view.
    (The term here is different from **Relative To** that appears in the UI for some
    quick table calculations.)'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**相对**：表计算将相对于表的布局进行计算。它们可能在表格中横向或纵向移动。重新排列维度以改变表格的方式会改变表计算的结果。正如我们将看到的，相对表计算的关键是**范围**和**方向**。当你设置表计算为使用相对计算时，即使重新排列视图，它也会继续使用相同的相对范围和方向。（这里的术语与UI中某些快速表计算中出现的**相对于**不同。）'
- en: '**Fixed**: The table calculation will be computed using one or more dimensions.
    Rearranging those dimensions in the view will not change the computation of the
    table calculation. Here, the scope and direction remain fixed to one or more dimensions,
    no matter where they are moved within the view. When we talk about fixed table
    calculations, we''ll focus on the concepts of **partitioning** and **addressing**.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**固定**：表计算将使用一个或多个维度进行计算。重新排列视图中的这些维度不会改变表计算的结果。在这种情况下，范围和方向保持固定于一个或多个维度，无论它们在视图中如何移动。当我们讨论固定表计算时，我们将重点讨论**分区**和**地址**的概念。'
- en: 'You can see these concepts in the user interface. The following is the **Table
    Calculation** editor that appears when you select **Edit Table Calculation** from
    the menu of a table calculation field:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在用户界面中看到这些概念。以下是**表计算**编辑器，当你从表计算字段的菜单中选择**编辑表计算**时会出现：
- en: '![](img/B16021_06_07.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16021_06_07.png)'
- en: 'Figure 6.7: The Edit Table Calculation UI demonstrates the difference between
    Relative and Fixed table calculations'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.7：编辑表计算UI展示了相对和固定表计算之间的差异
- en: We'll explore the options and terms in more detail, but for now, notice the
    options that relate to specifying a table calculation that is computed relative
    to rows and columns, and options that specify a table calculation that is computed
    fixed to certain dimensions in the view.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将更详细地探讨这些选项和术语，但现在请注意，相关选项用于指定相对于行和列计算的表计算，以及固定计算到视图中某些维度的表计算选项。
- en: Next, we'll look at **scope** and **direction**, which describe how relative
    table calculations operate.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论**范围**和**方向**，这描述了相对表计算的操作方式。
- en: Scope and direction
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 范围和方向
- en: '**Scope** and **direction** are terms that describe how a table calculation
    is computed relative to the table. Specifically, scope and direction refer to
    the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**范围**和**方向**是描述表计算如何相对于表格计算的术语。具体来说，范围和方向指以下内容：'
- en: '**Scope**: The scope defines the boundaries within which a given table calculation
    can reference other values.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**范围**：范围定义了给定表计算可以引用其他值的边界。'
- en: '**Direction**: The direction defines how the table calculation moves within
    the scope.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方向**：方向定义了表计算在范围内的移动方式。'
- en: You've already seen table calculations being calculated **Table (across)** (the
    running sum of sales over time in *Figure 6.5*) and **Table (down)** (in *Figure
    6.6*). In these cases, the scope was the entire table and the direction was either
    across or down. For example, the running total calculation ran across the entire
    table, adding subsequent values as it moved from left to right.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看过表计算的计算方式**表格（横向）**（*图6.5*中的销售额随时间的累计总和）和**表格（纵向）**（*图6.6*中）。在这些情况下，范围是整个表格，方向是横向或纵向。例如，运行总和计算横向遍历整个表格，逐步加上从左到右的后续值。
- en: To define scope and direction for a table calculation, use the drop-down menu
    for the field in the view and select **Compute Using**. You will get a list of
    options that vary slightly depending on the location of dimensions in the view.
    The first of the options listed allows you to define the scope and direction relative
    to the table. After the option for cell, you will see a list of dimensions present
    in the view. We'll look at those in the next section.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要为表计算定义范围和方向，使用视图中字段的下拉菜单并选择**计算方式**。你将获得一个选项列表，具体取决于维度在视图中的位置，这些选项会略有不同。列表中的第一个选项允许你相对于表格定义范围和方向。在单元格选项之后，你将看到视图中存在的维度列表。我们将在下一节中查看这些维度。
- en: 'The options for scope and direction relative to the table are as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 相对于表格的作用域和方向选项如下：
- en: '**Scope options**: Table, pane, and cells'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**作用域选项**：表格，窗格，单元格'
- en: '**Direction options**: Down, across, down then across, across then down'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方向选项**：纵向，横向，先纵向后横向，先横向后纵向'
- en: 'In order to understand these options, consider the following example:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解这些选项，请参考以下示例：
- en: '![](img/B16021_06_08.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16021_06_08.png)'
- en: 'Figure 6.8: The difference between table, pane, and cell in the view'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.8：视图中表格、窗格和单元格的区别
- en: 'When it comes to the scope of table calculations, Tableau makes the following
    distinctions:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在表格计算的作用域方面，Tableau做出了以下区分：
- en: The **table** is the entire set of aggregate data.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**表格**是整个汇总数据集。'
- en: The **pane** is a smaller section of the entire table. Technically, it is defined
    by the penultimate level of the table; that is, the next-to-last dimension on
    the **Rows** and/or **Columns** shelf defines the pane. In the preceding image,
    you can see that the intersection of **Year** on rows and **Region** on columns
    defines the panes (one of eight is highlighted in the view).
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**窗格**是整个表格的一个较小部分。严格来说，它由表格的倒数第二级定义；也就是说，**行**和/或**列**架上的倒数第二个维度定义了窗格。在前面的图像中，可以看到**年份**在行和**区域**在列的交点定义了窗格（视图中高亮显示了八个窗格中的一个）。'
- en: The **cell** is defined by the lowest level of the table. In this view, the
    intersection of one **Department** within a **Region** and one **Quarter** within
    a **Year** is a single cell (one of 96 is highlighted in the view).
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单元格**由表格的最低级别定义。在这个视图中，一个**区域**内的一个**部门**与一个**年份**内的一个**季度**交点形成一个单元格（视图中高亮显示了96个单元格中的一个）。'
- en: The bounded areas in the preceding screenshot are defined by the scope. Scope
    (and as we'll see, also partition) defines windows within the data that contain
    various table calculations. Window functions, such as `WINDOW_SUM()` in particular,
    work within the scope of these windows.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 前面截图中被界定的区域由作用域定义。作用域（以及我们将看到的，分区）定义了数据中的窗口，这些窗口包含了各种表格计算。窗口函数，特别是`WINDOW_SUM()`，在这些窗口的作用域内工作。
- en: Working with scope and direction
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用作用域和方向
- en: In order to see how scope and direction work together, let's work through a
    few examples. We'll start by creating our own custom table calculations. Create
    a new calculated field named `Index` with the code `Index()`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解作用域和方向是如何协同工作的，让我们通过一些例子来演示。我们将从创建自定义表格计算开始。创建一个名为`Index`的新计算字段，代码为`Index()`。
- en: '`Index()` is a table calculation function that starts with a value of `1` and
    increments by one as it moves in a given direction and within a given scope. There
    are many practical uses for `Index()`, but we''ll use it here because it is easy
    to see how it is moving for a given scope and direction.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`Index()`是一个表格计算函数，它从`1`开始，并在给定的方向和作用域内递增。`Index()`有许多实际应用，但我们在这里使用它，因为很容易看到它在给定作用域和方向下的移动。'
- en: 'Create the table as shown in *Figure 6.8*, with **YEAR(Order Date)** and **QUARTER(Order
    Date)** on **Rows** and **Region** and **Department** on **Columns**. Instead
    of placing **Sales** in the view, add the newly created **Index** field to the
    **Text** shelf. Then experiment, using the drop-down menu on the **Index** field
    and select **Compute Using** to cycle through various scope and direction combinations.
    In the following examples, we''ve only kept the **East** and **West** regions
    and two years, **2015** and **2016**:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 创建如*图 6.8*所示的表格，**年份（订单日期）**和**季度（订单日期）**放在**行**上，**区域**和**部门**放在**列**上。不要将**销售额**放入视图中，而是将新创建的**Index**字段添加到**文本**架上。然后，使用**Index**字段上的下拉菜单，选择**计算方式**，以切换不同的作用域和方向组合。在以下示例中，我们只保留了**东部**和**西部**区域以及**2015**年和**2016**年：
- en: '**Table (across)**: This is Tableau''s default when there are columns in the
    table. Notice in the following how **Index** increments across the entire table:![](img/B16021_06_09.png)'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**表格（横向）**：这是Tableau在表格中有列时的默认设置。请注意，以下内容中**Index**是如何在整个表格中横向递增的：![](img/B16021_06_09.png)'
- en: 'Figure 6.9: Table (across)'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 6.9：表格（横向）
- en: '**Table (down)**: When using `table (down)`, **Index** increments down the
    entire table:![](img/B16021_06_10.png)'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**表格（纵向）**：使用`table (down)`时，**Index**在整个表格中按纵向递增：![](img/B16021_06_10.png)'
- en: 'Figure 6.10: Table (down)'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 6.10：表格（纵向）
- en: '**Table (across then down)**: This increments **Index** across the table, then
    steps down, continues to increment across, and repeats for the entire table:![](img/B16021_06_11.png)'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**表格（先横向后纵向）**：这使得**Index**先横向递增，然后向下递增，再继续横向递增，整个表格都按此方式重复：![](img/B16021_06_11.png)'
- en: 'Figure 6.11: Table (across then down)'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 6.11：表（先横向再纵向）
- en: '**Pane (across)**: This defines a boundary for **Index** and causes it to increment
    across until it reaches the pane boundary, at which point the indexing restarts:![](img/B16021_06_12.png)'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**面板（横向）**：这定义了**索引**的边界，并使其横向递增，直到到达面板边界，此时索引会重新开始：![](img/B16021_06_12.png)'
- en: 'Figure 6.12: Pane (across)'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 6.12：面板（横向）
- en: '**Pane (down)**: This defines a boundary for **Index** and causes it to increment
    down until it reaches the pane boundary, at which point the indexing restarts:![](img/B16021_06_13.png)'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**面板（纵向）**：这定义了**索引**的边界，并使其纵向递增，直到到达面板边界，此时索引会重新开始：![](img/B16021_06_13.png)'
- en: 'Figure 6.13: Pane (down)'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 6.13：面板（纵向）
- en: '**Pane (across then down)**: This allows **Index** to increment across the
    pane and continue by stepping down. The pane defines the boundary here:![](img/B16021_06_14.png)'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**面板（先横向再纵向）**：这使得**索引**在面板内横向递增，并继续纵向递增。面板在这里定义了边界：![](img/B16021_06_14.png)'
- en: 'Figure 6.14: Pane (across then down)'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 6.14：面板（先横向再纵向）
- en: You may use scope and direction with any table calculation. Consider how a running
    total or percentage difference would be calculated using the same movement and
    boundaries shown here. Keep experimenting with different options until you feel
    comfortable with how scope and direction work.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将作用域和方向与任何表计算一起使用。考虑一下如何使用相同的移动和边界计算运行总计或百分比差异。继续尝试不同的选项，直到你熟悉作用域和方向的工作原理。
- en: Scope and direction operate relative to the table, so you can rearrange fields,
    and the calculation will continue to work in the same scope and direction. For
    example, you could swap **Year of Order Date** with **Department** and still see
    **Index** calculated according to the scope and direction you defined.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 作用域和方向相对于表格操作，因此你可以重新排列字段，计算仍然会在你定义的相同作用域和方向下进行。例如，你可以将**订单日期年份**与**部门**交换，仍然可以根据你定义的作用域和方向查看**索引**的计算结果。
- en: Next, we'll take a look at the corresponding concept for table calculations
    that are fixed to certain dimensions.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将查看与固定在某些维度上的表计算对应的概念。
- en: Addressing and partitioning
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 寻址和分区
- en: '**Addressing** and **partitioning** are very similar to scope and direction
    but are most often used to describe how table calculations are computed with absolute
    reference to certain fields in the view. With addressing and partitioning, you
    define which dimensions in the view define the addressing (direction) and all
    others define the partitioning (scope).'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**寻址**和**分区**与作用域和方向非常相似，但通常用来描述如何根据视图中某些字段的绝对引用计算表计算。使用寻址和分区时，你定义视图中哪些维度用于寻址（方向），而其他维度则用于分区（作用域）。'
- en: Using addressing and partitioning gives you much finer control because your
    table calculations are no longer relative to the table layout, and you have many
    more options for fine-tuning the scope, direction, and order of the calculations.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 使用寻址和分区可以提供更精细的控制，因为你的表计算不再依赖于表格布局，你有更多的选项来微调计算的作用域、方向和顺序。
- en: To begin to understand how this works, let's consider a simple example. Using
    the preceding view, select **Edit table calculation** from the drop-down menu
    of the **Index** field on **Text**. In the resulting dialog box, check **Department**
    under **Specific Dimensions**.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始理解这个是如何工作的，我们先来看一个简单的例子。在前面的视图中，从**索引**字段的下拉菜单中选择**编辑表计算**。在弹出的对话框中，在**特定维度**下勾选**部门**。
- en: 'The result of selecting **Department** is as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 选择**部门**的结果如下：
- en: '![](img/B16021_06_15.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16021_06_15.png)'
- en: 'Figure 6.15: Setting the table calculation to Compute Using Specific Dimensions
    uses addressing and partitioning'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.15：设置表计算为使用特定维度进行计算，使用了寻址和分区
- en: You'll notice that Tableau is computing **Index** along (in the direction of)
    the checked dimension, **Department**. In other words, you have used **Department**
    for addressing, so each new department increments the index. All other unchecked
    dimensions in the view are implicitly used for partitioning; that is, they define
    the scope or boundaries at which the index function must restart. As we saw with
    scope, these boundaries are sometimes referred to as a window.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，Tableau正在沿着（在）选中的维度**部门**计算**索引**。换句话说，你已使用**部门**进行寻址，因此每个新的部门都会增加索引。视图中所有其他未选中的维度隐式用于分区；也就是说，它们定义了索引功能必须重新开始的作用域或边界。正如我们在作用域中看到的，这些边界有时被称为窗口。
- en: The preceding view looks identical to what you would see if you set **Index**
    to compute using **Pane (across)**. However, there is a major difference. When
    you use **Pane (across)**, **Index** is always computed across the pane, even
    if you rearrange the dimensions in the view, remove some, or add others.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 上述视图看起来与如果你将**索引**设置为基于**面板（横向）**进行计算时相同。但是，它们有一个重大区别。当你使用**面板（横向）**时，**索引**总是沿着面板计算，即使你重新排列视图中的维度，移除某些维度或添加新的维度，**索引**仍然会按面板进行计算。
- en: But when you compute using a dimension for addressing, the table calculation
    will always compute using that dimension. Removing that dimension will break the
    table calculation (the field will turn red with an exclamation mark) and you'll
    need to edit the table calculation via the drop-down menu to adjust the settings.
    If you rearrange dimensions in the view, **Index** will continue to be computed
    along the **Department** dimension.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，当你使用某一维度进行地址计算时，表格计算将始终基于该维度进行计算。移除该维度将导致表格计算无法正常工作（字段会变成红色并显示感叹号），此时你需要通过下拉菜单编辑表格计算以调整设置。如果你在视图中重新排列维度，**索引**将继续沿着**部门**维度进行计算。
- en: 'Here, for example, is the result of clicking the **Swap Rows and Columns**
    button in the toolbar:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，点击工具栏中的**交换行和列**按钮后的结果如下：
- en: '![](img/B16021_06_16.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16021_06_16.png)'
- en: 'Figure 6.16: Swapping Rows and Columns does not change how this table calculation
    was computed as it is fixed to the dimensions rather than the table layout'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.16：交换行和列不会改变该表格计算的计算方式，因为它是固定在维度上的，而不是表格布局上
- en: Notice that **Index** continues to be computed along **Department** even though
    the entire orientation of the table has changed. To complete the following examples,
    we'll undo the swap of rows and columns to return our table to its original orientation.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尽管表格的整体方向发生了变化，**索引**仍然继续沿着**部门**进行计算。为了完成接下来的示例，我们将撤销行和列的交换，恢复表格的原始方向。
- en: Working with addressing and partitioning
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用地址和分区
- en: 'Let''s consider a few other examples of what happens when you add additional
    dimensions. For example, if you check **Quarter of Order Date**, you''ll see Tableau
    highlight a partition defined by **Region** and **Year of Order Date**, with **Index**
    incrementing by the addressing fields of **Quarter of Order Date** and then **Department**:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再看几个添加额外维度后会发生的例子。例如，如果你勾选了**订单日期的季度**，你将看到 Tableau 突出显示一个由**地区**和**订单日期的年份**定义的分区，**索引**将按**订单日期的季度**和**部门**的地址字段递增：
- en: '![](img/B16021_06_17.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16021_06_17.png)'
- en: 'Figure 6.17: Adding dimensions alters the table calculation''s behavior. One
    of the resulting partitions is highlighted'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.17：添加维度改变了表格计算的行为。一个结果分区被突出显示
- en: 'If you were to select **Department** and **Year of Order Date** as the addressing
    of **Index**, you''d see a single partition defined by **Region** and **Quarter**,
    like this:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你选择**部门**和**订单日期的年份**作为**索引**的地址，你将看到一个由**地区**和**季度**定义的单一分区，如下所示：
- en: '![](img/B16021_06_18.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16021_06_18.png)'
- en: 'Figure 6.18: Changing the checked dimensions alters the table calculation''s
    behavior. One of the resulting partitions is highlighted'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.18：更改已选维度改变了表格计算的行为。一个结果分区被突出显示
- en: You'll notice, in this view, that **Index** increments for every combination
    of **Year** and **Department** within the partition of **Quarter** and **Region**.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，在此视图中，**索引**会根据**季度**和**地区**分区内的**年份**和**部门**的每种组合递增。
- en: 'These are a few of the other things to consider when working with addressing
    and partitioning:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在使用地址和分区时需要考虑的其他事项：
- en: You can specify the sort order. For example, if you wanted **Index** to increment
    according to the value of the sum of sales, you could use the drop-down list at
    the bottom of the table calculation editor to define a custom sort.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以指定排序顺序。例如，如果你希望**索引**根据销售总额的值递增，你可以使用表格计算编辑器底部的下拉列表来定义自定义排序。
- en: The **At the Level** option in the edit table calculation dialog box allows
    you to specify a level at which the table calculations are performed. Most of
    the time, you'll leave this set at **Deepest** (which is the same as setting it
    to the bottom-most dimension), but occasionally, you might want to set it at a
    different level if you need to keep certain dimensions from defining the partition
    but need the table calculation to be applied at a higher level. You can also reorder
    the dimensions by dragging and dropping within the checkbox list of **Specific
    Dimensions**.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在编辑表格计算对话框中的**在级别**选项允许您指定执行表格计算的级别。大多数情况下，您将将其保持在**最深层**（这与将其设置为最底层维度相同），但偶尔，如果需要避免某些维度定义分区，但需要在更高层次应用表格计算，您可能希望将其设置为不同的级别。您还可以通过在**特定维度**的复选框列表中拖放来重新排序维度。
- en: The **Restarting Every...** option effectively makes the selected field, and
    all dimensions in the addressing above that selected field, part of the partition,
    but allows you to maintain the fine-tuning of the ordering.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**每次重启...** 选项实际上会使选定字段以及该选定字段上方所有维度成为分区的一部分，但允许您保持对排序的微调。'
- en: Dimensions are the only kinds of fields that can be used in addressing; however,
    a discrete (blue) measure can be used to partition table calculations. To enable
    this, use the drop-down menu on the field and uncheck **Ignore in Table Calculations**.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维度是唯一可以用于寻址的字段类型；然而，离散（蓝色）度量可以用于划分表格计算。要启用此功能，请使用字段上的下拉菜单并取消选中**在表格计算中忽略**。
- en: Take some time to experiment with various options and become comfortable with
    how addressing and partitioning works. Next, we'll look at how to write our own
    custom table calculations.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 花些时间实验各种选项，并熟悉寻址和分区的工作方式。接下来，我们将看看如何编写我们自己的自定义表格计算。
- en: Custom table calculations
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义表格计算
- en: Before we move on to some practical examples, let's briefly discuss how to write
    your own table calculations, instead of using quick table calculations. You can
    see a list of available table calculation functions by creating a new calculation
    and selecting **Table Calculation** from the drop-down list under **Functions**.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始一些实际示例之前，先简要讨论一下如何编写自己的表格计算，而不是使用快速表格计算。您可以通过创建一个新计算，并在**函数**下拉列表中选择**表格计算**来查看可用的表格计算函数列表。
- en: For each of the examples, we'll set **Compute Using** | **Category**. This means
    **Department** will be the partition.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个示例，我们将设置**计算方式** | **类别**。这意味着**部门**将作为分区。
- en: You can think of table calculations broken down into several categories. The
    following table calculations can be combined and even nested just like other functions.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将表格计算分解为几个类别。以下表格计算可以像其他函数一样组合甚至嵌套。
- en: Meta table functions
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 元表格函数
- en: 'These are the functions that give you information about the partitioning and
    addressing. These functions also include **Index**, **First**, **Last**, and **Size**:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是提供有关分区和寻址信息的函数。这些函数还包括**索引**、**第一个**、**最后**和**大小**：
- en: '**Index** gives an increment as it moves along the addressing within the partition.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**索引**给出在分区内寻址时的增量。'
- en: '**First** gives the offset from the first row in the partition, so the first
    row in each partition is **0**, the next row is **-1**, then **-2**, and so on.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第一个**给出分区中第一行的偏移量，因此每个分区中的第一行为**0**，下一行为**-1**，接下来是**-2**，以此类推。'
- en: '**Last** gives the offset to the last row in the partition, so the last row
    in each partition is **0**, the next-to-last row is **1**, then **2** and so on.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最后**给出分区中最后一行的偏移量，因此每个分区中的最后一行为**0**，倒数第二行为**1**，接下来是**2**，以此类推。'
- en: '**Size** gives the size of the partition.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**大小**给出分区的大小。'
- en: 'The following image illustrates the various functions:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图片展示了各种函数：
- en: '![](img/B16021_06_19.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16021_06_19.png)'
- en: 'Figure 6.19: Meta table calculations'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.19：元表格计算
- en: '**Index**, **First**, and **Last** are all affected by scope/partition and
    direction/addressing, while **Size** will give the same result at each address
    of the partition, no matter what direction is specified.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '**索引**、**第一个**和**最后**都受到范围/分区和方向/寻址的影响，而**大小**将在分区的每个地址上给出相同的结果，无论指定了什么方向。'
- en: Lookup and previous value
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查找和前一个值
- en: 'The first of these two functions gives you the ability to reference values
    in other rows, while the second gives you the ability to carry forward values.
    Notice from the following screenshot that direction is very important for these
    two functions:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数中的第一个允许你引用其他行中的值，而第二个允许你将值向前传递。从以下截图可以看出，方向对这两个函数非常重要：
- en: '![](img/B16021_06_20.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16021_06_20.png)'
- en: 'Figure 6.20: Lookup and Previous_Value functions (though Previous_Value includes
    some additional logic described below)'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.20：查找和 Previous_Value 函数（尽管 Previous_Value 包含下面描述的额外逻辑）
- en: Both calculations are computed using an addressing of **Category** (so **Department**
    is the partition).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种计算都是通过**类别**来定位的（因此**部门**是分区）。
- en: Here, we've used the code `Lookup(ATTR([Category]), -1)`, which looks up the
    value of the category in the row offset by `-1` from the current one. The first
    row in each partition gets a `NULL` result from the lookup (because there isn't
    a row before it).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们使用了代码 `Lookup(ATTR([Category]), -1)`，它查找当前行上偏移 `-1` 的类别值。每个分区中的第一行会得到 `NULL`
    结果（因为它之前没有行）。
- en: 'For `Previous_Value`, we used this code:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `Previous_Value`，我们使用了以下代码：
- en: '[PRE1]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Notice that in the first row of each partition, there is no previous value,
    so `Previous_Value()` simply returned what we specified as the default: an empty
    string. This was then concatenated together with a comma and the category in that
    row, giving us the value **Bookcases**.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在每个分区的第一行中，没有前一个值，因此 `Previous_Value()` 仅返回我们指定的默认值：空字符串。然后它与逗号和该行的类别拼接，得到值
    **书柜**。
- en: In the second row, **Bookcases** is the previous value, which gets concatenated
    with a comma and the category in that row, giving us the value **Bookcases, Chairs
    & Chairmats**, which becomes the previous value in the next row. The pattern continues
    throughout the partition and then restarts in the partition defined by the department
    **Office Supplies**.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二行中，**书柜**是前一个值，它与逗号及该行的类别一起拼接，得出值 **书柜, 椅子与椅垫**，然后这个值成为下一行的前一个值。这个模式在整个分区中继续进行，然后在由部门
    **办公用品** 定义的分区中重新开始。
- en: Running functions
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行函数
- en: 'These functions run along direction/addressing and include `Running_Avg()`,
    `Running_Count()`, `Running_Sum()`, `Running_Min()`, and `Running_Max()`, as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数沿方向/定位运行，包括 `Running_Avg()`、`Running_Count()`、`Running_Sum()`、`Running_Min()`
    和 `Running_Max()`，如下所示：
- en: '![](img/B16021_06_21.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16021_06_21.png)'
- en: 'Figure 6.21: Running Functions'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.21：运行函数
- en: Notice that `Running_Sum(SUM[Sales]))` continues to add the sum of sales to
    a running total for every row in the partition. `Running_Min(SUM[Sales]))` keeps
    the value of the sum of sales if it is the smallest value it has encountered so
    far as it moves along the rows of the partition.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`Running_Sum(SUM[Sales]))` 会继续将销售总和加到每个分区行的累计总和中。`Running_Min(SUM[Sales]))`
    在遍历分区中的各行时，会保持遇到的最小销售总和。
- en: Window functions
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 窗口函数
- en: 'These functions operate across all rows in the partition at once and essentially
    aggregate the aggregates. They include `Window_Sum`, `Window_Avg`, `Window_Max`,
    and `Window_Min`, among others, as shown in the following screenshot:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数一次性操作整个分区的所有行，基本上是对聚合结果进行聚合。它们包括 `Window_Sum`、`Window_Avg`、`Window_Max`
    和 `Window_Min` 等，如下截图所示：
- en: '![](img/B16021_06_22.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16021_06_22.png)'
- en: 'Figure 6.22: Examples of Window functions'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.22：窗口函数示例
- en: '`Window_Sum(SUM([Sales])` adds up the sums of sales within the entire window
    (in this case, for all categories within the department). `Window_Max(SUM([Sales])`
    returns the maximum sum of sales within the window.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`Window_Sum(SUM([Sales])` 对整个窗口内的销售额求和（在此情况下，为部门内所有类别的销售额）。`Window_Max(SUM([Sales])`
    返回窗口内销售额的最大总和。'
- en: You may pass optional parameters to window functions to further limit the scope
    of the window. The window will always be limited to, at most, the partition.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以向窗口函数传递可选参数，以进一步限制窗口的范围。窗口始终最多限制在分区内。
- en: Rank functions
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 排名函数
- en: 'These functions provide various ways to rank based on aggregate values. There
    are multiple variations of rank, which allow you to decide how to deal with ties
    and how dense the ranking should be, as shown in the following screenshot:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数提供了基于聚合值的多种排名方式。排名有多种变体，允许你决定如何处理并列项以及排名的密集程度，如下截图所示：
- en: '![](img/B16021_06_23.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16021_06_23.png)'
- en: 'Figure 6.23: Examples of rank functions'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.23：排名函数示例
- en: The `Rank(SUM([Sales])` calculation returns the rank of the sum of sales for
    categories within the department.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`Rank(SUM([Sales]))`计算返回部门内各类别销售额总和的排名。'
- en: Script functions
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 脚本函数
- en: These functions allow integration with the R analytics platform or Python, either
    of which can incorporate simple or complex scripts for everything from advanced
    statistics to predictive modeling. It's beyond the scope of this book to dive
    into all that is possible, but documentation and examples are readily available
    on Tableau's website and from various members of the Tableau community.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数允许与R分析平台或Python集成，任一平台都可以包含从高级统计到预测建模的简单或复杂脚本。深入探讨所有可能的功能超出了本书的范围，但文档和示例可以在Tableau的官网和Tableau社区的各种成员处轻松获取。
- en: 'Bora Beran, for example, has an excellent post here: [https://www.tableau.com/about/blog/2016/11/leverage-power-python-tableau-tabpy-62077](https://www.tableau.com/about/blog/2016/11/leverage-power-python-tableau-tabpy-62077)'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 比如，Bora Beran有一篇很棒的帖子：[https://www.tableau.com/about/blog/2016/11/leverage-power-python-tableau-tabpy-62077](https://www.tableau.com/about/blog/2016/11/leverage-power-python-tableau-tabpy-62077)
- en: The Total function
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Total函数
- en: The `Total` function deserves its own category because it functions a little
    differently from the others. Unlike the other functions that work on the aggregate
    table in the cache, `Total` will re-query the underlying source for all the source
    data rows that make up a given partition. In most cases, this will yield the same
    result as a window function.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`Total`函数值得单独列出，因为它的功能与其他函数略有不同。与在缓存中的聚合表上工作的其他函数不同，`Total`会重新查询构成给定分区的所有源数据行。在大多数情况下，这将产生与窗口函数相同的结果。'
- en: For example, `Total(SUM([Sales]))` gives the same result as `Window_Sum(SUM([Sales]))`,
    but `Total(AVG([Sales]))` will possibly give a different result from `Window_AVG(SUM([Sales]))`
    because `Total` is giving you the actual average of underlying rows, while the
    `Window` function is averaging the sums.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`Total(SUM([Sales]))`给出的结果与`Window_Sum(SUM([Sales]))`相同，但`Total(AVG([Sales]))`可能会与`Window_AVG(SUM([Sales]))`给出的结果不同，因为`Total`给出的是真实的底层行的平均值，而`Window`函数给出的则是各个和的平均值。
- en: In this section, we have looked at a number of table calculation functions.
    These will give you the building blocks to solve all kinds of practical problems
    and answer a great many questions. From ranking to year-over-year comparisons,
    you now have a foundation for success. Let's now move on to some practical examples.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们已经了解了许多表计算函数。这些函数将为你提供解决各种实际问题和回答许多问题的构建模块。从排名到年度比较，你现在已经有了成功的基础。接下来，我们将进入一些实际示例。
- en: Practical examples
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实际例子
- en: Having looked at some of the essential concepts of table calculations, let's
    consider some practical examples. We'll look at several examples, although the
    practical use of table calculations is nearly endless. You can do everything from
    running sums and analyzing year-over-year growth to viewing percentage differences
    between categories, and much more.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了表计算的一些基本概念之后，我们来看一些实际的例子。我们将举几个例子，尽管表计算的实际应用几乎是无穷无尽的。你可以做从累计和分析年度增长到查看各类别之间的百分比差异等等。
- en: Year over year growth
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 年度增长
- en: Often, you may want to compare year over year values. How much has our customer
    base grown over the last year? How did sales in each quarter compare to sales
    in the same quarter last year? These types of question can be answered using **Year
    over Year Growth**.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能经常需要比较年度数据。我们的客户基础在过去一年增长了多少？每个季度的销售额与去年同季度的销售额相比如何？这些问题可以通过**同比增长**来回答。
- en: 'Tableau exposes **Year over Year Growth** as one option in the quick table
    calculations. Here, for example, is a view that demonstrates **Sales** by **Quarter**,
    along with the percentage difference in sales for a quarter compared with the
    previous year:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Tableau将**同比增长**作为快速表计算的一个选项。举个例子，这是一个展示按**季度**划分的**销售额**视图，并展示与去年同季度销售额的百分比差异：
- en: '![](img/B16021_06_24.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16021_06_24.png)'
- en: 'Figure 6.24: Year over year growth of Sales'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.24：销售的同比增长
- en: The second **Sum(Sales)** field has had the **Year over Year Growth** quick
    table calculation applied (and the **Mark** type changed to bar). You'll notice
    the **>4 nulls** indicator in the lower right, alerting you to the fact that there
    are at least four null values (which makes sense as there is no 2016 with which
    to compare quarters in 2017).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个 **Sum(Sales)** 字段应用了 **年度增长** 快速表格计算（并且 **标记** 类型已更改为条形图）。您会注意到右下角有 **>4
    个空值** 的指示符，这提醒您至少有四个空值（因为没有 2016 年可以与 2017 年的季度进行比较，所以这很合理）。
- en: If you filtered out 2017, the nulls would appear in 2018 as table calculations
    can only operate on values present in the aggregated data in the cache. Any regular
    filters applied to the data are applied at the source and the excluded data never
    makes it to the cache.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您过滤掉了 2017 年，空值将出现在 2018 年，因为表格计算只能在缓存中存在的汇总数据上操作。任何应用于数据的常规过滤器都在源头上应用，排除的数据永远不会进入缓存。
- en: 'As easy as it is to build a view like this example, take care, because Tableau
    assumes each year in the view has the same number of quarters. For example, if
    the data for **Q1** in 2017 was not present or filtered out, then the resulting
    view would not necessarily represent what you want. Consider the following, for
    example:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管像这个示例一样构建视图非常简单，但请小心，因为 Tableau 假设视图中的每一年都有相同数量的季度。例如，如果 2017 年的 **Q1** 数据不存在或被过滤掉，那么结果视图可能不会完全符合您的预期。例如，考虑以下情况：
- en: '![](img/B16021_06_25.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16021_06_25.png)'
- en: 'Figure 6.25: Year over year growth of Sales—but it doesn''t work with Q1 missing
    in the first year'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.25：年度销售增长——但如果第一年缺少 Q1，则无法正常工作
- en: The problem here is that Tableau is calculating the quick table calculation
    using an addressing of **Year** and **Quarter** and an *At the Level* of value
    of **Year of Order Date**. This works assuming all quarters are present. However,
    here, the first quarter in **2018** is matched with the first quarter present
    in **2017**, which is really **Q2**. To solve this, you would need to edit the
    table calculation to only use **Year** for addressing. **Quarter** then becomes
    the partition and thus comparisons are done for the correct quarter.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题是，Tableau 使用 **年份** 和 **季度** 作为寻址，并且在 **订单日期年份** 的 *At the Level* 值上计算快速表格计算。这在假设所有季度都存在的情况下有效。然而，在这里，**2018**
    年的第一季度被匹配到了 **2017** 年的第一季度，而实际是 **Q2**。为了解决这个问题，您需要编辑表格计算，仅使用 **年份** 作为寻址。然后，**季度**
    成为分区，比较将会在正确的季度之间进行。
- en: 'An additional issue arises for consideration: what if you don''t want to show
    2017 in the view? Filtering it out will cause issues for 2018\. In this case,
    we''ll look at **table calculation filtering**, or **late filtering**, later in
    this section. Another potential way to remove 2017 but keep access to its data
    values is to right-click the 2017 header in the view and select **Hide**.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要考虑的问题是：如果您不想在视图中显示 2017 年该怎么办？将其过滤掉会导致 2018 年出现问题。在这种情况下，我们将在本节后面介绍 **表格计算过滤**
    或 **延迟过滤**。另一种删除 2017 年但仍然保留其数据值的方法是右键点击视图中的 2017 年标题，并选择 **隐藏**。
- en: Hide is a special command that simply keeps Tableau from rendering data, even
    when it is present in the cache. If you later decide you want to show 2017 after
    hiding it, you can use the menu for the **YEAR(Order Date)** field and select
    **Show Hidden Data**. Alternately, you can use the menu to select **Analysis**
    | **Reveal Hidden Data**.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 隐藏是一个特殊命令，它可以防止 Tableau 渲染数据，即使数据存在于缓存中。如果您在隐藏之后决定重新显示 2017 年，可以使用 **订单日期年份**
    字段的菜单，选择 **显示隐藏数据**。或者，您可以使用菜单选择 **分析** | **显示隐藏数据**。
- en: You may also wish to hide the null indicator in the view. You can do this by
    right-clicking the indicator and selecting **Hide Indicator**. Clicking the indicator
    will reveal options to filter the data or display it as a default value (typically,
    0).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还希望在视图中隐藏空值指示符。您可以通过右键点击指示符并选择 **隐藏指示符** 来实现。点击指示符后，将显示过滤数据或将其作为默认值（通常为 0）的选项。
- en: Year over year growth (or any period over another) is a common analytical question
    which table calculations allow you to answer. Next, let's consider another example
    of table calculations in practice.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 年度增长（或任何周期与另一个周期的比较）是一个常见的分析问题，表格计算可以帮助您回答这个问题。接下来，我们来看一个表格计算实际应用的例子。
- en: Dynamic titles with totals
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态标题与总计
- en: You've likely noticed the titles that are displayed for every view. There are
    also captions that are not shown unless you specifically turn them on (to do this,
    select **Worksheet** | **Show Caption** from the menu).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到每个视图中显示的标题。还有一些标题说明，除非你特别打开它们，否则是不会显示的（要打开这些标题说明，请从菜单中选择**工作表** | **显示标题说明**）。
- en: By default, the title displays the sheet name and captions are hidden, but you
    can show and modify them. At times, you might want to display totals that help
    your end users understand the broad context or immediately grasp the magnitude.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，标题显示的是工作表名称，标题说明被隐藏，但你可以显示并修改它们。有时，你可能希望显示一些总计，以帮助最终用户理解广泛的背景或立即掌握数据的规模。
- en: 'Here, for example, is a view that allows the user to select one or more **Regions**
    and then see **Sales per State** in each **Region**:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，下面是一个视图，允许用户选择一个或多个**Region**，然后查看每个**Region**中各州的**Sales**：
- en: '![](img/B16021_06_26.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16021_06_26.png)'
- en: 'Figure 6.26: Sales per State for two regions'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.26：两个区域的各州销售情况
- en: It might be useful to show a changing number of states as the user selects different
    regions. You might first think to use an aggregation on **State**, such as `Count
    Distinct`. However, if you try showing that in the title, you will always see
    the value `1`. Why? Because the view level of detail is **State** and the distinct
    count of states per state is `1`!
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 显示随着用户选择不同区域而变化的状态数可能会很有用。你可能首先想到对**State**进行聚合，比如使用`Count Distinct`。然而，如果你尝试在标题中显示这个聚合值，你会始终看到值为`1`。为什么？因为视图的详细级别是**State**，每个州的独立状态数是`1`！
- en: 'But there are some options with table calculations that let you further aggregate
    aggregates. Or, you might think of determining the number of values in the table
    based on the size of the window. In fact, here are several possibilities:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，有些表格计算选项可以让你进一步聚合聚合值。或者，你可能会考虑根据窗口的大小来确定表格中的值的数量。实际上，这里有几种可能性：
- en: 'To get the total distinct count: `TOTAL(COUNTD([State]))`'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取总的不同计数：`TOTAL(COUNTD([State]))`
- en: 'To get the sum within the window: `WINDOW_SUM(SUM(1))`'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取窗口内的总和：`WINDOW_SUM(SUM(1))`
- en: 'To get the size of the window: `SIZE()`'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取窗口大小：`SIZE()`
- en: 'You may recall that a window is defined as the boundaries determined by scope
    or partition. Whichever we choose, we want to define the window as the entire
    table. Either a relative computation of `Table (down)` or a fixed computation
    using all of the dimensions would accomplish this. Here is a view that illustrates
    a dynamic title and all three options in the caption:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能记得，窗口是由范围或分区确定的边界所定义的。无论我们选择哪种方式，我们都希望将窗口定义为整个表格。使用`Table (down)`的相对计算或使用所有维度的固定计算都可以实现这一目标。这里是一个展示动态标题和标题说明中三种选项的视图：
- en: '![](img/B16021_06_27.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16021_06_27.png)'
- en: 'Figure 6.27: Various table calculations could be employed to achieve the total
    in the title'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.27：可以使用各种表格计算来实现标题中的总计
- en: This example illustrated how you might use various table calculations to work
    at higher levels of detail, specifically counting all the states in the view.
    This technique will enable you to solve various analytical questions as you use
    Tableau. Let's now turn our attention to another technique that helps solve quite
    a few problems.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例说明了你如何使用各种表格计算在更高的细节层次上工作，特别是计数视图中所有的状态。这项技术将帮助你在使用 Tableau 时解决各种分析问题。现在，让我们转向另一种可以解决许多问题的技术。
- en: Table calculation filtering (late filtering)
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表格计算过滤（延迟过滤）
- en: Let's say you've built a view that allows you to see the percentage of total
    sales for each department. You have already used a quick table calculation on
    the **Sales** field to give you the percent of the total. You've also used **Department**
    as a filter. But this presents a problem.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你构建了一个视图，允许你查看每个部门的总销售额百分比。你已经对**Sales**字段使用了快速表格计算，得到了总销售额的百分比。你还使用了**Department**作为过滤器。但这会带来一个问题。
- en: 'Since table calculations are performed after the aggregate data is returned
    to the cache, the filter on department has already been evaluated at the data
    source and the aggregate rows don''t include any departments excluded by the filter.
    Thus, the percent of the total will always add up to 100%; that is, it is the
    percentage of the filtered total, as shown in the following screenshot:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 由于表格计算是在聚合数据返回到缓存后执行的，因此部门的过滤器已经在数据源中进行了评估，聚合行不包括任何被过滤器排除的部门。因此，总百分比始终会加起来为100%；也就是说，这是过滤后总数的百分比，如下截图所示：
- en: '![](img/B16021_06_28.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16021_06_28.png)'
- en: 'Figure 6.28: When Office Supplies is filtered out, the percentage table calculation
    adds up to 100% for the departments remaining in the view'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.28：当“办公用品”被过滤掉时，百分比表格计算将其余部门的百分比加总为100%
- en: What if you wanted to see the percentage of the total sales for all departments,
    even if you want to exclude some from the display? One option is to use a table
    calculation as a filter.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想看到所有部门的总销售百分比，即使你想排除某些部门的显示，怎么办？一种选择是使用表格计算作为过滤器。
- en: You might create a calculated field called `Department (table calc filter)`
    with the code `LOOKUP(ATTR([Department]), 0)`. The `Lookup()` function makes this
    a table calculation, while `ATTR()` treats **Department** as an aggregation (further
    explanation is provided at the end of this section). The second argument, `0`,
    tells the lookup function not to look backward or forward. Thus, the calculation
    returns all values for **Department**, but as a table calculation result.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会创建一个名为`部门（表格计算过滤器）`的计算字段，代码为`LOOKUP(ATTR([Department]), 0)`。`Lookup()`函数使其成为表格计算，而`ATTR()`将**部门**视为聚合（本节末尾将提供更多解释）。第二个参数`0`告诉查找函数不要向前或向后查找。因此，计算返回所有**部门**的值，但作为表格计算结果。
- en: 'When you place that table calculation on the **Filters** shelf instead of the
    **Department** dimension, then the filter is not applied at the source. Instead,
    all the aggregate data is still stored in the cache and the table calculation
    filter merely *hides* it from the view. Other table calculations, such as **Percent
    of Total**, will still operate on all the data in the cache. In this case, that
    allows the percent of total to be calculated for all departments, even though
    the table calculation filter is hiding one or more, as shown in the following
    screenshot:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将表格计算放置在**过滤器**架上，而不是**部门**维度时，过滤器不会在源头上应用。相反，所有的汇总数据仍然保存在缓存中，而表格计算过滤器仅仅是*隐藏*了视图中的数据。其他表格计算，例如**总计百分比**，仍然会在缓存中的所有数据上进行操作。在这种情况下，即使表格计算过滤器隐藏了一个或多个数据，如下图所示，仍然允许计算所有部门的总百分比：
- en: '![](img/B16021_06_29.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16021_06_29.png)'
- en: 'Figure 6.29: When a table calculation filter is used, all the aggregate data
    is available in the cache for the % of Total Sales to be calculated for all departments'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.29：当使用表格计算过滤器时，缓存中所有的汇总数据都可用于计算所有部门的总销售百分比
- en: You might have noticed the `ATTR` function used. Remember that table calculations
    require aggregate arguments. `ATTR` (which is short for attribute) is a special
    aggregation that returns the value of a field if there is only a single value
    of that field present for a given level of detail or a `*` if there is more than
    one value.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能注意到了`ATTR`函数的使用。记住，表格计算需要聚合的参数。`ATTR`（即属性的缩写）是一种特殊的聚合，当某个字段在给定的详细级别上只有一个值时，它返回该字段的值，如果该字段有多个值，则返回`*`。
- en: To understand this, experiment with a view having both **Department** and **Category**
    on rows. Using the drop-down menu on the active field in the view, change **Category**
    to **Attribute**. It will display as `*` because there is more than one category
    for each department. Then, undo and change **Department** to **Attribute**. It
    will display the department name because there is only one department per category.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解这一点，可以尝试在视图中同时使用**部门**和**类别**作为行。在视图中激活字段的下拉菜单，将**类别**更改为**属性**。由于每个部门都有多个类别，它将显示为`*`。然后，撤销操作并将**部门**更改为**属性**。由于每个类别只有一个部门，它将显示部门名称。
- en: In this example, we've seen how to effectively use table calculations as filters
    when we need other table calculations to operate on all the data in the cache.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们已经看到如何有效地使用表格计算作为过滤器，当我们需要其他表格计算在缓存中的所有数据上操作时。
- en: Summary
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We've covered a lot of concepts surrounding table calculations in this chapter.
    You now have a foundation for using the simplicity of quick table calculations
    and leveraging the power of advanced table calculations. We've looked at the concepts
    of scope and direction as they apply to table calculations that operate relative
    to the row and column layout of the view. We've also considered the related concepts
    of addressing and partitioning as they relate to table calculations that have
    computations fixed to certain dimensions.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经覆盖了许多与表格计算相关的概念。你现在已经具备了使用简单快速表格计算的基础，并能够利用高级表格计算的强大功能。我们讨论了作用域和方向的概念，这些概念适用于相对于视图的行列布局操作的表格计算。我们还考虑了与地址和分区相关的概念，这些概念适用于计算固定在某些维度上的表格计算。
- en: The practical examples we've covered barely scratch the surface of what is possible,
    but should give you an idea of what can be achieved. The kinds of problems that
    can be solved and the diversity of questions that can be answered are almost limitless.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所讨论的实际例子仅仅触及了可能实现的一部分，但应该能让你对可以达成的目标有所了解。能够解决的问题种类以及能够回答的问题的多样性几乎是无穷无尽的。
- en: We'll turn our attention to some lighter topics in the next couple of chapters,
    looking at formatting and design, but we'll certainly see another table calculation
    or two before we're finished!
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几章中，我们将转向一些较轻松的话题，讨论格式化和设计，但在结束之前，我们肯定还会看到一两个表格计算的例子！
