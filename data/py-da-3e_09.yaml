- en: Cleaning Messy Data
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 清理杂乱的数据
- en: Data analysts and scientists spend most of their time cleaning data and pre-processing
    messy datasets. While this activity is less talked about, it is one of the most
    performed activities and one of the most important skills for any data professional.
    Mastering the skill of data cleaning is necessary for any aspiring data scientist.
    Data cleaning and pre-processing is the process of identifying, updating, and
    removing corrupt or incorrect data. Cleaning and pre-processing results in high-quality
    data for robust and error-free analysis. Quality data can beat complex algorithms
    and outperform simple and less complex algorithms. In this context, high quality
    means accurate, complete, and consistent data. Data cleaning is a set of activities
    such as handling missing values, removing outliers, feature encoding, scaling,
    transformation, and splitting.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 数据分析师和科学家大部分时间都在清理数据和预处理杂乱的数据集。虽然这项活动较少被讨论，但它是最常执行的活动之一，也是任何数据专业人士必须具备的重要技能。掌握数据清理技巧是每个有抱负的数据科学家必备的技能。数据清理和预处理是识别、更新和删除损坏或不正确数据的过程。清理和预处理的结果是高质量的数据，能够支持强大且无误的分析。优质数据能够击败复杂的算法，并超越简单和不复杂的算法。在这个背景下，高质量意味着准确、完整和一致的数据。数据清理包括处理缺失值、移除异常值、特征编码、缩放、转换和拆分等一系列活动。
- en: This chapter focuses on data cleaning, manipulation, and wrangling. Data preparation,
    manipulation, wrangling, and munging are all terms for the same thing, and the
    main objective is to clean up the data in order to get valuable insights. We will
    start by exploring employee data and then start filtering the data and handling
    missing values and outliers. After cleaning, we will focus on performing data
    transformation activities such as encoding, scaling, and splitting. We will mostly
    be using `pandas` and `scikit-learn` in this chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点讲解数据清理、处理和整理。数据准备、处理、整理和清洗是同一件事情的不同说法，主要目标是清理数据，以便获得有价值的洞察。我们将从探索员工数据开始，然后过滤数据并处理缺失值和异常值。清理完数据后，我们将集中进行数据转换操作，如编码、缩放和拆分。本章大部分内容将使用`pandas`和`scikit-learn`。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Exploring data
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索数据
- en: Filtering data to weed out the noise
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过滤数据以剔除噪声
- en: Handling missing values
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理缺失值
- en: Handling outliers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理异常值
- en: Feature encoding techniques
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特征编码技术
- en: Feature scaling
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特征缩放
- en: Feature transformation
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特征转换
- en: Feature splitting
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特征拆分
- en: Let's get started!
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The following are the technical requirements for this chapter:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章的技术要求：
- en: You can find the code and the datasets that will be used in this chapter in
    this book's GitHub repository at [https://github.com/PacktPublishing/Python-Data-Analysis-Third-Edition/tree/master/Chapter07](https://github.com/PacktPublishing/Python-Data-Analysis-Third-Edition/tree/master/Chapter07).
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在本书的GitHub仓库中找到本章将使用的代码和数据集，链接为[https://github.com/PacktPublishing/Python-Data-Analysis-Third-Edition/tree/master/Chapter07](https://github.com/PacktPublishing/Python-Data-Analysis-Third-Edition/tree/master/Chapter07)。
- en: All the code is available in the `ch7.ipynb` file.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有代码都可以在`ch7.ipynb`文件中找到。
- en: This chapter uses only one CSV file (`employee.csv`) for practice purposes.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章仅使用一个CSV文件（`employee.csv`）进行练习。
- en: In this chapter, we will use the `pandas` and `scikit-learn` Python libraries,
    so please ensure you have them installed.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用`pandas`和`scikit-learn`这两个Python库，因此请确保你已安装它们。
- en: Exploring data
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索数据
- en: 'In this section, we will explore data by performing **Exploratory Data Analysis**
    (**EDA**). EDA is the most critical and most important component of the data analysis
    process. EDA offers the following benefits:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过进行**探索性数据分析**（**EDA**）来探索数据。EDA是数据分析过程中最关键和最重要的组成部分。EDA带来以下好处：
- en: It provides an initial glimpse of data and its context.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供了数据及其背景的初步了解。
- en: It captures quick insights and identifies the potential drivers from the data
    for predictive analysis. It finds the queries and questions that can be answered
    for decision-making purposes.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以快速捕捉洞察，并识别出数据中可能影响预测分析的潜在驱动因素。它可以发现那些有助于决策的查询和问题。
- en: It assesses the quality of the data and helps us build the road map for data
    cleaning and preprocessing.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它评估数据质量，帮助我们为数据清理和预处理制定路线图。
- en: It finds missing values, outliers, and the importance of features for analysis.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以找到缺失值、异常值，以及分析中各特征的重要性。
- en: EDA uses descriptive statistics and visualization techniques to explore data.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EDA（探索性数据分析）使用描述性统计和可视化技术来探索数据。
- en: In EDA, the first step is to read the dataset. We can read the dataset using
    `pandas`. The `pandas` library offers various options for reading data. It can
    read files in various formats, such as CSV, Excel, JSON, parquet, HTML, and pickle.
    All these methods were covered in the previous chapter. After reading the data,
    we can explore the data. This initial exploration will help us understand the
    data and gain some domain insights. Let's start with the EDA process.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在EDA中，第一步是读取数据集。我们可以使用`pandas`来读取数据集。`pandas`库提供了多种读取数据的选项。它可以读取多种格式的文件，如CSV、Excel、JSON、parquet、HTML和pickle。所有这些方法在前一章节中都有讲解。读取数据后，我们可以对数据进行探索。这一初步探索将帮助我们理解数据并获得一些领域洞察。让我们开始EDA过程吧。
- en: 'First, we will read the `employee.csv` file (you can find this file in the
    `Chapter-7` folder of this book''s GitHub repository at [https://github.com/PacktPublishing/Python-Data-Analysis-Third-Edition/blob/master/Chapter07/employee.csv](https://github.com/PacktPublishing/Python-Data-Analysis-Third-Edition/blob/master/Chapter07/employee.csv)):'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将读取`employee.csv`文件（你可以在本书GitHub仓库的`Chapter-7`文件夹中找到该文件，链接为[https://github.com/PacktPublishing/Python-Data-Analysis-Third-Edition/blob/master/Chapter07/employee.csv](https://github.com/PacktPublishing/Python-Data-Analysis-Third-Edition/blob/master/Chapter07/employee.csv)）：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let''s take a look at the first five records in the file using the `head()`
    method:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`head()`方法查看文件中的前五条记录：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This results in the following output:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![](img/3d02b414-5c80-4d3a-8499-ecaa7ec598c5.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3d02b414-5c80-4d3a-8499-ecaa7ec598c5.png)'
- en: 'Similarly, let''s look at the last five records using the `head()` method:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，让我们使用`head()`方法查看文件中的最后五条记录：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This results in the following output:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![](img/51201083-8298-496b-9d0c-b5ace193c3b1.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](img/51201083-8298-496b-9d0c-b5ace193c3b1.png)'
- en: 'We can check the list of columns using the `columns` attribute:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用`columns`属性查看列的列表：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This results in the following output:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s check out the list of columns by using the shape of the DataFrame by
    using the `shape` attribute:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过使用`shape`属性查看数据框的列列表：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This results in the following output:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As we can see, the dataset has `9` rows and `7` columns.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，数据集包含`9`行和`7`列。
- en: 'We can check the table schema, its columns, rows, data types, and missing values
    in the DataFrame by using the following code:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下代码检查数据框的表模式、列、行、数据类型和缺失值：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This results in the following output:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![](img/166eeb97-d7d1-43f2-ae99-8eeafbbcdcca.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](img/166eeb97-d7d1-43f2-ae99-8eeafbbcdcca.png)'
- en: In the preceding output, you can see that there are 7 columns in the data. Out
    of these 7 columns, 3 columns (age, income, and gender) have missing values. Out
    of these 7 columns, 4 are objects, 2 are floats, and 1 is an integer.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中，你可以看到数据中有7列。在这7列中，有3列（年龄、收入和性别）包含缺失值。这7列中，4列是对象类型，2列是浮动类型，1列是整数类型。
- en: 'Now, let''s take a look at the descriptive statistics of the data by using
    the `describe` function. This function will describe numerical objects. In our
    example, the age, income, and performance scores will describe the count, mean,
    standard deviation, min-max, and the first, second, and third quartiles:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过使用`describe`函数查看数据的描述性统计信息。该函数将描述数值型数据。在我们的例子中，年龄、收入和表现分数将描述计数、均值、标准差、最小值和最大值，以及第一个、第二个和第三个四分位数：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This results in the following output:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![](img/f3817ae7-9822-4147-a125-27a142c0b676.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f3817ae7-9822-4147-a125-27a142c0b676.png)'
- en: In the preceding code block, we have checked the descriptive statistics values
    of the data using the `describe()` function. From these results, we can interpret
    that the employee's age is ranging from 23 to 54 years. Here, the mean age is
    40 years and the median age is 45 years. Similarly, we can draw conclusions for
    income and performance scores. Now that we've described the data, let's learn
    how to filter noise from data.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，我们使用`describe()`函数检查了数据的描述性统计值。从这些结果我们可以解读出员工的年龄范围是从23岁到54岁。在这里，平均年龄是40岁，中位年龄是45岁。同样，我们也可以对收入和表现分数得出类似的结论。现在我们已经描述了数据，让我们来学习如何从数据中过滤噪声。
- en: Filtering data to weed out the noise
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过滤数据以剔除噪声
- en: In the last two decades, the data size of companies and government agencies
    has increased due to digitalization. This also caused an increase in consistency,
    errors, and missing values. Data filtering is responsible for handling such issues
    and optimizing them for management, reporting, and predictions. The filtering
    process boosts the accuracy, relevance, completeness, consistency, and quality
    of the data by processing dirty, messy, or coarse datasets. It is a very crucial
    step for any kind of data management because it can make or break a competitive
    edge of business. Data scientists need to master the skill of data filtering.
    Different kinds of data need different kinds of treatment. That's why a systematic
    approach to data filtering needs to be taken.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的二十年里，随着数字化的发展，企业和政府机构的数据量不断增加。这也导致了一致性、错误和缺失值的增加。数据过滤负责处理这些问题，并优化它们以用于管理、报告和预测。过滤过程通过处理脏数据、杂乱无章的数据或粗糙数据集，提升了数据的准确性、相关性、完整性、一致性和质量。这是任何数据管理中非常关键的步骤，因为它能够决定一个企业的竞争优势。数据科学家需要掌握数据过滤的技巧。不同类型的数据需要不同的处理方法。正因如此，数据过滤需要采取系统化的方法。
- en: In the previous section, we learned about data exploration, while in this section,
    we will learn about data filtering. Data can be filtered either column-wise or
    row-wise. Let's explore them one by one.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们学习了数据探索，而在本节中，我们将学习数据过滤。数据可以按列或按行过滤。我们一一探讨这两种方法。
- en: Column-wise filtration
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 按列过滤
- en: 'In this subsection, we will learnhow to filter column-wise data. We can filter
    columns using the `filter()` method. The `slicing []. filter()` method selects
    the columns when they''re passed as a list of columns. Take a look at the following
    example:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一小节中，我们将学习如何过滤按列排列的数据。我们可以使用`filter()`方法来过滤列数据。`slicing []. filter()`方法在列作为列列表传递时选择这些列。看看下面的例子：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This results in the following output:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生如下输出：
- en: '![](img/acc285e8-6ca1-49dd-84d5-445a40c8fd8f.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](img/acc285e8-6ca1-49dd-84d5-445a40c8fd8f.png)'
- en: 'Similarly, we can also filter columns using slicing. In slicing, a single column
    does not need a list, but when we are filtering multiple columns, then they should
    be on the list. The output of a single column is a pandas Series. If we want the
    output as a DataFrame, then we need to put the name of the single column into
    a list. Take a look at the following example:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们也可以通过切片来过滤列数据。在切片中，单个列不需要列表，但是当我们要过滤多个列时，它们应放在一个列表中。单列的输出是一个pandas Series。如果我们希望输出为DataFrame，则需要将单个列的名称放入列表中。看看下面的例子：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the preceding example, we have selected a single column without passing it
    into the list and the output is a pandas Series.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们选择了单个列而没有将其放入列表中，输出是一个pandas Series。
- en: 'Now, let''s select a single column using a Python list:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用Python列表选择单个列：
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This results in the following output:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生如下输出：
- en: '![](img/f42be3d8-d872-45b4-b40c-c39aa268a364.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f42be3d8-d872-45b4-b40c-c39aa268a364.png)'
- en: As you can see, a single column can be selected using a Python list. The output
    of this filter is a pandas DataFrame with a single column.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，单个列可以使用Python列表进行选择。此过滤的输出是一个包含单列的pandas DataFrame。
- en: 'Now, let''s filter multiple columns from the pandas DataFrame:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们从pandas DataFrame中过滤多个列：
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This results in the following output:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生如下输出：
- en: '![](img/ea038b30-cb77-48f8-bd72-7a063d4a0579.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ea038b30-cb77-48f8-bd72-7a063d4a0579.png)'
- en: As you can see, we have filtered the two columns without using the `filter()`
    function.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们在没有使用`filter()`函数的情况下对两列数据进行了过滤。
- en: Row-wise filtration
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 按行过滤
- en: 'Now, let''s filter row-wise data. We can filter data using indices, slices,
    and conditions. In indices, you have to pass the index of the record, while for
    slicing, we need to pass the slicing range. Take a look at the following example:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来过滤按行排列的数据。我们可以通过索引、切片和条件进行数据过滤。在索引中，你需要传递记录的索引，而在切片中，我们需要传递切片范围。看看下面的例子：
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This results in the following output:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生如下输出：
- en: '![](img/9d16add6-cd38-4581-ab1c-96fc90668c35.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9d16add6-cd38-4581-ab1c-96fc90668c35.png)'
- en: In the preceding example, we have filtered the data based on indexes.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们是基于索引来过滤数据的。
- en: 'The following is an example of filtering data by slicing:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是通过切片过滤数据的例子：
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This results in the following output:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生如下输出：
- en: '![](img/be28f328-311c-4eb3-b66b-68902c7adfff.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/be28f328-311c-4eb3-b66b-68902c7adfff.png)'
- en: 'In condition-based filtration, we have to pass some conditions in square brackets,
    `[ ]`, or brackets, `( )`. For a single value, we use the `==` (double equal to)
    condition, while for multiple values, we use the `isin()` function and pass the
    list of values. Let''s take a look at the following example:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于条件的筛选中，我们必须将一些条件传递给方括号`[ ]`或圆括号`( )`。对于单一值，我们使用`==`（双等于）条件，而对于多个值，我们使用`isin()`函数并传递值的列表。让我们看一下以下示例：
- en: '[PRE15]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This results in the following output:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这将得到以下输出：
- en: '![](img/4f23ef39-6cf0-413a-8d85-64ff83f73846.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4f23ef39-6cf0-413a-8d85-64ff83f73846.png)'
- en: 'In the preceding code, we filtered the department sales in the first line of
    code using `==` (double equal to) as a condition. Now, let''s filter multiple
    columns using the `isin()` function:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们在代码的第一行使用`==`（双等于）作为条件筛选了销售部门。现在，让我们使用`isin()`函数筛选多个列：
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This results in the following output:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这将得到以下输出：
- en: '![](img/9d775a08-dd7b-4a96-9775-284254f7d2a0.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9d775a08-dd7b-4a96-9775-284254f7d2a0.png)'
- en: In the preceding example, we filtered the department sales and finance department
    using the `isin()` function.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们使用`isin()`函数筛选了销售部门和财务部门。
- en: 'Now, let''s look at the `>=` and `<=` conditions for continuous variables.
    We can have single or multiple conditions. Let''s take a look at the following
    example:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下`>=`和`<=`条件，适用于连续变量。我们可以使用单个或多个条件。让我们看一下以下示例：
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This results in the following output:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这将得到以下输出：
- en: '![](img/eb7360aa-658f-4f1c-80a4-429e794ff40c.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eb7360aa-658f-4f1c-80a4-429e794ff40c.png)'
- en: 'In the preceding example, we filtered employees on the basis of their performance
    score (performance_score >=700). Now, let''s filter data using multiple conditions:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们根据员工的绩效评分（performance_score >=700）进行了筛选。现在，让我们使用多个条件来筛选数据：
- en: '[PRE18]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This results in the following output:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这将得到以下输出：
- en: '![](img/ac661fab-a43c-4c91-b0e9-23a07e3b9c75.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ac661fab-a43c-4c91-b0e9-23a07e3b9c75.png)'
- en: 'We can also try the `query()` method. This method queries the columns using
    a boolean expression. Let''s look at an example:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以尝试使用`query()`方法。这个方法使用布尔表达式查询列。让我们看一个例子：
- en: '[PRE19]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This results in the following output:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这将得到以下输出：
- en: '![](img/050ffa66-9c67-4c42-b988-b30fa16c3d76.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/050ffa66-9c67-4c42-b988-b30fa16c3d76.png)'
- en: In the preceding example, we filtered the employees who have performance scores
    less than 500\. Now, let's learn how to handle missing values.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们筛选了绩效分数低于500的员工。现在，让我们学习如何处理缺失值。
- en: Handling missing values
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理缺失值
- en: 'Missing values are the values that are absent from the data. Absent values
    can occur due to human error, privacy concerns, or the value not being filled
    in by the respondent filling in the survey. This is the most common problem in
    data science and the first step of data preprocessing. Missing values affect a
    machine learning model''s performance. Missing values can be handled in the following
    ways:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 缺失值是数据中缺失的值。缺失值可能由于人为错误、隐私问题，或调查填写者未填写该值而出现。这是数据科学中最常见的问题，也是数据预处理的第一步。缺失值会影响机器学习模型的表现。处理缺失值的方法有以下几种：
- en: Drop the missing value records.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除缺失值记录。
- en: Fill in the missing value manually.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动填充缺失值。
- en: Fill in the missing values using the measures of central tendency, such as mean,
    median, and mode. The mean is used to impute the numeric feature, the median is
    used to impute the ordinal feature, and the mode or highest occurring value is
    used to impute the categorical feature.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用集中趋势的测量值填充缺失值，例如均值、中位数和众数。均值用于填充数值特征，中位数用于填充序数特征，而众数或最高频次值用于填充分类特征。
- en: Fill in the most probable value using machine learning models such as regression,
    decision trees, KNNs.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用机器学习模型，如回归、决策树、KNN，填充最可能的值。
- en: It is important to understand that in some cases, missing values will not impact
    the data. For example, driving license numbers, social security numbers, or any
    other unique identification numbers will not impact the machine learning models
    because they can't be used as features in the model.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 需要理解的是，在某些情况下，缺失值不会影响数据。例如，驾驶执照号码、社会保障号码或任何其他唯一的身份证号码不会影响机器学习模型，因为它们无法作为模型中的特征使用。
- en: In the following subsections, we will look at how missing values can be handled
    in more detail. First, we'll learn how to drop missing values.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的子章节中，我们将更详细地了解如何处理缺失值。首先，我们将学习如何删除缺失值。
- en: Dropping missing values
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除缺失值
- en: 'In Python, missing values can be dropped using the `dropna()` function. `dropna`
    takes one argument: `how`. `how` can take two values: `all` or `any`. `any` drops
    certain rows that contain NAN or missing values, while `all` drops all the rows
    contains NAN or missing values:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，缺失值可以使用 `dropna()` 函数删除。`dropna` 接受一个参数：`how`。`how` 可以取两个值：`all`
    或 `any`。`any` 会删除包含 NAN 或缺失值的某些行，而 `all` 会删除包含 NAN 或缺失值的所有行：
- en: '[PRE20]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This results in the following output:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这会产生以下输出：
- en: '![](img/b7ec72c4-477c-4d59-9eb6-a5214c6913f0.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b7ec72c4-477c-4d59-9eb6-a5214c6913f0.png)'
- en: This summarizes the dataset as a dataframe.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这将数据集总结为一个数据框。
- en: Filling in a missing value
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 填充缺失值
- en: 'In Python, missing values can be dropped using the `fillna()` function. The
    `fillna()` function takes one value that we want to fill at the missing place.
    We can fill in the missing values using the mean, median, and mode:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，缺失值可以使用 `fillna()` 函数填充。`fillna()` 函数接受我们希望填充的值来替代缺失值。我们可以使用均值、中位数和众数来填充缺失值：
- en: '[PRE21]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This results in the following output:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这会产生以下输出：
- en: '![](img/9d5464ea-c441-4d9d-9b0d-20a15aed67ca.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9d5464ea-c441-4d9d-9b0d-20a15aed67ca.png)'
- en: 'In the preceding example, the missing values in the age column have been filled
    in with the mean value of the age column. Let''s learn how to fill in the missing
    values using the median:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，年龄列的缺失值已经使用年龄列的均值填充。接下来我们将学习如何使用中位数填充缺失值：
- en: '[PRE22]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This results in the following output:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这会产生以下输出：
- en: '![](img/03216565-ff03-4564-a983-d8d3f062abc7.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/03216565-ff03-4564-a983-d8d3f062abc7.png)'
- en: 'In the preceding example, the missing values in the income column have been
    filled in with the median value of the income column. Let''s learn how to fill
    in missing values using the mode:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，收入列的缺失值已经使用收入列的中位数填充。接下来我们将学习如何使用众数填充缺失值：
- en: '[PRE23]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This results in the following output:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这会产生以下输出：
- en: '![](img/07110f3e-266b-4b0a-ad09-b26324b99100.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](img/07110f3e-266b-4b0a-ad09-b26324b99100.png)'
- en: In the preceding code example, the missing values in the gender column have
    been filled in with the mode value of the gender column. As you have seen, the
    mean, median, and mode help us handle missing values in pandas DataFrames. In
    the next section, we will focus on how to handle outliers.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，性别列的缺失值已经使用性别列的众数进行了填充。正如你所见，均值、中位数和众数帮助我们在 pandas DataFrame 中处理缺失值。在接下来的部分，我们将重点讨论如何处理异常值。
- en: Handling outliers
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理异常值
- en: Outliers are those data points that are distant from most of the similar points
    – in other words, we can say the outliers are entities that are different from
    the crowd. Outliers cause problems when it comes to building predictive models,
    such as long model training times, poor accuracy, an increase in error variance,
    a decrease in normality, and a reduction in the power of statistical tests.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 异常值是那些与大多数相似数据点相距较远的数据点——换句话说，我们可以说，异常值是与大多数数据不同的实体。当建立预测模型时，异常值会引发问题，例如训练时间过长、准确度差、误差方差增大、正态性下降，以及统计检验的效能降低。
- en: 'There are two types of outliers: univariate and multivariate. Univariate outliers
    can be found in single variable distributions, while multivariates can be found
    in n-dimensional spaces. We can detect and handle outliers in the following ways:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 异常值有两种类型：单变量异常值和多变量异常值。单变量异常值可以在单一变量分布中找到，而多变量异常值可以在 n 维空间中找到。我们可以通过以下方法检测和处理异常值：
- en: '**Box Plot**: We can use a box plot to create a bunch of data points through
    quartiles. It groups the data points between the first and third quartile into
    a rectangular box. The box plot also displays the outliers as individual points
    using the interquartile range.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**箱型图**：我们可以使用箱型图通过四分位数生成一组数据点。它将数据点分组在第一四分位数和第三四分位数之间，形成一个矩形框。箱型图还通过四分位距显示异常值作为单独的点。'
- en: '**Scatter Plot**: A scatter plot displays the points (or two variables) on
    the two-dimensional chart. One variable is placed on the x-axis, while the other
    is placed on the y-axis.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**散点图**：散点图在二维图表上展示点（或两个变量）。一个变量放在 x 轴上，另一个变量放在 y 轴上。'
- en: '**Z-Score**: The Z-score is a kind of parametric approach to detecting outliers.
    It assumes a normal distribution of the data. The outlier lies in the tail of
    the normal curve distribution and is far from the mean:'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Z-Score**：Z-Score 是一种检测异常值的参数方法。它假设数据服从正态分布。异常值位于正态曲线分布的尾部，远离均值：'
- en: '![](img/94e69c69-f0e5-4091-b438-416b93b77c12.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](img/94e69c69-f0e5-4091-b438-416b93b77c12.png)'
- en: '**Interquartile Range (IQR)**: IQR is a robust statistical measure of data
    dispersion. It is the difference between the third and first quartile. These quartiles
    can be visualized in a box plot. This is also known as the midspread, the middle
    50%, or H-spread:'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**四分位距 (IQR)**：IQR 是一种稳健的统计数据离散度量。它是第三四分位数与第一四分位数之间的差值。这些四分位数可以通过箱线图可视化。这也被称为中间离差、中间
    50% 或 H-离差：'
- en: '![](img/60d1ecea-dfd3-41bd-a8ca-50b0eb2ce248.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](img/60d1ecea-dfd3-41bd-a8ca-50b0eb2ce248.png)'
- en: '**Percentile**: A percentile is a statistical measure that divides data into
    100 groups of equal size. Its value indicates the percentage of the population
    below that value. For example, the 95th percentile means 95% of people fall under
    this category.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**百分位数**：百分位数是一种统计度量，将数据分为 100 个相等大小的组。它的值表示该值以下的人群百分比。例如，第 95 百分位意味着 95% 的人处于此类别下。'
- en: 'Let''s drop some outliers using standard deviation and the mean:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过标准差和均值来去除一些异常值：
- en: '[PRE24]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This results in the following output:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![](img/1ae1c2b9-ca13-4b8f-af45-3d4e6c245f0a.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1ae1c2b9-ca13-4b8f-af45-3d4e6c245f0a.png)'
- en: 'In the preceding example, we are handling the outliers using standard deviation
    and the mean. We are using ![](img/4a8e21b2-2dfc-4fd4-b71f-83efba392c62.png) as
    the upper limit and ![](img/d88fce77-3079-49f8-9481-b6a4bd758751.png) as the lower
    limit for filtering the outliers. We can also try the percentile values to remove
    the outliers. Let''s take a look at the following example:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们使用标准差和均值来处理异常值。我们使用 ![](img/4a8e21b2-2dfc-4fd4-b71f-83efba392c62.png)
    作为上限，并使用 ![](img/d88fce77-3079-49f8-9481-b6a4bd758751.png) 作为下限来筛选异常值。我们也可以尝试使用百分位数来去除异常值。让我们看一下以下示例：
- en: '[PRE25]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This results in the following output:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![](img/98b31a6c-6ed8-4cfd-9ef2-91ebf8e8f072.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![](img/98b31a6c-6ed8-4cfd-9ef2-91ebf8e8f072.png)'
- en: In the preceding code example, we handled the outliers using percentiles. We
    removed the outliers by using a percentile of 1 for the lower limit and by using
    a percentile of 99 for the upper limit. This helps us handle outliers in pandas
    DataFrames. In the next section, we will focus on how to perform feature encoding.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码示例中，我们通过使用百分位数来处理异常值。我们通过使用 1 的百分位数作为下限，99 的百分位数作为上限来去除异常值。这有助于我们处理 pandas
    DataFrame 中的异常值。在接下来的部分，我们将重点介绍如何进行特征编码。
- en: Feature encoding techniques
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特征编码技术
- en: Machine learning models are mathematical models that required numeric and integer
    values for computation. Such models can't work on categorical features. That's
    why we often need to convert categorical features into numerical ones. Machine
    learning model performance is affected by what encoding technique we use. Categorical
    values range from 0 to N-1 categories.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 机器学习模型是数学模型，需要数值型和整数型数据进行计算。此类模型无法处理类别特征。因此，我们通常需要将类别特征转换为数值型特征。机器学习模型的性能受我们使用的编码技术的影响。类别值的范围从
    0 到 N-1 类。
- en: One-hot encoding
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: One-hot 编码
- en: 'One-hot encoding transforms the categorical column into labels and splits the
    column into multiple columns. The numbers are replaced by binary values such as
    1s or 0s. For example, let''s say that, in the `color` variable, there are three
    categories; that is, `red`, `green`, and `blue`. These three categories are labeled
    and encoded into binary columns, as shown in the following diagram:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: One-hot 编码将类别列转换为标签，并将该列拆分为多个列。数字会被二进制值如 1 或 0 替代。例如，假设在 `color` 变量中有三类，即 `red`、`green`
    和 `blue`。这三类将被标记并编码为二进制列，如下图所示：
- en: '![](img/704e22f0-db8d-4d31-9459-d632d51797fb.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](img/704e22f0-db8d-4d31-9459-d632d51797fb.png)'
- en: 'One-hot encoding can also be performed using the `get_dummies()` function.
    Let''s use the `get_dummies()` function as an example:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: One-hot 编码也可以使用 `get_dummies()` 函数进行。我们以 `get_dummies()` 函数为例：
- en: '[PRE26]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This results in the following output:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![](img/51e5d4fd-f955-4cd3-96be-c331ebaeeba0.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](img/51e5d4fd-f955-4cd3-96be-c331ebaeeba0.png)'
- en: Here, we can see two extra columns, F and M. Both columns are dummy columns
    that were added by the Boolean encoder. We can also perform the same task with
    `OneHotEncoder` from the `scikit-learn` module. Let's look at an example of using
    `OneHotEncoder`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到两个额外的列，F 和 M。这两列是布尔编码器添加的虚拟列。我们也可以使用 `scikit-learn` 模块中的 `OneHotEncoder`
    来执行相同的任务。让我们看一下使用 `OneHotEncoder` 的示例：
- en: '[PRE27]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This results in the following output:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '[PRE28]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In the preceding code example, we imported `OneHotEncoder`, initialized its
    object, and then fit and transformed the model on the gender column. We can see
    that the output array has two columns for female and male employees.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们导入了`OneHotEncoder`，初始化了它的对象，然后对性别列进行了拟合和转换。我们可以看到，输出数组为女性和男性员工各有一列。
- en: Label encoding
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标签编码
- en: 'Label encoding is also known as integer encoding. Integer encoding replaces
    categorical values with numeric values. Here, the unique values in variables are
    replaced with a sequence of integer values. For example, let''s say there are
    three categories: red, green, and blue. These three categories were encoded with
    integer values; that is, `red` is 0, `green` is 1, and `blue` is 2.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 标签编码也被称为整数编码。整数编码将分类值替换为数值。在这里，变量中的唯一值被替换为一系列整数值。例如，假设有三个类别：红色、绿色和蓝色。这三个类别已经用整数值进行了编码；也就是说，`red`是0，`green`是1，`blue`是2。
- en: 'Let''s take a look at the following label encoding example:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个标签编码的例子：
- en: '[PRE29]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This results in the following output:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '[PRE30]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the preceding example, we performed simple label encoding.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们进行了简单的标签编码。
- en: 'In the following example, we are encoding the department column using the `LabelEncoder`
    class. First, we must import and initialize the `LabelEncoder` object and then
    fit and transform the column that we want to encode. Let''s perform the inverse
    transformation on the encoded labels:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下例子中，我们使用`LabelEncoder`类对部门列进行编码。首先，我们必须导入并初始化`LabelEncoder`对象，然后拟合并转换我们想要编码的列。让我们对已编码的标签执行反向转换：
- en: '[PRE31]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This results in the following output:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '[PRE32]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In the preceding example, we reversed the encoding of the encoded values using
    `inverse_transformation()`. We can also use one-hot encoding with numerical variables.
    Here, each unique numeric value is encoded into an equivalent binary variable.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们使用`inverse_transformation()`方法反转了已编码值的编码。我们还可以对数值变量使用独热编码。在这里，每个唯一的数值都被编码为一个等效的二进制变量。
- en: Ordinal encoder
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 序数编码器
- en: Ordinal encoding is similar to label encoding, except there's an order to the
    encoding. The output encoding will start from 0 and end at one less than the size
    of the categories. Let's look at an example containing employee grades such as
    G0, G1, G2, G3, and G4\. These five grades have been encoded with ordinal integer
    values; that is, `G0` is 0, `G1` is 1, `G2` is 2, `G3` is 3, and `G4` is 4\. We
    can define the order of the values as a list and pass it to the category parameter.
    The ordinal encoder uses the integer or numeric values to encode. Here, the integer
    and numeric values are ordinal in nature. This encoding helps machine learning
    algorithms take advantage of this ordinal relationship.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 序数编码与标签编码类似，唯一的区别是编码是有顺序的。输出编码从0开始，到类别数量减1为止。我们来看一个包含员工等级的例子，例如G0、G1、G2、G3和G4。这五个等级已经用序数整数值进行了编码；也就是说，`G0`是0，`G1`是1，`G2`是2，`G3`是3，`G4`是4。我们可以将值的顺序定义为一个列表，并将其传递给类别参数。序数编码器使用整数或数值来进行编码。在这里，整数和数值是有序的。这种编码有助于机器学习算法利用这种序数关系。
- en: 'Let''s take a look at the following `OrdinalEncoder` example:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个`OrdinalEncoder`的例子：
- en: '[PRE33]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This results in the following output:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![](img/0a85a5ae-87a2-47e7-9b6f-75b4814c48ec.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0a85a5ae-87a2-47e7-9b6f-75b4814c48ec.png)'
- en: The preceding example is similar to the `LabelEncoder` example, except for the
    order of the values that were passed when the `OrdinalEncoder` object was initialized.
    In this example, the `categories` parameters were passed alongside the `grade`
    order at the time of initialization.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子与`LabelEncoder`的例子类似，唯一的区别是在初始化`OrdinalEncoder`对象时传递的值的顺序。在这个例子中，`categories`参数与`grade`顺序一起在初始化时传递。
- en: Feature scaling
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特征缩放
- en: In real life, most features have different ranges, magnitudes, and units, such
    as age being between 0-200 and salary being between 0 to thousands or millions.
    From a data analyst or data scientist's point of view, how can we compare these
    features when they are on different scales? High-magnitude features will weigh
    more on machine learning models than lower magnitude features. Thankfully, feature
    scaling or feature normalization can solve such issues.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实生活中，大多数特征有不同的范围、大小和单位，比如年龄在0到200之间，薪资从几千到几百万不等。从数据分析师或数据科学家的角度来看，当这些特征处于不同的尺度时，我们如何进行比较呢？大规模的特征会在机器学习模型中比小规模的特征权重更大。幸运的是，特征缩放或特征归一化可以解决这些问题。
- en: Feature scaling brings all the features to the same level of magnitude. This
    is not compulsory for all kinds of algorithms; some algorithms clearly need scaled
    data, such as those that rely on Euclidean distance measures such as K-nearest
    neighbor and the K-means clustering algorithm.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 特征缩放将所有特征的量级调整到相同水平。这对于所有类型的算法并非强制性的；有些算法显然需要缩放数据，例如那些依赖于欧几里得距离度量的算法，如K近邻算法和K-means聚类算法。
- en: Methods for feature scaling
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特征缩放方法
- en: 'Now, let''s look at the various methods we can use for feature scaling:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下我们可以使用的各种特征缩放方法：
- en: '**Standard Scaling or Z-Score Normalization**: This method computes the scaled
    values of a feature by using the mean and standard deviation of that feature.
    It is best suited for normally distributed data. Suppose [![](img/c70a5dad-c951-4138-b04c-706796d00869.png)]
    is the mean and [![](img/b2a11c1a-d40a-41ce-a8cb-d762bf9132ee.png)] is the standard
    deviation of the feature column. This results in the following formula:'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标准化缩放或Z得分归一化**：该方法通过使用特征的均值和标准差来计算特征的缩放值。它最适用于正态分布的数据。假设[![](img/c70a5dad-c951-4138-b04c-706796d00869.png)]是特征列的均值，[![](img/b2a11c1a-d40a-41ce-a8cb-d762bf9132ee.png)]是标准差。这将导致以下公式：'
- en: '![](img/1438fcd1-7e86-409c-8c14-e034bd0a83ea.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1438fcd1-7e86-409c-8c14-e034bd0a83ea.png)'
- en: 'Let''s take a look at the following standard scaling example:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下以下的标准化缩放示例：
- en: '[PRE34]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This results in the following output:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![](img/b4d91332-cd72-4946-9f97-2c0b19da5675.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b4d91332-cd72-4946-9f97-2c0b19da5675.png)'
- en: Here, we need to import and initialize the `StandardScaler` object. After initialization,
    we must perform fit and transform operations on the column that we want to scale.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们需要导入并初始化`StandardScaler`对象。初始化后，我们必须对要缩放的列执行拟合和转换操作。
- en: '**Min-Max Scaling**: This method linearly transforms the original data into
    the given range. It preserves the relationships between the scaled data and the
    original data. If the distribution is not normally distributed and the value of
    the standard deviation is very small, then the min-max scaler works better since
    it is more sensitive to outliers. Let''s say that [![](img/88f1ca2e-0121-4f60-9263-574826d461ad.png)]
    is the minimum value and [![](img/7d5098d6-0da7-4477-9c34-f6f2646aaffa.png)]is
    the maximum value of a feature column, while ![](img/1d4830e9-dcbc-4692-b7d8-423e060735e3.png)
    and ![](img/a6fc4c91-4f05-4b5f-8486-1a1d98183a7e.png) are the new minimum and
    new maximum. This results in the following formula:'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最小-最大缩放**：该方法将原始数据线性转换为给定范围。它保留了缩放数据与原始数据之间的关系。如果分布不是正态分布，并且标准差值非常小，则最小-最大缩放器效果更好，因为它对异常值更为敏感。假设[![](img/88f1ca2e-0121-4f60-9263-574826d461ad.png)]是特征列的最小值，[![](img/7d5098d6-0da7-4477-9c34-f6f2646aaffa.png)]是最大值，而![](img/1d4830e9-dcbc-4692-b7d8-423e060735e3.png)和![](img/a6fc4c91-4f05-4b5f-8486-1a1d98183a7e.png)是新的最小值和最大值。这将导致以下公式：'
- en: '![](img/a13a857a-ff6e-4795-9e10-df7d5865fd52.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a13a857a-ff6e-4795-9e10-df7d5865fd52.png)'
- en: 'Let''s take a look at the following min-max scaling example:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下以下的最小-最大缩放示例：
- en: '[PRE35]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This results in the following output:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![](img/77655e38-fc1e-40e7-b6cf-e018e3f3f644.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![](img/77655e38-fc1e-40e7-b6cf-e018e3f3f644.png)'
- en: Here, we need to import and initialize the `MinMaxScaler` object. After initialization,
    we, must perform the fit and transform operations on the column that we want to
    scale.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们需要导入并初始化`MinMaxScaler`对象。初始化后，我们必须对要缩放的列执行拟合和转换操作。
- en: '**Robust Scaling**: This method is similar to the min-max scaler method. Instead
    of min-max, this method uses an interquartile range. That''s why it is robust
    to outliers. Suppose ![](img/460af998-c191-4b5d-8e94-ce27f70f91dc.png)and ![](img/47c520a2-9875-422b-9fa7-7d9926f6fb43.png)
    are the first and third quartiles of column x. This results in the following formula:'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**鲁棒缩放**：该方法类似于最小-最大缩放方法。与最小-最大不同，使用的是四分位数范围。因此，它对异常值具有鲁棒性。假设![](img/460af998-c191-4b5d-8e94-ce27f70f91dc.png)和![](img/47c520a2-9875-422b-9fa7-7d9926f6fb43.png)是x列的第一四分位数和第三四分位数。这将导致以下公式：'
- en: '![](img/bed79988-4f47-4f1d-a43e-bd34e33ff648.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bed79988-4f47-4f1d-a43e-bd34e33ff648.png)'
- en: 'Let''s take a look at the following robust scaling example:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下以下的鲁棒缩放示例：
- en: '[PRE36]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This results in the following output:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![](img/098a721a-ae9c-4f03-8d07-f40c52064ae0.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![](img/098a721a-ae9c-4f03-8d07-f40c52064ae0.png)'
- en: Here, we need to import and initialize the `RobustScaler` object. After initialization,
    we must fit and transform the column that we want to scale.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们需要导入并初始化`RobustScaler`对象。初始化后，我们必须对要缩放的列进行拟合和转换操作。
- en: Feature transformation
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特征变换
- en: 'Feature transformation alters features so that they''re in the required form.
    It also reduces the effect of outliers, handles skewed data, and makes the model
    more robust. The following list shows the different kinds of feature transformation:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 特征变换改变特征的形式，使其符合要求。它还减少了异常值的影响，处理了偏态数据，并使模型更加稳健。以下是不同类型的特征变换：
- en: Log transformation is the most common mathematical transformation used to transform
    skewed data into a normal distribution. Before applying the log transform, ensure
    that all the data values ​​only contain positive values; otherwise, this will
    throw an exception or error message.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对数变换是最常用的数学变换，用于将偏态数据转换为正态分布。在应用对数变换之前，确保所有数据值仅包含正值；否则，这会抛出异常或错误信息。
- en: Square and cube transformation has a moderate effect on distribution shape.
    It can be used to reduce left skewness.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平方和立方变换对分布形状有中等的影响。它可以用于减少左偏。
- en: Square and cube root transformation has a fairly strong transformation effect
    on the distribution shape but it is weaker than logarithms. It can be applied
    to right-skewed data.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平方和立方根变换对分布形状有相当强的变换效果，但其效果比对数变换弱。它可以应用于右偏数据。
- en: Discretization can also be used to transform a numeric column or attribute.
    For example, the age of a group of candidates can be grouped into intervals such
    as 0-10, 11-20, and so on. We can also use discretization to assign conceptual
    labels instead of intervals such as youth, adult, and senior.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 离散化也可以用来转换数字列或属性。例如，一组候选人的年龄可以分组为0-10岁、11-20岁等区间。我们还可以使用离散化来分配概念标签，而不是区间，例如青年、成人和老年。
- en: If the feature is right-skewed or positively skewed or grouped at lower values,
    then we can apply the square root, cube root, and logarithmic transformations,
    while if the feature is left-skewed or negative skewed or grouped at higher values,
    then we can apply the cube, square, and so on.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果特征是右偏或正偏，或者在较低值处聚集，那么我们可以应用平方根、立方根和对数变换；而如果特征是左偏或负偏，或者在较高值处聚集，那么我们可以应用立方、平方等变换。
- en: 'Let''s take a look at an example of discretization transformation:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个离散化变换的例子：
- en: '[PRE37]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This results in the following output:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这会产生以下输出：
- en: '![](img/eb1d7b77-c332-45a4-ad61-c18d0418f707.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eb1d7b77-c332-45a4-ad61-c18d0418f707.png)'
- en: In the preceding example, we loaded the dataset and created the `performance_grade()`
    function. The `performance_grade()` function takes the performance score and converts
    it into grades; that is, `A`, `B`, and `C`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们加载了数据集并创建了`performance_grade()`函数。`performance_grade()`函数接受表现分数并将其转换为等级；即`A`、`B`和`C`。
- en: Feature splitting
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特征拆分
- en: Feature splitting helps data analysts and data scientists create more new features
    for modeling. It allows machine learning algorithms to comprehend features and
    uncover potential information for decision-making; for example, splitting name
    features into first, middle, and last name and splitting an address into house
    number, locality, landmark, area, city, country, and zip code.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 特征拆分帮助数据分析师和数据科学家为建模创造更多的新特征。它使机器学习算法能够理解特征并揭示决策过程中的潜在信息；例如，将姓名特征拆分为名、中间名和姓，或将地址拆分为门牌号、地区、地标、区域、城市、国家和邮政编码。
- en: 'Composite features such as string and date columns violate the tidy data principles.
    Feature splitting is a good option if you wish to generate more features from
    a composite feature. We can utilize the components of a column to do this. For
    example, from a date object, we can easily get the year, month, and weekday. These
    features may directly affect the prediction model. There is no rule of thumb when
    it comes to breaking the features into components; this depends on the characteristics
    of the feature:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 诸如字符串和日期列之类的复合特征违反了整洁数据原则。如果你希望从复合特征中生成更多特征，特征拆分是一个不错的选择。我们可以利用列的组件来做到这一点。例如，从一个日期对象中，我们可以轻松获得年份、月份和星期几。这些特征可能直接影响预测模型。拆分特征成组件时没有固定规则；这取决于特征的具体特点：
- en: '[PRE38]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This results in the following output:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这会产生以下输出：
- en: '![](img/9bf00656-9c59-40e1-b7d1-c2d6ec146ee1.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9bf00656-9c59-40e1-b7d1-c2d6ec146ee1.png)'
- en: In the preceding example, we split the name column using the `split()` and `map()`
    functions. The `split()` function splits the name column using a space, while
    the `map()` function assigns the first divided string to the first name and the
    second divided string to the last name.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们使用 `split()` 和 `map()` 函数拆分了姓名列。`split()` 函数使用空格拆分姓名列，而 `map()` 函数将拆分后的第一个字符串分配给名字，将第二个字符串分配给姓氏。
- en: Summary
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we explored data preprocessing and feature engineering with
    Python. This had helped you gain important skills for data analysis. The main
    focus of this chapter was on cleaning and filtering out dirty data. We started
    with EDA and discussed data filtering, handling missing values, and outliers.
    After this, we focused on feature engineering tasks such as transformation, feature
    encoding, feature scaling, and feature splitting. We then explored various methods
    and techniques we can use when it comes to feature engineering.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了使用 Python 进行数据预处理和特征工程。这帮助你获得了数据分析中重要的技能。本章的主要重点是清理和过滤脏数据。我们从 EDA（探索性数据分析）开始，讨论了数据过滤、处理缺失值和异常值。之后，我们重点介绍了特征工程任务，如数据变换、特征编码、特征缩放和特征分割。接着，我们探索了可以用于特征工程的各种方法和技术。
- en: In the next chapter, Chapter 8, *Signal Processing and Time Series*, we will
    focus on the importance of signal processing and time series data in Python. We'll
    start this chapter by analyzing time series data and discussing moving averages,
    autocorrelations, autoregressive models, and ARMA models. Then, we will look at
    signal processing and discuss Fourier transform, spectral transform, and filtering
    on signals.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，第 8 章，*信号处理与时间序列*，我们将重点讨论信号处理和时间序列数据在 Python 中的重要性。我们将从分析时间序列数据开始，讨论移动平均、自相关、回归模型和
    ARMA 模型。然后，我们将研究信号处理，讨论傅里叶变换、谱变换以及信号的滤波。
