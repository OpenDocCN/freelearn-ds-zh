- en: Chapter 4. Complex ArcPy Scripts and Generalizing Functions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。复杂 ArcPy 脚本和泛化函数
- en: In this chapter, we will move from creating simple scripts based on autogenerated
    scripts from ModelBuilder to complex scripts that incorporate advanced Python
    and ArcPy concepts, such as functions. Functions can improve code and save time
    when writing scripts. They are also useful when creating modules or other reusable
    code, allowing for standard programming operations to be scripted and ready for
    future use.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将从基于 ModelBuilder 自动生成的简单脚本创建转向包含高级 Python 和 ArcPy 概念的复杂脚本，例如函数。函数可以在编写脚本时提高代码效率和节省时间。当创建模块或其他可重用代码时，它们也非常有用，允许将标准编程操作脚本化并准备好供将来使用。
- en: 'In this chapter, will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Creating functions to avoid repeating code
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建函数以避免代码重复
- en: Creating helper functions to work with ArcPy limitations
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建辅助函数以处理 ArcPy 的限制
- en: Generalizing functions to make them reusable
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将函数泛化以使其可重用
- en: Python functions–Avoid repeating code
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python 函数–避免代码重复
- en: 'Programming languages share a concept that has aided programmers for decades:
    functions. The idea of a function, loosely speaking, is to create blocks of code
    that will perform an action on a piece of data, transforming it as required by
    the programmer and returning the transformed data back to the main body of code.
    We''ve already been introduced to some of Python''s built-in functions in the
    last few chapters, the `int` function, for instance, will convert a string or
    a floating number into an integer; now it''s time to write our own.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 编程语言共享一个几十年来帮助程序员的观念：函数。从广义上讲，函数的概念是创建代码块，将对数据进行操作，根据程序员的所需对其进行转换，并将转换后的数据返回到代码的主体部分。在前几章中，我们已经介绍了
    Python 的一些内置函数，例如 `int` 函数，它将字符串或浮点数转换为整数；现在是我们编写自己的函数的时候了。
- en: Functions are used because they solve many different needs within programming.
    Functions reduce the need to write repetitive code, which in turn reduces the
    time needed to create a script. They can be used to create ranges of numbers (the
    `range()` function), or to determine the maximum value of a list (the `max` function),
    or to create a SQL statement to select a set of rows from a feature class. They
    can even be copied and used in another script or included as part of a module
    that can be imported into scripts. Function reuse has the added bonus of making
    programming more useful and less of a chore. When a scripter starts writing functions,
    it is a major step towards making programming part of a GIS workflow.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 函数之所以被使用，是因为它们在编程中解决了许多不同的需求。函数减少了编写重复代码的需要，从而减少了创建脚本所需的时间。它们可以用来创建数字范围（`range()`
    函数），或者确定列表的最大值（`max` 函数），或者创建一个 SQL 语句来从要素类中选择一组行。它们甚至可以被复制并用于另一个脚本，或者作为可以导入到脚本中的模块的一部分。函数的重用不仅使编程更有用，而且减少了繁琐的工作。当脚本编写者开始编写函数时，这是将编程作为
    GIS 工作流程一部分的重大步骤。
- en: Technical definition of functions
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数的技术定义
- en: Functions, also called subroutines or procedures in other programming languages,
    are blocks of code that have been designed to either accept input data and transform
    it, or provide data to the main program when called without any input required.
    In theory, functions will only transform data that has been provided to the function
    as a parameter; it should not change any other part of the script that has not
    been included in the function. To make this possible, the concept of namespaces
    is invoked. As discussed in [Chapter 1](ch01.html "Chapter 1. Introduction to
    Python for ArcGIS"), *Introduction to Python for ArcGIS*, namespaces are used
    to isolate variables within a script; variables are either global, and available
    to be used in the main body of a script as well as in a function, or are local
    and only available within a function.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 函数，在其他编程语言中也称为子程序或过程，是一段代码块，其设计目的是接受输入数据并对其进行转换，或者在没有输入要求的情况下调用时，向主程序提供数据。在理论上，函数只会转换提供给函数作为参数的数据；它不应更改函数中未包含的脚本的其他任何部分。为了实现这一点，引入了命名空间的概念。如[第1章](ch01.html
    "第1章。ArcGIS的Python简介")中所述，“ArcGIS的Python简介”，命名空间用于隔离脚本中的变量；变量要么是全局的，可以在脚本的主体以及函数中使用，要么是局部的，仅在函数内部可用。
- en: Namespaces make it possible to use a variable name within a function, and allow
    it to represent a value, while also using the same variable name in another part
    of the script. This becomes especially important when importing modules from other
    programmers; within that module and its functions, the variables that it contains
    might have a variable name that is the same as a variable name within the main
    script.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间使得在函数内部使用变量名成为可能，并允许它表示一个值，同时也在脚本的另一部分使用相同的变量名。当从其他程序员那里导入模块时，这一点尤为重要；在该模块及其函数内部，它包含的变量可能具有与主脚本中变量名相同的名称。
- en: In a high-level programming language such as Python, there is built-in support
    for functions, including the ability to define function names and the data inputs
    (also known as parameters). Functions are created using the keyword `def` plus
    a function name, along with parentheses that may or may not contain parameters.
    Parameters can also be defined with default values, so parameters only need to
    be passed to the function when they differ from the default. The values that are
    returned from the function are also easily defined.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在像Python这样的高级编程语言中，有内置对函数的支持，包括定义函数名称和数据输入（也称为参数）的能力。函数是通过使用`def`关键字加上函数名称以及可能包含或不包含参数的括号来创建的。参数也可以定义默认值，因此只有当参数与默认值不同时才需要传递给函数。函数返回的值也容易定义。
- en: A first function
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第一个函数
- en: 'Let''s create a function to get a feel for what is possible when writing functions.
    First, we need to invoke the function by providing the `def` keyword and providing
    a name along with the parentheses. The `firstFunction()` will return a string
    when called:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个函数，以了解编写函数时可能实现的功能。首先，我们需要通过提供`def`关键字和括号内的名称来调用函数。当调用`firstFunction()`时，它将返回一个字符串：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The output is as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Notice that this function has a documentation string or doc string (a simple
    function returning a string) that describes what the function does; this string
    can be called later to find out what the function does, using the `__doc__` internal
    function:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个函数有一个文档字符串或doc字符串（一个简单返回字符串的函数），它描述了函数的功能；这个字符串可以在以后被调用，以了解函数的功能，使用`__doc__`内部函数：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The output is as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The function is defined and given a name, and then the parentheses are added
    followed by a colon. The following lines must then be indented (a good IDE will
    add the indention automatically). The function does not have any parameters, so
    the parentheses are empty. The function then uses the keyword `return` to return
    a value, in this case a string, from the function.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 函数被定义并赋予了一个名称，然后添加括号并跟一个冒号。接下来的行必须进行缩进（一个好的IDE会自动添加缩进）。该函数没有任何参数，因此括号是空的。然后函数使用`return`关键字从函数返回一个值，在这种情况下是一个字符串。
- en: 'Next, the function is called by adding parentheses to the function name. When
    it is called, it will do what it has been instructed to do: return the string.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，通过在函数名称后添加括号来调用函数。当它被调用时，它将执行它被指示执行的操作：返回一个字符串。
- en: Functions with parameters
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 带参数的函数
- en: 'Now let''s create a function that accepts parameters and transforms them as
    needed. This function will accept a number and multiply it by 3:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个接受参数并根据需要转换它们的函数。这个函数将接受一个数字并将其乘以3：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The output is as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The function has one flaw, however; there is no assurance that the value passed
    to the function is a number. We need to add a conditional to the function to make
    sure it does not throw an exception:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，该函数有一个缺点；无法保证传递给函数的值是一个数字。我们需要在函数中添加一个条件，以确保它不会抛出异常：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The output is as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE7]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The output is as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE8]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The function now accepts a parameter, checks what type of data it is, and returns
    a multiple of the parameter whether it is an integer or a function. If it is a
    string or some other data type, as shown in the last example, no value is returned.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在函数接受一个参数，检查它的数据类型，并返回参数的倍数，无论是整数还是函数。如果它是一个字符串或其他数据类型，如最后一个示例所示，则不返回任何值。
- en: 'There is one more adjustment to the simple function that we should discuss:
    parameter defaults. By including default values in the definition of the function,
    we avoid having to provide parameters that rarely change. If, for instance, we
    wanted a different multiplier than 3 in the simple function, we would define it
    like this:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该讨论的简单函数的另一个调整是参数默认值。通过在函数定义中包含默认值，我们避免了提供很少更改的参数。例如，如果我们想在简单函数中使用不同于 3 的乘数，我们可以这样定义它：
- en: '[PRE9]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The output is as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE10]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The output is as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE11]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The function will work when only the number to be multiplied is supplied, as
    the multiplier has a default value of 3\. However, if we need another multiplier,
    the value can be adjusted by adding another value when calling the function. Note
    that the second value doesn't have to be a number as there is no type checking
    on it. Also, the default value(s) in a function must follow the parameters with
    no defaults (or all parameters can have a default value and the parameters can
    be supplied to the function in order or by name).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当只提供要乘以的数字时，该函数将正常工作，因为乘数默认值为 3。然而，如果我们需要另一个乘数，可以在调用函数时添加另一个值来调整其值。请注意，第二个值不必是数字，因为它没有类型检查。此外，函数中的默认值（s）必须跟在无默认值的参数之后（或者所有参数都可以有默认值，并且可以按顺序或按名称向函数提供参数）。
- en: These simple functions combine many of the concepts that we discussed in earlier
    chapters, including built-in functions such as `type`, `conditionals`, `parameters`,
    `parameter defaults`, and `function returns`. We can now move on to creating functions
    with ArcPy.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这些简单的函数结合了我们之前章节中讨论的许多概念，包括内置函数如 `type`、`条件语句`、`参数`、`参数默认值` 和 `函数返回值`。我们现在可以继续使用
    ArcPy 创建函数。
- en: Using functions to replace repetitive code
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用函数替换重复代码
- en: One of the main uses of functions is to ensure that the same code does not have
    to be written over and over. Let's return to our example from the last chapter
    and make a function from the script to make it possible to perform the same analysis
    for any bus line in San Francisco.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的主要用途之一是确保相同的代码不必反复编写。让我们回到上一章的例子，并将脚本中的代码转换为函数，以便能够对旧金山的任何公交线路进行相同的分析。
- en: 'The first portion of the script that we could convert into a function is the
    three ArcPy functions. Doing so will allow the script to be applicable to any
    of the stops in the Bus Stop feature class and have an adjustable buffer distance:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将脚本的第一部分转换为函数的是三个 ArcPy 函数。这样做将使脚本适用于 Bus Stop 特征类中的任何站点，并具有可调整的缓冲距离：
- en: '[PRE12]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This function demonstrates how the analysis can be adjusted to accept the input
    and output feature class variables as parameters, along with some new variables.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数演示了如何调整分析以接受输入和输出特征类变量作为参数，以及一些新变量。
- en: The function adds a variable to replace the SQL statement and variables to adjust
    the bus stop, and also tweaks the buffer distance statement so that both the distance
    and the unit can be adjusted. The feature class name variables, defined earlier
    in the script, have all been replaced with local variable names; while the global
    variable names could have been retained, it reduces the portability of the function.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 函数添加了一个变量来替换 SQL 语句，以及变量来调整公交站，并且调整了缓冲距离语句，以便可以调整距离和单位。在脚本中先前定义的特征类名称变量都已替换为局部变量名；虽然全局变量名可以保留，但这会降低函数的可移植性。
- en: 'The next function will accept the result of the `selectBufferIntersect()` function
    and search it using the Search Cursor, passing the results into a dictionary.
    The dictionary will then be returned from the function for later use:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个函数将接受 `selectBufferIntersect()` 函数的结果，并使用搜索游标对其进行搜索，将结果传递到字典中。然后，该函数将返回字典供以后使用：
- en: '[PRE13]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This function only requires one parameter: the feature class returned from
    the `searchBufferIntersect()` function. The results holding dictionary is first
    created, then populated by the search cursor, with the `busStopid` attribute used
    as a key, and the census block population attribute added to a list assigned to
    the key.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数仅需要一个参数：来自 `searchBufferIntersect()` 函数返回的特征类。首先创建一个持有字典的结果，然后通过搜索游标填充，使用
    `busStopid` 属性作为键，并将人口普查区块人口属性添加到分配给该键的列表中。
- en: 'The dictionary, having been populated with sorted data, is returned from the
    function for use in the final function, `createCSV()`. This function accepts the
    dictionary and the name of the output CSV file as a string:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 字典在被填充了排序后的数据后，从函数中返回，用于最终函数`createCSV()`。这个函数接受字典和输出CSV文件的名称作为字符串：
- en: '[PRE14]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The final function creates the CSV using the `csv` module. The name of the file,
    a string, is now a customizable parameter (meaning the script name can be any
    valid file path and text file with the extension `.csv`). The `csvfile` parameter
    is passed to the CSV module's writer method and assigned to the variable `csvwriter`,
    and the dictionary is accessed and processed, and passed as a list to `csvwriter`
    to be written to the `CSV` file. The `csv.writer()` method processes each item
    in the list into the CSV format and saves the final result. Open the `CSV` file
    with Excel or a text editor such as Notepad.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的函数使用`csv`模块创建CSV文件。现在文件名，一个字符串，是一个可定制参数（这意味着脚本名称可以是任何有效的文件路径和具有`.csv`扩展名的文本文件）。`csvfile`参数传递给CSV模块的writer方法，并分配给变量`csvwriter`，然后访问和处理字典，并将其作为列表传递给`csvwriter`以写入`CSV`文件。`csv.writer()`方法将列表中的每个项目处理成CSV格式，并保存最终结果。使用Excel或记事本等文本编辑器打开`CSV`文件。
- en: 'To run the functions, we will call them in the script following the function
    definitions:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行这些函数，我们将在脚本中调用它们，在函数定义之后：
- en: '[PRE15]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, the script has been divided into three functions, which replace the code
    of the first modified script. The modified script looks like this:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，脚本已经被分为三个函数，它们替换了第一个修改后的脚本中的代码。修改后的脚本看起来像这样：
- en: '[PRE16]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Further generalization of the functions, while we have created functions from
    the original script that can be used to extract more data about bus stops in San
    Francisco, our new functions are still very specific to the dataset and analysis
    for which they were created. This can be very useful for long and laborious analysis
    for which creating reusable functions is not necessary. The first use of functions
    is to get rid of the need to repeat code. The next goal is to then make that code
    reusable. Let's discuss some ways in which we can convert the functions from one-offs
    into reusable functions or even modules.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的进一步泛化，虽然我们已经从原始脚本中创建了可以用来提取更多关于旧金山公交车站数据的函数，但我们的新函数仍然非常特定于它们被创建的数据集和分析。这对于那些不需要创建可重用函数的漫长而繁重分析来说非常有用。函数的第一个用途是消除重复代码的需要。接下来的目标是使代码可重用。让我们讨论一些方法，我们可以将这些函数从一次性函数转换为可重用函数甚至模块。
- en: 'First, let''s examine the first function:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们检查第一个函数：
- en: '[PRE17]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This function appears to be pretty specific to the bus stop analysis. It's so
    specific, in fact, that while there are a few ways in which we can tweak it to
    make it more general (that is, useful in other scripts that might not have the
    same steps involved), we should not convert it into a separate function. When
    we create a separate function, we introduce too many variables into the script
    in an effort to simplify it, which is a counterproductive effort. Instead, let's
    focus on ways to generalize the ArcPy tools themselves.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数似乎非常特定于公交车站分析。实际上，它如此特定，以至于尽管有几种方法可以调整它使其更通用（即，在其他可能不涉及相同步骤的脚本中也有用），我们不应该将其转换为单独的函数。当我们创建一个单独的函数时，我们引入了太多的变量到脚本中，试图简化它，这是一种事倍功半的努力。相反，让我们专注于泛化ArcPy工具本身的方法。
- en: The first step will be to split the three ArcPy tools and examine what can be
    adjusted with each of them. The Select tool should be adjusted to accept a string
    as the SQL select statement. The SQL statement can then be generated by another
    function or by parameters accepted at runtime (for example, passed to the script
    by a Script tool, which will be discussed in a later chapter).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步将是将三个ArcPy工具分开，并检查每个工具可以调整什么。Select工具应该调整以接受字符串作为SQL选择语句。SQL语句可以由另一个函数生成，或者通过在运行时接受的参数生成（例如，通过Script工具传递给脚本，这将在下一章中讨论）。
- en: 'For instance, if we wanted to make the script accept multiple bus stops for
    each run of the script (for example, the inbound and outbound stops for each line),
    we could create a function that would accept a list of the desired stops and a
    SQL template, and would return a SQL statement to plug into the Select tool. Here
    is an example of how it would look:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想使脚本接受每次运行脚本时多个公交车站（例如，每条线路的进站和出站车站），我们可以创建一个函数，该函数接受所需车站的列表和SQL模板，并返回一个SQL语句，可以插入到Select工具中。以下是一个示例：
- en: '[PRE18]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The output is as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE20]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This new function, `formatSQL()`, is a very useful function. Let''s review
    what it does by comparing the function to the results following it. The function
    is defined to accept two parameters: a list of values and a SQL template. The
    first local variable is the empty string `sql,` which will be added to using string
    addition. The function is designed to insert the values into the variable `sql`,
    creating a SQL statement by taking the SQL template and using string formatting
    to add them to the template, which in turn is added to the SQL statement string
    (note that `sql +=` is equivelent to `sql = sql +`). Also, an operator (`OR`)
    is used to make the SQL statement inclusive of all data rows that match the pattern.
    This function uses the built-in enumerate function to count the iterations of
    the list; once it has reached the last value in the list, the operator is not
    added to the SQL statement.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新的函数`formatSQL()`是一个非常实用的函数。让我们通过将函数与其后的结果进行比较来回顾它所做的工作。该函数被定义为接受两个参数：一个值列表和一个SQL模板。第一个局部变量是空字符串`sql`，它将通过字符串添加来添加。该函数旨在将值插入到变量`sql`中，通过使用字符串格式化将它们添加到模板中，然后将模板添加到SQL语句字符串中（注意`sql
    +=`等同于`sql = sql +`）。此外，使用一个运算符（`OR`）使SQL语句包含所有匹配该模式的数据行。此函数使用内置的`enumerate`函数来计数列表的迭代次数；一旦它达到了列表中的最后一个值，运算符就不会添加到SQL语句中。
- en: 'Note that we could also add one more parameter to the function to make it possible
    to use an `AND` operator instead of `OR`, while still keeping `OR` as the default:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们还可以向函数添加一个参数，使其能够使用`AND`运算符而不是`OR`，同时仍然保留`OR`作为默认选项：
- en: '[PRE21]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The output is as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE22]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'While it would make no sense to use an `AND` operator on ObjectIDs, there are
    other cases where it would make sense, hence leaving `OR` as the default while
    allowing for `AND`. Either way, this function can now be used to generate our
    bus stop SQL statement for multiple stops (ignoring, for now, the bus signage
    field):'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在ObjectIDs上使用`AND`运算符没有意义，但还有其他情况下使用它是有意义的，因此保留`OR`作为默认选项，同时允许使用`AND`。无论如何，这个函数现在可以用来生成我们的多站公交车站SQL语句（现在忽略公交标志字段）：
- en: '[PRE23]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The output is as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE24]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'However, we can''t ignore the Bus Signage field for the inbound line, as there
    are two starting points for the line, so we will need to adjust the function to
    accept multiple values:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们不能忽视进站线路的公交标志字段，因为该线路有两个起点，所以我们需要调整函数以接受多个值：
- en: '[PRE25]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The output is as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE27]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The slight difference in this function, the asterisk before the data variable,
    allows the values inside the data variable to be correctly formatted into the
    SQL template by exploding the values within the tuple. Notice that the SQL template
    has been created to segregate each conditional by using parentheses. The function(s)
    are now ready for reuse, and the SQL statement is now ready for insertion into
    the Select tool:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的细微差别在于数据变量前的星号，它允许数据变量内的值通过解包元组被正确地格式化到SQL模板中。注意，SQL模板已被创建，通过使用括号来分隔每个条件。现在函数（们）可以重用，SQL语句现在可以插入到选择工具中：
- en: '[PRE28]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Next up is the Buffer tool. We have already taken steps towards making it generalized
    by adding a variable for the distance. In this case, we will only add one more
    variable to it, a unit variable that will make it possible to adjust the buffer
    unit from feet to meter or any other allowed unit. We will leave the other defaults
    alone.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是缓冲工具。我们已经通过添加一个距离变量来使其通用化。在这种情况下，我们只需再添加一个变量，即单位变量，这将使缓冲单元可以从英尺调整到米或其他任何允许的单位。我们将保留其他默认设置不变。
- en: 'Here is an adjusted version of the Buffer tool:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是调整后的缓冲工具版本：
- en: '[PRE29]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Now, both the buffer distance and buffer unit are controlled by a variable defined
    in the previous script, and this will make it easily adjustable if it is decided
    that the distance was not sufficient and the variables might need to be adjusted.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，缓冲距离和缓冲单元都由前一个脚本中定义的变量控制，如果决定距离不足且可能需要调整变量，这将使其易于调整。
- en: 'The next step towards adjusting the ArcPy tools is to write a function, which
    will allow for any number of feature classes to be intersected together using
    the Intersect tool. This new function will be similar to the `formatSQL` functions
    as previous, as they will use string formatting and addition to allow for a list
    of feature classes to be processed into the correct string format for the Intersect
    tool to accept them. However, as this function will be built to be as general
    as possible, it must be designed to accept any number of feature classes to be
    intersected:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 调整ArcPy工具的下一步是编写一个函数，该函数将允许使用交集工具将任意数量的特征类相互交集。这个新函数将与之前的`formatSQL`函数类似，因为它们将使用字符串格式化和附加来允许将特征类列表处理成交集工具可以接受的正确字符串格式。然而，由于这个函数将被构建成尽可能通用，它必须设计成可以接受任意数量的要交集的特征类：
- en: '[PRE30]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The output is as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '[PRE32]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now that we have written the `formatIntersect()` function, all that needs to
    be created is a list of the feature classes to be passed to the function. The
    string returned by the function can then be passed to the Intersect tool:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经编写了`formatIntersect()`函数，需要创建的是要传递给函数的特征类列表。函数返回的字符串然后可以传递给交集工具：
- en: '[PRE33]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Because we avoided creating a function that only fits this script or analysis,
    we now have two (or more) useful functions that can be applied in later analyses,
    and we know how to manipulate the ArcPy tools to accept the data that we want
    to supply to them.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们避免创建仅适用于此脚本或分析的函数，我们现在有两个（或更多）有用的函数可以在后续分析中使用，并且我们知道如何操作ArcPy工具以接受我们想要提供给它们的任何数据。
- en: More generalization of the functions
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数的更一般化
- en: The other functions that we initially created to search the results, and generate
    the spreadsheet of results, can also be manipulated into being more generalized
    with a few tweaks.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最初创建的用于搜索结果并生成结果电子表格的其他函数，也可以通过一些调整变得更加通用。
- en: 'If we want to generate more information about each census block within a distance
    to a bus stop (for example, if we had a census block dataset with income data
    as well as population data), we would pass to the function a list of attributes
    to be extracted from the final feature class. To make this possible, it would
    be necessary to adjust the `createResultDic()` function to accept this list of
    attributes:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要生成关于距离公交站点的每个普查区更详细的信息（例如，如果我们有一个包含收入数据和人口数据的普查区数据集），我们需要将一个属性列表传递给函数，以便从最终的特征类中提取这些属性。为了实现这一点，需要调整`createResultDic()`函数以接受这个属性列表：
- en: '[PRE34]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This new version of the `createResultDic()` function will generate a list of
    lists (that is, the values from each row are contained within a list and are added
    to a master list) for each bus stop, which can then be parsed later by knowing
    the position of each value in the list. This solution is useful when needing to
    sort data into a dictionary.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新的`createResultDic()`函数将为每个公交站生成一个列表的列表（即，每行的值包含在一个列表中，并添加到主列表中），然后可以通过知道列表中每个值的位位置来稍后解析。这种解决方案在需要将数据排序到字典中时很有用。
- en: 'However, this is an unsatisfactory way to sort the results. What if the list
    of fields is not passed on to the dictionary and there is no way of knowing the
    order of the data in the lists? Instead, we want to be able to use the functionality
    of Python dictionaries to sort the data by field name. In this case, we will use
    nested dictionaries to create lists of results accessible by the type of data
    they contain (that is, population, income, or another field):'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这是一种不令人满意的结果排序方式。如果字段列表没有传递给字典，并且无法知道列表中数据的顺序怎么办？相反，我们希望能够使用Python字典的功能按字段名称对数据进行排序。在这种情况下，我们将使用嵌套字典来创建通过它们包含的数据类型（即，人口、收入或其他字段）可访问的结果列表：
- en: '[PRE35]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The output is as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '[PRE37]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In this example, the function is passed as parameters to a feature class, the
    `STOPID`, and the fields to be conglomerated. The `fields` variable is created
    to pass the required fields on to the Search Cursor. The cursor returns each row
    as a tuple; the first member of the tuple is `busStopID`, and the rest of the
    tuple is the data associated with that bus stop. The function then uses a condition
    to assess whether the bus stop has been previously analyzed; if not, it is added
    to the dictionary and assigned a second internal dictionary, which will be used
    to store the results associated with that stop. By using a dictionary, we can
    then sort through the results and assign them to the correct field to which they
    belong.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，函数作为参数传递给一个要素类，`STOPID`以及要合并的字段。`fields`变量被创建出来，以便将所需的字段传递给搜索光标。光标返回每一行作为一个元组；元组的第一个成员是`busStopID`，其余的元组是该公交车站相关联的数据。然后，函数使用一个条件来评估该公交车站是否已经被分析过；如果没有，它将被添加到字典中，并分配一个第二级内部字典，该字典将用于存储与该站点相关的结果。通过使用字典，我们可以然后对结果进行排序，并将它们分配给正确的字段。
- en: The previous example shows the results of requesting data for one particular
    bus stop (`1122023`). As there are two fields passed here, the data has been organized
    into two sets, and the field names are now keys for the internal dictionary. Because
    of this organization, we can now create averages for each field instead of just
    one.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的例子展示了请求一个特定公交车站（`1122023`）的数据结果。由于这里传递了两个字段，数据已经被组织成两组，字段名称现在成为内部字典的键。正因为这种组织方式，我们现在可以为每个字段创建平均值，而不仅仅是单个值。
- en: 'Speaking of averages, we left the job of averaging the results of the search
    cursor analysis to the `createCSV()` function. This should also be avoided, as
    it reduces the usefulness of the `createCSV()` function by adding additional data
    manipulation duties that should be the responsibility of another function. Let''s
    address this issue by adjusting the `createCSV()` function first:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 说到平均值，我们将搜索光标分析结果的平均值计算工作留给了`createCSV()`函数。这也应该避免，因为它通过添加额外的数据处理职责（这些职责应该由另一个函数负责）降低了`createCSV()`函数的有用性。让我们首先通过调整`createCSV()`函数来解决这个问题：
- en: '[PRE38]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This is a stripped down version of the function, but it is infinitely more
    useful. By adjusting the function like this, we are limiting it to only doing
    two things: opening the CSV file and adding a row of data to it. Because we used
    the `ab` mode, if the CSV file exists, we will only be adding data to it instead
    of writing over it (if it doesn''t exist, it will be created). This adding mode
    can be overridden by passing `wb` as the mode, which will generate a new script
    each time.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简化版的函数，但它非常有用。通过这样调整函数，我们限制它只做两件事：打开CSV文件并向其中添加一行数据。因为我们使用了`ab`模式，如果CSV文件存在，我们只会向其中添加数据而不是覆盖它（如果不存在，它将被创建）。这种添加模式可以通过传递`wb`作为模式来覆盖，这将每次生成一个新的脚本。
- en: 'Now we can sort through the results of the analysis, average them, and pass
    them to our new `createCSV` script. To do this, we will iterate through the dictionary
    created by the `createResultDic()` function:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以对分析结果进行排序，计算平均值，并将它们传递给我们的新`createCSV`脚本。为此，我们将遍历由`createResultDic()`函数创建的字典：
- en: '[PRE39]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This last step shows how the CSV file is created: by iterating through the
    data contained in the dictionary and then averaging the values for each bus stop.
    Then, these averages are added to a list that contains the name of each bus stop
    (and the line it belongs to in this instance) and passed to the `createCSV()`
    function to be written into the `CSV` file.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步展示了如何创建CSV文件：通过遍历字典中的数据，然后为每个公交车站的平均值。然后，这些平均值被添加到一个列表中，该列表包含每个公交车站的名称（以及在这个例子中它所属的线路），然后传递给`createCSV()`函数以写入到`CSV`文件中。
- en: 'Here is the final code. Note that I have converted many of the autogenerated
    comments into print statements to give some feedback on the state of the script:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是最终的代码。请注意，我已经将许多自动生成的注释转换成了打印语句，以提供关于脚本状态的反馈：
- en: '[PRE40]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Summary
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed how to take autogenerated code and make it generalized,
    while adding functions that can be reused in other scripts and will make the generation
    of the necessary code components, such as SQL statements, much easier. We also
    addressed when it is best not to go too far with the creation of functions to
    avoid making them too specific.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了如何将自动生成的代码进行泛化，同时添加可以在其他脚本中重用的功能，这将使生成必要的代码组件，如SQL语句，变得更加容易。我们还讨论了何时最好不过度创建函数，以避免使它们过于特定。
- en: In the next chapter, we will investigate the powerful Data Access module and
    its Search Cursors, Update Cursors, and Insert Cursors.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨强大的数据访问模块及其搜索游标、更新游标和插入游标。
