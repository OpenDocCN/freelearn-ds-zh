- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: The Data Project – Prototyping Projects in Streamlit
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据项目——在 Streamlit 中制作原型项目
- en: In the previous chapter, we discussed how to create Streamlit applications that
    are specific to job applications. Another fun application of Streamlit is to try
    out new and interesting data science ideas and create interactive apps for others.
    Some examples of this include applying a new machine learning model to an existing
    dataset, carrying out an analysis of some data uploaded by users, or creating
    an interactive analysis on a private dataset. There are numerous reasons for making
    a project like this, such as personal education or community contribution.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了如何创建特定于工作申请的 Streamlit 应用程序。另一个有趣的 Streamlit 应用是尝试新的、有趣的数据科学想法，并为他人创建互动应用。一些示例包括将新的机器学习模型应用到现有数据集、分析用户上传的数据，或创建一个基于私有数据集的互动分析。制作这样的项目有很多原因，比如个人教育或社区贡献。
- en: In terms of personal education, often, the best way to learn about a new topic
    is to observe how it actually works by applying it to the world around you or
    a dataset that you know closely. For instance, if you try to learn how **Principal
    Component Analysis** works, you can always learn about it in a textbook or watch
    someone else apply it to a dataset. However, I have found that my comprehension
    of a topic goes through the roof when I actually apply it myself in practice.
    Streamlit is perfect for this. It allows you to give new ideas a shot in a responsive,
    fun environment that can be easily shared with others. Learning data science can
    be collaborative, which leads me to the next reason for creating data projects
    in Streamlit.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 就个人教育而言，通常学习新主题的最佳方式是通过将其应用于你周围的世界或你熟悉的数据集来观察它是如何实际工作的。例如，如果你尝试了解**主成分分析**是如何工作的，你总是可以通过教科书学习，或者观看别人将其应用到数据集上。然而，我发现，当我自己亲自实践时，我对一个主题的理解会迅速提高。Streamlit
    非常适合这种方式。它允许你在一个响应式、充满乐趣的环境中尝试新想法，并且可以轻松地与他人分享。学习数据科学是可以协作的，这也引出了我在 Streamlit
    中创建数据项目的下一个原因。
- en: In terms of community contribution, one of the best parts of Streamlit – and,
    frankly, data science – is the growing community around the tools and toys we
    routinely play with. By learning with others and sharing Streamlit apps on Twitter
    ([https://twitter.com/tylerjrichards](https://twitter.com/tylerjrichards)), LinkedIn,
    and the Streamlit forums ([https://discuss.streamlit.io/](https://discuss.streamlit.io/)),
    we can turn away from the zero-sum experience that is taught in most schools and
    universities (where if your classmate gets a good grade, that usually comparatively
    hurts you) and toward a positive-sum experience (where you directly benefit from
    the lessons learned by others).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 就社区贡献而言，Streamlit 的一个最佳特点——坦白说，数据科学的一个最佳特点——是围绕我们日常使用的工具和玩具形成的日益壮大的社区。通过与他人共同学习，并在
    Twitter（[https://twitter.com/tylerjrichards](https://twitter.com/tylerjrichards)）、LinkedIn
    以及 Streamlit 论坛（[https://discuss.streamlit.io/](https://discuss.streamlit.io/)）分享
    Streamlit 应用程序，我们可以摆脱大多数学校和大学教授的零和博弈的经验（在这种情况下，如果你的同学得了好成绩，通常会相对伤害到你），转而迎接一种正和博弈的体验（在这种情况下，你能直接从他人学到的经验中受益）。
- en: To use the previous example, if you created an app that helped you understand
    the statistics behind principal component analysis, sharing that with others will
    probably teach them something too.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 以之前的示例为例，如果你创建了一个帮助你理解主成分分析背后统计学的应用，分享给他人可能也会让他们学到一些东西。
- en: 'In this chapter, we will run through one thorough data project from end to
    end, starting with an idea and ending with the final product. Specifically, we
    will cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将从头到尾完整地进行一个数据项目，开始于一个想法，最终以最终产品结束。具体来说，我们将涵盖以下主题：
- en: Data science ideation
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据科学创意
- en: Collecting and cleaning data
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据收集与清洗
- en: Making a **Minimum Viable Product** (**MVP**)
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建**最小可行产品**（**MVP**）
- en: Iterative improvement
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代改进
- en: Hosting and promotion
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 托管与推广
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In this section, we will utilize the website *Goodreads.com*, which is a popular
    website owned by Amazon that is used to track everything about a user’s reading
    habits, from when they started and finished books to what they would like to read
    next. It is recommended that you first head over to [https://www.goodreads.com/](https://www.goodreads.com/),
    sign up for an account, and explore a little (perhaps you can even add your own
    book lists!).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用*Goodreads.com*，这是一个由亚马逊拥有的流行网站，用于跟踪用户的阅读习惯，从开始和结束的时间到他们下一本想读的书。建议你首先访问[https://www.goodreads.com/](https://www.goodreads.com/)，注册一个账户，并稍作探索（也许你可以添加自己的书单！）。
- en: Data science ideation
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据科学创意
- en: Often, coming up with a new idea for a data science project is the most daunting
    part. You might have numerous doubts. What if I start a project that no one likes?
    What if my data actually doesn’t work out well? What if I can’t think of anything?
    The good news is that if you create projects that you actually do care about and
    would use, then the worst-case scenario is that you have an audience of one! And
    if you send me (`tylerjrichards@gmail.com`) your project, I promise to read it.
    So that makes it an audience of two at the very least.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 经常，想出一个新的数据科学项目的创意是最令人生畏的部分。你可能会有许多疑虑。假如我开始一个没人喜欢的项目怎么办？假如我的数据根本不好用怎么办？假如我想不出任何点子怎么办？好消息是，如果你创建的是你真正关心且愿意使用的项目，那么最糟的情况就是你的观众只有一个！如果你把项目发给我（`tylerjrichards@gmail.com`），我保证会阅读。所以最少的观众人数是两个。
- en: 'Some examples I have either created or observed in the wild include the following:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我自己创建或观察到的一些示例包括：
- en: Recording ping-pong games for a semester to determine the best player with an
    Elo model ([http://www.tylerjrichards.com/Ping_pong.html](http://www.tylerjrichards.com/Ping_pong.html)
    or [https://www.youtube.com/watch?v=uPg7PEdx7WA](https://www.youtube.com/watch?v=uPg7PEdx7WA))
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录一个学期的乒乓球比赛，以通过Elo模型确定最佳选手（[http://www.tylerjrichards.com/Ping_pong.html](http://www.tylerjrichards.com/Ping_pong.html)
    或 [https://www.youtube.com/watch?v=uPg7PEdx7WA](https://www.youtube.com/watch?v=uPg7PEdx7WA)）
- en: Using Large Language Models to chat with your organization’s Snowflake data
    ([https://snowchat.streamlit.app/](https://snowchat.streamlit.app/))
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用大型语言模型与您组织的Snowflake数据进行对话（[https://snowchat.streamlit.app/](https://snowchat.streamlit.app/)）
- en: Analyzing thousands of pizza reviews to find the best NYC pizza near you ([https://towardsdatascience.com/adventures-in-barstools-pizza-data-9b8ae6bb6cd1](https://towardsdatascience.com/adventures-in-barstools-pizza-data-9b8ae6bb6cd1))
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析成千上万的披萨评论，找到你附近的最佳纽约披萨（[https://towardsdatascience.com/adventures-in-barstools-pizza-data-9b8ae6bb6cd1](https://towardsdatascience.com/adventures-in-barstools-pizza-data-9b8ae6bb6cd1)）
- en: Analyzing your reading habits with Goodreads data ([https://goodreads.streamlit.app/](https://goodreads.streamlit.app/))
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Goodreads数据分析你的阅读习惯（[https://goodreads.streamlit.app/](https://goodreads.streamlit.app/)）
- en: Using your Spotify data to dig into your listening history ([https://spotify-history.streamlit.app/](https://spotify-history.streamlit.app/))
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用你的Spotify数据来深入挖掘你的听歌历史（[https://spotify-history.streamlit.app/](https://spotify-history.streamlit.app/)）
- en: While only two of these data projects use Streamlit, as the rest came out before
    the library was released, all of these could have been improved by deploying them
    on Streamlit rather than just uploading them to a Jupyter notebook (the first
    project in the list) or a Word document/HTML file (*the second and third projects*).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管只有这两个数据项目使用了Streamlit，因为其余的项目是在该库发布之前完成的，但所有这些项目都可以通过将它们部署到Streamlit上来改进，而不仅仅是上传到Jupyter笔记本（列表中的第一个项目）或Word文档/HTML文件（*第二个和第三个项目*）。
- en: 'There are many different methods that you can use to come up with your own
    idea for a data project, but the most popular methods generally fall into three
    categories:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多不同的方法可以帮助你想出自己的数据项目创意，但最流行的方法通常可以归为三类：
- en: Finding data that only you could gather (for example, your friend’s ping-pong
    games)
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寻找只有你能够收集到的数据（例如，你朋友的乒乓球比赛）
- en: Finding data that you care about (for example, Spotify’s reading data)
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寻找你关心的数据（例如，Spotify的阅读数据）
- en: Thinking of an analysis/app you wish existed to solve a problem you have and
    executing it (for example, hostel Wi-Fi analysis or finding the best pizza near
    you in NYC)
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 想到一个你希望存在的分析/应用程序来解决你的问题，并付诸实践（例如，宿舍Wi-Fi分析或在纽约市找到最佳披萨）
- en: You can try one of these or start with another idea that you have already. The
    best method is the one that works best for you! For this chapter, we will walk
    through and recreate the Goodreads Streamlit app, in depth, as an example of a
    data project. You can access it again at [https://goodreads.streamlit.app/](https://goodreads.streamlit.app/).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以尝试这些方法，或从你已有的其他想法开始。最好的方法是最适合你的方法！在本章中，我们将深入演示并重建 Goodreads Streamlit 应用，作为数据项目的示例。你可以通过
    [https://goodreads.streamlit.app/](https://goodreads.streamlit.app/) 再次访问该应用。
- en: 'This app is designed to scrape a user’s Goodreads history and create a set
    of graphs to inform them about their reading habits since they started using Goodreads.
    The sets of graphs should be similar to the following screenshot:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应用程序旨在抓取用户的 Goodreads 历史记录，并生成一组图表，向用户展示自开始使用 Goodreads 以来的阅读习惯。生成的图表应与以下截图相似：
- en: '![](img/B18444_11_01.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18444_11_01.png)'
- en: 'Figure 11.1: Examples of Goodreads graphs'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.1：Goodreads 图表示例
- en: I came up with this idea by doing a personal analysis of my book history, and
    then I thought to myself that others might also be interested in this analysis!
    I came away from this project knowing that I wanted to read older books (or books
    that have a longer “book age”). There really was no better reason than that, and
    often, the most fun projects start out that way. To begin, we will work on collecting
    and cleaning the user data that exists on Goodreads.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我是通过对我的书籍历史进行个人分析得出了这个想法，然后我想，其他人可能也会对这种分析感兴趣！通过这个项目，我意识到我想阅读更老的书籍（或者说有更长“书龄”的书籍）。其实没有比这个更好的理由了，而且，往往最有趣的项目就是这样开始的。首先，我们将收集并清洗存在于
    Goodreads 上的用户数据。
- en: Collecting and cleaning data
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据收集与清洗
- en: 'There are two ways in which to get data from Goodreads: through its **Application
    Programming Interface** (**API**), which allows developers to programmatically
    access data about books, and through its manual exporting function. Sadly, Goodreads
    is deprecating its API in the near future and, as of December 2020, does not give
    access to new developers.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 获取 Goodreads 数据有两种方式：通过 **应用程序编程接口** (**API**)，该接口允许开发者以编程方式访问书籍数据，和通过其手动导出功能。遗憾的是，Goodreads
    即将弃用其 API，并且从 2020 年 12 月起，不再向新开发者提供访问权限。
- en: 'The original Goodreads app uses the API, but our version will rely on the manual
    exporting function that the Goodreads website has instead. To get your data, head
    over to [https://www.goodreads.com/review/import](https://www.goodreads.com/review/import)
    and download your own data. If you do not have a Goodreads account, feel free
    to use my personal data for this, which can be found at [https://github.com/tylerjrichards/goodreads_book_demo](https://github.com/tylerjrichards/goodreads_book_demo).
    I have saved my Goodreads data in a file, called `goodreads_history.csv`, in a
    new folder, called `streamlit_goodreads_book`. To make your own folder with the
    appropriate setup, run the following in your terminal:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 原版的 Goodreads 应用使用了 API，但我们的版本将依赖于 Goodreads 网站提供的手动导出功能来获取数据。要获取你的数据，请前往 [https://www.goodreads.com/review/import](https://www.goodreads.com/review/import)
    并下载你的数据。如果你没有 Goodreads 账户，可以随意使用我的个人数据，数据可以在 [https://github.com/tylerjrichards/goodreads_book_demo](https://github.com/tylerjrichards/goodreads_book_demo)
    找到。我已经将我的 Goodreads 数据保存为一个名为 `goodreads_history.csv` 的文件，放在一个新文件夹 `streamlit_goodreads_book`
    中。要创建你自己的文件夹并进行相应设置，请在终端中运行以下命令：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now we are ready to get started. We really have no idea what this data looks
    like or what is in this dataset, so our first steps are to do the following:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好开始了。我们实际上不知道这些数据是什么样子，也不知道数据集中包含了什么，所以我们的第一步是做以下几件事：
- en: Put titles and an explanation at the top of our app.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用程序顶部添加标题和说明。
- en: Allow the user to upload their own data, or use ours as the default if they
    have no data of their own.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 允许用户上传自己的数据，或者如果他们没有自己的数据，则使用我们的默认数据。
- en: Write the first few rows of data to the app so that we can take a look at it.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将数据的前几行写入应用程序，以便我们查看。
- en: 'The following code block does all of this. Feel free to change the text so
    that your app has your name, and also add links to your profile that people can
    view! At the time of writing, around 10 percent of the traffic to my personal
    website comes from the Streamlit apps I have produced:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块完成了所有这些功能。你可以随意更改文本，使应用显示你的名字，还可以添加人们可以查看的个人资料链接！在撰写本文时，大约 10% 的访问流量来自我制作的
    Streamlit 应用：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, when we run this Streamlit app, we should get an app that looks similar
    to the following screenshot:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们运行这个 Streamlit 应用时，应该得到一个类似于以下截图的界面：
- en: '![](img/B18444_11_02.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18444_11_02.png)'
- en: 'Figure 11.2: The first five rows'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.2：前五行
- en: As you can see, we get a dataset where each book is a unique row. Additionally,
    we get a ton of data about each book, including the title and author, the average
    rating of the book, your rating of the book, the number of pages, and even if
    you have read the book, are planning to read the book, or are in the middle of
    reading the book. The data looks mostly clean but with some weirdness – for instance,
    the data having both a publication year and an original publication year, and
    the fact that the **ISBN** (**International Standard Book Number**) comes in the
    format of *=”1400067820”*, which is just odd. Now that we know more about the
    data at hand, we can switch to trying to build some interesting graphs for users.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们得到了一个数据集，每本书都是一个独立的行。此外，我们还获得了关于每本书的大量数据，包括书名和作者、书籍的平均评分、你给这本书的评分、页数，甚至是你是否读过这本书、是否计划阅读这本书，或是正在阅读这本书。数据看起来大部分是干净的，但也有一些奇怪的地方——例如，数据中既有出版年份，又有原出版年份；以及**ISBN**（**国际标准书号**）以*="1400067820"*的格式出现，这真是有点奇怪。现在我们了解了手头的数据，接下来可以尝试为用户构建一些有趣的图表。
- en: Making an MVP
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 制作MVP
- en: 'Looking at our data, we can start by asking a basic question: what are the
    most interesting questions I can answer with this data? After looking at the data
    and thinking about what information I would want from my Goodreads reading history,
    here are a few questions that I have thought of:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 观察我们的数据，我们可以从一个基本问题开始：我可以用这些数据回答哪些最有趣的问题？在查看数据并思考我想从我的Goodreads阅读历史中获得哪些信息后，以下是我想到的一些问题：
- en: How many books do I read each year?
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我每年读多少本书？
- en: How long does it take for me to finish a book that I have started?
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我开始读一本书后，需要多长时间才能完成它？
- en: How long are the books that I have read?
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我读过的书有多长？
- en: How old are the books that I have read?
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我读过的书有多老？
- en: How do I rate books compared to other Goodreads users?
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我是如何给书评分的，与其他Goodreads用户相比如何？
- en: We can take these questions, figure out how to modify our data to visualize
    them well, and then make the first attempt at creating our product by printing
    out all of the graphs.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以提出这些问题，弄清楚如何修改数据以便更好地可视化它们，然后尝试通过打印出所有图表来创建我们的第一个产品。
- en: How many books do I read each year?
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我每年读多少本书？
- en: 'For the first question about books read per year, we have the **Date Read**
    column with the data presented in the format of *yyyy/mm/dd*. The following code
    block will do the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 关于每年读书数量的第一个问题，我们有**阅读日期**列，数据格式为*yyyy/mm/dd*。以下代码块将执行以下操作：
- en: Convert our column into the datetime format.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们的列转换为日期时间格式。
- en: Extract the year from the **Date Read** column.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**阅读日期**列中提取年份。
- en: Group the books by this column and make a count of books per year.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按此列分组并计算每年书籍的数量。
- en: Graph this using Plotly.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Plotly绘制图形。
- en: 'The following code block does this, starting with the datetime conversion.
    It is important to note here that, as with all things, I didn’t get this right
    on the very first try. In fact, it took me some time to figure out exactly how
    I needed to manage and convert this data. When you create projects of your own,
    do not feel bad if you find that data cleaning and converting takes a long time!
    Very often, it is the hardest step:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块执行此操作，从日期时间转换开始。这里需要特别注意的是，和所有事情一样，我并没有在第一次尝试时就做对。事实上，我花了一些时间才弄清楚如何管理和转换这些数据。当你自己做项目时，如果发现数据清理和转换需要很长时间，不要感到沮丧！这通常是最难的一步：
- en: '[PRE2]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The preceding code block will create the following graph:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码块将创建以下图表：
- en: '![](img/B18444_11_03.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18444_11_03.png)'
- en: 'Figure 11.3: Year Finished bar plot'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.3：完成年份的条形图
- en: We actually made an assumption here – that is, we assumed the year in the **Date
    Read** column represents when we read the book. But what if we start a book in
    the middle of December and finish it on January 2? Or, what if we start a book
    in 2019 but only get a few pages into it, and then pick it back up during 2021?
    We know this will not be a perfect approximation of the number of books read per
    year, but it will be better to express this as the number of books finished per
    year.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，我们在这里做出了一个假设——也就是，我们假设**阅读日期**列中的年份代表我们阅读这本书的年份。但如果我们在12月中旬开始一本书，并在1月2日完成它呢？或者，如果我们在2019年开始读一本书，但只读了几页，然后在2021年重新拿起来继续读呢？我们知道这不会完美地估算每年读的书籍数量，但将其表示为每年完成的书籍数量会更好。
- en: How long does it take for me to finish a book that I have started?
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我需要多长时间才能读完一本已经开始的书？
- en: 'Our next question is about the time it takes for us to finish a book once we
    have started it. To answer this, we need to find the difference between two columns:
    the **Date Read** column and the **Date Added** column. Again, this is going to
    be an approximation, as we do not have the date of when the user started reading
    the book but only when they added the book to Goodreads. Given this, our next
    steps include the following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下一个问题是关于一旦开始读书后，我们需要多长时间才能读完它。为了回答这个问题，我们需要找出两列的差异：**读书日期**列和**添加日期**列。再次提醒，这将是一个近似值，因为我们没有用户开始读书的日期，只知道他们将书添加到
    Goodreads 上的日期。考虑到这一点，我们的下一步包括以下内容：
- en: Convert the two columns into the datetime format.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这两列转换为日期时间格式。
- en: Find the difference between the two columns in days.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找出两列之间的天数差异。
- en: Plot this difference as a histogram.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这个差异绘制为直方图。
- en: 'The following code block starts with the conversion, as we have done previously,
    and then moves through our list of tasks:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块首先进行转换，就像我们之前做的那样，然后继续进行我们的一系列任务：
- en: '[PRE3]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The previous code block can be added to the bottom of your current Streamlit
    app, which, when run, should show a new graph:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码块可以添加到你当前 Streamlit 应用的底部，运行后应该会显示一个新的图表：
- en: '![](img/B18444_11_04.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18444_11_04.png)'
- en: 'Figure 11.4: The days to finish graph'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.4：完成天数图
- en: 'This is not the most helpful graph for my data. It looks as though, at some
    point, I added books that I had read in the past to Goodreads, which show up in
    this chart. We also have a set of books that have not been finished yet or are
    on the to-read bookshelf, which exist as `null` values in this dataset. We can
    do a few things here, such as filtering the dataset to just include books where
    the number of days is positive and filtering the data to only finished books,
    which the following code block does:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这张图表对我的数据帮助不大。看起来，在某个时候，我把以前读过的书添加到了 Goodreads 上，这些书在这个图表中显示了出来。我们还有一组未读完或在待读书架上的书，它们在这个数据集中显示为`null`值。我们可以做一些调整，例如过滤数据集，只包含那些天数为正的书，或者仅过滤出已读完的书，这段代码块就是这样做的：
- en: '[PRE4]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This change in our code makes the graph significantly better. It makes some
    assumptions, but it also provides a more accurate analysis. The finished graph
    can be viewed in the following screenshot:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们代码中的这个改动使得图表大大改善。它做了一些假设，但也提供了更准确的分析。完成的图表可以在以下截图中查看：
- en: '![](img/B18444_11_05.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18444_11_05.png)'
- en: 'Figure 11.5: The improved days to finish graph'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.5：改进后的完成天数图
- en: This looks much better! Now, let’s move on to the next question.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这样好多了！现在，让我们继续下一个问题。
- en: How long are the books that I have read?
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我读过的书有多长？
- en: 'The data for this question is already in a fairly good state. We have a single
    column called **Number of Pages**, which, you guessed it, has the number of pages
    in each book. We just need to pass that column to another histogram, and we will
    be good to go:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的数据已经处于相当不错的状态。我们有一列叫做**页面数**，顾名思义，它记录了每本书的页数。我们只需要将这一列传递给另一个直方图，就能搞定：
- en: '[PRE5]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This code will produce something similar to the following screenshot, showing
    a histogram of book length as measured in pages:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将生成类似于以下屏幕截图的结果，显示按页面数衡量的书籍长度直方图：
- en: '![](img/B18444_11_06.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18444_11_06.png)'
- en: 'Figure 11.6: The Number of Pages histogram'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.6：页面数直方图
- en: This makes sense to me; a ton of books are in the 300–400 page range, with a
    few giant books that have 1,000+ pages. Now, let’s move on to the age of these
    books!
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这对我来说有道理；很多书的页数在 300 到 400 页之间，还有一些巨型书籍有 1,000 页以上。现在，让我们继续看这些书的出版年限吧！
- en: How old are the books that I have read?
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我读过的书有多老？
- en: Our next graph should be straightforward. How do we figure out how old the books
    that we read are? Are our tendencies to go for the newest set of books that are
    published or to shoot toward reading classics? There are two columns that we can
    get this information from, the publication year and the original publication year.
    There is very little documentation on this dataset, but I think we can safely
    assume that the original publication year is what we are looking for, and the
    publication year shows when a publisher republishes a book.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来的图表应该是直接的。我们怎么知道我们读的书有多旧？我们是倾向于选择最近出版的书籍，还是更喜欢阅读经典书籍？我们可以从两个列中获取这些信息：出版年份和原始出版年份。这个数据集的文档非常少，但我认为我们可以放心假设原始出版年份是我们需要的，而出版年份则显示的是出版商重新出版书籍的时间。
- en: 'The following code block checks this assumption by printing out all the books
    where the original publication year is later than the publication year:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块通过打印出所有原始出版年份晚于出版年份的书籍来验证这一假设：
- en: '[PRE6]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'When we run this, the app should return zero books with the original publication
    year greater than the year published. Now that we have checked this assumption,
    we can do the following:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行此代码时，应用程序应该返回没有原始出版年份大于出版年份的书籍。现在我们已经验证了这一假设，我们可以执行以下操作：
- en: Group the books by the original publication year.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按原始出版年份对书籍进行分组。
- en: Plot this on a bar chart.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在柱状图上绘制这个数据。
- en: 'The following code block takes two steps:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块执行了两个步骤：
- en: '[PRE7]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'When we run this app, we should get the following graph:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这个应用程序时，我们应该得到以下图表：
- en: '![](img/B18444_11_07.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18444_11_07.png)'
- en: 'Figure 11.7: Book Age Plot'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.7：书籍年龄图
- en: 'At first glance, this graph does not appear to be incredibly useful, as there
    are quite a few books written so far back in history (for example, Plato’s writings
    in -375 BCE) that the entire graph is hard to read. However, Plotly is interactive
    by default, and it allows us to zoom into sections of history that we care about
    more than others. For example, the following screenshot shows us what happens
    when we zoom into the period of 1850 to the present, which most of the books that
    I’ve read happen to be in:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 初看这个图表，它似乎不太有用，因为有很多书籍的写作时间距离现在非常久远（例如，柏拉图的著作是在公元前 375 年），导致整个图表难以阅读。然而，Plotly
    默认是交互式的，它允许我们缩放到我们关心的历史时期。例如，以下截图展示了当我们缩放到 1850 年至今的时期时的情况，而我读过的大多数书籍正好位于这个时间段：
- en: '![](img/B18444_11_08.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18444_11_08.png)'
- en: 'Figure 11.8: Zooming in on Year Published'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.8：缩放出版年份
- en: 'This is a much better graph! There are a couple of options going forward. We
    can start with the graph that is not as useful and tell users to zoom in, we can
    filter our dataset for only younger books (which would defeat the main purpose
    of the graph), or we can set a default zoom state for the graph and also alert
    users at the bottom that they can zoom in as they’d like. I think the third option
    is the best one. The following code implements this option:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个更好的图表！接下来有几个选项可以选择。我们可以从不太有用的图表开始，并告诉用户可以放大，也可以只筛选出较新的书籍数据集（这会违背图表的主要目的），或者我们可以为图表设置默认的缩放状态，并在底部提醒用户可以根据需要放大。我认为第三个选项是最好的。以下代码实现了这个选项：
- en: '[PRE8]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'When we run this code, we should get our final plot:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这段代码时，我们应该得到最终的图表：
- en: '![](img/B18444_11_09.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18444_11_09.png)'
- en: 'Figure 11.9: A default zoom with helpful text'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.9：带有帮助文本的默认缩放
- en: Four questions down – we have one to go!
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 四个问题已经完成——剩下一个！
- en: How do I rate books compared to other Goodreads users?
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我如何与其他 Goodreads 用户相比对书籍评分？
- en: 'For this final question, we really need two separate graphs. First, we need
    to plot how we have rated the books. Second, we need to plot how other users have
    rated the books that we also rated. This isn’t a perfect analysis because Goodreads
    just shows us the average rating of the books – we have not read the distribution.
    For example, if we had read *The Snowball*, a biography of Warren Buffett, and
    rated it 3 stars, and half of Goodreads’ readers rated it 1 star while the other
    half rated it 5 stars, we would have rated it exactly the same as the average
    rating, but we would not have rated it the same as any individual rater! However,
    we do what we can with the data we have. So, we can do the following:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个最后一个问题，我们实际上需要两个独立的图表。首先，我们需要绘制我们给书籍打的分。其次，我们需要绘制其他用户给我们也评分的书籍打的分。这并不是一个完美的分析，因为Goodreads只给我们显示了书籍的平均评分——我们没有读取分布情况。例如，如果我们读过《雪球》，沃伦·巴菲特的传记，并给它打了3星，而一半的Goodreads读者给它打了1星，另一半给了5星，那么我们打的分就和平均评分完全一样，但我们并没有和任何单个评分者的评分一致！不过，我们只能基于现有数据做我们能做的事。因此，我们可以这样做：
- en: Filter the books according to the ones we have rated (and, therefore, read).
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据我们评分过的书籍（即我们已阅读的书籍）来过滤图书。
- en: Create a histogram of the average rating per book for our first graph.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为我们的第一个图表创建一本书的平均评分的直方图。
- en: Create another histogram for your own ratings.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为你自己的评分创建另一个直方图。
- en: 'This next code block does exactly that:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的代码块正是做到了这一点：
- en: '[PRE9]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As you can see in the following screenshot, the first graph with the user rating
    distribution looks great. It looks as though I mainly rate books either 4 or 5
    stars, which are, overall, pretty lenient ratings:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在下面的截图中看到的，带有用户评分分布的第一个图表看起来非常好。看起来我主要给书籍打了4星或5星，这总体来说是相对宽松的评分：
- en: '![](img/B18444_11_10.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18444_11_10.png)'
- en: 'Figure 11.10: The User Rating distribution'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.10：用户评分分布
- en: 'When we also look at the second graph, we see a fairly clean distribution.
    However, we run into the problem that we have addressed before – all the rating
    averages are more tightly bundled than the user ratings:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看第二个图表时，看到的分布相当干净。然而，我们遇到了之前提到的问题——所有的评分平均值比用户评分的分布要集中得多：
- en: '![](img/B18444_11_11.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18444_11_11.png)'
- en: 'Figure 11.11: Average Goodreads Ratings'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.11：Goodreads平均评分
- en: 'We can always set the *x*-axis range to 1–5 for both graphs, but this will
    not help our actual problem. Instead, we can leave both of the graphs but also
    calculate whether, on average, we rate books higher or lower than the Goodreads
    average. The following code block will calculate this and add it underneath the
    average Goodreads rating graph:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以始终将两个图表的 *x* 轴范围设置为1到5，但这并不能解决我们真正的问题。相反，我们可以保留这两个图表，但还要计算出我们平均评分是否高于或低于Goodreads的平均评分。以下代码块将计算此差异，并将其添加到Goodreads平均评分图表下方：
- en: '[PRE10]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This code block makes our average and creates a dynamic string that will say
    that the Goodreads user rates books either higher or lower than the average Goodreads
    user. The result for my data is as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码块计算了我们的平均值，并创建了一个动态字符串，显示Goodreads用户给书籍的评分高于或低于Goodreads的平均用户评分。以下是我的数据结果：
- en: '![](img/B18444_11_12.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18444_11_12.png)'
- en: 'Figure 11.12: Adding an average difference'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.12：添加平均差异
- en: 'This is better and completes our MVP. Our app is in a decent state, and the
    difficult manipulation and visualization steps are pretty much complete. However,
    our app certainly doesn’t look great and is just a bunch of graphs that appear
    in a row. This might be good for an MVP, but we need to add some styling to really
    improve our state. That leads us to our next section: iterating on this idea to
    make it even better.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这样更好，完成了我们的MVP。我们的应用已经处于一个不错的状态，难度较大的操作和可视化步骤基本完成。然而，我们的应用看起来并不出色，只是一堆排成一行的图表。这可能适合MVP，但我们需要添加一些样式来真正改善状态。这就引出了我们下一部分内容：对这个想法进行迭代，使其更好。
- en: Iterative improvement
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迭代改进
- en: 'So far, we have been almost purely in production mode with this app. Iterative
    improvement is all about editing the work we have already done and organizing
    it in a way that makes the app more usable and, frankly, nicer to look at. There
    are a few improvements that we can shoot for here:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们几乎完全处于生产模式中。迭代改进就是在我们已经完成的工作基础上进行编辑和组织，以使应用更加易用，坦率地说，也更美观。这里有一些我们可以努力改进的地方：
- en: Beautification via animation
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过动画美化
- en: Organization using columns and width
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用列和宽度组织
- en: Narrative building through text and additional statistics
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过文本和额外统计数据构建叙事
- en: Let’s start by using animations to make our apps a bit prettier!
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过使用动画让应用变得更加美观吧！
- en: Beautification via animation
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过动画进行美化
- en: 'In *Chapter 7*, *Exploring Streamlit Components*, we explored the use of various
    Streamlit Components; one of these was a component called `streamlit-lottie`,
    which gives us the ability to add animation to our Streamlit applications. We
    can improve our current app by adding an animation to the top of our current Streamlit
    app using the following code. If you want to learn more about Streamlit Components,
    please head back over to *Chapter 7*, *Exploring Streamlit Components*:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第七章*，*探索 Streamlit 组件* 中，我们探讨了各种Streamlit组件的使用；其中有一个组件叫做`streamlit-lottie`，它使我们能够在Streamlit应用中添加动画。我们可以通过以下代码，在当前Streamlit应用的顶部添加一个动画来改进我们的应用。如果你想了解更多关于Streamlit组件的信息，请回到*第七章*，*探索
    Streamlit 组件*：
- en: '[PRE11]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This Lottie file is an animation of a book flipping its pages, as shown in
    the following screenshot. These animations are always a nice touch for longer
    Streamlit apps:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这个Lottie文件是一本书翻页的动画，如下图所示。这些动画总是能为较长的Streamlit应用程序增添一丝生动感：
- en: '![Figure 12.13 – Goodreads animation ](img/B18444_11_13.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.13 – Goodreads 动画](img/B18444_11_13.png)'
- en: 'Figure 11.13: Goodreads animation'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.13：Goodreads 动画
- en: Now that we have added our animation, we can move on to how to organize our
    app a bit better.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们添加了动画，可以继续改进应用的布局。
- en: Organization using columns and width
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用列和宽度进行组织
- en: As we discussed earlier, our app does not look very good, with each graph appearing
    one after the other. Another improvement we can make is to allow our app to be
    in a wide, rather than narrow, format, and then put our apps side by side in each
    column.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论的，我们的应用看起来并不太好，每个图表都是依次显示的。另一个改进是，我们可以让应用以宽格式而不是窄格式显示，然后将应用并排放置在每一列中。
- en: 'To begin, at the top of our app, we need the first Streamlit call to be the
    one that sets the configuration of our Streamlit app to wide rather than narrow,
    as shown in the following code block:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在应用程序顶部，我们需要第一个Streamlit调用来将Streamlit应用的配置设置为宽格式，而不是窄格式，代码块如下所示：
- en: '[PRE12]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This will set our Streamlit app to the wide format. So far, in our app, we
    have called each graph a unique name (such as `fig_year_finished`) to make this
    next step easier. We can now remove all of our `st.plotly_chart()` calls and create
    a set of two columns and three rows, where we can place our six graphs. The following
    code creates each of these. We name each space first, and then fill them with
    one of our graphs:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把我们的Streamlit应用设置为宽格式。到目前为止，我们在应用中为每个图表都命名了一个独特的名称（例如`fig_year_finished`），以便让接下来的步骤更加轻松。现在我们可以删除所有的`st.plotly_chart()`调用，并创建一个由两列三行组成的布局，在哪里可以放置我们的六个图表。以下代码创建了这些布局。我们首先为每个位置命名，然后用一个图表填充它们：
- en: '[PRE13]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This code will create the app that appears in the following screenshot, which
    has been cropped to the top two graphs for brevity:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将创建如下截图中的应用，为简洁起见，已经裁剪为前两个图表：
- en: '![](img/B18444_11_14.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18444_11_14.png)'
- en: 'Figure 11.14: The wide format example'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.14：宽格式示例
- en: This makes our graphs much easier to read and easily allows us to compare them.
    We have intentionally paired our two graphs according to ratings, and the rest
    also appear to fit quite well next to each other. Our final step is to add a bit
    more text to make the entire app easier to read.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们的图表更加易于阅读，并且可以轻松地进行比较。我们特意根据评分将两个图表配对，其余的图表也都能很好地并排显示。我们的最后一步是添加一些文字，使整个应用程序更加易读。
- en: Narrative building through text and additional statistics
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过文本和附加统计数据进行叙事构建
- en: These graphs are already quite helpful to understand how the user reads, but
    we can bolster the readability of this app by adding some useful statistics and
    text underneath each graph and at the beginning of the app.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这些图表已经很有帮助，可以理解用户的阅读方式，但我们可以通过在每个图表下方以及应用的开头添加一些有用的统计数据和文字来提高应用的可读性。
- en: 'Right above where we start to define our columns, we can add an initial section
    that shows the unique number of books that we have read, the unique authors, and
    our favorite author, all in one. We can use these basic statistics to kick off
    the app and tell the user that each graph is also interactive:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始定义列的位置上方，我们可以添加一个初步的部分，展示我们读过的独特书籍数量、独特作者数量和最喜欢的作者，将这些基本统计数据集中展示。我们可以利用这些基本数据来启动应用，并告知用户每个图表都是交互式的：
- en: '[PRE14]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now we need to add four new text sections below the four graphs that do not
    have any annotated text as of yet. For the first three graphs, the following code
    will add some statistics and text to each:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要在四个图表下方添加四个新的文本部分，这些图表目前没有任何注释文本。对于前面三个图表，以下代码将为每个图表添加一些统计数据和文本：
- en: '[PRE15]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'One example graph here is the histogram of book length. The preceding code
    adds an average length and some text below the graph, as shown in the following
    screenshot:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个示例图表是关于书籍长度的直方图。前面的代码为图表下方添加了平均长度和一些文本，具体如下面的截图所示：
- en: '![](img/B18444_11_15.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18444_11_15.png)'
- en: 'Figure 11.15: The average number of pages text'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.15：平均页数文本
- en: 'For the final set of graphs, we can add text to the ones without context:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 对于最后一组图表，我们可以为那些没有上下文的图表添加文本：
- en: '[PRE16]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This completes our section on adding text and additional statistics!
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们关于添加文本和额外统计数据的部分！
- en: Hosting and promotion
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 托管与推广
- en: 'Our final step is to host this app on Streamlit Community Cloud. To do this,
    we need to perform the following steps:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的最后一步是将这个应用托管到Streamlit Community Cloud上。为此，我们需要执行以下步骤：
- en: Create a GitHub repository for this work.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为这项工作创建一个GitHub仓库。
- en: Add a `requirements.txt` file.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`requirements.txt`文件。
- en: Use one-click deployment on Streamlit Community Cloud to deploy the app.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Streamlit Community Cloud上的一键部署功能来部署应用。
- en: We have already covered this extensively in *Chapter 5*, *Deploying Streamlit
    with Streamlit Community Cloud*, so give it a shot now without instructions.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在*第五章*《使用Streamlit部署到Streamlit Community Cloud》中已经详细讲解过了这个内容，现在可以没有指引地尝试一下。
- en: Summary
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: What a fun chapter! We have learned so much here – from how to come up with
    data science projects of our own, and how to create initial MVPs, to the iterative
    improvement of our apps. We did this all through the lens of our Goodreads dataset,
    and we took this app from just an idea to a fully functioning app hosted on Streamlit
    Community Cloud. I look forward to seeing all the different types of Streamlit
    apps that you create. Please create something fun and send it to me on Twitter
    at `@tylerjrichards`. In the next chapter, we will focus on interviews with Streamlit
    power users and creators to learn tips and tricks, why they use Streamlit so extensively,
    and also where they think the library will go from here. See you there!
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章真是太有趣了！我们在这里学到了很多内容——从如何提出我们自己的数据科学项目，到如何创建初步的MVP，再到我们应用程序的迭代改进。我们通过我们自己的Goodreads数据集来实现这一切，并且把这个应用从一个想法发展成了一个在Streamlit
    Community Cloud上托管的完全功能应用。我期待看到你们创造的各种不同类型的Streamlit应用。请创造一些有趣的应用，并在Twitter上发送给我，用户名是`@tylerjrichards`。在下一章中，我们将重点采访Streamlit的重度用户和创作者，了解他们的技巧与窍门，为什么他们如此广泛使用Streamlit，并且他们认为这个库的未来将会怎样发展。到时见！
- en: Learn more on Discord
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Discord上了解更多信息
- en: 'To join the Discord community for this book – where you can share feedback,
    ask questions to the author, and learn about new releases – follow the QR code
    below:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 要加入这本书的Discord社区——你可以在这里分享反馈、向作者提问、了解新版本的发布——请扫描下面的二维码：
- en: '[https://packt.link/sl](https://packt.link/sl)'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/sl](https://packt.link/sl)'
- en: '![](img/QR_Code13440134443835796.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code13440134443835796.png)'
