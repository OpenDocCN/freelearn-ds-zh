- en: Chapter 9. More ArcPy.Mapping Techniques
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章。更多 ArcPy 映射技术
- en: 'The ability to control map document cartography, while also running geospatial
    analyses, increases the power and usefulness of ArcPy. The properties and methods
    of `arcpy.mapping` can be utilized to manipulate layer objects, map scales and
    data frame extents, or even to set definition queries. By combining automated
    geospatial analysis with dynamic map production, scripted mapping systems are
    made possible. This chapter will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 能够控制地图文档的制图，同时运行地理空间分析，增加了 ArcPy 的功能和实用性。`arcpy.mapping` 的属性和方法可以用来操作图层对象、地图比例尺和数据帧范围，甚至可以设置定义查询。通过将自动地理空间分析与动态地图制作相结合，可以实现脚本化映射系统。本章将涵盖以下主题：
- en: Arcpy.mapping Layer objects
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Arcpy.mapping 图层对象
- en: Layer object definition queries and extents
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图层对象定义查询和范围
- en: Arcpy.mapping Data Frame objects
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Arcpy.mapping 数据帧对象
- en: Creating dynamically scaled maps
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建动态缩放的地图
- en: Using arcpy.mapping to control Layer objects
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 arcpy.mapping 控制图层对象
- en: '`Arcpy.mapping` Layer objects are used to control the properties of layers
    within map document data frames. Turning layer visibility on and off, adding new
    layers, and adjusting layer order can all be accomplished using Layer object properties.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '`Arcpy.mapping` 图层对象用于控制地图文档数据帧中图层的属性。通过图层对象属性可以开启和关闭图层可见性、添加新图层以及调整图层顺序。'
- en: 'Creating Layer objects involves passing parameters to the `arcpy.mapping.ListLayers()`
    method. As discussed in [Chapter 8](ch08.html "Chapter 8. Introduction to ArcPy.Mapping"),
    *Introduction to ArcPy.Mapping*, when referencing an `arcpy.mapping.MapDocument`
    object, the layers within the map document can be accessed using zero-based indexing.
    This code will print the list of Layer objects contained within the data frame
    called Layers in an MXD:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 创建图层对象涉及向 `arcpy.mapping.ListLayers()` 方法传递参数。如[第8章](ch08.html "第8章。ArcPy映射简介")所述，在引用
    `arcpy.mapping.MapDocument` 对象时，可以使用基于零的索引访问地图文档中的图层。此代码将打印出在MXD中名为“Layers”的数据帧中包含的图层对象列表：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The layers within the data frame called **Layers**, have been assigned to the
    variable `layersList` using the `ListLayers()` method. Each layer in `layersList`
    can be accessed using zero-based indexing. Once the layers have been accessed
    within the list and either assigned to a variable or placed inside a `for` loop,
    the properties and methods of the Layer objects can be utilized.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 被称为“Layers”的数据帧中的图层已使用 `ListLayers()` 方法分配给变量 `layersList`。`layersList` 中的每个图层都可以使用基于零的索引进行访问。一旦在列表中访问了图层并将其分配给变量或放入
    `for` 循环中，就可以利用图层对象的属性和方法。
- en: Note
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The second parameter of the `ListLayers` method is empty here, but does not
    have to be. It is a wild card parameter that will limit the returned Layer objects
    to those that match the pattern of the wild card. For instance, ***Stops** would
    return all layers with the name **Stops** at the end. Multiple asterisks can be
    used to find layers with the word at the beginning, middle, or end of the layer
    name.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`ListLayers` 方法的第二个参数在这里为空，但不必如此。它是一个通配符参数，将限制返回的图层对象仅限于与通配符模式匹配的对象。例如，***Stops**将返回所有以**Stops**结尾的图层。可以使用多个星号来查找图层名中包含单词的位置在开头、中间或结尾。 '
- en: Layer object methods and properties
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图层对象方法和属性
- en: Layer object properties and methods can either be read only, meaning they can
    be checked but not adjusted, or they are read and write, meaning they can be adjusted
    within the script. Let's explore a number of these properties and methods, and
    see how they can be used to control the look and feel of the maps produced from
    the map document, as well as the data from the script analysis.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图层对象属性和方法可以是只读的，这意味着可以检查但不能调整，或者它们是读写，这意味着可以在脚本中进行调整。让我们探索一些这些属性和方法，看看它们如何用来控制从地图文档生成的地图的外观和感觉，以及来自脚本分析的数据。
- en: Definition queries
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义查询
- en: 'An important property of Layer objects is the ability to dynamically set definition
    queries. A definition query is a SQL statement `where` clause that limits the
    data available for display, query, or other data operations (buffers, intersections,
    etc.) to only the rows that match the `where` clause. Definition queries could
    be set in an MXD by opening a layer''s properties menu and using the Definition
    Query tab, but here we are concerned with how to add them programmatically. Following
    is an example of how to do this:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图层对象的一个重要属性是能够动态设置定义查询。定义查询是一个SQL语句的`where`子句，它将可用于显示、查询或其他数据操作（缓冲区、交集等）的数据限制为仅匹配`where`子句的行。定义查询可以通过在MXD中打开图层属性菜单并使用定义查询选项卡来设置，但在这里我们关注的是如何以编程方式添加它们。以下是如何做到这一点的示例：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This valuable property can be utilized to reformat the code from [Chapter 8](ch08.html
    "Chapter 8. Introduction to ArcPy.Mapping"), *Introduction to ArcPy.Mapping*.
    Remember the complicated second portion of the `Chapter8_6.py` script, where each
    bus stop along the `71 Inbound` line is selected and its geometry is written to
    another feature class? Instead, we can use Layer objects and definition queries
    to perform the same type of geometry operation. Let''s examine how the first part
    of that operation (selecting the bus stop geometry and creating a buffer around
    it) looks when a definition query is used:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这个有价值的属性可以用来重新格式化[第8章](ch08.html "第8章。ArcPy映射简介") *ArcPy映射简介* 中的代码。记得`Chapter8_6.py`脚本的复杂第二部分，其中选择了沿`71
    Inbound`线路的每个公交车站，并将它的几何形状写入另一个要素类？相反，我们可以使用图层对象和定义查询来执行相同类型的几何操作。让我们检查当使用定义查询时，该操作的第一部分（选择公交车站几何形状并在其周围创建缓冲区）看起来是什么样的：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this example, the definition query is used to limit the potential results
    from the `SearchCursor` to the bus stop specified by the query. However, this
    is overly cumbersome and the definition query doesn't add much, as first another
    `SearchCursor` is needed to extract the `ObjectID` information from the `busStops`
    layer. This complicates the code when only one `SearchCursor` is necessary.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，定义查询被用来将`SearchCursor`的潜在结果限制为查询指定的公交车站。然而，这过于繁琐，并且定义查询并没有增加太多价值，因为首先还需要另一个`SearchCursor`来从`busStops`图层中提取`ObjectID`信息。这使代码变得更加复杂，而实际上只需要一个`SearchCursor`。
- en: Definition queries should be used to select the blocks that intersect with the
    buffer, as this will eliminate the need to use the complicated Search Cursor and
    Insert Cursor setup that was employed in [Chapter 8](ch08.html "Chapter 8. Introduction
    to ArcPy.Mapping"), *Introduction to ArcPy.Mapping*. Let's reformulate the code
    so that definition queries are properly used on the census block Layer object.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 定义查询应该用来选择与缓冲区相交的块，因为这将消除使用复杂搜索光标和插入光标设置的需要，这种设置在[第8章](ch08.html "第8章。ArcPy映射简介")
    *ArcPy映射简介* 中被采用。让我们重新编写代码，以便在人口普查块图层对象上正确使用定义查询。
- en: 'The first step is to add some code that will generate the SQL statement that
    will be used as the definition query:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是添加一些代码来生成将用作定义查询的SQL语句：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this section, the code assigns the census blocks layer in the MXD to the
    variable `censusBlocks`. The bus stops `SearchCursor` is then created, and the
    400 foot buffer is generated for each row to select the census blocks surrounding
    the bus stop. Once the correct blocks have been selected, a second `SearchCursor`
    is used on the `censusBlocks` Layer object to find the `ObjectID` (using the `OID@`
    token) of the selected blocks. The `ObjectIDs` are then appended to the list called
    `blockList`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，代码将MXD中的人口普查块图层分配给变量`censusBlocks`。然后创建公交车站`SearchCursor`，并为每一行生成400英尺的缓冲区以选择围绕公交车站的普查块。一旦选择了正确的块，就在`censusBlocks`图层对象上使用第二个`SearchCursor`来找到所选块的`ObjectID`（使用`OID@`令牌）。然后将`ObjectIDs`附加到名为`blockList`的列表中。
- en: 'This list is then iterated in a `for` loop to generate a string SQL statement.
    Using the initial string assigned to the variable `newQuery`, the `for` loop will
    add the `ObjectIDs` of each select block to the string to create a valid SQL statement.
    The `for` loop uses the function enumerate to count the number of loops that the
    `for` loop performs; this allows for an `if/then` statement to be used. The `if/then`
    statement determines what comes after the `ObjectID` in the string, as each `ObjectID`
    must be separated by a comma, except for the final `ObjectID`, which must be followed
    by the closing parenthesis. The `for` loop produces a SQL statement similar to
    this example:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 此列表随后在`for`循环中进行迭代，以生成一个字符串SQL语句。使用分配给变量`newQuery`的初始字符串，`for`循环将每个选择区块的`ObjectIDs`添加到字符串中，以创建一个有效的SQL语句。`for`循环使用`enumerate`函数来计数`for`循环执行的循环次数；这允许使用`if/then`语句。`if/then`语句确定字符串中`ObjectID`之后的内容，因为每个`ObjectID`必须由逗号分隔，除了最后的`ObjectID`，它必须后跟一个闭括号。`for`循环生成一个类似于以下示例的SQL语句：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `print` statement at the end is used to demonstrate the results of this
    section of the code, and also to give that warm fuzzy feeling that comes from
    seeing the results of the code working. Once we are sure that the code is generating
    valid SQL statements (closed parenthesis and comma separated `ObjectIDs`), the
    next step is to assign the definition query to the `censusBlocks` Layer object
    and use the result to generate a map of the area.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 结尾的`print`语句用于展示此段代码的结果，并带来看到代码工作结果的温暖舒适感。一旦我们确信代码正在生成有效的SQL语句（闭括号和逗号分隔的`ObjectIDs`），下一步是将定义查询分配给`censusBlocks`层对象，并使用结果生成该区域的地图。
- en: Controlling the data frame window extent and scale
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制数据帧窗口的范围和比例
- en: In [Chapter 8](ch08.html "Chapter 8. Introduction to ArcPy.Mapping"), *Introduction
    to ArcPy.Mapping* we started to explore the properties and methods of the data
    frame. Using the `arcpy.Extent` object, we were able to set the extent of the
    data frame to an extent that was hard-coded into the script. However, this does
    not always capture the entire extent of large census blocks. Using a combination
    of definition queries and the data frame extent and scale properties, we can avoid
    these unwanted results.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](ch08.html "第8章。ArcPy映射简介") *ArcPy映射简介*中，我们开始探索数据帧的属性和方法。使用`arcpy.Extent`对象，我们能够将数据帧的范围设置为脚本中硬编码的范围。然而，这并不总是能够捕捉到大型普查区块的整个范围。通过结合定义查询和数据帧的范围和比例属性，我们可以避免这些不希望的结果。
- en: There are two data frame object methods used to shift the data frame window
    to the area of interest, in this case the selected census blocks. The first, which
    we are not using here, is `dataFrame.zoomToSelectedFeatures`. The second, is to
    assign the data frame's extent property to the extent of the census block layer
    after the definition query has been assigned to it.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种数据帧对象方法用于将数据帧窗口移动到感兴趣的区域，在这种情况下是选定的普查区块。第一个，我们在这里没有使用，是`dataFrame.zoomToSelectedFeatures`。第二个是将数据帧的范围属性分配给定义查询后分配给它的普查区块层范围。
- en: 'I prefer the second method, as it will work even when there is no selected
    census blocks. Also, as the maps that are produced by this script should not show
    the selection of the blocks, we will have to add code to explicitly clear the
    selection once the correct census blocks have been identified:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我更喜欢第二种方法，因为它即使在没有选定的普查区块的情况下也能工作。此外，由于此脚本生成的地图不应该显示区块的选择，我们不得不添加代码来明确清除已识别的正确普查区块的选择：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The definition query has made it easy to move the data frame window to the area
    of interest, as the extent rectangle (or envelope) of the layer is now only around
    the specified blocks and the `dataFrame` extent property can be set to the extent
    rectangle. However, this is not always cartographically desirable as it seems
    better to move the data frame window back from the extent rectangle. To do that,
    we'll access the data frame the object's scale property.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 定义查询使得将数据帧窗口移动到感兴趣的区域变得容易，因为层的范围矩形（或边界）现在仅围绕指定的区块，并且可以将`dataFrame`的范围属性设置为范围矩形。然而，这并不总是地图学上所希望的，因为看起来将数据帧窗口从范围矩形移回更好。为了做到这一点，我们将访问数据帧对象的缩放属性。
- en: The scale property can be set to be a multiplier of the current scale to avoid
    hard-coding any specific distances when adjusting the data frame extent. When
    using the scale property, it is important to remember to use the `arcpy.RefreshActiveView()`
    method, as it will refresh the data frame window to the new scale.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 缩放属性可以设置为当前缩放的倍数，以避免在调整数据框架范围时硬编码任何特定距离。当使用缩放属性时，重要的是要记住使用`arcpy.RefreshActiveView()`方法，因为它将数据框架窗口刷新到新的缩放。
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As the data frame extent was set in the few lines before this, the current scale
    represents the envelope of the selected census blocks. To adjust it, assess the
    property and apply a multiplier. In this case, the multiplier is 1.1, but it could
    be any value. This makes the resulting map look better by giving the analysis
    results some background context.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 由于数据框架范围在之前的几行中已设置，当前缩放表示所选普查区块的范围。要调整它，评估属性并应用一个乘数。在这种情况下，乘数是1.1，但它可以是任何值。这使得生成的地图看起来更好，因为它为分析结果提供了一些背景上下文。
- en: Adding a Layer object
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加图层对象
- en: The last step before exporting out the maps is to add the 400 foot buffers created
    above as a layer to the data frame object. To accomplish this, we need to create
    a symbolized layer ahead of time and copy its symbology to ensure it looks as
    desired. This will be added to the **MXD** as a placeholder layer, and assigned
    to the `bufferLayer` variable in the script.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在导出地图之前，最后一步是将上面创建的400英尺缓冲区作为一个图层添加到数据框架对象中。为了完成这个任务，我们需要提前创建一个符号化图层并复制其符号化，以确保其看起来符合预期。这将作为一个占位符图层添加到**MXD**中，并分配给脚本中的`bufferLayer`变量。
- en: Open up an **MXD** and add the **bus stop feature class**.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个**MXD**并添加**公交车站要素类**。
- en: Run the **Buffer Tool** in the **Proximity** toolset in the **Analysis** toolset
    of the **ArcToolbox**, adding the **bus stop feature class** as the input and
    setting the buffer size to **400 feet**. After the tool has run, open the properties
    of the buffer layer and symbolize the layer as desired.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**ArcToolbox**的**分析工具集**中的**邻近工具集**中运行**缓冲工具**，将**公交车站要素类**作为输入，并将缓冲区大小设置为**400英尺**。工具运行完成后，打开缓冲图层属性并按需符号化图层。
- en: Once the layer has been symbolized, right-click on the layer and select **Save**
    **As Layer File**.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦图层被符号化，右键单击图层并选择**另存为图层文件**。
- en: Save the layer in a folder and close the **MXD**.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将图层保存在文件夹中，并关闭**MXD**。
- en: Open up the **MapDocument1.mxd** map document and add the layer using the **Add
    Data** button.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**MapDocument1.mxd**地图文档，并使用**添加数据**按钮添加图层。
- en: Make sure to change the name to **400 Foot Buffer** and to add it to the legend
    above the **Population** section.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保将其名称更改为**400 Foot Buffer**，并将其添加到**人口**部分上面的图例中。
- en: In the script, assign the buffer layer to the variable `bufferLayer`.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在脚本中，将缓冲区图层分配给变量`bufferLayer`。
- en: 'Lower in the script, in the bus stop `SearchCursor`, add these lines below
    where the buffer is generated around the bus stop geometry:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在脚本较低的部分，在公交车站的`SearchCursor`中，在生成缓冲区周围的代码下方添加以下行：
- en: '[PRE7]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: These two lines copy the buffer generated to disk as a shapefile and then replace
    the data source of the `bufferLayer` Layer object with the newly created buffer.
    Note that the name of the shapefile does not include the `.shp` extension; the
    `SHAPEFILE_WORKSPACE` parameter makes this unnecessary.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这两条线将生成的缓冲区作为shapefile复制到磁盘上，然后替换`bufferLayer`图层对象的源数据。注意，shapefile的名称不包括`.shp`扩展名；`SHAPEFILE_WORKSPACE`参数使得这一点变得不必要。
- en: Note
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: 'To make sure that each new buffer shapefile can be written over an existing
    shapefile, add the following line below the `import arcpy` line to make sure that
    files can be overwritten:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保每个新的缓冲区shapefile可以覆盖现有的shapefile，在`import arcpy`行下方添加以下行，以确保文件可以被覆盖：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Exporting the maps
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导出地图
- en: 'The final step of this script is to export the maps of the area surrounding
    each bus stop. To do this, we will borrow some code from the script `Chapter8_6_AdjustMap.py`
    and add the whole script to a file called `Chapter9.py`. This code will identify
    and adjust the title and subtitle elements, making it possible to customize each
    resulting PDF:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本的最后一步是导出每个公交车站周围的地图。为此，我们将从`Chapter8_6_AdjustMap.py`脚本中借用一些代码，并将整个脚本添加到名为`Chapter9.py`的文件中。此代码将识别并调整标题和副标题元素，使得可以自定义每个生成的PDF：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Summary
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered the use of layer definition queries, data frame
    extents and scales, and layer source replacement to ease the production of maps.
    By using definition queries, the layers can be modified to new extents, making
    it easier to zoom into the layer extent and to set the scale of the data frame.
    The definition queries also limit which members of a layer are displayed within
    the data frame. Layer source replacement was used as a cartographic control, allowing
    us to pre-generate the style of a layer and adjust the data that it represented
    dynamically.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了使用图层定义查询、数据框架范围和比例以及图层源替换来简化地图制作的方法。通过使用定义查询，可以修改图层到新的范围，从而更容易地缩放到图层范围并设置数据框架的比例。定义查询还限制了在数据框架内显示图层的哪些成员。图层源替换被用作制图控制，使我们能够预先生成图层的样式并动态调整它所代表的数据。
- en: In the next chapter, we will combine the lessons from the last three chapters,
    allowing us to create a script tool that will run analysis and produce spreadsheets
    and maps from the analysis results.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将结合前三章的教训，使我们能够创建一个脚本工具，该工具可以从分析结果中运行分析并生成电子表格和地图。
