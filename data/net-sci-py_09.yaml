- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Community Detection
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 社区检测
- en: In the last two chapters, we covered whole network analysis and egocentric network
    analysis. The former was useful for understanding the complete makeup of a complex
    network. The latter was useful for investigating the people and relationships
    that exist around an “ego” node. However, there’s a missing layer that we have
    not yet discussed. Between whole networks and egos, communities exist. We are
    people, and we are part of a global population of humans that exist on this planet,
    but we are each also part of individual communities. For instance, we work in
    companies and as part of individual teams. Many of us have social interests, and
    we know people from participating in activities. There are layers to life, and
    we can use algorithms to identify the various communities that exist in a network,
    automatically.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的两章中，我们介绍了整体网络分析和自我中心网络分析。前者有助于理解复杂网络的完整结构。后者则有助于研究存在于“自我”节点周围的人和关系。然而，在整个网络和自我之间，还存在一个我们尚未讨论的缺失层次。社区存在于其中。我们是人类，我们是地球上全球人口的一部分，但我们每个人也是个体社区的一部分。例如，我们在公司工作，作为个人团队的一部分。我们中的许多人有社交兴趣，我们通过参与活动认识人。生活有层次，我们可以使用算法自动识别网络中存在的各种社区。
- en: 'This chapter contains the following sections:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包含以下几个部分：
- en: Introducing community detection
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍社区检测
- en: Getting started with community detection
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 入门社区检测
- en: Exploring connected components
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索连接组件
- en: Using the Louvain method
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Louvain方法
- en: Using label propagation
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用标签传播
- en: Using the Girvan-Newman algorithm
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Girvan-Newman算法
- en: Other approaches to community detection
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 社区检测的其他方法
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In this chapter, we will mostly be using the NetworkX and pandas Python libraries.
    These libraries should be installed by now, so they should be ready for your use.
    If they are not installed, you can install the Python libraries with the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将主要使用NetworkX和pandas Python库。这些库应该已经安装好，可以供您使用。如果尚未安装，您可以使用以下命令安装Python库：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'For instance, to install NetworkX, you can use this:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要安装NetworkX，您可以使用以下命令：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In [*Chapter 4*](B17105_04.xhtml#_idTextAnchor158), we also introduced a `draw_graph()`
    function that uses both NetworkX and Scikit-Network. You will need that code any
    time that we do network visualization. You will need it for this chapter, and
    most of the chapters in this book.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第四章*](B17105_04.xhtml#_idTextAnchor158)中，我们还介绍了一个`draw_graph()`函数，该函数同时使用了NetworkX和Scikit-Network。您将在进行网络可视化时需要这段代码。这不仅限于本章，几乎适用于本书的大部分章节。
- en: 'For community detection, we will also be using `python-louvain`. You can install
    it with the following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 对于社区检测，我们还将使用`python-louvain`。您可以使用以下命令进行安装：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You can import it like this, which you will see later in this chapter:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以像这样导入它，稍后您将在本章看到：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: It is understandable if you’re confused by the installation and import commands
    for `python-louvain`. The library name does not match the import library name.
    It’s a useful library for community detection, so let’s accept this as an oddity
    and move on.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对`python-louvain`的安装和导入命令感到困惑，这是可以理解的。该库的名称与导入库名称不匹配。这是一个用于社区检测的有用库，因此让我们接受这种奇怪现象并继续前进。
- en: Introducing community detection
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍社区检测
- en: Community detection is about identifying the various communities or groups that
    exist in a network. This is useful in social network analysis, as humans interact
    with others as part of our various communities, but these approaches are not limited
    to studying humans.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 社区检测涉及识别网络中存在的各种社区或群组。这在社交网络分析中非常有用，因为人类作为我们各种社区的一部分与他人互动，但这些方法不仅限于研究人类。
- en: We can also use these approaches to investigate any kinds of nodes that interact
    closely with other nodes, whether those nodes are animals, hashtags, websites,
    or any kind of nodes in a network. Pause for a moment and think about what we
    are doing. Community detection is a clear, concise, and appropriate name for what
    we are doing. We are zooming in on communities that exist in a network. What communities
    would you be interested in exploring and understanding, and why?
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用这些方法来研究与其他节点紧密交互的任何类型的节点，无论这些节点是动物、标签、网站还是网络中的任何节点。稍作思考，我们正在做什么。社区检测是对我们正在做的事情的一个明确、简洁且恰当的名称。我们正在聚焦于网络中存在的社区。您对探索和理解哪些社区感兴趣，以及为什么？
- en: There are many good use cases for this. You can use it to understand the sentiment
    communities share about your product. You can use this to understand a threat
    landscape. You can use this to understand how ideas move and transform between
    different groups of people. Be creative here. There are probably more uses for
    this than you can imagine.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法有很多很好的使用场景。你可以用它来了解社区对你产品的情感反应。你可以用它来了解威胁格局。你可以用它来了解不同群体之间思想是如何传播和转变的。这里可以发挥创意。它可能有比你想象的更多的用途。
- en: In this chapter, we will explore this in the context of human life, but you
    should not feel limited to only using this for social network analysis. This is
    very useful in social network analysis, but it is also useful in analyzing most
    network data, not just social network data. For instance, this can be useful in
    both cybersecurity (malware analysis) and computational humanities, or in understanding
    how ideas move between groups and evolve.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将从人类生活的角度来探讨这一点，但你不应只限于将其应用于社交网络分析。它在社交网络分析中非常有用，但它在分析大多数网络数据时也很有用，不仅仅是社交网络数据。例如，这在网络安全（恶意软件分析）和计算人文学科中非常有用，或者在理解思想如何在群体之间传播并演变时也很有用。
- en: 'There are at least three different approaches to doing community detection,
    with the most frequently researched including the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 至少有三种不同的方法进行社区检测，其中最常被研究的包括以下几种：
- en: Node connectivity
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节点连通性
- en: Node closeness
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节点接近度
- en: Network splitting
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络拆分
- en: What I am calling *node connectivity* has to do with whether nodes are part
    of the same connected component or not. If two nodes are not part of the same
    connected component, then they are part of a completely different social group,
    not part of the same community.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我所说的*节点连通性*与节点是否属于同一个连通组件有关。如果两个节点不属于同一个连通组件，那么它们属于完全不同的社交群体，而不是同一个社区。
- en: Node closeness has to do with the distance between two nodes, even if they are
    part of the same connected component. For instance, two people might work together
    in the same large organization, but if they are more than two handshakes away
    from one another, they may not be part of the same community. It would take several
    rounds of introductions for them to ever meet each other. Consider how many people
    would you have to go through to be introduced to your favorite celebrity. How
    many people would you need to be introduced to?
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 节点接近度与两个节点之间的距离有关，即使它们是同一个连通组件的一部分。例如，两个可能在同一个大型组织中一起工作的人，但如果他们之间有超过两个握手的距离，他们可能不属于同一个社区。要让他们相遇，需要经过几轮介绍。想一想，要认识你最喜欢的名人，你需要通过多少人介绍。你需要经过多少人？
- en: Network splitting has to do with literally cutting a network into pieces by
    either removing nodes or edges. The preferred approach that I will explain is
    cuts on edges, but I have done something similar by removing nodes, and I've done
    this a few times in this book, shattering networks into pieces by removing central
    nodes.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 网络拆分实际上是通过移除节点或边来将一个网络切割成多个部分。我将解释的首选方法是对边进行切割，但我也做过类似的操作，移除节点，我在本书中做过几次，通过去除中心节点将网络打碎成碎片。
- en: I do not believe that we are at the end of discovery for community detection.
    I hope that reading through this chapter will give you some ideas for new approaches
    to identifying the various communities that exist in networks.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我不认为我们已经在社区检测的发现上走到了尽头。我希望通过阅读本章内容，你能够获得一些新的思路来识别网络中存在的各种社区。
- en: Getting started with community detection
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始进行社区检测
- en: 'Before we can start, we need a network to use. Let’s use NetworkX’s *Les Miserables*
    graph that we used in the previous chapter since it held several separate communities:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，我们需要一个网络来使用。让我们继续使用上章中提到的NetworkX的*悲惨世界*图，因为它包含了几个独立的社区：
- en: 'Loading the network is simple:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载网络是简单的：
- en: '[PRE4]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: That’s all it takes to load the graph.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是加载图形所需要的全部操作。
- en: 'There is a `weight` attribute that I do not want to include in the network
    because we don’t need edge weights for this simple demonstration. So, I’m going
    to drop it and rebuild the graph:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有一个`weight`属性，我不打算在网络中包含它，因为在这个简单的演示中我们不需要边权重。因此，我将删除它并重新构建图形：
- en: '[PRE7]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In those two steps, we converted the *Les Miserables* graph into a `pandas`
    edge list, and we kept only the `source` and `target` fields, effectively dropping
    the `weight` field. Let’s see how many nodes and edges exist in the network:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个步骤中，我们将*悲惨世界*图转换为`pandas`的边列表，并且仅保留`source`和`target`字段，有效地去除了`weight`字段。让我们看看网络中有多少节点和边：
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This is a tiny network. Does this network contain isolates and islands, or is
    it just one large connected component? Let’s check.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个小网络。这个网络包含孤立点和孤岛吗，还是只有一个大的连通分量？让我们来检查一下。
- en: 'First, let’s add the `draw_graph` function:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们添加`draw_graph`函数：
- en: '[PRE11]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, let’s visualize the network in its entirety:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们全面展示网络：
- en: '[PRE29]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This outputs the following:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 9.1 – Les Miserables graph](img/B17105_09_001.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.1 – 悲惨世界图](img/B17105_09_001.jpg)'
- en: Figure 9.1 – Les Miserables graph
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.1 – 悲惨世界图
- en: At a glance, we should be able to see that there are no isolates (nodes without
    edges), there are several nodes with a single edge, there are several clusters
    of nodes that are very close to each other (communities), and there are a few
    critically important nodes. If those critically important nodes were removed,
    the network would shatter to pieces.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 一眼看去，我们应该能够看到没有孤立点（没有边的节点），有几个只有一条边的节点，有几个节点群体非常接近（社区），还有一些非常关键的节点。如果移除这些关键节点，网络就会支离破碎。
- en: 'Let’s zoom in a little, using `k_core`, and only show nodes that have two or
    more edges. Let’s also not display labels so that we can get a sense of the overall
    shape of the network:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们稍微放大一点，使用`k_core`，并且只显示具有两条或更多边的节点。我们也不显示标签，这样可以更好地看到网络的整体形状：
- en: '[PRE30]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We will get the following output:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到以下输出：
- en: '![Figure 9.2 – Les Miserables graph, k_core with K=2, unlabeled](img/B17105_09_002.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.2 – 悲惨世界图，k_core，K=2，无标签](img/B17105_09_002.jpg)'
- en: Figure 9.2 – Les Miserables graph, k_core with K=2, unlabeled
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.2 – 悲惨世界图，k_core，K=2，无标签
- en: The communities should be a little clearer now. Look for parts of the graphs
    where the nodes are close together and where there are more edges/lines present.
    How many communities do you see? Four of them really stand out to me, but there
    are smaller groups scattered around, and there is also likely a community in the
    center of the network.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在社区应该更清晰了。寻找节点紧密且边/线更多的图部分。你看到了几个社区？我看到有四个社区特别明显，但周围也有一些较小的群体，而且网络中心可能还有一个社区。
- en: We are now ready to begin our attempts at community detection.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好尝试社区检测了。
- en: Exploring connected components
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索连通分量
- en: The first attempt at understanding the various communities and structures that
    exist in a network is often to analyze the connected components. As we discussed
    in *w*, connected components are structures in networks where all nodes have a
    connection to another node in the same component.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 理解网络中存在的各种社区和结构的第一步常常是分析连通分量。正如我们在*w*中讨论的，连通分量是网络中的结构，其中所有节点都与同一组件中的另一个节点连接。
- en: As we saw previously, connected components can be useful for finding smaller
    connected components. Those can be thought of as communities as they are detached
    from the primary component and overall network, but the largest connected component
    is not typically a single community. It is usually made up of several communities,
    and it can usually be split into individual communities.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前看到的，连通分量对于查找较小的连接部分非常有用。这些可以被视为社区，因为它们与主要组件和整体网络分离，但最大的连通分量通常不是单个社区。它通常由几个社区组成，并且通常可以分割成单独的社区。
- en: In the *Les Miserables* network, there is only one connected component. There
    are no islands or isolates. There is just one single component. That makes sense,
    as these are the characters from a piece of literature, and it wouldn’t make much
    sense for characters in a book to just spend all day talking to themselves. However,
    that takes away a bit of the usefulness of inspecting connected components for
    this graph.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在*悲惨世界*网络中，只有一个连通分量。没有孤岛或孤立点。只有一个单一组件。这是有道理的，因为这些都是文学作品中的角色，书中的角色不会整天和自己说话。然而，这也削弱了检查此图的连通分量的一些用处。
- en: 'There is a way around that! As I mentioned previously, if we remove a few critically
    important nodes from a network, that network tends to shatter into pieces:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个解决方法！正如我之前提到的，如果我们从网络中移除几个关键节点，那么网络往往会支离破碎：
- en: 'Let’s remove five very important characters from the network:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从网络中移除五个非常重要的角色：
- en: '[PRE31]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In these two lines, we built a second graph called `G_copy`, and then we removed
    five key nodes. Let’s visualize the network again!
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这两行代码中，我们构建了一个名为`G_copy`的第二个图，然后移除了五个关键节点。让我们再次可视化这个网络！
- en: '[PRE33]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This gives us the following output:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们带来了如下输出：
- en: '![Figure 9.3 – Shattered Les Miserables network](img/B17105_09_003.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.3 – 破碎后的《悲惨世界》网络](img/B17105_09_003.jpg)'
- en: Figure 9.3 – Shattered Les Miserables network
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.3 – 破碎后的《悲惨世界》网络
- en: Great. That’s much closer to how many real-world networks look. There’s still
    one primary connected component (continent), there are three smaller connected
    components (islands), and there are six isolate nodes. Calling these islands and
    continents is my own thing. There is no threshold for deciding that an island
    is a continent. It is just that most networks contain one super-component (continent),
    lots and lots of isolate nodes, and several connected components (islands). This
    helps me, but do with it what you like.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 很好。这与许多现实世界网络的样子更为接近。依然有一个主要的连通组件（大陆），有三个较小的连通组件（岛屿），还有六个孤立节点。把这些叫做岛屿和大陆是我个人的命名方式。没有一个明确的标准来决定岛屿是否就是大陆。只是大多数网络都包含一个超大组件（大陆），大量孤立节点，以及若干连通组件（岛屿）。这对我有帮助，但你可以随意处理。
- en: One other thing to keep in mind is that what we just did could be used as a
    step in community detection. Removing a few key nodes can break a network apart,
    pulling out the smaller communities that exist. Those critically important nodes
    held one or more communities together as part of the larger structure. Removing
    the important nodes allowed the communities to drift apart. We did this by removing
    important nodes, which is not usually ideal. However, other actual approaches
    to community detection work similarly, by removing edges rather than nodes.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要记住的事情是，我们刚才所做的可以作为社区检测中的一步。移除一些关键节点可以将网络拆散，揭示出存在的小社区。这些至关重要的节点将一个或多个社区维系在一起，作为更大结构的一部分。移除这些重要节点使得社区之间可以自由漂移。我们通过移除重要节点来完成这一操作，虽然这通常不是最理想的做法。然而，其他实际的社区检测方法工作原理类似，通过移除边而非节点来实现。
- en: How many connected components are left after shattering the network?
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在破碎网络后，还剩下多少个连通组件？
- en: '[PRE34]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: NetworkX says that there are `10`, but isolates are not connected to anything
    other than possibly themselves.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: NetworkX 说有 `10` 个连通组件，但孤立节点除了可能与自身连接外，不与任何东西相连。
- en: 'Let’s remove them before looking into connected components:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在查看连通组件之前，让我们先移除它们：
- en: '[PRE37]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: It looks like there are four connected components.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来有四个连通组件。
- en: 'As there are so few of them, let’s inspect each one:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于它们数量很少，我们来检查每一个：
- en: '[PRE41]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Let’s look at the visualization:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下可视化效果：
- en: '![Figure 9.4 – Component 0 subgraph of the shattered Les Miserables network](img/B17105_09_004.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.4 – 破碎后的《悲惨世界》网络中组件 0 的子图](img/B17105_09_004.jpg)'
- en: Figure 9.4 – Component 0 subgraph of the shattered Les Miserables network
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.4 – 破碎后的《悲惨世界》网络中组件 0 的子图
- en: Very interesting! The first connected component is almost a star network, with
    all nodes connecting to one central character, **Myriel**. However, if you look
    at the top left, you should see that two characters also share a link. That relationship
    could be worth investigating.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 非常有趣！第一个连通组件几乎是一个星型网络，所有节点都连接到一个中心角色——**米里埃尔**。然而，如果你看看左上角，你应该会看到两个角色也共享一个链接。这种关系可能值得进一步研究。
- en: 'Let’s look at the next component:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看下下一个组件：
- en: '[PRE44]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This gives us the following output:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们带来了如下输出：
- en: '![Figure 9.5 – Component 1 subgraph of the shattered Les Miserables network](img/B17105_09_005.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.5 – 破碎后的《悲惨世界》网络中组件 1 的子图](img/B17105_09_005.jpg)'
- en: Figure 9.5 – Component 1 subgraph of the shattered Les Miserables network
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.5 – 破碎后的《悲惨世界》网络中组件 1 的子图
- en: This is even more interesting. This is what I am calling the primary component.
    It’s the largest connected component in the shattered network. However, as I said,
    connected components are not ideal for identifying communities. Look slightly
    left of the center in the network – we should see two clusters of nodes, two separate
    communities. There’s also at least one other community on the right. If two edges
    or nodes were removed, the community on the right would split off from the network.
    Onward!
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这更加有趣了。我把这个叫做主要组件。它是破碎网络中最大的连通组件。然而，正如我之前说的，连通组件并不适合用来识别社区。稍微左偏一点，你应该能看到网络中心左边有两个节点簇，两个独立的社区。右侧至少还有一个其他社区。如果移除两条边或节点，右侧的社区就会从网络中分离出来。继续前进！
- en: 'Let’s keep shattering the community:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们继续打破社区：
- en: '[PRE47]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We will get the following output:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到以下输出：
- en: '![Figure 9.6 – Component 2 subgraph of the shattered Les Miserables network](img/B17105_09_006.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图9.6 – 破碎的《悲惨世界》网络的组件2子图](img/B17105_09_006.jpg)'
- en: Figure 9.6 – Component 2 subgraph of the shattered Les Miserables network
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6 – 破碎的《悲惨世界》网络的组件2子图
- en: This is a strongly connected component. Each node has a connection to the other
    nodes in this network. If one node were removed, this network would remain intact.
    From a network perspective, each node is as important or central as each other
    node.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个强连接组件。每个节点都与这个网络中的其他节点有连接。如果移除一个节点，网络仍然保持完整。从网络的角度来看，每个节点与其他节点同样重要或中心。
- en: 'Let’s check the final component:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们检查最后一个组件：
- en: '[PRE50]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'This gives us the following visualization:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们提供了以下的可视化：
- en: '![Figure 9.7 – Component 3 subgraph of the shattered Les Miserables network](img/B17105_09_007.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图9.7 – 破碎的《悲惨世界》网络的组件3子图](img/B17105_09_007.jpg)'
- en: Figure 9.7 – Component 3 subgraph of the shattered Les Miserables network
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.7 – 破碎的《悲惨世界》网络的组件3子图
- en: This is another densely connected network. Each node is equally important or
    central. If one node were to be removed, this network would remain intact.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个密集连接的网络。每个节点同样重要或中心。如果移除一个节点，网络仍然保持完整。
- en: As you can see, we were able to find three communities by looking at the connected
    components, but connected components did not draw out the communities that exist
    in the larger primary component. If we wanted to draw those out, we’d have to
    remove other important nodes and then repeat our analysis. Throwing away nodes
    is one way to lose information, so I do not recommend that approach, but it can
    be useful for quick ad hoc analysis.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们通过查看连接组件找到了三个社区，但连接组件没有揭示出在更大主组件中存在的社区。如果我们想要识别这些社区，我们需要移除其他重要节点，然后重复分析。丢弃节点是一种丢失信息的方式，因此我不推荐这种方法，但在快速的临时分析中，它可以是有用的。
- en: I do not consider investigating connected components to be community detection,
    but communities can be found while investigating connected components. I consider
    this one of the first steps that should be done during any network analysis, and
    the insights gained are valuable, but it’s not sensitive enough for community
    detection.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我不认为研究连接组件属于社区检测，但在研究连接组件时可以找到社区。我认为这是任何网络分析过程中应该做的第一步，获得的见解非常有价值，但它对于社区检测来说不够敏感。
- en: If your network contained no super-cluster of a connected component, then connected
    components would be pretty adequate for community detection. However, you would
    have to treat the super-cluster as one community, and in reality, the cluster
    contains many communities. The connected component approach becomes less useful
    with larger networks.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的网络中没有连接组件的超级集群，那么连接组件对于社区检测来说是相当足够的。然而，你必须将超级集群当作一个社区，实际上，那个集群包含了多个社区。随着网络规模的增大，连接组件方法的效果会变得不那么有效。
- en: Let’s move on to more suitable methods.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续讨论更合适的方法。
- en: Using the Louvain method
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用卢瓦恩方法
- en: The **Louvain method** is certainly my favorite for community detection, for
    a few reasons.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**卢瓦恩方法**无疑是我最喜欢的社区检测方法，原因有很多。'
- en: First, this algorithm can be used on very large networks of millions of nodes
    and it will be effective and fast. Other approaches that we will explore in this
    chapter will not work on large networks and will not be as fast, so we get effectiveness
    and speed with this algorithm that we can’t find anywhere else. As such, it is
    my go-to algorithm for community detection, and I save the others as options to
    consider.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这种算法可以应用于非常大的数百万节点的网络，且效果显著且快速。我们将在本章探讨的其他方法在大型网络中无法使用，也没有那么快，因此使用这种算法我们能得到其他地方找不到的效果和速度。因此，这是我首选的社区检测算法，其他的算法我则保留作为备选方案。
- en: Second, it is possible to tune the `resolution` parameter to find the best partitions
    for community detection, giving flexibility when the default results are not optimal.
    With the other algorithms, you do not have this flexibility.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，可以调节`分辨率`参数来找到最适合的社区检测分割，这在默认结果不理想时提供了灵活性。而其他算法则没有这种灵活性。
- en: In summary, with the Louvain method, we have a fast algorithm that is effective
    at community detection in massive networks, and we can optimize the algorithm
    for better results. I recommend dabbling in community detection by starting with
    the Louvain method, and then picking up these other approaches as you learn. It’s
    good to know that there are options.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，使用 Louvain 方法，我们有了一个快速的算法，它在大规模网络中的社区检测中非常有效，我们还可以优化该算法以获得更好的结果。我建议从 Louvain
    方法入手，尝试社区检测，然后在学习过程中逐步掌握其他方法。了解不同的选择是很有帮助的。
- en: How does it work?
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的？
- en: The creators of the Louvain method were able to use their algorithm on a network
    of hundreds of millions of nodes and more than a billion edges, making this approach
    suitable for very large networks. You can read more about the Louvain method at
    [https://arxiv.org/pdf/0803.0476.pdf](https://arxiv.org/pdf/0803.0476.pdf).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Louvain 方法的创始人能够在一个包含数亿个节点和超过十亿条边的网络上使用他们的算法，这使得这种方法非常适用于大型网络。你可以在 [https://arxiv.org/pdf/0803.0476.pdf](https://arxiv.org/pdf/0803.0476.pdf)
    阅读更多关于 Louvain 方法的内容。
- en: The algorithm works through a series of passes, where each pass contains two
    phases. The first phase assigns different communities to each node in the network.
    Initially, each node has a different community assigned to it. Then, each neighbor
    is evaluated and nodes are assigned to communities. The first step concludes when
    no more improvements can be made. In the second phase, a new network is built,
    with nodes being the communities discovered in the first step. Then, the results
    of the first phase can be repeated. The two steps are iterated until optimal communities
    are found.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法通过一系列的传递工作，每次传递包含两个阶段。第一阶段将不同的社区分配给网络中的每个节点。最初，每个节点都会分配一个不同的社区。接着，对每个邻居进行评估，并将节点分配到社区。第一步在无法再进行改进时结束。在第二阶段，构建一个新的网络，其中节点是第一阶段发现的社区。然后，可以重复第一阶段的结果。两个步骤不断迭代，直到找到最佳社区。
- en: This is a simplified description of how the algorithm works. I recommend reading
    the research paper in its entirety to get a feel for how the algorithm works.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这是算法工作原理的简化描述。建议完整阅读研究论文，以更好地理解算法是如何工作的。
- en: The Louvain method in action!
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Louvain 方法的实际应用！
- en: 'We used the Louvain method briefly in [*Chapter 3*](B17105_03.xhtml#_idTextAnchor080),
    so if you paid attention, this code should look familiar. The Louvain method has
    been included in more recent versions of NetworkX, so if you have the latest version
    of NetworkX, you will not need to use the `community` Python library, but your
    code will be different. For consistency, I will use the “community” library approach:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 [*第 3 章*](B17105_03.xhtml#_idTextAnchor080) 中简要使用了 Louvain 方法，所以如果你有注意的话，这段代码应该很熟悉。Louvain
    方法已经包含在最新版本的 NetworkX 中，因此如果你使用的是最新版本的 NetworkX，就不需要使用 `community` Python 库了，但你的代码会有所不同。为了保持一致，我将使用“community”库的方法：
- en: 'First, let’s import the library:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们导入库：
- en: '[PRE53]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Here is some code that will help us draw Louvain partitions:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下面是一些帮助我们绘制 Louvain 分区的代码：
- en: '[PRE54]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Now, let’s use the `best_partition` function to identify the optimal partition
    using the Louvain method. During my testing, I found `resolution=1` to be ideal,
    but with other networks, you should experiment with this parameter:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们使用 `best_partition` 函数，利用 Louvain 方法来识别最佳分区。在我的测试中，我发现 `resolution=1`
    是理想值，但在其他网络中，你应该尝试调整这个参数：
- en: '[PRE65]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'This creates a visualization:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成一个可视化：
- en: '![Figure 9.8 – Louvain method community detection of the Les Miserables network](img/B17105_09_008.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.8 – Louvain 方法对《悲惨世界》网络的社区检测](img/B17105_09_008.jpg)'
- en: Figure 9.8 – Louvain method community detection of the Les Miserables network
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.8 – Louvain 方法对《悲惨世界》网络的社区检测
- en: The helper function in *step 2* will color nodes by the communities that they
    belong to. What is important is that the separate communities have been detected,
    and each community of nodes is identified with a different color. Each node belongs
    to a different partition, and those partitions are the communities.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤 2* 中的辅助函数将根据节点所属的社区为其着色。重要的是，已经检测到独立的社区，并且每个节点的社区都用不同的颜色标识。每个节点都属于不同的分区，而这些分区就是社区。'
- en: 'Let’s take a look at what is inside the `partition` variable:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们来看看 `partition` 变量中包含了什么：
- en: '[PRE67]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'To save space, I cut out some of the nodes and partitions. Each node has an
    associated partition number, and that’s the community that it belongs to. If you
    wanted to get a list of nodes that belong to an individual community, you could
    do something like this:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 为了节省空间，我剪掉了一些节点和分区。每个节点都有一个关联的分区编号，这就是它所属的社区。如果你想获取属于某个特定社区的节点列表，你可以像这样操作：
- en: '[PRE81]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: So, why is this exciting? What’s so cool about the Louvain method? Well, for
    one thing, it can scale to massive networks, allowing for research into the largest
    networks, such as the internet. Second, it’s fast, which means it is practical.
    There is not a lot of point to an algorithm that is so slow as to only be useful
    on tiny networks. Louvain is practical with massive networks. This algorithm is
    fast and efficient, and the results are very good. This is one algorithm for community
    detection that you will want in your tool belt.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么这令人兴奋？Louvain方法到底有什么酷的地方？首先，它能够扩展到庞大的网络，允许对像互联网这样的最大网络进行研究。其次，它很快，这意味着它是实用的。如果一个算法慢到只适用于小型网络，那它就没有多大意义。Louvain方法在大规模网络上实用。这个算法既快速又高效，结果也非常好。它是你工具箱中会需要的一个社区检测算法。
- en: Next, let’s look at label propagation as another option for community detection.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看标签传播作为社区检测的另一个选择。
- en: Using label propagation
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用标签传播
- en: Label propagation is another fast approach for identifying communities that
    exist in a network. In my experience, the results haven’t been as good as with
    the Louvain method, but this is another tool that can be explored as part of community
    detection. You can read about label propagation at [https://arxiv.org/pdf/0709.2938.pdf](https://arxiv.org/pdf/0709.2938.pdf).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 标签传播是另一种快速识别网络中社区的方法。根据我的经验，结果没有Louvain方法那么好，但它是一个可以探索的工具，作为社区检测的一部分。你可以在[https://arxiv.org/pdf/0709.2938.pdf](https://arxiv.org/pdf/0709.2938.pdf)上阅读关于标签传播的更多内容。
- en: How does it work?
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的？
- en: This is an iterative approach. Each node is initialized with a unique label,
    and during each iteration of the algorithm, each node adopts the label that most
    of its neighbors have. For instance, if the **David** node had seven neighbor
    nodes, and four out of seven neighbors were **label 1** with the other three were
    **label 0**, then the **David** node would pick up **label 1**. During each step
    of the process, each node picks up the majority label, and the process concludes
    by grouping nodes with the same labels together as communities.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种迭代方法。每个节点被初始化为一个唯一的标签，在每次算法迭代过程中，每个节点都会采用其大多数邻居的标签。例如，如果**David**节点有七个邻居节点，且其中四个邻居的标签是**label
    1**，另外三个邻居的标签是**label 0**，那么**David**节点将选择**label 1**。在每次步骤中，每个节点都会选择大多数邻居的标签，最终通过将拥有相同标签的节点分组为社区来结束该过程。
- en: Label propagation in action!
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标签传播在行动！
- en: 'This algorithm can be imported directly from NetworkX:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法可以直接从NetworkX中导入：
- en: '[PRE82]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Once you have imported the algorithm, all you have to do is pass it to your
    graph, and you will get back a list of communities:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦导入了算法，你所要做的就是将它传递给你的图，然后你会得到一个社区列表：
- en: 'Let’s try this out using our Les Miserables graph:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用《悲惨世界》图来试试看：
- en: '[PRE83]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: This line passes our graph to the label propagation algorithm and writes the
    results to a `community` variable. On a network this small, this algorithm is
    zippy-fast, taking a fraction of a second to identify communities. I prefer to
    convert these results into a list, to extract the community nodes.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行将我们的图传递给标签传播算法，并将结果写入一个`community`变量。在这么小的网络上，这个算法非常快速，只需要不到一秒钟的时间就能识别社区。我更喜欢将这些结果转换成列表，以提取社区节点。
- en: 'We can do just that, like so:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以像这样做到：
- en: '[PRE84]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: In that last line, we inspected the first community, community 0\. Visualizing
    these communities is simple enough.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一行中，我们检查了第一个社区，社区0。可视化这些社区非常简单。
- en: 'We can extract them as subgraphs and then use the same `draw_graph` function
    we have used throughout this book:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以将它们提取为子图，然后使用我们在本书中一直使用的相同的`draw_graph`函数：
- en: '[PRE94]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: What can we see from the output?
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从输出中可以看到什么？
- en: '![Figure 9.9 – Label propagation community detection of the Les Miserables
    network, community 1](img/B17105_09_009.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![图9.9 – 《悲惨世界》网络的标签传播社区检测，社区1](img/B17105_09_009.jpg)'
- en: Figure 9.9 – Label propagation community detection of the Les Miserables network,
    community 1
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.9 – 《悲惨世界》网络的标签传播社区检测，社区1
- en: This looks pretty good, but not quite as good as the results from the Louvain
    method. It was fast but not quite as precise as I’d wanted. For instance, looking
    to the left of **Valjean**, there is a tight community of densely connected nodes.
    That should be its own community, not part of this larger group. This algorithm
    isn’t perfect, but no algorithm is. However, this algorithm is fast and can scale
    to large networks, so it is another option for large-scale community detection.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结果看起来不错，但还不如Louvain方法的结果那么好。虽然它速度很快，但精度不如我预期的那么高。例如，看看**Valjean**左边，有一个紧密连接的社区，节点之间的连接非常密集。这个应该是一个独立的社区，而不是这个大社区的一部分。这个算法并不完美，但没有算法是完美的。然而，这个算法很快，能够扩展到大规模网络，因此它是大规模社区检测的另一种选择。
- en: 'Let’s look at a couple more communities:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们再看看几个社区：
- en: '[PRE97]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'This gives us the following output:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们提供了以下输出：
- en: '![Figure 9.10 – Label propagation community detection of the Les Miserables
    network, community 2](img/B17105_09_010.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.10 – 悲惨世界网络的标签传播社区检测，社区 2](img/B17105_09_010.jpg)'
- en: Figure 9.10 – Label propagation community detection of the Les Miserables network,
    community 2
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.10 – 悲惨世界网络的标签传播社区检测，社区 2
- en: This community looks about perfect. It’s not uncommon to have a few additional
    nodes other than those found in the most densely connected parts of a community.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这个社区看起来几乎完美。在社区中，除了最密集连接的部分外，出现一些额外的节点并不罕见。
- en: 'Let’s look at another:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看另一个例子：
- en: '[PRE100]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'This gives us the following visualization:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们提供了以下的可视化：
- en: '![Figure 9.11 – Label propagation community detection of the Les Miserables
    network, community 3](img/B17105_09_011.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.11 – 悲惨世界网络的标签传播社区检测，社区 3](img/B17105_09_011.jpg)'
- en: Figure 9.11 – Label propagation community detection of the Les Miserables network,
    community 3
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.11 – 悲惨世界网络的标签传播社区检测，社区 3
- en: This community looks great as well. Overall, this algorithm works well and is
    fast. Also, the setup is easier and faster than with the Louvain method, as all
    you have to do is import the algorithm, pass it a graph, and then visualize the
    results. In terms of ease of use, this algorithm is the easiest that I’ve seen.
    The results look good, and communities have quickly been identified.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这个社区看起来也很好。总体来说，这个算法效果很好，且速度很快。此外，设置比Louvain方法更容易、更快，因为你只需导入算法，传入一个图形，然后可视化结果。在易用性方面，这是我见过的最简单的算法。结果看起来不错，社区很快就被识别出来了。
- en: But being fast and easy to use is not enough. Louvain is more accurate and is
    fast and easy to use. Still, this can be useful.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，快速和易于使用并不足够。Louvain更准确，并且快速且易于使用。尽管如此，这个算法仍然有其用处。
- en: Using the Girvan-Newman algorithm
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Girvan-Newman算法
- en: At the beginning of this chapter, we noticed that the *Les Miserables* network
    consisted of a single large connected component and that there were no isolates
    or smaller “islands” of communities apart from the large connected component.
    To show how connected components could be useful for identifying communities,
    we shattered the network by removing a few key nodes.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章开始时，我们注意到*悲惨世界*网络由一个大的连通分量组成，并且没有孤立点或除了大连通分量之外的小型“岛屿”社区。为了展示连通分量如何有助于识别社区，我们通过去除一些关键节点来打破这个网络。
- en: That approach is not typically ideal. While there is information in both nodes
    (people, places, things) and edges (relationships), in my experience, it is typically
    preferable to throw away edges than to throw away nodes.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法通常并不理想。尽管节点（人、地点、事物）和边（关系）中都包含信息，但根据我的经验，通常更倾向于去掉边而不是去掉节点。
- en: A better approach than what we did previously would be to identify the least
    number of edges that could be cut that would result in a split network. We could
    do this by looking for the edges that the greatest number of shortest paths pass
    through – that is, the edges with the highest `edge_betweenness_centrality`.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 一个比我们之前做的更好的方法是，找出能导致网络分裂的最少边，这些边将是切断网络的关键。我们可以通过寻找通过最多最短路径的边来实现这一点——也就是具有最高`edge_betweenness_centrality`的边。
- en: That is precisely what the **Girvan-Newman** **algorithm** does.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是**Girvan-Newman** **算法**的作用。
- en: How does it work?
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的？
- en: 'The Girvan-Newman algorithm identifies communities by cutting the least number
    of edges possible, which results in splitting a network into two pieces. You can
    read more about their approach here: [https://www.pnas.org/doi/full/10.1073/pnas.122653799](https://www.pnas.org/doi/full/10.1073/pnas.122653799).'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: Girvan-Newman算法通过尽可能少地切割边来识别社区，从而将网络分割成两部分。你可以在这里了解他们的研究方法：[https://www.pnas.org/doi/full/10.1073/pnas.122653799](https://www.pnas.org/doi/full/10.1073/pnas.122653799)。
- en: Many times, when I’m looking at networks, I see several nodes on two different
    sides connected by a few edges. It almost looks like a few rubber bands are holding
    the two groups together. If you snip the rubber bands, the two communities should
    fly apart, similar to how networks shatter into pieces when key nodes are removed.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 很多时候，当我在查看网络时，我会看到几个节点被几条边连接在两个不同的侧面上。它几乎看起来像几根橡皮筋将这两组捆绑在一起。如果你剪断橡皮筋，这两个社区应该会分开，类似于当关键节点被移除时，网络会分裂成碎片的情况。
- en: In a way, this is more surgically precise than removing nodes. There is less
    loss of valuable information. Sure, losing information on certain relationships
    is a drawback, but all of the nodes remain intact.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 从某种程度上来说，这比删除节点更具精准性。信息损失较少。当然，丧失某些关系的信息是一个缺点，但所有节点仍然完好无损。
- en: Through a series of iterations, the Girvan-Newman algorithm identifies edges
    with the highest `edge_betweenness_centrality` scores and removes them, splitting
    a network into two pieces. Then, the process begins again. If not repeated enough,
    communities are too large. If repeated too many times, communities end up being
    a single node. So, there will be some experimentation when using this algorithm
    to find the ideal number of cuts.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一系列迭代，Girvan-Newman算法识别出具有最高`edge_betweenness_centrality`得分的边并将其删除，将网络分割成两部分。然后，过程再次开始。如果没有足够重复，社区会太大；如果重复太多次，社区最终会只剩一个节点。因此，在使用此算法时需要进行一些实验，以找到理想的分割次数。
- en: This algorithm is all about cutting. The downside of this algorithm is that
    it is not fast. Calculating `edge_betweenness_centrality` is much more computationally
    expensive than the computations being done for the Louvain method or label propagation.
    As a result, this algorithm ceases to be useful very quickly, as it becomes much
    too slow to be practical.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法的核心就是切割。这个算法的缺点是它并不快。计算`edge_betweenness_centrality`要比Louvain方法或标签传播的计算更加耗费计算资源。因此，这个算法很快就变得不再实用，因为它变得非常慢，无法再实际应用。
- en: However, if your network is small enough, this is a very cool algorithm to explore
    for community detection. It’s also intuitive and easy to explain to others.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你的网络足够小，这是一个非常酷的社区检测算法，可以进行探索。它也很直观，容易向他人解释。
- en: Girvan-Newman algorithm in action!
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Girvan-Newman算法在运行中！
- en: 'Let’s try this out with our *Les Miserables* graph. The graph is small enough
    that this algorithm should be able to split it into communities pretty quickly:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用我们的*悲惨世界*图来试试看。图足够小，这个算法应该能够很快地将其分割成多个社区：
- en: 'First, import the algorithm:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，导入算法：
- en: '[PRE103]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Next, we need to pass the graph to the algorithm as a parameter. When we do
    this, the algorithm will return the results of each iteration of splits, which
    we can investigate by converting the results into a list:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要将图作为参数传递给算法。这样做时，算法将返回每次迭代分割的结果，我们可以通过将结果转换为列表来进行调查：
- en: '[PRE104]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'What was the maximum number of iterations that the algorithm could do before
    each community consisted of a single node? Let’s see:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每个社区由单个节点组成之前，算法最多可以进行多少次迭代？我们来看一下：
- en: '[PRE106]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Neat! We have `76` iterations of splits kept in a Python list. I recommend that
    you investigate the various levels of splits and find the one that looks best
    for your needs. It could be very early in the process, in the first 10 splits,
    or it might be a bit later. This part requires some analysis, further making this
    a bit of a hands-on algorithm.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们有`76`次分割迭代保存在Python列表中。我建议你研究不同的分割级别，找到最适合你需求的一个。可能是过程中的非常早期，前10次分割，或者可能稍微晚一些。这部分需要一些分析，使得这个算法更具实践性。
- en: 'However, just to push forward, let’s pretend that we found that the tenth iteration
    of splits yielded the best results. Let’s set the tenth iteration results as our
    final group of communities, and then visualize the communities as we did with
    the Louvain method and label propagation:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，为了推进进度，假设我们发现第十次迭代的分割得到了最好的结果。我们将第十次迭代的结果作为最终的社区分组，然后像使用Louvain方法和标签传播一样可视化这些社区：
- en: '[PRE108]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: We’re keeping the tenth iteration results and dropping everything else. If we
    didn’t want to throw away the results, we could have used a different variable
    name.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们保留了第十次迭代的结果，删除了其他所有结果。如果我们不想丢弃这些结果，可以使用不同的变量名。
- en: 'Let’s see what these communities look like so that we can compare them against
    the other algorithms we discussed:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们来看一下这些社区是什么样的，以便将它们与我们讨论的其他算法进行比较：
- en: '[PRE109]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'We get the following output:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到以下输出：
- en: '![Figure 9.12 – Girvan-Newman community detection of the Les Miserables network,
    community 0](img/B17105_09_012.jpg)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.12 – 《悲惨世界》网络的Girvan-Newman社区检测，社区 0](img/B17105_09_012.jpg)'
- en: Figure 9.12 – Girvan-Newman community detection of the Les Miserables network,
    community 0
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.12 – 《悲惨世界》网络的Girvan-Newman社区检测，社区 0
- en: This subgraph should look familiar! We saw exactly this when we shattered the
    network by nodes and then visualized connected components. This algorithm split
    the network using edges and managed to find the same community.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这个子图应该很熟悉！当我们通过节点将网络分裂然后可视化连接组件时，看到的正是这个。这个算法通过切割边缘分裂网络，并成功找到了相同的社区。
- en: 'Let’s see another community:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们来看另一个社区：
- en: '[PRE112]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'This produces the following network visualization:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成以下网络可视化：
- en: '![Figure 9.13 – Girvan-Newman community detection of the Les Miserables network,
    community 1](img/B17105_09_013.jpg)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.13 – 《悲惨世界》网络的Girvan-Newman社区检测，社区 1](img/B17105_09_013.jpg)'
- en: Figure 9.13 – Girvan-Newman community detection of the Les Miserables network,
    community 1
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.13 – 《悲惨世界》网络的Girvan-Newman社区检测，社区 1
- en: This also looks very good. It’s not uncommon for communities to have a densely
    connected group, as well as some less connected nodes.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这也看起来非常好。社区中有密集连接的节点组，以及一些连接较少的节点，这并不罕见。
- en: 'And another community:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一个社区：
- en: '[PRE115]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'We will see the following output:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到以下输出：
- en: '![Figure 9.14 – Girvan-Newman community detection of the Les Miserables network,
    community 2](img/B17105_09_014.jpg)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.14 – 《悲惨世界》网络的Girvan-Newman社区检测，社区 2](img/B17105_09_014.jpg)'
- en: Figure 9.14 – Girvan-Newman community detection of the Les Miserables network,
    community 2
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.14 – 《悲惨世界》网络的Girvan-Newman社区检测，社区 2
- en: This is similar to the last community. We have a densely connected group of
    nodes and two nodes with a single edge. This looks great.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 这与上一个社区类似。我们有一个密集连接的节点组和两个只有一条边的节点。看起来很棒。
- en: 'Let’s see community 3:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们来看一下社区 3：
- en: '[PRE118]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'Community 3 looks like this:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 社区 3 看起来是这样的：
- en: '![Figure 9.15 – Girvan-Newman community detection of the Les Miserables network,
    community 3](img/B17105_09_015.jpg)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.15 – 《悲惨世界》网络的Girvan-Newman社区检测，社区 3](img/B17105_09_015.jpg)'
- en: Figure 9.15 – Girvan-Newman community detection of the Les Miserables network,
    community 3
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.15 – 《悲惨世界》网络的Girvan-Newman社区检测，社区 3
- en: This should look familiar as well. Label propagation found the same community
    but Girvan-Newman removed one additional node.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 这也应该很熟悉。标签传播方法找到了相同的社区，但Girvan-Newman算法删除了一个额外的节点。
- en: 'And the next one:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以及下一个：
- en: '[PRE121]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'We will see the following network:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到以下网络：
- en: '![Figure 9.16 – Girvan-Newman community detection of the Les Miserables network,
    community 4](img/B17105_09_016.jpg)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.16 – 《悲惨世界》网络的Girvan-Newman社区检测，社区 4](img/B17105_09_016.jpg)'
- en: Figure 9.16 – Girvan-Newman community detection of the Les Miserables network,
    community 4
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.16 – 《悲惨世界》网络的Girvan-Newman社区检测，社区 4
- en: While this may be less visually appealing to look at, this impresses me more
    than the other network visualizations. This is a less obvious community, found
    only by cutting edges with the highest `edge_betweenness_centrality` scores. There
    is a slightly more connected group of nodes in the center, surrounded by nodes
    with a single edge each on the outskirts.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这可能在视觉上不如其他的网络可视化那么吸引人，但我认为它比其他的更令人印象深刻。这是一个不那么明显的社区，通过切割具有最高`edge_betweenness_centrality`得分的边找到的。中间有一个连接较多的节点组，周围是每个只与一条边连接的节点。
- en: The Girvan-Newman algorithm can give really good and clean results. The only
    downside is its speed. Calculating `edge_betweenness_centrality` and shortest_paths
    is time-consuming, so this algorithm is much slower than the others that we discussed,
    but it can be very useful if your network is not too large.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: Girvan-Newman算法可以给出非常好的、干净的结果。唯一的缺点是速度。计算`edge_betweenness_centrality`和最短路径是一个耗时的过程，因此该算法比我们讨论的其他算法要慢得多，但如果你的网络不太大，它仍然非常有用。
- en: Other approaches to community detection
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他社区检测方法
- en: All of these algorithms that we have explored were ideas that people had on
    how to identify communities in networks, either based on nearness to other nodes
    or found by cutting edges. However, these are not the only approaches. I came
    up with an approach before learning about the Girvan-Newman algorithm that cut
    nodes rather than edges. However, when I learned about the Girvan-Newman approach,
    I found that to be more ideal and gave up on my implementation. But that makes
    me think, what other approaches might there be for identifying communities in
    networks?
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们探讨过的所有这些算法，都是人们关于如何在网络中识别社区的想法，基于与其他节点的接近度或通过切割边缘来找到社区。然而，这些并不是唯一的方法。我在了解Girvan-Newman算法之前，曾提出过一种方法，通过切割节点而不是边缘来识别社区。然而，当我了解了Girvan-Newman方法后，我发现它更理想，因此放弃了我的实现。但这让我思考，识别网络社区可能还有其他方法吗？
- en: As you learn more and become more comfortable working with networks, try to
    discover other ways of identifying communities.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你对网络的理解逐渐深入，并且在使用网络分析时越来越得心应手，尝试发现其他识别社区的方法。
- en: Summary
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we went through several different approaches to community detection.
    Each had its pros and cons.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们探讨了几种不同的社区检测方法。每种方法都有其优缺点。
- en: We saw that connected components can be useful for identifying communities,
    but only if the network consists of more than just one single primary component.
    To use connected components to identify communities, there need to be some smaller
    connected components split off. It’s very important to use connected components
    at the beginning of your network analysis to get an understanding of the overall
    structure of your network, but it is less than ideal as a standalone tool for
    identifying communities.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到，连通组件在识别社区时是有用的，但前提是网络不仅仅由一个单一的主要组件组成。要利用连通组件识别社区，网络中需要有一些较小的连通组件被分割出来。在网络分析的初期使用连通组件非常重要，这有助于了解网络的整体结构，但作为单独的工具用于识别社区并不理想。
- en: Next, we used the Louvain method. This algorithm is extremely fast and can be
    useful in networks where there are hundreds of millions of nodes and billions
    of edges. If your network is very large, this is a useful first approach for community
    detection. The algorithm is fast, and the results are clean. There is also a parameter
    you can experiment with to get optimal partitions.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用了Louvain方法。这个算法非常快速，适用于节点数量达到数亿、边缘数量达到数十亿的网络。如果你的网络非常大，这将是一个很有用的社区检测初步方法。算法运行速度快，结果清晰。你还可以调整一个参数，以获得最佳的划分结果。
- en: We then used label propagation to identify communities. On the *Les Miserables*
    network, the algorithm took a fraction of a second to identify communities. Overall,
    the results looked good, but it did seem to struggle with splitting out a dense
    cluster of nodes from a larger community. However, every other community looked
    good. This algorithm is fast and should scale to large networks, but I have never
    heard of this being used on a network with millions of nodes. It is worth experimenting
    with.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用了标签传播方法来识别社区。在*悲惨世界*网络中，这个算法识别社区的时间仅为几分之一秒。总体来说，结果不错，但它似乎在将一个密集的节点群体从一个较大的社区中分割出来时遇到了一些困难。然而，其他社区的划分效果都很好。这个算法很快，并且应该能够扩展到大型网络，但我从未听说过它被应用于一个拥有数百万节点的网络。值得尝试。
- en: Finally, we used the Girvan-Newman algorithm, which is an algorithm that finds
    communities by performing several rounds of cuts on edges with the highest `edge_betweenness_centrality`
    scores. The results were very clean. The downside of this algorithm is that it
    is very slow and does not scale well to large networks. However, if your network
    is small, then this is a very useful algorithm for community detection.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用了Girvan-Newman算法，这是一种通过对具有最高`edge_betweenness_centrality`分数的边缘进行多轮切割来寻找社区的算法。结果非常清晰。这个算法的缺点是它非常慢，并且在大规模网络中扩展性差。然而，如果你的网络较小，这将是一个非常有用的社区检测算法。
- en: This has been a fun chapter to write. Community detection is one of the most
    interesting areas of network analysis, for me. It’s one thing to analyze networks
    as a whole or explore ego networks, but being able to identify and extract communities
    is another skill that sits somewhere between whole network analysis and egocentric
    network analysis.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章的编写过程非常有趣。对我来说，社区检测是网络分析中最有趣的领域之一。分析整个网络或探索自我中心网络是一回事，但能够识别并提取社区则是一项位于整体网络分析和自我中心网络分析之间的技能。
- en: In the next few chapters, we’re going to go into the wilderness and explore
    how we can use network science and machine learning together! The first chapter
    will be on supervised machine learning, while the final chapter will be on unsupervised
    machine learning. We only have a few more chapters to go! Hang in there!
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几章中，我们将进入未知领域，探索如何将网络科学与机器学习结合起来！第一章将讲解监督式机器学习，而最后一章则将讲解无监督式机器学习。我们只剩下几章了！坚持住！
