- en: Chapter 14. Comprehensive Examples
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 14 章. 综合示例
- en: In this chapter, we present some comprehensive and longer examples together
    with a brief introduction to the theoretical background and their complete implementation.
    By this, we want to show you how the concepts defined in this book are used in
    practice.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们展示了几个综合且较长的示例，以及理论背景的简要介绍和它们的完整实现。通过这种方式，我们希望向您展示本书中定义的概念在实际中的应用。
- en: Polynomials
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多项式
- en: First, we will demonstrate the power of the Python constructs presented so far
    by designing a class for polynomials. We will give some theoretical background,
    which leads us to a list of requirements, and then we will give the code, with
    some comments.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将通过设计一个多项式类来展示迄今为止所展示的 Python 构造的强大功能。我们将给出一些理论背景，这引导我们列出一系列要求，然后我们将给出代码，并附上一些注释。
- en: Note, this class differs conceptually from the class `numpy.poly1d`.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个类在概念上与 `numpy.poly1d` 类不同。
- en: Theoretical background
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理论背景
- en: 'A polynomial: *p*(*x*) *= a[n] x ^n + a[n-1] x^(n-1)*+…+ *a*[1]*x + a*[0 ]is
    defined by its degree, its representation, and its coefficients. The polynomial
    representation shown in the preceding equation is called a monomial representation.
    In this representation, the polynomial is written as a linear combination of monomials, *x^i*.
    Alternatively, the polynomial can be written in:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 一个多项式：*p*(*x*) *= a[n] x ^n + a[n-1] x^(n-1)*+…+ *a*[1]*x + a*[0 ]由其度数、其表示和其系数定义。前面方程中显示的多项式表示称为单项式表示。在这个表示中，多项式被写成单项式的线性组合，*x^i*。或者，多项式也可以写成：
- en: 'Newton representation with the coefficients *c[i]* and *n* points, *x[0]*,
    …, *x[n-1]*:'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用系数 *c[i]* 和 *n* 个点，*x[0]*, …, *x[n-1]* 的 Newton 表示：
- en: '*p*(*x*) *= c*[0] + *c*[1] (*x - x*[0]) *+ c*[2] (*x - x*[0])(*x-x*[1]) + ...
    + *c[n]*(*x - x[0]*) … (*x - x[n]*[-1])'
  id: totrans-8
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*p*(*x*) *= c*[0] + *c*[1] (*x - x*[0]) *+ c*[2] (*x - x*[0])(*x-x*[1]) + ...
    + *c[n]*(*x - x[0]*) … (*x - x[n]*[-1])'
- en: 'Lagrange representation with the coefficients *y[i]*and *n*+1 points, *x*[0],
    … , *x[n]*:'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用系数 *y[i]* 和 *n*+1 个点，*x*[0], … , *x[n]* 的 Lagrange 表示：
- en: '*p*(*x*) = *y*[0] *l*[0](*x*) + *y*[1] *l*[1](*x*) + … + *y[n] l[n]*(*x*)'
  id: totrans-10
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*p*(*x*) = *y*[0] *l*[0](*x*) + *y*[1] *l*[1](*x*) + … + *y[n] l[n]*(*x*)'
- en: 'with the cardinal functions:'
  id: totrans-11
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用基数函数：
- en: '![Theoretical background](img/B05511_14_01.jpg)'
  id: totrans-12
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![理论背景](img/B05511_14_01.jpg)'
- en: There are infinitely many representations, but we restrict ourselves here to
    these three typical ones.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 存在无限多种表示，但在这里我们只限制自己到这三种典型表示。
- en: 'A polynomial can be determined from interpolation conditions:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 可以根据插值条件确定一个多项式：
- en: '*p*(*x[i]*) = *y*[i] *i* = 0, … , *n*'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*p*(*x[i]*) = *y*[i] *i* = 0, … , *n*'
- en: 'with the given distinct values *x[i]* and arbitrary values *y[i]* as input.
    In the Lagrange formulation, the interpolation polynomial is directly available,
    as its coefficients are the interpolation data. The coefficients for the interpolation
    polynomial in Newton representation can be obtained by a recursion formula, called
    the divided differences formula:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 以给定的不同值 *x[i]* 和任意值 *y[i]* 作为输入。在 Lagrange 公式中，插值多项式直接可用，因为其系数是插值数据。Newton 表示中的插值多项式的系数可以通过一个递归公式获得，称为差分公式：
- en: '*c[i]*[,0] = *y[i,]*and'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*c[i]*[,0] = *y[i,]*and'
- en: '![Theoretical background](img/B05511_14.jpg).'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '![理论背景](img/B05511_14.jpg).'
- en: Finally, one sets ![Theoretical background](img/cic0.jpg).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，设置 ![理论背景](img/cic0.jpg)。
- en: 'The coefficients of the interpolation polynomial in monomial representation
    are obtained by solving a linear system:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 单项式表示中的插值多项式的系数通过求解一个线性系统获得：
- en: '![Theoretical background](img/B05511_14_03.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![理论背景](img/B05511_14_03.jpg)'
- en: 'A matrix that has a given polynomial *p* (or a multiple of it) as its characteristic
    polynomial is called a companion matrix. The eigenvalues of the companion matrix
    are the zeros (roots) of the polynomial. An algorithm for computing the zeros
    of *p* can be constructed by first setting up its companion matrix and then computing
    the eigenvalues with `eig`. The companion matrix for a polynomial in Newton representation
    reads as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一个具有给定多项式 *p*（或其倍数）作为其特征多项式的矩阵称为伴随矩阵。伴随矩阵的特征值是多项式的零点（根）。可以通过首先设置 *p* 的伴随矩阵然后使用
    `eig` 计算特征值来构建计算 *p* 的零点的算法。Newton 表示中的多项式的伴随矩阵如下所示：
- en: '![Theoretical background](img/B05511_14_04.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![理论背景](img/B05511_14_04.jpg)'
- en: Tasks
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 任务
- en: 'We can now formulate some programming tasks:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以制定一些编程任务：
- en: 'Write a class called `PolyNomial` with the `points`, `degree`, `coeff`, and
    `basis` attributes, where:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个名为 `PolyNomial` 的类，具有 `points`、`degree`、`coeff` 和 `basis` 属性，其中：
- en: '`points` is a list of tuples (*x[i], y[i]*)'
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`points` 是一个包含元组 (*x[i], y[i]*) 的列表'
- en: '`degree` is the degree of the corresponding interpolation polynomial'
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`degree` 表示对应插值多项式的次数'
- en: '`coeff` contains the polynomial coefficients'
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`coeff` 包含多项式系数'
- en: '`basis` is a string stating which representation is used'
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`basis` 是一个字符串，表示使用哪种表示形式'
- en: Provide the class with a method for evaluating the polynomial at a given point.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为该类提供一个方法，用于在给定点上评估多项式。
- en: Provide the class with a method called `plot` that plots the polynomial over
    a given interval.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为该类提供一个名为 `plot` 的方法，用于在给定区间内绘制多项式。
- en: Write a method called `__add__` that returns a polynomial that is the sum of
    two polynomials. Be aware that only in the monomial case the sum can be computed
    by just summing up the coefficients.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个名为 `__add__` 的方法，返回两个多项式的和。请注意，只有在单项式情况下，和可以通过简单地相加系数来计算。
- en: Write a method that computes the coefficients of the polynomial represented
    in a monomial form.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个方法，计算以单项式形式表示的多项式的系数。
- en: Write a method that computes the polynomial's companion matrix.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个方法，计算多项式的伴随矩阵。
- en: Write a method that computes the zeros of the polynomial by computing the eigenvalues
    of the companion matrix.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个方法，通过计算伴随矩阵的特征值来计算多项式的零点。
- en: Write a method that computes the polynomial that is the *i*^(th) derivative
    of the given polynomial.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个方法，计算给定多项式的 *i* 次导数的多项式。
- en: Write a method that checks whether two polynomials are equal. Equality can be
    checked by comparing all coefficients (zero leading coefficients should not matter).
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个方法，检查两个多项式是否相等。可以通过比较所有系数来检查相等性（零首项系数不应影响）。
- en: The polynomial class
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多项式类
- en: 'Let''s now design a polynomial base class based on a monomial formulation of
    the polynomial. The polynomial can be initialized either by giving its coefficients
    with respect to the monomial basis or by giving a list of interpolation points,
    as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们设计一个基于多项式的单项式表示的多项式基类。多项式可以通过给出单项式基的系数或给出插值点列表来初始化，如下所示：
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `__init__` method of the new class uses the `**args` construction as discussed
    in section *Parameters and arguments* in [Chapter 7](ch07.html "Chapter 7. Functions"),
    *Functions*. If no arguments are given, a zero polynomial is assumed. If the polynomial
    is given by interpolation points the method used to compute the coefficients by
    solving a Vandermonde system is given as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 新类的 `__init__` 方法使用在[第7章](ch07.html "第7章。函数") *函数* 中讨论的 `**args` 构造。如果没有给出参数，则假定多项式为零多项式。如果多项式由插值点给出，则用于通过求解Vandermonde系统的系数的方法如下：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If *k* coefficients are given also *k* interpolation points are constructed
    by:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果给出 *k* 个系数，也将构造 *k* 个插值点：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `self(x)` command does a polynomial evaluation, which is done by providing
    a  method, `__call__`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`self(x)` 命令执行多项式评估，这是通过提供一个方法 `__call__` 来完成的：'
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '(Refer example in section *Special methods* in [Chapter 8](ch08.html "Chapter 8. Classes"),
    *Classes.*) Here, this method uses the command `polyval`. As a next step, we just
    add for convenience two methods, which we decorate with the `property` decorator
    (refer section *Functions as decorators* in [Chapter 7](ch07.html "Chapter 7. Functions"),
    *Functions)*:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: （参考第8章 *特殊方法* 节中的示例[第8章](ch08.html "第8章。类")，*类*。）这里，此方法使用 `polyval` 命令。作为下一步，我们只是为了方便添加两个方法，我们用
    `property` 装饰器来装饰它们（参考第7章 *函数作为装饰器* 节中的[第7章](ch07.html "第7章。函数")，*函数)*）：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s explain what is going on here. We define a method to extract the *x*-values
    of the data, which were used to define the polynomial. Similarly, a method to
    extract the *y*-values of the data is defined. With the `property` decorator,
    the result of calling the method is presented as if it were just an attribute
    of the polynomial. There are two coding alternatives:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们解释一下这里发生了什么。我们定义了一个方法来提取用于定义多项式的数据的 *x* 值，同样，还定义了一个方法来提取数据的 *y* 值。使用 `property`
    装饰器，调用方法的结果被呈现为如果它只是多项式的一个属性。有两种编码选择：
- en: 'We use a method call:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用方法调用：
- en: '[PRE5]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This gives access to the *x*-values by the call: `p.x()`.'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这通过调用：`p.x()` 来访问 *x* 值。
- en: We use the `property` decorator. It us to access the *x*-values simply by this
    statement:  `p.x`
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用 `property` 装饰器。它允许通过这个语句访问 *x* 值：`p.x`
- en: 'We choose the second variant. It is always a good practice to define a `__repr__`
    method (refer section *Attributes* in [Chapter 8](ch08.html "Chapter 8. Classes"),
    *Classes*). At least for a quick check of the results, this method is useful:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择了第二种方案。始终定义一个 `__repr__` 方法是一个好习惯（参考第 8 章的 *Attributes* 部分，[第 8 章](ch08.html
    "第 8 章。类")，*类*）。至少对于快速检查结果，这个方法是很有用的：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We now provide a method for plotting the polynomial, as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在提供了一个绘制多项式的方法，如下所示：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Note the use of the `vectorize` command (refer section *Functions acting on
    arrays* in [Chapter 4](ch04.html "Chapter 4. Linear Algebra – Arrays"), *Linear
    algebra - Arrays*. The `__call__` method is specific to the monomial representation
    and has to be changed if a polynomial is represented in another basis. This is
    also the case for the computation of the polynomial''s companion matrix:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到使用了 `vectorize` 命令（参考第 4 章的 *Functions acting on arrays* 部分，[第 4 章](ch04.html
    "第 4 章。线性代数 – 数组")，*线性代数 - 数组*）。`__call__` 方法是针对单项式表示的，如果多项式以其他基表示，则需要更改。计算多项式的伴随矩阵也是如此：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Once the companion matrix is available, the zeros of the polynomial are given
    by the eigenvalues:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦有了伴随矩阵，多项式的零点就由特征值给出：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: For this end the function `eigvals` has to be imported from `scipy.linalg` first.
    Let's give some usage examples.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个目的，需要首先从 `scipy.linalg` 导入 `eigvals` 函数。让我们给出一些使用示例。
- en: 'First, we create a polynomial instance from the given interpolation points:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们从给定的插值点创建一个多项式实例：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The polynomial''s coefficients with respect to the monomial basis are available
    as an attribute of `p`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 多项式相对于单项式基的系数作为 `p` 的一个属性可用：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This corresponds to the polynomial ![The polynomial class](img/B05511_14_1.jpg)
    . The default plot of the polynomial, obtained by `p.plot(-3.5,3.5)`, results
    in the following figure (*Figure 14.1*):'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这对应于多项式 ![多项式类](img/B05511_14_1.jpg)。通过 `p.plot(-3.5,3.5)` 获得的多项式的默认绘图结果如下（*图
    14.1*）：
- en: '![The polynomial class](img/polyplot.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![多项式类](img/polyplot.jpg)'
- en: 'Figure 14.1: Result of the polynomial plot method'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.1：多项式绘图方法的结果
- en: 'Finally, we compute the zeros of the polynomial, which in this case are two
    real numbers:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们计算多项式的零点，在这种情况下是两个实数：
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The result can be verified by evaluating the polynomial at these points:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过在这些点上评估多项式来验证结果：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Newton polynomial
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 牛顿多项式
- en: 'The `NewtonPolyNomial` class defines a polynomial described with respect to
    the Newton basis. We let it inherit some common methods from the polynomial base
    class, for example, `polynomial.plot`, `polynomial.zeros`, and even parts of the
    `__init__` method, by using the `super` command (refer to section *Subclassing
    and Inheritance* in [Chapter 8](ch08.html "Chapter 8. Classes"), *Classes*):'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`NewtonPolyNomial` 类定义了一个以牛顿基为基准的多项式。我们通过使用 `super` 命令让它继承了一些来自多项式基类的常用方法，例如
    `polynomial.plot`、`polynomial.zeros`，甚至 `__init__` 方法的部分，如下所示（参考第 8 章的 *Subclassing
    and Inheritance* 部分，[第 8 章](ch08.html "第 8 章。类")，*类*）：'
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Once the interpolation points are given, the computation of the coefficients
    is performed by:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦给出了插值点，系数的计算就通过以下方式完成：
- en: '[PRE15]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here we used divided differences for computing the Newton representation of
    the polynomial, which is programmed as a generator here:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了差分法来计算多项式的牛顿表示，这里将其编程为一个生成器：
- en: '[PRE16]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let us briefly check how this works:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要检查一下这是如何工作的：
- en: '[PRE17]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `print` function executes the `__repr__` method of the base class and returns
    the following text:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`print` 函数执行基类的 `__repr__` 方法，并返回以下文本：'
- en: '[PRE18]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The polynomial evaluation is different from the corresponding method of the
    base class. The `Newton.PolyNomial.__call__` method needs to override `Polynomial.__call__`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 多项式评估与基类的相应方法不同。`Newton.PolyNomial.__call__` 方法需要覆盖 `Polynomial.__call__`：
- en: '[PRE19]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Finally, we give the code for the companion matrix, which overrides the corresponding
    method of the parent class, as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们给出了伴随矩阵的代码，它覆盖了父类的相应方法，如下所示：
- en: '[PRE20]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note the use of Boolean arrays. The exercises will further build on this foundation.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到使用了布尔数组。练习将进一步建立在这个基础上。
- en: Spectral clustering
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 谱聚类
- en: 'An interesting application of eigenvectors is for clustering data. Using the
    eigenvectors of a matrix derived from a distance matrix, unlabelled data can be
    separated into groups. Spectral clustering methods get their name from the use
    of the spectrum of this matrix. A distance matrix for *n* elements (for example,
    the pairwise distance between data points) is an n × n symmetric matrix. Given
    such an n × n distance matrix *M* with distance values *m[ij]*, we can create
    the Laplacian matrix of the data points as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 特征向量在聚类数据中的应用很有趣。使用从距离矩阵导出的矩阵的特征向量，未标记的数据可以被分成组。谱聚类方法的名字来源于这个矩阵的谱。一个包含**n**个元素（例如，数据点之间的成对距离）的距离矩阵是一个n
    × n的对称矩阵。给定这样的n × n距离矩阵**M**（距离值为**m[ij]**），我们可以创建数据点的拉普拉斯矩阵，如下所示：
- en: '![Spectral clustering](img/distance-1.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![谱聚类](img/distance-1.jpg)'
- en: Here, I is the identity matrix and *D* is the diagonal matrix containing the
    row sums of *M*,
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，**I**是单位矩阵，**D**是包含**M**行和的对角矩阵，
- en: '![Spectral clustering](img/B05511_14_2.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![谱聚类](img/B05511_14_2.jpg)'
- en: The data clusters are obtained from the eigenvectors of *L*. In the simplest
    case of data points with only two classes, the first eigenvector (that is, the
    one corresponding to the largest eigenvalue) is often enough to separate the data.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 数据簇是从**L**的特征向量中获得的。在只有两个类别的最简单数据点情况下，第一个特征向量（即对应于最大特征值的那个）通常足以分离数据。
- en: 'Here is an example for simple two-class clustering. The following code creates
    some 2D data points and clusters them based on the first eigenvector of the Laplacian
    matrix:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个简单二类聚类的示例。以下代码创建了一些二维数据点，并根据拉普拉斯矩阵的第一个特征向量对它们进行聚类：
- en: '[PRE21]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The eigenvector corresponding to the largest eigenvalue gives the grouping
    (for example, by thresholding at *0*) and can be shown with:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 与最大的特征值对应的特征向量给出了分组（例如，通过在**0**处进行阈值处理）并可以显示如下：
- en: '[PRE22]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The following figure (*Figure 14.2*) shows the result of spectral clustering
    of a simple two-class dataset:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图（图14.2）显示了简单二类数据集的谱聚类结果：
- en: '![Spectral clustering](img/cluster1.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![谱聚类](img/cluster1.jpg)'
- en: 'Figure 14.2: shows result of simple two-class clustering'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.2：显示简单二类聚类的结果
- en: 'For more difficult datasets and more classes, one usually takes the *k* eigenvectors
    corresponding to the *k* largest eigenvalues and then clusters the data with some
    other method, but using the eigenvectors instead of the original data points.
    A common choice is the *k*-means clustering algorithm, which is the topic of the
    next example:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更复杂的数据集和更多类别，通常取与**k**个最大特征值对应的**k**个特征向量，然后使用其他方法对数据进行聚类，但使用特征向量而不是原始数据点。一个常见的选择是**k**-均值聚类算法，这是下一个示例的主题：
- en: 'The eigenvectors are used as input to *k*-means clustering, as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 特征向量被用作**k**-均值聚类的输入，如下所示：
- en: '[PRE23]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Note that we computed the eigenvectors here using the singular value decomposition, `sl.svd`.
    As *L* is symmetric, the result is the same as if we would have used `sl.eig`,
    but the eigenvectors come already ordered corresponding to the ordering of the
    eigenvalues. We also used throw-away variables. `svd` returns a list with three
    arrays, the left and right singular vectors `U`, `V`, and the singular values
    `S`, as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在这里使用奇异值分解（`sl.svd`）计算了特征向量。由于**L**是对称的，所以结果与使用`sl.eig`相同，但特征向量已经按照特征值的顺序排列。我们还使用了废弃变量。`svd`返回一个包含三个数组的列表，即左奇异向量`U`、右奇异向量`V`和奇异值`S`，如下所示：
- en: '[PRE24]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'As we do not need `U` and `S` here, we can throw them away when unpacking the
    return value of `svd`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们这里不需要`U`和`S`，我们可以在解包`svd`的返回值时将它们丢弃：
- en: '[PRE25]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The result can be plotted using:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 结果可以使用以下方式绘制：
- en: '[PRE26]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The following figure shows the result of spectral clustering of a simple *multiclass
    dataset:*
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了简单**多类数据集**的谱聚类的结果：
- en: '![Spectral clustering](img/spectral_4class.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![谱聚类](img/spectral_4class.jpg)'
- en: 'Figure 14.3: An example of spectral clustering of a simple four class dataset.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.3：简单四类数据集的谱聚类示例。
- en: Solving initial value problems
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 求解初值问题
- en: 'In this section, we will consider the mathematical task of numerically solving
    a system of ordinary equations for given initial values:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将考虑一个数学任务，即对给定的初始值进行常微分方程组的数值求解：
- en: '*y''*(*t*) *= f*(*t, y*) *y*(*t*[0]) *= y*[0]∈ ℝ*^n*'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**y**''(*t*) *= f*(*t, y*) **y**(*t*[0]) *= y*[0]∈ ℝ*^n*'
- en: 'The solution of this problem is a function *y*. A numerical method aims at
    computing good approximations, *y[i]*≈ *y*(*t[i]*) at discrete points, the communications
    points *t[i]*, within the interval of interest [*t[0], t*[e]]. We collect the
    data that describes the problem in a class, as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的解是一个函数*y*。数值方法旨在计算好的近似值，*y[i]*≈ *y*(*t[i]*)在感兴趣的区间[*t[0], t*[e]]内的离散点*通信点*t[i]*，我们收集描述问题的数据在一个类中，如下所示：
- en: '[PRE27]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The differential equation:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 微分方程：
- en: '![Solving initial value problems](img/B05511_14_06.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![求解初值问题](img/B05511_14_06.jpg)'
- en: describes a mathematical pendulum; *y[1]* describes its angle with respect to
    the vertical axis, *g* is the gravitation constant, and *l* is its length. The
    initial angle is π/2 and the initial angular velocity is zero.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 描述了一个数学摆；*y[1]*描述了其相对于竖直轴的角度，*g*是重力常数，*l*是其长度。初始角度是π/2，初始角速度为零。
- en: 'The pendulum problem becomes an instance of the problem class, as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 摆动问题成为问题类的一个实例，如下所示：
- en: '[PRE28]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: There might be different views on the problem at hand, leading to a different
    design of the class. For example, one might want to consider the interval of independent
    variables as a part of a solution process instead of the problem definition. The
    same holds when considering initial values. They might, as we did here, be considered
    a part of the mathematical problem, while other authors might want to allow variation
    of initial values by putting them as a part of the solution process.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 对于当前的问题可能会有不同的观点，导致类的不同设计。例如，有人可能希望将独立变量的区间视为解决方案过程的一部分，而不是问题定义的一部分。当考虑初始值时，情况也是如此。它们可能，就像我们在这里所做的那样，被视为数学问题的一部分，而其他作者可能希望允许通过将它们作为解决方案过程的一部分来改变初始值。
- en: 'The solution process is modeled as another class:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 解决过程被建模为另一个类：
- en: '[PRE29]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We continue by first defining two discretization schemes:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续定义两个离散化方案：
- en: 'Explicit **Euler** method:'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显式**欧拉**方法：
- en: '[PRE30]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Classical **Runge-Kutta four-stage** method (**RK4**):'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 经典**龙格-库塔四阶**方法（**RK4**）：
- en: '[PRE31]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'With these, we can create instances to obtain the corresponding discretized
    versions of the pendulum ODE:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些工具，我们可以创建实例以获得摆动常微分方程（ODE）的相应离散化版本：
- en: '[PRE32]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We can solve the two discrete models and plot the solution and the angle difference:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以求解这两个离散模型并绘制解和角度差：
- en: '[PRE33]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '![Solving initial value problems](img/ivp_example.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![求解初值问题](img/ivp_example.jpg)'
- en: 'Figure14.4: Pendulum simulation with the explicit Euler method and comparison
    with the results of the more accurate Runge–Kutta 4 method'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.4：使用显式欧拉方法和与更精确的龙格-库塔4方法结果的比较进行摆动模拟
- en: It is worthwhile discussing alternative class designs. What should be put in
    separate classes, what should be bundled into the same class?
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 讨论替代类设计是值得的。应该将什么放入单独的类中，什么应该捆绑到同一个类中？
- en: We strictly separated the mathematical problem from the numerical method. Where
    should the initial values go? Should they be part of the problem or part of the
    solver? Or should they be left as input parameter for the solve method of the
    solver instance? One might even design the program so that it allows several possibilities.
    The decision to use one of these alternatives depends on the future use of this
    program. Looping over various initial values as in parameter identification would
    be eased by leaving the initial values as input parameters for the solve method.
    On the other hand, simulating different model variants with the same initial values
    would motivate to couple the initial values to the problem.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们严格地将数学问题与数值方法分开。初始值应该放在哪里？它们应该是问题的一部分还是求解器的一部分？或者它们应该作为求解器实例求解方法的输入参数？甚至可以设计程序以允许几种可能性。使用这些替代方案的决定取决于该程序未来的使用。将初始值作为求解方法输入参数可以简化像参数识别这样的各种初始值的循环。另一方面，使用相同的初始值模拟不同的模型变体会促使将初始值与问题耦合。
- en: We presented for simplicity only solvers with constant and given step size.
    Is the design of the `IVPsolver` class appropriate for a future extension of adaptive
    methods, where a tolerance rather than a step size is given?
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了简单起见，我们只展示了具有恒定和给定步长的求解器。`IVPsolver`类的设计是否适合未来自适应方法的扩展，其中给出的是容差而不是步长？
- en: We suggested earlier to use a generator construction for the stepping mechanism.
    Adaptive methods need to reject steps from time to time. Is this need conflicting
    with the design of the stepping mechanism in `IVPsolver.onestepper`?
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们之前建议使用生成器构造来构建步进机制。自适应方法需要不时地拒绝步骤。这种需求是否与 `IVPsolver.onestepper` 中步进机制的设计相冲突？
- en: We encourage you to check the design of the two SciPy tools for solving initial
    values, namely `scipy.integrate.ode` and `scipy.integrate.odeint`.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们鼓励您检查用于求解初值的两个 SciPy 工具的设计，即 `scipy.integrate.ode` 和 `scipy.integrate.odeint`。
- en: Summary
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Most of what we explained in this book is bundled into the three longer examples
    of this chapter. They mimic code development and give prototypes, which you are
    encouraged to alter and confront with your own ideas.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中所解释的大部分内容都包含在本章三个较长的示例中。它们模仿代码开发并提供原型，鼓励您对其进行修改并与自己的想法进行对比。
- en: You saw that code in scientific computing can have its own flavor due to its
    strong relation with mathematically defined algorithms and that it is often wise
    to keep the relationship between code and formula visible. Python has techniques
    for this, as you have seen.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经看到，科学计算中的代码可以有自己的特色，因为它与数学定义的算法有很强的关联，并且通常明智的做法是保持代码与公式之间的关系可见。Python 有这样的技术，正如您所看到的。
- en: Exercises
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: '**Ex. 1** → Implement a method `__add__`, which constructs a new polynomial
    *p+q* by adding two given polynomials *p* and *q*. In monomial form, polynomials
    are added by just adding the coefficients, whereas in Newton form, the coefficients
    depend on the abscissa *x[i]* of the interpolation points. Before adding the coefficients
    of both polynomials, the polynomial *q* has to get new interpolation points with
    the property that their abscissa *x[i]* coincides with those of *p* and the method `__changepoints__` has
    to be provided for that. It should change the interpolation points and return
    a new set of coefficients.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '**例 1** → 实现一个名为 `__add__` 的方法，该方法通过添加两个给定的多项式 *p* 和 *q* 来构建一个新的多项式 *p+q*。在单项式形式中，多项式通过仅添加系数来相加，而在牛顿形式中，系数依赖于插值点的横坐标
    *x[i]*。在添加两个多项式的系数之前，多项式 *q* 必须获得具有横坐标 *x[i]* 与 *p* 相同的新插值点，并且必须提供 `__changepoints__`
    方法来完成此操作。它应该更改插值点并返回一组新的系数。'
- en: '**Ex. 2** → Write conversion methods to convert a polynomial from Newton form
    into monomial form and vice versa.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '**例 2** → 编写转换方法，将多项式从牛顿形式转换为单项式形式，反之亦然。'
- en: '**Ex. 3** → Write a method called `add_point` that takes a polynomial *q* and
    a tuple *(x,y)* as parameters and returns a new polynomial that interpolates `self.points`
    and *(x,y)*.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '**例 3** → 编写一个名为 `add_point` 的方法，该方法接受一个多项式 *q* 和一个元组 *(x,y)* 作为参数，并返回一个新的多项式，该多项式插值
    `self.points` 和 *(x,y)*。'
- en: '**Ex. 4** → Write a class called `LagrangePolynomial` that implements polynomials
    in Lagrange form and inherits as much as possible from the polynomial base class.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**例 4** → 编写一个名为 `LagrangePolynomial` 的类，该类实现拉格朗日形式的多项式，并尽可能多地继承多项式基类。'
- en: '**Ex. 5** → Write tests for the polynomial class.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**例 5** → 为多项式类编写测试。'
