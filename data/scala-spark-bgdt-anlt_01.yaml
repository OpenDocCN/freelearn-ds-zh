- en: Introduction to Scala
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scala简介
- en: '*"I''m Scala. I''m a scalable, functional and object-oriented programming language.
    I can grow with you and you can play with me by typing one-line expressions and
    observing the results instantly"*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: “我是Scala。我是一种可扩展的、函数式的、面向对象的编程语言。我可以随着你的成长而成长，你可以通过输入一行表达式来与我互动，并立即观察结果。”
- en: '- Scala Quote'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '- Scala引用'
- en: 'In last few years, Scala has observed steady rise and wide adoption by developers
    and practitioners, especially in the fields of data science and analytics. On
    the other hand, Apache Spark which is ;written in Scala is a fast and general
    engine for large-scale data processing. Spark''s success is due to many factors:
    easy-to-use API, clean programming model, performance, and so on. Therefore, naturally,
    Spark has more support for Scala: more APIs are available for Scala compared to
    Python or Java; although, new Scala APIs are available before those for Java,
    Python, and R.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的几年里，Scala在数据科学和分析领域特别是开发人员和从业者中得到了稳步增长和广泛采用。另一方面，使用Scala编写的Apache Spark是用于大规模数据处理的快速通用引擎。Spark的成功归功于许多因素：易于使用的API、清晰的编程模型、性能等等。因此，自然而然地，Spark对Scala的支持更多：与Python或Java相比，Scala有更多的API可用；尽管如此，新的Scala
    API在Java、Python和R之前就已经可用。
- en: Now that before we start writing your data analytics program using Spark and
    Scala (part II), we will first get familiar with Scala's functional programming
    concepts, object oriented features and the Scala collection APIs in detail (part
    I). As a starting point, we will provide a brief introduction to Scala in this
    chapter. We will cover some basic aspects of Scala including it's history and
    purposes. Then we will see how to install Scala on different platforms including
    Windows, Linux, and Mac OS so that your data analytics programs can be written
    on your favourite editors and IDEs. Later in this chapter, we will provide a comparative
    analysis between Java and Scala. Finally, we will dive into Scala programming
    with some examples.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始使用Spark和Scala（第二部分）编写数据分析程序之前，我们将首先详细了解Scala的函数式编程概念、面向对象的特性和Scala集合API（第一部分）。作为起点，我们将在本章节中简要介绍Scala。我们将涵盖Scala的一些基本方面，包括其历史和目的。然后我们将看到如何在不同平台上安装Scala，包括Windows、Linux和Mac
    OS，以便您可以在您喜爱的编辑器和IDE上编写数据分析程序。在本章的后面，我们将对Java和Scala进行比较分析。最后，我们将通过一些示例深入学习Scala编程。
- en: 'In a nutshell, the following topics will be covered:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，以下主题将被涵盖：
- en: History and purposes of Scala
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Scala的历史和目的
- en: Platforms and editors
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平台和编辑器
- en: Installing and setting up Scala
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装和设置Scala
- en: 'Scala: the scalable language'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Scala：可扩展的语言
- en: Scala for Java programmers
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向Java程序员的Scala
- en: Scala for the beginners
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Scala初学者
- en: Summary
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 摘要
- en: History and purposes of Scala
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scala的历史和目的
- en: Scala is a general-purpose programming language that comes with support of `functional
    programming` and a strong `static type` system. The source code of Scala is intended
    to be compiled into `Java` bytecode, so that the resulting executable code can
    be run on `Java virtual machine` (JVM).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Scala是一种通用编程语言，支持`函数式编程`和强大的`静态类型`系统。Scala的源代码旨在编译成`Java`字节码，以便生成的可执行代码可以在`Java虚拟机`（JVM）上运行。
- en: Martin Odersky started the design of Scala back in 2001 at the **École Polytechnique
    Fédérale de Lausanne** (**EPFL**). It was an extension of his work on Funnel,
    which is a programming language that uses functional programming and Petri nets.
    The first public release appears in 2004 but with only on the Java platform support.
    Later on, it was followed by .`NET` framework in June 2004.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Martin Odersky于2001年在**洛桑联邦理工学院**（**EPFL**）开始设计Scala。这是他在Funnel上的工作的延伸，Funnel是一种使用函数式编程和Petri网的编程语言。首次公开发布是在2004年，但只支持Java平台。随后，在2004年6月，.NET框架也开始支持。
- en: Scala has become very popular and experienced wide adoptions because it not
    only supports the object-oriented programming paradigm, but it also embraces the
    functional programming concepts. In addition, although Scala's symbolic operators
    are hardly easy to read, compared to Java, most of the Scala codes are comparatively
    concise and easy to read -e.g. Java is too verbose.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Scala因不仅支持面向对象的编程范式，而且还包含了函数式编程概念，因此变得非常受欢迎并得到了广泛的采用。此外，尽管Scala的符号操作符很难阅读，与Java相比，大多数Scala代码相对简洁易读——例如，Java太啰嗦了。
- en: 'Like any other programming languages, Scala was prosed and developed for specific
    purposes. Now, the question is, why was Scala created and what problems does it
    solve? To answer these questions, Odersky said in his blog: ;'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他编程语言一样，Scala是为特定目的而提出和开发的。现在，问题是，为什么创建了Scala，它解决了什么问题？为了回答这些问题，Odersky在他的博客中说：
- en: '"The work on Scala stems from a research effort to develop better language
    support for component software. There are two hypotheses that we would like to
    validate with the Scala experiment. First, we postulate that a programming language
    for component software needs to be scalable in the sense that the same concepts
    can describe small as well as large parts. Therefore, we concentrate on mechanisms
    for abstraction, composition, and decomposition, rather than adding a large set
    of primitives, which might be useful for components at some level of scale but
    not at other levels. Second, we postulate that scalable support for components
    can be provided by a programming language which unifies and generalizes object-oriented
    and functional programming. For statically typed languages, of which Scala is
    an instance, these two paradigms were up to now largely separate."'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: “Scala的工作源于开发组件软件的更好语言支持的研究工作。我们希望通过Scala实验验证两个假设。首先，我们假设组件软件的编程语言需要在描述小部分和大部分时使用相同的概念。因此，我们集中于抽象、组合和分解的机制，而不是添加大量原语，这些原语在某个规模级别上可能对组件有用，但在其他级别上则不是。其次，我们假设组件的可扩展支持可以通过统一和泛化面向对象和函数式编程的编程语言来提供。对于Scala这样的静态类型语言，这两种范式到目前为止基本上是分开的。”
- en: Nevertheless, pattern matching and higher order functions, and so on, are also
    provided in Scala, not to fill the gap between FP and OOP, but because ;they are
    typical features of functional programming. For this, it has some incredibly powerful
    pattern-matching features, which are an actor-based concurrency framework. Moreover,
    it has the support of the first- and higher-order functions. In summary, the name
    "Scala" is a portmanteau of scalable language, signifying that it is designed
    to grow with the demands of its users.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Scala也提供了模式匹配和高阶函数等功能，不是为了填补函数式编程和面向对象编程之间的差距，而是因为它们是函数式编程的典型特征。因此，它具有一些非常强大的模式匹配功能，还有一个基于actor的并发框架。此外，它还支持一阶和高阶函数。总之，"Scala"这个名字是可伸缩语言的混成词，意味着它被设计成能够满足用户需求的语言。
- en: Platforms and editors
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 平台和编辑器
- en: 'Scala runs on **Java Virtual Machine** (**JVM**), which makes Scala a good
    choice for Java programmers too who would like to have a functional programming
    flavor in their codes. There are lots of options when it comes to editors. It''s
    better for you to spend some time making some sort of a comparative study between
    the available editors because being comfortable with an IDE is one of the key
    factors for a successful programming experience. Following are some options to
    choose from:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Scala在**Java虚拟机**（**JVM**）上运行，这使得Scala对于希望在代码中添加函数式编程风格的Java程序员来说是一个不错的选择。在编辑器方面有很多选择。最好花一些时间对可用的编辑器进行比较研究，因为熟悉IDE是成功编程经验的关键因素之一。以下是一些可供选择的选项：
- en: Scala IDE
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Scala IDE
- en: Scala plugin for Eclipse
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Eclipse的Scala插件
- en: IntelliJ IDEA
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IntelliJ IDEA
- en: Emacs
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Emacs
- en: VIM
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: VIM
- en: Scala support programming on Eclipse has several advantages using numerous beta
    plugins. Eclipse provides some exciting features such as local, remote, and high-level
    debugging facilities with semantic highlighting and code completion for Scala.
    You can use Eclipse for Java as well as Scala application development with equal
    ease. However, I would also suggest Scala IDE ([http://scala-ide.org/](http://scala-ide.org/))--it's
    a full-fledged Scala editor based on Eclipse and customized with a set of interesting
    features (for example, Scala worksheets, ScalaTest support, Scala refactoring,
    and so on). ;
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Scala在Eclipse上的编程支持使用了许多beta插件。Eclipse提供了一些令人兴奋的功能，如本地、远程和高级调试功能，以及用于Scala的语义突出显示和代码补全。您可以使用Eclipse同样轻松地进行Java和Scala应用程序开发。但是，我还建议Scala
    IDE（[http://scala-ide.org/](http://scala-ide.org/)）- 这是一个基于Eclipse的全功能Scala编辑器，并且定制了一系列有趣的功能（例如Scala工作表、ScalaTest支持、Scala重构等）；
- en: The second best option, in my view, is the IntelliJ IDEA. The first release
    came in 2001 as the first available Java IDEs with advanced code navigation and
    refactoring capabilities integrated. According to the InfoWorld report (see at
    [http://www.infoworld.com/article/2683534/development-environments/infoworld-review--top-java-programming-tools.html](http://www.infoworld.com/article/2683534/development-environments/infoworld-review--top-java-programming-tools.html)),
    out of the four top Java programming IDE (that is, Eclipse, IntelliJ IDEA, NetBeans,
    and JDeveloper), IntelliJ received the highest test center score of 8.5 out of
    10.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，第二个最佳选择是IntelliJ IDEA。第一个版本于2001年发布，是第一个具有高级代码导航和重构功能的Java IDE。根据InfoWorld报告（请参阅[http://www.infoworld.com/article/2683534/development-environments/infoworld-review--top-java-programming-tools.html](http://www.infoworld.com/article/2683534/development-environments/infoworld-review--top-java-programming-tools.html)），在四个顶级Java编程IDE（即Eclipse、IntelliJ
    IDEA、NetBeans和JDeveloper）中，IntelliJ获得了最高的测试中心评分8.5分（满分10分）。
- en: 'The corresponding scoring is shown in the following figure:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 相应的评分如下图所示：
- en: '![](img/00172.jpeg)**Figure 1:** Best IDEs for Scala/Java developers'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/00172.jpeg)**图1：** Scala/Java开发人员最佳IDE'
- en: From the preceding ;figure, you may be interested in using other IDEs such as
    NetBeans and JDeveloper too. Ultimately, the choice is an everlasting debate among
    the developers, which means the final choice is yours.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 从上面的图中，您可能对使用其他IDE，如NetBeans和JDeveloper也感兴趣。最终，选择是开发人员之间永恒的辩论，这意味着最终选择取决于您。
- en: Installing and setting up Scala
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装和设置Scala
- en: As we have already mentioned, Scala uses JVM, therefore make sure you have Java
    installed ;on your machine. If not, refer to the next subsection, which shows
    how to install Java on Ubuntu. In this section, at first, we will show you how
    to install Java 8 on Ubuntu. Then, we will see how to install Scala on Windows,
    Mac OS, and Linux.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经提到的，Scala使用JVM，因此请确保您的机器上已安装Java。如果没有，请参考下一小节，其中介绍了如何在Ubuntu上安装Java。在本节中，首先我们将向您展示如何在Ubuntu上安装Java
    8。然后，我们将看到如何在Windows、Mac OS和Linux上安装Scala。
- en: Installing Java
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Java
- en: 'For simplicity, we will show how to install Java 8 on an Ubuntu 14.04 LTS 64-bit
    machine. But for Windows and Mac OS, it would be better to invest some time on
    Google to know how. For a minimum clue for the Windows users: refer to this link
    for details [https://java.com/en/download/help/windows_manual_download.xml](https://java.com/en/download/help/windows_manual_download.xml)[.](https://java.com/en/download/help/windows_manual_download.xml.)'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为简单起见，我们将展示如何在Ubuntu 14.04 LTS 64位机器上安装Java 8。但是对于Windows和Mac OS，最好花一些时间在Google上了解一下。对于Windows用户的最小线索：请参考此链接获取详细信息[https://java.com/en/download/help/windows_manual_download.xml](https://java.com/en/download/help/windows_manual_download.xml)。
- en: 'Now, let''s see how to install Java 8 on Ubuntu with step-by-step commands
    and instructions. At first, check whether ;Java is already installed:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何通过逐步命令和说明在Ubuntu上安装Java 8。首先，检查Java是否已安装：
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If it returns `The program java cannot be found in the following packages`,
    Java hasn''t been installed yet. Then you would like to execute the following
    command to get rid of:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果返回`程序java在以下包中找不到`，则说明Java尚未安装。然后您可以执行以下命令来摆脱这个问题：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This will install the **Java Runtime Environment** (**JRE**). However, if you
    may instead need the **Java Development Kit** (**JDK**), which is usually needed
    to compile Java applications on Apache Ant, Apache Maven, Eclipse, and IntelliJ
    IDEA.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这将安装**Java Runtime Environment**（**JRE**）。但是，如果您可能需要**Java Development Kit**（**JDK**），通常需要在Apache
    Ant、Apache Maven、Eclipse和IntelliJ IDEA上编译Java应用程序。
- en: 'The Oracle JDK is the official JDK, however, it is no longer provided by Oracle
    as a default installation for Ubuntu. You can still install it using apt-get.
    To install any version, first execute the following commands:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Oracle JDK是官方JDK，但是Oracle不再将其作为Ubuntu的默认安装提供。您仍然可以使用apt-get安装它。要安装任何版本，首先执行以下命令：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Then, depending on the version you want to install, execute one of the following
    commands:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，根据您要安装的版本，执行以下命令之一：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'After installing, don''t forget to set the Java home environmental variable.
    Just apply the following ;commands (for the simplicity, we assume that Java is
    installed at `/usr/lib/jvm/java-8-oracle`):'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，不要忘记设置Java主目录环境变量。只需应用以下命令（为简单起见，我们假设Java安装在`/usr/lib/jvm/java-8-oracle`）：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, let''s see the `Java_HOME` as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一下`Java_HOME`如下：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You should observe the following result on Terminal:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该在终端上观察到以下结果：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, let''s check to make sure that Java has been installed successfully by
    issuing the following command (you might see the latest version!):'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过输入以下命令来检查Java是否已成功安装（您可能会看到最新版本！）：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You will get the following output:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 您将获得以下输出：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Excellent! Now you have Java installed on your machine, thus you're ready Scala
    codes once it is installed. Let's do this in the next few subsections.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在您的机器上已经安装了Java，因此一旦安装了Scala，您就可以准备好编写Scala代码了。让我们在接下来的几个小节中做这个。
- en: Windows
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Windows
- en: 'This part will focus on installing Scala on the PC with Windows 7, but in the
    end, it won''t matter which version of Windows you to run at the moment:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分将重点介绍在Windows 7上安装Scala的PC，但最终，您当前运行的Windows版本将不重要：
- en: 'The first step is to download a zipped file of Scala from the official site.
    You will find it at [https://www.Scala-lang.org/download/all.html](https://www.scala-lang.org/download/all.html).
    Under the other resources section of this page, you will find a list of the archive
    files from which you can install Scala. We will choose to download the zipped
    file for Scala 2.11.8, as shown in the following figure:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是从官方网站下载Scala的压缩文件。您可以在[https://www.Scala-lang.org/download/all.html](https://www.scala-lang.org/download/all.html)找到它。在此页面的其他资源部分，您将找到一个存档文件列表，您可以从中安装Scala。我们将选择下载Scala
    2.11.8的压缩文件，如下图所示：
- en: '![](img/00174.gif)**Figure 2:** Scala installer for Windows'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/00174.gif)**图2：** Windows的Scala安装程序'
- en: 'After the downloading has finished, unzip the file and place it in your favorite
    folder. You can also rename the file Scala for navigation flexibility. Finally,
    a `PATH` variable needs to be created for Scala to be globally seen on your OS.
    For this, navigate to Computer | Properties, as shown in the following figure:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载完成后，解压文件并将其放在您喜欢的文件夹中。您还可以将文件重命名为Scala以提高导航灵活性。最后，需要为Scala创建一个`PATH`变量，以便在您的操作系统中全局看到。为此，请转到计算机
    | 属性，如下图所示：
- en: '![](img/00176.jpeg)**Figure 3:** Environmental variable tab on windows'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/00176.jpeg)**图3：** Windows上的环境变量选项卡'
- en: 'Select Environment Variables from there and get the location of the `bin` folder
    of Scala; then, append it to the `PATH` environment variable. Apply the changes
    and then press OK, ;as shown in the following screenshot:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从中选择环境变量，并获取Scala的`bin`文件夹的位置；然后，将其附加到`PATH`环境变量。应用更改，然后按OK，如下截图所示：
- en: '![](img/00178.jpeg)**Figure 4:** Adding environmental variables for Scala'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/00178.jpeg)**图4：** 为Scala添加环境变量'
- en: 'Now, you are ready to go for the Windows installation. Open the CMD and just
    type `scala`. If you were successful in the installation process, then you should
    see an output similar to the following screenshot:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您可以开始进行Windows安装。打开CMD，只需输入`scala`。如果安装过程成功，您应该会看到类似以下截图的输出：
- en: '![](img/00182.jpeg)**Figure 5:** Accessing Scala from "Scala shell"'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/00182.jpeg)**图5：** 从“Scala shell”访问Scala'
- en: Mac OS
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Mac OS
- en: 'It''s time now to install Scala on your Mac. There are lots of ways in which
    you can install Scala on your Mac, and here, we are going to mention two of them:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候在您的Mac上安装Scala了。有很多种方法可以在Mac上安装Scala，在这里，我们将提到其中两种：
- en: Using Homebrew installer
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Homebrew安装程序
- en: At first, check your system to see whether it has Xcode installed or not because
    it's required in this step. You can install it from the Apple App Store free of
    charge.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，检查您的系统是否已安装Xcode，因为这一步骤需要。您可以免费从Apple App Store安装它。
- en: 'Next, you need to install `Homebrew` from the terminal by running the following
    command in your terminal:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，您需要通过在终端中运行以下命令来安装`Homebrew`：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Note: The preceding ;command is changed by the Homebrew guys from time to time.
    If the command doesn''t seem to be working, check the Homebrew website for the
    latest incantation: [http://brew.sh/](http://brew.sh/).'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：Homebrew的前面的命令会不时更改。如果命令似乎无效，请查看Homebrew网站获取最新的命令：[http://brew.sh/](http://brew.sh/)。
- en: Now, you are ready to go and install Scala by typing this command `brew install
    scala` ;in the terminal.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您已经准备好通过在终端中键入此命令`brew install scala`来安装Scala。
- en: 'Finally, you are ready to go by simply typing Scala in your terminal (the second
    line) and you will observe the following on your terminal: ;'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，您只需在终端中输入Scala，就可以开始了（第二行），您将在终端上看到以下内容：
- en: '![](img/00226.jpeg)**Figure 6**: Scala shell on macOS'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/00226.jpeg)**图6：** macOS上的Scala shell'
- en: Installing manually
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 手动安装
- en: 'Before installing Scala manually, choose your preferred version of Scala and
    download the corresponding `.tgz` file of that version `Scala-verion.tgz` from
    [http://www.Scala-lang.org/download/](http://www.scala-lang.org/download/). After
    downloading your preferred version of Scala, extract it as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在手动安装Scala之前，选择您喜欢的Scala版本，并从[http://www.scala-lang.org/download/](http://www.scala-lang.org/download/)下载相应版本的`.tgz`文件`Scala-verion.tgz`。下载您喜欢的Scala版本后，按以下步骤提取：
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then, move it to `/usr/local/share` as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将其移动到`/usr/local/share`，如下所示：
- en: '[PRE11]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, to make the installation permanent, execute the following commands:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要使安装永久生效，请执行以下命令：
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: That's it. Now, let's see how it can be done on Linux distributions like Ubuntu
    in the next subsection.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。现在，让我们看看在下一小节中如何在Ubuntu等Linux发行版上完成这个过程。
- en: Linux
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Linux
- en: 'In this subsection, we will show you the installation procedure of Scala on
    the Ubuntu distribution of Linux. Before starting, let''s check to make sure Scala
    is installed properly. Checking this is straightforward using the following command:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节中，我们将向您展示如何在Linux的Ubuntu发行版上安装Scala。在开始之前，让我们检查一下确保Scala已经正确安装。使用以下命令检查这一点非常简单：
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If Scala is already installed on your system, you should get the following
    message on your terminal:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Scala已经安装在您的系统上，您应该在终端上收到以下消息：
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Note that, during the writing of this installation, we used the latest version
    of Scala, that is, 2.11.8\. If you do not have Scala installed on your system,
    make sure you install it before proceeding to the next step. ; You can download
    the latest version of Scala from the Scala website at [http://www.scala-lang.org/download/](http://www.scala-lang.org/download/)
    (for a clearer view, refer to *Figure 2*). For ease, let''s download Scala 2.11.8,
    as follows: ;'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在编写本安装过程时，我们使用了Scala的最新版本，即2.11.8。如果您的系统上没有安装Scala，请确保在进行下一步之前安装它。您可以从Scala网站[http://www.scala-lang.org/download/](http://www.scala-lang.org/download/)下载最新版本的Scala（更清晰的视图，请参考*图2*）。为了方便起见，让我们下载Scala
    2.11.8，如下所示：
- en: '[PRE15]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: After the download has been finished, you should find the Scala tar file in
    the download folder.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 下载完成后，您应该在下载文件夹中找到Scala的tar文件。
- en: 'The user should first go into the `Download` directory with the following command:
    `$ cd /Downloads/`. Note that the name of the downloads folder may change depending
    on the system''s selected language.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 用户应该首先使用以下命令进入`Download`目录：`$ cd /Downloads/`。请注意，下载文件夹的名称可能会根据系统选择的语言而变化。
- en: 'To extract the Scala `tar` file from its location or more, type the following
    command. Using this, the Scala tar file can be extracted from the Terminal:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要从其位置提取Scala的`tar`文件或更多，请输入以下命令。使用这个命令，Scala的tar文件可以从终端中提取：
- en: '[PRE16]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, move the Scala distribution to the user''s perspective (for example, `/usr/local/scala/share`)
    by typing the following command or doing it manually:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过以下命令或手动将Scala分发到用户的视角（例如，`/usr/local/scala/share`）：
- en: '[PRE17]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Move to your home directory issue using the following command:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 进入您的主目录问题使用以下命令：
- en: '[PRE18]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then, set the Scala home using the following commands:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用以下命令设置Scala主目录：
- en: '[PRE19]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, make the change permanent for the session by using the following command:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用以下命令使更改在会话中永久生效：
- en: '[PRE20]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'After the installation has been completed, you should better to verify it using
    the following command:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，最好使用以下命令进行验证：
- en: '[PRE21]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If Scala has successfully been configured on your system, you should get the
    following message on your terminal:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Scala已经成功配置在您的系统上，您应该在终端上收到以下消息：
- en: '[PRE22]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Well done! Now, let''s enter into the Scala shell by typing the ;`scala` command
    on the terminal, as shown in the following figure:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！现在，让我们通过在终端上输入`;scala`命令来进入Scala shell，如下图所示：
- en: '**![](img/00033.jpeg)****Figure 7:** Scala shell on Linux (Ubuntu distribution)'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**![](img/00033.jpeg)****图7：** Linux上的Scala shell（Ubuntu发行版）'
- en: 'Finally, you can also install Scala using the apt-get command, as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您也可以使用apt-get命令安装Scala，如下所示：
- en: '[PRE23]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This command will download the latest version of Scala (that is, 2.12.x). However,
    Spark does not have support for Scala 2.12 yet (at least when we wrote this chapter).
    Therefore, we would recommend the manual installation described earlier.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将下载Scala的最新版本（即2.12.x）。然而，Spark目前还不支持Scala 2.12（至少在我们写这一章节时是这样）。因此，我们建议使用前面描述的手动安装。
- en: 'Scala: the scalable language'
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scala：可伸缩语言
- en: 'The name Scala comes from a scalable language because Scala''s concepts scale
    well to large programs. Some programs in other languages will take tens of lines
    to be coded, but in Scala, you will get the power to express the general patterns
    and concepts of programming in a concise and effective manner. In this section,
    we will describe some exciting features of Scala that Odersky has created for
    us:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Scala的名称来自于可伸缩语言，因为Scala的概念很好地适用于大型程序。其他语言中的一些程序可能需要编写数十行代码，但在Scala中，您将获得以简洁而有效的方式表达编程的一般模式和概念的能力。在本节中，我们将描述Odersky为我们创建的Scala的一些令人兴奋的特性：
- en: Scala is object-oriented
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scala是面向对象的
- en: Scala is a very good example of an object-oriented language. To define a type
    or behavior for your objects you need to use the notion of classes and traits,
    which will be explained later, in the next chapter. Scala doesn't support direct
    multiple inheritances, but to achieve this structure, you need to use Scala's
    extension of the **subclassing** and **mixing-based composition**. This will be
    discussed in later chapters.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Scala是面向对象语言的一个很好的例子。要为您的对象定义类型或行为，您需要使用类和特征的概念，这将在下一章节中进行解释。Scala不支持直接的多重继承，但要实现这种结构，您需要使用Scala的**子类化**和**基于混合的组合**。这将在后面的章节中讨论。
- en: Scala is functional
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scala是功能性的
- en: Functional programming treats functions like first-class citizens. In Scala,
    this is achieved with syntactic sugar and objects that extend traits (like *Function2*),
    but this is how functional programming is achieved in Scala. Also, Scala defines
    a simple and easy way to define **anonymous** **functions** (functions without
    names). It also supports higher-order functions and it allows nested functions**.**
    The syntax of these concepts will be explained in deeper details in the coming
    chapters.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程将函数视为一等公民。在Scala中，通过语法糖和扩展特性（如*Function2*）来实现这一点，但这就是Scala中实现函数式编程的方式。此外，Scala定义了一种简单易行的方法来定义**匿名**
    **函数**（没有名称的函数）。它还支持高阶函数，并允许嵌套函数**。**这些概念的语法将在接下来的章节中详细解释。
- en: Also, it helps you to code in an immutable way, and by this, you can easily
    apply it to parallelism with synchronization and concurrency.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，它还可以帮助您以不可变的方式编码，通过这种方式，您可以轻松地将其应用于同步和并发的并行处理。
- en: Scala is statically typed
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scala是静态类型的
- en: Unlike the other statically typed languages like Pascal, Rust, and so on, Scala
    does not expect you to provide redundant type information. You don't have to specify
    the type in most cases. Most importantly, you don't even need to repeat them again.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 与Pascal、Rust等其他静态类型语言不同，Scala不要求您提供冗余的类型信息。在大多数情况下，您不必指定类型。最重要的是，您甚至不需要再次重复它们。
- en: 'A programming language is called statically typed if the type of a variable
    is known at compile time: this also means that, as a programmer, you must specify
    what the type of each variable is. For example, Scala, Java, C, OCaml, Haskell,
    and C++, and so on. On the other hand, Perl, Ruby, Python, and so on are dynamically
    typed languages, where the type is not associated with the variables or fields,
    but with the runtime values.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在编译时知道变量的类型，则编程语言被称为静态类型：这也意味着作为程序员，您必须指定每个变量的类型。例如，Scala、Java、C、OCaml、Haskell、C++等。另一方面，Perl、Ruby、Python等是动态类型语言，其中类型与变量或字段无关，而与运行时值有关。
- en: The statically typed nature of Scala ensures that all kinds of checking are
    done by the compiler. This extremely powerful feature of Scala helps you find/catch
    most trivial bugs and errors at a very early stage, before being executed.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Scala的静态类型特性确保编译器完成了所有类型的检查。Scala这一极其强大的特性帮助您在执行之前找到/捕获大多数微不足道的错误和错误。
- en: Scala runs on the JVM
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scala在JVM上运行
- en: Just like Java, Scala is also compiled into bytecode which can easily be executed
    by the JVM. This means that the runtime platforms of Scala and Java are the same
    because both generate bytecodes as the compilation output. So, you can easily
    switch from Java to Scala, you can ;and also easily integrate both, or even use
    Scala in your Android application to add a functional flavor. ;
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 就像Java一样，Scala也被编译成字节码，这可以很容易地由JVM执行。这意味着Scala和Java的运行时平台是相同的，因为两者都生成字节码作为编译输出。因此，您可以轻松地从Java切换到Scala，您也可以轻松地集成两者，甚至在Android应用程序中使用Scala添加功能风格。
- en: Note that, while using Java code in a Scala program is quite easy, the opposite
    is very difficult, mostly because of Scala's syntactic sugar.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，虽然在Scala程序中使用Java代码非常容易，但相反的情况非常困难，主要是因为Scala的语法糖。
- en: Also, just like the `javac` command, which compiles Java code into bytecode,
    Scala has the `scalas` command, which compiles the Scala code into bytecode.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 与`javac`命令一样，它将Java代码编译成字节码，Scala也有`scalas`命令，它将Scala代码编译成字节码。
- en: Scala can execute Java code
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scala可以执行Java代码
- en: As mentioned earlier, Scala can also be used to execute your Java code. Not
    just installing your Java code; it also enables you to use all the available classes
    from the Java SDK, and even your own predefined classes, projects, and packages
    right in the Scala environment.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Scala也可以用于执行您的Java代码。不仅安装您的Java代码；它还使您能够在Scala环境中使用Java SDK中的所有可用类，甚至您自己预定义的类、项目和包。
- en: Scala can do concurrent and ;synchronized processing
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scala可以进行并发和同步处理
- en: Some programs in other languages will take tens of lines to be coded, but in
    Scala, you will get the power to express the general patterns and concepts of
    programming in a concise and effective manner. Also, it helps you to code in an
    immutable way, and by this, you can easily apply it to parallelism with synchronization
    and concurrency.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 其他语言中的一些程序可能需要数十行代码，但在Scala中，您将获得以简洁有效的方式表达编程的一般模式和概念的能力。此外，它还可以帮助您以不可变的方式编码，通过这种方式，您可以轻松地将其应用于同步和并发的并行处理。
- en: Scala for Java programmers
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java程序员的Scala
- en: Scala has a set of features that completely differ from Java. In this section,
    we will discuss some of these features. This section will be helpful for those
    who are from a Java background or are at least familiar with basic Java syntax
    and semantics.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Scala具有一组与Java完全不同的特性。在本节中，我们将讨论其中一些特性。对于那些来自Java背景或至少熟悉基本Java语法和语义的人来说，本节将是有帮助的。
- en: All types are objects
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 所有类型都是对象
- en: As mentioned earlier, every value in Scala will look like an object. This statement
    means everything looks like an object, but some of them do not actually object
    and you will see the interpretation of this in the coming chapters (for example,
    ;the difference between the reference types and the primitive types still exists
    in Scala, but it hides it for the most part). For example, in Scala, strings are
    implicitly converted to collections of characters, but not in Java!
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Scala中的每个值看起来都像一个对象。这意味着一切看起来都像对象，但其中一些实际上并不是对象，您将在接下来的章节中看到这一解释（例如，在Scala中，字符串会被隐式转换为字符集合，但在Java中不会！）
- en: Type inference
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型推断
- en: If you are not familiar with the term, it is nothing but the deduction of types
    at compile time. Hold on, isn't that what dynamic typing means? Well, no. Notice
    that I said deduction of types; this is drastically different from what dynamically
    typed languages do, and another thing is, it is done at compile time and not runtime.
    Many languages have this built in, but the implementation varies from one language
    to another. This might be confusing at the beginning, but it will become clearer
    with code examples. Let's jump into the Scala REPL for some experimentation.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不熟悉这个术语，那就是在编译时推断类型。等等，这不就是动态类型的意思吗？嗯，不是。请注意，我说的是类型的推断；这与动态类型语言所做的事情完全不同，另一件事是，它是在编译时而不是运行时完成的。许多语言都内置了这个功能，但实现方式各不相同。这可能在开始时会让人困惑，但通过代码示例将会更加清晰。让我们进入Scala
    REPL进行一些实验。
- en: Scala REPL
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Java中，您只能在代码文件的顶部导入包，就在包语句之后。在Scala中情况不同；您几乎可以在源文件的任何地方编写导入语句（例如，甚至可以在类或方法内部编写导入语句）。您只需要注意您的导入语句的作用域，因为它继承了类的成员或方法内部局部变量的作用域。在Scala中，`_`（下划线）用于通配符导入，类似于Java中您将使用的`*`（星号）：Scala
    REPL
- en: 'The Scala REPL is a powerful feature that makes it more straightforward and
    concise to write Scala code on ;the Scala shell. **REPL** stands for **Read-Eval-Print-Loop**
    also called **the Interactive Interpreter**. This means it is a program for:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Scala REPL是一个强大的功能，使得在Scala shell上编写Scala代码更加简单和简洁。**REPL**代表**读取-评估-打印-循环**，也称为**交互式解释器**。这意味着它是一个用于：
- en: ;Reading the expressions you type in.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ;读取您输入的表达式。
- en: Evaluating the expression in step 1 using the Scala compiler.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Scala编译器评估第1步中的表达式。
- en: Printing out the result of the evaluation in step 2.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印出第2步评估的结果。
- en: Waiting (looping) for you to enter further expressions.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待（循环）您输入更多表达式。
- en: '![](img/00211.jpeg)**Figure 8:** Scala REPL example 1'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/00211.jpeg)**图8：** Scala REPL示例1'
- en: 'From the figure, it is evident that there is no magic, the variables are inferred
    automatically to the best types they deem fit at compile time. If you look even
    more carefully, when I tried to declare: ;'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 从图中可以看出，这并没有什么神奇之处，变量在编译时会自动推断出最适合的类型。如果您仔细观察，当我尝试声明时：
- en: '[PRE24]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then, the Scala shell throws an error saying the following:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，Scala shell会抛出一个错误，显示如下：
- en: '[PRE25]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'According to Odersky, *"Mapping a character to the character map over a RichString
    should again yield a RichString, as in the following interaction with the Scala
    REP"*. The preceding statement can be proved using the following line of code:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Odersky的说法，“将字符映射到RichString上的字符映射应该再次产生一个RichString，如下与Scala REP的交互”。可以使用以下代码来证明前述声明：
- en: '[PRE26]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: However, if someone applies a method from `Char` to `Int` to a `String`, then
    what happens? In that case, Scala converts them, as a vector of integer also called
    immutable is a feature of Scala collection, as shown in *Figure 9*. We will look
    at the details on Scala collection API in [Chapter 4](part0117.html#3FIHQ1-21aec46d8593429cacea59dbdcd64e1c),
    *Collections APIs*.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果有人将`Char`的方法应用于`Int`到`String`，那会发生什么？在这种情况下，Scala会将它们转换为整数向量，也称为Scala集合的不可变特性，如*图9*所示。我们将在[第4章](part0117.html#3FIHQ1-21aec46d8593429cacea59dbdcd64e1c)中详细介绍Scala集合API。
- en: '[PRE27]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Both static and instance methods of objects are also available. For example,
    if you declare `x` as a string `hello` and then try to access both the static
    and instance methods of objects `x`, they are available. In the Scala shell, type
    `x` then `.` and `<tab>` and then you will find the available methods:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的静态方法和实例方法也都可用。例如，如果您将`x`声明为字符串`hello`，然后尝试访问对象`x`的静态和实例方法，它们是可用的。在Scala shell中，键入`x`，然后键入`.`和`<tab>`，然后您将找到可用的方法：
- en: '[PRE28]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Since this is all accomplished on the fly via reflection, even anonymous classes
    you''ve only just defined are equally accessible:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这一切都是通过反射动态完成的，即使您刚刚定义了匿名类，它们也同样可以访问：
- en: '[PRE29]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The preceding two examples can be shown on the Scala shell, as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个示例可以在Scala shell上显示如下：
- en: '![](img/00232.gif)**Figure 9:** Scala REPL example 2'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套函数
- en: '"So it turns out that map yields different types depending on what the result
    type of the passed function argument is!"'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: “原来map根据传递的函数参数的结果类型产生不同的类型！”
- en: '- Odersky'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '- Odersky'
- en: Nested functions
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ;
- en: 'Why will you require a nested functions support in your programming language?
    Most of the time, we want to maintain our methods to be a few lines and avoid
    overly large functions. A typical solution for this in Java would be to define
    all these small functions on a class level, but any other method could easily
    refer and access them even though they are helper methods. The situation is different
    in Scala, so you can use define functions inside each other, and this way, prevent
    any external access to these functions:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么您需要在编程语言中支持嵌套函数？大多数情况下，我们希望保持我们的方法只有几行，并避免过大的函数。在Java中，这个问题的典型解决方案是在类级别上定义所有这些小函数，但是任何其他方法都可以轻松地引用和访问它们，即使它们是辅助方法。在Scala中情况不同，您可以在彼此内部定义函数，从而防止任何外部访问这些函数：
- en: '[PRE30]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We are not expecting you to understand these code snippets, which show the difference
    between Scala and Java.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不希望您理解这些代码片段，它们展示了Scala和Java之间的区别。
- en: Import statements
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导入语句
- en: 'In Java, you can only import packages at the top of your code file, right after
    the packages statement. The situation is not the same in Scala; you can write
    your import statements almost anywhere inside your source file (for example, you
    can even write your import statements inside a class or a method). You just need
    to pay attention to the scope of your import statement, because it inherits the
    same scope of the members of your class or local variables inside your method.
    The `_` (underscore) in Scala is used for wildcard imports, which is similar to
    the `*` (asterisk) that you would use in java:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/00232.gif)**图9：** Scala REPL示例2'
- en: '[PRE31]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You may also use these `{ }` to indicate a set of imports from the same parent
    package, just in one line of code. In Java, you would use multiple lines of code
    to do so:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用这些`{ }`来指示从同一父包中导入一组导入，只需一行代码。在Java中，您需要使用多行代码来实现这一点：
- en: '[PRE32]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Unlike the Java, Scala does not have the concept of static imports. In other
    words, the concept of static doesn''t exist in Scala. However, as a developer,
    obviously, you can import a member or more than one member of an object using
    a regular import statement. The preceding example already shows this, where we
    import the methods sin and cos from the package object named math. To demonstrate
    an example, the preceding ;code snippet can be defined from the Java programmer''s
    perspective as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 与Java不同，Scala没有静态导入的概念。换句话说，静态的概念在Scala中不存在。然而，作为开发人员，显然，您可以使用常规导入语句导入一个对象的一个成员或多个成员。前面的例子已经展示了这一点，我们从名为math的包对象中导入了sin和cos方法。为了演示一个例子，前面的；代码片段可以从Java程序员的角度定义如下：
- en: '[PRE33]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Another beauty of Scala is that, in Scala, you can rename your imported packages
    as well. Alternatively, you can rename your imported packages to avoid the type
    conflicting with packages that have similar members. The following statement is
    valid in Scala:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Scala的另一个美妙之处在于，在Scala中，您还可以重命名导入的包。或者，您可以重命名导入的包以避免与具有相似成员的包发生类型冲突。以下语句在Scala中是有效的：
- en: '[PRE34]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Finally, you may want to exclude a member of packages for collisions or other
    purposes. For this, you can use a wildcard to do so:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可能希望排除包的成员以避免冲突或其他目的。为此，您可以使用通配符来实现：
- en: '[PRE35]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Operators as methods
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运算符作为方法
- en: It's worth mentioning that Scala doesn't support the operator overloading. You
    might think that there are no operators at all in Scala.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的是，Scala不支持运算符重载。您可能会认为Scala根本没有运算符。
- en: 'An alternative syntax for calling a method taking a single parameter is the
    use of the infix syntax. The infix syntax provides you with a flavor just like
    you are applying an operator overloading, as like what you did in C++. For example:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 调用只有一个参数的方法的另一种语法是使用中缀语法。中缀语法为您提供了一种味道，就像您在C++中进行运算符重载一样。例如：
- en: '[PRE36]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In the following case, the `+` ;means a method in class `Int`. ; The following
    ;code is a non-conventional method calling syntax:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的情况中，`+`；表示类`Int`中的一个方法。以下；代码是一种非常规的方法调用语法：
- en: '[PRE37]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'More formally, the same can be done using the infix syntax, as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 更正式地，可以使用中缀语法来完成相同的操作，如下所示：
- en: '[PRE38]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Moreover, you can utilize the infix syntax. However, the method has only a
    single parameter, as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您可以利用中缀语法。但是，该方法只有一个参数，如下所示：
- en: '[PRE39]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'There''s one special case when using the infix syntax. That is, if the method
    name ends with a `:` (colon), then the invocation or call will be right associative.
    This means that the method is called on the right argument with the expression
    on the left as the argument, instead of the other way around. For example, the
    following is valid in Scala:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用中缀语法时有一个特殊情况。也就是说，如果方法名以`:`（冒号）结尾，那么调用将是右结合的。这意味着该方法在右参数上调用，左侧的表达式作为参数，而不是相反。例如，在Scala中以下是有效的：
- en: '[PRE40]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The preceding ;statement signifies that: `my_list.+:(5)` rather than `5.+:(my_list)`
    and more formally: ;'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的；语句表示：`my_list.+:(5)`而不是`5.+:(my_list)`，更正式地说：；
- en: '[PRE41]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now, let''s look at the preceding examples on Scala REPL:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在Scala REPL上看一下前面的例子：
- en: '[PRE42]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In addition to the above, operators here are just methods, so that they can
    simply be overridden just like methods.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 除了上述之外，这里的运算符只是方法，因此它们可以像方法一样简单地被重写。
- en: Methods and parameter lists
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方法和参数列表
- en: 'In Scala, a method can have multiple parameter lists or even no parameter list
    at all. On the other hand, in Java, a method always has one parameter list, with
    zero or more parameters. For example, in Scala, the following is the valid method
    definition (written in `currie notation`) where a method has two parameter lists:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在Scala中，一个方法可以有多个参数列表，甚至根本没有参数列表。另一方面，在Java中，一个方法总是有一个参数列表，带有零个或多个参数。例如，在Scala中，以下是有效的方法定义（以`currie
    notation`编写），其中一个方法有两个参数列表：
- en: '[PRE43]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The preceding ;method cannot be written as:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的；方法不能被写成：
- en: '[PRE44]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'A method, let''s say ;`sum2`, can have no parameter list at all, as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 一个方法，比如；`sum2`，可以根本没有参数列表，如下所示：
- en: '[PRE45]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now, you can call the method `add2`, which returns a function taking one parameter.
    Then, it calls that function with the argument `5`, as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以调用方法`add2`，它返回一个带有一个参数的函数。然后，它使用参数`5`调用该函数，如下所示：
- en: '[PRE46]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Methods inside methods
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方法内部的方法
- en: Sometimes, you would like to make your applications, code modular by avoiding
    too long and complex methods. Scala provides you this facility to avoid your methods
    becoming overly large so that you can split them up into several smaller methods.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您可能希望通过避免过长和复杂的方法使您的应用程序、代码模块化。Scala为您提供了这种便利，以避免您的方法变得过大，以便将它们拆分成几个较小的方法。
- en: 'On the other hand, Java allows you only to have the methods defined at class
    level. For example, suppose you have the following method definition:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，Java只允许您在类级别定义方法。例如，假设您有以下方法定义：
- en: '[PRE47]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now, you can call the nested helper/auxiliary method as follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以按以下方式调用嵌套的辅助/辅助方法：
- en: '[PRE48]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Considering the above, here''s the complete code segment which is valid:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到上述内容，以下是有效的完整代码段：
- en: '[PRE49]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Constructor in Scala
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scala中的构造函数
- en: One surprising thing about Scala is that the body of a Scala class is itself
    a constructor. ; However, Scala does so; in fact, in a more explicit way. After
    that, a new instance of that class is created and executed. Moreover, you can
    specify the arguments of the constructor in the class declaration line.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Scala的一个令人惊讶的事情是，Scala类的主体本身就是一个构造函数。然而，Scala确实这样做；事实上，以一种更明确的方式。之后，该类的一个新实例被创建并执行。此外，您可以在类声明行中指定构造函数的参数。
- en: 'Consequently, the constructor arguments are accessible from all of the methods
    defined in that class. For example, the following class and constructor definition
    is valid in Scala:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，构造函数参数可以从该类中定义的所有方法中访问。例如，以下类和构造函数定义在Scala中是有效的：
- en: '[PRE50]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The equivalent Java class would look like this:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 等效的Java类如下所示：
- en: '[PRE51]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Objects instead of static methods
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象而不是静态方法
- en: 'As mentioned earlier, static does not exist in Scala. You cannot do static
    imports and neither can you cannot add static methods to classes. In Scala, when
    you define an object with the same name as the class and in the same source file,
    then the object is said to be the companion of that class*.* Functions that you
    define in this companion object of a class are like static methods of a class
    in Java:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Scala中不存在静态。你不能进行静态导入，也不能向类添加静态方法。在Scala中，当你在同一源文件中以相同的名称定义一个对象和类时，那么该对象被称为该类的伴生对象。在类的伴生对象中定义的函数就像Java类中的静态方法：
- en: '[PRE52]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'This is how you can define a companion object for the class hello:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你可以为类hello定义一个伴生对象的方法：
- en: '[PRE53]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The equivalent class in Java would look like this:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 等效的Java类如下所示：
- en: '[PRE54]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'So, lot''s of verbose in this simple class, isn''t there? ; The apply method
    in Scala is treated in a different way, such that you can find a special shortcut
    syntax to call it. This is the familiar way of calling the method:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这个简单的类中有很多冗长的内容，不是吗？Scala中的apply方法被以一种不同的方式处理，因此你可以找到一种特殊的快捷语法来调用它。这是调用方法的熟悉方式：
- en: '[PRE55]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Here''s the shortcut syntax that is equivalent to the one earlier:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是等效于之前的快捷语法：
- en: '[PRE56]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Note that this only works if you used the apply method in your code because
    Scala treats methods that are named apply in this different way.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这仅在你的代码中使用了apply方法时才有效，因为Scala以不同的方式处理被命名为apply的方法。
- en: Traits
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特征
- en: 'Scala provides a great functionality for you in order to extend and enrich
    your classes'' behaviors. These traits are similar to the interface in which you
    define the function prototypes or signatures. So, with this, you can have mix-ins
    of functionality coming from different traits and, in this way, you enriched your
    classes'' behavior. So, what''s so good about traits in Scala? They enable the
    composition of classes from these traits, with traits being the building blocks.
    As always, let''s look at in an example. This is how a conventional logging routine
    is set up in Java:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: Scala为你提供了一个很好的功能，以扩展和丰富你的类的行为。这些特征类似于接口，你可以在其中定义函数原型或签名。因此，你可以从不同的特征中获得功能的混合，并丰富你的类的行为。那么，Scala中的特征有什么好处呢？它们使得从这些特征组合类成为可能，特征是构建块。和往常一样，让我们通过一个例子来看看。这是在Java中设置传统日志记录例程的方法：
- en: 'Note that, even though you can mix in any number of traits you want. Moreover,
    like Java, Scala does not have the support of multiple inheritances. However,
    in both Java and Scala, a subclass can only extend a single superclass. For example,
    in Java:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尽管你可以混入任意数量的特征，但是和Java一样，Scala不支持多重继承。然而，在Java和Scala中，子类只能扩展一个父类。例如，在Java中：
- en: '[PRE57]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: For a more detailed discussion, refer to this URL [https://stackoverflow.com/questions/963492/in-log4j-does-checking-isdebugenabled-before-logging-improve-performance/963681#963681](https://stackoverflow.com/questions/963492/in-log4j-does-checking-isdebugenabled-before-logging-improve-performance/963681#963681).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更详细的讨论，请参阅此URL [https://stackoverflow.com/questions/963492/in-log4j-does-checking-isdebugenabled-before-logging-improve-performance/963681#963681](https://stackoverflow.com/questions/963492/in-log4j-does-checking-isdebugenabled-before-logging-improve-performance/963681#963681)。
- en: 'However, it''s different with traits. It''s very tiresome to always check for
    the log level being enabled. It would be good, if you could write this routine
    once and reuse it anywhere, in any class right away. Traits in Scala make this
    all possible. For example:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，特征是不同的。总是检查日志级别是否启用非常繁琐。如果你能够编写这个例程并在任何类中立即重用它，那就太好了。Scala中的特征使这一切成为可能。例如：
- en: '[PRE58]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: If you look at the preceding code, you will see an example of using string starting
    with `s`. ; This way, Scala offers the mechanism to create strings from your data
    called **String Interpolation**. ;
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看前面的代码，你会看到一个以`s`开头的字符串的使用示例。这种方式，Scala提供了从数据创建字符串的机制，称为**字符串插值**。
- en: 'String Interpolation, allows you to embed variable references directly in processed
    string literals. For example:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串插值允许你直接在处理的字符串文字中嵌入变量引用。例如：
- en: ; ; ;`scala> val name = "John Breslin"`
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`scala> val name = "John Breslin"`'
- en: '`; ;scala> println(s"Hello, $name") ; // Hello, John Breslin`.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`scala> println(s"Hello, $name") ; // Hello, John Breslin`。'
- en: 'Now, we can get an efficient logging routine in a more conventional style as
    a reusable block. To enable logging for any class, we just mix in our `Logging`
    trait! Fantastic! Now that''s all it takes to add a logging feature to your class:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以以更传统的方式获得一个高效的日志记录例程作为可重用的代码块。要为任何类启用日志记录，我们只需混入我们的`Logging`特征！太棒了！现在，这就是为你的类添加日志记录功能所需的全部内容：
- en: '[PRE59]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'It is even possible to mix-up multiple traits. For example, for the preceding
    ;trait (that is, `Logging`) you can keep extending in the following ;order:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 甚至可以混合多个特征。例如，对于前面的特征（即`Logging`），你可以按以下顺序不断扩展：
- en: '[PRE60]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: However, it is noted that a Scala class can extend multiple traits at once,
    but JVM classes can extend only one parent class.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，需要注意的是，Scala类可以一次扩展多个特征，但JVM类只能扩展一个父类。
- en: 'Now, to invoke the above traits and classes, use `new D()` from Scala REPL,
    as shown in the following ;figure:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要调用上述特征和类，可以在Scala REPL中使用`new D()`，如下图所示：
- en: '![](img/00220.gif)**Figure 10**: Mixing multiple traits'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/00220.gif)**图10**：混合多个特征'
- en: Everything has gone smoothly so far in this chapter. Now, let's move to a new
    section where we will discuss some topics for the beginner who wants to drive
    themselves into the realm of Scala programming.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本章一切顺利。现在，让我们转到一个新的部分，讨论一些初学者想要进入Scala编程领域的主题。
- en: Scala for the beginners
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scala初学者
- en: In this part, you will find that we assume that you have a basic understanding
    of any previous programming language. If Scala is your first entry into the coding
    world, then you will find a large set of materials and even courses online that
    explain Scala for beginners. As mentioned, there are lots of tutorials, videos,
    and courses out there.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，你会发现我们假设你对任何之前的编程语言有基本的了解。如果Scala是你进入编程世界的第一步，那么你会发现有很多在线材料甚至课程可以为初学者解释Scala。正如前面提到的，有很多教程、视频和课程。
- en: 'There is a whole Specialization, which contains this course, on Coursera: [https://www.coursera.org/specializations/scala](https://www.coursera.org/specializations/scala).
    Taught by the creator of Scala, Martin Odersky, this online class takes a somewhat
    academic approach to teaching the fundamentals of functional programming. You
    will learn a lot about Scala by solving the programming assignments. Moreover,
    this specialization includes a course on Apache Spark. Furthermore, Kojo ([http://www.kogics.net/sf:kojo](http://www.kogics.net/sf:kojo))
    is an interactive learning environment that uses Scala programming to explore
    and play with math, art, music, animations, and games.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在Coursera上有一个包含这门课程的整个专业课程：[https://www.coursera.org/specializations/scala](https://www.coursera.org/specializations/scala)。由Scala的创始人Martin
    Odersky教授，这个在线课程以一种相当学术的方式教授函数式编程的基础知识。通过解决编程作业，你将学到很多关于Scala的知识。此外，这个专业课程还包括一个关于Apache
    Spark的课程。此外，Kojo ([http://www.kogics.net/sf:kojo](http://www.kogics.net/sf:kojo))是一个使用Scala编程来探索和玩耍数学、艺术、音乐、动画和游戏的交互式学习环境。
- en: Your first line of code
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你的第一行代码
- en: 'As a first example, we will use the pretty common `Hello, world!` program in
    order to show you how to use Scala and its tools without knowing much about it.
    Let''s open your favorite editor (this example runs on Windows 7, but can be run
    similarly on Ubuntu or macOS), say Notepad++, and type the following lines of
    code:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一个例子，我们将使用非常常见的`Hello, world!`程序来向你展示如何在不太了解它的情况下使用Scala及其工具。让我们打开你喜欢的编辑器（这个例子在Windows
    7上运行，但在Ubuntu或macOS上也可以类似地运行），比如Notepad++，并输入以下代码：
- en: '[PRE61]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Now, save the code with a name, say `HelloWorld.scala`, as shown in the following
    figure: ;'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，保存代码为一个名字，比如`HelloWorld.scala`，如下图所示：
- en: '![](img/00235.jpeg)**Figure 11:** Saving your first Scala source code using
    Notepad++'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/00235.jpeg)**图11：**使用Notepad++保存你的第一个Scala源代码'
- en: 'Let''s compile the source file as follows:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下方式编译源文件：
- en: '[PRE62]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: I'm ; the hello world program, explain me well!
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我是hello world程序，好好解释给我听！
- en: 'The program should be familiar to anyone who has some programming of experience.
    It has a main method which prints the string `Hello, world!` to your console.
    Next, to see how we defined the `main` function, we used the `def main()` strange
    syntax to define it. `def` is a Scala keyword to declare/define a method, and
    we will be covering more about methods and different ways of writing them in the
    next chapter. So, we have an `Array[String]` as an argument for this method, which
    is an array of strings that can be used for initial configurations of your program,
    and omit is valid. ;Then, we use the common `println()` method, which takes a
    string (or formatted one) and prints it to the console. A simple hello world has
    opened up many topics to learn; three in particular:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序对于有一些编程经验的人来说应该很熟悉。它有一个主方法，打印字符串`Hello, world!`到你的控制台。接下来，为了看到我们如何定义`main`函数，我们使用了`def
    main()`奇怪的语法来定义它。`def`是Scala的关键字，用来声明/定义一个方法，我们将在下一章中更多地涵盖关于方法和不同的写法。所以，我们有一个`Array[String]`作为这个方法的参数，这是一个可以用于程序的初始配置的字符串数组，也可以省略。然后，我们使用常见的`println()`方法，它接受一个字符串（或格式化的字符串）并将其打印到控制台。一个简单的hello
    world打开了许多要学习的话题；特别是三个：
- en: ● ; ; ;Methods (covered in a later chapter)
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: ● ; ; ;方法（在后面的章节中涵盖）
- en: ● ; ; ;Objects and classes (covered in a later chapter)
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: ● ; ; ;对象和类（在后面的章节中涵盖）
- en: ● ; ; ;Type inference - the reason why Scala is a statically typed language
    - explained earlier
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: ● ; ; ;类型推断 - Scala是一种静态类型语言的原因 - 之前解释过
- en: Run Scala interactively!
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 交互式运行Scala！
- en: 'The `scala` command starts the interactive shell for you, where you can interpret
    Scala expressions interactively:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`scala`命令为你启动了交互式shell，你可以在其中交互地解释Scala表达式：'
- en: '[PRE63]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The shortcut `:q` stands for the internal shell command `:quit`, ;used to exit
    the interpreter.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 快捷键`:q`代表内部shell命令`:quit`，用于退出解释器。
- en: Compile it!
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译它！
- en: 'The `scalac` command, which is similar to `javac` command, compiles one or
    more Scala source files and generates a bytecode as output, which then can be
    executed on any Java Virtual Machine. To compile your hello world object, use
    the following:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`scalac`命令，类似于`javac`命令，编译一个或多个Scala源文件，并生成一个字节码作为输出，然后可以在任何Java虚拟机上执行。要编译你的hello
    world对象，使用以下命令：'
- en: '[PRE64]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'By default, `scalac` generates the class files into the current working directory.
    You may specify a different output directory using the `-d` option:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`scalac`将类文件生成到当前工作目录。你可以使用`-d`选项指定不同的输出目录：
- en: '[PRE65]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: However, note that the directory called `classes` must be created before executing
    this command.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，请注意，在执行这个命令之前必须创建一个名为`classes`的目录。
- en: Execute it with Scala command
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用Scala命令执行它
- en: 'The `scala` command executes the bytecode that is generated by the interpreter:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '`scala`命令执行由解释器生成的字节码：'
- en: '[PRE66]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Scala allows us to specify command options, such as the `-classpath` (alias
    `-cp`) option:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: Scala允许我们指定命令选项，比如`-classpath`（别名`-cp`）选项：
- en: '[PRE67]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Before using the `scala` command to execute your source file(s), you should
    have a main method that acts as an entry point for your application. Otherwise,
    you should have an `Object` that extends `Trait Scala.App`, then all the code
    inside this object will be executed by the command. The following is the same
    `Hello, world!` ;example, but using the `App` trait:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`scala`命令执行源文件之前，你应该有一个作为应用程序入口点的主方法。否则，你应该有一个扩展`Trait Scala.App`的`Object`，然后这个对象内的所有代码将被命令执行。以下是相同的`Hello,
    world!`例子，但使用了`App`特性：
- en: '[PRE68]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The preceding ;script can be run directly from the command shell:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的脚本可以直接从命令行运行：
- en: '[PRE69]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Note: we assume here that the file `script.sh` has the execute permission:
    ;'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 注：我们假设文件`script.sh`具有执行权限：；
- en: '[PRE70]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Then, the search path for the `scala` command is specified in the `$PATH` environment
    variable.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`$PATH`环境变量中指定了`scala`命令的搜索路径。
- en: Summary
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'Throughout this chapter, you have learned the basics of the Scala programming
    language, its features, and available editor. We have also briefly discussed Scala
    and its syntax. We demonstrated the installation and setting up guidelines for
    beginners who are new to Scala programming. Later in the chapter, you learned
    how to write, compile, and execute a sample Scala code. Moreover, a comparative
    discussion about Scala and Java provided for those who are from a Java background.
    Here''s a short comparison between Scala and Python:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您已经学习了Scala编程语言的基础知识、特性和可用的编辑器。我们还简要讨论了Scala及其语法。我们演示了安装和设置指南，供那些新手学习Scala编程的人参考。在本章后面，您将学习如何编写、编译和执行Scala代码示例。此外，我们还为那些来自Java背景的人提供了Scala和Java的比较讨论。下面是Scala和Python的简要比较：
- en: Scala is statically typed, but Python is dynamically typed. Scala (mostly) embraces
    the functional programming paradigm, while Python doesn't. Python has a unique
    syntax that lacks most of the parentheses, while Scala (almost) always requires
    them. In Scala, almost everything is an expression; while this isn't true in Python.
    However, there are a few points on the upside that are seemingly convoluted. The
    type complexity is mostly optional. Secondly, according to the documentation provided
    by [https://stackoverflow.com/questions/1065720/what-is-the-purpose-of-scala-programming-language/5828684#5828684](https://stackoverflow.com/questions/1065720/what-is-the-purpose-of-scala-programming-language/5828684#5828684),
    ; *Scala compiler is like free testing and documentation as cyclomatic complexity
    and lines of code escalate. When aptly implemented Scala can perform otherwise
    all but impossible operations behind consistent and coherent APIs.*
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: Scala是静态类型的，而Python是动态类型的。Scala（大多数情况下）采用函数式编程范式，而Python不是。Python具有独特的语法，缺少大部分括号，而Scala（几乎）总是需要它们。在Scala中，几乎所有东西都是表达式；而在Python中并非如此。然而，有一些看似复杂的优点。类型复杂性大多是可选的。其次，根据[https://stackoverflow.com/questions/1065720/what-is-the-purpose-of-scala-programming-language/5828684#5828684](https://stackoverflow.com/questions/1065720/what-is-the-purpose-of-scala-programming-language/5828684#5828684)提供的文档；*Scala编译器就像自由测试和文档一样，随着圈复杂度和代码行数的增加。当Scala得到恰当实现时，可以在一致和连贯的API背后执行几乎不可能的操作。*
- en: In next the chapter, we will discuss ;how to improve our experience on the basics
    to know how Scala implements the object oriented paradigm to allow building modular
    software systems.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论如何改进我们对基础知识的理解，了解Scala如何实现面向对象的范式，以便构建模块化软件系统。
