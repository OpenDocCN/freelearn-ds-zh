- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Databases and Asynchronous ORMs
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库和异步 ORM
- en: 'The main goal of a REST API is, of course, to read and write data. So far,
    we’ve solely worked with the tools given by Python and FastAPI, allowing us to
    build reliable endpoints to process and answer requests. However, we haven’t been
    able to effectively retrieve and persist that information: we don’t have a **database**.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: REST API 的主要目标当然是读写数据。到目前为止，我们只使用了 Python 和 FastAPI 提供的工具，允许我们构建可靠的端点来处理和响应请求。然而，我们尚未能够有效地检索和持久化这些信息：我们还没有
    **数据库**。
- en: 'The goal of this chapter is to show you how you can interact with different
    types of databases and related libraries inside FastAPI. It’s worth noting that
    FastAPI is completely agnostic regarding databases: you can use any system you
    want and it’s your responsibility to integrate it. This is why we’ll review two
    different approaches to integrating a database: using an **object-relational mapping**
    (**ORM**) system for SQL databases and using a NoSQL database.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是展示你如何在 FastAPI 中与不同类型的数据库及相关库进行交互。值得注意的是，FastAPI 对数据库是完全无关的：你可以使用任何你想要的系统，并且集成工作由你负责。这就是为什么我们将回顾两种不同的数据库集成方式：使用
    **对象关系映射**（**ORM**）系统连接 SQL 数据库，以及使用 NoSQL 数据库。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将讨论以下主要主题：
- en: An overview of relational and NoSQL databases
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关系型数据库和 NoSQL 数据库概述
- en: Communicating with a SQL database with SQLAlchemy ORM
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 SQLAlchemy ORM 与 SQL 数据库进行通信
- en: Communicating with a MongoDB database using Motor
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Motor 与 MongoDB 数据库进行通信
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, you’ll require a Python virtual environment, just as we set
    up in [*Chapter 1*](B19528_01.xhtml#_idTextAnchor024), *Python Development* *Environment
    Setup*.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，你将需要一个 Python 虚拟环境，正如我们在 [*第 1 章*](B19528_01.xhtml#_idTextAnchor024) 中设置的，*Python
    开发* *环境设置*。
- en: 'For the *Communicating with a MongoDB database using Motor* section, you’ll
    need a running MongoDB server on your local computer. The easiest way to do this
    is to run it as a Docker container. If you’ve never used Docker before, we recommend
    that you refer to the *Getting started* tutorial in the official documentation
    at [https://docs.docker.com/get-started/](https://docs.docker.com/get-started/).
    Once you have done this, you’ll be able to run a MongoDB server using this simple
    command:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 *使用 Motor 与 MongoDB 数据库进行通信* 部分，你需要在本地计算机上运行 MongoDB 服务器。最简单的方法是将其作为 Docker
    容器运行。如果你以前从未使用过 Docker，我们建议你参考官方文档中的 *入门教程*，链接为 [https://docs.docker.com/get-started/](https://docs.docker.com/get-started/)。完成这些步骤后，你将能够使用以下简单命令运行
    MongoDB 服务器：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The MongoDB server instance will then be available on your local computer at
    port `27017`.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB 服务器实例将通过端口 `27017` 在你的本地计算机上提供。
- en: You can find all the code examples for this chapter in this book’s dedicated
    GitHub repository at [https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在本书专门的 GitHub 仓库中找到本章的所有代码示例，地址为 [https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06)。
- en: An overview of relational and NoSQL databases
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关系型数据库和 NoSQL 数据库概述
- en: The role of a database is to store data in a structured way, preserve the integrity
    of the data, and offer a query language that enables you to retrieve this data
    when an application needs it.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库的作用是以结构化的方式存储数据，保持数据的完整性，并提供查询语言，使你在应用程序需要时能够检索这些数据。
- en: 'Nowadays, when it comes to choosing a database for your web project, you have
    two main choices: **relational databases**, with their associated SQL query language,
    and **NoSQL databases**, named in opposition to the first category.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，选择适合你网站项目的数据库时，你有两个主要选择：**关系型数据库**，及其相关的 SQL 查询语言，和 **NoSQL 数据库**，它们与第一类数据库相对立。
- en: Selecting the right technology for your project is left up to you as it greatly
    depends on your needs and requirements. In this section, we’ll outline the main
    characteristics and features of those two database families and try to give you
    some insights into choosing the right one for your project.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 选择适合你项目的技术由你来决定，因为这在很大程度上取决于你的需求和要求。在本节中，我们将概述这两类数据库的主要特点和功能，并尝试为你提供一些选择适合项目的数据库的见解。
- en: Relational databases
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关系型数据库
- en: Relational databases have existed since the 1970s, and they have proved to be
    very performant and reliable over time. They are almost inseparable from SQL,
    which has become the de facto standard for querying such databases. Even if there
    are a few differences between one database engine and another, most of the syntax
    is common, simple to understand, and flexible enough to express complex queries.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 关系型数据库自1970年代以来就存在，并且随着时间的推移证明了它们的高效性和可靠性。它们几乎与SQL不可分离，SQL已成为查询此类数据库的事实标准。即使不同数据库引擎之间有一些差异，大多数语法是通用的，简单易懂，足够灵活，可以表达复杂的查询。
- en: 'Relational databases implement the relational model: each entity, or object,
    of the application is stored in **tables**. For example, if we consider a blog
    application, we could have tables that represent *users*, *posts*, and *comments*.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 关系型数据库实现了关系模型：应用的每个实体或对象都存储在**表**中。例如，如果我们考虑一个博客应用，我们可以有表示*用户*、*帖子*和*评论*的表。
- en: Each of those tables will have several **columns** representing the attributes
    of the entity. If we consider posts, we could have a *title*, a *publication date*,
    and *content*. In those tables, there will be several rows, each one representing
    a single entity of this type; each post will have its own row.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 每个表都会有多个**列**，表示实体的属性。如果我们考虑帖子，可能会有一个*标题*、*发布日期*和*内容*。在这些表中，会有多行，每行表示这种类型的一个实体；每篇帖子将有自己的行。
- en: One of the key points of relational databases is, as their name suggests, *relationships*.
    Each table can be in a relationship with others, with rows referring to other
    rows in other tables. In our example, a post could be related to the user who
    wrote it. In the same way, a comment could be linked to the post that it relates
    to.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 关系型数据库的一个关键点是，如其名称所示，*关系*。每个表可以与其他表建立关系，表中的行可以引用其他表中的行。在我们的示例中，一篇帖子可以与写它的用户相关联。类似地，一条评论可以与其相关的帖子关联。
- en: The main motivation behind this is to *avoid duplication*. Indeed, it wouldn’t
    be very efficient to repeat the user’s name or email on each post. If it needs
    to be modified at some point, we would have to go through each post, which is
    error-prone and puts data consistency at risk. This is why we prefer to *reference*
    the user in the posts. So, how can we do this?
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的主要动机是*避免重复*。事实上，如果我们在每篇帖子上都重复用户的姓名或邮箱，这并不是很高效。如果需要修改某个信息，我们就得通过每篇帖子修改，这容易出错并危及数据一致性。因此，我们更倾向于在帖子中*引用*用户。那么，我们该如何实现这一点呢？
- en: 'Usually, each row in a relational database has an identifier, called a **primary
    key**. This is unique in the table and allows you to uniquely identify this row.
    Therefore, it’s possible to use this key in another table to reference it. We
    call this a **foreign key**: the key is foreign in the sense that it refers to
    another table.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，关系型数据库中的每一行都有一个标识符，称为**主键**。这个键在表中是唯一的，允许你唯一标识这一行。因此，可以在另一个表中使用这个键来引用它。我们称之为**外键**：外键之所以叫做外，是因为它引用了另一个表。
- en: '*Figure 6**.1* shows a representation of such a database schema using an entity-relationship
    diagram. Note that each table has its own primary key, named `id`. The `Post`
    table refers to a user, through the `user_id` foreign key. Similarly, the `Comment`
    table refers to both a post and a user through the `user_id` and `post_id` foreign
    keys:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6.1*展示了使用实体-关系图表示这种数据库模式的方式。请注意，每个表都有自己的主键，名为`id`。`Post`表通过`user_id`外键引用一个用户。类似地，`Comment`表通过`user_id`和`post_id`外键分别引用一个用户和一篇帖子：'
- en: '![Figure 6.1 – A relational database schema example for a blog application](img/B19528_06_01.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.1 – 博客应用的关系型数据库模式示例](img/B19528_06_01.jpg)'
- en: Figure 6.1 – A relational database schema example for a blog application
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1 – 博客应用的关系型数据库模式示例
- en: In an application, you’ll likely want to retrieve a post, along with the comments
    and the users associated with them. To do so, we can perform a **join query**,
    which will return all the relevant records based on the foreign keys. Relational
    databases are designed to perform such tasks efficiently; however, those operations
    can become expensive if the schema is more complex. This is why it’s important
    to carefully design a relational schema and its queries.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个应用中，你可能希望检索一篇帖子，以及与之相关的评论和用户。为了实现这一点，我们可以执行一个**连接查询**，根据外键返回所有相关记录。关系型数据库旨在高效地执行此类任务；然而，如果模式更加复杂，这些操作可能会变得昂贵。这就是为什么在设计关系型模式及其查询时需要小心谨慎的原因。
- en: NoSQL databases
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NoSQL数据库
- en: 'All database engines that are not relational fall back into the NoSQL category.
    This is a quite vague denomination that regroups different families of databases:
    key-value stores, such as Redis; graph databases, such as Neo4j; and document-oriented
    databases, such as MongoDB. That said, most of the time, when we talk about “NoSQL
    databases,” we are implicitly referring to document-oriented databases. They are
    the ones we’re interested in.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 所有非关系型的数据库引擎都属于NoSQL范畴。这是一个相当模糊的术语，涵盖了不同类型的数据库：键值存储，例如Redis；图数据库，例如Neo4j；以及面向文档的数据库，例如MongoDB。也就是说，当我们谈论“NoSQL数据库”时，通常是指面向文档的数据库。它们是我们关注的对象。
- en: Document-oriented databases move away from the relational architecture and try
    to store all the information of a given object inside a single **document**. As
    such, performing a join query is much rarer and usually more difficult.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 面向文档的数据库摒弃了关系型架构，试图将给定对象的所有信息存储在一个**文档**中。因此，执行联接查询的情况非常少见，通常也更为困难。
- en: 'Those documents are stored in **collections**. Contrary to relational databases,
    documents in a collection might not have all of the same attributes: while tables
    in relational databases have a defined schema, collections accept any kind of
    document.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文档存储在**集合**中。与关系型数据库不同，集合中的文档可能没有相同的属性：关系型数据库中的表有定义好的模式，而集合可以接受任何类型的文档。
- en: '*Figure 6**.2* shows a representation of our previous blog example, which has
    been adapted into a document-oriented database structure. In this configuration,
    we have chosen to have a collection for users and another one for posts. However,
    notice that the comments are now part of a post, directly included as a list:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6.2* 显示了我们之前博客示例的表示，已经调整为面向文档的数据库结构。在这种配置中，我们选择了一个集合用于用户，另一个集合用于帖子。然而，请注意，评论现在是帖子的组成部分，直接作为一个列表包含在内：'
- en: '![Figure 6.2 — A document-oriented schema example for a blog application](img/B19528_06_02.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图6.2 — 博客应用的面向文档的架构示例](img/B19528_06_02.jpg)'
- en: Figure 6.2 — A document-oriented schema example for a blog application
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2 — 博客应用的面向文档的架构示例
- en: 'To retrieve a post and all of its comments, you don’t need to perform a join
    query: all the data comes in one query. This was the main motivation behind the
    development of document-oriented databases: increase query performance by limiting
    the need to look at several collections. In particular, they proved to be useful
    for applications with huge data scales and less structured data, such as social
    networks.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要检索一篇帖子及其所有评论，你不需要执行联接查询：所有数据只需一个查询即可获取。这是开发面向文档数据库的主要动机：通过减少查看多个集合的需求来提高查询性能。特别是，它们在处理具有巨大数据规模和较少结构化数据的应用（如社交网络）时表现出了极大的价值。
- en: Which one should you choose?
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你应该选择哪一个？
- en: As we mentioned in the introduction to this section, your choice of database
    engine greatly depends on your application and needs. A detailed comparison between
    relational and document-oriented databases is beyond the scope of this book, but
    let’s look at some elements for you to think about.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本节引言中提到的，你选择数据库引擎很大程度上取决于你的应用和需求。关系型数据库和面向文档的数据库之间的详细比较超出了本书的范围，但我们可以看一下你需要考虑的一些要素。
- en: Relational databases are very good for storing structured data with a lot of
    relationships between entities. Besides, they maintain data consistency at all
    costs, even in the event of errors or hardware failures. However, you’ll have
    to precisely define your schema and consider a migration system to update your
    schema if your needs evolve.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 关系型数据库非常适合存储结构化数据，且实体之间存在大量关系。此外，它们在任何情况下都会维护数据的一致性，即使在发生错误或硬件故障时也不例外。然而，你必须精确定义模式，并考虑迁移系统，以便在需求变化时更新你的模式。
- en: 'On the other hand, document-oriented databases don’t require you to define
    a schema: they accept any document structure, so they can be convenient if your
    data is highly variable or if your project is not mature enough. The downside
    of this is that they are far less picky in terms of data consistency, which could
    result in data loss or inconsistencies.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，面向文档的数据库不需要你定义模式：它们接受任何文档结构，因此如果你的数据高度可变或你的项目尚未成熟，它们会很方便。其缺点是，它们在数据一致性方面要求较低，可能导致数据丢失或不一致。
- en: 'For small and medium-sized applications, the choice doesn’t matter too much:
    both relational databases and document-oriented databases are very optimized and
    will deliver awesome performance at such scales.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 对于小型和中型应用程序，选择并不太重要：关系型数据库和面向文档的数据库都经过了高度优化，在这些规模下都会提供出色的性能。
- en: Next, we’ll show you how to work with these different kinds of databases using
    FastAPI. When we introduced asynchronous I/O in [*Chapter 2*](B19528_02.xhtml#_idTextAnchor032),
    *Python Programming Specificities*, we mentioned that it was important to carefully
    select the libraries you use to perform I/O operations. Of course, databases are
    particularly important in this context!
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将展示如何使用FastAPI处理这些不同类型的数据库。当我们在[*第2章*](B19528_02.xhtml#_idTextAnchor032)中介绍异步I/O时，*Python编程特性*，我们提到过选择你用来执行I/O操作的库是很重要的。当然，在这种情况下，数据库尤为重要！
- en: While working with classic non-async libraries is perfectly possible in FastAPI,
    you could miss out on one of the key aspects of the framework and might not reach
    the best performance it can offer. That’s why, in this chapter, we’ll only focus
    on async libraries.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在FastAPI中使用经典的非异步库是完全可行的，但你可能会错过框架的一个关键方面，无法达到它所能提供的最佳性能。因此，在本章中，我们将只专注于异步库。
- en: Communicating with a SQL database with SQLAlchemy ORM
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SQLAlchemy ORM与SQL数据库进行通信
- en: To begin, we’ll discuss how to work with a relational database using the SQLAlchemy
    library. SQLAlchemy has been around for years and is the most popular library
    in Python when you wish to work with SQL databases. Since version 1.4, it also
    natively supports async.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将讨论如何使用SQLAlchemy库处理关系型数据库。SQLAlchemy已经存在多年，并且是Python中处理SQL数据库时最受欢迎的库。从版本1.4开始，它也原生支持异步。
- en: 'The key thing to understand about this library is that it’s composed of two
    parts:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 理解这个库的关键点是，它由两个部分组成：
- en: '**SQLAlchemy Core**, which provides all the fundamental features to read and
    write data to SQL databases'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SQLAlchemy Core**，提供了读取和写入SQL数据库数据的所有基本功能'
- en: '**SQLAlchemy ORM**, which provides a powerful abstraction over SQL concepts'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SQLAlchemy ORM**，提供对SQL概念的强大抽象'
- en: While you can choose to only use SQLAlchemy Core, it’s generally more convenient
    to use ORM. The goal of ORM is to abstract away the SQL concepts of tables and
    columns so that you only have to deal with Python objects. The role of ORM is
    to *map* those objects to the tables and columns they belong to and generate the
    corresponding SQL queries automatically.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以选择只使用SQLAlchemy Core，但通常使用ORM更为方便。ORM的目标是抽象出表和列的SQL概念，这样你只需要处理Python对象。ORM的作用是将这些对象*映射*到它们所属的表和列，并自动生成相应的SQL查询。
- en: 'The first step is to install this library:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是安装这个库：
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Notice that we added two optional dependencies: `asyncio` and `mypy`. The first
    one ensures the tools for async support are installed.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们添加了两个可选依赖项：`asyncio`和`mypy`。第一个确保安装了异步支持所需的工具。
- en: The second one is a special plugin for mypy that provides special support for
    SQLAlchemy. ORM does a lot of magic things under the hood, which are hard for
    type checkers to understand. With this plugin, mypy learns to recognize those
    constructs.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个是一个为mypy提供特殊支持的插件，专门用于SQLAlchemy。ORM在后台做了很多“魔法”事情，这些对于类型检查器来说很难理解。有了这个插件，mypy能够学会识别这些构造。
- en: 'As we said in the introduction, numerous SQL engines exist. You have probably
    heard of PostgreSQL and MySQL, which are among the most popular. Another interesting
    choice is SQLite, a tiny engine that stores all the data inside a single file
    on your computer, without the need for complex server software. It’s ideal for
    testing and experimenting. To allow SQLAlchemy to talk to those engines, you’ll
    need to install the corresponding **driver**. Here are the async drivers you’ll
    need to install, depending on your engine:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在介绍中所说，存在许多SQL引擎。你可能听说过PostgreSQL和MySQL，它们是最受欢迎的引擎之一。另一个有趣的选择是SQLite，它是一个小型引擎，所有数据都存储在你电脑上的单个文件中，不需要复杂的服务器软件。它非常适合用于测试和实验。为了让SQLAlchemy能够与这些引擎进行通信，你需要安装相应的**驱动程序**。根据你的引擎，这里是你需要安装的异步驱动程序：
- en: 'PostgreSQL:'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PostgreSQL：
- en: '[PRE2]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'MySQL:'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MySQL：
- en: '[PRE3]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'SQLite:'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQLite：
- en: '[PRE4]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'For the rest of this section, we’ll work with SQLite databases. We’ll show
    you, step by step, how to set up a complete database interaction. *Figure 6**.4*
    shows the structure of the project:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的其余部分，我们将使用SQLite数据库。我们将一步步展示如何设置完整的数据库交互。*图6.4*展示了项目的结构：
- en: '![Figure 6.3 – The FastAPI and SQLAlchemy project structure](img/B19528_06_03.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.3 – FastAPI 和 SQLAlchemy 项目结构](img/B19528_06_03.jpg)'
- en: Figure 6.3 – The FastAPI and SQLAlchemy project structure
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.3 – FastAPI 和 SQLAlchemy 项目结构
- en: Creating ORM models
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 ORM 模型
- en: 'First, you need to define your ORM models. Each one is a Python class whose
    attributes represent the columns of your table. The actual entities of your database
    will be instances of this class, giving you access to its data, just like any
    other object. Under the hood, the role of SQLAlchemy ORM is to link this Python
    object and the row in the database. Let’s take a look at the definition of our
    blog post model:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要定义您的 ORM 模型。每个模型是一个 Python 类，其属性代表表中的列。数据库中的实际实体将是该类的实例，您可以像访问任何其他对象一样访问其数据。在幕后，SQLAlchemy
    ORM 的作用是将 Python 对象与数据库中的行链接起来。让我们来看一下我们博客文章模型的定义：
- en: models.py
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: models.py
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy/models.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy/models.py%0D)'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy/models.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy/models.py)'
- en: The first step is to create a `Base` class that inherits from `DeclarativeBase`.
    *All our models will inherit from this class*. Internally, SQLAlchemy uses it
    to keep all the information about your database schema together. This is why you
    should create it only once in your whole project and always use the same one throughout.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是创建一个继承自 `DeclarativeBase` 的 `Base` 类。*我们所有的模型都将继承自这个类*。在内部，SQLAlchemy 使用它来将所有有关数据库模式的信息集中在一起。这就是为什么在整个项目中只需要创建一次，并始终使用相同的
    `Base` 类。
- en: Next, we must define our `Post` class. Once again, notice how it inherits from
    `Base`. Inside this class, we can define each of our columns in the form of class
    properties. They are assigned thanks to the `mapped_column` function, which helps
    us define the type of the column and its related properties. For example, we define
    our `id` column as an integer primary key with auto-increment, which is quite
    common in a SQL database.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须定义我们的 `Post` 类。再次注意，它是如何从 `Base` 类继承的。在这个类中，我们可以以类属性的形式定义每一列。它们是通过 `mapped_column`
    函数来赋值的，这个函数帮助我们定义列的类型及其相关属性。例如，我们将 `id` 列定义为一个自增的整数主键，这在 SQL 数据库中非常常见。
- en: 'Note that we won’t go through all the types and options provided by SQLAlchemy.
    Just know that they closely follow the ones that are usually provided by SQL databases.
    You can check the complete list in the official documentation, as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们不会详细介绍 SQLAlchemy 提供的所有类型和选项。只需知道它们与 SQL 数据库通常提供的类型非常相似。您可以在官方文档中查看完整的列表，如下所示：
- en: You can find the list of types at [https://docs.sqlalchemy.org/en/20/core/type_basics.html#generic-camelcase-types](https://docs.sqlalchemy.org/en/20/core/type_basics.html#generic-camelcase-types%0D)
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在 [https://docs.sqlalchemy.org/en/20/core/type_basics.html#generic-camelcase-types](https://docs.sqlalchemy.org/en/20/core/type_basics.html#generic-camelcase-types)
    找到类型的列表。
- en: You can find the list of `mapped_column` arguments at [https://docs.sqlalchemy.org/en/20/orm/mapping_api.html#sqlalchemy.orm.mapped_column](https://docs.sqlalchemy.org/en/20/orm/mapping_api.html#sqlalchemy.orm.mapped_column%0D)
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在 [https://docs.sqlalchemy.org/en/20/orm/mapping_api.html#sqlalchemy.orm.mapped_column](https://docs.sqlalchemy.org/en/20/orm/mapping_api.html#sqlalchemy.orm.mapped_column)
    找到 `mapped_column` 参数的列表。
- en: 'Another interesting thing to notice here is that we added type hints to each
    property, which correspond to the Python type of our columns. This will greatly
    help us during development: for example, if we try to get the `title` property
    of a post object, the type checker will know it’s a string. For this to work,
    notice that we wrap each type with the `Mapped` class. This is a special class
    provided by SQLAlchemy so that the type checker can understand the underlying
    type of the data when we assign it a `MappedColumn` object.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这里另一个值得注意的有趣点是，我们为每个属性添加了类型提示，这些类型与我们列的 Python 类型对应。这将极大地帮助我们在开发过程中：例如，如果我们尝试获取帖子对象的
    `title` 属性，类型检查器会知道它是一个字符串。为了使这一点生效，请注意，我们将每个类型都包裹在 `Mapped` 类中。这是 SQLAlchemy
    提供的一个特殊类，类型检查器可以通过它了解数据的底层类型，当我们将一个 `MappedColumn` 对象分配给它时。
- en: This is how you declare models in SQLAlchemy 2.0
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在 SQLAlchemy 2.0 中声明模型的方式
- en: The way we’ll show you to declare models in this section is the newest way to
    do so, as introduced in SQLAlchemy 2.0.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本节中展示的声明模型的方式是 SQLAlchemy 2.0 中引入的最新方式。
- en: If you look at older tutorials or documentation on the web, you’ll probably
    come across a slightly different way where we assign properties to a `Column`
    object. While this older style still works in SQLAlchemy 2.0, it should be considered
    deprecated.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看网上较老的教程或文档，你可能会看到一种略有不同的方法，其中我们将属性分配给`Column`对象。虽然这种旧风格在SQLAlchemy 2.0中仍然有效，但它应该被视为过时的。
- en: We now have a model that will help us read and write post data to our database.
    However, as you’re now aware, with FastAPI, we’ll also need Pydantic models so
    that we can validate input data and output the right representation in our API.
    If you need a refresher about this, you can check [*Chapter 3*](B19528_03.xhtml#_idTextAnchor058),
    *Developing a RESTful API* *with FastAPI*.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个帮助我们读写数据库中帖子数据的模型。然而，正如你现在所知道的，使用FastAPI时，我们还需要Pydantic模型，以便验证输入数据并在API中输出正确的表示。如果你需要复习这部分内容，可以查看[*第3章*](B19528_03.xhtml#_idTextAnchor058)，*使用FastAPI开发RESTful
    API*。
- en: Defining Pydantic models
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义Pydantic模型
- en: 'As we said, if we want to correctly validate the data coming in and out of
    our FastAPI application, we’ll need Pydantic models. In an ORM context, they will
    help us *go back and forth with the ORM model*. That’s the key takeaway of this
    section: we’ll use Pydantic models to validate and serialize the data, but the
    database communication will be done with the ORM model.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所说的，如果我们想正确验证进出FastAPI应用的数据，我们需要使用Pydantic模型。在ORM上下文中，它们将帮助我们*在ORM模型之间来回转换*。这一节的关键要点是：我们将使用Pydantic模型来验证和序列化数据，但数据库通信将通过ORM模型完成。
- en: To avoid confusion, we’ll now refer to Pydantic models as **schemas**. When
    we talk about models, we’ll be referring to the ORM model.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免混淆，我们现在将Pydantic模型称为**模式**。当我们谈论模型时，我们指的是ORM模型。
- en: 'That’s why the definitions of those schemas are placed in the `schemas.py`
    module, which can be seen here:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么那些模式的定义被放置在`schemas.py`模块中的原因，如下所示：
- en: schemas.py
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: schemas.py
- en: '[PRE6]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy/schemas.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy/schemas.py%0D)'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy/schemas.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy/schemas.py%0D)'
- en: The preceding code corresponds to the pattern we explained in [*Chapter 4*](B19528_04.xhtml#_idTextAnchor176),
    *Managing Pydantic Data Models* *in FastAPI*.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码对应我们在[*第4章*](B19528_04.xhtml#_idTextAnchor176)中解释的模式，*在FastAPI中管理Pydantic数据模型*。
- en: 'There is a new thing, though: you probably noticed the `Config` subclass, which
    is defined in `PostBase`. It’s a way to add some configuration options to Pydantic
    schemas. Here, we set the `orm_mode` option to `True`. As its name suggests, it’s
    an option to make Pydantic work better with ORM. In a standard setting, Pydantic
    is designed to parse data from dictionaries: if it wants to parse the `title`
    property, it’ll use `d["title"]`. With ORM, however, we access the properties
    like an object – that is, by using dot notation (`o.title`). Enabling ORM mode
    allows Pydantic to use this style.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 但有一个新内容：你可能已经注意到`Config`子类，它是在`PostBase`中定义的。这是为Pydantic模式添加一些配置选项的一种方式。在这里，我们将`orm_mode`选项设置为`True`。顾名思义，这是一个使Pydantic与ORM更好配合的选项。在标准设置下，Pydantic被设计用来解析字典中的数据：如果它想解析`title`属性，它会使用`d["title"]`。然而，在ORM中，我们通过点号表示法（`o.title`）来像访问对象一样访问属性。启用ORM模式后，Pydantic就能使用这种风格。
- en: Connecting to a database
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接到数据库
- en: 'Now that our model and schemas are ready, we have to set up the connection
    between our FastAPI app and the database engine. For this, we’ll create a `database.py`
    module where we’ll put the objects we need for this task:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的模型和模式已经准备好了，我们必须设置FastAPI应用和数据库引擎之间的连接。为此，我们将创建一个`database.py`模块，并在其中放置我们需要的对象：
- en: database.py
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: database.py
- en: '[PRE7]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy/database.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy/database.py%0D)'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy/database.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy/database.py%0D)'
- en: 'Here, you can see that we have set our connection string inside the `DATABASE_URL`
    variable. Generally, it consists of the following:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到我们已经将连接字符串设置在`DATABASE_URL`变量中。通常，它由以下几个部分组成：
- en: The database engine. Here, we use `sqlite`.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库引擎。在这里，我们使用`sqlite`。
- en: Optionally, the driver, after a plus sign. Here, we set `aiosqlite`. In an async
    context, it’s necessary to specify the async driver we want to use. Otherwise,
    SQLAlchemy will fall back to a standard, synchronous driver.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选的驱动程序，后面带有加号。这里，我们设置为`aiosqlite`。在异步环境中，必须指定我们想要使用的异步驱动程序。否则，SQLAlchemy会回退到标准的同步驱动程序。
- en: Optionally, the authentication information.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选的身份验证信息。
- en: The hostname of the database server. In the case of SQLite, we simply have to
    specify the path of the file that will store all the data.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库服务器的主机名。在SQLite的情况下，我们只需指定将存储所有数据的文件路径。
- en: You can find an overview of this format in the official SQLAlchemy documentation
    at [https://docs.sqlalchemy.org/en/20/core/engines.html#database-urls](https://docs.sqlalchemy.org/en/20/core/engines.html#database-urls).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在官方SQLAlchemy文档中找到该格式的概述：[https://docs.sqlalchemy.org/en/20/core/engines.html#database-urls](https://docs.sqlalchemy.org/en/20/core/engines.html#database-urls)。
- en: 'Then, we create an engine using the `create_async_engine` function and this
    URL. An engine is an object where SQLAlchemy will manage the connection with your
    database. At this point, it’s important to understand that no connection is being
    made: we are just declaring things.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`create_async_engine`函数和这个URL创建引擎。引擎是一个对象，SQLAlchemy将在其中管理与数据库的连接。此时，重要的是要理解，尚未建立任何连接：我们只是声明了相关内容。
- en: We then have a more cryptic line to define the `async_session_maker` variable.
    We won’t go too much into the details of the `async_sessionmaker` function. Just
    know that it returns a function so that we can generate **sessions** tied to our
    database engine.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有一个更为复杂的代码行来定义`async_session_maker`变量。我们不会深入讨论`async_sessionmaker`函数的细节。只需知道它返回一个函数，允许我们生成与数据库引擎绑定的**会话**。
- en: What is a session? It’s a concept defined by ORM. A session will establish an
    actual connection with the database and represent a *zone* where it’ll store all
    the objects you’ve read from the database and all the ones you’ve defined that’ll
    be written to the database. It’s the proxy between the ORM concepts and the fundamental
    SQL queries.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是会话？它是由ORM定义的概念。会话将与数据库建立实际连接，并代表一个*区域*，在该区域中它将存储你从数据库中读取的所有对象以及你定义的所有将在数据库中写入的对象。它是ORM概念和基础SQL查询之间的代理。
- en: 'When building HTTP servers, we usually *open a fresh session when the request
    starts* and *close it when we answered the request*. Therefore, each HTTP request
    represents a unit of work with the database. That’s why we must define a FastAPI
    dependency whose role is to yield us a fresh session:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建HTTP服务器时，我们通常在请求开始时*打开一个新的会话*，并在响应请求时*关闭它*。因此，每个HTTP请求代表与数据库的一个工作单元。这就是为什么我们必须定义一个FastAPI依赖项，其作用是提供一个新的会话给我们：
- en: database.py
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: database.py
- en: '[PRE8]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy/database.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy/database.py)'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy/database.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy/database.py)'
- en: Having it as a dependency will greatly help us when implementing our path operation
    functions.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 将它作为依赖项将大大帮助我们在实现路径操作函数时。
- en: 'So far, we haven’t had the opportunity to talk about the `with` syntax. In
    Python, this is what’s called a `with` block, the object automatically executes
    the setup logic. When you *exit* the block, it executes its teardown logic. You
    can read more about context managers in the Python documentation: [https://docs.python.org/3/reference/datamodel.html#with-statement-context-managers](https://docs.python.org/3/reference/datamodel.html#with-statement-context-managers).'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们还没有机会讨论`with`语法。在Python中，这被称为`with`块，对象会自动执行设置逻辑。当你*退出*该块时，它会执行拆解逻辑。你可以在Python文档中阅读更多关于上下文管理器的信息：[https://docs.python.org/3/reference/datamodel.html#with-statement-context-managers](https://docs.python.org/3/reference/datamodel.html#with-statement-context-managers)。
- en: In our case, `async_session_maker` works as a context manager. Among other things,
    it takes care of opening a connection to the database.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，`async_session_maker`作为上下文管理器工作。它负责打开与数据库的连接等操作。
- en: Notice that we define a generator here by using `yield`. This is important because
    it ensures that the *session remains open until the end of the request*. If we
    were to use a simple `return` statement, the context manager would close immediately.
    With `yield`, we make sure we only get out of the context manager when the request
    and our endpoint logic have been fully handled by FastAPI.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在这里通过使用`yield`定义了一个生成器。这一点很重要，因为它确保了*会话在请求结束前保持打开状态*。如果我们使用一个简单的`return`语句，上下文管理器会立即关闭。使用`yield`时，我们确保只有在请求和端点逻辑被FastAPI完全处理后，才会退出上下文管理器。
- en: Using a dependency to retrieve a database instance
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 使用依赖注入来获取数据库实例
- en: You might be wondering why we don’t just call `async_session_maker` directly
    in our path operation functions rather than using a dependency. This would work,
    but it would make our life very hard when we try to implement unit tests. Indeed,
    it would be very difficult to replace this instance with a mock or test database.
    With a dependency, FastAPI makes it very easy to swap it with another function.
    We’ll see this in more detail in [*Chapter 9*](B19528_09.xhtml#_idTextAnchor618),
    *Testing an API Asynchronously with pytest* *and HTTPX*.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，为什么我们不直接在路径操作函数中调用`async_session_maker`，而是使用依赖注入。这是可行的，但当我们尝试实现单元测试时会非常困难。实际上，将这个实例替换为模拟对象或测试数据库将变得非常困难。通过使用依赖注入，FastAPI使得我们可以轻松地将其替换为另一个函数。我们将在[*第9章*](B19528_09.xhtml#_idTextAnchor618)，*使用pytest和HTTPX异步测试API*中详细了解这一点。
- en: The last thing we must define in this module is the `create_all_tables` function.
    Its goal is to create the table’s schema inside our database. If we don’t do that,
    our database will be empty and we wouldn’t be able to save or retrieve data. Creating
    a schema like this is a simple approach that’s only suitable for simple examples
    and experiments. In a real-world application, you should have a proper migration
    system whose role is to make sure your database schema is in sync. We’ll learn
    how to set one up for SQLAlchemy later in this chapter.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个模块中我们必须定义的最后一个函数是`create_all_tables`。它的目标是创建数据库中的表模式。如果我们不这么做，数据库将是空的，无法保存或检索数据。像这样创建模式是一种简单的做法，只适用于简单的示例和实验。在实际应用中，你应该有一个合适的迁移系统，确保你的数据库模式保持同步。我们将在本章稍后学习如何为SQLAlchemy设置迁移系统。
- en: 'To make sure our schema is created when our application starts, we must call
    this function the `app.py` module:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保在应用启动时创建我们的模式，我们必须在`app.py`模块中调用这个函数：
- en: app.py
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: app.py
- en: '[PRE9]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy/app.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy/app.py)'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy/app.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy/app.py)'
- en: Creating objects
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建对象
- en: 'Let’s start by inserting new objects inside our database. The main challenge
    is to take a Pydantic schema as input, transform it into a SQLAlchemy model, and
    save it in the database. Let’s review this process, which is shown in the following
    example:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从向数据库中插入新对象开始。主要的挑战是接受Pydantic模式作为输入，将其转换为SQLAlchemy模型，并将其保存到数据库中。让我们回顾一下这个过程，如下例所示：
- en: app.py
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: app.py
- en: '[PRE10]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy/app.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy/app.py)'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy/app.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy/app.py)'
- en: Here, we have our `POST` endpoint, which accepts our `PostCreate` schema. Notice
    that we inject a fresh SQLAlchemy session using our `get_async_session` dependency.
    The core logic consists of two operations.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个`POST`端点，接受我们的`PostCreate`模式。注意，我们通过`get_async_session`依赖注入了一个新的SQLAlchemy会话。核心逻辑包括两个操作。
- en: 'First, we transform `post_create` into a full `Post` model object. For this,
    we can simply call the `dict` method of Pydantic and *unpack* it with `**` to
    directly assign the properties. At this point, the post is not in the database
    yet: we need to tell the session about it.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将`post_create`转换为完整的`Post`模型对象。为此，我们可以简单地调用Pydantic的`dict`方法，并用`**`解包它，直接赋值给属性。此时，文章还没有保存到数据库中：我们需要告诉会话有关它的信息。
- en: 'The first step is to *add it in the session*, through the `add` method. Now,
    the post is in the session memory, but not in the database yet. By calling the
    `commit` method, we tell the session to generate the appropriate SQL queries and
    execute them on the database. As we might expect, we see that we need to *await*
    this method: we perform an I/O operation on the database, so it’s an async operation.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是通过`add`方法*将其添加到会话中*。现在，post 已经进入会话内存，但尚未存储在数据库中。通过调用`commit`方法，我们告诉会话生成适当的
    SQL 查询并在数据库上执行它们。正如我们所预料的那样，我们发现需要*await*此方法：我们对数据库进行了 I/O 操作，因此它是异步操作。
- en: 'Finally, we can just return the `post` object. You may be surprised that we
    directly return a SQLAlchemy ORM object rather than a Pydantic schema. How could
    FastAPI correctly serialize it with the properties we specified? If you pay attention,
    you’ll see that we set the `response_model` property in the path operation decorator.
    As you may recall from the *Response model* section of [*Chapter 3*](B19528_03.xhtml#_idTextAnchor058),
    *Developing a RESTful API with FastAPI*, you’ll understand what is going on: FastAPI
    will automatically take care of transforming the ORM object into the specified
    schema. And that’s exactly why we need to enable `orm_mode` of Pydantic, as shown
    in the previous section!'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以直接返回`post`对象。你可能会惊讶于我们直接返回了一个 SQLAlchemy ORM 对象，而不是 Pydantic 模式。FastAPI
    如何正确地序列化它并保留我们指定的属性呢？如果你留心一下，你会看到我们在路径操作装饰器中设置了`response_model`属性。正如你可能从 [*第 3
    章*](B19528_03.xhtml#_idTextAnchor058)的*响应模型*部分回想起来的那样，*使用 FastAPI 开发 RESTful API*，你就能理解发生了什么：FastAPI
    会自动处理将 ORM 对象转化为指定模式的过程。正因为如此，我们需要启用 Pydantic 的`orm_mode`，正如前面一节所示！
- en: From this, you can see that the implementation is quite straightforward. Now,
    let’s retrieve this data!
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，你可以看到实现过程非常直接。现在，让我们来检索这些数据吧！
- en: Getting and filtering objects
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取和筛选对象
- en: 'Usually, a REST API provides two types of endpoints to read data: one to list
    objects and one to get a specific object. This is exactly what we’ll review next!'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，REST API 提供两种类型的端点来读取数据：一种用于列出对象，另一种用于获取特定对象。这正是我们接下来要回顾的内容！
- en: 'In the following example, you can see how we implemented the endpoint to list
    objects:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，你可以看到我们如何实现列出对象的端点：
- en: app.py
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: app.py
- en: '[PRE11]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy/app.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy/app.py)'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy/app.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy/app.py)'
- en: 'The operation is performed in two steps. First, we build a query. The `select`
    function of SQLAlchemy allows us to begin defining a query. Conveniently, we can
    directly pass it the `model` class: it’ll automatically understand which table
    we are talking about. From there, we can apply various methods and filters, which
    are a mirror of what we could expect in pure SQL. Here, we’re able to apply our
    pagination parameters through `offset` and `limit`.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 该操作分为两步执行。首先，我们构建一个查询。SQLAlchemy 的`select`函数允许我们开始定义查询。方便的是，我们可以直接将`model`类传递给它：它会自动理解我们所谈论的表格。接下来，我们可以应用各种方法和筛选条件，这些与纯
    SQL 中的操作是相似的。在这里，我们能够通过`offset`和`limit`应用我们的分页参数。
- en: Then, we execute this query using the `execute` method of a fresh session object
    (which was, once again, injected by our dependency). Since we read data from the
    database, it’s an async operation.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用一个新的会话对象的`execute`方法执行此查询（该会话对象再次通过我们的依赖注入）。由于我们是从数据库中读取数据，这是一项异步操作。
- en: From this, we get a `result` object. This object is an instance of the `Result`
    class of SQLAlchemy. It’s not directly our list of posts, but rather a set representing
    the results of the SQL query. That’s why we need to call `scalars` and `all`.
    The first one will make sure we get actual `Post` objects, while the second will
    return them as a sequence.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 由此，我们得到一个`result`对象。这个对象是 SQLAlchemy 的`Result`类的实例。它不是我们直接的帖子列表，而是表示 SQL 查询结果的一个集合。这就是为什么我们需要调用`scalars`和`all`。第一个方法会确保我们获得实际的`Post`对象，而第二个方法会将它们作为一个序列返回。
- en: 'Once again, we can directly return those SQLAlchemy ORM objects: FastAPI will
    transform them into the correct schema thanks to the `response_model` setting.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 再次说明，我们可以直接返回这些 SQLAlchemy ORM 对象：感谢`response_model`设置，FastAPI 会将它们转化为正确的模式。
- en: 'Now, let’s see how we can retrieve a single post by ID:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何通过 ID 获取单个 post：
- en: app.py
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: app.py
- en: '[PRE12]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy/app.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy/app.py)'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy/app.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy/app.py)'
- en: 'This is a simple `GET` endpoint that expects the ID of the post in the path
    parameter. The implementation is very light: we just return the post. Most of
    the logic is in the `get_post_or_404` dependency, which we’ll reuse often in our
    application. Here is its implementation:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的`GET`端点，期望在路径参数中提供帖子的ID。实现非常简单：我们只是返回帖子。大部分逻辑在`get_post_or_404`依赖项中，我们将在应用程序中经常重复使用它。以下是它的实现：
- en: app.py
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: app.py
- en: '[PRE13]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy/app.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy/app.py)'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy/app.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy/app.py)'
- en: As you can see, it’s quite similar to what we’ve seen for the list endpoint.
    We also start by building a select query, but this time, we add a `where` clause
    so that we can retrieve only the post matching the desired ID. The clause itself
    might look strange.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这与我们在列表端点看到的内容非常相似。我们同样从构建一个选择查询开始，但这次，我们添加了一个`where`子句，以便只检索与所需ID匹配的帖子。这个子句本身可能看起来有些奇怪。
- en: First, we must set the actual column we want to compare. Indeed, when you access
    the properties of the `model` class directly, such as `Post.id`, SQLAlchemy automatically
    understands that you are referring to the column.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须设置我们想要比较的实际列。事实上，当你直接访问`model`类的属性时，比如`Post.id`，SQLAlchemy会自动理解你在引用列。
- en: 'Then, we use the equality operator to compare the column with our actual `id`
    variable. It looks like a standard comparison that would result in a Boolean,
    not a SQL statement! In a general Python context, it would. However, SQLAlchemy
    developers have done something clever here: they overloaded the standard operators
    so that they produce SQL expressions instead of comparing objects. This is exactly
    what we saw in the *Magic methods* section of [*Chapter 2*](B19528_02.xhtml#_idTextAnchor032),
    *Python* *Programming Specificities*.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用等号运算符来比较列与我们实际的`id`变量。它看起来像是一个标准的比较，会产生一个布尔值，而不是一个SQL语句！在一般的Python环境中，确实是这样。然而，SQLAlchemy的开发者在这里做了一些聪明的事情：他们重载了标准运算符，使其产生SQL表达式而不是比较对象。这正是我们在[*第2章*](B19528_02.xhtml#_idTextAnchor032)的*Python*
    *编程特性*中看到的内容。
- en: Now, we can simply execute the query and call `scalar_one_or_none` on the result
    set. It’s a convenient shortcut that tells SQLAlchemy to return a single object
    if it exists, or `None` otherwise.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以简单地执行查询并在结果集上调用`scalar_one_or_none`。这是一个方便的快捷方式，告诉SQLAlchemy如果存在单个对象则返回它，否则返回`None`。
- en: 'If the result is `None`, we can raise a `404` error: no post is matching this
    ID. Otherwise, we can simply return the post.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果结果是`None`，我们可以抛出一个`404`错误：没有帖子匹配这个ID。否则，我们可以简单地返回帖子。
- en: Updating and deleting objects
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新和删除对象
- en: We’ll finish by showing you how to update and delete existing objects. You’ll
    see it’s just a matter of manipulating the ORM object and calling the right method
    on `session`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将展示如何更新和删除现有对象。你会发现这只是操作ORM对象并在`session`上调用正确方法的事情。
- en: 'Check out the following code and review the implementation of the `update`
    endpoint:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 检查以下代码，并审查`update`端点的实现：
- en: app.py
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: app.py
- en: '[PRE14]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy/app.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy/app.py)'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy/app.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy/app.py)'
- en: 'Here, the main point of attention is that we’ll operate directly on the post
    we want to modify. This is one of the key aspects when working with ORM: entities
    are objects that can be modified as you wish. When you are happy with the data,
    you can persist it in the database. This is exactly what we are doing here: we
    get a fresh representation of our post thanks to `get_post_or_404`. Then, we transform
    the `post_update` schema into a dictionary, and we iterate over the properties
    to set them on our ORM object. Finally, we can save it in the session and commit
    it to the database, as we did for creation.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，主要需要注意的是，我们将直接操作我们想要修改的帖子。这是使用ORM时的一个关键点：实体是可以按需修改的对象。当你对数据满意时，可以将其持久化到数据库中。这正是我们在这里所做的：我们通过`get_post_or_404`获取帖子的最新表示。然后，我们将`post_update`架构转换为字典，并遍历这些属性，将它们设置到我们的ORM对象上。最后，我们可以将其保存在会话中并提交到数据库，就像我们在创建时所做的那样。
- en: 'The same concept is applied when you wish to delete an object: when you have
    an instance, you can pass it to the `delete` method of `session` so that it can
    schedule it for removal. You can view this in action in the following example:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想删除一个对象时，同样的概念也适用：当你拥有一个实例时，可以将其传递给`session`的`delete`方法，从而安排它的删除。你可以通过以下示例查看这一过程：
- en: app.py
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: app.py
- en: '[PRE15]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy/app.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy/app.py)'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy/app.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy/app.py)'
- en: 'Throughout these examples, you’ve seen that we always call `commit` after a
    write operation: your changes must be written in the database. Otherwise, they’ll
    just stay in the session memory and be lost.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些示例中，你看到我们总是在写操作后调用`commit`：你的更改必须被写入数据库，否则它们将仅停留在会话内存中并丢失。
- en: Adding relationships
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加关系
- en: As we mentioned at the beginning of this chapter, relational databases are all
    about data and its relationships. Quite often, you’ll need to create entities
    that are linked to others. For example, in a blog application, comments are linked
    to the post they relate to. In this section, we’ll examine how you can set up
    such relationships with SQLAlchemy ORM.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章开头提到的，关系型数据库关心的是数据及其关系。你经常需要创建与其他实体相关联的实体。例如，在一个博客应用中，评论是与其相关的帖子关联的。在这一部分，我们将讨论如何使用SQLAlchemy
    ORM设置这种关系。
- en: 'First, we need to define a new model for comments. This new model must be placed
    above `Post` in the code. We’ll explain why this matters later. You can view its
    definition in the following example:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要为评论定义一个新模型。这个新模型必须放在`Post`模型之上。稍后我们会解释为什么这很重要。你可以在以下示例中查看它的定义：
- en: models.py
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: models.py
- en: '[PRE16]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy_relationship/models.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy_relationship/models.py)'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy_relationship/models.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy_relationship/models.py)'
- en: The important point here is the `post_id` column, which is of the `ForeignKey`
    type. This is a special type that tells SQLAlchemy to automatically handle the
    type of the column and the associated constraint. We simply have to give the table
    and column names it refers to.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的重要点是`post_id`列，它是`ForeignKey`类型。这是一个特殊类型，告诉SQLAlchemy自动处理该列的类型和相关约束。我们只需要提供它所指向的表和列名。
- en: But that’s only the SQL part of the definition. We now need to tell ORM that
    our `Comment` object has a relationship with a `Post` object. This is the purpose
    of the `post` property, which is assigned to the `relationship` function. It’s
    a special function exposed by SQLAlchemy ORM to *define how models relate to each
    other*. It won’t create a new column in the SQL definition – that’s the role of
    the `ForeignKey` column – but it’ll allow us to directly get the `Post` object
    linked to a comment by using `comment.post`. You can also see that we define the
    `back_populates` argument. It allows us to do the opposite operation – that is,
    get the list of comments from a post. The name of this option determines the name
    of the property we’ll use to access the comment. Here, this is `post.comments`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 但这只是定义中的SQL部分。现在我们需要告诉ORM我们的`Comment`对象与`Post`对象之间存在关系。这就是`post`属性的目的，它被分配给`relationship`函数。它是SQLAlchemy
    ORM暴露的一个特殊函数，用来*定义模型之间的关系*。它不会在SQL定义中创建一个新列——这是`ForeignKey`列的作用——但它允许我们通过`comment.post`直接获取与评论相关联的`Post`对象。你还可以看到我们定义了`back_populates`参数。它允许我们执行相反的操作——也就是说，从一个`post`获取评论列表。这个选项的名称决定了我们用来访问评论的属性名。这里，它是`post.comments`。
- en: Forward reference type hint
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 前向引用类型提示
- en: 'If you look at the type hint of the post property, you will see that we correctly
    set it to the `Post` class. However, we put it inside quotes: `post: "Post" =
    …`.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '如果你查看`post`属性的类型提示，你会看到我们正确地将其设置为`Post`类。然而，我们将其放在了引号中：`post: "Post" = …`。'
- en: This is what is called a `Post` is defined after `Comment`. If we forget the
    quotes, Python will complain because we are trying to access something that doesn’t
    exist yet. To solve this, we can put it inside quotes. Type checkers are smart
    enough to understand what you are referring to.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是所谓的`Post`在`Comment`之后定义。如果我们忘记了引号，Python会抱怨，因为我们试图访问一个尚未存在的东西。为了解决这个问题，我们可以将其放在引号中。类型检查器足够智能，可以理解你指的是什么。
- en: 'Now, if you look at the `Post` model, as follows, you’ll see that we added
    one thing:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你查看以下`Post`模型，你会看到我们添加了一个内容：
- en: models.py
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: models.py
- en: '[PRE17]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy_relationship/models.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy_relationship/models.py)'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy_relationship/models.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy_relationship/models.py)'
- en: 'We also defined the mirror relationship, taking care of *naming with the same
    name we chose for* `back_populates`. This time, we also set the `cascade` argument,
    which allows us to define the behavior of ORM when we delete a post: should we
    implicitly delete the comments as well? Or should we keep them as orphans? In
    this case, we chose to delete them. Note that it’s *not the same thing* as the
    `CASCADE DELETE` construct of SQL: it has the same effect, but it will be handled
    by ORM in the Python code, not by the SQL database.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还定义了镜像关系，并注意*以我们为`back_populates`选择的相同名称命名*。这次，我们还设置了`cascade`参数，它允许我们定义ORM在删除帖子时的行为：我们是应该隐式删除评论，还是将它们保留为孤立的？在这个例子中，我们选择了删除它们。请注意，这与SQL的`CASCADE
    DELETE`构造*不完全相同*：它具有相同的效果，但将由ORM在Python代码中处理，而不是由SQL数据库处理。
- en: 'There are a lot of options regarding relationships, all of which you can find
    in the official documentation: [https://docs.sqlalchemy.org/en/20/orm/relationship_api.html#sqlalchemy.orm.relationship.](https://docs.sqlalchemy.org/en/20/orm/relationship_api.html#sqlalchemy.orm.relationship%0D)'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 关于关系有很多选项，所有这些选项都可以在官方文档中找到：[https://docs.sqlalchemy.org/en/20/orm/relationship_api.html#sqlalchemy.orm.relationship.](https://docs.sqlalchemy.org/en/20/orm/relationship_api.html#sqlalchemy.orm.relationship%0D)
- en: 'Once again, adding this `comments` property doesn’t change the SQL definition:
    it’s just a way to wire things for ORM, on the Python side.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，添加这个`comments`属性并不会改变SQL定义：它只是为ORM在Python端做的连接。
- en: 'Now, we can define the Pydantic schemas for our comment entity. They are quite
    straightforward, so we won’t go into the details. However, notice how we added
    the `comments` property to the `PostRead` schema:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以为评论实体定义Pydantic模式。它们非常直接，因此我们不会深入讨论细节。但请注意我们是如何将`comments`属性添加到`PostRead`模式中的：
- en: schemas.py
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: schemas.py
- en: '[PRE18]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy_relationship/schemas.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy_relationship/schemas.py)'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy_relationship/schemas.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy_relationship/schemas.py)'
- en: Indeed, in a REST API, there are some cases where it makes sense to automatically
    retrieve the associated objects of an entity. Here, it’ll be convenient to get
    the comments of a post in a single request. This schema will allow us to *serialize
    the comments, along with the* *post data*.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 确实，在REST API中，有些情况下自动检索实体的相关对象是有意义的。在这里，能够在一次请求中获取帖子的评论会很方便。这个架构将允许我们*序列化评论以及*帖子数据*。
- en: 'Now, we’ll implement an endpoint to create a new comment. This is shown in
    the following example:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将实现一个端点来创建新的评论。以下示例展示了这一点：
- en: app.py
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: app.py
- en: '[PRE19]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy_relationship/app.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy_relationship/app.py)'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy_relationship/app.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy_relationship/app.py)'
- en: This endpoint is defined, so we need to set the post ID directly in the path.
    It allows us to reuse the `get_post_or_404` dependency and automatically have
    a `404` error occur if we try to add a comment to a non-existing post.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这个端点已定义，因此我们需要直接在路径中设置帖子ID。它允许我们重用`get_post_or_404`依赖项，并且如果尝试向不存在的帖子添加评论时，会自动触发`404`错误。
- en: Other than that, it’s very similar to what we saw in the *Creating objects*
    section of this chapter. The only point of attention here is that we manually
    set the `post` property on this new `comment` object. Thanks to the relationship
    definition, we can directly assign the `post` object, and ORM will automatically
    set the right value in the `post_id` column.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，它与本章中*创建对象*部分的内容非常相似。这里唯一需要注意的是，我们手动设置了这个新`comment`对象的`post`属性。由于关系定义的存在，我们可以直接分配`post`对象，ORM将自动在`post_id`列中设置正确的值。
- en: 'Earlier, we mentioned that we wanted to retrieve a post and its comments at
    the same time. To do this, we’ll have to tweak our queries a bit when getting
    posts. The following sample shows what we did for the `get_post_or_404` function,
    but the same goes for the list endpoint:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 之前我们提到过，我们希望同时检索帖子及其评论。为了实现这一点，我们在获取帖子时需要稍微调整一下查询。以下示例展示了我们为`get_post_or_404`函数所做的调整，但对列表端点也是一样的：
- en: app.py
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: app.py
- en: '[PRE20]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy_relationship/app.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy_relationship/app.py)'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy_relationship/app.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy_relationship/app.py)'
- en: As you can see, we added a call to `options` with a `selectinload` construct.
    This is a way to tell ORM to automatically retrieve the associated comments of
    the post when performing the query. If we don’t do this, we’ll get an error. Why?
    Because of the async nature of our queries. But let’s start from the beginning.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们添加了对`options`的调用，并使用了`selectinload`构造。这是告诉ORM在执行查询时自动检索帖子的相关评论的一种方式。如果我们不这么做，就会出错。为什么？因为我们的查询是异步的。但我们从头开始讲。
- en: 'In a classic synchronous ORM context, you can do this:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在经典的同步ORM上下文中，你可以这样做：
- en: '[PRE21]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: If `comments` was not loaded in the first request, synchronous ORM will implicitly
    perform a new query on the SQL database. It’s invisible to the user, but an I/O
    operation is performed. This is called **lazy loading**, and it’s the default
    behavior for relationships in SQLAlchemy.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`comments`在第一次请求时没有被加载，同步ORM将隐式地对SQL数据库执行一个新查询。这对用户是不可见的，但实际上会进行I/O操作。这被称为**懒加载**，它是SQLAlchemy中关系的默认行为。
- en: 'However, in an async context, I/O operations can’t be done implicitly: we have
    to *await* them. This is why you will get an error if you forget to explicitly
    load the relationship into the first query. When Pydantic tries to serialize the
    `PostRead` schema, it’ll try to reach `post.comments`, but SQLAlchemy can’t perform
    this implicit query.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在异步上下文中，I/O操作不能隐式执行：我们必须显式地*等待（await）*它们。这就是为什么如果你忘记在第一次查询时显式加载关系，系统会报错的原因。当Pydantic尝试序列化`PostRead`模式时，它将尝试访问`post.comments`，但是SQLAlchemy无法执行这个隐式查询。
- en: 'So, when working with async, you need to perform **eager loading** on the relationships
    you want to access directly from the ORM object. Admittedly, this is way less
    convenient than its sync counterpart. However, it has a massive advantage: you
    *finely control which queries are made*. Indeed, with a synchronous ORM, it’s
    quite usual to have bad performance on an endpoint because the code performs dozens
    of implicit queries. With an asynchronous ORM, you can make sure you load everything
    in a single or few queries. It’s a trade-off that can pay in the long run.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在使用异步（async）时，你需要在关系上执行**预加载（eager loading）**，以便直接从ORM对象访问。诚然，这比同步版本不太方便。然而，它有一个巨大的优势：你可以*精确控制执行的查询*。事实上，使用同步ORM时，某些端点可能因为代码执行了数十个隐式查询而导致性能不佳。而使用异步ORM时，你可以确保所有内容都在单个或少数几个查询中加载。这是一种权衡，但从长远来看，它可能会带来好处。
- en: Eager loading can be configured on the relationship
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在关系中配置预加载（eager loading）
- en: 'If you’re sure that you’ll always need to load the related objects of an entity,
    regardless of the context, you can define the eager loading strategy directly
    on the `relationship` function. This way, you won’t need to set it on each query.
    You can read more about this in the official documentation: [https://docs.sqlalchemy.org/en/20/orm/relationship_api.html#sqlalchemy.orm.relationship.params.lazy](https://docs.sqlalchemy.org/en/20/orm/relationship_api.html#sqlalchemy.orm.relationship.params.lazy).'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你确定无论上下文如何，你始终需要加载实体的相关对象，你可以直接在`relationship`函数中定义预加载策略。这样，你就无需在每个查询中设置它。你可以在官方文档中阅读更多关于此的信息：[https://docs.sqlalchemy.org/en/20/orm/relationship_api.html#sqlalchemy.orm.relationship.params.lazy](https://docs.sqlalchemy.org/en/20/orm/relationship_api.html#sqlalchemy.orm.relationship.params.lazy)。
- en: Essentially, that’s it for working with relationships with SQLAlchemy ORM. You’ve
    seen that the key thing is to correctly define the relationship so that ORM can
    understand how objects are linked together.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，处理SQLAlchemy ORM中的关系就是这些。你已经看到，关键在于正确定义关系，以便ORM可以理解对象之间是如何关联的。
- en: Setting up a database migration system with Alembic
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Alembic设置数据库迁移系统
- en: 'When developing an application, you’ll likely make changes to your database
    schema to add new tables, add new columns, or modify existing ones. Of course,
    if your application is already in production, you don’t want to erase all your
    data to recreate the schema from scratch: you want it to be migrated to the new
    schema. Tools for this task have been developed, and in this section, we’ll learn
    how to set up *Alembic*, from the creators of SQLAlchemy. Let’s install this library:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发应用程序时，你很可能会对数据库模式进行更改，添加新表、新列或修改现有的列。当然，如果你的应用程序已经投入生产，你不希望删除所有数据并重新创建数据库模式：你希望它能迁移到新的模式。为此任务开发了相关工具，本节将学习如何设置*Alembic*，它是SQLAlchemy的创作者所开发的库。让我们来安装这个库：
- en: '[PRE22]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Once you’ve done this, you’ll have access to the `alembic` command to manage
    this migration system. When starting a new project, the first thing you must do
    is initialize the migration environment, which includes a set of files and directories
    where Alembic will store its configuration and migration files. At the root of
    your project, run the following command:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此操作后，你将能够使用`alembic`命令来管理此迁移系统。在开始一个新项目时，首先需要初始化迁移环境，该环境包括一组文件和目录，Alembic将在其中存储其配置和迁移文件。在项目的根目录下，运行以下命令：
- en: '[PRE23]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This will create a directory, named `alembic`, at the root of your project.
    You can view the result of this command in the example repository shown in *Figure
    6**.4*:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这将会在项目的根目录下创建一个名为`alembic`的目录。你可以在*图6.4*所示的示例仓库中查看该命令的执行结果：
- en: '![Figure 6.4 – The Alembic migration environment structure](img/B19528_06_04.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![图6.4 – Alembic迁移环境结构](img/B19528_06_04.jpg)'
- en: Figure 6.4 – The Alembic migration environment structure
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4 – Alembic迁移环境结构
- en: This folder will contain all the configurations for your migrations and your
    migration scripts themselves. It should be committed along with your code so that
    you have a record of the versions of those files.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件夹将包含所有迁移的配置以及迁移脚本本身。它应该与代码一起提交，以便你有这些文件版本的记录。
- en: 'Additionally, note that it created an `alembic.ini` file, which contains all
    the configuration options of Alembic. We’ll review one important setting in this
    file: `sqlalchemy.url`. This can be seen in the following code:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，请注意，它创建了一个`alembic.ini`文件，其中包含了Alembic的所有配置选项。我们将在此文件中查看一个重要的设置：`sqlalchemy.url`。你可以在以下代码中看到：
- en: alembic.ini
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: alembic.ini
- en: '[PRE24]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy_relationship/alembic.ini](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy_relationship/alembic.ini)'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy_relationship/alembic.ini](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy_relationship/alembic.ini)'
- en: 'Predictably, this is the connection string of your database that will receive
    the migration queries. It follows the same convention that we saw earlier. Here,
    we set our SQLite database. However, note that we don’t set the `aiosqlite` driver:
    Alembic will only work with synchronous drivers. It’s not a big deal since it’ll
    only run in dedicated scripts to perform migrations.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 可以预见的是，这是你数据库的连接字符串，它将接收迁移查询。它遵循我们之前看到的相同约定。在这里，我们设置了SQLite数据库。但是，请注意，我们没有设置`aiosqlite`驱动程序：Alembic只能与同步驱动程序一起使用。这并不是什么大问题，因为它仅在执行迁移的专用脚本中运行。
- en: 'Next, we’ll focus on the `env.py` file. This is a Python script that contains
    all the logic executed by Alembic to initialize the migration engine and execute
    the migrations. Being a Python script, it allows us to finely customize the execution
    of Alembic. For the time being, we’ll keep the default one, except for one thing:
    we’ll import our `Base` object. You can view this in the following example:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将重点关注`env.py`文件。它是一个包含Alembic初始化迁移引擎和执行迁移的所有逻辑的Python脚本。作为Python脚本，它允许我们精细定制Alembic的执行。暂时我们保持默认配置，除了一个小改动：我们会导入我们的`Base`对象。你可以通过以下示例查看：
- en: env.py
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: env.py
- en: '[PRE25]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy_relationship/alembic/env.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy_relationship/alembic/env.py)'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy_relationship/alembic/env.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy_relationship/alembic/env.py)'
- en: By default, the file defines a variable named `target_metadata`, which is set
    to `None`. Here, we changed it so that it refers to the `Base.metadata` object
    we imported from our `models` module. But why do we do that? Well, recall that
    `Base` is a SQLAlchemy object that contains all the information about your database
    schema. By providing it to Alembic, the migration system will be able to *automatically
    generate the migration scripts* just by looking at your schema! This way, you
    won’t have to write them from scratch.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，该文件定义了一个名为`target_metadata`的变量，初始值为`None`。在这里，我们将其修改为指向从`models`模块导入的`Base.metadata`对象。但为什么要这么做呢？回想一下，`Base`是一个SQLAlchemy对象，包含了数据库架构的所有信息。通过将它提供给Alembic，迁移系统将能够*自动生成迁移脚本*，只需查看你的架构！这样，你就不必从头编写迁移脚本了。
- en: 'Once you have made changes to your database schema, you can run the following
    command to generate a new migration script:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你对数据库架构进行了更改，可以运行以下命令生成新的迁移脚本：
- en: '[PRE26]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This will create a new script in the `versions` directory with the commands
    reflecting your schema changes. This file defines two functions: `upgrade` and
    `downgrade`. You can view `upgrade` in the following snippet:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这将根据你的架构更改创建一个新的脚本文件，并将命令反映到`versions`目录中。该文件定义了两个函数：`upgrade`和`downgrade`。你可以在以下代码片段中查看`upgrade`：
- en: eabd3f9c5b64_initial_migration.py
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: eabd3f9c5b64_initial_migration.py
- en: '[PRE27]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy_relationship/alembic/versions/eabd3f9c5b64_initial_migration.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy_relationship/alembic/versions/eabd3f9c5b64_initial_migration.py)'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy_relationship/alembic/versions/eabd3f9c5b64_initial_migration.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy_relationship/alembic/versions/eabd3f9c5b64_initial_migration.py)'
- en: This function is executed when we *apply the migration*. It describes the required
    operations to create our `posts` and `comments` table, with all of their columns
    and constraints.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数在我们*应用迁移*时执行。它描述了创建 `posts` 和 `comments` 表所需的操作，包括所有列和约束。
- en: 'Now, let’s examine the other function in this file, `downgrade`:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下这个文件中的另一个函数，`downgrade`：
- en: eabd3f9c5b64_initial_migration.py
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: eabd3f9c5b64_initial_migration.py
- en: '[PRE28]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy_relationship/alembic/versions/eabd3f9c5b64_initial_migration.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy_relationship/alembic/versions/eabd3f9c5b64_initial_migration.py)'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy_relationship/alembic/versions/eabd3f9c5b64_initial_migration.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/sqlalchemy_relationship/alembic/versions/eabd3f9c5b64_initial_migration.py)'
- en: This function describes the operations to *roll back the migration* so that
    the databases go back to their previous states. This is very important because
    if something goes wrong during the migration, or if you need to revert to an older
    version of your application, you’ll be able to do so without breaking your data.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数描述了*回滚迁移*的操作，以便数据库恢复到之前的状态。这一点非常重要，因为如果迁移过程中出现问题，或者你需要恢复到应用程序的旧版本，你可以在不破坏数据的情况下做到这一点。
- en: Autogeneration doesn’t detect everything
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 自动生成并不能检测到所有问题
- en: Bear in mind that, even though autogeneration is very helpful, it’s not always
    accurate, and sometimes, it’s not able to detect ambiguous changes. For example,
    if you rename a column, it will delete the old one and create another. As a result,
    the data for this column will be lost! This is why you should always carefully
    review the migration scripts and make the required changes for edge cases like
    this.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，尽管自动生成非常有帮助，但它并不总是准确的，有时它无法检测到模糊的变化。例如，如果你重命名了一个列，它会删除旧列并创建一个新的列。因此，该列中的数据将丢失！这就是为什么你应该始终仔细审查迁移脚本，并为类似这种极端情况做出必要的修改。
- en: 'Finally, you can apply the migrations to your database using the following
    command:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以使用以下命令将迁移应用到数据库：
- en: '[PRE29]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This will run all the migrations that have not yet been applied to your database
    until the latest. It’s interesting to know that, in the process, Alembic creates
    a table in your database so that it can remember all the migrations it has applied:
    this is how it detects which scripts to run.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这将运行所有尚未应用到数据库中的迁移，直到最新的版本。值得注意的是，在这个过程中，Alembic 会在数据库中创建一个表，以便它可以记住所有已应用的迁移：这就是它如何检测需要运行的脚本。
- en: Generally speaking, you should be *extremely careful* when you run such commands
    on your database, especially on a production one. Very bad things can happen if
    you make a mistake, and you can lose precious data. You should always test your
    migrations in a test environment and have fresh and working backups before running
    them on your production database.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，当你在数据库上运行此类命令时，应该*极其小心*，特别是在生产环境中。如果犯了错误，可能会发生非常糟糕的事情，甚至丢失宝贵的数据。在在生产数据库上运行迁移之前，你应该始终在测试环境中进行测试，并确保有最新且有效的备份。
- en: This was a very quick introduction to Alembic and its powerful migration system.
    We strongly encourage you to go through its documentation to understand all of
    its mechanisms, especially regarding migration script operations. Please refer
    to [https://alembic.sqlalchemy.org/en/latest/index.html](https://alembic.sqlalchemy.org/en/latest/index.html).
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是对 Alembic 及其强大迁移系统的简短介绍。我们强烈建议你阅读它的文档，以了解所有机制，特别是关于迁移脚本的操作。请参考 [https://alembic.sqlalchemy.org/en/latest/index.html](https://alembic.sqlalchemy.org/en/latest/index.html)。
- en: That’s it for the SQLAlchemy part of this chapter! It’s a complex but powerful
    library for working with SQL databases. We’ll now leave the world of relational
    databases to explore how we can work with a document-oriented database, MongoDB.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是本章 SQLAlchemy 部分的内容！它是一个复杂但强大的库，用于处理 SQL 数据库。接下来，我们将离开关系型数据库的世界，探索如何与文档导向型数据库
    MongoDB 进行交互。
- en: Communicating with a MongoDB database using Motor
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Motor 与 MongoDB 数据库进行通信
- en: 'As we mentioned at the beginning of this chapter, working with a document-oriented
    database, such as MongoDB, is quite different from a relational database. First
    and foremost, you don’t need to configure a schema upfront: it follows the structure
    of the data that you insert into it. In the case of FastAPI, it makes our life
    slightly easier since we only have to work with Pydantic models. However, there
    are some subtleties around the document identifiers that we need to take into
    account. We’ll review this next.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章开头提到的，使用文档导向型数据库（例如 MongoDB）与使用关系型数据库有很大的不同。首先，你不需要提前配置模式：它遵循你插入到其中的数据结构。在
    FastAPI 中，这使得我们的工作稍微轻松一些，因为我们只需处理 Pydantic 模型。然而，关于文档标识符，还有一些细节需要我们注意。接下来我们将讨论这一点。
- en: 'To begin, we’ll install Motor, which is a library that is used to communicate
    asynchronously with MongoDB and is officially supported by the MongoDB organization.
    Run the following command:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将安装 Motor，这是一个用于与 MongoDB 异步通信的库，并且是 MongoDB 官方支持的。运行以下命令：
- en: '[PRE30]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Once you’ve done this, we can start working!
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这部分工作后，我们可以开始实际操作了！
- en: Creating models that are compatible with MongoDB ID
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建与 MongoDB ID 兼容的模型
- en: 'As we mentioned in the introduction to this section, there are some difficulties
    with the identifiers that MongoDB uses to store documents. Indeed, by default,
    MongoDB assigns every document an `_id` property that acts as a unique identifier
    in a collection. This causes two issues:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本节介绍中提到的，MongoDB 用于存储文档的标识符存在一些困难。事实上，默认情况下，MongoDB 会为每个文档分配一个 `_id` 属性，作为集合中的唯一标识符。这导致了两个问题：
- en: In a Pydantic model, if a property starts with an underscore, it’s considered
    to be private and thus, is not used as a data field for our model.
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Pydantic 模型中，如果一个属性以下划线开头，则被认为是私有的，因此不会作为数据字段使用。
- en: '`_id` is encoded as a binary object, called `ObjectId`, instead of a simple
    integer or string. It’s usually represented in the form of a string such as `608d1ee317c3f035100873dc`.
    This type of object is not supported out of the box by Pydantic or FastAPI.'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_id` 被编码为一个二进制对象，称为 `ObjectId`，而不是简单的整数或字符串。它通常以类似 `608d1ee317c3f035100873dc`
    的字符串形式表示。Pydantic 或 FastAPI 默认不支持这种类型的对象。'
- en: 'This is why we’ll need some boilerplate code to ensure those identifiers work
    with Pydantic and FastAPI. To begin, in the following example, we have created
    a `MongoBaseModel` base class that takes care of defining the `id` field:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么我们需要一些样板代码来确保这些标识符能够与 Pydantic 和 FastAPI 一起工作。首先，在下面的示例中，我们创建了一个 `MongoBaseModel`
    基类，用来处理定义 `id` 字段：
- en: models.py
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: models.py
- en: '[PRE31]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/mongodb/models.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/mongodb/models.py)'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/mongodb/models.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/mongodb/models.py)'
- en: First, we need to define an `id` field, which is of the `PyObjectId` type. This
    is a custom type that was defined in the preceding code. We won’t go into the
    details of its implementation but just know that it’s a class that makes `ObjectId`
    a compatible type for Pydantic. We define this same class as a default factory
    for this field. Interestingly, this kind of identifier allows us to generate them
    on the client side, contrary to traditional auto-incremented integers of relational
    databases, which could be useful in some cases.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要定义一个 `id` 字段，类型为 `PyObjectId`。这是一个在前面代码中定义的自定义类型。我们不会深入讨论它的实现细节，但只需知道它是一个类，使得
    `ObjectId` 成为 Pydantic 兼容的类型。我们将此类定义为该字段的默认工厂。有趣的是，这种标识符允许我们在客户端生成它们，这与传统的关系型数据库中自动递增的整数不同，在某些情况下可能非常有用。
- en: The most interesting argument is `alias`. It’s a Pydantic option that allows
    us to *change the name of the field during serialization*. In this example, when
    we call the `dict` method on an instance of `MongoBaseModel`, the identifier will
    be set on the `_id` key, which is the name expected by MongoDB. That solves the
    first issue.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 最有趣的参数是 `alias`。这是 Pydantic 的一个选项，允许我们*在序列化过程中更改字段的名称*。在这个例子中，当我们在 `MongoBaseModel`
    的实例上调用 `dict` 方法时，标识符将被设置为 `_id` 键，这也是 MongoDB 所期望的名称。这解决了第一个问题。
- en: Then, we add the `Config` subclass and set the `json_encoders` option. By default,
    Pydantic is completely unaware of our `PyObjectId` type, so it won’t be able to
    correctly serialize it to JSON. This option allows us to *map custom types with
    a function that will be called to serialize them*. Here, we simply transform it
    into a string (this works because `ObjectId` implements the `__str__` magic method).
    That solves the second issue for Pydantic.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，我们添加了 `Config` 子类并设置了 `json_encoders` 选项。默认情况下，Pydantic 完全不了解我们的 `PyObjectId`
    类型，因此无法正确地将其序列化为 JSON。这个选项允许我们*使用一个函数映射自定义类型，以便在序列化时调用它们*。在这里，我们只是将其转换为字符串（因为
    `ObjectId` 实现了 `__str__` 魔法方法）。这解决了 Pydantic 的第二个问题。
- en: Our base model for Pydantic is complete! We can now use it as a `base` class
    instead of `BaseModel` for our actual data models. Notice, however, that the `PostPartialUpdate`
    doesn’t inherit from it. Indeed, we don’t want the `id` field in this model; otherwise,
    a `PATCH` request might be able to replace the ID of the document, which could
    lead to weird issues.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 Pydantic 基础模型已经完成！现在，我们可以将其作为 `base` 类，而不是 `BaseModel`，来创建我们实际的数据模型。然而请注意，`PostPartialUpdate`
    并没有继承它。实际上，我们不希望这个模型中有 `id` 字段；否则，`PATCH` 请求可能会替换文档的 ID，进而导致奇怪的问题。
- en: Connecting to a database
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接到数据库
- en: 'Now that our models are ready, we can set up the connection with a MongoDB
    server. This is quite easy and only involves a class instantiation, as shown in
    the `database.py` module:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的模型已经准备好，我们可以设置与 MongoDB 服务器的连接。这非常简单，仅涉及类的实例化，代码示例如下所示，在 `database.py`
    模块中：
- en: database.py
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: database.py
- en: '[PRE32]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/mongodb/database.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/mongodb/database.py)'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/mongodb/database.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/mongodb/database.py)'
- en: Here, you can see that `AsyncIOMotorClient` simply expects a connection string
    to your database. Generally, it consists of the scheme, followed by authentication
    information, and the hostname of the database server. You can find an overview
    of this format in the official MongoDB documentation at [https://docs.mongodb.com/manual/reference/connection-string/](https://docs.mongodb.com/manual/reference/connection-string/).
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到 `AsyncIOMotorClient` 仅仅需要一个连接字符串来连接到你的数据库。通常，它由协议、后面的身份验证信息和数据库服务器的主机名组成。你可以在官方的MongoDB文档中查看这个格式的概述：[https://docs.mongodb.com/manual/reference/connection-string/](https://docs.mongodb.com/manual/reference/connection-string/)。
- en: 'However, be careful. Contrary to the libraries we’ve discussed so far, the
    client that’s instantiated here is not bound to any database – that is, it’s only
    a connection to a whole server. That’s why we need the second line: by accessing
    the `chapter06_mongo` key, we get a database instance. It’s worth noting that
    MongoDB doesn’t require you to create the database upfront: it’ll create it automatically
    if it doesn’t exist.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，要小心。与我们迄今讨论的库不同，这里实例化的客户端并没有绑定到任何数据库——也就是说，它只是一个与整个服务器的连接。因此，我们需要第二行代码：通过访问
    `chapter06_mongo` 键，我们得到了一个数据库实例。值得注意的是，MongoDB 并不要求你提前创建数据库：如果数据库不存在，它会自动创建。
- en: Then, we create a simple function to return this database instance. We’ll use
    this function as a dependency to retrieve this instance in our path operation
    functions. We explained the benefits of this pattern in the *Communicating with
    a SQL database with SQLAlchemy* *ORM* section.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，我们创建一个简单的函数来返回这个数据库实例。我们将把这个函数作为依赖项，在路径操作函数中获取这个实例。我们在*使用SQLAlchemy与SQL数据库通信*
    *ORM* 部分中解释了这种模式的好处。
- en: That’s it! We can now make queries to our database!
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！我们现在可以对数据库执行查询了！
- en: Inserting documents
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 插入文档
- en: 'We’ll start by demonstrating how to implement an endpoint to create posts.
    Essentially, we just have to insert our transformed Pydantic model into a dictionary:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先演示如何实现一个端点来创建帖子。本质上，我们只需要将转换后的 Pydantic 模型插入字典中：
- en: app.py
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: app.py
- en: '[PRE33]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/mongodb/app.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/mongodb/app.py)'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/mongodb/app.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/mongodb/app.py)'
- en: Classically, this is a `POST` endpoint that accepts a payload in the form of
    a `PostCreate` model. Additionally, we inject the database instance with the dependency
    we wrote earlier.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，这是一个接受 `PostCreate` 模型格式负载的 `POST` 端点。此外，我们通过之前编写的依赖项注入数据库实例。
- en: In the path operation itself, you can see that we start by instantiating a `Post`
    from the `PostCreate` data. This is usually a good practice if you have fields
    that only appear in `Post` that need to be initialized.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在路径操作本身中，你可以看到我们从 `PostCreate` 数据实例化了一个 `Post`。如果你有字段只在 `Post` 中出现并且需要初始化，这通常是一个好做法。
- en: 'Then, we have the query. To retrieve a collection in our MongoDB database,
    we simply have to get it by name, like a dictionary. Once again, MongoDB will
    take care of creating it if it doesn’t exist. As you can see, document-oriented
    databases are much more lightweight regarding schema than relational databases!
    In this collection, we can call the `insert_one` method to insert a single document.
    It expects a dictionary to map fields to their values. Therefore, the `dict` method
    of Pydantic objects is once again our friend. However, here, we can see something
    new: we call it with the `by_alias` argument set to `True`. By default, Pydantic
    will serialize the object with the real field name, not the alias name. However,
    we do need the `_id` identifier in our MongoDB database. Using this option, Pydantic
    will use the alias as a key in the dictionary.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有了查询。为了从我们的 MongoDB 数据库中检索一个集合，我们只需要通过名称像访问字典一样获取它。再次强调，如果该集合不存在，MongoDB
    会自动创建它。如你所见，面向文档的数据库在架构方面比关系型数据库更加轻量！在这个集合中，我们可以调用 `insert_one` 方法插入单个文档。它期望一个字典来将字段映射到它们的值。因此，Pydantic
    对象的 `dict` 方法再次成为我们的好朋友。然而，在这里，我们看到了一些新东西：我们用 `by_alias` 参数设置为 `True` 来调用它。默认情况下，Pydantic
    会使用真实的字段名序列化对象，而不是别名。但是，我们确实需要 MongoDB 数据库中的 `_id` 标识符。使用这个选项，Pydantic 将使用别名作为字典中的键。
- en: To ensure we have a true and fresh representation of our document in the dictionary,
    we can retrieve one from the database thanks to our `get_post_or_404` function.
    We’ll examine how this works in the next section.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们在字典中有一个真实且最新的文档表示，我们可以通过我们的 `get_post_or_404` 函数从数据库中检索一个。我们将在下一部分中查看这一点是如何工作的。
- en: Dependencies are like functions
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖关系就像函数
- en: 'In this section, we used `get_post_or_404` as a regular function to retrieve
    our newly created blog post. This is perfectly okay: dependencies don’t have hidden
    or magic logic inside them, so you can reuse them at will. The only thing to remember
    is that you have to provide every argument manually since you are outside of the
    dependency injection context.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分中，我们使用 `get_post_or_404` 作为常规函数来检索我们新创建的博客帖子。这完全没问题：依赖项内部没有隐藏或魔法逻辑，因此你可以随意重用它们。唯一需要记住的是，由于你不在依赖注入的上下文中，因此必须手动提供每个参数。
- en: Getting documents
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取文档
- en: 'Of course, retrieving the data from the database is an important part of the
    job of a REST API. In this section, we’ll demonstrate how to implement two classic
    endpoints – that is, to list posts and get a single post. Let’s start with the
    first one and take a look at its implementation:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，从数据库中检索数据是 REST API 工作的重要部分。在这一部分中，我们将演示如何实现两个经典的端点——即列出帖子和获取单个帖子。让我们从第一个开始，看看它的实现：
- en: app.py
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: app.py
- en: '[PRE34]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/mongodb/app.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/mongodb/app.py)'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/mongodb/app.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/mongodb/app.py)'
- en: The most interesting part is the second line, which is where we define the query.
    After retrieving the `posts` collection, we call the `find` method. The first
    argument should be the filtering query, following the MongoDB syntax. Since we
    want every document, we leave it empty. Then, we have keyword arguments that allow
    us to apply our pagination parameters.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 最有趣的部分是第二行，我们在这里定义了查询。在获取`posts`集合后，我们调用了`find`方法。第一个参数应该是过滤查询，遵循MongoDB语法。由于我们想要获取所有文档，所以将其留空。然后，我们有一些关键字参数，允许我们应用分页参数。
- en: MongoDB returns a result in the form of a list of dictionaries, which maps fields
    to their values. This is why we added a list comprehension construct to transform
    them back into `Post` instances – so that FastAPI can serialize them properly.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB返回的是一个字典列表形式的结果，将字段映射到它们的值。这就是为什么我们添加了一个列表推导式结构来将它们转回`Post`实例——以便FastAPI能够正确序列化它们。
- en: 'You might have noticed something quite surprising here: contrary to what we
    do usually, we didn’t wait for the query directly. Instead, we added the `async`
    keyword to our list comprehension. Indeed, in this case, Motor returns `async`
    keyword, which we have to add when iterating over it.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能注意到这里有些令人惊讶的地方：与我们通常做法不同，我们并没有直接等待查询。相反，我们在列表推导式中加入了`async`关键字。确实，在这种情况下，Motor返回了`async`关键字，我们在遍历时必须加上它。
- en: 'Now, let’s take a look at the endpoint that retrieves a single post. The following
    example shows its implementation:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一下获取单个帖子的端点。下面的示例展示了它的实现：
- en: app.py
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: app.py
- en: '[PRE35]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/mongodb/app.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/mongodb/app.py)'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/mongodb/app.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/mongodb/app.py)'
- en: 'As you can see, it’s a simple `GET` endpoint that accepts the `id` post as
    a path parameter. Most of the logic’s implementation is in the reusable `get_post_or_404`
    dependency. You can view what it looks like here:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这是一个简单的`GET`端点，它接受`id`作为路径参数。大部分逻辑的实现都在可复用的`get_post_or_404`依赖中。你可以在这里查看它的实现：
- en: app.py
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: app.py
- en: '[PRE36]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/mongodb/app.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/mongodb/app.py)'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/mongodb/app.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/mongodb/app.py)'
- en: 'The logic is quite similar to what we saw for the list endpoint. This time,
    however, we call the `find_one` method with a query to match the post identifier:
    the key is the name of the document attribute we want to filter on, and the value
    is the one we are looking for.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑与我们在列表端点中看到的非常相似。然而，这次我们调用了`find_one`方法，并使用查询来匹配帖子标识符：键是我们要过滤的文档属性的名称，值是我们正在寻找的值。
- en: This method returns the document in the form of a dictionary or `None` if it
    doesn’t exist. In this case, we raise a proper `404` error.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法返回一个字典形式的文档，若不存在则返回`None`。在这种情况下，我们抛出一个适当的`404`错误。
- en: Finally, we transform it back into a `Post` model before returning it.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在返回之前将其转换回`Post`模型。
- en: You might have noticed that we got `id` through a dependency, `get_object_id`.
    Indeed, FastAPI will return a string from the path parameter. If we try to make
    a query with `id` in the form of a string, MongoDB will not match with the actual
    binary IDs. That’s why we use another dependency that transforms the identifier,
    represented as a string (such as `608d1ee317c3f035100873dc`), into a proper `ObjectId`.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，我们是通过依赖`get_object_id`获取`id`的。实际上，FastAPI会从路径参数中返回一个字符串。如果我们尝试用字符串形式的`id`进行查询，MongoDB将无法与实际的二进制ID匹配。这就是为什么我们使用另一个依赖来将作为字符串表示的标识符（例如`608d1ee317c3f035100873dc`）转换为合适的`ObjectId`。
- en: 'As a side note, here’s a very nice example of *nested dependencies*: endpoints
    use the `get_post_or_404` dependency, which itself gets a value from `get_object_id`.
    You can view the implementation of this dependency in the following example:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便提一下，这里有一个非常好的*嵌套依赖*的例子：端点使用`get_post_or_404`依赖，它本身从`get_object_id`获取一个值。你可以在下面的示例中查看这个依赖的实现：
- en: app.py
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: app.py
- en: '[PRE37]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/mongodb/app.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/mongodb/app.py)'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/mongodb/app.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/mongodb/app.py)'
- en: Here, we simply retrieve the `id` string from the path parameters and try to
    instantiate it back into an `ObjectId`. If it’s not a valid value, we catch the
    corresponding errors and consider it a `404` error.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只是从路径参数中提取`id`字符串，并尝试将其重新实例化为`ObjectId`。如果它不是一个有效值，我们会捕获相应的错误，并将其视为`404`错误。
- en: With this, we have solved every challenge posed by the MongoDB identifiers format.
    Now, let’s discuss how to update and delete documents.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就解决了MongoDB标识符格式带来的所有挑战。现在，让我们讨论如何更新和删除文档。
- en: Updating and deleting documents
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新和删除文档
- en: We’ll now review the endpoints for updating and deleting documents. The logic
    is still the same and only involves building the proper query from the request
    payload.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将回顾更新和删除文档的端点。逻辑还是一样，只需要从请求负载构建适当的查询。
- en: 'Let’s start with the `PATCH` endpoint, which you can view in the following
    example:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`PATCH`端点开始，您可以在以下示例中查看：
- en: app.py
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: app.py
- en: '[PRE38]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/mongodb/app.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/mongodb/app.py)'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/mongodb/app.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/mongodb/app.py)'
- en: 'Here, we used the `update_one` method to update one document. The first argument
    is the filtering query, while the second one is the actual operation to apply
    to the document. Once again, it follows the MongoDB syntax: the `$set` operation
    allows us to only modify the fields we want to change by passing the `update`
    dictionary.'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`update_one`方法来更新一条文档。第一个参数是过滤查询，第二个参数是要应用于文档的实际操作。同样，它遵循MongoDB的语法：`$set`操作允许我们通过传递`update`字典，仅修改我们希望更改的字段。
- en: 'The `DELETE` endpoint is even simpler; it’s just a single query, as you can
    see in the following example:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '`DELETE`端点更简单；它只是一个查询，您可以在以下示例中看到：'
- en: app.py
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: app.py
- en: '[PRE39]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/mongodb/app.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/mongodb/app.py)'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/mongodb/app.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/mongodb/app.py)'
- en: The `delete_one` method expects the filtering query as the first argument.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '`delete_one`方法期望过滤查询作为第一个参数。'
- en: 'That’s it! Of course, here, we’ve only demonstrated the simplest type of query,
    but MongoDB has a very powerful query language that allows you to do more complex
    things. If you’re not familiar with this, we recommend that you read the nice
    introduction from the official documentation: [https://docs.mongodb.com/manual/crud](https://docs.mongodb.com/manual/crud).'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！当然，这里我们只是演示了最简单的查询类型，但MongoDB有一个非常强大的查询语言，允许你执行更复杂的操作。如果你不熟悉这个，我们建议你阅读官方文档中的精彩介绍：[https://docs.mongodb.com/manual/crud](https://docs.mongodb.com/manual/crud)。
- en: Nesting documents
  id: totrans-319
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嵌套文档
- en: At the beginning of this chapter, we mentioned that document-based databases,
    contrary to relational databases, aim to store all the data related to an entity
    in a single document. In our current example, if we wish to store the comments
    along with the post, we simply have to add a list where each item is the comment
    data.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章开始时，我们提到过，与关系型数据库不同，基于文档的数据库旨在将与实体相关的所有数据存储在一个文档中。在我们当前的示例中，如果我们希望将评论与帖子一起存储，我们只需要添加一个列表，每个项目就是评论数据。
- en: In this section, we’ll implement this behavior. You’ll see that the functioning
    of MongoDB makes this straightforward.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将实现这一行为。你会看到MongoDB的工作方式使得这变得非常简单。
- en: 'We’ll start by adding a new `comments` attribute to our `Post` model. You can
    view this in the following example:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从向`Post`模型添加一个新的`comments`属性开始。您可以在以下示例中查看：
- en: models.py
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: models.py
- en: '[PRE40]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/mongodb_relationship/models.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/mongodb_relationship/models.py)'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/mongodb_relationship/models.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/mongodb_relationship/models.py)'
- en: This field is simply a list of `Comment`. We won’t go into the details of the
    comment models since they are quite straightforward. Notice that we use the `list`
    function as the default factory for this attribute. This instantiates an empty
    list by default when we create a `Post` without setting any comments.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 这个字段只是一个`Comment`的列表。我们不会深入讨论评论模型，因为它们非常简单。请注意，我们使用`list`函数作为此属性的默认工厂。当我们创建一个没有设置评论的`Post`时，默认会实例化一个空列表。
- en: 'Now that we have our models, we can implement an endpoint to create a new comment.
    You can view it in the following example:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了模型，我们可以实现一个端点来创建新的评论。你可以在下面的示例中查看：
- en: app.py
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: app.py
- en: '[PRE41]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/mongodb_relationship/app.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/mongodb_relationship/app.py)'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/mongodb_relationship/app.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter06/mongodb_relationship/app.py)'
- en: As we did before, we nest the endpoints under the path of a single post. Thus,
    we can reuse `get_post_or_404` to retrieve the post we want to add a comment to
    if it exists.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所做的，我们将端点嵌套在单个帖子的路径下。因此，如果该帖子存在，我们可以重新使用`get_post_or_404`来检索我们要添加评论的帖子。
- en: 'Then, we trigger an `update_one` query: this time, using the `$push` operation.
    This is a useful operator for adding elements to a list attribute. Operators that
    remove elements from a list are also available. You can find a description of
    every `update` operator in the official documentation at [https://docs.mongodb.com/manual/reference/operator/update/](https://docs.mongodb.com/manual/reference/operator/update/).'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们触发一个`update_one`查询：这次，使用`$push`操作符。这个操作符对于向列表属性添加元素非常有用。也有可用的操作符用于从列表中移除元素。你可以在官方文档中找到每个`update`操作符的描述：[https://docs.mongodb.com/manual/reference/operator/update/](https://docs.mongodb.com/manual/reference/operator/update/)。
- en: And that’s it! We don’t even have to modify the rest of our code. Because the
    comments are included in the whole document, we’ll always retrieve them when querying
    for a post in the database. Besides, our `Post` model now expects a `comments`
    attribute, so Pydantic will take care of serializing them automatically.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！我们甚至不需要修改其余的代码。因为评论已经包含在整个文档中，当我们在数据库中查询帖子时，我们总是能够检索到它们。此外，我们的`Post`模型现在期待一个`comments`属性，所以Pydantic会自动处理它们的序列化。
- en: That concludes this part regarding MongoDB. You’ve seen that it can be integrated
    into a FastAPI application very quickly, especially because of its very flexible
    schema.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分关于MongoDB的内容到此结束。你已经看到，它可以非常快速地集成到FastAPI应用中，特别是由于其非常灵活的架构。
- en: Summary
  id: totrans-335
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Congratulations! You’ve reached another big milestone in mastering how to build
    a REST API with FastAPI. As you know, databases are an essential part of every
    system; they allow you to save data in a structured way and retrieve it precisely
    and reliably thanks to powerful query languages. You are now able to leverage
    their power in FastAPI, whether they are relational databases or document-oriented
    databases.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你已经达到了掌握如何使用FastAPI构建REST API的另一个重要里程碑。正如你所知道的，数据库是每个系统中不可或缺的一部分；它们允许你以结构化的方式保存数据，并通过强大的查询语言精确而可靠地检索数据。现在，无论是关系型数据库还是文档导向型数据库，你都能在FastAPI中充分利用它们的强大功能。
- en: 'Serious things can now happen; users can send and retrieve data to and from
    your system. However, this poses a new challenge to tackle: this data needs to
    be protected so that it can remain private and secure. This is exactly what we’ll
    discuss in the next chapter: how to authenticate users and set up FastAPI for
    maximum security.'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以进行更严肃的操作了；用户可以向你的系统发送和检索数据。然而，这也带来了一个新的挑战：这些数据需要受到保护，以确保它们能够保持私密和安全。这正是我们在下一章将讨论的内容：如何认证用户并为FastAPI配置最大安全性。
