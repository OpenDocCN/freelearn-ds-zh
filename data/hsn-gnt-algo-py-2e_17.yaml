- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: Accelerating Genetic Algorithms – the Power of Concurrency
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加速遗传算法——并发的力量
- en: This chapter delves into the use of concurrency, with a special focus on multiprocessing,
    as a means to boost the performance of genetic algorithms. We will explore both
    built-in Python functionalities and an external library to achieve this enhancement.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章深入探讨了如何通过并发，特别是多进程，来提升遗传算法的性能。我们将探索 Python 内置的功能以及外部库来实现这一改进。
- en: The chapter starts by highlighting the potential benefits of applying **concurrency**
    to genetic algorithms. We then proceed to put this theory into practice by experimenting
    with various **multiprocessing** approaches to a CPU-intensive version of the
    well-known One-Max problem. This enables us to gauge the extent of performance
    improvements achievable through these techniques.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章首先强调了将 **并发** 应用于遗传算法的潜在好处。接着，我们通过尝试各种 **多进程** 方法来解决计算密集型的 One-Max 问题，将这一理论付诸实践。这使我们能够衡量通过这些技术实现的性能提升程度。
- en: 'By the end of this chapter, you will be able to do the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章结束时，你将能够做到以下几点：
- en: Understand why genetic algorithms can be computationally intensive and time-consuming
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解为什么遗传算法可能计算密集且耗时
- en: Recognize why genetic algorithms are well-suited for concurrent execution
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认识到为什么遗传算法非常适合并发执行
- en: Implement a CPU-intensive version of the One-Max problem, which we have previously
    explored
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现一个计算密集型的 One-Max 问题版本，我们之前已经探索过
- en: Learn how to use Python’s built-in multiprocessing module to accelerate the
    genetic algorithm process
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何使用 Python 内置的多进程模块加速遗传算法的过程
- en: Become familiar with the SCOOP library and learn how to integrate it with the
    DEAP framework to further enhance the efficiency of genetic algorithms
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 熟悉 SCOOP 库，学习如何将其与 DEAP 框架结合使用，进一步提高遗传算法的效率
- en: Experiment with both methods and gain insights into the application of multiprocessing
    to the problem at hand
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试两种方法，深入了解如何将多进程应用于当前问题
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In this chapter, we will use Python 3 with the following supporting libraries:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用 Python 3 并配合以下支持库：
- en: '**deap**'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**deap**'
- en: '**numpy**'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**numpy**'
- en: '**scoop** – introduced in this chapter'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**scoop** —— 本章介绍'
- en: Important note
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: If you use the **requirements.txt** file we provide (see [*Chapter 3*](B20851_03.xhtml#_idTextAnchor091)),
    these libraries are already included in your environment.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用我们提供的 **requirements.txt** 文件（见 [*第3章*](B20851_03.xhtml#_idTextAnchor091)），这些库已经包含在你的环境中了。
- en: The programs that will be used in this chapter can be found in this book’s GitHub
    repository at [https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/tree/main/chapter_13](https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/tree/main/chapter_13).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中将使用的程序可以在本书的 GitHub 仓库中找到，链接如下：[https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/tree/main/chapter_13](https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/tree/main/chapter_13)。
- en: 'Check out the following video to see the Code in Action:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频，了解代码的实际运行：
- en: '[https://packt.link/OEBOd](https://packt.link/OEBOd)'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/OEBOd](https://packt.link/OEBOd)'
- en: Long runtimes in real-world genetic algorithms
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实际应用中遗传算法的长时间运行
- en: 'The example programs we’ve explored so far, while addressing practical problems,
    were intentionally designed to converge quickly to a reasonable solution. However,
    in the context of real-world applications, the use of genetic algorithms often
    proves to be highly time-consuming due to the way they operate – exploring the
    solution space by considering a diverse set of potential solutions. The main factors
    affecting the running time of a typical genetic algorithm are as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们探讨的示例程序虽然解决了实际问题，但它们故意设计得可以迅速收敛到一个合理的解。然而，在实际应用中，由于遗传算法的工作方式——通过考虑多样化的潜在解决方案来探索解空间——它通常会非常耗时。影响典型遗传算法运行时间的主要因素如下：
- en: '**The number of generations**: Genetic algorithms operate through a series
    of generations, each involving the evaluation, selection, and manipulation of
    the population.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**世代数**：遗传算法通过一系列世代来运行，每一代都涉及对种群的评估、选择和操作。'
- en: '**The population size**: Genetic algorithms maintain a population of potential
    solutions; more complex problems typically require larger populations. This increases
    the number of individuals that need evaluation, selection, and manipulation in
    each generation.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**种群大小**：遗传算法保持一个潜在解的种群；更复杂的问题通常需要更大的种群。这增加了每一代中需要评估、选择和操作的个体数量。'
- en: '**Fitness evaluation**: The fitness of each individual in the population must
    be evaluated to determine how well it solves the problem. Depending on the complexity
    of the fitness function or the nature of the optimization problem, the evaluation
    process can be both computationally expensive and time-consuming.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**适应度评估**：必须评估种群中每个个体的适应度，以确定其解决问题的效果。根据适应度函数的复杂性或优化问题的性质，评估过程可能既计算密集又耗时。'
- en: '**Genetic operations**: Selection is used to choose pairs of individuals that
    will serve as parents for each new generation. Crossover and mutation are applied
    to each of these pairs and, depending on the algorithm’s design, can be computationally
    intensive, especially when dealing with complex data structures. In practice,
    however, the duration of the fitness function often dominates the time consumed
    per individual.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**遗传操作**：选择用于选择作为每代父母的个体对。交叉和变异应用于这些个体对，并且根据算法的设计，可能会计算密集，特别是在处理复杂数据结构时。然而，在实践中，适应度函数的持续时间通常是每个个体所消耗时间的主导因素。'
- en: One obvious way to mitigate the long running times of genetic algorithms is
    the use of parallelization, as we will explore further in the following section.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 减少遗传算法长时间运行的一个显而易见的方式是使用并行化，正如我们将在以下小节中进一步探讨的。
- en: Parallelizing genetic algorithms
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并行化遗传算法
- en: Within a single generation, genetic algorithms can be considered **embarrassingly
    parallelizable** – they can be effortlessly divided into multiple independent
    tasks, with minimal or no dependency or interaction between them. This is because
    the fitness evaluation and manipulation of individuals in the population are typically
    independent tasks. Each individual’s fitness is evaluated based on its own characteristics,
    and genetic operators (crossover and mutation) are applied independently to pairs
    of individuals. This independence allows for the straightforward parallel execution
    of these tasks.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在单一代际内，遗传算法可以被认为是**显然可并行化**的——它们可以轻松地分解为多个独立任务，这些任务之间几乎没有或完全没有依赖关系或交互。这是因为种群中个体的适应度评估和操作通常是独立的任务。每个个体的适应度是根据其自身特征评估的，而遗传操作符（交叉和变异）是独立地应用于每一对个体的。这种独立性使得这些任务能够轻松并行执行。
- en: Two parallelization methods – **multithreading** and **multiprocessing** – come
    to mind, as we will explore in the following subsections.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种并行化方法——**多线程**和**多进程**——是我们将在以下小节中探讨的内容。
- en: Multithreading
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多线程
- en: Multithreading is a concurrent execution model that allows multiple threads
    to exist within the same process, sharing the same resources, such as memory space,
    but running independently. Each thread represents a separate flow of control,
    allowing a program to execute multiple tasks concurrently.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 多线程是一种并发执行模型，允许多个线程在同一进程内存在，共享相同的资源，如内存空间，但独立运行。每个线程代表一个独立的控制流，使程序能够并发执行多个任务。
- en: 'In a multithreaded environment, threads can be thought of as lightweight processes
    that share the same address space. Multithreading is particularly beneficial for
    tasks that can be divided into smaller, independent units of work, enabling efficient
    use of available resources and enhancing responsiveness. This is illustrated by
    the following diagram:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在多线程环境中，线程可以被看作是共享相同地址空间的轻量级进程。多线程特别适用于可以分解为较小、独立工作单元的任务，使得可用资源的使用更加高效，并增强响应性。以下图示了这一点：
- en: '![Figure 13.1: Multiple threads running concurrently within a single process](img/B20851_13_1.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图13.1：多个线程在单一进程内并发运行](img/B20851_13_1.jpg)'
- en: 'Figure 13.1: Multiple threads running concurrently within a single process'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.1：多个线程在单一进程内并发运行
- en: However, multithreading in Python faces some limitations that impact its effectiveness
    for our use case. A major factor is the **Global Interpreter Lock** (**GIL**)
    in CPython, the standard implementation of Python. The GIL is a **mutex** (mutually
    exclusive lock) that protects access to Python objects, preventing multiple native
    threads from executing Python bytecodes at the same time. As a result, the benefits
    of multithreading are primarily seen in I/O-bound tasks, as we will explore in
    the following chapter. For computation-intensive tasks that don’t frequently release
    the GIL, common in many numerical computations, multithreading may not provide
    the expected performance improvements.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Python中的多线程面临一些限制，这些限制影响了它在我们用例中的效果。一个主要因素是**全局解释器锁**（**GIL**），这是CPython（Python的标准实现）中的一个关键部分。GIL是一个**互斥锁**（mutex），用于保护对Python对象的访问，防止多个本地线程同时执行Python字节码。因此，多线程的好处主要体现在I/O密集型任务中，正如我们将在下一章中探讨的那样。对于那些计算密集型任务，这些任务不经常释放GIL，且在许多数值计算中比较常见，多线程可能无法提供预期的性能提升。
- en: Note
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Discussions within the Python community and ongoing research suggest that the
    limitations imposed by the GIL may be lifted in a future version of Python, potentially
    enhancing multithreading efficiency.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Python社区的讨论和持续的研究表明，GIL带来的限制可能会在未来的Python版本中解除，从而提高多线程的效率。
- en: Fortunately, the approach described next is a highly viable option.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，接下来描述的方法是一个非常可行的选择。
- en: Multiprocessing
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多进程
- en: 'Multiprocessing is a concurrent computing paradigm that involves the simultaneous
    execution of multiple processes within a computer system. In contrast to multithreading,
    multiprocessing allows for the creation of independent processes, each with its
    dedicated memory space. These processes can run concurrently on different CPU
    cores or processors, making it a powerful technique to parallelize tasks and capitalize
    on modern multi-core architectures, as illustrated in the following diagram:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 多进程是一种并发计算范式，涉及计算机系统内多个进程的同时执行。与多线程不同，多进程允许创建独立的进程，每个进程都有独立的内存空间。这些进程可以在不同的CPU核心或处理器上并行运行，使其成为一种强大的并行化任务的技术，能够充分利用现代多核架构，如下图所示：
- en: '![Figure 13.2: Multiple processes running concurrently on separate cores](img/B20851_13_2.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.2：多个进程在独立的核心上同时运行](img/B20851_13_2.jpg)'
- en: 'Figure 13.2: Multiple processes running concurrently on separate cores'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.2：多个进程在独立的核心上同时运行
- en: Operating independently, each process avoids limitations associated with shared
    memory models, such as the GIL in Python. Multiprocessing proves particularly
    effective for CPU-bound tasks, commonly encountered in genetic algorithms, where
    the computational workload can be divided into parallelizable units.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 每个进程独立运行，避免了与共享内存模型相关的限制，例如Python中的全局解释器锁（GIL）。多进程对于CPU密集型任务尤其有效，这类任务在遗传算法中常见，其中计算工作负载可以被划分为可并行化的单元。
- en: As multiprocessing seems to be a viable way to enhance the performance of genetic
    algorithms, we will explore its implementation throughout the remainder of this
    chapter, using a new version of the OneMax problem as our benchmark.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 由于多进程似乎是一种提高遗传算法性能的可行方法，我们将在本章剩余部分探讨其实现，使用OneMax问题的新版本作为我们的基准。
- en: Back to the OneMax problem
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回到OneMax问题
- en: In [*Chapter 3*](B20851_03.xhtml#_idTextAnchor091), *Using the DEAP Framework*,
    we utilized the OneMax problem as the “Hello World” of genetic algorithms. As
    a quick recap, the objective is to discover the binary string of a specified length
    that maximizes the sum of its digits. For instance, when dealing with a OneMax
    problem of length 5, candidate solutions such as 10010 (sum of digits = 2) and
    01110 (sum of digits = 3) are considered, ultimately leading to the optimal solution
    of 11111 (sum of digits = 5).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第3章*](B20851_03.xhtml#_idTextAnchor091)，《使用DEAP框架》中，我们使用了OneMax问题作为遗传算法的“Hello
    World”。简要回顾一下，目标是发现一个指定长度的二进制字符串，使其数字之和最大。例如，在处理一个长度为5的OneMax问题时，考虑到的候选解包括10010（数字之和=2）和01110（数字之和=3），最终的最优解是11111（数字之和=5）。
- en: While, in [*Chapter 3*](B20851_03.xhtml#_idTextAnchor091), we used a problem
    length of 100, a population size of 200, and 50 generations, here we will tackle
    a significantly scaled-down version, having a length of 10, a population size
    of 20, and only 5 generations. The reasons for this adjustment will become apparent
    shortly.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第3章*](B20851_03.xhtml#_idTextAnchor091)中，我们使用了问题长度为100、种群大小为200、50代的参数，而在这里我们将处理一个大幅缩小的版本，问题长度为10、种群大小为20，且只有5代。这一调整的原因很快就会显现出来。
- en: A baseline benchmark program
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个基准程序
- en: The initial version of this Python program is `01_one_max_start.py`, available
    at [https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_13/01_one_max_start.py](https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_13/01_one_max_start.py).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 该Python程序的初始版本为`01_one_max_start.py`，可在[https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_13/01_one_max_start.py](https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_13/01_one_max_start.py)找到。
- en: 'The main functionality of this program is outlined as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序的主要功能概述如下：
- en: Candidate solutions are represented using a list of integers, with values 0
    and 1.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 候选解通过一个由0和1组成的整数列表来表示。
- en: 'The **oneMaxFitness()** function calculates the fitness by summing the elements
    of the list:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**oneMaxFitness()**函数通过对列表元素求和来计算适应度：'
- en: '[PRE0]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: For genetic operators, we employ *tournament selection* with a tournament size
    of 4, *single-point crossover*, and *flip-bit mutation*.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于遗传操作，我们采用*锦标赛选择*（锦标赛大小为4）、*单点交叉*和*翻转位变异*。
- en: The *elitist* approach is applied, utilizing the **elitism.eaSimpleWithElitism()**
    function.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 采用了*精英主义*方法，利用**elitism.eaSimpleWithElitism()**函数。
- en: 'The program’s runtime duration is measured using **time.time()** function calls,
    surrounding the invocation of the **main()** function:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 程序的运行时间通过调用**time.time()**函数来测量，包围着**main()**函数的调用：
- en: '[PRE1]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Running the program yields the following output:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 运行该程序会产生以下输出：
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The output indicates that the program achieved the optimal solution of 1111111111
    by the 5th generation, completing its run in less than 10 milliseconds (considering
    only the first two decimal digits of the elapsed time).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 输出表明程序在第5代时达到了最优解1111111111，运行时间不到10毫秒（仅考虑经过时间的小数点后两位）。
- en: Another noteworthy detail, which will play a part in subsequent experiments,
    is the number of fitness evaluations carried out at each generation. The relevant
    values can be found in the second column from the left, `nevals`. Despite a population
    size of 20, there are typically fewer than 20 evaluations per generation. This
    is because the algorithm skips the fitness function if it has already been calculated
    for a similar individual. Summing the values in this column, we find that the
    total number of fitness evaluations executed during the program’s run amounts
    to 95.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个值得注意的细节，这将在后续实验中起作用，是每代进行的适应度评估次数。相关值可以在从左数第二列`nevals`中找到。尽管种群大小为20，每代的评估次数通常少于20次。这是因为如果某个个体的适应度已被计算过，算法会跳过该适应度函数。将这一列的数值加起来，我们可以发现，在程序运行过程中执行的总适应度评估次数为95次。
- en: Simulating computational intensity
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟计算密集度
- en: As mentioned earlier, the most computationally intensive task in a genetic algorithm
    is often the fitness evaluation of individuals. To simulate this aspect, we will
    now intentionally extend the execution time of our fitness function.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，遗传算法中最消耗计算资源的任务通常是对个体的适应度评估。为了模拟这一方面，我们将故意延长适应度函数的执行时间。
- en: This modification is implemented in the Python program, `02_one_max_busy.py`,
    available at [https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_13/02_one_max_busy.py](https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_13/02_one_max_busy.py).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 该修改已在Python程序`02_one_max_busy.py`中实现，程序可在[https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_13/02_one_max_busy.py](https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_13/02_one_max_busy.py)找到。
- en: 'This program is based on the previous one, with the following modifications:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序基于之前的版本，进行了如下修改：
- en: 'A **busy_wait()** function is added. This function exercises an empty loop
    for a specified duration (in seconds):'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加了一个**busy_wait()**函数。该函数通过执行一个空循环来消耗指定时长（以秒为单位）：
- en: '[PRE3]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The original fitness function is updated to incorporate a call to the **busy_wait()**
    function before calculating the sum of the digits:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新原始适应度函数，以便在计算数字之和之前调用**busy_wait()**函数：
- en: '[PRE4]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The **DELAY_SECONDS** constantis added, and its value is set to 3:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加了**DELAY_SECONDS**常量，并将其值设置为3：
- en: '[PRE5]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Running the modified program yields the following output:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 运行修改后的程序会产生以下输出：
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As anticipated, the output of the modified program is identical to that of the
    original, with the notable exception of the elapsed time, which has significantly
    increased to approximately 285 seconds.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，修改后的程序输出与原始程序相同，唯一显著的不同是经过的时间显著增加，约为285秒。
- en: This duration makes perfect sense; as highlighted in the previous section, there
    are 95 executions of the fitness function throughout the program’s run (the sum
    of the values in the `nevals` column). With each execution now taking an additional
    3 seconds, the anticipated additional time is calculated as 95 times 3 seconds,
    totaling 285 seconds.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这个持续时间是完全合理的；正如前面部分所强调的那样，在程序的执行过程中有95次适应度函数的调用（`nevals`列中的值之和）。由于每次执行现在需要额外的3秒，因此预期的额外时间为95次乘以3秒，总计285秒。
- en: While examining these results, let’s also establish the theoretical limit, or
    the best-case scenario we can aim for. As indicated in the output, the execution
    of our benchmark genetic algorithm involves six “rounds” of fitness calculations
    – one for the initial generation (“generation zero”) and one for each of the five
    subsequent generations. The best achievable time in the context of perfect concurrency
    within each generation is 3 seconds, equal to the duration of a single fitness
    evaluation. Therefore, the optimal result we could theoretically achieve would
    be 18 seconds, calculated as 6 times 3 seconds per round.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查这些结果时，让我们也确定一下理论上的限制，或者我们可以追求的最佳情况。如输出所示，执行基准遗传算法涉及六个“轮次”的适应度计算——一次用于初始代（“代零”），另外五次用于随后的五代。在每代内完全并发的情况下，最佳的执行时间为3秒，即单次适应度评估的时间。因此，理论上我们可以达到的最佳结果是18秒，即6次乘以每轮3秒。
- en: With this theoretical limit in mind, we can now proceed to explore the application
    of multiprocessing to our benchmark.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 以这个理论上的限制为基础，我们现在可以继续探索将多进程应用到基准测试中的方法。
- en: Multiprocessing using the Pool class
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Pool类进行多进程
- en: In Python, the `multiprocessing.Pool` module provides a convenient mechanism
    to parallelize operations across multiple processes. With the `Pool` class, a
    pool of worker processes is created, allowing tasks to be distributed among them.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，`multiprocessing.Pool`模块提供了一种方便的机制，可以将操作并行化到多个进程中。通过`Pool`类，可以创建一组工作进程，并将任务分配给这些进程。
- en: The `Pool` class abstracts away the details of managing individual processes
    by providing the `map` and `apply` methods. Conversely, the DEAP framework makes
    it very easy to utilize this abstraction. All operations specified in the `toolbox`
    module are internally executed via a default `map` function. Replacing this map
    with the `map` from the `Pool` class means that these operations, including fitness
    evaluations, are now distributed among the worker processes in the pool.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`Pool`类通过提供`map`和`apply`方法来抽象化管理单个进程的细节。相反，DEAP框架使得利用这种抽象变得非常简单。`toolbox`模块中指定的所有操作都通过默认的`map`函数在内部执行。将这个`map`替换为`Pool`类中的`map`意味着这些操作，包括适应度评估，现在将分配到池中的工作进程上。'
- en: Let’s illustrate this by incorporating multiprocessing into our previous program.
    This modification is implemented in the `03_one_max_pool.py` Python program, available
    at [https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_13/03_one_max_pool.py](https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_13/03_one_max_pool.py).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过将多进程应用到之前的程序来进行说明。此修改在`03_one_max_pool.py` Python程序中实现，可以在[https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_13/03_one_max_pool.py](https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_13/03_one_max_pool.py)找到。
- en: 'Only a few modifications are required, as outlined here:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 只需进行少量修改，具体如下：
- en: 'The **multiprocessing** is imported:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入**multiprocessing**模块：
- en: '[PRE7]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The **map** method of a **multiprocessing.Pool** class instance is registered
    as the **map** function to be used by DEAP’s toolbox module:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**multiprocessing.Pool**类实例的**map**方法被注册为DEAP工具箱模块中使用的**map**函数：'
- en: '[PRE8]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The genetic algorithm flow, implemented in the **main()** function, now runs
    under a **with** statement that manages the creation and cleanup of the **multiprocessing.Pool**
    instance:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遗传算法流程，实现在**main()**函数中，现在在**with**语句下运行，该语句管理**multiprocessing.Pool**实例的创建和清理：
- en: '[PRE9]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Running the modified program on a four-core computer yields the following output:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在四核计算机上运行修改后的程序，输出结果如下：
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As anticipated, the output remains identical to that of the original program,
    while the duration is significantly shorter compared to the previous one.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，输出结果与原始程序相同，而运行时间明显比之前短。
- en: Important note
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The running time of this program may vary across different computers and even
    in successive runs on the same machine. As discussed earlier, the optimal result
    for this benchmark is around 18 seconds. If your computer already approaches this
    theoretical limit, you can make the benchmark program more CPU-intensive by doubling
    (or more, if needed) the population size. Remember to adjust all versions of our
    benchmark program, both in this chapter and the next, to reflect the new population
    size.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序的运行时间可能会因不同计算机之间的差异而有所不同，甚至在同一台机器上的连续运行之间也会有所变化。如前所述，此基准测试的最佳结果大约是18秒。如果您的计算机已经接近这个理论极限，您可以通过将种群大小加倍（或根据需要更多）来使基准程序变得更加CPU密集型。记得调整本章和下一章中的所有基准程序版本，以反映新的种群大小。
- en: Given the use of a four-core computer, you might expect the duration to be precisely
    one-quarter of the previous one. However, in this case, we can see that the ratio
    between the durations is approximately 3.6 (≈285/79), falling short of the expected
    4.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 假设使用四核计算机，您可能期望运行时间是之前的四分之一。然而，在这种情况下，我们可以看到持续时间的比率大约是3.6（≈285/79），低于预期的4。
- en: Several factors contribute to us not fully realizing the time-saving potential.
    A significant factor is the presence of overhead associated with the parallelization
    process, introducing an additional computational burden when dividing tasks among
    multiple processes and coordinating their execution.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个因素导致我们没有完全实现节省时间的潜力。其中一个重要因素是与并行化过程相关的开销，在将任务分配给多个进程并协调它们的执行时，会引入额外的计算负担。
- en: Moreover, the granularity of the tasks plays a role. While the fitness function
    consumes most of the processing time, smaller tasks such as the genetic operators
    of crossover and mutation may encounter a scenario where the overhead of parallelization
    outweighs the benefits.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，任务的粒度也起着作用。虽然适应度函数消耗了大部分处理时间，但像交叉和变异等遗传操作可能会遇到并行化开销大于收益的情况。
- en: Additionally, certain parts of the algorithm, such as handling the hall-of-fame
    and calculating statistics, are not parallelized. This limitation restricts the
    extent to which parallelization can be exploited.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，算法中的某些部分，如处理名人堂和计算统计数据，并没有并行化。这一限制限制了并行化可以发挥的程度。
- en: 'To illustrate the last point, let’s examine a snapshot of the Activity Monitor
    application on a Mac while the program is running:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明最后一点，我们来看一下程序运行时，Mac上Activity Monitor应用程序的快照：
- en: '![Figure 13.3: Activity Monitor showing the four genetic algorithm processes
    in action](img/B20851_13_3.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图13.3：Activity Monitor展示四个遗传算法进程在运行](img/B20851_13_3.jpg)'
- en: 'Figure 13.3: Activity Monitor showing the four genetic algorithm processes
    in action'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.3：Activity Monitor展示四个遗传算法进程在运行
- en: As expected, the four Python processes handling the multiprocessor program are
    heavily utilized, although not at 100%. This prompts the question, can we “squeeze”
    more out of the CPUs at our disposal and further reduce the duration of the program’s
    run? In the following section, we will explore this possibility.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，处理多处理器程序的四个Python进程得到了大量利用，尽管还没有达到100%。这引出了一个问题，能否“榨取”更多CPU的潜力，进一步缩短程序的运行时间？在接下来的部分中，我们将探讨这一可能性。
- en: Increasing the number of processes
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 增加进程数
- en: 'Since the four CPUs at our disposal were not utilized at 100%, a question arises:
    can we further increase utilization by employing more than four concurrent processes?'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们手头的四个CPU并未被充分利用，问题随之而来：是否可以通过使用超过四个并发进程来进一步提高利用率？
- en: 'When we created the instance of the `Pool` class by calling `multiprocessing.Pool()`
    without any arguments, the number of processes created defaulted to the number
    of CPUs available – four, in our case. However, we can use the optional `processes`
    argument to set the desired number of processes, as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们通过调用 `multiprocessing.Pool()` 创建 `Pool` 类的实例时，如果没有任何参数，默认创建的进程数将与可用 CPU 的数量相同——在我们的案例中是四个。然而，我们可以使用可选的
    `processes` 参数来设置所需的进程数量，如下所示：
- en: '[PRE11]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: For our next experiment, we will utilize this option to vary the number of processes
    and compare the resulting durations. This is implemented in the Python `04_one_max_pool_loop.py`
    program, available at [https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_13/04_one_max_pool_loop.py](https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_13/04_one_max_pool_loop.py).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的下一个实验中，我们将利用这个选项来改变进程数量，并比较结果时长。这将在 Python 程序 `04_one_max_pool_loop.py`
    中实现，程序可通过 [https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_13/04_one_max_pool_loop.py](https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_13/04_one_max_pool_loop.py)
    获取。
- en: 'This program introduces a few modifications to the previous one, as outlined
    here:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序对前一个程序做了一些修改，具体如下：
- en: The **main()** function is renamed **run()**, as we are going to run it several
    times. It now accepts an argument, **num_processes**.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**main()** 函数被重命名为 **run()**，因为我们将多次调用它。它现在接受一个参数，**num_processes**。'
- en: 'The instantiation of the **Pool** object echoes this argument to create a process
    pool of the requested size:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Pool** 对象的实例化会传递此参数，以创建所请求大小的进程池：'
- en: '[PRE12]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The **plot_graph()** function is added to help illustrate the results.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**plot_graph()** 函数被添加用来帮助展示结果。'
- en: 'The code launching the program, found at the bottom of the file, now creates
    a loop, calling the **run()** function multiple times, with the **num_processes**
    argument incrementing from 1 to 20\. Additionally, it collects the resulting durations
    in a list, **run_times**:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 程序的启动代码位于文件底部，现在创建了一个循环，多次调用 **run()** 函数，**num_processes** 参数从 1 增加到 20。它还将结果时长收集到列表
    **run_times** 中：
- en: '[PRE13]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'At the end of the loop, the values in the **run_times** list to draw two plots,
    with the aid of the **plot_graph()** function:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在循环结束时，利用 **run_times** 列表中的值绘制两个图表，借助 **plot_graph()** 函数：
- en: '[PRE14]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Before we continue to describe the results of this experiment, keep in mind
    that the actual figures may vary between different computers. As a result, your
    specific results may differ somewhat. Nevertheless, the main observations should
    hold true.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续描述这个实验的结果之前，请记住，实际的数值可能因不同的计算机而有所不同。因此，您的具体结果可能会有所不同。然而，主要的观察结果应该是成立的。
- en: 'Running this program on our four-core computer yields the following output:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的四核计算机上运行此程序将产生以下输出：
- en: '[PRE15]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In addition, two plots are generated. The first plot, displayed in the following
    figure, illustrates the runtimes of the program for different numbers of processes.
    As anticipated, the runtime consistently decreased as the number of processes
    increased, surpassing the capacity of the four available CPUs. Notably, the improvements
    became marginal beyond eight processes:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还生成了两个图表。第一个图表，如下图所示，展示了不同进程数量下程序的运行时间。正如预期的那样，随着进程数量的增加，运行时间持续减少，超出了四个可用
    CPU 的容量。值得注意的是，超过八个进程后，性能提升变得非常有限：
- en: '![Figure 13.4: The durations of the program run over the different numbers
    of processes](img/B20851_13_4.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.4：程序在不同进程数量下的运行时长](img/B20851_13_4.jpg)'
- en: 'Figure 13.4: The durations of the program run over the different numbers of
    processes'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.4：程序在不同进程数量下的运行时长
- en: 'The dashed red line in this plot represents the shortest duration achieved
    in our test – about 31 seconds. For the sake of comparison, let''s recall the
    theoretical limit in this test: with 6 rounds of fitness calculations at 3 seconds
    each, the best possible result is 18 seconds.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图中虚线红线表示我们测试中取得的最短时长——约 31 秒。为了进行对比，我们回顾一下本次测试的理论极限：在每轮 3 秒的适应度计算中，6 轮的计算总时间最好的结果是
    18 秒。
- en: 'The second plot, shown in the following figure, depicts the reciprocal of the
    duration (or 1/duration), representing the “speed” of the program, across different
    numbers of processes:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个图表，如下图所示，描绘了时长的倒数（即 1/时长），表示程序在不同进程数量下的“速度”：
- en: '![Figure 13.5: The durations of the program run over the different numbers
    of processes](img/B20851_13_5.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.5：程序在不同进程数下的运行时长](img/B20851_13_5.jpg)'
- en: 'Figure 13.5: The durations of the program run over the different numbers of
    processes'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.5：程序在不同进程数下的运行时长
- en: This plot reveals that the program’s speed increases almost linearly with the
    addition of up to eight processes, but the rate of increase slows beyond this
    point. Notably, the graph shows a significant performance improvement when moving
    from 15 to 16 processes, a trend also observable in the previous plot.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这张图表明，程序的速度随着进程数增加到8个时几乎呈线性增长，但超过这个点后，增长速率减缓。值得注意的是，图表显示在从15个进程增加到16个进程时，性能显著提升，这一趋势在之前的图表中也有所体现。
- en: The performance gains observed when the number of processes exceeds the number
    of available physical CPU cores, a phenomenon known as “oversubscription,” can
    be linked to various factors. These include task overlapping, I/O and wait times,
    multithreading, hyper-threading, and optimizations by the operating system. The
    marked performance boost from 15 to 16 processes might be influenced by the computer’s
    hardware architecture and the operating system’s process scheduling strategies.
    Additionally, the specific structure of the program’s workload, as indicated by
    the fact that 3 out of 6 rounds of fitness calculations involved exactly 16 fitness
    evaluations (as shown in the `nevals` column), could also contribute to this increase.
    It’s important to note that these effects can differ, based on the computer’s
    architecture and the nature of the problems being solved.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当进程数超过可用的物理CPU核心数时，所观察到的性能提升现象，称为“过度订阅”，可以与多种因素相关。这些因素包括任务重叠、I/O和等待时间、多线程、超线程以及操作系统的优化。从15个进程到16个进程的显著性能提升可能受计算机硬件架构和操作系统进程调度策略的影响。此外，程序工作负载的特定结构，也由三分之二的适应度计算轮次中涉及正好16次适应度评估（如`nevals`列所示）可见，也可能有助于这种增加。需要注意的是，这些效果会因计算机架构和所解决问题的性质而有所不同。
- en: The takeaway from this experiment is the importance of experimenting with various
    process counts to find the optimal configuration for your program. Fortunately,
    you don’t need to rerun your entire genetic algorithm each time – a few generations
    should be enough to compare and figure out the best setup.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实验的主要收获是，实验不同的进程数以找到程序的最佳配置非常重要。幸运的是，你不需要每次都重新运行整个遗传算法——几代就足够用来比较并找出最佳设置。
- en: Multiprocessing using the SCOOP library
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SCOOP库进行多进程处理
- en: Another approach to introduce multiprocessing is by utilizing **SCOOP**, a Python
    library designed to parallelize and distribute code execution across multiple
    processes. **SCOOP**, which stands for **Simple COncurrent Operations in Python**,
    provides a straightforward interface for parallel computing in Python, which we’ll
    explore shortly.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种引入多进程的方法是使用**SCOOP**，这是一个旨在将代码执行并行化和分布到多个进程的Python库。**SCOOP**，即**Python中的简单并发操作**，为Python中的并行计算提供了一个简单的接口，我们稍后会详细探讨。
- en: Applying SCOOP to a DEAP-based program is quite similar to using the `multiprocessing.Pool`
    module, as demonstrated by the Python `05_one_max_scoop.py` program, available
    at [https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_13/05_one_max_scoop.py](https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_13/05_one_max_scoop.py).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 将SCOOP应用到基于DEAP的程序中与使用`multiprocessing.Pool`模块非常相似，如Python程序`05_one_max_scoop.py`所示，可以在[https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_13/05_one_max_scoop.py](https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_13/05_one_max_scoop.py)查看。
- en: 'This program requires only a couple of modifications to the original non-multiprocessing
    version of the `02_one_max_busy.py` program; these are outlined here:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序只需要对原始的非多进程版本`02_one_max_busy.py`进行几个修改；这些修改在此列出：
- en: 'Import SCOOP’s **futures** module:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入SCOOP的**futures**模块：
- en: '[PRE16]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Register the **map** method of SCOOP’s **futures** module as the “map” function
    to be used by DEAP’s toolbox module:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将SCOOP的**futures**模块的**map**方法注册为DEAP工具箱模块中使用的“map”函数：
- en: '[PRE17]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'And that’s it! However, launching this program requires using SCOOP as the
    main module, via the following command:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！但是，启动这个程序需要通过以下命令使用SCOOP作为主模块：
- en: '[PRE18]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Running this program on the same four-core computer yields the following output:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一台四核计算机上运行该程序，得到如下输出：
- en: '[PRE19]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: python3 -m scoop -n 16 05_one_max_scoop.py
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: python3 -m scoop -n 16 05_one_max_scoop.py
- en: '[PRE20]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: SCOOP 0.7 2.0 on darwin using Python 3.11.1
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: SCOOP 0.7 2.0 在 darwin 上使用 Python 3.11.1
- en: Deploying 16 worker(s) over 1 host(s).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在 1 台主机上部署 16 个工作进程。
- en: 'Worker distribution:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 工作进程分配：
- en: '127.0.0.1: 15 + origin'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '127.0.0.1: 15 + 原点'
- en: Launching 16 worker(s) using /bin/zsh.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 /bin/zsh 启动 16 个工作进程。
- en: gen     nevals  max     avg
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: gen     nevals  max     avg
- en: 0       20      7       4.35
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 0       20      7       4.35
- en: 1       14      7       6.1
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 1       14      7       6.1
- en: 2       16      9       6.85
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 2       16      9       6.85
- en: 3       16      9       7.6
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 3       16      9       7.6
- en: 4       16      9       8.45
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 4       16      9       8.45
- en: 5       13      10      8.9
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 5       13      10      8.9
- en: Best Individual =  [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳个体 =  [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
- en: Lost track of future or Received an unexpected future. These warnings indicate
    communication issues, related to resource constraints caused by oversubscription.
    Despite these warnings, SCOOP is generally capable of recovering and successfully
    reproducing the expected results.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 忘记了未来的进度或接收到了意外的未来。这些警告表示通信问题，通常与由于过度订阅而导致的资源限制有关。尽管有这些警告，SCOOP 通常能够恢复并成功地重现预期的结果。
- en: A few more experiments reveal that we could achieve times as low as 20 seconds
    when using SCOOP with process counts of 20 and above. This marks a significant
    improvement over the 31 seconds we managed with the `multiprocessing.Pool` module
    for the same problem.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 一些实验表明，当使用 20 个以上进程时，SCOOP 可以在 20 秒内完成任务，相较于我们在相同问题上使用 `multiprocessing.Pool`
    模块时达到的 31 秒，取得了显著的提升。
- en: This enhancement might stem from SCOOP’s distinct approach to parallelization.
    For instance, its dynamic task allocation could be more effective than the static
    method used by `multiprocessing.Pool`. Additionally, SCOOP might handle the overhead
    of process management more efficiently and could be better at scheduling tasks
    on the available cores. However, this doesn’t mean SCOOP will always have the
    upper hand over `multiprocessing.Pool`. It’s wise to try out both methods and
    see how they perform with your specific algorithm and problem. The good news is
    that switching between the two is relatively simple.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这个改进可能源自于SCOOP在并行化方面的独特方法。例如，其动态任务分配可能比 `multiprocessing.Pool` 使用的静态方法更有效。此外，SCOOP
    可能在进程管理开销上表现得更高效，且在可用核心上调度任务的能力更强。然而，这并不意味着 SCOOP 总是会优于 `multiprocessing.Pool`。建议试用两种方法，看看它们在你特定算法和问题上的表现。好消息是，在两者之间切换相对简单。
- en: Having said that, it’s important to mention that SCOOP offers a key feature
    that sets it apart from `multiprocessing.Pool` – **distributed computing**. This
    feature allows for parallel processing across multiple machines. We will briefly
    explore this capability in the following section.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，值得一提的是，SCOOP 提供了一个使其与 `multiprocessing.Pool` 区别开来的关键特性——**分布式计算**。这一特性允许在多台机器上进行并行处理。我们将在接下来的部分简要探讨这一功能。
- en: Distributed computing with SCOOP
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 SCOOP 进行分布式计算
- en: 'SCOOP not only supports multiprocessing on a single machine but also enables
    distributed computing across multiple interconnected nodes. This functionality
    can be configured in one of two ways:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: SCOOP 不仅支持单机上的多进程计算，还能够在多个互联的节点之间进行分布式计算。这一功能可以通过两种方式进行配置：
- en: '**Using the** **--hostfile** **parameter**: This parameter should be followed
    by the name of a file containing a list of hosts. The format for each line in
    this file is **<hostname or IP address> <num_of_processes>**, where each line
    specifies a host and the corresponding number of processes to run on that host.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用** **--hostfile** **参数**：此参数后面应跟随一个包含主机列表的文件名。该文件中每行的格式为**<主机名或IP地址> <进程数>**，其中每一行指定了一个主机及该主机上要运行的进程数。'
- en: '**Using the** **--hosts** **parameter**: This option requires a list of hostnames.
    Each hostname should be listed as many times as the number of processes you intend
    to run on that host.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用** **--hosts** **参数**：此选项需要一个主机名列表。每个主机名应根据你打算在该主机上运行的进程数量列出。'
- en: For more detailed information and practical examples, you are encouraged to
    consult SCOOP’s official documentation.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如需更详细的信息和实际示例，建议查阅 SCOOP 的官方文档。
- en: A different approach to extending beyond the limitations of a single machine
    will be explored in the next chapter.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将探讨一种超越单机限制的不同方法。
- en: Summary
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you were introduced to the concept of applying concurrency
    to genetic algorithms via multiprocessing, a natural strategy to alleviate their
    computationally intensive nature. Two main approaches were demonstrated – using
    Python’s built-in `multiprocessing.Pool` class and the SCOOP library. We employed
    a CPU-intensive version of the familiar One-Max problem as a benchmark, through
    which several insights were gained. The final part of the chapter addressed the
    potential of using the SCOOP library for distributed computing.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了通过多进程将并发应用于遗传算法的概念，这是一种缓解其计算密集型特征的自然策略。展示了两种主要方法——使用 Python 内建的 `multiprocessing.Pool`
    类和 SCOOP 库。我们采用了一个 CPU 密集型的经典 One-Max 问题作为基准，从中获得了一些洞见。本章的最后部分讨论了使用 SCOOP 库进行分布式计算的潜力。
- en: In the next chapter, we will take the idea of concurrency to the next level
    by employing a client-server model. This approach will utilize both multiprocessing
    and multithreading, ultimately leveraging the power of cloud computing to further
    enhance performance.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将通过采用客户端-服务器模型，将并发的概念提升到一个新的层次。这种方法将结合使用多进程和多线程，最终利用云计算的力量进一步提升性能。
- en: Further reading
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 深入阅读
- en: 'For more information on the topics that were covered in this chapter, refer
    to the following resources:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解本章中涉及的更多内容，请参考以下资源：
- en: '*Advanced Python Programming: Build high performance, concurrent, and multi-threaded
    apps with Python using proven design patterns* by Dr. Gabriele Lanaro, Quan Nguyen,
    and Sakis Kasampalis, February 2019'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《高级 Python 编程：使用经过验证的设计模式构建高性能、并发和多线程的 Python 应用程序》*，作者：Dr. Gabriele Lanaro、Quan
    Nguyen 和 Sakis Kasampalis，2019年2月'
- en: 'SCOOP framework documentation: [https://scoop.readthedocs.io/en/latest/](https://scoop.readthedocs.io/en/latest/)'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SCOOP 框架文档：[https://scoop.readthedocs.io/en/latest/](https://scoop.readthedocs.io/en/latest/)
- en: 'Python multiprocessing module documentation: [https://docs.python.org/3/library/multiprocessing.html](https://docs.python.org/3/library/multiprocessing.html)'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 多进程模块文档：[https://docs.python.org/3/library/multiprocessing.html](https://docs.python.org/3/library/multiprocessing.html)
- en: '[PRE21]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
