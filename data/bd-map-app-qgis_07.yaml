- en: Chapter 7. Selecting and Editing Features in a PyQGIS Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章. 在PyQGIS应用程序中选择和编辑要素
- en: When running the QGIS application, the user has a range of tools available to
    create and manipulate geospatial features. For example, the **Add Feature** tool
    lets the user create a new feature, while the **Move Feature** tool and the **Node**
    tool allow the user to move and edit existing geospatial features. However, these
    tools are only available within QGIS itself—if you want to write an external application
    on top of the PyQGIS library, these built-in tools aren't available, and you will
    have to implement these features yourself.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行QGIS应用程序时，用户有一系列工具可用于创建和操作地理要素。例如，**添加要素**工具允许用户创建新要素，而**移动要素**工具和**节点**工具允许用户移动和编辑现有的地理要素。然而，这些工具仅在QGIS本身内可用——如果您想在PyQGIS库之上编写外部应用程序，这些内置工具不可用，您将必须自己实现这些功能。
- en: 'In this chapter, we will look at what is involved in adding functionality to
    a PyQGIS application so that the user can select and edit geospatial features.
    In particular, we will examine:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨向PyQGIS应用程序添加功能所涉及的内容，以便用户可以选择和编辑地理要素。特别是，我们将检查：
- en: How to work with selections
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何处理选择
- en: How the layer editing mode can be used to save or undo the changes the user
    has made to a map layer
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用图层编辑模式来保存或撤销用户对地图层所做的更改
- en: How to create map tools that will allow the user to add and edit Point geometries
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建允许用户添加和编辑点几何形状的地图工具
- en: How to let the user remove a geometry from a map layer
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何允许用户从地图层中删除几何形状
- en: How to implement custom map tools that allow the user to add LineString and
    Polygon geometries to a map layer
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何实现自定义地图工具，允许用户将线字符串和多边形几何形状添加到地图层
- en: How to let the user edit a LineString or Polygon geometry
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何允许用户编辑线字符串或多边形几何形状
- en: Working with selections
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理选择
- en: 'The vector layer class, `QgsVectorLayer`, includes support for keeping track
    of the user''s current selection. Doing this is relatively straightforward: there
    are methods that set and alter the selection, as well as retrieve the selected
    features. When features are selected, they are visually highlighted on the screen
    so that the user can see what has been selected.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 向量图层类`QgsVectorLayer`包括跟踪用户当前选择的支持。这样做相对简单：有设置和更改选择的方法，以及检索所选要素的方法。当要素被选中时，它们在屏幕上以视觉方式突出显示，以便用户可以看到已选择的内容。
- en: Tip
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you create your own custom symbol layer, you will need to handle the highlighting
    of the selected features yourself. We saw how to do this in [Chapter 6](part0047_split_000.html#page
    "Chapter 6. Mastering the QGIS Python API"), *Mastering the QGIS Python API*,
    in the section titled *Implementing symbol layers in Python*.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你创建了自己的自定义符号层，你需要自己处理所选要素的高亮显示。我们已经在[第6章](part0047_split_000.html#page "第6章.
    掌握QGIS Python API")，*掌握QGIS Python API*，标题为*在Python中实现符号层*的部分中看到了如何做到这一点。
- en: 'While there are several ways in which the user can select features, the most
    straightforward way is to click on them. This can be implemented by using a simple
    map tool, for example:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然用户有多种选择要素的方法，但最直接的方法是点击它们。这可以通过使用一个简单的地图工具来实现，例如：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is very similar to the `ExploreTool` we implemented in the previous chapter
    as part of the Lex application. The only difference is that, instead of displaying
    information about the clicked-on feature, we tell the map layer to select it.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们在上一章Lex应用程序中实现的`ExploreTool`非常相似。唯一的区别是，我们不是显示关于点击的要素的信息，而是告诉地图层选择它。
- en: Note that we check to see if the *Shift* key is held down. If so, the clicked-on
    feature is added to the current selection; otherwise, the current selection will
    be replaced with the newly selected feature. Also, if the user clicks on the background
    of the map, the current selection will be removed. These are all standard user
    interface conventions the user will be familiar with.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们检查是否按下了*Shift*键。如果是，则将点击的要素添加到当前选择中；否则，当前选择将被新选中的要素替换。此外，如果用户点击地图的背景，当前选择将被移除。这些都是用户熟悉的标准的用户界面约定。
- en: 'Once we have a selection, it is quite straightforward to get the selected features
    from the map layer. For example:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了选择，从地图层中获取所选要素就相当简单。例如：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If you want to see all this in action, you can download and run the **SelectionExplorer**
    program, which is included in the sample code of this chapter.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想看到所有这些功能在实际中的应用，您可以下载并运行本章示例代码中包含的 **SelectionExplorer** 程序。
- en: Using the layer editing mode
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用图层编辑模式
- en: 'To let the user change the contents of a map layer, you first have to turn
    on the **editing mode** for that layer. The layer editing mode is similar to the
    way transactions are handled in a database:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要让用户更改地图图层的内容，您首先必须打开该图层的**编辑模式**。图层编辑模式类似于数据库中处理事务的方式：
- en: '![Using the layer editing mode](img/00081.jpeg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![使用图层编辑模式](img/00081.jpeg)'
- en: 'The changes you make to the layer are held in memory until you decide to either
    **commit** the changes to the layer, or **roll** **back** the changes to discard
    them. The following pseudocode is an example of how to implement this using PyQGIS:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 您对图层所做的更改将保留在内存中，直到您决定将更改**提交**到图层，或者**回滚**更改以丢弃它们。以下伪代码是使用 PyQGIS 实现此功能的示例：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As you can see, we turn on the editing mode for a given map layer by calling
    `layer.startEditing()`. As well as set up an internal *editing buffer* to hold
    the changes you make, this tells the layer to visually highlight the layer''s
    features by drawing small vertex markers on each of the vertices, as shown in
    the following image:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们通过调用 `layer.startEditing()` 打开特定地图图层的编辑模式。除了设置一个内部 *编辑缓冲区* 来保存您所做的更改外，这还告诉图层通过在每个顶点上绘制小顶点标记来视觉上突出显示图层的要素，如下面的图像所示：
- en: '![Using the layer editing mode](img/00082.jpeg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![使用图层编辑模式](img/00082.jpeg)'
- en: We then allow the user to make changes to the layer's features. We will learn
    how this is done in the following sections of this chapter. When the user turns
    off the editing mode, we check whether any changes have been made, and if so,
    display a confirmation message box to the user. Depending on the user's response,
    we either save the changes by calling `layer.commitChanges()` or discard them
    by calling `layer.rollBack()`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们允许用户更改图层的要素。我们将在本章的后续部分学习如何实现这一点。当用户关闭编辑模式时，我们会检查是否进行了更改，如果有，则向用户显示确认消息框。根据用户的响应，我们通过调用
    `layer.commitChanges()` 保存更改，或者通过调用 `layer.rollBack()` 抛弃更改。
- en: Both `commitChanges()` and `rollBack()` turn off the editing mode, hiding the
    vertex markers and erasing the contents of the editing buffer.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`commitChanges()` 和 `rollBack()` 都会关闭编辑模式，隐藏顶点标记并擦除编辑缓冲区的内容。'
- en: Note
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When you use the layer's editing mode, you *must* use the various methods in
    `QgsVectorLayer` to modify the features, rather than using the equivalent methods
    in the data provider. For example, you should call `layer.addFeature(feature)`
    instead of `layer.dataProvider().addFeatures([feature])`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用图层的编辑模式时，您**必须**使用 `QgsVectorLayer` 中的各种方法来修改要素，而不是使用数据提供者中的等效方法。例如，您应该调用
    `layer.addFeature(feature)` 而不是 `layer.dataProvider().addFeatures([feature])`。
- en: The layer's editing methods only work when the layer is in the editing mode.
    These methods add the changes to the internal editing buffer so that they can
    be committed or rolled back at the appropriate time. If you make your changes
    directly to the data provider, you will bypass the editing buffer, so the rollback
    feature won't work.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图层的编辑方法仅在图层处于编辑模式时才有效。这些方法将更改添加到内部编辑缓冲区，以便在适当的时候提交或回滚。如果您直接对数据提供者进行更改，您将绕过编辑缓冲区，因此回滚功能将不会工作。
- en: Now that we have seen the overall process used to edit the contents of a map
    layer, let's create some map tools that will let the user add and edit geospatial
    data.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了编辑地图图层内容的整体过程，让我们创建一些地图工具，使用户能够添加和编辑地理空间数据。
- en: Adding Points
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加点
- en: 'The following map tool allows the user to add a new Point feature to the given
    layer:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 以下地图工具允许用户向给定图层添加新的点要素：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see, this straightforward map tool sets the mouse cursor to a cross
    shape, and when the user releases the mouse over the map canvas, a new `QgsGeometry`
    object is created that represents a point at the current mouse position. This
    point is then added to the layer using `layer.addFeature()`, and the layer's extent
    is updated in case the newly added point is outside the layer's current extent.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这个简单的地图工具将鼠标光标设置为十字形，当用户在地图画布上释放鼠标时，会创建一个新的 `QgsGeometry` 对象，该对象代表当前鼠标位置的一个点。然后，使用
    `layer.addFeature()` 将此点添加到图层中，并更新图层的范围，以防新添加的点位于图层的当前范围之外。
- en: Of course, this map tool is only a starting point—you would typically add code
    to set the feature's attributes and to notify the application that a point has
    been added. However, as you can see, allowing the user to create a new Point feature
    is quite straightforward.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这个地图工具只是一个起点——你通常会添加代码来设置特征的属性，并通知应用程序一个点已经被添加。然而，正如你所见，允许用户创建一个新的点特征相当简单。
- en: Editing Points
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编辑点
- en: 'Editing a Point feature is also quite straightforward: since the geometry consists
    of only one point, the user can simply click-and-drag to move the point around
    within the map layer. The following is a map tool that implements this behavior:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑点特征也相当简单：由于几何形状只包含一个点，用户可以简单地点击并拖动来在地图层中移动点。以下是一个实现此行为的地图工具：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see, we subclass `QgsMapToolIdentify` for this map tool. This lets
    us use the `identify()` method to find the geometry that the user clicked on,
    just like we did in the `SelectTool`, which we implemented earlier in this chapter.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们为这个地图工具继承自 `QgsMapToolIdentify`。这让我们可以使用 `identify()` 方法找到用户点击的几何形状，就像我们在本章前面实现的
    `SelectTool` 一样。
- en: Notice that our `canvasMoveEvent()` method keeps track of the user's current
    mouse position. It also updates the feature's geometry by calling `layer.changeGeometry()`
    to remember the changed mouse position as the user moves the point around. The
    `canvasPressEvent()` enables dragging if and only if the user clicked on a Point,
    and the `canvasReleaseEvent()` method tidies up so that the user can move another
    point by clicking on it.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们的 `canvasMoveEvent()` 方法跟踪用户当前的鼠标位置。它还通过调用 `layer.changeGeometry()` 来更新特征的几何形状，以记住用户移动点时的变化鼠标位置。`canvasPressEvent()`
    只在用户点击点时启用拖动，而 `canvasReleaseEvent()` 方法整理好，以便用户可以通过点击来移动另一个点。
- en: If you are writing a standalone PyQGIS application that includes a point-based
    `QgsVectorLayer`, you can use the `AddPointTool` and `MovePointTool` classes we
    defined here to allow the user to add and edit Point features within your vector
    layer. The only thing missing (for Point geometries) is the ability to remove
    points. Let's implement this now.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在编写一个包含基于点的 `QgsVectorLayer` 的独立 PyQGIS 应用程序，你可以使用我们在这里定义的 `AddPointTool`
    和 `MovePointTool` 类来允许用户在你的矢量层中添加和编辑点特征。对于点几何来说，唯一缺少的功能是删除点的功能。现在让我们来实现这个功能。
- en: Deleting Points and other features
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除点和其他特征
- en: 'Fortunately, the code required to delete a Point feature will also work for
    other types of geometries, so we don''t need to implement separate `DeletePointTool`,
    `DeleteLineTool`, and `DeletePolygonTool` classes. Instead, we only need a generic
    `DeleteTool`. The following code implements this map tool:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，删除点特征所需的代码也适用于其他类型的几何形状，因此我们不需要实现单独的 `DeletePointTool`、`DeleteLineTool`
    和 `DeletePolygonTool` 类。相反，我们只需要一个通用的 `DeleteTool`。以下代码实现了这个地图工具：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Once again, we are using the `QgsMapToolIdentify` class to let us quickly find
    the feature the user clicked on. We use the `canvasPressEvent()` and `canvasReleaseEvent()`
    methods to ensure that the user clicked and released the mouse over the same feature;
    this ensures that the map tool works in a more user-friendly way than simply deleting
    the feature when the user clicks on it. If both the mouse click and the mouse
    release were over the same feature, we would delete it.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，我们使用 `QgsMapToolIdentify` 类来快速找到用户点击的特征。我们使用 `canvasPressEvent()` 和 `canvasReleaseEvent()`
    方法来确保用户在同一个特征上点击和释放鼠标；这确保了地图工具比简单地删除用户点击的特征更加用户友好。如果鼠标点击和释放都在同一个特征上，我们会删除它。
- en: With the help of these map tools, it is quite straightforward to implement a
    PyQGIS application that allows the user to add, edit, and delete Point features
    within a map layer. These, however, are the "low hanging fruit"—our next task,
    where we have to let the user add and edit LineString and Polygon geometries,
    is more complex.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些地图工具的帮助下，实现一个允许用户在地图层中添加、编辑和删除点特征的 PyQGIS 应用程序相当简单。然而，这些都是“低垂的果实”——我们的下一个任务，即让用户添加和编辑
    LineString 和 Polygon 几何形状，要复杂得多。
- en: Adding lines and polygons
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加线和多边形
- en: 'To add a LineString or a Polygon geometry, the user will *draw* the desired
    shape by clicking on each vertex in turn. Appropriate feedback will be displayed
    as the user clicks on each vertex. For example, a LineString geometry would be
    displayed in the following way:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加 LineString 或 Polygon 几何形状，用户将依次点击每个顶点来 *绘制* 所需的形状。用户点击每个顶点时，将显示适当的反馈。例如，LineString
    几何形状将以以下方式显示：
- en: '![Adding lines and polygons](img/00083.jpeg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![添加线和多边形](img/00083.jpeg)'
- en: 'To draw the outline of a Polygon geometry, the user will once again click on
    each vertex in turn. This time, however, the polygon itself will be displayed
    to make the resulting shape clear, as the following image shows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要绘制 Polygon 几何形状的轮廓，用户将再次依次单击每个顶点。然而，这次，多边形本身将显示出来，以便使结果形状清晰，如下面的图像所示：
- en: '![Adding lines and polygons](img/00084.jpeg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![添加线和多边形](img/00084.jpeg)'
- en: In both cases, the basic logic of clicking on each vertex and displaying appropriate
    feedback is the same.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，点击每个顶点和显示适当反馈的基本逻辑是相同的。
- en: 'QGIS includes a map tool named `QgsMapToolCapture`, which handles exactly this
    behavior: it allows the user to draw a LineString or the outline of a Polygon
    geometry by clicking on each vertex in turn. Unfortunately, `QgsMapToolCapture`
    is not available as part of the PyQGIS library, so we will have to re-implement
    it ourselves using Python.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: QGIS 包含一个名为 `QgsMapToolCapture` 的地图工具，它正好处理这种行为：它允许用户通过依次单击每个顶点来绘制 LineString
    或 Polygon 几何形状的轮廓。不幸的是，`QgsMapToolCapture` 并不是 PyQGIS 库的一部分，因此我们必须自己使用 Python
    重新实现它。
- en: Let's start by looking at the design of our `QgsMapToolCapture` port, which
    we will call `CaptureTool`. This will be a standard map tool, derived from `QgsMapTool`,
    which makes use of `QgsRubberBand` objects to draw the visual highlighting of
    the LineString or Polygon as it is drawn.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从查看我们的 `QgsMapToolCapture` 端口设计开始，我们将称之为 `CaptureTool`。这将是一个标准的地图工具，由 `QgsMapTool`
    派生而来，它使用 `QgsRubberBand` 对象来绘制 LineString 或 Polygon 在绘制时的视觉高亮。
- en: 'A `QgsRubberBand` is a map canvas item that draws a geometry on top of the
    map. Since a rubber band draws its entire geometry in a single color and style,
    we have to use two rubber bands in our capture tool: one that draws the already
    captured part of the geometry and a second temporary rubber band that extends
    the geometry out to the current mouse position. The following illustration shows
    how this works for both LineString and Polygon geometries:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`QgsRubberBand` 是一个地图画布项，它在地图上绘制一个几何形状。由于橡皮筋以单色和样式绘制其整个几何形状，因此在我们的捕获工具中，我们必须使用两个橡皮筋：一个用于绘制已经捕获的几何形状的部分，另一个临时橡皮筋用于将几何形状扩展到当前鼠标位置。以下插图显示了这对于
    LineString 和 Polygon 几何形状是如何工作的：'
- en: '![Adding lines and polygons](img/00085.jpeg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![添加线和多边形](img/00085.jpeg)'
- en: 'Here are some additional features that we will include in `CaptureTool`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些我们将在 `CaptureTool` 中包含的附加功能：
- en: It will have a *capture mode* that indicates whether the user is creating a
    LineString or a Polygon geometry.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将有一个 *捕获模式*，指示用户是否正在创建 LineString 或 Polygon 几何形状。
- en: The user can press the *Backspace* or *Delete* key to remove the last vertex
    added.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户可以按 *Backspace* 或 *Delete* 键来删除最后添加的顶点。
- en: The user can press the *Enter* or *Return* key to finish the capturing process.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户可以按 *Enter* 或 *Return* 键来完成捕获过程。
- en: If we are capturing a Polygon, the geometry will be *closed* when the user finishes
    capturing. This means that we add an extra point to the geometry so that the outline
    begins and ends at the same point.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们正在捕获 Polygon，当用户完成捕获时，几何形状将被 *封闭*。这意味着我们向几何形状添加一个额外的点，以便轮廓从同一点开始和结束。
- en: When the user finishes capturing a geometry, the geometry will be added to the
    layer, and a callback function will be used to tell the application that a new
    geometry has been added.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户完成捕获几何形状时，几何形状将被添加到层中，并使用回调函数来通知应用程序已添加新的几何形状。
- en: 'Now that we know what we''re doing, let''s start implementing the `CaptureTool`
    class. The first part of our class definition will look like the following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们知道我们在做什么，让我们开始实现 `CaptureTool` 类。我们类定义的第一部分将看起来如下：
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'At the top of our class, we define two constants, `CAPTURE_LINE` and `CAPTURE_POLYGON`,
    which define the available capture modes. We then have the class initializer,
    which will accept the following parameters:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们类的顶部，我们定义了两个常量，`CAPTURE_LINE` 和 `CAPTURE_POLYGON`，它们定义了可用的捕获模式。然后我们有类初始化器，它将接受以下参数：
- en: '`canvas`: This is the `QgsMapCanvas` this map tool will be part of.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`canvas`：这是这个地图工具将作为一部分的 `QgsMapCanvas`。'
- en: '`layer`: This is the `QgsVectorLayer` the geometry will be added to.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`layer`：这是几何形状将被添加到的 `QgsVectorLayer`。'
- en: '`onGeometryAdded`: This is a Python-callable object (that is, a method or function)
    that will be called when a new geometry has been added to the map layer.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onGeometryAdded`：这是一个 Python 可调用对象（即，一个方法或函数），当新的几何形状被添加到地图层时将被调用。'
- en: '`captureMode`: This indicates whether we are capturing a LineString or a Polygon
    geometry.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`captureMode`：这表示我们正在捕获 LineString 或 Polygon 几何形状。'
- en: We then set the various instance variables to their initial state, and tell
    the map tool to use a cross cursor, which makes it easier for the user to see
    exactly where they are clicking.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将各种实例变量设置为其初始状态，并告诉地图工具使用十字光标，这使用户更容易看到他们确切点击的位置。
- en: Our next task is to implement the various `XXXEvent()` methods to respond to
    the user's actions. We'll start with `canvasReleaseEvent()`, which responds to
    a left-click by adding a new vertex to the geometry, and to a right-click by finishing
    off the capture process and then adding the geometry to the map layer.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来的任务是实现各种 `XXXEvent()` 方法以响应用户的操作。我们将从 `canvasReleaseEvent()` 开始，它响应左键点击通过向几何形状添加新顶点，以及右键点击通过完成捕获过程然后将几何形状添加到地图层。
- en: Note
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We implement this behavior in the `canvasReleaseEvent()` method, rather than
    `canvasPressEvent()`, because we want the vertex to be added when the user releases
    the mouse button, rather than when they initially press it.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `canvasReleaseEvent()` 方法中实现这种行为，而不是 `canvasPressEvent()`，因为我们希望顶点在用户释放鼠标按钮时添加，而不是在它们最初按下时。
- en: 'Here is the implementation of the `canvasReleaseEvent()` method. Note that
    we make use of several helper methods, which we will define shortly:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `canvasReleaseEvent()` 方法的实现。注意我们使用了几个辅助方法，我们将在稍后定义：
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Next, we have the `canvasMoveEvent()` method, which responds to the action
    of the user moving the mouse by updating the temporary rubber band to reflect
    the current mouse position:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有 `canvasMoveEvent()` 方法，它响应用户移动鼠标的动作，通过更新临时橡皮筋以反映当前鼠标位置：
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The interesting part here is the call to `tempRubberBand.movePoint()`. The `QgsRubberBand`
    class works in map coordinates, so we first have to convert from the current mouse
    position, which is in pixels, to map coordinates. We then call `movePoint()`,
    which moves the current vertex in the rubber band to the new position.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有趣的部分是对 `tempRubberBand.movePoint()` 的调用。`QgsRubberBand` 类在地图坐标中工作，因此我们首先必须将当前鼠标位置（以像素为单位）转换为地图坐标。然后我们调用
    `movePoint()`，它将橡皮筋中的当前顶点移动到新位置。
- en: 'There is one more event handling method to define: `onKeyEvent()`. This responds
    to the user pressing the *Backspace* or *Delete* keys by removing the last added
    vertex, and to the user pressing *Return* or *Enter* by closing and saving the
    current geometry. Here is the code for this method:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个事件处理方法需要定义：`onKeyEvent()`。该方法响应用户按下 *Backspace* 或 *Delete* 键，通过移除最后一个添加的顶点，以及用户按下
    *Return* 或 *Enter* 键通过关闭并保存当前几何形状。以下是此方法的代码：
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now that we''ve defined our event handling methods, let''s now define the various
    helper methods that these event handlers rely on. We''ll start with the `transformCoordinates()`
    method, which converts from a mouse position, which is in canvas coordinates,
    to map and layer coordinates:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了事件处理方法，接下来定义这些事件处理器所依赖的各种辅助方法。我们将从 `transformCoordinates()` 方法开始，该方法将鼠标位置（在画布坐标中）转换为地图和层坐标：
- en: '[PRE10]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If, for example, the mouse is currently at position `(17,53)` on the canvas,
    this may translate to a map and layer coordinate of `lat=37.234` and `long=-112.472`.
    As the map and layer might use different coordinate reference systems, we calculate
    and return the coordinates for both.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果鼠标当前位于画布上的 `(17,53)` 位置，这可能转换为地图和层坐标 `lat=37.234` 和 `long=-112.472`。由于地图和层可能使用不同的坐标参考系统，我们计算并返回两者的坐标。
- en: 'Let''s now define the `startCapturing()` method, which prepares our two rubber
    bands and sets `self.capturing` to `True`, so we know that we are currently capturing
    a geometry:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们定义 `startCapturing()` 方法，它准备我们的两个橡皮筋并将 `self.capturing` 设置为 `True`，这样我们知道我们目前正在捕获几何形状：
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Notice that we use another helper method, `bandType()`, to decide on the type
    of geometry that the rubber band should draw. Let''s define that method now:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用另一个辅助方法 `bandType()` 来决定橡皮筋应该绘制的几何类型。现在让我们定义这个方法：
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Next up is the `stopCapturing()` method, which removes our two rubber bands
    from the map canvas, resets our instance variables back to their initial state,
    and tells the map canvas to refresh itself so that the rubber bands are hidden:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是 `stopCapturing()` 方法，它从地图画布中移除我们的两个橡皮筋，将实例变量重置到初始状态，并告诉地图画布刷新自身，以便隐藏橡皮筋：
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We now come to the `addVertex()` method. This adds a new vertex to the current
    geometry at the clicked-on mouse position, and updates the rubber bands to match:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来到`addVertex()`方法。此方法在点击的鼠标位置向当前几何形状添加一个新的顶点，并更新橡皮筋以匹配：
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note that we add the captured point to the `self.capturedPoints` list. This
    is the list of points that will define the geometry when we finish capturing.
    Setting up the temporary rubber band is a bit convoluted, but the basic idea is
    to define LineString or Polygon so that it covers the currently highlighted portion
    of the new geometry.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们将捕获的点添加到`self.capturedPoints`列表中。这是我们完成捕获后定义几何形状的点列表。设置临时橡皮筋有点复杂，但基本思想是定义LineString或Polygon，使其覆盖新几何形状当前高亮显示的部分。
- en: 'Let''s now define the `removeLastVertex()` method, which is called when the
    user presses *Backspace* or *Delete* to undo their last click. This method is
    slightly complicated because we have to update both rubber bands to remove the
    last vertex, as well as the `self.capturedPoints` list:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们定义`removeLastVertex()`方法，当用户按下*退格*或*删除*键撤销上一次点击时，该方法会被调用。这个方法稍微复杂一些，因为我们必须更新两个橡皮筋以移除最后一个顶点，以及更新`self.capturedPoints`列表：
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We''ve now defined quite a few methods for our `CaptureTool`. Fortunately,
    there are only two methods left. Let''s now define the `getCapturedGeometry()`
    method. This method checks whether a LineString geometry has at least two points,
    and whether a Polygon geometry has at least three points. It then closes the polygon
    and returns the list of points that make up the captured geometry:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经为我们的`CaptureTool`定义了相当多的方法。幸运的是，只剩下两个方法。现在让我们定义`getCapturedGeometry()`方法。此方法检查LineString几何形状是否至少有两个点，以及Polygon几何形状是否至少有三个点。然后关闭多边形并返回组成捕获几何形状的点列表：
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Finally, we have the `geometryCaptured()` method, which responds to the geometry
    that is captured. This method creates a new geometry of the given type, adds it
    as a feature to the map layer, and uses the `onGeometryAdded` callable object
    passed to the initializer of our `CaptureTool`, to tell the rest of the application
    that a new geometry has been added to the layer:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有`geometryCaptured()`方法，它响应捕获的几何形状。此方法创建给定类型的新几何形状，将其作为要素添加到地图层，并使用传递给我们的`CaptureTool`初始化器的`onGeometryAdded`可调用对象，通知应用程序其余部分已向层添加了新几何形状：
- en: '[PRE17]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: While `CaptureTool` is complicated, it is a very powerful class that allows
    the user to add new lines and polygons to a map layer. There are a few features
    we haven't implemented here (coordinate snapping, checking whether the resulting
    geometry is valid, and adding support for inner rings that form "holes" within
    a polygon), but even as is, this is a useful tool for adding new features to a
    map.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`CaptureTool`很复杂，但它是一个非常强大的类，允许用户向地图层添加新的线和多边形。这里还有一些我们没有实现的功能（坐标捕捉、检查生成的几何形状是否有效，以及添加对形成多边形内环的支持），但即使如此，这也是一个有用的工具，可以用来向地图添加新要素。
- en: Editing lines and polygons
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编辑线和多边形
- en: 'The last major functionality we will examine is the ability to edit LineString
    and Polygon features. Just as the `CaptureTool` allowed the user to click and
    drag to create new lines and polygons, we will implement `EditTool`, which lets
    the user click and drag to move the existing feature''s vertices. The following
    image shows what the user will see when they use this tool to move a vertex:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要考察的最后一项主要功能是编辑LineString和Polygon要素的能力。正如`CaptureTool`允许用户点击并拖动来创建新的线和多边形一样，我们将实现`EditTool`，它允许用户点击并拖动来移动现有要素的顶点。以下图片显示了当用户使用此工具移动顶点时将看到的内容：
- en: '![Editing lines and polygons](img/00086.jpeg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![编辑线和多边形](img/00086.jpeg)'
- en: Our editing tool will also let the user add new vertices by double-clicking
    on a line segment, and delete vertices by right-clicking on the same line segment.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的编辑工具还将允许用户通过双击线段来添加新的顶点，并通过右击相同的线段来删除顶点。
- en: 'Let''s define our `EditTool` class:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义我们的`EditTool`类：
- en: '[PRE18]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'As you can see, `EditTool` is a subclass of `QgsMapTool`, and the initializer
    accepts three parameters: the map canvas, the layer to be edited, and an `onGeometryChanged`
    callable object, which will be called when the user makes a change to a geometry.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`EditTool`是`QgsMapTool`的子类，初始化器接受三个参数：地图画布、要编辑的图层，以及一个`onGeometryChanged`可调用对象，当用户对几何形状进行更改时，将调用此对象。
- en: 'Next, we want to define the `canvasPressEvent()` method. We''ll start by identifying
    the feature that the user clicked on:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们想要定义`canvasPressEvent()`方法。我们首先将识别用户点击的要素：
- en: '[PRE19]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We''ll implement the `findFeatureAt()` method shortly. Now that we know which
    feature the user clicked on, we want to identify the vertex within that feature
    that is closest to the click point, and how far away from the vertex the user
    clicked. Here is the relevant code:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在稍后实现`findFeatureAt()`方法。现在我们知道用户点击了哪个要素，我们想要识别该要素中离点击点最近的顶点，以及用户点击离顶点有多远。以下是相关代码：
- en: '[PRE20]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As you can see, we're using a copy of the `transformCoordinates()` method (borrowed
    from our `CaptureTool` class) to convert from canvas coordinates to map and layer
    coordinates. We then use the `QgsGeometry.closestVertex()` method to identify
    the closest vertex to the mouse click. This method returns a number of values,
    including the square of the distance from the closest vertex to the mouse position.
    We use the `math.sqrt()` function to convert this into a regular distance value,
    which will be in layer coordinates.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们正在使用`transformCoordinates()`方法的副本（从我们的`CaptureTool`类中借用）来将画布坐标转换为地图和图层坐标。然后，我们使用`QgsGeometry.closestVertex()`方法来识别鼠标点击位置最近的顶点。此方法返回多个值，包括从最近顶点到鼠标位置的距离的平方。我们使用`math.sqrt()`函数将其转换为常规距离值，该值将在图层坐标中。
- en: 'Now that we know how far away the mouse click was from the vertex, we have
    to decide whether the distance was too much. If the user didn''t click anywhere
    near a vertex, we''ll want to ignore the mouse click. To do this, we''ll calculate
    a **tolerance** value. The tolerance is determined by how far the click point
    can be from a vertex while still considering it to be a click on that vertex.
    As with the distance value we calculated earlier, the tolerance is measured in
    layer coordinates. We''ll use a helper method, `calcTolerance()`, to calculate
    this value. Here is the relevant code to add at the end of our `canvasPressEvent()`
    method:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道鼠标点击离顶点有多远，我们必须决定距离是否太远。如果用户没有在顶点附近点击任何地方，我们将想要忽略鼠标点击。为此，我们将计算一个**容差**值。容差是指点击点可以离顶点多远，同时仍然将其视为对该顶点的点击。与之前计算的距离值一样，容差是以图层坐标来衡量的。我们将使用一个辅助方法`calcTolerance()`来计算这个值。以下是需要在我们的`canvasPressEvent()`方法末尾添加的相关代码：
- en: '[PRE21]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'As you can see, we ignore the mouse click if it is too far away from the vertex,
    that is, if the distance is greater than the tolerance. Now that we know that
    the user did click near the vertex, we want to respond to that mouse click. How
    we do this depends on whether the user pressed the left or the right mouse button:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，如果鼠标点击位置离顶点太远，即距离大于容差，我们将忽略鼠标点击。现在我们知道用户确实在顶点附近点击了，我们想要对此鼠标点击做出响应。我们如何做这取决于用户是否按下了左键或右键：
- en: '[PRE22]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'As you can see, we''re relying on a number of helper methods to do most of
    the work. We''ll define these methods shortly, but first, let''s finish implementing
    our event handling methods, starting with `canvasMoveEvent()`. This method responds
    as the user moves the mouse over the canvas. It does this by moving the dragged
    vertex (if any) to the current mouse position:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们依赖于许多辅助方法来完成大部分工作。我们将在稍后定义这些方法，但首先，让我们完成我们的事件处理方法实现，从`canvasMoveEvent()`开始。此方法响应用户将鼠标移过画布。它是通过将拖动的顶点（如果有）移动到当前鼠标位置来实现的：
- en: '[PRE23]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Next, we have `canvasReleaseEvent()`, which moves the vertex to its final position,
    refreshes the map canvas, and updates our instance variables to reflect the fact
    that we are no longer dragging a vertex:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有`canvasReleaseEvent()`，它将顶点移动到其最终位置，刷新地图画布，并更新我们的实例变量以反映我们不再拖动顶点的事实：
- en: '[PRE24]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Our final event-handling method is `canvasDoubleClickEvent()`, which responds
    to a double-click by adding a new vertex to the feature. This method is similar
    to the `canvasPressEvent()` method; we have to identify the clicked-on feature,
    and then identify which line segment the user double-clicked on:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终的事件处理方法是`canvasDoubleClickEvent()`，它通过向要素添加新顶点来响应双击。此方法与`canvasPressEvent()`方法类似；我们必须识别被点击的要素，然后识别用户双击的是哪条线段：
- en: '[PRE25]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'As you can see, we ignore the double-click if the mouse position is too far
    away from the line segment. Next, we want to add the new vertex to the geometry,
    and update the map layer and the map canvas to reflect this change:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，如果鼠标位置离线段太远，我们将忽略双击。接下来，我们想要将新顶点添加到几何形状中，并更新地图图层和地图画布以反映这一变化：
- en: '[PRE26]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This completes all of the event-handling methods for our `EditTool`. Let''s
    now implement our various helper methods, starting with the `findFeatureAt()`
    method that identifies the clicked-on feature:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们 `EditTool` 的所有事件处理方法。现在让我们实现我们的各种辅助方法，从识别点击的要素的 `findFeatureAt()` 方法开始：
- en: '[PRE27]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We use the tolerance value to define a search rectangle centered around the
    click point, and identify the first feature that intersects that rectangle:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用容差值来定义一个以点击点为中心的搜索矩形，并识别与该矩形相交的第一个要素：
- en: '![Editing lines and polygons](img/00087.jpeg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![编辑线和多边形](img/00087.jpeg)'
- en: 'Next up is the `calcTolerance()` method, which calculates how much distance
    we can tolerate before a click is considered to be too far away from a vertex
    or geometry:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是 `calcTolerance()` 方法，它计算在点击被认为太远于顶点或几何形状之前我们可以容忍的距离：
- en: '[PRE28]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We calculate this by identifying two points on the map canvas that are ten pixels
    apart, and converting both of these coordinates into layer coordinates. We then
    return the distance between these two points, which will be the tolerance in the
    layer coordinate system.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过识别地图画布上相距十像素的两个点，并将这两个坐标都转换为层坐标来计算这个值。然后我们返回这两个点之间的距离，这将是层坐标系中的容差。
- en: 'We now get to the interesting part: moving and deleting vertices. Let''s start
    with the method to move a vertex to a new location:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来到了有趣的部分：移动和删除顶点。让我们从将顶点移动到新位置的方法开始：
- en: '[PRE29]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As you can see, we convert the position into layer coordinates, tell the `QgsGeometry`
    object to move the vertex to this location, and then tell the layer to save the
    updated geometry. Finally, we use the `onGeometryChanged` callable object to tell
    the rest of the application that the geometry has been changed.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们将位置转换为层坐标，告诉 `QgsGeometry` 对象将顶点移动到这个位置，然后告诉层保存更新的几何形状。最后，我们使用 `onGeometryChanged`
    可调用对象告诉应用程序的其他部分几何形状已被更改。
- en: 'Deleting a vertex is slightly more complicated, as we have to prevent the user
    from deleting a vertex if there aren''t enough vertices left to make a valid geometry—LineString
    must have a minimum of two vertices, while a polygon must have at least three.
    Here is the implementation of our `deleteVertex()` method:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 删除一个顶点稍微复杂一些，因为我们必须防止用户在没有足够的顶点来构成有效几何形状的情况下删除顶点——LineString 至少需要两个顶点，而多边形至少需要三个。以下是我们的
    `deleteVertex()` 方法的实现：
- en: '[PRE30]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note that the polygon check has to allow for the fact that the first and last
    points on the polygon's exterior are the same. This is why we check to see whether
    a polygon has at least four coordinates rather than three.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，多边形检查必须考虑到多边形外部的第一个和最后一个点实际上是相同的。这就是为什么我们检查多边形是否至少有四个坐标而不是三个。
- en: This completes our implementation of the `EditTool` class for editing LineString
    and Polygon geometries. To see this map tool in action along with the other geometry-editing
    map tools we defined in this chapter, check out the **GeometryEditor** program,
    which is included in the sample code of this chapter.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们对 `EditTool` 类的 `EditTool` 类的实现。要查看这个地图工具的实际效果，以及其他我们在本章中定义的几何形状编辑地图工具，请查看包含在本章示例代码中的
    **GeometryEditor** 程序。
- en: Summary
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to write a PyQGIS application that lets the
    user select and edit features. We created a map tool that uses the selection-handling
    methods in `QgsVectorLayer` to let the user select features, and learned how to
    work with the currently selected features within your program. We then looked
    at how the layer's editing mode allows the user to make changes and then either
    commit those changes or discard them. Finally, we created a series of map tools
    that allow the user to add, edit, and delete Point, LineString, and Polygon geometries
    within a map layer.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何编写一个 PyQGIS 应用程序，允许用户选择和编辑要素。我们创建了一个地图工具，它使用 `QgsVectorLayer` 中的选择处理方法来让用户选择要素，并学习了如何在程序内部处理当前选定的要素。然后我们探讨了层的编辑模式如何允许用户进行更改，然后要么提交这些更改，要么丢弃它们。最后，我们创建了一系列地图工具，允许用户在地图层内添加、编辑和删除点、线字符串和多边形几何形状。
- en: Putting all these tools together, your PyQGIS application can sport a complete
    range of selection- and geometry-editing features. In the final two chapters of
    this book, we will use these tools together with the knowledge we gained in the
    previous chapters, to build a complete standalone mapping application using Python
    and QGIS.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有这些工具整合在一起，您的PyQGIS应用程序将具备一套完整的选区和几何编辑功能。在本书的最后两章中，我们将使用这些工具，结合前几章所获得的知识，利用Python和QGIS构建一个完整的独立地图应用程序。
