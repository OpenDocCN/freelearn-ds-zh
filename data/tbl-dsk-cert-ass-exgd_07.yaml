- en: Understanding Simple Calculations in Tableau
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Tableau中理解简单计算
- en: In the previous chapters, you have learned much about visualizing data in various
    forms in Tableau. It is common to have cases where the data you want to visualize
    is not directly present in your dataset but can easily be obtained by applying
    transformations on the dataset or even aggregating the data in the dataset. For
    example, you may have the full address for a placed order, and you want to obtain
    only the country or city where the order came from. Alternatively, you may have
    data for each individual sale and you want to know the average of all sales. This
    and the subsequent two chapters will focus on calculations and how you can use
    these to answer such questions. This chapter will introduce calculations and cover
    simple calculations, while the next two will look at more advanced calculations.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，你已经学习了在Tableau中用各种形式可视化数据。通常情况下，你想要可视化的数据可能不会直接出现在你的数据集中，但可以通过对数据集应用转换或甚至聚合数据集中的数据来轻松获得。例如，你可能有一个订单的完整地址，但你只想获取订单来自的国家或城市。或者，你可能拥有每个单独销售的详细数据，你想知道所有销售的平均值。接下来的两个章节将重点介绍计算以及如何使用这些计算来回答这样的问题。本章将介绍计算，并涵盖简单计算，而下一章将探讨更高级的计算。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Calculation basics
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算基础
- en: Creating calculations and understanding their components
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建计算并理解其组件
- en: Building arithmetic calculations
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建算术计算
- en: Building string calculations
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建字符串计算
- en: Building date calculations
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建日期计算
- en: Building logical statements
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建逻辑语句
- en: Building grand totals and subtotals
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建总计和子总计
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'This chapter uses the following dataset:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章使用以下数据集：
- en: The Global Superstore dataset, which can be found at [http://www.tableau.com/sites/default/files/training/global_superstore.zip](http://www.tableau.com/sites/default/files/training/global_superstore.zip).
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全球超级商店数据集，可以在[http://www.tableau.com/sites/default/files/training/global_superstore.zip](http://www.tableau.com/sites/default/files/training/global_superstore.zip)找到。
- en: Calculation basics
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算基础
- en: Calculations allow us to obtain more data points from the existing dataset and
    allow us to enhance our visualizations and analysis. Creating calculations in
    Tableau enables you to analyze data on the fly, without having to create overheads
    by transforming your original datasets every time you have a new idea about how
    you can analyze your data even further.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 计算使我们能够从现有数据集中获得更多数据点，并允许我们增强我们的可视化和分析。在Tableau中创建计算可以使你即时分析数据，无需每次有关于如何进一步分析数据的想法时都创建额外的数据集。
- en: When to use calculations
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 何时使用计算
- en: 'Before we dive into calculations and how to create them, it is equally important
    to understand when to create calculations. Some examples of when calculations
    are useful are as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨计算及其创建方法之前，同样重要的是要了解何时创建计算。以下是一些计算有用的例子：
- en: '**Changing datatypes**: For example, you have data that is being represented
    as a string value.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更改数据类型**：例如，你有的数据被表示为字符串值。'
- en: '**Performing mathematical calculations**: For example, you want to divide two
    fields to obtain ratios or percentages or subtract fields.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**执行数学计算**：例如，你想要将两个字段相除以获得比率或百分比，或者从字段中减去。'
- en: '**To create logical groupings/labels**: For example, if you want to group people
    in those who can drive or not, you can create a calculation saying: if you are
    older than 18 and have a valid driving license, you can drive.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建逻辑分组/标签**：例如，如果你想将人们分为能开车和不能开车两组，你可以创建一个计算公式说：如果你年满18岁并且拥有有效的驾驶执照，你就可以开车。'
- en: '**To create new fields from existing data**: For example, you want to create
    a country field by extracting a part of the address or a new date field from another
    date field.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**从现有数据创建新字段**：例如，你想要通过提取地址的一部分来创建国家字段，或者从一个日期字段创建新的日期字段。'
- en: '**Aggregating data**: For example, you want to view the sum, average, and median
    of distribution or subtotals and totals at the country and city levels for sales.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**聚合数据**：例如，你想要查看分布或国家/城市级别的销售的总和、平均值和中位数。'
- en: Now that we understand when to use calculations, we can discuss the three types
    of calculations available in Tableau.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了何时使用计算，我们可以讨论Tableau中可用的三种计算类型。
- en: Types of calculations
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算类型
- en: '**Simple calculations**: These calculations allow you to create new fields
    at either the same level of granularity as your dataset (row-level) or aggregate
    data at the granularity of the visual.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简单计算**：这些计算允许你在数据集的相同粒度级别（行级）或视觉粒度上聚合数据来创建新的字段。'
- en: '**Level Of Detail (LOD) expressions**: LOD calculations are an extension of
    simple calculations but allow you to have more control over the granularity of
    the data you are working on. You have options to work to specify a FIXED level
    of granularity or INCLUDE data fields to the visualization granularity or EXCLUDE
    them.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**细节级别（LOD）表达式**：LOD计算是简单计算的扩展，但允许你更多地控制你正在处理的数据的粒度。你有选项来指定一个固定的粒度级别或将数据字段包含到可视化粒度中或排除它们。'
- en: '**Table calculations**: Table calculations only work at the level of granularity
    of the visuals. These allow you to build calculations at visual levels of top
    of your existing data or simple calculations.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**表计算**：表计算仅在视觉的粒度级别上工作。这些计算允许你在现有数据或简单计算的基础上构建视觉级别的计算。'
- en: The type of calculation you require will depend on the use case of your problem.
    If you already have all of the data you want to answer the questions, then you
    need table calculations. If you do not have all of the data you need, but the
    data needed will be at the same granularity as your dataset, you will need a basic
    calculation. Otherwise, it will be a LOD calculation.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要的计算类型将取决于你问题的用例。如果你已经有了所有你想回答问题的数据，那么你需要表计算。如果你没有所有你需要的数据，但所需的数据将与数据集的粒度相同，你需要基本计算。否则，它将是一个LOD计算。
- en: Do not worry if you are a bit confused about the types of calculations. We will
    cover each type in detail in separate chapters. This chapter will cover simple
    calculations in detail while the next two will cover the other two calculation
    types. So, let's look at how to create simple calculations.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对于计算类型有点困惑，不要担心。我们将在单独的章节中详细讲解每种类型。本章将详细讲解简单计算，而接下来的两个章节将讲解其他两种计算类型。所以，让我们看看如何创建简单计算。
- en: Creating calculations
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建计算
- en: To create a calculation, click on **Analysis** | **Create Calculated Field**.
    Alternatively, you can scroll to the end of dimensions/measures tabs and right-click
    in the white space there.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个计算，请点击**分析** | **创建计算字段**。或者，你可以滚动到维度/度量标签的末尾，并在那里的空白处右键单击。
- en: 'You should see the following calculations window:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到以下计算窗口：
- en: '![](img/14c57d5b-0278-4d24-a661-b18a0da00be4.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/14c57d5b-0278-4d24-a661-b18a0da00be4.png)'
- en: The top of the window, where it says `Calculation1`, is where you enter the
    name of your calculated field. The blank area underneath is where you enter your
    calculation. To the right side, you have a list of all of the available functions
    you can use and their syntax to quickly help you out. The tiny triangle icon to
    the right of the calculation editor can be used to toggle the functions window
    in/out.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 窗口的顶部，写着`Calculation1`的地方是你输入计算字段名称的地方。下面的空白区域是你输入计算的地方。右侧，有一个你可以使用的所有可用函数及其语法的列表，以快速帮助你。计算编辑器右侧的小三角形图标可以用来切换函数窗口的打开和关闭。
- en: 'Let''s create a very simple calculation to see what our total profit would
    be if the average profit increased four times, and name this calculation `4x Profit`,
    as shown in the following screenshot:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个非常简单的计算，看看如果平均利润增加四倍，我们的总利润会是多少，并将这个计算命名为`4x 利润`，如下面的截图所示：
- en: '![](img/2154dc36-c4f1-4c5e-941f-30dd72111f41.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2154dc36-c4f1-4c5e-941f-30dd72111f41.png)'
- en: You will see, at the bottom of the calculation, the message: **The calculation
    is valid**. This means we can now click **OK** and the field will be created.
    The error checker in Tableau quickly displays error messages below if the calculation
    is invalid, allowing for easy troubleshooting.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你会在计算的底部看到这样的信息：**计算有效**。这意味着我们现在可以点击**确定**，字段将被创建。如果计算无效，Tableau中的错误检查器会快速显示错误信息，便于轻松排查问题。
- en: 'Once you click **OK**, you will notice the field appears under **Measures**.
    Now, you can use this calculation as you would any other measure. Let''s use it
    to show the results per **Segment**:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你点击**确定**，你会注意到字段出现在**度量**下。现在，你可以像使用任何其他度量一样使用这个计算。让我们用它来按**段**显示结果：
- en: '![](img/a29046db-8ca1-4507-9b62-a4153a30226a.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a29046db-8ca1-4507-9b62-a4153a30226a.png)'
- en: 'Like the previously discussed calculation, all calculations in Tableau can
    be a combination of six basic elements. These elements are described in the following
    table:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前讨论的计算一样，Tableau 中的所有计算都可以是六个基本元素的组合。以下表格描述了这些元素：
- en: '| **Components** | **Description** | **Example** |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| **组件** | **描述** | **示例** |'
- en: '| Functions | Functions are used to transform the values or members of a field.
    There are many types of functions available in Tableau such as `Number`, `String`,
    `Date`, and `User`. Different functions have different syntax, inputs/data type
    expected, and so on. | In our example, `AVG()` was an example of a function. |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| 函数 | 函数用于转换字段的值或成员。Tableau 中有许多类型的函数，例如 `Number`、`String`、`Date` 和 `User`。不同的函数有不同的语法、期望的输入/数据类型等。
    | 在我们的示例中，`AVG()` 是函数的一个示例。|'
- en: '| Fields | Fields represent the dimensions or measures (columns) from our data
    source. | `[Profit]` was the field used by us. |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| 字段 | 字段代表数据源中的维度或度量（列）。 | 我们使用的字段是 `[Profit]`。|'
- en: '| Operators | Operators are symbols that denote some kind of operation. Operators
    can be one of the following: +, -, *, /, %, ==, =, >, <, >=, <=, !=, <>, ^, AND,
    OR, NOT, and ( ). | * in our example was the operator. |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| 操作符 | 操作符是表示某种操作的符号。操作符可以是以下之一：+、-、*、/、%、==、=、>、<、>=、<=、!=、<>、^、AND、OR、NOT
    和 ( )。 | 在我们的示例中，* 是操作符。|'
- en: '| Literal expressions | These are constant values that do not change. These
    can be either Numeric, String, Date, Boolean, or Null. | 4 was the literal used
    by us. |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 文字表达式 | 这些是不变的常量值，不会改变。这些可以是数值、字符串、日期、布尔值或空值。 | 我们使用的文字是 4。|'
- en: '| Parameters | Parameters, as we know, are dynamic values that can replace
    literals. These too can be used in the calculations. |  |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 正如我们所知，参数是动态值，可以替换文字。这些也可以用于计算。 |  |'
- en: '| Comments | Comments are simple descriptions that you can add to the calculation
    fields. These are informational only and do not affect the actual calculation.
    The `//` symbols are used to add comments. | We didn''t add a comment to our example,
    but we could have added something like `// To create 4 times profit value`. |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 注释 | 注释是您可以添加到计算字段中的简单描述。这些仅用于信息目的，不会影响实际计算。使用 `//` 符号添加注释。 | 我们没有在我们的示例中添加注释，但我们可以添加类似
    `// To create 4 times profit value` 的内容。|'
- en: Using the preceding combination of six elements, all calculations are created.
    Now that we understand the components better, we can look at the syntax of each
    component in detail in the following sections.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面提到的六个元素组合，所有计算都是创建的。现在我们更好地理解了组件，我们可以在以下部分详细查看每个组件的语法。
- en: Functions syntax
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数语法
- en: 'There are many types of functions available in Tableau, such as `Number`, `String`,
    `Date`, and `User`. Different functions have different syntax and require different
    inputs for them to work. The list of all of the functions available to you in
    Tableau is available in the side tab of the calculated field window. Select `AVG()`
    from the functions list. Once you select any function, you will see three elements
    in the help window:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Tableau 中有许多可用的函数类型，例如 `Number`、`String`、`Date` 和 `User`。不同的函数有不同的语法，并且需要不同的输入才能正常工作。您在
    Tableau 中可用的所有函数列表可在计算字段窗口的侧边标签中找到。从函数列表中选择 `AVG()`。一旦选择任何函数，您将在帮助窗口中看到三个元素：
- en: '![](img/bfbd0dcc-45fd-4a84-a6f7-52ee74cf4010.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bfbd0dcc-45fd-4a84-a6f7-52ee74cf4010.png)'
- en: 'These elements are as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这些元素如下：
- en: 'Syntax of the function: For `AVG`, it shows **AVG(expression)**, meaning that,
    to obtain the average, you need to write AVG(expression here).'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数的语法：对于 `AVG`，它显示为 **AVG(expression)**，这意味着要获取平均值，您需要在这里写上 AVG(expression)。
- en: 'Explanation: Below the syntax, there is an explanation of what the function
    does.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 说明：在语法下方，是对函数功能的解释。
- en: 'Example: This is an example of how the function can be used.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例：这是函数如何使用的示例。
- en: If you are unsure of how to use a function, copy and paste the example, and
    then replace the fields in it with your own fields. This ensures that the syntax
    remains correct.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不确定如何使用函数，可以复制并粘贴示例，然后用您自己的字段替换其中的字段。这确保了语法的正确性。
- en: You can use more than one function in a calculation and even nest them inside
    one another as long as they meet the syntax requirements. We will learn about
    some of the common types of functions later in this chapter.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在计算中使用多个函数，甚至可以将它们嵌套在一起，只要它们满足语法要求。我们将在本章后面学习一些常见的函数类型。
- en: Fields syntax
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字段语法
- en: 'Fields are the columns in the data (and can be calculated fields too). A field
    should always be surrounded by square brackets, `[]`, if they contain spaces or
    are not unique in name. It is best practice to surround fields with `[]`. Fields
    are shown in orange in Tableau. You can drag and drop the field directly into
    the calculation from the **Dimension** or **Measures** tabs. Alternatively, you
    can start typing the field name and Tableau will show you options to autocomplete
    fields, as shown in the following screenshot:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 字段是数据中的列（也可以是计算字段）。如果字段包含空格或名称不唯一，则应始终用方括号 `[]` 包围。最佳实践是使用 `[]` 包围字段。在 Tableau
    中，字段以橙色显示。您可以直接从 **维度** 或 **度量** 选项卡将字段拖放到计算中。或者，您可以开始键入字段名称，Tableau 将显示自动完成字段的选项，如下面的截图所示：
- en: '![](img/29da1d43-a473-4afe-9c49-f80356ab1984.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/29da1d43-a473-4afe-9c49-f80356ab1984.png)'
- en: Operator syntax
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运算符语法
- en: 'Operators are symbols that denote some kind of operation. Operators can be
    of the following types:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 运算符是表示某种操作的符号。运算符可以是以下类型：
- en: 'Mathematical operators: Mathematical operators are used for performing mathematical
    calculations. The operators are as follows:'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数学运算符：用于执行数学计算。运算符如下：
- en: '**+ (plus)**: Plus can be used for addition (numeric and date fields) and string
    concatenation. For example, `4+2` will return `6` while `Abc` + `Def` will return
    `AbcDef`. We can use addition for dates as well, for example, adding `#23-04-2019#+4`
    will give `#27-04-2019#`.'
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**+ (加法)**: 加法可用于加法（数值和日期字段）和字符串连接。例如，`4+2` 将返回 `6`，而 `Abc` + `Def` 将返回 `AbcDef`。我们还可以使用加法进行日期计算，例如，添加
    `#23-04-2019#+4` 将给出 `#27-04-2019#`。'
- en: '**- (minus)**: Minus can be used for the subtraction of dates and numeric fields,
    in a similar way to the + operator.'
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**- (减法)**: 减法可用于日期和数值字段的减法，与加法运算符类似。'
- en: '*** (multiplication)** and **/ (division)**: This is used to multiply or divide
    numeric fields.'
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*** (乘法)** 和 **/ (除法)**: 这用于乘除数值字段。'
- en: '**% (modulo)**: This returns the remainder of a division operator, for example, `5%2=1`.'
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**% (取模)**: 返回除法运算符的余数，例如，`5%2=1`。'
- en: '**^ (power/exponent):** This returns the exponent value, for example, `2^3
    =8`.'
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**^ (幂/指数):** 这返回指数值，例如，`2^3 =8`。'
- en: 'Relational operators: These are used for comparing expressions and return `TRUE`,
    `FALSE`, or `NULL` values. Each operator can be used to compare numbers, dates,
    or strings. The operators are as follows:'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关系运算符：用于比较表达式，并返回 `TRUE`、`FALSE` 或 `NULL` 值。每个运算符都可以用于比较数字、日期或字符串。运算符如下：
- en: '**== or = (equals)**'
  id: totrans-69
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**== 或 = (等于)**'
- en: '**> ( greater than) **'
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**> (大于)**'
- en: '**< (less than)**'
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**< (小于)**'
- en: '**>= (greater than or equal to)**'
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**>= (大于或等于)**'
- en: '**<= (less than or equal to)**'
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<= (小于或等于)**'
- en: '**!=** and **<> (not equal to)**'
  id: totrans-74
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**!=** 和 **<> (不等于)**'
- en: 'Logical operators: Logical operators compare both sides of the expression and
    return `TRUE`, `FALSE`, or `NULL` values. The logical operators are as follows:'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逻辑运算符：逻辑运算符比较表达式的两边，并返回 `TRUE`、`FALSE` 或 `NULL` 值。逻辑运算符如下：
- en: '**AND**: If both expression 1 and expression 2 are `TRUE`, then it returns
    `TRUE`; otherwise, it returns `FALSE`. If any of the expressions are `NULL`, then
    it returns `NULL`. `AND` follows the following rules for output:'
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AND**: 如果表达式 1 和表达式 2 都是 `TRUE`，则返回 `TRUE`；否则，返回 `FALSE`。如果任一表达式为 `NULL`，则返回
    `NULL`。`AND` 的输出遵循以下规则：'
- en: '| **Expression 1** | **Expression 2** | **Output** |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| **表达式 1** | **表达式 2** | **输出** |'
- en: '| `TRUE` | `TRUE` | `TRUE` |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `TRUE` | `TRUE` | `TRUE` |'
- en: '| `TRUE` | `FALSE`/`NULL` | `FALSE`/`NULL` |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `TRUE` | `FALSE`/`NULL` | `FALSE`/`NULL` |'
- en: '| `FALSE`/`NULL` | `TRUE` | `FALSE`/`NULL` |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `FALSE`/`NULL` | `TRUE` | `FALSE`/`NULL` |'
- en: '| `FALSE`/`NULL` | `FALSE`/`NULL` | `FALSE`/`NULL` |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `FALSE`/`NULL` | `FALSE`/`NULL` | `FALSE`/`NULL` |'
- en: '**OR:** `OR` returns `FALSE` only if both the expressions are `FALSE`; otherwise,
    it will return `TRUE`. It returns `NULL` only if both values are `NULL`. It follows
    the following rules for output:'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OR:** `OR` 仅在两个表达式都是 `FALSE` 时返回 `FALSE`；否则，返回 `TRUE`。如果两个值都是 `NULL`，则返回
    `NULL`。它遵循以下输出规则：'
- en: '| **Expression 1** | **Expression 2** | **Output** |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| **表达式 1** | **表达式 2** | **输出** |'
- en: '| `TRUE` | `TRUE` | `TRUE` |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `TRUE` | `TRUE` | `TRUE` |'
- en: '| `TRUE` | `FALSE`/`NULL` | `TRUE` |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `TRUE` | `FALSE`/`NULL` | `TRUE` |'
- en: '| `FALSE`/`NULL` | `TRUE` | `TRUE` |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `FALSE`/`NULL` | `TRUE` | `TRUE` |'
- en: '| `FALSE`/`NULL` | `FALSE`/`NULL` | `FALSE`/`NULL` |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `FALSE`/`NULL` | `FALSE`/`NULL` | `FALSE`/`NULL` |'
- en: '**NOT:** `NOT` is used to negate other Booleans or expressions. It follows
    the following rules of output:'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NOT:** `NOT` 用于否定其他布尔值或表达式。它遵循以下输出规则：'
- en: '| **Expression 1** | **Expression 2** |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| **表达式 1** | **表达式 2** |'
- en: '| `TRUE` | `FALSE` |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `TRUE` | `FALSE` |'
- en: '| `FALSE` | `TRUE` |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `FALSE` | `TRUE` |'
- en: Order of precedence of operators
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运算符的优先级顺序
- en: 'The operators get evaluated in the following order of precedence:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 运算符的评估顺序如下：
- en: '`–` (negate)'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`–`（取反）'
- en: '`^` (power)'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`^`（幂）'
- en: '`*`, `/`, `%`'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`*`, `/`, `%`'
- en: '`+`, `–`'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`+`, `–`'
- en: '`==`, `>`, `<`, `>=`, `<=`, `!=`'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`==`, `>`, `<`, `>=`, `<=`, `!=`'
- en: '`NOT`'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`NOT`'
- en: '`AND`'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`AND`'
- en: '`OR`'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`OR`'
- en: To change the order of precedence, we can use the final operator called parentheses, `()`.
    If you put something in parentheses, it gets executed first. If there are nested
    parentheses, then the innermost gets executed first and so on, for example, if
    we had the following expression to get evaluated: `(1+2*5) = 11 , (1+(2*5)/2)
    = (1+10/2) =6`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 要改变运算符的优先级顺序，我们可以使用最后的运算符，即括号，`()`。如果你把某样东西放在括号里，它将首先被执行。如果有嵌套的括号，则最内层的括号将首先执行，依此类推，例如，如果我们有以下表达式需要评估：`(1+2*5)
    = 11 , (1+(2*5)/2) = (1+10/2) =6`。
- en: Literal expressions syntax
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字面表达式语法
- en: 'Literal expressions are constant values that are represented as is. Literals
    are of the following types:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 字面表达式是按原样表示的常量值。字面量有以下类型：
- en: '**Numeric literals**: Numbers or floats such as `4.2` and `2`'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数值字面量**：数字或浮点数，例如 `4.2` 和 `2`'
- en: '**String literals**: Constant strings such as `Hello`'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**字符串字面量**：常量字符串，例如 `Hello`'
- en: '**Date literals**: Represent dates as constants, such as `#20-05-2019#`'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**日期字面量**：将日期表示为常量，例如 `#20-05-2019#`'
- en: '**Boolean literals**: Represent Boolean values of `TRUE` or `FALSE`'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**布尔字面量**：表示 `TRUE` 或 `FALSE` 的布尔值'
- en: '**Null literals**: Used to assign or compare against `NULL`'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**空字面量**：用于赋值或比较 `NULL`'
- en: Parameter syntax
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参数语法
- en: Parameters are simply placeholder variables. Parameters are represented with
    the color purple in Tableau. They can represent numbers, floats, strings, date/date-time
    values, or Booleans.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 参数是简单的占位符变量。在 Tableau 中，参数以紫色表示。它们可以代表数字、浮点数、字符串、日期/日期时间值或布尔值。
- en: Comments syntax
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注释语法
- en: Comments are represented using `//`. To add multiline comments, add `//` in
    every line.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 注释使用 `//` 表示。要添加多行注释，每行都添加 `//`。
- en: Now that we understand all about the basic elements of what constitutes calculated
    fields and how to create them, let's dive into some calculations.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了构成计算字段的基本元素及其创建方法，让我们深入探讨一些计算。
- en: Building arithmetic calculations
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建算术计算
- en: To work with arithmetic calculations in Tableau, we can either use operators
    as discussed in the last section, work with one of the many **number functions**
    that are present, or make use of some of the **aggregation options**. This section
    will cover some of the important functions but it is not an exhaustive list. The
    *Further reading* section contains links to an A-Z list of functions maintained
    by Tableau.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Tableau 中处理算术计算，我们可以使用上一节中讨论的运算符，使用其中许多 **数字函数** 之一，或者利用一些 **聚合选项**。本节将介绍一些重要函数，但不是完整的列表。*进一步阅读*部分包含到
    Tableau 维护的函数 A-Z 列表的链接。
- en: Aggregation options
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 聚合选项
- en: Aggregation options define how your data values are combined or aggregated.
    Simple aggregation works at the level of visual granularity.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合选项定义了你的数据值是如何组合或聚合的。简单的聚合在视觉粒度级别上工作。
- en: 'What this means is the data is aggregated at the level of the dimensions in
    the visual. Without even studying it, we have used this logic in the previous
    chapters when we created visuals. Whenever we wanted to see the total **SUM(Sales)**,
    we would only bring the **SUM(Sales)** measure to our visual window. However,
    if we wanted to see the sales per segment, we would add the **Segment** dimension
    to our window and our sales would split up, as can be seen in the following screenshot:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着数据在视觉的维度级别上进行了聚合。即使不进行研究，我们在前几章创建视觉时已经使用了这种逻辑。每当我们想看到总 **SUM(Sales)** 时，我们只会将
    **SUM(Sales)** 测量值带到我们的视觉窗口中。然而，如果我们想看到按段的销售，我们会在窗口中添加 **Segment** 维度，我们的销售将细分，如下面的截图所示：
- en: '![](img/2754ca91-c279-4005-8160-28ab086f57c9.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2754ca91-c279-4005-8160-28ab086f57c9.png)'
- en: 'This same principle works with all the aggregations. To see the aggregation
    levels available, right-click on the measured field, select **Measure** (aggregation
    level) and it will show you what other options are available. For example, by
    right-clicking on the **SUM(Sales)** measure field, the following aggregation
    levels are available:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这个原则同样适用于所有聚合操作。要查看可用的聚合级别，右键单击测量字段，选择 **测量**（聚合级别），它将显示其他可用的选项。例如，通过右键单击 **SUM(Sales)**
    测量字段，以下聚合级别是可用的：
- en: '![](img/1933a496-7590-44a0-a4e9-9d507129ac4c.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1933a496-7590-44a0-a4e9-9d507129ac4c.png)'
- en: Similarly, if you want to use a dimension field to represent a measure value,
    you can bring it into the visual and right-click and select **Measure**, and then
    it will show the aggregation options available for the dimension.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，如果您想使用维度字段来表示度量值，可以将它拖入视觉中，然后右键单击并选择 **度量**，然后它将显示维度可用的聚合选项。
- en: 'Assuming a column in our dataset looks like `1, 1, 1, 2, 2, 3, 4`, the various
    aggregation options and their results are as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的数据集中的一个列看起来像 `1, 1, 1, 2, 2, 3, 4`，各种聚合选项及其结果如下：
- en: '| **Sum** | This adds the measure values, calculated by adding values = `1+1+1+2+2+3+4
    = 14`. |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| **总和** | 这是通过将值相加得到的度量值，计算为 = `1+1+1+2+2+3+4 = 14`。 |'
- en: '| **Average** | This is the average of the measure values, calculated by adding
    values divided by the count of values = `14/7 = 2`. |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| **平均值** | 这是度量值的平均值，通过将值相加除以值的计数来计算 = `14/7 = 2`。 |'
- en: '| **Median** | This is the central value = `2`. |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| **中位数** | 这是中心值 = `2`。 |'
- en: '| **Count** | This simply counts the number of elements = `7`. |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| **计数** | 这只是简单地计算元素的数量 = `7`。 |'
- en: '| **Count** **(Distinct)** | This is the count of distinct values, so no same
    value is counted more than once = `4`. |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| **计数** **（唯一）** | 这是唯一值的计数，因此不会对相同的值进行多次计数 = `4`。 |'
- en: '| **Minimum** | This the least value = `1`. |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| **最小值** | 这是最低值 = `1`。 |'
- en: '| **Maximum** | This is the highest value = `4`. |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| **最大值** | 这是最高值 = `4`。 |'
- en: '| **Percentile** | This shows what percentage of the values are less than this
    value. It has further options to look at the 5, 10, 25, 50, 75, 90, and 95 percentiles.
    Here, the 25^(th) percentile would be 1, the 75^(th) percentile would be 3, and
    so on. |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| **百分位数** | 这显示了低于此值的值的百分比。它有进一步查看5、10、25、50、75、90和95百分位数的选项。在这里，第25百分位数将是1，第75百分位数将是3，依此类推。
    |'
- en: '| **Standard Deviation**, **Standard Deviation(Pop)** | Standard deviation
    defines how much of the members are differing from the mean value. If you have
    an entire dataset, use the standard deviation population; if it is a sample, then
    use standard deviation. **Standard deviation (Pop) **= `1.07` |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| **标准差**, **标准差（总体）** | 标准差定义了成员与平均值差异的程度。如果您有一个完整的数据集，请使用总体标准差；如果是样本，则使用标准差。**标准差（总体）**
    = `1.07` |'
- en: '| **Variance**, **Variance (Pop)** | Variance is the square of standard deviation,
    so depending on population or sample, we use variance = `1.14` for this case.
    |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| **方差**, **方差（总体）** | 方差是标准差的平方，因此根据总体或样本，我们使用方差 = `1.14` 来计算此案例。 |'
- en: The aggregations calculated in Tableau are sent back to the databases for querying.
    So, the general rule of thumb is if the database doesn't support a particular
    aggregation, Tableau will not be able to support it either. However, if you create
    extracts of the same data, then the aggregation will be supported.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Tableau 中计算的聚合被发送回数据库进行查询。因此，一般规则是如果数据库不支持特定的聚合，Tableau 也不会支持它。然而，如果您创建了相同数据的提取，则聚合将得到支持。
- en: As an exercise, look at all of the aggregation options for the `Profit` measure and
    the `Customer Name` dimension.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，查看 `利润` 度量值和 `客户名称` 维度的所有聚合选项。
- en: By simply using a combination of the preceding aggregation options and operators,
    many important calculations can be done. For example, `Cost` can be determined
    as `[Sales]-[Profit]`. Then, the average cost can be found with `AVG(Cost)`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 通过简单地使用前面聚合选项和运算符的组合，可以完成许多重要计算。例如，`成本` 可以确定为 `[Sales]-[Profit]`。然后，可以通过 `AVG(Cost)`
    找到平均成本。
- en: We can also calculate the `Profit to Sales` ratio as `SUM(Profit)/SUM(Sales)`.
    This will show up in decimals. To see it as a percentage, one way would be to
    multiply the calculation by 100\. However, this will not show the `%` sign. To
    show the percentage sign, we need to format the results as a percentage. To do
    this, right-click on **Measure** and select **Format**. A side window will appear.
    Here, under **Default**, click on **Numbers** and then **Percentage**.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以计算 `利润/销售额` 比率，计算公式为 `SUM(Profit)/SUM(Sales)`。这将显示为小数。要将其显示为百分比，一种方法是将计算乘以100。然而，这将不会显示
    `%` 符号。要显示百分号，我们需要将结果格式化为百分比。为此，右键单击 **度量** 并选择 **格式**。将出现一个侧边窗口。在这里，在 **默认**
    下，单击 **数字** 然后单击 **百分比**。
- en: You can also include other things such as a suffix/prefix by using custom options.
    Once you are happy, you can close the side window.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过使用自定义选项包括其他内容，例如后缀/前缀。一旦您满意，您可以关闭侧边窗口。
- en: 'Beyond the aggregations and operator use, we can look at other number functions
    available. They can be logically grouped into the following categories:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 除了聚合和运算符的使用之外，我们还可以看看其他可用的数字函数。它们可以逻辑地分为以下类别：
- en: '**Trigonometric functions**: These include the following:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '**三角函数**：这些包括以下内容：'
- en: '| `PI` | This returns the numeric constant value for pi, as 3.141592…., up
    to 16 decimal places. `PI()` is generally used within other trigonometric functions
    to specify the angles in radians. |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| `PI` | 这返回了圆周率π的数值常量，精确到16位小数，例如3.141592……。`PI()`通常用于其他三角函数中，以指定弧度角度。|'
- en: '| `SIN` | This returns the sine of an angle. The angle must be specified in
    radians, for example, `SIN(-PI()/4) =-0.7071`. |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| `SIN` | 这返回一个角度的正弦值。角度必须以弧度指定，例如，`SIN(-PI()/4) =-0.7071`。|'
- en: '| `ASIN` | This returns the arc sine of a number in radians. This is the inverse
    of `SIN`, for example, `ASIN(-0.7071)=-0.7854` (which is *-pi/4*). |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| `ASIN` | 这返回一个数的弧度正弦值。这是 `SIN` 的反函数，例如，`ASIN(-0.7071)=-0.7854`（即 *-pi/4*）。|'
- en: '| `ATAN2` | This takes the two coordinate positions *y* and *x* as input and
    returns the arc tangent of two numbers in radians, for example, `ATAN2(1,1) =
    0.7854 i.e pi/4` |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| `ATAN2` | 这接受两个坐标位置 *y* 和 *x* 作为输入，并返回两个数的弧度反正切值，例如，`ATAN2(1,1) = 0.7854
    i.e pi/4`。|'
- en: '| `DEGREE` | This converts radians into degrees, so `DEGREE(0.7854) =45`..
    |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| `DEGREE` | 这将弧度转换为度，所以 `DEGREE(0.7854) =45`。|'
- en: '** The COS, ACOS, TAN, ATAN, and COT functions are similar to SIN and ASIN.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '**COS, ACOS, TAN, ATAN, 和 COT 函数与 SIN 和 ASIN 类似。|'
- en: '**Logarithmic and exponential functions**: These include the following:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**对数和指数函数**：这些包括以下内容：'
- en: '| `EXP` | This returns *e* raised to the power of a number, for example, `EXP(2)
    = e^2`. |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| `EXP` | 这返回数字的e的幂，例如，`EXP(2) = e^2`。|'
- en: '| `LN` | This returns the natural logarithm of the number. The value is null
    for all zero and negative values, for example, `LN(2) = 0.69` or `LN(EXP(2))=2`.
    |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| `LN` | 这返回数字的自然对数。对于所有零和负值，值是null，例如，`LN(2) = 0.69` 或 `LN(EXP(2))=2`。|'
- en: '| `LOG` | This returns a logarithmic value to the base of another number. If
    no base is specified, then it returns a logarithmic value to the base of 100,
    for example, `LOG(1000) = 3` and `LOG( 4,2) = 2`. |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| `LOG` | 这返回以另一个数为底的对数值。如果没有指定底数，则返回以100为底的对数值，例如，`LOG(1000) = 3` 和 `LOG(
    4,2) = 2`。|'
- en: '| `POWER` | This returns a value to the power of another, for example, `POWER
    (2,3) =2^3= 8`. |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| `POWER` | 这返回另一个数的幂，例如，`POWER (2,3) =2^3= 8`。|'
- en: '**Other mathematical functions**: These include the following:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**其他数学函数**：这些包括以下内容：'
- en: '| `SQUARE` | This returns the square of a number and is equivalent to `Power
    (number, 2)`, for example, `SQUARE(5) = 25`. |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| `SQUARE` | 这返回一个数的平方，相当于 `Power (number, 2)`，例如，`SQUARE(5) = 25`。|'
- en: '| `SQRT` | This returns the square root of a number and is equivalent to `Power
    (number, 0.5)`, for example, `SQRT(25) =5`. |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| `SQRT` | 这返回一个数的平方根，相当于 `Power (number, 0.5)`，例如，`SQRT(25) =5`。|'
- en: '| `ABS` | This returns the absolute value of a number, for example, `ABS(-7)
    =7`. It''s very useful when you work with quantities or deviations where the actual
    values are more important than the sign of the numbers. |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| `ABS` | 这返回一个数的绝对值，例如，`ABS(-7) =7`。当处理数量或偏差时，实际值比数字的符号更重要时，非常有用。|'
- en: '| `CEILING` | This rounds a number to the nearest integer greater or equal
    to the number. This is useful when doing capacity planning kind of problems, for
    example, if you had to assign resources to a project to get work completed and
    the result was `3.2`. If you simply round the number, your result would be `3`.
    But you actually have more work, so it makes more sense to have four resources
    than three and plan based on that, for example, `CEILING(3.2) = 4`. |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| `CEILING` | 这将一个数字四舍五入到最接近的整数，大于或等于该数字。这在做容量规划等问题时很有用，例如，如果你需要分配资源到项目中以完成工作，结果是`3.2`。如果你简单地四舍五入这个数字，你的结果将是`3`。但实际上你有更多的工作要做，所以有四个资源比三个更有意义，并据此进行规划，例如，`CEILING(3.2)
    = 4`。|'
- en: '| `FLOOR` | `FLOOR` does the reverse of `CEILING`. It returns the greatest
    integer smaller or equal to the given number, for example, `FLOOR(3.2) =3`. |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| `FLOOR` | `FLOOR` 是 `CEILING` 的反操作。它返回小于或等于给定数字的最大整数，例如，`FLOOR(3.2) =3`。|'
- en: '| `ROUND` | This rounds the number to the nearest integer or the specified
    decimal values, for example, `ROUND (3.2)=3`, `ROUND(3.7) = 4`, and `ROUND(3.1421,2)
    = 3.14`. |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| `ROUND` | 这将数字四舍五入到最接近的整数或指定的十进制值，例如，`ROUND (3.2)=3`，`ROUND(3.7) = 4`，和 `ROUND(3.1421,2)
    = 3.14`。|'
- en: '| `SIGN` | This returns the sign of the number, 1 if positive, 0 if zero, and
    -1 if negative, for example, `SIGN(-3)=-1` and `SIGN(4) =1`. |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| `SIGN` | 这返回数字的符号，如果为正数则返回 1，如果为零则返回 0，如果为负数则返回 -1，例如，`SIGN(-3)=-1` 和 `SIGN(4)
    =1`。 |'
- en: '| `ZN` | This returns the expression if it is not null; otherwise, it will
    return 0\. This is useful if we want to calculate averages, without ignoring `NULL`
    or to display 0s instead of nulls.  |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| `ZN` | 如果表达式不是空值，则返回表达式；否则，将返回 0。这在我们要计算平均值时非常有用，既不忽略 `NULL`，也显示 0 而不是空值。
    |'
- en: '| `DIV` | This returns the quotient of a division operation, for example, `DIV(7,2)
    =3`. |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| `DIV` | 这返回除法操作的商，例如，`DIV(7,2) =3`。 |'
- en: '| `HEXBINX`, `HEXBINY` | Both of these functions are used to map an *x*, *y*
    coordinate to the nearest hexagonal bin. `HENBINX` maps to the nearest *x *coordinate
    while `HEXBINY` maps the nearest *y *coordinate. The bins have side length 1,
    so the inputs need to be scaled accordingly.  |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| `HEXBINX`, `HEXBINY` | 这两个函数都用于将 *x*，*y* 坐标映射到最近的六边形网格。`HENBINX` 映射到最近的 *x*
    坐标，而 `HEXBINY` 映射到最近的 *y* 坐标。网格的边长为 1，因此输入需要相应地缩放。 |'
- en: Now that we are familiar with the various aggregation options and number functions
    that can be used to create numeric calculations, let's move on to the next section
    where we will learn about string calculations.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们熟悉了可以用于创建数值计算的多种聚合选项和数字函数，让我们继续到下一节，我们将学习字符串计算。
- en: Building string calculations
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建字符串计算
- en: Similar to numeric calculations, many string functions exist to allow for various
    calculations. Let's look at some of the key string calculations and how they can
    be used.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 与数值计算类似，存在许多字符串函数，允许进行各种计算。让我们看看一些关键字符串计算及其用法。
- en: Functions related to obtaining substrings from a string
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与从字符串中获取子字符串相关的函数
- en: One of the most common use cases when dealing with strings is that we want only
    parts of the string and not all. Many functions help us to do that. Let's have
    a look at what functions we can use.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理字符串时，最常见的用例之一是我们只想得到字符串的一部分，而不是全部。许多函数帮助我们做到这一点。让我们看看我们可以使用哪些函数。
- en: '`LEFT`: This follows the syntax `LEFT (string, num_chars)`.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`LEFT`: 这遵循语法 `LEFT (string, num_chars)`.'
- en: Using `LEFT`, the `num_chars` specified starting from the start of a string
    is returned. This becomes very useful for grouping.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `LEFT`，从字符串的开始返回指定的 `num_chars`。这对于分组非常有用。
- en: 'For example, we want to find the customers who have ordered the most, based
    on what letter their name starts with. We could create a calculation as follows: `LEFT([Customer
    Name,1)`. This will return only the first character of the string. We can then
    use this and count the number of orders to clearly see which category ordered
    the most:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们想根据客户名字的首字母找到订购最多的客户。我们可以创建如下计算：`LEFT([Customer Name,1)`. 这将只返回字符串的第一个字符。然后我们可以使用这个字符并计算订单数量，清楚地看到哪个类别订购最多：
- en: '![](img/4b5a7abc-05f4-48b0-818c-8fbcd7ee0068.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4b5a7abc-05f4-48b0-818c-8fbcd7ee0068.png)'
- en: '`RIGHT`: This follows the syntax `RIGHT(string, num_chars)`.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`RIGHT`: 这遵循语法 `RIGHT(string, num_chars)`.'
- en: Using `RIGHT`, the `num_chars` specified starting from the end of a string is
    returned.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `RIGHT`，从字符串的末尾返回指定的 `num_chars`。
- en: Similar to the first example, if you wanted to find the last letter of the names
    of the people who ordered, you would use `RIGHT([Customer Name,1).`
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 与第一个示例类似，如果你想找到订购人的名字中的最后一个字母，你会使用 `RIGHT([Customer Name,1]).`
- en: '`MID`: This follows the syntax `MID (string, start, [length])`.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`MID`: 这遵循语法 `MID (string, start, [length])`.'
- en: It returns the characters from `string`, starting from the position specified
    by the start value. The first character of the string has the starting position
    of 1\. `length` is optional to specify, and if it is specified, it will return
    up to that many characters.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 它从 `string` 中返回字符，从由起始值指定的位置开始。字符串的第一个字符的起始位置为 1。`length` 是可选的，如果指定，则返回多达那么多字符。
- en: 'Look at the following example:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 看看以下示例：
- en: '[PRE0]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`SPLIT`: This follows the syntax `SPLIT (string, delimiter, token number)`.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`SPLIT`: 这遵循语法 `SPLIT (string, delimiter, token number)`.'
- en: Sometimes, we don't know the exact position we want to create a substring from
    but might have a delimiter to specify it.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，我们不知道确切的位置来创建子字符串，但可能有一个分隔符来指定它。
- en: For example, in our dataset, we have a customer full name, so what if we only
    wanted to obtain the first name? We know the names are in the format of **First
    Name** followed by space character and then **Middle** + **Last** **Name**. So,
    our delimiter is `" "`. Based on the delimiter, your string is divided into equal
    tokens.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在我们的数据集中，我们有一个客户的完整姓名，如果我们只想获取名字怎么办？我们知道名字的格式是**名字**后跟空格字符，然后是**中间名** + **姓氏**。因此，我们的分隔符是
    `" "`。基于分隔符，您的字符串被分割成相等的标记。
- en: For example, if the string was `Alex Young`, your string would be broken by
    the delimiter into two strings. Token 1 would be `Alex`, and Token 2 would be `Young`.
    So, `SPLIT("Alex Young", " ",1)` would return `Alex`, while `SPLIT ("Alex Young","
    ",2)` would return `Young`. If you use negative numbers, it counts from the right
    in a string. So, `SPLIT("Alex Young"," ", -1)` would be `Young`, and `SPLIT ("Alex
    Young"," ",-2)` would be `Alex`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果字符串是 `Alex Young`，您的字符串将被分隔符分割成两个字符串。标记 1 将是 `Alex`，标记 2 将是 `Young`。因此，`SPLIT("Alex
    Young", " ",1)` 将返回 `Alex`，而 `SPLIT ("Alex Young"," ",2)` 将返回 `Young`。如果您使用负数，它将从字符串的右侧开始计数。因此，`SPLIT("Alex
    Young"," ", -1)` 将是 `Young`，而 `SPLIT ("Alex Young"," ",-2)` 将是 `Alex`。
- en: 'Now, back to our example—if we wanted to find the **First Name** of our customers,
    we would create a calculation as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回到我们的例子——如果我们想找到客户的**名字**，我们会创建以下计算：
- en: '![](img/abe84fbe-c819-4809-b979-1fae83f4e336.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/abe84fbe-c819-4809-b979-1fae83f4e336.png)'
- en: 'Now, we count the people with that as their first names, to find the most popular
    names, as shown here:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们统计那些以这个名字作为他们名字的人，以找到最流行的名字，如下所示：
- en: '![](img/596825ed-0941-487d-98f8-abb5882193b5.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/596825ed-0941-487d-98f8-abb5882193b5.png)'
- en: This first logical subset of string functions allows us to obtain substrings
    from a string. In the next section, we shall learn about functions that deal with
    the position of occurrence or existence of a substring within a string.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这个字符串函数的第一个逻辑子集允许我们从字符串中获取子字符串。在下一节中，我们将学习处理子字符串在字符串中位置或存在性的函数。
- en: Functions related to finding a substring within a string
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与在字符串中查找子字符串相关的函数
- en: 'Sometimes, we don''t want to obtain substrings, but just check whether certain
    substrings exist in strings or even obtain their position of occurrence. For this,
    the following functions are useful:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，我们不想获取子字符串，只想检查某些子字符串是否存在于字符串中，甚至获取它们出现的位置。为此，以下函数很有用：
- en: '`CONTAINS`: This follows the syntax `CONTAINS(string, substring)`. `CONTAINS` returns
    true if the string contains the substring within it, for example, `CONTAINS("Tableau",
    "Table") = TRUE`. For example, to find how many people have names containing the
    letter `E`, we can then create the calculation as `CONTAINS([Customer Name],"e")`
    and see the count of `TRUE`.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CONTAINS`: 这个函数遵循 `CONTAINS(string, substring)` 语法。如果字符串包含其内的子字符串，则 `CONTAINS`
    返回 true，例如，`CONTAINS("Tableau", "Table") = TRUE`。例如，为了找到有多少人的名字包含字母 `E`，我们可以创建以下计算：`CONTAINS([Customer
    Name],"e")` 并查看 `TRUE` 的计数。'
- en: '`ENDSWITH`:This follows the syntax `ENDSWITH(string, substring)`. This returns
    true if the string ends with the substring provided, and trailing white spaces
    are ignored, for example, `ENDSWITH("hello", "lo")=TRUE`.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ENDSWITH`: 这个函数遵循 `ENDSWITH(string, substring)` 语法。如果字符串以提供的子字符串结束，则返回 true，并且忽略尾随空格，例如，`ENDSWITH("hello", "lo")=TRUE`。'
- en: '`FIND`: This follows the syntax `FIND (string, substring, [start])`. It will
    return the position of the string within a substring. If a start position is specified,
    then it starts searching for the substring after the start position. For example,
    `FIND("hello","lo")` would return `4`.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FIND`: 这个函数遵循 `FIND (string, substring, [start])` 语法。它将返回字符串在子字符串中的位置。如果指定了起始位置，则它将在起始位置之后开始搜索子字符串。例如，`FIND("hello","lo")`
    将返回 `4`。'
- en: '`FINDNTH`:This follows the syntax `FINDNTH(string, substring, occurrence)` and
    returns the *n*^(th) position of the *n*^(th) occurrence of a substring with a
    string. For example, if a string is `abcabcabc` and we want to find the third
    occurrence of `abc` in the string, we would find it using `FINDNTH("abcabcabc"."abc",3)`.
    It will return `7`.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FINDNTH`: 这个函数遵循 `FINDNTH(string, substring, occurrence)` 语法，并返回子字符串在字符串中出现的第
    *n* 次位置。例如，如果字符串是 `abcabcabc`，而我们想找到字符串中 `abc` 的第三次出现，我们会使用 `FINDNTH("abcabcabc"."abc",3)`。它将返回
    `7`。'
- en: '`STARTSWITH`: This follows the syntax `STARTSWITH(string, substring)`, similar
    to `ENDSWITH`. This displays true if the string starts with the other substring,
    for example, `STARTSWITH("hello","he")=TRUE`.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`STARTSWITH`：这遵循`STARTSWITH(string, substring)`的语法，类似于`ENDSWITH`。如果字符串以另一个子串开头，则显示为真，例如，`STARTSWITH("hello","he")=TRUE`。'
- en: Functions related to formatting/standardizing a string
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与格式化/标准化字符串相关的函数
- en: 'Often, strings do not all follow a consistent format. There could be leading
    or trailing spaces in strings or them having different cases. All of these will
    lead to the strings to be considered distinct and separate. For example, if there
    was a string called `book` and another string called `BOOK`, they would be considered
    different. Using the following functions, we can standardize the string in our
    dataset:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，字符串并不都遵循一致的格式。字符串中可能有前导或尾随空格，或者它们有不同的大小写。所有这些都会导致字符串被视为不同的和独立的。例如，如果有一个名为`book`的字符串和另一个名为`BOOK`的字符串，它们将被视为不同。使用以下函数，我们可以标准化我们的数据集中的字符串：
- en: '`LOWER`: This follows the syntax `LOWER(string)`. It will return the string
    in all lowercase, for example, `LOWER("Book") = book`.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LOWER`：这遵循`LOWER(string)`的语法。它将返回全部小写的字符串，例如，`LOWER("Book") = book`。'
- en: '`UPPER`: This follows the syntax `UPPER(string)`. It will return the strings
    in all uppercase, for example, `UPPER("Book")= BOOK`.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UPPER`：这遵循`UPPER(string)`的语法。它将返回全部大写的字符串，例如，`UPPER("Book")= BOOK`。'
- en: '`TRIM`: This follows the syntax `TRIM(string)` and removes both leading and
    trailing spaces from a string, for example, `TRIM("    Book    ") = Book`.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TRIM`：这遵循`TRIM(string)`的语法，并从字符串中删除前导和尾随空格，例如，`TRIM("    Book    ") = Book`。'
- en: Similar to `TRIM`, there are `LTRIM` and `RTRIM`, which follow the same syntax
    but only remove spaces from the left of the string or the right of the string.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 与`TRIM`类似，还有`LTRIM`和`RTRIM`，它们遵循相同的语法，但只从字符串的左侧或右侧删除空格。
- en: Other important string functions
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他重要的字符串函数
- en: '`LEN`: This follows the syntax `LEN(string)`. Length is used to find the number
    of characters in a string. It counts the number of spaces as a character within
    a string. For example, `LEN("Hi There")` is 8: 2 for `Hi`, 1 for space, and 5
    for `There`.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LEN`：这遵循`LEN(string)`的语法。长度用于查找字符串中的字符数。它将字符串中的空格计为一个字符。例如，`LEN("Hi There")`是8：`Hi`有2个字符，空格有1个字符，`There`有5个字符。'
- en: '`REPLACE`: This follows the syntax `REPLACE(string, substring, replacement)`. `REPLACE` is
    used to replace every occurrence of the substring in a string with the replacement,
    for example, to replace occurrences of special characters such as `/` or `''`
    in the string, such as `Replace([Customer Name],"/","")`.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`REPLACE`：这遵循`REPLACE(string, substring, replacement)`的语法。`REPLACE`用于将字符串中的子串替换为替换内容，例如，在字符串中替换特殊字符，如`/`或`''`，例如`Replace([Customer
    Name],"/","")`。'
- en: 'Another example would be if someone changed their name. You could replace their
    name with the new one. Let''s replace Aaron Bergman''s name with `Aaron B`. Create
    a new calculation using `REPLACE` as follows: `REPLACE([Customer Name], "Aaron
    Bergman", "Aaron B")`. The result of this calculation can be seen in the following
    screenshot:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是如果有人更改了他们的名字。你可以用新名字替换他们的名字。让我们用`Aaron B`替换Aaron Bergman的名字。创建一个新的计算，使用`REPLACE`如下所示：`REPLACE([Customer
    Name], "Aaron Bergman", "Aaron B")`。这个计算的结果可以在下面的屏幕截图中看到：
- en: '![](img/390e1bee-9ce8-4c9a-beff-7a6a87442834.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/390e1bee-9ce8-4c9a-beff-7a6a87442834.png)'
- en: Now that we have made ourselves familiar with the important string calculations,
    let's look at date calculations in the next section.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经熟悉了重要的字符串计算，让我们在下一节中看看日期计算。
- en: Building date calculations
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建日期计算
- en: Date calculations allow us to perform operations on dates, such as adding or
    subtracting dates and obtaining parts of dates. Let's look at some of the key
    functions in the following sections.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 日期计算允许我们对日期执行操作，例如添加或减去日期以及获取日期的一部分。让我们在下面的部分中看看一些关键函数。
- en: Obtaining the current date/time
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取当前日期和时间
- en: '`Today()` returns the current date in Tableau and `NOW()` can be used to return
    the current date-time. A common use case of this is to find the time taken between
    an event occurrence and today.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`Today()`返回Tableau中的当前日期，`NOW()`可以用来返回当前日期和时间。一个常见的用例是找到事件发生与今天之间的时间差。'
- en: Obtaining parts of a date
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取日期的一部分
- en: '`DAY()`, `MONTH()` and `YEAR()`: They share the syntax of function (date). They
    can be used for obtaining the day, month, and year part of the date as integers
    respectively. For example, `DAY(#24-05-2019#)` returns `24`.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DAY()`, `MONTH()` 和 `YEAR()`: 它们共享函数（日期）的语法。它们分别可以用来获取日期的天、月、年部分作为整数。例如，`DAY(#24-05-2019#)`
    返回 `24`。'
- en: '`DATEPART`:It follows the syntax: `DATEPART(date_part,date,[start_of_week])`.
    If the start of the week is not mentioned, then it is determined based on the
    start day defined in the data source. For example, `DATEPART(week,#24-05-2019#)`
    returns `21`.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DATEPART`: 它遵循语法 `DATEPART(date_part, date, [start_of_week])`。如果未提及周的开始，则根据数据源中定义的开始日确定。例如，`DATEPART(week,#24-05-2019#)`
    返回 `21`。'
- en: '`DATENAME`:The syntax remains the same as `DATENAME` as `DATEPART(date_part,date,[start_of_week])`.
    It is very similar to `DATEPART`. The key difference is that it will return the
    values as a string. For example, `DATENAME("month",#24-05-2019#)` returns `May`.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DATENAME`: 其语法与 `DATENAME` 相同，即 `DATEPART(date_part, date, [start_of_week])`。它与
    `DATEPART` 非常相似。关键区别在于它将以字符串的形式返回值。例如，`DATENAME("month",#24-05-2019#)` 返回 `May`。'
- en: '`DATETRUNC`: The syntax is the same as `DATEPART` and `DATENAME`, as follows: `DATETRUNC(date_part,
    date,[start_of_week])`. It allows us to not just obtain a `date_part` but rather
    truncate the date to that `date_part`. The syntax is the same as `DATEPART` and
    `DATENAME`, as follows: `DATETRUNC(date_part, date,[start_of_week])`. For example,
    `DATETRUNC("month",#24-05-2019#)` returns `01-05-2019 00:00:00`.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DATETRUNC`: 其语法与 `DATEPART` 和 `DATENAME` 相同，如下所示：`DATETRUNC(date_part, date,
    [start_of_week])`。它允许我们不仅获取 `date_part`，而且截断日期到该 `date_part`。例如，`DATETRUNC("month",#24-05-2019#)`
    返回 `01-05-2019 00:00:00`。'
- en: Other date calculations
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他日期计算
- en: '`ISDATE`: This follows the syntax `ISDATE(string)`. It returns `TRUE` if the
    string is a date otherwise, it returns `FALSE`, for example, `ISDATE("24-05-2019")=
    TRUE`.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ISDATE`: 它遵循语法 `ISDATE(string)`。如果字符串是日期，则返回 `TRUE`，否则返回 `FALSE`，例如，`ISDATE("24-05-2019")=
    TRUE`。'
- en: '`DATEPARSE`: This follows the syntax `DATEPARSE(format, string)`. It is used
    to convert a string into `DATE` in the format specified. For example, `DATEPARSE("dd-MM-yyyy","24-05-2019)`
    returns `24-05-2019` as a date.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DATEPARSE`: 它遵循语法 `DATEPARSE(format, string)`。它用于将字符串转换为指定格式的 `DATE`。例如，`DATEPARSE("dd-MM-yyyy","24-05-2019")`
    返回 `24-05-2019` 作为日期。'
- en: '`DATEADD`: This follows the syntax `DATEADD(date_part, interval, date)`. It
    adds the interval to `date_part` specified of the date. `DATEADD` is one of the
    most commonly used date functions.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DATEADD`: 它遵循语法 `DATEADD(date_part, interval, date)`。它将间隔添加到日期的指定 `date_part`。`DATEADD`
    是最常用的日期函数之一。'
- en: 'Suppose there was an issue in the system and all of the order dates captured
    were wrong. They were actually a month before they are showing in the calculation.
    To get the right order dates, we create a calculation for `Correct Order Date`
    as `DATEADD("month",-1,[Order Date])`. Now, if we place the dates next to each
    other, we will obtain the following:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 假设系统存在问题，所有捕获的订单日期都是错误的。实际上，它们比计算中显示的日期早了一个月。为了得到正确的订单日期，我们创建了一个计算 `Correct
    Order Date` 的公式，即 `DATEADD("month", -1, [Order Date])`。现在，如果我们把日期并排放置，我们将得到以下结果：
- en: '![](img/e09da0b5-97f8-403b-95c9-1dd43e761607.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e09da0b5-97f8-403b-95c9-1dd43e761607.png)'
- en: '`DATEDIFF`:This follows the syntax `DATEDIFF(date_part, start_date,end_date,[start_of_week])`.
    It returns the difference between the two dates in terms of the units of `date_part`.
    For example, if we wanted to calculate the time to ship orders after they are
    ordered in months, we can calculate `Shipping Time` as `DATEDIFF("month", [Order
    Date],[Ship Date])`. Once created, if we look at the total time spent in months
    across all shipping categories, we get the following:'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DATEDIFF`: 它遵循语法 `DATEDIFF(date_part, start_date, end_date, [start_of_week])`。它以
    `date_part` 的单位返回两个日期之间的差异。例如，如果我们想计算订单下单后需要多少个月才能发货，我们可以将 `Shipping Time` 计算为
    `DATEDIFF("month", [Order Date], [Ship Date])`。一旦创建，如果我们查看所有运输类别的总耗时（以月为单位），我们得到以下结果：'
- en: '![](img/4e1898db-aedb-4bb5-90c6-207558a0a6cf.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4e1898db-aedb-4bb5-90c6-207558a0a6cf.png)'
- en: As you can see, same-day delivery is super-fast, so even after combining all
    of the orders, shipping only took 2 months. On the other hand, 4,489 months was
    spent in shipping orders by standard class.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，同日送达超级快，所以即使将所有订单合并，运输也只花了2个月。另一方面，标准类别的订单运输花费了4,489个月。
- en: In the past few sections, we have covered numeric, string, and date calculations.
    In the next section, we will focus on building logical statements. Logical statements
    work with numbers, strings, and dates and can be used in combination with the
    calculations we have learned so far.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几节中，我们介绍了数字、字符串和日期计算。在下一节中，我们将专注于构建逻辑语句。逻辑语句与数字、字符串和日期一起工作，可以与我们已经学过的计算结合使用。
- en: Building logical statements
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建逻辑语句
- en: Logical functions allow you to check conditions and see whether they are true
    or false. We will take a look at the various categories of logical functions over
    the coming sections.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑函数允许你检查条件并查看它们是真是假。在接下来的几节中，我们将查看各种逻辑函数类别。
- en: Case statements
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 情况语句
- en: 'Case statements make use of the following syntax: `CASE <expression> WHEN <value1>
    THEN <return1> WHEN <value2> THEN <return2> ... ELSE <default return> END`.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 情况语句使用以下语法：`CASE <expression> WHEN <value1> THEN <return1> WHEN <value2> THEN
    <return2> ... ELSE <default return> END`.
- en: In case statements, the value of the expression is matched to each of the values
    and whenever a match is found, the return value corresponding to it is returned.
    If no value matches the expression, then the default else value is returned. If
    there is no default value, null values will be returned.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在情况语句中，表达式的值与每个值进行匹配，每当找到匹配时，就返回相应的返回值。如果没有值与表达式匹配，则返回默认的else值。如果没有默认值，则返回null值。
- en: 'Case statements are very useful when you have to compare the same expression
    against multiple values. An example would be if we wanted to assign numbers to
    some of the markets. We can create a calculation as shown in the following screenshot:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 情况语句在需要将相同的表达式与多个值进行比较时非常有用。一个例子是，如果我们想要给一些市场分配数字，我们可以创建如下截图所示的计算：
- en: '![](img/a5a1ed5e-f31e-46f5-872f-b25501705a18.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a5a1ed5e-f31e-46f5-872f-b25501705a18.png)'
- en: 'Now, if we place both Market and Market Number next to one another, we can
    see the groups:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们把市场和市场编号放在一起，我们可以看到这些组：
- en: '![](img/a77c50cb-7172-4988-b529-9e79847920c5.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a77c50cb-7172-4988-b529-9e79847920c5.png)'
- en: As an independent exercise, create a case statement giving each day of the week
    a number.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一项独立练习，创建一个情况语句，给每周的每一天分配一个数字。
- en: IF statement
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IF语句
- en: An IF statement has the following syntax: `IF <expr> THEN <then> [ELSEIF <expr2>
    THEN <then2>...] [ELSE <else>] END`.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: IF语句的语法如下：`IF <expr> THEN <then> [ELSEIF <expr2> THEN <then2>...] [ELSE <else>]
    END`.
- en: Using an `IF` statement, we can test a series of conditions, and based on whether
    the condition is true, the values are returned; otherwise, the next condition
    is tested. This continues until no condition is true, in which case, the default
    condition's value is represented; otherwise, it is returned. If there is no default
    condition, then null is returned.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 使用IF语句，我们可以测试一系列条件，并根据条件是否为真返回值；否则，测试下一个条件。这会一直继续，直到没有条件为真，在这种情况下，表示默认条件的值；否则，它将被返回。如果没有默认条件，则返回null。
- en: Within `IF` statements, multiple conditions can also be combined using `OR`
    and `AND` operators.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在IF语句中，也可以使用`OR`和`AND`运算符组合多个条件。
- en: 'For example, if we wanted to group sales into categories of high, medium, and
    low, we could create a calculation such as the following:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想要将销售分为高、中、低类别，我们可以创建如下计算：
- en: '![](img/1e0c8024-46df-42fe-aa0d-4934d877f743.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1e0c8024-46df-42fe-aa0d-4934d877f743.png)'
- en: Here, you can see we have grouped any sales that are greater than 0 and less
    than 1,000 dollars as being in the category of low, anything up to 2,000 dollars
    is medium, from 2,000-10,000 is high, and all other values we assume are potential
    errors, either from the sales value being too high or being under 0, which we
    might need to recheck.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到我们将任何大于0且小于1,000美元的销售归为低类别，2,000美元及以下为中等，2,000-10,000为高，其他所有值我们假设是潜在的错误，可能是销售值过高或低于0，这可能是需要重新检查的。
- en: 'Now, counting the number of order IDs by each **Sales Group**, we can see that
    the bulk of the orders are for the **Low** category, followed by the **High**
    category, and there are only five potential error cases, as shown in the following
    screenshot:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，按每个**销售组**计算订单ID的数量，我们可以看到大部分订单是**低**类别，其次是**高**类别，只有五个潜在的错误案例，如下截图所示：
- en: '![](img/8c4b3983-6726-4654-9ea4-7358e8b6f37a.png)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8c4b3983-6726-4654-9ea4-7358e8b6f37a.png)'
- en: As an exercise, create similar calculations for the profit ranges.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，为利润范围创建类似的计算。
- en: IIF
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IIF
- en: '`IIF` is similar to `IF` for one condition. It follows the syntax: `IIF(test,
    then, else, [unknown])`. Here, it will test a condition and if the condition is
    true, the statement returns the then value; otherwise, it returns the else value.
    If the else value is not specified, `NULL` will be returned, for example, `IIF([Sales]>0,"Valid","Invalid")`.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`IIF` 与 `IF` 对于一个条件相似。它遵循语法：`IIF(test, then, else, [unknown])`。在这里，它将测试一个条件，如果条件为真，则返回
    `then` 值；否则，返回 `else` 值。如果未指定 `else` 值，则返回 `NULL`，例如，`IIF([Sales]>0,"Valid","Invalid")`。'
- en: IFNULL and ISNULL
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IFNULL 和 ISNULL
- en: Both `IFNULL` and `ISNULL` are used to test whether an expression is null or
    not.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`IFNULL` 和 `ISNULL` 都用于测试表达式是否为空。'
- en: '**IFNULL**: It follows the syntax: `IFNULL(expr1,expr2)`, and it returns expression
    1 if the value is null and expression 2 if it is not. For example, `IFNULL([Sales],0)`
    will return the value of `Sales` where it is not null, else return 0.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '**IFNULL**：它遵循语法：`IFNULL(expr1,expr2)`，如果值为空，则返回表达式 1；如果不为空，则返回表达式 2。例如，`IFNULL([Sales],0)`
    将返回 `Sales` 的值，如果它不是空值，否则返回 0。'
- en: '**ISNULL**: `ISNULL` follows the syntax: `ISNULL(expr)`. It returns `TRUE`
    if the expression is `NULL`. For example, `ISNULL([Sales])` will return true if
    `Sales` is null.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '**ISNULL**：`ISNULL` 遵循语法：`ISNULL(expr)`。如果表达式是 `NULL`，则返回 `TRUE`。例如，`ISNULL([Sales])`
    如果 `Sales` 是空值，将返回 true。'
- en: Other functions
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他函数
- en: Beyond the functions discussed so far, there are some other important functions
    that are useful and available in Tableau. One of those is the type conversion
    functions. Type conversion functions are useful for converting one data type into
    another, for example, from an integer into a string or from a float into an integer.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 除了之前讨论的函数之外，还有一些其他重要且在 Tableau 中可用的重要函数。其中之一是类型转换函数。类型转换函数对于将一种数据类型转换为另一种数据类型很有用，例如，从整数转换为字符串或从浮点数转换为整数。
- en: 'All of the following functions follow the common syntax of `Function(expression)`:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的以下函数都遵循 `Function(expression)` 的通用语法：
- en: '| `DATE` | It is used to obtain a date from numbers or strings or date expressions,
    for example, `DATE("25/05/2019")` returns `#25-05-2019#`. |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '| `DATE` | 它用于从数字、字符串或日期表达式中获取日期，例如，`DATE("25/05/2019")` 返回 `#25-05-2019#`。
    |'
- en: '| `DATETIME` | Very similar to `DATE`, this function returns the date and time,
    for example, `DATETIME("25 May 2019 13:40:00")` returns `#25-05-2019 13:40:00#`.
    |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| `DATETIME` | 与 `DATE` 非常相似，此函数返回日期和时间，例如，`DATETIME("25 May 2019 13:40:00")`
    返回 `#25-05-2019 13:40:00#`。 |'
- en: '| `FLOAT` | This is used to cast to floating-point numbers, for example, `FLOAT(2)=2.000`.
    |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| `FLOAT` | 这用于转换为浮点数，例如，`FLOAT(2)=2.000`。 |'
- en: '| `INT` | This is used to cast its argument to integers, for example `INT("22")=22`
    or `INT(22.2)=22`. |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| `INT` | 这用于将参数转换为整数，例如 `INT("22")=22` 或 `INT(22.2)=22`。 |'
- en: '| `STR` | This is used to cast values to a string, for example, `STR(22)` results
    in a string, `22`. |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '| `STR` | 这用于将值转换为字符串，例如，`STR(22)` 结果为字符串，`22`。 |'
- en: For example, if there is number field `12` and another number field, `22`, and
    we want to obtain the concatenated field `1222`, we can convert them into strings
    and back into numbers as `INT( (STR(12)+STR(22))` and it will return `1222` as
    a number. Type conversions can help many times when we need to create complex
    calculations and need the output of one field to be in the correct format to be
    the input of another.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果有数字字段 `12` 和另一个数字字段 `22`，我们想要获得连接字段 `1222`，我们可以将它们转换为字符串然后再转换回数字，作为 `INT(
    (STR(12)+STR(22)))` 并返回 `1222` 作为数字。类型转换可以在我们需要创建复杂计算并且需要某个字段的输出以正确格式作为另一个字段的输入时多次帮助。
- en: User functions are another set of useful Tableau functions. These are useful
    to create row-level filters and security to limit the fields that are visible
    if your dashboard is published to Tableau Online or Server. Tableau also allows
    for some regular expression functionalities in functions such as `REGEXP_MATCH`
    or `REGEXP_EXTRACT`, which can be used to create some advanced string matching.
    Also, in the next chapter, we will study some advanced table calculation functions
    that haven't been discussed so far.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 用户函数是另一组有用的 Tableau 函数。这些函数对于创建行级筛选和安全限制在您的仪表板发布到 Tableau Online 或 Server 时可见的字段很有用。Tableau
    还允许在函数如 `REGEXP_MATCH` 或 `REGEXP_EXTRACT` 中使用一些正则表达式功能，可用于创建一些高级字符串匹配。此外，在下一章中，我们将研究一些尚未讨论的高级表格计算函数。
- en: One last thing we will discuss in this chapter will be totals and subtotals
    and how they can be used.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将讨论的最后一点将是总计和子总计以及它们如何被使用。
- en: Building grand totals and subtotals
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建总计和子总计
- en: Beyond showing the values from calculations, sometimes, we also want to show
    the values of the totals or subtotals in the same window as these values.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 除了显示计算值之外，有时我们还想在相同窗口中显示总计或子总计的值。
- en: 'For instance, we have the following graph for SUM(Sales) split by Category
    and Sub-Category across segments:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们有以下图表，按类别和子类别分段显示SUM(Sales)：
- en: '![](img/61d70d88-a643-4f54-9b81-2b630fd05756.png)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/61d70d88-a643-4f54-9b81-2b630fd05756.png)'
- en: 'Now, if we want to add the subtotals and the grand totals for both rows and
    columns, we can do the following:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们想为行和列添加子总计和总计，我们可以执行以下操作：
- en: Go to **Analysis** > **Totals**.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往**分析** > **总计**。
- en: 'Select Show Row Totals | Show Column Totals. This will show the graph as follows:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择显示行总计 | 显示列总计。这将显示如下图表：
- en: '![](img/8f31b197-3b98-4a23-a315-2f98a7f8f769.png)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8f31b197-3b98-4a23-a315-2f98a7f8f769.png)'
- en: 'Now if we want to see the subtotals too, we can select **Add All Subtotals**
    from Analysis | Tools. This will show the following:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果我们想看到子总计，我们可以从分析 | 工具中选择**添加所有子总计**。这将显示以下内容：
- en: '![](img/8f29d18d-1f37-4483-b521-3d6475698c23.png)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8f29d18d-1f37-4483-b521-3d6475698c23.png)'
- en: If there is more than one dimension for which the subtotals are being calculated,
    then we can right-click on the dimensions to select or unselect, depending on
    whether we want the totals to be calculated or not.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有多个维度需要计算子总计，则可以右键单击维度以选择或取消选择，具体取决于我们是否希望计算总计。
- en: 'For example, adding city to the previous and adding all subtotals creates the
    following:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，将城市添加到之前的内容中，并添加所有子总计，将创建以下图表：
- en: '![](img/c7d6ebcc-5732-46a2-81b0-b2cddb6dfdc7.png)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c7d6ebcc-5732-46a2-81b0-b2cddb6dfdc7.png)'
- en: 'Now, if we do not want to see the subtotals at the level of Categories, then
    right-click on Category in the Rows shelf and uncheck Subtotals, as shown in the
    following screenshot:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们不想在类别级别看到子总计，则可以在行架上右键单击类别，并取消选中子总计，如图下截图所示：
- en: '![](img/573c7b54-98d5-4c4a-940e-066e3e267868.png)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/573c7b54-98d5-4c4a-940e-066e3e267868.png)'
- en: This will remove the subtotals from the level of Category. Another way to create
    totals and subtotals is to use the **Analytics Window | Totals.**
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这将移除类别级别的子总计。创建总计和子总计的另一种方法是使用**分析窗口 | 总计**。
- en: Summary
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have learned how to create simple calculations. We looked
    at the format and syntax requirements for the various elements of calculations.
    Following that, we looked in detail at some of the important functions and examples
    of number, string, date, and logical functions. Lastly, we also learned how to
    add totals and subtotals to our calculations. In the next chapter, we will learn
    about more advanced table calculations, where we will use the results of the calculations
    learned in this chapter to build on further calculations.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何创建简单的计算。我们探讨了计算的各种元素所需的格式和语法要求。随后，我们详细研究了数字、字符串、日期和逻辑函数的一些重要函数和示例。最后，我们还学习了如何将总计和子总计添加到我们的计算中。在下一章中，我们将学习更高级的表格计算，我们将使用本章学到的计算结果来构建进一步的计算。
- en: Further reading
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: To look at a list of all available functions in Tableau, go to the following
    link: [https://help.tableau.com/current/pro/desktop/en-us/functions_all_categories.htm](https://help.tableau.com/current/pro/desktop/en-us/functions_all_categories.htm).
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看Tableau中所有可用函数的列表，请访问以下链接：[https://help.tableau.com/current/pro/desktop/en-us/functions_all_categories.htm](https://help.tableau.com/current/pro/desktop/en-us/functions_all_categories.htm)。
