- en: Input and Output
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 输入与输出
- en: In this chapter, we will cover some options for handling data files. Depending
    on the data and the desired format, there are several options for reading and
    writing. We will show some of the most useful alternatives.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍一些处理数据文件的选项。根据数据和所需的格式，有几种读取和写入的选项。我们将展示一些最有用的替代方案。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: File handling
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件处理
- en: NumPy methods
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NumPy 方法
- en: Pickling
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 序列化
- en: Shelves
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持存储
- en: Reading and writing Matlab data files
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取和写入 Matlab 数据文件
- en: Reading and writing images
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取和写入图像
- en: 14.1 File handling
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 14.1 文件处理
- en: 'File **input and output**(**I/O**) is essential in a number of scenarios, for
    example:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 文件**输入与输出**（**I/O**）在许多场景中是至关重要的，例如：
- en: Working with measured or scanned data. Measurements are stored in files that
    need to be read in order to be analyzed.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理测量或扫描数据。测量结果存储在文件中，需要读取这些文件以进行分析。
- en: Interacting with other programs. Save results to files so that they can be imported
    into other applications, and vice-versa.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与其他程序的交互。将结果保存到文件中，以便可以导入到其他应用程序中，反之亦然。
- en: Storing information for future reference or comparisons.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储信息以备将来参考或比较。
- en: Sharing data and results with others, possibly on other platforms using other
    software.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与他人共享数据和结果，可能是在其他平台上使用其他软件。
- en: In this section, we will cover how to handle file I/O in Python.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将介绍如何在 Python 中处理文件 I/O。
- en: 14.1.1 Interacting with files
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.1.1 与文件的交互
- en: 'In Python, an object of the type `file` represents the contents of a physical
    file stored on a disk. A new object `file` may be created using the following
    syntax:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，`file` 类型的对象表示存储在磁盘上的物理文件的内容。可以使用以下语法创建一个新的 `file` 对象：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The contents of the file may be accessed, for instance, with this command:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 文件内容可以通过以下命令访问：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Usage of file objects requires some care. The problem is that a file has to
    be closed before it can be re-read or used by other applications, which is done
    using the following syntax:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 使用文件对象需要小心。问题在于，文件必须在重新读取或由其他应用程序使用之前关闭，这是通过以下语法完成的：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'It is not that simple because an exception might be triggered before the call
    to `close` is executed, which will skip the closing code (consider the following
    example). A simple way to make sure that a file will be properly closed is to
    use context managers. This construction, using the keyword `with`, is explained
    in more detail in [Section 12.1.3](9bd2d3f3-b846-4421-931c-7ebfbdc8fbea.xhtml):
    *Context **Managers – the with statement*. Here is how it is used with files:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 事情并没有那么简单，因为在执行 `close` 调用之前可能会触发异常，这将跳过关闭代码（考虑以下示例）。确保文件正确关闭的简单方法是使用上下文管理器。使用
    `with` 关键字的这种结构将在[第 12.1.3 节](9bd2d3f3-b846-4421-931c-7ebfbdc8fbea.xhtml)：*上下文管理器
    – with 语句*中进行更详细的说明。以下是如何与文件一起使用它：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This ensures that the file is closed when you exit the `with` block, even if
    an exception is raised inside the block. The command works with context manager
    objects. We recommend that you read more on context managers in [Section 12.1.3](9bd2d3f3-b846-4421-931c-7ebfbdc8fbea.xhtml): *Context*
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这确保了即使在块内引发异常时，文件也会在退出 `with` 块时关闭。该命令适用于上下文管理器对象。我们建议您阅读更多关于上下文管理器的内容，见[第 12.1.3
    节](9bd2d3f3-b846-4421-931c-7ebfbdc8fbea.xhtml)：*上下文*
- en: '*Managers – the with statement*. Here is an example showing why the construct `with` is
    desirable:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*管理器 – with 语句*。以下是一个示例，展示了为什么 `with` 结构是值得推荐的：'
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'An exception is raised before the file is closed. The file remains open, and
    there is no guarantee of what data is written in the file or when it is written.
    Hence, the proper way to achieve the same result is this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件关闭之前引发了异常。文件保持打开状态，并且无法保证数据何时以及如何写入文件。因此，确保达到相同结果的正确方法是：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In that case, the file is cleanly closed just after the exception (here, `ZeroDivisionError`)
    is raised. Notice also that there is no need to close the file explicitly.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，文件会在异常（此处为`ZeroDivisionError`）被触发后干净地关闭。还需要注意的是，无需显式地关闭文件。
- en: 14.1.2 Files are iterables
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.1.2 文件是可迭代的
- en: 'A file is, in particular, iterable (see [Section 9.3](66c25bba-72d2-46a9-929a-1f57fa7a1684.xhtml):
    *Iterable objects*). Files iterate their lines:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 文件尤其是可迭代的（见[第 9.3 节](66c25bba-72d2-46a9-929a-1f57fa7a1684.xhtml)：*可迭代对象*）。文件会迭代它们的每一行：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The lines of the file are returned as strings. The string method `split` is
    a possible tool to convert the string to a list of strings; for example:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 文件的每一行会作为字符串返回。`split` 字符串方法是将字符串转换为字符串列表的一个可能工具，例如：
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Since the object `myfile` is iterable, we can also do a direct extraction into
    a list, as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 由于对象 `myfile` 是可迭代的，我们也可以直接提取到列表中，示例如下：
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 14.1.3 File modes
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.1.3 文件模式
- en: 'As you can see in these examples of file handling, the function `open` takes
    at least two arguments. The first is obviously the filename, and the second is
    a string describing the way in which the file will be used. There are several
    such modes for opening files. The basic ones are as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在这些文件处理的示例中看到的，函数 `open` 至少需要两个参数。第一个显然是文件名，第二个是描述文件使用方式的字符串。打开文件有几种模式，基本模式如下：
- en: '[PRE9]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The modes `'r'`, `'r+'`, and `'a'` require that the file exists, whereas `'w'` will
    create a new file if no file with that name exists. Reading and writing with `'r'` and `'w'` is
    most common, as you saw in previous examples.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 模式 `'r'`、`'r+'` 和 `'a'` 要求文件已存在，而 `'w'` 会在没有该文件的情况下创建一个新文件。使用 `'r'` 和 `'w'`
    进行读写是最常见的，正如你在前面的示例中看到的那样。
- en: 'Consider an example of opening a file and adding data at the end of the file
    without modifying what is already there using the append mode `''a''`. Note the
    line break,`\n`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个例子，展示了如何使用追加模式 `'a'` 打开文件并在文件末尾添加数据，而不修改文件中已存在的内容。注意换行符 `\n`：
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 14.2 NumPy methods
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 14.2 NumPy 方法
- en: NumPy has built-in methods for reading and writing NumPy array data to text
    files. These are `numpy.loadtxt` and `numpy.savetxt`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 提供了用于将 NumPy 数组数据读取和写入文本文件的内置方法。这些方法是 `numpy.loadtxt` 和 `numpy.savetxt`。
- en: 14.2.1 savetxt
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.2.1 savetxt
- en: 'Writing an array to a text file is simple:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个数组写入文本文件非常简单：
- en: '[PRE11]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'There are two useful parameters given as strings, `fmt`, and `delimiter`, which
    control the format and the delimiter between columns. The defaults are space for
    the delimiter and `%.18e` for the format, which corresponds to the exponential
    format with all digits. The formatting parameters are used as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个有用的参数作为字符串给出，`fmt` 和 `delimiter`，它们控制列之间的格式和分隔符。默认值为分隔符为空格，格式为`%.18e`，即对应于具有所有数字的指数格式。格式化参数的使用方式如下：
- en: '[PRE12]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 14.2.3 loadtxt
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.2.3 loadtxt
- en: 'Reading to an array from a text file is done with the help of the following
    syntax:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 从文本文件读取到数组使用以下语法：
- en: '[PRE13]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Due to the fact that each row in an array must have the same length, each row
    in the text file must have the same number of elements. Similar to `savetxt`,
    the default values are `float` and the delimiter is a space. These can be set
    using the parameters `dtype` and `delimiter`. Another useful parameter is `comments`,
    which can be used to mark what symbol is used for comments in the data file. An
    example of using the formatting parameters is as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 由于数组中的每一行必须具有相同的长度，因此文本文件中的每一行必须有相同数量的元素。与 `savetxt` 类似，默认值为 `float`，分隔符为空格。可以使用
    `dtype` 和 `delimiter` 参数进行设置。另一个有用的参数是 `comments`，可以用来标记数据文件中用于注释的符号。使用格式化参数的示例如下：
- en: '[PRE14]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 14.3 Pickling
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 14.3 Pickling
- en: The read and write methods you just saw convert data to strings before writing.
    Complex types (such as objects and classes) cannot be written this way. With Python's module `pickle`,
    you can save any object and also multiple objects to a file.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚看到的读写方法会在写入之前将数据转换为字符串。复杂类型（如对象和类）不能以这种方式写入。使用 Python 的模块 `pickle`，你可以将任何对象以及多个对象保存到文件中。
- en: 'Data can be saved in plain-text (ASCII) format or using a slightly more efficient
    binary format. There are two main methods: `dump`, which saves a pickled representation
    of a Python object to a file, and `load`, which retrieves a pickled object from
    the file. The basic usage is like this:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 数据可以保存为纯文本（ASCII）格式或使用稍微高效一些的二进制格式。主要有两种方法：`dump`，它将一个 Python 对象的 pickle 表示保存到文件中，和
    `load`，它从文件中检索一个 pickle 对象。基本用法如下：
- en: '[PRE15]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Note the order in which the two objects are returned. Besides the two main
    methods, it is sometimes useful to serialize a Python object to a string instead
    of a file. This is done with `dumps` and `loads`. Consider an example of serializing
    an array and a dictionary:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 注意返回的两个对象的顺序。除了这两种主要方法，有时将 Python 对象序列化为字符串而不是文件也是很有用的。这可以通过 `dumps` 和 `loads`
    来实现。以下是序列化数组和字典的一个例子：
- en: '[PRE16]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: A good example of using `dumps` is when you need to write Python objects or
    NumPy arrays to a database. These usually have support for storing strings, which
    makes it easy to write and read complex data and objects without any special modules.
    Besides the `pickle` module, there is also an optimized version called `cPickle`.
    It is written in C and is an option if you need fast reading and writing. The
    data produced by pickle and *cPickle* is identical and can be interchanged.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`dumps`的一个好例子是当你需要将Python对象或NumPy数组写入数据库时。数据库通常支持存储字符串，这使得无需特殊模块就可以轻松地写入和读取复杂数据和对象。除了`pickle`模块，还有一个优化版，称为`cPickle`。它是用C语言编写的，若需要快速的读写操作，可以使用它。`pickle`和`*cPickle*`产生的数据是相同的，可以互换使用。
- en: 14.4 Shelves
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 14.4 文件架构
- en: 'Objects in dictionaries can be accessed by keys. There is a similar way to
    access particular data in a file by first assigning it a key. This is possible
    by using the module `shelve`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 字典中的对象可以通过键来访问。类似地，可以通过先为文件分配一个键来访问特定的数据。这可以通过使用`shelve`模块来实现：
- en: '[PRE17]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In [Section 14.1.1](f95f92d6-d8d1-46a6-bb5b-560714044c70.xhtml): *Interacting
    with files*, we saw that the built-in command `open` generates a context manager,
    and we saw why this is important for handling external resources, such as files.
    In contrast to this command, `sv.open` does not create a context manager by itself.
    The command `closing` from the module `contextlib` is needed to transform it into
    an appropriate context manager.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第14.1.1节](f95f92d6-d8d1-46a6-bb5b-560714044c70.xhtml)：*与文件交互*中，我们看到内置命令`open`会生成一个上下文管理器，我们也了解了这对于处理外部资源（如文件）为什么很重要。与此命令不同，`sv.open`本身不会创建上下文管理器。`contextlib`模块中的命令`closing`需要将其转变为合适的上下文管理器。
- en: 'Consider the following example of restoring the file:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下恢复文件的示例：
- en: '[PRE18]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: A `shelve` object has all dictionary methods, for example, keys and values,
    and can be used in the same way as a dictionary. Note that changes are only written
    in the file after one of the methods `close` or `sync` has been called.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`shelve`对象具有所有字典方法，例如键和值，可以像字典一样使用。请注意，只有在调用了`close`或`sync`等方法后，文件中的更改才会被写入。'
- en: 14.5 Reading and writing Matlab data files
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 14.5 读取和写入Matlab数据文件
- en: SciPy has the ability to read and write data in Matlab's `.mat` file format
    using the module \pyth!scipy.io!. The commands are `loadmat` and `savemat`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: SciPy能够使用模块\pyth!scipy.io!读取和写入Matlab的`.mat`文件格式。相关命令是`loadmat`和`savemat`。
- en: 'To load data, use the following syntax:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 要加载数据，请使用以下语法：
- en: '[PRE19]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The variable data now contains a dictionary, with keys corresponding to the
    variable names saved in the `.mat` file. The variables are in NumPy array format.
    Saving to `.mat` files involves creating a dictionary with all the variables you
    want to save (variable name and value). The command is then `savemat`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 变量数据现在包含一个字典，字典的键对应于保存在`.mat`文件中的变量名。变量以NumPy数组格式存储。保存到`.mat`文件时，需要创建一个包含所有要保存的变量（变量名和对应的值）的字典。然后使用命令`savemat`：
- en: '[PRE20]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This saves the NumPy arrays, `x` and `y`, in Matlab's internal file format,
    thereby preserving variable names.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这将`x`和`y`这两个NumPy数组保存为Matlab的内部文件格式，从而保留变量名。
- en: 14.6 Reading and writing images
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 14.6 读取和写入图像
- en: 'The module `PIL.Image` comes with some functions for handling images. The following
    will read a *JPEG* image, print the shape and type, and then create a resized
    image, and write the new image to a file:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`PIL.Image`模块提供了一些用于处理图像的函数。以下代码将读取一张*JPEG*图像，打印其形状和类型，然后创建一张调整过大小的图像，并将新图像写入文件：'
- en: '[PRE21]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'PIL creates an image object that can easily be converted to a NumPy array.
    As an array object, images are stored with pixel values in the range *0...255* as
    8-bit unsigned integers (`unint8`). The third shape value shows how many color
    channels the image has. In this case, *3* means it is a color image with values
    stored in this order: red `im_array[:,:,0]`, green `im_array[:,:,1]`, and blue `im_array[:,:,2]`.
    A grayscale image would only have one channel.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: PIL创建了一个可以轻松转换为NumPy数组的图像对象。作为数组对象，图像以8位无符号整数（`unint8`）的形式存储像素值，范围为*0...255*。第三个形状值表示图像的颜色通道数。在此情况下，*3*表示这是一个彩色图像，其值按照以下顺序存储：红色`im_array[:,:,0]`，绿色`im_array[:,:,1]`，蓝色`im_array[:,:,2]`。灰度图像只有一个通道。
- en: 'For working with images, the module `PIL` contains many useful basic image
    processing functions, including filtering, transforms, measurements, and conversion
    from a NumPy array to a `PIL` image object:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 对于处理图像，`PIL`模块包含许多有用的基本图像处理功能，包括滤波、变换、度量以及从NumPy数组转换为`PIL`图像对象：
- en: '[PRE22]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 14.7 Summary
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 14.7 总结
- en: File handling is inevitable when dealing with measurements and other sources
    of a larger amount of data. Also, communication with other programs and tools
    is done via file handling.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 文件处理在处理测量数据和其他大量数据源时是不可避免的。此外，与其他程序和工具的通信也是通过文件处理完成的。
- en: You learned to see a file as a Python object, like others, with important methods
    such as `readlines` and `write`. We showed how files can be protected by special
    attributes, which may allow only read or write access.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经学会将文件视为一个Python对象，就像其他对象一样，具有重要的方法，如`readlines`和`write`。我们展示了如何通过特殊属性保护文件，这些属性可能只允许读取或写入访问。
- en: The way you write to a file often influences the speed of the process. We saw
    how data is stored by pickling or by using the method `shelve`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你写入文件的方式往往会影响处理的速度。我们看到数据是通过序列化（pickling）或使用`shelve`方法来存储的。
