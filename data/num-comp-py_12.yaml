- en: Index Alignment
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 索引对齐
- en: When multiple Series or DataFrames are combined in some way, each dimension
    of the data automatically aligns on each axis first before any computation happens.
    This silent and automatic alignment of axes can cause tremendous confusion for
    the uninitiated, but it gives great flexibility to the power user. This chapter
    explores the Index object in-depth before showcasing a variety of recipes that
    take advantage of its automatic alignment.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当多个 Series 或 DataFrame 以某种方式组合时，数据的每个维度都会在每个轴上自动对齐，然后才会进行任何计算。对于未熟悉者来说，这种默默进行的自动对齐可能会引起极大的困惑，但它为高级用户提供了巨大的灵活性。本章深入探讨了索引对象，并展示了一系列利用其自动对齐功能的示例。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Examining the Index object
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查索引对象
- en: Producing Cartesian products
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成笛卡尔积
- en: Exploding indexes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展索引
- en: Filling values with unequal indexes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 填充具有不等索引的值
- en: Appending columns from different DataFrames
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从不同的 DataFrame 中追加列
- en: Highlighting the maximum value from each column
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 突出显示每列的最大值
- en: Replicating `idxmax` with method chaining
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用方法链复制`idxmax`
- en: Finding the most common maximum
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找最常见的最大值
- en: Examining the Index object
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查索引对象
- en: Each axis of Series and DataFrames has an Index object that labels the values.
    There are many different types of Index objects, but they all share the same common
    behavior. All Index objects, except for the special MultiIndex, are single-dimensional
    data structures that combine the functionality and implementation of Python sets
    and NumPy ndarrays.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Series 和 DataFrame 的每个轴都有一个 Index 对象，用于标记值。索引对象有许多不同类型，但它们都具有相同的公共行为。除特殊的 MultiIndex
    外，所有 Index 对象都是一维数据结构，结合了 Python 集合和 NumPy ndarray 的功能和实现。
- en: Getting ready
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备好
- en: In this recipe, we will examine the column index of the college dataset and
    explore much of its functionality.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将检查大学数据集的列索引，并探讨其许多功能。
- en: How to do it...
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Read in the college dataset, assign for the column index to a variable, and
    output it:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取大学数据集，将列索引分配给一个变量，并输出它：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Use the `values` attribute to access the underlying NumPy array:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`values`属性访问底层的NumPy数组：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Select items from the index by integer location with scalars, lists, or slices:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过标量、列表或切片根据整数位置选择索引中的项：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Indexes share many of the same methods as Series and DataFrames:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 索引与 Series 和 DataFrame 共享许多相同的方法：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Use basic arithmetic and comparison operators directly on `Index` objects:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 直接在`Index`对象上使用基本的算术和比较操作符：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Trying to change an Index value directly after its creation fails. Indexes
    are immutable objects:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试在创建后直接更改索引值会失败。索引是不可变对象：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How it works...
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As you can see from many of the Index object operations, it appears to have
    quite a bit in common with both Series and `ndarrays`. One of the biggest differences
    comes in step 6\. Indexes are immutable and their values cannot be changed once
    created.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你从许多索引对象操作中看到的，它似乎与 Series 和`ndarrays`有很多相似之处。最大的区别之一出现在第6步。索引是不可变的，一旦创建，其值不能更改。
- en: There's more...
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Indexes support the set operations, union, intersection, difference, and symmetric
    difference:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 索引支持集合操作：并集、交集、差集和对称差集：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Indexes share some of the same operations as Python sets. Indexes are similar
    to Python sets in another important way. They are (usually) implemented using
    hash tables, which make for extremely fast access when selecting rows or columns
    from a DataFrame. As they are implemented using hash tables, the values for the
    Index object need to be immutable such as a string, integer, or tuple just like
    the keys in a Python dictionary.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 索引与 Python 集合共享一些相同的操作。索引在另一个重要方面与 Python 集合相似。它们（通常）使用哈希表实现，这使得从 DataFrame
    中选择行或列时具有极快的访问速度。由于它们是使用哈希表实现的，索引对象的值需要是不可变的，如字符串、整数或元组，就像 Python 字典中的键一样。
- en: Indexes support duplicate values, and if there happens to be a duplicate in
    any Index, then a hash table can no longer be
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 索引支持重复值，如果某个索引中有重复项，那么哈希表将无法再使用
- en: used for its implementation, and object access becomes much slower.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 用于其实现，且对象访问速度变得更慢。
- en: See also
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: Pandas official documentation of `Index` ([http://bit.ly/2upfgtr](https://pandas.pydata.org/pandas-docs/stable/generated/pandas.Index.html))
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pandas 官方文档中的`Index`（[http://bit.ly/2upfgtr](https://pandas.pydata.org/pandas-docs/stable/generated/pandas.Index.html)）
- en: Producing Cartesian products
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成笛卡尔积
- en: Whenever two Series or DataFrames operate with another Series or DataFrame,
    the indexes (both the row index and column index) of each object align first before
    any operation begins. This index alignment happens silently and can be very surprising
    for those new to pandas. This alignment always creates a Cartesian product between
    the indexes unless the indexes are identical.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 每当两个 Series 或 DataFrame 与另一个 Series 或 DataFrame 进行操作时，每个对象的索引（包括行索引和列索引）首先会进行对齐，才会开始任何操作。这个索引对齐是默默发生的，对于新接触
    pandas 的人来说可能会感到很惊讶。除非索引完全相同，否则这种对齐总是会在索引之间创建一个笛卡尔积。
- en: A Cartesian product is a mathematical term that usually appears in set theory.
    A Cartesian product between two sets is all the combinations of pairs of both
    sets. For example, the 52 cards in a standard playing card deck represent a Cartesian
    product between the 13 ranks (A, 2, 3,..., Q, K) and the four suits.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 笛卡尔积是一个数学术语，通常出现在集合论中。两个集合的笛卡尔积是两个集合中所有可能的元素对的组合。例如，标准扑克牌中的52张牌表示的是13个点数（A，2，3，...，Q，K）与四种花色之间的笛卡尔积。
- en: Getting ready
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Producing a Cartesian product isn't always the intended outcome, but it's extremely
    important to be aware of how and when it occurs to avoid unintended consequences.
    In this recipe, two Series with overlapping but non-identical indexes are added
    together, yielding a surprising result.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 产生笛卡尔积并不总是预期的结果，但了解它是如何发生的以及何时发生，能帮助避免不期望的后果。在这个示例中，两个具有重叠但不同索引的 Series 被相加，产生了一个令人惊讶的结果。
- en: How to do it...
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Follow these steps to create a Cartesian product:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建一个笛卡尔积：
- en: 'Construct two Series that have indexes that are different but contain some
    of the same values:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构造两个具有不同索引但包含一些相同值的 Series：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Add the two Series together to produce a Cartesian product:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这两个 Series 相加，产生一个笛卡尔积：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: How it works...
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Each Series was created with the class constructor which accepts a wide variety
    of inputs with the simplest being a sequence of values for each of the parameters
    `index` and data.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 Series 都是通过类构造函数创建的，该构造函数接受各种各样的输入，其中最简单的输入是每个参数 `index` 和 data 的值序列。
- en: Mathematical Cartesian products are slightly different from the outcome of operating
    on two pandas objects. Each `a` label in `s1` pairs up with each `a` label in
    `s2`. This pairing produces six `a` labels, three `b` labels, and one `c` label
    in the resulting Series. A Cartesian product happens between all identical index
    labels.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 数学上的笛卡尔积与对两个 pandas 对象进行操作的结果略有不同。在 `s1` 中的每个 `a` 标签都会与 `s2` 中的每个 `a` 标签配对。这种配对在结果的
    Series 中产生了六个 `a` 标签，三个 `b` 标签和一个 `c` 标签。笛卡尔积发生在所有相同的索引标签之间。
- en: As the element with label `c` is unique to Series `s2`, pandas defaults its
    value to missing, as there is no label for it to align to in `s1`. Pandas defaults
    to a missing value whenever an index label is unique to one object. This has the
    unfortunate consequence of changing the data type of the Series to a float, whereas
    each Series had only integers as values. This occurred because of NumPy's missing
    value object; `np.nan` only exists for floats but not for integers. Series and
    DataFrame columns must have homogeneous numeric data types; therefore, each value
    was converted to a float. This makes very little difference for this small dataset,
    but for larger datasets, this can have a significant memory impact.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 由于标签 `c` 仅存在于 Series `s2` 中，pandas 默认将其值设为缺失，因为在 `s1` 中没有与之对齐的标签。每当一个索引标签只属于一个对象时，pandas
    会将其默认设置为缺失值。遗憾的是，这导致 Series 的数据类型从整数转换为浮点数，因为 NumPy 的缺失值对象 `np.nan` 只适用于浮点数，而不适用于整数。Series
    和 DataFrame 列必须具有同质的数值数据类型，因此每个值都被转换为浮点数。对于这个小数据集来说差异不大，但对于较大的数据集，这可能会带来显著的内存影响。
- en: There's more...
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'An exception to the preceding example takes place when the indexes contain
    the same exact elements in the same order. When this occurs, a Cartesian product
    does not take place, and the indexes instead align by their position. Notice here
    that each element aligned exactly by position and that the data type remained
    an integer:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例的例外情况发生在索引包含完全相同的元素并且顺序相同的情况下。当发生这种情况时，不会进行笛卡尔积，索引会根据它们的位置对齐。在这里需要注意的是，每个元素都根据位置精确对齐，并且数据类型保持为整数：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If the elements of the index are identical, but the order is different between
    the Series, a Cartesian product occurs. Let''s change the order of the index in
    `s2` and rerun the same operation:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果索引的元素相同，但顺序在两个 Series 之间不同，则会发生笛卡尔积。让我们改变 `s2` 中索引的顺序，并重新运行相同的操作：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: It is quite interesting that pandas has two drastically different outcomes for
    this same operation. If a Cartesian product was the only choice for pandas, then
    something as simple as adding DataFrame columns together would explode the number
    of elements returned.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 很有趣的是，pandas对相同操作有两个截然不同的结果。如果笛卡尔积是pandas的唯一选择，那么像将DataFrame列相加这样简单的操作也会导致返回元素数量的爆炸。
- en: In this recipe, each Series had a different number of elements. Typically, array-like
    data structures in Python and other languages do not allow operations to take
    place when the operating dimensions do not contain the same number of elements.
    Pandas allows this to happen by aligning the indexes first before completing the
    operation.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，每个系列的元素数量不同。通常，在Python和其他语言中，当操作的维度包含不同数量的元素时，不允许进行操作。但Pandas通过首先对齐索引，然后再执行操作，允许这种情况发生。
- en: Exploding indexes
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 爆炸索引
- en: The previous recipe walked through a trivial example of two small Series being
    added together with unequal indexes. This problem can produce comically incorrect
    results when dealing with larger data.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的示例通过两个小系列的加法操作演示了索引不相等时的情况。当处理更大数据时，这个问题可能会产生荒谬的错误结果。
- en: Getting ready
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: In this recipe, we add two larger Series that have indexes with only a few unique
    values but in different orders. The result will explode the number of values in
    the indexes.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们添加了两个较大的系列，它们的索引有少量独特的值，但顺序不同。结果会导致索引中的值数爆炸。
- en: How to do it...
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Read in the employee data and set the index equal to the race column:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取员工数据并将索引设置为种族列：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '![](img/3c2c2456-00e7-471b-9b21-c30ae0628d71.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3c2c2456-00e7-471b-9b21-c30ae0628d71.png)'
- en: 'Select the `BASE_SALARY` column as two different Series. Check to see whether
    this operation actually did create two new objects:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`BASE_SALARY`列作为两个不同的系列。检查此操作是否确实创建了两个新对象：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `salary1` and `salary2` variables are actually referring to the same object.
    This means that any change to one will change the other. To ensure that you receive
    a brand new copy of the data, use the `copy` method:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`salary1`和`salary2`变量实际上引用的是同一个对象。这意味着对其中一个的任何修改都会影响另一个。为了确保获得数据的全新副本，使用`copy`方法：'
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s change the order of the index for one of the Series by sorting it:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过对其中一个系列进行排序来改变其索引的顺序：
- en: '[PRE14]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let''s add these `salary` Series together:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将这两个`salary`系列加在一起：
- en: '[PRE15]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The operation completed successfully. Let''s create one more Series of `salary1`
    added to itself and then output the lengths of each Series. We just exploded the
    index from 2,000 values to more than 1 million:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 操作成功完成。让我们再创建一个`salary1`系列，并将其加到自身，然后输出每个系列的长度。我们将索引从2,000个值爆炸到超过100万个值：
- en: '[PRE16]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: How it works...
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Step 2 appears at first to create two unique objects but in fact, it creates
    a single object that is referred to by two different variable names. The expression `employee['BASE_SALARY']`,
    technically creates a **view**, and not a brand new copy. This is verified with
    the `is` operator.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 第2步乍一看好像创建了两个独特的对象，但实际上它创建了一个单独的对象，通过两个不同的变量名引用。表达式`employee['BASE_SALARY']`技术上创建了一个**视图**，而不是一个全新的副本。通过`is`运算符可以验证这一点。
- en: In pandas, a view is not a new object but just a reference to another object,
    usually some subset of a DataFrame. This shared object can be a cause for many
    issues.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在pandas中，视图不是新对象，而只是另一个对象的引用，通常是DataFrame的某个子集。这个共享对象可能会引发许多问题。
- en: To ensure that both variables reference completely different objects, we use
    the `copy` Series method and again verify that they are different objects with
    the `is` operator. Step 4 uses the `sort_index` method to sort the Series by race.
    Step 5 adds these different Series together to produce some result. By just inspecting
    the head, it's still not clear what has been produced.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保两个变量引用完全不同的对象，我们使用`copy`系列方法，并再次通过`is`运算符验证它们是不同的对象。第4步使用`sort_index`方法按照种族排序系列。第5步将这些不同的系列加在一起，产生某些结果。仅通过查看头部，仍然不清楚已产生了什么。
- en: Step 6 adds `salary1` to itself to show a comparison between the two different
    Series additions. The length of all the Series in this recipe are output and we
    clearly see that `series_add` has now exploded to over one million values. A Cartesian
    product took place for each unique value in the index because the indexes were
    not exactly the same. This recipe dramatically shows how much of an impact the
    index can have when combining multiple Series or DataFrames.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 第6步将`salary1`与自身相加，展示两种不同Series相加的比较。所有Series的长度都已输出，我们清楚地看到`series_add`的值已经爆炸性地增长到超过一百万个值。由于索引不完全相同，每个唯一的索引值之间进行了笛卡尔积。这个例子极大地展示了在合并多个Series或DataFrame时，索引的影响有多大。
- en: There's more...
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: 'We can verify the number of values of `salary_add` by doing a little mathematics.
    As a Cartesian product takes place between all of the same index values, we can
    sum the square of their individual counts. Even missing values in the index produce
    Cartesian products with themselves:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过一点数学计算来验证`salary_add`的值的数量。由于所有相同索引值之间进行了笛卡尔积，我们可以将它们各自的计数的平方相加。即使是缺失的索引值，也会与自己进行笛卡尔积：
- en: '[PRE17]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Filling values with unequal indexes
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用不等索引填充值
- en: When two Series are added together using the plus operator and one of the index
    labels does not appear in the other, the resulting value is always missing. Pandas
    offers the `add` method, which provides an option to fill the missing value.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用加法运算符将两个Series相加时，如果其中一个索引标签在另一个Series中不存在，结果值总是缺失的。Pandas提供了`add`方法，可以选择填充缺失值。
- en: Getting ready
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we add together multiple Series from the `baseball` dataset
    with unequal indexes using the `fill_value` parameter of the `add` method to ensure
    that there are no missing values in the result.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用`add`方法的`fill_value`参数将来自`baseball`数据集的多个Series相加，确保结果中没有缺失值，即使这些Series的索引不相等。
- en: How to do it...
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Read in the three `baseball` datasets and set the index as `playerID`:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取三个`baseball`数据集，并将索引设置为`playerID`：
- en: '[PRE18]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '![](img/3df8c217-9081-49b2-86c8-2737836ff6d9.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3df8c217-9081-49b2-86c8-2737836ff6d9.png)'
- en: 'Use the index method `difference` to discover which index labels are in `baseball_14`
    and not in `baseball_15`, and vice versa:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`difference`索引方法来查找哪些索引标签出现在`baseball_14`中但不在`baseball_15`中，反之亦然：
- en: '[PRE19]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'There are quite a few players unique to each index. Let''s find out how many
    hits each player has in total over the three-year period. The `H` column contains
    the number of hits:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个索引中都有相当多的独特球员。让我们找出每个球员在三年期间的总击球数。`H`列包含击球次数：
- en: '[PRE20]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let''s first add together two Series using the plus operator:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先使用加法运算符将两个Series相加：
- en: '[PRE21]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Even though players `congeha01` and `corpoca01` have recorded hits for 2015,
    their result is missing. Let''s use the `add` method and its parameter, `fill_value`,
    to avoid missing values:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 即使球员`congeha01`和`corpoca01`在2015年有击球记录，他们的结果仍然是缺失的。让我们使用`add`方法及其参数`fill_value`来避免缺失值：
- en: '[PRE22]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We add hits from 2016 by chaining the `add` method once more:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过再次链式调用`add`方法将2016年的击球数据加到一起：
- en: '[PRE23]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Check for missing values in the result:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查结果中是否存在缺失值：
- en: '[PRE24]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: How it works...
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `add` method works similarly to the plus operator but allows for more flexibility
    by providing the `fill_value` parameter to take the place of a non-matching index.
    In this problem, it makes sense to default the non-matching index value to 0,
    but you could have used any other number.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`add`方法与加法运算符类似，但通过提供`fill_value`参数来代替不匹配的索引，从而提供更多灵活性。在这个问题中，将不匹配的索引值默认设置为0是有意义的，但你也可以使用其他任意数字。'
- en: 'There will be occasions when each Series contains index labels that correspond
    to missing values. In this specific instance, when the two Series are added, the
    index label will still correspond to a missing value regardless if the `fill_value`
    parameter is used. To clarify this, take a look at the following example where
    the index label `a` corresponds to a missing value in each Series:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，每个Series中包含的索引标签对应着缺失值。在这个特定的例子中，当两个Series相加时，无论是否使用了`fill_value`参数，索引标签依然会对应缺失值。为了说明这一点，看看下面的例子，其中索引标签`a`在每个Series中都对应着缺失值：
- en: '[PRE25]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: There's more...
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: This recipe shows how to add Series with only a single index together. It is
    also entirely possible to add DataFrames together. Adding DataFrames together
    will align both the index and columns before computation and yield missing values
    for non-matching indexes. Let's start by selecting a few of the columns from the
    2014 baseball dataset.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 本例展示了如何仅使用单一索引将多个 Series 相加。将 DataFrame 相加也是完全可行的。将 DataFrame 相加时，会先对齐索引和列，然后进行计算，并且对于不匹配的索引会生成缺失值。让我们从
    2014 年的棒球数据集中选择几个列开始。
- en: '[PRE26]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '![](img/925e3c65-b0b0-4610-8768-ed57f0f07d3e.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](img/925e3c65-b0b0-4610-8768-ed57f0f07d3e.png)'
- en: 'Let''s also select a few of the same and a few different columns from the 2015
    baseball dataset:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 2015 年的棒球数据集中也选择一些相同的列和一些不同的列：
- en: '[PRE27]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '![](img/48c50717-2d2c-4ab0-b247-7ac9996abf1e.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](img/48c50717-2d2c-4ab0-b247-7ac9996abf1e.png)'
- en: 'Adding the two DataFrames together create missing values wherever rows or column
    labels cannot align. Use the `style` attribute to access the `highlight_null`
    method to easily see where the missing values are:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 将两个 DataFrame 相加时，当行或列标签无法对齐时，会创建缺失值。使用 `style` 属性访问 `highlight_null` 方法，可以轻松查看缺失值的位置：
- en: '[PRE28]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '![](img/7d3abb8d-db33-4a10-b126-7fcdb14c8e92.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7d3abb8d-db33-4a10-b126-7fcdb14c8e92.png)'
- en: 'Only the rows with `playerID` appearing in both DataFrames will be non-missing.
    Similarly, the columns `AB`, `H`, and `R` are the only ones that appear in both
    DataFrames. Even if we use the `add` method with the `fill_value` parameter specified,
    we still have missing values. This is because some combinations of rows and columns
    never existed in our input data. For example, the intersection of `playerID` *congeha01*
    and column `G`. He only appeared in the 2015 dataset that did not have the `G`
    column. Therefore, no value was filled with it:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在两个 DataFrame 中都出现的 `playerID` 行才不会是缺失的。同样，`AB`、`H` 和 `R` 列是两个 DataFrame 中唯一出现的列。即使我们使用
    `add` 方法并指定了 `fill_value` 参数，我们仍然会有缺失值。这是因为某些行和列的组合在输入数据中从未存在过。例如，`playerID` *congeha01*
    与列 `G` 的交集。他只出现在没有 `G` 列的 2015 数据集中。因此，没有为其填充值：
- en: '[PRE29]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '![](img/034d596f-f6a3-4bef-a441-9876f382215f.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](img/034d596f-f6a3-4bef-a441-9876f382215f.png)'
- en: Appending columns from different DataFrames
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从不同 DataFrame 中追加列
- en: All DataFrames can add new columns to themselves. However, as usual, whenever
    a DataFrame is adding a new column from another DataFrame or Series, the indexes
    align first before the new column is created.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 DataFrame 都可以向自己添加新列。然而，像往常一样，每当一个 DataFrame 从另一个 DataFrame 或 Series 添加新列时，索引会先对齐，然后才会创建新列。
- en: Getting ready
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe uses the `employee` dataset to append a new column containing the
    maximum salary of that employee's department.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 本例使用 `employee` 数据集，在其中添加一个包含该员工所在部门最大薪水的新列。
- en: How to do it...
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Import the `employee` data and select the `DEPARTMENT` and `BASE_SALARY` columns
    in a new DataFrame:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入 `employee` 数据并在一个新 DataFrame 中选择 `DEPARTMENT` 和 `BASE_SALARY` 列：
- en: '[PRE30]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Sort this smaller DataFrame by salary within each department:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照每个部门的薪水对这个较小的 DataFrame 进行排序：
- en: '[PRE31]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Use the `drop_duplicates` method to keep the first row of each `DEPARTMENT`:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `drop_duplicates` 方法保留每个 `DEPARTMENT` 的第一行：
- en: '[PRE32]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '![](img/d8ceb0fc-6e16-478d-92aa-0c92e459cee3.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d8ceb0fc-6e16-478d-92aa-0c92e459cee3.png)'
- en: 'Put the `DEPARTMENT` column into the index for each DataFrames:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `DEPARTMENT` 列放入每个 DataFrame 的索引中：
- en: '[PRE33]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now that the indexes contain matching values, we can append a new column to
    the `employee` DataFrame:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在索引已经包含匹配的值，我们可以向 `employee` DataFrame 添加一个新列：
- en: '[PRE34]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '![](img/c4b7b4e0-0965-4667-aa95-5a77cb78a941.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c4b7b4e0-0965-4667-aa95-5a77cb78a941.png)'
- en: 'We can validate our results with the `query` method to check whether there
    exist any rows where `BASE_SALARY` is greater than `MAX_DEPT_SALARY`:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用 `query` 方法验证结果，检查是否存在 `BASE_SALARY` 大于 `MAX_DEPT_SALARY` 的行：
- en: '[PRE35]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '![](img/1e21fa39-41e4-46f4-9077-ce4e247d2181.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1e21fa39-41e4-46f4-9077-ce4e247d2181.png)'
- en: How it works...
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Steps 2 and 3 find the maximum salary for each department. For automatic index
    alignment to work properly, we set each DataFrame index as the department. Step
    5 works because each row index from the left DataFrame; `employee` aligns with
    one and only one index from the right DataFrame, `max_dept_sal`. If `max_dept_sal` had
    repeats of any departments in its index, then the operation would fail.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 第 2 步和第 3 步找到每个部门的最大薪水。为了使自动索引对齐正常工作，我们将每个 DataFrame 的索引设置为部门。第 5 步之所以有效，是因为左侧
    DataFrame `employee` 的每一行索引与右侧 DataFrame `max_dept_sal` 中的唯一一个索引对齐。如果 `max_dept_sal`
    的索引中有重复的部门，则该操作将失败。
- en: 'For instance, let''s see what happens when we use a DataFrame on the right-hand
    side of the equality that has repeated index values. We use the `sample` DataFrame
    method to randomly choose ten rows without replacement:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 比如，假设我们在等号右侧使用一个有重复索引值的 DataFrame，会发生什么情况。我们使用 `sample` DataFrame 方法随机选择十行，且不进行替换：
- en: '[PRE36]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '![](img/c71b573f-af49-4b9e-9bbb-cacd9c5d9532.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c71b573f-af49-4b9e-9bbb-cacd9c5d9532.png)'
- en: 'Notice how there are several repeated departments in the index. Now when we
    attempt to create a new column, an error is raised alerting us that there are
    duplicates. At least one index label in the `employee` DataFrame is joining with
    two or more index labels from `random_salary`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 注意索引中有多个重复的部门。当我们尝试创建一个新列时，系统会提示一个错误，告知我们存在重复项。`employee` DataFrame 中至少有一个索引标签与
    `random_salary` 中的两个或多个索引标签发生了连接：
- en: '[PRE37]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: There's more...
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多……
- en: 'Not all indexes on the left-hand side of the equal sign need to have a match,
    but at most can have one. If there is nothing for the left DataFrame index to
    align to, the resulting value will be missing. Let''s create an example where
    this happens. We will use only the first three rows of the `max_dept_sal` Series
    to create a new column:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 不是所有等号左侧的索引都需要匹配，但最多只能有一个匹配项。如果左侧的 DataFrame 索引没有对应的对齐项，结果值将会缺失。我们来创建一个示例，展示这种情况的发生。我们将只使用
    `max_dept_sal` Series 的前三行来创建一个新列：
- en: '[PRE38]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The operation completed successfully but filled in salaries for only three of
    the departments. All the other departments that did not appear in the first three
    rows of the `max_dept_sal` Series resulted in a missing value.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 操作成功完成，但只填充了三个部门的薪资数据。其他没有出现在 `max_dept_sal` Series 前三行中的部门，结果显示为缺失值。
- en: Highlighting the maximum value from each column
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 突出显示每一列中的最大值
- en: The `college` dataset has many numeric columns describing different metrics
    about each school. Many people are interested in schools that perform the best
    for certain metrics.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`college` 数据集包含许多数值型列，用于描述每所学校的不同指标。很多人对在某些指标上表现最佳的学校感兴趣。'
- en: Getting ready
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe discovers the school that has the maximum value for each numeric
    column and styles the DataFrame in order to highlight the information so that
    it is easily consumed by a user.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方案会发现每个数值型列的最大值，并对 DataFrame 进行样式设置，以突出显示信息，方便用户查看。
- en: How to do it...
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做……
- en: 'Read the college dataset with the institution name as the index:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用机构名称作为索引来读取 college 数据集：
- en: '[PRE39]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'All the other columns besides `CITY` and `STABBR` appear to be numeric. Examining
    the data types from the preceding step reveals unexpectedly that the `MD_EARN_WNE_P10`
    and `GRAD_DEBT_MDN_SUPP` columns are of type object and not numeric. To help get
    a better idea of what kind of values are in these columns, let''s examine their
    first value:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除了 `CITY` 和 `STABBR` 列外，所有其他列似乎都是数值型的。从前一步检查数据类型时，意外发现 `MD_EARN_WNE_P10` 和 `GRAD_DEBT_MDN_SUPP`
    列的数据类型为对象，而非数值型。为了更好地了解这些列的值是什么，让我们检查它们的第一个值：
- en: '[PRE40]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'These values are strings but we would like them to be numeric. This means that
    there are likely to be non-numeric characters that appear elsewhere in the Series.
    One way to check for this is to sort these columns in descending order and examine
    the first few rows:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些值是字符串格式，但我们希望它们是数值型的。这意味着 Series 中可能会出现其他非数值字符。检查的一个方法是将这些列按降序排序，并检查前几行：
- en: '[PRE41]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The culprit appears to be that some schools have privacy concerns about these
    two columns of data. To force these columns to be numeric, use the pandas function `to_numeric`:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 问题似乎出在一些学校对于这两列数据存在隐私问题。为了强制将这些列转换为数值型，可以使用 pandas 的 `to_numeric` 函数：
- en: '[PRE42]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Use the `select_dtypes` method to filter for only numeric columns. This will
    exclude `STABBR` and `CITY` columns, where a maximum value doesn''t make sense
    with this problem:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `select_dtypes` 方法筛选出只有数值型的列。这样可以排除 `STABBR` 和 `CITY` 列，因为在这个问题中，这些列没有最大值的意义：
- en: '[PRE43]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '![](img/8b94a8f7-cb84-4108-b3d3-798f75cdce6d.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8b94a8f7-cb84-4108-b3d3-798f75cdce6d.png)'
- en: 'By utilizing the data dictionary, there are several columns that have only
    binary (0/1) values that will not provide useful information. To programmatically
    find these columns, we can create boolean Series and find all the columns that
    have two unique values with the `nunique` method:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 利用数据字典，有几列仅包含二进制（0/1）值，这些列提供不了有用信息。为了程序化地找到这些列，我们可以创建布尔 Series，并通过 `nunique`
    方法查找所有具有两个唯一值的列：
- en: '[PRE44]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Pass this boolean Series to the indexing operator of the columns index object
    and create a list of the binary columns:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这个布尔系列传递给列索引对象的索引运算符，并创建一个二进制列的列表：
- en: '[PRE45]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Remove the binary columns with the `drop` method:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`drop`方法移除二进制列：
- en: '[PRE46]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '![](img/f0aef0a2-b9f1-404c-8fab-7b302aa8bada.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f0aef0a2-b9f1-404c-8fab-7b302aa8bada.png)'
- en: 'Use the `idxmax` method to find the index label of the maximum value for each
    column:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`idxmax`方法查找每列最大值的索引标签：
- en: '[PRE47]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Call the `unique` method on the `max_cols` Series. This returns an `ndarray`
    of the unique column names:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对`max_cols`系列调用`unique`方法。这将返回一个包含唯一列名的`ndarray`：
- en: '[PRE48]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Use the values of `max_cols` to select only the rows that have schools with
    a maximum value and then use the `style` attribute to highlight these values:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`max_cols`的值来选择只有最大值的学校的行，然后使用`style`属性突出显示这些值：
- en: '[PRE49]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '![](img/eac420e0-ba86-4a95-95aa-059b068cb5fd.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eac420e0-ba86-4a95-95aa-059b068cb5fd.png)'
- en: How it works...
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `idxmax` method is very powerful and becomes quite useful when the index
    is meaningfully labeled. It was unexpected that both `MD_EARN_WNE_P10` and `GRAD_DEBT_MDN_SUPP`
    were of `object` data type. When importing, pandas coerces all numeric values
    of columns to strings if the column contains at least one string.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`idxmax`方法非常强大，当索引有意义的标签时，它变得非常有用。没想到`MD_EARN_WNE_P10`和`GRAD_DEBT_MDN_SUPP`都是`object`数据类型。在导入时，如果列中至少包含一个字符串，Pandas会将所有数字值强制转换为字符串。'
- en: By examining a specific column value in step 2, we were able to see clearly
    that we had strings in these columns. In step 3, we sort in descending order as
    numeric characters appear first. This elevates all alphabetical values to the
    top of the Series. We uncover the `PrivacySuppressed` string causing havoc. Pandas
    has the ability to force all strings that contain only numeric characters to actual
    numeric data types with the `to_numeric` function. To override the default behavior
    of raising an error when `to_numeric` encounters a string that cannot be converted,
    you must pass *coerce* to the `errors` parameter. This forces all non-numeric
    character strings to become missing values (`np.nan`).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 通过检查第2步中的特定列值，我们清楚地看到这些列中包含了字符串。在第3步中，我们按降序排序，因为数字字符会首先出现。这将所有字母值提升到Series的顶部。我们发现了导致问题的`PrivacySuppressed`字符串。Pandas能够使用`to_numeric`函数强制将仅包含数字字符的所有字符串转换为实际的数字数据类型。为了覆盖`to_numeric`在遇到无法转换的字符串时抛出错误的默认行为，必须将*coerce*传递给`errors`参数。这会强制所有非数字字符的字符串变为缺失值（`np.nan`）。
- en: Several columns don't have useful or meaningful maximum values. They were removed
    in step 4 through step 6\. The `select_dtypes` can be extremely useful for very
    wide DataFrames with lots of columns.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个列没有有用或有意义的最大值。它们在第4步到第6步中被移除。`select_dtypes`对于包含许多列的宽数据框非常有用。
- en: In step 7, `idxmax` iterates through all the columns to find the index of the
    maximum value for each column. It outputs the results as a Series. The school
    with both the highest SAT math and verbal scores is California Institute of Technology.
    Dongguk University Los Angeles has the highest number of students older than 25.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在第7步中，`idxmax`遍历所有列，查找每列的最大值索引。它将结果输出为一个Series。既有最高的SAT数学成绩，也有最高的SAT语文成绩的学校是加利福尼亚理工学院。东国大学洛杉矶校区的学生人数超过25岁的是最多的。
- en: Although the information provided by `idxmax` is nice, it does not yield the
    corresponding maximum value. To do this, we gather all the unique school names
    from the values of the `max_cols` Series.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`idxmax`提供的信息很有用，但它并没有给出相应的最大值。为此，我们从`max_cols`系列中的值中收集所有唯一的学校名称。
- en: Finally, in step 8, we use the `.loc` indexer to select rows based on the index
    label, which we made as school names in the first step. This filters for only
    schools that have a maximum value. DataFrames have an experimental `style` attribute
    that itself has some methods to alter the appearance of the displayed DataFrame.
    Highlighting the maximum value makes the result much clearer.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在第8步中，我们使用`.loc`索引器根据索引标签选择行，索引标签在第一步中作为学校名称创建。这只筛选出具有最大值的学校。数据框有一个实验性的`style`属性，它本身有一些方法可以改变显示数据框的外观。突出显示最大值使结果更加清晰。
- en: There's more...
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'By default, the `highlight_max` method highlights the maximum value of each
    column. We can use the `axis` parameter to highlight the maximum value of each
    row instead. Here, we select just the race percentage columns of the `college`
    dataset and highlight the race with the highest percentage for each school:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`highlight_max`方法会高亮显示每列的最大值。我们可以使用`axis`参数来高亮显示每行的最大值。在这里，我们只选择`college`数据集中的种族百分比列，并突出显示每个学校的最高百分比种族：
- en: '[PRE50]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '![](img/55f8f912-bfef-4d73-9205-ee2c8d67e1cb.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](img/55f8f912-bfef-4d73-9205-ee2c8d67e1cb.png)'
- en: Attempting to apply a style on a large DataFrame can cause Jupyter to crash,
    which is why the style was only applied to the head of the DataFrame.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在大型DataFrame上应用样式可能会导致Jupyter崩溃，这就是为什么样式只应用于DataFrame的头部。
- en: See also
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: Pandas official documentation on Dataframe *Styling* ([http://bit.ly/2hsZkVK](https://pandas.pydata.org/pandas-docs/stable/style.html))
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pandas官方文档关于DataFrame *样式*的说明（[http://bit.ly/2hsZkVK](https://pandas.pydata.org/pandas-docs/stable/style.html)）
- en: Replicating idxmax with method chaining
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用方法链模拟`idxmax`
- en: It can be a good exercise to attempt an implementation of a built-in DataFrame
    method on your own. This type of replication can give you a deeper understanding
    of other pandas methods that you normally wouldn't have come across. `idxmax`
    is a challenging method to replicate using only the methods covered thus far in
    the book.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试自己实现一个内置的DataFrame方法是一个很好的练习。这种类型的模仿可以帮助你更深入地理解一些通常不会接触到的其他pandas方法。`idxmax`是一个挑战性很大的方法，仅使用本书中讲解过的方法来实现它比较困难。
- en: Getting ready
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe slowly chains together basic methods to eventually find all the
    row index values that contain a maximum column value.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法逐步链式调用基本方法，最终找到所有包含最大列值的行索引值。
- en: How to do it...
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现……
- en: 'Load in the college dataset and execute the same operations as the previous
    recipe to get only the numeric columns that are of interest:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载`college`数据集，并执行与前一个方法相同的操作，以获取我们感兴趣的数值列：
- en: '[PRE51]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Find the maximum of each column with the `max` method:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`max`方法找到每列的最大值：
- en: '[PRE52]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Use the `eq` DataFrame method to test each value with its column `max`. By
    default, the `eq` method aligns the columns of the column DataFrame with the labels
    of the passed Series index:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`eq`方法测试DataFrame中的每个值与其列的`max`值是否相等。默认情况下，`eq`方法会将DataFrame的列与传递的Series索引的标签对齐：
- en: '[PRE53]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '![](img/e0256497-0a05-4391-b89c-474c19ba9c8a.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e0256497-0a05-4391-b89c-474c19ba9c8a.png)'
- en: 'All the rows in this DataFrame that have at least one `True` value must contain
    a column maximum. Let''s use the `any` method to find all such rows that have
    at least one `True` value:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个DataFrame中所有至少包含一个`True`值的行必须包含一个列最大值。我们可以使用`any`方法来查找所有包含至少一个`True`值的行：
- en: '[PRE54]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'There are only 18 columns, which means that there should only be at most 18
    `True` values in `has_row_max`. Let''s find out how many there actually are:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只有18列，这意味着`has_row_max`中最多只有18个`True`值。让我们查找实际有多少个：
- en: '[PRE55]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'This was a bit unexpected, but it turns out that there are columns with many
    rows that equal the maximum value. This is common with many of the percentage
    columns that have a maximum of 1\. `idxmax` returns the first occurrence of the
    maximum value. Let''s back up a bit, remove the `any` method, and look at the
    output from step 3\. Let''s run the `cumsum` method instead to accumulate all
    the `True` values. The first and last three rows are shown:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这有点出乎意料，但事实证明，有些列有很多行等于最大值。这在许多百分比列中很常见，这些列的最大值为1。`idxmax`返回最大值的第一次出现。让我们退后一步，去掉`any`方法，查看步骤3的输出。我们改用`cumsum`方法来累积所有的`True`值。展示的是前后三行数据：
- en: '[PRE56]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '![](img/3591f3ec-bbbd-49d3-834c-c838e44f4009.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3591f3ec-bbbd-49d3-834c-c838e44f4009.png)'
- en: 'Some columns have one unique maximum like `SATVRMID` and `SATMTMID`, while
    others like `UGDS_WHITE` have many. 109 schools have 100% of their undergraduates
    as white. If we chain the `cumsum` method one more time, the value 1 would only
    appear once in each column and it would be the first occurrence of the maximum:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有些列只有一个唯一的最大值，比如`SATVRMID`和`SATMTMID`，而像`UGDS_WHITE`这样的列有很多最大值。109所学校的本科生全部是白人。如果我们再链式调用一次`cumsum`方法，值1将在每列中只出现一次，并且它会是最大值的第一次出现：
- en: '[PRE57]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '![](img/0528cfc1-4884-47df-a1d5-fa527e3ea823.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0528cfc1-4884-47df-a1d5-fa527e3ea823.png)'
- en: 'We can now test the equality of each value against 1 with the `eq` method and
    then use the `any` method to find rows that have at least one `True` value:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以使用`eq`方法测试每个值是否等于1，然后使用`any`方法查找包含至少一个`True`值的行：
- en: '[PRE58]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Test that `has_row_max2` has no more `True` values than the number of columns:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试`has_row_max2`是否没有超过列数的`True`值：
- en: '[PRE59]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'We need all the institutions where `has_row_max2` is `True`. We can simply
    use boolean indexing on the Series itself:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要所有`has_row_max2`为`True`的机构。我们可以简单地在系列上使用布尔索引：
- en: '[PRE60]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'All 16 of these institutions are the index of the first maximum occurrence
    for at least one of the columns. We can check whether they are the same as the
    ones found with the `idxmax` method:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这16个机构是至少包含一个列的首次最大值发生的索引。我们可以检查它们是否与通过`idxmax`方法找到的相同：
- en: '[PRE61]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: How it works...
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The first step replicates work from the previous recipe by converting two columns
    to numeric and eliminating the binary columns. We find the maximum value of each
    column in step 2\. Care needs to be taken here as pandas silently drops columns
    that it cannot produce a maximum. If this happens, then step 3 will still complete
    but produce all `False` values for each column without an available maximum.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步通过将两列转换为数字并去除二进制列，复制了之前配方中的工作。在第二步中，我们找到每列的最大值。需要注意的是，pandas 会默默地丢弃它无法计算最大值的列。如果发生这种情况，那么第三步仍然会完成，但对于每个没有最大值的列，都会产生`False`值。
- en: Step 4 uses the `any` method to scan across each row in search of at least one
    `True` value. Any row with at least one `True` value contains a maximum value
    for a column. We sum up the resulting boolean Series in step 5 to determine how
    many rows contain a maximum. Somewhat unexpectedly, there are far more rows than
    columns. Step 6 gives insight on why this happens. We take a cumulative sum of
    the output from step 3 and detect the total number of rows that equal the maximum
    for each column.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 第四步使用`any`方法扫描每一行，寻找至少一个`True`值。任何包含至少一个`True`值的行都表示该列有一个最大值。在第五步中，我们将结果布尔系列相加，确定有多少行包含最大值。有些出乎意料的是，行数远远多于列数。第六步解释了为什么会发生这种情况。我们对第三步的输出进行累计求和，检测每列的最大值等于多少行的总数。
- en: Many colleges have 100% of their student population as only a single race. This
    is by far the largest contributor to the multiple rows with maximums. As you can
    see, there is only one row with a maximum value for both SAT score columns and
    undergraduate population, but several of the race columns have a tie for the maximum.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 许多学院的学生群体中100%属于单一种族。这是多行最大值出现的最大原因。如你所见，SAT分数列和本科生人数列只有一行最大值，但多个种族列则有最大值的平局。
- en: Our goal is to find the first row with the maximum value. We need to take the
    cumulative sum once more so that each column has only a single row equal to 1\.
    Step 8 formats the code to have one method per line and runs the `any` method
    exactly as it was done in step 4\. If this step is successful, then we should
    have no more `True` values than the number of columns. Step 9 asserts that this
    is true.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是找到具有最大值的第一行。我们需要再次进行累计求和，这样每列只有一行等于1。第8步将代码格式化为每行一个方法，并且如同第4步那样运行`any`方法。如果此步骤成功，那么我们应该没有比列数更多的`True`值。第9步验证了这一点。
- en: To validate that we have found the same columns as `idxmax` in the previous
    columns, we use boolean selection on `has_row_max2` with itself. The columns will
    be in a different order so we convert the sequence of column names to sets, which
    are inherently unordered to compare equality.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证我们找到的列与之前列中的`idxmax`相同，我们在`has_row_max2`上使用布尔选择。由于列的顺序会不同，因此我们将列名序列转换为集合，集合本身是无序的，用来比较相等性。
- en: There's more...
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'It is possible to complete this recipe in one long line of code chaining the
    indexing operator with an anonymous function. This little trick removes the need
    for step 10\. We can time the difference between the direct `idxmax` method and
    our manual effort in this recipe:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将索引操作符与匿名函数链式调用，实际上可以在一行代码中完成这个配方。这一小技巧去除了第10步的需要。我们可以对比直接使用`idxmax`方法和我们手动实现的时间差：
- en: '[PRE62]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Our effort is, unfortunately, five times as slow as the built-in `idxmax` pandas
    method but regardless of its performance regression, many creative and practical
    solutions use the accumulation methods like `cumsum` with boolean Series to find
    streaks or specific patterns along an axis.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我们的努力比内置的`idxmax` pandas方法慢五倍，但无论其性能回退如何，许多富有创意和实用的解决方案都使用类似`cumsum`的累计方法与布尔系列一起，沿着轴找到连续的序列或特定的模式。
- en: Finding the most common maximum
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找最常见的最大值
- en: The college dataset contains the undergraduate population percentage of eight
    different races for over 7,500 colleges. It would be interesting to find the race
    with the highest undergrad population for each school and then find the distribution
    of this result for the entire dataset. We would be able to answer a question like,
    *What percentage of institutions have more white students than any other race?*
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 该大学数据集包含超过7,500所大学的八种不同种族的本科生人口比例。我们可以尝试找出每所学校本科生中种族比例最高的种族，并找到这个结果在整个数据集中的分布。我们可以回答一个问题，例如，*有多少比例的学校白人学生比例高于其他任何种族？*
- en: Getting ready
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: In this recipe, we find the race with the highest percentage of the undergraduate
    population for each school with the `idxmax` method and then find the distribution
    of these maximums.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用`idxmax`方法找到每所学校本科生中种族比例最高的种族，然后查找这些最大值的分布。
- en: How to do it...
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Read in the college dataset and select just those columns with undergraduate
    race percentage information:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取大学数据集并仅选择那些包含本科生种族比例信息的列：
- en: '[PRE63]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '![](img/69b400f6-4d02-4018-9443-ba548c759335.png)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![](img/69b400f6-4d02-4018-9443-ba548c759335.png)'
- en: 'Use the `idxmax` method to get the column name with the highest race percentage
    for each row:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`idxmax`方法获取每行中种族比例最高的列名称：
- en: '[PRE64]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Use the `value_counts` method to return the distribution of maximum occurrences:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`value_counts`方法返回最大出现次数的分布：
- en: '[PRE65]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: How it works...
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: The key to this recipe is recognizing that the columns all represent the same
    unit of information. We can compare these columns with each other, which is usually
    not the case. For instance, it wouldn't make sense to directly compare SAT verbal
    scores with the undergraduate population. As the data is structured in this manner,
    we can apply the `idxmax` method to each row of data to find the column with the
    largest value. We need to alter its default behavior with the `axis` parameter.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子的关键在于认识到这些列都代表相同的信息单位。我们可以相互比较这些列，这通常不是常见的情况。例如，直接比较SAT语文成绩和本科生人口比例是没有意义的。由于数据是以这种方式结构化的，我们可以对每一行数据应用`idxmax`方法来找到最大值所在的列。我们需要使用`axis`参数来修改其默认行为。
- en: Step 2 completes this operation and returns a Series, to which we can now simply
    apply the `value_counts` method to return the distribution. We pass `True` to
    the `normalize` parameter as we are interested in the distribution (relative frequency)
    and not the raw counts.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 第2步完成了此操作并返回了一个Series，现在我们可以简单地应用`value_counts`方法来返回分布。我们将`True`传递给`normalize`参数，因为我们关心的是分布（相对频率），而不是原始计数。
- en: There's more...
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多……
- en: 'We might want to explore more and answer the question: For the schools with
    more black students than any other race, what is the distribution of its second
    highest race percentage?'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能还想进一步探索并回答这个问题：对于那些黑人学生比例高于任何其他种族的学校，它们的第二高种族比例的分布是什么？
- en: '[PRE66]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: We needed to drop the `UGDS_BLACK` column before applying the same method from
    this recipe. Interestingly, it seems that these schools with higher black populations
    have a tendency to have higher Hispanic populations.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用本例中的相同方法之前，我们需要删除`UGDS_BLACK`列。有趣的是，似乎这些黑人学生比例较高的学校也倾向于有更高的西班牙裔学生比例。
