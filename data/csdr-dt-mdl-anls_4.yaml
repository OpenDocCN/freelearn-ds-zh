- en: Chapter 4. Indexes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章 索引
- en: There is no doubt that Cassandra can store a gigantic volume of data effortlessly.
    However, if we cannot efficiently look for what we want in such a data abyss,
    it is meaningless. Cassandra provides very good support to search and retrieve
    the desired data by the primary index and secondary index.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，Cassandra可以轻松地存储大量数据。然而，如果我们不能高效地在这样的数据深渊中找到我们想要的东西，那么这一切都是没有意义的。Cassandra通过主索引和二级索引提供了非常好的支持，以搜索和检索所需的数据。
- en: In this chapter, we will look at how Cassandra uses the primary index and the
    secondary index to spotlight the data. After developing an understanding of them,
    we can then design a high-performance data model.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨Cassandra如何使用主索引和二级索引来突出显示数据。在理解了它们之后，我们就可以设计一个高性能的数据模型。
- en: Primary index
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主索引
- en: Cassandra is a column-based database. Each row can have different number of
    columns. A cell is the placeholder of the value and the timestamp data is identified
    by a row and column. Each cell can store values that are less than 2 GB. The rows
    are grouped by partitions. The maximum number of cells per partition is limited
    to the condition that the number of rows times the number of columns is less than
    2 billion. Each row is identified by a row key that determines which machine stores
    the row. In other words, the row key determines the node location of the row.
    A list of row keys of a table is known as a primary key. A primary index is just
    created on the primary key.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Cassandra是一个基于列的数据库。每一行可以有不同的列数。单元格是值的占位符，时间戳数据通过行和列来标识。每个单元格可以存储小于2 GB的值。行通过分区进行分组。每个分区的单元格数量限制在行数乘以列数小于20亿的条件之下。每一行通过行键来标识，该键决定了存储该行的机器。换句话说，行键决定了行的节点位置。一个表的所有行键列表称为主键。主索引仅仅创建在主键上。
- en: A primary key can be defined on a single column or multiple columns. In either
    case, the first component of a table's primary key is the partition key. Each
    node stores a data partition of the table and maintains its own primary key for
    the data that it manages. Therefore, each node knows what ranges of row key it
    can manage and the rows can then be located by scanning the row indexes only on
    the relevant replicas. The range of the primary keys that a node manages is determined
    by the partition key and a cluster-wide configuration parameter called partitioner.
    Cassandra provides three choices to partitioner that will be covered later in
    this chapter.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 主键可以定义在单个列或多个列上。在任一情况下，表的主键的第一个组件是分区键。每个节点存储表的数据分区，并维护其管理的数据的主键。因此，每个节点都知道它可以管理的行键的范围，并且可以通过扫描相关副本上的行索引来定位行。节点管理的主键范围由分区键和一个称为分区器的集群范围配置参数确定。Cassandra提供了三种分区器选择，将在本章后面介绍。
- en: 'A primary key can be defined by the CQL keywords `PRIMARY KEY`, with the column(s)
    to be indexed. Imagine that we want to store the daily stock quotes into a Cassandra
    table called `dayquote01`. The `CREATE TABLE` statement creates a table with a
    simple primary key that involves only one column, as shown in the following screenshot:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 主键可以通过CQL关键字`PRIMARY KEY`来定义，包括要索引的列。想象一下，我们想要将每日股票报价存储到名为`dayquote01`的Cassandra表中。`CREATE
    TABLE`语句创建了一个具有简单主键的表，该主键仅涉及一个列，如下面的截图所示：
- en: '![Primary index](img/8884OS_04_01.jpg)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![主索引](img/8884OS_04_01.jpg)'
- en: The `symbol` field is assigned the primary key of the `dayquote01` table. This
    means that all the rows of the same symbol are stored on the same node. Hence,
    this makes the retrieval of these rows very efficient.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '`symbol`字段被分配为`dayquote01`表的唯一键。这意味着具有相同`symbol`的所有行都存储在同一个节点上。因此，这使得这些行的检索非常高效。'
- en: 'Alternatively, the primary key can be defined by an explicit `PRIMARY KEY`
    clause, as shown in the following screenshot:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，主键可以通过显式的`PRIMARY KEY`子句来定义，如下面的截图所示：
- en: '![Primary index](img/8884OS_04_02.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![主索引](img/8884OS_04_02.jpg)'
- en: 'Unlike relational databases, Cassandra does not enforce a unique constraint
    on the primary key, as there is no *primary key violation* in Cassandra. An `INSERT`
    statement using an existing row key is allowed. Therefore, in CQL, `INSERT` and
    `UPDATE` act in the same way, which is known as **UPSERT**. For example, we can
    insert two records into the table `dayquote01` with the same symbol and no primary
    key violation is alerted, as shown in the following screenshot:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 与关系数据库不同，Cassandra不对主键强制唯一约束，因为在Cassandra中没有*主键违规*。使用现有行键的`INSERT`语句是允许的。因此，在CQL中，`INSERT`和`UPDATE`的行为相同，这被称为**UPSERT**。例如，我们可以将两个记录插入到`dayquote01`表中，具有相同的符号，并且不会发出主键违规的警告，如下面的截图所示：
- en: '![Primary index](img/8884OS_04_03.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![主索引](img/8884OS_04_03.jpg)'
- en: The returned query result contains only one row, not two rows as expected. This
    is because the primary key is the symbol and the row in the latter `INSERT` statement
    overrode the record that was created by the former `INSERT` statement. There is
    no warning for a duplicate primary key. Cassandra simply and quietly updated the
    row. This silent UPSERT behavior might sometimes cause undesirable effects in
    the application logic.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的查询结果只包含一行，而不是预期的两行。这是因为主键是符号，后一个`INSERT`语句中的行覆盖了前一个`INSERT`语句创建的记录。对于重复的主键没有警告。Cassandra简单地、默默地更新了行。这种静默的UPSERT行为有时可能会在应用逻辑中产生不良影响。
- en: Tip
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Hence, it is very important for an application developer to handle duplicate
    primary key situations in the application logic. Do not rely on Cassandra to check
    the uniqueness for you.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于应用程序开发者来说，在应用逻辑中处理重复主键情况非常重要。不要依赖Cassandra为您检查唯一性。
- en: 'In fact, the reason why Cassandra behaves like this becomes more clear when
    we know how the internal storage engine stores the row, as shown by Cassandra
    CLI in the following screenshot:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，当我们知道Cassandra的内部存储引擎如何存储行时，Cassandra CLI显示的以下截图会使这种行为的原因变得更加清晰：
- en: '![Primary index](img/8884OS_04_04.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![主索引](img/8884OS_04_04.jpg)'
- en: The row key is `0001.HK`. It is used to locate which node is used to store the
    row. Whenever we insert or update the row of the same row key, Cassandra blindly
    locates the row and modifies the columns accordingly, even though an `INSERT`
    statement has been used.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 行键是 `0001.HK`。它用于定位哪个节点被用来存储该行。每次当我们插入或更新具有相同行键的行时，Cassandra都会盲目地定位该行并相应地修改列，即使使用了`INSERT`语句。
- en: Although a single column primary key is not uncommon, a primary key composed
    of more than one column is much more practical.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然单列主键并不罕见，但由多个列组成的复合主键更加实用。
- en: Compound primary key and composite partition key
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复合主键和复合分区键
- en: 'A compound primary key is composed of more than one column. The order of the
    columns is important. The structure of a compound primary key is depicted in the
    following figure:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 复合主键由多个列组成。列的顺序很重要。复合主键的结构如图所示：
- en: '![Compound primary key and composite partition key](img/8884OS_04_05.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![复合主键和复合分区键](img/8884OS_04_05.jpg)'
- en: Columns 1 to A are used as the partition key for Cassandra to determine the
    node location for the partition. The remaining columns, columns B to N, are referred
    to as the clustering columns for the ordering of data. The clustering columns
    are used to locate a unique record in the data node. They are ordered, by default,
    and have the ability to use the `ORDER BY [DESC]` clause in the `SELECT` statements.
    Moreover, we can get the `MIN` or `MAX` values for clustering keys with the `LIMIT
    1` clause. We also need to use the clustering columns for the predicates in a
    `WHERE` clause. We cannot leave out one when trying to build a query.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 列1到A被用作Cassandra的分区键，以确定分区所在的节点位置。其余的列，即列B到N，被称为排序列，用于数据的排序。排序列用于定位数据节点中的唯一记录。默认情况下，它们是有序的，并且可以在`SELECT`语句中使用`ORDER
    BY [DESC]`子句。此外，我们可以使用`LIMIT 1`子句获取排序键的`MIN`或`MAX`值。我们还需要在`WHERE`子句的谓词中使用排序列。在构建查询时，我们不能省略任何一个。
- en: 'To define a compound primary key, an explicit `PRIMARY KEY` clause must be
    used in the `CREATE TABLE` or `ALTER TABLE` statements. We can define a compound
    primary key for the table `dayquote03`, as shown in the following screenshot:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义复合主键，必须在`CREATE TABLE`或`ALTER TABLE`语句中使用显式的`PRIMARY KEY`子句。我们可以为`dayquote03`表定义一个复合主键，如下面的截图所示：
- en: '![Compound primary key and composite partition key](img/8884OS_04_06.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![复合主键和复合分区键](img/8884OS_04_06.jpg)'
- en: Because the first part of the primary key (that is `symbol`) is the same as
    that of the simple primary key, the partition key is the same as that in `dayquote01`.
    Therefore, the node location is the same regardless of whether the primary key
    is compound or not, as in this case.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 因为主键的第一部分（即`symbol`）与简单主键相同，所以分区键与`dayquote01`中的相同。因此，无论主键是复合的还是简单的，节点位置都是相同的，就像在这个例子中一样。
- en: 'So, what is difference between the simple primary key (`symbol`) and this compound
    one (`symbol, price_time`)? The additional field `price_time` instructs Cassandra
    to guarantee the clustering or ordering of the rows within the partition by the
    values of `price_time`. Thus, the compound primary key sorts the rows of the same
    symbol by `price_time`. We insert two records into the `dayquote03` table and
    select all the records to see the effect, as shown in the following screenshot:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，简单主键（`symbol`）和这个复合主键（`symbol, price_time`）之间有什么区别呢？额外的字段`price_time`指示Cassandra通过`price_time`的值保证分区内行的聚类或排序。因此，复合主键按`price_time`对相同符号的行进行排序。我们在`dayquote03`表中插入两条记录，并选择所有记录以查看效果，如下面的截图所示：
- en: '![Compound primary key and composite partition key](img/8884OS_04_07.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![复合主键和复合分区键](img/8884OS_04_07.jpg)'
- en: 'Two records are returned as expected (compared to only one record in `dayquote01`).
    Moreover, the ordering of the results is sorted by the values of `price_time`.
    The following screenshot shows the internal view of the rows in the `dayquote03`
    table:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期地返回了两条记录（与`dayquote01`中仅返回一条记录相比）。此外，结果按`price_time`的值排序。以下截图显示了`dayquote03`表中行的内部视图：
- en: '![Compound primary key and composite partition key](img/8884OS_04_08.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![复合主键和复合分区键](img/8884OS_04_08.jpg)'
- en: The row key is still the partition key, that is, `0001.HK`. However, Cassandra
    stores the two rows returned by the CQL `SELECT` statement, as one single internal
    row in its storage. The values of the clustering columns are used as a prefix
    to the columns that are not specified in the `PRIMARY KEY` clause. As Cassandra
    stores the internal columns in the sorting order of the column name, the rows
    returned by the CQL `SELECT` statement are sorted inherently. In a nutshell, on
    a physical node, when the rows for a partition key are stored in the order that
    is based on the clustering columns, the retrieval of rows is very efficient.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 行键仍然是分区键，即`0001.HK`。然而，Cassandra将CQL `SELECT`语句返回的两个行存储为其存储中的一个单独的内部行。聚类列的值用作未在`PRIMARY
    KEY`子句中指定的列的前缀。由于Cassandra按列名排序存储内部列，因此CQL `SELECT`语句返回的行是按顺序存储的。简而言之，在物理节点上，当分区键的行按聚类列的顺序存储时，行的检索效率非常高。
- en: Now you know that the first part of a compound primary key is the partition
    key. If we need to keep on storing 3,000 daily quotes (around 10 years) for `0001.HK`,
    although the CQL `SELECT` statement returns 3,000 virtual rows, Cassandra requires
    to store these 3,000 virtual rows as one entire row on a node by the partition
    key. The size of the entire row gets bigger and bigger on a node as a result of
    storing more and more daily quotes. The row will quickly become gigantic over
    a period of time and will then pose a serious performance problem, as a result
    of an unbalanced cluster. The solution is a feature offered by Cassandra called
    composite partition key.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道复合主键的第一部分是分区键。如果我们需要继续存储`0001.HK`的3,000条每日报价（大约10年），尽管CQL `SELECT`语句返回3,000条虚拟行，但Cassandra需要根据分区键将这些3,000条虚拟行作为一个完整的行存储在节点上。随着每日报价的存储越来越多，整个行的大小在节点上会越来越大。随着时间的推移，行将迅速变得巨大，并因此由于集群不平衡而引发严重的性能问题。解决方案是Cassandra提供的一个称为复合分区键的功能。
- en: 'The composite partition key spreads the data over multiple nodes. It is defined
    by an extra set of parentheses in the `PRIMARY KEY` clause. Let us create another
    table `dayquote04` with a composite partition key in order to illustrate the effect.
    The columns `exchange` and `symbol` are now members of a composite partition key,
    whereas the column `price_time` is a clustering column. We insert the same two
    records of different symbols into `dayquote04`, as shown in the following screenshot:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 复合分区键将数据分散到多个节点上。它由`PRIMARY KEY`子句中的额外一组括号定义。让我们创建另一个具有复合分区键的表`dayquote04`，以便说明其效果。现在，`exchange`和`symbol`列是复合分区键的成员，而`price_time`列是一个聚类列。我们向`dayquote04`中插入相同但符号不同的两条记录，如下面的截图所示：
- en: '![Compound primary key and composite partition key](img/8884OS_04_09.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![复合主键和复合分区键](img/8884OS_04_09.jpg)'
- en: 'With reference to the following screenshot, two internal rows are returned
    with their row keys as `SEHK:0001.HK` and `SEHK:0002.HK`, respectively. Internally,
    Cassandra concatenates the columns in the composite partition key together as
    an internal row key. In short, the original row without a composite partition
    key is now split into two rows. As the row keys are now different from each other,
    the corresponding rows can be stored on different nodes. The value of the clustering
    column `price_time` is still used as a prefix in the internal column name to preserve
    the ordering of data:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下截图所示，返回了两个内部行，它们的行键分别为`SEHK:0001.HK`和`SEHK:0002.HK`。在内部，Cassandra将复合分区键中的列连接起来作为一个内部行键。简而言之，原始的没有复合分区键的行现在被分割成两个行。由于行键现在不同，相应的行可以存储在不同的节点上。聚类列`price_time`的值仍然用作内部列名的前缀，以保留数据的顺序：
- en: '![Compound primary key and composite partition key](img/8884OS_04_10.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![复合主键和复合分区键](img/8884OS_04_10.jpg)'
- en: Time-series data
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 时间序列数据
- en: Cassandra is very suitable for handling time-series type of data, such as web
    server logfiles, usage data, sensor data, SIP packets, and so on. The tables `dayquote01`
    to `dayquote04` in the previous sections are used to store the daily stock quotes
    is an example of the time-series data.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Cassandra非常适合处理时间序列类型的数据，例如Web服务器日志文件、使用数据、传感器数据、SIP数据包等。前几节中的`dayquote01`到`dayquote04`表用于存储每日股票报价，是时间序列数据的一个例子。
- en: 'We have just seen in the last section that a composite partition key is a better
    way of not overwhelming the row. It limits the size of the rows on the basis of
    a symbol. However, this does partially solve the problem. The size of the row
    of a symbol still grows over a period of time. Do you have any other suggestion?
    We can define an artificial column, `quote_date`, in the table and set the composite
    partition key to `exchange` and `quote_date` instead, as shown in the following
    screenshot:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一个部分中已经看到，复合分区键是一种避免过度压榨行的更好方法。它基于符号限制行的尺寸。然而，这仅仅部分解决了问题。符号行的尺寸仍然会在一段时间内增长。您还有其他建议吗？我们可以在表中定义一个人工列，`quote_date`，并将复合分区键设置为`exchange`和`quote_date`，如下面的截图所示：
- en: '![Time-series data](img/8884OS_04_11.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![时间序列数据](img/8884OS_04_11.jpg)'
- en: Now the composite partition key limits the size of the rows on a daily basis,
    and makes the rows more manageable. This way of doing is analogous to inserting
    the data into different buckets labeled by a particular date. Hence, it is given
    a name called the **date bucket pattern**. Partitioning by the date also makes
    table maintenance easier by allowing you to drop the partition of `quote_date`.
    One drawback of the date bucket pattern is that you always need to know the partition
    key in order to get the rows. So, in `dayquote05`, you cannot get the latest `quote_date`
    value using the `ORDER BY DESC` and `LIMIT 1` clauses.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在复合分区键基于每日限制行的尺寸，并使行更加易于管理。这种方式类似于将数据插入由特定日期标记的不同桶中。因此，它被命名为**日期桶模式**。按日期分区还通过允许您删除`quote_date`的分区，使表维护更容易。日期桶模式的一个缺点是您总是需要知道分区键才能获取行。因此，在`dayquote05`中，您不能使用`ORDER
    BY DESC`和`LIMIT 1`子句获取最新的`quote_date`值。
- en: The date bucket pattern gives an application developer a design option to attain
    a more balanced cluster, but how balanced a cluster is depends on a number of
    factors in which the most important one is the selection of the partitioner.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 日期桶模式为应用程序开发者提供了一个设计选项，以实现更平衡的集群，但集群的平衡程度取决于许多因素，其中最重要的因素是分区器的选择。
- en: Partitioner
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分区器
- en: 'A partitioner is basically a hash function used to calculate the `TOKEN()`
    (the hash value) of a row key and so, it determines how data is distributed across
    the nodes in a cluster. Choosing a partitioner determines which node is used to
    place the first copy of data. Each row of data is uniquely identified by a partition
    key and is distributed across the cluster by the value of the `TOKEN()`. Cassandra
    provides the following three partitioners:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 分区器基本上是一个哈希函数，用于计算行键的`TOKEN()`（哈希值），因此它决定了数据如何在集群的节点之间分布。选择分区器决定了哪个节点用于放置数据的第一个副本。每一行数据都由一个分区键唯一标识，并通过`TOKEN()`的值在集群中分布。Cassandra提供了以下三个分区器：
- en: '`Murmur3Partitioner` (default since version 1.2)'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Murmur3Partitioner`（自1.2版本以来为默认值）'
- en: '`RandomPartitioner` (default before version 1.2)'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RandomPartitioner` (版本 1.2 之前的默认值)'
- en: '`ByteOrderedPartitioner`'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ByteOrderedPartitioner`'
- en: Murmur3Partitioner
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Murmur3Partitioner
- en: '`Murmur3Partitioner` provides faster hashing and improved performance than
    the partitioner `RandomPartitioner`. It is the default partitioning strategy and
    the right choice for new clusters in almost all cases. It uses the *MurmurHash*
    function that creates a 64-bit hash value of the partition key. The possible range
    of hash values is from -2^(63) to +2^(63) -1\. When using `Murmur3Partitioner`,
    you can page through all the rows using the `TOKEN()` function in a CQL `SELECT`
    statement.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`Murmur3Partitioner` 提供比 `RandomPartitioner` 更快的哈希和改进的性能。在几乎所有情况下，它都是默认的分区策略，也是新集群的正确选择。它使用
    *MurmurHash* 函数，该函数创建分区键的 64 位哈希值。哈希值的可能范围是从 -2^(63) 到 +2^(63) -1。当使用 `Murmur3Partitioner`
    时，你可以通过在 CQL `SELECT` 语句中使用 `TOKEN()` 函数来翻页查看所有行。'
- en: RandomPartitioner
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RandomPartitioner
- en: '`RandomPartitioner` was the default partitioner prior to Cassandra Version
    1.2\. It distributes data evenly across the nodes using an *MD5* hash value of
    the row key. The possible range of hash values is from 0 to 2^(127) -1\. The MD5
    hash function is slow in performance, that is why Cassandra has moved to Murmur3
    hashes. When using `RandomPartitioner`, you can page through all rows using the
    `TOKEN()` function in a CQL `SELECT` statement.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`RandomPartitioner` 在 Cassandra 版本 1.2 之前是默认的分区器。它通过使用行键的 *MD5* 哈希值将数据均匀地分布在节点之间。哈希值的可能范围是从
    0 到 2^(127) -1。MD5 哈希函数在性能上较慢，这就是为什么 Cassandra 转向了 Murmur3 哈希。当使用 `RandomPartitioner`
    时，你可以通过在 CQL `SELECT` 语句中使用 `TOKEN()` 函数来翻页查看所有行。'
- en: ByteOrderedPartitioner
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ByteOrderedPartitioner
- en: '`ByteOrderedPartitioner`, as its name suggests, is used for ordered partitioning.
    This partitioner orders rows lexically by key bytes. Tokens are calculated by
    looking at the actual values of the partition key data and using a hexadecimal
    representation of the leading character(s) in a key. For example, if you wanted
    to partition rows alphabetically, you can assign a B `TOKEN()` using its hexadecimal
    representation of `0x42`.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名称所示，`ByteOrderedPartitioner` 用于有序分区。这个分区器按照键字节进行排序。令牌是通过查看分区键数据的实际值并使用键的前导字符的十六进制表示来计算的。例如，如果你想按字母顺序分区行，你可以使用其十六进制表示
    `0x42` 分配一个 B `TOKEN()`。
- en: Using `ByteOrderedPartitioner` allows ordered scans by a primary key as though
    you were moving a cursor through a traditional index in a relational table. This
    type of range scan query is not possible using `RandomPartitioner` because the
    keys are stored in the order of their MD5 hash, and not in the sequential order
    of the keys.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `ByteOrderedPartitioner` 允许通过主键进行有序扫描，就像你在关系型表的传统索引中移动游标一样。这种类型的范围扫描查询在 `RandomPartitioner`
    中是不可能的，因为键是按照它们的 MD5 哈希顺序存储的，而不是按照键的顺序。
- en: 'Apparently, performing range-scan on rows sounds like a desirable feature of
    `ByteOrderedPartitioner`. There are ways to achieve the same functionality using
    secondary indexes. Conversely, using `ByteOrderedPartitioner` is not recommended
    for the following reasons:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，对行执行范围扫描听起来像是 `ByteOrderedPartitioner` 的一个期望特性。有方法可以通过使用二级索引来实现相同的功能。相反，出于以下原因不建议使用
    `ByteOrderedPartitioner`：
- en: '**Difficult load balancing**: More administrative overhead is required to load
    balance the cluster. `ByteOrderedPartitioner` requires administrators to manually
    calculate partition ranges based on their estimates of the partition key distribution.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**负载均衡困难**：需要更多的管理开销来平衡集群。`ByteOrderedPartitioner` 要求管理员根据他们对分区键分布的估计手动计算分区范围。'
- en: '**Sequential writes can cause hot spots**: If the application tends to write
    or update a sequential block of rows at a time, the writes will not be distributed
    across the cluster. They all go to one node. This is frequently a problem for
    applications dealing with timestamped data.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**顺序写入可能导致热点问题**：如果应用程序倾向于一次写入或更新一个顺序的行块，写入将不会在集群中分布。它们都会流向一个节点。这对于处理时间戳数据的应用程序来说通常是一个问题。'
- en: '**Uneven load balancing for multiple tables**: If the application has multiple
    tables, chances are that these tables have different row keys and different distributions
    of data. An ordered partitioner that is balanced for one table can cause hot spots
    and uneven distribution for another table in the same cluster.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多表负载不均衡**：如果应用程序有多个表，这些表可能有不同的行键和不同的数据分布。为一张表平衡的有序分区器可能会在同一个集群中的另一张表上造成热点和不均匀的分布。'
- en: Paging and token function
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分页和令牌函数
- en: 'When using the `RandomPartitioner` or `Murmur3Partitioner`, the rows are ordered
    by the hash of their value. Hence, the order of the rows is not meaningful. Using
    CQL, the rows can still be paged through even when using `RandomPartitioner` or
    `Murmur3Partitioner` using the `TOKEN()` function, as shown in the following screenshot:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `RandomPartitioner` 或 `Murmur3Partitioner` 时，行按其值的哈希值排序。因此，行的顺序没有意义。使用 CQL，即使使用
    `RandomPartitioner` 或 `Murmur3Partitioner`，也可以通过 `TOKEN()` 函数遍历行，如下面的截图所示：
- en: '![Paging and token function](img/8884OS_04_12.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![分页和令牌功能](img/8884OS_04_12.jpg)'
- en: '`ByteOrderedPartitioner` arranges tokens in the same way as key values, while
    `RandomPartitioner` and `Murmur3Partitioner` distribute tokens in a completely
    unordered manner. The `TOKEN()` function makes it possible to page through the
    unordered partitioner results. It actually queries results directly using tokens.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`ByteOrderedPartitioner` 以与键值相同的方式排列令牌，而 `RandomPartitioner` 和 `Murmur3Partitioner`
    以完全无序的方式分配令牌。`TOKEN()` 函数使得可以遍历无序分区器的结果。它实际上直接使用令牌查询结果。'
- en: Secondary indexes
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 二级索引
- en: As Cassandra only allows each table to have one primary key, it supports secondary
    index on columns other than those in the primary key. The benefit is a fast, efficient
    lookup of data matching the indexed columns in the `WHERE` clause. Each table
    can have more than one secondary index. Cassandra uses secondary indexes to find
    the rows that are not using the row key. Behind the scenes, the secondary index
    is implemented as a separate, hidden table that is maintained automatically by
    the internal process of Cassandra. As with relational databases, keeping secondary
    indexes up to date is not free, so unnecessary indexes should be avoided.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Cassandra 只允许每个表有一个主键，因此它支持在主键之外的列上创建二级索引。好处是可以在 `WHERE` 子句中快速、高效地查找匹配索引列的数据。每个表可以有多个二级索引。Cassandra
    使用二级索引来查找不使用行键的行。在幕后，二级索引作为由 Cassandra 内部进程自动维护的单独、隐藏的表实现。与关系数据库一样，保持二级索引的更新不是免费的，因此应避免不必要的索引。
- en: Note
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The major difference between a primary index and a secondary index is that the
    primary index is a distributed index used to locate the node that stores the row
    key, whereas the secondary index is a local index just to index the data on the
    local node.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 主索引和二级索引之间的主要区别在于，主索引是一个分布式索引，用于定位存储行键的节点，而二级索引是一个本地索引，仅用于索引本地节点上的数据。
- en: Therefore, the secondary index will not be able to know immediately the locations
    of all matched rows without having examined all the nodes in the cluster. This
    makes the performance of the secondary index unpredictable.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在没有检查集群中的所有节点的情况下，二级索引将无法立即知道所有匹配行的位置。这使得二级索引的性能不可预测。
- en: Note
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The secondary index is the most efficient when using equality predicates. This
    is indeed a limitation that must have at least one equality predicate clause to
    hopefully limit the set of rows that need to be read into memory.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用等值谓词时，二级索引是最有效的。这确实是一个限制，必须至少有一个等值谓词子句，以希望限制需要读入内存的行集。
- en: In addition, the secondary index cannot be created on the primary key itself.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，二级索引不能创建在主键本身上。
- en: Note
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Caveat!**'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意！**'
- en: Secondary indexes in Cassandra are *NOT* equivalent to those in the traditional
    RDBMS. They are not akin to a B-tree index in RDBMS. They are mostly like a hash.
    So, the range queries do not work on secondary indexes in Cassandra, only equality
    queries work on secondary indexes.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Cassandra 中的二级索引与传统的 RDBMS 中的二级索引并不相同。它们不类似于 RDBMS 中的 B-tree 索引。它们更像是哈希。因此，范围查询在
    Cassandra 的二级索引上不工作，只有等值查询在二级索引上工作。
- en: 'We can use the CQL `CREATE INDEX` statement to create an index on a column
    after we define a table. For example, we might want to add a column `sector` to
    indicate the sector that the stock belongs to, as shown in the following screenshot:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 CQL 的 `CREATE INDEX` 语句在定义表之后在列上创建索引。例如，我们可能想添加一个 `sector` 列来指示股票所属的部门，如下面的截图所示：
- en: '![Secondary indexes](img/8884OS_04_13.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![二级索引](img/8884OS_04_13.jpg)'
- en: 'If we want to search `dayquote06` for symbols that belong to `Properties`,
    we might run the command, as shown in the following screenshot:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在 `dayquote06` 中搜索属于 `Properties` 的符号，我们可能会运行以下命令，如下面的截图所示：
- en: '![Secondary indexes](img/8884OS_04_14.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![二级索引](img/8884OS_04_14.jpg)'
- en: 'As `sector` is not in the primary key, we cannot query Cassandra directly by
    `sector`. Instead, we can create a secondary index on the column `sector` to make
    this possible, as shown in the following screenshot:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`sector`不在主键中，我们无法直接通过`sector`查询Cassandra。相反，我们可以在列`sector`上创建一个二级索引来实现这一点，如下面的截图所示：
- en: '![Secondary indexes](img/8884OS_04_15.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![二级索引](img/8884OS_04_15.jpg)'
- en: The index name `dayquote06_sector_idx` is optional, but must be unique within
    the keyspace. Cassandra assigns a name such as `dayquote06_idx` if you do not
    provide a name. We can now query Cassandra for daily stock quotes by `sector`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 索引名称`dayquote06_sector_idx`是可选的，但必须在键空间内是唯一的。如果您不提供名称，Cassandra将分配一个类似于`dayquote06_idx`的名称。我们现在可以通过`sector`查询Cassandra的每日股票报价。
- en: You can see that the columns in the primary key are not present in the `WHERE`
    predicate clause in the previous screenshot and Cassandra uses the secondary index
    to look for the rows matching the selection condition.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，在先前的截图中的`WHERE`谓词子句中，主键列不存在，Cassandra使用二级索引来查找匹配选择条件的行。
- en: Multiple secondary indexes
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多个二级索引
- en: Cassandra supports multiple secondary indexes on a table. The `WHERE` clause
    is executed if at least one column is involved in a secondary index. Thus, we
    can use multiple conditions in the `WHERE` clause to filter the results. When
    multiple occurrences of data match a condition in the `WHERE` predicate clause,
    Cassandra selects the least frequent occurrence of a condition to process first
    so as to have a better query efficiency.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Cassandra支持在表上创建多个二级索引。如果至少有一个列参与了二级索引，则执行`WHERE`子句。因此，我们可以在`WHERE`子句中使用多个条件来过滤结果。当`WHERE`谓词子句中的多个数据匹配条件时，Cassandra将首先处理最不频繁出现的条件，以提高查询效率。
- en: When a potentially expensive query is attempted, such as a range query, Cassandra
    requires the `ALLOW FILTERING` clause, which can apply additional filters to the
    result set for values of other non-indexed columns. It works very slowly because
    it scans all rows in all nodes. The `ALLOW FILTERING` clause is used to explicitly
    direct Cassandra to execute that potentially expensive query on any `WHERE` clause
    without creating secondary indexes, despite unpredictability of the performance.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当尝试执行可能昂贵的查询，例如范围查询时，Cassandra需要`ALLOW FILTERING`子句，该子句可以对其他非索引列的值应用额外的过滤器，以对结果集进行过滤。由于它扫描所有节点上的所有行，因此它运行得非常慢。`ALLOW
    FILTERING`子句用于显式指导Cassandra在`WHERE`子句上执行该可能昂贵的查询，而不创建二级索引，尽管性能不可预测。
- en: Secondary index do's and don'ts
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 二级索引的注意事项
- en: The secondary index is best on a table that has many rows that contain fewer
    unique values, that is low cardinality in the relational database terminologies,
    which is counterintuitive to the relational people. The more unique values that
    exist in a particular column, the more overhead you will have to query and maintain
    the index. Hence, it is not suitable for querying a huge volume of records for
    a small number of results.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 二级索引最适合具有许多行且包含较少唯一值的表，在关系数据库术语中称为低基数，这对关系数据库人员来说可能是不直观的。一个特定列中存在的唯一值越多，查询和维护索引的开销就越大。因此，它不适合查询大量记录以获取少量结果。
- en: Tip
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Do index the columns with values that have low cardinality. Cassandra stores
    secondary indexes only for local rows in the data node as a hash-multimap or as
    bitmap indexes, you can refer to it at [https://issues.apache.org/jira/browse/CASSANDRA-1472](https://issues.apache.org/jira/browse/CASSANDRA-1472).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 不要对具有低基数值的列进行索引。Cassandra将二级索引仅存储为数据节点上的本地行的哈希多映射或位图索引，您可以在[https://issues.apache.org/jira/browse/CASSANDRA-1472](https://issues.apache.org/jira/browse/CASSANDRA-1472)中参考它。
- en: 'Secondary indexes should be avoided in the following situations:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下情况下应避免使用二级索引：
- en: On high-cardinality columns for a small number of results out of a huge volume
    of rows
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在大量行中，对于少量结果的高基数列
- en: An index on a high-cardinality column will incur many seeks for very few results.
    For columns containing unique values, using an index for convenience is fine from
    a performance perspective, as long as the query volume to the indexed column family
    is moderate and not under constant load.
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在高基数列上的索引将导致为非常少的查询结果进行多次搜索。对于包含唯一值的列，从性能角度来看，使用索引以方便查询是可以接受的，只要对索引列族的查询量适中，并且不是持续负载。
- en: In tables that use a counter column
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在使用计数器列的表中
- en: On a frequently updated or deleted column
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在频繁更新或删除的列上
- en: Cassandra stores tombstones (a marker in a row that indicates that a column
    was deleted. During compaction, marked columns are deleted in the index (a hidden
    table) until the tombstone limit reaches 100 K cells. After exceeding this limit,
    the query that uses the indexed value will fail.
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Cassandra 存储墓碑（行中的一个标记，表示某个列已被删除。在压缩过程中，标记的列在索引（一个隐藏的表）中被删除，直到墓碑限制达到 100 K 个单元格。超过这个限制后，使用索引值进行的查询将失败。
- en: To look for a row in a large partition
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在大型分区中查找行
- en: A query on an indexed column in a large cluster typically requires collating
    responses from multiple data partitions. The query response slows down as more
    machines get added to the cluster.
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在大型集群中对索引列进行查询通常需要从多个数据分区收集响应。随着集群中机器数量的增加，查询响应速度会变慢。
- en: Tip
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Important points to take note of**'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**需要注意的重要要点**'
- en: Don't index on high-cardinality columns
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要在高基数列上建立索引
- en: Don't use index in tables having a counter column
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要在具有计数列的表中使用索引
- en: Don't index on a frequently updated or deleted column
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要在频繁更新或删除的列上建立索引
- en: Don't abuse the index to look for a row in a large partition
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要滥用索引在大型分区中查找行
- en: Summary
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have learned about the primary and secondary indexes in this chapter. Related
    topics such as compound primary key, composite partition key, and partitioner
    are also introduced. With the help of the explanation of the internal storage
    and inner working mechanisms of Cassandra, you should now be able to state the
    difference between the primary index and the secondary index, as well as use them
    properly in your data model.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了主索引和辅助索引。复合主键、复合分区键和分区器等相关主题也进行了介绍。通过解释 Cassandra 的内部存储和内部工作原理，你现在应该能够说明主索引和辅助索引之间的区别，并在数据模型中正确使用它们。
- en: In the next chapter, we will start building the first version of the technical
    analysis application using Cassandra and Python. A quick installation and setup
    guide on how to connect Python to Cassandra and collect market data will also
    be provided.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始构建使用 Cassandra 和 Python 的第一个版本的技术分析应用程序。还将提供如何将 Python 连接到 Cassandra
    并收集市场数据的快速安装和设置指南。
