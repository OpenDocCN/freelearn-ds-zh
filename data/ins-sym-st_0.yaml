- en: Chapter 1. Instant SymPy Starter
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章。立即开始使用SymPy
- en: Welcome to *Instant SymPy Starter*. This book has been especially created to
    provide you with all the information that you need to get up to speed with SymPy.
    You will learn the basics of SymPy, build your first SymPy code, and discover
    functions and tricks of the trade when it comes to using SymPy.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎使用 *立即开始使用SymPy*。这本书特别创建，旨在为你提供所有你需要的信息，以便快速掌握SymPy。你将学习SymPy的基础知识，构建你的第一个SymPy代码，并在使用SymPy时发现一些技巧和技巧。
- en: 'This document contains the following sections:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本文档包含以下章节：
- en: '*So, what is SymPy?* helps you find out what SymPy actually is, what you can
    do with it, and why it’s so great.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*那么，什么是SymPy？* 帮助你了解SymPy实际上是什么，你可以用它做什么，以及为什么它如此出色。'
- en: '*Installation* teaches you how to try out SymPy in your browser, download and
    install it with minimum fuss, and then set up its optional dependencies so that
    you can use all its functionalities.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '*安装* 教你如何在浏览器中尝试SymPy，以最少的麻烦下载和安装它，然后设置其可选依赖项，以便你可以使用所有功能。'
- en: '*Quick start – Automated curve sketching* will show you how to perform one
    of the core tasks of SymPy, automating mathematical tasks, by guiding you through
    the creation of a commonplace curve sketching application.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*快速入门 – 自动化曲线绘制* 将向你展示如何通过引导你创建一个常见的曲线绘制应用程序，来执行SymPy的核心任务之一，自动化数学任务。'
- en: '*Top 5 features you need to know about* will teach you how to perform five
    tasks with the most important features of SymPy. By the end of this section you
    will be able to create symbolic expressions, manipulate them, convert them to
    efficient numerical functions, compute limits, integrals and derivatives, and
    solve equations.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*你需要了解的前5个功能* 将教你如何使用SymPy最重要的功能执行五个任务。在本节结束时，你将能够创建符号表达式，操作它们，将它们转换为高效的数值函数，计算极限、积分和导数，并解方程。'
- en: '*People and places you should get to know* provides you with many useful links
    to the open source project as it is centered around a community. You will find
    the project page and forums, as well as a number of helpful articles, tutorials,
    blogs, and the Twitter feeds of SymPy contributors.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*你应该了解的人和地点* 为你提供了许多有用的链接到开源项目，因为它围绕一个社区。你将找到项目页面和论坛，以及一些有用的文章、教程、博客和SymPy贡献者的Twitter动态。'
- en: So, what is SymPy?
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 那么，什么是SymPy？
- en: 'SymPy is a library for symbolic computation written entirely in Python and
    distributed under a BSD-type permissive free software license. Its core symbolic
    capabilities include:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: SymPy是一个完全用Python编写的符号计算库，在BSD类型的许可免费软件许可下分发。其核心符号能力包括：
- en: Elementary algebra
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初等代数
- en: Pattern matching and substitution
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式匹配和替换
- en: Symbolic transformations and simplifications
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 符号变换和简化
- en: All the common mathematical functions and many special ones
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有常见的数学函数以及许多特殊函数
- en: 'Calculus: limits, derivatives, integrals, Taylor series, and so on'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微积分：极限、导数、积分、泰勒级数等
- en: Solving many kinds of equations, including differential equations
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解多种类型的方程，包括微分方程
- en: Linear algebra
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线性代数
- en: Polynomials
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多项式
- en: Infinite sums and products
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无穷级数和无穷乘积
- en: Planar geometry
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平面几何
- en: Physical constants and units
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 物理常数和单位
- en: Numeric computation in arbitrary precision
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在任意精度下的数值计算
- en: SymPy also includes subpackages dealing with advanced, specialized topics such
    as category theory, quantum logic, mechanical dynamics, or statistics. Even if
    you have no use for their functionalities, they can serve as useful examples of
    how to encode complex domain knowledge.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: SymPy还包括处理高级、专业主题的子包，例如范畴论、量子逻辑、机械动力学或统计学。即使你不需要它们的函数，它们也可以作为如何编码复杂领域知识的有用示例。
- en: SymPy is well integrated with the rest of the scientific Python ecosystem. Using
    it inside the IPython notebook provides a productive environment for prototyping
    and exploration of symbolic models and calculations. Powerful numerical libraries—such
    as NumPy, SciPy, pandas, and sklearn—are also just a few import statements away,
    and SymPy has features to help smooth the transition between the symbolic and
    numeric worlds.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: SymPy与科学Python生态系统中的其他部分很好地集成。在IPython笔记本中使用它提供了一个用于原型设计和符号模型与计算探索的生产性环境。强大的数值库——如NumPy、SciPy、pandas和sklearn——也只需几个导入语句即可使用，并且SymPy具有帮助平滑符号和数值世界之间过渡的功能。
- en: What sets SymPy apart from conventional computer algebra systems is that it
    is easy to integrate it into any processing pipeline. Drawing from the qualities
    of Python, it is easy to interface it with any other Python library or even with
    other languages. It can, for instance, serve as a bridge between two otherwise
    incompatible systems, such as a proprietary dynamical modeling application or
    a C library for coupled differential equations, transform user input to feed it
    to a renderer, or serve as an easier and less error-prone way of turning equations
    into efficient code.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: SymPy 与传统计算机代数系统不同的地方在于，它很容易集成到任何处理流程中。借鉴 Python 的特性，它很容易与任何其他 Python 库或其他语言进行接口。例如，它可以作为两个原本不兼容的系统之间的桥梁，如专有的动力学建模应用程序或耦合微分方程的
    C 库，将用户输入转换为渲染器的输入，或者作为将方程转换为高效代码的更简单、更不易出错的方法。
- en: Installation
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装
- en: In four easy steps, you can install SymPy and prepare it to be used on your
    system.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 通过四个简单的步骤，您就可以安装 SymPy 并将其准备就绪，以便在您的系统上使用。
- en: Step 1 – Trying it out online
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 1 步 – 在线尝试
- en: 'The easiest way to use SymPy is to try it out in your browser. SymPy is available
    from [http://live.sympy.org](http://live.sympy.org), an online Python shell, with
    SymPy already imported, which allows you to perform simple calculations. Take
    a moment to become familiar with it. Every code snippet in the online documentation
    can be turned into a SymPy Live shell, so you will be using it quite often. It
    looks as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 SymPy 最简单的方法是在浏览器中尝试它。SymPy 可从 [http://live.sympy.org](http://live.sympy.org)
    获取，这是一个在线 Python shell，其中已导入 SymPy，允许您执行简单计算。花点时间熟悉它。在线文档中的每个代码片段都可以转换为 SymPy
    Live shell，因此您会经常使用它。它看起来如下所示：
- en: '![Step 1 – Trying it out online](img/3626OS_01_01.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![第 1 步 – 在线尝试](img/3626OS_01_01.jpg)'
- en: 'The Live shell is similar to the default Python shell, with tab completion
    enabled and LaTeX-based pretty printing. The obvious limitations of an online
    app apply: the local filesystem is unavailable and computations are throttled.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Live shell 与默认的 Python shell 类似，启用了自动补全功能，并基于 LaTeX 进行美观打印。在线应用的明显限制是：本地文件系统不可用，计算受到限制。
- en: When it comes to deployment and distribution of the final product, SymPy's liberal
    license places no legal restriction on re-use, and being a pure-Python library,
    it can easily be installed into most environments, so it can easily be used to
    enable mathematically-aware scripting by end users.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到最终产品的部署和分发时，SymPy 的宽松许可不对其再利用施加任何法律限制，并且作为一个纯 Python 库，它很容易安装到大多数环境中，因此可以轻松地使用它来允许最终用户进行数学感知脚本编写。
- en: Step 2 – Installing the environment
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 2 步 – 安装环境
- en: SymPy is entirely written in Python and has no mandatory dependencies. So the
    only thing you need to run it is an appropriate version of the Python interpreter.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: SymPy 完全用 Python 编写，没有强制依赖项。因此，您只需要一个合适的 Python 解释器版本即可运行它。
- en: However, for developing with SymPy or using it interactively, it is highly recommended
    to install NumPy, matplotlib, and, most importantly, IPython. The IPython notebook
    provides a productive environment for interactive exploration, combined with the
    ability to display mathematical notation.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于使用 SymPy 进行开发或交互式使用，强烈建议安装 NumPy、matplotlib，最重要的是 IPython。IPython 笔记本提供了一个高效的环境，用于交互式探索，并具备显示数学符号的能力。
- en: 'On Mac and Windows devices, the easiest way is to install one of the scientific
    Python distributions:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Mac 和 Windows 设备上，最简单的方法是安装以下科学 Python 发行版之一：
- en: '**Python(x,y)** – [http://code.google.com/p/pythonxy/](http://code.google.com/p/pythonxy/)'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Python(x, y)** – [http://code.google.com/p/pythonxy/](http://code.google.com/p/pythonxy/)'
- en: '**Enthought Python Disrtibution** (**EPD**) – [http://www.enthought.com/products/epd.php](http://www.enthought.com/products/epd.php)'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Enthought Python Distribution**（**EPD**）- [http://www.enthought.com/products/epd.php](http://www.enthought.com/products/epd.php)'
- en: '**Anaconda CE** – [http://www.continuum.io/downloads.html](http://www.continuum.io/downloads.html)'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Anaconda CE** – [http://www.continuum.io/downloads.html](http://www.continuum.io/downloads.html)'
- en: Python(x, y) targets Windows and is the best choice on that platform. EPD is
    free to use only for academics and students. Anaconda CE has fewer features, but
    is free for everyone. All three provide SymPy as well as the core components of
    the Python scientific stack; if you install one of them, you can skip ahead to
    step 4.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Python(x, y) 针对 Windows 平台，是该平台上的最佳选择。EPD 仅对学术人员和学生在使用上免费。Anaconda CE 功能较少，但对所有人免费。所有这三个都提供了
    SymPy 以及 Python 科学堆栈的核心组件；如果您安装了其中之一，就可以跳到第 4 步。
- en: On Linux, the package manager simplifies the installation of packages with dependencies.
    The same applies to Mac users of Homebrew or Macports who want more control over
    their system than what the distribution route affords. Windows users with the
    same requirements will have to rely on the binary installers provided by the different
    projects or master the art of compiling Python extensions.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux上，包管理器简化了具有依赖关系的包的安装。同样适用于希望比发行版路线提供更多系统控制的Mac用户（Homebrew或Macports）。具有相同要求的Windows用户将不得不依赖不同项目提供的二进制安装程序或掌握编译Python扩展的技艺。
- en: The best supported version of Python is 2.7, but 2.6, 3.2, 3.3, and PyPy are
    also supported. Additionally, SymPy supports Python 2.5 but the IPython notebook
    does not. You probably already have a Python interpreter, but if it is not Version
    2.7, we recommend that you install it with your package manager or go to [http://www.python.org/download/](http://www.python.org/download/)
    and choose the appropriate installer.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 最受支持的Python版本是2.7，但2.6、3.2、3.3和PyPy也受到支持。此外，SymPy还支持Python 2.5，但IPython笔记本不支持。您可能已经有一个Python解释器，但如果它不是2.7版本，我们建议您使用包管理器安装它，或者访问[http://www.python.org/download/](http://www.python.org/download/)并选择适当的安装程序。
- en: 'For IPython, we need Version 0.13 or newer. Install it from your package manager
    if you can, noting that some distributions split its components into several packages.
    So, on Debian and Ubuntu, for instance, you should use the following command:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 对于IPython，我们需要版本0.13或更高版本。如果您可以使用包管理器安装，请注意，某些发行版将组件拆分为几个包。例如，在Debian和Ubuntu上，您应该使用以下命令：
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If your OS does not provide a sufficiently recent version, go to [http://ipython.org](http://ipython.org)
    and follow the installation instructions. On Ubuntu, you can also use a **Personal
    Package Archive** (**PPA**) at [https://launchpad.net/~jtaylor/+archive/ipython](https://launchpad.net/~jtaylor/+archive/ipython).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的操作系统没有提供足够新的版本，请访问[http://ipython.org](http://ipython.org)，并按照安装说明进行操作。在Ubuntu上，您还可以使用位于[https://launchpad.net/~jtaylor/+archive/ipython](https://launchpad.net/~jtaylor/+archive/ipython)的**个人软件包存档**（**PPA**）。
- en: 'For NumPy and matplotlib, there are no stringent version requirements so you
    can probably use whatever version your package manager provides. On Debian and
    Ubuntu, you only need to use the following command:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 对于NumPy和matplotlib，没有严格的版本要求，因此您可能可以使用包管理器提供的任何版本。在Debian和Ubuntu上，您只需要使用以下命令：
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Installing the libraries from the source presents no particular difficulty
    if you are used to compiling C and C++ extensions. Just locate and, if needed,
    compile their respective dependencies, then use pip to compile and install the
    libraries themselves. If you do not already have pip, go to [http://www.pip-installer.org/en/latest/installing.html](http://www.pip-installer.org/en/latest/installing.html)
    and follow the instructions. Then, type the following command:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您习惯于编译C和C++扩展，从源代码安装库不会遇到特别的困难。只需定位并（如果需要）编译它们各自的依赖项，然后使用pip编译和安装库本身。如果您还没有pip，请访问[http://www.pip-installer.org/en/latest/installing.html](http://www.pip-installer.org/en/latest/installing.html)并按照说明操作。然后，输入以下命令：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Step 3 – Installing SymPy
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第3步 – 安装SymPy
- en: 'The easiest option is to use pip. At the command line, simply type the following
    command and that''s it:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的方法是使用pip。在命令行中，只需输入以下命令即可：
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Another possibility is to download a source archive. Go to [http://code.google.com/p/sympy/downloads/list](http://code.google.com/p/sympy/downloads/list)
    and pick the most recent source release for your Python version (its name should
    look something like `sympy-0.7.2.tar.gz`, or `sympy-0.7.2-py3.2.tar.gz` if you
    use Python 3.*). Unpack the archive, open a console in the newly created folder,
    and type the following command (replace `python` with `python3` if needed):'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种可能性是下载源代码存档。访问[http://code.google.com/p/sympy/downloads/list](http://code.google.com/p/sympy/downloads/list)，并选择适合您Python版本的最新源代码发布版（其名称应类似于`sympy-0.7.2.tar.gz`，或者如果您使用Python
    3.*，则为`sympy-0.7.2-py3.2.tar.gz`）。解压存档，在新创建的文件夹中打开控制台，并输入以下命令（如果需要，将`python`替换为`python3`）：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: SymPy should now be installed and you can discard the archive and the folder.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: SymPy现在应该已经安装，您可以丢弃存档和文件夹。
- en: '![Step 3 – Installing SymPy](img/3626OS_01_02.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![第3步 – 安装SymPy](img/3626OS_01_02.jpg)'
- en: Choosing the right archive to download
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 选择正确的存档进行下载
- en: 'Finally, on Linux, another simple alternative is to use your distribution''s
    package manager. For example, for Debian and Ubuntu, use the following command:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在Linux上，另一个简单的替代方案是使用您发行版的包管理器。例如，对于Debian和Ubuntu，使用以下命令：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: However, you may not get the latest version of SymPy.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，您可能无法获得最新版本的 SymPy。
- en: In any case, to check that SymPy has been correctly installed, enter a Python
    shell and type `import sympy`. It should succeed without producing any output
    (ignore any warnings related to matplotlib). To make sure that all of SymPy works
    as intended on your system, you can additionally run the full test suite with
    `sympy.test()` (beware, it takes quite a long time).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，为了检查 SymPy 是否已正确安装，进入 Python 命令行并输入 `import sympy`。它应该成功而不会产生任何输出（忽略与 matplotlib
    相关的任何警告）。为了确保 SymPy 在您的系统上按预期工作，您还可以使用 `sympy.test()` 运行完整的测试套件（请注意，这需要相当长的时间）。
- en: '![Step 3 – Installing SymPy](img/3626OS_01_03.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![第 3 步 – 安装 SymPy](img/3626OS_01_03.jpg)'
- en: Testing a fresh installation of SymPy
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 测试 SymPy 的新安装
- en: Step 4 – Configuring the notebook
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 4 步 – 配置笔记本
- en: The IPython notebook is a two-process application split between a frontend and
    a kernel executing Python code. The frontend is a JavaScript application that
    runs in a web browser (all recent versions of major browsers are supported, except
    Internet Explorer).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: IPython 笔记本是一个分为前端和执行 Python 代码的内核的双进程应用程序。前端是一个在网页浏览器中运行的 JavaScript 应用程序（所有主流浏览器的最新版本都受支持，但
    Internet Explorer 除外）。
- en: The notebook is a perfect environment for exploratory analysis. It has an intuitive
    and minimalist interface based on the concept of cells, that is, multiline text
    input boxes. They can hold text—to structure the notebook and add explanations—or
    Python code. Code cells are executed as a unit and the result of the last line
    is displayed as in a shell. There is also a rich and extensible system of magic
    commands that start with `%` and allow nearly any conceivable action inside the
    notebook, from configuring IPython to executing shell commands to embedding other
    languages. Look inside the **Help** menu for more information.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 笔记本是一个完美的探索性分析环境。它基于单元的概念，即多行文本输入框的直观和简约界面。它们可以包含文本——以结构化笔记本和添加解释，或者 Python
    代码。代码单元作为单元执行，最后一行的结果以类似壳的方式显示。还有一个丰富且可扩展的以 `%` 开头的魔法命令系统，它允许在笔记本内执行几乎任何可想象的操作，从配置
    IPython 到执行 shell 命令到嵌入其他语言。在 **帮助** 菜单中查找更多信息。
- en: 'The notebook has built-in support for displaying matplotlib figures in-line,
    and we recommend that you always use it when working with SymPy (one reason is
    that a quirk of the three-way interaction between sympy-0.7.2, IPython, and matplotlib
    prevents the latter from being properly configured once SymPy has been imported).
    Therefore, to start the notebook, use the following command:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 笔记本内置了对显示 matplotlib 图形的支持，并且我们建议您在处理 SymPy 时始终使用它（一个原因是 sympy-0.7.2、IPython
    和 matplotlib 之间的三方交互存在一个怪癖，一旦导入 SymPy，后者就无法正确配置）。因此，要启动笔记本，请使用以下命令：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This should open your web browser on the IPython Dashboard page. Create a new
    notebook. To configure it for a SymPy session, type the following into the first
    cell and execute it by pressing *Shift* + *Enter*:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会在您的网页浏览器上打开 IPython 仪表板页面。创建一个新的笔记本。为了配置它以进行 SymPy 会话，请在第一个单元中输入以下内容并按 *Shift*
    + *Enter* 执行：
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The first line sets up LaTeX-based rendering of results using MathJax.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一行设置使用 MathJax 的基于 LaTeX 的结果渲染。
- en: The second one imports a large number of names from the `sympy` namespace. This
    makes it possible to type formulas in a natural way, but you should be aware that
    there are many name conflicts with `numpy`. Consequently, whenever you plan to
    use both libraries heavily in the same notebook, you should rather use an import
    shortcut trick à la `import sympy as sy`.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个导入来自 `sympy` 命名空间的大量名称。这使得以自然的方式输入公式成为可能，但您应该意识到与 `numpy` 存在许多名称冲突。因此，当您计划在同一个笔记本中大量使用这两个库时，您最好使用类似于
    `import sympy as sy` 的导入快捷方式技巧。
- en: The third line is optional and merely creates a few mathematical variables to
    play with.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三行是可选的，仅创建一些用于玩耍的数学变量。
- en: 'Now, try to enter a formula, for instance, `(exp(x)/factorial(y))**z`, and
    admire the result. You should see something like the following :'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，尝试输入一个公式，例如 `(exp(x)/factorial(y))**z`，并欣赏结果。您应该看到以下内容：
- en: '![Step 4 – Configuring the notebook](img/3626OS_01_04.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![第 4 步 – 配置笔记本](img/3626OS_01_04.jpg)'
- en: And that's it
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 就是这样
- en: By this point, you should have a working environment ready to make full use
    of SymPy. You are encouraged to play around in the notebook and discover more.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您应该有一个可以充分利用 SymPy 的工作环境。我们鼓励您在笔记本中尝试并发现更多。
- en: Quick start – Automated curve sketching
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速入门 – 自动绘制曲线
- en: The main use of SymPy is to automate tedious mathematical procedures, so let
    us look at an example of this. Curve sketching, that staple of introductory calculus
    classes where the student has to find out the salient features of the curve of
    a function through algebraic manipulations, limits, and derivatives. In this section,
    you will learn how to perform it automatically using SymPy.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: SymPy的主要用途是自动化繁琐的数学过程，因此让我们看看一个这样的例子。曲线绘制是入门微积分课程中的基本内容，学生需要通过代数运算、极限和导数来找出函数曲线的显著特征。在本节中，你将学习如何使用SymPy自动执行它。
- en: 'There are many variants of the task. For simplicity, we will reduce it to its
    bare essentials: identifying the local extrema and asymptotes of the curve, and
    highlight them on a plot of the function. We will also limit ourselves to rational
    fractions, which are functions equal to a ratio of polynomials.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这个任务有很多变体。为了简单起见，我们将它简化为其基本要素：识别曲线的局部极值和渐近线，并在函数的图像上突出显示它们。我们还将限制自己使用有理分数，即等于多项式比率的函数。
- en: 'We shall work exclusively in the IPython notebook, taking advantage of its
    advanced mathematical rendering and of in-line plotting. Our goal will be to write
    a function that takes a string (representing a mathematical function using the
    Python syntax) and creates a figure similar to the following:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在IPython笔记本中独家工作，利用其高级数学渲染和内联绘图功能。我们的目标将是编写一个函数，该函数接受一个字符串（使用Python语法表示数学函数），并创建一个类似于以下图示的图形：
- en: '![Quick start – Automated curve sketching](img/3626OS_01_05.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![快速入门 – 自动化曲线绘制](img/3626OS_01_05.jpg)'
- en: Step 1 – Handling the input
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第1步 – 处理输入
- en: Let us choose `string = '1/(x-1) + 1/(x+1) + x + 1'` as the example that will
    guide us along the way. The `sympify()`function can convert a string into an expression.
    However, this expression needs further transformation. One issue is that SymPy
    defaults to computing in the complex field, but here we are only interested in
    real values. We also need to ensure that the expression is explicitly in the form
    of a rational fraction.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们选择`string = '1/(x-1) + 1/(x+1) + x + 1'`作为引导我们的例子。`sympify()`函数可以将字符串转换为表达式。然而，这个表达式需要进一步转换。一个问题在于SymPy默认在复数域中进行计算，但在这里我们只对实数感兴趣。我们还需要确保表达式明确地以有理分数的形式存在。
- en: 'Our first task is therefore to create a function that handles all these operations.
    Thanks to the notebook interface, you can build it step by step, first by creating
    a series of statements operating on the example string and then converting this
    series of operation into a `convert_input(string)` function that works on all
    valid input strings. These steps are illustrated as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的第一个任务是创建一个处理所有这些操作的功能。多亏了笔记本界面，你可以逐步构建它，首先通过创建一系列操作示例字符串的语句，然后将这些操作序列转换为`convert_input(string)`函数，该函数适用于所有有效的输入字符串。以下是如何展示这些步骤的：
- en: Create a new notebook.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的笔记本。
- en: In the first cell, add `%load_ext sympy.interactive.ipythonprinting` and `from
    sympy import *` (refer to *Step 4 – Configuring the notebook* of the *Quick start*
    section), and execute by pressing *Shift* + *Enter*.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第一个单元格中，添加`%load_ext sympy.interactive.ipythonprinting`和`from sympy import
    *`（参考“快速入门”部分的“步骤 4 – 配置笔记本”），然后按*Shift* + *Enter*执行。
- en: In the next cell, type `string = '1/(x-1) + 1/(x+1) + x + 1'`.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一个单元格中，键入`string = '1/(x-1) + 1/(x+1) + x + 1'`。
- en: 'Still in the second cell, add the line: `expr = sympify(string)` and execute
    it. This converts `string` into a SymPy expression.'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然在第二个单元格中，添加行：`expr = sympify(string)`并执行它。这会将`string`转换为SymPy表达式。
- en: Check your result by executing `expr` in the third cell.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在第三个单元格中执行`expr`来检查你的结果。
- en: Back in the second cell, find the symbol that `expr` uses with `sym, = expr.free_symbols`
    (this will fail if there are no symbols or if there are more than one). Again
    execute the cell and check your result.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第二个单元格中，找到`expr`使用`sym, = expr.free_symbols`（如果没有符号或符号多于一个，这将失败）所使用的符号。再次执行单元格并检查你的结果。
- en: Create a real symbol with the same name using `x = Symbol(sym.name, real=True)`.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`x = Symbol(sym.name, real=True)`创建具有相同名称的实数符号。
- en: Replace `sym` with `x` in the expression using `expr = expr.subs(sym, x)` and
    check your result.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`expr = expr.subs(sym, x)`将表达式中的`sym`替换为`x`，并检查你的结果。
- en: Turn the expression into a rational fraction. For this, you need the `together()`function,
    which combines the expression into a single fraction, and the `cancel()` function,
    which simplifies the fraction.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将表达式转换为有理分数。为此，你需要`together()`函数，它将表达式组合成一个单独的分数，以及`cancel()`函数，它简化分数。
- en: 'Finally, create the `convert_input(string)` function: insert the line `def
    convert_input(string):` before the second line of the cell, add `return frac,
    x` at the end, and, just for clarity, move the first line (the definition of `string`)
    elsewhere.'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，创建 `convert_input(string)` 函数：在单元格的第二行之前插入 `def convert_input(string):`，在末尾添加
    `return frac, x`，并且为了清晰起见，将第一行（`string` 的定义）移到其他地方。
- en: 'You can now test your function on `string` and on other inputs. In the following
    sections, we will assume that `frac, x = convert_input(''1/(x-1) + 1/(x+1) + x
    + 1'')` has been run. At this point, your notebook should contain something like
    the following:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以对你的函数在 `string` 和其他输入上进行测试。在接下来的章节中，我们将假设 `frac, x = convert_input('1/(x-1)
    + 1/(x+1) + x + 1')` 已经运行。此时，你的笔记本应该包含以下内容：
- en: '![Step 1 – Handling the input](img/3626OS_01_06.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![第 1 步 – 处理输入](img/3626OS_01_06.jpg)'
- en: Step 2 – Finding the domain of definition
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 2 步 – 查找定义域
- en: 'The domain of definition of the function is the set of values of *x* for which
    the expression is well-defined. In the case of a rational fraction, these are
    the values where the denominator is not zero. Computing the domain is hence just
    a matter of finding the (real) roots of the denominator and computing the complement
    of the set of roots. You can do this as follows (continue to check the results
    after every instruction):'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的定义域是使表达式有定义的 *x* 的值的集合。在有理分数的情况下，这些是分母不为零的值。因此，计算定义域只是找到分母的（实数）根并计算根的补集的问题。你可以这样做（在每条指令之后继续检查结果）：
- en: Extract the denominator of the fraction, using `den = denom(x)`.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `den = denom(x)` 提取分数的分母。
- en: Find the zeros of the denominator with `poles = solve(den, x)`. Since `x` was
    declared as real, this call to `solve()` finds the real values of `x` for which
    `den` is zero.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `poles = solve(den, x)` 查找分母的零点。由于 `x` 被声明为实数，此 `solve()` 调用找到 `den` 为零的
    `x` 的实数值。
- en: Get the domain. The full real line is `Interval(-oo, oo)` and the list of zeros
    can be converted to a symbolic set by calling `FiniteSet.fromiter(poles)`.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取定义域。整个实数线是 `Interval(-oo, oo)`，而零点的列表可以通过调用 `FiniteSet.fromiter(poles)` 转换为符号集合。
- en: 'Here are the notebook cells corresponding to this step:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是与这一步骤对应的笔记本单元格：
- en: '![Step 2 – Finding the domain of definition](img/3626OS_01_07.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![步骤 2 – 求定义域](img/3626OS_01_07.jpg)'
- en: Step 3 – Finding the local extrema
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 3 步 – 查找局部极值
- en: To find the local extrema, we need to compute the derivative of the function.
    The zeros of the derivative give the critical points, in other words, the points
    where the curve has a horizontal tangent. The local extrema of the function are
    actually the zeros where the derivative changes sign, but for simplicity, we will
    ignore this detail and assume, as is usually the case, that every zero is an extremum.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找到局部极值，我们需要计算函数的导数。导数的零点给出临界点，换句话说，曲线具有水平切线的点。函数的局部极值实际上是导数改变符号的零点，但为了简单起见，我们将忽略这个细节，并假设，正如通常情况，每个零点都是一个极值。
- en: 'You should therefore use the following steps:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你应该使用以下步骤：
- en: Compute the derivative by calling `diff(frac, x)`.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用 `diff(frac, x)` 计算导数。
- en: 'Apply the `cancel()` function to the previous result to simplify the derivative.
    These two steps can be combined using the code: `deriv = cancel(diff(frac, x))`.'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对上一个结果应用 `cancel()` 函数以简化导数。这两个步骤可以使用以下代码合并：`deriv = cancel(diff(frac, x))`。
- en: 'Find the zeros using the following code: `extrema = solve(deriv, x)`.'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码查找零点：`extrema = solve(deriv, x)`。
- en: Get the value of the function at each extremum. To do this, replace `x` with
    the location `x0` of each extremum, using `frac.subs(x, x0)`.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每个极值处获取函数的值。为此，使用 `frac.subs(x, x0)` 将 `x` 替换为每个极值的 `x0` 位置。
- en: 'Applying these instructions should give you the following:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 应用这些指令应该给出以下结果：
- en: '![Step 3 – Finding the local extrema](img/3626OS_01_08.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![第 3 步 – 查找局部极值](img/3626OS_01_08.jpg)'
- en: Step 4 – Computing the asymptotes
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 4 步 – 计算渐近线
- en: We shall now find the asymptotes of the curve. In fact, we already know the
    vertical asymptotes; they are simply the lines *x = x0* for each pole *x0*. For
    a rational function, the only other possible asymptote can be found by studying
    the function's behavior when *x* goes to infinity. If we have *f(x) ≈ m x + p*
    in that case, *y = m x + p* is the equation of the asymptote. To find *m* and
    *p*, we take *m* as the limit of *f(x)/x*, if it is not infinite, and then take
    *p* as the limit of *f(x) – m x*.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将找到曲线的渐近线。实际上，我们已经知道垂直渐近线；它们只是每个极点*x0*的*x = x0*直线。对于有理函数，唯一可能的另一个渐近线可以通过研究当*x*趋于无穷大时函数的行为来找到。如果我们有*f(x)
    ≈ m x + p*，那么*y = m x + p*就是渐近线的方程。为了找到*m*和*p*，如果*m*不是无穷大，我们将*m*作为*f(x)/x*的极限，然后取*p*作为*f(x)
    – m x*的极限。
- en: 'It is actually easier to do it than to explain it – simply follow these instructions:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，做起来比解释起来容易得多——只需遵循以下说明：
- en: Compute the limit of *f(x)/x* using `m = limit(y/x, x, oo)`.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`m = limit(y/x, x, oo)`计算*f(x)/x*的极限。
- en: To check that m is not infinite, use `m.is_bounded`
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要检查m不是无穷大，使用`m.is_bounded`
- en: Compute the limit of f(x) – m x, using `p = limit(y – m*x, x, oo)`
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`p = limit(y – m*x, x, oo)`计算f(x) – m x的极限。
- en: Wrap this into a function `find_asymptote(expr, x)` that returns `(m, p)` if
    the asymptote exists and `None` otherwise.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其封装成一个函数`find_asymptote(expr, x)`，如果渐近线存在，则返回`(m, p)`，否则返回`None`。
- en: 'The result of this step should look as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 此步骤的结果应如下所示：
- en: '![Step 4 – Computing the asymptotes](img/3626OS_01_09.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![步骤4 – 计算渐近线](img/3626OS_01_09.jpg)'
- en: Step 5 – Plotting the curve
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 步骤5 – 绘制曲线
- en: 'To create the summary plot, we will use matplotlib directly. So, let us first
    see how to plot just the curve. Since direct numerical evaluation inside SymPy,
    while precise, is rather slow, it would be inefficient to generate the curve using
    it. Fortunately, it is easy to "compile" a symbolic expression into a Python function
    that takes advantage of NumPy''s fast vectorized operations. Everything else is
    just standard matplotlib. Follow these instructions:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建总结图，我们将直接使用matplotlib。因此，让我们首先看看如何仅绘制曲线。由于在SymPy内部进行直接数值评估虽然精确，但相当慢，因此使用它生成曲线将是不高效的。幸运的是，很容易将符号表达式“编译”成一个利用NumPy快速向量化操作的Python函数。其余的只是标准的matplotlib。按照以下说明操作：
- en: Import matplotlib and NumPy, using `import matplotlib.pyplot as plt` and `import
    numpy as np`.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`import matplotlib.pyplot as plt`和`import numpy as np`导入matplotlib和NumPy。
- en: Compile the function using `func = lambdify([x], frac)`.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`func = lambdify([x], frac)`编译函数。
- en: Create a NumPy array sampling the *x*-interval, with the `np.linspace()`function.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`np.linspace()`函数创建一个采样*x*-区间的NumPy数组。
- en: Evaluate the compiled function over the array.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在数组上评估编译后的函数。
- en: Draw the plot, using `plt.plot()`.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`plt.plot()`绘制图形。
- en: Set the bounding box in the *x* and *y* directions, using the `plt.xlim()` and
    `plt.ylim()`functions.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`plt.xlim()`和`plt.ylim()`函数在*x*和*y*方向上设置边界框。
- en: Bundle this procedure into a helper function, `plot_curve(expr, x, (x_min, x_max),
    (y_min, y_max))`.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此过程封装成一个辅助函数，`plot_curve(expr, x, (x_min, x_max), (y_min, y_max))`。
- en: 'For this step, you should end up with the following:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此步骤，你应该得到以下结果：
- en: '![Step 5 – Plotting the curve](img/3626OS_01_10.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![步骤5 – 绘制曲线](img/3626OS_01_10.jpg)'
- en: Step 6 – Building the figure
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 步骤6 – 构建图形
- en: To make the final figure, we need to choose a plotting domain, overlay the asymptotes
    and the critical points over the graph of the function, and add a descriptive
    title.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 为了制作最终的图形，我们需要选择一个绘图域，在函数的图形上叠加渐近线和临界点，并添加一个描述性标题。
- en: Choosing a domain that gives an informative and aesthetically pleasing figure
    is actually an art. Doing it automatically is hence challenging. We will dodge
    this difficulty by simply making sure that the domain contains all the interesting
    values of `x` and `y`, and add a buffer of `2` on all sides. In code, this means
    `x_min = min(xs) - 2` and `x_max = max(xs) + 2`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 选择一个既信息丰富又美观的域实际上是一种艺术。自动完成这个任务因此具有挑战性。我们将通过确保域包含所有有趣的x和y值，并在所有边上添加一个`2`的缓冲区来避免这个困难。在代码中，这意味着`x_min
    = min(xs) - 2`和`x_max = max(xs) + 2`。
- en: 'Here are the steps you should use:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是你应该使用的步骤：
- en: 'Write a helper function `choose_domain()`: it needs to take a list, convert
    its elements to float, and return `x_min` and `x_max` as aforementioned. Note
    that calling `float()` on symbolic SymPy objects automatically converts them into
    ordinary Python floats using numerical algorithms.'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个辅助函数 `choose_domain()`：它需要接受一个列表，将其元素转换为浮点数，并返回上述的 `x_min` 和 `x_max`。请注意，在符号
    SymPy 对象上调用 `float()` 会自动使用数值算法将它们转换为普通的 Python 浮点数。
- en: 'Find the bounds for `x`, the interesting values being the origin, the poles,
    and the extrema. For this, you can use the following code:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到 `x` 的界限，有趣的是原点、极点和极值。为此，你可以使用以下代码：
- en: '[PRE8]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Find the bounds for `y`, using the origin, the extrema, and the end points
    of the oblique asymptote, with the following:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下方法找到 `y` 的界限，使用原点、极值和斜渐近线的端点：
- en: '[PRE9]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Plot the curve, using `plot_curve(frac, x, (x_min, x_max), (y_min, y_max))`.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `plot_curve(frac, x, (x_min, x_max), (y_min, y_max))` 绘制曲线。
- en: 'Add the vertical asymptotes, using the following code:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码添加垂直渐近线：
- en: '[PRE10]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Add the oblique asymptote, using the following code:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码添加斜渐近线：
- en: '[PRE11]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Add the extrema, using the following code:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码添加极值：
- en: '[PRE12]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Finally, add the title. SymPy''s `latex()` function returns the LaTex representation
    of its argument, which matplotlib can render. This allows you to use mathematical
    notation in the title, using the following code:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，添加标题。SymPy 的 `latex()` 函数返回其参数的 LaTex 表示形式，matplotlib 可以渲染。这允许你使用数学符号在标题中，使用以下代码：
- en: '[PRE13]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The final result of these steps looks as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤的最终结果如下所示：
- en: '![Step 6 – Building the figure](img/3626OS_01_11.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![第 6 步 – 构建图形](img/3626OS_01_11.jpg)'
- en: Tip
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Downloading the example code**'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从你购买的所有 Packt 书籍的账户中下载示例代码文件。[http://www.packtpub.com](http://www.packtpub.com)。如果你在其他地方购买了这本书，你可以访问
    [http://www.packtpub.com/support](http://www.packtpub.com/support) 并注册以直接将文件通过电子邮件发送给你。
- en: Top 5 features you'll want to know about
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你需要了解的前五项功能
- en: As you start to use SymPy, you will realize that there are a wide variety of
    things that you can do with it and many concepts you need to understand. This
    section will teach you all about the most fundamental features and the most commonly
    performed tasks in SymPy.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始使用 SymPy 时，你会意识到你可以用它做很多事情，你需要理解许多概念。本节将教你关于 SymPy 中最基本的功能和最常见任务的所有内容。
- en: Creating expressions
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建表达式
- en: Mathematical expressions are the most important objects in SymPy. Nearly everything
    you can do involves expressions at some point. In this section, you will learn
    how best to create mathematical expressions that SymPy can manipulate.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 数学表达式是 SymPy 中最重要的对象。几乎你能做的每一件事都涉及到在某个时刻使用表达式。在本节中，你将学习如何最好地创建 SymPy 可以操作数学表达式。
- en: 'The first building blocks for expressions are numbers. SymPy uses its own classes
    to represent them because the behavior of Python''s built-in types is geared toward
    numerical evaluation, not symbolic computation. There are two major kinds of numbers:
    exact expressions and floating point numbers. The latter are represented by the
    class `Float`.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式的第一个构建块是数字。SymPy 使用它自己的类来表示它们，因为 Python 内置类型的行为了解数值评估，而不是符号计算。主要有两种数字：精确表达式和浮点数。后者由
    `Float` 类表示。
- en: 'Exact expressions can involve many different classes as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 精确表达式可能涉及许多不同的类别，如下所示：
- en: '`Integer` represents signed integer numbers of arbitrary magnitude.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Integer` 表示任意大小的有符号整数。'
- en: '`Rational` represents rational numbers, or ordinary fractions. Internally,
    it is implemented as a pair of integers.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Rational` 表示有理数，或普通分数。内部实现为一个整数对。'
- en: Common mathematical constants are represented by singleton classes and are directly
    available in the `sympy` namespace. Thus, `pi` is the diameter of a unit circle,
    `E` is the base of the natural logarithm, and `I` is the imaginary unit. Note
    that there is no separate type corresponding to complex numbers. Rather, they
    are represented in the same way as they are usually written with pen and paper,
    for example, `2 + 3*I` is 2 + 3i.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见的数学常数由单例类表示，并且可以直接在 `sympy` 命名空间中访问。因此，`pi` 是单位圆的直径，`E` 是自然对数的底数，而 `I` 是虚数单位。请注意，没有与复数对应的单独类型。相反，它们以通常用笔和纸书写的方式表示，例如，`2
    + 3*I` 表示 2 + 3i。
- en: '`Integer` objects behave mostly like Python''s built-in `int`. The most important
    exception is that the division between integers is exact and returns either an
    `Integer` or `Rational` object. Here are a few examples of arithmetic operations:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`Integer` 对象的行为大多类似于 Python 的内置 `int`。最重要的例外是整数之间的除法是精确的，并返回一个 `Integer` 或
    `Rational` 对象。以下是一些算术操作的示例：'
- en: '[PRE14]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When you enter a number into the interpreter, such as "3", it creates a Python
    built-in object, of class `int`. To convert it to a SymPy object, you need to
    use the `sympify()` function, or the more convenient shortcut `S()`. Thus, you
    can use `S(23)` to create an integer. However, all operations between a SymPy
    object and a Python number convert the number into a SymPy object, and all the
    common functions do the same to their arguments. This limits the need for `S()`drastically.
    In practice, the rule to remember is that you must use `S()` only when dividing
    two integers, as in `S(1)/2`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个数字输入到解释器中，例如 "3"，它创建了一个 Python 内置对象，其类为 `int`。要将它转换为 SymPy 对象，你需要使用 `sympify()`
    函数，或者更方便的快捷方式 `S()`。因此，你可以使用 `S(23)` 来创建一个整数。然而，所有在 SymPy 对象和 Python 数字之间的操作都将数字转换为
    SymPy 对象，所有常见函数对其参数也做同样的处理。这大大减少了使用 `S()` 的需求。在实践中，要记住的规则是，只有在除以两个整数时才必须使用 `S()`，例如
    `S(1)/2`。
- en: A few additional operations are available, such as prime factor decomposition
    with `factorint()`, finding the least common multiple with `lcm()`, or the greatest
    common divisor with `gcd()`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 可用一些额外的操作，例如使用 `factorint()` 进行素数分解，使用 `lcm()` 查找最小公倍数，或使用 `gcd()` 查找最大公约数。
- en: '[PRE15]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Rationals also support all arithmetic operations. The resulting fractions are
    always reduced to their lowest terms. Also, raising a number to a fractional power
    produces algebraic *n*th roots. There are a few conveniences to make such calculations
    easier: `sqrt(n)` is a shortcut for `n**(S(1)/2)` and `root(n, a)` is a shortcut
    for `n**(1/a)`.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 有理数也支持所有算术操作。结果分数总是化简到最简形式。此外，将一个数提升到分数次幂会产生代数的 *n* 次根。有一些便利性使此类计算更容易：`sqrt(n)`
    是 `n**(S(1)/2)` 的快捷方式，而 `root(n, a)` 是 `n**(1/a)` 的快捷方式。
- en: 'Doing calculations involving fractions and square roots with SymPy is therefore
    as easy as elementary arithmetic using only integers. Here are the steps to follow:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，使用 SymPy 进行涉及分数和平方根的计算与仅使用整数进行的基本算术一样简单。以下是遵循的步骤：
- en: Create the relevant numbers, using `S()` as necessary.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建相关数字，必要时使用 `S()`。
- en: Write the calculation in the obvious manner.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以明显的方式写出计算。
- en: 'For example, the following commands find the hypotenuse of a right triangle
    with sides one-half and two-thirds:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下命令找到边长为半和三分之二的直角三角形的斜边：
- en: '[PRE16]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Roots of negative and complex numbers are supported, but note that *n*th roots
    are always defined as the principal *n*th root of the number. This means in particular
    that the third root of a negative number is a complex number with positive real
    and imaginary parts. Also, these roots are often expressed using fractional powers
    of -1, as shown in the following example:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 负数和复数的根是支持的，但请注意，第 *n* 次根始终定义为该数的正则 *n* 次根。这意味着特别是负数的立方根是一个具有正实部和虚部的复数。此外，这些根通常使用
    -1 的分数次幂来表示，如下面的示例所示：
- en: '[PRE17]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Symbols
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 符号
- en: 'We have just seen how to calculate with numbers, but the real power of mathematics
    comes from using algebraic variables. For this, you need to use the `Symbol` objects.
    To create them, you must specify their name and you can optionally specify various
    "assumptions" about the variable. The available assumptions include "integer",
    "real", "positive", and so on. If none is specified, the `Symbol` object is treated
    as a complex variable. Implications between properties are automatically taken
    into account, and impossible combinations cause an error. The following are a
    few examples of `Symbol` declarations:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚看到了如何使用数字进行计算，但数学的真正力量来自于使用代数变量。为此，你需要使用 `Symbol` 对象。要创建它们，你必须指定它们的名称，并且你可以选择指定关于变量的各种“假设”。可用的假设包括“整数”、“实数”、“正数”等。如果没有指定，`Symbol`
    对象被视为复数变量。属性之间的含义会自动考虑，不可能的组合会导致错误。以下是一些 `Symbol` 声明的示例：
- en: '[PRE18]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `symbols()`function makes it easier to create many symbols at once. The
    keyword arguments you give it are passed on to the `Symbol()` constructor. For
    the first argument, it accepts a mini-language inspired by the Python `slice`
    notation, which is best described by the following example:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`symbols()` 函数使得一次性创建多个符号变得更加容易。你给出的关键字参数会被传递给 `Symbol()` 构造函数。对于第一个参数，它接受一个受
    Python `slice` 语法启发的迷你语言，以下是一个示例：'
- en: '[PRE19]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: You may find on the Internet (including SymPy's own documentation) some references
    to the `sympy.abc` module or the `var` function. Their sole purpose is to save
    a little bit of typing, while using implicit magic to do so. We recommend that
    you only use `Symbol()` or `symbols()` and explicit assignments to create `Symbol`
    objects.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会在互联网上（包括 SymPy 的官方文档）找到一些关于 `sympy.abc` 模块或 `var` 函数的引用。它们唯一的目的就是节省一点输入，同时使用隐式魔法来实现。我们建议你只使用
    `Symbol()` 或 `symbols()` 以及显式赋值来创建 `Symbol` 对象。
- en: 'In the IPython notebook, symbol names containing Greek letters, underscores,
    and/or numbers get special rendering as shown in the following screenshot:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在 IPython 笔记本中，包含希腊字母、下划线和/或数字的符号名称会得到特殊的渲染，如下面的截图所示：
- en: '![Symbols](img/3626OS_02_01.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![符号](img/3626OS_02_01.jpg)'
- en: 'For the remainder of the text, we will assume that the following definitions
    are in effect:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 对于文本的其余部分，我们将假设以下定义是有效的：
- en: '[PRE20]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'All the arithmetic operators and mathematical functions operating on numbers
    work on symbols as well. The result is a new symbolic expression. Very simple
    calculations such as `x + x` are automatically carried out, but more complex expressions
    such as `(x + 1) * (x - 1)` are not simplified, as you can see:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 所有对数字进行操作的算术运算符和数学函数也可以对符号进行操作。结果是新的符号表达式。非常简单的计算，如 `x + x`，会自动执行，但更复杂的表达式，如
    `(x + 1) * (x - 1)`，则不会简化，正如你所看到的：
- en: '[PRE21]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'It is worth emphasizing that SymPy symbols are just ordinary objects, as far
    as the Python interpreter is concerned. Even experienced SymPy users sometimes
    get bitten by the semantic proximity between Python variables and mathematical
    variables. To prevent confusion on this subject, let us analyze the following
    sequence of statements:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 值得强调的是，从 Python 解释器的角度来看，SymPy 符号只是普通对象。即使是经验丰富的 SymPy 用户有时也会被 Python 变量和数学变量之间的语义相似性所困扰。为了避免在这方面产生混淆，让我们分析以下一系列语句：
- en: '[PRE22]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the first line, a `Symbol` object is created with `t` as the value of its
    name attribute. This object is immediately bound to a Python variable named `t`.
    In the second line, the object `(1 + Symbol('t'))` is bound to the variable `expr`.
    In the third line, the `t` variable is re-bound to the object `1`. This new binding
    does not affect the objects created in the first-two lines in any way, as the
    fourth line demonstrates.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行，使用 `t` 作为其名称属性值的 `Symbol` 对象被创建。此对象立即绑定到名为 `t` 的 Python 变量。在第二行，对象 `(1
    + Symbol('t'))` 被绑定到变量 `expr`。在第三行，变量 `t` 重新绑定到对象 `1`。这种新的绑定方式不会以任何方式影响第一、二行中创建的对象，正如第四行所展示的。
- en: Note
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: Confusion arises when a `Symbol` object is bound to a variable with the same
    name (for example, with the statement `x = Symbol('x')`). To prevent it entirely,
    consider using different names for the variable and the `Symbol` object, that
    is, `symb = Symbol('x')`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个 `Symbol` 对象绑定到具有相同名称的变量时（例如，使用语句 `x = Symbol('x')`）会产生混淆。为了完全避免这种情况，考虑为变量和
    `Symbol` 对象使用不同的名称，即 `symb = Symbol('x')`。
- en: Functions
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数
- en: SymPy implements a large number of mathematical functions. Their names tend
    to follow programmers' naming conventions, with for example, "atanh" for the inverse
    hyperbolic tangent, "log" for the natural logarithm, or "sqrt" for the square
    root.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: SymPy 实现了大量的数学函数。它们的名称往往遵循程序员的命名约定，例如，“atanh”用于双曲正切，“log”用于自然对数，或“sqrt”用于平方根。
- en: Applying a function to an exact number expression always results in another
    exact expression. This result is usually an unevaluated expression, such as sin(1),
    unless a simple result exists, such as sin(0) = 0, in which case it is returned.
    Evaluating the result can sometimes involve floating-point computations, which
    are automatically performed with enough precision.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 将函数应用于精确数字表达式始终会产生另一个精确表达式。这个结果通常是一个未评估的表达式，如sin(1)，除非存在简单结果，如sin(0) = 0，在这种情况下，它会被返回。评估结果有时可能涉及浮点计算，这些计算会自动以足够的精度执行。
- en: 'Here is an elementary example of the use of mathematical functions:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个使用数学函数的基本示例：
- en: '[PRE23]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'It is also possible to create abstract symbolic functions; the syntax for this
    is `Function(''f'')`. Such functions behave like the built-in ones, except that
    their values always remain unevaluated, as shown in this example:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以创建抽象的符号函数；这种语法的格式是`Function('f')`。这些函数的行为类似于内置函数，但它们的值始终保持未评估状态，如下例所示：
- en: '[PRE24]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Mathematical functions defined by an expression such as g(x) = 1 – x² are represented
    by Lambda objects. The name of this class and the syntax it uses echo Python''s
    `Lambda` keyword. Calling these objects evaluates the function according to the
    given expression. Here is an example demonstrating the creation and use of a `Lambda`
    object:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 由表达式如g(x) = 1 – x²定义的数学函数由Lambda对象表示。这个类的名称和它使用的语法反映了Python的`Lambda`关键字。调用这些对象会根据给定的表达式评估函数。以下是一个演示创建和使用`Lambda`对象的示例：
- en: '[PRE25]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Note that the `Lambda` objects are rarely actually useful. The idiomatic way
    of studying the function `g`, which is previously defined, is to define `expr
    = 1 - x**2` and to manipulate that expression.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`Lambda`对象实际上很少真正有用。研究先前定义的函数`g`的惯用方法是定义`expr = 1 - x**2`并操作该表达式。
- en: Manipulating expressions
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作表达式
- en: Once you have created expressions, you often need to transform them in some
    way. This section will teach you how to inspect them and to transform them in
    many ways.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了表达式，你通常需要以某种方式对其进行转换。本节将教你如何检查它们，并以多种方式转换它们。
- en: The structure of expressions
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 表达式的结构
- en: 'In terms of structure, SymPy objects such as integers, rationals, constants,
    and symbols are called **atoms**. All expressions are built on top of these simpler
    objects. They obey the following invariant: `expr == expr.__class__(*expr.args)`,
    which means that all their properties derive solely from their type and the contents
    of their `.args` attribute. Also, since the elements of `expr.args` are SymPy
    objects themselves, the whole expression actually has a tree structure with SymPy
    classes as nodes and atoms as leaves.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 从结构上来说，SymPy 对象如整数、有理数、常量和符号被称为**原子**。所有表达式都是建立在这些更简单的对象之上的。它们遵循以下不变性：`expr
    == expr.__class__(*expr.args)`，这意味着它们的全部属性仅从它们的类型和`.args`属性的内容中派生。此外，由于`expr.args`的元素本身也是
    SymPy 对象，整个表达式实际上具有树状结构，其中 SymPy 类作为节点，原子作为叶子。
- en: 'It is easy, and often illuminating, to explore this expression tree. Here are
    some of the options at your disposal to do it:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 探索这个表达式树既容易又富有启发性。以下是一些你可以使用的选项：
- en: The `srepr()`function prints a low-level representation of the expression.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`srepr()`函数打印表达式的一个低级表示。'
- en: To walk the whole expression tree, use `preorder_traversal()`; it returns an
    iterator that yields nodes in a preorder fashion. That is, it yields the root
    (the full expression), then its first child, then the first child's first child,
    and so on
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要遍历整个表达式树，使用`preorder_traversal()`；它返回一个迭代器，以先序方式产生节点。也就是说，它首先产生根（完整表达式），然后是其第一个子节点，然后是第一个子节点的第一个子节点，依此类推。
- en: Drill down directly through the chain of `args`.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接通过`args`链钻入。
- en: 'The following commands show all these ways of exploring the expression `exp(-x)*log(1-x)*2`:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令显示了探索表达式`exp(-x)*log(1-x)*2`的所有这些方式：
- en: '[PRE26]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this example, you can see two important classes, `Add` and `Mul`, which are
    used internally to represent addition and multiplication, respectively. Note in
    particular that `1 - x` is actually represented as `Add(Mul(-1, x), 1)`, and that
    the actual order in which the arguments are stored internally has no relation
    to the order in which they were input.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你可以看到两个重要的类，`Add` 和 `Mul`，它们分别用于内部表示加法和乘法。特别注意的是，`1 - x` 实际上表示为 `Add(Mul(-1,
    x), 1)`，并且实际存储参数的顺序与它们输入的顺序没有关系。
- en: 'You can also obtain an aggregate view of the contents of the expression with
    the `.atoms()`method. By default, it returns the set of the atomic objects contained
    in the expressions. A type can also be passed to it, to return all the objects
    of that type appearing in the expression tree. Here are a few ways of applying
    it to the expression from the previous example:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用 `.atoms()` 方法获得表达式内容的聚合视图。默认情况下，它返回包含在表达式中的原子对象的集合。也可以传递一个类型给它，以返回表达式树中出现的该类型的所有对象。以下是如何将其应用于前面示例中表达式的几种方法：
- en: '[PRE27]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If you want to check which variables an expression depends on, this purely
    structural query does not give enough information, because some objects, such
    as `Lambda`, use `Symbol` internally as bound variables: in `Lambda([x], x*2)`,
    the identity of the symbol does not matter and, for any practical purpose, this
    object is the same as `Lambda([y], y**2)`. What you need in this case is the `free_symbols`
    property, which returns only the symbols acting as free variables. The right way
    of checking if some expr depends explicitly on `x` is therefore `x in expr.free_symbols`,
    as shown in the following example:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想检查表达式依赖于哪些变量，这种纯粹的结构查询提供的信息不足，因为一些对象，如 `Lambda`，在内部使用 `Symbol` 作为绑定变量：在
    `Lambda([x], x*2)` 中，符号的身份并不重要，并且对于任何实际目的，这个对象与 `Lambda([y], y**2)` 是相同的。在这种情况下，你需要的是
    `free_symbols` 属性，它只返回作为自由变量的符号。因此，检查某个表达式是否明确依赖于 `x` 的正确方式是 `x in expr.free_symbols`，如下面的示例所示：
- en: '[PRE28]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Conceivably, every operation on expressions could be done by walking through
    the expression tree and inspecting its elements as we have just seen and then
    constructing the result directly. And, indeed, a sizable portion of SymPy's source
    code does precisely that. It is, however, too cumbersome for ordinary uses and
    there are much more convenient ways of manipulating expressions, but exploring
    the expression tree should be your first reflex when debugging any problem.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，对表达式进行的每一个操作都可以通过遍历表达式树并检查其元素（正如我们刚才所看到的）来直接构造结果。实际上，SymPy 源代码中相当大的一部分就是这样做的。然而，对于普通用途来说，这太繁琐了，而且有更多更方便的方式来操作表达式，但在调试任何问题时，探索表达式树应该是你的第一反应。
- en: Querying properties
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查询属性
- en: Every expression has properties, which include `is_integer`, `is_real`, and
    so on. These allow querying the mathematical properties of the object and correspond
    to the similarly named assumptions on symbols. They return `True`, `False`, or
    `None`, depending on whether the mathematical property is proven to be true, proven
    to be false, or of uncertain truth value.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 每个表达式都有属性，包括 `is_integer`、`is_real` 等。这些属性允许查询对象的数学属性，并对应于符号上的类似名称的假设。它们根据数学属性是否被证明为真、被证明为假或具有不确定的真值返回
    `True`、`False` 或 `None`。
- en: For number expressions, they will usually return a definite answer, either `True`
    or `False`. For symbolic expressions, on the other hand, `None` is a common and
    meaningful result. For example, if `x = Symbol('x', real=True)`, then `x.is_positive`
    must return `None` because both positive and negative values are compatible with
    the assumption that `x` is real.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数字表达式，它们通常会返回一个确定的答案，即 `True` 或 `False`。另一方面，对于符号表达式，`None` 是一个常见且有意义的结果。例如，如果
    `x = Symbol('x', real=True)`，那么 `x.is_positive` 必须返回 `None`，因为正数和负数都与 `x` 是实数的假设兼容。
- en: 'The following commands demonstrate the computation of these properties for
    numbers and symbolic expressions:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令演示了这些属性在数字和符号表达式上的计算：
- en: '[PRE29]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'SymPy checks the properties when performing many operations and can return
    different results depending on them. For instance, compare the following:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: SymPy 在执行许多操作时会检查属性，并且可以根据它们返回不同的结果。例如，比较以下：
- en: '[PRE30]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Substitution
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代换
- en: 'SymPy objects and expressions are immutable. Transforming them actually means
    creating a new object differing from the initial one in some way. The most direct
    way of doing this is to use the `.subs()` method. `expr.subs(old, new)` returns
    a new expression where all the occurrences of `old` in `expr` have been replaced
    by `new`. To replace several different expressions at once, you can also pass
    it as a single argument a dictionary of the `{old: new}` pairs, as shown in the
    following example:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 'SymPy 对象和表达式是不可变的。转换它们实际上意味着创建一个新的对象，它在某些方面与初始对象不同。最直接的方法是使用 `.subs()` 方法。`expr.subs(old,
    new)` 返回一个新的表达式，其中 `expr` 中所有 `old` 的出现都被 `new` 替换。要同时替换多个不同的表达式，你也可以将它作为一个包含
    `{old: new}` 对的字典的单个参数传递，如下面的例子所示：'
- en: '[PRE31]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Substitution is also the most idiomatic way of evaluating a function at a specific
    value. To take an example, here is what you should do if you want to compute `f(2)`,
    where the function `f` is given by `f(x) = exp(x+1)/(x^2-2)`:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 代入也是评估函数在特定值时的最地道方式。以一个例子来说明，如果你想要计算 `f(2)`，其中函数 `f` 定义为 `f(x) = exp(x+1)/(x^2-2)`，你应该这样做：
- en: Create the expression corresponding to the `exp(x+1)/(x**2 - 2)` function.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建对应于 `exp(x+1)/(x**2 - 2)` 函数的表达式。
- en: Substitute `x` by `2` in the expression.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在表达式中将 `x` 代入 `2`。
- en: 'The corresponding commands are as follows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 对应的命令如下：
- en: '[PRE32]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'A useful trick involving substitution is to force some transformation that
    SymPy would not normally do. For instance, supposing you want to simplify `sqrt((z-1)**2)`
    to `z-1` inside a larger expression, even though `z` is complex, here is what
    you should do:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 一个涉及代入的有用技巧是强制进行 SymPy 通常不会做的某些转换。例如，假设你想要在一个更大的表达式中将 `sqrt((z-1)**2)` 简化为 `z-1`，即使
    `z` 是复数，你应该这样做：
- en: Identify what assumption would allow the transformation. Here you need to make
    the value of `(z - 1).is_positive` to be true.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定什么假设可以使转换成立。在这里，你需要使 `(z - 1).is_positive` 的值为真。
- en: Find a substitution that makes the assumption true. Here, replacing `z` with
    `1 + a`, `a` positive, would do it.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到一个代入，使得假设成立。在这里，将 `z` 替换为 `1 + a`，`a` 为正数，就可以做到这一点。
- en: 'Do the substitution:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进行代入：
- en: '[PRE33]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Optionally, do more manipulations on the substituted expression (not needed
    in this example).
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可选地，对代入后的表达式进行更多操作（在这个例子中不需要）。
- en: Substitute back the initial symbol.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代回初始符号。
- en: 'The corresponding commands are as follows:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 对应的命令如下：
- en: '[PRE34]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Simplification
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 简化
- en: When you have a symbolic expression, a common need is to put it into a shorter
    form or one that is easier to understand. It is nearly always more convenient
    to deal with 1 than with `cos(x)**2 + sin(x)**2`. This is where the `simplify()`
    function comes in use.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有一个符号表达式时，一个常见的需求是将它转换成更短或更容易理解的形式。通常来说，处理 `1` 比处理 `cos(x)**2 + sin(x)**2`
    更方便。这就是 `simplify()` 函数发挥作用的地方。
- en: '`simplify()` applies a heuristic combination of simplification algorithms.
    It can use trigonometric relations, apply properties of logarithms and exponentials,
    simplify fractions and square roots, and so on. In all these operations, it takes
    into account the properties of the objects, particularly `is_positive` and `is_real`,
    as shown in the following example:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`simplify()` 应用一系列简化的启发式算法。它可以使用三角关系，应用对数和指数的性质，简化分数和平方根，等等。在这些操作中，它考虑了对象的性质，尤其是
    `is_positive` 和 `is_real`，如下面的例子所示：'
- en: '[PRE35]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Note that, in general, simplification is not a well-defined concept and what
    is considered the simplest expression depends on how it will be used subsequently.
    `simplify()` is a good choice for interactive exploration or when you do not know
    much about the expression. However, SymPy has a large array of specialized simplification
    functions, so when you know the structure of the expression and what kind of transformation
    you need, it is better to use these.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，一般来说，简化不是一个定义良好的概念，被认为是最简单的表达式取决于它随后的使用方式。`simplify()` 是交互式探索或当你对表达式了解不多时的一个好选择。然而，SymPy
    有大量专门化的简化函数，所以当你知道表达式的结构和你需要的转换类型时，使用这些函数会更好。
- en: 'Here is a list of the most useful ones (there are more in the `sympy.simplify`
    module):'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这里列出了最有用的几个（`sympy.simplify` 模块中还有更多）：
- en: '`radsimp()`: This simplifies expressions with square roots'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`radsimp()`: 这将简化包含平方根的表达式'
- en: '`trigsimp()`: This simplifies combinations of trigonometric functions'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`trigsimp()`: 这将简化三角函数的组合'
- en: '`cancel()`: This clears out common factors between the numerator and the denominator
    of a fraction'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cancel()`: 这将清除分数的分子和分母之间的公因数'
- en: '`together()`: This puts sums of a fraction over the same denominator'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`together()`: 这个函数将分数的加和放在相同的分母上'
- en: '`apart()`: This applies partial fraction decomposition'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`apart()`: 这个函数应用部分分式分解'
- en: 'The following commands show how they can be used:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令展示了它们的使用方法：
- en: '[PRE36]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Another class of transformations is provided by the `expand` family of functions.
    They modify expressions by making their structure simpler or by replacing "advanced"
    objects with more elementary ones. Their result is typically longer than their
    input (and sometimes very much longer). `expand()` itself subsumes all the `expand_*()`
    functions via a complex set of keyword flags (see its docstring for details).
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 另一类变换是由 `expand` 函数族提供的。它们通过简化表达式结构或用更基本的对象替换“高级”对象来修改表达式。它们的结果通常比输入长（有时非常长）。`expand()`
    本身通过一组复杂的关键字标志将所有 `expand_*()` 函数包含在内（详细信息请参阅其文档字符串）。
- en: 'Like `simplify()`, `expand()` is a good one-stop shop, but you should rather
    use the specialized variants when you can. Here is a selection of them, demonstrated
    by example:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `simplify()` 类似，`expand()` 也是一个一站式商店，但当你能使用专门的变体时，你应该使用它们。以下是一些示例，展示了这些变体的使用：
- en: '[PRE37]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Checking for mathematical equality
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查数学上的相等性
- en: 'Comparing two expressions with `==` checks whether they are structurally identical,
    which is a sufficient but by no means a necessary condition for mathematical equality.
    Note that only expressions that are printed identically may be considered equal:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `==` 比较两个表达式检查它们是否在结构上相同，这是数学相等的充分但不必要条件。请注意，只有打印相同的表达式才能被认为是相等的：
- en: '[PRE38]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'To check whether two expressions are mathematically equal, you need to check
    whether their difference reduces to zero. To do this, apply a canonicalization
    function to the difference, and test whether it''s equal to zero. `simplify()`
    is a generally useful choice for this, but `expand()` can also be used:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查两个表达式在数学上是否相等，你需要检查它们的差是否简化为零。为此，对差值应用一个规范化函数，并测试它是否等于零。`simplify()` 通常是一个有用的选择，但
    `expand()` 也可以使用：
- en: '[PRE39]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Numerical evaluation
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数值评估
- en: In this section you will learn all the best ways of obtaining numerical results
    from your symbolic computations.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习从符号计算中获得数值结果的所有最佳方法。
- en: Floating-point numbers
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 浮点数
- en: To represent floating point numbers, SymPy uses the class `Float`. The major
    difference between the built-in `float` and `sympy.Float` is that the latter uses
    arbitrary precision. This means that you can use it to obtain as many digits of
    precision as you want.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 为了表示浮点数，SymPy 使用 `Float` 类。与内置的 `float` 和 `sympy.Float` 之间的主要区别在于后者使用任意精度。这意味着你可以用它来获取你想要的任意多位数的精度。
- en: 'Floating point numbers are approximations. Symbolic calculations work best
    when all objects involved are known exactly. For this reason, you should avoid
    letting `Float` objects appear in your expressions. Instead, perform your calculations
    with `Rational` and other symbolic objects and convert only the final result to
    a numeric value. This is done with the `N()` function. It takes an optional second
    argument, `''n''`, specifying the number of digits of precision of the result.
    By default, the result has 15 digits of precision, which is roughly as much as
    can be encoded in a Python `float`. However, a major difference between using
    `N()` and floating point arithmetic is that `N()` can perform intermediate computation
    at a much higher precision if needed. The following example illustrates this:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点数是近似值。符号计算在所有涉及的对象都已知精确时效果最佳。因此，你应该避免在表达式中出现 `Float` 对象。相反，使用 `Rational` 和其他符号对象进行计算，并将最终结果转换为数值值。这是通过
    `N()` 函数完成的。它接受一个可选的第二个参数 `'n'`，指定结果的小数位数精度。默认情况下，结果有15位精度，这大约是Python `float`
    可以编码的精度。然而，使用 `N()` 与浮点运算之间的主要区别是，如果需要，`N()` 可以在更高的精度下执行中间计算。以下示例说明了这一点：
- en: '[PRE40]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In the last line, note the precision of the result. It can only have been obtained
    by using a much higher precision internally. This shows why it's important to
    carry out exact computations as far as possible. Indeed, if `q` had been converted
    to a double-precision float (with ~15 digits of precision), it would have been
    impossible to extend the precision to recover a meaningful result.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一行，注意结果的确切度。这只能通过在内部使用更高的精度才能获得。这表明尽可能进行精确计算的重要性。实际上，如果 `q` 被转换为双精度浮点数（具有约15位精度），将无法扩展精度以恢复有意义的结果。
- en: 'You can see in the following code that converting to `Float` too early gives
    a wrong and even absurd result:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下代码中看到，过早地将 `Float` 转换为错误甚至荒谬的结果：
- en: '[PRE41]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'To get a numerical result out of a symbolic computation, it is best to use
    the `subs` option of `N()`, which accepts a substitution dictionary. Step by step,
    here is the process to follow:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 要从符号计算中获得数值结果，最好使用 `N()` 的 `subs` 选项，它接受一个替换字典。以下是逐步过程：
- en: Create a symbolic expression.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个符号表达式。
- en: Do the computation symbolically.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进行符号计算。
- en: Evaluate the result using `N()` with the `subs` option.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `N()` 并带有 `subs` 选项来评估结果。
- en: 'For instance, the following commands compute the derivative of `f` at x=1.2345,
    where `f(x) = exp(x)/(x+1)`:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下命令计算 `f` 在 x=1.2345 处的导数，其中 `f(x) = exp(x)/(x+1)`：
- en: '[PRE42]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Compiling expressions
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编译表达式
- en: SymPy's facilities for floating point computations are implemented in pure Python
    and their primary objective is precision, not speed. As a result, they are too
    slow for the many applications where double-precision is sufficient but many computations
    are required, such as plotting or numerical integration.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: SymPy 的浮点计算功能是用纯 Python 实现的，其主要目标是精度，而不是速度。因此，对于许多需要双精度但计算量大的应用（如绘图或数值积分），它们太慢了。
- en: 'The solution to this problem is to convert symbolic expressions obtained with
    SymPy into a more efficient form for numerical evaluation. More specifically,
    this form will often be a function using `numpy`. To obtain it, you can use `lambdify()`.
    Its interface is `lambdify(args, expr)`, where `expr` is the expression you wish
    to convert, and `args` is a list of symbols that correspond to the arguments of
    the resulting Python callable, so that, for example, `lambdify([x, y, z], x+y)`
    is effectively equivalent to `lambda x, y, z: x+y`.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '解决这个问题的方法是，将使用 SymPy 获得的符号表达式转换为数值评估的更有效形式。更具体地说，这种形式通常是一个使用 `numpy` 的函数。要获得它，你可以使用
    `lambdify()`。其接口是 `lambdify(args, expr)`，其中 `expr` 是你希望转换的表达式，而 `args` 是对应于结果
    Python 可调用参数的符号列表，因此，例如，`lambdify([x, y, z], x+y)` 实际上等同于 `lambda x, y, z: x+y`。'
- en: 'Here are the steps you should follow to evaluate an expression efficiently
    for a large number of parameter values:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是你应该遵循的步骤，以高效地评估大量参数值的表达式：
- en: Create the symbolic expression. It would usually be the result of some symbolic
    calculation, but in this example, we will use `a + x**2`.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建符号表达式。它通常是某些符号计算的结果，但在这个例子中，我们将使用 `a + x**2`。
- en: 'Identify all the symbols appearing in the expression. This step is often trivial
    (here, the symbols are obviously `x` and `a`), but nevertheless critical: if you
    happened to leave one symbol out, the "compiled" function would actually return
    a symbolic expression and be slow.'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 识别表达式中出现的所有符号。这一步通常是微不足道的（在这里，符号显然是 `x` 和 `a`），但仍然至关重要：如果你不小心遗漏了一个符号，"编译"后的函数实际上会返回一个符号表达式并且运行缓慢。
- en: Compile the expression using `lambdify()`. In this example, you should use `lambdify([x,
    a], a + x**2, "numpy")` (we will explain the meaning of the third argument in
    the following explanation).
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `lambdify()` 编译表达式。在这个例子中，你应该使用 `lambdify([x, a], a + x**2, "numpy")`（我们将在以下解释中解释第三个参数的含义）。
- en: Create NumPy arrays holding the parameter values.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建包含参数值的 NumPy 数组。
- en: Evaluate the compiled function.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 评估编译后的函数。
- en: 'The corresponding commands are as follows:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 对应的命令如下：
- en: '[PRE43]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: By default, `lambdify()` converts SymPy functions into their equivalents in
    either the `math` module in the standard library, `numpy`, or `mpmath`, by decreasing
    the order of preference. To get fast numerical evaluation, the best choice is
    to use only NumPy functions. For this, pass the string `"numpy"` as the third
    argument of `lambdify`.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`lambdify()` 将 SymPy 函数转换为标准库中的 `math` 模块、`numpy` 或 `mpmath` 的等效函数，按照优先级递减。为了获得快速的数值评估，最佳选择是仅使用
    NumPy 函数。为此，将字符串 `"numpy"` 作为 `lambdify` 的第三个参数传递。
- en: You can also make `lambdify()` use any function you wish, by passing the appropriate
    objects as the third argument. Passing any module will fetch the functions from
    it, but note that functions are matched by name, so that naming differences (for
    example, `sympy.atan` versus `numpy.arctan`) may prevent some functions from being
    translated. You can also pass a dictionary directly mapping names to functions.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过传递适当的对象作为第三个参数，让 `lambdify()` 使用你希望使用的任何函数。传递任何模块都会从中获取函数，但请注意，函数是通过名称匹配的，因此命名差异（例如，`sympy.atan`
    与 `numpy.arctan`）可能会阻止某些函数被转换。你也可以直接传递一个将名称映射到函数的字典。
- en: Preset dictionaries establishing the correct equivalences are also available
    for the modules `math`, `numpy`, `mpmath`, and `sympy`. To use them, pass the
    name of the module as a string.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 为 `math`、`numpy`、`mpmath` 和 `sympy` 模块提供正确等价的预置字典也是可用的。要使用它们，传递模块名称作为字符串。
- en: 'Finally, it is also possible to combine these mapping specifications by putting
    several of them in a list. For instance, assuming you have created your own approximation
    for sin, and wish to fallback to NumPy for any other function, you would use the
    following:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，也可以通过将几个映射规范放入一个列表中来组合这些映射规范。例如，假设你已经创建了自己的正弦近似，并希望对于任何其他函数回退到 NumPy，你会使用以下方法：
- en: '[PRE44]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Calculus
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 微积分
- en: Calculus is probably the most important application of SymPy. In this section,
    you will learn how to compute derivatives, integrals, limits, and series.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 微积分可能是 SymPy 最重要的应用之一。在本节中，你将学习如何计算导数、积分、极限和级数。
- en: Derivatives
  id: totrans-301
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 导数
- en: 'To compute the derivative of a function, create the corresponding expression
    and use `diff()`. Its first argument is the expression and the second is the variable
    with regard to which you want to differentiate. The result is the expression for
    the derivative:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算一个函数的导数，创建相应的表达式并使用 `diff()`。它的第一个参数是表达式，第二个参数是你想要对其求导的变量。结果是导数的表达式：
- en: '[PRE45]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Higher-order derivatives can also be computed with a single call to `diff()`:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以通过一次调用 `diff()` 来计算高阶导数：
- en: '[PRE46]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Due to SymPy's focus on expressions rather than functions, the derivatives for
    symbolic functions can seem a little surprising, but LaTeX rendering in the notebook
    should make their meaning clear.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 SymPy 专注于表达式而不是函数，符号函数的导数可能会显得有些令人惊讶，但笔记本中的 LaTeX 渲染应该会使它们的意义变得清晰。
- en: '[PRE47]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Let''s take a look at the following screenshot:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看下面的截图：
- en: '![Derivatives](img/3626OS_02_02.jpg)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![导数](img/3626OS_02_02.jpg)'
- en: Limits
  id: totrans-310
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 极限
- en: 'Limits are obtained through `limit()`. The syntax for the limit of `expr` when
    `x` goes to some value `x0` is `limit(expr, x, x0)`. To specify a limit towards
    infinity, you need to use SymPy''s infinity object, named `oo`. This object will
    also be returned for infinite limits:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 极限是通过 `limit()` 获得的。当 `x` 走向某个值 `x0` 时，`expr` 的极限的语法是 `limit(expr, x, x0)`。要指定向无限大的极限，需要使用
    SymPy 的无限对象，名为 `oo`。此对象也将返回无限大的极限：
- en: '[PRE48]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'There is also a fourth optional parameter, to specify the direction of approach
    of the limit target. `"+"` (the default) gives the limit from above, and `"-"`
    is from below. Obviously, this parameter is ignored when the limit target is infinite:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个第四个可选参数，用于指定极限目标的接近方向。`"+"`（默认值）表示从上方给出极限，而`"-"`表示从下方。显然，当极限目标是无限大时，此参数将被忽略：
- en: '[PRE49]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Let''s take a look at the following screenshot:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看下面的截图：
- en: '![Limits](img/3626OS_02_03.jpg)'
  id: totrans-316
  prefs: []
  type: TYPE_IMG
  zh: '![极限](img/3626OS_02_03.jpg)'
- en: Integrals
  id: totrans-317
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 积分
- en: SymPy has powerful algorithms for integration, and, in particular, can find
    most integrals of logarithmic and exponential functions expressible with special
    functions, and many more besides, thanks to Meijer G-functions.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: SymPy 具有强大的积分算法，特别是可以找到大多数可以用特殊函数表示的对数和指数函数的积分，以及更多，这得益于 Meijer G 函数。
- en: The main function for integration is `integrate()`. It can compute both antiderivatives
    (indefinite integrals) and definite integrals. Note that the value of an antiderivative
    is only defined up to an arbitrary constant but the result does not include it.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 集成的主要函数是 `integrate()`。它可以计算反导数（不定积分）和定积分。请注意，反导数的值仅定义到任意常数，但结果不包括它。
- en: '[PRE50]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Unevaluated symbolic integrals and antiderivatives are represented by the `Integral`
    class. `integrate()` may return these objects if it cannot compute the integral.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 未评估的符号积分和反导数由 `Integral` 类表示。如果无法计算积分，`integrate()` 可能会返回这些对象。
- en: 'It is also possible to create `Integral` objects directly, using the same syntax
    as `integrate()`. To evaluate them, call their `.doit()` method:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以直接使用与 `integrate()` 相同的语法创建 `Integral` 对象。要评估它们，调用它们的 `.doit()` 方法：
- en: '[PRE51]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Let''s take a look at the following screenshot:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看下面的截图：
- en: '![Integrals](img/3626OS_02_04.jpg)'
  id: totrans-325
  prefs: []
  type: TYPE_IMG
  zh: '![积分](img/3626OS_02_04.jpg)'
- en: Taylor series
  id: totrans-326
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 泰勒级数
- en: 'A Taylor series approximation is an approximation of a function obtained by
    truncating its Taylor series. To compute it, use `series(expr, x, x0, n)`, where
    `x` is the relevant variable, `x0` is the point where the expansion is done (defaults
    to 0), and `n` is the order of expansion (defaults to 6):'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 泰勒级数近似是通过截断函数的泰勒级数得到的函数近似。要计算它，使用 `series(expr, x, x0, n)`，其中 `x` 是相关变量，`x0`
    是展开的点（默认为0），`n` 是展开的阶数（默认为6）：
- en: '[PRE52]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The `O(x**6)` part in the result is a "big-O" object. Intuitively, it represents
    all the terms of order equal to or higher than 6\. This object automatically absorbs
    or combines with powers of the variable, which makes simple arithmetic operations
    on expansions convenient:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 结果中的 `O(x**6)` 部分是一个 "大O" 对象。直观上，它表示所有阶数等于或高于6的项。此对象会自动吸收或结合变量的幂，这使得对展开式进行简单算术运算变得方便：
- en: '[PRE53]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'If you want to use the expansion as an approximation of the function, the `O()`
    term prevents it from behaving like an ordinary expression, so you need to remove
    it. You can do so by using the aptly named `.removeO()` method:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想将展开式用作函数的近似，`O()` 项会阻止它像普通表达式那样行为，因此你需要将其移除。你可以通过使用名为 `.removeO()` 的方法来完成此操作：
- en: '[PRE54]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Taylor series look better in the notebook, as shown in the following screenshot:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 泰勒级数在笔记本中看起来更好，如下面的截图所示：
- en: '![Taylor series](img/3626OS_02_05.jpg)'
  id: totrans-334
  prefs: []
  type: TYPE_IMG
  zh: '![泰勒级数](img/3626OS_02_05.jpg)'
- en: Solving equations
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解方程
- en: This section will teach you how to solve the different types of equations that
    SymPy handles.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将教你如何解决 SymPy 处理的不同类型的方程。
- en: The main function to use for solving equations is `solve()`. Its interface is
    somewhat complicated as it accepts many different kinds of inputs and can output
    results in various forms depending on the input.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 用于解方程的主要函数是 `solve()`。它的接口相对复杂，因为它接受许多不同类型的输入，并且根据输入可以以各种形式输出结果。
- en: In the simplest case, univariate equations, use the syntax `solve(expr, x)`
    to solve the equation expr = 0 for the variable `x`. If you want to solve an equation
    of the form A = B, simply put it under the preceding form, using `solve(A - B,
    x)`. This can solve algebraic and transcendental equations involving rational
    fractions, square roots, absolute values, exponentials, logarithms, trigonometric
    functions, and so on. The result is then a list of the values of the variables
    satisfying the equation.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在最简单的情况下，一元方程，使用 `solve(expr, x)` 语法来解方程 expr = 0 对于变量 `x`。如果你想解形式为 A = B 的方程，只需将其放在前面的形式下面，使用
    `solve(A - B, x)`。这可以解决涉及有理分数、平方根、绝对值、指数、对数、三角函数等的代数方程和超越方程。结果是满足方程的变量的值列表。
- en: 'The following commands show a few examples of equations that can be solved:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令展示了几个可以解决的方程示例：
- en: '[PRE55]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Note that the form of the result means that it can only return a finite set
    of solutions. In cases where the true solution is infinite, it can therefore be
    misleading. When the solution is an interval, `solve()` typically returns an empty
    list. For periodic functions, usually only one solution is returned:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，结果的形式意味着它只能返回有限解集。在真实解是无限的情况下，这可能会产生误导。当解是一个区间时，`solve()` 通常返回一个空列表。对于周期函数，通常只返回一个解：
- en: '[PRE56]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The domain over which the equation is solved depends on the assumptions on
    the variable. Hence, if the variable is a real `Symbol` object, only real solutions
    are returned, but if it is complex, then all solutions in the complex plane are
    returned (subject to the aforementioned restriction on returning infinite solution
    sets). This difference is readily apparent when solving polynomials, as the following
    example demonstrates:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 解方程的域取决于变量的假设。因此，如果变量是一个实数 `Symbol` 对象，则只返回实数解，但如果它是复数，则返回复平面上的所有解（受上述返回无限解集的限制）。当解多项式时，这种差异很容易看出，如下例所示：
- en: '[PRE57]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'There is no restriction on the number of variables appearing in the expression.
    Solving a multivariate expression for any of its variables allows it to be expressed
    as a function of the other variables, and to eliminate it from other expressions.
    The following example shows different ways of solving the same multivariate expression:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式中出现的变量数量没有限制。解一个多元表达式的任意变量允许它以其他变量的函数形式表示，并从其他表达式中消除它。以下示例展示了以不同方式解同一个多元表达式的方法：
- en: '[PRE58]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'To solve a system of equations, pass a list of expressions to `solve()`: each
    one will be interpreted, as in the univariate case, as an equation of the form
    expr = 0\. The result can be returned in one of two forms, depending on the mathematical
    structure of the input: either as a list of tuples, where each tuple contains
    the values for the variables in the order given to solve, or a single dictionary,
    suitable for use in `subs()`, mapping variables to their values.'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 要解一个方程组，将表达式列表传递给 `solve()`：每个表达式都将像在单变量情况下一样被解释，作为形式为 expr = 0 的方程。结果可以以两种形式之一返回，具体取决于输入的数学结构：要么作为包含解变量值的元组列表，每个元组包含解时给出的变量顺序，要么作为单个字典，适合用于
    `subs()`，将变量映射到它们的值。
- en: 'As you can see in the following example, it can be hard to predict what form
    the result will take:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下示例所示，预测结果的形式可能很难：
- en: '[PRE59]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'This variability in return types is fine for interactive use, but for library
    code, more predictability is required. In this case, you should use the `dict=True`
    option. The output will then always be a list of mappings of variables to value.
    Compare the following example to the previous one:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 这种返回类型的可变性对于交互式使用来说很好，但对于库代码，需要更多的可预测性。在这种情况下，你应该使用 `dict=True` 选项。然后输出将始终是变量到值的映射的列表。将以下示例与上一个示例进行比较：
- en: '[PRE60]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: People and places you should get to know
  id: totrans-352
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你应该了解的人和地方
- en: If you need help with SymPy, here are some people and places which will prove
    invaluable.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要 SymPy 的帮助，以下是一些人和地方，它们将非常有价值。
- en: Official sites
  id: totrans-354
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 官方网站
- en: 'Homepage: [http://sympy.org/](http://sympy.org/)'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主页：[http://sympy.org/](http://sympy.org/)
- en: 'Manual and documentation: [http://docs.sympy.org/](http://docs.sympy.org/)'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手册和文档：[http://docs.sympy.org/](http://docs.sympy.org/)
- en: 'Wiki: [http://wiki.sympy.org/](http://wiki.sympy.org/)'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Wiki: [http://wiki.sympy.org/](http://wiki.sympy.org/)'
- en: 'Blog: [http://sympy.blogspot.com/](http://sympy.blogspot.com/)'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 博客：[http://sympy.blogspot.com/](http://sympy.blogspot.com/)
- en: 'Source code: [https://github.com/sympy/sympy](https://github.com/sympy/sympy)'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源代码：[https://github.com/sympy/sympy](https://github.com/sympy/sympy)
- en: Articles and tutorials
  id: totrans-360
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文章和教程
- en: An impressive demonstration of SymPy-powered multibody dynamics by Jason Moore
    at [http://www.moorepants.info/blog/npendulum.html](http://www.moorepants.info/blog/npendulum.html)
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jason Moore 在 [http://www.moorepants.info/blog/npendulum.html](http://www.moorepants.info/blog/npendulum.html)
    上展示了由 SymPy 驱动的多体动力学令人印象深刻的演示。
- en: A SymPy tutorial given at SciPy 2011 at [http://mattpap.github.com/scipy-2011-tutorial/html/index.html](http://mattpap.github.com/scipy-2011-tutorial/html/index.html)
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 SciPy 2011 上提供的 SymPy 教程：[http://mattpap.github.com/scipy-2011-tutorial/html/index.html](http://mattpap.github.com/scipy-2011-tutorial/html/index.html)
- en: SymPy's tutorial, straight from the official documentation at [http://docs.sympy.org/0.7.2/tutorial.html](http://docs.sympy.org/0.7.2/tutorial.html)
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SymPy 的教程，直接来自官方文档：[http://docs.sympy.org/0.7.2/tutorial.html](http://docs.sympy.org/0.7.2/tutorial.html)
- en: Community
  id: totrans-364
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 社区
- en: Official mailing list at `<[sympy@googlegroups.com](mailto:sympy@googlegroups.com)>`
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 官方邮件列表：`<[sympy@googlegroups.com](mailto:sympy@googlegroups.com)>`
- en: Web interface to the mailing list at [https://groups.google.com/forum/?fromgroups#!forum/sympy](https://groups.google.com/forum/?fromgroups#!forum/sympy)
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 邮件列表的 Web 界面：[https://groups.google.com/forum/?fromgroups#!forum/sympy](https://groups.google.com/forum/?fromgroups#!forum/sympy)
- en: 'Official IRC channel: `#sympy on freenode`'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 官方 IRC 频道：`#sympy on freenode`
- en: User FAQ at [https://github.com/sympy/sympy/wiki/Faq](https://github.com/sympy/sympy/wiki/Faq)
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户常见问题解答：[https://github.com/sympy/sympy/wiki/Faq](https://github.com/sympy/sympy/wiki/Faq)
- en: Blogs
  id: totrans-369
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 博客
- en: 'Official blog aggregator for the whole community: [http://planet.sympy.org/](http://planet.sympy.org/)'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整个社区的官方博客聚合器：[http://planet.sympy.org/](http://planet.sympy.org/)
- en: 'The blog of Aaron Meurer, SymPy''s project leader: [http://asmeurersympy.wordpress.com/](http://asmeurersympy.wordpress.com/)'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SymPy 项目负责人 Aaron Meurer 的博客：[http://asmeurersympy.wordpress.com/](http://asmeurersympy.wordpress.com/)
- en: Matthew Rocklin blogs on statistics and linear algebra in SymPy at [http://matthewrocklin.com/blog/](http://matthewrocklin.com/blog/)
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Matthew Rocklin 在 SymPy 的统计和线性代数博客上写博：[http://matthewrocklin.com/blog/](http://matthewrocklin.com/blog/)
- en: Twitter
  id: totrans-373
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Twitter
- en: For more open source information, follow Packt at [http://twitter.com/#!/packtopensource](http://twitter.com/#!/packtopensource)
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要获取更多开源信息，请关注 Packt 在 [http://twitter.com/#!/packtopensource](http://twitter.com/#!/packtopensource)
