- en: 11 Additional Statistical Modeling Techniques for Time Series
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11种时间序列的附加统计建模技术
- en: Join our book community on Discord
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 书籍社区
- en: '![](img/file0.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](img/file0.png)'
- en: '[https://packt.link/zmkOY](https://packt.link/zmkOY)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/zmkOY](https://packt.link/zmkOY)'
- en: In *Chapter 10*, *Building Univariate Time Series Models Using Statistical Methods*,
    you were introduced to popular forecasting techniques such as *exponential smoothing,
    non-seasonal ARIMA*, *and seasonal ARIMA*. These methods, often referred to as
    classical statistical forecasting approaches, are fast, simple to implement, and
    easy to interpret.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第10章*，*使用统计方法构建单变量时间序列模型*中，你学习了流行的预测技术，如*指数平滑法、非季节性 ARIMA*，*和季节性 ARIMA*。这些方法通常被称为经典的统计预测方法，具有快速、易实现和易解释的特点。
- en: In this chapter, you will dive head-first and learn about additional statistical
    methods that build on the foundation you gained from the previous chapter. This
    chapter will introduce a few libraries that can automate time series forecasting
    and model optimization - Facebook's (meta) `Prophet` library. Additionally, you
    will explore `statsmodels'` **vector autoregressive (VAR)** class for working
    with multivariate time series and the `arch` library, which supports **GARCH**
    for modeling volatility in financial data.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将深入学习基于上一章基础的额外统计方法。本章将介绍一些可以自动化时间序列预测和模型优化的库——Facebook（Meta）的`Prophet`库。此外，你将探索`statsmodels`的**向量自回归（VAR）**类，用于处理多变量时间序列，以及`arch`库，它支持用于金融数据波动性建模的**GARCH**模型。
- en: The main goal of this chapter is to familiarize you with **automated forecasting
    tools** (like Prophet) and introduce the concept of **multivariate time series
    modeling** with VAR models. You will also gain an understanding of how to model
    and forecast **volatility** in financial time series, which is essential for risk
    management and financial decision-making.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的主要目标是让你熟悉**自动化预测工具**（如 Prophet），并介绍**多变量时间序列建模**的概念，使用 VAR 模型。你还将了解如何在金融时间序列中建模和预测**波动性**，这对于风险管理和财务决策至关重要。
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下食谱：
- en: Forecasting time series data using Facebook Prophet
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Facebook Prophet 进行时间序列数据预测
- en: Forecasting multivariate time series data using VAR
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 VAR 预测多变量时间序列数据
- en: Evaluating vector autoregressive (VAR) models
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评估向量自回归（VAR）模型
- en: Forecasting volatility in financial time series data with GARCH
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 GARCH 预测金融时间序列数据中的波动性
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You can download the Jupyter Notebooks to follow along and the necessary datasets
    for this chapter from this book''s GitHub repository:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从本书的 GitHub 仓库下载 Jupyter Notebooks 以便跟随学习，并下载本章所需的数据集：
- en: 'Jupyter Notebooks: [https://github.com/PacktPublishing/Time-Series-Analysis-with-Python-Cookbook./blob/main/code/Ch11/Chapter%2011.ipynb](https://github.com/PacktPublishing/Time-Series-Analysis-with-Python-Cookbook./blob/main/code/Ch11/Chapter%2011.ipynb)'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Jupyter Notebooks: [https://github.com/PacktPublishing/Time-Series-Analysis-with-Python-Cookbook./blob/main/code/Ch11/Chapter%2011.ipynb](https://github.com/PacktPublishing/Time-Series-Analysis-with-Python-Cookbook./blob/main/code/Ch11/Chapter%2011.ipynb)'
- en: 'Datasets: [https://github.com/PacktPublishing/Time-Series-Analysis-with-Python-Cookbook./tree/main/datasets/Ch11](https://github.com/PacktPublishing/Time-Series-Analysis-with-Python-Cookbook./tree/main/datasets/Ch11)'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '数据集: [https://github.com/PacktPublishing/Time-Series-Analysis-with-Python-Cookbook./tree/main/datasets/Ch11](https://github.com/PacktPublishing/Time-Series-Analysis-with-Python-Cookbook./tree/main/datasets/Ch11)'
- en: 'There are common libraries that you will be using throughout the recipes in
    this chapter. You can import them in advance by using the following code:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的食谱中，你将使用一些常见的库。你可以通过以下代码提前导入它们：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Forecasting time series data using Facebook Prophet
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Facebook Prophet 进行时间序列数据预测
- en: The **Prophet** library is a popular open-source project that was initially
    developed at Facebook (now Meta), based on a 2017 paper that proposed an algorithm
    for time series forecasting titled *Forecasting at Scale*. The project gained
    popularity due to its simplicity, ability to create performant forecasting models,
    and ability to handle complex seasonality, holiday effects, missing data, and
    outliers. Prophet automates many aspects of designing a forecasting model while
    providing rich built-in visualizations. Additional capabilities include building
    growth models (like **saturated forecasts**), working with uncertainty in trend
    and seasonality, and **detecting changepoints**.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**Prophet** 库是一个流行的开源项目，最初由 Facebook（现为 Meta）开发，基于 2017 年的一篇论文，提出了一种时间序列预测算法，标题为《*大规模预测*》。该项目因其简单性、能够创建高效的预测模型、以及处理复杂季节性、假期效应、缺失数据和异常值的能力而广受欢迎。Prophet
    自动化了许多设计预测模型的过程，同时提供了丰富的内置可视化功能。其他功能包括构建增长模型（如**饱和预测**）、处理趋势和季节性的 不确定性，以及**检测变化点**。'
- en: In this recipe, you will use the `Milk Production` dataset for benchmarking
    performance. This is the same dataset introduced in *Chapter 10*, *Building Univariate
    Time Series Models Using Statistical Methods*. Using the same dataset helps in
    understanding and comparing different methods.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，您将使用 `Milk Production` 数据集进行性能基准测试。这是 *第10章，使用统计方法构建单变量时间序列模型* 中介绍的相同数据集。使用相同的数据集有助于理解和比较不同的方法。
- en: 'Prophet is an **additive regression model** that can handle **non-linear trends**,
    especially when there are strong seasonal effects. The model decomposes time series
    data into three main components: *trend*, *seasonality*, and *holidays*, represented
    in the following form:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Prophet 是一个**加性回归模型**，可以处理**非线性趋势**，特别是在存在强烈季节性效应时。该模型将时间序列数据分解为三个主要组成部分：*趋势*、*季节性*和*假期*，形式如下所示：
- en: '![](img/file244.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](img/file244.png)'
- en: 'Where:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 其中：
- en: is the trend function,
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是趋势函数，
- en: represents the periodic seasonality function,
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代表周期性季节性函数，
- en: accounts for the effects of holidays,
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑到假期的影响，
- en: is the residual error term.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是残差误差项。
- en: Prophet uses **Bayesian inference** to automate tuning and optimization of the
    model components. Behind the scenes, it relies on **Stan**, a state-of-the-art
    platform for Bayesian modeling, with **cmdstand** and **cmdstanpy** as the current
    Python interface (replacing the earlier **PyStan**). Recent updates have improved
    compatibility with Apple M1/M2 chips and enhanced model customization options,
    such as adjusting the handling of holidays and scaling output.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Prophet 使用**贝叶斯推断**自动调整和优化模型组件。其背后依赖于**Stan**，一个最先进的贝叶斯建模平台，当前的 Python 接口为 **cmdstand**
    和 **cmdstanpy**（取代了早期的 **PyStan**）。最近的更新提高了与 Apple M1/M2 芯片的兼容性，并增强了模型自定义选项，例如调整假期处理和缩放输出。
- en: Getting ready
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 准备工作
- en: You can find the Jupyter Notebooks and necessary datasets from this book's GitHub
    repository. Please refer to the *Technical requirements* section of this chapter
    for more information. We use Prophet 1.0 version for this recipe.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在本书的 GitHub 仓库中找到 Jupyter 笔记本和必要的数据集。有关更多信息，请参阅本章的 *技术要求* 部分。我们为本教程使用 Prophet
    1.0 版本。
- en: 'Creating a new Python environment when installing new libraries like Prophet
    is always a good idea. If you need a quick refresher on creating a virtual Python
    environment, check out the *Development environment setup recipe* from *Chapter
    1*, *Getting Started with Time Series Analysis*. The chapter covers two methods:
    using `conda` and `venv`.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装像 Prophet 这样的新库时，创建一个新的 Python 环境总是一个好主意。如果您需要快速回顾如何创建虚拟 Python 环境，可以查看 *第1章，时间序列分析入门*
    中的 *开发环境设置教程*。该章节介绍了两种方法：使用 `conda` 和 `venv`。
- en: 'For example, you can create the environment using conda as in the following
    example:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您可以像以下示例一样使用 conda 创建环境：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This preceding code will create a new virtual environment named `prophet`.
    To make the new `prophet` environment visible in Jupyter, you can run the following
    code:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将创建一个名为 `prophet` 的新虚拟环境。要使新的 `prophet` 环境在 Jupyter 中可见，可以运行以下代码：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Once the new environment is activated, you can install the Prophet library.
    To install using **pip,** you can run the following:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦新环境被激活，您就可以安装 Prophet 库。要使用 **pip** 安装，您可以运行以下命令：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To install using **conda,** use the following command:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 **conda** 安装，请使用以下命令：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How to do it…
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Prophet requires the input data to be in a pandas DataFrame with two specific
    columns: a **datetime** column named `ds` and a target variable column named `y`
    – this is the variable you wish to forecast. Prophet does not work with a `Datetimeindex`
    directly. Hence, it’s crucial to have these columns explicitly named. If your
    data contains more than two columns, Prophet will only recognize `ds` and `y`,
    and ignore the rest by default. However, if you want to include additional predictors
    (regressors), use the `add_regressor` method. If these columns are missing or
    incorrectly named, Prophet will throw an error.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Prophet要求输入数据为一个包含两个特定列的pandas DataFrame：一个名为`ds`的**datetime**列和一个名为`y`的目标变量列——这是你希望预测的变量。Prophet不能直接处理`Datetimeindex`。因此，确保这些列明确命名非常重要。如果数据包含超过两列，Prophet只会识别`ds`和`y`，并默认忽略其他列。然而，如果你想添加额外的预测变量（回归器），可以使用`add_regressor`方法。如果这些列缺失或命名不正确，Prophet会抛出错误。
- en: 'To ensure your data is formatted properly, follow these steps:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 为确保数据格式正确，请按照以下步骤操作：
- en: 'Start by reading the `milk_productions.csv` file and rename the columns `ds`
    and `y`:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先读取`milk_productions.csv`文件并重命名列为`ds`和`y`：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Split the data into **test** and **train** sets. Let''s go with a `90/10` split
    by using the following code:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将数据拆分为**测试集**和**训练集**。我们使用`90/10`的比例进行拆分，代码如下：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You can create an instance of the Prophet class and fit it on the training
    set in one line with the `fit` method. The milk production time series is *monthly*,
    with both a trend and a steady seasonal fluctuation (additive). The default `seasonality_mode`
    in Prophet is `additive`, so leave it as-is:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以通过以下一行代码创建一个Prophet类的实例，并使用`fit`方法在训练集上进行拟合。牛奶生产的时间序列是*按月*记录的，具有趋势和稳定的季节性波动（加性）。Prophet的默认`seasonality_mode`是`additive`，所以保持原样即可：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Some setup needs to be done before you can use the model to make predictions.
    Use the `make_future_dataframe` method to extend the `train` DataFrame forward
    for a specific number of periods and at a specified frequency:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你使用模型进行预测之前，需要进行一些设置。使用`make_future_dataframe`方法将`train` DataFrame扩展到特定的预测期数，并按指定频率生成数据：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This extends the training data by 17 months (the number of periods in the `test`
    set). In total, you should have the exact number of periods that are in the milk
    DataFrame (train and test). The frequency is set to **month start** with `freq=''MS''`.
    The `future` object only contains one column, `ds`, of type `datetime64[ns]` ,
    which is used to populate the predicted values:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这会将训练数据延长17个月（`test`集中的期数）。总之，你应该拥有与牛奶DataFrame（训练和测试）中相同数量的期数。频率设置为**月初**，即`freq='MS'`。`future`对象只包含一个列`ds`，其类型为`datetime64[ns]`，用于填充预测值：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Use the `predict` method to take the `future` DataFrame and make the predictions.
    The result will be a DataFrame that''s the same length as `forecast` but now with
    additional columns:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`predict`方法对`future` DataFrame进行预测。结果将是一个与`forecast`长度相同的DataFrame，但现在会增加一些额外的列：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Notice that Prophet returned a lot of details to help you understand how the
    model performs. Of interest are `ds` and the predicted value, `yhat`. Both `yhat_lower`
    and `yhat_upper` represent the uncertainty intervals for the prediction (`yhat`).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Prophet返回了许多细节，帮助你了解模型的表现。重点是`ds`和预测值`yhat`。`yhat_lower`和`yhat_upper`分别表示预测的不确定性区间（`yhat`）。
- en: 'The `model` object provides two plotting methods: `plot` and `plot_components`.
    Start by using `plot` to visualize the forecast from Prophet:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`model`对象提供了两个绘图方法：`plot`和`plot_components`。首先使用`plot`方法来可视化Prophet的预测结果：'
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This should produce a plot of the Prophet forecast: the dots in the plot represent
    the training data point, the line over the dots represents the estimated forecast
    for the historical data, the line is extended beyond the training points reflect
    the future prediction'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会生成一个Prophet预测图：图中的点代表训练数据点，点上的线代表历史数据的估计预测，线条延伸到训练点之外，反映未来的预测。
- en: '![Figure 11.4 – Plotting the forecast (historical and future) using Prophet](img/file245.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图11.4 – 使用Prophet绘制预测图（历史与未来）](img/file245.png)'
- en: Figure 11.4 – Plotting the forecast (historical and future) using Prophet
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.4 – 使用Prophet绘制预测图（历史与未来）
- en: 'If you only want to show the forecast just for the periods beyond the training
    set you can use the following code:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只想展示超出训练集的预测期，可以使用以下代码：
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here you are only forecasting for the length of the test dataset. The predict
    method will only capture the `ds` column (datetime). This should produce a plot
    that's similar to the one shown in *Figure 11.4*, but it will only show the forecast
    line for future data points (beyond the training points)– that is, the future
    forecast.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这里你只预测了测试数据集的长度。预测方法将仅捕获 `ds` 列（日期时间）。这将生成一个类似于*图 11.4*所示的图表，但它只会显示未来数据点（训练数据点之后）的预测线——即未来的预测。
- en: '![Figure 11.5 – Plotting the forecast (historical and future) using Prophet](img/file246.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.5 – 使用 Prophet 绘制预测（历史和未来）](img/file246.png)'
- en: Figure 11.5 – Plotting the forecast (historical and future) using Prophet
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.5 – 使用 Prophet 绘制预测（历史和未来）
- en: The shaded area in *Figure 11.4* represents the uncertainty intervals. This
    is represented by the `yhat_lower` and `yhat_upper` columns in the `forecast`
    DataFrame.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11.4* 中的阴影区域表示不确定性区间。这由 `forecast` 数据框中的 `yhat_lower` 和 `yhat_upper` 列表示。'
- en: 'The next important plot deals with the forecast components. Use the `plot_components`
    method to plot the components:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，重要的图表涉及预测组件。使用 `plot_components` 方法绘制这些组件：
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The number of subplots will depend on the number of components that have been
    identified in the forecast. For example, if holiday was included, then it will
    show the `holiday` component. In our example, there will be two subplots: `trend`
    and `yearly`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 子图的数量将取决于预测中已识别的组件数量。例如，如果包括了假期，那么将会显示`holiday`组件。在我们的示例中，将有两个子图：`trend`和`yearly`：
- en: '![Figure 11.6 – Plotting the components showing trend and seasonality (annual)](img/file247.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.6 – 绘制显示趋势和季节性（年度）的组成部分](img/file247.png)'
- en: Figure 11.6 – Plotting the components showing trend and seasonality (annual)
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.6 – 绘制显示趋势和季节性（年度）的组成部分
- en: '*Figure 11.6* breaks down the trend and seasonality of the training data. If
    you look at *Figure 11.6*, you will see a positive upward trend that has become
    steady (slowing down) since 1972\. Additionally, the seasonal pattern shows an
    increase in production around summertime.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11.6* 展示了训练数据的趋势和季节性。如果你查看*图 11.6*，你会看到一个持续上升的趋势，自 1972 年以来逐渐稳定（放缓）。此外，季节性模式显示出夏季时生产量的增加。'
- en: The shaded area in the trend plot represents the uncertainty interval for estimating
    the trend. The data is stored in the `trend_lower` and `trend_upper` columns of
    the `forecast` DataFrame.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 趋势图中的阴影区域表示估算趋势的不确定性区间。数据存储在 `forecast` 数据框的 `trend_lower` 和 `trend_upper` 列中。
- en: 'Finally, compare with out-of-sample data (the test data) to see how well the
    model performs:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，与样本外数据（测试数据）进行比较，看看模型的表现如何：
- en: '[PRE14]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Compare the following plot with *Figure 10.43 from Chapter 10* to see how **Prophet**
    compares to the **SARIMA** model that you obtained using `auto_arima`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下图表与*第 10 章的图 10.43*进行比较，看看**Prophet**与使用 `auto_arima` 获得的**SARIMA**模型有何不同：
- en: '![Figure 11.7 – Comparing Prophet''s forecast against test data](img/file248.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.7 – 将 Prophet 的预测与测试数据进行比较](img/file248.png)'
- en: Figure 11.7 – Comparing Prophet's forecast against test data
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.7 – 将 Prophet 的预测与测试数据进行比较
- en: Notice that for the highly seasonal milk production data, the model did a great
    job. Generally, Prophet shines when it's working with strong seasonal time series
    data.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，对于高度季节性的牛奶生产数据，模型表现非常出色。通常，Prophet 在处理强季节性时间序列数据时表现优异。
- en: How it works…
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Prophet streamlines many aspects of building and optimizing time series models,
    but a few key instructions are required at the start to allow Prophet to properly
    tune the model. For example, initializing the model, you need to decide whether
    the seasonal effect should be additive or multiplicative. You also specify parameters
    like the frequency of the data (e.g., `freq='MS'` for monthly data) when extending
    the forecast horizon using the `make_future_dataframe` method.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Prophet 精简了构建和优化时间序列模型的多个方面，但在开始时需要一些关键指令，以便 Prophet 正确调整模型。例如，在初始化模型时，你需要决定季节性效应是加法模型还是乘法模型。你还需要指定诸如数据频率（例如，对于按月数据的`freq='MS'`）等参数，并使用
    `make_future_dataframe` 方法来扩展预测范围。
- en: 'When you instantiated a model with `model = Prophet()`, Prophet used the default
    values for parameters like `yearly_seasonality=''auto''`, `weekly_seasonality=''auto''`,
    and `daily_seasonality=''auto''`. This lets Prophet **automatically** determine
    which seasonal components to include based on the data. In the case of the Milk
    Production dataset, only yearly seasonality is detected, as shown below:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当你实例化模型 `model = Prophet()` 时，Prophet 会使用默认的参数值，例如 `yearly_seasonality='auto'`、`weekly_seasonality='auto'`
    和 `daily_seasonality='auto'`。这使得 Prophet 可以**自动**根据数据来确定需要包含的季节性分量。在牛奶生产数据集中，只检测到年度季节性，如下所示：
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Prophet also provides **uncertainty intervals** for predictions, which are
    influenced by three factors:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Prophet 还提供了**不确定性区间**来预测结果，这些区间受到三个因素的影响：
- en: '**Observation noise**: refers to the random variations in the observed data
    that cannot be explained by the model.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**观测噪声**：指的是无法通过模型解释的观测数据中的随机变化。'
- en: '**Parameter uncertainty**: refers to the uncertainty in estimating the model
    parameters. For example, adjusting the `mcmc_samples` parameter (**Markov Chain
    Monte Carlo** or **MCMC** sampling) to get the uncertainty in seasonal components.
    The defaults value is set to zero (`0`).'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**参数不确定性**：指的是在估计模型参数时的的不确定性。例如，调整 `mcmc_samples` 参数（**马尔可夫链蒙特卡罗** 或 **MCMC**
    采样）来获取季节性分量的不确定性。默认值为零 (`0`)。'
- en: '**Future trend uncertainty**: refers to uncertainty about future changes in
    trends based on historical data. For example, increasing the `changepoint_prior_scale`
    parameter can increase the forecast uncertainty. The default value is set to `0.05`.
    Additionally the width of the uncertainty intervals can also be adjusted with
    the `interval_width` parameter (defaults to 0.80 or 80%).'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**未来趋势不确定性**：指的是基于历史数据对未来趋势变化的预期不确定性。例如，增加 `changepoint_prior_scale` 参数值可以增加预测的不确定性。默认值设置为
    `0.05`。此外，区间宽度也可以通过 `interval_width` 参数进行调整（默认为 0.80 或 80%）。'
- en: By default, the `uncertainty_samples` parameter is set to `1000`, which means
    Prophet will run 1000 simulations using **Hamiltonian Monte Carlo (HMC)** algorithm
    to estimate uncertainty. You can adjust this to control the number of simulation
    or even turn off uncertainty estimates entirely by setting `uncertainty_samples=0`
    or `uncertainty_samples=False`. If uncertainty samples are disabled, Prophet will
    omit uncertainty intervals like `yhat_lower` and `yhat_upper` from the forecast
    results.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`uncertainty_samples` 参数设置为 `1000`，这意味着 Prophet 会使用**哈密顿蒙特卡罗（HMC）**算法进行
    1000 次模拟来估计不确定性。你可以调整此值以控制模拟次数，或者通过设置 `uncertainty_samples=0` 或 `uncertainty_samples=False`
    来完全关闭不确定性估计。如果禁用不确定性样本，Prophet 会从预测结果中省略像 `yhat_lower` 和 `yhat_upper` 这样的不确定性区间。
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Prophet’s strength lies in its ability to **automatically detect changepoints**,
    which are points in time where the **trend shifts** significantly. By default,
    Prophet will identify 25 potential changepoints within the first 80% of the training
    data. You can modify this behavior by adjusting the `n_changepoints` parameter
    or control how much historical data to use for changepoint detection via `changepoint_range`,
    which defaults to `0.8` (or 80%).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Prophet 的优势在于它能够**自动检测变化点**，这些是趋势发生显著变化的时间点。默认情况下，Prophet 会在训练数据的前 80% 中识别 25
    个潜在变化点。你可以通过调整 `n_changepoints` 参数来修改此行为，或者通过 `changepoint_range` 控制用于变化点检测的历史数据量，默认值为
    `0.8`（即 80%）。
- en: 'You can inspect the detected changepoints using the model’s `changepoints`
    attribute. For example, the following code displays the first five changepoints:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过模型的 `changepoints` 属性检查检测到的变化点。例如，以下代码显示前五个变化点：
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'These changepoints can also be visualized on a plot. The following code overlays
    the changepoints on the original time series data:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这些变化点也可以在图表上进行可视化。以下代码将变化点叠加到原始时间序列数据上：
- en: '[PRE18]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This should generate a plot with the original time series and the 25 potential
    changepoints, showing moments where Prophet identified shifts in the trend.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会生成一个图表，展示原始时间序列及 25 个潜在变化点，显示 Prophet 识别的趋势变化时刻。
- en: '![Figure 11.8 – The 25 potential changepoints, as identified by Prophet](img/file249.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.8 – Prophet 所识别的 25 个潜在变化点](img/file249.png)'
- en: Figure 11.8 – The 25 potential changepoints, as identified by Prophet
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.8 – Prophet 所识别的 25 个潜在变化点
- en: These potential changepoints were estimated from the first 80% of the training
    data.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这些潜在变化点是从训练数据的前 80% 中估算出来的。
- en: In the next section, you will explore changepoint detection in more detail.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，你将更详细地探索变化点检测。
- en: There's more…
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 还有更多内容…
- en: 'To plot the **significant** changepoints that capture the impactful changes
    in trend, you can use the `add_changepoints_to_plot` function, as shown in the
    following code:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 要绘制捕捉趋势中影响较大的变化点，你可以使用`add_changepoints_to_plot`函数，如以下代码所示：
- en: '[PRE19]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This should produce a plot similar to *Figure 11.8*, but with the additional
    changepoint lines and the trend line. There are ten (10) significant changepoints
    (the vertical lines in Figure 11.9) out of the 25\. The linear trend line should
    be the same as the trend component shown in *Figure 11.6*:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成类似于*图 11.8*的图表，但会有额外的变化点线和趋势线。图 11.9中的25个变化点中有10个（垂直线是显著的变化点）。线性趋势线应与*图
    11.6*中显示的趋势成分相同：
- en: '![Figure 11.9 – Showing the ten significant change points and the trend line](img/file250.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.9 – 显示十个显著的变化点和趋势线](img/file250.png)'
- en: Figure 11.9 – Showing the ten significant change points and the trend line
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.9 – 显示十个显著的变化点和趋势线
- en: Notice how the trend line changes at the identified changepoints. This is how
    Prophet can detect changes in the trend. The line is not an exact straight line
    since **piecewise regression** was applied to build the trend model. When thinking
    about *piecewise linear models*, you can think of multiple linear regression lines
    between the significant changepoints (segments) that are then connected. This
    gives the model the flexibility to capture **non-linear** changes in trends and
    make future predictions.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 注意趋势线在识别出的变化点处的变化。这就是Prophet如何检测趋势变化的方式。由于应用了**分段回归**来构建趋势模型，趋势线并不是完全直线。当考虑*分段线性模型*时，你可以把它看作是多个线性回归线段（在显著变化点之间），然后将这些线段连接起来。这使得模型能够灵活地捕捉到趋势中的**非线性**变化，并进行未来预测。
- en: Prophet also includes **cross-validation** capabilities to better evaluate how
    well the model performs in forecasting future data. Cross-validation is used to
    ensure that the model generalizes well to unseen data and is not overfitting or
    underfitting. Additionally, cross-validation can help you determine how far into
    the future the forecasts remain reliable.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Prophet还包含**交叉验证**功能，以更好地评估模型在预测未来数据时的表现。交叉验证用于确保模型能够很好地泛化到未见过的数据，而不是出现过拟合或欠拟合的情况。此外，交叉验证还可以帮助你确定预测结果在多长时间内仍然可靠。
- en: Prophet provides the `cross_validation` and `performance_metrics` functions,
    which allow you to split the data into training and testing sets across multiple
    horizons. This method helps evaluate the model's accuracy by making predictions
    at different points in time and comparing them to the actual value.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Prophet提供了`cross_validation`和`performance_metrics`函数，允许你将数据拆分成训练集和测试集，并跨多个时段进行验证。这种方法通过在不同时间点进行预测并与实际值进行比较，帮助评估模型的准确性。
- en: Here is how to implement cross-validation in Prophet.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在Prophet中实现交叉验证的方法。
- en: '[PRE20]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In the preceding code, we specified the following parameters:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们指定了以下参数：
- en: '`initial`: The size of the initial training period. In our code, we specified
    730 days, which is roughly 2 years, or 24-months for our Monthly Milk Production
    data.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`initial`：初始训练期的大小。在我们的代码中，我们指定了730天，大约是2年，或者是24个月，用于我们的月度牛奶生产数据。'
- en: '`period`: The spacing between cutoff points for making forecasts. In this example,
    we specified 180 days (roughly 6 months). This means after the initial training,
    Prophet will step forward in increments of 6 months.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`period`：进行预测时切分点之间的间隔。在这个例子中，我们指定了180天（大约6个月）。这意味着在初始训练后，Prophet会按6个月的增量向前推进。'
- en: '`horizon`: The forecast horizon (how far into the future you are predicting).
    In this example, we specified 365 days or 1-year. This means Prophet will forecast
    for the next 12 months (1 year) ahead of each cutoff point.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`horizon`：预测的时间跨度（预测未来的时间长度）。在这个例子中，我们指定了365天或1年。这意味着Prophet将在每个切分点之后的12个月（1年）内进行预测。'
- en: After running the cross-validation, you can evaluate the model's performance
    using `performance_metrics` function.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行交叉验证之后，你可以使用`performance_metrics`函数评估模型的表现。
- en: '[PRE21]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The function computes several metrics such as **Mean Absolute Error** (MAE),
    **Root Mean Squared Error** (RMSE), among many others.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数计算多个指标，如**平均绝对误差**（MAE）、**均方根误差**（RMSE）等。
- en: 'You can visualize the performance of the cross-validated forecasts using the
    `plot_cross_validation_metric` function:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`plot_cross_validation_metric`函数来可视化交叉验证预测的表现：
- en: '[PRE22]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This should plot the RMSE over the different forecast horizons.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会绘制不同预测时段的RMSE。
- en: '![Figure 11.10 – plot showing the model’s RMSE over different forecast horizon](img/file251.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.10 – 显示模型在不同预测期的 RMSE 曲线](img/file251.png)'
- en: Figure 11.10 – plot showing the model’s RMSE over different forecast horizon
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.10 – 显示模型在不同预测期的 RMSE 曲线
- en: Interpreting the plot indicates that the models is better at short forecast
    horizons as RMSE is relatively low. As the forecast horizons increase, the RMSE
    seems to generally increase. Generally, we expect these models to perform better,
    with lower errors, at short-term forecasts (1-3 months).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 对图形的解释表明，该模型在短期预测期内表现较好，因为 RMSE 相对较低。随着预测期的增加，RMSE 似乎普遍增加。通常，我们期望这些模型在短期预测（1-3
    个月）内表现更好，误差更小。
- en: See also
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 另请参见
- en: 'Prophet supports both Python and R. For more information on the Python API,
    please visit the following documentation: [https://facebook.github.io/prophet/docs/quick_start.html#python-api](https://facebook.github.io/prophet/docs/quick_start.html#python-api).'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Prophet 支持 Python 和 R。有关 Python API 的更多信息，请访问以下文档：[https://facebook.github.io/prophet/docs/quick_start.html#python-api](https://facebook.github.io/prophet/docs/quick_start.html#python-api)。
- en: If you are interested in reading the original paper behind the Prophet algorithm,
    which is publicly available, go to [https://peerj.com/preprints/3190/](https://peerj.com/preprints/3190/).
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你有兴趣阅读关于 Prophet 算法的原始论文，可以通过此链接访问：[https://peerj.com/preprints/3190/](https://peerj.com/preprints/3190/)。
- en: Cross-validation can also be used for fine-tuning hyperparameters of the model.
    You can learn more about this here [https://facebook.github.io/prophet/docs/diagnostics.html#hyperparameter-tuning](https://facebook.github.io/prophet/docs/diagnostics.html#hyperparameter-tuning)
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交叉验证也可以用于微调模型的超参数。你可以在这里了解更多：[https://facebook.github.io/prophet/docs/diagnostics.html#hyperparameter-tuning](https://facebook.github.io/prophet/docs/diagnostics.html#hyperparameter-tuning)
- en: So far, you have been working with univariate time series. The following recipe
    will teach you how to work with multivariate time series.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你一直在处理单变量时间序列。接下来的章节将教你如何处理多元时间序列。
- en: Forecasting multivariate time series data using VAR
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 VAR 预测多元时间序列数据
- en: In this recipe, you will explore the **Vector Autoregressive** (**VAR**) model
    for working with multivariate time series. In *Chapter 10*, *Building Univariate
    Time Series Models Using Statistical Methods,* we discussed AR, MA, ARIMA, and
    SARIMA as examples of univariate one-directional models. VAR, on the other hand,
    is **bi-directional** and **multivariate**.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章节中，你将探索用于处理多元时间序列的**向量自回归**（**VAR**）模型。在*第 10 章*，《使用统计方法构建单变量时间序列模型》中，我们讨论了
    AR、MA、ARIMA 和 SARIMA 作为单变量单向模型的示例。而 VAR 则是**双向**且**多元**的。
- en: VAR VERSUS AR MODELS
  id: totrans-131
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: VAR 与 AR 模型的比较
- en: ''
  id: totrans-132
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: You can think of a VAR of order p, or **VAR(p)**, as a generalization of the
    univariate AR(p) made for working with multiple time series. Multiple time series
    are represented as a vector, hence the name vector autoregression. A VAR of lag
    one (1) can be written as VAR(1) across two or more variables.
  id: totrans-133
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你可以将阶数为 p 的 VAR，或称**VAR(p)**，视为单变量 AR(p) 的一种推广，用于处理多个时间序列。多个时间序列被表示为一个向量，因此命名为向量自回归。滞后为一（1）的
    VAR 可以表示为 VAR(1)，涉及两个或更多变量。
- en: There are other forms of multivariate time series models, including **Vector
    Moving Average** (**VMA**), **Vector Autoregressive Moving Average** (**VARMA**),
    and **Vector Autoregressive Integrated Moving Average** (**VARIMA**), that generalize
    other univariate models. In practice, you will find that VAR is used the most
    due to its simplicity. VAR models are very popular in economics, but you will
    find them used in other areas, such as social sciences, natural sciences, and
    engineering.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他形式的多元时间序列模型，包括**向量移动平均**（**VMA**）、**向量自回归移动平均**（**VARMA**）和**向量自回归积分移动平均**（**VARIMA**），它们是对其他单变量模型的推广。在实践中，你会发现由于其简单性，VAR
    使用得最多。VAR 模型在经济学中非常流行，但你也会在其他领域看到它的应用，如社会科学、自然科学和工程学。
- en: The premise behind multivariate time series is that you can add more power to
    your forecast when leveraging multiple time series (or input variables) instead
    of a single time series (single variable). Simply put, VAR is used when you have
    two or more time series that have (or are assumed to have) an influence on each
    other's behavior. These are normally referred to as **endogenous** variables and
    the relationship is bi-directional. If the variables or time series are not directly
    related, or we do not know if there is a direct influence within the same system,
    we refer to them as **exogenous** variables.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 多变量时间序列的前提是，当利用多个时间序列（或输入变量）而不是单一时间序列（单一变量）时，可以增强预测的能力。简而言之，当你有两个或更多的时间序列，并且它们彼此间有（或假设有）相互影响时，VAR就可以被使用。这些通常被称为**内生**变量，其关系是双向的。如果变量或时间序列之间没有直接关系，或者我们不知道它们是否存在直接的影响，则称其为**外生**变量。
- en: EXOGENOUS VERSUS ENDOGENOUS VARIABLES
  id: totrans-136
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 外生与内生变量
- en: ''
  id: totrans-137
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: When you start researching more about VAR models, you will come across references
    to **endogenous** and **exogenous** variables. At a high level, the two are the
    opposite of each other and in `statsmodels`, you will see them referenced as `endog`
    and `exog`, respectively.
  id: totrans-138
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当你开始深入研究VAR模型时，你会遇到关于**内生**和**外生**变量的引用。从宏观角度来看，这两者是相互对立的，在`statsmodels`中，它们分别被称为`endog`和`exog`。
- en: ''
  id: totrans-139
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**Endogenous** variables are influenced by other variables within the system.
    In other words, we expect that a change in one''s state affects the other. Sometimes,
    these can be referred to as dependent variables in machine learning literature.
    You can use the **Granger causality tests** to determine if there is such a relationship
    between multiple endogenous variables. For example, in `statsmodels`, you can
    use `grangercausalitytests`.'
  id: totrans-140
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**内生**变量受到系统内其他变量的影响。换句话说，我们预期一个状态的变化会影响其他状态。有时，这些变量在机器学习文献中被称为依赖变量。你可以使用**Granger因果检验**来确定多个内生变量之间是否存在这种关系。例如，在`statsmodels`中，你可以使用`grangercausalitytests`。'
- en: ''
  id: totrans-141
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: On the other hand, **exogenous** variables are outside the system and do not
    have a direct influence on the variables. They are external influencers. Sometimes,
    these can be referred to as independent variables in machine learning literature.
  id: totrans-142
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 另一方面，**外生**变量位于系统外部，并且不直接影响其他变量。它们是外部影响因素。有时，这些变量在机器学习文献中被称为独立变量。
- en: A VAR model, like an AR model, assumes the **stationarity** of the time series
    variables. This means that each endogenous variable (time series) needs to be
    stationary.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于AR模型，VAR模型假设时间序列变量的**平稳性**。这意味着每个内生变量（时间序列）需要是平稳的。
- en: To illustrate how VAR works and the mathematical equation behind it, let's start
    with a simple VAR(1) with **two** (2) endogenous variables, referred to as (![](img/file252.png)).
    Recall from *Chapter 10*, *Building Univariate Time Series Models Using Statistical
    Methods*, that an AR(1) model would take the following form:![](img/file253.png)
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明VAR是如何工作的以及背后的数学公式，我们从一个简单的VAR(1)模型开始，该模型包含**两个**（2）内生变量，表示为(![](img/file252.png))。回顾一下*第10章*，*使用统计方法构建单变量时间序列模型*，AR(1)模型的形式如下：![](img/file253.png)
- en: 'Generally, an AR(p) model is a linear model of past values of itself and the
    (p) parameter tells us how far back we should go. Now, assume you have **two**
    AR(1) models for two different time series data. This will look as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，AR(p)模型是自我过去值的线性模型，其中(p)参数告诉我们应该追溯多远。现在，假设你有**两个**AR(1)模型，分别对应两个不同的时间序列数据。其形式如下：
- en: '![](img/file254.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](img/file254.jpg)'
- en: 'However, these are two separate models that do not show any relationship or
    that influence each other. If we create a **linear combination** of the two models
    (the past values of itself and the past values of the other time series), we would
    get the following formula:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这两个模型是独立的，没有展示出任何相互关系或相互影响。如果我们创建这两个模型的**线性组合**（即自身过去值和另一个时间序列的过去值），我们将得到以下公式：
- en: '![Figure 11.11 – Formula for a VAR model with lag one or VAR(1)](img/file255.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图11.11 – 带滞后一期的VAR模型公式，或VAR(1)](img/file255.jpg)'
- en: Figure 11.11 – Formula for a VAR model with lag one or VAR(1)
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.11 – 带滞后一期的VAR模型公式，或VAR(1)
- en: The preceding equation may seem complex, but in the end, like an AR model, it
    is still simply a linear function of past lags. In other words, in a VAR(1) model,
    you will have a linear function of lag (1) for each variable. When fitting a VAR
    model, as you shall see in this recipe, the **Ordinary Least Squares** (**OLS**)
    method is used for each equation to estimate the VAR model.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 上述方程看起来可能很复杂，但最终，像 AR 模型一样，它仍然只是过去滞后值的线性函数。换句话说，在 VAR(1) 模型中，每个变量都将有一个滞后(1)的线性函数。当拟合
    VAR 模型时，正如你将在本食谱中看到的那样，使用**最小二乘法**(**OLS**)方法来估计每个方程的 VAR 模型。
- en: Getting ready
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 准备开始
- en: For this recipe, you will be using you will use the `pandas_datareader` library
    to download data from FRED (Federal Reserve Economic Data). The files are also
    available for you to download from the GitHub repo of this book.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，你将使用 `pandas_datareader` 库从 FRED（联邦储备经济数据）下载数据。相关文件也可以从本书的 GitHub 仓库下载。
- en: 'To install using **conda**:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**conda**安装：
- en: '[PRE23]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'To install using **pip**:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**pip**安装：
- en: '[PRE24]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: How to do it…
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何操作……
- en: In this recipe, you will use the `FredReader()` function from the `pandas_datareader`
    library to pull two different time series datasets. As mentioned on FRED's website,
    the first symbol, `FEDFUNDS`, is the **Federal Funds Effective Rate**, which *"is
    the interest rate at which depository institutions trade federal funds (balances
    held at Federal Reserve Banks) with each other overnight*." Simply put, the federal
    funds effective rate influences the cost of borrowing. It is *the target interest
    rate set by the Federal Open Market Committee (FOMC) for what banks can charge
    other institutions for lending excess cash from their reserve balances.* The second
    symbol is `unrate` for the **Unemployment Rate**, which is the percentage of the
    total labor force that is unemployed but actively seeking employment or willing
    to work.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，你将使用 `pandas_datareader` 库中的 `FredReader()` 函数来提取两个不同的时间序列数据集。正如 FRED
    网站上所提到的，第一个符号 `FEDFUNDS` 是**联邦基金有效利率**，它*“是存款机构之间互相过夜交易联邦基金（存放在联邦储备银行的余额）的利率”*。简单来说，联邦基金有效利率影响借贷成本。它是*由联邦公开市场委员会（FOMC）设定的目标利率，用于确定银行向其他机构收取的利率，特别是借出其储备余额中的多余现金的利率。*
    第二个符号是 `unrate`，代表**失业率**，它是指总劳动人口中正在积极寻找工作或愿意工作的失业人员的比例。
- en: CITATIONS
  id: totrans-159
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 引用
- en: ''
  id: totrans-160
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Board of Governors of the Federal Reserve System (US)*, *Federal Funds Effective
    Rate [FEDFUNDS]*, retrieved from FRED, Federal Reserve Bank of St. Louis; https://fred.stlouisfed.org/series/FEDFUNDS,
    October 6, 2024.'
  id: totrans-161
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*美国联邦储备系统理事会*，*联邦基金有效利率 [FEDFUNDS]*，来自 FRED，圣路易斯联邦储备银行； https://fred.stlouisfed.org/series/FEDFUNDS，2024年10月6日。'
- en: ''
  id: totrans-162
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*U.S. Bureau of Labor Statistics*, *Unemployment Rate [UNRATE]*, retrieved
    from FRED, Federal Reserve Bank of St. Louis; https://fred.stlouisfed.org/series/UNRATE,
    October 6, 2024.'
  id: totrans-163
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*美国劳动统计局*，*失业率 [UNRATE]*，来自 FRED，圣路易斯联邦储备银行； https://fred.stlouisfed.org/series/UNRATE，2024年10月6日。'
- en: 'Follow these steps:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤进行：
- en: 'Start by loading the necessary libraries and pulling the data. Note that both
    `FEDFUNDS` and `unrate` are reported monthly:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始时加载必要的库并提取数据。注意，`FEDFUNDS` 和 `unrate` 都是按月报告的：
- en: '[PRE25]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Pull the data using `FredReader`, which wraps over the FRED API and returns
    a pandas DataFrame. For the `FEDFUNDS` and `unrate` symbols, you will pull close
    to 34 years'' worth of data (417 months):'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `FredReader` 提取数据，`FredReader` 封装了 FRED API，并返回一个 pandas DataFrame。对于 `FEDFUNDS`
    和 `unrate` 符号，你将提取大约 34 年的数据（417 个月）：
- en: '[PRE26]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Store the DataFrame as a `pickle` object, as shown in the last line of the preceding
    code. This way, you do not have make an API call to rerun the example. You can
    read the `economic_df.pickle` file using `economic_df = pd.read_pickle(file)`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据框存储为 `pickle` 对象，如前面的代码最后一行所示。这样，你就不需要再次调用 API 来重新运行示例。你可以使用 `economic_df
    = pd.read_pickle(file)` 读取 `economic_df.pickle` 文件。
- en: 'Inspect the data and make sure there are no null values:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查数据，确保没有空值：
- en: '[PRE27]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Change the DataFrame''s frequency to month start (`MS`) to reflect how the
    data is being stored:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将数据框的频率更改为月初（`MS`），以反映数据存储的方式：
- en: '[PRE28]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Plot the datasets for visual inspection and understanding:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制数据集进行可视化检查和理解：
- en: '[PRE29]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Since `subplots` is set to `True`, this will produce two subplots for each
    column:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `subplots` 设置为 `True`，这将为每一列生成两个子图：
- en: '![Figure 11.12 – Plotting both Federal Funds Effective Rate and Unemployment
    Rate](img/file256.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.12 – 绘制联邦基金有效利率和失业率](img/file256.png)'
- en: Figure 11.12 – Plotting both Federal Funds Effective Rate and Unemployment Rate
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.12 – 绘制联邦基金有效利率和失业率
- en: 'There is some sort of inverse relationship between `FEDFUND` and `unrate` –
    as `FEDFUNDS` increases, `unrate` decreases. There is interesting anomalous behavior
    starting in 2020 due to the COVID-19 pandemic. We can further check the correlation
    between the variables:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`FEDFUND`和`unrate`之间存在某种反向关系——随着`FEDFUNDS`的增加，`unrate`减少。从2020年开始，由于COVID-19疫情，出现了有趣的异常行为。我们可以进一步检查这两个变量之间的相关性：'
- en: '[PRE30]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The correlation between `FEDFUNDS` and `unrate` is -0.435 indicating a moderate
    negative relationship (inverse correlation). This suggest that as federal funds
    rate increases, the unemployment rate tends to decrease, and vice versa.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`FEDFUNDS`和`unrate`之间的相关系数为-0.435，表明存在中等强度的负相关关系（反向相关）。这表明，随着联邦基金利率的上升，失业率趋向下降，反之亦然。'
- en: Further you can perform a **Cross-Correlation Function** (CCF) between `FEDFUNDS`
    and `unrate` to see the correlation at different lags. The CFF helps identity
    lagged relationships or temporal dependencies between the two time series. The
    outcome mainly tells us whether one series leads or lags the other. It does not
    a formal test of causality, which you will investigate later.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步，你可以执行**互相关函数**（CCF）分析`FEDFUNDS`和`unrate`之间不同滞后的相关性。CCF有助于识别两个时间序列之间的滞后关系或时间依赖性。结果主要告诉我们一个系列是否领先或滞后于另一个系列。这并不是一个正式的因果性检验，你将在后续步骤中进行更深入的调查。
- en: '[PRE31]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '![Figure 11.13 – Cross-Correlation Function plot for 12 months ahead and 12
    months behind for better interpretability](img/file257.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.13 – 前后12个月的互相关函数图，便于更好的解释](img/file257.png)'
- en: Figure 11.13 – Cross-Correlation Function plot for 12 months ahead and 12 months
    behind for better interpretability
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.13 – 前后12个月的互相关函数图，便于更好的解释
- en: The plot shows spikes that extend beyond the shaded confidence interval which
    indicates significant negative correlation. This suggests that changes in `FEDFUNDS`
    might be associate with opposite changes in `unrate` within the same frame
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图中显示了超出阴影置信区间的尖峰，这表明存在显著的负相关。这暗示着`FEDFUNDS`的变化可能与`unrate`的相反变化有关，且这些变化发生在同一时段内。
- en: 'An important assumption in VAR is **stationarity**. Both variables (the two
    endogenous time series) need to be stationary. Create a `check_stationarity()`
    function, which returns the stationarity results from the **Augmented Dickey-Fuller**
    (`adfuller`) test:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: VAR模型中的一个重要假设是**平稳性**。两个变量（这两个内生时间序列）需要是平稳的。创建一个`check_stationarity()`函数，该函数返回**扩展型迪基-富勒**（`adfuller`）检验的平稳性结果：
- en: '[PRE32]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Use the `check_stationarity` function to evaluate each endogenous variable
    (column):'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`check_stationarity`函数评估每个内生变量（列）：
- en: '[PRE33]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Overall, both time series are shown to be stationary.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，这两个时间序列被证明是平稳的。
- en: 'Plot both **ACF** and **PACF** plots to gain an intuition over each variable
    and which process they belong to – for example, an AR or MA process:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制**ACF**和**PACF**图，以便对每个变量及其所属的过程（例如AR或MA过程）获得直观理解：
- en: '[PRE34]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This should produce an ACF and PACF for `FEDFUNDS` and `unrate`:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该生成`FEDFUNDS`和`unrate`的ACF和PACF：
- en: '![Figure 11.11 – ACF and PACF plots for FEDFUNDS and unrate](img/file258.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.11 – `FEDFUNDS`和`unrate`的ACF和PACF图](img/file258.png)'
- en: Figure 11.11 – ACF and PACF plots for FEDFUNDS and unrate
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.11 – `FEDFUNDS`和`unrate`的ACF和PACF图
- en: The ACF and PACF plots for `FEDFUNDS` and `unrate` indicate we are dealing with
    an **autoregressive** (**AR**) process. The ACF plots show a slow gradual decay,
    while the PACF plots show a sharp cutoff after lag 1\. The PACF for `FEDFUNDS`
    shows slightly significant (above or below the shaded area) lags at 2 and 3, while
    the PACF for `unrate` shows some significance at lag 24\. We can ignore those
    for now.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`FEDFUNDS`和`unrate`的ACF和PACF图表明我们正在处理一个**自回归**（**AR**）过程。ACF图显示出逐渐缓慢衰减，而PACF图则显示出在滞后1之后的急剧截断。`FEDFUNDS`的PACF图在滞后2和滞后3时显示出略微显著的（超出阴影区域）滞后，而`unrate`的PACF图在滞后24时显示出一定的显著性。我们可以暂时忽略这些。'
- en: 'Split the data into train and test sets:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将数据分为训练集和测试集：
- en: '[PRE35]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: You can scale the data (**standardization**), even though it is not necessary
    for VAR, and the two time series are not far off in terms of scale. In this step,
    you will perform scaling for *illustrative purposes* to show how it can be done
    and how you inversely transform the results for interpretation later on.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以对数据进行缩放（**标准化**），尽管VAR模型并不要求标准化，且这两个时间序列的规模差异不大。在这一步中，你将进行缩放操作，*仅用于演示目的*，以展示如何进行此操作，并如何在后续步骤中反向转换结果以便进行解释。
- en: There is often a debate on whether the variables need to be scaled (standardized)
    when implementing VAR. However, the VAR algorithm does not inherently require
    the variables to be scaled, as it is **scale-invariant**. In practice, it is common
    to leave variables in their original units to **preserver the interpretability**
    of the coefficients and residuals in meaningful terms (e.g., percentage points).
    However, if the variables differ significantly in scale, then standardization
    can be applied to make the **coefficients easier to compare** and detect **outliers**
    more effectively.
  id: totrans-201
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在实现VAR时，是否需要对变量进行标准化（缩放）常常存在争议。然而，VAR算法本身并不要求变量必须进行标准化，因为它是**与规模无关的**。在实践中，通常保持变量的原始单位，以**保留系数和残差的可解释性**，这样可以用有意义的术语（例如百分比点）来解释。然而，如果变量在规模上差异显著，则可以应用标准化，以便**更容易比较系数**并更有效地检测**异常值**。
- en: ''
  id: totrans-202
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: If you choose to standardize (for example, using `StandardScalar` from **Scikit-Learn**),
    it is important to note that the results will be in terms of **standard deviations.**
    You can use the `inverse_transform` method to revert the data back to its original
    units when interpreting the results. This is useful when you need to explain the
    findings in the context of the original variable scale.
  id: totrans-203
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你选择标准化（例如，使用**Scikit-Learn**中的`StandardScalar`），需要注意，结果将以**标准差**为单位。你可以使用`inverse_transform`方法将数据还原到其原始单位，以便在解释结果时使用。这对于需要在原始变量规模的上下文中解释结果时非常有用。
- en: 'Scale the data using `StandardScalar` by fitting the train set using the `fit`
    method. Then, apply the scaling transformation to both the **train** and **test**
    sets using the `transform` method. The transformation will return a NumPy `ndarray`,
    which you will then return as pandas DataFrames. This will make it easier for
    you to plot and examine the DataFrames further:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`StandardScalar`对数据进行缩放，通过`fit`方法拟合训练集。然后，使用`transform`方法对**训练集**和**测试集**应用缩放变换。变换将返回一个NumPy
    `ndarray`，然后你可以将其作为pandas DataFrame返回。这样，你可以更方便地绘制图形并进一步检查DataFrame：
- en: '[PRE36]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'But how can you determine the optimal **lag order** **p** for your VAR model?
    Luckily, the VAR implementation in `statsmodels` will pick the best VAR order.
    You only need to define the maximum number of lags (threshold); the model will
    determine the best `p` values that minimize each of the four information criteria
    scores: **AIC**, **BIC**, **FPE**, and **HQIC**. The `select_order` method will
    compute the scores at each lag order, while the `summary` method will display
    the scores for each lag. The results will help when you train (`fit`) the model
    to specify which information criteria the algorithm should use:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 那么，如何确定VAR模型的最优**滞后期数**（**p**）呢？幸运的是，`statsmodels`中的VAR实现会自动选择最佳的VAR滞后期数。你只需要定义滞后的最大数量（阈值）；模型将确定最小化每个四种信息准则得分的最佳`p`值：**AIC**、**BIC**、**FPE**和**HQIC**。`select_order`方法会计算每个滞后期数的得分，而`summary`方法会显示每个滞后的得分。这些结果将有助于在训练（`fit`）模型时指定算法应使用哪些信息准则：
- en: '[PRE37]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This should show the results for all `10` lags. The lowest scores are marked
    with an `*`:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该显示所有`10`个滞后的结果。最低的得分会用`*`标记：
- en: '[PRE38]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `res` object is an instance of the `LagOrderResults` class. You can print
    the selected lag number for each information criterion using the `selected_orders`
    attribute, which return a dictionary of the **optimal lag orders** for **AIC**,
    **BIC**, **FPE**, and **HQIC**:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`res`对象是`LagOrderResults`类的一个实例。你可以使用`selected_orders`属性打印每个信息准则的选定滞后期数，该属性返回**最优滞后期数**的字典，包括**AIC**、**BIC**、**FPE**和**HQIC**：'
- en: '[PRE39]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: At lag 7, both *AIC* and *FPE* scores were the lowest. On the other hand, both
    *BIC* and *HQ* scores were the lowest at lag 3, suggesting a more parsimonious
    model with fewer lags.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在滞后期7时，*AIC*和*FPE*得分最低。另一方面，*BIC*和*HQ*得分在滞后期3时最低，表明该模型可能更简洁，滞后期数较少。
- en: Generally, *BIC* and *HQIC* tend to favor more **parsimonious** models (i.e.,
    models with fewer lags) because they impose higher penalty on model complexity.
    In contrats, *AIC* and *FPE* tend to be more lenient and may suggest higher lag
    orders since they are less strict in penalizing for complexity.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，*BIC*和*HQIC*倾向于偏好更**简洁的**模型（即滞后期数较少的模型），因为它们对模型复杂度施加更高的惩罚。相反，*AIC*和*FPE*则较为宽松，可能建议使用更高的滞后期数，因为它们对复杂度的惩罚较少。
- en: In this case, **lag 3** seems like a safer choice, helping to aim for simplicity
    and avoiding overfitting. However, choosing **lag 7** would result in a more complex
    model that might capture more dynamics in the data, but it comes with a higher
    risk of overfitting.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，**滞后 3**似乎是更安全的选择，旨在追求简洁性并避免过拟合。然而，选择**滞后 7**将会得到一个更复杂的模型，可能捕捉到数据中的更多动态，但也带有更高的过拟合风险。
- en: To train the model, you must use the *BIC* score (or another criterion of your
    choice). You experiment with a different information criterion by updating the
    `ic` parameter. The `maxlags` parameter is optional –if you leave it blank, the
    model will automatically determine the optimal lag order based on the selected
    information criterion, which in this case is `'bic'`.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要训练模型，必须使用*BIC*分数（或其他你选择的标准）。你可以通过更新`ic`参数来尝试不同的信息准则。`maxlags`参数是可选的——如果你留空，模型会根据所选信息准则自动确定最优滞后阶数，在此案例中为`'bic'`。
- en: '[PRE40]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This will automatically select the lag order that minimizes the BIC score (i.e.
    lag 3). You can experiment with other criteria, such as AIC, by setting `ic='aic'`.
    If you prefer to manually specify the maximum number of lags, you can use the
    `maxlags` parameter. Keep in mind if both `maxlags` and `ic` are used then `ic`
    will take precedence.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这将自动选择最小化 BIC 分数的滞后阶数（即滞后 3）。你可以通过设置`ic='aic'`来尝试其他标准，如 AIC。如果你更倾向于手动指定最大滞后阶数，可以使用`maxlags`参数。请记住，如果同时使用了`maxlags`和`ic`，则`ic`将优先考虑。
- en: Running `results.summary()` will print a detailed summary, including the regression
    results for each autoregressive process.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`results.summary()`将打印详细的总结，包括每个自回归过程的回归结果。
- en: The summary includes information on the **number of equations** (corresponding
    to the number of variables), the **information criteria** (AIC, BIC, HQIC, and
    FPE), and other details like **log likelihood**. These metrics help assess the
    overall fit and complexity of the model.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 总结中包括了**方程数量**（对应变量的数量）、**信息准则**（AIC、BIC、HQIC 和 FPE）及其他细节，如**对数似然**。这些指标有助于评估模型的整体拟合度和复杂度。
- en: '[PRE41]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: At the end of the summary, there is **correlation matrix** of residuals. The
    matrix show the correlations between the residuals (Errors) from each equation
    in the VAR model. Ideally, you want these off-diagonal values to be as close to
    **zero** as possible. A low correlation suggests that the model has captured most
    of the relationship between the variables, and there is little leftover correlation
    in the residuals.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在总结的最后，有**残差相关矩阵**。该矩阵显示了每个方程中残差（误差）之间的相关性。理想情况下，你希望这些非对角线值尽可能接近**零**。较低的相关性表明模型已经捕捉到了大部分变量之间的关系，且残差中剩余的相关性较小。
- en: '[PRE42]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The correlation between the residuals for `FEDFUNDS` and `unrate` is `-0.1159`,
    which is relatively small, indicating that the model has done a good job capturing
    the relationship between the two variables.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`FEDFUNDS`和`unrate`之间的残差相关性为`-0.1159`，相对较小，表明模型很好地捕捉到了这两个变量之间的关系。'
- en: 'Store the VAR lag order using the `k_ar` attribute so that we can use it later
    when we use the forecast method:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`k_ar`属性存储 VAR 滞后阶数，以便在以后使用预测方法时能再次使用：
- en: '[PRE43]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This shows that the optimal lag order selected was 3.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示选择的最优滞后阶数为 3。
- en: 'Finally, you can forecast using either the `forecast` or `forecast_interval`
    method. The latter will return the forecast, as well as the **upper** and **lower
    confidence intervals**. Both methods will require past values and the number of
    steps ahead to forecast. The prior values (`past_y`) will be used as the initial
    values for the forecast:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以使用`forecast`或`forecast_interval`方法进行预测。后者将返回预测值，以及**上**和**下置信区间**。这两种方法都需要过去的值和预测的步数。先前的值（`past_y`）将作为预测的初始值：
- en: '[PRE44]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Since you applied `StandardScalar` on the dataset, the forecast values are
    scaled. You will need to apply `inverse_transform` to convert them back to the
    original scale of the data. You can also convert the forecasts and confidence
    interval into pandas DataFrames for convenience:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于你对数据集应用了`StandardScalar`，预测值已被缩放。你需要应用`inverse_transform`将它们转换回原始数据的尺度。你还可以将预测和置信区间转换为
    pandas DataFrame，方便使用：
- en: '[PRE45]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Plot the actual versus forecasted `unrate` with the confidence intervals:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制实际值与预测值`unrate`及其置信区间：
- en: '[PRE46]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This should plot the actual test data, the forecast (middle dashed line) for
    `unrate`, along with the upper and lower confidence intervals:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该绘制实际的测试数据，`unrate` 的预测（中间虚线），以及上下置信区间：
- en: '![Figure 11.12 – Plotting the forecast with confidence intervals for unrate](img/file259.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.12 – 绘制带有置信区间的 unrate 预测](img/file259.png)'
- en: Figure 11.12 – Plotting the forecast with confidence intervals for unrate
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.12 – 绘制带有置信区间的 unrate 预测
- en: 'In a VAR model, all variables are forecasted simultaneously because the model
    assumes that past values of all variables in the system contribute to the future
    values of each variable. So, even though you may only be interested in predicting
    `unrate` from `FEDFUNDS`, the model forecasts the future values of `FEDFUNDS`
    based on `unrate`. You can visualize the forecast for `FEDFUNDS` in a similar
    way as you did for `unrate` as shown:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在 VAR 模型中，所有变量都同时进行预测，因为该模型假设系统中所有变量的过去值都会对每个变量的未来值产生影响。因此，即使你只关心预测 `unrate`
    来自 `FEDFUNDS`，该模型也会基于 `unrate` 预测 `FEDFUNDS` 的未来值。你可以像绘制 `unrate` 的预测一样，绘制 `FEDFUNDS`
    的预测，如下所示：
- en: '[PRE47]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '![Figure 11.13 – Plotting the forecast with confidence intervals for FEDFUNDS](img/file260.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.13 – 绘制带有置信区间的 FEDFUNDS 预测](img/file260.png)'
- en: Figure 11.13 – Plotting the forecast with confidence intervals for FEDFUNDS
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.13 – 绘制带有置信区间的 FEDFUNDS 预测
- en: Recall that the training data was set up until the end of 2022, which includes
    the significant economic disruption caused by COVID-19 in 2020\. Thus, the model’s
    predictions may not perform as well as expected due to the large and sudden shifts
    in the data.
  id: totrans-240
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 请记住，训练数据是设置到 2022 年底的，包括 2020 年 COVID-19 导致的重大经济冲击。因此，由于数据的巨大且突然而来的变化，模型的预测可能无法如预期般表现。
- en: ''
  id: totrans-241
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: You may need to adjust the train-test split to accommodate this fact and perform
    different experiments with the model. When dealing with major anomalies like COVID-19,
    it is essential to assess whether the event is a **one-time anomaly** whose effects
    will fade or whether it represents a lasting change that requires special handling
    in your model.
  id: totrans-242
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你可能需要调整训练-测试划分来适应这一事实，并对模型进行不同的实验。当处理像 COVID-19 这样的重要异常时，必须评估事件是**一次性异常**，其影响将逐渐消退，还是它代表了一种持久的变化，需要在模型中进行特殊处理。
- en: ''
  id: totrans-243
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'This is where **domain knowledge** becomes crucial: understanding the economic
    context will help you decide whether to model such events or treat them as outliers
    that shouldn’t influence future predictions.'
  id: totrans-244
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在这里，**领域知识**变得至关重要：理解经济背景将帮助你决定是否将此类事件建模，或将其视为不应影响未来预测的异常值。
- en: How it works…
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Vector autoregressive models (VAR) are very useful, especially in **econometrics**.
    When evaluating the performance of a VAR model, it is common to report to report
    results from several important analysis, such as **Granger causality tests**,
    residual (or error) analysis, and **impulse response analysis**. These are critical
    for understanding the interactions between variables. You will explore these in
    the next recipe, *Evaluating vector autoregressive (VAR) models*.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 向量自回归模型（VAR）在**计量经济学**中非常有用。在评估 VAR 模型的性能时，通常会报告几个重要的分析结果，例如**Granger 因果关系检验**、残差（或误差）分析和**冲击响应分析**。这些对理解变量之间的相互作用至关重要。你将在下一个章节中探索这些内容，*评估向量自回归（VAR）模型*。
- en: In *Figure 11.11*, a VAR(1) model for two variables results in two equations.
    Each equation models the current value of one variables as a function of its own
    lagged values and the lagged values of the other variable. The matrix notation
    shows **four coefficients** and **two constants**. Each equation has two **coefficients**
    for the lagged values of both variables (e.g. and for and and for ). The **constants**
    and represent the intercepts for each equation.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图 11.11*中，两个变量的 VAR(1) 模型产生了两个方程。每个方程将一个变量的当前值建模为其自身滞后值和另一个变量滞后值的函数。矩阵符号显示了**四个系数**和**两个常数**。每个方程有两个**系数**，分别用于两个变量的滞后值（例如，对于和对于）。**常数**和代表每个方程的截距。
- en: In this recipe, the model selected was a VAR(3) model for two variables. The
    key difference between a VAR(1) and a VAR(3) is the increased complexity due to
    additional lagged terms. In VAR(3) model, you will have **twelve coefficients**
    (three lags per variable) and **two constants** to solve for. Each equation is
    estimated using **OLS**, as shown in the `results.summary()` output.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，选择的模型是针对两个变量的VAR(3)模型。VAR(1)和VAR(3)之间的主要区别在于由于附加滞后项，复杂性有所增加。在VAR(3)模型中，你将需要求解**十二个系数**（每个变量三个滞后期）和**两个常数**。每个方程都是使用**OLS**估计的，如`results.summary()`输出所示。
- en: The two functions represented in *Figure 11.11* for VAR(1) show how each variables
    is influence not only by its own past values but also the past values of the second
    (endogenous) variable. This is a key difference between a VAR model and an AR
    model (which only considers a variable’s own lags). A VAR model captures the dynamic
    interaction between multiple variables over time.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11.11*中表示的两个函数显示了VAR(1)中每个变量不仅受到自身过去值的影响，还受到第二个（内生）变量的过去值的影响。这是VAR模型和AR模型（仅考虑变量自身滞后）的一个关键区别。VAR模型捕捉了多个变量之间随时间变化的动态交互。'
- en: In the next recipe, now that the model is fitted, you will spend time plotting
    VAR-specific outputs – for example, the **impulse responses (IRs)** and the **forecast
    error variance decomposition (FEVD)** – to better understand these interactions
    and how the variables influence each other.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个配方中，既然模型已经拟合完成，你将花时间绘制VAR特定的输出——例如，**脉冲响应（IRs）**和**预测误差方差分解（FEVD）**——以更好地理解这些相互作用以及变量之间的影响。
- en: In this recipe we focused on using the model for **forecasting**; next, we will
    focus on understanding the **causal relationships**, using tools like Granger
    causality tests, and evaluating the overall performance of the model through additional
    diagnostics.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，我们专注于使用模型进行**预测**；接下来，我们将专注于理解**因果关系**，使用Granger因果关系检验等工具，并通过额外的诊断评估模型的整体性能。
- en: VARIMA (Vector ARIMA) models extend VAR to handle non-stationary data by incorporating
    **differencing**. We didn't use it here because both time series were stationary,
    so differencing wasn’t needed. Consider VARIMA when dealing with multiple non-stationary
    variables that require differencing to achieve stationarity.
  id: totrans-252
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: VARIMA（向量ARIMA）模型扩展了VAR，用于通过加入**差分**来处理非平稳数据。我们在这里没有使用它，因为两个时间序列都是平稳的，所以不需要差分。在处理多个需要差分以实现平稳的非平稳变量时，可以考虑使用VARIMA。
- en: There's more…
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 还有更多……
- en: Since we are focusing on comparing forecasting results, it would be interesting
    to see if our VAR(3) model, with two endogenous variables, performs better than
    a univariate AR(3) model. Comparing multivariate VAR(3) model to a simpler AR(3)
    (or ARIMA(3,0,0)) model will help assess whether the inclusion of the second variables
    (`FEDFUNDS`) improves the forecast for `unrate`.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们关注的是比较预测结果，观察包含两个内生变量的VAR(3)模型是否比单变量AR(3)模型表现更好是很有趣的。将多元VAR(3)模型与更简单的AR(3)（或ARIMA(3,0,0)）模型进行比较有助于评估第二个变量（`FEDFUNDS`）的加入是否改善了对`unrate`的预测。
- en: You can try fitting an AR(3) or ARIMA(3,0,0) model to the **unrate** time series,
    using the same lag values for consistency. Since that the `unrate` series is stationary,
    there is no need for differencing. Recall, from the previous activity that `lag_order`
    is equal to 3.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以尝试为**unrate**时间序列拟合AR(3)或ARIMA(3,0,0)模型，并使用相同的滞后值以保持一致性。由于`unrate`序列是平稳的，因此无需进行差分。回想一下，从之前的活动中，`lag_order`等于3。
- en: '[PRE48]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'You can review the ARIMA model''s summary using `model.summary()`. After fitting
    the model, you can evaluate the residuals by plotting diagnostic charts to check
    for any issues with the model’s fit:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`model.summary()`查看ARIMA模型的摘要。拟合模型后，你可以通过绘制诊断图表来评估残差，以检查模型拟合是否存在问题：
- en: '[PRE49]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This should produce four diagnostic subplots:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成四个诊断子图：
- en: '![Figure 11.14 –Output of AR(3) or ARIMA(3, 0, 0) model diagnostic plots](img/file261.png)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![图11.14 – AR(3)或ARIMA(3,0,0)模型诊断图输出](img/file261.png)'
- en: Figure 11.14 –Output of AR(3) or ARIMA(3, 0, 0) model diagnostic plots
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.14 – AR(3)或ARIMA(3,0,0)模型诊断图输出
- en: The Standardized residual plot shows a significant spike around 2020, likely
    due to the economic impact of COVID-19\. There are also some deviations from normality
    based on the Q-Q plots suggesting the model may not full capture the tail behavior
    of the data. Overall, the AR model captured the necessary information based on
    the autocorrelation plot.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 标准化残差图显示在2020年左右出现显著峰值，这可能是由于COVID-19的经济影响。根据Q-Q图，还可以观察到一些偏离正态分布的迹象，表明该模型可能未完全捕捉数据尾部行为。总体而言，AR模型根据自相关图捕捉到了必要的信息。
- en: 'Now, forecast future streps using the AR(3) model and compare it to the VAR(3)
    model, which we already fitted and applied `inverse_transform` to:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用AR(3)模型预测未来步骤，并将其与我们已经拟合并应用了`inverse_transform`的VAR(3)模型进行比较：
- en: '[PRE50]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'This should produce the following plot:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会生成以下图表：
- en: '![Figure 11.15 – AR(3) forecast versus actual comparison against test](img/file262.png)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![图11.15 – AR(3)预测与实际结果对比（测试集）](img/file262.png)'
- en: Figure 11.15 – AR(3) forecast versus actual comparison against test
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.15 – AR(3)预测与实际结果对比（测试集）
- en: 'The same plot can be done for the VAR(3) model, which includes the impact of
    `FEDFUNDS` on `unrate`:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的图表也可以为VAR(3)模型绘制，该模型考虑了`FEDFUNDS`对`unrate`的影响：
- en: '[PRE51]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This should produce the following plot:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会生成以下图表：
- en: '![Figure 11.16 – VAR(3) forecast versus actual comparison against test](img/file263.png)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![图11.16 – VAR(3)预测与实际结果对比（测试集）](img/file263.png)'
- en: Figure 11.16 – VAR(3) forecast versus actual comparison against test
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.16 – VAR(3)预测与实际结果对比（测试集）
- en: 'Finally, let’s calculate the **root-mean-square error** (**RMSE**) scores for
    both models (VAR and AR) to see which one performs better on the test data:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将计算**均方根误差**（**RMSE**）得分，以比较两个模型（VAR和AR）在测试数据上的表现：
- en: '[PRE52]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The AR(3) model has a lower RMSE compared to the VAR(3) model, indicating that
    the simpler AR(3) model, which only considers the past values of `unrate`, actually
    performs better in this case. The VAR(3) model, which incorporates both `unrate`
    and `FEDFUNDS`, doesn’t significantly improve the forecast for `unrate`.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: AR(3)模型相较于VAR(3)模型具有更低的RMSE，表明仅考虑`unrate`过去值的简单AR(3)模型在此案例中表现更佳。包含`unrate`和`FEDFUNDS`的VAR(3)模型并未显著提高`unrate`的预测精度。
- en: Given the results, an AR(3) model might be preferred due to its lower complexity
    and better forecasting accuracy. However, when there are stronger interactions
    between the variables, a VAR model can provide **additional insights** and more
    accurate forecasts.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 根据结果，可能更倾向于选择AR(3)模型，因为其复杂度较低且预测精度较高。然而，当变量之间存在更强的相互作用时，VAR模型可以提供**额外的洞察力**和更精确的预测。
- en: See also...
  id: totrans-277
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 另见...
- en: To learn more about the VAR class in statsmodels, please visit the official
    documentation at [https://www.statsmodels.org/dev/generated/statsmodels.tsa.vector_ar.var_model.VAR.html](https://www.statsmodels.org/dev/generated/statsmodels.tsa.vector_ar.var_model.VAR.html).
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解有关statsmodels中VAR类的更多信息，请访问官方文档：[https://www.statsmodels.org/dev/generated/statsmodels.tsa.vector_ar.var_model.VAR.html](https://www.statsmodels.org/dev/generated/statsmodels.tsa.vector_ar.var_model.VAR.html)。
- en: Evaluating vector autoregressive (VAR) models
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 评估向量自回归（VAR）模型
- en: After fitting a VAR model, the next step is to evaluate how well the model captures
    the interactions and dynamic relationships between the different endogenous variables
    (multiple time series). Understanding these relationships can help you asses causality,
    how one variable influences another, and how shocks to one variable propagate
    through the system.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在拟合VAR模型之后，下一步是评估模型如何捕捉不同内生变量（多个时间序列）之间的相互作用和动态关系。了解这些关系有助于您评估因果关系，变量如何相互影响，以及一个变量的冲击如何在系统中传播。
- en: In this recipe, you will continue where you left off from the previous recipe,
    *Forecasting multivariate time series data* using *VAR*, and explore various diagnostic
    tools to deepen your understanding of the VAR model. Specifically, test for granger
    causality, analyze **Residual Autocorrelation Function** (**ACF**) plots, use
    the **Impulse Response Function** (**IRF**), and perform **Forecast Error Variance
    Decomposition** (**FEVD**).
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，您将继续上一个配方《*多元时间序列数据预测*》中使用*VAR*的内容，并探索各种诊断工具以加深您对VAR模型的理解。具体来说，测试格兰杰因果关系，分析**残差自相关函数**（**ACF**）图，使用**脉冲响应函数**（**IRF**）以及进行**预测误差方差分解**（**FEVD**）。
- en: These evaluation steps will help you understand both the **causal relationships**
    and the **interdependencies** between the variables in your system, ensuring that
    your model captures the underlying dynamics correctly.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这些评估步骤将帮助你理解系统中变量之间的**因果关系**和**相互依赖关系**，确保你的模型正确捕捉到潜在的动态。
- en: How to do it...
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The following steps continue from the previous recipe. If you have not performed
    those steps, you can run the code from the accompanying **Jupyter Notebook** to
    follow along. You will focus on diagnosing the VAR(3) model that was created in
    the earlier recipe:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤接着上一个步骤进行。如果你没有执行过这些步骤，可以运行附带的**Jupyter Notebook**中的代码来继续进行。你将专注于诊断之前创建的VAR(3)模型：
- en: First, perform a Granger causality test to determine if one time series can
    be used to predict another. In this case, you want to find out if `FEDFUNDS` can
    be used to predict `unrate`.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，进行格兰杰因果关系检验，以确定一个时间序列是否可以用来预测另一个。在本例中，你需要找出`FEDFUNDS`是否可以用来预测`unrate`。
- en: Based on the previous recipe, you have already selected **3 lags** using the
    **BIC** criterion. However, you can adjust the lag order and test for higher lags
    if needed, depending on the nature of your data or specific research question.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 根据之前的步骤，你已经使用**BIC**准则选择了**3个滞后期**。然而，你可以根据数据的特性或具体的研究问题，调整滞后期的顺序，并在需要时测试更高的滞后期。
- en: '**Granger causality tests** are implemented in `statsmodels` with the `grangercausalitytests()`
    function, which performs **four tests** across each past lag. You can control
    this using the `maxlag` parameter. Granger causality tests are used to determine
    if past values from one variable influence the other variable.'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**格兰杰因果关系检验**在`statsmodels`中通过`grangercausalitytests()`函数实现，该函数在每个过去的滞后期上执行**四项检验**。你可以通过`maxlag`参数控制滞后期的数量。格兰杰因果关系检验用于确定一个变量的过去值是否影响另一个变量。'
- en: 'The **null hypothesis** in the Granger causality test is that the second variable
    (in this case `FEDFUNDS`) does not granger cause the first variable (in this case,
    `unrate`). In other words, it assumes there is no **statistical significance**
    *in terms of influence or effect*. To test if `FEDFUNDS` influences `unrate`,
    you will need to switch the order of the columns before applying the test:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 格兰杰因果关系检验中的**原假设**是第二个变量（在本例中为`FEDFUNDS`）不对第一个变量（在本例中为`unrate`）产生格兰杰因果关系。换句话说，假设在**影响或效应**方面没有**统计学意义**。要测试`FEDFUNDS`是否影响`unrate`，你需要在应用检验之前交换列的顺序：
- en: '[PRE53]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The test is set for a maximum of 3 lags, based on the BIC criterion selected
    earlier. The output will show the *test statistics*, *p-values*, *and degrees
    of freedom* for each lag. Focus on the **p-value** to decide whether to reject
    or accept the null hypothesis.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 根据之前选择的BIC准则，测试的最大滞后期设为3。输出将显示每个滞后期的*检验统计量*、*p值*和*自由度*。重点关注**p值**，以决定是否拒绝或接受原假设。
- en: '[PRE54]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Since the p-values for lags 2 and 3 are less than 0.05, this suggests that `FEDFUNDS`
    does **Granger-cause** `unrate`. In other words, past values of `FEDFUNDS` provide
    significant predictive power for `unrate` when considering a lag of 2 or 3 months.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 由于滞后期2和3的p值都小于0.05，这表明`FEDFUNDS`对`unrate`有**格兰杰因果关系**。换句话说，考虑到2个月或3个月的滞后期时，`FEDFUNDS`的过去值对`unrate`具有显著的预测能力。
- en: 'Next, you will explore the residual plots. The `results` object from the previous
    recipe `results = model.fit(ic=''bic'')`, is of the `VARResultsWrapper` type,
    which is the same as the `VARResults` class and has access to the same methods
    and attributes. Start with the **ACF** plot of the residuals using the `plot_acorr`
    method:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，你将探讨残差图。之前步骤中的`results`对象`results = model.fit(ic='bic')`是`VARResultsWrapper`类型，与`VARResults`类相同，拥有相同的方法和属性。首先使用`plot_acorr`方法绘制残差的**ACF**图：
- en: '[PRE55]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'This should produce four plots (2x2 plots – two for each variable) for **autocorrelation**
    and **cross-correlation** between the residuals. Recall from *Figure 11.11* that
    for two variables, you will have two functions, and this translates into 2x2 residual
    subplots. If you had three variables, you would have a 3x3 subplot:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成四个图（2x2图——每个变量各两个）来展示残差的**自相关**和**交叉相关**。回忆*图11.11*，对于两个变量，你将有两个函数，这将转化为2x2的残差子图。如果有三个变量，则会有一个3x3的子图：
- en: '![Figure 11.17 – Residual autocorrelation and cross-correlation plots](img/file264.png)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
  zh: '![图11.17 – 残差自相关和交叉相关图](img/file264.png)'
- en: Figure 11.17 – Residual autocorrelation and cross-correlation plots
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.17 – 残差自相关和交叉相关图
- en: Unfortunately, the plots in *Figure 11.17* do not have proper labels. The first
    row of plots corresponds to the first variable in the DataFrame (`FEDFUNDS`),
    and the second row corresponds to the second variable in the DataFrame (`unrate`).
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，*图 11.17*中的图表没有正确的标签。第一行的图表对应数据框架中的第一个变量（`FEDFUNDS`），第二行对应第二个变量（`unrate`）。
- en: You are looking for no significant autocorrelation in the residuals which is
    the case in *Figure 11.17*. This would confirm that the VAR(3) model has effectively
    captured the dynamic relationships between the variables (`FEDFUNDS` and `unrate`),
    with no leftover patterns in the residual that the model failed to capture and
    account for.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要观察残差中没有显著的自相关性，这在*图 11.17*中是成立的。这将确认VAR(3)模型已经有效捕捉了变量之间的动态关系（`FEDFUNDS` 和
    `unrate`），并且残差中没有模型未能捕捉和考虑的剩余模式。
- en: 'If you want a mode tailed look at the residuals for each variable separately,
    you can do so by extracting the residuals using the `resid` attribute. This would
    return a DataFrame of the residuals for each variable. You can use the standard
    `plot_acf` function to create your ACF plots:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你希望单独查看每个变量的残差，你可以通过提取`resid`属性来实现。这将返回一个每个变量残差的DataFrame。你可以使用标准的`plot_acf`函数来创建自相关函数（ACF）图：
- en: '[PRE56]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This should produce two ACF plots – one for `FEDFUNDS` and another for `unrate`.
    This will confirm the same finding – that there is no significant autocorrelation
    in the residuals.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成两个ACF图——一个用于`FEDFUNDS`，另一个用于`unrate`。这将确认相同的发现——即残差中没有显著的自相关性。
- en: Next, you will move to the **Impulse Response Function (IRF)** analysis. The
    IRF helps you visualize and understand how shocks to one variable affect another
    variable (or itself) over time, which is crucial for assessing the dynamic interactions
    between the variables in a VAR model.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，你将进行**脉冲响应函数（IRF）**分析。IRF帮助你可视化并理解一个变量的冲击如何随时间影响另一个变量（或其自身），这对于评估VAR模型中变量之间的动态相互作用至关重要。
- en: 'You will analyze the impulse response to shocks in the system using the `irf`
    method:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用`irf`方法分析系统对冲击的响应：
- en: '[PRE57]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The `irf_output` object is of the `IRAnalysis` type and has access to a `plot()`
    function:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '`irf_output`对象是`IRAnalysis`类型，可以访问`plot()`函数：'
- en: '![Figure 11.18 – Impulse response showing the effect of one unit change in
    one variable against another](img/file265.png)'
  id: totrans-307
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.18 – 显示一个变量的单位变化对另一个变量的冲击响应](img/file265.png)'
- en: Figure 11.18 – Impulse response showing the effect of one unit change in one
    variable against another
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.18 – 显示一个变量的单位变化对另一个变量的冲击响应
- en: The **Impulse Response Function (IRF)** analysis computes the dynamic impulse
    responses and the approximated standard errors, and displays the effect of a shock
    (or impulse) in one variable and the response in the other variables over time
    (lags). In a **VAR model**, all the variables influence each other, and the IRF
    traces the effect of a change in one variable and its influence on the other variables
    over time.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '**脉冲响应函数（IRF）**分析计算动态脉冲响应和近似标准误差，并显示一个变量的冲击（或脉冲）对其他变量随时间（滞后）变化的影响。在**VAR模型**中，所有变量相互影响，IRF追踪一个变量变化对其他变量随时间的影响。'
- en: For example, the plot **FEDFUNDS → unrate** (bottom left in *Figure 11.18*)
    shows
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，**FEDFUNDS → unrate**（位于*图 11.18*的左下角）显示了
- en: how `unrate` responds to a one-unit increase in `FEDFUNDS` across the 10 lags.
    Immediately, there is noticeable **sharp negative response** in `unrate`, indicating
    that an increase in federal funds rate lowers the unemployment rate. The effect
    persists but gradually diminishes over time, which is consistent with how monetary
    policy impacts employment in the economy. We see this effect from *lag 2* to *lag
    3*, where these is a period of **stabilization**. The response levels off a bit,
    this is where the **delayed effect** becomes visible; as the initial drop occurs
    quickly, the total adjustment takes longer as `unrate` remains below the starting
    point. After *lag 3*, we see a slight upward movement in `unrate` and this gradual
    adjustment suggests that the `unrate` starts to recover slowly but does not yet
    fully return to its pre-shock level for several periods.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '`unrate`如何对`FEDFUNDS`增加一个单位在10个滞后期中的反应。立刻可以观察到`unrate`有明显的**急剧负响应**，这表明联邦基金利率的提高会降低失业率。该效应持续存在，但随着时间的推移逐渐减弱，这与货币政策如何影响经济中的就业一致。从*滞后期
    2* 到 *滞后期 3*，我们可以看到有一个**稳定期**，响应水平有所平稳，这就是**滞后效应**开始显现的地方；初始下降发生得很快，但总的调整需要更长时间，因为`unrate`仍然低于起始点。在*滞后期
    3* 之后，我们看到`unrate`略微上升，这种逐步调整表明`unrate`开始缓慢恢复，但在若干期内仍未完全回到冲击前的水平。'
- en: On the other hand, the **unrate → FEDFUNDS** (top right in *Figure 11.18*) shows
    a relatively small and slightly positive response. This suggests that an increase
    in unemployment (`unrate`) leads to a slight rise in `FEDFUNDS`, but the effect
    diminishes over time.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，**unrate → FEDFUNDS**（*图 11.18* 的右上角）显示了一个相对较小且略微正向的响应。这表明失业率（`unrate`）的提高会导致`FEDFUNDS`略微上升，但该效应会随着时间的推移减弱。
- en: 'If you only want to see the response of one variable to another (instead of
    all subplots), you can specify the `impulse` and a `response` variables:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只想查看一个变量对另一个变量的响应（而不是所有子图），你可以指定 `impulse` 和 `response` 变量：
- en: '[PRE58]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Plot the cumulative response effect:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制累积响应效应：
- en: '[PRE59]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '![Figure 11.19 – Plot of the Cumulative Impulse Responses Function](img/file266.png)'
  id: totrans-317
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.19 – 累积脉冲响应函数图](img/file266.png)'
- en: Figure 11.19 – Plot of the Cumulative Impulse Responses Function
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.19 – 累积脉冲响应函数图
- en: The cumulative response plot shows how the effect of a shock builds up over
    time. For example, **FEDFUNDS → unrate** plot (bottom left in *Figure 11.19*),
    you can see that the commutative effect of a one-unit increase in FEDFUNDS leads
    to a sustained decrease in `unrate` overtime. The cumulative response helps you
    assess the long-term impact of these shocks.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 累积响应图展示了冲击效果如何随着时间的推移逐渐累积。例如，**FEDFUNDS → unrate** 图（*图 11.19* 的左下角），你可以看到FEDFUNDS增加一个单位对`unrate`的累积效应会导致`unrate`持续下降。累积响应有助于你评估这些冲击的长期影响。
- en: Next, you will move to **Forecast Error Variance Decomposition (FEVD**) to quantity
    how much of the **forecast error variance** of each variable in the system is
    attributed to shocks in itself and shocks in the other variables. In other words,
    you want to understand the contribution of shocks from each variable.
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，你将进入**预测误差方差分解（FEVD）**，以量化系统中每个变量的**预测误差方差**有多少是由自身冲击和其他变量的冲击造成的。换句话说，你需要了解每个变量冲击的贡献。
- en: 'You can compute the FEVD using the using the `fevd()` method:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `fevd()` 方法计算 FEVD：
- en: '[PRE60]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'You can explore the FEVD results using either `fv.summay()` and `fv.plot()`
    methods. Both of which provide similar information:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `fv.summay()` 和 `fv.plot()` 方法探索 FEVD 结果。它们提供相似的信息：
- en: '[PRE61]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: This will produce two FEVD plot (Figure 11.20) one for each variable.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成两个 FEVD 图（图 11.20），每个变量一个。
- en: '![Figure 11.20 – FEVD plot for the FEDFUNDS and unrate variables](img/file267.png)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.20 – FEDFUNDS 和 unrate 变量的 FEVD 图](img/file267.png)'
- en: Figure 11.20 – FEVD plot for the FEDFUNDS and unrate variables
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.20 – FEDFUNDS 和 unrate 变量的 FEVD 图
- en: The x-axis represents the number of periods (lags) from 0 to 9, and the y-axis
    represents the percentage (0 to 100%) that each shock contributed to the forecast
    error variance Visually, the contribution of each shock is represented as a portion
    of the total bar for every period.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: x轴表示从0到9的时期（滞后期），y轴表示每个冲击对预测误差方差的贡献百分比（0到100%）。从视觉上看，每个冲击的贡献在每个时期的总条形中占据一定部分。
- en: The **FEDFUNDS plot** (top) shows that the entire forecast error variance in
    `FEDFUNDS` is explained by its own shocks. This means that shocks to `unrate`
    have no impact on the forecast error variance of `FEDFUNDS`.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '**FEDFUNDS图**（顶部）显示，`FEDFUNDS`的整个预测误差方差由其自身的冲击解释。这意味着`unrate`的冲击对`FEDFUNDS`的预测误差方差没有影响。'
- en: On the other hand, the **unrate plot** (bottom) starts off by showing that the
    forecast error variance of `unrate` is mostly explained by its own shocks. However,
    starting from *lag 4*, the contribution from `FEDFUNDS` begins to grow. By *lag
    9*, roughly around 30% of the variance in `unrate` can be said to be driven by
    shocks from `FEDFUNDS`. This suggest that, over longer time horizons, `FEDFUNDS`
    becomes a more significant driver to `unrate’s` forecast error variance.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，**失业率图**（底部）开始时显示，`unrate`的预测误差方差主要由其自身的冲击解释。然而，从*滞后4期*开始，`FEDFUNDS`的贡献开始增大。到*滞后9期*时，大约30%的`unrate`方差可以归因于`FEDFUNDS`的冲击。这表明，在较长的时间范围内，`FEDFUNDS`成为`unrate`预测误差方差的更重要驱动因素。
- en: How it works...
  id: totrans-331
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: The VAR implementation from statsmodels offers several tools to help you understand
    the dynamic relationships between the different time series (or endogenous variables).
    This includes methods like Granger causality tests, Impulse Response Functions
    (IRFs), and Forecast Error Variance Decomposition (FEVD). Each of these tools
    gives you a different perspective on how variables in the system interact over
    time, whether through causal links or how shocks to one variable influence others.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 来自statsmodels的VAR实现提供了多个工具，帮助你理解不同时间序列（或内生变量）之间的动态关系。这包括格兰杰因果检验、脉冲响应函数（IRFs）和预测误差方差分解（FEVD）等方法。这些工具为你提供了不同的视角，帮助你理解系统中变量如何随时间互动，不论是通过因果关系还是一个变量的冲击如何影响其他变量。
- en: In addition to understanding relationships, diagnostic tools (such as residual
    analysis and autocorrelation plots) are provided to help you assess model fit
    and determine whether any adjustments (like model order, differencing, or additional
    variables) are necessary.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 除了理解变量之间的关系外，还提供了诊断工具（如残差分析和自相关图），帮助你评估模型拟合度，并判断是否需要进行调整（如模型阶数、差分或增加变量）。
- en: There's more...
  id: totrans-334
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 还有更多……
- en: Earlier, in the *Forecasting multivariate time series data using VAR* recipe,
    you manually created a forecast plot. However, the `results` object (an instance
    of the `VARResults` class) offers a convenient way for you to plot your forecasts
    quickly using the `plot_forecast` method. This function automatically generates
    a forecast along with confidence intervals.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的*使用VAR预测多元时间序列数据*示例中，你手动创建了预测图。然而，`results`对象（即`VARResults`类的实例）提供了一种便捷的方式，使用`plot_forecast`方法可以快速绘制你的预测图。此函数会自动生成预测值及其置信区间。
- en: '[PRE62]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Here, `n` is the number of future steps. This should produce two subplots,
    with one forecast for each variable, as shown in the following diagram:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`n`是未来的步数。这个操作应该会生成两个子图，每个变量都有一个预测图，如下图所示：
- en: '![Figure 11.21 – Forecast plots for FEDFUNDS and unrate](img/file268.png)'
  id: totrans-338
  prefs: []
  type: TYPE_IMG
  zh: '![图11.21 – FEDFUNDS和失业率的预测图](img/file268.png)'
- en: Figure 11.21 – Forecast plots for FEDFUNDS and unrate
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.21 – FEDFUNDS和失业率的预测图
- en: See also…
  id: totrans-340
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 另见…
- en: To learn more about the `VARResults` class and all the available methods and
    attributes, visit the official documentation at [https://www.statsmodels.org/dev/generated/statsmodels.tsa.vector_ar.var_model.VARResults.html](https://www.statsmodels.org/dev/generated/statsmodels.tsa.vector_ar.var_model.VARResults.html).
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于`VARResults`类及其所有可用方法和属性的信息，请访问官方文档：[https://www.statsmodels.org/dev/generated/statsmodels.tsa.vector_ar.var_model.VARResults.html](https://www.statsmodels.org/dev/generated/statsmodels.tsa.vector_ar.var_model.VARResults.html)。
- en: Forecasting volatility in financial time series data with GARCH
  id: totrans-342
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用GARCH模型预测金融时间序列数据的波动性
- en: When working with financial time series data, a common task is measuring **volatility**,
    which represents uncertainty in future returns. Generally, volatility measures
    the spread of the probability distribution of returns over a specific period,
    often calculated as the **variance** or **standard deviation** (which is the square
    root of variance). It is used as a proxy for quantifying **risk** or **uncertainty**.
    In other words, it measures the dispersion of financial asset returns around an
    expected value. Higher volatility indicates higher risks. This helps investors
    understand the level of return they can expect and how often their returns will
    differ from the expected value.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理金融时间序列数据时，一个常见的任务是衡量**波动性**，它代表了未来回报的不确定性。一般来说，波动性衡量的是在特定时期内回报的概率分布范围，通常通过**方差**或**标准差**（即方差的平方根）来计算。它被用作量化**风险**或**不确定性**的代理指标。换句话说，它衡量了金融资产回报围绕预期值的分散程度。更高的波动性意味着更高的风险。这有助于投资者理解他们能期望的回报水平，以及回报与预期值之间的差异频率。
- en: Most of the models we discussed previously (e.g., ARIMA, SARIMA, and Prophet)
    focused on forecasting an observed variable based on its past values. However,
    these models assume a constant variance (**homoskedasticity**) and do not account
    for changes in variance over time (**heteroskedasticity**).
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前讨论的大多数模型（如ARIMA、SARIMA和Prophet）都专注于基于过去的值预测观察到的变量。然而，这些模型假设方差是恒定的（**同方差性**），并没有考虑方差随时间的变化（**异方差性**）。
- en: 'In this recipe, you will work with a different kind of forecasting: forecasting
    and modeling changes in variance over time. This is known as volatility. In general,
    volatility is an important measure of risk when there is uncertainty and it is
    an important concept when working with financial data.'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，你将处理另一种类型的预测：预测和建模方差随时间变化的情况。这就是所谓的波动性。一般而言，当存在不确定性时，波动性是衡量风险的一个重要指标，也是处理金融数据时的一个重要概念。
- en: To achieve this, you will be introduced to a new family of algorithms related
    to **Autoregressive Conditional Heteroskedasticity (ARCH)**. The ARCH model captures
    change in variance over time, modeled as a function of squared error terms (*innovations*)
    from past time points. An extension of ARCH is the **GARCH** model, which stands
    for **Generalized Autoregressive Conditional Heteroskedasticity**. It extends
    ARCH by adding a moving average component to account for past variances, providing
    a more flexible and persistent volatility structure.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，你将接触到一类与**自回归条件异方差（ARCH）**相关的新算法。ARCH模型捕捉了方差随时间的变化，它将变化建模为来自过去时间点的平方误差项（*创新*）的函数。ARCH的扩展是**GARCH**模型，代表**广义自回归条件异方差**。它通过增加一个移动平均成分来考虑过去的方差，从而提供了一个更灵活、更持久的波动性结构。
- en: GARCH is popular in econometrics and is widely used by financial institutes
    for assessing investments and market risks. Predicting turbulence and volatility
    is just as important as forecasting future prices, and many trading strategies
    -such as **mean reversion**- utilize volatility as a key factor.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: GARCH在计量经济学中很受欢迎，金融机构广泛使用它来评估投资和市场风险。预测市场动荡和波动性与预测未来价格同样重要，许多交易策略——例如**均值回归**——都将波动性作为一个关键因素。
- en: 'Before moving forward, let''s break down the components of a general ARCH model:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，让我们分解一下一个典型ARCH模型的组成部分：
- en: '**Autoregressive**- a concept we explored in *Chapter 10*, *Building Univariate
    Time Series Models Using Statistical Methods*, means that the current value of
    a variable is influenced by its past values. In ARCH models this means that current
    volatility (*variance*) is influence by past values of the squared error terms
    (*innovations*).'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自回归** - 这是我们在*第10章*，*使用统计方法构建单变量时间序列模型*中探讨过的一个概念，意味着变量的当前值受到其过去值的影响。在ARCH模型中，这意味着当前的波动性（*方差*）受过去的平方误差项（*创新*）的影响。'
- en: '**Heteroskedasticity-** means that the model may have different magnitudes
    or variability at different time points (variance changes over time).'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**异方差性** - 意味着模型在不同的时间点可能具有不同的幅度或波动性（方差随时间变化）。'
- en: '**Conditional**- since the variance (volatility) is not fixed, it depends on
    past information. In other words, the variance at a given time point is conditionally
    dependent on past values from the series, meaning that volatility is updated as
    new information becomes available.'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**条件性** - 由于方差（波动性）不是固定的，它依赖于过去的信息。换句话说，在某一时点的方差条件性地依赖于该序列中过去的值，意味着随着新信息的到来，波动性会被更新。'
- en: In this recipe, you will create a **GARCH model** of order (**p, q**), where
    **p** represents the number of lagged **variances** (the **GARCH term**), and
    **q** represents the number of lagged **squared residuals** (the **ARCH term**).
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，您将创建一个**GARCH模型**，其阶数为（**p, q**），其中**p**表示滞后**方差**的数量（**GARCH项**），**q**表示滞后**平方残差**的数量（**ARCH项**）。
- en: 'Using the `arch` Python library, you will implement this with the `arch_model`
    function. The parameters in this function can be broken down into three main components
    based on the GARCH model''s assumptions:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`arch` Python库，您将通过`arch_model`函数实现这一点。该函数中的参数可以根据GARCH模型的假设分为三个主要组件：
- en: '`dist` : Controls the distribution assumption for the innovations (residuals)
    and defaults to `''normal''`'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dist` ：控制创新项（残差）的分布假设，默认为 `''normal''`。'
- en: '`mean` : Controls the model for the conditional mean and defaults to `''Constant''`,
    whichassumes a constant mean'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mean` ：控制条件均值的模型，默认为`''Constant''`，即假设均值为常数。'
- en: '`vol` : Controls the volatility model (conditional variance) and defaults to
    `''GARCH''`'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vol` ：控制波动率模型（条件方差），默认为`''GARCH''`。'
- en: In most literature, **q** typically represents the **ARCH order** (the number
    of lagged squared residuals or innovations), while **p** represents the **GARCH
    order** (the number of lagged variances). However, in the `arch` Python library,
    the roles of **p** and **q** are **reversed**.
  id: totrans-357
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在大多数文献中，**q**通常表示**ARCH阶数**（滞后平方残差或创新项的数量），而**p**表示**GARCH阶数**（滞后方差的数量）。然而，在`arch`
    Python库中，**p**和**q**的角色是**颠倒**的。
- en: ''
  id: totrans-358
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In the `arch` package, **p** refers to the lag order of the **squared residuals**
    (the **ARCH** component), and **q** refers to the lag order of the **lagged variances**
    (the **GARCH** component).
  id: totrans-359
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在`arch`包中，**p**表示**平方残差**（**ARCH**组件）的滞后阶数，而**q**表示**滞后方差**（**GARCH**组件）的滞后阶数。
- en: ''
  id: totrans-360
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This distinction is important to keep in mind when specifying and interpreting
    GARCH models using the `arch` library, as it differs from the conventional notation
    used in the academic literature.
  id: totrans-361
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这个区别在使用`arch`库指定和解释GARCH模型时非常重要，因为它与学术文献中使用的常规符号有所不同。
- en: ''
  id: totrans-362
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: For example, specifying `p=2` and `q=1` in `arch_model` would actually fit a
    **GARCH(1, 2)** model according to the conventional notation (with 1 lagged variance
    and 2 lagged residuals)
  id: totrans-363
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 例如，在`arch_model`中指定`p=2`和`q=1`，实际上会根据常规符号拟合一个**GARCH(1, 2)**模型（包含1个滞后方差和2个滞后残差）。
- en: Getting ready
  id: totrans-364
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, you will be using the `arch` library, which contains several
    volatility models, as well as financial econometrics tools. The library produces
    similar output to those from the statsmodels library. At the time of writing,
    the latest version is `7.1.0`.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，您将使用`arch`库，它包含了多个波动率模型以及金融计量经济学工具。该库的输出与statsmodels库的输出类似。撰写本文时，最新版本为`7.1.0`。
- en: 'To install `arch` using **pip**, use the following command:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**pip**安装`arch`，请使用以下命令：
- en: '[PRE63]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'To install `arch` using **conda**, use the following command:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**conda**安装`arch`，请使用以下命令：
- en: '[PRE64]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: How to do it…
  id: totrans-370
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'When using the `arch_model` function from the `arch` library to build the **GARCH**
    model, there are a few key parameters: the default **distribution** is *normal*
    (`dist=''normal''`), the **mean** model is constant (`mean=''Constant''`), and
    the **volatility model** is GARCH (`vol=''GARCH''` by default). Other mean models,
    such as autoregressive models (`''AR''`) can also be specified depending on the
    context. Similarly, other volatility models can be selected such `''GARCH''`,
    `''ARCH''`, `''EGARCH''`, `''FIGARCH''`, and `''APARCH''`. You can also select
    different distributions such as ''`gaussian''`, `''t''`, `''studentst''`, `''skewstudent''.`'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`arch`库中的`arch_model`函数构建**GARCH**模型时，有几个关键参数：默认的**分布**是*normal*（`dist='normal'`），**均值**模型是常数（`mean='Constant'`），**波动率模型**是GARCH（默认`vol='GARCH'`）。根据上下文，您还可以指定其他均值模型，如自回归模型（`'AR'`）。同样，您也可以选择其他波动率模型，如`'GARCH'`、`'ARCH'`、`'EGARCH'`、`'FIGARCH'`和`'APARCH'`。您还可以选择不同的分布，如`'gaussian'`、`'t'`、`'studentst'`、`'skewstudent'`。
- en: 'You will be using the **Microsoft** daily closing price dataset for this recipe.
    Follow these steps:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 本例中，您将使用**微软**的日收盘价数据集。请按照以下步骤进行：
- en: 'Start by loading the necessary libraries for this recipe:'
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先加载本例所需的库：
- en: '[PRE65]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Load the `MSFT.csv` dataset:'
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载`MSFT.csv`数据集：
- en: '[PRE66]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: You will need to convert the daily stock price into a **daily stock return.**
    This can be calculated as where is the price at time and is the price from the
    previous day. This can be done easily in pandas using the `DataFrame.pct_change()`
    function, followed by multiplying by 100to express returns as **percentages**.
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你需要将每日股价转换为**每日股价收益**。这可以通过计算当前时间的价格与前一天的价格之间的比例来完成。在 pandas 中可以使用 `DataFrame.pct_change()`
    函数，之后乘以 100 将收益表示为**百分比**。
- en: 'The `pct_change()` function takes a `periods` parameter that defaults to `1`.
    If you want to calculate a 30-day return, then you will need change that value
    to `pct_change(periods=30)`:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '`pct_change()` 函数接受一个 `periods` 参数，默认值为 `1`。如果你想计算 30 天的收益率，那么你需要将该值改为 `pct_change(periods=30)`：'
- en: '[PRE67]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The `dropna` step is necessary because calculating `returns` will produce `NaN`
    for the first row.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '`dropna` 步骤是必要的，因为计算 `returns` 会对第一行产生 `NaN`。'
- en: 'You can plot both the daily stock price and daily return:'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以同时绘制每日股价和每日收益：
- en: '[PRE68]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'This will produce the following plot:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下图表：
- en: '![Figure 11.22 – Microsoft daily closing price and daily returns](img/file269.png)'
  id: totrans-384
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.22 – 微软每日收盘价和日收益](img/file269.png)'
- en: Figure 11.22 – Microsoft daily closing price and daily returns
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.22 – 微软每日收盘价和日收益
- en: Split the data into train and test. For short-term volatility forecasting you
    will examin how well the model predicts the next few day’s volatility. When splitting
    the data, you will leave the last 5 days for testing.
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将数据拆分为训练集和测试集。对于短期波动率预测，你将检查模型如何预测接下来几天的波动率。在拆分数据时，你将留出最后 5 天作为测试数据。
- en: '[PRE69]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Fit a **GARCH(p, q)** model. Start with the simple GARCH(1,1) model with all
    the default options – that is, `mean='Constant'`, distribution as `dist='normal'`,
    volatility as `vol='GARCH'`, `p=1`, and `q=1`. A GARCH(1,1) is the most commonly
    used model, and a good starting point, for volatility forecasting due to its simplicity
    and effectiveness in capturing volatility clusters.
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拟合一个**GARCH(p, q)** 模型。从简单的 GARCH(1,1) 模型开始，使用所有默认选项——即 `mean='Constant'`，分布为
    `dist='normal'`，波动率为 `vol='GARCH'`，`p=1`，`q=1`。GARCH(1,1) 是最常用的模型，也是波动率预测的一个很好的起点，因其简洁性和有效性在捕捉波动率集群方面表现出色。
- en: '[PRE70]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The fitting process was completed in nine (9) iterations. Using `update_freq=3`
    affects the frequency of printing the progress during the fitting process. The
    default is one (1) which means it will print out an output on each iteration.
    By setting it to three (3) we get an output every three iterations. To print the
    summary, use the `summary()` method:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 拟合过程在九次（9）迭代中完成。使用 `update_freq=3` 会影响拟合过程中打印进度的频率。默认值是 1，意味着每次迭代都会打印输出。通过设置为三（3），我们每三次迭代打印一次输出。要打印总结，使用
    `summary()` 方法：
- en: '[PRE71]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'This will produce the following output:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![Figure 11.22 – Summary of the GARCH(1,1) model](img/file270.png)'
  id: totrans-393
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.22 – GARCH(1,1) 模型的总结](img/file270.png)'
- en: Figure 11.22 – Summary of the GARCH(1,1) model
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.22 – GARCH(1,1) 模型的总结
- en: The *omega*, *alpha*, and *beta* parameters (the symbols) of the GARCH(1,1)
    model are estimated using the **Maximum Likelihood** method. The `p-value` for
    the coefficients indicates they are *statistically* *significant*.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: GARCH(1,1) 模型的*omega*、*alpha* 和 *beta* 参数（符号）是通过**最大似然**方法估计的。系数的 `p-value`
    表明它们是*统计学上* *显著*的。
- en: You can access several of the components that you see in the summary table by
    calling the appropriate attribute from the `results` object – for example, `results.pvalues`,
    `results.tvalues`, `results.std_err`, or `results.params`.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过从 `results` 对象中调用相应的属性来访问总结表中看到的几个组件——例如，`results.pvalues`，`results.tvalues`，`results.std_err`，或
    `results.params`。
- en: '[PRE72]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Next, you need to evaluate the model''s performance. Start by plotting the
    standardized residuals and conditional volatility using the `plot` method:'
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，你需要评估模型的表现。首先，使用 `plot` 方法绘制标准化残差和条件波动率：
- en: '[PRE73]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'This should produce the following plot:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该产生以下图表：
- en: '![Figure 11.23 – Model diagnostics for the GARCH(1,1) model](img/file271.png)'
  id: totrans-401
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.23 – GARCH(1,1) 模型的诊断](img/file271.png)'
- en: Figure 11.23 – Model diagnostics for the GARCH(1,1) model
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.23 – GARCH(1,1) 模型的诊断
- en: If the model is well-fitted, then the **Standardized Residuals** plot should
    look like white noise, indicating no patterns remain in the residuals. The plot
    seems to show randomness without obvious patterns indicating a good fit. The **Conditional
    Volatility** plot shows the time-varying volatility that the model has estimated,
    reflecting how volatility changes over time. You can see periods of high and low
    volatility reflecting market conditions.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 如果模型拟合良好，那么**标准化残差**图应该呈现出白噪声的样子，表明残差中没有残余模式。该图似乎表现出随机性，没有明显的模式，表明拟合良好。**条件波动率**图显示了模型估计的时间变化波动率，反映了波动率随时间变化的情况。你可以看到反映市场状况的高波动和低波动时期。
- en: 'Plot a histogram for the standardized residuals. You can obtain this using
    the `std_resid` attribute:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制标准化残差的直方图。你可以使用`std_resid`属性来获取该数据：
- en: '[PRE74]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '![Figure 11.24 – Histogram plot for the standardized residuals of the GARCH
    model](img/file272.png)'
  id: totrans-406
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.24 – GARCH模型标准化残差的直方图](img/file272.png)'
- en: Figure 11.24 – Histogram plot for the standardized residuals of the GARCH model
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.24 – GARCH模型标准化残差的直方图
- en: The histogram suggests that the standardized residuals are roughly normal, though
    you can use additional statistical tests, like the **Jarque-Bera** test, for a
    more formal assessment of normality
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 直方图表明标准化残差大致符合正态分布，尽管你可以使用额外的统计检验，如**Jarque-Bera**检验，进行更正式的正态性评估。
- en: You can further evaluate the model by testing for **autocorrelation** using
    the **Ljung-Box test**, which tests the null hypothesis of no autocorrelation.
    For the first 10 lags, use `acorr_ljungbox`. A p-value greater than 0.05 indicates
    that the null hypothesis cannot be rejected, suggesting no significant autocorrelation
    at that lag.
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你还可以通过使用**Ljung-Box检验**来测试**自相关性**，该检验检验无自相关性的原假设。在前10个滞后期中，使用`acorr_ljungbox`。p值大于0.05表示无法拒绝原假设，表明该滞后期没有显著的自相关性。
- en: '[PRE75]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The p-values from the Ljung-Box test suggest that there is no significant autocorrelation
    in the standardized residuals at most lags. Since most p-values are above 0.05,
    we fail to reject the null hypothesis of no autocorrelation, indicating a good
    model fit.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 来自Ljung-Box检验的p值表明，在大多数滞后期，标准化残差没有显著的自相关性。由于大多数p值大于0.05，我们未能拒绝无自相关性的原假设，表明模型拟合良好。
- en: 'To make a prediction, use the `forecast()` method. The default is to produce
    a one (1) step ahead forecast. To get `n` number of steps ahead, you will need
    to update the `horizon` parameter:'
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要进行预测，请使用`forecast()`方法。默认情况下，它会生成一步（1步）预测。要获取`n`步预测，你需要更新`horizon`参数：
- en: '[PRE76]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'To access the predicted future variance (or volatility), use the `variance`
    property from the `msft_forecast` object:'
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要访问预测的未来方差（或波动率），请使用`msft_forecast`对象中的`variance`属性：
- en: '[PRE77]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'You can also evaluate the predicted mean. Recall that when you fit the model,
    you specified that the mean as `Constant`. This is further validated if you examine
    the mean:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以评估预测的均值。回想一下，当你拟合模型时，你指定了均值为`Constant`。如果你检查均值，这一点将得到进一步验证：
- en: '[PRE78]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: This will print out a constant value of `0.144878` across all horizons.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在所有时间段中输出一个常数值`0.144878`。
- en: How it works…
  id: totrans-419
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 工作原理……
- en: '`GARCH(p,q)` can be written as follows:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '`GARCH(p,q)`可以写成如下形式：'
- en: '![](img/file273.jpg)Omega, alpha, and beta (![](img/file274.png)) are parameters
    here. The `p` order is commonly referred to as the GARCH order, while `q` is referred
    to as the ARCH order.'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/file273.jpg)Omega、alpha和beta（![](img/file274.png)）是此处的参数。`p`阶通常被称为GARCH阶，而`q`被称为ARCH阶。'
- en: 'The parameters for the GARCH model represent the following:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: GARCH模型的参数表示如下：
- en: '**Omega** : the constant or baseline variance'
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Omega**：常数或基准方差'
- en: '**Alpha**: The coefficient for the lagged squared residuals (*ARCH term*),
    which measures the impact of recent shocks on volatility.'
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Alpha**：滞后平方残差的系数（*ARCH项*），衡量近期冲击对波动率的影响。'
- en: '**Beta**: The coefficient for the lagged variances (*GARCH term*), representing
    the persistence of volatility over time.'
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Beta**：滞后方差的系数（*GARCH项*），表示波动率随时间的持续性。'
- en: In the `arch` Python package, the roles of **p** and **q** are swapped, with
    **p** representing the ARCH component (lagged squared residuals) and **q** representing
    the GARCH component (lagged variances).
  id: totrans-426
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在`arch` Python包中，**p**和**q**的角色被交换，**p**表示ARCH成分（滞后平方残差），**q**表示GARCH成分（滞后方差）。
- en: 'The GARCH(1,1) that you implemented can be written as follows:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 你实现的GARCH(1,1)模型可以写成如下形式：
- en: '![](img/file275.png)'
  id: totrans-428
  prefs: []
  type: TYPE_IMG
  zh: '![](img/file275.png)'
- en: INNOVATIONS VERSUS ERRORS IN TIME SERIES
  id: totrans-429
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 时间序列中的创新与误差
- en: ''
  id: totrans-430
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In time series literature, you will come across the term **innovations**, which
    refers to unexpected and unpredictable new information, shocks, or errors that
    cannot be forecasted using past information. Put simply, you can think of **innovations**
    as forecast errors or surprises at each time step. While in machine learning,
    we often refer to these as prediction errors, in time series models like ARCH/GARCH,
    we use the term **innovations** to describe the new, unanticipated information
    affecting the model.
  id: totrans-431
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在时间序列文献中，你会遇到**创新**这个术语，指的是无法通过过去的信息预测的意外和不可预测的新信息、冲击或误差。简而言之，你可以将**创新**视为每个时间步的预测误差或意外情况。虽然在机器学习中，我们通常称这些为预测误差，但在像ARCH/GARCH这样的时间序列模型中，我们使用**创新**这个术语来描述影响模型的新、出乎意料的信息。
- en: There's more...
  id: totrans-432
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Previously, when implementing the GARCH model, you set the mean to `'Constant'`.
    Now, let's explore the impact of changing the mean to `'Zero'`, which effectively
    removes the mean model from the equation.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，在实现GARCH模型时，你将均值设置为`'Constant'`。现在，让我们探讨将均值更改为`'Zero'`的影响，这实际上会将均值模型从方程中移除。
- en: Let’s start by setting `mean='Zero':`
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从设置`mean='Zero'`开始：
- en: '[PRE79]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'This should produce the GARCH summary in a tabular format:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成一个表格格式的GARCH总结：
- en: '![Figure 11.25 – GARCH(1, 1) with a zero mean](img/file276.png)'
  id: totrans-437
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.25 – 带零均值的GARCH(1, 1)](img/file276.png)'
- en: Figure 11.25 – GARCH(1, 1) with a zero mean
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.25 – 带零均值的GARCH(1, 1)
- en: Notice that in Figure 11.25, there is no mean model like the one shown in Figure
    11.21\. Using a **Zero Mean** is common when you want to separate the modeling
    of **volatility** from the **mean**. This approach can be helpful in situations
    where you are primarily interested in modeling volatility and don’t need a mean
    model for the underlying returns.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在图11.25中，没有像图11.21中那样的均值模型。使用**零均值**在你想将**波动性**建模与**均值**分开时很常见。当你主要关注建模波动性，而不需要用于基础回报的均值模型时，这种方法非常有帮助。
- en: See also
  id: totrans-440
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 另见
- en: To learn more about the `arch` library, please visit the official documentation
    at [https://arch.readthedocs.io/en/latest/univariate/introduction.html](https://arch.readthedocs.io/en/latest/univariate/introduction.html).
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于`arch`库的信息，请访问官方文档：[https://arch.readthedocs.io/en/latest/univariate/introduction.html](https://arch.readthedocs.io/en/latest/univariate/introduction.html)。
