- en: Chapter 2. Best Practices in Interactive Computing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章 交互式计算中的最佳实践
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Choosing (or not) between Python 2 and Python 3
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择（或不选择）Python 2 和 Python 3
- en: Efficient interactive computing workflows with IPython
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 IPython 进行高效的交互式计算工作流
- en: Learning the basics of the distributed version control system Git
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习分布式版本控制系统 Git 的基础
- en: A typical workflow with Git branching
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Git 分支的典型工作流
- en: Ten tips for conducting reproducible interactive computing experiments
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进行可重现交互式计算实验的十条技巧
- en: Writing high-quality Python code
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写高质量的 Python 代码
- en: Writing unit tests with nose
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 nose 编写单元测试
- en: Debugging your code with IPython
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 IPython 调试代码
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引言
- en: This is a special chapter about good practices in interactive computing. If
    the rest of the book is about the content, then this chapter is about the form.
    It describes how to work efficiently and properly with the tools this book is
    about. We will cover the essentials of the version control system Git before tackling
    reproducible computing experiments (notably with the IPython notebook).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这是关于交互式计算中良好实践的特别章节。如果本书的其余部分讨论的是内容，那么本章讨论的是形式。它描述了如何高效且正确地使用本书所讨论的工具。我们将在讨论可重现计算实验之前，先介绍版本控制系统
    Git 的基本要点（特别是在 IPython notebook 中）。
- en: We will also cover more general topics in software development, such as code
    quality, debugging, and testing. Attention to these subjects can greatly improve
    the quality of our end products (for example, software, research, and publications).
    We will only scratch the surface here, but you will find many references to learn
    more about these important topics.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将讨论一些软件开发中的一般主题，例如代码质量、调试和测试。关注这些问题可以极大地提高我们最终产品的质量（例如软件、研究和出版物）。我们这里只是略微涉及，但你将找到许多参考资料，帮助你深入了解这些重要主题。
- en: Choosing (or not) between Python 2 and Python 3
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择（或不选择）Python 2 和 Python 3
- en: 'In this first recipe, we will briefly cover a transverse and kind of a prosaic
    subject: Python 2 or Python 3?'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这第一个食谱中，我们将简要讨论一个横向且有些平凡的话题：Python 2 还是 Python 3？
- en: '**Python 3** has been available since 2008, but many Python users are still
    stuck with Python 2\. By improving many aspects of Python 2, Python 3 has broken
    compatibility with the previous branch. Migrating to Python 3 may therefore require
    a significant investment.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python 3** 自2008年推出以来，许多 Python 用户仍然停留在 Python 2。通过改进了 Python 2 的多个方面，Python
    3 打破了与之前版本的兼容性。因此，迁移到 Python 3 可能需要投入大量精力。'
- en: Even if there aren't that many compatibility-breaking changes, a program that
    works perfectly fine in Python 2 may not work at all in Python 3\. For example,
    your very first `Hello World` Python 2 program doesn't work anymore in Python
    3; `print "Hello World!"` raises a `SyntaxError` in Python 3\. Indeed, `print`
    is now a function rather than a statement. You should write `print("Hello World!")`,
    which also works fine in Python 2.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 即使没有太多破坏兼容性的变化，一个在 Python 2 中运行良好的程序可能在 Python 3 中完全无法运行。例如，你的第一个 `Hello World`
    Python 2 程序在 Python 3 中无法运行；`print "Hello World!"` 在 Python 3 中会引发 `SyntaxError`。实际上，`print`
    现在是一个函数，而不是一个语句。你应该写成 `print("Hello World!")`，这在 Python 2 中也能正常工作。
- en: Whether you start a new project or need to maintain an old Python library, the
    question of choosing between Python 2 and Python 3 arises. Here, we give some
    arguments and pointers that should let you make an informed decision.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你是开始一个新项目，还是需要维护一个旧的 Python 库，选择 Python 2 还是 Python 3 的问题都会出现。在这里，我们提供一些论点和提示，帮助你做出明智的决策。
- en: Note
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When we refer to Python 2, we especially mean Python 2.6 or Python 2.7, as these
    last versions of the Python 2.*x* branch are closer to Python 3 than Python 2.5
    and earlier versions. It is more complicated to support Python 2.5+ and Python
    3.*x* at the same time.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们提到 Python 2 时，我们特别指的是 Python 2.6 或 Python 2.7，因为这些 Python 2.*x* 的最后版本比 Python
    2.5 及更早版本更接近 Python 3。支持 Python 2.5+ 和 Python 3.*x* 同时运行更为复杂。
- en: Similarly, when we refer to Python 3 or Python 3.*x*, we especially mean Python
    3.3 or above.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，当我们提到 Python 3 或 Python 3.*x* 时，我们特别指的是 Python 3.3 或更高版本。
- en: How to do it...
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到……
- en: First, what are the differences between Python 2 and Python 3?
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，Python 2 和 Python 3 之间有什么区别？
- en: Main differences in Python 3 compared to Python 2
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Python 3 相对于 Python 2 的主要差异
- en: 'Here is a partial list of differences:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一些差异的部分列表：
- en: Instead of a statement, `print` is a function (parentheses are compulsory).
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`print` 不再是一个语句，而是一个函数（括号是必须的）。'
- en: Division of integers yields floating-point numbers and not integers.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整数除法会返回浮点数，而不是整数。
- en: Several built-in functions return iterators or views instead of lists. For example,
    `range` behaves in Python 3 like `xrange` in Python 2, and the latter no longer
    exists in Python 3.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些内置函数返回的是迭代器或视图，而不是列表。例如，`range` 在 Python 3 中的行为类似于 Python 2 中的 `xrange`，而后者在
    Python 3 中已经不存在。
- en: Dictionaries do not have the `iterkeys()`, `iteritems()`, and `itervalues()`
    methods anymore. You should use the `keys()`, `items()`, and `values()` functions
    instead.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字典不再有 `iterkeys()`、`iteritems()` 和 `itervalues()` 方法了。你应该改用 `keys()`、`items()`
    和 `values()` 函数。
- en: 'The following is a quote from the official Python documentation:'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下是来自官方 Python 文档的引用：
- en: '*"Everything you thought you knew about binary data and Unicode has changed."*'
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*“你曾经以为自己了解的二进制数据和 Unicode，现在都变了。”*'
- en: String formatting with `%` is deprecated; use `str.format` instead.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `%` 进行字符串格式化已不推荐使用；请改用 `str.format`。
- en: Instead of a statement, `exec` is a function.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exec` 是一个函数，而不是一个语句。'
- en: Python 3 brings many other improvements and new features regarding syntax and
    standard library content. You will find more details in the references at the
    end of this recipe.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3 带来了许多关于语法和标准库内容的改进和新特性。你将在本食谱末尾的参考资料中找到更多细节。
- en: 'Now, you have basically two options for your project: stick with a single branch
    (Python 2 or Python 3), or maintain compatibility with both branches.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你的项目基本上有两种选择：坚持使用单一分支（Python 2 或 Python 3），或同时保持与两个分支的兼容性。
- en: Python 2 or Python 3?
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Python 2 还是 Python 3？
- en: 'It is natural to have a preference for Python 3; it is the future, whereas
    Python 2 is the past. Why bother supporting a deprecated version of Python? Here
    are a few situations where you might want to keep compatibility with Python 2:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 自然，许多人会偏爱 Python 3；它代表着未来，而 Python 2 是过去。为什么还要去支持一个已被废弃的 Python 版本呢？不过，这里有一些可能需要保持
    Python 2 兼容性的情况：
- en: You need to maintain a large project written in Python 2, and it would be too
    costly to update it to Python 3 (even if semiautomatic updating tools exist).
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要维护一个用 Python 2 编写的大型项目，而更新到 Python 3 会花费太高（即使存在半自动化的更新工具）。
- en: Your project has dependencies that do not work with Python 3.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的项目有一些依赖项无法与 Python 3 一起使用。
- en: Note
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Most libraries we will be using in this book support both Python 2 and Python
    3\. This book's code is also compatible with both branches.
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 本书中我们将使用的大多数库支持 Python 2 和 Python 3。并且本书的代码兼容这两个分支。
- en: Your end users work on environments that do not support Python 3 well. For example,
    they may work in a large institution where deploying a new version of Python on
    many servers would be too costly.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的最终用户所使用的环境不太支持 Python 3。例如，他们可能在某个大型机构工作，在许多服务器上部署新的 Python 版本成本太高。
- en: In these situations, you may choose to stick with Python 2, with the risk that
    your code becomes obsolete in the near future. Otherwise, you could pick Python
    3 and its shiny new features, with the risk of leaving behind Python 2 users.
    You could also write your code in Python 2 and make it ready for Python 3\. Thus,
    you can reduce the number of changes that will be required during a subsequent
    port to Python 3.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你可以选择继续使用 Python 2，但这意味着你的代码可能在不久的将来变得过时。或者，你可以选择 Python 3 和它那一堆崭新的功能，但也有可能会把
    Python 2 的用户抛在后头。你也可以用 Python 2 编写代码，并为 Python 3 做好准备。这样，你可以减少将来迁移到 Python 3 时所需的修改。
- en: Fortunately, you don't necessarily have to choose between Python 2 and Python
    3\. There are ways to support both versions at the same time. Even if this involves
    slightly more work than just sticking to a single branch, it can be quite interesting
    in certain cases. Note, however, that you may miss many Python 3-only features
    if you go down this road.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，你不一定要在 Python 2 和 Python 3 之间做出选择。实际上，有方法可以同时支持这两个版本。即使这可能比单纯选择一个分支多花一些工作，但在某些情况下它可能会非常有趣。不过，需要注意的是，如果选择这种做法，你可能会错过许多仅支持
    Python 3 的特性。
- en: Supporting both Python 2 and Python 3
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 同时支持 Python 2 和 Python 3
- en: 'There are basically two ways to support both branches in your code: use the
    **2to3** tool, or write code that *just works* in both branches.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 支持两个分支的基本方法有两种：使用 **2to3** 工具，或者编写在两个分支中都能*正常运行*的代码。
- en: Using 2to3
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 2to3 工具
- en: 2to3 is a program in the standard library that automatically converts Python
    2 code to Python 3\. For example, run `2to3 -w example.py` to migrate a single
    Python 2 module to Python 3\. You can find more information on the 2to3 tool at
    [https://docs.python.org/2/library/2to3.html](https://docs.python.org/2/library/2to3.html).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`2to3` 是标准库中的一个程序，能够自动将 Python 2 代码转换为 Python 3。例如，运行 `2to3 -w example.py`
    可以将单个 Python 2 模块迁移到 Python 3。你可以在 [https://docs.python.org/2/library/2to3.html](https://docs.python.org/2/library/2to3.html)
    找到更多关于 2to3 工具的信息。'
- en: You can configure your installation script so that 2to3 runs automatically when
    users install your package. Python 3 users will get the automatically-converted
    Python 3 version of your package.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以配置安装脚本，使得 `2to3` 在用户安装你的包时自动运行。Python 3 用户将自动获得转换后的 Python 3 版本的包。
- en: This solution requires your program to be well-covered by a solid testing suite
    and a continuous integration system that tests both Python 2 and Python 3 (see
    the recipes about unit testing later in this chapter). This is how you can ensure
    that your code works fine in both versions.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案要求你的程序有一个坚实的测试套件，并且有一个持续集成系统，能够测试 Python 2 和 Python 3（请参阅本章稍后的单元测试食谱）。这是确保你的代码在两个版本中都能正常工作的方式。
- en: Writing code that works in Python 2 and Python 3
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写在 Python 2 和 Python 3 中都能运行的代码。
- en: You can also write code that works in Python 2 and Python 3\. This solution
    is simpler if you start a new project from scratch. A widely-used method is to
    rely on a lightweight and mature module called **six**, developed by Benjamin
    Petersons. This module is only a single file, so you can easily distribute it
    with your package. Wherever you would use a function or feature that is only supported
    in one Python branch, you need to use a specific function implemented in six.
    This function either wraps or emulates the corresponding functionality, thus it
    can work in both branches. You can find more information on six at [http://pythonhosted.org/six/](http://pythonhosted.org/six/).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以编写既能在 Python 2 中运行，又能在 Python 3 中运行的代码。如果从头开始一个新项目，这个解决方案会更简单。一个广泛使用的方法是依赖一个轻量且成熟的模块，名为
    **six**，由 Benjamin Peterson 开发。这个模块只有一个文件，因此你可以轻松地将其与包一起分发。无论何时你需要使用一个仅在某个 Python
    分支中支持的函数或特性时，都需要使用 six 中实现的特定函数。这个函数要么包装，要么模拟相应的功能，因此它能在两个分支中正常工作。你可以在 [http://pythonhosted.org/six/](http://pythonhosted.org/six/)
    上找到关于 six 的更多信息。
- en: 'This method requires you to change some habits. For example, to iterate over
    all items of a dictionary in Python 2, you would write the following code:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法要求你改变一些习惯。例如，在 Python 2 中迭代字典的所有项时，你会写如下代码：
- en: '[PRE0]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, instead of the preceding code, you write the following code with six:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，不再使用前面的代码，而是使用 six 编写以下代码：
- en: '[PRE1]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `iteritems()` method of dictionaries in Python 2 is replaced by `items()`
    in Python 3\. The six module's `iteritems` function internally calls one method
    or the other, depending on the Python version.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Python 2 中字典的 `iteritems()` 方法在 Python 3 中被 `items()` 替代。six 模块的 `iteritems`
    函数根据 Python 版本内部调用一个方法。
- en: Tip
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Downloading the example code**'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从你的账号中下载所有已购买的 Packt 图书的示例代码文件，网址为 [http://www.packtpub.com](http://www.packtpub.com)。如果你是在其他地方购买的此书，可以访问
    [http://www.packtpub.com/support](http://www.packtpub.com/support) 注册并直接将文件通过电子邮件发送给你。
- en: There's more...
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'As we have seen, there are many options you can choose regarding the Python
    2 or Python 3 question. In brief, you should consider the following options:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，关于 Python 2 或 Python 3 的问题，有很多选择可以考虑。简而言之，你应该考虑以下选项：
- en: 'Decide very carefully whether you absolutely need to support Python 2 or not:'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请仔细决定是否真的需要支持 Python 2：
- en: If so, prepare your code for Python 3 by avoiding Python 2-only syntax or features.
    You can use six, 2to3, or similar tools.
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果是，请通过避免使用 Python 2 专有的语法或特性，为 Python 3 准备好你的代码。你可以使用 six、2to3 或类似的工具。
- en: If not, stick to Python 3.
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有必要，坚决使用 Python 3。
- en: In all cases, make sure your project has a solid testing suite, an excellent
    code coverage (approaching 100 percent), and a continuous integration system that
    tests your code against all versions of Python that you officially support
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在所有情况下，确保你的项目拥有一个坚实的测试套件、出色的代码覆盖率（接近 100%），并且有一个持续集成系统，能够在你正式支持的所有 Python 版本中测试你的代码。
- en: 'Here are several references on the subject:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有几个相关的参考资料：
- en: An excellent free book about porting code to Python 3, by Lennart Regebro, available
    at [http://python3porting.com/](http://python3porting.com/)
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一本关于将代码迁移到 Python 3 的优秀免费书籍，作者：Lennart Regebro，访问地址：[http://python3porting.com/](http://python3porting.com/)
- en: Official recommendations on porting code to Python 3, available at [https://docs.python.org/3/howto/pyporting.html](https://docs.python.org/3/howto/pyporting.html)
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于将代码迁移到 Python 3 的官方推荐，访问地址：[https://docs.python.org/3/howto/pyporting.html](https://docs.python.org/3/howto/pyporting.html)
- en: Official wiki page about the Python 2/Python 3 question, available at [https://wiki.python.org/moin/Python2orPython3](https://wiki.python.org/moin/Python2orPython3)
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于 Python 2/Python 3 问题的官方维基页面，访问地址：[https://wiki.python.org/moin/Python2orPython3](https://wiki.python.org/moin/Python2orPython3)
- en: Python 3 questions and answers, by Nick Coghlan, available at [http://python-notes.curiousefficiency.org/en/latest/python3/questions_and_answers.html](http://python-notes.curiousefficiency.org/en/latest/python3/questions_and_answers.html)
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Nick Coghlan 提供的 Python 3 问答，访问地址：[http://python-notes.curiousefficiency.org/en/latest/python3/questions_and_answers.html](http://python-notes.curiousefficiency.org/en/latest/python3/questions_and_answers.html)
- en: '*What''s new in Python 3*, available at [https://docs.python.org/3.3/whatsnew/3.0.html](https://docs.python.org/3.3/whatsnew/3.0.html)'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Python 3 中的新特性*，请见 [https://docs.python.org/3.3/whatsnew/3.0.html](https://docs.python.org/3.3/whatsnew/3.0.html)'
- en: '*Ten awesome features of Python that you can''t use because you refuse to upgrade
    to Python 3*, a presentation by Aaron Meurer, available at [http://asmeurer.github.io/python3-presentation/slides.html](http://asmeurer.github.io/python3-presentation/slides.html)'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*你无法使用的 Python 十大酷炫特性，因为你拒绝升级到 Python 3*，由 Aaron Meurer 提供的演讲，访问地址：[http://asmeurer.github.io/python3-presentation/slides.html](http://asmeurer.github.io/python3-presentation/slides.html)'
- en: Using the `__future__` module when writing the compatibility code, available
    at [https://docs.python.org/2/library/__future__.html](https://docs.python.org/2/library/__future__.html)
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在编写兼容性代码时使用 `__future__` 模块，访问地址：[https://docs.python.org/2/library/__future__.html](https://docs.python.org/2/library/__future__.html)
- en: Key differences between Python 2 and Python 3, available at [https://sebastianraschka.com/Articles/2014_python_2_3_key_diff.html](https://sebastianraschka.com/Articles/2014_python_2_3_key_diff.html)
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 2 和 Python 3 的关键区别，访问地址：[https://sebastianraschka.com/Articles/2014_python_2_3_key_diff.html](https://sebastianraschka.com/Articles/2014_python_2_3_key_diff.html)
- en: See also
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: The *Writing high-quality Python code* recipe
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*编写高质量 Python 代码* 这篇食谱'
- en: The *Writing unit tests with nose* recipe
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 nose 编写单元测试* 这篇食谱'
- en: Efficient interactive computing workflows with IPython
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 IPython 进行高效的交互式计算工作流
- en: There are multiple ways of using IPython for interactive computing. Some of
    them are better in terms of flexibility, modularity, reusability, and reproducibility.
    We will review and discuss them in this recipe.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方法可以使用 IPython 进行交互式计算。其中一些在灵活性、模块化、可重用性和可复现性方面更为优秀。我们将在本节中回顾和讨论这些方法。
- en: 'Any interactive computing workflow is based on the following cycle:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 任何交互式计算工作流都基于以下循环：
- en: Write some code
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一些代码
- en: Execute it
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行它
- en: Interpret the results
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释结果
- en: Repeat
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重复
- en: This fundamental loop (also known as **Read-Eval-Print Loop** or **REPL**) is
    particularly useful when doing exploratory research on data or model simulations,
    or when building a complex algorithm step by step. A more classical workflow (the
    edit-compile-run-debug loop) would consist of writing a full-blown program, and
    then performing a complete analysis. This is generally more tedious. It is more
    common to build an algorithmic solution iteratively, by doing small-scale experiments
    and tweaking the parameters, and this is precisely what interactive computing
    is about.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这个基本循环（也叫做**读取-求值-打印循环**，或称**REPL**）在进行数据或模型模拟的探索性研究时特别有用，或者在逐步构建复杂算法时也很有用。一个更经典的工作流（编辑-编译-运行-调试循环）通常是编写一个完整的程序，然后进行全面分析。这种方法通常比较繁琐。更常见的做法是通过做小规模实验、调整参数来迭代地构建算法解决方案，这正是交互式计算的核心。
- en: '**Integrated Development Environments** (**IDEs**), providing comprehensive
    facilities for software development (such as a source code editor, compiler, and
    debugger), are widely used for classical workflows. However, when it comes to
    interactive computing, alternatives to IDEs exist. We will review them here.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**集成开发环境**（**IDEs**），提供了全面的软件开发设施（如源代码编辑器、编译器和调试器），广泛应用于经典工作流。然而，在交互式计算方面，存在一些替代
    IDE 的工具。我们将在这里进行回顾。'
- en: How to do it...
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: Here are a few possible workflows for interactive computing, by increasing order
    of complexity. Of course, IPython is at the core of all of these methods.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是几个可能的交互式计算工作流程，按复杂度递增排列。当然，IPython是所有这些方法的核心。
- en: The IPython terminal
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: IPython终端
- en: IPython is the *de facto* standard for interactive computing in Python. The
    IPython terminal (the `ipython` command) offers a command-line interface specifically
    designed for REPLs. It is a much more powerful tool than the native Python interpreter
    (the `python` command). The IPython terminal is a convenient tool for quick experiments,
    simple shell interactions, and to find help. Forgot the input arguments of NumPy's
    `savetxt` function? Just type in `numpy.savetxt?` in IPython (you will first need
    to use `import numpy`, of course). Some people even use the IPython terminal as
    a (sophisticated) calculator!
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: IPython是Python中交互式计算的*事实标准*。IPython终端（`ipython`命令）提供了一个专门为REPL设计的命令行界面。它比本地Python解释器（`python`命令）更强大。IPython终端是一个便捷的工具，用于快速实验、简单的Shell交互以及查找帮助。忘记了NumPy的`
    savetxt`函数的输入参数吗？只需在IPython中输入`numpy.savetxt?`（当然，你首先需要使用`import numpy`）。有些人甚至把IPython终端当作（复杂的）计算器来使用！
- en: Yet, the terminal quickly becomes limited when it is used alone. The main issue
    is that the terminal is not a code editor, and thus entering more than a few lines
    of code can be inconvenient. Fortunately, there are various ways of solving this
    problem, as detailed in the following sections.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当单独使用时，终端很快变得有限。主要问题是终端不是一个代码编辑器，因此输入超过几行的代码可能会变得不方便。幸运的是，有多种方法可以解决这个问题，下面的章节将详细介绍这些方法。
- en: IPython and text editor
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: IPython与文本编辑器
- en: 'The simplest solution to the *not-a-text-editor* problem is, perhaps unsurprisingly,
    to use IPython along with a text editor. The `%run` magic command then becomes
    the central tool in this workflow:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '*非文本编辑器*问题的最简单解决方案或许并不令人意外，那就是结合使用IPython和文本编辑器。在这种工作流程中，`%run`魔法命令成为了核心工具：'
- en: Write some code in your favorite text editor and save it in a `myscript.py`
    Python script file.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你喜欢的文本编辑器中编写一些代码，并将其保存在`myscript.py` Python脚本文件中。
- en: In IPython, assuming you are in the right directory, type in `%run myscript.py`.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在IPython中，假设你处于正确的目录，输入`%run myscript.py`。
- en: The script is executed. The standard output is displayed in real time in the
    IPython terminal along with possible errors. Top-level variables defined in the
    script are accessible in the IPython terminal at the end of the script's execution.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 脚本被执行。标准输出会实时显示在IPython终端中，并且会显示可能的错误。脚本中定义的顶级变量在脚本执行完毕后，可以在IPython终端中访问。
- en: If code changes are required in the script, repeat the process.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果需要在脚本中进行代码更改，请重复此过程。
- en: Tip
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'The IPython-text editor workflow can be made yet more efficient with adequate
    keyboard shortcuts. You can, for instance, automate your text editor such that,
    when pressing *F8*, the following command is executed in the running IPython interpreter:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 通过适当的键盘快捷键，IPython-文本编辑器工作流程可以变得更加高效。例如，你可以自动化你的文本编辑器，当按下*F8*时，在正在运行的IPython解释器中执行以下命令：
- en: '[PRE2]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This approach is described here (on Windows, with Notepad++ and AutoHotKey):'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这里描述了这种方法（在Windows上，使用Notepad++和AutoHotKey）：
- en: '[http://cyrille.rossant.net/python-ide-windows/](http://cyrille.rossant.net/python-ide-windows/)'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://cyrille.rossant.net/python-ide-windows/](http://cyrille.rossant.net/python-ide-windows/)'
- en: 'With a good text editor, this workflow can be quite efficient. As the script
    is reloaded when you execute `%run`, your changes will be taken into account automatically.
    Things become more complicated when your script imports other Python modules that
    you modify, as these won''t be reloaded with `%run`. You can use a deep reload
    to solve this problem:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 使用一个好的文本编辑器，这个工作流程可以非常高效。由于每次执行`%run`时都会重新加载脚本，因此你的更改会自动生效。当你的脚本导入了其他Python模块并且你修改了这些模块时，情况会变得更复杂，因为这些模块不会随着`%run`被重新加载。你可以使用深度重新加载来解决这个问题：
- en: '[PRE3]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Modules imported in `myscript` will then be reloaded. A related IPython magic
    command is `%autoreload` (you first need to execute `%load_ext autoreload`). This
    command tries to automatically reload the modules imported in the interactive
    namespace, but it is not always successful. You may need to reload the changed
    modules explicitly with `reload(module)` (in Python 2) or `imp.reload(module)`
    (Python 3).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`myscript`中导入的模块将会被重新加载。一个相关的IPython魔法命令是`%autoreload`（你首先需要执行`%load_ext autoreload`）。此命令会尝试自动重新加载交互命名空间中导入的模块，但并不总是成功。你可能需要显式地重新加载已更改的模块，使用`reload(module)`（在Python
    2中）或`imp.reload(module)`（Python 3中）。'
- en: The IPython notebook
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: IPython笔记本
- en: The IPython notebook plays a central role in efficient interactive workflows.
    It is a well-designed mix between a code editor and a terminal, bringing the best
    of both worlds within a unified environment.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: IPython 笔记本在高效的交互式工作流程中起着核心作用。它是代码编辑器和终端的精心设计的结合，将两者的优点融为一体，提供一个统一的环境。
- en: You can start writing all your code in your notebook's cells. You write, execute,
    and test your code at the same place, thereby improving your productivity. You
    can put long comments in Markdown cells and structure your notebook with Markdown
    headers.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在笔记本的单元格中开始编写所有代码。你可以在同一地方编写、执行和测试代码，从而提高生产力。你可以在 Markdown 单元格中加入长注释，并使用
    Markdown 标题来结构化你的笔记本。
- en: Once portions of your code become mature enough and do not require further changes,
    you can (and should) refactor them into reusable Python components (functions,
    classes, and modules). This will clean up your notebooks and facilitate future
    reuse of your code. Let's emphasize the fact that it is very important to refactor
    your code constantly into reusable components. IPython notebooks are currently
    not easily reusable by third-party code, and they are not designed for this. Notebooks
    are convenient for preliminary analyses and exploratory research, but they should
    not preclude you from regularly cleaning and refactoring your code into Python
    components.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你的一部分代码足够成熟且不再需要进一步修改，你可以（并且应该）将它们重构为可重用的 Python 组件（函数、类和模块）。这将清理你的笔记本，并促进代码的未来重用。需要强调的是，不断将代码重构为可重用组件非常重要。IPython
    笔记本当前不容易被第三方代码重用，并且它们并不针对这一点进行设计。笔记本适合进行初步分析和探索性研究，但它们不应该阻止你定期清理并将代码重构为 Python
    组件。
- en: A major advantage of notebooks is that they give you documents retracing everything
    you did with your code. They are extremely useful for reproducible research. Notebooks
    are saved in human-readable JSON documents, thus they work relatively well with
    version control systems such as Git.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 笔记本的一个主要优势是，它们能为你提供一份文档，记录你在代码中所做的一切。这对可重复研究极为有用。笔记本保存在人类可读的 JSON 文档中，因此它们与
    Git 等版本控制系统相对兼容。
- en: Integrated Development Environments
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集成开发环境
- en: IDEs are particularly well-adapted for classic software development, but they
    can also be used for interactive computing. A good Python IDE combines a powerful
    text editor (for example, one that includes features such as syntax highlighting
    and tab completion), an IPython terminal, and a debugger within a unified environment.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 集成开发环境（IDEs）特别适用于经典的软件开发，但它们也可以用于交互式计算。一款好的 Python IDE 将强大的文本编辑器（例如，包含语法高亮和自动补全功能的编辑器）、IPython
    终端和调试器结合在统一的环境中。
- en: There are multiple commercial and open-source IDEs for most platforms. **Eclipse**/**PyDev**
    is a popular (although slightly heavy) open source cross-platform environment.
    **Spyder** is another open source IDE with good integration of IPython and matplotlib.
    **PyCharm** is one of many commercial environments that support IPython.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数平台，有多个商业和开源 IDE。**Eclipse**/**PyDev** 是一个流行的（尽管略显笨重的）开源跨平台环境。**Spyder**
    是另一个开源 IDE，具有良好的 IPython 和 matplotlib 集成。**PyCharm** 是众多支持 IPython 的商业环境之一。
- en: Microsoft's IDE for Windows, Visual Studio, has an open source plugin named
    **Python Tools for Visual Studio** (**PTVS**). This tool brings Python support
    to Visual Studio. PTVS natively supports IPython. You don't necessarily need a
    paid version of Visual Studio; you can download a free package bundling PTVS with
    Visual Studio.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 微软的 Windows IDE，Visual Studio，有一个名为 **Python Tools for Visual Studio**（**PTVS**）的开源插件。这个工具为
    Visual Studio 带来了 Python 支持。PTVS 原生支持 IPython。你不一定需要付费版本的 Visual Studio；你可以下载一个免费的包，将
    PTVS 和 Visual Studio 打包在一起。
- en: There's more...
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'Here are a few links to various IDEs for Python:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些 Python IDE 的链接：
- en: '[http://pydev.org](http://pydev.org) for PyDev for Eclipse'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://pydev.org](http://pydev.org) 是 PyDev for Eclipse 的官方网站。'
- en: '[http://code.google.com/p/spyderlib/](http://code.google.com/p/spyderlib/)
    for Spyder, an open source IDE'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://code.google.com/p/spyderlib/](http://code.google.com/p/spyderlib/)
    是 Spyder，一个开源 IDE。'
- en: '[www.jetbrains.com/pycharm/](http://www.jetbrains.com/pycharm/) for PyCharm'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[www.jetbrains.com/pycharm/](http://www.jetbrains.com/pycharm/) 是 PyCharm 的官方网站。'
- en: '[http://pytools.codeplex.com](http://pytools.codeplex.com) for PyTools for
    Microsoft Visual Studio on Windows'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://pytools.codeplex.com](http://pytools.codeplex.com) 是微软 Visual Studio
    在 Windows 上的 PyTools。'
- en: '[http://code.google.com/p/pyscripter/](http://code.google.com/p/pyscripter/)
    for PyScripter'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://code.google.com/p/pyscripter/](http://code.google.com/p/pyscripter/)
    是 PyScripter 的官方网站。'
- en: '[www.iep-project.org](http://www.iep-project.org) for IEP, the Interactive
    Editor for Python'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[www.iep-project.org](http://www.iep-project.org) 为 IEP，Python 的交互式编辑器'
- en: See also
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: The *Learning the basics of the distributed version control system Git* recipe
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*学习分布式版本控制系统 Git 的基础* 方法'
- en: The *Debugging your code with IPython* recipe
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 IPython 调试代码* 的方法'
- en: Learning the basics of the distributed version control system Git
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习分布式版本控制系统 Git 的基础
- en: Using a **distributed version control system** is so natural nowadays that if
    you are reading this book, you are probably already using one. However, if you
    aren't, read this recipe carefully. You should always use a version control system
    for your code.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 **分布式版本控制系统** 在当今已经变得非常自然，如果你正在阅读本书，你可能已经在使用某种版本控制系统。然而，如果你还没有，请认真阅读这个方法。你应该始终为你的代码使用版本控制系统。
- en: Getting ready
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Notable distributed version control systems include **Git**, **Mercurial**,
    and **Bazaar**. In this chapter, we chose the popular Git system. You can download
    the Git program and Git GUI clients from [http://git-scm.com](http://git-scm.com).
    On Windows, you can also install **msysGit** ([http://msysgit.github.io](http://msysgit.github.io))
    and **TortoiseGit** ([https://code.google.com/p/tortoisegit/](https://code.google.com/p/tortoisegit/)).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 著名的分布式版本控制系统包括 **Git**、**Mercurial** 和 **Bazaar**。在这一章中，我们选择了流行的 Git 系统。你可以从
    [http://git-scm.com](http://git-scm.com) 下载 Git 程序和 Git GUI 客户端。在 Windows 上，你也可以安装
    **msysGit**（[http://msysgit.github.io](http://msysgit.github.io)）和 **TortoiseGit**（[https://code.google.com/p/tortoisegit/](https://code.google.com/p/tortoisegit/)）。
- en: Note
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Distributed systems tend to be more popular than centralized systems such as
    SVN or CVS. Distributed systems allow local (offline) changes and offer more flexible
    collaboration systems.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 与 SVN 或 CVS 等集中式系统相比，分布式系统通常更受欢迎。分布式系统允许本地（离线）更改，并提供更灵活的协作系统。
- en: Online providers supporting Git include **GitHub** ([https://github.com](https://github.com)),
    **Bitbucket** ([https://bitbucket.org](https://bitbucket.org)), **Google code**
    ([https://code.google.com](https://code.google.com)), **Gitorious** ([https://gitorious.org](https://gitorious.org)),
    and **SourceForge** ([https://sourceforge.net](https://sourceforge.net)). At the
    time of writing this book, creating an account is free on all these websites.
    GitHub offers free unlimited public repositories, while Bitbucket offers free
    unlimited public and private repositories. GitHub offers special features and
    discounts to academics ([https://github.com/edu](https://github.com/edu)). Synchronizing
    your Git repositories on such a website is particularly convenient when you work
    on multiple computers.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 支持 Git 的在线服务商包括 **GitHub**（[https://github.com](https://github.com)）、**Bitbucket**（[https://bitbucket.org](https://bitbucket.org)）、**Google
    code**（[https://code.google.com](https://code.google.com)）、**Gitorious**（[https://gitorious.org](https://gitorious.org)）和
    **SourceForge**（[https://sourceforge.net](https://sourceforge.net)）。在撰写本书时，所有这些网站创建账户都是免费的。GitHub
    提供免费的无限制公共仓库，而 Bitbucket 提供免费的无限制公共和私有仓库。GitHub 为学术用户提供特殊功能和折扣（[https://github.com/edu](https://github.com/edu)）。将你的
    Git 仓库同步到这样的网站，在你使用多台计算机时特别方便。
- en: You need to install Git (and possibly a GUI) for this recipe (see [http://git-scm.com/downloads](http://git-scm.com/downloads)).
    We also suggest that you create an account on one of these websites. GitHub is
    a popular choice, notably for its user-friendly web interface and its well-developed
    social features. GitHub also provides a very good GUI on Windows ([https://windows.github.com](https://windows.github.com))
    and Mac OS X ([https://mac.github.com](https://mac.github.com)). Most Python libraries
    we will be using in this book are being developed on GitHub.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要安装 Git（可能还需要安装 GUI）才能使用此方法（参见 [http://git-scm.com/downloads](http://git-scm.com/downloads)）。我们还建议你在以下这些网站之一创建账户。GitHub
    是一个很受欢迎的选择，特别是因为它用户友好的网页界面和发达的社交功能。GitHub 还提供了非常好的 Windows 客户端（[https://windows.github.com](https://windows.github.com)）和
    Mac OS X 客户端（[https://mac.github.com](https://mac.github.com)）。我们在本书中使用的大多数 Python
    库都是在 GitHub 上开发的。
- en: How to do it…
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: We will show two methods to initialize a repository.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将展示两种初始化仓库的方法。
- en: Creating a local repository
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个本地仓库
- en: 'This method is best when starting to work locally. This can be with using the
    following steps:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法最适合开始在本地工作时使用。可以通过以下步骤实现：
- en: 'The very first thing to do when starting a new project or computing experiment
    is create a new folder locally:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在开始一个新项目或计算实验时，最先要做的就是在本地创建一个新文件夹：
- en: '[PRE4]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We initialize a Git repository:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们初始化一个 Git 仓库：
- en: '[PRE5]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let''s set our name and e-mail address:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们设置我们的姓名和电子邮件地址：
- en: '[PRE6]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We create a new file, and tell Git to track it:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建一个新文件，并告诉 Git 跟踪它：
- en: '[PRE7]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Finally, let''s create our first commit:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们创建我们的第一次提交：
- en: '[PRE8]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Cloning a remote repository
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 克隆一个远程仓库
- en: 'This method is best when the repository is to be synchronized with an online
    provider such as GitHub. Let''s perform the following steps:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当仓库需要与 GitHub 等在线提供商同步时，这种方法最好。我们来执行以下步骤：
- en: We create a new repository on the web interface of our online provider.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在在线提供商的网页界面上创建了一个新的仓库。
- en: 'On the main webpage of the newly created project, we click on the **Clone**
    button with the repository URL and we type in a terminal:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新创建项目的主页面上，我们点击**克隆**按钮并获取仓库 URL，然后在终端输入：
- en: '[PRE9]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We set our name and e-mail address:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们设置我们的姓名和电子邮件地址：
- en: '[PRE10]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let''s create a new file and tell Git to track it:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个新文件并告诉 Git 跟踪它：
- en: '[PRE11]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We create our first commit:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建我们的第一次提交：
- en: '[PRE12]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We push our local changes to the remote server:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将本地更改推送到远程服务器：
- en: '[PRE13]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: When we have a local repository (created with the first method), we can synchronize
    it with a remote server using a `git remote add` command.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们拥有一个本地仓库（通过第一种方法创建）时，我们可以使用 `git remote add` 命令将其与远程服务器同步。
- en: How it works…
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: When you start a new project or a new computing experiment, create a new folder
    on your computer. You will eventually add code, text files, datasets, and other
    resources in this folder. The distributed version control system keeps track of
    the changes you make to your files as your project evolves. It is more than a
    simple backup, as every change you make on any file can be saved along with the
    corresponding timestamp. You can even revert to a previous state at any time;
    never be afraid of breaking your code anymore!
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始一个新项目或新的计算实验时，在你的计算机上创建一个新文件夹。你最终会在这个文件夹中添加代码、文本文件、数据集和其他资源。分布式版本控制系统会跟踪你在项目发展过程中对文件所做的更改。它不仅仅是一个简单的备份，因为你对任何文件所做的每个更改都会保存相应的时间戳。你甚至可以随时恢复到之前的状态；再也不用担心破坏你的代码了！
- en: Specifically, you can take a snapshot of your project at any time by doing a
    **commit**. The snapshot includes all staged (or tracked) files. You are in total
    control of which files and changes will be tracked. With Git, you specify a file
    as staged for your next commit with `git add`, before committing your changes
    with `git commit`. The `git commit -a` command allows you to commit all changes
    in the files that are already being tracked.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，你可以随时通过执行**提交**来拍摄项目的快照。该快照包括所有已暂存（或已跟踪）的文件。你完全控制哪些文件和更改将被跟踪。使用 Git，你可以通过
    `git add` 将文件标记为下次提交的暂存文件，然后用 `git commit` 提交你的更改。`git commit -a` 命令允许你提交所有已经被跟踪的文件的更改。
- en: When committing, you need to provide a message describing the changes you made.
    This makes the repository's history considerably more informative.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在提交时，你需要提供一个消息来描述你所做的更改。这样可以使仓库的历史更加详细和富有信息。
- en: Note
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注
- en: '**How often should you commit?**'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '**你应该多频繁地提交？**'
- en: The answer is very often. Git only takes responsibility of your work when you
    commit changes. What happens between two commits may be lost, so you'd better
    commit very regularly. Besides, commits are quick and cheap as they are local;
    that is, they do not involve any remote communication with an external server.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是非常频繁的。Git 只有在你提交更改时才会对你的工作负责。在两次提交之间发生的内容可能会丢失，所以你最好定期提交。此外，提交是快速且便宜的，因为它们是本地的；也就是说，它们不涉及与外部服务器的任何远程通信。
- en: Git is a distributed version control system; your local repository does not
    need to synchronize with an external server. However, you should synchronize if
    you need to work on several computers, or if you prefer to have a remote backup.
    Synchronization with a remote repository can be done with `git push` (send your
    local commits on the remote server), `git fetch` (download remote branches and
    objects), or `git pull` (synchronize the remote changes on your local repository).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Git 是一个分布式版本控制系统；你的本地仓库不需要与外部服务器同步。然而，如果你需要在多台计算机上工作，或者如果你希望拥有远程备份，你应该进行同步。与远程仓库的同步可以通过
    `git push`（将你的本地提交发送到远程服务器）、`git fetch`（下载远程分支和对象）或 `git pull`（同步远程更改到本地仓库）来完成。
- en: There's more…
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: The simplistic workflow shown in this recipe is linear. In practice though,
    workflows with Git are typically nonlinear; this is the concept of branching.
    We will describe this idea in the next recipe, *A typical workflow with Git branching*.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程中展示的简化工作流是线性的。然而，在实际操作中，Git 的工作流通常是非线性的；这就是分支的概念。我们将在下一个教程中描述这个概念，*使用 Git
    分支的典型工作流*。
- en: 'Here are some excellent references on Git:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些关于 Git 的优秀参考资料：
- en: Hands-on tutorial, available at [https://try.github.io](https://try.github.io)
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实操教程，见于 [https://try.github.io](https://try.github.io)
- en: Git Guided Tour, at [http://gitimmersion.com](http://gitimmersion.com)
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Git 指导游，见于 [http://gitimmersion.com](http://gitimmersion.com)
- en: Atlassian Git tutorial, available at [www.atlassian.com/git](http://www.atlassian.com/git)
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Atlassian Git 教程，见于 [www.atlassian.com/git](http://www.atlassian.com/git)
- en: Online course, available at [www.codeschool.com/courses/try-git](http://www.codeschool.com/courses/try-git)
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在线课程，见于 [www.codeschool.com/courses/try-git](http://www.codeschool.com/courses/try-git)
- en: Git tutorial by Lars Vogel, available at [www.vogella.com/tutorials/Git/article.html](http://www.vogella.com/tutorials/Git/article.html)
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lars Vogel 编写的 Git 教程，见于 [www.vogella.com/tutorials/Git/article.html](http://www.vogella.com/tutorials/Git/article.html)
- en: GitHub Git tutorial, available at [http://git-lectures.github.io](http://git-lectures.github.io)
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitHub Git 教程，见于 [http://git-lectures.github.io](http://git-lectures.github.io)
- en: Git tutorial for scientists, available at [http://nyuccl.org/pages/GitTutorial/](http://nyuccl.org/pages/GitTutorial/)
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 针对科学家的 Git 教程，见于 [http://nyuccl.org/pages/GitTutorial/](http://nyuccl.org/pages/GitTutorial/)
- en: GitHub help, available at [https://help.github.com](https://help.github.com)
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitHub 帮助，见于 [https://help.github.com](https://help.github.com)
- en: '*Pro Git* by Scott Chacon, available at [http://git-scm.com](http://git-scm.com)'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由 Scott Chacon 编写的 *Pro Git*，见于 [http://git-scm.com](http://git-scm.com)
- en: See also
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: The *A typical workflow with Git branching* recipe
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Git 分支的典型工作流* 方案'
- en: A typical workflow with Git branching
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Git 分支的典型工作流
- en: A distributed version control system such as Git is designed for complex and
    nonlinear workflows typical in interactive computing and exploratory research.
    A central concept is **branching**, which we will discuss in this recipe.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 像 Git 这样的分布式版本控制系统是为复杂的、非线性的工作流设计的，这类工作流通常出现在交互式计算和探索性研究中。一个核心概念是**分支**，我们将在本方案中讨论这一点。
- en: Getting ready
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You need to work in a local Git repository for this recipe (see the previous
    recipe, *Learning the basics of the distributed version control system Git*).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要在本地 Git 仓库中工作才能进行此方案（见前一方案，*学习分布式版本控制系统 Git 的基础知识*）。
- en: How to do it…
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何执行…
- en: 'We create a new branch named `newidea`:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建一个名为 `newidea` 的新分支：
- en: '[PRE14]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We switch to this branch:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们切换到这个分支：
- en: '[PRE15]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We make changes to the code, for instance, by creating a new file:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们对代码进行更改，例如，创建一个新文件：
- en: '[PRE16]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We add this file and commit our changes:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们添加此文件并提交我们的更改：
- en: '[PRE17]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If we are happy with the changes, we merge the branch to the *master* branch
    (the default):'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们对更改感到满意，我们将该分支合并到 *master* 分支（默认分支）：
- en: '[PRE18]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Otherwise, we delete the branch:'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 否则，我们删除该分支：
- en: '[PRE19]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Other commands of interest include:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 其他感兴趣的命令包括：
- en: '`git status`: Find the current **status** of the repository'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`git status`：查看仓库的当前**状态**'
- en: '`git log`: Show the commit logs'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`git log`：显示提交日志'
- en: '`git branch`: Show the existing **branches** and highlight the current one'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`git branch`：显示现有的**分支**并突出当前分支'
- en: '`git diff`: Show the **differences** between commits or branches'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`git diff`：显示提交或分支之间的**差异**'
- en: Stashing
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 暂存
- en: 'It may happen that while we are halfway through some work, we need to make
    some other change in another commit or another branch. We could commit our half-done
    work, but this is not ideal. A better idea is to **stash** our working copy in
    a secured location so that we can recover all of our uncommitted changes later.
    Here is how it works:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 可能发生的情况是，当我们正在进行某项工作时，需要在另一个提交或另一个分支中进行其他更改。我们可以提交尚未完成的工作，但这并不理想。更好的方法是将我们正在工作的副本**暂存**到安全位置，以便稍后恢复所有未提交的更改。它是如何工作的：
- en: 'We save our uncommitted changes with the following command:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用以下命令保存我们的未提交更改：
- en: '[PRE20]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We can do anything we want with the repository: checkout a branch, commit changes,
    pull or push from a remote repository, and so on.'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以对仓库进行任何操作：检出一个分支、提交更改、从远程仓库拉取或推送等。
- en: 'When we want to recover our uncommitted changes, we type the following command:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们想要恢复未提交的更改时，输入以下命令：
- en: '[PRE21]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We can have several stashed states in the repository. More information about
    stashing can be found with `git stash --help`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在仓库中有多个暂存的状态。有关暂存的更多信息，请使用 `git stash --help`。
- en: How it works…
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Let's imagine that in order to test a new idea, you need to make non-trivial
    changes to your code in multiple files. You create a new branch, test your idea,
    and end up with a modified version of your code. If this idea was a dead end,
    you switch back to the original branch of your code. However, if you are happy
    with the changes, you **merge** it into the main branch.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 假设为了测试一个新想法，你需要对多个文件中的代码进行非琐碎的修改。你创建了一个新的分支，测试你的想法，并最终得到了修改过的代码版本。如果这个想法是死路一条，你可以切换回原始的代码分支。然而，如果你对这些修改感到满意，你可以**合并**它到主分支。
- en: The strength of this workflow is that the main branch can evolve independently
    from the branch with the new idea. This is particularly useful when multiple collaborators
    are working on the same repository. However, it is also a good habit to have,
    especially when there is a single contributor.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这种工作流的优势在于，主分支可以独立于包含新想法的分支进行发展。当多个协作者在同一个仓库中工作时，这特别有用。然而，这也是一种很好的习惯，尤其是当只有一个贡献者时。
- en: Merging is not always a trivial operation, as it can involve two divergent branches
    with potential conflicts. Git tries to resolve conflicts automatically, but it
    is not always successful. In this case, you need to resolve the conflicts manually.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 合并并不总是一个简单的操作，因为它可能涉及到两个分歧的分支，且可能存在冲突。Git 会尝试自动解决冲突，但并不总是成功。在这种情况下，你需要手动解决冲突。
- en: An alternative to merging is **rebasing**, which is useful when the main branch
    has changed while you were working on your branch. Rebasing your branch on the
    main branch allows you to move your branching point to a more recent point. This
    process may require you to resolve conflicts.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 合并的替代方法是**重基（rebasing）**，当你在自己的分支上工作时，如果主分支发生了变化，重基将非常有用。将你的分支重基到主分支上，可以让你将分支点移到一个更近期的点。这一过程可能需要你解决冲突。
- en: Git branches are lightweight objects. Creating and manipulating them is cheap.
    They are meant to be used frequently. It is important to perfectly grasp all related
    notions and `git` commands (notably `checkout`, `merge`, and `rebase`). The previous
    recipe contains many excellent references.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: Git 分支是轻量级对象。创建和操作它们的成本很低。它们是为了频繁使用而设计的。掌握所有相关概念和`git`命令（尤其是 `checkout`、`merge`
    和 `rebase`）非常重要。前面的食谱中包含了许多很好的参考资料。
- en: There's more…
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多……
- en: Many people have thought about effective workflows. For example, a common but
    complex workflow, called git-flow, is described at [http://nvie.com/posts/a-successful-git-branching-model/](http://nvie.com/posts/a-successful-git-branching-model/).
    However, it may be preferable to use a simpler workflow in small and mid-size
    projects, such as the one described at [http://scottchacon.com/2011/08/31/github-flow.html](http://scottchacon.com/2011/08/31/github-flow.html).
    The latter workflow elaborates on the simplistic example shown in this recipe.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 许多人曾思考过有效的工作流。例如，一个常见但复杂的工作流，叫做 git-flow，可以在 [http://nvie.com/posts/a-successful-git-branching-model/](http://nvie.com/posts/a-successful-git-branching-model/)
    中找到描述。然而，在小型和中型项目中，使用一个更简单的工作流可能更为适宜，比如 [http://scottchacon.com/2011/08/31/github-flow.html](http://scottchacon.com/2011/08/31/github-flow.html)
    中描述的工作流。后者详细阐述了这个食谱中展示的简化示例。
- en: A related notion to branching is **forking**. There can be multiple copies of
    the same repository on different servers. Imagine that you want to contribute
    to IPython's code stored on GitHub. You probably don't have the permission to
    modify their repository, but you can make a copy into your personal account—this
    is called forking. In this copy, you can create a branch and propose a new feature
    or a bug fix. Then, you can propose the IPython developers to merge your branch
    into their master branch with a **pull request**. They can review your changes,
    propose suggestions, and eventually merge your work (or not). GitHub is built
    around this idea and thereby offers a clean, modern way to collaborate on open
    source projects.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 与分支相关的概念是**分叉（forking）**。同一个仓库可以在不同的服务器上有多个副本。假设你想为存储在 GitHub 上的 IPython 代码做贡献。你可能没有权限修改他们的仓库，但你可以将其复制到你的个人账户中——这就是所谓的分叉。在这个副本中，你可以创建一个分支，并提出一个新功能或修复一个
    bug。然后，你可以提出一个**拉取请求（pull request）**，请求 IPython 的开发者将你的分支合并到他们的主分支。他们可以审核你的修改，提出建议，并最终决定是否合并你的工作（或不合并）。GitHub
    就是围绕这个想法构建的，因此提供了一种清晰、现代的方式来协作开发开源项目。
- en: Performing code reviews before merging pull requests leads to higher code quality
    in a collaborative project. When at least two people review any piece of code,
    the probability of merging bad or wrong code is reduced.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在合并 pull 请求之前进行代码审查，有助于提高协作项目中的代码质量。当至少两个人审查任何一段代码时，合并错误代码或不正确代码的可能性就会降低。
- en: There is, of course, much more to say about Git. Version control systems are
    complex and quite powerful in general, and Git is no exception. Mastering Git
    requires time and experimentation. The previous recipe contains many excellent
    references.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，关于 Git 还有很多要说的。版本控制系统通常是复杂且功能强大的，Git 也不例外。掌握 Git 需要时间和实验。之前的食谱中包含了许多优秀的参考资料。
- en: 'Here are a few further references about branches and workflows:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些关于分支和工作流的进一步参考资料：
- en: Git workflows available at [www.atlassian.com/git/workflows](http://www.atlassian.com/git/workflows)
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用的 Git 工作流，见于 [www.atlassian.com/git/workflows](http://www.atlassian.com/git/workflows)
- en: Learn Git branching at [http://pcottle.github.io/learnGitBranching/](http://pcottle.github.io/learnGitBranching/)
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 [http://pcottle.github.io/learnGitBranching/](http://pcottle.github.io/learnGitBranching/)
    学习 Git 分支
- en: The Git workflow recommended on the NumPy project (and others), described at
    [http://docs.scipy.org/doc/numpy/dev/gitwash/development_workflow.html](http://docs.scipy.org/doc/numpy/dev/gitwash/development_workflow.html)
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NumPy 项目（以及其他项目）推荐的 Git 工作流，描述于 [http://docs.scipy.org/doc/numpy/dev/gitwash/development_workflow.html](http://docs.scipy.org/doc/numpy/dev/gitwash/development_workflow.html)
- en: A post on the IPython mailing list about an efficient Git workflow, by Fernando
    Perez, available at [http://mail.scipy.org/pipermail/ipython-dev/2010-October/006746.html](http://mail.scipy.org/pipermail/ipython-dev/2010-October/006746.html)
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Fernando Perez 在 IPython 邮件列表上关于高效 Git 工作流的帖子，见于 [http://mail.scipy.org/pipermail/ipython-dev/2010-October/006746.html](http://mail.scipy.org/pipermail/ipython-dev/2010-October/006746.html)
- en: See also
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: The *Learning the basics of the distributed version control system Git* recipe
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*学习分布式版本控制系统 Git 的基础* 食谱'
- en: Ten tips for conducting reproducible interactive computing experiments
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进行可重现的互动计算实验的十个技巧
- en: In this recipe, we present ten tips that can help you conduct efficient and
    **reproducible** interactive computing experiments. These are more guidelines
    than absolute rules.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在这篇食谱中，我们提出了十个技巧，帮助你进行高效且**可重现**的互动计算实验。这些更多是指导性建议，而非绝对规则。
- en: First, we will show how you can improve your productivity by minimizing the
    time spent doing repetitive tasks and maximizing the time spent thinking about
    your core work.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将展示如何通过减少重复性任务的时间、增加思考核心工作的时间来提高生产力。
- en: Second, we will demonstrate how you can achieve more reproducibility in your
    computing work. Notably, academic research requires experiments to be reproducible
    so that any result or conclusion can be verified independently by other researchers.
    It is not uncommon for errors or manipulations in methods to result in erroneous
    conclusions that can have damaging consequences. For example, in the 2010 research
    paper in economics *Growth in a Time of Debt*, by Carmen Reinhart and Kenneth
    Rogoff, computational errors were partly responsible for a flawed study with global
    ramifications for policy makers (see [http://en.wikipedia.org/wiki/Growth_in_a_Time_of_Debt](http://en.wikipedia.org/wiki/Growth_in_a_Time_of_Debt)).
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们将展示如何在计算工作中实现更高的可重现性。值得注意的是，学术研究要求实验可重现，以便任何结果或结论可以被其他研究者独立验证。方法中的错误或操控往往会导致错误的结论，从而产生有害的后果。例如，在
    2010 年 Carmen Reinhart 和 Kenneth Rogoff 发表的经济学研究论文《债务时期的增长》中，计算错误部分导致了一项存在全球影响力的
    flawed 研究，对政策制定者产生了影响（请见 [http://en.wikipedia.org/wiki/Growth_in_a_Time_of_Debt](http://en.wikipedia.org/wiki/Growth_in_a_Time_of_Debt)）。
- en: How to do it…
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Organize your directory structure carefully and coherently. The specific structure
    does not matter. What matters is to be consistent throughout your projects regarding
    file-naming conventions, folders, subfolders, and so on. Here is a simple example:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仔细而一致地组织你的目录结构。具体的结构并不重要，重要的是在整个项目中保持文件命名规范、文件夹、子文件夹等的一致性。以下是一个简单的例子：
- en: '`my_project/`'
  id: totrans-238
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`my_project/`'
- en: '`data/`'
  id: totrans-239
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data/`'
- en: '`code/`'
  id: totrans-240
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`code/`'
- en: '`common.py`'
  id: totrans-241
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`common.py`'
- en: '`idea1.ipynb`'
  id: totrans-242
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`idea1.ipynb`'
- en: '`idea2.ipynb`'
  id: totrans-243
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`idea2.ipynb`'
- en: '`figures/`'
  id: totrans-244
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`figures/`'
- en: '`notes/`'
  id: totrans-245
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`notes/`'
- en: '`README.md`'
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`README.md`'
- en: Write notes in text files using a lightweight markup language such as **Markdown**
    ([http://daringfireball.net/projects/markdown/](http://daringfireball.net/projects/markdown/))
    or **reStructuredText** (**reST**). All meta-information related to your project,
    files, data sets, code, figures, lab notebooks, and so on, should be written down
    in text files.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用轻量级标记语言（如 **Markdown** ([http://daringfireball.net/projects/markdown/](http://daringfireball.net/projects/markdown/))
    或 **reStructuredText** (**reST**)）在文本文件中写下笔记。所有与项目、文件、数据集、代码、图形、实验室笔记本等相关的元信息应写入文本文件。
- en: Relatedly, document everything non-trivial in your code with comments, docstrings,
    and so on. You can use a documentation tool such as **Sphinx** ([http://sphinx-doc.org](http://sphinx-doc.org)).
    However, do not spend too much time documenting unstable and bleeding-edge code
    while you are working on it; it might change frequently and your documentation
    may soon be out of date. Write your code in such a way that it's easily understandable
    without comments (name your variables and functions well, use Pythonic patterns,
    and so on). See also the next recipe, *Write high-quality Python code*.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与此相关，在代码中记录所有非平凡的内容，包括注释、文档字符串等。你可以使用文档生成工具，如 **Sphinx** ([http://sphinx-doc.org](http://sphinx-doc.org))。然而，在你工作时，不要花费太多时间记录不稳定和前沿的代码；它可能频繁变化，且你的文档很快就会过时。编写代码时要确保它易于理解，无需过多注释（为变量和函数命名合理，使用
    Pythonic 编程模式等）。另请参见下一个章节，*编写高质量的 Python 代码*。
- en: Use a distributed version control system such as Git for all text-based files,
    but not binary files (except maybe for very small ones when you really need to).
    You should use one repository per project. Synchronize the repositories on a remote
    server, using a free or paid hosting provider (such as GitHub or Bitbucket) or
    your own server (your host institution might be able to set up one for you). Use
    a specific system to store and share binary data files, such as [figshare.com](http://figshare.com)
    or [datadryad.org](http://datadryad.org).
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于所有基于文本的文件，使用分布式版本控制系统，如 Git，但不要用于二进制文件（除非是非常小的文件且确实需要）。每个项目应使用一个版本库。将版本库同步到远程服务器上，使用免费或付费的托管服务提供商（如
    GitHub 或 Bitbucket）或你自己的服务器（你的主办机构可能能够为你设置一个）。使用特定的系统来存储和共享二进制数据文件，例如 [figshare.com](http://figshare.com)
    或 [datadryad.org](http://datadryad.org)。
- en: Write all your interactive computing code in IPython notebooks first and refactor
    it into standalone Python components only when it is sufficiently mature and stable.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先在 IPython 笔记本中编写所有交互式计算代码，只有在代码成熟和稳定时，才将其重构为独立的 Python 组件。
- en: For full reproducibility, make sure that you record the exact versions of all
    components in your entire software stack (operating system, Python distribution,
    modules, and so on). A possibility is to use virtual environments with **virtualenv**
    or **conda**.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了完全可重现性，确保记录下整个软件堆栈中所有组件的确切版本（操作系统、Python 发行版、模块等）。一种选择是使用虚拟环境，如 **virtualenv**
    或 **conda**。
- en: Cache long-to-compute intermediary results using Python's native **pickle**
    module, **dill** ([https://pypi.python.org/pypi/dill](https://pypi.python.org/pypi/dill)),
    or **Joblib** ([http://pythonhosted.org/joblib/](http://pythonhosted.org/joblib/)).
    Joblib notably implements a NumPy-aware **memoize** pattern (not to be confused
    with memorize), which allows you to cache the results of computationally intensive
    functions. See also the **ipycache** IPython extension ([https://github.com/rossant/ipycache](https://github.com/rossant/ipycache));
    it implements a `%%cache` cell magic in the notebook.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Python 的原生 **pickle** 模块、**dill** ([https://pypi.python.org/pypi/dill](https://pypi.python.org/pypi/dill))
    或 **Joblib** ([http://pythonhosted.org/joblib/](http://pythonhosted.org/joblib/))
    缓存长时间计算的中间结果。Joblib 特别实现了一个 NumPy 友好的 **memoize** 模式（不要与 memorize 混淆），该模式允许你缓存计算密集型函数的结果。还可以查看
    **ipycache** IPython 扩展 ([https://github.com/rossant/ipycache](https://github.com/rossant/ipycache))；它在笔记本中实现了一个
    `%%cache` 单元魔法。
- en: Note
  id: totrans-253
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Saving persistent data in Python**'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**在 Python 中保存持久化数据**'
- en: For purely internal purposes, you can use Joblib, NumPy's `save` and `savez`
    functions for arrays, and pickle for any other Python object (prefer native types
    such as lists and dictionaries rather than custom classes). For sharing purposes,
    prefer text files for small datasets (less than 10k points), for example, CSV
    for arrays, and JSON or YAML for highly structured data. For larger datasets,
    you can use HDF5 (see the *Manipulating large arrays with HDF5 and PyTables* and
    *Manipulating large heterogeneous tables with HDF5 and PyTables* recipes of [Chapter
    4](ch04.html "Chapter 4. Profiling and Optimization"), *Profiling and Optimization*).
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于纯内部使用，你可以使用Joblib、NumPy的`save`和`savez`函数来保存数组，使用pickle来保存任何其他Python对象（尽量选择原生类型，如列表和字典，而非自定义类）。对于共享用途，建议使用文本文件来保存小型数据集（少于10k个数据点），例如，使用CSV格式存储数组，使用JSON或YAML格式存储高度结构化的数据。对于较大的数据集，你可以使用HDF5（请参见[第4章](ch04.html
    "第4章：性能分析与优化")中的*使用HDF5和PyTables操作大型数组*和*使用HDF5和PyTables操作大型异构表格*的配方）。
- en: When developing and trying out algorithms on large data sets, run them and compare
    them on small portions of your data first, before moving to the full sets.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在开发并测试大数据集上的算法时，先在数据的小部分上运行并进行比较，再转向整个数据集。
- en: When running jobs in a batch, use parallel computing to take advantage of your
    multicore processing units, for example, with `IPython.parallel`, Joblib, Python's
    multiprocessing package, or any other parallel computing library.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在批量运行任务时，使用并行计算来充分利用你的多核处理单元，例如，使用`IPython.parallel`、Joblib、Python的多处理包，或任何其他并行计算库。
- en: Automate your work as much as possible with Python functions or scripts. Use
    command-line arguments for user-exposed scripts, but prefer Python functions over
    scripts when possible. On Unix systems, learn terminal commands to improve your
    productivity. For repetitive tasks on Windows or GUI-based systems, use automation
    tools such as AutoIt ([www.autoitscript.com/site/autoit/](http://www.autoitscript.com/site/autoit/))
    or AutoHotKey ([www.autohotkey.com](http://www.autohotkey.com)). Learn keyboard
    shortcuts in the programs you use a lot, or create your own shortcuts.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尽可能使用Python函数或脚本来自动化你的工作。对于用户公开的脚本，使用命令行参数，但在可能的情况下，更倾向于使用Python函数而非脚本。在Unix系统中，学习终端命令以提高工作效率。对于Windows或基于GUI的系统上的重复性任务，使用自动化工具，如AutoIt（[www.autoitscript.com/site/autoit/](http://www.autoitscript.com/site/autoit/)）或AutoHotKey（[www.autohotkey.com](http://www.autohotkey.com)）。学习你经常使用程序的快捷键，或者创建你自己的快捷键。
- en: Tip
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'For example, you can create a keyboard shortcut to launch an IPython notebook
    server in the current directory. The following link contains an AutoHotKey script,
    which does this in Windows Explorer:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以创建一个键盘快捷键来启动当前目录下的IPython笔记本服务器。以下链接包含一个AutoHotKey脚本，可以在Windows资源管理器中实现这一操作：
- en: '[http://cyrille.rossant.net/start-an-ipython-notebook-server-in-windows-explorer/](http://cyrille.rossant.net/start-an-ipython-notebook-server-in-windows-explorer/)'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://cyrille.rossant.net/start-an-ipython-notebook-server-in-windows-explorer/](http://cyrille.rossant.net/start-an-ipython-notebook-server-in-windows-explorer/)'
- en: How it works…
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The tips given in this recipe ultimately aim to optimize your workflows, in
    terms of human time, computer time, and quality. Using coherent conventions and
    structure for your code makes it easier for you to organize your work. Documenting
    everything saves everyone's time, including (eventually) yours! Should you be
    hit by a bus tomorrow, which I really hope you are not, you should ensure that
    your substitute can take over quickly, thanks to your conscientiously-written
    documentation. (You can find more information about the bus factor at [http://en.wikipedia.org/wiki/Bus_factor](http://en.wikipedia.org/wiki/Bus_factor).)
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 本文档中的建议最终旨在优化你的工作流程，涵盖人类时间、计算机时间和质量。使用一致的约定和结构来编写代码，可以让你更轻松地组织工作。记录所有内容可以节省每个人的时间，包括（最终）你自己！如果明天你被公交车撞了（我真心希望你不会），你应该确保你的替代者能够迅速接手，因为你的文档写得非常认真细致。（你可以在[http://en.wikipedia.org/wiki/Bus_factor](http://en.wikipedia.org/wiki/Bus_factor)找到更多关于“公交车因子”的信息。）
- en: Using a distributed version control system with an online hosting service makes
    it easy for you to work on the same code base from multiple locations, without
    ever worrying about backups. As you can go back in time in your code, you have
    very little chance of unintentionally breaking it.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 使用分布式版本控制系统和在线托管服务可以让你在多个地点协同工作同一个代码库，且无需担心备份问题。由于你可以回溯代码历史，因此几乎不可能无意间破坏代码。
- en: The IPython notebook is an excellent tool for reproducible interactive computing.
    It lets you keep a detailed record of your work. Also, the IPython notebook's
    ease of use means that you don't have to worry about reproducibility; just do
    all of your interactive work in notebooks, put them under version control, and
    commit regularly. Don't forget to refactor your code into independent reusable
    components.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: IPython笔记本是一个用于可重复交互计算的出色工具。它让你可以详细记录工作过程。此外，IPython笔记本的易用性意味着你无需担心可重复性；只需在笔记本中进行所有交互式工作，将其放入版本控制中，并定期提交。不要忘记将你的代码重构为独立的可重用组件。
- en: 'Be sure to optimize the time you spend in front of your computer. When working
    on an algorithm, this cycle frequently happens: you do a slight modification,
    you launch the code, get the results, make another change, and so on and so forth.
    If you need to try out a lot of changes, you should ensure that the execution
    time is fast enough (no more than a few seconds). Using advanced optimization
    techniques is not necessarily the best option at this stage of experimentation.
    You should cache your results, try out your algorithms on data subsets, and run
    your simulations with shorter durations. You can also launch batch jobs in parallel
    when you want to test different parameter values.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 确保优化你在电脑前花费的时间。当处理一个算法时，经常会发生这样的循环：你做了一点修改，运行代码，获取结果，再做另一个修改，依此类推。如果你需要尝试很多修改，你应该确保执行时间足够快（不超过几秒钟）。在实验阶段，使用高级优化技术未必是最佳选择。你应该缓存结果，在数据子集上尝试算法，并以较短的时间运行模拟。当你想测试不同的参数值时，也可以并行启动批处理任务。
- en: Finally, desperately try to avoid doing repetitive tasks. It is worth spending
    time automating such tasks when they occur frequently in your day-to-day work.
    It is more difficult to automate tasks that involve GUIs, but it is feasible thanks
    to free tools such as AutoIt or AutoHotKey.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，极力避免重复任务。对于日常工作中频繁发生的任务，花时间将其自动化是值得的。虽然涉及GUI的任务更难自动化，但借助AutoIt或AutoHotKey等免费工具，还是可以实现自动化的。
- en: There's more...
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'Here are a few references about reproducibility in computing:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些关于计算可重复性的参考资料：
- en: '*An efficient workflow for reproducible science*, a talk by Trevor Bekolay,
    available at [http://bekolay.org/scipy2013-workflow/](http://bekolay.org/scipy2013-workflow/).'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*高效的可重复科学工作流程*，Trevor Bekolay的演讲， 可在[http://bekolay.org/scipy2013-workflow/](http://bekolay.org/scipy2013-workflow/)找到。'
- en: '*Ten Simple Rules for Reproducible Computational Research*, *Sandve et al.*,
    *PLoS Computational Biology*, *2013*, available at [http://dx.doi.org/10.1371/journal.pcbi.1003285](http://dx.doi.org/10.1371/journal.pcbi.1003285).'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可重复计算研究的十条简单规则*，*Sandve等*，*PLoS计算生物学*，*2013年*，可在[http://dx.doi.org/10.1371/journal.pcbi.1003285](http://dx.doi.org/10.1371/journal.pcbi.1003285)找到。'
- en: Konrad Hinsen's blog at [http://khinsen.wordpress.com](http://khinsen.wordpress.com).
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Konrad Hinsen的博客，[http://khinsen.wordpress.com](http://khinsen.wordpress.com)。
- en: Software Carpentry, a volunteer organization running workshops for scientists;
    the workshops cover scientific programming, interactive computing, version control,
    testing, reproducibility, and task automation. You can find more information at
    [http://software-carpentry.org](http://software-carpentry.org).
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Software Carpentry是一个为科学家举办研讨会的志愿者组织；这些研讨会涵盖了科学编程、交互式计算、版本控制、测试、可重复性和任务自动化等内容。你可以在[http://software-carpentry.org](http://software-carpentry.org)找到更多信息。
- en: See also
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: The *Efficient interactive computing workflows with IPython* recipe
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*高效的交互式计算工作流程与IPython* 配方'
- en: The *Writing high-quality Python code* recipe
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*编写高质量的Python代码* 配方'
- en: Writing high-quality Python code
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写高质量的Python代码
- en: Writing code is easy. Writing high-quality code is much harder. Quality is to
    be understood both in terms of actual code (variable names, comments, docstrings,
    and so on) and architecture (functions, modules, and classes). In general, coming
    up with a well-designed code architecture is much more challenging than the implementation
    itself.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 编写代码很容易，编写高质量的代码则要困难得多。质量不仅体现在实际代码（变量名、注释、文档字符串等）上，还包括架构（函数、模块、类等）。通常，设计一个良好的代码架构比实现代码本身更具挑战性。
- en: In this recipe, we will give a few tips about how to write high-quality code.
    This is a particularly important topic in academia, as more and more scientists
    without prior experience in software development need to program.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，我们将提供一些如何编写高质量代码的建议。这是学术界一个特别重要的话题，因为越来越多没有软件开发经验的科学家需要编程。
- en: The references given at the end of this recipe contain much more details than
    what we could mention here.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程末尾给出的参考资料包含了比我们在此提到的更多细节。
- en: How to do it...
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: Take the time to learn the Python language seriously. Review the list of all
    modules in the standard library—you may discover that functions you implemented
    already exist. Learn to write *Pythonic* code, and do not translate programming
    idioms from other languages such as Java or C++ to Python.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 花时间认真学习 Python 语言。查看标准库中所有模块的列表——你可能会发现你已经实现的某些函数已经存在。学会编写 *Pythonic* 代码，不要将其他语言（如
    Java 或 C++）的编程习惯直接翻译到 Python 中。
- en: Learn common **design patterns**; these are general reusable solutions to commonly
    occurring problems in software engineering.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 学习常见的 **设计模式**；这些是针对软件工程中常见问题的通用可复用解决方案。
- en: Use assertions throughout your code (the `assert` keyword) to prevent future
    bugs (**defensive programming**).
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在代码中使用断言（`assert` 关键字）来防止未来的 bug (**防御性编程**)。
- en: Start writing your code with a bottom-up approach; write independent Python
    functions that implement focused tasks.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 采用自下而上的方法开始编写代码；编写实现专注任务的独立 Python 函数。
- en: Do not hesitate to refactor your code regularly. If your code is becoming too
    complicated, think about how you can simplify it.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不要犹豫定期重构你的代码。如果你的代码变得过于复杂，思考如何简化它。
- en: Avoid classes when you can. If you can use a function instead of a class, choose
    the function. A class is only useful when you need to store persistent state between
    function calls. Make your functions as *pure* as possible (no side effects).
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尽量避免使用类。如果可以使用函数代替类，请选择函数。类只有在需要在函数调用之间存储持久状态时才有用。尽量让你的函数保持 *纯净*（没有副作用）。
- en: In general, prefer Python native types (lists, tuples, dictionaries, and types
    from Python's collections module) over custom types (classes). Native types lead
    to more efficient, readable, and portable code.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一般来说，优先使用 Python 原生类型（列表、元组、字典和 Python collections 模块中的类型）而不是自定义类型（类）。原生类型能带来更高效、更可读和更具可移植性的代码。
- en: Choose keyword arguments over positional arguments in your functions. Argument
    names are easier to remember than argument ordering. They make your functions
    self-documenting.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在函数中选择关键字参数而不是位置参数。参数名称比参数顺序更容易记住。它们使你的函数自文档化。
- en: Name your variables carefully. Names of functions and methods should start with
    a verb. A variable name should describe what it is. A function name should describe
    what it does. The importance of naming things well cannot be overstated.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 小心命名你的变量。函数和方法的名称应以动词开头。变量名应描述它是什么。函数名应描述它做什么。命名的正确性至关重要，不能被低估。
- en: 'Every function should have a docstring describing its purpose, arguments, and
    return values, as shown in the following example. You can also look at the conventions
    chosen in popular libraries such as NumPy. The important thing is to be consistent
    within your code. You can use a markup language such as Markdown or reST:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个函数都应该有一个描述其目的、参数和返回值的文档字符串，如下例所示。你还可以查看像 NumPy 这样的流行库中所采用的约定。重要的是在你的代码中保持一致性。你可以使用
    Markdown 或 reST 等标记语言：
- en: '[PRE22]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Follow (at least partly) Guido van Rossum's Style Guide for Python, also known
    as **Python Enhancement Proposal number 8** (**PEP8**), available at [www.python.org/dev/peps/pep-0008/](http://www.python.org/dev/peps/pep-0008/).
    It is a long read, but it will help you write well-readable Python code. It covers
    many little things such as spacing between operators, naming conventions, comments,
    and docstrings. For instance, you will learn that it is considered a good practice
    to limit any line of your code to 79 characters (or 99 exceptionally if that improves
    readability). This way, your code can be correctly displayed in most situations
    (such as in a command-line interface or on a mobile device) or side by side with
    another file. Alternatively, you can decide to ignore certain rules. In general,
    following common guidelines is beneficial on projects involving many developers.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遵循（至少部分遵循）Guido van Rossum 的 Python 风格指南，也叫 **Python 增强提案第 8 号**（**PEP8**），可在
    [www.python.org/dev/peps/pep-0008/](http://www.python.org/dev/peps/pep-0008/)
    查阅。这是一本长篇指南，但它能帮助你编写可读性强的 Python 代码。它涵盖了许多小细节，如操作符之间的空格、命名约定、注释和文档字符串。例如，你会了解到将代码行限制在
    79 个字符以内（如果有助于提高可读性，可以例外为 99 个字符）是一个良好的实践。这样，你的代码可以在大多数情况下（如命令行界面或移动设备上）正确显示，或者与其他文件并排显示。或者，你可以选择忽略某些规则。总的来说，在涉及多个开发人员的项目中，遵循常见的指南是有益的。
- en: You can check your code automatically against most of the style conventions
    in PEP8 with the **pep8** Python package. Install it with `pip install pep8` and
    execute it with `pep8 myscript.py`.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以通过**pep8** Python包自动检查代码是否符合PEP8中的大多数编码风格规范。使用`pip install pep8`进行安装，并通过`pep8
    myscript.py`执行。
- en: Use a tool for static code analysis such as Pylint ([www.pylint.org](http://www.pylint.org)).
    It lets you find potential errors or low-quality code *statically*, that is, without
    running your code.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用静态代码分析工具，如Pylint（[www.pylint.org](http://www.pylint.org)）。它可以让你静态地找到潜在的错误或低质量的代码，即在不运行代码的情况下进行检查。
- en: 'Use blank lines to avoid cluttering your code (see PEP8). You can also demarcate
    sections in a long Python module with salient comments like this:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用空行来避免代码杂乱（参见PEP8）。你也可以通过显著的注释来标记一个较长Python模块的各个部分，例如：
- en: '[PRE23]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: A Python module should not contain more than a few hundreds lines of code. Having
    too many lines of code in a module may be a sign that you need to split it into
    several modules.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个Python模块不应包含超过几百行代码。一个模块的代码行数过多可能意味着你需要将其拆分成多个模块。
- en: 'Organize important projects (with tens of modules) into subpackages, for example:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将重要的项目（包含数十个模块）组织为子包，例如：
- en: '`core/`'
  id: totrans-300
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`core/`'
- en: '`io/`'
  id: totrans-301
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`io/`'
- en: '`utils/`'
  id: totrans-302
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`utils/`'
- en: '`__init__.py`'
  id: totrans-303
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__init__.py`'
- en: Take a look at how major Python projects are organized. For example, IPython's
    code is well-organized into a hierarchy of subpackages with focused roles. Reading
    the code itself is also quite instructive.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 看看主要的Python项目是如何组织的。例如，IPython的代码就很有条理，按照具有明确职责的子包层次结构进行组织。阅读这些代码本身也非常有启发性。
- en: Learn best practices to create and distribute a new Python package. Make sure
    that you know setuptools, pip, wheels, virtualenv, PyPI, and so on. Also, you
    are highly encouraged to take a serious look at conda ([http://conda.pydata.org](http://conda.pydata.org)),
    a powerful and generic packaging system created by Continuum Analytics. Packaging
    is a chaotic and rapidly evolving topic in Python, so read only the most recent
    references. There are a few references in the *There's more…* section.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 学习创建和分发新Python包的最佳实践。确保你了解setuptools、pip、wheels、virtualenv、PyPI等工具。此外，我们强烈建议你认真研究conda（[http://conda.pydata.org](http://conda.pydata.org)），这是由Continuum
    Analytics开发的一个强大且通用的打包系统。打包是Python中一个混乱且快速发展的领域，因此请只阅读最新的参考资料。在*更多内容…*部分中有一些参考资料。
- en: How it works...
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Writing readable code means that other people (or you in a few months or years)
    will understand it quicker and will be more willing to use it. It also facilitates
    bug tracking.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 编写可读的代码意味着其他人（或者几年后你自己）会更快地理解它，也更愿意使用它。这也有助于bug追踪。
- en: Modular code is also easier to understand and to reuse. Implementing your program's
    functionality in independent functions that are organized as a hierarchy of packages
    and modules is an excellent way of achieving high code quality.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 模块化代码也更容易理解和重用。将程序的功能实现为独立的函数，并按照包和模块的层次结构进行组织，是实现高质量代码的绝佳方式。
- en: It is easier to keep your code loosely coupled when you use functions instead
    of classes. Spaghetti code is really hard to understand, debug, and reuse.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 使用函数而不是类可以更容易地保持代码的松耦合。意大利面式代码（Spaghetti code）真的很难理解、调试和重用。
- en: Iterate between bottom-up and top-down approaches while working on a new project.
    Starting with a bottom-up approach lets you gain experience with the code before
    you start thinking about the overall architecture of your program. Still, make
    sure you know where you're going by thinking about how your components will work
    together.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理一个新项目时，可以在自下而上的方法和自上而下的方法之间交替进行。自下而上的方法让你在开始思考程序的整体架构之前先对代码有一定的经验。然而，仍然要确保通过思考组件如何协同工作来知道自己最终的目标。
- en: There's more...
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容…
- en: 'Much has been written on how to write beautiful code—see the following references.
    You can find many books on the subject. In the next recipe, we will cover standard
    techniques to make sure that our code not only looks nice but also works as expected:
    unit testing, code coverage, and continuous integration.'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 已经有很多关于如何编写优美代码的文章——请参阅以下参考资料。你可以找到许多关于这个主题的书籍。在接下来的教程中，我们将介绍确保代码不仅看起来漂亮，而且能够按预期工作的标准技术：单元测试、代码覆盖率和持续集成。
- en: 'Here are a few references:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些参考资料：
- en: '*Python Cookbook*, by David Beazley and Brian K. Jones, with many Python 3
    advanced recipes, available at [http://shop.oreilly.com/product/0636920027072.do](http://shop.oreilly.com/product/0636920027072.do)'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《Python 厨房秘籍》*，由 David Beazley 和 Brian K. Jones 编写，包含许多 Python 3 高级配方，可在 [http://shop.oreilly.com/product/0636920027072.do](http://shop.oreilly.com/product/0636920027072.do)
    获取'
- en: '*The Hitchhiker''s Guide to Python!*, available at [http://docs.python-guide.org/en/latest/](http://docs.python-guide.org/en/latest/)'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《Python 旅行者指南！》*，可在 [http://docs.python-guide.org/en/latest/](http://docs.python-guide.org/en/latest/)
    获取'
- en: Design patterns on Wikipedia, available at [http://en.wikipedia.org/wiki/Software_design_pattern](http://en.wikipedia.org/wiki/Software_design_pattern)
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维基百科上的设计模式，详见 [http://en.wikipedia.org/wiki/Software_design_pattern](http://en.wikipedia.org/wiki/Software_design_pattern)
- en: Design patterns in Python, described at [https://github.com/faif/python-patterns](https://github.com/faif/python-patterns)
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 设计模式，描述于 [https://github.com/faif/python-patterns](https://github.com/faif/python-patterns)
- en: Coding standards of Tahoe-LAFS, available at [https://tahoe-lafs.org/trac/tahoe-lafs/wiki/CodingStandards](https://tahoe-lafs.org/trac/tahoe-lafs/wiki/CodingStandards)
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Tahoe-LAFS 编码标准，详见 [https://tahoe-lafs.org/trac/tahoe-lafs/wiki/CodingStandards](https://tahoe-lafs.org/trac/tahoe-lafs/wiki/CodingStandards)
- en: '*How to be a great software developer*, by Peter Nixey, available at [http://peternixey.com/post/83510597580/how-to-be-a-great-software-developer](http://peternixey.com/post/83510597580/how-to-be-a-great-software-developer)'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《如何成为一名伟大的软件开发者》*，由 Peter Nixey 编写，可在 [http://peternixey.com/post/83510597580/how-to-be-a-great-software-developer](http://peternixey.com/post/83510597580/how-to-be-a-great-software-developer)
    阅读'
- en: '*Why you should write buggy software with as few features as possible*, a talk
    by Brian Granger, available at [www.youtube.com/watch?v=OrpPDkZef5I](http://www.youtube.com/watch?v=OrpPDkZef5I)'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《为什么你应该用尽可能少的功能编写有缺陷的软件》*，由 Brian Granger 主讲，可在 [www.youtube.com/watch?v=OrpPDkZef5I](http://www.youtube.com/watch?v=OrpPDkZef5I)
    观看'
- en: '*The Hitchhiker''s Guide to Packaging*, available at [http://guide.python-distribute.org](http://guide.python-distribute.org)'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《程序包指南》*，可在 [http://guide.python-distribute.org](http://guide.python-distribute.org)
    获取'
- en: '*Python Packaging User Guide*, available at [http://python-packaging-user-guide.readthedocs.org](http://python-packaging-user-guide.readthedocs.org)'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Python 包装用户指南*，可在 [http://python-packaging-user-guide.readthedocs.org](http://python-packaging-user-guide.readthedocs.org)
    获取'
- en: See also
  id: totrans-323
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: The *Ten tips for conducting reproducible interactive computing experiments*
    recipe
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《进行可重复交互式计算实验的十个技巧》* 配方'
- en: The *Writing unit tests with nose* recipe
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 nose 编写单元测试* 配方'
- en: Writing unit tests with nose
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 nose 编写单元测试
- en: Manual testing is essential to ensuring that our software works as expected
    and does not contain critical bugs. However, manual testing is severely limited
    because bugs may be introduced every time a change is made in the code. We can't
    possibly expect to manually test our entire program at every commit.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 手动测试对确保我们的软件按预期工作并且不包含关键性错误至关重要。然而，手动测试存在严重限制，因为每次更改代码时，可能会引入新的缺陷。我们不可能在每次提交时都手动测试整个程序。
- en: 'Nowadays, automated testing is a standard practice in software engineering.
    In this recipe, we will briefly cover important aspects of automated testing:
    unit tests, test-driven development, test coverage, and continuous integration.
    Following these practices is absolutely necessary in order to produce high-quality
    software.'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 现如今，自动化测试已经成为软件工程中的标准实践。在这个配方中，我们将简要介绍自动化测试的重要方面：单元测试、测试驱动开发、测试覆盖率和持续集成。遵循这些实践对于开发高质量的软件是绝对必要的。
- en: Getting ready
  id: totrans-329
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Python has a native unit-testing module that you can readily use (`unittest`).
    Other third-party unit testing packages exist, such as py.test or nose, which
    we have chosen here. nose makes it a bit easier to write a test suite, and it
    has a library of external plugins. Your users don't need that extra dependency
    unless they want to run the test suite themselves. You can install nose with `pip
    install nose`.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: Python 有一个原生的单元测试模块（`unittest`），你可以直接使用。还有其他第三方单元测试包，如 py.test 或 nose，我们在这里选择了
    nose。nose 使得编写测试套件变得稍微容易一些，并且拥有一个外部插件库。除非用户自己想运行测试套件，否则他们不需要额外的依赖。你可以通过 `pip install
    nose` 安装 nose。
- en: How to do it...
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: In this example, we will write a unit test for a function that downloads a file
    from a URL. A testing suite should run and successfully pass even in the absence
    of a network connection. We take care of that by fooling Python's `urllib` module
    with a mock HTTP server.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将为一个从 URL 下载文件的函数编写单元测试。即使在没有网络连接的情况下，测试套件也应能够运行并成功通过。我们通过使用一个模拟的 HTTP
    服务器来欺骗 Python 的 `urllib` 模块，从而解决这一问题。
- en: Note
  id: totrans-333
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The code snippets used in this recipe have been written for Python 3\. A few
    changes are required to make them work with Python 2, and we have indicated these
    changes in the code. The versions for Python 2 and Python 3 are both available
    on the book's website.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱中使用的代码片段是为Python 3编写的。要使它们在Python 2中运行，需要做一些更改，我们在代码中已标明了这些更改。Python 2和Python
    3的版本都可以在本书的网站上找到。
- en: You may also be interested in the `requests` module; it provides a much simpler
    API for HTTP requests ([http://docs.python-requests.org/en/latest/](http://docs.python-requests.org/en/latest/)).
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能对`requests`模块也感兴趣；它为HTTP请求提供了一个更简单的API（[http://docs.python-requests.org/en/latest/](http://docs.python-requests.org/en/latest/)）。
- en: 'We create a file named `datautils.py` with the following code:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个名为`datautils.py`的文件，里面包含以下代码：
- en: '[PRE24]'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We create a file named `test_datautils.py` with the following code:'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个名为`test_datautils.py`的文件，里面包含以下代码：
- en: '[PRE25]'
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, to launch the tests, we execute the following command in a terminal:'
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，为了启动测试，我们在终端中执行以下命令：
- en: '[PRE26]'
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Our first unit test passes! Now, let''s add a new test. We add some code at
    the end of `test_datautils.py`:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的第一个单元测试通过了！现在，让我们添加一个新的测试。我们在`test_datautils.py`文件的末尾添加一些代码：
- en: '[PRE27]'
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We launch the tests again with the `nosetests` command:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`nosetests`命令再次启动测试：
- en: '[PRE28]'
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The second test fails. In a real-world scenario, we might need to debug the
    program. This should be easy because the bug is isolated in a single test function.
    Here, by inspecting the traceback error and the code, we find that the bug results
    from the requested URL not ending with a proper file name. Thus, the inferred
    file name, `os.path.basename(url)`, is empty. Let''s fix this by replacing the
    `download` function in `datautils.py` with the following function:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个测试失败了。在实际应用中，我们可能需要调试程序。这应该不难，因为错误被隔离在一个单独的测试函数中。在这里，通过检查回溯错误和代码，我们发现错误是由于请求的URL没有以正确的文件名结尾。因此，推断的文件名`os.path.basename(url)`为空。我们通过以下方法来修复这个问题：将`datautils.py`中的`download`函数替换为以下函数：
- en: '[PRE29]'
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Finally, let''s run the tests again:'
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们再次运行测试：
- en: '[PRE30]'
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Tip
  id: totrans-350
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: By default, `nosetests` hides the standard output (unless errors occur). If
    you want the standard output to show up, use `nosetests --nocapture`.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`nosetests`会隐藏标准输出（除非发生错误）。如果你希望标准输出显示出来，可以使用`nosetests --nocapture`。
- en: How it works...
  id: totrans-352
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: A `test_xxx.py` module should accompany every Python module named `xxx.py`.
    This testing module contains functions (unit tests) that execute and test functionality
    implemented in the `xxx.py` module.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 每个名为`xxx.py`的Python模块应该有一个对应的`test_xxx.py`模块。这个测试模块包含执行并测试`xxx.py`模块中功能的函数（单元测试）。
- en: By definition, a given unit test must focus on one very specific functionality.
    All unit tests should be completely independent. Writing a program as a collection
    of well-tested, mostly decoupled units forces you to write modular code that is
    more easily maintainable.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 根据定义，一个给定的单元测试必须专注于一个非常具体的功能。所有单元测试应该是完全独立的。将程序编写为一组经过充分测试、通常是解耦的单元，迫使你编写更易于维护的模块化代码。
- en: However, sometimes your module's functions require preliminary work to run (for
    example, setting up the environment, creating data files, or setting up a web
    server). The unit testing framework can handle this; just write `setup()` and
    `teardown()` functions (called **fixtures**), and they will be called at the beginning
    and at the end of the test module, respectively. Note that the state of the system
    environment should be exactly the same before and after a testing module runs
    (for example, temporarily created files should be deleted in `teardown`).
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时你的模块函数在运行之前需要一些预处理工作（例如，设置环境、创建数据文件或设置Web服务器）。单元测试框架可以处理这些事情；只需编写`setup()`和`teardown()`函数（称为**fixtures**），它们将分别在测试模块开始和结束时被调用。请注意，测试模块运行前后的系统环境状态应该完全相同（例如，临时创建的文件应在`teardown`中删除）。
- en: Here, the `datautils.py` module contains a single function, `download`, that
    accepts a URL as an argument, downloads the file, and saves it locally. This module
    comes with a testing module named `test_datautils.py`. You should choose the same
    convention in your program (`test_<modulename>` for the testing module of `modulename`).
    This testing module contains one or several functions prefixed with `test_`. This
    is how nose automatically discovers the unit tests across your project. nose also
    accepts other similar conventions.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`datautils.py` 模块包含一个名为 `download` 的函数，该函数接受一个 URL 作为参数，下载文件并将其保存到本地。这个模块还带有一个名为
    `test_datautils.py` 的测试模块。你应该在你的程序中使用相同的约定（`test_<modulename>` 作为 `modulename`
    模块的测试模块）。这个测试模块包含一个或多个以 `test_` 为前缀的函数。nose 就是通过这种方式自动发现项目中的单元测试。nose 也接受其他类似的约定。
- en: Tip
  id: totrans-357
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: nose runs all tests it can find in your project, but you can, of course, have
    more fine-grained control over the tests to run. Type `nosetests --help` to get
    the list of all options. You can also check out the documentation at [http://nose.readthedocs.org/en/latest/testing.html](http://nose.readthedocs.org/en/latest/testing.html).
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: nose 会运行它在你的项目中找到的所有测试，但你当然可以更精确地控制要运行的测试。键入 `nosetests --help` 可以获取所有选项的列表。你也可以查阅
    [http://nose.readthedocs.org/en/latest/testing.html](http://nose.readthedocs.org/en/latest/testing.html)
    上的文档。
- en: The testing module also contains the `setup` and `teardown` functions, which
    are automatically detected as fixtures by nose. A custom HTTP handler object is
    created within the `setup` function. This object captures all HTTP requests, even
    those with fictional URLs. The `setup` function then moves into a test folder
    (created with the `tempfile` module) to avoid potential conflicts between downloaded
    files and existing files. In general, unit tests should not leave any trace; this
    is how we ensure that they are fully reproducible. Likewise, the `teardown` function
    deletes the test folder.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 测试模块还包含 `setup` 和 `teardown` 函数，这些函数会被 nose 自动识别为测试夹具。在 `setup` 函数中创建一个自定义的
    HTTP 处理程序对象。该对象会捕获所有 HTTP 请求，即使是那些具有虚构 URL 的请求。接着，`setup` 函数会进入一个测试文件夹（该文件夹是通过
    `tempfile` 模块创建的），以避免下载的文件和现有文件之间可能的冲突。一般来说，单元测试不应该留下任何痕迹；这也是我们确保测试完全可重复的方式。同样，`teardown`
    函数会删除测试文件夹。
- en: Tip
  id: totrans-360
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: In Python 3.2 and higher versions, you can also use `tempfile.TemporaryDirectory`
    to create a temporary directory.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 3.2 及更高版本中，你还可以使用 `tempfile.TemporaryDirectory` 来创建一个临时目录。
- en: The first unit test downloads a file from a mock URL and checks whether it contains
    the expected contents. By default, a unit test passes if it does not raise an
    exception. This is where `assert` statements, which raise exceptions if the statement
    is `False`, are useful. nose also comes with convenient routines and decorators
    for precisely determining the conditions under which a particular unit test is
    expected to pass or fail (for example, it should raise a particular exception
    to pass, or it should run in less than *X* seconds, and so on).
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个单元测试从一个虚拟 URL 下载文件，并检查它是否包含预期的内容。默认情况下，如果单元测试没有抛出异常，则视为通过。这时，`assert` 语句就非常有用，如果语句为
    `False`，则会抛出异常。nose 还提供了方便的例程和装饰器，用于精确地确定某个单元测试期望通过或失败的条件（例如，它应该抛出某个特定的异常才算通过，或者它应该在
    *X* 秒内完成等）。
- en: Tip
  id: totrans-363
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Further convenient assert-like functions are provided by NumPy (see [http://docs.scipy.org/doc/numpy/reference/routines.testing.html](http://docs.scipy.org/doc/numpy/reference/routines.testing.html)).
    They are especially useful when working with arrays. For example, `np.testing.assert_allclose(x,
    y)` asserts that the `x` and `y` arrays are almost equal, up to a given precision
    that can be specified.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 提供了更多方便的类似 assert 的函数（请参见 [http://docs.scipy.org/doc/numpy/reference/routines.testing.html](http://docs.scipy.org/doc/numpy/reference/routines.testing.html)）。这些函数在处理数组时特别有用。例如，`np.testing.assert_allclose(x,
    y)` 会断言 `x` 和 `y` 数组几乎相等，精度可以指定。
- en: Writing a full testing suite takes time. It imposes strong (but good) constraints
    on your code's architecture. It's a real investment, but it is always profitable
    in the long run. Also, knowing that your project is backed by a full testing suite
    is a real load off your mind.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 编写完整的测试套件需要时间。它对你代码的架构提出了严格（但良好的）约束。这是一次真正的投资，但从长远来看总是值得的。此外，知道你的项目有一个完整的测试套件支持，真是让人放心。
- en: First, thinking about unit tests from the beginning forces you to think about
    a modular architecture. It is really difficult to write unit tests for a monolithic
    program full of interdependencies.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，从一开始就考虑单元测试迫使你思考模块化架构。对于一个充满相互依赖的单体程序，编写单元测试是非常困难的。
- en: Second, unit tests make it easier for you to find and fix bugs. If a unit test
    fails after introducing a change in the program, isolating and reproducing the
    bugs becomes trivial.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，单元测试使得发现和修复bug变得更加容易。如果在程序中引入了更改后，某个单元测试失败，隔离并重现bug就变得非常简单。
- en: Third, unit tests help you avoid **regressions**, that is, fixed bugs that silently
    reappear in a later version. When you discover a new bug, you should write a specific
    failing unit test for it. To fix it, make this test pass. Now, if the bug reappears
    later, this unit test will fail and you will immediately be able to address it.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，单元测试帮助你避免**回归**，即已修复的bug在后续版本中悄然重现。当你发现一个新bug时，应该为它编写一个特定的失败单元测试。修复它时，让这个测试通过。现在，如果这个bug后来再次出现，这个单元测试将会失败，你就可以立即解决它。
- en: Let's say that you write a complex program in several layers, with an *n+1*
    layer based on an *n* layer. Having a battery of successful unit tests for the
    *n* layer makes you confident that it works as expected. When working on the *n+1*
    layer, you can focus on this layer instead of constantly worrying whether the
    layer below works or not.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你编写了一个多层次的复杂程序，每一层的基础上都有一个基于*第n*层的*n+1*层。有了一套成功的单元测试作为*第n*层的保障，你就能确信它按预期工作。当你在处理*n+1*层时，你可以专注于这一层，而不必总是担心下面一层是否有效。
- en: Unit testing is not the whole story, as it just concerns independent components.
    Further levels of testing are required in order to ensure good integration of
    the components within the program.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试并不是全部，它只关注独立的组件。为了确保程序中各组件的良好集成，还需要进一步的测试层级。
- en: There's more...
  id: totrans-371
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Unit testing is a wide topic, and we only scratched the surface in this recipe.
    We give some further information here.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试是一个广泛的话题，我们在这个配方中仅仅触及了表面。这里提供了一些进一步的信息。
- en: Test coverage
  id: totrans-373
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试覆盖率
- en: 'Using unit tests is good. However, measuring **test coverage** is even better:
    it quantifies how much of our code is being covered by your testing suite. Ned
    Batchelder''s **coverage** module ([http://nedbatchelder.com/code/coverage/](http://nedbatchelder.com/code/coverage/))
    does precisely this. It integrates very well with nose.'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 使用单元测试是好事，但测量**测试覆盖率**更好：它量化了我们的代码有多少被你的测试套件覆盖。Ned Batchelder的**coverage**模块（[http://nedbatchelder.com/code/coverage/](http://nedbatchelder.com/code/coverage/)）正是做这件事。它与nose非常好地集成。
- en: 'First, install coverage with `pip install coverage`. Then run your testing
    suite with the following command:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，使用`pip install coverage`安装coverage。然后使用以下命令运行你的测试套件：
- en: '[PRE31]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This command instructs nose to launch your testing suite with coverage measurement
    for the `datautils` package only.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令指示nose仅为`datautils`包启动测试套件并进行覆盖率测量。
- en: The [coveralls.io](http://coveralls.io) service brings test-coverage features
    to a continuous integration server (refer to the *Unit testing and continuous
    integration* section). It works seamlessly with GitHub.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '[coveralls.io](http://coveralls.io)服务将测试覆盖率功能引入持续集成服务器（参见*单元测试与持续集成*部分）。它与GitHub无缝集成。'
- en: Workflows with unit testing
  id: totrans-379
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 带有单元测试的工作流
- en: Note the particular workflow we have used in this example. After writing our
    `download` function, we created a first unit test that passed. Then we created
    a second test that failed. We investigated the issue and fixed the function. The
    second test passed. We could continue writing more and more complex unit tests,
    until we are confident that the function works as expected in most situations.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们在这个例子中使用的特定工作流。在编写`download`函数后，我们创建了第一个通过的单元测试。然后我们创建了第二个失败的测试。我们调查了问题并修复了函数，第二个测试通过了。我们可以继续编写越来越复杂的单元测试，直到我们确信该函数在大多数情况下按预期工作。
- en: Tip
  id: totrans-381
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Run `nosetests --pdb` to drop into the Python debugger on failures. This is
    quite convenient to find out quickly why a unit test fails.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`nosetests --pdb`以在失败时进入Python调试器。这对于快速找出单元测试失败的原因非常方便。
- en: This is **test-driven development**, which consists of writing unit tests *before*
    writing the actual code. This workflow forces us to think about what our code
    does and how one uses it, instead of how it is implemented.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是**测试驱动开发**，它要求在编写实际代码之前编写单元测试。这个工作流迫使我们思考代码的功能和使用方式，而不是它是如何实现的。
- en: Unit testing and continuous integration
  id: totrans-384
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单元测试与持续集成
- en: A good habit to get into is running the full testing suite of our project at
    every commit. In fact, it is even possible to do this completely transparently
    and automatically through **continuous integration**. We can set up a server that
    automatically runs our testing suite in the cloud at every commit. If a test fails,
    we get an automatic e-mail telling us what the problem is so that we can fix it.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 养成每次提交时运行完整测试套件的好习惯。实际上，我们甚至可以通过 **持续集成** 完全透明且自动地做到这一点。我们可以设置一个服务器，在每次提交时自动在云端运行我们的测试套件。如果某个测试失败，我们会收到一封自动邮件，告诉我们问题所在，以便我们修复。
- en: 'There are many continuous integration systems and services: Jenkins/Hudson,
    [https://drone.io](https://drone.io), [http://stridercd.com](http://stridercd.com),
    [https://travis-ci.org](https://travis-ci.org), and many others. Some of them
    play well with GitHub projects. For example, to use Travis CI with a GitHub project,
    create an account on Travis CI, link your GitHub project to this account, and
    then add a `.travis.yml` file with various settings in your repository (see the
    additional details in the following references).'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多持续集成系统和服务：Jenkins/Hudson、[https://drone.io](https://drone.io)、[http://stridercd.com](http://stridercd.com)、[https://travis-ci.org](https://travis-ci.org)
    等等。其中一些与 GitHub 项目兼容。例如，要在 GitHub 项目中使用 Travis CI，可以在 Travis CI 上创建账户，将 GitHub
    项目与此账户关联，然后在仓库中添加一个 `.travis.yml` 文件，其中包含各种设置（有关更多详情，请参见以下参考资料）。
- en: In conclusion, unit testing, code coverage, and continuous integration are standard
    practices that should be used for all significant projects.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，单元测试、代码覆盖率和持续集成是所有重大项目应遵循的标准实践。
- en: 'Here are a few references:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些参考资料：
- en: Test-driven development, available at [http://en.wikipedia.org/wiki/Test-driven_development](http://en.wikipedia.org/wiki/Test-driven_development)
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试驱动开发，详见 [http://en.wikipedia.org/wiki/Test-driven_development](http://en.wikipedia.org/wiki/Test-driven_development)
- en: '*Untested code is broken code: test automation in enterprise software delivery*,
    by Martin Aspeli, available at [www.deloittedigital.com/eu/blog/untested-code-is-broken-code-test-automation-in-enterprise-software-deliver](http://www.deloittedigital.com/eu/blog/untested-code-is-broken-code-test-automation-in-enterprise-software-deliver)'
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*未经测试的代码是坏代码：企业软件交付中的测试自动化*，由 Martin Aspeli 编写，详见 [www.deloittedigital.com/eu/blog/untested-code-is-broken-code-test-automation-in-enterprise-software-deliver](http://www.deloittedigital.com/eu/blog/untested-code-is-broken-code-test-automation-in-enterprise-software-deliver)'
- en: Documentation of Travis CI in Python, at [http://about.travis-ci.org/docs/user/languages/python/](http://about.travis-ci.org/docs/user/languages/python/)
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Travis CI 在 Python 中的文档，见 [http://about.travis-ci.org/docs/user/languages/python/](http://about.travis-ci.org/docs/user/languages/python/)
- en: Debugging your code with IPython
  id: totrans-392
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 IPython 调试代码
- en: Debugging is an integral part of software development and interactive computing.
    A widespread debugging technique consists of placing `print` statements in various
    places in the code. Who hasn't done this? It is probably the simplest solution,
    but it is certainly not the most efficient (it's the poor man's debugger).
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 调试是软件开发和交互式计算的一个不可或缺的部分。一种常见的调试技术是在代码中的各个地方放置 `print` 语句。谁没做过这个呢？它可能是最简单的解决方案，但肯定不是最有效的（它是穷人版的调试器）。
- en: IPython is perfectly adapted for debugging, and the integrated debugger is quite
    easy to use (actually, IPython merely offers a nice interface to the native Python
    debugger `pdb`). In particular, tab completion works in the IPython debugger.
    This recipe describes how to debug code with IPython.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: IPython 完美适配调试，集成的调试器非常易于使用（实际上，IPython 只是提供了一个友好的界面来访问原生的 Python 调试器 `pdb`）。特别是，IPython
    调试器中支持 Tab 补全。本节内容描述了如何使用 IPython 调试代码。
- en: Note
  id: totrans-395
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Earlier versions of the IPython notebook did not support the debugger, that
    is, the debugger could be used in the IPython terminal and Qt console, but not
    in the notebook. This issue was fixed in IPython 1.0.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 早期版本的 IPython 笔记本不支持调试器，也就是说，调试器可以在 IPython 终端和 Qt 控制台中使用，但在笔记本中无法使用。这个问题在 IPython
    1.0 中得到了解决。
- en: How to do it...
  id: totrans-397
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: There are two not-mutually exclusive ways of debugging code in Python. In the
    post-mortem mode, the debugger steps into the code as soon as an exception is
    raised so that we can investigate what caused it. In the step-by-step mode, we
    can stop the interpreter at a breakpoint and resume its execution step by step.
    This process allows us to check carefully the state of our variables as our code
    is executed.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '在 Python 中有两种非互斥的调试方式。在事后调试模式下，一旦抛出异常，调试器会立即进入代码，这样我们就可以调查导致异常的原因。在逐步调试模式下，我们可以在断点处停止解释器，并逐步恢复执行。这个过程使我们能够在代码执行时仔细检查变量的状态。  '
- en: Both methods can actually be used simultaneously; we can do step-by-step debugging
    in the post-mortem mode.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '两种方法其实可以同时使用；我们可以在事后调试模式下进行逐步调试。  '
- en: The post-mortem mode
  id: totrans-400
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '事后调试模式  '
- en: When an exception is raised within IPython, execute the `%debug` magic command
    to launch the debugger and step into the code. Also, the `%pdb on` command tells
    IPython to launch the debugger automatically as soon as an exception is raised.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '当在 IPython 中抛出异常时，执行 `%debug` 魔法命令启动调试器并逐步进入代码。并且，`%pdb on` 命令告诉 IPython 一旦抛出异常，就自动启动调试器。  '
- en: 'Once you are in the debugger, you have access to several special commands,
    the most important ones being listed here:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '一旦进入调试器，你可以访问几个特殊命令，下面列出的是最重要的一些：  '
- en: '`p varname` **prints** the value of a variable'
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`p varname` **打印**一个变量的值  '
- en: '`w` shows your current location within the stack'
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`w` 显示你在堆栈中的当前位置  '
- en: '`u` goes **up** in the stack'
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`u` 在堆栈中向**上**跳  '
- en: '`d` goes **down** in the stack'
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`d` 在堆栈中向**下**跳  '
- en: '`l` shows the **lines** of code around your current location'
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`l` 显示你当前位置周围的**代码行**  '
- en: '`a` shows the **arguments** of the current function'
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`a` 显示当前函数的**参数**  '
- en: The call stack contains the list of all active functions at a given location
    in the code's execution. You can easily navigate up and down the stack to inspect
    the values of the function arguments. Although quite simple to use, this mode
    should let you resolve most of your bugs. For more complex problems, you may need
    to do step-by-step debugging.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '调用堆栈包含代码执行当前位置的所有活动函数的列表。你可以轻松地在堆栈中上下导航，检查函数参数的值。虽然这个模式使用起来相当简单，但它应该能帮助你解决大部分问题。对于更复杂的问题，可能需要进行逐步调试。  '
- en: Step-by-step debugging
  id: totrans-410
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '步骤调试  '
- en: 'You have several options to start the step-by-step debugging mode. First, in
    order to put a breakpoint somewhere in your code, insert the following commands:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '你有几种方法来启动逐步调试模式。首先，为了在代码中某处设置断点，插入以下命令：  '
- en: '[PRE32]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Second, you can run a script from IPython with the following command:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '其次，你可以使用以下命令从 IPython 运行一个脚本：  '
- en: '[PRE33]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This command runs the `script.py` file under the control of the debugger with
    a breakpoint on line 20 in `extscript.py` (which is imported at some point by
    `script.py`). Finally, you can do step-by-step debugging as soon as you are in
    the debugger.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '这个命令在调试器控制下运行 `script.py` 文件，并在 `extscript.py` 的第 20 行设置一个断点（该文件在某个时刻由 `script.py`
    导入）。最后，一旦进入调试器，你就可以开始逐步调试。  '
- en: 'Step-by-step debugging consists of precisely controlling the course of the
    interpreter. Starting from the beginning of a script or from a breakpoint, you
    can resume the execution of the interpreter with the following commands:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '步骤调试就是精确控制解释器的执行过程。从脚本开始或者从断点处，你可以使用以下命令恢复解释器的执行：  '
- en: '`s` executes the current line and stops as soon as possible afterwards (**step-by-step**
    debugging, that is, the most fine-grained execution pattern)'
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s` 执行当前行并尽快停下来（**逐步**调试，也就是最细粒度的执行模式）  '
- en: '`n` continues the execution until the **next** line in the current function
    is reached'
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`n` 继续执行直到到达当前函数中的**下一**行  '
- en: '`r` continues the execution until the current function **returns**'
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`r` 继续执行直到当前函数**返回**  '
- en: '`c` **continues** the execution until the next breakpoint is reached'
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`c` **继续**执行直到到达下一个断点'
- en: '`j 30` brings you to line 30 in the current file'
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`j 30` 将你带到当前文件的第 30 行  '
- en: You can add breakpoints dynamically from within the debugger using the `b` command
    or with `tbreak` (temporary breakpoint). You can also clear all or some of the
    breakpoints, enable or disable them, and so on. You can find the full details
    of the debugger at [https://docs.python.org/3/library/pdb.html](https://docs.python.org/3/library/pdb.html).
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过 `b` 命令或 `tbreak`（临时断点）动态添加断点。你还可以清除所有或部分断点，启用或禁用它们，等等。你可以在 [https://docs.python.org/3/library/pdb.html](https://docs.python.org/3/library/pdb.html)
    找到调试器的完整细节。
- en: There's more...
  id: totrans-423
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: To debug your code with IPython, you typically need to execute it first with
    IPython, for example, with `%run`. However, you may not always have an easy way
    of doing this. For instance, your program may run with a custom command-line Python
    script, it may be launched by a complex bash script, or it may be integrated within
    a GUI. In these cases, you can embed an IPython interpreter at any point in your
    code (launched by Python), instead of running your whole program with IPython
    (which may be overkill if you just need to debug a small portion of your code).
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 IPython 调试代码，你通常需要先通过 IPython 执行它，例如使用 `%run`。然而，你可能并不总是有一个简单的方法来做到这一点。例如，你的程序可能通过一个自定义的命令行
    Python 脚本运行，可能是由一个复杂的 bash 脚本启动，或者集成在一个 GUI 中。在这些情况下，你可以在代码的任何位置嵌入一个 IPython 解释器（由
    Python 启动），而不是用 IPython 运行整个程序（如果你只需要调试代码的一小部分，使用整个程序可能会显得过于复杂）。
- en: 'To embed IPython within your program, simply insert the following commands
    somewhere in your code:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 IPython 嵌入到你的程序中，只需在代码中的某个地方插入以下命令：
- en: '[PRE34]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: When your Python program reaches this code, it will pause and launch an interactive
    IPython terminal at this specific point. You will then be able to inspect all
    local variables, run any code you want, and possibly debug your code before resuming
    normal execution.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的 Python 程序执行到这段代码时，它会暂停并在该特定位置启动一个交互式的 IPython 终端。你将能够检查所有局部变量，执行你想要的任何代码，并且在恢复正常执行之前，可能会调试你的代码。
- en: Tip
  id: totrans-428
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: rfoo, available at [https://code.google.com/p/rfoo/](https://code.google.com/p/rfoo/),
    lets you inspect and modify the namespace of a running Python script remotely.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: rfoo，访问链接 [https://code.google.com/p/rfoo/](https://code.google.com/p/rfoo/)，让你可以远程检查和修改正在运行的
    Python 脚本的命名空间。
- en: GUI debuggers
  id: totrans-430
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: GUI 调试器
- en: Most Python IDEs offer graphical debugging features (see the *Efficient interactive
    computing workflows with IPython* recipe). A GUI can sometimes be more convenient
    than a command-line debugger. Let's also mention Winpdb ([winpdb.org](http://winpdb.org)),
    a graphical platform-independent Python debugger.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 Python 集成开发环境（IDE）都提供图形化调试功能（参见 *使用 IPython 的高效交互式计算工作流*）。有时候，GUI 比命令行调试器更为方便。我们还可以提到
    Winpdb（[winpdb.org](http://winpdb.org)），一个图形化、平台无关的 Python 调试器。
