- en: Chapter 5. Creating Dynamic Maps
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 5 章：创建动态地图
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下菜谱：
- en: Accessing the map canvas
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问地图画布
- en: Changing the map units
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改地图单位
- en: Iterating over layers
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遍历图层
- en: Symbolizing a vector layer
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 矢量图层符号化
- en: Rendering a single band raster using a color ramp algorithm
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用颜色渐变算法渲染单波段栅格
- en: Creating a complex vector layer symbol
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建复杂的矢量图层符号
- en: Using icons as vector layer symbols
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用图标作为矢量图层符号
- en: Creating a graduated vector layer symbol
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建渐变矢量图层符号
- en: Creating a categorized vector layer symbol
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建分类矢量图层符号
- en: Creating a map bookmark
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建地图书签
- en: Navigating to a map bookmark
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导航到地图书签
- en: Setting scale-based visibility for a layer
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置图层的基于比例的可见性
- en: Using SVG for layer symbols
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 SVG 作为图层符号
- en: Using pie charts for symbols
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用饼图作为符号
- en: Using the OpenStreetMap service
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 OpenStreetMap 服务
- en: Using the Bing aerial image service
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Bing 航拍影像服务
- en: Adding real-time weather data from OpenWeatherMap
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 OpenWeatherMap 添加实时天气数据
- en: Labeling a feature
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特征标注
- en: Changing map layer transparency
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改地图图层透明度
- en: Adding standard map tools to the canvas
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将标准地图工具添加到画布上
- en: Using a map tool to draw points on the canvas
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用地图工具在画布上绘制点
- en: Using a map tool to draw polygons or lines on the canvas
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用地图工具在画布上绘制多边形或线条
- en: Building a custom selection tool
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建自定义选择工具
- en: Creating a mouse coordinate tracking tool
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建鼠标坐标跟踪工具
- en: Introduction
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In this chapter, we'll programmatically create dynamic maps using Python to
    control every aspect of the QGIS map canvas. We'll learn how to use custom symbology,
    labels, map bookmarks, and even real-time data. We'll also go beyond the canvas
    to create custom map tools. You will see that every aspect of QGIS is up for grabs
    with Python, to write your own application. Sometimes, the PyQGIS API may not
    directly support your application goal, but there is nearly always a way to accomplish
    what you set out to do with QGIS.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用 Python 编程创建动态地图，以控制 QGIS 地图画布的各个方面。我们将学习如何使用自定义符号、标签、地图书签，甚至实时数据。我们还将超越画布创建自定义地图工具。您将看到
    Python 可以控制 QGIS 的各个方面，以编写您自己的应用程序。有时，PyQGIS API 可能不会直接支持您的应用程序目标，但几乎总是有办法使用 QGIS
    完成您设定的目标。
- en: Accessing the map canvas
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问地图画布
- en: Maps in QGIS are controlled through the map canvas. In this recipe, we'll access
    the canvas and then check one of its properties to ensure that we have control
    over the object.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: QGIS 中的地图通过地图画布进行控制。在本菜谱中，我们将访问画布，然后检查其属性之一以确保我们对对象有控制权。
- en: Getting ready
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The only thing you need to do for this recipe is to open QGIS and select **Python
    Console** from the **Plugins** menu.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，您需要做的唯一事情是打开 QGIS 并从 **插件** 菜单中选择 **Python 控制台**。
- en: How to do it...
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We will assign the map canvas to a variable named `canvas`. Then, we''ll check
    the `size` property of the canvas to get its size in pixels. To do this, perform
    the following steps:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把地图画布分配给一个名为 `canvas` 的变量。然后，我们将检查画布的 `size` 属性以获取其像素大小。为此，请执行以下步骤：
- en: 'Enter the following line in the QGIS **Python Console**:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 QGIS **Python 控制台**中输入以下行：
- en: '[PRE0]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, to ensure that we have properly accessed the canvas, check its size in
    pixels using the following line of code:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，为了确保我们已经正确访问了画布，请使用以下代码行检查其像素大小：
- en: '[PRE1]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Verify that QGIS returns a `QSize` object that contains the canvas''s pixel
    size, similar to the following format:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证 QGIS 是否返回一个包含画布像素大小的 `QSize` 对象，格式类似于以下内容：
- en: '[PRE2]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: How it works...
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Everything in QGIS centers on the canvas. The canvas is part of the QGIS interface
    or iface API. Anything you see on the screen when using QGIS is generated through
    the iface API. Note that the `iface` object is only available to scripts and plugins.
    When you are building a standalone application, you must initialize your own `QgsMapCanvas`
    object.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: QGIS 中的所有内容都集中在画布上。画布是 QGIS 界面或 iface API 的一部分。使用 QGIS 时你在屏幕上看到的所有内容都是通过 iface
    API 生成的。请注意，`iface` 对象仅对脚本和插件可用。当你构建独立应用程序时，你必须初始化自己的 `QgsMapCanvas` 对象。
- en: Changing the map units
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更改地图单位
- en: Changing the units of measurement on a map, or map units, is a very common operation,
    depending on the purpose of your map or the standards of your organization or
    country. In this recipe, we'll read the map units used by QGIS and then change
    them for your project.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的地图目的或您组织或国家的标准，更改地图单位或地图单位是一个非常常见的操作。在本菜谱中，我们将读取 QGIS 使用的地图单位，然后更改它们以适应您的项目。
- en: Getting ready
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The only preparation you need for this recipe is to open QGIS and select **Python
    Console** from the **Plugins** menu.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为此菜谱，您唯一需要的准备是打开 QGIS 并从**插件**菜单中选择**Python 控制台**。
- en: How to do it...
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: In the following steps, we'll access the map canvas, check the map unit type,
    and then alter it to a different setting.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下步骤中，我们将访问地图画布，检查地图单位类型，并将其更改为不同的设置。
- en: 'First, access the map canvas, as follows:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，按照以下方式访问地图画布：
- en: '[PRE3]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, get the map units type. By default, it should be the number **2**:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，获取地图单位类型。默认情况下，它应该是数字**2**：
- en: '[PRE4]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, let''s set the map units to meters using the built-in enumerator:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们使用内置枚举器将地图单位设置为米：
- en: '[PRE5]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How it works...
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'QGIS has seven different map units, which are enumerated in the following order:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: QGIS 有七个不同的地图单位，按以下顺序列出：
- en: 0 Meters
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 0 米
- en: 1 Feet
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 1 英尺
- en: 2 Degrees
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 2 度
- en: 3 UnknownUnit
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 3 未知单位
- en: 4 DecimalDegrees
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 4 十进制度
- en: 5 DegreesMinutesSeconds
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 5 度分秒
- en: 6 DegreesDecimalMinutes
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 6 十进制度分
- en: 7 NauticalMiles
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 7 海里
- en: It is important to note that changing the map units just changes the unit of
    measurement for the measurement tool and the display in the status bar; it does
    not change the underlying map projection. You'll notice this difference if you
    try to run an operation in the Processing Toolbox, which depends on projected
    data in meters, if the data is unprojected. The most common use case for changing
    map units is to switch between imperial and metric units, depending on the user's
    preference.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，更改地图单位仅更改测量工具和状态栏显示的测量单位；它不会更改底层地图投影。如果您尝试在依赖于未投影数据的米投影数据上运行 Processing
    工具箱中的操作，您将注意到这种差异。更改地图单位的最常见用例是根据用户的偏好在英制和公制单位之间切换。
- en: Iterating over layers
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 遍历层
- en: For many GIS operations, you need to loop through the map layers to look for
    specific information or to apply a change to all the layers. In this recipe, we'll
    loop through the layers and get information about them.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多 GIS 操作，您需要遍历地图层以查找特定信息或对所有层应用更改。在这个菜谱中，我们将遍历层并获取它们的信息。
- en: Getting ready
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We'll need two layers in the same map projection to perform this recipe. You
    can download the first layer as a ZIP file from [https://geospatialpython.googlecode.com/files/MSCities_Geo_Pts.zip](https://geospatialpython.googlecode.com/files/MSCities_Geo_Pts.zip).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要两个具有相同地图投影的层来执行此菜谱。您可以从[https://geospatialpython.googlecode.com/files/MSCities_Geo_Pts.zip](https://geospatialpython.googlecode.com/files/MSCities_Geo_Pts.zip)下载第一个层作为
    ZIP 文件。
- en: You can download the second zipped layer from [https://geospatialpython.googlecode.com/files/Mississippi.zip](https://geospatialpython.googlecode.com/files/Mississippi.zip).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[https://geospatialpython.googlecode.com/files/Mississippi.zip](https://geospatialpython.googlecode.com/files/Mississippi.zip)下载第二个压缩层。
- en: Unzip both of these layers into a directory named `ms` within your `qgis_data`
    directory.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 将这两个层解压缩到您`qgis_data`目录下的名为`ms`的目录中。
- en: How to do it...
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We will add the layers to the map through the map registry. Then, we will iterate
    through the map layers and print each layer''s title. To do this, perform the
    following steps:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过地图注册表将层添加到地图中。然后，我们将遍历地图层并打印每一层的标题。为此，执行以下步骤：
- en: 'First, let''s open the polygon and the point layer using the QGIS **Python
    Console**:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们使用 QGIS **Python 控制台**打开多边形和点层：
- en: '[PRE6]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, get the map layer registry instance:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，获取地图层注册实例：
- en: '[PRE7]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now add the vector layers to the map:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将矢量层添加到地图中：
- en: '[PRE8]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then, we retrieve the layers as an interator:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将层作为迭代器检索：
- en: '[PRE9]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Finally, we loop through the layers and print the titles:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们遍历层并打印标题：
- en: '[PRE10]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Verify that you can read the layer titles in the **Python Console**, similar
    to the following format:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确认您可以在**Python 控制台**中读取层标题，格式类似于以下：
- en: '[PRE11]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: How it works...
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Layers in QGIS are independent of the map canvas until you add them to the map
    layer registry. They have an ID as soon as they are created. When added to the
    map, they become part of the canvas, where they pick up titles, symbols, and many
    other attributes. In this case, you can use the map layer registry to iterate
    through them and access them to change the way they look or to add and extract
    data.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在 QGIS 中，层在您将它们添加到地图层注册表之前与地图画布独立。一旦创建，它们就有一个 ID。当添加到地图中时，它们成为画布的一部分，在那里它们获取标题、符号和许多其他属性。在这种情况下，您可以使用地图层注册表遍历它们并访问它们以更改它们的外观或添加和提取数据。
- en: Symbolizing a vector layer
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 符号化矢量层
- en: The appearance of the layers on a QGIS map is controlled by its symbology. A
    layer's symbology includes the renderer and one or more symbols. The renderer
    provides rules dictating the appearance of symbols. The symbols describe properties,
    including color, shape, size, and linewidth. In this recipe, we'll load a vector
    layer, change its symbology, and refresh the map.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: QGIS地图上图层的外观由其符号控制。图层的符号包括渲染器和一个或多个符号。渲染器提供规则，以规定符号的外观。符号描述属性，包括颜色、形状、大小和线宽。在本食谱中，我们将加载一个矢量图层，更改其符号，并刷新地图。
- en: Getting ready
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Download the following zipped shapefile and extract it to your `qgis_data` directory
    into a folder named `ms` from [https://geospatialpython.googlecode.com/files/Mississippi.zip](https://geospatialpython.googlecode.com/files/Mississippi.zip).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 下载以下压缩的shapefile并将其提取到您的`qgis_data`目录中的`ms`文件夹中，从[https://geospatialpython.googlecode.com/files/Mississippi.zip](https://geospatialpython.googlecode.com/files/Mississippi.zip)。
- en: How to do it...
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We will load a layer, add it to the map layer registry, change the layer''s
    color, and then refresh the map. To do this, perform the following steps:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将加载一个图层，将其添加到地图图层注册表中，更改图层的颜色，然后刷新地图。为此，执行以下步骤：
- en: 'First, using the QGIS **Python Console**, we must import the `QtGui` library
    in order to access the `QColor` object that is used to describe colors in the
    PyQGIS API:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，使用QGIS **Python控制台**，我们必须导入`QtGui`库，以便访问用于在PyQGIS API中描述颜色的`QColor`对象：
- en: '[PRE12]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Next, we create our vector layer, as follows:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们创建我们的矢量图层，如下所示：
- en: '[PRE13]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then, we add it to the map layer registry:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将它添加到地图图层注册表中：
- en: '[PRE14]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, we access the layer''s symbol list through the layer''s renderer object:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们通过图层的渲染器对象访问图层的符号列表：
- en: '[PRE15]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, we reference the first symbol, which in this case is the only symbol:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们引用第一个符号，在这种情况下，这是唯一的符号：
- en: '[PRE16]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Once we have the symbol, we can set its color:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们有了符号，我们就可以设置其颜色：
- en: '[PRE17]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We must remember to repaint the layer in order to force the update:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须记住重新绘制图层以强制更新：
- en: '[PRE18]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: How it works...
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Changing the color of a layer sounds simple, but remember that in QGIS, anything
    you see must be altered through the canvas API. Therefore, we add the layer to
    the map and access the layer's symbology through its renderer. The map canvas
    is rendered as a raster image. The renderer is responsible for turning the layer
    data into a bitmap image, so the presentation information for a layer is stored
    with its renderer.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 改变图层的颜色听起来很简单，但请记住，在QGIS中，您看到的任何内容都必须通过画布API进行更改。因此，我们将图层添加到地图中，并通过其渲染器访问图层的符号。地图画布被渲染为位图图像。渲染器负责将图层数据转换为位图图像，因此图层的表示信息与其渲染器一起存储。
- en: Rendering a single band raster using a color ramp algorithm
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用颜色渐变算法渲染单波段栅格
- en: A color ramp allows you to render a raster using just a few colors to represent
    different ranges of cell values that have similar meaning, in order to group them.
    The approach that will be used in this recipe is the most common way to render
    elevation data.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 颜色渐变允许您使用仅几种颜色来表示具有相似意义的单元格值的不同范围，以便将它们分组。本食谱中将使用的方法是渲染高程数据最常见的方式。
- en: Getting ready
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You can download a sample DEM from [https://geospatialpython.googlecode.com/files/dem.zip](https://geospatialpython.googlecode.com/files/dem.zip),
    which you can unzip in a directory named `rasters` in your `qgis_data` directory.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[https://geospatialpython.googlecode.com/files/dem.zip](https://geospatialpython.googlecode.com/files/dem.zip)下载一个示例DEM，您可以在`qgis_data`目录中的`rasters`目录中解压缩它。
- en: How to do it...
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'In the following steps, we will set up objects to color a raster, create a
    list establishing the color ramp ranges, apply the ramp to the layer renderer,
    and finally add the layer to the map. To do this, we need to perform the following
    steps:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下步骤中，我们将设置对象以着色栅格，创建一个建立颜色渐变范围的列表，将渐变应用于图层渲染器，并最终将图层添加到地图中。为此，我们需要执行以下步骤：
- en: 'First, we import the `QtGui` library for color objects in the QGIS **Python
    Console**:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们在QGIS **Python控制台**中导入用于颜色对象的`QtGui`库：
- en: '[PRE19]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, we load the raster layer, as follows:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们加载栅格图层，如下所示：
- en: '[PRE20]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, we create a generic raster shader object:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们创建一个通用的栅格着色器对象：
- en: '[PRE21]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Then, we instantiate the specialized ramp shader object:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们实例化专门的渐变着色器对象：
- en: '[PRE22]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We must name a type for the ramp shader. In this case, we use an `INTERPOLATED`
    shader:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须为渐变着色器命名一个类型。在这种情况下，我们使用一个`INTERPOLATED`着色器：
- en: '[PRE23]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, we''ll create a list of our color ramp definitions:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将创建我们的颜色渐变定义列表：
- en: '[PRE24]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then, we populate the list with color ramp values that correspond to elevation
    value ranges:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们填充颜色渐变值列表，这些值对应于高程值范围：
- en: '[PRE25]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now we assign the color ramp to our shader:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将颜色渐变分配给我们的着色器：
- en: '[PRE26]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, we tell the generic raster shader to use the color ramp:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们告诉通用栅格着色器使用颜色渐变：
- en: '[PRE27]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Next, we create a raster renderer object with the shader:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们使用着色器创建一个栅格渲染器对象：
- en: '[PRE28]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We assign the renderer to the raster layer:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将渲染器分配给栅格图层：
- en: '[PRE29]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Finally, we add the layer to the canvas in order to view it:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将图层添加到画布上以便查看：
- en: '[PRE30]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: How it works…
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: While it takes a stack of four objects to create a color ramp, this recipe demonstrates
    how flexible the PyQGIS API is. Typically, the more objects it takes to accomplish
    an operation in QGIS, the richer the API is, giving you the flexibility to make
    complex maps.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然创建颜色渐变需要四个对象，但这个菜谱展示了PyQGIS API的灵活性。通常，在QGIS中完成操作所需的对象越多，API就越丰富，这为你提供了制作复杂地图的灵活性。
- en: Notice that in each `ColorRampItem` object, you specify a starting elevation
    value, the color, and a label as the string. The range for the color ramp ends
    at any value less than the following item. So, in this case, the first color will
    be assigned to the cells with a value between 400 and 899\. The following screenshot
    shows the applied color ramp.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在每一个`ColorRampItem`对象中，你指定一个起始高程值、颜色和作为字符串的标签。颜色渐变的范围在下一个项目之前的任何值结束。因此，在这种情况下，第一个颜色将被分配给值在400到899之间的单元格。以下截图显示了应用的颜色渐变。
- en: '![How it works…](img/00040.jpeg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的…](img/00040.jpeg)'
- en: Creating a complex vector layer symbol
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建复杂矢量图层符号
- en: The true power of QGIS symbology lies in its ability to stack multiple symbols
    in order to create a single complex symbol. This ability makes it possible to
    create virtually any type of map symbol you can imagine. In this recipe, we'll
    merge two symbols to create a single symbol and begin unlocking the potential
    of complex symbols.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: QGIS符号化的真正力量在于其能够堆叠多个符号以创建单个复杂符号的能力。这种能力使得创建几乎任何你可以想象到的地图符号成为可能。在这个菜谱中，我们将合并两个符号以创建单个符号，并开始解锁复杂符号的潜力。
- en: Getting ready
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we will need a line shapefile, which you can download and extract
    from [https://geospatialpython.googlecode.com/svn/paths.zip](https://geospatialpython.googlecode.com/svn/paths.zip).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们需要一个线形状文件，你可以从[https://geospatialpython.googlecode.com/svn/paths.zip](https://geospatialpython.googlecode.com/svn/paths.zip)下载并提取。
- en: Add this shapefile to a directory named `shapes` in your `qgis_data` directory.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 将此形状文件添加到`qgis_data`目录中名为`shapes`的目录。
- en: How to do it…
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Using the **QGISPythonConsole**,we will create a classic railroad line symbol
    by placing a series of short, rotated line markers along a regular line symbol.
    To do this, we need to perform the following steps:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**QGISPythonConsole**，我们将通过在规则线符号上放置一系列短旋转线标记来创建一个经典的铁路线符号。为此，我们需要执行以下步骤：
- en: 'First, we load our line shapefile:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们加载我们的线形状文件：
- en: '[PRE31]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Next, we get the symbol list and reference the default symbol:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们获取符号列表并引用默认符号：
- en: '[PRE32]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Then, we create a shorter variable name for the symbol layer registry:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们为符号层创建一个更短的变量名：
- en: '[PRE33]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, we set up the line style for a simple line using a Python dictionary:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们使用Python字典设置简单线的样式：
- en: '[PRE34]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Then, we create an abstract symbol layer for a simple line:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们为简单线创建一个抽象符号层：
- en: '[PRE35]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We instantiate a symbol layer from the abstract layer using the line style
    properties:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用线样式属性从抽象层实例化一个符号层：
- en: '[PRE36]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, we add the symbol layer to the layer''s symbol:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将符号层添加到层的符号中：
- en: '[PRE37]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now, in order to create the rails on the railroad, we begin building a marker
    line style with another Python dictionary, as follows:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，为了在铁路上创建轨道，我们开始使用另一个Python字典构建一个标记线样式，如下所示：
- en: '[PRE38]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Then, we create the marker line abstract symbol layer for the second symbol:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们为第二个符号创建标记线抽象符号层：
- en: '[PRE39]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We instatiate the symbol layer, as shown here:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建符号层，如下所示：
- en: '[PRE40]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now, we must work with a subsymbol that defines the markers along the marker
    line:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们必须与定义标记线上的标记的子符号一起工作：
- en: '[PRE41]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We must delete the default subsymbol:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须删除默认的子符号：
- en: '[PRE42]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, we set up the style for our rail marker using a dictionary:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们使用字典设置我们的轨道标记的样式：
- en: '[PRE43]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now, we repeat the process of building a symbol layer and add it to the subsymbol:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们重复构建符号层并将其添加到子符号的过程：
- en: '[PRE44]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Then, we add the subsymbol to the second symbol layer:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将子符号添加到第二个符号层：
- en: '[PRE45]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Finally, we add the layer to the map:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将图层添加到地图上：
- en: '[PRE46]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: How it works…
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: First, we must create a simple line symbol. The marker line by itself will render
    correctly, but the underlying simple line will be a randomly chosen color. We
    must also change the subsymbol of the marker line because the default subsymbol
    is a simple circle.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须创建一个简单的线符号。标记线本身将正确渲染，但底层的简单线将是一个随机选择的颜色。我们还必须更改标记线的子符号，因为默认的子符号是一个简单的圆圈。
- en: Using icons as vector layer symbols
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用图标作为矢量层符号
- en: In addition to the default symbol types available in QGIS, you can also use
    TrueType fonts as map symbols. TrueType fonts are scalable vector graphics that
    can be used as point markers. In this recipe, we'll create this type of symbol.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 除了QGIS中可用的默认符号类型外，您还可以使用TrueType字体作为地图符号。TrueType字体是可缩放矢量图形，可以用作点标记。在本例中，我们将创建此类符号。
- en: Getting ready
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You can download the point shapefile used in this recipe from [https://geospatialpython.googlecode.com/files/NYC_MUSEUMS_GEO.zip](https://geospatialpython.googlecode.com/files/NYC_MUSEUMS_GEO.zip).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[https://geospatialpython.googlecode.com/files/NYC_MUSEUMS_GEO.zip](https://geospatialpython.googlecode.com/files/NYC_MUSEUMS_GEO.zip)下载本例中使用的点形状文件。
- en: Extract it to your `qgis_data` directory in a folder named `nyc`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 将其提取到您的`qgis_data`目录中名为`nyc`的文件夹中。
- en: How to do it…
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We will load a point shapefile as a layer and then use the character `G` in
    a freely-available font called `Webdings`, which is probably already on your system,
    to render a building icon on each point in the layer. To do this, we need to perform
    the following steps:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将加载一个点形状文件作为图层，然后使用一个名为`Webdings`的免费字体中的字符`G`，这个字体可能已经存在于您的系统中，在每个点渲染建筑图标。为此，我们需要执行以下步骤：
- en: 'First, we''ll define the path to our point shapefile:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将定义点形状文件的路径：
- en: '[PRE47]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Then, we''ll load the vector layer:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将加载矢量层：
- en: '[PRE48]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now, we''ll use a Python dictionary to define the font properties:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将使用Python字典来定义字体属性：
- en: '[PRE49]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now, we''ll create a font symbol layer:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个字体符号层：
- en: '[PRE50]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Then, we''ll change the default symbol layer of the vector layer to our font''s
    symbol information:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将矢量层的默认符号层更改为我们的字体符号信息：
- en: '[PRE51]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Finally, we''ll add the layer to the map:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将图层添加到地图中：
- en: '[PRE52]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: How it works…
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The font marker symbol layer is just another type of marker layer; however,
    the range of possibilities with vector fonts is far broader than the built-in
    fonts in QGIS. Many industries define standard cartographic symbols using customized
    fonts as markers.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 字体标记符号层只是另一种标记层；然而，与QGIS内置字体相比，矢量字体的可能性范围更广。许多行业使用自定义字体作为标记来定义标准地图符号。
- en: Creating a graduated vector layer symbol renderer
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建渐变向量层符号渲染器
- en: A graduated vector layer symbol renderer is the vector equivalent of a raster
    color ramp. You can group features into similar ranges and use a limited set of
    colors to visually identify these ranges. In this recipe, we'll render a graduated
    symbol using a polygon shapefile.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 毕业向量层符号渲染器是栅格颜色渐变的矢量等价物。您可以将要素分组到相似的范围内，并使用有限的颜色集来视觉上识别这些范围。在本例中，我们将使用多边形形状文件渲染渐变符号。
- en: Getting ready
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You can download a shapefile containing a set of urban area polygons from [https://geospatialpython.googlecode.com/files/MS_UrbanAnC10.zip](https://geospatialpython.googlecode.com/files/MS_UrbanAnC10.zip).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[https://geospatialpython.googlecode.com/files/MS_UrbanAnC10.zip](https://geospatialpython.googlecode.com/files/MS_UrbanAnC10.zip)下载包含一组城市区域多边形的形状文件。
- en: Extract this file to a directory named `ms` in your `qgis_data` directory.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 将此文件提取到您的`qgis_data`目录中名为`ms`的目录中。
- en: How to do it...
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We will classify each urban area by population size using a graduated symbol,
    as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用渐变符号根据人口规模对每个城市区域进行分类，如下所示：
- en: First, we import the `QColor` object to build our color range.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们导入`QColor`对象来构建我们的颜色范围。
- en: '[PRE53]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Next, we load our polygon shapefile as a vector layer:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将加载我们的多边形形状文件作为矢量层：
- en: '[PRE54]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Now, we build some nested Python tuples that define the symbol graduation.
    Each item in the tuple contains a range label, range start value, range end value,
    and a color name, as shown here:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们构建一些嵌套的Python元组，定义符号的渐变。元组中的每个项目包含一个范围标签、范围起始值、范围结束值和颜色名称，如下所示：
- en: '[PRE55]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Then, we establish a Python list to hold our QGIS renderer objects:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们创建一个Python列表来保存我们的QGIS渲染器对象：
- en: '[PRE56]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Next, we loop through our range list, build the QGIS symbols, and add them
    to the renderer list:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将遍历我们的范围列表，构建QGIS符号，并将它们添加到渲染器列表中：
- en: '[PRE57]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Now, reference the field name containing the population values in the shapefile
    attributes:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，引用包含形状文件属性中人口值的字段名称：
- en: '[PRE58]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Then, we create the renderer:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们创建渲染器：
- en: '[PRE59]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'We assign the renderer to the layer:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将渲染器分配给图层：
- en: '[PRE60]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Finally, we add the map to the layer:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将地图添加到图层：
- en: '[PRE61]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: How it works...
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作...
- en: The approach to using a graduated symbol for a vector layer is very similar
    to the color ramp shader for a raster layer. You can have as many ranges as you'd
    like by extending the Python tuple that is used to build the ranges. Of course,
    you can also build your own algorithms by programmatically examining the data
    fields first and then dividing up the values in equal intervals or some other
    scheme.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 使用渐变符号为矢量图层的方法与栅格图层中的颜色渐变着色器非常相似。你可以通过扩展用于构建范围的Python元组来拥有你想要的任意多个范围。当然，你也可以通过首先以编程方式检查数据字段，然后以相等间隔或其他方案划分值来构建自己的算法。
- en: Creating a categorized vector layer symbol
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建分类矢量图层符号
- en: A categorized vector layer symbol allows you to create distinct categories with
    colors and labels for unique features. This approach is typically used for datasets
    with a limited number of unique types of features. In this recipe, we'll categorize
    a vector layer into three different categories.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 分类矢量图层符号允许你为独特特征创建具有颜色和标签的不同类别。这种方法通常用于具有有限独特类型特征的集合。在这个食谱中，我们将矢量图层分类为三个不同的类别。
- en: Getting ready
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we'll use a land use shapefile, which you can download from
    [https://geospatialpython.googlecode.com/svn/landuse_shp.zip](https://geospatialpython.googlecode.com/svn/landuse_shp.zip).
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个食谱，我们将使用一个土地利用shapefile，你可以从[https://geospatialpython.googlecode.com/svn/landuse_shp.zip](https://geospatialpython.googlecode.com/svn/landuse_shp.zip)下载。
- en: Extract it to a directory named `hancock` in your `qgis_data` directory.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 将其提取到你的`qgis_data`目录中名为`hancock`的目录。
- en: How to do it...
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We will load the vector layer, create three categories of land use, and render
    them as categorized symbols. To do this, we need to perform the following steps:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将加载矢量图层，创建三个土地利用类别，并将它们渲染为分类符号。为此，我们需要执行以下步骤：
- en: 'First, we need to import the `QColor` object for our category colors:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要导入`QColor`对象以用于我们的分类颜色：
- en: '[PRE62]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Then, we load the vector layer:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们加载矢量图层：
- en: '[PRE63]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Next, we''ll create our three land use categories using a Python dictionary
    with a field value as the key, color name, and label:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将使用Python字典创建我们的三个土地利用分类，其中字段值作为键，颜色名称和标签：
- en: '[PRE64]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Now, we can build our categorized renderer items:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以构建我们的分类渲染项：
- en: '[PRE65]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'We name the field containing the land use value:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们命名包含土地利用值的字段：
- en: '[PRE66]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Next, we build the renderer:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们构建渲染器：
- en: '[PRE67]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'We add the renderer to the layer:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将渲染器添加到图层：
- en: '[PRE68]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Finally, we add the categorized layer to the map:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将分类图层添加到地图：
- en: '[PRE69]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: How it works...
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作...
- en: 'There are only slight differences in the configurations of the various types
    of renderers in QGIS. Setting them up by first defining the properties of the
    renderer using native Python objects makes your code easier to read and ultimately
    manage. The following map image illustrates the categorized symbol in this recipe:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: QGIS中各种渲染器类型的配置只有细微差别。通过首先使用原生Python对象定义渲染器的属性来设置它们，可以使你的代码更容易阅读和管理。以下地图图像展示了本食谱中的分类符号：
- en: '![How it works...](img/00041.jpeg)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/00041.jpeg)'
- en: Creating a map bookmark
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建地图书签
- en: Map bookmarks allow you to save a location on a map in QGIS, so you can quickly
    jump to the points you need to view repeatedly without manually panning and zooming
    the map. PyQGIS does not contain API commands to read, write, and zoom to bookmarks.
    Fortunately, QGIS stores the bookmarks in an SQLite database. Python has a built-in
    SQLite library that we can use to manipulate bookmarks using the database API.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 地图书签允许你在QGIS中保存地图上的位置，这样你可以快速跳转到需要重复查看的点，而无需手动平移和缩放地图。PyQGIS不包含用于读取、写入和缩放到书签的API命令。幸运的是，QGIS将书签存储在SQLite数据库中。Python有一个内置的SQLite库，我们可以使用数据库API来操作书签。
- en: Getting ready
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You can download a census tract polygon shapefile to use with this recipe from
    [https://geospatialpython.googlecode.com/files/GIS_CensusTract.zip](https://geospatialpython.googlecode.com/files/GIS_CensusTract.zip).
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从[https://geospatialpython.googlecode.com/files/GIS_CensusTract.zip](https://geospatialpython.googlecode.com/files/GIS_CensusTract.zip)下载一个人口普查区多边形shapefile，用于与这个食谱一起使用。
- en: Extract it to your `qgis_data` directory. We are going to create a bookmark
    that uses an area of interest within this shapefile, so you can manually load
    the bookmark in order to test it out.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 将其提取到你的`qgis_data`目录中。我们将创建一个使用此shapefile中感兴趣区域的书签，这样你可以手动加载书签以进行测试。
- en: How to do it...
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We will access the QGIS configuration variables to get the path of the user
    database, which stores the bookmarks. Then, we''ll connect to this database and
    execute a SQL query that inserts a bookmark. Finally, we''ll commit the changes
    to the database, as follows:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将访问QGIS配置变量以获取用户数据库的路径，该数据库存储书签。然后，我们将连接到这个数据库并执行一个插入书签的SQL查询。最后，我们将更改提交到数据库，如下所示：
- en: 'First, using the QGIS **PythonConsole**, we must import Python''s built-in
    SQLite library:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，使用QGIS的**Python控制台**，我们必须导入Python的内置SQLite库：
- en: '[PRE70]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Next, get the path to the database:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，获取数据库的路径：
- en: '[PRE71]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Now, we connect to the database:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们连接到数据库：
- en: '[PRE72]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Then, we need a database cursor to manipulate the database:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要一个数据库游标来操作数据库：
- en: '[PRE73]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Now, we can execute the SQL query, which is a string. In the `VALUES` portion
    of the query, we will leave the bookmark ID as `NULL` but give it a name, then
    we leave the project name `NULL` and set the extents, as follows:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以执行SQL查询，它是一个字符串。在查询的`VALUES`部分，我们将书签ID留为`NULL`但给它一个名称，然后我们将项目名称留为`NULL`并设置范围，如下所示：
- en: '[PRE74]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Then, we commit the changes:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们提交更改：
- en: '[PRE75]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: To test the map bookmark, load the census tract layer onto the map by dragging
    and dropping it from your filesystem into QGIS.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了测试地图书签，通过从您的文件系统拖放到QGIS中，将人口普查区层加载到地图上。
- en: Next, click on the **View** menu in QGIS and select **ShowBookmarks**.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在QGIS中点击**视图**菜单并选择**显示书签**。
- en: Then, select the **BSL bookmark** and click on the **ZoomTo** button.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，选择**BSL书签**并点击**ZoomTo**按钮。
- en: Verify that the map snapped to an area of interest close to the polygons, with
    OBJECTIDs from 4625 to 4627.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证地图是否已捕捉到接近多边形的感兴趣区域，其OBJECTID从4625到4627。
- en: How it works...
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Even when QGIS doesn't provide a high-level API, you can almost always use Python
    to dig deeper and access the information you want. QGIS is built on open source
    software, therefore no part of the program is truly off-limits.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 即使QGIS没有提供高级API，您几乎总是可以使用Python深入挖掘并访问您想要的信息。QGIS建立在开源软件之上，因此程序中的任何部分都不是真正受限的。
- en: Navigating to a map bookmark
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导航到地图书签
- en: Map bookmarks store important locations on a map, so you can quickly find them
    later. You can programmatically navigate to bookmarks using the Python `sqlite3`
    library in order to access the bookmarks database table in the QGIS user database
    and then use the PyQGIS canvas API.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 地图书签在地图上存储重要位置，因此您可以快速找到它们。您可以使用Python的`sqlite3`库编程导航到书签，以便访问QGIS用户数据库中的书签数据库表，然后使用PyQGIS画布API。
- en: Getting ready
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will use a census tract layer to test out the bookmark navigation. You can
    download the zipped shapefile from [https://geospatialpython.googlecode.com/files/GIS_CensusTract.zip](https://geospatialpython.googlecode.com/files/GIS_CensusTract.zip).
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用人口普查区层来测试书签导航。您可以从[https://geospatialpython.googlecode.com/files/GIS_CensusTract.zip](https://geospatialpython.googlecode.com/files/GIS_CensusTract.zip)下载压缩的shapefile。
- en: Manually load this layer into QGIS after extracting it from the ZIP file. Also,
    make sure that you have completed the previous recipe, *Creating a map bookmark*.
    You will need a bookmark named BSL for an area of interest in this shapefile.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在从ZIP文件中提取后，手动将此层加载到QGIS中。同时，请确保您已完成了之前的配方，*创建地图书签*。您将需要一个名为BSL的书签来定位此shapefile中的感兴趣区域。
- en: How to do it...
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We will retrieve a bookmark from the QGIS user database and then set the map''s
    extents to this bookmark. To do this, perform the following steps:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从QGIS用户数据库中检索一个书签，并将地图的范围设置为这个书签。为此，执行以下步骤：
- en: 'First, import the Python `sqlite3` library:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，导入Python的`sqlite3`库：
- en: '[PRE76]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Next, get the location of the user database from the QGIS data:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，从QGIS数据中获取用户数据库的位置：
- en: '[PRE77]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Now, we connect to the database:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们连接到数据库：
- en: '[PRE78]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Then, we need a database cursor to run queries:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要一个数据库游标来运行查询：
- en: '[PRE79]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Now, we can get the bookmark information for the bookmark named **BSL**:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以获取名为**BSL**的书签信息：
- en: '[PRE80]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Now, we''ll get the complete results from the query:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将从查询中获取完整的结果：
- en: '[PRE81]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Then, we split the values of the result into multiple variables:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将结果值拆分为多个变量：
- en: '[PRE82]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Now, we can use the bookmark to create a QGIS extent rectangle:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以使用书签来创建一个QGIS范围矩形：
- en: '[PRE83]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Next, we reference the map canvas:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们引用地图画布：
- en: '[PRE84]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Finally, we set the extent of the canvas to the rectangle and then refresh
    the canvas:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将画布的范围设置为矩形并刷新画布：
- en: '[PRE85]'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: How it works...
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Reading and writing bookmarks with SQLite is straightforward even though its
    not a part of the main PyQGIS API. Notice that bookmarks have a placeholder for
    a project name, which you can use to filter bookmarks by project if needed.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 使用SQLite读取和写入书签非常简单，尽管它不是PyQGIS主API的一部分。请注意，书签有一个用于项目名称的占位符，您可以使用它根据需要按项目过滤书签。
- en: Setting scale-based visibility for a layer
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为图层设置基于比例的可见性
- en: Sometimes, a GIS layer only makes sense when it is displayed at a certain scale,
    for example, a complex road network. PyQGIS supports scale-based visibility to
    programmatically set the scale range, in which a layer is displayed. In this recipe,
    we'll investigate scale-dependent layers.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，GIS图层只有在特定比例下显示时才有意义，例如，复杂的道路网络。PyQGIS支持基于比例的可见性，可以编程设置图层显示的比例范围。在本菜谱中，我们将研究基于比例的图层。
- en: Getting ready
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need the sample census tract shapefile available as a ZIP file from
    [https://geospatialpython.googlecode.com/files/GIS_CensusTract.zip](https://geospatialpython.googlecode.com/files/GIS_CensusTract.zip).
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要从[https://geospatialpython.googlecode.com/files/GIS_CensusTract.zip](https://geospatialpython.googlecode.com/files/GIS_CensusTract.zip)提供的ZIP文件中获取样本人口普查区形状文件。
- en: Extract the zipped layer to a directory named `census` in your `qgis_data` directory.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 将压缩层提取到您的`qgis_data`目录下名为`census`的目录中。
- en: How to do it...
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'We will load the vector layer, toggle scale-based visibility, set the visibility
    range, and then add the layer to the map. To do this, perform the following steps:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将加载矢量层，切换基于比例的可见性，设置可见范围，然后将图层添加到地图中。为此，请执行以下步骤：
- en: 'First, we load the layer:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们加载图层：
- en: '[PRE86]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Next, we toggle scale-based visibility:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们切换基于比例的可见性：
- en: '[PRE87]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Then, we set the minimum and maximum map scales at which the layer is visible:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们设置图层可见的最小和最大地图比例：
- en: '[PRE88]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Now, we add the layer to the map:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将图层添加到地图中：
- en: '[PRE89]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Finally, manually zoom in and out of the map to ensure that the layer disappears
    and reappears at the proper scales.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，手动放大和缩小地图以确保图层在适当的比例下消失和重新出现。
- en: How it works...
  id: totrans-328
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The map scale is a ratio of map units to physical map size, expressed as a floating-point
    number. You must remember to toggle scale-dependent visibility so that QGIS knows
    that it needs to check the range each time the map scale changes.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 地图比例是地图单位与物理地图大小的比率，以浮点数表示。您必须记住切换基于比例的可见性，以便QGIS知道每次地图比例变化时都需要检查范围。
- en: Using SVG for layer symbols
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SVG作为图层符号
- en: '**Scalable Vector Graphics** (**SVG)** are an XML standard that defines vector
    graphics that can be scaled at any resolution. QGIS can use SVG files as markers
    for points. In this recipe, we''ll use Python to apply one of the SVG symbols
    included with QGIS to a point layer.'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '**可缩放矢量图形**（**SVG**）是一个XML标准，它定义了可以按任何分辨率缩放的矢量图形。QGIS可以使用SVG文件作为点的标记。在本菜谱中，我们将使用Python将QGIS附带的一个SVG符号应用到点图层上。'
- en: Getting ready
  id: totrans-332
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, download the following zipped point shapefile layer from [https://geospatialpython.googlecode.com/files/NYC_MUSEUMS_GEO.zip](https://geospatialpython.googlecode.com/files/NYC_MUSEUMS_GEO.zip).
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，从[https://geospatialpython.googlecode.com/files/NYC_MUSEUMS_GEO.zip](https://geospatialpython.googlecode.com/files/NYC_MUSEUMS_GEO.zip)下载以下压缩的点形状文件图层。
- en: Extract it to your `qgis_data` directory.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 将其提取到您的`qgis_data`目录中。
- en: How to do it...
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'In the following steps, we''ll load the vector layer, build a symbol layer
    and renderer, and add it to the layer, as follows:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下步骤中，我们将加载矢量层，构建符号层和渲染器，并将其添加到图层中，如下所示：
- en: 'First, we''ll define the path to the shapefile:'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将定义形状文件的路径：
- en: '[PRE90]'
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Next, we''ll load the layer:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将加载图层：
- en: '[PRE91]'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Now, we define the properties of the symbol, including the location of the
    SVG file as a Python dictionary:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们定义符号的属性，包括将SVG文件位置作为Python字典：
- en: '[PRE92]'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Then, we create an SVG symbol layer:'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们创建一个SVG符号层：
- en: '[PRE93]'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Now, we change the layer renderer''s default symbol layer:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们更改图层渲染器的默认符号层：
- en: '[PRE94]'
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Finally, we add the layer to the map in order to view the SVG symbol:'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将图层添加到地图中以查看SVG符号：
- en: '[PRE95]'
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: How it works...
  id: totrans-349
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The default SVG layers are stored in the QGIS application directory. There
    are numerous graphics available that cover many common uses. You can also add
    your own graphics as well. The following map image shows the recipe''s output:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 默认SVG图层存储在QGIS应用程序目录中。有许多图形可用于许多常见用途。您也可以添加自己的图形。以下地图图像显示了菜谱的输出：
- en: '![How it works...](img/00042.jpeg)'
  id: totrans-351
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/00042.jpeg)'
- en: Using pie charts for symbols
  id: totrans-352
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用饼图作为符号
- en: QGIS has the ability to use dynamic pie charts as symbols describing the statistics
    in a given region. In this recipe, we'll use pie chart symbols on a polygon layer
    in QGIS.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: QGIS具有使用动态饼图作为符号描述给定区域统计信息的能力。在这个配方中，我们将使用QGIS中的多边形图层上的饼图符号。
- en: Getting ready
  id: totrans-354
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, download the following zipped shapefile and extract it to a
    directory named `ms` in your `qgis_data` directory from [https://geospatialpython.googlecode.com/svn/County10PopnHou.zip](https://geospatialpython.googlecode.com/svn/County10PopnHou.zip).
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，请从[https://geospatialpython.googlecode.com/svn/County10PopnHou.zip](https://geospatialpython.googlecode.com/svn/County10PopnHou.zip)下载以下压缩的shapefile并将其提取到`qgis_data`目录中名为`ms`的目录中。
- en: How to do it...
  id: totrans-356
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'As with other renderers, we will build a symbol layer, add it to a renderer,
    and display the layer on the map. The pie chart diagram renderers are more complex
    than other renderers but have many more options. Perform the following steps to
    create a pie chart map:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他渲染器一样，我们将构建一个符号图层，将其添加到渲染器中，并在地图上显示该图层。饼图图示渲染器比其他渲染器更复杂，但具有更多选项。按照以下步骤创建饼图地图：
- en: 'First, we import the PyQt GUI library:'
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们导入PyQt GUI库：
- en: '[PRE96]'
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Then, we load the layer:'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们加载图层：
- en: '[PRE97]'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Next, we set up categories based on attribute names:'
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们根据属性名称设置类别：
- en: '[PRE98]'
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Now, we set up a list of corresponding colors for each category:'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们为每个类别设置一个相应的颜色列表：
- en: '[PRE99]'
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Next, we convert the hex color values to `QColor` objects:'
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将十六进制颜色值转换为`QColor`对象：
- en: '[PRE100]'
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Now, we reference the map canvas:'
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们引用地图画布：
- en: '[PRE101]'
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Then, we create a pie diagram object:'
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们创建一个饼图对象：
- en: '[PRE102]'
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Then, we create a diagram settings object:'
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们创建一个图示设置对象：
- en: '[PRE103]'
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Now, we define all the diagram settings that will be used for the renderer:'
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们定义所有将用于渲染器的图示设置：
- en: '[PRE104]'
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Now, we can create our diagram renderer:'
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以创建我们的图示渲染器：
- en: '[PRE105]'
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'We must set a few size parameters for our diagrams:'
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须为我们的图示设置一些尺寸参数：
- en: '[PRE106]'
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Then, we can add our diagram to the renderer:'
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以将我们的图示添加到渲染器中：
- en: '[PRE107]'
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Next, we add the renderer to the layer:'
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将渲染器添加到图层中：
- en: '[PRE108]'
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Now, we apply some additional placement settings at the layer level:'
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们在图层级别应用一些额外的放置设置：
- en: '[PRE109]'
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'In QGIS 2.6, the diagram renderer is tied to the new PAL labeling engine, so
    we need to activate this engine:'
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在QGIS 2.6中，图示渲染器与新的PAL标签引擎绑定，因此我们需要激活此引擎：
- en: '[PRE110]'
  id: totrans-387
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Next, we delete any cached images that are rendered and force the layer to
    repaint:'
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们删除任何已渲染的缓存图像并强制图层重新绘制：
- en: '[PRE111]'
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Finally, we add our diagram layer to the map:'
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将我们的图示图层添加到地图中：
- en: '[PRE112]'
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: How it works...
  id: totrans-392
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作...
- en: 'The basics of pie chart diagram symbols are straightforward and work in a similar
    way to other types of symbols and renderers. However, it gets a little confusing
    as we need to apply settings at three different levels – the diagram level, the
    render level, and the layer level. It turns out they are actually quite complex.
    Most of the settings are poorly documented, if at all. Fortunately, most of them
    are self-explanatory. The following screenshot shows an example of the completed
    pie chart diagram map:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 饼图图示的基本符号简单易懂，其工作方式与其他类型的符号和渲染器类似。然而，当我们需要在三个不同级别应用设置时——图示级别、渲染级别和图层级别——事情就会变得有些复杂。实际上，它们相当复杂。大多数设置都没有很好地记录，如果有的话。幸运的是，大多数设置都是自我解释的。以下截图显示了完成的饼图图示地图示例：
- en: '![How it works...](img/00043.jpeg)'
  id: totrans-394
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/00043.jpeg)'
- en: There's more...
  id: totrans-395
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: To learn more about what is possible with pie chart diagram symbols, you can
    experiment with this recipe in the Script Runner plugin, where you can change
    or remove settings and quickly re-render the map. You can also manually change
    the settings using the QGIS dialogs and then export the style to an XML file and
    see what settings are used. Most of them map to the Python API well.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解饼图图示符号的更多可能性，您可以在Script Runner插件中尝试此配方，在那里您可以更改或删除设置，并快速重新渲染地图。您还可以使用QGIS对话框手动更改设置，然后将样式导出为XML文件，查看使用了哪些设置。它们中的大多数都很好地映射到Python
    API。
- en: Using the OpenStreetMap service
  id: totrans-397
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用OpenStreetMap服务
- en: Cloud-based technology is moving more and more data to the Internet, and GIS
    is no exception. QGIS can load web-based data using Open GIS Consortium standards,
    such as **Web Map Service (WMS).** The easiest way to add WMS layers is using
    the **Geospatial Data Abstraction Library (GDAL**) and its virtual filesystem
    feature to load a tiled layer.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 云技术正越来越多地将数据移动到互联网上，GIS也不例外。QGIS可以使用Open GIS Consortium标准加载基于Web的数据，例如**Web
    Map Service (WMS)**。添加WMS图层最简单的方法是使用**地理空间数据抽象库 (GDAL**)及其虚拟文件系统功能来加载瓦片图层。
- en: Getting ready
  id: totrans-399
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You don't need to do any preparation for this recipe, other than opening the
    Python console plugin within QGIS.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在 QGIS 中打开 Python 控制台插件之外，您不需要为此菜谱做任何准备。
- en: How to do it...
  id: totrans-401
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We will create an XML template that describes the tiled web service from OpenStreetMap
    we want to import. Then, we''ll turn it into a GDAL virtual file and load it as
    a QGIS raster layer. To do this, we need to perform the following steps:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个描述我们想要导入的 OpenStreetMap 瓦片网络服务的 XML 模板。然后，我们将将其转换为 GDAL 虚拟文件，并在 QGIS
    中将其加载为栅格图层。为此，我们需要执行以下步骤：
- en: 'First, we import the GDAL library:'
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们导入 GDAL 库：
- en: '[PRE113]'
  id: totrans-404
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Next, we''ll create our XML template, describing the OpenStreetMap tiled web
    service:'
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建我们的 XML 模板，描述我们想要导入的 OpenStreetMap 瓦片网络服务：
- en: '[PRE114]'
  id: totrans-406
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Now, we''ll create the path for our GDAL virtual filesystem''s file:'
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将为我们的 GDAL 虚拟文件系统文件创建路径：
- en: '[PRE115]'
  id: totrans-408
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Next, we use GDAL to create the virtual file using the path and the XML document:'
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们使用 GDAL 通过路径和 XML 文档创建虚拟文件：
- en: '[PRE116]'
  id: totrans-410
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Now, we can create a raster layer from the virtual file:'
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以从虚拟文件创建一个栅格图层：
- en: '[PRE117]'
  id: totrans-412
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'Before we add the layer to the map, we''ll make sure that it''s valid:'
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们将图层添加到地图之前，我们将确保其有效性：
- en: '[PRE118]'
  id: totrans-414
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Finally, add the layer to the map:'
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将图层添加到地图中：
- en: '[PRE119]'
  id: totrans-416
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE119]'
- en: How it works...
  id: totrans-417
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: There are other ways to load tiled map services such as OpenStreetMap into QGIS
    programmatically, but GDAL is by far the most robust. The prefix `vsimem` tells
    GDAL to use a virtual file in order to manage the tiles. This approach frees you
    from the need to manage downloaded tiles on disk directly and allows you to focus
    on your application's functionality.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有其他方法可以将如 OpenStreetMap 之类的瓦片地图服务以编程方式加载到 QGIS 中，但 GDAL 是最稳健的方法。前缀 `vsimem`
    告诉 GDAL 使用虚拟文件来管理瓦片。这种方法让您免于直接在磁盘上管理下载的瓦片，并让您专注于应用程序的功能。
- en: Using the Bing aerial image service
  id: totrans-419
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Bing 空中影像服务
- en: While there are many services that provide street map tiles, there are far fewer
    services that provide imagery services. One excellent free service for both maps
    and, more importantly, imagery is Microsoft's Bing map services. We can access
    Bing imagery programmatically in QGIS using GDAL's WMS capability coupled with
    virtual files.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有许多服务提供街道地图瓦片，但提供影像服务的服务却少得多。对于地图和更重要的是影像，Microsoft 的 Bing 地图服务是一个出色的免费服务。我们可以使用
    GDAL 的 WMS 功能结合虚拟文件在 QGIS 中以编程方式访问 Bing 影像。
- en: Getting ready
  id: totrans-421
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You don't need to do any preparation for this recipe other than opening the
    Python console plugin within QGIS.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在 QGIS 中打开 Python 控制台插件之外，您不需要为此菜谱做任何准备。
- en: How to do it...
  id: totrans-423
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Similar to the approach used for the previous *Using the OpenStreetMap service*
    recipe, we will create an XML file as a string to describe the service, turn it
    into a GDAL virtual file, and load it as a raster in QGIS. To do this, we need
    to perform the following steps:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前用于 *使用 OpenStreetMap 服务* 的方法类似，我们将创建一个字符串形式的 XML 文件来描述服务，将其转换为 GDAL 虚拟文件，并在
    QGIS 中将其加载为栅格。为此，我们需要执行以下步骤：
- en: 'First, we import the GDAL library:'
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们导入 GDAL 库：
- en: '[PRE120]'
  id: totrans-426
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'Next, we create the XML file, describing the Bing service as a string:'
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建 XML 文件，将 Bing 服务描述为一个字符串：
- en: '[PRE121]'
  id: totrans-428
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'Now, we create the virtual file path for the XML file:'
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们为 XML 文件创建虚拟文件路径：
- en: '[PRE122]'
  id: totrans-430
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Then, we turn the XML file into a GDAL virtual file:'
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将 XML 文件转换为 GDAL 虚拟文件：
- en: '[PRE123]'
  id: totrans-432
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'Now, we can add the file as a QGIS raster layer and check its validity:'
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以将文件作为 QGIS 栅格图层添加，并检查其有效性：
- en: '[PRE124]'
  id: totrans-434
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'Finally, we add the layer to the map:'
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将图层添加到地图中：
- en: '[PRE125]'
  id: totrans-436
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE125]'
- en: How it works...
  id: totrans-437
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: GDAL has drivers for various map services. The service name for Bing is `VirtualEarth`.
    The `${}` clauses in the server URL provide placeholders, which will be replaced
    with instance-specific data when GDAL downloads styles. When using this data,
    you should be aware that it has copyright restrictions. Be sure to read the Bing
    usage agreement online.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: GDAL 为各种地图服务提供了驱动程序。Bing 的服务名称为 `VirtualEarth`。服务器 URL 中的 `${}` 子句提供了占位符，当 GDAL
    下载样式时，这些占位符将被实例特定的数据替换。在使用这些数据时，您应该意识到它们有版权限制。请务必在线阅读 Bing 使用协议。
- en: Adding real-time weather data from OpenWeatherMap
  id: totrans-439
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加来自 OpenWeatherMap 的实时天气数据
- en: Real-time data is one of the most exciting data types you can add to a modern
    map. Most data producers make data available through **Open GIS Consortium** standards.
    One such example is OpenWeatherMap, which offers an OGC **Web Map Service (WMS**)
    for different real-time weather data layers. In this recipe, we'll access this
    service to access a real-time weather data layer.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 实时数据是您可以添加到现代地图中最激动人心的数据类型之一。大多数数据生产者通过 **Open GIS Consortium** 标准提供数据。一个这样的例子是
    OpenWeatherMap，它提供不同实时天气数据层的 OGC **Web Map Service (WMS**)。在本食谱中，我们将访问此服务以访问实时天气数据层。
- en: Getting ready
  id: totrans-441
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To prepare for this recipe, you just need to open the QGIS **Python Console**
    by clicking on the **Plugins** menu and selecting **Python Console**.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 为了准备这个食谱，您只需通过点击 **插件** 菜单并选择 **Python 控制台** 来打开 QGIS **Python 控制台**。
- en: How to do it...
  id: totrans-443
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We will add a WMS weather data layer for precipitation to a QGIS map, as follows:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将按照以下方式将降水 WMS 数据层添加到 QGIS 地图中：
- en: 'First, we specify the parameters for the `service`:'
  id: totrans-445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们指定 `service` 的参数：
- en: '[PRE126]'
  id: totrans-446
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'Next, we create the raster layer, specifying `wms` as the type:'
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建栅格图层，指定 `wms` 作为类型：
- en: '[PRE127]'
  id: totrans-448
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'Finally, we add the precipitation layer to the map:'
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将降水层添加到地图中：
- en: '[PRE128]'
  id: totrans-450
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE128]'
- en: How it works...
  id: totrans-451
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: A WMS request is typically an HTTP `GET` request with all of the parameters
    as part of the URL. In PyQGIS, you use a URL-encoded format and specify the parameters
    separately from the URL.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: WMS 请求通常是一个带有所有参数作为 URL 部分的 HTTP `GET` 请求。在 PyQGIS 中，您使用 URL 编码格式，并从 URL 中单独指定参数。
- en: 'The following map image shows the output of the precipitation layer in QGIS:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 以下地图图像显示了 QGIS 中降水层的输出：
- en: '![How it works...](img/00044.jpeg)'
  id: totrans-454
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/00044.jpeg)'
- en: Labeling features
  id: totrans-455
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标记要素
- en: Once your map layers are styled, the next step to creating a complete map is
    labeling features. We'll explore the basics of labeling in this recipe.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您的地图图层被样式化，创建完整地图的下一步就是标记要素。在本食谱中，我们将探讨标记的基础知识。
- en: Getting ready
  id: totrans-457
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Download the following zipped shapefile from [https://geospatialpython.googlecode.com/files/MSCities_Geo_Pts.zip](https://geospatialpython.googlecode.com/files/MSCities_Geo_Pts.zip).
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 从 [https://geospatialpython.googlecode.com/files/MSCities_Geo_Pts.zip](https://geospatialpython.googlecode.com/files/MSCities_Geo_Pts.zip)
    下载以下压缩的 shapefile。
- en: Extract the shapefile to a directory named `ms` in your `qgis_data` shapefile.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 将 shapefile 提取到名为 `ms` 的目录中，该目录位于您的 `qgis_data` shapefile 目录下。
- en: How to do it...
  id: totrans-460
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We will load the point shapefile layer, create a label object, set its properties,
    apply it to the layer, and then add the layer to the map. To do this, we need
    to perform the following steps:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将加载点 shapefile 图层，创建一个标签对象，设置其属性，将其应用于图层，然后将图层添加到地图中。为此，我们需要执行以下步骤：
- en: 'First, to save space, we''ll specify the path to the shapefile:'
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，为了节省空间，我们将指定 shapefile 的路径：
- en: '[PRE129]'
  id: totrans-463
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'Next, we''ll load the layer:'
  id: totrans-464
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将加载图层：
- en: '[PRE130]'
  id: totrans-465
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'Then, we''ll create the labeling object:'
  id: totrans-466
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将创建标记对象：
- en: '[PRE131]'
  id: totrans-467
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'Now, we''ll configure the labels, starting with the current layer settings
    being read:'
  id: totrans-468
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将配置标签，从正在读取的当前图层设置开始：
- en: '[PRE132]'
  id: totrans-469
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'Then, we specify the attribute for the label data:'
  id: totrans-470
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们指定标签数据的属性：
- en: '[PRE133]'
  id: totrans-471
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'Then, we can set the placement and size options:'
  id: totrans-472
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以设置放置和大小选项：
- en: '[PRE134]'
  id: totrans-473
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'Next, we commit the changes to the layer:'
  id: totrans-474
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将更改提交到图层：
- en: '[PRE135]'
  id: totrans-475
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'Finally, we can add the layer to the map to view the labels:'
  id: totrans-476
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以将图层添加到地图中以查看标签：
- en: '[PRE136]'
  id: totrans-477
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE136]'
- en: How it works...
  id: totrans-478
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: An interesting part of labeling is the round-trip read and write process to
    access the layer data and the assignment of the labeling properties. Labeling
    can be quite complex, but this recipe covers the basics needed to get started.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 标记的一个有趣部分是往返读取和写入过程，用于访问图层数据和分配标记属性。标记可能相当复杂，但本食谱涵盖了开始所需的基本知识。
- en: Changing map layer transparency
  id: totrans-480
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改变地图图层透明度
- en: Map layer transparency allows you to change the opacity of a layer, so the items
    behind it are visible to some degree. A common technique is to make a vector layer
    polygon partially transparent in order to allow the underlying imagery or elevation
    data to add texture to the data.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 地图图层透明度允许您更改图层的透明度，以便在一定程度上可以看到其后的项目。一种常见的技术是将矢量图层多边形部分透明，以便允许底层图像或高程数据为数据添加纹理。
- en: Getting ready
  id: totrans-482
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In a directory called `ms`, in your `qgis_data` directory, download and extract
    the following shapefile from
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 在名为 `ms` 的目录中，在您的 `qgis_data` 目录下，从以下位置下载并提取以下 shapefile：
- en: '[https://geospatialpython.googlecode.com/files/Mississippi.zip](https://geospatialpython.googlecode.com/files/Mississippi.zip).'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://geospatialpython.googlecode.com/files/Mississippi.zip](https://geospatialpython.googlecode.com/files/Mississippi.zip)。'
- en: How to do it...
  id: totrans-485
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The process is extremely simple. Transparency is just a method:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程极其简单。透明度只是一个方法：
- en: 'First, we load the shapefile layer:'
  id: totrans-487
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们加载 shapefile 图层：
- en: '[PRE137]'
  id: totrans-488
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'Next, we set the layer''s transparency to `50` percent:'
  id: totrans-489
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将图层的透明度设置为 `50` 百分比：
- en: '[PRE138]'
  id: totrans-490
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'Finally, we add this layer to the map:'
  id: totrans-491
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将此图层添加到地图上：
- en: '[PRE139]'
  id: totrans-492
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE139]'
- en: How it works...
  id: totrans-493
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: If you set the transparency to 100 percent, the layer is completely opaque.
    If you set it to `0,` the layer becomes completely invisible.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将透明度设置为 100%，则图层完全不透明。如果设置为 `0`，则图层完全不可见。
- en: Adding standard map tools to the canvas
  id: totrans-495
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将标准地图工具添加到画布
- en: In this recipe, you'll learn how to add standard map navigation tools to a standalone
    map canvas. Creating the simplest possible interactive application provides a
    framework to begin building specialized geospatial applications using QGIS as
    a library.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，您将学习如何将标准地图导航工具添加到独立的地图画布。创建最简单的交互式应用程序提供了一个框架，以开始使用 QGIS 作为库来构建专业地理空间应用程序。
- en: Getting ready
  id: totrans-497
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Download the following zipped shapefile and extract it to your `qgis_data` directory
    into a folder named `ms` from [https://geospatialpython.googlecode.com/files/Mississippi.zip](https://geospatialpython.googlecode.com/files/Mississippi.zip).
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 下载以下压缩的 shapefile 并将其提取到您的 `qgis_data` 目录中的 `ms` 文件夹中，从 [https://geospatialpython.googlecode.com/files/Mississippi.zip](https://geospatialpython.googlecode.com/files/Mississippi.zip)。
- en: How to do it...
  id: totrans-499
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We will walk through the steps required to create a map canvas, add a layer
    to it, and then add some tools to zoom and pan the map, as follows:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将逐步介绍创建地图画布、向其添加图层以及添加缩放和平移地图的工具所需的步骤，如下所示：
- en: 'First, because we are working outside the QGIS Python interpreter, we need
    to import some QGIS and Qt libraries:'
  id: totrans-501
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，因为我们是在 QGIS Python 解释器外部工作，所以我们需要导入一些 QGIS 和 Qt 库：
- en: '[PRE140]'
  id: totrans-502
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'Then, we must set the location of our main QGIS application directory. This
    setting is platform-dependent:'
  id: totrans-503
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们必须设置主 QGIS 应用程序目录的位置。此设置取决于平台：
- en: '[PRE141]'
  id: totrans-504
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'Next, we begin initializing the class:'
  id: totrans-505
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们开始初始化类：
- en: '[PRE142]'
  id: totrans-506
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'Now, we can initialize the application and create the map canvas:'
  id: totrans-507
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以初始化应用程序并创建地图画布：
- en: '[PRE143]'
  id: totrans-508
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'Then, we can load the shapefile layer and add it to the canvas:'
  id: totrans-509
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以加载 shapefile 图层并将其添加到画布上：
- en: '[PRE144]'
  id: totrans-510
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'Next, we define the buttons that will be visible on the toolbar:'
  id: totrans-511
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义将在工具栏上可见的按钮：
- en: '[PRE145]'
  id: totrans-512
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'Now, we connect the signal created when the buttons are clicked to the Python
    methods that will provide each tool''s functionality:'
  id: totrans-513
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将按钮点击时创建的信号连接到提供每个工具功能的 Python 方法：
- en: '[PRE146]'
  id: totrans-514
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'Next, we create our toolbar and add the buttons:'
  id: totrans-515
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建工具栏并添加按钮：
- en: '[PRE147]'
  id: totrans-516
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'Then, we connect the buttons to the applications states:'
  id: totrans-517
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将按钮连接到应用程序的状态：
- en: '[PRE148]'
  id: totrans-518
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'Then, we define which button will be selected when the application loads:'
  id: totrans-519
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们定义当应用程序加载时将选择的按钮：
- en: '[PRE149]'
  id: totrans-520
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'Now, we define the Python methods that control the application''s behavior
    for each tool:'
  id: totrans-521
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们定义控制应用程序行为的每个工具的 Python 方法：
- en: '[PRE150]'
  id: totrans-522
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'Then, we create a Qt application that uses our application window class:'
  id: totrans-523
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们创建一个使用我们的应用程序窗口类的 Qt 应用程序：
- en: '[PRE151]'
  id: totrans-524
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'Finally, we enter the program''s main loop:'
  id: totrans-525
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们进入程序的主循环：
- en: '[PRE152]'
  id: totrans-526
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE152]'
- en: How it works...
  id: totrans-527
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: An application is a continuously running program loop that ends only when we
    quit the application. QGIS is based on the Qt windowing library, so our application
    class inherits from the main window class that provides the canvas and the ability
    to create toolbars and dialogs.This is a lot of setup, even for an extremely simple
    application, but once the framework for an application is complete, it becomes
    much easier to extend it.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序是一个持续运行的程序循环，只有当我们退出应用程序时才会结束。QGIS 基于 Qt 窗口库，因此我们的应用程序类继承自提供画布以及创建工具栏和对话框的主要窗口类。即使是对于极其简单的应用程序，这也有很多设置，但一旦应用程序的框架完成，扩展它就变得容易得多。
- en: Using a map tool to draw points on the canvas
  id: totrans-529
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用地图工具在画布上绘制点
- en: QGIS contains a built-in functionality to zoom and pan the map in custom applications.
    It also contains the basic hooks to build your own interactive tools. In this
    recipe, we'll create an interactive point tool that lets you mark locations on
    the map by clicking on a point.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: QGIS 包含了在自定义应用程序中缩放和平移地图的内置功能。它还包含了构建您自己的交互式工具的基本钩子。在这个菜谱中，我们将创建一个交互式点工具，允许您通过点击点在地图上标记位置。
- en: Getting ready
  id: totrans-531
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will use the application framework from the previous *Adding standard map
    tools to the canvas* recipe, so complete that recipe first. We will extend that
    application with a new tool. The complete version of this application is available
    in the code samples provided with this book.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用来自上一节“将标准地图工具添加到画布”的应用程序框架，因此首先完成该食谱。我们将通过添加新工具来扩展该应用程序。该应用程序的完整版本可在本书提供的代码示例中找到。
- en: How to do it...
  id: totrans-533
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We will set up the button, signal trigger, and actions as we do with all map
    tools. However, because we are building a new tool, we must also define a class
    to define exactly what the tool does. To do this, we need to perform the following
    actions:'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将设置按钮、信号触发和动作，就像我们处理所有地图工具一样。然而，因为我们正在构建一个新工具，我们必须定义一个类来精确地定义工具的功能。为此，我们需要执行以下操作：
- en: 'First, we define our point tool''s button in the actions portion of our application.
    Place this line after the `QAction("Pan")` method:'
  id: totrans-535
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们在应用程序的动作部分定义我们的点工具按钮。将此行放置在`QAction("Pan")`方法之后：
- en: '[PRE153]'
  id: totrans-536
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'In the next section, we make sure that when we click on the button, it stays
    selected:'
  id: totrans-537
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一节中，我们确保点击按钮后它保持选中状态：
- en: '[PRE154]'
  id: totrans-538
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'In the section after that, we define the method that is used when the button
    is triggered:'
  id: totrans-539
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一节中，我们定义当按钮被触发时使用的方法：
- en: '[PRE155]'
  id: totrans-540
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 'Now, we add the button to the toolbar along with the other buttons:'
  id: totrans-541
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将按钮添加到工具栏中，与其他按钮一起：
- en: '[PRE156]'
  id: totrans-542
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'Then, we link the application to our specialized tool class:'
  id: totrans-543
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将应用程序链接到我们的专用工具类：
- en: '[PRE157]'
  id: totrans-544
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'We set the point tool to be selected when the application loads:'
  id: totrans-545
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们设置在应用程序加载时选择点工具：
- en: '[PRE158]'
  id: totrans-546
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'Now, we define the method in the main application class for our tool:'
  id: totrans-547
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们在主应用程序类中定义我们的工具方法：
- en: '[PRE159]'
  id: totrans-548
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'Now, we create a class that describes the type of tool we have and the output
    it provides. The output is a point on the canvas, defined in the `canvasPressEvent`
    method, that receives the button-click event. We will inherit from a generic tool
    called the `QgsMapToolEmitPoint` in order to create points:'
  id: totrans-549
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们创建一个类来描述我们拥有的工具类型及其提供的输出。输出是在`canvasPressEvent`方法中定义的画布上的一个点，它接收按钮点击事件。我们将从名为`QgsMapToolEmitPoint`的通用工具继承，以创建点：
- en: '[PRE160]'
  id: totrans-550
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE160]'
- en: How it works...
  id: totrans-551
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: For custom tools, PyQGIS provides a set of generic tools for the common functions
    that you can extend and piece together. In this case, the EmitPoint tool handles
    the details of the events and map functionality when you click on a location on
    the map.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 对于自定义工具，PyQGIS提供了一套通用工具，用于执行您可以扩展和组合的常见功能。在这种情况下，EmitPoint工具处理您在地图上点击位置时事件和地图功能的相关细节。
- en: Using a map tool to draw polygons or lines on the canvas
  id: totrans-553
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用地图工具在画布上绘制多边形或线条
- en: In this recipe, we'll create a tool to draw polygons on the canvas. This tool
    is an important tool because it opens the doors to even more advanced tools. Once
    you have a polygon on the canvas, you can do all sorts of operations that involve
    querying and geometry.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将创建一个在画布上绘制多边形的工具。这个工具是一个重要的工具，因为它打开了通往更多高级工具的大门。一旦你在画布上有一个多边形，你就可以执行所有涉及查询和几何的各种操作。
- en: Getting ready
  id: totrans-555
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will use the application framework from the *Adding standard map tools to
    the canvas* recipe, so complete that recipe. We will extend that application with
    a new tool. The complete version of this application is available in the code
    samples provided with this book.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用来自“将标准地图工具添加到画布”的*Adding standard map tools to the canvas*食谱的应用程序框架，因此首先完成该食谱。我们将通过添加新工具来扩展该应用程序。该应用程序的完整版本可在本书提供的代码示例中找到。
- en: How to do it...
  id: totrans-557
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We will add a new tool to the toolbar and also create a class that describes
    our polygon tool, as follows:'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加一个新工具到工具栏，并创建一个描述我们的多边形工具的类，如下所示：
- en: 'First, we define our polygon tool''s button in the actions portion of our application.
    Place this line after the `QAction("Pan")` method:'
  id: totrans-559
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们在应用程序的动作部分定义我们的多边形工具按钮。将此行放置在`QAction("Pan")`方法之后：
- en: '[PRE161]'
  id: totrans-560
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE161]'
- en: 'In the next section, we make sure that when we click on the button, it stays
    selected:'
  id: totrans-561
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一节中，我们确保点击按钮后它保持选中状态：
- en: '[PRE162]'
  id: totrans-562
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE162]'
- en: 'In the section after that, we define the method used when the button is triggered:'
  id: totrans-563
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一节中，我们定义当按钮被触发时使用的方法：
- en: '[PRE163]'
  id: totrans-564
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE163]'
- en: 'Now, we add the button to the toolbar along with the other buttons:'
  id: totrans-565
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将按钮添加到工具栏中，与其他按钮一起：
- en: '[PRE164]'
  id: totrans-566
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE164]'
- en: 'Then, we link the application to our specialized tool class:'
  id: totrans-567
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将应用程序链接到我们的专用工具类：
- en: '[PRE165]'
  id: totrans-568
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE165]'
- en: 'We set the point tool to be selected when the application loads:'
  id: totrans-569
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们设置在应用程序加载时选择点工具：
- en: '[PRE166]'
  id: totrans-570
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE166]'
- en: 'Now, we define the method in the main application class for our tool:'
  id: totrans-571
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们在主应用程序类中定义我们的工具方法：
- en: '[PRE167]'
  id: totrans-572
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE167]'
- en: 'Now, we create a class that describes the type of tool we have and the output
    it provides. The output is a point on the canvas defined in the `canvasPressEvent`
    method, which receives the button-click event and the `showPoly` method. We will
    inherit from a generic tool in order to create points called the `QgsMapToolEmitPoint`;
    we will also use an object called `QgsRubberBand` for handling polygons:'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们创建一个类来描述我们拥有的工具类型以及它提供的输出。输出是在`canvasPressEvent`方法中定义的画布上的一个点，该方法接收按钮点击事件和`showPoly`方法。我们将从通用的工具中继承以创建名为`QgsMapToolEmitPoint`的点；我们还将使用名为`QgsRubberBand`的对象来处理多边形：
- en: '[PRE168]'
  id: totrans-574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: How it works...
  id: totrans-575
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作...
- en: 'All the settings for the polygon are contained in the custom class. There is
    a key property, called **EmittingPoint**, which we use to detect whether we are
    still adding points to the polygon. This value starts out as `false`. If this
    is the case, we reset our polygon object and begin drawing a new one. The following
    screenshot shows a polygon drawn with this tool on a map:'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 多边形的所有设置都包含在自定义类中。有一个关键属性，称为**EmittingPoint**，我们用它来检测我们是否仍在向多边形添加点。这个值最初是`false`。如果是这种情况，我们将重置我们的多边形对象并开始绘制一个新的。以下截图显示了使用此工具在地图上绘制的多边形：
- en: '![How it works...](img/00045.jpeg)'
  id: totrans-577
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/00045.jpeg)'
- en: Building a custom selection tool
  id: totrans-578
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建自定义选择工具
- en: In this recipe, we will build a custom tool that both draws a shape on the map
    and interacts with other features on the map. These two basic functions are the
    basis for almost any map tool you would want to build, either in a standalone
    QGIS application like this one, or by extending the QGIS desktop application with
    a plugin.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将构建一个自定义工具，该工具可以在地图上绘制形状并与地图上的其他功能交互。这两个基本功能是几乎所有你想要构建的地图工具的基础，无论是像这样一个独立的QGIS应用程序，还是通过插件扩展QGIS桌面应用程序。
- en: Getting ready
  id: totrans-580
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will use the application framework from the *Adding standard map tools to
    the canvas* recipe, so complete that recipe first. We will extend that application
    with a new tool. The complete version of this application is available in the
    code samples provided with this book. It will also be beneficial to study the
    other two tool-related recipes, *A map tool to draw polygons or lines on the canvas*
    and *A map tool to draw points on the canvas*, as this recipe builds on them as
    well.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用来自*将标准地图工具添加到画布*菜谱的应用程序框架，所以首先完成那个菜谱。我们将通过添加新工具来扩展该应用程序。该应用程序的完整版本可在本书提供的代码示例中找到。研究其他两个与工具相关的菜谱，*在画布上绘制多边形或线条的工具*和*在画布上绘制点的工具*也将大有裨益，因为这个菜谱也是基于它们的。
- en: You will also need the following zipped shapefile from [https://geospatialpython.googlecode.com/files/NYC_MUSEUMS_GEO.zip](https://geospatialpython.googlecode.com/files/NYC_MUSEUMS_GEO.zip).
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要以下来自[https://geospatialpython.googlecode.com/files/NYC_MUSEUMS_GEO.zip](https://geospatialpython.googlecode.com/files/NYC_MUSEUMS_GEO.zip)的压缩shapefile。
- en: Download and extract it to your `qgis_data` directory.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 下载并提取到你的`qgis_data`目录中。
- en: How to do it...
  id: totrans-584
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We will add a new tool to the toolbar and also create a class describing our
    selection tool, including how to draw the selection polygon and how to select
    the features. To do this, we need to perform the following steps:'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在工具栏中添加一个新工具，并创建一个描述我们的选择工具的类，包括如何绘制选择多边形以及如何选择功能。为此，我们需要执行以下步骤：
- en: 'First, we define our polygon tool''s button in the actions portion of our application.
    Place this line after the `QAction("Pan")` method:'
  id: totrans-586
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们在应用程序的动作部分定义我们的多边形工具的按钮。将此行放置在`QAction("Pan")`方法之后：
- en: '[PRE169]'
  id: totrans-587
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE169]'
- en: 'In the next section, we make sure that when we click on the button, it stays
    selected:'
  id: totrans-588
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一节中，我们确保当我们点击按钮时，它保持选中状态：
- en: '[PRE170]'
  id: totrans-589
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE170]'
- en: 'In the section after that, we define the method used when the button is triggered:'
  id: totrans-590
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们定义当按钮被触发时使用的方法：
- en: '[PRE171]'
  id: totrans-591
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE171]'
- en: 'Now, we add the button to the toolbar along with the other buttons:'
  id: totrans-592
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们在工具栏中添加按钮以及其他按钮：
- en: '[PRE172]'
  id: totrans-593
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE172]'
- en: 'Then, we link the application to our specialized tool class:'
  id: totrans-594
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将应用程序链接到我们的专用工具类：
- en: '[PRE173]'
  id: totrans-595
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE173]'
- en: 'We set the point tool to be selected when the application loads:'
  id: totrans-596
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们设置点工具在应用程序加载时被选中：
- en: '[PRE174]'
  id: totrans-597
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE174]'
- en: 'Now, we define the method in the main application class for our tool:'
  id: totrans-598
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们在主应用程序类中为我们的工具定义方法：
- en: '[PRE175]'
  id: totrans-599
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE175]'
- en: 'Next, we create a class that describes the type of tool we have and how it
    works. The output is a point on the canvas defined in the `canvasPressEvent` method,
    which receives the button click-event and the `selectPoly` method. We will inherit
    from a generic tool to create points called the `QgsMapToolEmitPoint`; we will
    also use an object called `QgsRubberBand` to handle polygons. However, we must
    also perform the selection process to highlight the features that fall within
    our selection polygon:'
  id: totrans-600
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个类来描述我们工具的类型及其工作方式。输出是在`canvasPressEvent`方法中定义的画布上的一个点，该方法接收按钮点击事件和`selectPoly`方法。我们将从名为`QgsMapToolEmitPoint`的通用工具继承以创建点；我们还将使用名为`QgsRubberBand`的对象来处理多边形。然而，我们还必须执行选取过程以突出显示落在我们的选取多边形内的特征：
- en: '[PRE176]'
  id: totrans-601
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE176]'
- en: How it works...
  id: totrans-602
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'QGIS has a generic tool for highlighting features, but in this case, we can
    use the standard selection functionality, which simplifies our code. With the
    exception of a dialog to load new layers and the ability to show attributes, we
    have a very basic but nearly complete standalone GIS application.The following
    screenshot shows the selection tool in action:'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: QGIS有一个用于突出显示特征的通用工具，但在这个案例中，我们可以使用标准的选取功能，这简化了我们的代码。除了加载新图层对话框和显示属性的能力之外，我们有一个非常基础但几乎完整的独立GIS应用程序。以下截图显示了选取工具的效果：
- en: '![How it works...](img/00046.jpeg)'
  id: totrans-604
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/00046.jpeg)'
- en: Creating a mouse coordinate tracking tool
  id: totrans-605
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建鼠标坐标跟踪工具
- en: In this recipe, we'll build a tool that tracks and displays the mouse coordinates
    in real time. This tool will also demonstrate how to interact with the status
    bar of a QGIS application.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将构建一个实时跟踪和显示鼠标坐标的工具。此工具还将演示如何与QGIS应用程序的状态栏交互。
- en: Getting ready
  id: totrans-607
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will use the application framework from the *Adding standard map tools to
    the canvas* recipe, so complete that recipe first. We will extend that application
    with the coordinate tracking tool. A complete version of this application is available
    in the code samples provided with this book. It will also be beneficial to study
    the other two tool-related recipes in this chapter, *A map tool to draw polygons
    or lines on the canvas* and *A map tool to draw points on the canvas*, as this
    recipe builds on them as well.
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用来自*将标准地图工具添加到画布*菜谱的应用程序框架，因此首先完成该菜谱。我们将使用坐标跟踪工具扩展该应用程序。此书的代码示例中提供了一个此应用程序的完整版本。研究本章中的其他两个与工具相关的菜谱，*在画布上绘制多边形或线条的工具*和*在画布上绘制点的工具*也将有益，因为此菜谱也基于它们。
- en: How to do it...
  id: totrans-609
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We will add an event filter to the basic standalone QGIS application and use
    it to grab the current mouse coordinates as well as update the status bar. To
    do this, we need to perform the following steps:'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将向基本独立QGIS应用程序添加一个事件过滤器，并使用它来获取当前鼠标坐标以及更新状态栏。为此，我们需要执行以下步骤：
- en: 'As the last line of our application''s `__init__` method, insert the following
    line to create a default status bar message when the application loads:'
  id: totrans-611
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为我们应用程序`__init__`方法的最后一行，插入以下行以在应用程序加载时创建默认状态栏消息：
- en: '[PRE177]'
  id: totrans-612
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE177]'
- en: 'Immediately after the application''s `__init__` method, we will add the following
    event filter method:'
  id: totrans-613
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用程序的`__init__`方法之后立即，我们将添加以下事件过滤器方法：
- en: '[PRE178]'
  id: totrans-614
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE178]'
- en: 'In the `MainApp` class, as the second-last line, we must install the event
    filter using the following code:'
  id: totrans-615
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MainApp`类中，作为倒数第二行，我们必须使用以下代码安装事件过滤器：
- en: '[PRE179]'
  id: totrans-616
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE179]'
- en: How it works...
  id: totrans-617
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In the Qt framework, in order to watch out for mouse events, we must insert
    an event filter that allows us to monitor all the events in the application. Within
    the default event filter method, we can then process any event we want. In this
    case, we watch for any movements of the mouse.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 在Qt框架中，为了监视鼠标事件，我们必须插入一个事件过滤器，允许我们监视应用程序中的所有事件。在默认事件过滤器方法中，然后我们可以处理我们想要的任何事件。在这种情况下，我们监视鼠标的任何移动。
