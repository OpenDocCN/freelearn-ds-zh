- en: '*Chapter 4*: Data Manipulation and Preparation, Paving the Way to Plotly Express'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第4章*：数据操作与准备，为Plotly Express铺路'
- en: We saw that preparing data can take much more mental effort and code than the
    process of creating charts. Or, to put it differently, if we invest a good amount
    of time in preparing our data and making certain decisions about how and what
    we intend to do with it, the process of visualization can be made much easier.
    So far, we have used a small part of our dataset and didn't make any changes to
    its shape or format. And when making our charts, we followed the approach of building
    them from scratch by creating a figure and then adding different layers and options
    for traces, titles, and so on.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发现，准备数据可能比创建图表需要更多的脑力和代码。换句话说，如果我们在准备数据和决定如何以及做什么方面投入足够的时间，那么可视化过程将变得更加容易。到目前为止，我们只使用了数据集的一小部分，并且没有对其形状或格式进行任何更改。在制作图表时，我们遵循的是从头开始构建图表的方法，通过创建图形然后添加不同的层和选项，如轨迹、标题等。
- en: In this chapter, we will go through a thorough familiarization with the dataset
    and reshape it to an intuitive and easy-to-use format. This will help us in using
    a new approach for creating visualizations, using **Plotly Express**. Instead
    of starting with an empty rectangle and building layers on top of it, we will
    start with the features (columns) of our dataset, and create visualizations based
    on them. In other words, instead of being screen- or chart-oriented, we will work
    with more of a data-oriented approach. We will also compare the two approaches
    and discuss when to use them.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入熟悉数据集，并将其重塑为直观易用的格式。这将帮助我们使用一种新的方法来创建可视化，即使用**Plotly Express**。我们将不再从一个空白矩形开始并在其上构建图层，而是从数据集的特征（列）出发，根据这些特征创建可视化。换句话说，我们将不再是以屏幕或图表为中心，而是采用更以数据为导向的方法。我们还将比较这两种方法，并讨论何时使用它们。
- en: 'We will mainly cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将主要涵盖以下主题：
- en: Understanding long format (tidy) data
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解长格式（整洁型）数据
- en: Understanding the role of data manipulation skills
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解数据操作技能的作用
- en: Learning Plotly Express
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习Plotly Express
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Technically, no new packages will be used in this chapter, but as a major module
    of Plotly, we can consider Plotly Express to be a new one. We will also be extensively
    using `pandas` for data preparation, reshaping, and general manipulation. This
    will mainly be done in JupyterLab. Our dataset will consist of the files in the
    `data` folder in the root of the repository.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术角度来看，本章不会使用任何新包，但作为Plotly的一个主要模块，我们可以把Plotly Express视为一个新的模块。我们还将广泛使用`pandas`进行数据准备、重塑和一般操作。所有这些主要将在JupyterLab中完成。我们的数据集将由存储在根目录`data`文件夹中的文件组成。
- en: The code files of this chapter can be found on GitHub at [https://github.com/PacktPublishing/Interactive-Dashboards-and-Data-Apps-with-Plotly-and-Dash/tree/master/chapter_04](https://github.com/PacktPublishing/Interactive-Dashboards-and-Data-Apps-with-Plotly-and-Dash/tree/master/chapter_04).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在GitHub上找到：[https://github.com/PacktPublishing/Interactive-Dashboards-and-Data-Apps-with-Plotly-and-Dash/tree/master/chapter_04](https://github.com/PacktPublishing/Interactive-Dashboards-and-Data-Apps-with-Plotly-and-Dash/tree/master/chapter_04)
- en: Check out the following video to see the Code in Action at [https://bit.ly/3suvKi4](https://bit.ly/3suvKi4).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频，了解代码的实际应用：[https://bit.ly/3suvKi4](https://bit.ly/3suvKi4)
- en: Let's start by exploring the different formats in which we can have data, and
    what we can do about it.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始探索可以获取数据的不同格式，以及我们能为之做些什么。
- en: Understanding long format (tidy) data
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解长格式（整洁型）数据
- en: We have a moderately complex dataset that we will be working with. It consists
    of four CSV files, containing information on almost all the countries and regions
    in the world. We have more than 60 metrics spanning more than 40 years, which
    means that there are quite a lot of options and combinations to choose from.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个相对复杂的数据集。它由四个CSV文件组成，包含关于世界上几乎所有国家和地区的信息。我们有超过60个指标，跨越超过40年，这意味着有很多选择和组合可以选择。
- en: But before going through the process of preparing our dataset, I'd like to demonstrate
    our end goal with a simple example, so you have an idea of where we are heading.
    It will also hopefully show why we are investing time in making those changes.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在准备我们的数据集之前，我想通过一个简单的示例来展示我们的最终目标，这样你就能了解我们将要前进的方向。希望这也能解释为什么我们要投入时间进行这些更改。
- en: Plotly Express example chart
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Plotly Express示例图表
- en: 'Plotly Express ships with a few datasets for practicing and testing certain
    features whenever you want to do so. They fall under the `data` module of `plotly.express`,
    and calling them as functions returns the respective dataset. Let''s take a look
    at the famous Gapminder dataset:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Plotly Express附带了一些数据集，方便你在任何时候进行练习和测试特定功能。它们位于`plotly.express`的`data`模块中，调用它们作为函数会返回相应的数据集。让我们来看看著名的Gapminder数据集：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Running this code displays sample rows of the `gapminder` DataFrame as you
    can see in *Figure 4.1*:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码将显示`gapminder` DataFrame的示例行，如*图 4.1*所示：
- en: '![Figure 4.1 – The Gapminder dataset included in Plotly Express](img/B16780_04_1.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.1 – Plotly Express中包含的Gapminder数据集](img/B16780_04_1.jpg)'
- en: Figure 4.1 – The Gapminder dataset included in Plotly Express
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 – Plotly Express中包含的Gapminder数据集
- en: 'The dataset structure seems straightforward. For each unique combination of
    **country**, **continent**, and **year**, we have three metrics: **lifeExp**,
    **pop**, and **gdpPercap**. The **iso_alpha** and **iso_num** columns seem to
    be encoded values for the countries.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 数据集结构看起来很简单。对于每一个独特的**国家**、**大洲**和**年份**的组合，我们有三个指标：**lifeExp**、**pop**和**gdpPercap**。**iso_alpha**和**iso_num**列似乎是国家的编码值。
- en: Let's see how we might summarize the `gapminder` `data_frame` with a `scatter`
    plot.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何通过`scatter`图来总结`gapminder`的`data_frame`。
- en: On the `x` axis, we can have the `y` axis, it would be good to see the `size`
    of the markers reflect the population of the respective countries.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在`x`轴上，我们可以有`y`轴，最好能看到标记的`size`反映出相应国家的人口。
- en: We might also split the chart horizontally (`facet_col`), into sub-plots, one
    for each continent, on one row, and make the sub-plot titles reflect that as well.
    We can also assign a separate `color` to each continent's markers. For more clarity,
    we can set the `title` of the figure to `'Life Expectancy and GDP per capita.
    1952 – 2007'`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将图表水平拆分（`facet_col`），在一行中为每个大洲创建子图，并使子图标题也能反映这一点。我们还可以为每个大洲的标记分配不同的`color`。为了更加清晰，我们可以将图表的`title`设置为`'人均GDP与寿命预期
    1952 – 2007'`。
- en: To make them clearer, we can change the `labels` of the X and Y axes' titles
    from `'gdpPercap'` to `'GDP per Capita'`, and from `'lifeExp'` to `'Life Expectancy'`
    respectively.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让它们更清晰，我们可以将X轴和Y轴标题的`labels`从`'gdpPercap'`更改为`'人均GDP'`，将`'lifeExp'`更改为`'寿命预期'`。
- en: We would expect the GDP per capita to have outliers and not to be normally distributed,
    so we can set the type of the X-axis scale to logarithmic (`log_x`). The range
    of the Y-axis (`range_y`) should be the interval [20, 100], so we can see how
    life expectancy varies on a fixed vertical range.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以预期人均GDP存在离群值且不符合正态分布，因此我们可以将X轴的比例类型设置为对数（`log_x`）。Y轴的范围（`range_y`）应为[20,
    100]区间，这样我们就能看到在固定垂直范围内寿命预期的变化。
- en: Hovering over the markers should show the full information for that particular
    country, and the title of the hover label (`hover_name`) should take the name
    of the country. Having the same chart overlaid on top of itself for all years
    would be really cluttered and almost impossible to read. So let's have a separate
    `animation_frame` for each of the years.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 将鼠标悬停在标记上应该显示该国家的完整信息，悬停标签的标题（`hover_name`）应为该国的名称。将同一个图表叠加在所有年份上会显得非常杂乱，几乎无法阅读。因此，我们为每个年份设置一个单独的`animation_frame`。
- en: It would be great if we could have a play button that would move the markers
    across years when clicked, one frame per year, like a video, with the option to
    stop it at a certain year.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能有一个播放按钮，当点击时，标记会按年移动，一个年为一帧，像视频一样播放，并且可以在某一年暂停，那就太好了。
- en: 'The `height` of the figure should be 600 pixels:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图表的`height`应该是600像素：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Running the preceding code would produce the visualization in *Figure 4.2*:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上述代码将生成*图 4.2*中的可视化效果：
- en: '![Figure 4.2 – An interactive chart of the Gapminder dataset using Plotly Express](img/B16780_04_2.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.2 – 使用Plotly Express展示的Gapminder数据集交互式图表](img/B16780_04_2.jpg)'
- en: Figure 4.2 – An interactive chart of the Gapminder dataset using Plotly Express
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2 – 使用Plotly Express展示的Gapminder数据集交互式图表
- en: My first observation for this process is that it took us much more text than
    code to describe the chart. Actually, it was a single line of code that produced
    it.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我对这个过程的第一个观察是，描述图表所需的文字比代码多得多。实际上，只需要一行代码就能生成它。
- en: Clicking the play button would animate the chart, and you would see a new frame
    for each year. You could also pause or move to a certain year if you want. This
    way you can see how the relationship between the two variables progressed through
    the years, like watching a short movie.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 点击播放按钮将动画化图表，每年会显示一个新帧。如果需要，你也可以暂停或跳转到某一年。这样你可以看到两个变量之间的关系如何随着年份推移而变化，就像看一部短片电影。
- en: You can also see that hovering over a certain marker representing a country
    would show all relevant data that was used to specify the location, size, color,
    and whatever other attributes we might have set. The `hover_name` argument was
    set to `'country'` and this is why you see it in bold as the title of the label.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以看到，当你悬停在表示某个国家的标记上时，会显示出所有相关数据，这些数据用于指定位置、大小、颜色以及我们可能设置的其他属性。`hover_name`
    参数被设置为 `'country'`，这就是为什么你看到它以粗体显示作为标签的标题。
- en: In most cases, we have markers overlapping, which makes it difficult to understand
    the chart. Because Plotly figures are interactive by default, we can easily use
    the modebar buttons to zoom in/out, or we can manually select a certain rectangle
    to zoom into.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，我们有标记重叠，这使得理解图表变得困难。由于 Plotly 图形默认是交互式的，我们可以轻松使用模式栏按钮进行缩放，或者可以手动选择一个矩形进行放大。
- en: 'Zooming into Africa by selecting the rectangle that contains only its markers,
    *Figure 4.3* shows how the chart changes, and now it is much easier to read the
    African sub-plot:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 通过选择仅包含非洲标记的矩形来放大非洲，*图 4.3* 展示了图表的变化，现在阅读非洲子图变得更容易了：
- en: '![Figure 4.3 – Zooming into specific regions in charts](img/B16780_04_3.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.3 – 放大图表中的特定区域](img/B16780_04_3.jpg)'
- en: Figure 4.3 – Zooming into specific regions in charts
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3 – 放大图表中的特定区域
- en: Note that all other continent charts were also zoomed in to the same zoom level
    of Africa. Feel free to explore more of the interactive features, but I hope this
    shows how powerful and intuitive this approach is.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，其他大陆的图表也被放大到与非洲相同的缩放级别。可以自由探索更多交互式功能，但我希望这能展示出这种方法的强大和直观。
- en: Tip
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: There are many colored charts in this chapter. I did my best to make sure you
    can easily distinguish between colored markers as much as possible. It's still
    better to refer to the color version of the book, which is available online, if
    you are reading the print version.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中有许多彩色图表。我尽力确保你可以尽可能容易地区分不同的彩色标记。如果你正在阅读打印版，最好参考该书的彩色版本，该版本可以在线访问。
- en: There are two main reasons that allowed us to create such a rich chart with
    one line of code. First, Plotly Express has powerful features and is specially
    designed to produce such charts with minimal code. This will be covered in more
    detail later. Second, the structure of the dataset plays an important role in
    the process. Once we have our data in a consistent format, it becomes easy to
    model, visualize, or run any kind of analysis.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能够用一行代码创建如此丰富图表的原因有两个。首先，Plotly Express 拥有强大的功能，专门设计用来通过最少的代码生成这样的图表。稍后会详细介绍这一点。第二，数据集的结构在这个过程中起着重要作用。一旦我们的数据具有一致的格式，就很容易进行建模、可视化或进行任何类型的分析。
- en: Let's take a look at the main aspects of this data format.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这种数据格式的主要方面。
- en: Main attributes of long format (tidy) data
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 长格式（整洁）数据的主要属性
- en: One of the key features of this structure is that it allows each marker on the
    chart to be independently represented by a row. Each value in those rows belongs
    to a distinct column. In turn, those columns each represent a separate variable
    and have their own data types. This makes it easy to map color, size, or whatever
    visual attributes we want, simply by declaring which column values we want to
    express with which visual attribute.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 该结构的一个关键特点是，它允许图表上的每个标记都通过一行独立表示。这些行中的每个值属于一个不同的列。反过来，这些列每个代表一个独立的变量，并具有自己的数据类型。这使得我们可以轻松地映射颜色、大小或任何其他视觉属性，只需声明我们希望用哪个视觉属性来表示哪个列的值。
- en: 'Notice that what I just said is close to the definition of a DataFrame:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我刚才说的内容接近 DataFrame 的定义：
- en: A set of columns, where each has exactly one type of data.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一组列，每列只有一种数据类型。
- en: Columns in a DataFrame can be of different types.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DataFrame 中的列可以是不同类型的。
- en: All columns have the same length, even though they might contain missing values.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有列的长度相同，即使它们可能包含缺失值。
- en: From a conceptual point of view, the main difference between a long form DataFrame
    and a regular one is having one observation per row (country, person, brand, or
    a combination of them), and one variable per column (population, size, length,
    height, revenue, and so on). For example, the **country** column contains countries
    and only countries. Additionally, countries are only present in this column. So,
    there is no ambiguity about where or how to access them.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 从概念角度来看，长格式DataFrame和常规DataFrame之间的主要区别是每行包含一个观察值（例如：国家、个人、品牌或它们的组合），而每列包含一个变量（例如：人口、大小、长度、身高、收入等）。例如，**国家**列只包含国家信息，且该列中只会出现国家数据。因此，对于这些数据的访问不会产生任何歧义。
- en: This format is not required and is not any more "correct" than other formats.
    It is simply intuitive, consistent, and easy to use. The actual requirement for
    producing the visualization we just did is to have a set of values for the X axis
    and another set of values of the same length for the Y axis. For other features
    such as color and size, we also need sets of numbers or names of the same length,
    so we can properly map them together. The DataFrame is a natural fit for such
    a requirement.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这种格式不是必需的，也不比其他格式更“正确”。它只是直观、一致且易于使用。我们刚刚制作的可视化的实际要求是：需要为X轴准备一组数值，Y轴需要另一组相同长度的数值。对于其他特性，如颜色和大小，我们也需要相同长度的数字或名称集合，这样才能将它们正确地映射在一起。DataFrame是这种需求的自然匹配。
- en: In the chart we just produced, you can easily see that we can have all markers
    the same size, simply by removing the `size` argument. Changing `facet_col` to
    `facet_row` would immediately have the sub-plots vertically stacked on top of
    one another as opposed to side by side. Minimal tweaks allow us to introduce big
    changes to our visualizations. This is as simple as flipping switches on a dashboard,
    pun intended!
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们刚刚生成的图表中，你可以很容易地看到，我们可以通过移除`size`参数让所有标记保持相同的大小。将`facet_col`改为`facet_row`会立即将子图垂直堆叠，而不是并排显示。通过微小的调整，我们可以对可视化进行大幅改变。这就像在仪表盘上切换开关一样简单，带有一点幽默感！
- en: I hope the end goal is now clear. We want to check the four files of our dataset
    and see how to generate long format (tidy) DataFrames. As a result, every column
    would contain data about one variable (year, population, Gini index, and so on),
    and every row would describe an observation (a combination of country, year, metric,
    and other values). Once that is done, we should be able to look at the data, specify
    what we want, and express that with a concise Plotly Express function call.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望最终目标现在已经清楚了。我们要检查数据集中的四个文件，并查看如何生成长格式（整洁型）DataFrame。这样，每一列将包含关于一个变量的数据（例如：年份、人口、基尼指数等），而每一行则描述一个观察值（国家、年份、指标以及其他值的组合）。完成这些后，我们应该能够查看数据，指定我们想要的内容，并通过简洁的Plotly
    Express函数调用表达出来。
- en: The process will be much clearer once we start the preparation, so let's start
    right away.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦开始准备过程，整个过程会更加清晰，所以我们现在就开始吧。
- en: Understanding the role of data manipulation skills
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解数据操作技能的作用
- en: In practical situations, we rarely have our data in the format that we want;
    we usually have different datasets that we want to merge, and often, we need to
    normalize and clean up the data. For these reasons, data manipulation and preparation
    will always play a big part in any data visualization process. So, we will be
    focusing on this in this chapter and throughout the book.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际情况下，我们的数据通常并不是我们希望的格式；我们通常有不同的数据集需要合并，而且常常需要对数据进行规范化和清理。正因如此，数据操作和准备将在任何数据可视化过程中发挥重要作用。因此，我们将在本章以及全书中重点关注这一点。
- en: 'The plan for preparing our dataset is roughly the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 准备数据集的计划大致如下：
- en: Explore the different files one by one.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一一探索不同的文件。
- en: Check the available data and data types and explore how each can help us categorize
    and analyze the data.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查可用的数据和数据类型，探索每种数据如何帮助我们对数据进行分类和分析。
- en: Reshape the data where required.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在需要的地方重新塑形数据。
- en: Combine different DataFrames to add more ways to describe our data.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 合并不同的DataFrame，以增加描述数据的方式。
- en: Let's go through these steps right away.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们马上开始执行这些步骤。
- en: Exploring the data files
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索数据文件
- en: 'We start by reading in the files in the `data` folder:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从读取`data`文件夹中的文件开始：
- en: '[PRE2]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To make things clear, I''ll use the distinct part of each filename as the variable
    name for each DataFrame: `''PovStats<name>.csv''`.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为了明确起见，我将使用每个文件名的独特部分作为每个DataFrame的变量名：`'PovStats<name>.csv'`。
- en: The series file
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 系列文件
- en: 'We start by exploring the `series` file, using the following code:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先通过以下代码来探索`series`文件：
- en: '[PRE3]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This will display the `shape` attribute of the DataFrame, as well as the first
    five rows, as you can see in *Figure 4.4*:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示DataFrame的`shape`属性，以及前五行数据，如你在*图4.4*中所见：
- en: '![Figure 4.4 – The first few rows and columns of the PovStatsSeries file](img/B16780_04_4.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图4.4 – PovStatsSeries文件的前几行和列](img/B16780_04_4.jpg)'
- en: Figure 4.4 – The first few rows and columns of the PovStatsSeries file
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4 – PovStatsSeries文件的前几行和列
- en: It seems we have 64 different indicators, and for each one of them, we have
    21 attributes, explanations, and notes. This is already in long format – columns
    contain data about one attribute, and rows are complete representations of an
    indicator, so there is nothing to change. We just need to explore what data is
    available and get familiar with this table.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 似乎我们有64个不同的指标，并且每个指标都有21个属性、说明和注释。这个数据已经是长格式——列包含关于一个属性的数据，行是指标的完整表示，因此不需要做任何修改。我们只需要探索可用数据并熟悉这个表格。
- en: Using this information, you can easily imagine creating a special dashboard
    for each indicator and placing it on a separate page. Each row seems to have enough
    information to produce an independent page with a title, description, details,
    and so on. The main content area of the page could be a visualization of that
    indicator, for all countries and across all years. This is just one idea.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些信息，你可以轻松地设想为每个指标创建一个独立的仪表板，并将其放在单独的页面上。每一行似乎都包含足够的信息，以便生成一个独立的页面，包含标题、描述、详细信息等。页面的主要内容区域可以是该指标的可视化，涵盖所有国家和所有年份。这只是一个想法。
- en: 'Let''s take a closer look at some interesting columns:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看一些有趣的列：
- en: '[PRE4]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We can see that the indicators are spread across four topics, the counts of
    which can be seen above.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到这些指标分布在四个主题中，每个主题的计数可以在上面看到。
- en: 'There is a column for `Unit of measure`, which might be interesting to explore:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个`计量单位`的列，可能值得探索：
- en: '[PRE5]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: It seems we have indicators whose units of measure are either percentages (rates)
    or not available (`NaN`). This might help us later in grouping certain types of
    charts together.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 似乎我们有一些指标，其计量单位要么是百分比（比率），要么是不可用（`NaN`）。这可能会在以后帮助我们将某些类型的图表归为一类。
- en: 'Another important column is the `series` DataFrame by the **Topic** column,
    and then summarizes the **Limitations and Exceptions** column values by their
    count and number of unique values:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的列是按**主题**列分组的`series` DataFrame，然后按计数和唯一值的数量总结**限制和例外**列的值：
- en: '[PRE6]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The output can be seen in *Figure 4.5*:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 输出可以在*图4.5*中看到：
- en: '![Figure 4.5 – Counts and unique values of Limitations and Exceptions](img/B16780_04_5.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图4.5 – 限制和例外的计数与唯一值](img/B16780_04_5.jpg)'
- en: Figure 4.5 – Counts and unique values of Limitations and Exceptions
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5 – 限制和例外的计数与唯一值
- en: It looks like this is going to be a good reference point for us to learn more
    about the different indicators that we have. It would also be very helpful for
    the users so they can also get a better understanding of what they are analyzing.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来这将成为我们了解不同指标的一个良好参考点。这对于用户也非常有帮助，这样他们也能更好地理解他们正在分析的内容。
- en: The country file
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 国家文件
- en: 'Let''s now take a look at the next file, `''PovStatsCountry.csv''`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下下一个文件，`'PovStatsCountry.csv'`：
- en: '[PRE7]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This will display the shape of the DataFrame as well as a sample of rows and
    columns, as in *Figure 4.6*:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示DataFrame的形状以及行和列的样本，如*图4.6*所示：
- en: '![Figure 4.6 – Sample rows and columns from the country file](img/B16780_04_6.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图4.6 – 来自国家文件的样本行和列](img/B16780_04_6.jpg)'
- en: Figure 4.6 – Sample rows and columns from the country file
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.6 – 来自国家文件的样本行和列
- en: In the call to `read_csv`, we have specified `keep_default_na=False` and `na_values=''`.
    The reason is that `pandas` interprets strings such as `NA` and `NaN` as indicators
    of missing values. One of the countries, Namibia, has a `NA`, so it was missing
    from the DataFrame. That's why we had to make this change. That's a very good
    example of how things might go wrong in unexpected ways.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`read_csv`时，我们指定了`keep_default_na=False`和`na_values=''`。原因是`pandas`将像`NA`和`NaN`这样的字符串解释为缺失值的指示符。纳米比亚这个国家有一个`NA`，因此它在DataFrame中缺失了。这就是我们需要进行此更改的原因。这是一个非常好的例子，说明事情可能以意想不到的方式出错。
- en: This is very interesting metadata about the countries and regions in our dataset.
    It is a very small dataset but can be very useful in enriching our understanding,
    as well as giving us more options to filter and group our countries. It is also
    in long (tidy) format. Let's take a look at some of its interesting columns.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这是关于我们数据集中国家和地区的非常有趣的元数据。它是一个非常小的数据集，但可以在丰富我们理解的同时，非常有助于提供更多的过滤和分组国家的选项。它也是长格式（tidy）。让我们看一看其中一些有趣的列。
- en: 'The **Region** column seems straightforward. We can check to see what regions
    are available, as well as the counts of countries in each region:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**Region** 列似乎很直观。我们可以检查有哪些区域可用，以及每个区域内国家的数量：'
- en: '[PRE8]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The result can be seen in *Figure 4.7*:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 结果可以在*图 4.7* 中看到：
- en: '![Figure 4.7 – Counts of countries per region](img/B16780_04_7.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.7 – 每个区域的国家数量](img/B16780_04_7.jpg)'
- en: Figure 4.7 – Counts of countries per region
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.7 – 每个区域的国家数量
- en: 'Another column that might be helpful is **Income Group**. Once we have this
    properly mapped to the right values, we might consider splitting our sub-plots
    by income group, as we previously did with continents in the first example of
    this chapter:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可能有帮助的列是**Income Group**。一旦我们将其正确映射到相应的值，我们可能会考虑像本章第一部分中对大陆做的那样，按收入组拆分我们的子图：
- en: '[PRE9]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Having fifteen `NaN` values is consistent with the number of regions and classifications
    combined, which we will see shortly. The income level of countries is independent
    of their geographic locations.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有十五个`NaN`值与区域和分类的总数相符，稍后我们会看到这一点。国家的收入水平与其地理位置无关。
- en: If you look at the `Lower middle income`. I think it's important to distinguish
    between them, and we can easily create a special column for that, so we can differentiate
    between countries and non-countries.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看`Lower middle income`，我认为区分它们是很重要的，我们可以轻松地为此创建一个特殊的列，这样我们就能区分国家和非国家。
- en: 'The `is_country` Boolean column:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`is_country` 布尔型列：'
- en: '[PRE10]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Figure 4.8* shows a sample of rows containing countries and regions, as well
    as classifications:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4.8* 显示了包含国家和地区以及分类的行样本：'
- en: '![Figure 4.8 – A sample of countries and regions with the is_country column](img/B16780_04_8.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.8 – 含有 is_country 列的国家和地区样本](img/B16780_04_8.jpg)'
- en: Figure 4.8 – A sample of countries and regions with the is_country column
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.8 – 含有 is_country 列的国家和地区样本
- en: 'The full listing of those categories can be found by getting a subset of the
    `country` DataFrame where the **Region** column contains missing values and then
    getting the **Short Name** column:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过获取`country` DataFrame的子集，筛选出**Region**列为空值的行，然后获取**Short Name**列，查看这些分类的完整列表：
- en: '[PRE11]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Going through this process is very important in helping you plan your dashboards
    and apps. For example, knowing that we have four classifications for income levels
    means that it makes sense to create sub-plots for them side by side. But if we
    had 20 classifications, it might not be a good idea to do so.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历这个过程对帮助你规划仪表板和应用程序非常重要。例如，知道我们有四个收入水平的分类意味着并排创建它们的子图是合理的。但如果我们有20个分类，可能就不太适合这样做了。
- en: Let's create one more column and then move on to the next file.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再创建一个列，然后继续处理下一个文件。
- en: Since we are dealing with countries, we can use flags as visual and easy-to-spot
    identifiers. Since flags are emojis, and they are basically Unicode characters,
    they can be rendered as text on our charts, just like other regular text. We can
    later consider using other emojis as symbols that make it easy for the reader
    to spot growth and decline, for example (using the relevant arrow symbols and
    colors). This can also be useful when you don't have much space and you still
    need to communicate something to the users, especially on smaller screens. An
    emoji is worth a thousand words!
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们处理的是国家，可以使用国旗作为直观且易于识别的标识符。由于国旗是表情符号，且本质上是Unicode字符，它们可以像其他常规文本一样在我们的图表上呈现为文本。我们以后还可以考虑使用其他表情符号作为符号，帮助读者轻松识别增长与下降，例如（使用相关的箭头符号和颜色）。当空间有限而你仍然需要与用户沟通时，尤其是在小屏幕上，这也很有用。一张表情符号胜过千言万语！
- en: The interesting thing about country flag emojis is that they are a concatenation
    of two special letters whose name is `"REGIONAL INDICATOR SYMBOL LETTER <letter>"`.
    For example, these are the regional indicator symbols for the letters A and B:AB.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 关于国家国旗表情符号有趣的是，它们是由两个特殊字母连接而成，这些字母的名称是`"REGIONAL INDICATOR SYMBOL LETTER <字母>"`。例如，这些是字母A和B的区域指示符符号：AB。
- en: 'You simply have to get the two-letter code of a certain country, and look up
    the name from the `unicodedata` Python Standard Library module. The `lookup` function
    takes the name of a character and returns the character itself:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需获取某个国家的两位字母代码，然后通过 `unicodedata` Python 标准库模块查找该国家的名称。`lookup`函数接受一个字符名称并返回该字符本身：
- en: '[PRE12]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Once we have two letters representing a country, we can look them up, and concatenate
    them to produce the respective country's flag. We can create a simple function
    that does that. We just need to handle the situation where the provided letters
    are either `NaN` or not part of the country code list.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们得到了代表国家的两位字母代码，我们就可以查找它们，并将它们连接起来生成相应国家的国旗。我们可以创建一个简单的函数来实现这一点。我们只需要处理那些提供的字母是`NaN`或不属于国家代码列表的情况。
- en: 'We can create a `country_codes` variable and check against it. If the provided
    letters are not in the list, we return the empty character, otherwise we create
    an emoji flag:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个`country_codes`变量并进行检查。如果提供的字母不在列表中，我们返回空字符，否则我们创建一个表情符号国旗：
- en: '[PRE13]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can now easily define the `flag` function:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以轻松地定义`flag`函数：
- en: '[PRE14]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Using this function, we can create our `flag` column:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个函数，我们可以创建我们的`flag`列：
- en: '[PRE15]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Figure 4.9* shows a random sample of countries, their flags, and the **is_country**
    column:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4.9* 显示了随机选择的国家、它们的国旗以及**is_country**列：'
- en: '![Figure 4.9 – Sample of rows showing countries and their flags](img/B16780_04_9.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.9 – 显示国家及其国旗的行样本](img/B16780_04_9.jpg)'
- en: Figure 4.9 – Sample of rows showing countries and their flags
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.9 – 显示国家及其国旗的行样本
- en: In the case where `NaN` because in many cases we might want to concatenate the
    country name with its flag, for titles or labels for instance, and an empty string
    would not cause any issues. Note that if you save the DataFrame to a file and
    reopen it, `pandas` will interpret empty strings as `NaN`, and you will have to
    either convert them or prevent them from being interpreted as such.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是`NaN`的情况，因为在许多情况下我们可能希望将国家名称与其国旗连接起来，例如标题或标签，空字符串不会导致任何问题。请注意，如果你将数据框保存到文件并重新打开，`pandas`会将空字符串解释为`NaN`，你将需要将它们转换或防止它们被解释为`NaN`。
- en: The country-series file
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 国家系列文件
- en: Our next file "`PovStatsCountry-Series.csv`" simply contains a list of the country
    codes and shows the sources of their population data. We'll see if/when we might
    use this as metadata in a relevant chart.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一个文件 "`PovStatsCountry-Series.csv`" 简单地包含了国家代码的列表，并展示了它们的人口数据来源。我们将看看是否/何时可以将其作为元数据在相关图表中使用。
- en: The footnotes file
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 脚注文件
- en: 'Next, we''ll take a quick look at the footnotes file `PovStatsFootNote.csv`:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们快速查看`PovStatsFootNote.csv`的脚注文件：
- en: 'There is an empty column `YR2015` and that''s why we extract the characters
    starting from index 2\. We renamed the columns to make them consistent with the
    `series` DataFrame, to make it easy to merge them when needed:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个空的列`YR2015`，因此我们从索引2开始提取字符。我们重命名了列，以使其与`series`数据框一致，这样在需要时便于合并：
- en: '[PRE16]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Figure 4.10* shows a few rows from the `footnote` DataFrame:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4.10* 显示了`footnote`数据框中的几行：'
- en: '![Figure 4.10 – Sample of rows from the footnote file](img/B16780_04_10.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.10 – 脚注文件中的行样本](img/B16780_04_10.jpg)'
- en: Figure 4.10 – Sample of rows from the footnote file
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.10 – 脚注文件中的行样本
- en: That looks like a large number of notes about the data. We should make sure
    to include them somehow, to make sure the readers get the full picture. Those
    footnotes seem to be based on combinations of country, indicator, and year. Since
    the three are encoded in a consistent way with other tables, it should be straightforward
    to incorporate and map them to the relevant values elsewhere.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来像是大量关于数据的注释。我们应该确保以某种方式包含它们，以确保读者能够获得完整的视图。这些脚注似乎是基于国家、指标和年份的组合。由于这三者在其他表格中以一致的方式编码，因此应该可以轻松地将它们整合并映射到其他地方的相关值。
- en: The data file
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据文件
- en: Next is the main data file, which we have already worked with in previous chapters,
    but we want to now reshape and merge with other DataFrames, for a more intuitive
    and powerful view into our dataset.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是主数据文件，我们已经在前面的章节中使用过，但现在我们想要重新整理并与其他数据框合并，以便更直观、更强大地查看我们的数据集。
- en: 'Let''s now explore this file:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们探索这个文件：
- en: '[PRE17]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The preceding code removes the column named `data` DataFrame, and displays
    a random sample of rows, as you can see in *Figure 4.11*:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码删除了名为`data`的列，并显示了行的随机样本，正如你在*图 4.11*中看到的：
- en: '![Figure 4.11 – Sample of rows and columns from the data file](img/B16780_04_11.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.11 – 数据文件中的行和列样本](img/B16780_04_11.jpg)'
- en: Figure 4.11 – Sample of rows and columns from the data file
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.11 – 数据文件中的行和列样本
- en: 'It''s always interesting to know how many missing values we have, and what
    percentage they form of all values. The interesting parts are the columns starting
    from `isna` method returns a `Series` of Booleans for each column. Taking the
    mean of that gets the percentage of missing values per column, as a `Series`.
    Running `mean` again gives the overall percentage of missing values:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 了解缺失值的数量及其占所有值的百分比总是很有趣的。有趣的部分是从 `isna` 方法返回的每列布尔值的 `Series`。取其均值即可得到每列缺失值的百分比，结果是一个
    `Series`。再运行一次 `mean` 可以得到缺失值的总体百分比：
- en: '[PRE18]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 91.8% of our cells are empty. This has important implications for the results
    because most of the time we won't have enough data, or we won't have it for certain
    countries. Many countries didn't exist in their current form before the early
    nineties, for example, so this is one of the reasons. You can check out the `series`
    DataFrame and all the information about the indicators and the data collection
    issues where applicable.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有 91.8% 的单元格是空的。这对结果有重要的影响，因为大部分时间我们没有足够的数据，或者某些国家的数据缺失。例如，许多国家在九十年代初之前并没有以现有形式存在，这就是其中一个原因。你可以查看
    `series` DataFrame，以及有关指标和数据收集问题的所有信息（如果适用）。
- en: Let's now explore how we can reshape DataFrames to and from long format, and
    more importantly, why we would want to do so.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们探讨如何将 DataFrame 转换为长格式，并且更重要的是，为什么我们要这么做。
- en: Melting DataFrames
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使 DataFrame 变长
- en: One of the first things you probably noticed is that years are spread across
    columns, with the values corresponding to them, each in its respective cell under
    the respective year. The issue is that `1980` is not really a variable. A more
    useful way is to have a `year` variable, and in that column, the values would
    vary from 1974 to 2019\. If you remember the way we created the first chart in
    this chapter, you can see how this makes our life much easier. Let me illustrate
    what I mean, using a small dataset so things are clear, and then we can implement
    the same approach with the `data` DataFrame.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能首先注意到的一点是，年份被分布在不同的列中，值对应于它们，每个值都在对应年份下的各自单元格中。问题是，`1980` 并不是真正的一个变量。一个更有用的方式是拥有一个
    `year` 变量，在该列中，值会从 1974 年到 2019 年不等。如果你记得我们在本章创建第一个图表的方式，你就能明白这样做能让我们的工作变得更加轻松。让我用一个小数据集来说明我的意思，这样事情会更清楚，然后我们可以在
    `data` DataFrame 上实施相同的方法。
- en: '*Figure 4.12* shows how we can have the same data structured differently while
    containing the same information:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4.12* 展示了我们如何以不同的结构展示相同的数据，同时保持相同的信息：'
- en: '![Figure 4.12 – Two datasets containing the same information in two different
    formats](img/B16780_04_12.jpg)![Figure 4.12 – Two datasets containing the same
    information in two different formats](img/B16780_04_13.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.12 – 包含相同信息的两个数据集，采用两种不同的格式](img/B16780_04_12.jpg)![图 4.12 – 包含相同信息的两个数据集，采用两种不同的格式](img/B16780_04_13.jpg)'
- en: Figure 4.12 – Two datasets containing the same information in two different
    formats
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.12 – 包含相同信息的两个数据集，采用两种不同的格式
- en: Our current DataFrame is structured like the table on the right, and it would
    be easier to have it in a format like the one on the left.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当前的 DataFrame 结构如右侧的表格所示，使用左侧那种格式会更加方便。
- en: 'The difficulty with the wide format is that the variables are presented in
    different ways. In some cases, they are displayed vertically in a column (**country**
    and **indicator**), while in others, they are displayed horizontally across the
    columns **2015** and **2020**. Accessing the same data in the long format DataFrame
    is straightforward: we simply specify the columns that we want. In addition to
    that, we get automatic mapping of values. For example, taking the columns **year**
    and **value** from the long DataFrame would automatically map 2015 to 100, 2015
    to 10, and so on. At the same time, each row is a complete and independent representation
    of the case we are dealing with.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 宽格式的难点在于变量的呈现方式不同。在某些情况下，变量是垂直显示在一列中（**国家** 和 **指标**），而在其他情况下，它们是水平显示在 **2015**
    和 **2020** 等列中。访问长格式 DataFrame 中相同的数据非常简单：我们只需指定想要的列。此外，我们可以自动映射值。例如，从长格式 DataFrame
    中提取 **year** 和 **value** 列时，系统会自动将 2015 映射为 100，2015 映射为 10，依此类推。同时，每一行都是我们所处理的案例的完整且独立的表示。
- en: 'The good news is that this is doable with one call to the `melt` method:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，这可以通过一次调用`melt`方法来实现：
- en: '[PRE19]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here is an overview of what the preceding code and parameters do:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是前述代码和参数的概述：
- en: '`id_vars`: Keep these as rows and duplicate them as needed to keep the mapping
    in place.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id_vars`：将这些列作为行保留，并根据需要重复它们以保持映射关系。'
- en: '`value_vars`: Take these columns and make them values, melt them into a new
    column, and make sure the mapping with other values remains consistent with the
    previous structure. If we don''t specify `value_vars`, then this operation will
    be used for all unspecified columns (all columns except `id_vars`).'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`value_vars`：将这些列作为值，将它们“熔化”成一个新列，并确保与其他值的映射与之前的结构一致。如果我们没有指定`value_vars`，那么该操作将应用于所有未指定的列（除了`id_vars`）。'
- en: '`var_name`: Optional. What you want this newly created column to be named –
    "`year`" in this case.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`var_name`：可选。您希望新创建的列命名为何—在此情况下为“`year`”。'
- en: 'Let''s do this operation on our `data` DataFrame:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在我们的`data`数据框上执行此操作：
- en: '[PRE20]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The code is almost identical to the previous example. We first created a list
    of `id_vars` and used it for the argument of the same name. Right after that,
    we removed the missing values under the `value` column. We could have changed
    the name of this column by using the `value_name` parameter, but "`value`" seems
    appropriate. We then converted the years to integers. Running this code displays
    the shape and a sample of the new `data_melt` DataFrame, shown in *Figure 4.13*:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与前面的示例几乎相同。我们首先创建了一个`id_vars`的列表，并将其用作同名参数的参数。紧接着，我们删除了`value`列下的缺失值。我们本可以通过使用`value_name`参数来更改该列的名称，但“`value`”似乎比较合适。然后，我们将年份转换为整数。运行这段代码会显示新`data_melt`数据框的形状和示例，见*图
    4.13*：
- en: '![Figure 4.13 – The data DataFrame after being "melted"](img/B16780_04_14.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.13 – 数据框在被“熔化”后的样子](img/B16780_04_14.jpg)'
- en: Figure 4.13 – The data DataFrame after being "melted"
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.13 – 数据框在被“熔化”后的样子
- en: The first four columns are the same as they were, with each unique combination
    intact. We now have all the year columns and their values, condensed into two
    columns, **year** and **value**.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 前四列与之前相同，每个唯一的组合保持不变。现在，我们将所有年份列及其值压缩成了两列，**year**和**value**。
- en: Now let's see how we can improve the structure further by doing the reverse
    operation on other columns.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何通过对其他列执行逆操作进一步改进结构。
- en: Pivoting DataFrames
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据框透视
- en: The **Indicator Name** column might be improved by doing the reverse of the
    operation that we just did to the years columns. Ideally, we should have a column
    for population, another one for poverty rates, and so on. Let's first do this
    using our long (melted) example DataFrame so it's clear.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**指标名称**列可以通过对我们刚才对年份列进行的操作的逆操作来改进。理想情况下，我们应该为人口、贫困率等分别创建不同的列。让我们首先使用我们的长格式（已“熔化”）示例数据框来演示，以便更清楚地理解。'
- en: 'Assume we wanted to convert the unique values in the `pivot` method for that.
    This can give us a "round trip" back where we came from, using the `melt` method.
    Here, I''m using it on different columns:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要使用`pivot`方法转换唯一值。这样可以通过使用`melt`方法实现“回程”，返回到原来的格式。这里，我正在对不同的列使用它：
- en: '[PRE21]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Running this code would convert the melted DataFrame to a wide format (pivoted)
    DataFrame as you can see in *Figure 4.14*:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码将把“熔化”后的数据框转换为宽格式（透视）数据框，您可以在*图 4.14*中看到：
- en: '![Figure 4.14 – The conversion from long to wide format](img/B16780_04_15.jpg)![Figure
    4.14 – The conversion from long to wide format](img/B16780_04_16.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.14 – 从长格式到宽格式的转换](img/B16780_04_15.jpg)![图 4.14 – 从长格式到宽格式的转换](img/B16780_04_16.jpg)'
- en: Figure 4.14 – The conversion from long to wide format
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.14 – 从长格式到宽格式的转换
- en: 'The `data_melt` contains names that can be better used as column names, so
    each indicator can be represented independently in its own column, to be consistent
    with our data representation:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`data_melt`包含可以更好用作列名的名称，因此每个指标可以独立地表示在自己的列中，以便与我们的数据表示保持一致：'
- en: '[PRE22]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This will produce our `data_pivot` DataFrame, a sample of which you can see
    in *Figure 4.15*:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成我们的`data_pivot`数据框，您可以在*图 4.15*中看到其示例：
- en: '![Figure 4.15 – The long form (tidy) poverty DataFrame](img/B16780_04_17.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.15 – 长格式（整洁）贫困数据框](img/B16780_04_17.jpg)'
- en: Figure 4.15 – The long form (tidy) poverty DataFrame
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.15 – 长格式（整洁）贫困数据框
- en: 'If our work is correct, we should now have a unique combination of country
    and year in each row. That was the whole point of the exercise actually. Let''s
    test that our work is correct:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的工作是正确的，那么每一行现在应该有一个唯一的国家和年份的组合。这实际上就是这个练习的核心。让我们来检查一下我们的工作是否正确：
- en: '[PRE23]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Rows now contain country names, codes, and years, as well as all the values
    for the different indicators. The country information can be enriched by including
    the metadata that we have in the `country` DataFrame. Let's take a look at the
    `merge` function, and after that, we'll start using Plotly Express.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，行中包含了国家名称、代码和年份，以及所有不同指标的值。通过将`country`数据框中的元数据包含在内，国家信息可以得到丰富。我们来看一下`merge`函数，之后我们将开始使用Plotly
    Express。
- en: Merging DataFrames
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 合并数据框
- en: 'First, let''s look at a simple example of how merging works, and then we can
    merge the `data_pivot` and `country` DataFrames. *Figure 4.16* shows how two DataFrames
    can be merged:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看一个简单的示例，了解合并是如何工作的，然后我们可以合并`data_pivot`和`country`数据框。*图 4.16*展示了如何将两个数据框进行合并：
- en: '![Figure 4.16 How DataFrames are merged](img/B16780_04_18.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.16 数据框是如何合并的](img/B16780_04_18.jpg)'
- en: Figure 4.16 How DataFrames are merged
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.16 数据框是如何合并的
- en: 'The merge operation can be done with the `merge` function:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 合并操作可以通过`merge`函数来完成：
- en: '[PRE24]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Here are the details of the preceding call to `pd.merge`:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前述`pd.merge`调用的详细信息：
- en: '`left_on`: The name of the column(s) from the `left` DataFrame to merge on.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`left_on`：来自`left`数据框的列名，用于合并。'
- en: '`right_on`: The name of the column(s) from the `right` DataFrame to merge on.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`right_on`：来自`right`数据框的列名，用于合并。'
- en: '`how`: The `merge` method. In this case, `"left"` means to take all the rows
    in `left` and only match them with rows in `right` that have the same values in
    the `right` that don''t have matches in the `country` column will be discarded.
    The merged DataFrame should end up with the same number of rows as the left DataFrame.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`how`：合并方法。在这种情况下，`"left"`表示取`left`中的所有行，并只与`right`中值相同的行进行匹配。如果`right`中没有匹配的行，那么`country`列中的这些行将被丢弃。合并后的数据框应该与左侧数据框拥有相同的行数。'
- en: 'There are several other options for this function, and it''s quite powerful.
    Make sure to check out the other merge methods: inner, outer, and right. For our
    case, we will be using the options shown in the previous example, so let''s do
    it now. We will merge `data_pivot` with `country` the same way:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数还有其他几个选项，非常强大。确保查看其他合并方法：inner、outer和right。对于我们的例子，我们将使用前面示范的选项，现在就开始吧。我们将以相同的方式合并`data_pivot`和`country`：
- en: '[PRE25]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This merge operation produces the `poverty` DataFrame, which you can see in
    *Figure 4.17*:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 该合并操作生成了`poverty`数据框，您可以在*图 4.17*中看到：
- en: '![Figure 4.17 – Merging data_pivot and country](img/B16780_04_19.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.17 – 合并data_pivot和country](img/B16780_04_19.jpg)'
- en: Figure 4.17 – Merging data_pivot and country
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.17 – 合并data_pivot和country
- en: 'A quick check to make sure our work is correct:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 快速检查，确保我们的工作是正确的：
- en: '[PRE26]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The eight additional columns in the rectangle on the right are some of the additional
    columns that were added to our `poverty` DataFrame. Now it's very easy to take
    a certain region or income group, filter by its countries, color by its values,
    or group it however we want. This is now looking like the Gapminder dataset, only
    with many more indicators and years, and more metadata about countries.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 右侧矩形中的八个附加列是我们添加到`poverty`数据框中的一些附加列。现在，过滤某个地区或收入组，按国家筛选，按其值着色，或按我们想要的方式进行分组变得非常容易。现在看起来像是Gapminder数据集，只是有更多的指标和年份，以及关于国家的更多元数据。
- en: We now have a DataFrame that has a consistent structure.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个结构一致的数据框。
- en: Every column contains data about one and only one variable. All values in columns
    are of the same data type (or missing). Each row can independently represent a
    complete observation, because it contains the full information available, like
    all other rows.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 每一列都包含关于一个且仅一个变量的数据。列中的所有值都是相同的数据类型（或缺失值）。每一行都能独立表示一个完整的观测结果，因为它包含了所有可用的完整信息，就像其他行一样。
- en: Important note
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The main drawback of the long format is that it is inefficient for storage.
    From that perspective, we are unnecessarily repeating a lot of values, which takes
    a lot of space. We will tackle this later, but keep in mind that this format is
    extremely efficient in terms of your time as a developer. As we saw in several
    examples, once the mapping is consistent, creating and changing your visualizations
    becomes much easier.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 长格式的主要缺点是它在存储上效率低下。从这个角度来看，我们不必要地重复了许多值，这占用了大量空间。我们稍后会处理这个问题，但请记住，这种格式在作为开发者的时间效率方面是极其高效的。正如我们在几个示例中看到的，一旦映射一致，创建和修改可视化就变得更加容易。
- en: 'I highly recommend reading Hadley Wickham''s *Tidy Data* paper, for a deeper
    discussion on several ways in which data might be formatted and different solutions
    for that. The examples shown here are inspired by those principles: [https://www.jstatsoft.org/article/view/v059i10](https://www.jstatsoft.org/article/view/v059i10).'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈推荐阅读 Hadley Wickham 的 *Tidy Data* 论文，深入讨论数据格式的几种方式以及不同的解决方案。这里展示的示例灵感来源于这些原则：[https://www.jstatsoft.org/article/view/v059i10](https://www.jstatsoft.org/article/view/v059i10)。
- en: We are now ready to explore how to use Plotly Express, first with a toy dataset,
    and then with the dataset that we prepared.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备好探索如何使用 Plotly Express，首先使用一个玩具数据集，然后使用我们准备的数据集。
- en: Learning Plotly Express
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习 Plotly Express
- en: Plotly Express is a higher-level plotting system, built on top of Plotly. Not
    only does it handle certain defaults for us, such as labeling axes and legends,
    it enables us to utilize our data to express many of its attributes using visual
    aesthetics (size, color, location, and so on). This can be done simply by declaring
    what attribute we want to express with which column of our data, given a few assumptions
    about the data structure. So, it mainly provides us with the flexibility to approach
    the problem from the data point of view, as mentioned at the beginning of the
    chapter.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: Plotly Express 是一个更高级的绘图系统，建立在 Plotly 的基础上。它不仅处理一些默认设置，例如标注坐标轴和图例，还使我们能够利用数据通过视觉美学（如大小、颜色、位置等）表达其许多特征。只需声明我们希望通过哪个数据列表达哪些特征，基于一些关于数据结构的假设，就可以轻松做到这一点。因此，它主要为我们提供了从数据角度解决问题的灵活性，就像本章开头提到的那样。
- en: 'Let''s first create a simple DataFrame:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先创建一个简单的 DataFrame：
- en: '[PRE27]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This will produce the DataFrame in *Figure 4.18*:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成 *图 4.18* 中的 DataFrame：
- en: '![Figure 4.18 – A simple example DataFrame](img/B16780_04_20.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.18 – 一个简单的示例 DataFrame](img/B16780_04_20.jpg)'
- en: Figure 4.18 – A simple example DataFrame
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.18 – 一个简单的示例 DataFrame
- en: We typically create charts with Plotly Express by calling the type of the chart
    as a function, `px.line`, `px.histogram`, and so on. Each function has its own
    set of parameters, based on its type.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常通过调用图表类型函数来使用 Plotly Express，例如 `px.line`、`px.histogram` 等。每个函数都有自己的一组参数，具体取决于它的类型。
- en: 'There are several ways of passing arguments to those functions, and we will
    focus on two main approaches:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方式可以将参数传递给这些函数，我们将重点介绍两种主要的方法：
- en: 'A DataFrame with column names: In most cases, the first parameter is `data_frame`.
    You set the DataFrame that you want to visualize, and then you specify the columns
    you want to use for the parameters that you want. For our example DataFrame, if
    we want to create a scatter plot with `px.scatter(data_frame=df, x=''numbers'',
    y=''floats'')`.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有列名的 DataFrame：在大多数情况下，第一个参数是 `data_frame`。你设置要可视化的 DataFrame，然后指定你想要的参数所使用的列。对于我们的示例
    DataFrame，如果我们想要创建一个散点图，可以使用 `px.scatter(data_frame=df, x='numbers', y='floats')`。
- en: 'Arrays as arguments: Another way of specifying parameters is by simply passing
    lists, tuples, or any array-like data structure, without a `data_frame` argument.
    We can create the same scatter plot by running: `px.scatter(x=df[''numbers''],
    y=df[''floats''])`. This is a straightforward and very fast approach, whenever
    you have lists that you want to explore.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组作为参数：另一种指定参数的方式是直接传入列表、元组或任何类似数组的数据结构，而不使用`data_frame`参数。我们可以通过运行`px.scatter(x=df['numbers'],
    y=df['floats'])`来创建相同的散点图。这是一种直接且非常快速的方法，适用于你想要探索的列表。
- en: 'We can also mix the approaches. We can set a `data_frame` argument with a few
    column names as arguments, and we can pass separate lists for other arguments
    when needed. A few examples should illustrate these points easily. The following
    code shows how easy it is to create a scatter plot:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以将这些方法结合使用。我们可以设置一个`data_frame`参数，并将一些列名作为参数传入，当需要时，也可以为其他参数传入单独的列表。几个示例应该能轻松说明这些要点。以下代码展示了创建散点图是多么简单：
- en: '[PRE28]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '*Figure 4.19* shows the resulting figure in JupyterLab:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4.19* 显示了在 JupyterLab 中的结果图：'
- en: '![Figure 4.19 – Creating a scatter plot with Plotly Express](img/B16780_04_21.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.19 – 使用 Plotly Express 创建散点图](img/B16780_04_21.jpg)'
- en: Figure 4.19 – Creating a scatter plot with Plotly Express
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.19 – 使用 Plotly Express 创建散点图
- en: I'm sure you noticed that we got the X- and Y-axis titles set for us by default.
    It takes the names of the arguments we gave (the DataFrame columns in this example)
    and uses them for that.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我敢肯定你已经注意到，X 轴和 Y 轴的标题已经由系统默认设置。它会使用我们提供的参数名称（在这个例子中是数据框列名）来设置这些标题。
- en: We have several other variables in the DataFrame, and we might be interested
    in checking whether there are any relations between them. For example, let's check
    whether there is a relationship between **floats** and **shapes**.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数据框中还有其他变量，我们可能有兴趣检查它们之间是否存在任何关系。例如，让我们检查**浮动**和**形状**之间是否有关系。
- en: 'We can rerun the same code and add two parameters that allow us to distinguish
    which markers belong to which shape. We can use the `color` parameter for that,
    and it will assign a different color to each marker based on the `symbol` parameter
    was added, to make it easy to distinguish them. This also makes it easier for
    readers on a colored screen as well, by giving two signals to distinguish the
    markers:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以重新运行相同的代码，并添加两个参数，使我们能够区分哪些标记属于哪个形状。我们可以使用`color`参数来做到这一点，系统会根据`symbol`参数为每个标记分配不同的颜色，以便轻松区分它们。这也使得彩屏的读者更容易理解，因为通过提供两个信号来区分标记：
- en: '[PRE29]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '*Figure 4.20* shows the code and resulting figure in JupyterLab:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4.20* 显示了在 JupyterLab 中的代码和结果图：'
- en: '![Figure 4.20 – Assigning colors and symbols to markers](img/B16780_04_22.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.20 – 为标记分配颜色和符号](img/B16780_04_22.jpg)'
- en: Figure 4.20 – Assigning colors and symbols to markers
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.20 – 为标记分配颜色和符号
- en: Note that we have a legend helping us to distinguish the markers by telling
    us which color and symbol belong to which shape. It also has its own title, all
    generated by default.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们有一个图例帮助我们区分标记，告诉我们哪个颜色和符号属于哪个形状。它还拥有自己的标题，所有这些都是默认生成的。
- en: 'There seems to be no relationship between floats and shapes. So, let''s try
    coloring and setting symbols based on the **letters** column, which can be done
    with the following code:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 似乎浮动和形状之间没有关系。那么，我们来尝试根据**字母**列来上色并设置符号，方法是使用以下代码：
- en: '[PRE30]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '*Figure 4.21* demonstrates this:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4.21* 演示了这一点：'
- en: '![Figure 4.21 – Setting marker sizes using an independent list](img/B16780_04_23.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.21 – 使用独立列表设置标记大小](img/B16780_04_23.jpg)'
- en: Figure 4.21 – Setting marker sizes using an independent list
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.21 – 使用独立列表设置标记大小
- en: We can see a clear difference based on the letters now. This shows how easy
    it is to explore your datasets by quickly trying out different options. Note that
    we also mixed the approaches this time by setting a `size` for the markers. Size
    wasn't mapped to a value; it was set to make the symbols bigger and easier to
    see. So, we simply passed a list with the marker size that we wanted. The list
    had to have the same length as the other variables that we are visualizing.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以根据字母看到明显的差异。这展示了通过快速尝试不同的选项来探索数据集是多么容易。请注意，这次我们还混合了方法，给标记设置了`size`。大小没有映射到某个值，它是为了让符号更大、更容易看见。因此，我们只是传递了一个包含我们想要的标记大小的列表。这个列表的长度必须与我们要可视化的其他变量相同。
- en: 'Let''s explore bar charts with the same approach and using the same dataset.
    We can adjust how the bars are displayed using the `barmode` parameter like this:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用相同的方法和相同的数据集来探索条形图。我们可以通过`barmode`参数调整条形的显示方式，像这样：
- en: '[PRE31]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '*Figure 4.22* shows two different ways of displaying the bars – the default,
    on top of each other, and "`group`," as you can see:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4.22* 展示了两种不同的条形显示方式——默认方式是将条形叠加在一起，而 "`group`" 方式则是将条形分组显示，正如你所看到的：'
- en: '![Figure 4.22 – Creating bar charts using different display modes (barmode)](img/B16780_04_24.jpg)![Figure
    4.22 – Creating bar charts using different display modes (barmode)](img/B16780_04_25.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.22 – 使用不同显示模式（barmode）创建条形图](img/B16780_04_24.jpg)![图 4.22 – 使用不同显示模式（barmode）创建条形图](img/B16780_04_25.jpg)'
- en: Figure 4.22 – Creating bar charts using different display modes (barmode)
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.22 – 使用不同显示模式（barmode）创建条形图
- en: The discussion about long (tidy) format data should make it very easy to understand
    how to use Plotly. You just need a basic understanding of the chart type, and
    how it works, and then you can easily set the arguments that you want.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 关于长格式（整洁格式）数据的讨论应该能让你非常容易理解如何使用Plotly。你只需要对图表类型及其工作原理有基本了解，然后你就可以轻松设置你想要的参数。
- en: Important note
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Plotly Express does not require data to be in long format. It is very flexible
    and can handle wide, long, as well as mixed format data. Also, `pandas` and `numpy`
    are extremely flexible in data manipulation. I just believe it is better to use
    a consistent approach for your own productivity.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: Plotly Express不要求数据必须是长格式的。它非常灵活，可以处理宽格式、长格式以及混合格式的数据。此外，`pandas`和`numpy`在数据处理上非常灵活。我只是认为，为了提高个人生产力，最好使用一致的方法。
- en: Now let's see how Plotly Express relates to the `Figure` object and when to
    use which approach.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看Plotly Express如何与`Figure`对象相关，以及何时使用哪种方法。
- en: Plotly Express and Figure objects
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Plotly Express和Figure对象
- en: 'It''s helpful to know that all calls to the Plotly Express chart functions
    return a `Figure` object, the same one we discussed in [*Chapter 3*](B16780_03_Final_NM_ePub.xhtml#_idTextAnchor044),
    *Working with Plotly''s Figure Objects*. This is very important for customizing
    our charts after creating them, in case you want to change the defaults. Let''s
    say you created a scatter plot, and after that, you wanted to add an annotation
    to it to explain something. You could do it just like we did in the previous chapter:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 了解所有调用Plotly Express图表函数的返回值都是`Figure`对象是非常有帮助的，这个对象就是我们在[*第3章*](B16780_03_Final_NM_ePub.xhtml#_idTextAnchor044)中讨论的**与Plotly的Figure对象协作**。这对于在创建图表后定制它们非常重要，以防你想更改默认设置。假设你创建了一个散点图，然后你想在图上添加一个注释来解释某些内容。你可以像在上一章中那样进行操作：
- en: '[PRE32]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Everything you know about the `Figure` object and how it is structured can be
    used with Plotly Express, so this builds on that knowledge.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 你所知道的关于`Figure`对象及其结构的所有内容都可以与Plotly Express一起使用，因此这建立在你已有的知识基础上。
- en: This naturally raises the question of when to use Plotly Express and when to
    use Plotly's `graph_objects` module for creating charts from a lower level.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这自然引出了一个问题：什么时候使用Plotly Express，什么时候使用Plotly的`graph_objects`模块来从更低的层次创建图表。
- en: 'This question can be tackled by asking the more general question: Given two
    interfaces that do the same thing at different levels of abstraction, how do we
    choose between them?'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题可以通过问一个更一般性的问题来解决：给定两个在不同抽象层次执行相同操作的接口，我们如何在它们之间做出选择？
- en: 'Consider three different approaches to having a pizza:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑三种不同的做披萨的方法：
- en: '**The ordering approach**: You call a restaurant and order your pizza. It arrives
    at your doorstep in half an hour, and you start eating.'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**订购方法**：你打电话给餐厅，点了一份披萨。它半小时后送到你家门口，你开始吃。'
- en: '**The supermarket approach**: You go to a supermarket, buy dough, cheese, vegetables,
    and all other ingredients. You then make the pizza yourself.'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**超市方法**：你去超市，买面团、奶酪、蔬菜和所有其他食材。然后你自己做披萨。'
- en: '**The farm approach**: You grow tomatoes in your backyard. You raise cows,
    milk them, and convert the milk to cheese, and so on.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**农场方法**：你在后院种番茄。你养牛，挤奶，然后把奶转化为奶酪，等等。'
- en: As we go up to higher-level interfaces, towards the ordering approach, the amount
    of knowledge required decreases a lot. Someone else holds responsibility, and
    quality is checked by the market forces of reputation and competition.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们进入更高层次的接口，走向订购方法时，所需的知识量大大减少。其他人承担责任，市场力量——声誉和竞争——检查质量。
- en: The price we pay for this is the diminished freedom and options. Each restaurant
    has a set of options to choose from, and you have to choose from those options.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为此付出的代价是减少了自由度和选择的余地。每家餐厅都有一系列选择，你必须从中选择。
- en: Going down to lower levels, the amount of knowledge required increases, we have
    to handle more complexity, we hold more responsibility for the outcomes, and it
    takes much more time. What we gain here is much more freedom and power to customize
    our outcomes the way we want. Cost is a major benefit as well, but only on a large
    enough scale. If you only want to have a pizza today, it's probably cheaper to
    order it. But if you plan on having one every day, then you can expect major cost-savings
    if you do it yourself.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 当深入到更低的层次时，所需的知识量增加，我们必须处理更多的复杂性，承担更多的结果责任，且花费更多的时间。我们在这里得到的是更多的自由和权力，可以按我们想要的方式自定义我们的结果。成本也是一个重要的好处，但只有在规模足够大的情况下。如果你今天只想吃一块披萨，可能订外卖更便宜。但如果你计划每天吃披萨，那么如果自己做，预计会有很大的成本节省。
- en: This is the trade-off you have in choosing between the higher-level Plotly Express,
    and the lower-level Plotly `graph_objects`.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你在选择更高层次的 Plotly Express 和更低层次的 Plotly `graph_objects` 之间的权衡。
- en: 'Since Plotly Express returns `Figure` objects, then it''s generally not a difficult
    decision, because you can retroactively modify them. In general, it''s good to
    use the `graph_objects` module in the following cases:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Plotly Express 返回的是 `Figure` 对象，因此通常这不是一个困难的决定，因为你可以事后修改它们。一般来说，在以下情况下使用
    `graph_objects` 模块是个不错的选择：
- en: '**Non-standard visualizations**: Many diagrams created in this book were done
    with Plotly. To create such diagrams with Plotly Express would be quite difficult
    because they are not standard graphs.'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**非标准可视化**：本书中创建的许多图表都是使用 Plotly 完成的。使用 Plotly Express 创建这类图表会相当困难，因为它们不是标准图表。'
- en: '`graph_objects` module.'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`graph_objects` 模块。'
- en: '`graph_objects`.'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`graph_objects`。'
- en: In general, Plotly Express is usually a better starting point for creating your
    charts, as we saw how powerful and convenient it is.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，Plotly Express 通常是创建图表的更好起点，正如我们看到它是多么强大和方便。
- en: You are now ready to use the `poverty` dataset to specify the visualization
    that you want with Plotly Express, starting from the data.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经准备好使用 `poverty` 数据集，利用 Plotly Express 从数据开始指定你想要的可视化。
- en: Creating a Plotly Express chart using the dataset
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用数据集创建 Plotly Express 图表
- en: 'Let''s see how we might summarize the `poverty` `data_frame` with a scatter
    plot:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用散点图总结 `poverty` `data_frame`：
- en: 'Create variables for `year`, `indicator`, and a grouping (`grouper`) metric
    to use in the visualization. The grouping metric will be used to distinguish between
    the markers (using color and symbol), and could take any categorical value from
    the dataset, such as region, income group, and so on:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `year`、`indicator` 和一个分组（`grouper`）度量变量用于可视化。分组度量将用于区分标记（通过颜色和符号），可以从数据集中提取任何类别值，如地区、收入组等：
- en: '[PRE33]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Based on these variables, create a DataFrame, where the `year` column is equal
    to `year`, sort the values by `indicator`, and remove any missing values from
    the columns of `indicator` and `grouper`:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基于这些变量，创建一个 DataFrame，其中 `year` 列等于 `year`，按 `indicator` 排序，并移除 `indicator`
    和 `grouper` 列中的任何缺失值：
- en: '[PRE34]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Set the `x` axis values to `indicator` and set the `y` axis values to the column
    "`Country Name`". The `color` and `symbol` of the markers should be set using
    `grouper`. The X-axis values are expected to have outliers, and not to be normally
    distributed, so set `log_x` to `True`. The `hover_name` of each hover label should
    take the country name together with its flag. Set the `title` of the figure by
    concatenating `indicator`, "`by`", `grouper`, and `year`. Give markers a constant
    `size`, and set the `height` to `700` pixels:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `x` 轴的值设置为 `indicator`，并将 `y` 轴的值设置为 "`Country Name`" 列。标记的 `color` 和 `symbol`
    应使用 `grouper` 设置。X 轴值预计会有异常值，并且不是正态分布的，因此将 `log_x` 设置为 `True`。每个悬浮标签的 `hover_name`
    应包含国家名称及其国旗。将图表的 `title` 设置为 `indicator`、"`by`"、`grouper` 和 `year` 的组合。给标记一个固定的
    `size`，并将 `height` 设置为 `700` 像素：
- en: '[PRE35]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This creates the chart in *Figure 4.23*:'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将创建*图 4.23*中的图表：
- en: '![Figure 4.23 – The Plotly Express figure using the poverty dataset](img/B16780_04_26.jpg)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.23 – 使用贫困数据集的 Plotly Express 图表](img/B16780_04_26.jpg)'
- en: Figure 4.23 – The Plotly Express figure using the poverty dataset
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.23 – 使用贫困数据集的 Plotly Express 图表
- en: 'By simply playing with the different combinations of `year`, `grouper`, and
    `indicator`, you can generate hundreds of charts. *Figure 4.24* shows some samples:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 通过简单地玩弄 `year`、`grouper` 和 `indicator` 的不同组合，你可以生成数百个图表。*图 4.24* 展示了一些示例：
- en: '![Figure 4.24 – Other figures using the same dataset](img/B16780_04_27.jpg)![Figure
    4.24 – Other figures using the same dataset](img/B16780_04_28.jpg)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.24 – 使用相同数据集的其他图表](img/B16780_04_27.jpg)![图 4.24 – 使用相同数据集的其他图表](img/B16780_04_28.jpg)'
- en: Figure 4.24 – Other figures using the same dataset
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.24 – 使用相同数据集的其他图表
- en: 'With these powerful features, and with data formatted as observations by variables,
    we can easily visualize six or seven attributes of our data using several visual
    attributes: X axis, Y axis, marker size, marker symbol, marker color, facets (columns
    or rows), and animations. We can also add more context and information using hover
    labels, as well as annotations. Any combination of those attributes can be explored
    simply by selecting which column to map to which attribute.'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 借助这些强大的功能，以及将数据按变量组织为观测值的格式，我们可以通过几种视觉属性轻松地可视化数据的六个或七个属性：X 轴、Y 轴、标记大小、标记符号、标记颜色、面板（列或行）和动画。我们还可以使用悬停标签和注释来增加更多的上下文和信息。通过选择将哪个列映射到哪个属性，我们可以简单地探索这些属性的任何组合。
- en: Let's now explore how easy it is to enrich our dataset with external resources.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来探索一下将外部资源轻松地加入到我们的数据集中有多简单。
- en: Adding new data and columns to our dataset
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向我们的数据集添加新数据和列
- en: 'There are many ways to add more data, but I would like to highlight two very
    easy and effective ones:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多方法可以添加更多数据，但我想突出介绍两种非常简单且有效的方法：
- en: '`pandas` `read_html` function, which downloads all tables on a web page, you
    can very easily download any such list. Assuming it has the country codes, you
    can merge it with the main DataFrame and start analyzing accordingly. This can
    also be a filtering mechanism, where you simply want a subset of all countries.'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pandas`的`read_html`函数可以下载网页上的所有表格，你可以非常轻松地下载任何此类列表。假设它包含国家代码，你可以将其与主数据框合并，然后开始相应地分析。这也可以是一个过滤机制，你只需要所有国家中的一个子集。'
- en: '**Adding new data**: The World Bank has thousands of other similar datasets.
    For example, the population figures we have here are for the total population.
    There are many detailed and segmented population datasets that break the numbers
    down by gender, age, and other factors. Using the World Bank''s API, you can easily
    obtain other data, merge it, and immediately enrich your analysis.'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**添加新数据**：世界银行拥有成千上万的类似数据集。例如，我们这里的人口数据是总人口数。还有很多详细的、按性别、年龄和其他因素划分的人口数据集。通过世界银行的API，你可以轻松获取其他数据，合并数据，并立即丰富你的分析。'
- en: Let's now review what we have done in this chapter and in *Part 1* of the book.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们回顾一下我们在本章和本书的*第1部分*中做了什么。
- en: Summary
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: You now have enough information and have seen enough examples to create dashboards
    quickly. In [*Chapter 1*](B16780_01_Final_NM_ePub.xhtml#_idTextAnchor015), *Overview
    of the Dash Ecosystem*, we learned how apps are structured and learned how to
    build fully running apps, but without interactivity. In [*Chapter 2*](B16780_02_Final_NM_ePub.xhtml#_idTextAnchor031),
    *Exploring the Structure of a Dash App*, we explored how interactivity works,
    through callback functions, and we added interactive features to our app. [*Chapter
    3*](B16780_03_Final_NM_ePub.xhtml#_idTextAnchor044), *Working with Plotly's Figure
    Objects*, introduced how Plotly's charts are created, their components, and how
    to manipulate them to achieve the results you want. Finally, in this chapter,
    we introduced Plotly Express, a high-level interface to Plotly that is easy to
    use but more importantly, follows an intuitive approach that is data-oriented,
    as opposed to being chart-oriented.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经掌握了足够的信息，并且看到了足够的示例，可以快速创建仪表板。在[*第1章*](B16780_01_Final_NM_ePub.xhtml#_idTextAnchor015)《Dash生态系统概览》中，我们了解了应用程序的结构，并学会了如何构建完整运行的应用程序，但没有交互性。在[*第2章*](B16780_02_Final_NM_ePub.xhtml#_idTextAnchor031)《探索Dash应用程序的结构》中，我们通过回调函数探索了交互性的工作原理，并向应用程序添加了交互功能。[*第3章*](B16780_03_Final_NM_ePub.xhtml#_idTextAnchor044)《使用Plotly的图形对象》介绍了Plotly图表的创建方法、组成部分以及如何操作它们以获得所需的结果。最后，在本章中，我们介绍了Plotly
    Express，这是一个易于使用的高层接口，最重要的是，它遵循一种以数据为导向的直观方法，而非以图表为导向的方法。
- en: One of the most important and biggest parts of creating visualizations is the
    process of preparing data in certain formats, after which it becomes relatively
    straightforward to create those visualizations. Investing in understanding how
    your dataset is structured, as well as investing time and effort in reshaping
    your data, pays well in the end, as we saw in the extensive example in this chapter.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 创建可视化的最重要和最大部分之一是将数据准备为特定格式的过程，之后创建这些可视化就变得相对简单。投资于理解数据集的结构，并投入时间和精力来重塑数据，最终会带来丰厚回报，正如我们在本章的详细示例中所看到的那样。
- en: Armed with this knowledge and examples, as well as our familiarity with our
    dataset, and straightforward mechanisms to enrich it, we are now ready to explore
    in more detail different Dash components, as well as different types of charts.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 凭借这些知识和示例，以及我们对数据集的熟悉和丰富它的简单机制，我们现在准备更详细地探索不同的Dash组件以及不同类型的图表。
- en: '*Part 2* will go deep into different chart types, how to use them, and the
    different ways we can combine them with the interactivity features that Dash provides.'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '*第二部分*将深入探讨不同的图表类型、如何使用它们，以及如何将它们与Dash提供的交互功能结合的不同方式。'
