- en: Chapter 7.  Flink Graph API - Gelly
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。 Flink图API - Gelly
- en: We are living in the era of social media where everyone is connected to each
    other by some means. Every single object is in a relationship with another. Facebook
    and Twitter are excellent examples of social graphs, where *x* is friends with
    *y* and *p* is following *q*, and so on. These graphs are so huge that we need
    an engine which can process them efficiently. If we are surrounded by such graphs,
    it is very important to analyze them in order to get more insights about their
    relationships and next-level relationships.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们生活在社交媒体时代，每个人都以某种方式与他人联系。每个单独的对象都与另一个对象有关系。Facebook和Twitter是社交图的绝佳例子，其中*x*与*y*是朋友，*p*正在关注*q*，等等。这些图如此庞大，以至于我们需要一个能够高效处理它们的引擎。如果我们被这样的图所包围，分析它们以获取更多关于它们关系和下一级关系的见解非常重要。
- en: There are various technologies in the market which help us analyze such graphs,
    for example, graph databases such as Titan and Neo4J, graph processing libraries
    such as Spark GraphX and Flink Gelly, and so on. In this chapter, we are going
    to understand the details of graphs and how we can use Flink Gelly to analyze
    graph data.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 市场上有各种技术可以帮助我们分析这样的图，例如Titan和Neo4J等图数据库，Spark GraphX和Flink Gelly等图处理库等。在本章中，我们将了解图的细节以及如何使用Flink
    Gelly来分析图数据。
- en: So let's get started.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 那么让我们开始吧。
- en: What is a graph?
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是图？
- en: In the computer science field, a graph is a means of representing relationships
    amongst the object. It consists of a set of vertices connected via edges. **Vertices**
    are objects on a plane, identified by co-ordinates or some unique id/name while
    **Edges** are the connecting links between the vertices having certain weights
    or the relationship. A graph can be directed or undirected. In a directed graph,
    the edges are directed from one vertex to other while there is no direction for
    edges in undirected graph.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机科学领域，图是表示对象之间关系的一种方式。它由一组通过边连接的顶点组成。**顶点**是平面上的对象，由坐标或某个唯一的id/name标识，而**边**是连接顶点的链接，具有一定的权重或关系。图可以是有向的或无向的。在有向图中，边从一个顶点指向另一个顶点，而在无向图中，边没有方向。
- en: 'The following diagram shows the basic representation of a directed graph:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了有向图的基本表示：
- en: '![What is a graph?](img/image_07_001.jpg)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![什么是图？](img/image_07_001.jpg)'
- en: A graph structure can be used for various purposes, such as finding the shortest
    path to a certain destination, or it could be used for finding out the degree
    of relationship between certain vertices, or it could be used for finding out
    the nearest neighbor.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 图结构可以用于各种目的，例如找到到达某个目的地的最短路径，或者用于查找某些顶点之间关系的程度，或者用于查找最近的邻居。
- en: Now let's dive deep into Flink's Graph API - Gelly.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们深入了解Flink的图API - Gelly。
- en: Flink graph API - Gelly
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Flink图API - Gelly
- en: Flink provides a graph processing library called Gelly to simplify the development
    of graph analysis. It provides data structures to store and represent graph data
    and it provides methods to analyze the graphs. In Gelly, we can transform graphs
    from one state to another using Flink's higher-level functions. It also provides
    a set of algorithms used for detailed graph analysis.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Flink提供了一个名为Gelly的图处理库，以简化图分析的开发。它提供了用于存储和表示图数据的数据结构，并提供了分析图的方法。在Gelly中，我们可以使用Flink的高级函数将图从一种状态转换为另一种状态。它还提供了一组用于详细图分析的算法。
- en: Gelly is currently available as a part of the Flink libraries, so we need to
    add a Maven dependency in our programs to use it.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Gelly目前作为Flink库的一部分可用，因此我们需要在程序中添加Maven依赖项才能使用它。
- en: 'Java dependency:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Java依赖：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Scala dependency:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Scala依赖：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now let's look at various options we have in order to use Gelly effectively.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看我们有哪些选项可以有效地使用Gelly。
- en: Graph representation
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图表示
- en: In Gelly, a graph is represented as dataset of nodes and datasets of edges.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在Gelly中，图被表示为节点数据集和边数据集。
- en: Graph nodes
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 图节点
- en: A graph node is represented by a `Vertex` data type. A `Vertex` data type consists
    of a unique ID and an optional value. A unique ID should implement a comparable
    interface because, while doing graph processing, we compare the nodes by their
    IDs. A `Vertex` can have a value or it can have a null value as well. A null-valued
    vertex is defined by the type, `NullValue`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图节点由`Vertex`数据类型表示。`Vertex`数据类型包括唯一ID和可选值。唯一ID应实现可比较接口，因为在进行图处理时，我们通过它们的ID进行比较。一个`Vertex`可以有一个值，也可以有一个空值。空值顶点由类型`NullValue`定义。
- en: 'The following code snippets show how to create nodes:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了如何创建节点：
- en: 'In Java:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In Scala:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在Scala中：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Graph edges
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 图边
- en: Similarly, an edge can be defined by the type, `Edge`. An `Edge` has a source
    node ID, a destination node ID, and an optional value. The value represents the
    degree or weight of relationship. Source and Target Ids need to be of same type.
    Edges with no value can be defined using `NullValue`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，边可以由类型`Edge`定义。`Edge`具有源节点ID、目标节点ID和可选值。该值表示关系的程度或权重。源和目标ID需要是相同类型的。没有值的边可以使用`NullValue`定义。
- en: 'The following code snippets shows `Edge` definitions in Java and Scala:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了Java和Scala中的`Edge`定义：
- en: 'In Java:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In Scala:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在Scala中：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In Gelly, a graph is always directed from a source to a destination vertex.
    In order to show an undirected graph, we should add another edge representing
    a connection from the destination to the source and back.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在Gelly中，图始终是从源顶点到目标顶点的有向的。为了显示无向图，我们应该添加另一条边，表示从目标到源的连接和返回。
- en: 'The following code snippet represents a directed graph in Gelly:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段表示了Gelly中的有向图：
- en: 'In Java:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In Scala:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在Scala中：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The following is its visual representation for the same:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是它的可视化表示：
- en: '![Graph edges](img/image_07_002.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图边](img/image_07_002.jpg)'
- en: 'The following code snippet represents the vertex and edge definitions for an
    undirected graph in Gelly:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段表示了Gelly中无向图的顶点和边的定义：
- en: 'In Java:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In Scala:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在Scala中：
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The following is its visual representation for the same:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是其相同的可视表示：
- en: '![Graph edges](img/image_07_003.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![Graph edges](img/image_07_003.jpg)'
- en: Graph creation
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图创建
- en: In Flink Gelly, graphs can be created in multiple ways. The following are some
    examples.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在Flink Gelly中，可以以多种方式创建图。以下是一些示例。
- en: From dataset of edges and vertices
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 来自边和顶点数据集
- en: 'The following code snippets represent how we create graphs using the dataset
    of edges and optional vertices:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段表示我们如何使用边数据集和可选顶点创建图：
- en: 'In Java:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In Scala:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在Scala中：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: From dataset of tuples representing edges
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 来自表示边的元组数据集
- en: The following code snippets represent how we create graphs using the dataset
    of Tuple2 representing edges. Here Gelly automatically converts Tuple2 into edges
    having source and destination vertices IDs and null value.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段表示我们如何使用表示边的Tuple2数据集创建图。在这里，Gelly会自动将Tuple2转换为具有源和目标顶点ID以及空值的边。
- en: 'In Java:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中：
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In Scala:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在Scala中：
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The following code snippets represent how we create graphs using the dataset
    of Tuple3 representing edges. Here vertices are represented using Tuple2 while
    edge using Tuple3 are represented with information about source, destination vertex,
    and weight. We can also read the set of values from CSV files:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段表示我们如何使用表示边的Tuple3数据集创建图。这里，顶点使用Tuple2表示，而边使用Tuple3表示，包含有关源顶点、目标顶点和权重的信息。我们还可以从CSV文件中读取一组值：
- en: 'In Java:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中：
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In Scala:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在Scala中：
- en: '[PRE15]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: From CSV files
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 来自CSV文件
- en: The following code snippets represent how we create graphs using the CSV file
    reader. CSV files should have data represented in the form vertices and edges.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段表示我们如何使用CSV文件读取器创建图。CSV文件应以顶点和边的形式表示数据。
- en: 'The following code snippet creates a graph from CSV files of the format, source,
    target, weight, for edges and ID, name for vertices:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段创建了一个图，该图来自CSV文件，格式为边的源、目标、权重，以及顶点的ID、名称：
- en: '[PRE16]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We can use a vertex value initializer as well by defining a `map` function
    while creating the graph:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过在创建图时定义`map`函数来使用顶点值初始化程序：
- en: '[PRE17]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: From collection lists
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 来自集合列表
- en: 'We can also create graphs from a collection of list. The following code snippet
    show how we create graphs from a list of edges and vertices:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以从列表集合创建图。以下代码片段显示了我们如何从边和顶点列表创建图：
- en: 'In Java:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中：
- en: '[PRE18]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In Scala:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在Scala中：
- en: '[PRE19]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If no vertex input is provided, then we can think of providing a `map` initialization
    function as shown here:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有提供顶点输入，则可以考虑提供一个`map`初始化函数，如下所示：
- en: '[PRE20]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Graph properties
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图属性
- en: 'The following table shows the set of methods available to retrieve graph properties:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了用于检索图属性的一组可用方法：
- en: '| **Property** | **In Java** | **In Scala** |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| **属性** | **在Java中** | **在Scala中** |'
- en: '| `getVertices` dataset | `DataSet<Vertex<K, VV>> getVertices()` | `getVertices:
    DataSet[Vertex[K, VV]]` |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `getVertices`数据集 | `DataSet<Vertex<K, VV>> getVertices()` | `getVertices:
    DataSet[Vertex<K, VV>]` |'
- en: '| `getEdges` dataset | `DataSet<Edge<K, EV>> getEdges()` | `getEdges: DataSet[Edge[K,
    EV]]` |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `getEdges`数据集 | `DataSet<Edge<K, EV>> getEdges()` | `getEdges: DataSet[Edge<K,
    EV>]` |'
- en: '| `getVertexIds` | `DataSet<K> getVertexIds()` | `getVertexIds: DataSet[K]`
    |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `getVertexIds` | `DataSet<K> getVertexIds()` | `getVertexIds: DataSet[K]`
    |'
- en: '| `getEdgeIds` | `DataSet<Tuple2<K, K>> getEdgeIds()` | `getEdgeIds: DataSet[(K,
    K)]` |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `getEdgeIds` | `DataSet<Tuple2<K, K>> getEdgeIds()` | `getEdgeIds: DataSet[(K,
    K)]` |'
- en: '| Get dataset of vertex IDs and `inDegrees` for all vertices | `DataSet<Tuple2<K,
    LongValue>> inDegrees()` | `inDegrees: DataSet[(K, LongValue)]` |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| 获取顶点ID和所有顶点的`inDegrees`数据集 | `DataSet<Tuple2<K, LongValue>> inDegrees()`
    | `inDegrees: DataSet[(K, LongValue)]` |'
- en: '| Get dataset of vertex IDs and `outDegrees` for all vertices | `DataSet<Tuple2<K,
    LongValue>> outDegrees()` | `outDegrees: DataSet[(K, LongValue)]` |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| 获取顶点ID和所有顶点的`outDegrees`数据集 | `DataSet<Tuple2<K, LongValue>> outDegrees()`
    | `outDegrees: DataSet[(K, LongValue)]` |'
- en: '| Get dataset of vertex IDs and in, `getDegree` for all vertices | `DataSet<Tuple2<K,
    LongValue>> getDegrees()` | `getDegrees: DataSet[(K, LongValue)]` |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| 获取顶点ID和所有顶点的in、`getDegree`数据集 | `DataSet<Tuple2<K, LongValue>> getDegrees()`
    | `getDegrees: DataSet[(K, LongValue)]` |'
- en: '| Get `numberOfVertices` | `long numberOfVertices()` | `numberOfVertices: Long`
    |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| 获取`numberOfVertices` | `long numberOfVertices()` | `numberOfVertices: Long`
    |'
- en: '| Get `numberOfEdges` | `long numberOfEdges()` | `numberOfEdges: Long` |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| 获取`numberOfEdges` | `long numberOfEdges()` | `numberOfEdges: Long` |'
- en: '| `getTriplets` provides triplets consisting of source vertex, target vertex
    and the edge | `DataSet<Triplet<K, VV, EV>> getTriplets()` | `getTriplets: DataSet[Triplet[K,
    VV, EV]]` |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `getTriplets`提供了由源顶点、目标顶点和边组成的三元组 | `DataSet<Triplet<K, VV, EV>> getTriplets()`
    | `getTriplets: DataSet[Triplet<K, VV, EV>]` |'
- en: Graph transformations
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图转换
- en: Gelly provides various transformation operations which helps transforming graphs
    from one form to another. The following are some transformations we can do by
    using Gelly.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Gelly提供了各种转换操作，可帮助将图从一种形式转换为另一种形式。以下是我们可以使用Gelly进行的一些转换。
- en: Map
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 映射
- en: Gelly provides map transformations which keeps the vertices and edge IDs intact
    and transforms the values as per given in the function. This operation always
    returns a new graph. The following code snippet shows how to use it.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Gelly提供了保持顶点和边ID不变并根据函数中给定的值转换值的映射转换。此操作始终返回一个新图。以下代码片段显示了如何使用它。
- en: 'In Java:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中：
- en: '[PRE21]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In Scala:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在Scala中：
- en: '[PRE22]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Translate
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 翻译
- en: Translate is a special function that allows translating vertex IDs, vertex values,
    edge IDs, and so on. Translation is performed using a custom map function provided
    by the user. The following code snippet shows how we use the translate function.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Translate是一种特殊函数，允许翻译顶点ID、顶点值、边ID等。翻译是使用用户提供的自定义映射函数执行的。以下代码片段显示了我们如何使用translate函数。
- en: 'In Java:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中：
- en: '[PRE23]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In Scala:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在Scala中：
- en: '[PRE24]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Filter
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 过滤
- en: '`FilterFunction` can be used to filter out vertices and edges based on certain
    conditions. `filterOnEdges` will create a sub-graph of the original one. In this
    operation, the vertices dataset remains unchanged. Similarly, `filterOnVertices`
    applies the filter on vertices values. In this case, edges that do not find target
    nodes are removed. The following code snippet shows how we use `FilterFunction`
    in Gelly.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`FilterFunction`可用于根据某些条件过滤顶点和边。`filterOnEdges`将创建原始图的子图。在此操作中，顶点数据集保持不变。同样，`filterOnVertices`对顶点值应用过滤器。在这种情况下，找不到目标节点的边将被移除。以下代码片段显示了我们如何在Gelly中使用`FilterFunction`。'
- en: 'In Java:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中：
- en: '[PRE25]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In Scala:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在Scala中：
- en: '[PRE26]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The following is a graphical representation of the preceding code:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前述代码的图形表示：
- en: '![Filter](img/image_07_004.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![Filter](img/image_07_004.jpg)'
- en: 'Similarly, the following diagram shows `filterOnEdges`:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，以下图表显示了`filterOnEdges`：
- en: '![Filter](img/image_07_005.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![Filter](img/image_07_005.jpg)'
- en: Join
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接
- en: 'The `join` operation helps in joining vertices and edge datasets with other
    datasets. The `joinWithVertices` method joins with vertex IDs and the first field
    of Tuple2\. The `join` method returns a new graph. Similarly, input datasets can
    be joined with edges. There are three ways we can join edges:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`join`操作有助于将顶点和边数据集与其他数据集进行连接。`joinWithVertices`方法与顶点ID和Tuple2的第一个字段进行连接。`join`方法返回一个新的图。同样，输入数据集可以与边进行连接。我们可以通过三种方式连接边：'
- en: '`joinWithEdges`: Joins graphs with the Tuple3 dataset on composite keys of
    both source and target vertex IDs'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`joinWithEdges`：在源和目标顶点ID的复合键上与Tuple3数据集进行连接'
- en: '`joinWithEdgeOnSource`: Joins with the Tuple2 dataset on the source key and
    first attribute of the Tuple2 dataset'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`joinWithEdgeOnSource`：与Tuple2数据集在源键和Tuple2数据集的第一个属性上进行连接'
- en: '`joinWithEdgeOnTarget`: Joins with the Tuple2 dataset on the target key and
    first attribute of the Tuple2 dataset'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`joinWithEdgeOnTarget`：与目标键和Tuple2数据集的第一个属性进行连接'
- en: 'The following code snippet shows how to use joins in Gelly:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了如何在Gelly中使用连接：
- en: 'In Java:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中：
- en: '[PRE27]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In Scala:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在Scala中：
- en: '[PRE28]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Reverse
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 反向
- en: The `reverse` method returns a graph with edge direction reverted.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`reverse`方法返回一个边方向被颠倒的图。'
- en: 'The following code snippet shows how to use the same:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了如何使用相同的方法：
- en: 'In Java:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中：
- en: '[PRE29]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In Scala:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在Scala中：
- en: '[PRE30]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Undirected
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 无向的
- en: The `undirected` method returns a new graph with additional edges opposite to
    the original ones.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`undirected`方法返回一个具有与原始边相反的额外边的新图。'
- en: 'The following code snippet shows how to use the same:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了如何使用相同的方法：
- en: 'In Java:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中：
- en: '[PRE31]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In Scala:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在Scala中：
- en: '[PRE32]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Union
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 联合
- en: The `union` operation returns a graph combining vertices and edges of two graphs.
    It joins the vertices on vertex IDs. Duplicate vertices are removed while edges
    are preserved.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`union`操作返回一个组合了两个图的顶点和边的图。它在顶点ID上进行连接。重复的顶点将被移除，而边将被保留。'
- en: 'The following is a graphical representation of the `union` operation:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`union`操作的图形表示：
- en: '![Union](img/image_07_006.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![Union](img/image_07_006.jpg)'
- en: Intersect
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 相交
- en: The `intersect` method performs the intersection of edges from given graph datasets.
    Two edges are considered equal if they have the same source and target vertices.
    The method also contains distinct parameter; if set to `true`, it only returns
    distinct graphs. The following are some code snippets show casing the `intersect`
    method usage.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`intersect`方法执行给定图数据集的边的交集。如果两条边具有相同的源和目标顶点，则它们被视为相等。该方法还包含distinct参数；如果设置为`true`，它只返回不同的图。以下是一些代码片段，展示了`intersect`方法的用法。'
- en: 'In Java:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中：
- en: '[PRE33]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In Scala:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在Scala中：
- en: '[PRE34]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Graph mutations
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图变异
- en: Gelly provides methods to add/remove edges and vertices to existing graphs.
    Let's try to understand these mutations one by one.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Gelly提供了向现有图添加/移除边和顶点的方法。让我们逐一了解这些变异。
- en: '| **Mutation** | **In Java** | **In Scala** |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '**变异** | **在Java中** | **在Scala中**'
- en: '| Add vertex. | `Graph<K, VV, EV> addVertex(final Vertex<K, VV> vertex)` |
    `addVertex(vertex: Vertex[K, VV])` |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '添加顶点。`Graph<K, VV, EV> addVertex(final Vertex<K, VV> vertex)` `addVertex(vertex:
    Vertex[K, VV])`'
- en: '| Add list of vertices. | `Graph<K, VV, EV> addVertices(List<Vertex<K, VV>>
    verticesToAdd)` | `addVertices(verticesToAdd: List[Vertex[K, VV]])` |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '添加顶点列表。`Graph<K, VV, EV> addVertices(List<Vertex<K, VV>> verticesToAdd)` `addVertices(verticesToAdd:
    List[Vertex[K, VV]])`'
- en: '| Add edges to the graph. This adds new edges and vertices if they don''t exist
    already. | `Graph<K, VV, EV> addEdge(Vertex<K, VV> source, Vertex<K, VV> target,
    EV edgeValue)` | `addEdge(source: Vertex[K, VV], target: Vertex[K, VV], edgeValue:
    EV)` |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '向图中添加边。如果边和顶点不存在，则添加新的边和顶点。`Graph<K, VV, EV> addEdge(Vertex<K, VV> source,
    Vertex<K, VV> target, EV edgeValue)` `addEdge(source: Vertex[K, VV], target: Vertex[K,
    VV], edgeValue: EV)`'
- en: '| Add edges, if vertices do not exist then the edge is considered invalid.
    | `Graph<K, VV, EV> addEdges(List<Edge<K, EV>> newEdges)` | `addEdges(edges: List[Edge[K,
    EV]])` |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '添加边，如果顶点不存在，则该边被视为无效。`Graph<K, VV, EV> addEdges(List<Edge<K, EV>> newEdges)`
    `addEdges(edges: List[Edge[K, EV]])`'
- en: '| Remove vertex, removes edges and vertices from the given graph. | `Graph<K,
    VV, EV> removeVertex(Vertex<K, VV> vertex)` | `removeVertex(vertex: Vertex[K,
    VV])` |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '从给定的图中移除顶点，移除边和顶点。`Graph<K, VV, EV> removeVertex(Vertex<K, VV> vertex)` `removeVertex(vertex:
    Vertex[K, VV])`'
- en: '| Remove multiple vertices from the given graph. | `Graph<K, VV, EV> removeVertices(List<Vertex<K,
    VV>> verticesToBeRemoved)` | `removeVertices(verticesToBeRemoved: List[Vertex[K,
    VV]])` |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '从给定的图中移除多个顶点。`Graph<K, VV, EV> removeVertices(List<Vertex<K, VV>> verticesToBeRemoved)`
    `removeVertices(verticesToBeRemoved: List[Vertex[K, VV]])`'
- en: '| Removes all edges that match the given edge. | `Graph<K, VV, EV> removeEdge(Edge<K,
    EV> edge)` | `removeEdge(edge: Edge[K, EV])` |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '移除与给定边匹配的所有边。`Graph<K, VV, EV> removeEdge(Edge<K, EV> edge)` `removeEdge(edge:
    Edge[K, EV])`'
- en: '| Removes edges that match the given list of edges. | `Graph<K, VV, EV> removeEdges(List<Edge<K,
    EV>> edgesToBeRemoved)` | `removeEdges(edgesToBeRemoved: List[Edge[K, EV]])` |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '移除与给定边列表匹配的边。`Graph<K, VV, EV> removeEdges(List<Edge<K, EV>> edgesToBeRemoved)`
    `removeEdges(edgesToBeRemoved: List[Edge[K, EV]])`'
- en: Neighborhood methods
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 邻域方法
- en: Neighborhood methods help in performing operations related to its first hop
    neighborhood. Methods such as `reduceOnEdges()` and `reduceOnNeighbours()` can
    be used to perform aggregate operations. The first one is used to compute aggregation
    on neighboring edges of the vertex while the latter is used to compute aggregation
    on neighboring vertices. The neighbor scope can be defined by providing edge directions,
    and we have options such as `IN`, `OUT`, or `ALL`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 邻域方法有助于执行与其第一跳邻域相关的操作。诸如`reduceOnEdges()`和`reduceOnNeighbours()`之类的方法可用于执行聚合操作。第一个用于计算顶点相邻边的聚合，而后者用于计算相邻顶点的聚合。邻居范围可以通过提供边方向来定义，我们有选项，如`IN`，`OUT`或`ALL`。
- en: 'Consider an example where we need to get the maximum weight of all vertices
    for `OUT` direction edges:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个例子，我们需要获取“OUT”方向边的所有顶点的最大权重：
- en: '![Neighborhood methods](img/image_07_007.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![邻域方法](img/image_07_007.jpg)'
- en: 'Now we want to find out the maximum weighted `OUT` edge for each vertex. Gelly
    provides us with neighborhood methods with which we can find the desired result.
    The following is the code snippet for the same:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们想要找出每个顶点的最大加权“OUT”边。Gelly为我们提供了邻域方法，我们可以用它找到所需的结果。以下是相同的代码片段：
- en: 'In Java:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中：
- en: '[PRE35]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In Scala:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在Scala中：
- en: '[PRE36]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Gelly solves this by first segregating each vertex and finding out the maximum
    weighted edge for each vertex. The following is a graphical representation for
    the same:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Gelly通过首先分离每个顶点并找出每个顶点的最大加权边来解决这个问题。以下是相同的图形表示：
- en: '![Neighborhood methods](img/image_07_008.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![邻域方法](img/image_07_008.jpg)'
- en: Similarly, we can also write one more function to sum the values of incoming
    edges in all neighborhoods.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们也可以编写一个函数来计算所有邻域中传入边的值的总和。
- en: 'In Java:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中：
- en: '[PRE37]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In Scala:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在Scala中：
- en: '[PRE38]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Graph validation
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图验证
- en: Gelly provides us with a utility to validate the input graph before sending
    it for processing. In various situations, we first need to validate the graph
    with certain conditions and only then send it for further processing. Validations
    could be checking if the graph contains duplicate edges or checking if the graph
    structure is bipartite.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Gelly为我们提供了一个实用程序，在将其发送进行处理之前验证输入图。在各种情况下，我们首先需要验证图是否符合某些条件，然后才能将其发送进行进一步处理。验证可能是检查图是否包含重复边或检查图结构是否为二部图。
- en: Note
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Bipartite or Bigraph is a graph whose vertices can be divided into two distinct
    sets such that every vertex in each set has an edge connecting to vertex in another
    set. A simple example of bipartite graph is a graph of Basket Ball Players and
    the teams they play for. Here we will have two sets as players and teams and each
    vertex in player set would have edge to team set. More details on Bipartite graph
    can be read here [https://en.wikipedia.org/wiki/Bipartite_graph](https://en.wikipedia.org/wiki/Bipartite_graph).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 二部图或双图是一个图，其顶点可以分为两个不同的集合，以便每个集合中的每个顶点都与另一个集合中的顶点相连。二部图的一个简单例子是篮球运动员和他们所效力的球队的图。在这里，我们将有两个集合，分别是球员和球队，每个球员集合中的顶点都将与球队集合中的顶点相连。有关二部图的更多细节，请阅读这里[https://en.wikipedia.org/wiki/Bipartite_graph](https://en.wikipedia.org/wiki/Bipartite_graph)。
- en: We can also define custom validate methods to get the desired output. Gelly
    also provides a built-in validator called `InvalidVertexValidator`. This checks
    if the edge set contains validate vertex IDs. The following are some code snippets
    showcasing its usage.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以定义自定义验证方法来获得所需的输出。Gelly还提供了一个名为“InvalidVertexValidator”的内置验证器。这将检查边集是否包含验证顶点ID。以下是一些展示其用法的代码片段。
- en: 'In Java:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中：
- en: '[PRE39]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In Scala:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在Scala中：
- en: '[PRE40]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Iterative graph processing
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迭代图处理
- en: 'Gelly enhances Flink''s iterative processing capabilities to support large
    scale graph processing. Currently it supports implementation of the following
    models:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Gelly增强了Flink的迭代处理能力，以支持大规模图处理。目前它支持以下模型的实现：
- en: Vertex-Centric
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 顶点中心
- en: Scatter-Gather
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分散-聚集
- en: Gather-Sum-Apply
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 聚集-求和-应用
- en: Let's start by understanding these models in the context of Gelly.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先在Gelly的背景下理解这些模型。
- en: Vertex-Centric iterations
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 顶点中心迭代
- en: As the name suggest, these iterations are built thinking the vertex is in the
    center. Here each Vertex processes the same user-defined function in parallel.
    Each step of execution is called a **superset**. A vertex can send a message to
    another vertex as long as it knows its unique ID. This message would be used as
    input to the next superset.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 正如名称所示，这些迭代是建立在顶点处于中心的思想上。在这里，每个顶点并行处理相同的用户定义函数。执行的每一步被称为**超集**。只要顶点知道其唯一ID，它就可以向另一个顶点发送消息。这个消息将被用作下一个超集的输入。
- en: To use Vertex-Centric iterations, the user needs to provide a `ComputeFunction`.
    We can also define an optional `MessageCombiner` to reduce the cost of communication.
    We can solve problems, such as Single Source Shortest Path in which we need to
    find the shortest path from source vertex to all other vertices.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用顶点中心迭代，用户需要提供一个“ComputeFunction”。我们还可以定义一个可选的“MessageCombiner”来减少通信成本。我们可以解决问题，比如单源最短路径，在这种情况下，我们需要找到从源顶点到所有其他顶点的最短路径。
- en: Note
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Single Source Shortest Path is where we try to minimize the sum of weights joining
    two distinct vertices. A very simple example could be a graph of cities and flight
    routes. In this case, SSSP algorithm will try to find the shortest distance connecting
    two cities considering the available flight routes. More details on SSSP can be
    found at [https://en.wikipedia.org/wiki/Shortest_path_problem](https://en.wikipedia.org/wiki/Shortest_path_problem).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 单源最短路径是我们试图最小化连接两个不同顶点的权重之和。一个非常简单的例子可能是城市和航班路线的图。在这种情况下，SSSP算法将尝试找到连接两个城市的最短距离，考虑到可用的航班路线。有关SSSP的更多细节，请参阅[https://en.wikipedia.org/wiki/Shortest_path_problem](https://en.wikipedia.org/wiki/Shortest_path_problem)。
- en: The following code snippets show how we solve the Single Source Shortest Path
    problem using Gelly.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了我们如何使用Gelly解决单源最短路径问题。
- en: 'In Java:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中：
- en: '[PRE41]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In Scala:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在Scala中：
- en: '[PRE42]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We can use following configurations in Vertex-Centric iterations.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在顶点中心迭代中使用以下配置。
- en: '| **Parameter** | **Description** |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| **参数** | **描述** |'
- en: '| Name: `setName()` | Sets the name of Vertex-Centric iteration. Can be seen
    in logs. |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| 名称：`setName()` | 设置顶点中心迭代的名称。可以在日志中看到。 |'
- en: '| Parallelism: `setParallelism()` | Sets the parallelism for parallel execution.
    |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| 并行度：`setParallelism()` | 设置并行执行的并行度。 |'
- en: '| Broadcast variables: `addBroadcastSet()` | Adds broadcast variables to the
    computation function. |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| 广播变量：`addBroadcastSet()` | 将广播变量添加到计算函数中。 |'
- en: '| Aggregator: `registerAggregator()` | Registers custom defined aggregator
    function to be used by the computation function. |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| 聚合器：`registerAggregator()` | 注册自定义定义的聚合器函数，供计算函数使用。 |'
- en: '| Solution set in unmanaged memory: `setSolutionSetUnmanagedMemory()` | Defines
    whether the solution set is kept in managed memory. |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| 未管理内存中的解集：`setSolutionSetUnmanagedMemory()` | 定义解集是否保存在受控内存中。 |'
- en: Scatter-Gather iterations
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Scatter-Gather迭代
- en: 'Scatter-Gather iterations also works in superset iterations and also have a
    vertex at its center and we also define a function that are executed in parallel.
    Here each vertex has two important things to do:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: Scatter-Gather迭代也适用于超集迭代，并且在其中心也有一个顶点，我们还定义了一个并行执行的函数。在这里，每个顶点有两件重要的事情要做：
- en: '**Scatter**: Scatter produces the message it needs to send to other vertices'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Scatter**：Scatter生成需要发送到其他顶点的消息'
- en: '**Gather**: Gather updates the vertex value from the messages it received'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Gather**：Gather从收到的消息中更新顶点值'
- en: Gelly provides methods for scatter and gather. The user needs to implement only
    these two functions to make use of these iterations. `ScatterFunction` produces
    messages for the rest of the vertices while `GatherFunction` computes the updated
    value for the vertex based on the messages it has received.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: Gelly提供了scatter和gather的方法。用户只需实现这两个函数即可利用这些迭代。`ScatterFunction`为其余顶点生成消息，而`GatherFunction`根据收到的消息计算顶点的更新值。
- en: 'The following code snippet shows how we can solve the Single Source Shortest
    Path problem using Gelly-Scatter-Gather iterations:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了如何使用Gelly-Scatter-Gather迭代解决单源最短路径问题：
- en: 'In Java:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中：
- en: '[PRE43]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In Scala:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在Scala中：
- en: '[PRE44]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We can configure Scatter-Gather iterations using the following parameters:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下参数配置Scatter-Gather迭代：
- en: '| Parameter | Description |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 描述 |'
- en: '| --- | --- |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Name: `setName()` | Sets the name of scatter-gather iteration. Can be seen
    in logs. |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| 名称：`setName()` | 设置scatter-gather迭代的名称。可以在日志中看到。 |'
- en: '| Parallelism: `setParallelism()` | Sets the parallelism for parallel execution.
    |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| 并行度：`setParallelism()` | 设置并行执行的并行度。 |'
- en: '| Broadcast variables: `addBroadcastSet()` | Adds broadcast variables to the
    computation function. |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| 广播变量：`addBroadcastSet()` | 将广播变量添加到计算函数中。 |'
- en: '| Aggregator: `registerAggregator()` | Registers the custom defined aggregator
    function to be used by the computation function. |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| 聚合器：`registerAggregator()` | 注册自定义定义的聚合器函数，供计算函数使用。 |'
- en: '| Solution set in unmanaged memory: `setSolutionSetUnmanagedMemory()` | Defines
    whether the solution set is kept in managed memory. |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| 未管理内存中的解集：`setSolutionSetUnmanagedMemory()` | 定义解集是否保存在受控内存中。 |'
- en: '| Number of vertices: `setOptNumVertices()` | Accesses the total no. of vertices
    in an iteration. |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| 顶点数量：`setOptNumVertices()` | 访问迭代中顶点的总数。 |'
- en: '| Degrees: `setOptDegrees()` | Sets the number of in/out degrees to be reached
    within an iteration. |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| 度数：`setOptDegrees()` | 设置在迭代中要达到的入/出度数。 |'
- en: '| Messaging directions: `setDirection()` | By default we only consider out
    degrees for processing but we can change that by setting this property. Options
    are `in`, `out`, and `all`. |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| 消息方向：`setDirection()` | 默认情况下，我们只考虑出度进行处理，但我们可以通过设置此属性来更改。选项有`in`、`out`和`all`。'
- en: Gather-Sum-Apply iterations
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Gather-Sum-Apply迭代
- en: 'Like the previous two models, **Gather-Sum-Apply** (**GSA**) iterations are
    also synchronized in iterative steps. Each superset consists of the following
    steps:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 与前两个模型一样，**Gather-Sum-Apply**（**GSA**）迭代也在迭代步骤中同步。每个超集包括以下步骤：
- en: '**Gather**: A user defined function executed on edges and each neighbor, producing
    a partial value.'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Gather**：在边和每个邻居上执行用户定义的函数，生成部分值。'
- en: '**Sum**: Partial values calculated in earlier step would be aggregated in this
    step.'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Sum**：在早期步骤中计算的部分值将在此步骤中聚合。'
- en: '**Apply**: Each vertex value is updated by applying the function on the aggregated
    value from the previous step and the current value.'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Apply**：通过将上一步的聚合值和当前值应用于顶点值来更新每个顶点值。'
- en: We will try to solve the Single Source Shortest Path using the GSA iteration.
    To use this, we need to define custom functions for gather, sum, and apply.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将尝试使用GSA迭代来解决单源最短路径问题。要使用此功能，我们需要为gather、sum和apply定义自定义函数。
- en: 'In Java:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中：
- en: '[PRE45]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'In Scala:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在Scala中：
- en: '[PRE46]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We can configure GSA iterations using the following parameters:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下参数配置GSA迭代：
- en: '| **Parameter** | **Description** |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| **参数** | **描述** |'
- en: '| Name: `setName()` | Sets the name of the GSA iteration. Can be seen in logs.
    |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| 名称：`setName()` | 设置GSA迭代的名称。可以在日志中看到。 |'
- en: '| Parallelism: `setParallelism()` | Sets the parallelism for parallel execution.
    |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| 并行度：`setParallelism()` | 设置并行执行的并行度。 |'
- en: '| Broadcast variables: `addBroadcastSet()` | Adds broadcast variables to the
    computation function. |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| 广播变量：`addBroadcastSet()` | 将广播变量添加到计算函数中。 |'
- en: '| Aggregator: `registerAggregator()` | Registers the custom defined aggregator
    function to be used by the computation function. |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| 聚合器：`registerAggregator()` | 注册自定义定义的聚合器函数，供计算函数使用。 |'
- en: '| Solution set in unmanaged memory: `setSolutionSetUnmanagedMemory()` | Defines
    whether the solution set is kept in managed memory. |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| 未管理内存中的解集：`setSolutionSetUnmanagedMemory()` | 定义解集是否保存在受控内存中。 |'
- en: '| Number of vertices: `setOptNumVertices()` | Accesses the total number of
    vertices in an iteration. |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| 顶点数量：`setOptNumVertices()` | 访问迭代中顶点的总数。 |'
- en: '| Neighbour directions: `setDirection()` | By default we only consider `OUT`
    degrees for processing but we can change that by setting this property. Options
    are `IN`, `OUT`, and `ALL`. |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| 邻居方向：`setDirection()` | 默认情况下，我们只考虑处理的“OUT”度，但我们可以通过设置此属性来更改。选项有“IN”、“OUT”和“ALL”。'
- en: Use case - Airport Travel Optimization
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用例 - 机场旅行优化
- en: 'Let''s consider a use case where we have data for the airports and the distance
    between them. In order to travel to certain destination from a particular airport,
    we have to find the shortest path between the two. Our airport data looks like
    as shown in the following table:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个使用案例，其中我们有关于机场和它们之间距离的数据。为了从特定机场前往某个目的地，我们必须找到两者之间的最短路径。我们的机场数据如下表所示：
- en: '| Id | Airport name |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '| Id | 机场名称 |'
- en: '| --- | --- |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| s01 | A |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '| s01 | A |'
- en: '| s02 | B |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| s02 | B |'
- en: '| s03 | C |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| s03 | C |'
- en: '| s04 | D |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| s04 | D |'
- en: '| s05 | E |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '| s05 | E |'
- en: 'The distance information between the airport looks like as shown in the following
    table:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 机场之间的距离信息如下表所示：
- en: '| From | To | Distance |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '| From | To | Distance |'
- en: '| --- | --- | --- |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| s01 | s02 | 10 |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| s01 | s02 | 10 |'
- en: '| s01 | s02 | 12 |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| s01 | s02 | 12 |'
- en: '| s01 | s03 | 22 |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| s01 | s03 | 22 |'
- en: '| s01 | s04 | 21 |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| s01 | s04 | 21 |'
- en: '| s04 | s11 | 22 |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| s04 | s11 | 22 |'
- en: '| s05 | s15 | 21 |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| s05 | s15 | 21 |'
- en: '| s06 | s17 | 21 |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| s06 | s17 | 21 |'
- en: '| s08 | s09 | 11 |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '| s08 | s09 | 11 |'
- en: '| s08 | s09 | 12 |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '| s08 | s09 | 12 |'
- en: Now let's use Gelly to find the Single Source Shortest Path.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用Gelly来找到单源最短路径。
- en: Here we have options to choose among the three algorithms we learnt in previous
    section. In this example, we will use Vertex-Centric iterations method.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以在前一节学到的三种算法中选择其中一种。在这个例子中，我们将使用顶点中心迭代方法。
- en: 'In order to solve the Single Source Shortest Path, we have to first load the
    data from CSV files as shown in the following code:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决单源最短路径问题，我们必须首先从CSV文件中加载数据，如下面的代码所示：
- en: '[PRE47]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Next we run Vertex-Centric iteration as discussed in the previous section on
    the graph we created:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在创建的图上运行前一节中讨论的顶点中心迭代：
- en: '[PRE48]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The implementation of Compute function and Combiner is similar to what we looked
    in the earlier section. When we run this code, we will get the answer for SSSP
    from given source vertex.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 计算函数和组合器的实现与我们在前一节中所看到的类似。当我们运行这段代码时，我们将得到从给定源顶点到SSSP的答案。
- en: The complete code and sample data for this use case is available at [https://github.com/deshpandetanmay/mastering-flink/tree/master/chapter07/flink-gelly](https://github.com/deshpandetanmay/mastering-flink/tree/master/chapter07/flink-gelly)
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 此用例的完整代码和样本数据可在 [https://github.com/deshpandetanmay/mastering-flink/tree/master/chapter07/flink-gelly](https://github.com/deshpandetanmay/mastering-flink/tree/master/chapter07/flink-gelly)
    上找到
- en: In general, all three iterations ways look similar but they have minute differences.
    One needs to really think which algorithm to use based on use case. Here is some
    good reading about the this thought [https://ci.apache.org/projects/flink/flink-docs-release-1.1/apis/batch/libs/gelly.html#iteration-abstractions-comparison](https://ci.apache.org/projects/flink/flink-docs-release-1.1/apis/batch/libs/gelly.html#iteration-abstractions-comparison).
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，所有三种迭代方式看起来都很相似，但它们有微小的差异。根据用例，人们需要真正思考使用哪种算法。这里有一些关于这个想法的好文章 [https://ci.apache.org/projects/flink/flink-docs-release-1.1/apis/batch/libs/gelly.html#iteration-abstractions-comparison](https://ci.apache.org/projects/flink/flink-docs-release-1.1/apis/batch/libs/gelly.html#iteration-abstractions-comparison)。
- en: Summary
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we explored various aspects of the graph processing API provided
    by the Flink Gelly library. We learnt how to define graphs, load data, and process
    it. We also looked at various transformations one can do on a graph. Finally we
    learnt details of iterative graph processing options that Gelly provides.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了Flink Gelly库提供的图处理API的各个方面。我们学习了如何定义图，加载数据并对其进行处理。我们还研究了可以对图进行的各种转换。最后，我们学习了Gelly提供的迭代图处理选项的详细信息。
- en: In the next chapter, we will see how to execute Flink applications on Hadoop
    and YARN.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到如何在Hadoop和YARN上执行Flink应用程序。
