- en: Building Objects and Packages for Code Reuse
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为了代码重用构建对象和包
- en: In this final chapter, we'll take a look at taking our code out of our own machines
    and sharing it with the world. The person we'll share with most often will be
    ourselves! So, with a view to making our own programming lives easier and more
    streamlined, we'll look at how to create objects and classes to simplify our own
    workflows and how to bundle them into packages for reuse in other projects. We'll
    look at tools for sharing code on sites such as GitHub and how to check that everything
    in your code works the way it is supposed to.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一章中，我们将探讨如何将我们的代码从自己的机器中带出去，并与世界分享。我们最常分享的对象将是我们自己！因此，为了使我们的编程生活更加轻松和流畅，我们将学习如何创建对象和类来简化我们的工作流程，并如何将它们打包成可在其他项目中重用的包。我们将查看如何在
    GitHub 等网站上共享代码的工具，以及如何检查代码是否按预期工作。
- en: 'The following recipes will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下食谱：
- en: Creating simple S3 objects to simplify code
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建简单的 S3 对象来简化代码
- en: Taking advantage of generic object functions with S3 classes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用 S3 类的通用对象函数
- en: Creating structured and formal objects with the S4 system
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 S4 系统创建结构化和正式的对象
- en: Simple ways to package code for sharing and reuse
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单的代码打包方法，用于共享和重用
- en: Using `devtools` to host code from GitHub
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `devtools` 从 GitHub 托管代码
- en: Building a unit test suite to ensure that functions work as you intend
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建单元测试套件，以确保函数按预期工作
- en: Using continuous integration with Travis to keep code tested and up to date
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Travis 进行持续集成，以确保代码经过测试并保持最新
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The sample data you'll need is available from this book's GitHub repository
    at [https://github.com/PacktPublishing/R-Bioinformatics-Cookbook](https://github.com/PacktPublishing/R-Bioinformatics-Cookbook)[.](https://github.com/danmaclean/R_Bioinformatics_Cookbook) If
    you want to use the code examples as they are written, then you will need to make
    sure that this data is in a sub-directory of whatever your working directory is.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要的示例数据可以从本书的 GitHub 仓库获取：[https://github.com/PacktPublishing/R-Bioinformatics-Cookbook](https://github.com/PacktPublishing/R-Bioinformatics-Cookbook)[。](https://github.com/danmaclean/R_Bioinformatics_Cookbook)
    如果您想按照书中的代码示例使用，您需要确保这些数据位于您的工作目录的子目录中。
- en: 'Here are the R packages that you''ll need. In general, you can install these
    with `install.packages("package_name")`. The packages listed under `Bioconductor`
    need to be installed with the dedicated installer. If you need to do anything
    further, installation will be described in the recipes in which the packages are
    used:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是您需要的 R 包。通常，您可以通过 `install.packages("package_name")` 来安装这些包。列在 `Bioconductor`
    下的包需要通过专用的安装程序安装。如果您需要做其他安装操作，会在包使用的食谱中描述：
- en: '`devtools`'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`devtools`'
- en: '`usethis`'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`usethis`'
- en: For some of the later recipes, we'll also need an installation of the `git` version
    control system. Check out the official website to get the latest version for your
    system: [https://git-scm.com/downloads](https://git-scm.com/downloads). You will
    also find a GitHub account on the GitHub website useful. Check out [https://github.com/](https://github.com/)[ if
    you don't already have a GitHub account.](https://github.com/)
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一些后续的食谱，我们还需要安装 `git` 版本控制系统。请访问官方网页以获取适用于您系统的最新版本：[https://git-scm.com/downloads](https://git-scm.com/downloads)。您还可以在
    GitHub 网站上找到一个有用的 GitHub 账户。如果您还没有 GitHub 账户，请访问[https://github.com/](https://github.com/)。
- en: Normally, in R, a user will load a library and use functions directly by name.
    This is great in interactive sessions but it can cause confusion when many packages
    are loaded. To clarify which package and function I'm using at a given moment,
    I will occasionally use the `packageName::functionName()` convention.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在 R 中，用户会加载一个库并直接按名称使用函数。这在交互式会话中非常方便，但当加载了多个包时，可能会引起混乱。为了明确在某一时刻我正在使用哪个包和函数，我偶尔会使用
    `packageName::functionName()` 这种惯例。
- en: 'Sometimes, in the middle of a recipe, I''ll interrupt the code so you can see
    some intermediate output or the structure of an object that''s important to understand.
    Whenever that happens, you''ll see a code block where each line begins with `##` (double
    hash) symbols. Consider the following command:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，在食谱的中途，我会中断代码，以便您可以看到一些中间输出或了解对象的结构，这对理解非常重要。每当发生这种情况时，您将看到一个代码块，其中每一行都以`##`（双哈希符号）开头。请考虑以下命令：
- en: '`letters[1:5]` This will give us the following output:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`letters[1:5]` 这将给我们以下输出：'
- en: '`## a b c d e` Note that the output lines are prefixed with `##`.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`## a b c d e` 请注意，输出行前面有`##`。'
- en: Creating simple S3 objects to simplify code
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建简单的 S3 对象以简化代码
- en: Creating your own objects can do a great deal to simplify your code and workflows,
    making them easier for you to reproduce and reuse and abstracting away a lot of
    the internal logic of a program so that the cognitive load on you as a programmer
    is reduced and you can concentrate more on the bioinformatic and analytical aspects
    of the project you're working on. R actually has numerous ways of creating objects
    and classes. In this recipe, we'll look at its simplest, most ad hoc method—S3\.
    This is a pretty informal way of creating objects and classes but does suffice
    in a lot of cases.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 创建你自己的对象可以大大简化代码和工作流，使它们更容易被你复现和重用，并且将程序的内部逻辑抽象掉，减少你作为程序员的认知负担，让你能够更多地集中精力在项目的生物信息学和分析方面。R
    实际上有多种方法来创建对象和类。在这个教程中，我们将重点看它最简单、最临时的方法——S3。这是一种相当非正式的创建对象和类的方式，但在很多情况下都足够使用。
- en: Getting ready
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we'll need just base R functions, so there's no need to install
    anything.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们只需要基础的 R 函数，因此无需安装任何额外的工具。
- en: How to do it...
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Creating simple S3 objects to simplify code can be done using the following
    steps:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 创建简单的 S3 对象以简化代码可以通过以下步骤完成：
- en: 'Create a constructor function:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个构造函数：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Call the constructor to make new objects:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用构造函数来创建新对象：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How it works...
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '*Step 1* is where all the work happens. This is all we need to create an S3
    object. As you can see, it is very lightweight code. We simply create a function
    that generates and returns a data structure. Our class is supposed to represent
    a simplistic genome and we want it to hold some basic information about a genome.
    The `SimpleGenome()` function is our constructor of objects. The genome list created
    by `SimpleGenome` is the data structure that makes up the body of the eventual
    object. The members of this list are the slots of the object, so we create members
    called `chromosome_count` and `chromosome_length` to represent some features of
    the genome. With that done, we carry out the important step—we append the class
    name (`SimpleGenome`) to the class attribute of the genome list. It is this that
    makes R recognize the object as being of the `SimpleGenome` class. We can now
    return the created S3 object.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*第1步* 是所有工作的起点。这就是我们创建 S3 对象所需的全部内容。如你所见，这是非常简洁的代码。我们只是创建了一个生成并返回数据结构的函数。我们的类应该代表一个简化的基因组，并且我们希望它能保存一些关于基因组的基本信息。`SimpleGenome()`
    函数是我们创建对象的构造函数。`SimpleGenome` 创建的基因组列表是构成最终对象主体的数据结构。这个列表的成员就是对象的槽，因此我们创建了名为 `chromosome_count`
    和 `chromosome_length` 的成员，以表示基因组的一些特征。完成这一步后，我们进行一个重要的步骤——我们将类名（`SimpleGenome`）附加到基因组列表的类属性上。正是这一点使
    R 能够识别这个对象属于 `SimpleGenome` 类。现在我们可以返回创建的 S3 对象。'
- en: 'In *step 2*, we simply use the constructor to make instances of the class.
    Inspecting the resulting objects looks like this:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第2步*中，我们只是简单地使用构造函数来创建类的实例。检查得到的对象如下所示：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We can see the object slots, the differences in the objects, and the class containing
    the new `SimpleGenome` object. This is how we create an S3 object; it's a simple
    but effective way of doing things. The advantages over just creating a normal
    data structure such as a list are not immediately obvious, but when we look at
    how to create methods in the next recipe the reasons will be clearer.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到对象的槽、对象之间的差异，以及包含新 `SimpleGenome` 对象的类。这就是我们创建 S3 对象的方式；它是一个简单但有效的做法。与仅仅创建一个普通数据结构（如列表）相比，优势并不是立刻显现出来，但当我们查看如何在下一个教程中创建方法时，原因将会更加明确。
- en: Taking advantage of generic object functions with S3 classes
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用 S3 类的通用对象函数
- en: Once we have an S3 object, we will need to create functions to work with it.
    These are really what makes working with the objects easy in the long run. It
    is in these functions that we can abstract away the processing of the data in
    the objects and reduce the work we are doing each time we use them. R's object
    system is based on generic functions. These are grouped functions with the same
    base name, but a class-specific name extension. Each group is called a method
    and R will decide which of the particular functions belonging to a method will
    be called based on the class of the object the method is called on. This means
    we can call `plot()` on objects of class `A` and get a completely different sort
    of figure than if we called it on an object of class `B`. In this recipe, we'll
    have a look at how that works.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了一个S3对象，我们需要创建与之配套的函数。这些函数实际上是使得长期使用这些对象变得更容易的关键。正是在这些函数中，我们可以抽象化对象数据的处理，从而减少每次使用时所需的工作量。R的对象系统基于通用函数。这些函数是具有相同基础名称但类特定名称扩展的分组函数。每个分组称为方法，R会根据方法调用的对象的类来决定调用属于该方法的具体哪个函数。这意味着我们可以在`A`类的对象上调用`plot()`，并得到与在`B`类对象上调用时完全不同的图形。在本食谱中，我们将了解它是如何工作的。
- en: Getting ready
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we'll use base R functions, so no need to install any packages,
    but we will use the built-in `iris` data.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本食谱，我们将使用基础的R函数，因此无需安装任何包，但我们将使用内置的`iris`数据。
- en: How to do it...
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Taking advantage of generic object functions with S3 classes can be done using
    the following steps:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 利用通用对象函数与S3类一起使用，可以通过以下步骤完成：
- en: 'Create a generic function in the `plot()` method:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`plot()`方法中创建一个通用函数：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Create an object and use it in `plot()`:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个对象并在`plot()`中使用它：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Create a new method first:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先创建一个新方法：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Modify an existing object''s class:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改现有对象的类：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Create a generic function for the new class:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为新类创建通用函数：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: How it works...
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In *step 1*, we create a generic function called `plot.SimpleGenome()`. The
    special naming convention here marks this out as a member of the group of generic
    plot functions specific to objects of the `SimpleGenome` class. The convention
    is `method.class`. This is all we need for the generic plot method to work.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第1步*中，我们创建了一个名为`plot.SimpleGenome()`的通用函数。这里的特殊命名约定标志着该函数是属于专门针对`SimpleGenome`类对象的通用绘图函数组。约定是`method.class`。这就是使通用绘图方法工作的所有必要步骤。
- en: 'In *step 2*, we actually create a `SimpleGenome` object as we did in the *Creating
    simple S3 objects to simplify code* recipe in this chapter (you''ll need to make
    sure that recipe''s *step 1* was executed in the current session for this step
    to work), and then call `plot()` on it. The `plot` method looks up the generic
    function for the `SimpleGenome` objects and runs that object, giving us the barplot
    we expect, as shown in the following diagram:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第2步*中，我们实际上创建一个`SimpleGenome`对象，就像在本章中的*创建简单的S3对象以简化代码*的食谱中所做的那样（你需要确保该食谱的*第1步*在当前会话中已经执行，否则这一步无法正常工作），然后调用`plot()`方法。`plot`方法查找适用于`SimpleGenome`对象的通用函数并运行该对象，从而生成我们预期的条形图，如下图所示：
- en: '![](img/a0f08b74-f112-4fdb-a319-9c4823670dd8.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a0f08b74-f112-4fdb-a319-9c4823670dd8.png)'
- en: 'With *step 3*, we take things a little deeper. In this step, we want to use
    a method name (`genome_lengths`) that doesn''t already exist (you can use the
    `methods()` function to see those that exist), so we must first create the method
    group. We do that by creating a function that calls the `UseMethod()` function,
    with the name of the method we want to create as the enclosing function name and
    the first argument. With that done, we can create the generic function for our
    `SimpleGenome` class and use it on our objects by simply calling `genomeLength()`.
    As our generic function simply adds up the `chromosome_lengths` vector, we get
    a result like this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第3步*中，我们深入了一些。在这一步中，我们想使用一个不存在的方法名（你可以使用`methods()`函数查看已经存在的方法），因此我们必须首先创建方法组。我们通过创建一个调用`UseMethod()`函数的函数来实现这一点，方法的名称作为封闭函数名称和第一个参数。完成后，我们就可以为`SimpleGenome`类创建通用函数，并通过简单地调用`genomeLength()`在对象上使用它。由于我们的通用函数只是将`chromosome_lengths`向量相加，我们得到如下结果：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Step 4* shows the mechanics of the class lookup system. We first make a copy
    of the `iris` data and then use the `summary()` method on it, giving the standard
    result for a dataframe:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '*第4步*展示了类查找系统的机制。我们首先复制`iris`数据，然后在其上使用`summary()`方法，得到数据框的标准结果：'
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next, we use the `class()` function, in *step 4*, to add a new class to the
    `some_data` object. Note we add it as the first element of the vector. We can
    see that the `data.frame` class is still there but is later in the order than
    the one we added:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在*第 4 步*中，我们使用`class()`函数为`some_data`对象添加了一个新类。注意，我们将其作为向量的第一个元素添加。我们可以看到，`data.frame`类仍然存在，但排在我们添加的类之后：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then, in *step 5*, we create a generic `summary()` function for `my_new_class`
    so that it returns a very different type of summary. We see that when we call
    it:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在*第 5 步*中，我们为`my_new_class`创建了一个通用的`summary()`函数，使其返回一个完全不同类型的摘要。我们可以看到，当我们调用它时：
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The point to note is that, although the object had more than one class, by default,
    the first generic function that matches a class is chosen. Try switching the order
    of the `class` attribute if you'd like to test this out.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一点是，尽管对象有多个类，但默认情况下会选择第一个与类匹配的通用函数。如果你想测试这一点，可以尝试交换`class`属性的顺序。
- en: Creating structured and formal objects with the S4 system
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用S4系统创建结构化和正式的对象
- en: S4 is a more formal counterpart to S3, particularly in that it has formal class
    definitions so it can't be used ad hoc but it does work in quite a similar way
    to S3, so what we've learned already will be generally applicable. In this recipe,
    we'll quickly run through how to create a class similar to our `SimpleGenome`
    object in the first two recipes of this chapter, with the S4 system. Knowing S4
    will be advantageous if you wish to write code to extend `Bioconductor`, as that
    is written in S4.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: S4是S3的更正式的对应版本，特别是因为它具有正式的类定义，所以不能随意使用，但它的工作方式与S3非常相似，因此我们已经学到的内容通常适用。在这个教程中，我们将快速介绍如何使用S4系统创建一个类似于本章前两节中`SimpleGenome`对象的类。了解S4会对你扩展`Bioconductor`（因为它是用S4编写的）有所帮助。
- en: Getting ready
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Again, we'll just use base R, so nothing to install.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们只使用基础R，因此无需安装任何东西。
- en: How to do it...
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Creating structured and formal objects with the S4 system can be done using
    the following steps:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 使用S4系统创建结构化和正式的对象可以按照以下步骤进行：
- en: 'Write the class definition:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写类定义：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Create a generic function:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建通用函数：
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Create the method:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建方法：
- en: '[PRE14]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: How it works
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: 'The outline here is very similar to the previous two recipes. In *step 1*,
    we create a class definition using the `setClass()` function; the first argument
    is the name of the class, and the `slots` argument is a proper list of slot names
    for the objects and the type for each one. The S4 class needs the types to be
    defined. In-use objects can be instantiated in the same way as for S3:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的大纲与前两个教程非常相似。在*第 1 步*中，我们使用`setClass()`函数创建了类定义；第一个参数是类的名称，`slots`参数是一个适当的插槽名称列表以及每个插槽的类型。S4类需要定义类型。使用中的对象可以像S3那样实例化：
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In *step 2*, we create a generic function, `chromosome_count`, using the `setGeneric()`
    function, passing the name and a function that calls the `standardGeneric()` function.
    This is pretty much boilerplate code, so follow it now and check it out in the
    documentation when you need more details.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第 2 步*中，我们使用`setGeneric()`函数创建了一个通用函数`chromosome_count`，传入函数的名称和一个调用`standardGeneric()`函数的函数。这基本上是模板代码，因此请按照这个步骤进行，并在需要更多细节时查阅文档。
- en: In *step 3*, we create the method. We use the `setMethod()` function to create
    a `chromosome_count` method. The second argument is the class this method will
    be called on, and finally, we pass the code we want for the method. The anonymous
    function simply calls the `slot()` function on the object passed to it. `slot()` returns
    the contents of the slot named in the second argument.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第 3 步*中，我们创建了方法。我们使用`setMethod()`函数创建了一个`chromosome_count`方法。第二个参数是这个方法将被调用的类，最后，我们传递了我们想要的代码。匿名函数仅仅调用了传递给它的对象上的`slot()`函数。`slot()`返回第二个参数中指定的槽的内容。
- en: See also
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参见
- en: If you do wish to go further with S4 to extend Bioconductor classes, see the
    tutorials provided by Bioconductor themselves at [https://www.bioconductor.org/help/course-materials/2017/Zurich/S4-classes-and-methods.html](https://www.bioconductor.org/help/course-materials/2017/Zurich/S4-classes-and-methods.html).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望进一步了解S4来扩展Bioconductor类，请查看Bioconductor自己提供的教程：[https://www.bioconductor.org/help/course-materials/2017/Zurich/S4-classes-and-methods.html](https://www.bioconductor.org/help/course-materials/2017/Zurich/S4-classes-and-methods.html)。
- en: Simple ways to package code for sharing and reuse
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分享和重用代码的简单方法
- en: Inevitably, there will come a time when you want to be able to reuse some functions
    or classes and not have to type (or—horror—copy and paste) them in every time.
    Having just one reliable version of things in one place makes it easy to manage
    and keep on top of mistakes and changes in code. So, in this recipe, we'll look
    at two simple ways of wrapping code up to reuse it. We'll touch on the very basics
    of package creation, though the packages we will make will be quite bare-bones
    and will need quite some fleshing out—especially with documentation and tests—before
    you consider releasing them. The packages you make in this way, though, will help
    you out as you develop your code.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 不可避免地，总会有这么一个时刻，你希望能够重用一些函数或类，而不必每次都重新输入（或者——更糟——复制粘贴）它们。将功能的唯一可靠版本放在一个地方，可以轻松管理，及时发现并解决代码中的错误和变化。因此，在这个教程中，我们将探讨两种简单的封装代码以便重用的方法。我们将讨论包创建的基础知识，尽管我们将创建的包将非常简陋，并且在考虑发布之前，需要进行大量的完善——特别是文档和测试方面。然而，以这种方式创建的包，将在你开发代码时提供帮助。
- en: Getting ready
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this, we'll need the `devtools` and `usethis` packages and the source code
    file, `my_source_file.R`, in the `datasets/ch11` folder of this book's repository.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们需要`devtools`和`usethis`包，以及本书仓库中`datasets/ch11`文件夹下的源代码文件`my_source_file.R`。
- en: How to do it...
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Wrapping code for sharing and reuse can be done using the following steps:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 封装代码以便共享和重用可以通过以下步骤完成：
- en: 'Load an existing source code file:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载现有的源代码文件：
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Create a package skeleton:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包骨架：
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Write code:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写代码：
- en: '[PRE18]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Load the package code into memory:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将包代码加载到内存中：
- en: '[PRE19]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Install the package into your current R installation:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将包安装到当前的 R 安装环境中：
- en: '[PRE20]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: How it works...
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The first step of this code shows a very effective but very rudimentary method
    of loading in your own pre-written external code. We use the `source()` function
    to load in a file of R code to the current namespace. The particular file here
    contains normal R functions and nothing else. The `source()` function simply reads
    the code in the external file and executes it as if it was typed directly into
    the current console. As the file just contains functions, then you have to get
    those loaded into memory for immediate use.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的第一步展示了一种非常有效但非常基础的加载外部代码的方法。我们使用 `source()` 函数将 R 代码文件加载到当前的命名空间中。这里的特定文件包含普通的
    R 函数，除此之外没有其他内容。`source()` 函数仅仅是读取外部文件中的代码并将其执行，就像它是直接在当前控制台中输入的一样。由于文件中仅包含函数，因此你必须将这些函数加载到内存中以便立即使用。
- en: '*Step 2* takes things a step further and creates a bare-bones package with
    the `usethis::create_package()`function. The function creates a new folder with
    the name that you provide (so, in this case, `newpackage`) and puts all of the
    essential files and folders you need for a package in there. You can now fill
    the `R/` subfolder in the package with R code that will eventually be loaded when
    you load the package. Try it with the function in *step 3*; add this function
    to a file called `my_functions.R` in the `R/` folder. It doesn''t matter too much
    what the files in the `R/` folder are called and you can have many—make sure they
    end in `.R` though.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤 2* 更进一步，使用 `usethis::create_package()` 函数创建了一个简陋的包。该函数会创建一个你提供名称的新文件夹（在这个例子中是
    `newpackage`），并将包所需的所有基本文件和文件夹放入其中。现在你可以在包的 `R/` 子文件夹中填充 R 代码，这些代码将在你加载包时加载。尝试使用
    *步骤 3* 中的函数；将此函数添加到 `R/` 文件夹中的 `my_functions.R` 文件中。`R/` 文件夹中的文件名并不太重要，你可以有很多文件——但一定要确保它们以
    `.R` 结尾。'
- en: '*Step 4* will take your source package and load it into memory using the `devtools::load_all()`
    function. This roughly emulates what happens when we call the `library()` function
    but without actually installing the package. By using `devtools::load_all()`,
    we can quickly load code to test it out, without having to first install it, so
    if we need to change the code, we don''t have a broken version installed. We don''t
    provide any arguments, so it loads the package in the current directory (if you
    provide a path as the first argument, it will load the package it finds there).'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤 4* 将会使用 `devtools::load_all()` 函数加载你的源代码包到内存中。这大致模拟了我们调用 `library()` 函数时发生的情况，但并没有真正安装包。通过使用
    `devtools::load_all()`，我们可以快速加载代码进行测试，而不必先安装它，这样如果我们需要更改代码，就不会有破损的版本被安装。我们没有提供任何参数，因此它会加载当前目录中的包（如果提供路径作为第一个参数，它会加载路径中找到的包）。'
- en: In *step 5*, we actually install the code properly into R. We use the `devtools::install()` function
    and it builds the package and copies the built version into the normal place in
    R. We can now load the built version as any other package with library (`newpackage`).
    Note that this means that we have two copies of the package—the one we installed
    and the one we are working on. You'll need to repeat steps four and five as needed
    as you develop more code and add it to your package.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第 5 步* 中，我们实际上将代码正确安装到 R 中。我们使用 `devtools::install()` 函数，它会构建包并将构建后的版本复制到
    R 中的常规位置。现在，我们可以像加载任何其他包一样加载该构建版本 (`newpackage`)。请注意，这意味着我们有两个包的副本—一个是我们安装的版本，另一个是我们正在开发的版本。在开发更多代码并将其添加到包中时，你需要根据需要重复步骤四和五。
- en: Using devtools to host code from GitHub
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 devtools 从 GitHub 托管代码
- en: Good practice in developing code means keeping it in some sort of version control
    system. One popular system among many is Git and the Git-sharing website GitHub.
    In this recipe, we'll look at using the `usethis` package to add some useful non-code
    files that help to describe how another user can reuse our code and the current
    state of its development and adding a mechanism to make sure the downstream user
    has the other packages that yours depends on. We'll look at how to then send the
    package to GitHub and how it can be installed directly from there.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的代码开发实践意味着将代码保存在某种版本控制系统中。Git 和 Git 共享网站 GitHub 是其中一种非常流行的系统。在本教程中，我们将使用 `usethis`
    包添加一些有用的非代码文件，帮助描述其他用户如何重用我们的代码以及当前开发状态，并添加机制确保下游用户拥有与你的代码相关依赖的其他包。接下来，我们将看看如何将包上传到
    GitHub 以及如何直接从 GitHub 安装。
- en: Getting ready
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will need the `usethis` and `devtools` packages.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要 `usethis` 和 `devtools` 包。
- en: How to do it...
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Using `devtools` to host code from GitHub can be done using the following steps:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `devtools` 从 GitHub 托管代码可以通过以下步骤完成：
- en: 'Add some useful metadata and license files to the package:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向包中添加一些有用的元数据和许可证文件：
- en: '[PRE21]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Add to the list of dependencies that will be automatically installed when your
    package is installed:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向依赖项列表中添加将在安装包时自动安装的内容：
- en: '[PRE22]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Automatically set up the local Git repository and get GitHub credentials:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 自动设置本地 Git 仓库并获取 GitHub 凭证：
- en: '[PRE23]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Install the package from GitHub:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 GitHub 安装包：
- en: '[PRE24]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: How it works...
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The code in *step 1* is really simple but it adds a lot to a package. The `usethis::use_mit_license()` function adds
    a text file called `LICENSE` that is populated with the text of the MIT license.
    Without a license file, it's difficult for others to see under what terms they
    can use the software. The MIT license is a simple and permissive one that's good
    for general open source software but there are alternatives; see this site for
    more help on choosing the right license for you: [https://choosealicense.com/](https://choosealicense.com/).
    Check out the `usethis` documentation regarding licenses for related functions
    that let you add other license types. The argument name in all of these functions
    allows you to specify the copyright holder of the software—it might be worth checking
    this out—if you're working for a company or institute, legal copyright may belong
    to them.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*第 1 步* 中的代码非常简单，但它为包添加了很多内容。`usethis::use_mit_license()` 函数会添加一个名为 `LICENSE`
    的文本文件，文件中包含 MIT 许可协议的内容。没有许可证文件，其他人很难知道在什么条件下可以使用该软件。MIT 许可协议是一种简单且宽松的许可，非常适合一般的开源软件，但也有其他替代方案；有关如何选择适合你的许可证，参见此网站：[https://choosealicense.com/](https://choosealicense.com/)。查看
    `usethis` 文档，了解有关许可证的相关函数，允许你添加其他许可证类型。所有这些函数的参数名称允许你指定软件的版权持有者—如果你为公司或机构工作，法律版权可能属于他们，值得检查这一点。'
- en: The `usethis::use_readme_rmd()` function adds a blank `.Rmd` file to which you
    can add code and text and which will be built into a regular markdown file and
    used on the front GitHub page of your repository as a `README` file. Put stuff
    describing your packages' objectives, basic usage, and installation instructions
    here as a minimum.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`usethis::use_readme_rmd()` 函数会添加一个空的 `.Rmd` 文件，你可以在其中添加代码和文本，该文件将被构建成一个常规的
    markdown 文件，并作为 `README` 文件显示在你仓库的 GitHub 前端页面上。最少在此文件中添加描述你的包的目标、基本用法和安装说明。'
- en: A helpful thing to add to your documentation is an indication of the stage of
    development. The `usethis::use_lifecycle_badge()` function lets you create a nice
    little graphical badge that displays where your package is up to. The terms you
    can use as the first argument are defined here: [https://www.tidyverse.org/lifecycle/](https://www.tidyverse.org/lifecycle/).
    Allied to this is the `usethis::use_version()` function, which will help you to
    increment the version major, minor, or patch version of your software.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 向文档中添加一个有用的信息是指明开发的阶段。`usethis::use_lifecycle_badge()`函数可以让你创建一个漂亮的小图形徽章，显示你的包的开发进度。你可以作为第一个参数使用的术语可以在这里查看：[https://www.tidyverse.org/lifecycle/](https://www.tidyverse.org/lifecycle/)。与此相关的是`usethis::use_version()`函数，它将帮助你递增软件的主要、次要或修复版本。
- en: In *step 2*, we manage the dependencies your package needs. These should be
    installed automatically by the package manager software when a user installs your
    package; R requires that they are placed in particular places in the package metadata
    description file. The `usethis::use_package()` function does this for you.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤 2*中，我们管理包所需的依赖项。当用户安装你的包时，包管理软件应会自动安装这些依赖项；R要求它们放置在包元数据描述文件中的特定位置。`usethis::use_package()`函数会为你完成这项工作。
- en: In *step 3*, we use the `usethis::use_git()` function to create a local `git`
    repository in the current directory; it also performs an initial commit of the
    current code to the repository. The `usethis::browse_github_token()` function will
    open a web browser window and navigate to GitHub on a page that will let you get
    a GitHub access token so your R session can interact with GitHub. Once you have
    this, `usethis::use_github()` will take the local `git` repository and create
    a repository on GitHub, make its origin remote, and push the code. You only need
    to do this once. When the `git` and GitHub repositories exist, you'll need to
    manage versioning manually using something such as RStudio's `git` panel or the
    command-line version of `git`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤 3*中，我们使用`usethis::use_git()`函数在当前目录创建一个本地的`git`仓库；它还会对当前代码进行初始提交。`usethis::browse_github_token()`函数会打开一个浏览器窗口，并导航到GitHub页面，允许你获取GitHub访问令牌，以便你的R会话能够与GitHub交互。获得令牌后，`usethis::use_github()`将把本地的`git`仓库上传至GitHub，设置远程仓库并推送代码。你只需要执行一次。当`git`和GitHub仓库存在时，你需要手动管理版本，使用RStudio的`git`面板或`git`的命令行版本。
- en: In *step 4*, we see how a remote user can install your package, simply using
    the `devtools::install_github()` function with whatever username and repository
    name are appropriate.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤 4*中，我们看到远程用户如何安装你的包，只需要使用`devtools::install_github()`函数，并提供适当的用户名和仓库名。
- en: Building a unit test suite to ensure that functions work as you intend
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建单元测试套件以确保函数按预期工作
- en: Most programmers test code obsessively and the practice of unit testing has
    arisen so that we have a formal way of testing functions that can be automated
    and help to reduce the time it takes to build even moderately complex code projects.
    A well-engineered and maintained software package has a unit test suite for as
    many of its component functions as it is possible to do. In this recipe, we'll
    look at how to use the `usethis` package to add the component files and folders
    for an automated test suite that uses the `testthat` package. It's beyond the
    scope of this book to look at the philosophy of why and how to write tests in
    any detail, but you can check out the `testthat` package documentation here, [https://testthat.r-lib.org/](https://testthat.r-lib.org/),
    for a nice primer.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数程序员会过度测试代码，单元测试的实践应运而生，让我们有了一种可以自动化并帮助减少构建中等复杂代码项目所需时间的正式测试方法。一个设计良好并维护的软件包，会为尽可能多的组件函数提供单元测试套件。在本食谱中，我们将学习如何使用`usethis`包添加组件文件和文件夹，以便创建一个使用`testthat`包的自动化测试套件。本书的范围不包括详细探讨为什么以及如何编写测试的哲学，但你可以查看`testthat`包的文档，网址是：[https://testthat.r-lib.org/](https://testthat.r-lib.org/)，作为一个很好的入门指南。
- en: Getting ready
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We'll need the `usethis`, `testthat`, and `devtools` packages.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要`usethis`、`testthat`和`devtools`包。
- en: How to do it...
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Use the following steps to build a unit test suite to ensure that functions
    work as you intend:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下步骤构建单元测试套件，以确保函数按预期工作：
- en: 'Create the test folder structure:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建测试文件夹结构：
- en: '[PRE25]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Add a new test:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加新的测试：
- en: '[PRE26]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Run the actual tests:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行实际的测试：
- en: '[PRE27]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: How it works...
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '*Step 1* is a typical `usethis` style function that creates some common filesystem
    components for your package—`use_testthat()` simply builds the folder structure
    that the underlying testing engine `testthat` needs.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '*第 1 步* 是一个典型的 `usethis` 风格函数，创建一些你的包所需的常见文件系统组件——`use_testthat()` 只是构建了 `testthat`
    测试引擎所需要的文件夹结构。'
- en: '*Step 2* puts the `usethiss::use_test()` function to work to create a test
    file—it uses the value of the function argument as the suffix of a filename so
    that, in this case, with `adds` as the argument, we get a file called `test-adds.R`
    in the `tests/testthat` folder. We can then add `tests` to that file. Each test
    will follow the basic pattern shown in the second line of this step. The `test_that()`
    function is called; its first argument is a bit of text that is printed to the
    console at test time, so we know which test is being worked on. The second argument
    is a block of assertions from the `testthat` package that compare the output from
    a function with an expected value. If the two match, the test passes; otherwise,
    it fails. There are many assertions in `testthat` that allow you to test many
    types of output and objects. You can see these in the documentation: [https://testthat.r-lib.org/](https://testthat.r-lib.org/).
    Note that the test should be in the test file and saved, not typed into the console.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '*第 2 步* 中，`usethis::use_test()` 函数开始工作，创建一个测试文件——它使用函数参数的值作为文件名的后缀，因此在此情况下，使用
    `adds` 作为参数，会在 `tests/testthat` 文件夹中创建一个名为 `test-adds.R` 的文件。然后，我们可以将 `tests`
    添加到该文件中。每个测试将遵循此步骤第二行所示的基本模式。调用 `test_that()` 函数；其第一个参数是打印到控制台的文本，显示当前正在进行的测试。第二个参数是来自
    `testthat` 包的断言块，比较函数的输出与预期值。如果两者匹配，则测试通过；否则，测试失败。`testthat` 中有许多断言，可以测试多种类型的输出和对象。你可以在文档中查看：[https://testthat.r-lib.org/](https://testthat.r-lib.org/)。请注意，测试应该在测试文件中完成并保存，而不是直接在控制台中输入。'
- en: In *step 3*, we use the `devtools::test()` function in the console to run the
    test suite automatically. The results of the tests are printed to the console
    and you can modify the functions as needed then re-run this step.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第 3 步* 中，我们在控制台使用 `devtools::test()` 函数自动运行测试套件。测试结果会打印到控制台，你可以根据需要修改函数，然后重新运行此步骤。
- en: Using continuous integration with Travis to keep code tested and up to date
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Travis 的持续集成来保持代码经过测试并保持最新
- en: '**Continuous Integration** (**CI**) is a team programming practice that was
    developed to help large teams working on the same project to keep all of their
    code, dependencies, and tests working together as well as possible. The tools
    developed to facilitate this can also help us to manage our own software projects
    and keep on top of problems that arise from our own updates, updates in the packages
    we have used as dependencies, and even updates to R and the operating system in
    certain cases. `Travis.CI` is one CI service that is supported in the `devtools`
    package. With `Travis.CI` integrated into your project, the Travis server will
    build a new virtual computer, install an operating system on it, install R and
    all of the package dependencies your package needs, then install your package
    and run its test suite. Travis will then send the results to you. This process
    is repeated at intervals—notably, every time you do a push to GitHub so you can
    keep an eye on what is breaking with your code and get an early handle on problems.
    In this recipe, we''ll look at how to set up Travis for your package project.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '**持续集成**（**CI**）是一种团队编程实践，旨在帮助大团队在同一个项目中保持代码、依赖关系和测试的最佳协作。为此开发的工具同样可以帮助我们管理自己的软件项目，解决由于自己更新、所依赖包的更新，甚至在某些情况下，R
    和操作系统更新引发的问题。`Travis.CI` 是 `devtools` 包支持的一个 CI 服务。通过将 `Travis.CI` 集成到你的项目中，Travis
    服务器将构建一个新的虚拟计算机，安装操作系统，安装 R 及你的包所需的所有依赖包，然后安装你的包并运行测试套件。Travis 会将结果发送给你。这个过程会周期性地重复，尤其是每次你向
    GitHub 推送代码时，以便你及时了解哪些代码出现了问题，并能及早解决问题。在这个食谱中，我们将介绍如何为你的包项目设置 Travis。'
- en: Getting ready
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, you'll need the `usethis` package and a package project hosted
    on GitHub. The earlier recipes in this chapter will help you with that if you
    don't already have that set up.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个食谱，你需要 `usethis` 包和一个托管在 GitHub 上的包项目。如果你还没有设置这些，前面章节的食谱将帮助你完成这些步骤。
- en: How to do it...
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'To use CI with Travis to keep code tested and up to date, we create a `.travis.yml`
    file:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用 Travis 的持续集成来保持代码经过测试并保持最新，我们需要创建一个 `.travis.yml` 文件：
- en: '[PRE28]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: How it works...
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The only line of code in this recipe creates a file called `.travis.yml` in
    the root of your package directory. This file works as a hook on GitHub so that,
    once the repository is updated, the `Travis.CI` server will carry out a new build
    of the virtual server and package and run the tests, then email you the results
    at the address associated with your GitHub account. Although it is only one line,
    this is probably one of the most impactful single lines in this whole book! The
    `.travis.yml` file carries configuration options for the Travis build and much
    can be added to customize the output. One common addition to that file is as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码中的唯一一行会在你的包目录的根目录中创建一个名为`.travis.yml`的文件。这个文件在GitHub上作为钩子使用，因此，一旦仓库被更新，`Travis.CI`服务器将会执行新的虚拟服务器构建和打包，并运行测试，然后将结果通过电子邮件发送到与你的GitHub账户关联的邮箱地址。尽管这只有一行代码，但这可能是本书中最具影响力的单行代码！`.travis.yml`文件包含了Travis构建的配置选项，并且可以添加很多内容来自定义输出。一个常见的添加内容如下：
- en: '[PRE29]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This will tell Travis that warnings from R code are not to be counted as errors
    and won't make the build fail.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这将告诉Travis，R代码中的警告不应视为错误，也不会导致构建失败。
- en: A build can take time; expect even simple code to take 15 minutes. More complicated
    projects will take longer.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 构建可能需要一些时间；即便是简单的代码也可能需要15分钟。更复杂的项目将需要更长的时间。
