- en: Chapter 1. Statistics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章. 统计学
- en: '|   | *"The people who cast the votes decide nothing. The people who count
    the votes decide everything."* |   |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
  zh: '|   | *“投票的人决定不了什么，计算票数的人决定了一切。”* |   |'
- en: '|   | --*Joseph Stalin* |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '|   | --*约瑟夫·斯大林* |'
- en: Over the course of the following ten chapters of *Clojure for Data Science*,
    we'll attempt to discover a broadly linear path through the field of data science.
    In fact, we'll find as we go that the path is not quite so linear, and the attentive
    reader ought to notice many recurring themes along the way.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的十章中，我们将尝试在*数据科学的Clojure*中探索一条大体线性的路径。事实上，我们会发现这条路径并不是那么线性，细心的读者应当注意到沿途会有许多反复出现的主题。
- en: Descriptive statistics concern themselves with summarizing sequences of numbers
    and they'll appear, to some extent, in every chapter in this book. In this chapter,
    we'll build foundations for what's to come by implementing functions to calculate
    the mean, median, variance, and standard deviation of numerical sequences in Clojure.
    While doing so, we'll attempt to take the fear out of interpreting mathematical
    formulae.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 描述性统计学关注的是总结数字序列，它们将在本书的每一章中以某种程度出现。在本章中，我们将通过实现函数来计算数字序列的均值、中位数、方差和标准差，为后续内容奠定基础。在此过程中，我们将尽力消除对数学公式解释的恐惧。
- en: 'As soon as we have more than one number to analyze it becomes meaningful to
    ask how those numbers are distributed. You''ve probably already heard expressions
    such as "long tail" and the "80/20 rule". They concern the spread of numbers throughout
    a range. We demonstrate the value of distributions in this chapter and introduce
    the most useful of them all: the normal distribution.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有多个数字需要分析，询问这些数字是如何分布的就变得有意义了。你可能已经听过像“长尾效应”和“80/20法则”这样的表达。它们关注的是数字在一个范围内的分布情况。本章中，我们将展示分布的价值，并介绍最有用的分布：正态分布。
- en: The study of distributions is aided immensely by visualization, and for this
    we'll use the Clojure library Incanter. We'll show how Incanter can be used to
    load, transform, and visualize real data. We'll compare the results of two national
    elections—the 2010 United Kingdom general election and the 2011 Russian presidential
    election—and see how even basic analysis can provide evidence of potentially fraudulent
    activity.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 分布的研究得到了可视化的大力帮助，为此我们将使用Clojure库Incanter。我们将展示如何使用Incanter加载、转换和可视化真实数据。我们将比较两次国家选举的结果——2010年英国大选和2011年俄罗斯总统选举——并看看即使是基础分析也能提供潜在欺诈行为的证据。
- en: Downloading the sample code
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 下载示例代码
- en: All of the book's sample code is available on Packt Publishing's website at
    [http://www.packtpub.com/support](http://www.packtpub.com/support) or from GitHub
    at [http://github.com/clojuredatascience](http://github.com/clojuredatascience).
    Each chapter's sample code is available in its own repository.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的所有示例代码都可以在Packt出版公司的官方网站[http://www.packtpub.com/support](http://www.packtpub.com/support)或GitHub上[http://github.com/clojuredatascience](http://github.com/clojuredatascience)找到。每章的示例代码都有自己的仓库。
- en: Note
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The sample code for [Chapter 1](ch01.xhtml "Chapter 1. Statistics"), *Statistics*
    can be downloaded from [https://github.com/clojuredatascience/ch1-statistics](https://github.com/clojuredatascience/ch1-statistics).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '[第1章](ch01.xhtml "第1章. 统计学")的示例代码，*统计学*可以从[https://github.com/clojuredatascience/ch1-statistics](https://github.com/clojuredatascience/ch1-statistics)下载。'
- en: Executable examples are provided regularly throughout all chapters, either to
    demonstrate the effect of code that has been just been explained, or to demonstrate
    statistical principles that have been introduced. All example function names begin
    with `ex-` and are numbered sequentially throughout each chapter. So, the first
    runnable example of [Chapter 1](ch01.xhtml "Chapter 1. Statistics"), *Statistics*
    is named `ex-1-1`, the second is named `ex-1-2`, and so on.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 可执行示例会定期出现在所有章节中，要么演示刚刚解释的代码效果，要么演示已引入的统计原理。所有示例函数的名称都以`ex-`开头，并且在每章中按顺序编号。所以，第1章的第一个可运行示例*统计学*名为`ex-1-1`，第二个名为`ex-1-2`，依此类推。
- en: Running the examples
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行示例
- en: 'Each example is a function in the `cljds.ch1.examples` namespace that can be
    run in two ways—either from the **REPL** or on the command line with **Leiningen**.
    If you''d like to run the examples in the REPL, you can execute:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 每个示例是`cljds.ch1.examples`命名空间中的一个函数，可以通过两种方式运行——要么从**REPL**，要么通过**Leiningen**在命令行运行。如果你想在REPL中运行示例，可以执行：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'on the command line. By default, the REPL will open in the `examples` namespace.
    Alternatively, to run a specific numbered example, you can execute:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令行中，默认情况下，REPL 将在 `examples` 命名空间中打开。或者，如果你想运行某个特定的示例，可以执行：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'or pass the single-letter equivalent:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 或者使用单个字母的等效命令：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We only assume basic command-line familiarity throughout this book. The ability
    to run Leiningen and shell scripts is all that's required.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本书假设你对基本的命令行操作有一定了解。只需能够运行 Leiningen 和 Shell 脚本即可。
- en: Tip
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you become stuck at any point, refer to the book's wiki at [http://wiki.clojuredatascience.com](http://wiki.clojuredatascience.com).
    The wiki will provide troubleshooting tips for known issues, including advice
    for running examples on a variety of platforms.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在任何阶段遇到困难，请参考本书的维基：[http://wiki.clojuredatascience.com](http://wiki.clojuredatascience.com)。维基将提供已知问题的故障排除提示，包括在不同平台上运行示例的建议。
- en: In fact, shell scripts are only used for fetching data from remote locations
    automatically. The book's wiki will also provide alternative instructions for
    those not wishing or unable to execute the shell scripts.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，Shell 脚本仅用于自动从远程位置获取数据。本书的维基也会为不愿意或无法执行 Shell 脚本的读者提供替代的说明。
- en: Downloading the data
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 下载数据
- en: The dataset for this chapter has been made available by the Complex Systems
    Research Group at the Medical University of Vienna. The analysis we'll be performing
    closely mirrors their research to determine the signals of systematic election
    fraud in the national elections of countries around the world.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的数据集由维也纳医科大学的复杂系统研究小组提供。我们将进行的分析与他们的研究紧密相连，旨在确定全球各国全国选举中系统性选举舞弊的信号。
- en: Note
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more information about the research, and for links to download other datasets,
    visit the book's wiki or the research group's website at [http://www.complex-systems.meduniwien.ac.at/elections/election.html](http://www.complex-systems.meduniwien.ac.at/elections/election.html).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如需了解更多关于研究的信息，以及下载其他数据集的链接，请访问本书的维基或研究小组的网站：[http://www.complex-systems.meduniwien.ac.at/elections/election.html](http://www.complex-systems.meduniwien.ac.at/elections/election.html)。
- en: Throughout this book we'll be making use of numerous datasets. Where possible,
    we've included the data with the example code. Where this hasn't been possible—either
    because of the size of the data or due to licensing constraints—we've included
    a script to download the data instead.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将使用大量数据集。在可能的情况下，我们已将数据与示例代码一起提供。如果由于数据量太大或许可限制无法提供数据，我们则提供了下载数据的脚本。
- en: '[Chapter 1](ch01.xhtml "Chapter 1. Statistics"), *Statistics* is just such
    a chapter. If you''ve cloned the chapter''s code and intend to follow the examples,
    download the data now by executing the following on the command line from within
    the project''s directory:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '[第一章](ch01.xhtml "第一章. 统计学")，*统计学*就是这样的一章。如果你已经克隆了该章节的代码，并打算跟随示例进行操作，请通过在项目目录中的命令行执行以下命令来下载数据：'
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The script will download and decompress the sample data into the project's data
    directory.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本将会下载并解压样本数据到项目的数据目录中。
- en: Tip
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you have any difficulty running the download script or would like to follow
    manual instructions instead, visit the book's wiki at [http://wiki.clojuredatascience.com](http://wiki.clojuredatascience.com)
    for assistance.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在运行下载脚本时遇到困难，或者希望按照手动说明进行操作，请访问本书的维基：[http://wiki.clojuredatascience.com](http://wiki.clojuredatascience.com)获取帮助。
- en: We'll begin investigating the data in the next section.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节开始调查数据。
- en: Inspecting the data
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查数据
- en: Throughout this chapter, and for many other chapters in this book, we'll be
    using the Incanter library ([http://incanter.org/](http://incanter.org/)) to load,
    manipulate, and display data.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章以及本书的许多其他章节中，我们将使用 Incanter 库（[http://incanter.org/](http://incanter.org/)）来加载、处理和显示数据。
- en: Incanter is a modular suite of Clojure libraries that provides statistical computing
    and visualization capabilities. Modeled after the extremely popular R environment
    for data analysis, it brings together the power of Clojure, an interactive REPL,
    and a set of powerful abstractions for working with data.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Incanter 是一套模块化的 Clojure 库，提供统计计算和可视化功能。它模仿了广受欢迎的数据分析环境 R，将 Clojure 的强大功能、交互式
    REPL 和处理数据的强大抽象结合在一起。
- en: Each module of Incanter focuses on a specific area of functionality. For example
    `incanter-stats` contains a suite of related functions for analyzing data and
    producing summary statistics, while `incanter-charts` provides a large number
    of visualization capabilities. `incanter-core` provides the most fundamental and
    generally useful functions for transforming data.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Incanter的每个模块专注于特定的功能领域。例如，`incanter-stats`包含一套相关函数，用于分析数据并生成摘要统计信息，而`incanter-charts`提供大量的可视化功能。`incanter-core`提供了最基本且通常有用的用于数据转换的函数。
- en: 'Each module can be included separately in your own code. For access to stats,
    charts, and Excel features, you could include the following in your `project.clj`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 每个模块可以单独包含在你的代码中。如果需要访问统计、图表和Excel功能，你可以在`project.clj`中包含以下内容：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If you don''t mind including more libraries than you need, you can simply include
    the full Incanter distribution instead:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不介意包含比所需更多的库，你也可以直接包含完整的Incanter分发包：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'At Incanter''s core is the concept of a dataset—a structure of rows and columns.
    If you have experience with relational databases, you can think of a dataset as
    a table. Each column in a dataset is named, and each row in the dataset has the
    same number of columns as every other. There are a several ways to load data into
    an Incanter dataset, and which we use will depend how our data is stored:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Incanter的核心概念是数据集——一个包含行和列的结构。如果你有关系型数据库的经验，可以将数据集视为一个表格。数据集中的每一列都有名称，数据集中的每一行都有与其他行相同数量的列。有几种方式可以将数据加载到Incanter数据集中，具体使用哪种方式取决于我们的数据存储方式：
- en: If our data is a text file (a CSV or tab-delimited file), we can use the `read-dataset`
    function from `incanter-io`
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们的数据是文本文件（CSV或制表符分隔文件），我们可以使用`incanter-io`中的`read-dataset`函数。
- en: If our data is an Excel file (for example, an `.xls` or `.xlsx` file), we can
    use the `read-xls` function from `incanter-excel`
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们的数据是Excel文件（例如，`.xls`或`.xlsx`文件），我们可以使用`incanter-excel`中的`read-xls`函数。
- en: For any other data source (an external database, website, and so on), as long
    as we can get our data into a Clojure data structure we can create a dataset with
    the `dataset` function in `incanter-core`
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于任何其他数据源（外部数据库、网站等），只要我们能将数据转换成Clojure数据结构，就可以使用`incanter-core`中的`dataset`函数来创建数据集。
- en: 'This chapter makes use of Excel data sources, so we''ll be using `read-xls`.
    The function takes one required argument—the file to load—and an optional keyword
    argument specifying the sheet number or name. All of our examples have only one
    sheet, so we''ll just provide the file argument as string:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 本章使用了Excel数据源，因此我们将使用`read-xls`函数。该函数需要一个必需的参数——要加载的文件——以及一个可选的关键字参数，用于指定工作表的编号或名称。我们所有的示例只有一个工作表，因此我们只需提供文件参数作为字符串：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In general, we will not reproduce the namespace declarations from the example
    code. This is both for brevity and because the required namespaces can usually
    be inferred by the symbol used to reference them. For example, throughout this
    book we will always refer to `clojure.java.io` as `io`, `incanter.core` as `I`,
    and `incanter.excel` as `xls` wherever they are used.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，我们不会在示例代码中重复命名空间声明。这是为了简洁，并且因为所需的命名空间通常可以通过引用它们的符号推断出来。例如，在本书中，我们将始终把`clojure.java.io`称为`io`，将`incanter.core`称为`I`，将`incanter.excel`称为`xls`，无论何时使用它们。
- en: 'We''ll be loading several data sources throughout this chapter, so we''ve created
    a multimethod called `load-data` in the `cljds.ch1.data` namespace:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将加载多个数据源，因此我们在`cljds.ch1.data`命名空间中创建了一个名为`load-data`的多方法：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding code, we define the `load-data` multimethod that dispatches
    on the `identity` of the first argument. We also define the implementation that
    will be called if the first argument is `:uk`. Thus, a call to `(load-data :uk)`
    will return an Incanter dataset containing the UK data. Later in the chapter,
    we'll define additional `load-data` implementations for other datasets.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们定义了`load-data`多方法，它根据第一个参数的`identity`进行分派。我们还定义了当第一个参数为`:uk`时被调用的实现。因此，调用`(load-data
    :uk)`将返回一个包含英国数据的Incanter数据集。在本章后面，我们将为其他数据集定义额外的`load-data`实现。
- en: 'The first row of the `UK2010.xls` spreadsheet contains column names. Incanter''s
    `read-xls` function will preserve these as the column names of the returned dataset.
    Let''s begin our exploration of the data by inspecting them now—the `col-names`
    function in `incanter.core` returns the column names as a vector. In the following
    code (and throughout the book, where we use functions from the `incanter.core`
    namespace) we require it as `i`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`UK2010.xls` 电子表格的第一行包含列名。Incanter 的 `read-xls` 函数会将这些列名作为返回数据集的列名。让我们现在通过检查它们来开始探索数据——`incanter.core`
    中的 `col-names` 函数将列名作为向量返回。在接下来的代码中（以及本书中，我们使用来自 `incanter.core` 命名空间的函数时），我们将其命名为
    `i`：'
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As described in running the examples earlier, functions beginning with `ex-`
    can be run on the command line with Leiningen like this:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在运行示例时，前缀为`ex-`的函数可以像下面这样通过Leiningen在命令行上运行：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The output of the preceding command should be the following Clojure vector:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 前述命令的输出应该是以下 Clojure 向量：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This is a very wide dataset. The first six columns in the data file are described
    as follows; subsequent columns break the number of votes down by party:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常宽的数据集。数据文件中的前六列描述如下；后续列按党派细分投票数：
- en: '**Press Association Reference**: This is a number identifying the constituency
    (voting district, represented by one MP)'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**新闻社参考**：这是一个识别选区（投票区，由一名议员代表）的数字'
- en: '**Constituency Name**: This is the common name given to the voting district'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选区名称**：这是给投票区（选区）起的常用名称'
- en: '**Region**: This is the geographic region of the UK where the constituency
    is based'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**区域**：这是选区所在的英国地理区域'
- en: '**Election Year**: This is the year in which the election was held'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选举年份**：这是选举举行的年份'
- en: '**Electorate**: This is the total number of people eligible to vote in the
    constituency'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选民**：这是选区内有资格投票的总人数'
- en: '**Votes**: This is the total number of votes cast'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**投票数**：这是总投票数'
- en: Whenever we're confronted with new data, it's important to take time to understand
    it. In the absence of detailed data definitions, one way we could do this is to
    begin by validating our assumptions about the data. For example, we expect that
    this dataset contains information about the 2010 election so let's review the
    contents of the `Election Year` column.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们面对新数据时，理解数据是非常重要的。如果没有详细的数据定义，我们可以通过验证自己对数据的假设来开始理解它。例如，我们预期这个数据集包含关于2010年选举的信息，那么让我们先回顾一下
    `选举年份` 列的内容。
- en: 'Incanter provides the `i/$` function (`i`, as before, signifying the `incanter.core`
    namespace) for selecting columns from a dataset. We''ll encounter the function
    regularly throughout this chapter—it''s Incanter''s primary way of selecting columns
    from a variety of data representations and it provides several different arities.
    For now, we''ll be providing just the name of the column we''d like to extract
    and the dataset from which to extract it:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Incanter 提供了 `i/$` 函数（`i`，如前所述，表示 `incanter.core` 命名空间）用于从数据集中选择列。我们将在本章中经常遇到这个函数——它是
    Incanter 从各种数据表示中选择列的主要方式，并且提供了多个不同的重载。目前，我们只需要提供我们想提取的列名和要提取的 dataset：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The years are returned as a single sequence of values. The output may be hard
    to interpret since the dataset contains so many rows. As we''d like to know which
    unique values the column contains, we can use the Clojure core function `distinct`.
    One of the advantages of using Incanter is that its useful data manipulation functions
    augment those that Clojure already provides as shown in the following example:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这些年份作为一个单一的值序列返回。由于数据集包含很多行，输出可能难以理解。为了知道列中包含哪些唯一值，我们可以使用 Clojure 的核心函数 `distinct`。使用
    Incanter 的一个优点是它的有用数据操作函数增强了 Clojure 已经提供的函数，正如下面的示例所示：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `2010` year goes a long way to confirming our expectations that this data
    is from `2010`. The `nil` value is unexpected, though, and may indicate a problem
    with our data.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`2010` 年份在很大程度上确认了我们的预期——这些数据来自 `2010`。然而，`nil` 值则出乎意料，可能表明数据存在问题。'
- en: 'We don''t yet know how many nils exist in the dataset and determining this
    could help us decide what to do next. A simple way of counting values such as
    this it to use the core library function `frequencies`, which returns a map of
    values to counts:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们目前还不知道数据集中有多少个 nil 值，确定这一点可能帮助我们决定接下来该做什么。计数这类值的一个简单方法是使用核心库函数 `frequencies`，它返回一个值与计数的映射：
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the preceding examples, we used Clojure's thread-last macro `->>` to chain
    a several functions together for legibility.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们使用了 Clojure 的线程最后宏 `->>` 来将多个函数连接在一起，提升可读性。
- en: Tip
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Along with Clojure's large core library of data manipulation functions, macros
    such as the one discussed earlier—including the thread-last macro `->>`—are other
    great reasons for using Clojure to analyze data. Throughout this book, we'll see
    how Clojure can make even sophisticated analysis concise and comprehensible.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 Clojure 大量的核心数据处理函数外，像前面讨论的宏——包括线程最后宏 `->>`——也是使用 Clojure 进行数据分析的另一个重要原因。在本书中，我们将看到
    Clojure 如何使即使是复杂的分析也能简洁且易于理解。
- en: It wouldn't take us long to confirm that in 2010 the UK had 650 electoral districts,
    known as constituencies. Domain knowledge such as this is invaluable when sanity-checking
    new data. Thus, it's highly probable that the `nil` value is extraneous and can
    be removed. We'll see how to do this in the next section.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很快就能确认，2010 年英国有 650 个选区，称为选区。像这样的领域知识在对新数据进行合理性检查时非常宝贵。因此，`nil` 值很可能是多余的，可以删除。我们将在下一节看到如何做这件事。
- en: Data scrubbing
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据清洗
- en: It is a commonly repeated statistic that at least 80 percent of a data scientist's
    work is data scrubbing. This is the process of detecting potentially corrupt or
    incorrect data and either correcting or filtering it out.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个常见的统计数据表明，数据科学家至少 80% 的工作是数据清洗。这是检测潜在的损坏或错误数据，并进行修正或过滤的过程。
- en: Note
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Data scrubbing is one of the most important (and time-consuming) aspects of
    working with data. It's a key step to ensuring that subsequent analysis is performed
    on data that is valid, accurate, and consistent.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 数据清洗是处理数据时最重要（也是最耗时）的步骤之一。它是确保后续分析基于有效、准确且一致的数据进行的关键步骤。
- en: The `nil` value at the end of the election year column may indicate dirty data
    that ought to be removed. We've already seen that filtering *columns* of data
    can be accomplished with Incanter's `i/$` function. For filtering *rows* of data
    we can use Incanter's `i/query-dataset` function.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 选举年列末尾的 `nil` 值可能表示需要清除的脏数据。我们已经看到，通过 Incanter 的 `i/$` 函数可以过滤 *列* 数据。要过滤 *行*
    数据，我们可以使用 Incanter 的 `i/query-dataset` 函数。
- en: 'We let Incanter know which rows we''d like it to filter by passing a Clojure
    map of column names and predicates. Only rows for which all predicates return
    true will be retained. For example, to select only the `nil` values from our dataset:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过传递一个包含列名和谓词的 Clojure 映射，让 Incanter 知道我们希望过滤哪些行。只有所有谓词返回 true 的行才会被保留。例如，要从数据集中仅选择
    `nil` 值：
- en: '[PRE14]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If you know SQL, you'll notice this is very similar to a `WHERE` clause. In
    fact, Incanter also provides the `i/$where` function, an alias to `i/query-dataset`
    that reverses the order of the arguments.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你了解 SQL，你会发现这与 `WHERE` 子句非常相似。事实上，Incanter 还提供了 `i/$where` 函数，这是 `i/query-dataset`
    的别名，反转了参数的顺序。
- en: 'The query is a map of column names to predicates and each predicate is itself
    a map of operator to operand. Complex queries can be constructed by specifying
    multiple columns and multiple operators together. Query operators include:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 查询是一个将列名映射到谓词的映射，每个谓词本身是一个操作符到操作数的映射。可以通过指定多个列和多个操作符来构建复杂的查询。查询操作符包括：
- en: '`:$gt` greater than'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`:$gt` 大于'
- en: '`:$lt` less than'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`:$lt` 小于'
- en: '`:$gte` greater than or equal to'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`:$gte` 大于或等于'
- en: '`:$lte` less than or equal to'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`:$lte` 小于或等于'
- en: '`:$eq` equal to'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`:$eq` 等于'
- en: '`:$ne` not equal to'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`:$ne` 不等于'
- en: '`:$in` to test for membership of a collection'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`:$in` 用于测试是否为某集合的成员'
- en: '`:$nin` to test for non-membership of a collection'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`:$nin` 用于测试是否不为某集合的成员'
- en: '`:$fn` a predicate function that should return a true response for rows to
    keep'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`:$fn` 一个谓词函数，应该返回 true 以保留该行'
- en: If none of the built-in operators suffice, the last operator provides the ability
    to pass a custom function instead.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果内置操作符不足以满足需求，最后一个操作符提供了传递自定义函数的能力。
- en: 'We''ll continue to use Clojure''s thread-last macro to make the code intention
    a little clearer, and return the row as a map of keys and values using the `i/to-map`
    function:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续使用 Clojure 的线程最后宏（thread-last macro）来使代码的意图更清晰，并使用 `i/to-map` 函数将行返回为键值对映射：
- en: '[PRE15]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Looking at the results carefully, it''s apparent that all (but one) of the
    columns in this row are `nil`. In fact, a bit of further exploration confirms
    that the non-nil row is a summary total and ought to be removed from the data.
    We can remove the problematic row by updating the predicate map to use the `:$ne`
    operator, returning only rows where the election year is not equal to `nil`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细查看结果，很明显这一行中所有（除了一个）列的值都是`nil`。事实上，经过进一步的探索，确认非`nil`行是一个汇总总数，应该从数据中删除。我们可以通过更新谓词映射，使用`:$ne`操作符来删除有问题的行，只返回选举年份不等于`nil`的行：
- en: '[PRE16]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The preceding function is one we''ll almost always want to make sure we call
    in advance of using the data. One way of doing this is to add another implementation
    of our `load-data` multimethod, which also includes this filtering step:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 上述函数是我们几乎总是希望在使用数据之前调用的。实现这一点的一种方式是添加另一个`load-data`多方法的实现，其中也包括此过滤步骤：
- en: '[PRE17]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now with any code we write, can choose whether to refer to the `:uk` or `:uk-scrubbed`
    datasets.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，无论我们写什么代码，都可以选择引用`:uk`或`:uk-scrubbed`数据集。
- en: By always loading the source file and performing our scrubbing on top, we're
    preserving an audit trail of the transformations we've applied. This makes it
    clear to us—and future readers of our code—what adjustments have been made to
    the source. It also means that, should we need to re-run our analysis with new
    source data, we may be able to just load the new file in place of the existing
    file.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 通过始终加载源文件并在其上执行数据清洗，我们保留了我们所做转换的审计记录。这使我们——以及未来的代码读者——能够清楚地了解对源数据做了哪些调整。它还意味着，如果我们需要使用新的源数据重新运行分析，我们可能只需将新文件加载到现有文件的位置。
- en: Descriptive statistics
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 描述性统计
- en: Descriptive statistics are numbers that are used to summarize and describe data.
    In the next chapter, we'll turn our attention to a more sophisticated analysis,
    the so-called **inferential statistics**, but for now we'll limit ourselves to
    simply describing what we can observe about the data contained in the file.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 描述性统计是用来总结和描述数据的数字。在下一章，我们将关注更复杂的分析方法——所谓的**推论统计**，但现在我们只限于简单地描述文件中数据的观察内容。
- en: 'To demonstrate what we mean, let''s look at the `Electorate` column of the
    data. This column lists the total number of registered voters in each constituency:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示我们的意思，我们来看一下数据中的`Electorate`列。该列列出了每个选区注册选民的总数：
- en: '[PRE18]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We've filtered the `nil` field from the dataset; the preceding code should return
    a list of `650` numbers corresponding to the electorate in each of the UK constituencies.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经从数据集中过滤掉了`nil`字段；上述代码应该返回一个包含`650`个数字的列表，代表每个英国选区的选民。
- en: Descriptive statistics, also called **summary statistics**, are ways of measuring
    attributes of sequences of numbers. They help characterize the sequence and can
    act as a guide for further analysis. Let's start by calculating the two most basic
    statistics that we can from a sequence of numbers—its mean and its variance.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 描述性统计，也叫做**汇总统计**，是衡量数值序列特征的方式。它们有助于表征序列，并可以作为进一步分析的指导。让我们从计算数值序列中最基本的两个统计量开始——均值和方差。
- en: The mean
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 均值
- en: 'The most common way of measuring the average of a data set is with the mean.
    It''s actually one of several ways of measuring the **central tendency** of the
    data. The mean, or more precisely, the arithmetic mean, is a straightforward calculation—simply
    add up the values and divide by the count—but in spite of this it has a somewhat
    intimidating mathematical notation:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 测量数据集平均值最常见的方法是均值。它实际上是衡量数据**集中趋势**的几种方法之一。均值，或者更准确地说，是算术均值，是一种直接的计算方法——简单地将数值加起来并除以数量——但尽管如此，它的数学符号看起来还是让人有些畏惧：
- en: '![The mean](img/7180OS_01_01.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![均值](img/7180OS_01_01.jpg)'
- en: where ![The mean](img/7180OS_01_02.jpg) is pronounced *x-bar*, the mathematical
    symbol often used to denote the mean.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 其中![均值](img/7180OS_01_02.jpg)被读作*x-bar*，是常用于表示均值的数学符号。
- en: To programmers coming to data science from fields outside mathematics or the
    sciences, this notation can be quite confusing and alienating. Others may be entirely
    comfortable with this notation, and they can safely skip the next section.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 对于从数学或科学以外领域进入数据科学的程序员来说，这种符号可能会让人感到困惑和陌生。其他人可能对这种符号完全熟悉，他们可以放心跳过下一节。
- en: Interpreting mathematical notation
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解释数学符号
- en: Although mathematical notation may appear obscure and upsetting, there are really
    only a handful of symbols that will occur frequently in the formulae in this book.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管数学符号看起来可能晦涩难懂，实际上只有少数几个符号会在本书的公式中频繁出现。
- en: '*Σ* is pronounced *sigma* and means *sum*. When you see it in mathematical
    notation it means that a sequence is being added up. The symbols above and below
    the *sigma* indicate the range over which we''ll be summing. They''re rather like
    a C-style `for` loop and in the earlier formula indicate we''ll be summing from
    *i=1* up to *i=n*. By convention *n* is the length of the sequence, and sequences
    in mathematical notation are one-indexed, not zero-indexed, so summing from *1*
    to *n* means that we''re summing over the entire length of the sequence.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '*Σ* 读作 *sigma*，意思是 *和*。当你看到它出现在数学符号中时，意味着一个序列正在被求和。位于 *sigma* 上下的符号表示我们将要进行求和的范围。它们类似于
    C 风格的 `for` 循环，在之前的公式中，表示我们会从 *i=1* 到 *i=n* 进行求和。按照惯例，*n* 是序列的长度，且数学符号中的序列是从 1
    开始索引的，而不是从 0 开始，因此从 *1* 到 *n* 求和意味着我们在求整个序列的和。'
- en: The expression immediately following the sigma is the sequence to be summed.
    In our preceding formula for the mean, *x*[i] immediately follows the sigma. Since
    *i* will represent each index from *1* up to *n*, *x*[i] represents each element
    in the sequence of *xs*.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 紧跟着 sigma 的表达式是要被求和的序列。在我们之前的平均数公式中，*x*[i] 紧跟在 sigma 后面。由于 *i* 将表示从 *1* 到 *n*
    的每个索引，*x*[i] 代表 *xs* 序列中的每个元素。
- en: Finally, ![Interpreting mathematical notation](img/7180OS_01_03.jpg) appears
    just before the sigma, indicating that the entire expression should be multiplied
    by *1* divided by *n* (also called the **reciprocal of n**). This can be simplified
    to just dividing by *n*.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，![解读数学符号](img/7180OS_01_03.jpg) 出现在 sigma 之前，表示整个表达式应乘以 *1* 除以 *n*（也称为 **n
    的倒数**）。这可以简化为只除以 *n*。
- en: '| Name | Mathematical symbol | Clojure equivalent |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 数学符号 | Clojure 对应 |'
- en: '| --- | --- | --- |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '|   | *n* | `(count xs)` |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '|   | *n* | `(count xs)` |'
- en: '| Sigma notation | ![Interpreting mathematical notation](img/7180OS_01_04.jpg)
    | `(reduce + xs)` |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| Sigma 符号 | ![解读数学符号](img/7180OS_01_04.jpg) | `(reduce + xs)` |'
- en: '| Pi notation | ![Interpreting mathematical notation](img/7180OS_01_05.jpg)
    | `(reduce * xs)` |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| Pi 符号 | ![解读数学符号](img/7180OS_01_05.jpg) | `(reduce * xs)` |'
- en: 'Putting this all together, we get "add up the elements in the sequence from
    the first to the last and divide by the count". In Clojure, this can be written
    as:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 将这一切结合起来，我们得出“将序列中的元素从第一个加到最后一个，然后除以元素的数量”。在 Clojure 中，这可以写成：
- en: '[PRE19]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Where `xs` stands for "the sequence of *xs*". We can use our new `mean` function
    to calculate the mean of the UK electorate:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，`xs` 代表“*xs* 序列”。我们可以使用新的 `mean` 函数来计算英国选民的平均数：
- en: '[PRE20]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In fact, Incanter already includes a function, `mean`, to calculate the mean
    of a sequence very efficiently in the `incanter.stats` namespace. In this chapter
    (and throughout the book), the `incanter.stats` namespace will be required as
    `s` wherever it's used.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，Incanter 已经在 `incanter.stats` 命名空间中包含了一个非常高效的计算序列平均数的函数 `mean`。在本章（以及全书）中，任何使用
    `incanter.stats` 命名空间的地方都会用 `s` 作为简写。
- en: The median
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 中位数
- en: The median is another common descriptive statistic for measuring the central
    tendency of a sequence. If you ordered all the data from lowest to highest, the
    median is the middle value. If there is an even number of data points in the sequence,
    the median is usually defined as the mean of the middle two values.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 中位数是另一种常见的描述性统计量，用于衡量序列的集中趋势。如果将所有数据从低到高排序，中位数就是中间的值。如果序列中的数据点数量是偶数，中位数通常定义为中间两个值的平均数。
- en: 'The median is often represented in formulae by ![The median](img/7180OS_01_06.jpg),
    pronounced *x-tilde*. It''s one of the deficiencies of mathematical notation that
    there''s no particularly standard way of expressing the formula for the median
    value, but nonetheless it''s fairly straightforward in Clojure:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 中位数通常用 ![中位数](img/7180OS_01_06.jpg) 表示，发音为 *x-tilde*。这是数学符号中的一个不足之处，因为没有特别标准的方式来表示中位数公式，但在
    Clojure 中仍然相当直接：
- en: '[PRE21]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The median of the UK electorate is:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 英国选民的中位数是：
- en: '[PRE22]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Incanter also has a function for calculating the median value as `s/median`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Incanter 也提供了一个用于计算中位数的函数 `s/median`。
- en: Variance
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方差
- en: The mean and the median are two alternative ways of describing the middle value
    of a sequence, but on their own they tell you very little about the values contained
    within it. For example, if we know the mean of a sequence of ninety-nine values
    is 50, we can still say very little about what values the sequence contains.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 均值和中位数是描述序列中间值的两种替代方法，但单独使用它们几乎无法告诉我们序列中包含的值。例如，如果我们知道一个包含99个值的序列的均值是50，我们也无法仅凭此判断序列包含哪些值。
- en: It may contain all the integers from one to ninety-nine, or forty-nine zeros
    and fifty ninety-nines. Maybe it contains negative one ninety-eight times and
    a single five-thousand and forty-eight. Or perhaps all the values are exactly
    fifty.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 它可能包含从1到99的所有整数，或者49个零和50个99。也许它包含了负一的值98次，且有一个5000和48。或者，可能所有的值都是恰好50。
- en: 'The variance of a sequence is its "spread" about the mean, and each of the
    preceding examples would have a different variance. In mathematical notation,
    the variance is expressed as:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 序列的方差是其关于均值的“分散度”，前面每个例子的方差都会不同。在数学符号中，方差表示为：
- en: '![Variance](img/7180OS_01_07.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![Variance](img/7180OS_01_07.jpg)'
- en: where *s*² is the mathematical symbol often used to denote the variance.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，*s*²是通常用于表示方差的数学符号。
- en: This equation bears a number of similarities to the equation for the mean calculated
    previously. Instead of summing a single value, *x*[i], we are summing a function
    of ![Variance](img/7180OS_01_08.jpg). Recall that the symbol ![Variance](img/7180OS_01_02.jpg)
    represents the mean value, so the function calculates the squared deviation of
    *xi* from the mean of all the *xs*.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方程与之前计算均值的方程有许多相似之处。不同的是，我们不是求单一值*x*[i]的总和，而是求![Variance](img/7180OS_01_08.jpg)函数的总和。回忆一下，符号![Variance](img/7180OS_01_02.jpg)表示均值，因此这个函数计算了*xi*相对于所有*xs*均值的平方偏差。
- en: We can turn the expression ![Variance](img/7180OS_01_08.jpg) into a function,
    `square-deviation`, that we map over the sequence of `xs`. We can also make use
    of the `mean` function we've already created to sum the values in the sequence
    and divide by the count.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将表达式![Variance](img/7180OS_01_08.jpg)转化为一个函数`square-deviation`，然后应用于`xs`序列。我们还可以利用已经创建的`mean`函数，计算序列中的值的总和，并除以计数。
- en: '[PRE23]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We're using Incanter's `i/sq` function to calculate the square of our expression.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用Incanter的`i/sq`函数来计算表达式的平方。
- en: 'Since we''ve squared the deviation before taking the mean, the units of variance
    are also squared, so the units of the variance of the UK electorate are "people
    squared". This is somewhat unnatural to reason about. We can make the units more
    natural by taking the square root of the variance so the units are "people" again,
    and the result is called the **standard deviation**:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在取均值之前已经对偏差进行了平方，因此方差的单位也会被平方，所以英国选民的方差单位是“人平方”。这种单位有些不太自然。我们可以通过取方差的平方根，使得单位再次变为“人”，结果称为**标准差**：
- en: '[PRE24]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Incanter's implements functions to calculate the variance and standard deviation
    as `s/variance` and `s/sd` respectively.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Incanter实现了分别计算方差和标准差的函数，分别为`s/variance`和`s/sd`。
- en: Quantiles
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分位数
- en: The median is one way to calculate the *middle* value from a list, and the variance
    provides a way to measure the spread of the data about this midpoint. If the entire
    spread of data were represented on a scale of zero to one, the median would be
    the value at 0.5.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 中位数是计算列表中*中间*值的一种方法，方差则提供了一种衡量数据相对于该中点的分布情况的方式。如果整个数据的分布在零到一的尺度上表示，中位数将是位于0.5处的值。
- en: 'For example, consider the following sequence of numbers:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下数字序列：
- en: '[PRE25]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: There are seven numbers in the sequence, so the median is the fourth, or 21\.
    This is also referred to as the 0.5 quantile. We can get a richer picture of a
    sequence of numbers by looking at the 0, 0.25, 0.5, 0.7, and 1.0 quantiles. Taken
    together, these numbers will not only show the median, but will also summarize
    the range of the data and how the numbers are distributed within it. They're sometimes
    referred to as the *five-number summary*.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 序列中有七个数字，因此中位数是第四个，或者是21。这个值也称为0.5分位数。我们可以通过查看0、0.25、0.5、0.7和1.0分位数，获得序列数字的更丰富画面。将这些数字放在一起，它们不仅显示了中位数，还总结了数据的范围和数字在其中的分布情况。它们有时被称为*五数概括*。
- en: 'One way to calculate the five-number summary for the UK electorate data is
    shown as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 计算英国选民数据的五数概括的一种方法如下所示：
- en: '[PRE26]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Quantiles can also be calculated in Incanter directly with the `s/quantile`
    function. A sequence of desired quantiles is passed as the keyword argument `:probs`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以直接使用Incanter的`s/quantile`函数计算分位数。所需的分位数序列作为关键字参数`:probs`传入。
- en: Note
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Incanter's `quantile` function uses a variant of the algorithm shown earlier
    called the **phi-quantile**, which performs linear interpolation between consecutive
    numbers in certain cases. There are many alternative ways of calculating quantiles—consult
    [https://en.wikipedia.org/wiki/Quantile](https://en.wikipedia.org/wiki/Quantile)
    for a discussion of the differences.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Incanter的`quantile`函数使用一种称为**phi-quantile**的算法变体，在某些情况下，它会在连续数字之间进行线性插值。计算分位数的方式有很多种——请参阅[https://en.wikipedia.org/wiki/Quantile](https://en.wikipedia.org/wiki/Quantile)了解不同算法之间的差异。
- en: Where quantiles split the range into four equal ranges as earlier, they are
    called **quartiles**. The difference between the lower and upper quartile is referred
    to as the **interquartile** **range**, also often abbreviated to just **IQR**.
    Like the variance about the mean, the IQR gives a measure of the spread of the
    data about the median.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当分位数将范围分为四个相等的范围时，它们被称为**四分位数**。下四分位数和上四分位数之间的差异称为**四分位距**，通常简写为**IQR**。像均值的方差一样，IQR提供了关于中位数数据分布的度量。
- en: Binning data
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分箱数据
- en: To develop an intuition for what these various calculations of variance are
    measuring, we can employ a technique called **binning**. Where data is continuous,
    using `frequencies` (as we did with the election data to count the nils) is not
    practical since no two values may be the same. However, it's possible to get a
    broad sense of the structure of the data by grouping the data into discrete intervals.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解这些方差计算所衡量的内容，我们可以使用一种称为**分箱**的技术。对于连续数据，使用`frequencies`（正如我们在选举数据中用来计算零值一样）并不实用，因为两个值可能不完全相同。然而，通过将数据分为离散的区间，我们可以大致了解数据的结构。
- en: 'The process of binning is to divide the range of values into a number of consecutive,
    equally-sized, smaller bins. Each value in the original series falls into exactly
    one bin. By counting the number of points falling into each bin, we can get a
    sense of the spread of the data:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 分箱过程是将数值范围划分为若干个连续、等大小的较小箱子。原始数据中的每个值都会落入其中的一个箱子。通过统计每个箱子中的点数，我们可以大致了解数据的分布情况：
- en: '![Binning data](img/7180OS_01_100.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![分箱数据](img/7180OS_01_100.jpg)'
- en: 'The preceding illustration shows fifteen values of *x* split into five equally-sized
    bins. By counting the number of points falling into each bin we can clearly see
    that most points fall in the middle bin, with fewer points falling into the bins
    towards the edges. We can achieve the same in Clojure with the following `bin`
    function:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例展示了将十五个*x*值分为五个相等大小的箱子。通过统计每个箱子内的点数，我们可以清楚地看到，大多数点落在中间的箱子中，而靠近边缘的箱子内的点数较少。我们可以使用以下`bin`函数在Clojure中实现相同的功能：
- en: '[PRE27]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'For example, we can bin range 0-14 into `5` bins like so:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以将范围0-14分成`5`个箱子，如下所示：
- en: '[PRE28]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Once we''ve binned the values we can then use the `frequencies` function once
    again to count the number of points in each bin. In the following code, we use
    the function to split the UK electorate data into five bins:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们将值分箱，我们可以再次使用`frequencies`函数统计每个箱子中的点数。在以下代码中，我们使用该函数将英国选民数据分为五个箱子：
- en: '[PRE29]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The count of points in the extremal bins (0 and 4) is much lower than the bins
    in the middle—the counts seem to rise up towards the median and then down again.
    In the next section, we'll visualize the shape of these counts.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 极端箱子（0和4）的点数远低于中间的箱子——这些点数似乎向中位数处上升，然后又下降。在接下来的部分，我们将可视化这些点数的分布形态。
- en: Histograms
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 直方图
- en: A histogram is one way to visualize the distribution of a single sequence of
    values. Histograms simply take a continuous distribution, bin it, and plot the
    frequencies of points falling into each bin as a bar. The height of each bar in
    the histogram represents how many points in the data are contained in that bin.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 直方图是一种可视化单一数据序列分布的方法。直方图通过将连续分布进行分箱，并绘制每个箱子中点数的频率来呈现数据。直方图中每个条形的高度表示数据中有多少点落在该箱子内。
- en: We've already seen how to bin data ourselves, but `incanter.charts` contains
    a `histogram` function that will bin the data and visualize it as a histogram
    in two steps. We require `incanter.charts` as `c` in this chapter (and throughout
    the book).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看过如何自己进行数据分箱，但`incanter.charts`包含一个`histogram`函数，可以通过两个步骤对数据进行分箱并可视化为直方图。在本章（以及全书）中，我们需要将`incanter.charts`作为`c`。
- en: '[PRE30]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The preceding code generates the following chart:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码生成了以下图表：
- en: '![Histograms](img/7180OS_01_110.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![直方图](img/7180OS_01_110.jpg)'
- en: 'We can configure the number of bins data is segmented into by passing the keyword
    argument `:nbins` as the second parameter to the histogram function:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将关键字参数`:nbins`作为第二个参数传递给`histogram`函数，来配置数据被分为多少个箱：
- en: '[PRE31]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The preceding graph shows a single, high peak but expresses the shape of the
    data quite crudely. The following graph shows fine detail, but the volume of the
    bars obscures the shape of the distribution, particularly in the tails:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图表显示了一个单一的高峰，但相对粗略地表达了数据的形状。下面的图表显示了更精细的细节，但柱状图的体积遮蔽了分布的形状，特别是在尾部：
- en: '![Histograms](img/7180OS_01_120.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![直方图](img/7180OS_01_120.jpg)'
- en: Choosing the number of bins to represent your data is a fine balance—too few
    bins and the shape of the data will only be crudely represented, too many and
    noisy features may obscure the underlying structure.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 选择表示数据的箱数是一个精细的平衡——箱数太少，数据的形状将只会被粗略表示；箱数太多，噪声特征可能会遮蔽底层结构。
- en: '[PRE32]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The following shows a histogram of `20` bars instead:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 下面显示的是`20`个柱状条的直方图：
- en: '![Histograms](img/7180OS_01_130.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![直方图](img/7180OS_01_130.jpg)'
- en: This final chart containing `20` bins seems to be the best representation for
    this data so far.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这个包含`20`个箱的最终图表似乎是目前为止最好的数据表示。
- en: Along with the mean and the median, the *mode* is another way of measuring the
    average value of a sequence—it's defined as the most frequently occurring value
    in the sequence. The mode is strictly only defined for sequences with at least
    one duplicated value; for many distributions, this is not the case and the mode
    is undefined. Nonetheless, the peak of the histogram is often referred to as the
    mode, since it corresponds to the most popular bin.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 除了均值和中位数，*众数*是另一种衡量序列平均值的方式——它被定义为序列中最常出现的值。众数严格来说仅定义在至少有一个重复值的序列中；对于许多分布，情况并非如此，因此众数是未定义的。然而，直方图的峰值通常被称为众数，因为它对应于最流行的箱。
- en: We can clearly see that the distribution is quite symmetrical about the mode,
    with values falling sharply either side along shallow tails. This is data following
    an approximately normal distribution.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以清晰地看到，分布在众数附近非常对称，值在两侧急剧下降，尾部较浅。这是数据遵循大致正态分布的表现。
- en: The normal distribution
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正态分布
- en: A histogram will tell you approximately how data is distributed throughout its
    range, and provide a visual means of classifying your data into one of a handful
    of common distributions. Many distributions occur frequently in data analysis,
    but none so much as the normal distribution, also called the **Gaussian distribution**.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 直方图将告诉你数据如何大致分布在其范围内，并提供一种将数据分类为几种常见分布之一的可视化手段。在数据分析中，许多分布经常出现，但没有比正态分布更为常见的，正态分布也叫做**高斯分布**。
- en: Note
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The distribution is named the normal distribution because of how often it occurs
    in nature. Galileo noticed that the errors in his astronomical measurements followed
    a distribution where small deviations from the mean occurred more frequently than
    large deviations. It was the great mathematician Gauss' contribution to describing
    the mathematical shape of these errors that led to the distribution also being
    called the Gaussian distribution in his honor.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 该分布被称为正态分布，是因为它在自然界中出现的频率非常高。伽利略注意到，他的天文测量误差遵循一个分布，即从均值的偏差较小的出现频率比偏差较大的频率更高。正是伟大的数学家高斯对这些误差的数学形状的描述，使得该分布也被称为高斯分布，以此纪念他。
- en: 'A distribution is like a compression algorithm: it allows a potentially large
    amount of data to be summarized very efficiently. The normal distribution requires
    just two parameters from which the rest of the data can be approximated—the mean
    and the standard deviation.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 分布就像是一种压缩算法：它允许将大量数据非常高效地进行总结。正态分布只需要两个参数，其他数据可以从这两个参数中进行近似——均值和标准差。
- en: The central limit theorem
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 中心极限定理
- en: The reason for the normal distribution's ubiquity is partly explained by the
    central limit theorem. Values generated from diverse distributions will tend to
    converge to the normal distribution under certain circumstances, as we will show
    next.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 正态分布的普遍性部分可以通过中心极限定理来解释。来自不同分布的数值在特定条件下会趋向于收敛到正态分布，接下来我们将展示这一点。
- en: 'A common distribution in programming is the *uniform* distribution. This is
    the distribution of numbers generated by Clojure''s `rand` function: for a fair
    random number generator, all numbers have an equal chance of being generated.
    We can visualize this on a histogram by generating a random number between zero
    and one many times over and plotting the results.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程中，一种常见的分布是*均匀*分布。这是由Clojure的`rand`函数生成的数字分布：对于一个公平的随机数生成器，所有数字生成的机会是相等的。我们可以通过多次生成一个0到1之间的随机数并绘制结果，来在直方图中可视化这一点。
- en: '[PRE33]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The preceding code will generate the following histogram:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将生成以下直方图：
- en: '![The central limit theorem](img/7180OS_01_140.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![中心极限定理](img/7180OS_01_140.jpg)'
- en: Each bar of the histogram is approximately the same height, corresponding to
    the equal probability of generating a number that falls into each bin. The bars
    aren't exactly the same height since the uniform distribution describes the theoretical
    output that our random sampling can't mirror precisely. Over the next several
    chapters, we'll learn ways to precisely quantify the difference between theory
    and practice to determine whether the differences are large enough to be concerned
    with. In this case, they are not.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 每个直方图的条形高度大致相同，对应于生成落入每个区间的数字的均等概率。条形的高度并不完全相同，因为均匀分布描述的是我们的随机抽样无法精确反映的理论输出。在接下来的几章中，我们将学习如何精确量化理论与实践之间的差异，以确定这些差异是否足够大，值得关注。在这个案例中，它们并不大。
- en: If instead we generate a histogram of the means of sequences of numbers, we'll
    end up with a distribution that looks rather different.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们生成的是数列均值的直方图，结果会呈现出与之前截然不同的分布。
- en: '[PRE34]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The preceding code will provide an output similar to the following histogram:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将生成类似于以下直方图的输出：
- en: '![The central limit theorem](img/7180OS_01_150.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![中心极限定理](img/7180OS_01_150.jpg)'
- en: Although it's not impossible for the mean to be close to zero or one, it's exceedingly
    improbable and grows less probable as both the number of averaged numbers and
    the number of sampled averages grow. In fact, the output is exceedingly close
    to the normal distribution.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然均值接近零或一并非不可能，但这种情况极为不可能，而且随着平均数的数量和抽样平均值的数量增加，这种不可能性会变得越来越大。事实上，输出值极其接近正态分布。
- en: This outcome—where the average effect of many small random fluctuations leads
    to the normal distribution—is called the **central limit theorem**, sometimes
    abbreviated to **CLT**, and goes a long way towards explaining why the normal
    distribution occurs so frequently in natural phenomena.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结果——即许多小的随机波动的平均效应导致正态分布——被称为**中心极限定理**，有时简称为**CLT**，它在很大程度上解释了为什么正态分布在自然现象中如此频繁地出现。
- en: 'The central limit theorem wasn''t named until the 20^(th) century, although
    the effect had been documented as early as 1733 by the French mathematician Abraham
    de Moivre, who used the normal distribution to approximate the number of heads
    resulting from tosses of a fair coin. The outcome of coin tosses is best modeled
    with the binomial distribution, which we will introduce in [Chapter 4](ch04.xhtml
    "Chapter 4. Classification"), *Classification*. While the central limit theorem
    provides a way to generate samples from an approximate normal distribution, Incanter''s
    `distributions` namespace provides functions for generating samples efficiently
    from a variety of distributions, including the normal:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 中心极限定理直到20世纪才得以命名，尽管这一效应早在1733年就被法国数学家阿布拉罕·德·莫伊夫（Abraham de Moivre）记录下来，他用正态分布来近似公平投掷硬币时的正面出现次数。硬币投掷的结果最适合用二项分布来建模，我们将在[第4章](ch04.xhtml
    "第4章. 分类") *分类*中介绍二项分布。虽然中心极限定理提供了一种从近似正态分布中生成样本的方法，但Incanter的`distributions`命名空间提供了从多种分布中高效生成样本的函数，包括正态分布：
- en: '[PRE35]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The preceding code generates the following histogram:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码生成了以下直方图：
- en: '![The central limit theorem](img/7180OS_01_155.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![中心极限定理](img/7180OS_01_155.jpg)'
- en: The `d/draw` function will return one sample from the supplied distribution.
    The default mean and standard deviation from `d/normal-distribution` are zero
    and one respectively.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`d/draw`函数将从提供的分布返回一个样本。`d/normal-distribution`的默认均值和标准差分别为零和一。'
- en: Poincaré's baker
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 庞加莱的面包师
- en: There's a story that, while almost certainly apocryphal, allows us to look in
    more detail at the way in which the central limit theorem allows us to reason
    about how distributions are formed. It concerns the celebrated nineteenth century
    French polymath Henri Poincaré who, so the story goes, weighed his bread every
    day for a year.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个故事说，虽然几乎可以确定是虚构的，但它使我们更详细地了解中心极限定理如何帮助我们推断分布的形成方式。这个故事涉及到著名的十九世纪法国多面手亨利·庞加莱，据说他一年中每天称量自己的面包。
- en: Baking was a regulated profession, and Poincaré discovered that, while the weights
    of the bread followed a normal distribution, the peak was at 950g rather than
    the advertised 1kg. He reported his baker to the authorities and so the baker
    was fined.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 烘焙是一个受监管的行业，庞加莱发现，虽然面包的重量符合正态分布，但峰值在950克，而不是宣传的1公斤。他再次向当局举报面包师，于是面包师被罚款。
- en: The next year, Poincaré continued to weigh his bread from the same baker. He
    found the mean value was now 1kg, but that the distribution was no longer symmetrical
    around the mean. The distribution was skewed to the right, consistent with the
    baker giving Poincaré only the heaviest of his loaves. Poincaré reported his baker
    to the authorities once more and his baker was fined a second time.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 第二年，庞加莱继续从同一位面包师那里购买面包并称重。他发现均值现在是1公斤，但围绕均值的分布不再对称。分布向右偏，与面包师只给庞加莱最重的面包相符。庞加莱再次向当局举报面包师，面包师第二次被罚款。
- en: Whether the story is true or not needn't concern us here; it's provided simply
    to illustrate a key point—the distribution of a sequence of numbers can tell us
    something important about the process that generated it.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在不必关心这个故事是否真实；这个故事仅用来说明一个关键点——一系列数字的分布可以告诉我们生成它的过程中的一些重要信息。
- en: Generating distributions
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成分布
- en: To develop our intuition about the normal distribution and variance, let's model
    an honest and dishonest baker using Incanter's distribution functions. We can
    model the honest baker as a normal distribution with a mean of 1,000, corresponding
    to a fair loaf of 1kg. We'll assume a variance in the baking process that results
    in a standard deviation of 30g.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 为了发展我们对正态分布和方差的直觉，让我们使用Incanter的分布函数来模拟一个诚实和不诚实的面包师。我们可以将诚实的面包师建模为均值为1000的正态分布，对应于1公斤的公平面包。我们假设在烘焙过程中存在方差，导致标准差为30克。
- en: '[PRE36]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The preceding code will provide an output similar to the following histogram:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将生成类似以下直方图的输出：
- en: '![Generating distributions](img/7180OS_01_160.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![生成分布](img/7180OS_01_160.jpg)'
- en: 'Now, let''s model a baker who sells only the heaviest of his loaves. We partition
    the sequence into groups of thirteen (a "baker''s dozen") and pick the maximum
    value:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们模拟一个只卖最重的面包的面包师。我们将序列分成13个一组（“面包师的一打”），然后选择最大值：
- en: '[PRE37]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The preceding code will produce a histogram similar to the following:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将生成类似以下直方图的输出：
- en: '![Generating distributions](img/7180OS_01_170.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![生成分布](img/7180OS_01_170.jpg)'
- en: It should be apparent that this histogram does not look quite like the others
    we have seen. The mean value is still 1kg, but the spread of values around the
    mean is no longer symmetrical. We say that this histogram indicates a **skewed
    normal distribution**.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 显而易见，这个直方图看起来与我们之前看到的不太一样。均值仍然是1公斤，但围绕均值的数值分布不再对称。我们称这个直方图显示出一个**偏态正态分布**。
- en: Skewness
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 偏度
- en: Skewness is the name for the asymmetry of a distribution about its mode. **Negative
    skew**, or **left skew**, indicates that the area under the graph is larger on
    the left side of the mode. **Positive skew**, or **right skew**, indicates that
    the area under the graph is larger on the right side of the mode.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 偏度是分布围绕其众数的不对称性的名称。**负偏态**或**左偏态**表明图形下众数左侧的面积较大。**正偏态**或**右偏态**表明图形下众数右侧的面积较大。
- en: '![Skewness](img/7180OS_01_180.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![偏度](img/7180OS_01_180.jpg)'
- en: 'Incanter has a built-in function for measuring skewness in the `stats` namespace:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: Incanter在`stats`命名空间中有一个内置函数用于测量偏度：
- en: '[PRE38]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The preceding example shows that the skewness of the dishonest baker's output
    is about 0.4, quantifying the skew evident in the histogram.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的示例显示，不诚实面包师输出的偏度约为 0.4，量化了在直方图中显示的偏斜。
- en: Quantile-quantile plots
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分位数-分位数图
- en: We encountered quantiles as a means of describing the distribution of data earlier
    in the chapter. Recall that the `quantile` function accepts a number between zero
    and one and returns the value of the sequence at that point. 0.5 corresponds to
    the median value.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章前面已经遇到过分位数，作为描述数据分布的一种方式。回想一下，`quantile` 函数接受介于零和一之间的数字，并返回该点的序列值。0.5 对应于中位数值。
- en: Plotting the quantiles of your data against the quantiles of the normal distribution
    allows us to see how our measured data compares against the theoretical distribution.
    Plots such as this are called **Q-Q plots** and they provide a quick and intuitive
    way of determining normality. For data corresponding closely to the normal distribution,
    the Q-Q Plot is a straight line. Deviations from a straight line indicate the
    manner in which the data deviates from the idealized normal distribution.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据的分位数与正态分布的分位数进行绘制，可以让我们看到测量数据与理论分布的比较。这种图形被称为**Q-Q 图**，它提供了一种快速且直观的方式来判断正态性。对于接近正态分布的数据，Q-Q
    图呈现直线。偏离直线的部分表明数据偏离理想化的正态分布的方式。
- en: 'Let''s plot Q-Q plots for both our honest and dishonest bakers side-by-side.
    Incanter''s `c/qq-plot` function accepts the list of data points and generates
    a scatter chart of the sample quantiles plotted against the quantiles from the
    theoretical normal distribution:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们并排绘制诚实和不诚实面包师的 Q-Q 图。Incanter 的 `c/qq-plot` 函数接受数据点列表，并生成一个样本分位数与理论正态分布的分位数绘制的散点图：
- en: '[PRE39]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The preceding code will produce the following plots:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将生成以下图表：
- en: '![Quantile-quantile plots](img/7180OS_01_190.jpg)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![分位数-分位数图](img/7180OS_01_190.jpg)'
- en: 'The Q-Q plot for the honest baker is shown earlier. The dishonest baker''s
    plot is next:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 诚实面包师的 Q-Q 图在前面已经展示。下面是指不诚实面包师的图：
- en: '![Quantile-quantile plots](img/7180OS_01_200.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![分位数-分位数图](img/7180OS_01_200.jpg)'
- en: 'The fact that the line is curved indicates that the data is positively skewed;
    a curve in the other direction would indicate negative skew. In fact, Q-Q plots
    make it easier to discern a wide variety of deviations from the standard normal
    distribution, as shown in the following diagram:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 线条弯曲表明数据是正偏的；反向弯曲则表明数据是负偏的。实际上，Q-Q 图使得我们更容易识别各种偏离标准正态分布的情况，如下图所示：
- en: '![Quantile-quantile plots](img/7180OS_01_210.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![分位数-分位数图](img/7180OS_01_210.jpg)'
- en: Q-Q plots compare the distribution of the honest and dishonest baker against
    the theoretical normal distribution. In the next section, we'll compare several
    alternative ways of visually comparing two (or more) measured sequences of values
    with each other.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: Q-Q 图比较了诚实与不诚实面包师的分布与理论正态分布的对比。在接下来的部分，我们将比较几种不同的方式来直观地比较两个（或更多）测量值序列。
- en: Comparative visualizations
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较可视化
- en: Q-Q plots provide a great way to compare a measured, empirical distribution
    to a theoretical normal distribution. If we'd like to compare two or more empirical
    distributions with each other, we can't use Incanter's Q-Q plot charts. We have
    a variety of other options, though, as shown in the next two sections.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: Q-Q 图提供了一种极好的方式，用来将测量得到的经验分布与理论正态分布进行比较。如果我们想要比较两个或多个经验分布之间的关系，我们不能使用 Incanter
    的 Q-Q 图表。不过，我们有其他多种选择，如接下来的两部分所示。
- en: Box plots
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 箱形图
- en: 'Box plots, or **box and whisker plots**, are a way to visualize the descriptive
    statistics of median and variance visually. We can generate them using the following
    code:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 箱形图，或称为**箱线图**，是一种可视化描述统计中的中位数和方差的方式。我们可以使用以下代码生成它们：
- en: '[PRE40]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This creates the following plot:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成以下图表：
- en: '![Box plots](img/7180OS_01_220.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![箱形图](img/7180OS_01_220.jpg)'
- en: The boxes in the center of the plot represent the **interquartile range**. The
    median is the line across the middle of the box, and the mean is the large black
    dot. For the honest baker, the median passes through the centre of the circle,
    indicating the mean and median are about the same. For the dishonest baker, the
    mean is offset from the median, indicating a skew.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 图中间的框表示**四分位数范围**。中位数是通过盒子中间的线，而均值则是大的黑点。对于诚实的面包师，中位数穿过圆形的中心，表明均值和中位数差不多。而对于不诚实的面包师，均值偏离中位数，表明存在偏斜。
- en: The whiskers indicate the range of the data and outliers are represented by
    hollow circles. In just one chart, we're more clearly able to see the difference
    between the two distributions than we were on either the histograms or the Q-Q
    plots independently.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 须根表示数据的范围，异常值用空心圆表示。在一个图表中，我们比在单独的直方图或 Q-Q 图上更清楚地看到了两个分布之间的差异。
- en: Cumulative distribution functions
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 累积分布函数
- en: Cumulative distribution functions, also known as **CDFs**, describe the probability
    that a value drawn from a distribution will have a value less than *x*. Like all
    probability distributions, they value between *0* and *1*, with *0* representing
    impossibility and *1* representing certainty. For example, imagine that I'm about
    to throw a six-sided die. What's the probability that I'll roll less than a six?
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 累积分布函数，也称为 **CDF**，描述了从一个分布中抽取的值小于 *x* 的概率。像所有概率分布一样，它们的值在 *0* 和 *1* 之间，*0*
    代表不可能，*1* 代表确定性。例如，假设我即将掷一个六面骰子。掷出小于六的概率是多少？
- en: For a fair die, the probability I'll row a five or lower is ![Cumulative distribution
    functions](img/7180OS_01_09.jpg). Conversely, the probability I'll roll a one
    is only ![Cumulative distribution functions](img/7180OS_01_10.jpg). Three or lower
    corresponds to even odds—a probability of 50 percent.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一颗公平的骰子，掷出 5 或更小的概率是 ![Cumulative distribution functions](img/7180OS_01_09.jpg)。相反，掷出
    1 的概率只有 ![Cumulative distribution functions](img/7180OS_01_10.jpg)。掷出 3 或更小的结果对应着平等的几率——50%
    的概率。
- en: The CDF of die rolls follows the same pattern as all CDFs—for numbers at the
    lower end of the range, the CDF is close to zero, corresponding to a low probability
    of selecting numbers in this range or below. At the high end of the range, the
    CDF is close to one, since most values drawn from the sequence will be lower.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 骰子掷出的 CDF 遵循与所有 CDF 相同的模式——对于数值范围较低的部分，CDF 接近零，表示选择该范围或以下的数字的概率较低。对于范围的高端，CDF
    接近一，因为大多数从序列中抽取的值会较小。
- en: Note
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The CDF and quantiles are closely related to each other—the CDF is the inverse
    of the quantile function. If the 0.5 quantile corresponds to a value of 1,000,
    then the CDF for 1,000 is 0.5.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: CDF 和分位数密切相关——CDF 是分位数函数的逆函数。如果 0.5 分位数对应的值是 1,000，那么 1,000 的 CDF 就是 0.5。
- en: Just as Incanter's `s/quantile` function allows us to sample values from a distribution
    at specific points, the `s/cdf-empirical` function allows us to input a value
    from the sequence and return a value between zero and one. It is a higher-order
    function—one that will accept the value (in this case, a sequence of values) and
    return a function. The returned function can then be called as often as necessary
    with different input values, returning the CDF for each of them.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 Incanter 的 `s/quantile` 函数允许我们在特定点从分布中采样值一样，`s/cdf-empirical` 函数允许我们输入一个来自序列的值，并返回一个介于零和一之间的值。它是一个高阶函数——接受值（在此情况下是一个值的序列）并返回一个函数。然后可以多次调用返回的函数，传入不同的输入值，从而返回它们各自的
    CDF。
- en: Note
  id: totrans-261
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Higher-order functions are functions that accept or return functions.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 高阶函数是接受或返回函数的函数。
- en: Let's plot the CDF of both the honest and dishonest bakers side by side. We
    can use Incanter's `c/xy-plot` for visualizing the CDF by plotting the source
    data—the samples from our honest and dishonest bakers—against the probabilities
    calculated against the empirical CDF. The `c/xy-plot` function expects the *x*
    values and the *y* values to be supplied as two separate sequences of values.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们并排绘制诚实和不诚实面包师的 CDF。我们可以使用 Incanter 的 `c/xy-plot` 来通过绘制源数据——来自诚实和不诚实面包师的样本——与针对经验
    CDF 计算出的概率，来可视化 CDF。`c/xy-plot` 函数期望 *x* 值和 *y* 值作为两个单独的值序列提供。
- en: 'To plot both distributions on the same chart, we need to be able to provide
    multiple series to our `xy-plot`. Incanter offers functions for many of its charts
    to add additional series. In the case of an `xy-plot`, we can use the function
    `c/add-lines`, which accepts the chart as the first argument, and the *x* series
    and the *y* series of data as the next two arguments respectively. You can also
    pass an optional series label. We do this in the following code so we can tell
    the two series apart on the finished chart:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在同一个图表上绘制这两个分布，我们需要能够为我们的 `xy-plot` 提供多个系列。Incanter 为其许多图表提供了添加附加系列的功能。对于
    `xy-plot`，我们可以使用函数 `c/add-lines`，它的第一个参数是图表，接下来的两个参数分别是 *x* 系列和 *y* 系列的数据。你还可以传递一个可选的系列标签。我们在以下代码中这么做，以便在最终的图表上区分这两个系列：
- en: '[PRE41]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The preceding code generates the following chart:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码生成了如下图表：
- en: '![Cumulative distribution functions](img/7180OS_01_230.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![累积分布函数](img/7180OS_01_230.jpg)'
- en: Although it looks very different, this chart shows essentially the same information
    as the box and whisker plot. We can see that the two lines cross at approximately
    the median of 0.5, corresponding to 1,000g. The dishonest line is truncated at
    the lower tail and longer on the upper tail, corresponding to a skewed distribution.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管看起来很不一样，这个图表实际上展示了与箱线图相同的信息。我们可以看到，两条线大约在0.5的中位数处交叉，对应于1,000克。那个不诚实的线在下尾处被截断，上尾则更长，表明其分布是偏斜的。
- en: The importance of visualizations
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可视化的重要性
- en: Simple visualizations like those earlier are succinct ways of conveying a large
    quantity of information. They complement the summary statistics we calculated
    earlier in the chapter, and it's important that we use them. Statistics such as
    the mean and standard deviation necessarily conceal a lot of information as they
    reduce a sequence down to just a single number.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 像前面那样的简单可视化是传达大量信息的简洁方式。它们补充了我们在本章前面计算的摘要统计量，使用它们非常重要。像均值和标准差这样的统计量不可避免地会隐藏大量信息，因为它们将一系列数据压缩为一个单一的数字。
- en: 'The statistician Francis Anscombe devised a collection of four scatter plots,
    known as **Anscombe''s Quartet**, that have nearly identical statistical properties
    (including the mean, variance, and standard deviation). In spite of this, it''s
    visually apparent that the distribution of *xs* and *ys* are all very different:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 统计学家弗朗西斯·安斯科姆（Francis Anscombe）设计了一组四个散点图，称为**安斯科姆四重奏**，它们具有几乎相同的统计特性（包括均值、方差和标准差）。尽管如此，*xs*和*ys*的分布在视觉上是截然不同的：
- en: '![The importance of visualizations](img/7180OS_01_240.jpg)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![可视化的重要性](img/7180OS_01_240.jpg)'
- en: 'Datasets don''t have to be contrived to reveal valuable insights when graphed.
    Take for example this histogram of the marks earned by candidates in Poland''s
    national Matura exam in 2013:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 数据集在绘制图表时不必经过人为设计就能揭示有价值的见解。以2013年波兰全国马图拉考试成绩的直方图为例：
- en: '![The importance of visualizations](img/7180OS_01_250.jpg)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![可视化的重要性](img/7180OS_01_250.jpg)'
- en: We might expect the abilities of students to be normally distributed and indeed—with
    the exception of a sharp spike around 30 percent —it is. What we can clearly see
    is the very human effect of examiners nudging student's grades over the pass mark.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能期望学生的能力呈正态分布，实际上——除了大约30%的急剧峰值——它确实是正态分布的。我们可以清楚地看到，考官人为地把学生的成绩推高，使其超过及格线。
- en: In fact, the distributions for sequences drawn from large samples can be so
    reliable that any deviation from them can be evidence of illegal activity. Benford's
    law, also called the first-digit law, is a curious feature of random numbers generated
    over a large range. One occurs as the leading digit about 30 percent of the time,
    while larger digits occur less and less frequently. For example, nine occurs as
    the leading digit less than 5 percent of the time.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，从大样本中提取的序列的分布可以如此可靠，以至于任何偏离它们的情况都可能是非法活动的证据。本福德定律，也叫做首位数字定律，是一种关于大范围随机数的奇特特性。数字1大约有30%的时间作为首位数字出现，而较大的数字则越来越少。比如，数字9作为首位数字的概率不到5%。
- en: Note
  id: totrans-277
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Benford's law is named after physicist Frank Benford who stated it in 1938 and
    showed its consistency across a wide variety of data sources. It had been previously
    observed by Simon Newcomb over 50 years earlier, who noticed that the pages of
    his books of logarithm tables were more battered for numbers beginning with the
    digit one.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 本福德定律以物理学家弗兰克·本福德（Frank Benford）的名字命名，他于1938年提出该定律，并展示了它在各种数据源中的一致性。早在50多年前，西蒙·纽科姆（Simon
    Newcomb）就曾注意到，本福德定律曾被他发现过，纽科姆观察到，他的对数表书页在数字以1开头的地方更为磨损。
- en: Benford showed that the law applied to data as diverse as electricity bills,
    street addresses, stock prices, population numbers, death rates, and lengths of
    rivers. The law is so consistent for data sets covering large ranges of values
    that deviation from it has been accepted as evidence in trials for financial fraud.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 本福德展示了该定律适用于各种各样的数据，例如电费账单、街道地址、股价、人口数据、死亡率以及河流的长度。这一定律在涵盖大范围数值的数据集中的一致性如此之高，以至于其偏离被接受作为金融欺诈审判中的证据。
- en: Visualizing electorate data
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可视化选民数据
- en: Let's return to the election data and compare the electorate sequence we created
    earlier against the theoretical normal distribution CDF. We can use Incanter's
    `s/cdf-normal` function to generate a normal CDF from a sequence of values. The
    default mean is 0 and standard deviation is 1, so we'll need to provide the measured
    mean and standard deviation from the electorate data. These values for our electorate
    data are 70,150 and 7,679, respectively.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到选举数据，并将我们之前创建的选民序列与理论正态分布的CDF进行比较。我们可以使用Incanter的`s/cdf-normal`函数根据值序列生成正态分布的CDF。默认均值为0，标准差为1，因此我们需要提供选民数据的测量均值和标准差。对于我们的选民数据，这些值分别为70,150和7,679。
- en: 'We generated an empirical CDF earlier in the chapter. The following example
    simply generates each of the two CDFs and plots them on a single `c/xy-plot`:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章前面，我们生成了一个经验性的CDF。以下示例仅生成了两个CDF，并将它们绘制在单个`c/xy-plot`上：
- en: '[PRE42]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The preceding example generates the following plot:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例生成了以下绘图：
- en: '![Visualizing electorate data](img/7180OS_01_260.jpg)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![可视化选民数据](img/7180OS_01_260.jpg)'
- en: You can see from the proximity of the two lines to each other how closely this
    data resembles normality, although a slight skew is evident. The skew is in the
    opposite direction to the dishonest baker CDF we plotted previously, so our electorate
    data is slightly skewed to the left.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 通过两条线的接近程度，您可以看出数据多么接近正态分布，尽管稍有偏斜。偏斜方向与我们之前绘制的不诚实面包师的CDF相反，因此我们的选民数据略微向左倾斜。
- en: 'As we''re comparing our distribution against the theoretical normal distribution,
    let''s use a Q-Q plot, which will do this by default:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们正在将我们的分布与理论正态分布进行比较，让我们使用Q-Q图，默认情况下将执行此操作：
- en: '[PRE43]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The following Q-Q plot does an even better job of highlighting the left skew
    evident in the data:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的Q-Q图更好地突显了数据中明显的左偏态：
- en: '![Visualizing electorate data](img/7180OS_01_270.jpg)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![可视化选民数据](img/7180OS_01_270.jpg)'
- en: As we expected, the curve bows in the opposite direction to the dishonest baker
    Q-Q plot earlier in the chapter. This indicates that there is a greater number
    of constituencies that are smaller than we would expect if the data were more
    closely normally distributed.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们预期的那样，曲线与本章早期不诚实的面包师Q-Q图相反。这表明，如果数据更接近正态分布，比我们预期的小选区数目更多。
- en: Adding columns
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加列
- en: So far this chapter, we've reduced the size of our dataset by filtering both
    rows and columns. Often we'll want to add rows to a dataset instead, and Incanter
    supports this in several ways.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本章中我们通过过滤行和列来减少数据集的大小。通常，我们会希望向数据集添加行，Incanter支持几种方式来实现这一点。
- en: Firstly, we can choose whether to replace an existing column within the dataset
    or append an additional column to the dataset. Secondly, we can choose whether
    to supply the new column values to replace the existing column values directly,
    or whether to calculate the new values by applying a function to each row of the
    data.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以选择是替换数据集中的现有列还是追加附加列到数据集。其次，我们可以选择是直接提供新列值以替换现有列值，还是通过对数据的每一行应用函数来计算新值。
- en: 'The following chart lists our options and the corresponding Incanter function
    to use:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 下图列出了我们的选项及相应的Incanter函数使用方法：
- en: '|   | Replace data | Append data |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
  zh: '|   | 替换数据 | 追加数据 |'
- en: '| --- | --- | --- |'
  id: totrans-297
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| By providing a sequence | `i/replace-column` | `i/add-column` |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
  zh: '| 通过提供序列 | `i/replace-column` | `i/add-column` |'
- en: '| By applying a function | `i/transform-column` | `i/add-derived-column` |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
  zh: '| 通过应用函数 | `i/transform-column` | `i/add-derived-column` |'
- en: When transforming or deriving a column based on a function, we pass the name
    of the new column to create, a function to apply for each row, and also a sequence
    of existing column names. The values contained in each of these existing columns
    will comprise the arguments to our function.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 当基于函数转换或派生列时，我们将传递新列的名称以创建，应用于每行的函数，以及现有列名称的序列。每个现有列中包含的值将构成函数的参数。
- en: Let's show how to use the `i/add-derived-column` function with reference to
    a real example. The 2010 UK general election resulted in a hung parliament with
    no single party commanding an overall majority. A coalition between the Conservative
    and Liberal Democrat parties was formed. In the next section we'll find out how
    many people voted for either party, and what percentage of the total vote this
    was.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个实际示例来展示如何使用 `i/add-derived-column` 函数。2010 年的英国大选结果是悬浮议会，没有任何政党获得绝对多数席位。保守党和自由民主党之间形成了联合政府。在下一节中，我们将找出每个党派的支持人数，并计算其在总投票中的比例。
- en: Adding derived columns
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加衍生列
- en: To find out what percentage of the electorate voted for either the Conservative
    or Liberal Democrat parties, we'll want to calculate the sum of votes for either
    party. Since we're creating a new field of data based on a function of the existing
    data, we'll want to use the `i/add-derived-column` function.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 要找出选民中投票支持保守党或自由民主党的比例，我们需要计算每个政党的得票总和。由于我们是基于现有数据创建一个新的数据字段，因此我们需要使用 `i/add-derived-column`
    函数。
- en: '[PRE44]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'If we run this now, however, an exception will be generated:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们现在运行这个操作，将会生成一个异常：
- en: '[PRE45]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Unfortunately Clojure is complaining that we''re trying to add a `java.lang.String`.
    Clearly either (or both) the `Con` or the `LD` columns contain string values,
    but which? We can use frequencies again to see the extent of the problem:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，Clojure 报告错误，指出我们试图添加一个 `java.lang.String` 类型的值。显然，`Con` 或 `LD` 列中某个（或两个）包含了字符串值，但到底是哪个呢？我们可以再次使用频率统计来查看问题的范围：
- en: '[PRE46]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Let''s use the `i/$where` function we encountered earlier in the chapter to
    inspect just these rows:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用本章早些时候提到的 `i/$where` 函数，仅查看这些数据行：
- en: '[PRE47]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This bit of exploration should be enough to convince us that the reason for
    these fields being blank is that candidates were not put forward in the corresponding
    constituencies. Should they be filtered out or assumed to be zero? This is an
    interesting question. Let's filter them out, since it wasn't even possible for
    voters to choose a Liberal Democrat or Conservative candidate in these constituencies.
    If instead we assumed a zero, we would artificially lower the mean number of people
    who—given the choice—voted for either of these parties.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分的探索应该足以让我们确信，这些字段为空的原因是没有在相应选区推出候选人。我们应该过滤掉这些数据，还是认为它们的值为零呢？这是一个有趣的问题。我们选择过滤掉这些数据，因为在这些选区内，选民根本无法选择自由民主党或保守党候选人。如果我们假定为零，将人为地降低那些本可以选择其中一个政党投票的选民的平均数。
- en: 'Now that we know how to filter the problematic rows, let''s add the derived
    columns for the victor and the victor''s share of the vote, along with election
    turnout. We filter the rows to show only those where both a Conservative and Liberal
    Democrat candidate were put forward:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何过滤掉有问题的行，接下来添加胜选者及其投票份额、选民投票率的衍生列。我们过滤数据行，仅显示那些有保守党和自由民主党候选人的行：
- en: '[PRE48]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'As a result, we now have three additional columns in our dataset: `:victors`,
    `:victors-share`, and `:turnout`. Let''s plot the victor''s share of the vote
    as a Q-Q plot to see how it compares against the theoretical normal distribution:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，我们的数据集中新增了三列：`:victors`、`:victors-share` 和 `:turnout`。接下来，让我们通过 Q-Q 图展示胜选者的投票份额，看看它与理论上的正态分布有何不同：
- en: '[PRE49]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The preceding code generates the following plot:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码生成了以下图表：
- en: '![Adding derived columns](img/7180OS_01_275.jpg)'
  id: totrans-317
  prefs: []
  type: TYPE_IMG
  zh: '![添加衍生列](img/7180OS_01_275.jpg)'
- en: Referring back to the diagram of various Q-Q plot shapes earlier in the chapter
    reveals that the victor's share of the vote has "light tails" compared to the
    normal distribution. This means that more of the data is closer to the mean than
    we might expect from truly normally distributed data.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾本章前面提到的各种 Q-Q 图形，结果显示胜选者的投票份额相比正态分布具有“轻尾”特性。这意味着更多的数据点集中在均值附近，超出了我们对真正正态分布数据的预期。
- en: Comparative visualizations of electorate data
  id: totrans-319
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选民数据的对比可视化
- en: Let's look now at a dataset from another general election, this time from Russia
    in 2011\. Russia is a much larger country, and its election data is much larger
    too. We'll be loading two large Excel files into the memory, which may exceed
    your default JVM heap size.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看另一个大选的数据集，这次是 2011 年的俄罗斯大选。俄罗斯是一个更大的国家，其选举数据也要大得多。我们将加载两个较大的 Excel 文件到内存中，这可能会超过默认的
    JVM 堆大小。
- en: To expand the amount of memory available to Incanter, we can adjust the JVM
    settings in the project's `profile.clj`. The a vector of configuration flags for
    the JVM can be provided with the key `:jvm-opts`. Here we're using Java's `Xmx`
    flag to increase the heap size to 1GB. This should be more than enough.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 为了扩展Incanter可用的内存，我们可以调整项目中`profile.clj`的JVM设置。可以通过`：jvm-opts`键提供一个JVM的配置标志向量。这里我们使用Java的`Xmx`标志将堆内存大小增加到1GB，这应该足够用了。
- en: '[PRE50]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Russia''s data is available in two data files. Fortunately the columns are
    the same in each, so they can be concatenated together end-to-end. Incanter''s
    function `i/conj-rows` exists for precisely this purpose:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 俄罗斯的数据存储在两个数据文件中。幸运的是，每个文件中的列名相同，因此它们可以按顺序连接在一起。Incanter的`i/conj-rows`函数正是为了这个目的而存在：
- en: '[PRE51]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: In the preceding code, we define a third implementation of the `load-data` multimethod
    to load and combine both Russia files.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们定义了`load-data`多重方法的第三个实现来加载并合并这两个俄罗斯文件。
- en: Note
  id: totrans-326
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In addition to `conj-rows`, Incanter-core also defines `conj-columns` that will
    merge the columns of datasets provided they have the same number of rows.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`conj-rows`，Incanter-core还定义了`conj-columns`，它将合并具有相同行数的数据集的列。
- en: 'Let''s see what the Russia data column names are:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看俄罗斯数据的列名是什么：
- en: '[PRE52]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The column names in the Russia dataset are very descriptive, but perhaps longer
    than we want to type out. Also, it would be convenient if columns that represent
    the same attributes as we've already seen in the UK election data (the victor's
    share and turnout for example) were labeled the same in both datasets. Let's rename
    them accordingly.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 俄罗斯数据集中的列名非常具有描述性，但可能比我们想要输入的更长。而且，如果与我们之前看到的英国选举数据中表示相同属性的列（例如，获胜者的份额和投票率）在两者中有相同的标签，那将更加方便。让我们相应地重命名它们。
- en: 'Along with a dataset, the `i/rename-cols` function expects to receive a map
    whose keys are the current column names with values corresponding to the desired
    new column name. If we combine this with the `i/add-derived-column` data we have
    already seen, we arrive at the following:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 与数据集一起，`i/rename-cols`函数期望接收一个映射，其中键是当前的列名，值对应所需的新列名。如果我们将其与之前看到的`i/add-derived-column`数据结合起来，我们得到如下结果：
- en: '[PRE53]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The `i/safe-div` function is identical to `/` but will protect against division
    by zero. Rather than raising an exception, it returns the value `Infinity`, which
    will be ignored by Incanter's statistical and charting functions.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '`i/safe-div`函数与`/`相同，但它能够防止除以零的情况。它不会抛出异常，而是返回`Infinity`，该值将在Incanter的统计和图表功能中被忽略。'
- en: Visualizing the Russian election data
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可视化俄罗斯选举数据
- en: 'We previously saw that a histogram of the UK election turnout was approximately
    normal (albeit with light tails). Now that we''ve loaded and transformed the Russian
    election data, let''s see how it compares:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前看到，英国选举投票率的直方图大致呈正态分布（尽管尾部较轻）。现在我们已经加载并转换了俄罗斯选举数据，让我们看看它的对比情况：
- en: '[PRE54]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The preceding example generates the following histogram:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的例子生成了以下的直方图：
- en: '![Visualizing the Russian election data](img/7180OS_01_320.jpg)'
  id: totrans-338
  prefs: []
  type: TYPE_IMG
  zh: '![可视化俄罗斯选举数据](img/7180OS_01_320.jpg)'
- en: This histogram doesn't look at all like the classic bell-shaped curves we've
    seen so far. There's a pronounced positive skew, and the voter turnout actually
    increases from 80 percent towards 100 percent—the opposite of what we would expect
    from normally-distributed data.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 这个直方图看起来根本不像我们之前看到的经典钟形曲线。它有明显的正偏态，选民的投票率实际上从80%增加到100%——这与我们对正态分布数据的预期正好相反。
- en: 'Given the expectations set by the UK data and by the central limit theorem,
    this is a curious result. Let''s visualize the data with a Q-Q plot instead:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 根据英国数据和中心极限定理所设定的预期，这是一个有趣的结果。让我们改用Q-Q图来可视化数据：
- en: '[PRE55]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'This returns the following plot:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回以下图表：
- en: '![Visualizing the Russian election data](img/7180OS_01_330.jpg)'
  id: totrans-343
  prefs: []
  type: TYPE_IMG
  zh: '![可视化俄罗斯选举数据](img/7180OS_01_330.jpg)'
- en: This Q-Q plot is neither a straight line nor a particularly S-shaped curve.
    In fact, the Q-Q plot suggests a light tail at the top end of the distribution
    and a heavy tail at the bottom. This is almost the opposite of what we see on
    the histogram, which clearly indicates an extremely heavy right tail.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 这个Q-Q图既不是一条直线，也不是特别S形的曲线。实际上，Q-Q图暗示了分布的上端有轻微的尾部，而下端则有较重的尾部。这几乎与我们在直方图中看到的情况相反，后者明显表明右尾极重。
- en: 'In fact, it''s precisely because the tail is so heavy that the Q-Q plot is
    misleading: the density of points between 0.5 and 1.0 on the histogram suggests
    that the peak should be around 0.7 with a right tail continuing beyond 1.0\. It''s
    clearly illogical that we would have a percentage exceeding 100 percent but the
    Q-Q plot doesn''t account for this (it doesn''t know we''re plotting percentages),
    so the sudden absence of data beyond 1.0 is interpreted as a clipped right tail.'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，正是因为尾部如此沉重，Q-Q图才会产生误导：直方图上0.5到1.0之间的点密度暗示峰值应在0.7左右，右尾则延续到1.0以外。显然，百分比超过100%是没有逻辑的，但Q-Q图没有考虑到这一点（它并不知道我们在绘制百分比），因此1.0以上数据的突然缺失被解释为被截断的右尾。
- en: Given the central limit theorem, and what we've observed with the UK election
    data, the tendency towards 100 percent voter turnout is curious. Let's compare
    the UK and Russia datasets side-by-side.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于中心极限定理以及我们在英国选举数据中观察到的情况，100%的选民投票率这一趋势颇为引人注目。让我们将英国和俄罗斯的数据集并排比较。
- en: Comparative visualizations
  id: totrans-347
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较可视化
- en: Let's suppose we'd like to compare the distributions of electorate data between
    the UK and Russia. We've already seen in this chapter how to make use of CDFs
    and box plots, so let's investigate an alternative that's similar to a histogram.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想比较英国和俄罗斯选民数据的分布。我们已经在本章中学习了如何使用CDF和箱线图，所以让我们来研究一种类似于直方图的替代方法。
- en: 'We could try and plot both datasets on a histogram but this would be a bad
    idea. We wouldn''t be able to interpret the results for two reasons:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以尝试在直方图上绘制这两个数据集，但这不是一个好主意。我们无法解释结果，原因有二：
- en: The sizes of the voting districts, and therefore the means of the distributions,
    are very different
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 投票区的大小，以及因此而导致的分布均值，差异非常大。
- en: The number of voting districts overall is so different, so the histograms bars
    will have different heights
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 投票区的数量差异如此之大，因此直方图的条形高度会不同
- en: An alternative to the histogram that addresses both of these issues is the **probability
    mass function** (**PMF**).
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 解决上述问题的一个替代方法是**概率质量函数**（**PMF**）。
- en: Probability mass functions
  id: totrans-353
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概率质量函数
- en: The probability mass function, or PMF, has a lot in common with a histogram.
    Instead of plotting the counts of values falling into bins, though, it instead
    plots the probability that a number drawn from a distribution will be exactly
    equal to a given value. As the function assigns a probability to every value that
    can possibly be returned by the distribution, and because probabilities are measured
    on a scale from zero to one, (with one corresponding to certainty), the area under
    the probability mass function is equal to one.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 概率质量函数（PMF）与直方图有很多相似之处。不过，它不是绘制落入区间的数值计数，而是绘制从分布中抽取的数字恰好等于某一给定值的概率。由于该函数为分布中所有可能返回的值分配了概率，而且概率是在零到一的范围内度量的（其中一对应确定性），因此概率质量函数下的面积等于一。
- en: Thus, the PMF ensures that the area under our plots will be comparable between
    datasets. However, we still have the issue that the sizes of the voting districts—and
    therefore the means of the distributions—can't be compared. This can be addressed
    by a separate technique—normalization.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，PMF确保了我们绘制的图形下的面积在不同数据集之间是可比较的。然而，我们仍然面临投票区大小——因此分布的均值——无法直接比较的问题。这可以通过一个独立的技术——规范化来解决。
- en: Note
  id: totrans-356
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Normalizing the data isn't related to the normal distribution. It's the name
    given to the general task of bringing one or more sequences of values into alignment.
    Depending on the context, it could mean simply adjusting the values so they fall
    within the same range, or more sophisticated procedures to ensure that the distributions
    of data are the same. In general, the goal of normalization is to facilitate the
    comparison of two or more series of data.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 数据规范化与正态分布无关。它是一个通用任务，用来将一个或多个数值序列对齐。根据具体情况，它可以仅仅意味着调整值使其落在相同的范围内，或者采取更复杂的程序来确保数据分布一致。通常，规范化的目的是为了便于比较两组或更多组数据。
- en: 'There are innumerable ways to normalize data, but one of the most basic is
    to ensure that each series is in the range zero to one. None of our values decrease
    below zero, so we can accomplish this normalization by simply dividing by the
    largest value:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 规范化数据的方法有无数种，但最基本的一种是确保每个系列的数值都在零到一之间。我们所有的值都不会低于零，因此我们可以通过简单地除以最大值来实现这种规范化：
- en: '[PRE56]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'With the preceding function in place, we can normalize both the UK and Russia
    data and plot it side by side on the same axes:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上述函数，我们可以将英国和俄罗斯的数据进行归一化，并将它们并排绘制在相同的坐标轴上：
- en: '[PRE57]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The preceding example generates the following chart:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 上述例子生成了以下图表：
- en: '![Probability mass functions](img/7180OS_01_340.jpg)'
  id: totrans-363
  prefs: []
  type: TYPE_IMG
  zh: '![概率质量函数](img/7180OS_01_340.jpg)'
- en: After normalization, the two distributions can be compared more readily. It's
    clearly apparent how—in spite of having a lower mean turnout than the UK—the Russia
    election had a massive uplift towards 100-percent turnout. Insofar as it represents
    the combined effect of many independent choices, we would expect election results
    to conform to the central limit theorem and be approximately normally distributed.
    In fact, election results from around the world generally conform to this expectation.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 经过归一化处理后，这两个分布可以更方便地进行比较。显然，尽管俄罗斯的投票率均值低于英国，但俄罗斯选举的投票率在接近100%的地方出现了大幅跃升。由于选举结果代表了许多独立选择的综合效应，我们预计选举结果会符合中心极限定理，呈大致正态分布。实际上，全球范围内的选举结果通常都符合这一预期。
- en: Although not quite as high as the modal peak in the center of the distribution—corresponding
    to approximately 50 percent turnout—the Russian election data presents a very
    anomalous result. Researcher Peter Klimek and his colleagues at the Medical University
    of Vienna have gone as far as to suggest that this is a clear signature of ballot-rigging.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管并不像分布中心的模态峰值那样高——对应大约50%的投票率——但俄罗斯选举数据呈现出一个非常反常的结果。维也纳医科大学的研究员彼得·克里梅克及其同事甚至建议这明显是选票操控的标志。
- en: Scatter plots
  id: totrans-366
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 散点图
- en: We've observed the curious results for the turnout at the Russian election and
    identified that it has a different signature from the UK election. Next, let's
    see how the proportion of votes for the winning candidate is related to the turnout.
    After all, if the unexpectedly high turnout really is a sign of foul play by the
    incumbent government, we'd anticipate that they'll be voting for themselves rather
    than anyone else. Thus we'd expect most, if not all, of these additional votes
    to be for the ultimate election winners.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经观察到俄罗斯选举投票率的奇异结果，并且确认它与英国选举的签名不同。接下来，让我们看看获胜候选人的选票比例与投票率之间的关系。毕竟，如果出乎意料的高投票率真的是现任政府操纵选举的信号，那么我们预计他们会为自己投票，而不是为其他候选人投票。因此，我们预计大多数（如果不是全部的话）额外的选票将投给最终的选举获胜者。
- en: '[Chapter 3](ch03.xhtml "Chapter 3. Correlation"), *Correlation*, will cover
    the statistics behind correlating two variables in much more detail, but for now
    it would be interesting simply to visualize the relationship between turnout and
    the proportion of votes for the winning party.'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '[第3章](ch03.xhtml "第3章：相关性")，*相关性*，将更详细地讨论相关两个变量的统计学原理，但现在，仅仅可视化投票率与获胜党派选票比例之间的关系就已经很有趣了。'
- en: 'The final visualization we''ll introduce this chapter is the scatter plot.
    Scatter plots are very useful for visualizing correlations between two variables:
    where a linear correlation exists, it will be evident as a diagonal tendency in
    the scatter plot. Incanter contains the `c/scatter-plot` function for this kind
    of chart with arguments the same as for the `c/xy-plot` function.'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将介绍的最后一个可视化图表是散点图。散点图非常适合用来可视化两个变量之间的相关性：如果存在线性相关性，它将在散点图中表现为对角线趋势。Incanter包含了`c/scatter-plot`函数用于这种类型的图表，参数与`c/xy-plot`函数相同。
- en: '[PRE58]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The preceding code generates the following chart:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码生成了以下图表：
- en: '![Scatter plots](img/7180OS_01_350.jpg)'
  id: totrans-372
  prefs: []
  type: TYPE_IMG
  zh: '![散点图](img/7180OS_01_350.jpg)'
- en: 'Although the points are arranged broadly in a fuzzy ellipse, a diagonal tendency
    towards the top right of the scatter plot is clearly apparent. This indicates
    an interesting result—turnout is correlated with the proportion of votes for the
    ultimate election winners. We might have expected the reverse: voter complacency
    leading to a lower turnout where there was a clear victor in the running.'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这些点大致呈现为一个模糊的椭圆形，但在散点图中，明显存在向右上方的对角线趋势。这表明了一个有趣的结果——投票率与最终选举获胜者的选票比例之间存在关联。我们本可能预期到相反的结果：选民自满导致投票率降低，而在有明确胜者的情况下尤为如此。
- en: Note
  id: totrans-374
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As mentioned earlier, the UK election of 2010 was far from ordinary, resulting
    in a hung parliament and a coalition government. In fact, the "winners" in this
    case represent two parties who had, up until election day, been opponents. A vote
    for either counts as a vote for the winners.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，2010年英国大选远非普通选举，结果是悬浮议会和联合政府。事实上，所谓的“赢家”是指两党，这两党直到选举日之前一直是对手。选任何一方的票都算作是投给赢家的票。
- en: 'Next, we''ll create the same scatter plot for the Russia election:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将为俄罗斯选举创建相同的散点图：
- en: '[PRE59]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'This generates the following plot:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成以下图表：
- en: '![Scatter plots](img/7180OS_01_360.jpg)'
  id: totrans-379
  prefs: []
  type: TYPE_IMG
  zh: '![散点图](img/7180OS_01_360.jpg)'
- en: Although a diagonal tendency in the Russia data is clearly evident from the
    outline of the points, the sheer volume of data obscures the internal structure.
    In the last section of this chapter, we'll show a simple technique for extracting
    structure from a chart such as the earlier one using opacity.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管俄罗斯数据中的对角趋势从点的轮廓中清晰可见，但大量数据掩盖了其内部结构。在本章的最后一部分，我们将展示一种简单的技术，利用透明度从这样的图表中提取结构。
- en: Scatter transparency
  id: totrans-381
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 散点透明度
- en: In situations such as the preceding one where a scatter plot is overwhelmed
    by the volume of points, transparency can help to visualize the structure of the
    data. Since translucent points that overlap will be more opaque, and areas with
    fewer points will be more transparent, a scatter plot with semi-transparent points
    can show the density of the data much better than solid points can.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的情境中，当散点图被大量数据点淹没时，透明度可以帮助更好地可视化数据的结构。由于重叠的半透明点会变得更不透明，而点较少的区域会更透明，使用半透明点的散点图比使用实心点更能有效显示数据的密度。
- en: 'We can set the alpha transparency of points plotted on an Incanter chart with
    the `c/set-alpha` function. It accepts two arguments: the chart and a number between
    zero and one. One signifies fully opaque and zero fully transparent.'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`c/set-alpha`函数设置Incanter图表上绘制点的alpha透明度。它接受两个参数：一个图表和一个介于零到一之间的数字。1表示完全不透明，0表示完全透明。
- en: '[PRE60]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The preceding example generates the following chart:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子生成了以下图表：
- en: '![Scatter transparency](img/7180OS_01_370.jpg)'
  id: totrans-386
  prefs: []
  type: TYPE_IMG
  zh: '![散点透明度](img/7180OS_01_370.jpg)'
- en: The preceding scatter plot shows the general tendency of the victor's share
    and the turnout to vary together. We can see a correlation between the two values,
    and a "hot spot" in the top right corner of the chart corresponding to close to
    100-percent turnout and 100-percent votes for the winning party. This in particular
    is the sign that the researchers at the Medial University of Vienna have highlighted
    as being the signature of electoral fraud. It's evident in the results of other
    disputed elections around the world, such as those of the 2011 Ugandan presidential
    election, too.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的散点图展示了胜者的份额与选民投票率之间通常同时变化的趋势。我们可以看到这两个值之间存在一定的相关性，并且在图表的右上角有一个“热点”，它对应着接近100%的选民投票率和赢得选举的党派几乎拿到100%的选票。特别是，这正是维也纳医科大学的研究人员所指出的选举舞弊的标志。这一点在世界其他地方的有争议选举结果中也十分明显，比如2011年乌干达总统选举的结果。
- en: Tip
  id: totrans-388
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The district-level results for many other elections around the world are available
    at [http://www.complex-systems.meduniwien.ac.at/elections/election.html](http://www.complex-systems.meduniwien.ac.at/elections/election.html).
    Visit the site for links to the research paper and to download other datasets
    on which to practice what you've learned in this chapter about scrubbing and transforming
    real data.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 世界其他地方许多选举的地区级结果可以在[http://www.complex-systems.meduniwien.ac.at/elections/election.html](http://www.complex-systems.meduniwien.ac.at/elections/election.html)上查看。访问该网站可以获取研究论文的链接，并下载其他数据集，帮助你实践本章关于清理和转换真实数据的知识。
- en: We'll cover correlation in more detail in [Chapter 3](ch03.xhtml "Chapter 3. Correlation"),
    *Correlation*, when we'll learn how to quantify the strength of the relationship
    between two values and build a predictive model based on it. We'll also revisit
    this data in [Chapter 10](ch10.xhtml "Chapter 10. Visualization"), *Visualization*
    when we implement a custom two-dimensional histogram to visualize the relationship
    between turnout and the winner's proportion of the vote even more clearly.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第3章](ch03.xhtml "第3章. 相关性")中更详细地讲解相关性，*相关性*，届时我们将学习如何量化两个值之间关系的强度，并基于此建立预测模型。我们还将在[第10章](ch10.xhtml
    "第10章. 可视化")，*可视化*中回顾这些数据，当时我们将实现一个自定义的二维直方图，以更清晰地可视化选民投票率与获胜党派选票比例之间的关系。
- en: Summary
  id: totrans-391
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this first chapter, we've learned about summary statistics and the value
    of distributions. We've seen how even a simple analysis can provide evidence of
    potentially fraudulent activity.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了总结性统计和分布的价值。我们已经看到，即使是简单的分析，也能提供潜在欺诈活动的证据。
- en: In particular, we've encountered the central limit theorem and seen why it goes
    such a long way towards explaining the ubiquity of the normal distribution throughout
    data science. An appropriate distribution can represent the essence of a large
    sequence of numbers in just a few statistics and we've implemented several of
    them using pure Clojure functions in this chapter. We've also introduced the Incanter
    library and used it to load, transform, and visually compare several datasets.
    We haven't been able to do much more than note a curious difference between two
    distributions, however.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其是，我们遇到了中心极限定理，并理解了它为何如此有助于解释正态分布在数据科学中的普遍性。一个合适的分布可以用少数几个统计量来代表一大串数字的本质，我们在本章中已经使用纯Clojure函数实现了其中的几个。我们还介绍了Incanter库，并用它加载、转换和可视化地比较了几个数据集。然而，我们并未做更多的工作，只能注意到两个分布之间一个有趣的差异。
- en: In the next chapter, we'll extend what we've learned about descriptive statistics
    to cover inferential statistics. These will allow us to quantify a measured difference
    between two or more distributions and decide whether a difference is statistically
    significant. We'll also learn about hypothesis testing—a framework for conducting
    robust experiments that allow us to draw conclusions from data.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将扩展关于描述性统计的知识，涵盖推断统计。这将使我们能够量化两个或更多分布之间的测量差异，并判断这种差异是否具有统计显著性。我们还将学习假设检验——一种进行稳健实验的框架，使我们能够从数据中得出结论。
