- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Overview of Algorithms
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 算法概述
- en: An algorithm must be seen to be believed.
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 必须亲眼看到算法，才能相信它。
- en: ''
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: – Donald Knuth
  id: totrans-4
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: – 唐纳德·克努斯
- en: This book covers the information needed to understand, classify, select, and
    implement important algorithms. In addition to explaining their logic, this book
    also discusses data structures, development environments, and production environments
    that are suitable for different classes of algorithms. This is the second edition
    of this book. In this edition, we especially focus on modern machine learning
    algorithms that are becoming more and more important. Along with the logic, practical
    examples of the use of algorithms to solve actual everyday problems are also presented.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本书涵盖了理解、分类、选择和实现重要算法所需的信息。除了讲解算法的逻辑，本书还讨论了适用于不同类别算法的数据结构、开发环境和生产环境。这是本书的第二版，在这一版中，我们特别关注日益重要的现代机器学习算法。除了逻辑部分，本书还展示了使用算法解决实际日常问题的实际例子。
- en: This chapter provides an insight into the fundamentals of algorithms. It starts
    with a section on the basic concepts needed to understand the workings of different
    algorithms. To provide a historical perspective, this section summarizes how people
    started using algorithms to mathematically formulate a certain class of problems.
    It also mentions the limitations of different algorithms. The next section explains
    the various ways to specify the logic of an algorithm. As Python is used in this
    book to write the algorithms, how to set up a Python environment to run the examples
    is explained. Then, the various ways that an algorithm’s performance can be quantified
    and compared against other algorithms are discussed. Finally, this chapter discusses
    various ways a particular implementation of an algorithm can be validated.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章为算法的基础提供了深入的理解。首先介绍了理解不同算法工作原理所需的基本概念。为了提供历史视角，本节总结了人们如何开始使用算法来数学化某类问题。还提到了不同算法的局限性。接下来的部分解释了指定算法逻辑的各种方法。由于本书使用
    Python 编写算法，因此解释了如何设置 Python 环境以运行示例。然后，讨论了如何量化和比较算法的性能与其他算法的不同方法。最后，本章讨论了验证算法特定实现的各种方式。
- en: 'To sum up, this chapter covers the following main points:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，本章涵盖了以下主要内容：
- en: What is an algorithm?
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是算法？
- en: The phases of an algorithm
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 算法的各个阶段
- en: Development environment
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发环境
- en: Algorithm design techniques
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 算法设计技巧
- en: Performance analysis
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能分析
- en: Validating an algorithm
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证算法
- en: What is an algorithm?
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是算法？
- en: 'In the simplest terms, an algorithm is a set of rules for carrying out some
    calculations to solve a problem. It is designed to yield results for any valid
    input according to precisely defined instructions. If you look up the word algorithm
    in a dictionary (such as American Heritage), it defines the concept as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 从最简单的角度看，算法是一组规则，用于执行某些计算以解决问题。它被设计为根据精确定义的指令，对任何有效的输入产生结果。如果你查阅字典（例如《美国传统词典》），它是这样定义算法的：
- en: An algorithm is a finite set of unambiguous instructions that, given some set
    of initial conditions, can be performed in a prescribed sequence to achieve a
    certain goal and that has a recognizable set of end conditions.
  id: totrans-16
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 算法是一组有限的、不含歧义的指令，在给定一组初始条件下，按照规定的顺序执行，以实现特定目标，并且具有可识别的结束条件。
- en: Designing an algorithm is an effort to create a mathematical recipe in the most
    efficient way that can effectively be used to solve a real-world problem. This
    recipe may be used as the basis for developing a more reusable and generic mathematical
    solution that can be applied to a wider set of similar problems.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 设计一个算法是努力以最有效的方式创建一个数学公式，能够有效地用于解决现实世界的问题。这个公式可以作为开发更具可重用性和通用性的数学解决方案的基础，应用于更广泛的类似问题。
- en: The phases of an algorithm
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 算法的各个阶段
- en: 'The different phases of developing, deploying, and finally, using an algorithm
    are illustrated in *Figure 1.1*:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 开发、部署并最终使用算法的不同阶段如*图 1.1*所示：
- en: '![Diagram, schematic  Description automatically generated](img/B18046_01_01.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图表，示意图 自动生成的描述](img/B18046_01_01.png)'
- en: 'Figure 1.1: The different phases of developing, deploying, and using an algorithm'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1：开发、部署和使用算法的不同阶段
- en: As we can see, the process starts with understanding the requirements from the
    problem statement that details what needs to be done. Once the problem is clearly
    stated, it leads us to the development phase.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，过程始于理解问题陈述中的需求，明确了需要做什么。一旦问题被清晰地陈述出来，就会引导我们进入开发阶段。
- en: 'The development phase consists of two phases:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 开发阶段包括两个阶段：
- en: '**The design phase**: In the design phase, the architecture, logic, and implementation
    details of the algorithm are envisioned and documented. While designing an algorithm,
    we keep both accuracy and performance in mind. While searching for the best solution
    to a given problem, in many cases, we will end up having more than one candidate
    algorithm. The design phase of an algorithm is an iterative process that involves
    comparing different candidate algorithms. Some algorithms may provide simple and
    fast solutions but may compromise accuracy. Other algorithms may be very accurate
    but may take considerable time to run due to their complexity. Some of these complex
    algorithms may be more efficient than others. Before making a choice, all the
    inherent tradeoffs of the candidate algorithms should be carefully studied. Particularly
    for a complex problem, designing an efficient algorithm is important. A correctly
    designed algorithm will result in an efficient solution that will be capable of
    providing both satisfactory performance and reasonable accuracy at the same time.'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**设计阶段**：在设计阶段，算法的架构、逻辑和实现细节被构思并记录下来。在设计算法时，我们始终考虑准确性和性能。在寻找给定问题的最佳解决方案时，通常会有多个候选算法可供选择。算法的设计阶段是一个迭代过程，涉及比较不同的候选算法。有些算法可能提供简单且快速的解决方案，但可能会牺牲准确性。其他算法可能非常准确，但由于其复杂性，运行时可能需要相当长的时间。一些复杂的算法可能比其他算法更高效。在做出选择之前，应该仔细研究所有候选算法的固有权衡。特别是对于复杂问题，设计一个高效的算法非常重要。正确设计的算法将提供一个高效的解决方案，能够同时提供令人满意的性能和合理的准确性。'
- en: '**The coding phase**: In the coding phase, the designed algorithm is converted
    into a computer program. It is important that the computer program implements
    all the logic and architecture suggested in the design phase.'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**编码阶段**：在编码阶段，设计好的算法被转换为计算机程序。计算机程序实现设计阶段提出的所有逻辑和架构是至关重要的。'
- en: The requirements of the business problem can be divided into functional and
    non-functional requirements. The requirements that directly specify the expected
    features of the solutions are called the functional requirements. Functional requirements
    detail the expected behavior of the solution. On the other hand, the non-functional
    requirements are about the performance, scalability, usability, and accuracy of
    the algorithm. Non-functional requirements also establish the expectations about
    the security of the data. For example, let us consider that we are required to
    design an algorithm for a credit card company that can identify and flag fraudulent
    transactions. Function requirements in this example will specify the expected
    behavior of a valid solution by providing the details of the expected output given
    a certain set of input data. In this case, the input data may be the details of
    the transaction, and the output may be a binary flag that labels a transaction
    as fraudulent or non-fraudulent. In this example, the non-functional requirements
    may specify the response time of each of the predictions. Non-functional requirements
    will also set the allowable thresholds for accuracy. As we are dealing with financial
    data in this example, the security requirements related to user authentication,
    authorization, and data confidentiality are also expected to be part of non-functional
    requirements.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 商业问题的需求可以分为功能性需求和非功能性需求。直接指定解决方案预期特征的需求称为功能性需求。功能性需求详细说明了解决方案的预期行为。另一方面，非功能性需求关注算法的性能、可扩展性、可用性和准确性。非功能性需求还规定了数据安全性的期望。例如，假设我们需要为一家信用卡公司设计一个可以识别并标记欺诈交易的算法。这个例子中的功能性需求将通过提供给定一组输入数据的预期输出的详细信息，来指定有效解决方案的预期行为。在这种情况下，输入数据可能是交易的详细信息，而输出可能是一个二进制标志，用来标记交易是欺诈的还是非欺诈的。在这个例子中，非功能性需求可能会指定每个预测的响应时间。非功能性需求还会设置准确度的容许阈值。由于我们在这个例子中处理的是金融数据，因此与用户身份验证、授权和数据保密相关的安全需求也应该是非功能性需求的一部分。
- en: Note that functional and non-functional requirements aim to precisely define
    *what* needs to be done. Designing the solution is about figuring out *how* it
    will be done. And implementing the design is developing the actual solution in
    the programming language of your choice. Coming up with a design that fully meets
    both functional and non-functional requirements may take lots of time and effort.
    The choice of the right programming language and development/production environment
    may depend on the requirements of the problem. For example, as C/C++ is a lower-level
    language than Python, it may be a better choice for algorithms needing compiled
    code and lower-level optimization.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，功能性和非功能性需求的目标是精确定义*需要做什么*。设计解决方案是关于弄清楚*如何做*。实现设计是使用您选择的编程语言开发实际解决方案。设计一个完全满足功能性和非功能性需求的解决方案可能需要大量时间和精力。选择合适的编程语言和开发/生产环境可能取决于问题的需求。例如，由于
    C/C++ 是比 Python 更低级的语言，因此对于需要编译代码和低级优化的算法，它可能是更好的选择。
- en: Once the design phase is completed and the coding is complete, the algorithm
    is ready to be deployed. Deploying an algorithm involves the design of the actual
    production environment in which the code will run. The production environment
    needs to be designed according to the data and processing needs of the algorithm.
    For example, for parallelizable algorithms, a cluster with an appropriate number
    of computer nodes will be needed for the efficient execution of the algorithm.
    For data-intensive algorithms, a data ingress pipeline and the strategy to cache
    and store data may need to be designed. Designing a production environment is
    discussed in more detail in *Chapter 15*, *Large-Scale Algorithms*, and *Chapter
    16*, *Practical Considerations*.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设计阶段完成且编码完成，算法就可以部署了。部署算法涉及设计实际的生产环境，其中代码将运行。生产环境的设计需要根据算法的数据和处理需求来进行。例如，对于可并行化的算法，需要一个适当数量计算节点的集群，以便高效执行算法。对于数据密集型算法，可能需要设计数据输入管道，以及缓存和存储数据的策略。生产环境的设计将在*第15章*《大规模算法》和*第16章*《实际考虑事项》中详细讨论。
- en: Once the production environment is designed and implemented, the algorithm is
    deployed, which takes the input data, processes it, and generates the output as
    per the requirements.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦生产环境设计并实施完毕，算法就可以部署，算法将根据要求处理输入数据并生成输出。
- en: Development environment
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开发环境
- en: Once designed, algorithms need to be implemented in a programming language as
    per the design. For this book, we have chosen the programming language Python.
    We chose it because Python is flexible and is an open-source programming language.
    Python is also one of the languages that you can use in various cloud computing
    infrastructures, such as **Amazon Web Services** (**AWS**), Microsoft Azure, and
    **Google Cloud Platform** (**GCP**).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设计完成，算法需要根据设计在编程语言中实现。对于本书，我们选择了 Python 作为编程语言。我们之所以选择它，是因为 Python 灵活且是开源编程语言。Python
    也是您可以在各种云计算基础设施中使用的语言之一，如**Amazon Web Services**（**AWS**）、Microsoft Azure 和 **Google
    Cloud Platform**（**GCP**）。
- en: The official Python home page is available at [https://www.python.org/](https://www.python.org/),
    which also has instructions for installation and a useful beginner’s guide.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 官方 Python 首页可以通过[https://www.python.org/](https://www.python.org/)访问，页面上还有安装说明和有用的初学者指南。
- en: A basic understanding of Python is required to better understand the concepts
    presented in this book.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解本书中呈现的概念，您需要具备基本的 Python 知识。
- en: For this book, we expect you to use the most recent version of Python 3\. At
    the time of writing, the most recent version is 3.10, which is what we will use
    to run the exercises in this book.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本书，我们建议使用最新版本的 Python 3。写作时，最新版本是 3.10，我们将使用这个版本来运行本书中的练习。
- en: We will be using Python throughout this book. We will also be using Jupyter
    Notebook to run the code. The rest of the chapters in this book assume that Python
    is installed and Jupyter Notebook has been properly configured and is running.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中我们将始终使用 Python。我们还将使用 Jupyter Notebook 来运行代码。本书的其余章节假设已安装 Python，并且 Jupyter
    Notebook 已正确配置并正在运行。
- en: Python packages
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python 包
- en: 'Python is a general-purpose language. It follows the philosophy of “batteries
    included,” which means that there is a standard library that is available, without
    making the user download separate packages. However, the standard library modules
    only provide the bare minimum functionality. Based on the specific use case you
    are working on, additional packages may need to be installed. The official third-party
    repository for Python packages is called PyPI, which stands for **Python Package
    Index**. It hosts Python packages both as source distribution and pre-compiled
    code. Currently, there are more than 113,000 Python packages hosted at PyPI. The
    easiest way to install additional packages is through the `pip` package management
    system. `pip` is a nerdy recursive acronym, which are abundant in Python culture.
    `pip` stands for **Pip Installs Python**. The good news is that starting from
    version 3.4 of Python, `pip` is installed by default. To check the version of
    `pip`, you can type on the command line:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Python 是一种通用编程语言。它遵循“自带电池”（batteries included）的理念，这意味着有一个标准库可供使用，而无需用户下载单独的包。然而，标准库模块仅提供最低限度的功能。根据您正在处理的特定用例，可能需要安装额外的包。Python
    包的官方第三方库称为 PyPI，代表 **Python 包索引**。它以源代码分发和预编译代码的形式托管 Python 包。目前，PyPI 上托管了超过 113,000
    个 Python 包。安装额外包最简单的方式是通过 `pip` 包管理系统。`pip` 是一个典型的递归首字母缩略词，Python 文化中充斥着这样的词汇。`pip`
    代表 **Pip Installs Python**。好消息是，从 Python 3.4 版本开始，`pip` 默认已安装。要检查 `pip` 的版本，可以在命令行输入：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This `pip` command can be used to install additional packages:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `pip` 命令可用于安装额外的包：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The packages that have already been installed need to be periodically updated
    to get the latest functionality. This is achieved by using the `upgrade` flag:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 已安装的包需要定期更新，以获得最新的功能。这可以通过使用 `upgrade` 标志来实现：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'And to install a specific version of a Python package:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 并且可以安装特定版本的 Python 包：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Adding the right libraries and versions has become part of setting up the Python
    programming environment. One feature that helps with maintaining these libraries
    is the ability to create a requirements file that lists all the packages that
    are needed. The requirements file is a simple text file that contains the name
    of the libraries and their associated versions. A sample of the requirements file
    looks as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 添加正确的库和版本已成为设置 Python 编程环境的一部分。帮助维护这些库的一个功能是能够创建一个列出所有所需包的 requirements 文件。requirements
    文件是一个简单的文本文件，包含库的名称及其相关版本。requirements 文件的示例如下所示：
- en: '`scikit-learn==0.24.1`'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`scikit-learn==0.24.1`'
- en: '`tensorflow==2.5.0`'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`tensorflow==2.5.0`'
- en: '`tensorboard==2.5.0`'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`tensorboard==2.5.0`'
- en: By convention, the `requirements.txt` is placed in the project’s top-level directory.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 按惯例，`requirements.txt` 文件放置在项目的顶层目录中。
- en: 'Once created, the requirements file can be used to set up the development environment
    by installing all the Python libraries and their associated versions by using
    the following command:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 创建后，可以使用以下命令通过安装所有 Python 库及其相关版本来设置开发环境：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now let us look into the main packages that we will be using in this book.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看本书中将使用的主要包。
- en: The SciPy ecosystem
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SciPy 生态系统
- en: '**Scientific Python** (**SciPy**)—pronounced sigh pie—is a group of Python
    packages created for the scientific community. It contains many functions, including
    a wide range of random number generators, linear algebra routines, and optimizers.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**科学 Python**（**SciPy**）——发音为 sigh pie——是为科学社区创建的一组 Python 包。它包含许多功能，包括广泛的随机数生成器、线性代数例程和优化器。'
- en: SciPy is a comprehensive package and, over time, people have developed many
    extensions to customize and extend the package according to their needs. SciPy
    is performant as it acts as a thin wrapper around optimized code written in C/C++
    or Fortran.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: SciPy 是一个全面的包，随着时间的推移，人们开发了许多扩展，以根据自己的需求定制和扩展该包。SciPy 性能良好，因为它作为围绕 C/C++ 或 Fortran
    编写的优化代码的薄包装器。
- en: 'The following are the main packages that are part of this ecosystem:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是该生态系统中主要的包：
- en: '**NumPy**: For algorithms, the ability to create multi-dimensional data structures,
    such as arrays and matrices, is really important. NumPy offers a set of array
    and matrix data types that are important for statistics and data analysis. Details
    about NumPy can be found at [http://www.numpy.org/](http://www.numpy.org/).'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NumPy**：对于算法来说，能够创建多维数据结构，如数组和矩阵，十分重要。NumPy 提供了一组数组和矩阵数据类型，对于统计学和数据分析非常重要。有关
    NumPy 的详细信息，请访问 [http://www.numpy.org/](http://www.numpy.org/)。'
- en: '**scikit-learn**: This machine learning extension is one of the most popular
    extensions of SciPy. Scikit-learn provides a wide range of important machine learning
    algorithms, including classification, regression, clustering, and model validation.
    You can find more details about scikit-learn at [http://scikit-learn.org/](http://scikit-learn.org/).'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**scikit-learn**：这个机器学习扩展是 SciPy 最受欢迎的扩展之一。Scikit-learn 提供了广泛的重要机器学习算法，包括分类、回归、聚类和模型验证。你可以在
    [http://scikit-learn.org/](http://scikit-learn.org/) 上找到有关 scikit-learn 的更多详细信息。'
- en: '**pandas**: pandas contains the tabular complex data structure that is used
    widely to input, output, and process tabular data in various algorithms. The pandas
    library contains many useful functions and it also offers highly optimized performance.
    More details about pandas can be found at [http://pandas.pydata.org/](http://pandas.pydata.org/).'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**pandas**：pandas 包含了广泛用于输入、输出和处理表格数据的表格复杂数据结构，广泛应用于各种算法中。pandas 库包含了许多有用的函数，同时也提供了高度优化的性能。有关
    pandas 的更多信息，请访问 [http://pandas.pydata.org/](http://pandas.pydata.org/)。'
- en: '**Matplotlib**: Matplotlib provides tools to create powerful visualizations.
    Data can be presented as line plots, scatter plots, bar charts, histograms, pie
    charts, and so on. More information can be found at [https://matplotlib.org/](https://matplotlib.org/).'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Matplotlib**：Matplotlib 提供了创建强大可视化工具的功能。数据可以以折线图、散点图、条形图、直方图、饼图等形式呈现。有关更多信息，请访问
    [https://matplotlib.org/](https://matplotlib.org/)。'
- en: Using Jupyter Notebook
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Jupyter Notebook
- en: We will be using Jupyter Notebook and Google’s Colaboratory as the IDE. More
    details about the setup and the use of Jupyter Notebook and Colab can be found
    in *Appendix A* and *B*.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Jupyter Notebook 和 Google 的 Colaboratory 作为 IDE。有关 Jupyter Notebook 和
    Colab 设置和使用的更多信息，请参见 *附录 A* 和 *B*。
- en: Algorithm design techniques
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 算法设计技术
- en: 'An algorithm is a mathematical solution to a real-world problem. When designing
    an algorithm, we keep the following three design concerns in mind as we work on
    designing and fine-tuning the algorithms:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 算法是解决实际问题的数学方法。在设计算法时，我们在设计和调优算法的过程中会考虑以下三个设计问题：
- en: '**Concern 1**: Is this algorithm producing the result we expected?'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**问题 1**：这个算法是否生成了我们预期的结果？'
- en: '**Concern 2**: Is this the most optimal way to get these results?'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**问题 2**：这是获取这些结果的最优方式吗？'
- en: '**Concern 3**: How is the algorithm going to perform on larger datasets?'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**问题 3**：这个算法在更大数据集上的表现如何？'
- en: It is important to understand the complexity of the problem itself before designing
    a solution for it. For example, it helps us to design an appropriate solution
    if we characterize the problem in terms of its needs and complexity.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计解决方案之前，理解问题本身的复杂性非常重要。例如，如果我们根据问题的需求和复杂性来描述它，这将有助于我们设计合适的解决方案。
- en: 'Generally, the algorithms can be divided into the following types based on
    the characteristics of the problem:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，算法可以根据问题的特征分为以下几种类型：
- en: '**Data-intensive algorithms**: Data-intensive algorithms are designed to deal
    with a large amount of data. They are expected to have relatively simplistic processing
    requirements. A compression algorithm applied to a huge file is a good example
    of data-intensive algorithms. For such algorithms, the size of the data is expected
    to be much larger than the memory of the processing engine (a single node or cluster),
    and an iterative processing design may need to be developed to efficiently process
    the data according to the requirements.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据密集型算法**：数据密集型算法旨在处理大量数据。它们预计具有相对简单的处理要求。应用于大型文件的压缩算法就是数据密集型算法的一个很好的例子。对于这类算法，数据的大小预计将远大于处理引擎的内存（单个节点或集群），并且可能需要开发一种迭代处理设计，以根据要求高效地处理数据。'
- en: '**Compute-intensive algorithms**: Compute-intensive algorithms have considerable
    processing requirements but do not involve large amounts of data. A simple example
    is the algorithm to find a very large prime number. Finding a strategy to divide
    the algorithm into different phases so that at least some of the phases are parallelized
    is key to maximizing the performance of the algorithm.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**计算密集型算法**：计算密集型算法有相当大的处理需求，但不涉及大量数据。一个简单的例子是寻找一个非常大的素数。找到一种策略，将算法划分为不同的阶段，以便至少一些阶段可以并行处理，是最大化算法性能的关键。'
- en: '**Both data and compute-intensive algorithms**: There are certain algorithms
    that deal with a large amount of data and also have considerable computing requirements.
    Algorithms used to perform sentiment analysis on live video feeds are a good example
    of where both the data and the processing requirements are huge in accomplishing
    the task. Such algorithms are the most resource-intensive algorithms and require
    careful design of the algorithm and intelligent allocation of available resources.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据和计算密集型算法**：有些算法处理大量数据并且计算需求也很大。用于对实时视频流进行情感分析的算法就是一个很好的例子，其中数据和处理需求都非常庞大，完成任务所需的资源也很大。这类算法是最消耗资源的算法，需要仔细设计算法并智能地分配可用资源。'
- en: To characterize the problem in terms of its complexity and needs, it helps if
    we study its data and compute dimensions in more depth, which we will do in the
    following section.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为了描述问题的复杂性和需求，深入研究它的数据和计算维度会有所帮助，我们将在接下来的章节中进行讨论。
- en: The data dimension
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据维度
- en: 'To categorize the data dimension of the problem, we look at its **volume**,
    **velocity**, and **variety** (the **3Vs**), which are defined as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了对问题的数据维度进行分类，我们查看其**数据量**、**速度**和**多样性**（即**3Vs**），定义如下：
- en: '**Volume**: The volume is the expected size of the data that the algorithm
    will process.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据量**：数据量是算法处理的数据的预期大小。'
- en: '**Velocity**: The velocity is the expected rate of new data generation when
    the algorithm is used. It can be zero.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**速度**：速度是算法使用时新数据生成的预期速率。它可以为零。'
- en: '**Variety**: The variety quantifies how many different types of data the designed
    algorithm is expected to deal with.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多样性**：多样性量化了设计的算法预期要处理的数据类型的数量。'
- en: '*Figure 1.2* shows the 3Vs of the data in more detail. The center of this diagram
    shows the simplest possible data, with a small volume and low variety and velocity.
    As we move away from the center, the complexity of the data increases. It can
    increase in one or more of the three dimensions.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*图1.2*更详细地展示了数据的3Vs。该图的中心显示了最简单的数据，具有小数据量、低多样性和低速度。随着我们远离中心，数据的复杂性增加，可能在三维中的一个或多个维度上增加。'
- en: 'For example, in the dimension of velocity, we have the batch process as the
    simplest, followed by the periodic process, and then the near real-time process.
    Finally, we have the real-time process, which is the most complex to handle in
    the context of data velocity. For example, a collection of live video feeds gathered
    by a group of monitoring cameras will have a high volume, high velocity, and high
    variety and may need an appropriate design to have the ability to store and process
    data effectively:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在速度维度上，我们有批处理过程作为最简单的，其次是周期性过程，然后是近实时过程。最后，我们有实时过程，这是在数据速度的背景下最复杂的处理方式。例如，一组监控摄像头收集的实时视频流将具有高数据量、高速度和高多样性，可能需要适当的设计来有效地存储和处理数据：
- en: '![Diagram  Description automatically generated](img/B18046_01_02.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图表描述自动生成](img/B18046_01_02.png)'
- en: 'Figure 1.2: 3Vs of Data: Volume, Velocity, and Variety'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.2：数据的3Vs：数据量、速度和多样性
- en: 'Let us consider three examples of use cases having three different types of
    data:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑三个具有三种不同数据类型的用例示例：
- en: First, consider a simple data-processing use case where the input data is a
    .`csv` file. In this case, the volume, velocity, and variety of the data will
    be low.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，考虑一个简单的数据处理用例，其中输入数据是一个`.csv`文件。在这种情况下，数据的量、速度和多样性将较低。
- en: Second, consider the use case where the input data is the live stream of a security
    video camera. Now the volume, velocity, and variety of the data will be quite
    high and should be kept in mind while designing an algorithm for it.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，考虑一个用例，其中输入数据是一个安全监控摄像头的实时视频流。在这种情况下，数据的量、速度和多样性将非常高，设计算法时应考虑这一点。
- en: Third, consider the use case of a typical sensor network. Let us assume that
    the data source of the sensor network is a mesh of temperature sensors installed
    in a large building. Although the velocity of the data being generated is typically
    very high (as new data is being generated very quickly), the volume is expected
    to be quite low (as each data element is typically only 16-bits long consisting
    of an 8-bit measurement plus 8-bit metadata such as a timestamp and the geo-coordinates.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三，考虑典型传感器网络的使用案例。假设传感器网络的数据源是安装在一座大楼中的温度传感器网格。尽管生成的数据的速度通常非常高（因为新数据生成非常快），但数据量预期相对较低（因为每个数据元素通常只有16位长，包含8位测量值和8位元数据，如时间戳和地理坐标）。
- en: The processing requirements, storage needs, and suitable software stack selection
    will be different for all the above three examples and, in general, are dependent
    on the volume, velocity, and variety of the data sources. It is important to first
    characterize data as the first step of designing an algorithm.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 以上三个示例的处理要求、存储需求和合适的软件栈选择都不相同，通常取决于数据源的体量、速度和多样性。将数据进行表征是设计算法的第一步，因此非常重要。
- en: The compute dimension
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算维度
- en: To characterize the compute dimension, we analyze the processing needs of the
    problem at hand. The processing needs of an algorithm determine what sort of design
    is most efficient for it. For example, complex algorithms, in general, require
    lots of processing power. For such algorithms, it may be important to have multi-node
    parallel architecture. Modern deep algorithms usually involve considerable numeric
    processing and may need the power of GPUs or TUPs as discussed in *Chapter 16*,
    *Practical Considerations*.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了表征计算维度，我们需要分析当前问题的处理需求。一个算法的处理需求决定了最适合的设计类型。例如，复杂算法通常需要大量的处理能力。对于这类算法，可能需要具有多节点并行架构。现代深度算法通常涉及大量的数值处理，可能需要GPU或TUP的计算能力，如*第16章*、*实际考虑因素*中所讨论的。
- en: Performance analysis
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能分析
- en: Analyzing the performance of an algorithm is an important part of its design.
    One of the ways to estimate the performance of an algorithm is to analyze its
    complexity.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 分析算法的性能是其设计的一个重要部分。估算算法性能的方式之一是分析其复杂度。
- en: 'Complexity theory is the study of how complicated algorithms are. To be useful,
    any algorithm should have three key features:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂度理论是研究算法复杂度的学科。为了有用，任何算法都应该具备三个关键特性：
- en: '**Should be correct**: A good algorithm should produce the correct result.
    To confirm that an algorithm is working correctly, it needs to be extensively
    tested, especially testing edge cases.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应该正确**：一个好的算法应该产生正确的结果。为了确认算法是否正确工作，需要进行广泛的测试，特别是测试边界情况。'
- en: '**Should be understandable**: A good algorithm should be understandable. The
    best algorithm in the world is not very useful if it’s too complicated for us
    to implement on a computer.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应该可理解**：一个好的算法应该是可理解的。如果一个算法过于复杂，无法在计算机上实现，那么它再好也没有用。'
- en: '**Should be efficient**: A good algorithm should be efficient. Even if an algorithm
    produces the correct result, it won’t help us much if it takes a thousand years
    or if it requires 1 billion terabytes of memory.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应该高效**：一个好的算法应该是高效的。即使一个算法产生了正确的结果，如果它需要一千年才能完成，或者需要十亿TB的内存，那么它也没有多大帮助。'
- en: 'There are two possible types of analysis to quantify the complexity of an algorithm:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种可能的分析方法来量化算法的复杂度：
- en: '**Space complexity analysis**: Estimates the runtime memory requirements needed
    to execute the algorithm.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**空间复杂度分析**：估算执行算法所需的运行时内存需求。'
- en: '**Time complexity analysis**: Estimates the time the algorithm will take to
    run.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**时间复杂度分析**：估算算法运行所需的时间。'
- en: 'Let us study them one by one:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一研究：
- en: Space complexity analysis
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 空间复杂度分析
- en: 'Space complexity analysis estimates the amount of memory required by the algorithm
    to process input data. While processing the input data, the algorithm needs to
    store the transient temporary data structures in memory. The way the algorithm
    is designed affects the number, type, and size of these data structures. In an
    age of distributed computing and with increasingly large amounts of data that
    needs to be processed, space complexity analysis is becoming more and more important.
    The size, type, and number of these data structures will dictate the memory requirements
    for the underlying hardware. Modern in-memory data structures used in distributed
    computing need to have efficient resource allocation mechanisms that are aware
    of the memory requirements at different execution phases of the algorithm. Complex
    algorithms tend to be iterative in nature. Instead of bringing all the information
    into the memory at once, such algorithms iteratively populate the data structures.
    To calculate the space complexity, it is important to first classify the type
    of iterative algorithm we plan to use. An iterative algorithm can use one of the
    following three types of iterations:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 空间复杂度分析估算了算法处理输入数据时所需的内存量。在处理输入数据时，算法需要将瞬时临时数据结构存储在内存中。算法的设计方式会影响这些数据结构的数量、类型和大小。在分布式计算时代，随着需要处理的数据量越来越大，空间复杂度分析变得越来越重要。这些数据结构的大小、类型和数量将决定底层硬件的内存需求。现代分布式计算中使用的内存数据结构需要具备高效的资源分配机制，能够在算法的不同执行阶段意识到内存需求。复杂的算法往往是迭代式的。此类算法并不会一次性将所有信息加载到内存中，而是通过迭代逐步填充数据结构。为了计算空间复杂度，首先需要对我们计划使用的迭代算法类型进行分类。迭代算法可以使用以下三种类型的迭代：
- en: '**Converging Iterations**: As the algorithm proceeds through iterations, the
    amount of data it processes in each individual iteration decreases. In other words,
    space complexity decreases as the algorithm proceeds through its iterations. The
    main challenge is to tackle the space complexity of the initial iterations. Modern
    scalable cloud infrastructures such as AWS and Google Cloud are best suited to
    run such algorithms.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**收敛迭代**：随着算法通过迭代进行，每次迭代中处理的数据量都会减少。换句话说，随着算法迭代的进行，空间复杂度逐渐降低。主要的挑战是处理初始迭代的空间复杂度。现代可扩展的云基础设施，如
    AWS 和 Google Cloud，非常适合运行这类算法。'
- en: '**Diverging Iterations**: As the algorithm proceeds through iterations, the
    amount of data it processes in each individual iteration increases. As the space
    complexity increases with the algorithm’s progress through iterations, it is important
    to set constraints to prevent the system from becoming unstable. The constraints
    can be set by limiting the number of iterations and/or by setting a limit on the
    size of initial data.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发散迭代**：随着算法通过迭代进行，每次迭代中处理的数据量逐渐增加。随着空间复杂度随着算法迭代的推进而增加，重要的是设置约束条件，以防止系统变得不稳定。可以通过限制迭代次数和/或限制初始数据大小来设置这些约束条件。'
- en: '**Flat Iterations**: As the algorithm proceeds through iterations, the amount
    of data it processes in each individual iteration remains constant. As space complexity
    does not change, elasticity in infrastructure is not needed.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**平面迭代**：随着算法通过迭代进行，每次迭代中处理的数据量保持不变。由于空间复杂度不发生变化，因此不需要基础设施的弹性。'
- en: To calculate the space complexity, we need to focus on one of the most complex
    iterations. In many algorithms, as we converge towards the solution, the resource
    needs are gradually reduced. In such cases, initial iterations are the most complex
    and give us a better estimate of space complexity. Once chosen, we estimate the
    total amount of memory used by the algorithm, including the memory used by its
    transient data structures, execution, and input values. This will give us a good
    estimate of the space complexity of an algorithm.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 计算空间复杂度时，我们需要关注最复杂的迭代之一。在许多算法中，随着我们逐步接近解决方案，所需的资源会逐渐减少。在这种情况下，初始迭代是最复杂的，可以帮助我们更好地估算空间复杂度。选择后，我们估算算法使用的总内存量，包括其瞬时数据结构、执行和输入值所占用的内存。这将帮助我们很好地估算算法的空间复杂度。
- en: 'The following are guidelines to minimize the space complexity:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是最小化空间复杂度的指导原则：
- en: Whenever possible, try to design an algorithm as iterative.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在可能的情况下，尽量将算法设计为迭代式。
- en: While designing an iterative algorithm, whenever there is a choice, prefer a
    larger number of iterations over a smaller number of iterations. A fine-grained
    larger number of iterations is expected to have less space complexity.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在设计迭代算法时，每当有选择时，应该优先选择更多的迭代次数而不是更少的迭代次数。细粒度的更多迭代预计会有较低的空间复杂度。
- en: Algorithms should bring only the information needed for current processing into
    memory. Whatever is not needed should be flushed out from the memory.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 算法应该只将当前处理所需的信息加载到内存中，任何不需要的信息应当被清除出内存。
- en: Space complexity analysis is a must for the efficient design of algorithms.
    If proper space complexity analysis is not conducted while designing a particular
    algorithm, insufficient memory availability for the transient temporary data structures
    may trigger unnecessary disk spillovers, which could potentially considerably
    affect the performance and efficiency of the algorithm.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 空间复杂度分析是高效设计算法的必要条件。如果在设计特定算法时没有进行适当的空间复杂度分析，可能会因为临时数据结构的内存不足而触发不必要的磁盘溢出，这可能会显著影响算法的性能和效率。
- en: In this chapter, we will look deeper into time complexity. Space complexity
    will be discussed in *Chapter 15*, *Large-Scale Algorithms*, in more detail, where
    we will deal with large-scale distributed algorithms with complex runtime memory
    requirements.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将深入探讨时间复杂度。空间复杂度将在*第15章*《大规模算法》中更详细地讨论，其中我们将处理具有复杂运行时内存需求的大规模分布式算法。
- en: Time complexity analysis
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 时间复杂度分析
- en: 'Time complexity analysis estimates how long it will take for an algorithm to
    complete its assigned job based on its structure. In contrast to space complexity,
    time complexity is not dependent on any hardware that the algorithm will run on.
    Time complexity analysis solely depends on the structure of the algorithm itself.
    The overall goal of time complexity analysis is to try to answer these important
    two questions:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 时间复杂度分析通过评估算法的结构，估算算法完成指定任务所需的时间。与空间复杂度不同，时间复杂度不依赖于算法运行的硬件。时间复杂度分析仅取决于算法本身的结构。时间复杂度分析的总体目标是尝试回答这两个重要问题：
- en: Will this algorithm scale? A well-designed algorithm should be fully capable
    of taking advantage of the modern elastic infrastructure available in cloud computing
    environments. An algorithm should be designed in a way such that it can utilize
    the availability of more CPUs, processing cores, GPUs, and memory. For example,
    an algorithm used for training a model in a machine learning problem should be
    able to use distributed training as more CPUs are available.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个算法能扩展吗？一个设计良好的算法应该能够充分利用云计算环境中现代弹性基础设施的优势。算法应当设计成能够利用更多的CPU、处理核心、GPU和内存。例如，用于训练机器学习模型的算法应当能够在更多的CPU可用时使用分布式训练。
- en: Such algorithms should also take advantage of GPUs and additional memory if
    made available during the execution of the algorithm.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的算法在执行过程中应当能够充分利用GPU和额外的内存（如果有的话）。
- en: How well will this algorithm handle larger datasets?
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个算法如何处理更大的数据集？
- en: To answer these questions, we need to determine the effect on the performance
    of an algorithm as the size of the data is increased and make sure that the algorithm
    is designed in a way that not only makes it accurate but also scales well. The
    performance of an algorithm is becoming more and more important for larger datasets
    in today’s world of “big data.”
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回答这些问题，我们需要确定当数据量增大时，算法的性能受到的影响，并确保算法的设计不仅要保证准确性，还要具有良好的扩展性。在当今“大数据”时代，算法的性能对大数据集来说变得越来越重要。
- en: 'In many cases, we may have more than one approach available to design the algorithm.
    The goal of conducting time complexity analysis, in this case, will be as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，我们可能有不止一种方法可以用来设计算法。在这种情况下，进行时间复杂度分析的目标将如下：
- en: '*“Given a certain problem and more than one algorithm, which one is the most
    efficient to use in terms of time efficiency?”*'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*“给定一个特定的问题，且有多个算法可供选择，哪个算法在时间效率方面最为高效？”*'
- en: 'There can be two basic approaches to calculating the time complexity of an
    algorithm:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 计算算法时间复杂度有两种基本方法：
- en: '**A post-implementation profiling approach**: In this approach, different candidate
    algorithms are implemented, and their performance is compared.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**后期实现的性能分析方法**：在这种方法中，首先实现不同的候选算法，并比较它们的性能。'
- en: '**A pre-implementation theoretical approach**: In this approach, the performance
    of each algorithm is approximated mathematically before running an algorithm.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**预实现理论方法**：在这种方法中，每个算法的性能在运行算法之前通过数学方法进行近似。'
- en: The advantage of the theoretical approach is that it only depends on the structure
    of the algorithm itself. It does not depend on the actual hardware that will be
    used to run the algorithm, the choice of the software stack chosen at runtime,
    or the programming language used to implement the algorithm.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 理论方法的优势在于它仅依赖于算法本身的结构。它不依赖于运行算法时将使用的实际硬件、运行时选择的软件栈，或实现算法所使用的编程语言。
- en: Estimating the performance
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 估算性能
- en: The performance of a typical algorithm will depend on the type of data given
    to it as an input. For example, if the data is already sorted according to the
    context of the problem we are trying to solve, the algorithm may perform blazingly
    fast. If the sorted input is used to benchmark this particular algorithm, then
    it will give an unrealistically good performance number, which will not be a true
    reflection of its real performance in most scenarios. To handle this dependency
    of algorithms on the input data, we have different types of cases to consider
    when conducting a performance analysis.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型算法的性能将取决于输入数据的类型。例如，如果数据已经按照我们试图解决的问题的上下文进行了排序，那么算法可能会运行得非常快速。如果排序后的输入数据被用来基准测试该算法，那么它将给出一个不切实际的优异性能结果，这并不能真实反映其在大多数场景中的实际表现。为了处理算法对输入数据的依赖性，在进行性能分析时我们需要考虑不同的情况。
- en: The best case
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 最佳情况
- en: In the best case, the data given as input is organized in a way that the algorithm
    will give its best performance. Best-case analysis gives the upper bound of the
    performance.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在最佳情况下，作为输入的数据已按算法能够提供最佳性能的方式进行组织。最佳情况分析给出性能的上界。
- en: The worst case
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 最坏情况
- en: The second way to estimate the performance of an algorithm is to try to find
    the maximum possible time it will take to get the job done under a given set of
    conditions. This worst-case analysis of an algorithm is quite useful as we are
    guaranteeing that regardless of the conditions, the performance of the algorithm
    will always be better than the numbers that come out of our analysis. Worst-case
    analysis is especially useful for estimating the performance when dealing with
    complex problems with larger datasets. Worst-case analysis gives the lower bound
    of the performance of the algorithm.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 估算算法性能的第二种方法是尝试找出在给定条件下完成任务所需的最大时间。算法的最坏情况分析非常有用，因为我们可以保证无论条件如何，算法的性能总是优于我们分析中得出的数字。最坏情况分析对于估算处理复杂问题和大型数据集时的性能特别有用。最坏情况分析给出了算法性能的下界。
- en: The average case
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 平均情况
- en: This starts by dividing the various possible inputs into various groups. Then,
    it conducts the performance analysis from one of the representative inputs from
    each group. Finally, it calculates the average of the performance of each of the
    groups.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这一方法首先将各种可能的输入划分为不同的组别。然后，从每个组别的一个代表性输入进行性能分析。最后，它计算每个组别性能的平均值。
- en: Average-case analysis is not always accurate as it needs to consider all the
    different combinations and possibilities of input to the algorithm, which is not
    always easy to do.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 平均情况分析并不总是准确的，因为它需要考虑所有不同的输入组合和可能性，这并不总是容易做到的。
- en: Big O notation
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 大 O 符号
- en: 'Big O notation was first introduced by Bachmann in 1894 in a research paper
    to approximate an algorithm’s growth. He wrote:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 大 O 符号最早由巴赫曼（Bachmann）于1894年在一篇研究论文中提出，用于近似算法的增长。他写道：
- en: “… with the symbol *O(n)* we express a magnitude whose order in respect to *n*
    does not exceed the order of *n*” (Bachmann 1894, p. 401).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: “… 使用符号 *O(n)*，我们表示一种其相对于 *n* 的阶数不超过 *n* 阶数的量。”（巴赫曼 1894，p. 401）
- en: Big-O notation provides a way to describe the long-term growth rate of an algorithm’s
    performance. In simpler terms, it tells us how the runtime of an algorithm increases
    as the input size grows. Let’s break it down with the help of two functions, *f(n)*
    and *g(n)*. If we say *f* = *O(g)*, what we mean is that as n approaches infinity,
    the ratio ![](img/B18046_01_001.png) stays limited or bounded. In other words,
    no matter how large our input gets, *f(n)* will not grow disproportionately faster
    than *g(n)*.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 大O符号提供了一种描述算法性能长期增长率的方式。简单来说，它告诉我们，随着输入规模的增加，算法的运行时间是如何增长的。我们可以通过两个函数 *f(n)*
    和 *g(n)* 来进一步解释。如果我们说 *f* = *O(g)*，意思是当n趋向于无穷大时，比例 ![](img/B18046_01_001.png)
    保持有限或有界。换句话说，无论我们的输入有多大，*f(n)* 的增长速度都不会比 *g(n)* 快得不成比例。
- en: 'Let’s look at particular functions:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些特定的函数：
- en: '*f(n)* = 1000*n*² + 100*n* + 10'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '*f(n)* = 1000*n*² + 100*n* + 10'
- en: and
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 并且
- en: '*g(n)* = *n*²'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '*g(n)* = *n*²'
- en: Note that both functions will approach infinity as *n* approaches infinity.
    Let’s ﬁnd out if *f* = *O(g)* by applying the deﬁnition.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当 *n* 趋近无穷大时，两个函数都会趋近无穷大。让我们通过应用定义来验证 *f* = *O(g)*。
- en: First, let us calculate ![](img/B18046_01_002.png),
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们计算 ![](img/B18046_01_002.png)。
- en: which will be equal to ![](img/B18046_01_003.png) = ![](img/B18046_01_004.png)
    = (1000 + ![](img/B18046_01_005.png)).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这将等于 ![](img/B18046_01_003.png) = ![](img/B18046_01_004.png) = (1000 + ![](img/B18046_01_005.png))。
- en: It is clear that ![](img/B18046_01_003.png) is bounded and will not approach
    infinity as *n* approaches infinity.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，![](img/B18046_01_003.png) 是有界的，并且当 *n* 趋向无穷大时，它不会趋向于无穷大。
- en: Thus *f(n)* = *O(g)* = *O(n*²*)*.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，*f(n)* = *O(g)* = *O(n*²*)*。
- en: '*(n*²*)* represents that the complexity of this function increases as the square
    of input *n*. If we double the number of input elements, the complexity is expected
    to increase by 4.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '*(n*²*)* 表示该函数的复杂度随着输入 *n* 的平方而增加。如果我们将输入元素数量翻倍，那么复杂度预计会增加4倍。'
- en: Note the following 4 rules when dealing with Big-O notation.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 处理大O符号时，请注意以下4个规则。
- en: '**Rule 1**:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**规则 1**：'
- en: Let us look into the complexity of loops in algorithms. If an algorithm performs
    a certain sequence of steps *n* times, then it has *O(n)* performance.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看算法中的循环复杂度。如果一个算法执行某一系列步骤 *n* 次，那么它的性能就是 *O(n)*。
- en: '**Rule 2**:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '**规则 2**：'
- en: Let us look into the nested loops of the algorithms. If an algorithm performs
    a function that has a loop of *n*¹ steps, and for each loop it performs another
    *n*² steps, the algorithm’s total performance is *O(n*¹ *× n*²*)*.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来分析算法中的嵌套循环。如果一个算法执行的某个函数有 *n*¹ 步，并且对于每次循环它执行另一个 *n*² 步的操作，那么该算法的总性能是 *O(n*¹
    *× n*²*)*。
- en: 'For example, if an algorithm has both outer and inner loops having *n* steps,
    then the complexity of the algorithm will be represented by:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果一个算法有外循环和内循环，且都需要 *n* 步，那么该算法的复杂度将表示为：
- en: '*O(n*n)* = *O(n*²*)*'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '*O(n*n)* = *O(n*²*)*'
- en: '**Rule 3**:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '**规则 3**：'
- en: If an algorithm performs a function *f(n)* that takes *n*¹ steps and then performs
    another function *g(n)* that takes *n*² steps, the algorithm’s total performance
    is *O(f(n)+g(n))*.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个算法执行一个需要 *n*¹ 步的函数 *f(n)*，然后执行另一个需要 *n*² 步的函数 *g(n)*，则该算法的总性能是 *O(f(n)+g(n))*。
- en: '**Rule 4**:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '**规则 4**：'
- en: If an algorithm takes *O(g(n) + h(n))* and the function *g(n)* is greater than
    *h(n)* for large *n*, the algorithm’s performance can be simplified to *O(g(n))*.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个算法的复杂度是 *O(g(n) + h(n))*，并且在大n的情况下，函数 *g(n)* 大于 *h(n)*，那么该算法的性能可以简化为 *O(g(n))*。
- en: It means that *O(1+n)* = *O(n)*.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着 *O(1+n)* = *O(n)*。
- en: And *O(n*²*+ n*³*)* = *O(n*²*)*.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 并且 *O(n*²*+ n*³*)* = *O(n*²*)*。
- en: '**Rule 5**:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**规则 5**：'
- en: When calculating the complexity of an algorithm, ignore constant multiples.
    If *k* is a constant, *O(kf(n))* is the same as *O(f(n))*.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 计算算法的复杂度时，要忽略常数倍数。如果 *k* 是常数，*O(kf(n))* 等同于 *O(f(n))*。
- en: Also, *O(f(k × n))* is the same as *O(f(n))*.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，*O(f(k × n))* 等同于 *O(f(n))*。
- en: Thus *O(5n*²*)* = *O(n*²*).*
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，*O(5n*²*)* = *O(n*²*)*。
- en: And *O((3n*²*))* = *O(n*²*).*
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 并且 *O((3n*²*))* = *O(n*²*)*。
- en: 'Note that:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意：
- en: The complexity quantified by Big O notation is only an estimate.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大O符号表示的复杂度仅为估算值。
- en: For smaller sizes of data, we do not care about the time complexity. *n*⁰ in
    the graph defines the threshold above which we are interested in finding the time
    complexity. The shaded area describes this area of interest where we will analyze
    the time complexity.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于较小规模的数据，我们不关心时间复杂度。图中的 *n*⁰ 定义了我们开始关注时间复杂度的阈值。阴影区域描述了我们感兴趣的区域，在这个区域内我们将分析时间复杂度。
- en: '*T(n)* time complexity is more than the original function. A good choice of
    *T(n)* will try to create a tight upper bound for *F(n)*.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*T(n)* 时间复杂度大于原始函数。一个好的 *T(n)* 选择会尽量为 *F(n)* 创建一个紧密的上界。'
- en: 'The following table summarizes the different kinds of Big O notation types
    discussed in this section:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 下表总结了本节中讨论的不同类型的大 O 符号：
- en: '| **Complexity Class** | **Name** | **Example Operations** |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| **复杂度类别** | **名称** | **示例操作** |'
- en: '| `O(1)` | Constant | Append, get item, set item. |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| `O(1)` | 常数 | 添加、获取项、设置项。 |'
- en: '| `O(logn)` | Logarithmic | Finding an element in a sorted array. |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| `O(logn)` | 对数 | 在已排序数组中查找一个元素。 |'
- en: '| `O(n)` | Linear | Copy, insert, delete, iteration |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| `O(n)` | 线性 | 复制、插入、删除、迭代 |'
- en: '| `O(n`²`)` | Quadratic | Nested loops |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| `O(n²)` | 二次 | 嵌套循环 |'
- en: Constant time (O(1)) complexity
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常数时间 (O(1)) 复杂度
- en: 'If an algorithm takes the same amount of time to run, independent of the size
    of the input data, it is said to run in constant time. It is represented by *O(1)*.
    Let’s take the example of accessing the *n*^(th) element of an array. Regardless
    of the size of the array, it will take constant time to get the results. For example,
    the following function will return the first element of the array and has a complexity
    of *O(1)*:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个算法的运行时间与输入数据的大小无关，始终相同，则称其为常数时间运行。它用 *O(1)* 表示。以访问数组中的 *n*^(th) 元素为例。无论数组的大小如何，获取结果所需的时间是常数时间。例如，以下函数将返回数组的第一个元素，并具有
    *O(1)* 复杂度：
- en: '[PRE5]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Note that:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：
- en: The addition of a new element to a stack is done by using `push` and removing
    an element from a stack is done by using `pop`. Regardless of the size of the
    stack, it will take the same time to add or remove an element.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向栈中添加新元素是通过 `push` 操作完成的，而从栈中删除元素是通过 `pop` 操作完成的。无论栈的大小如何，添加或删除一个元素所需的时间是相同的。
- en: When accessing the element of the hashtable, note that it is a data structure
    that stores data in an associative format, usually as key-value pairs.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当访问哈希表中的元素时，请注意，它是一种以关联格式存储数据的数据结构，通常为键值对。
- en: Linear time (O(n)) complexity
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线性时间 (O(n)) 复杂度
- en: 'An algorithm is said to have a complexity of linear time, represented by *O(n)*,
    if the execution time is directly proportional to the size of the input. A simple
    example is to add the elements in a single-dimensional data structure:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个算法的执行时间与输入规模成正比，则称其为线性时间复杂度，表示为 *O(n)*。一个简单的例子是将一维数据结构中的元素相加：
- en: '[PRE9]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Note the main loop of the algorithm. The number of iterations in the main loop
    increases linearly with an increasing value of *n*, producing an *O(n)* complexity
    in the following figure:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意算法的主循环。主循环中的迭代次数随着 *n* 值的增加而线性增长，产生如图所示的 *O(n)* 复杂度：
- en: '[PRE10]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Some other examples of array operations are as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 其他一些数组操作的示例如下：
- en: Searching an element
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找一个元素
- en: Finding the minimum value among all the elements of an array
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找数组中所有元素的最小值
- en: Quadratic time (O(n2)) complexity
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 二次时间 (O(n²)) 复杂度
- en: 'An algorithm is said to run in quadratic time if the execution time of an algorithm
    is proportional to the square of the input size; for example, a simple function
    that sums up a two-dimensional array, as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个算法的执行时间与输入规模的平方成正比，则称该算法的运行时间为二次时间；例如，一个简单的函数用于求和一个二维数组，如下所示：
- en: '[PRE14]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Note the nested inner loop within the other main loop. This nested loop gives
    the preceding code the complexity of *O(n*²*)*:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，内层循环嵌套在另一个主循环内。这个嵌套循环使得前面的代码具有 *O(n²)* 的复杂度：
- en: '[PRE15]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Another example is the *bubble sort algorithm* (which will be discussed in *Chapter
    2*, *Data Structures Used in Algorithms*).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是 *冒泡排序算法*（将在 *第2章*，*算法中的数据结构* 中讨论）。
- en: Logarithmic time (O(logn)) complexity
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对数时间 (O(logn)) 复杂度
- en: 'An algorithm is said to run in logarithmic time if the execution time of the
    algorithm is proportional to the logarithm of the input size. With each iteration,
    the input size decreases by constant multiple factors. An example of a logarithmic
    algorithm is binary search. The binary search algorithm is used to find a particular
    element in a one-dimensional data structure, such as a Python list. The elements
    within the data structure need to be sorted in descending order. The binary search
    algorithm is implemented in a function named `search_binary`, as follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个算法的执行时间与输入大小的对数成正比，那么这个算法被称为对数时间算法。在每次迭代中，输入大小会按固定倍数减少。一个对数算法的例子是二分查找。二分查找算法用于在一维数据结构中查找特定元素，例如Python列表。数据结构中的元素需要按降序排序。二分查找算法在一个名为
    `search_binary` 的函数中实现，如下所示：
- en: '[PRE19]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The main loop takes advantage of the fact that the list is ordered. It divides
    the list in half with each iteration until it gets to the result.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 主循环利用了列表已排序的事实。它每次迭代都将列表分成一半，直到找到结果。
- en: After defining the function, it is tested to search a particular element in
    lines `11` and `12`. The binary search algorithm is further discussed in *Chapter
    3*, *Sorting and Searching Algorithms*.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了这个函数之后，它在第 `11` 和第 `12` 行进行了测试，用于搜索特定元素。二分查找算法将在 *第3章*，*排序与查找算法* 中进一步讨论。
- en: 'Note that among the four types of Big O notation types presented, *O(n*²*)*
    has the worst performance and *O(logn)* has the best performance. On the other
    hand, *O(n*²*)* is not as bad as *O(n*³*)*, but still, algorithms that fall in
    this class cannot be used on big data as the time complexity puts limitations
    on how much data they can realistically process. The performance of four types
    of Big O notations is shown in *Figure 1.3*:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在展示的四种大O符号中，*O(n²)* 的性能最差，而 *O(logn)* 的性能最好。另一方面，*O(n²)* 不如 *O(n³)* 那么糟糕，但仍然，属于这个类别的算法无法处理大数据，因为时间复杂度限制了它们实际能够处理的数据量。四种大O符号的性能如
    *图1.3* 所示：
- en: '![Chart, line chart  Description automatically generated](img/B18046_01_03.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![Chart, line chart  Description automatically generated](img/B18046_01_03.png)'
- en: 'Figure 1.3: Big O complexity chart'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.3：大O复杂度图表
- en: One way to reduce the complexity of an algorithm is to compromise on its accuracy,
    producing a type of algorithm called an **approximate algorithm**.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 降低算法复杂度的一种方法是牺牲其精确度，从而产生一种被称为 **近似算法** 的算法。
- en: Selecting an algorithm
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择算法
- en: How do you know which one is a better solution? How do you know which algorithm
    runs faster? Analyzing the time complexity of an algorithm may answer these types
    of questions.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如何知道哪种解决方案更好？如何知道哪个算法运行得更快？分析一个算法的时间复杂度可以回答这些问题。
- en: To see where it can be useful, let’s take a simple example where the objective
    is to sort a list of numbers. There are a bunch of algorithms readily available
    that can do the job. The issue is how to choose the right one.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到算法的用途，让我们以一个简单的例子为例，目标是对数字列表进行排序。有许多现成的算法可以完成这个任务。问题是如何选择正确的算法。
- en: First, an observation that can be made is that if there are not too many numbers
    in the list, then it does not matter which algorithm we choose to sort the list
    of numbers. So, if there are only 10 numbers in the list (*n=10*), then it does
    not matter which algorithm we choose as it would probably not take more than a
    few microseconds, even with a very simple algorithm. But as *n* increases, the
    choice of the right algorithm starts to make a difference. A poorly designed algorithm
    may take a couple of hours to run, while a well-designed algorithm may finish
    sorting the list in a couple of seconds. So, for larger input datasets, it makes
    a lot of sense to invest time and effort, perform a performance analysis, and
    choose the correctly designed algorithm that will do the job required in an efficient
    manner.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 首先可以观察到，如果列表中的数字不多，那么选择哪种算法来排序这些数字并不重要。因此，如果列表中只有10个数字（*n=10*），那么选择哪种算法并无太大关系，因为即使使用非常简单的算法，也可能只需要几微秒的时间。但随着
    *n* 的增加，选择正确算法开始变得重要。一个设计不良的算法可能需要几个小时来运行，而一个设计良好的算法可能只需要几秒钟就能完成排序。因此，对于较大的输入数据集，花时间和精力进行性能分析，并选择合适设计的算法来高效地完成任务是非常有意义的。
- en: Validating an algorithm
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证算法
- en: Validating an algorithm confirms that it is actually providing a mathematical
    solution to the problem we are trying to solve. A validation process should check
    the results for as many possible values and types of input values as possible.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 验证算法确认它实际上提供了我们尝试解决的问题的数学解决方案。验证过程应检查尽可能多的可能值和类型的输入值的结果。
- en: Exact, approximate, and randomized algorithms
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 精确、近似和随机化算法
- en: Validating an algorithm also depends on the type of the algorithm as the testing
    techniques are different. Let’s first differentiate between deterministic and
    randomized algorithms.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 验证算法也取决于算法的类型，因为测试技术是不同的。首先让我们区分确定性和随机化算法。
- en: 'For deterministic algorithms, a particular input always generates exactly the
    same output. But for certain classes of algorithms, a sequence of random numbers
    is also taken as input, which makes the output different each time the algorithm
    is run. The k-means clustering algorithm, which is detailed in *Chapter 6*, *Unsupervised
    Machine Learning Algorithms*, is an example of such an algorithm:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 对于确定性算法，特定输入始终生成完全相同的输出。但对于某些类别的算法，随机数序列也被视为输入，这使得每次运行算法时输出都不同。详见第 6 章《无监督机器学习算法》中详细介绍的
    k 均值聚类算法。
- en: '![Waterfall chart  Description automatically generated](img/B18046_01_04.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![瀑布图  自动生成描述](img/B18046_01_04.png)'
- en: 'Figure 1.4: Deterministic and Randomized Algorithms'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '图 1.4: 确定性与随机化算法'
- en: 'Algorithms can also be divided into the following two types based on assumptions
    or approximation used to simplify the logic to make them run faster:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 根据用于简化逻辑以使其运行更快的假设或近似，算法还可以分为以下两种类型：
- en: '**An exact algorithm**: Exact algorithms are expected to produce a precise
    solution without introducing any assumptions or approximations.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一个精确算法**：精确算法预期能够在不引入任何假设或近似的情况下产生精确的解决方案。'
- en: '**An approximate algorithm**: When the problem complexity is too much to handle
    for the given resources, we simplify our problem by making some assumptions. The
    algorithms based on these simplifications or assumptions are called approximate
    algorithms, which don’t quite give us the precise solution.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一个近似算法**：当问题复杂度超出给定资源的处理能力时，我们通过做一些假设来简化问题。基于这些简化或假设的算法称为近似算法，它们不能给出精确的解决方案。'
- en: Let’s look at an example to understand the difference between exact and approximate
    algorithms—the famous traveling salesman problem, which was presented in 1930\.
    Traveling salesman challenges you to find the shortest route for a particular
    salesman that visits each city (from a list of cities) and then returns to the
    origin, which is why he is named the traveling salesman. The first attempt to
    provide the solution will include generating all the permutations of cities and
    choosing the combination of cities that is cheapest. It is obvious that time complexity
    starts to become unmanageable beyond 30 cities.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来理解精确算法和近似算法之间的区别——著名的旅行推销员问题，这个问题在 1930 年被提出。旅行推销员问题挑战你找出一个特定推销员访问每个城市（从城市列表中）并返回原点的最短路线，这也是他被称为旅行推销员的原因。首次尝试提供解决方案将包括生成所有城市的排列组合，并选择最便宜的城市组合。显然，当城市超过
    30 个时，时间复杂度开始变得难以管理。
- en: If the number of cities is more than 30, one way of reducing the complexity
    is to introduce some approximations and assumptions.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果城市数量超过 30，减少复杂性的一种方法是引入一些近似和假设。
- en: For approximate algorithms, it is important to set the expectations for accuracy
    when gathering the requirements. Validating an approximation algorithm is about
    verifying that the error of the results is within an acceptable range.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 对于近似算法，重要的是在收集需求时设定准确性期望。验证近似算法涉及验证结果的误差是否在可接受范围内。
- en: Explainability
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可解释性
- en: When algorithms are used for critical cases, it becomes important to have the
    ability to explain the reason behind each and every result whenever needed. This
    is necessary to make sure that decisions based on the results of the algorithms
    do not introduce bias.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 当算法用于关键情况时，有必要能够解释每个结果背后的原因。这对确保基于算法结果的决策不引入偏见至关重要。
- en: The ability to exactly identify the features that are used directly or indirectly
    to come up with a particular decision is called the **explainability** of an algorithm.
    Algorithms, when used for critical use cases, need to be evaluated for bias and
    prejudice. The ethical analysis of algorithms has become a standard part of the
    validation process for those algorithms that can affect decision-making that relates
    to the lives of people.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 准确识别直接或间接用于做出特定决策的特征的能力称为算法的**可解释性**。当算法用于关键应用场景时，需要评估其偏见和偏袒。算法的伦理分析已经成为验证过程的标准部分，特别是那些涉及影响到人们生活决策的算法。
- en: For algorithms that deal with deep learning, explainability is difficult to
    achieve. For example, if an algorithm is used to refuse the mortgage application
    of a person, it is important to have the transparency and ability to explain the
    reason.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 对于处理深度学习的算法来说，实现可解释性是困难的。例如，如果一个算法被用来拒绝某人的抵押贷款申请，那么拥有透明度和能够解释原因是非常重要的。
- en: Algorithmic explainability is an active area of research. One of the effective
    techniques that have been recently developed is **Local Interpretable Model-Agnostic
    Explanations** (**LIME**), as proposed in the proceedings of the 22^(nd) **Association
    for Computing Machinery** (**ACM**) at the **Special Interest Group on Knowledge
    Discovery and Data Mining** (**SIGKDD**) international conference on knowledge
    discovery and data mining in 2016\. LIME is based on a concept where small changes
    are introduced to the input for each instance and then an effort to map the local
    decision boundary for that instance is made. It can then quantify the influence
    of each variable for that instance.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 算法的可解释性是一个活跃的研究领域。最近开发的有效技术之一是**局部可解释模型无关解释**（**LIME**），这是在2016年**计算机协会**（**ACM**）的**知识发现与数据挖掘特别兴趣小组**（**SIGKDD**）国际会议的论文集中提出的。LIME基于这样一个概念：对于每个实例，引入小的变化，然后努力映射该实例的局部决策边界。然后，它可以量化每个变量对该实例的影响。
- en: Summary
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 小结
- en: This chapter was about learning the basics of algorithms. First, we learned
    about the different phases of developing an algorithm. We discussed the different
    ways of specifying the logic of an algorithm that are necessary for designing
    it. Then, we looked at how to design an algorithm. We learned two different ways
    of analyzing the performance of an algorithm. Finally, we studied different aspects
    of validating an algorithm.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 本章内容是学习算法的基础。首先，我们了解了开发算法的不同阶段。我们讨论了设计算法所需的不同方法，以明确算法的逻辑。接着，我们看了如何设计一个算法。我们学习了两种不同的分析算法性能的方法。最后，我们研究了验证算法的不同方面。
- en: After going through this chapter, we should be able to understand the pseudocode
    of an algorithm. We should understand the different phases in developing and deploying
    an algorithm. We also learned how to use Big O notation to evaluate the performance
    of an algorithm.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读完本章后，我们应该能够理解算法的伪代码。我们应该理解开发和部署算法的不同阶段。我们还学习了如何使用大O符号来评估算法的性能。
- en: The next chapter is about the data structures used in algorithms. We will start
    by looking at the data structures available in Python. We will then look at how
    we can use these data structures to create more sophisticated data structures,
    such as stacks, queues, and trees, which are needed to develop complex algorithms.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将讨论算法中使用的数据结构。我们将从Python中的数据结构开始，接着探讨如何利用这些数据结构创建更复杂的数据结构，例如栈、队列和树，这些都是开发复杂算法所需要的。
- en: Learn more on Discord
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Discord上了解更多
- en: 'To join the Discord community for this book – where you can share feedback,
    ask questions to the author, and learn about new releases – follow the QR code
    below:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 要加入本书的Discord社区——在这里你可以分享反馈、向作者提问并了解新版本——请扫描下面的二维码：
- en: '[https://packt.link/WHLel](https://packt.link/WHLel)'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/WHLel](https://packt.link/WHLel)'
- en: '![](img/QR_Code1955211820597889031.png)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code1955211820597889031.png)'
