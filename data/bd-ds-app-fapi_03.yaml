- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Python Programming Specificities
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python 编程特性
- en: The Python language was designed to emphasize code readability. As such, it
    provides syntaxes and constructs that allow developers to quickly express complex
    concepts in a few readable lines. This makes it quite different from other programming
    languages.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Python 语言的设计重点是强调代码的可读性。因此，它提供了语法和结构，使开发者能够用几行易读的代码快速表达复杂的概念。这使得它与其他编程语言有很大的不同。
- en: The goal of this chapter is thus to get you acquainted with its specificities,
    but we expect you already have some experience with programming. We’ll first get
    started with the basics of the language, the standard types, and the flow control
    syntaxes. You’ll also be introduced to the list comprehension and generator concepts,
    which are very powerful ways to go through and transform sequences of data. You’ll
    also see that Python can be used as an object-oriented language, still through
    a very lightweight yet powerful syntax. Before moving on, we’ll also review the
    concepts of type hinting and asynchronous I/O, which are quite new in Python but
    are at the core of the **FastAPI** framework.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是让你熟悉 Python 的特性，但我们希望你已经具备一定的编程经验。我们将首先介绍 Python 的基础知识、标准类型和流程控制语法。你还将了解列表推导式和生成器的概念，这些是处理和转换数据序列的非常强大的方法。你还会看到，Python
    可以作为面向对象语言来使用，依然通过非常轻量且强大的语法。我们在继续之前，还将回顾类型提示和异步 I/O 的概念，这在 Python 中相对较新，但它们是
    **FastAPI** 框架的核心。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将覆盖以下主要内容：
- en: Basics of Python programming
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 编程基础
- en: List comprehensions and generators
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表推导式和生成器
- en: Classes and objects
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类和对象
- en: Type hinting and type checking with mypy
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 mypy 进行类型提示和类型检查
- en: Asynchronous I/O
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步 I/O
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You’ll need a Python virtual environment, as we set up in [*Chapter 1*](B19528_01.xhtml#_idTextAnchor024),
    *Python Development* *Environment Setup*.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要一个 Python 虚拟环境，正如我们在[*第 1 章*](B19528_01.xhtml#_idTextAnchor024)中设置的那样，*Python
    开发* *环境设置*。
- en: 'You’ll find all the code examples of this chapter in the book’s dedicated GitHub
    repository: [https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter02](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter02).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在本书的 GitHub 仓库中找到本章的所有代码示例：[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter02](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter02)。
- en: Basics of Python programming
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python 编程基础
- en: 'First of all, let’s review some of the key aspects of Python:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们回顾一下 Python 的一些关键特点：
- en: It’s an **interpreted language**. Contrary to languages such as C or Java, it
    doesn’t need to be compiled, which allows us to run Python code interactively.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是一种**解释型语言**。与 C 或 Java 等语言不同，Python 不需要编译，这使得我们可以交互式地运行 Python 代码。
- en: It’s **dynamically typed**. The type of values is determined at runtime.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是**动态类型**的。值的类型是在运行时确定的。
- en: 'It supports several **programming paradigms**: procedural, object-oriented,
    and functional programming.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它支持多种**编程范式**：过程化编程、面向对象编程和函数式编程。
- en: This makes Python quite a versatile language, from simple automation scripts
    to complex data science projects.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得 Python 成为一种非常多用途的语言，从简单的自动化脚本到复杂的数据科学项目。
- en: Let’s now write and run some Python!
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们编写并运行一些 Python 代码吧！
- en: Running Python scripts
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行 Python 脚本
- en: 'As we said, Python is an interpreted language. Hence, the simplest and quickest
    way to run some Python code is to launch an interactive shell. Just run the following
    command to start a session:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所说，Python 是一种解释型语言。因此，运行一些 Python 代码最简单和最快的方法就是启动一个交互式 shell。只需运行以下命令启动一个会话：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This shell makes it very easy to run some simple statements and do some experiments:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 shell 使得运行一些简单语句并进行实验变得非常容易：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: To exit the shell, use the *Ctrl* + *D* keyboard shortcut.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 要退出 shell，请使用 *Ctrl* + *D* 键盘快捷键。
- en: 'Obviously, this can become tedious when you start to have more statements or
    if you just wish to keep your work to reuse it later. Python scripts are saved
    in files with the `.py` extension. Let’s create a file named `chapter2_basics_01.py`
    in our project directory and add this code:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，当你开始有更多语句，或者仅仅是希望保留你的工作以便以后重用时，这会变得繁琐。Python 脚本保存为 `.py` 扩展名的文件。让我们在项目目录中创建一个名为
    `chapter2_basics_01.py` 的文件，并添加以下代码：
- en: chapter02_basics_01.py
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: chapter02_basics_01.py
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_basics_01.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_basics_01.py)'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_basics_01.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_basics_01.py)'
- en: 'Quite simply, this script prints `Hello world` on the console, assigns the
    value `100` to a variable named `x`, and prints a string with the value of `x`
    and its double. To run it, simply add the path of your script as a parameter of
    the Python command:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，这个脚本在控制台打印 `Hello world`，将值 `100` 赋给名为 `x` 的变量，并打印一个包含 `x` 和其双倍值的字符串。要运行它，只需将脚本的路径作为参数传递给
    Python 命令：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: f-strings
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: f-strings
- en: You have probably noticed the string starting with `f`. This syntax, called
    *f-strings*, is a very convenient and neat way to perform string interpolation.
    Within, you can simply insert variables between curly braces; they will automatically
    be converted into strings to build the resulting string. We’ll use it quite often
    in our examples.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到字符串以 `f` 开头。这个语法被称为 *f-strings*，是一种非常方便且简洁的字符串插值方式。在其中，你可以简单地将变量插入大括号中，它们会自动转换为字符串来构建最终的字符串。我们将在示例中经常使用它。
- en: That’s it! You are now able to write and run simple Python scripts. Let’s now
    dive deeper into the Python syntax.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！你现在已经能够编写并运行简单的 Python 脚本。接下来，让我们深入了解 Python 的语法。
- en: Indentation matters
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缩进很重要
- en: 'One of the most iconic aspects of Python is that code blocks are not defined
    using curly braces like many other programming languages, but rather with **whitespace
    indentation**. This may sound a bit strange, but it’s at the heart of the readability
    philosophy of Python. Let’s see how you can write a script that finds the even
    numbers in a list:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Python 最具标志性的特点之一是代码块不是像许多其他编程语言那样通过大括号来定义，而是通过 **空格缩进** 来区分。这听起来可能有些奇怪，但它是
    Python 可读性哲学的核心。让我们看看如何编写一个脚本来查找列表中的偶数：
- en: chapter02_basics_02.py
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: chapter02_basics_02.py
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_basics_02.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_basics_02.py)'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_basics_02.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_basics_02.py)'
- en: In this script, we define `numbers`, a list of numbers from 1 to 10, and `even`,
    an empty list that will contain the even numbers.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个脚本中，我们定义了 `numbers`，一个从 1 到 10 的数字列表，和 `even`，一个空列表，用于存储偶数。
- en: Then, we define a `for` loop statement to go through each element of `numbers`.
    As you see, we open a block with a colon, `:`, break a line, and start writing
    the next statement with an indentation.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义了一个 `for` 循环语句来遍历 `numbers` 中的每个元素。正如你所看到的，我们使用冒号 `:` 打开一个块，换行并开始在下一行写入语句，缩进一个级别。
- en: The next line is a conditional statement to check the parity of the current
    number. Once again, we open a block with a colon, `:`, and write the next statement
    with an additional indentation level. This statement adds the even number to the
    even list.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行是一个条件语句，用来检查当前数字的奇偶性。我们再次使用冒号 `:` 来打开一个代码块，并在下一行添加一个额外的缩进级别。这个语句将偶数添加到偶数列表中。
- en: After that, the next statements are not intended. This means that we are out
    of the `for` loop block; they should be executed after the iteration is finished.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，接下来的语句没有缩进。这意味着我们已经退出了 `for` 循环块；这些语句应该在迭代完成后执行。
- en: 'Let’s run it:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来运行一下：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Indentation style and size
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 缩进风格和大小
- en: You can choose the indentation style (tabs or spaces) and size (2, 4, 6...)
    you prefer; the only constraint is that you should be consistent *within* a block.
    However, by convention, Python developers usually go for a *four-space indentation*.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以选择你喜欢的缩进风格（制表符或空格）和大小（2、4、6 等），唯一的约束是你应该在一个代码块内保持一致性 *within*。然而，根据惯例，Python
    开发者通常使用 *四个空格的缩进*。
- en: This aspect of Python may sound weird but with some practice, you’ll find that
    it enforces clear formatting and greatly improves the readability of your scripts.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的这一特性可能听起来有些奇怪，但经过一些练习后，你会发现它能强制执行清晰的格式，并大大提高脚本的可读性。
- en: We’ll now review the built-in types and data structures.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将回顾一下内置类型和数据结构。
- en: Working with built-in types
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用内置类型
- en: 'Python is quite conventional regarding scalar types. There are six of them:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Python在标量类型方面相当传统。它有六种标量类型：
- en: '`int`, to store `x = 1`'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int`，用于存储`x = 1`'
- en: '`float`, for `x =` `1.5`'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`float`，表示`x =` `1.5`'
- en: '`complex`, for `x = 1 +` `2j`'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`complex`，表示`x = 1 +` `2j`'
- en: '`bool`, for `True` or `False`'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bool`，表示`True`或`False`'
- en: '`str`, for `x = "``abc"`'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`str`，表示`x = "``abc"`'
- en: '`NoneType`, to indicate `x =` `None`'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NoneType`，表示`x =` `None`'
- en: 'It’s worth noting that Python is `int` value and a `str` value will raise an
    error, as you can see in the following example:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，Python中的`int`值和`str`值相加会引发错误，正如你在下面的示例中所看到的：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Still, adding an `int` value and a `float` value will automatically upcast
    the result to `float`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 但仍然，添加一个`int`值和一个`float`值会自动将结果向上转型为`float`：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you may have noticed, Python is quite traditional regarding those standard
    types. Let’s see now how basic data structures are handled.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经注意到的，Python在这些标准类型方面相当传统。现在，让我们看看基本数据结构是如何处理的。
- en: Working with data structures – lists, tuples, dictionaries, and sets
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理数据结构——列表、元组、字典和集合
- en: 'Besides the scalar types, Python also provides handy data structures: an array
    structure, of course, called a *list* in Python, but also *tuples*, *dictionaries*,
    and *sets*, which are very convenient in lots of cases. Let’s start with lists.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 除了标量类型，Python还提供了方便的数据结构：一种数组结构，当然在Python中称为*列表*，但也有*元组*、*字典*和*集合*，这些在很多情况下都非常方便。我们从列表开始。
- en: Lists
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 列表
- en: 'Lists are the equivalent in Python of the classic array structure. Defining
    a list is quite straightforward:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 列表在Python中等同于经典的数组结构。定义一个列表非常简单：
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As you see, wrapping a suite of elements in **square brackets** denotes a list.
    You can, of course, access single elements by index:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，将一组元素包裹在**方括号**中表示一个列表。你当然可以通过索引访问单个元素：
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'It also supports `-1` index is the last element, `-2` is the second last element,
    and so on:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 它还支持`-1`索引表示最后一个元素，`-2`表示倒数第二个元素，以此类推：
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Another useful syntax is slicing, which quickly allows you to retrieve a sub-list:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的语法是切片，它可以快速地让你获取一个子列表：
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The first number is the start index (inclusive) and the second one is the end
    index (exclusive), separated by a colon. You can omit the first one; in this case,
    `0` is assumed:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个数字是起始索引（包含），第二个是结束索引（不包含），用冒号分隔。你可以省略第一个数字；在这种情况下，默认是`0`：
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You can also omit the second one; in this case, the length of the list is assumed:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以省略第二个数字；在这种情况下，默认使用列表的长度：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Finally, this syntax also supports a third argument to specify the step size.
    It can be useful to select every second element of the list:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这种语法还支持一个第三个参数来指定步长。它可以用于选择列表中的每第二个元素：
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'A useful trick with this syntax is to use `-1` to reverse the list:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种语法的一个有用技巧是使用`-1`来反转列表：
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Lists are **mutable**. This means that you can reassign elements or add new
    ones:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 列表是**可变的**。这意味着你可以重新赋值元素或添加新的元素：
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This is different from their cousins, the tuples, which are **immutable**.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这与它们的“表亲”元组不同，元组是**不可变的**。
- en: Tuples
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 元组
- en: 'Tuples are very similar to lists. Instead of square brackets, they are defined
    using parentheses:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 元组与列表非常相似。它们不是用方括号定义，而是使用圆括号：
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'They support the same syntax as lists to access elements or slicing:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 它们支持与列表相同的语法来访问元素或切片：
- en: '[PRE18]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'However, tuples are immutable. You can’t reassign elements or add new ones.
    Trying to do so will raise an error:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，元组是不可变的。你不能重新赋值元素或添加新的元素。尝试这样做会引发错误：
- en: '[PRE19]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'A common way to use them is for functions that have multiple return values.
    In the following example, we define a function to compute and return both the
    quotient and remainder of the Euclidean division:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的用法是将其用于返回多个值的函数。在下面的示例中，我们定义了一个函数来计算并返回欧几里得除法的商和余数：
- en: chapter02_basics_03.py
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: chapter02_basics_03.py
- en: '[PRE20]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_basics_03.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_basics_03.py)'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_basics_03.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_basics_03.py)'
- en: 'This function simply returns the quotient and remainder wrapped in a tuple.
    Let’s now compute the Euclidean division of `3` and `2`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数简单地返回商和余数，它们被包裹在一个元组中。现在我们来计算`3`和`2`的欧几里得除法：
- en: chapter02_basics_03.py
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: chapter02_basics_03.py
- en: '[PRE21]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_basics_03.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_basics_03.py)'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_basics_03.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_basics_03.py)'
- en: 'In this case, we assign the result to a tuple named `t` and simply retrieve
    the quotient and remainder *by index*. However, we can do something better than
    that. Let’s compute the Euclidean division of `42` and `4`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将结果赋值给一个名为`t`的元组，并通过索引*来提取商和余数*。然而，我们可以做得更好。让我们计算 `42` 和 `4` 的欧几里得除法：
- en: chapter02_basics_03.py
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: chapter02_basics_03.py
- en: '[PRE22]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_basics_03.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_basics_03.py)'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_basics_03.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_basics_03.py)'
- en: You can see here that we directly assign the quotient and remainder to the `q`
    and `r variables`, respectively. This syntax is called `t` is a tuple, it’s immutable,
    so you can’t reassign the values. On the other hand, `q` and `r` are new variables
    and therefore are mutable.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到我们直接将商和余数分别赋值给`q`和`r`变量。这种语法称为` t `是一个元组，它是不可变的，所以你不能重新赋值。而 `q` 和 `r` 是新的变量，因此是可变的。
- en: Dictionaries
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字典
- en: 'A dictionary is also a widely used data structure in Python, used to map keys
    to values. One is defined using curly braces, with a list of keys and values separated
    by a colon:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 字典是 Python 中也广泛使用的数据结构，用于将键映射到值。它是通过花括号定义的，其中键和值由冒号分隔：
- en: '[PRE23]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Elements can be accessed by key:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 元素可以通过键访问：
- en: '[PRE24]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Dictionaries are mutable, so you can reassign or add elements in the mapping:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 字典是可变的，因此你可以在映射中重新赋值或添加元素：
- en: '[PRE25]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Sets
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集合
- en: 'A set is a convenient data structure for storing a collection of unique items.
    It is defined using curly braces:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 集合是一个便捷的数据结构，用于存储唯一项的集合。它是通过花括号定义的：
- en: '[PRE26]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Elements can be added to the set, but the structure ensures elements appear
    only once:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 元素可以添加到集合中，但结构确保元素只出现一次：
- en: '[PRE27]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Convenient methods are also provided to perform operations such as unions or
    intersections on two sets:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 也提供了方便的方法来执行集合之间的并集或交集等操作：
- en: '[PRE28]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'That’s all for this overview of the Python data structures. You’ll probably
    use them quite often in your programs, so take some time to get acquainted with
    them. Obviously, we didn’t cover all of their methods and specificities, but you
    can have a look at the official Python documentation for exhaustive information:
    [https://docs.python.org/3/library/stdtypes.html](https://docs.python.org/3/library/stdtypes.html).'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是本节对 Python 数据结构的概述。你在程序中可能会频繁使用它们，所以花些时间熟悉它们。显然，我们没有涵盖它们的所有方法和特性，但你可以查看官方的
    Python 文档以获取详尽的信息：[https://docs.python.org/3/library/stdtypes.html](https://docs.python.org/3/library/stdtypes.html)。
- en: Let’s now talk about the different types of operators available in Python that
    will allow us to perform some logic on this data.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来谈谈 Python 中可用的不同类型的运算符，这些运算符允许我们对这些数据进行一些逻辑操作。
- en: Performing Boolean logic and a few other operators
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行布尔逻辑及其他几个运算符
- en: Predictably, Python provides operators to perform Boolean logic. However, we’ll
    also see that there are other operators that are less common but make Python a
    very efficient language to work with.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 可预测地，Python 提供了运算符来执行布尔逻辑。然而，我们也会看到一些不太常见但使得 Python 在工作中非常高效的运算符。
- en: Performing Boolean logic
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 执行布尔逻辑
- en: 'Boolean logic is performed with the `and`, `or`, and `not` keywords. Let’s
    review some simple examples:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔逻辑通过`and`、`or`和`not`关键字来执行。让我们回顾一些简单的例子：
- en: '[PRE29]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You’ll probably use them quite often in your programs, especially with conditional
    blocks. Let’s now review the identity operators.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会在程序中经常使用它们，尤其是在条件语句块中。现在让我们回顾一下身份运算符。
- en: Checking whether two variables are the same
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查两个变量是否相同
- en: The `is` and `is not` identity operators check whether two variables *refer*
    to the same object. This is different from the comparison operators, `==` and
    `!=`, which check whether two variables have the same *value*.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`is` 和 `is not` 身份运算符检查两个变量是否 *指向* 同一个对象。这与比较运算符 `==` 和 `!=` 不同，后者检查的是两个变量是否具有相同的
    *值*。'
- en: 'Internally, Python stores variables in pointers. The goal of the identity operators
    is thus to check whether two variables actually point to the same object in memory.
    Let’s review some examples:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 内部，变量是通过指针存储的。身份运算符的目标就是检查两个变量是否实际上指向内存中的同一个对象。让我们来看一些例子：
- en: '[PRE30]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Even though the `a` and `b` lists are identical, they’re not the same object
    in memory, so `a is b` is false. However, `a == b` is true. Let’s see what happens
    if we assign `a` to `b`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 即使 `a` 和 `b` 列表是相同的，它们在内存中并不是同一个对象，因此 `a is b` 为假。但是，`a == b` 为真。让我们看看如果将 `a`
    赋值给 `b` 会发生什么：
- en: '[PRE31]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In this case, the `b` variable will now refer to the same object as `a`, that
    is, the same list in memory. Thus, the identity operator is true.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`b` 变量将指向与 `a` 相同的对象，也就是内存中的同一列表。因此，身份运算符的结果为真。
- en: “is None” or “== None”?
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: “is None” 还是 “== None”？
- en: To check whether a variable is null, you could write `a == None`. While it will
    work most of the time, it’s generally advised to write `a` `is None`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查一个变量是否为 null，你可以写 `a == None`。虽然大多数时候它能工作，但通常建议写 `a is None`。
- en: Why? In Python, classes can implement custom comparison operators, so the result
    of `a == None` may be unpredictable in some cases, since a class can choose to
    attach a special meaning to the `None` value.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么？在 Python 中，类可以实现自定义的比较运算符，因此 `a == None` 的结果在某些情况下可能是不可预测的，因为类可以选择为 `None`
    值附加特殊含义。
- en: We’ll now review the membership operators.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来回顾一下成员运算符。
- en: Checking whether a value is present in a data structure
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查数据结构中是否存在某个值
- en: 'The membership operators, `in` and `not in`, are very useful for checking whether
    an element is present in data structures such as lists or dictionaries. They are
    idiomatic in Python and make this operation very efficient and easy to write.
    Let’s review some examples:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 成员运算符，`in` 和 `not in`，对于检查元素是否存在于诸如列表或字典等数据结构中非常有用。它们在 Python 中是惯用的，使得该操作非常高效且易于编写。让我们来看一些例子：
- en: '[PRE32]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'With the membership operators, we can check in one statement whether an element
    is present or not in a list. It also works with tuples and sets:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 使用成员运算符，我们可以通过一个语句检查元素是否存在于列表中。它也适用于元组和集合：
- en: '[PRE33]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Finally, it also works with dictionaries. In this case, the membership operators
    check whether the *key* is present, not the value:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，它同样适用于字典。在这种情况下，成员运算符检查的是 *键* 是否存在，而不是值：
- en: '[PRE34]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We are now clear about those common operations. We’ll now put them to use with
    conditional statements.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经清楚了这些常见的操作。接下来，我们将通过条件语句来实际应用它们。
- en: Controlling the flow of a program
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制程序的流程
- en: A programming language would not be a programming language without its control
    flow statements. Once again, you’ll see that Python is a bit different from other
    languages. Let’s start with conditional statements.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 没有控制流语句，一个编程语言就不算是一个编程语言了。再次提醒你，Python 在这方面与其他语言有所不同。我们从条件语句开始。
- en: Executing operations conditionally – if, elif, and else
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 有条件地执行操作 – if, elif 和 else
- en: 'Classically, these statements are here for performing some logic based on some
    Boolean conditions. In the following example, we’ll consider a situation where
    we have a dictionary containing information about an e-commerce website order.
    We’ll write a function that will change the order status to the next step given
    the current status:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，这些语句用于根据布尔条件执行一些逻辑。在下面的例子中，我们将考虑一个包含电子商务网站订单信息的字典。我们将编写一个函数，基于当前状态将订单状态更新为下一个步骤：
- en: chapter02_basics_04.py
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: chapter02_basics_04.py
- en: '[PRE35]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_basics_04.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_basics_04.py)'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_basics_04.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_basics_04.py)'
- en: The first condition is noted as `if`, followed by a Boolean condition. We then
    open an indented block, as we explained in the *Indentation matters* section of
    this chapter.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个条件用 `if` 来表示，后跟一个布尔条件。然后我们打开一个缩进块，正如我们在本章的 *缩进很重要* 部分所解释的那样。
- en: The alternate conditions are noted as `elif` (not `else if`) and the fallback
    block is noted as `else`. Of course, those are *optional* if you don’t need alternate
    or fallback conditions.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 替代条件被标记为`elif`（而不是`else if`），回退块被标记为`else`。当然，如果你不需要替代条件或回退条件，这些都是*可选*的。
- en: It’s also worth noting that, contrary to many other languages, Python does not
    provide a `switch` statement.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 另外值得注意的是，与许多其他语言不同，Python没有提供`switch`语句。
- en: Repeating operations over an iterator – the for loop statement
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在一个迭代器上重复操作——`for`循环语句
- en: 'We’ll now move on to another classic control flow statement: the `for` loop.
    You can repeat operations over a sequence using the `for` loop statement.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将讨论另一个经典的控制流语句：`for`循环。你可以使用`for`循环语句在一个序列上重复操作。
- en: We already saw an example of the `for` loop in action in the *Indentation matters*
    section of this chapter. As you probably understood, this statement is useful
    for repeating the execution of a code block.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在本章的*缩进很重要*部分看到了`for`循环的示例。如你所理解的，这条语句对于重复执行代码块非常有用。
- en: 'You also may have noticed that it works a bit differently from other languages.
    Usually, programming languages define `for` loops like this: `for (i = 0; i <=
    10; i++)`. They give you the responsibility to define and control the variable
    used for the iteration.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能也已经注意到它的工作方式与其他语言有些不同。通常，编程语言会像这样定义`for`循环：`for (i = 0; i <= 10; i++)`。它们让你负责定义和控制用于迭代的变量。
- en: 'Python doesn’t work this way. Instead, it expects you to feed the loop with
    an `for` loop. Let’s see some examples:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Python不是这样工作的。相反，它希望你将一个`for`循环提供给循环体。让我们看几个例子：
- en: '[PRE36]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'But what if you just wish to iterate a certain number of times? Thankfully,
    Python has built-in functions that generate some useful iterators. The most well
    known is `range`, which precisely creates a sequence of numbers. Let’s see how
    it works:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果你只想迭代某个特定次数怎么办？幸运的是，Python内置了生成一些有用迭代器的函数。最著名的就是`range`，它精确地创建了一个数字序列。让我们看看它是如何工作的：
- en: '[PRE37]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '`range` will generate a sequence of the size you provided in the first argument,
    starting with zero.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`range`将根据你在第一个参数中提供的大小生成一个序列，从零开始。'
- en: 'You could also be more precise by specifying two arguments: the start index
    (inclusive) and the last index (exclusive):'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过指定两个参数来更精确地控制：起始索引（包含）和最后索引（不包含）：
- en: '[PRE38]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Finally, you may even provide a step as a third argument:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你甚至可以提供一个步长作为第三个参数：
- en: '[PRE39]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Note that this syntax is quite similar to the slicing syntax we saw earlier
    in this chapter in the sections dedicated to *lists* and *tuples*.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这种语法与我们之前在本章中*列表*和*元组*部分看到的切片语法非常相似。
- en: range output is not a list
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`range`输出不是一个列表'
- en: 'A common misconception is to think `range` returns a *list*. It’s actually
    a `Sequence` object that only stores the *start*, *end*, and *step* arguments.
    That’s why you could write `range(1000000000)` without blowing up your system’s
    memory: the billions of elements are not assigned to memory all at once.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的误解是认为`range`返回一个*列表*。实际上，它是一个`Sequence`对象，仅存储*开始*、*结束*和*步长*参数。这就是为什么你可以写`range(1000000000)`而不会让你的系统内存崩溃：数十亿个元素并不会一次性分配到内存中。
- en: As you see, the `for` loop syntax in Python is quite straightforward to understand
    and emphasizes readability. We’ll now have a word about its cousin, the `while`
    loop.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，Python中的`for`循环语法相当简单易懂，并且强调可读性。接下来我们将讨论它的“亲戚”——`while`循环。
- en: Repeating operations until a condition is met – the while loop statement
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重复操作直到满足条件——`while`循环语句
- en: 'The classical `while` loop is also available in Python. At the risk of disappointing
    you, there is nothing truly special about this one. Classically, this statement
    allows you to repeat instructions until a condition is met. We’ll review an example
    in which we use a `while` loop to retrieve paginated elements until we reach the
    end:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 经典的`while`循环在Python中也可以使用。冒昧地说，这个语句并没有什么特别的地方。传统上，这个语句允许你重复执行指令直到满足条件。我们将回顾一个示例，其中我们使用`while`循环来获取分页元素直到我们到达结束：
- en: chapter02_basics_05.py
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: chapter02_basics_05.py
- en: '[PRE40]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_basics_05.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_basics_05.py)'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_basics_05.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_basics_05.py)'
- en: The `retrieve_page` function is a dummy function that returns a dictionary with
    the items for the page passed in an argument and the next page number or `None`
    if we reached the last page. *A priori*, we don’t know how many pages there are.
    Thus, we repeatedly call `retrieve_page` until the page is `None`. At each iteration,
    we save the current page items in an accumulator, `items`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`retrieve_page`函数是一个虚拟函数，它返回一个字典，其中包含传递给它的页面的项目以及下一页的页码，或者如果到达最后一页则返回`None`。*A
    priori*，我们并不知道有多少页。因此，我们反复调用`retrieve_page`，直到页面是`None`。在每次迭代中，我们将当前页面的项目保存到累加器`items`中。'
- en: This kind of use case is quite common when you are dealing with third-party
    REST APIs and you wish to retrieve all items available, and `while` loops perfectly
    help with this.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当你处理第三方REST API并希望检索所有可用项目时，这种使用场景非常常见，`while` 循环对此非常有帮助。
- en: Finally, there are cases where you wish to prematurely end the loop or skip
    an iteration. To solve this, Python implements the classic `break` and `continue`
    statements.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，有一些情况下你希望提前结束循环或跳过某次迭代。为了解决这个问题，Python实现了经典的`break`和`continue`语句。
- en: Defining functions
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义函数
- en: Now that we know how to use the common operators and control the flow of our
    program, let’s put it in reusable logic. As you may have guessed, we’ll look at
    **functions** and how to define them. We already saw them in some of our previous
    examples, but let’s introduce them more formally.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何使用常见的运算符并控制程序的流程，让我们将它放入可重用的逻辑中。正如你可能已经猜到的，我们将学习**函数**以及如何定义它们。我们在之前的一些例子中已经看到了它们，但让我们更正式地介绍它们。
- en: 'In Python, functions are defined using the `def` keyword followed by the name
    of the function. Then, you have the list of supported arguments in parentheses,
    before a colon that indicates the start of the function body. Let’s see a simple
    example:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，函数是通过`def`关键字定义的，后面跟着函数的名称。然后，你会看到在括号中列出支持的参数，在冒号后面是函数体的开始。我们来看一个简单的例子：
- en: '[PRE41]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'That’s it! Python also supports default values on arguments:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！Python 也支持为参数设置默认值：
- en: '[PRE42]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'When calling a function, you can specify the value of arguments using their
    name:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 调用函数时，你可以通过参数的名称指定参数的值：
- en: '[PRE43]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Those arguments are called *keyword arguments*. They are especially useful
    if you have several default arguments but only wish to set one of them:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这些参数被称为*关键字参数*。如果你有多个默认参数，但只希望设置其中一个，它们特别有用：
- en: '[PRE44]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Function naming
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 函数命名
- en: By convention, functions should be named using `my_wonderful_function` but not
    `MyWonderfulFunction`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 按约定，函数应该使用`my_wonderful_function`这种格式命名，而不是`MyWonderfulFunction`。
- en: But there is more! You can actually define functions accepting a dynamic number
    of arguments.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 但不仅如此！实际上，你可以定义接受动态数量参数的函数。
- en: Accepting arguments dynamically with *args and **kwargs
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动态接受参数的*args和**kwargs
- en: 'Sometimes, you may need a function that supports a dynamic number of arguments.
    Those arguments are then handled in your function logic at runtime. To do this,
    you have to use the `*args` and `**kwargs` syntax. Let’s define a function that
    uses this syntax and prints the value of those arguments:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能需要一个支持动态数量参数的函数。这些参数会在运行时在你的函数逻辑中处理。为了做到这一点，你必须使用`*args`和`**kwargs`语法。让我们定义一个使用这种语法的函数，并打印这些参数的值：
- en: '[PRE45]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: As you can see, standard arguments are placed in a *tuple*, in the same order
    as they were called. Keyword arguments, on the other hand, have been placed in
    a *dictionary*, with the key being the name of the argument. It’s up to you then
    to use this data to perform your logic!
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，标准参数被放置在一个*元组*中，顺序与它们被调用时的顺序相同。另一方面，关键字参数被放置在一个*字典*中，键是参数的名称。然后由你来使用这些数据来执行你的逻辑！
- en: 'Interestingly, you can mix both approaches so that you have hardcoded arguments
    and dynamic ones:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，你可以将这两种方法混合使用，以便同时拥有硬编码参数和动态参数：
- en: '[PRE46]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Well done! You have learned how to write functions in Python to organize the
    logic of your program. The next step now is to organize those functions into modules
    and import them into other modules to take advantage of them!
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 做得好！你已经学会了如何在Python中编写函数来组织程序的逻辑。接下来的步骤是将这些函数组织到模块中，并将它们导入到其他模块中以便使用！
- en: Writing and using packages and modules
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写和使用包与模块
- en: You probably already know that, apart from small scripts, your source code shouldn’t
    live in one big file with thousands of lines. Instead, you should split it into
    logical blocks of reasonable size that are easy to maintain. That’s exactly what
    packages and modules are for! We’ll see how they work and how you can define your
    own.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经知道，除了小脚本之外，你的源代码不应该存放在一个包含成千上万行的大文件中。相反，你应该将它拆分成逻辑上合理且易于维护的块。这正是包和模块的用途！我们将看看它们是如何工作的，以及你如何定义自己的模块。
- en: 'First of all, Python comes with its own set of modules, the standard library,
    which are directly importable in a program:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，Python 提供了一组自己的模块——标准库，这些模块可以直接在程序中导入：
- en: '[PRE47]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'With just the `import` keyword, you can use the `datetime` module and access
    all its content by referring to its namespace, `datetime.date`, which is the built-in
    class to work with dates. However, you may sometimes wish to explicitly import
    a part of this module:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 仅使用`import`关键字，你就可以使用`datetime`模块，并通过引用其命名空间`datetime.date`来访问其所有内容，`datetime.date`是用于处理日期的内置类。然而，你有时可能希望显式地导入该模块的一部分：
- en: '[PRE48]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Here, we explicitly import the `date` class to use it directly. The same principles
    apply to third-party packages installed with `pip`, such as FastAPI.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们显式地导入了`date`类以直接使用它。相同的原则也适用于通过`pip`安装的第三方包，例如 FastAPI。
- en: 'Using existing packages and modules is nice but writing your own is even better.
    In Python, a **module** is a single file containing declarations but can also
    contain instructions that will be executed when the module is first imported.
    You’ll find the definition of a very simple module in the following example:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 使用现有的包和模块很方便，但编写自己的模块更好。在 Python 中，**模块**是一个包含声明的单个文件，但也可以包含在首次导入模块时执行的指令。你可以在以下示例中找到一个非常简单模块的定义：
- en: chapter02_basics_module.py
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: chapter02_basics_module.py
- en: '[PRE49]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_basics_module.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_basics_module.py)'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_basics_module.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_basics_module.py)'
- en: 'This module only contains a function, `module_function`, and a `print` statement.
    Create a file containing this code at the root of your project directory and name
    it `module.py`. Then, open a Python interpreter and run this command:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模块只包含一个函数`module_function`和一个`print`语句。在你的项目根目录下创建一个包含该代码的文件，并将其命名为`module.py`。然后，打开一个
    Python 解释器并运行以下命令：
- en: '[PRE50]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Notice that the `print` statement was executed when you imported it. You can
    now use the function:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`print`语句在导入时已经执行。现在你可以使用该函数了：
- en: '[PRE51]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Congratulations! You’ve just written your first Python module!
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你刚刚编写了你的第一个 Python 模块！
- en: Now, let’s see how to structure a **package**. A package is a way to organize
    modules in a hierarchy, which you can then import using their namespace.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下如何构建一个**包**。包是将模块组织在层次结构中的一种方式，你可以通过它们的命名空间导入这些模块。
- en: 'At the root of your project, create a directory named `package`. Inside, create
    another directory named `subpackage` and move `module.py` into it. Your project
    structure should look like the one shown in *Figure 2**.1*:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的项目根目录下，创建一个名为`package`的目录。在其中，再创建一个名为`subpackage`的目录，并将`module.py`移入该目录。你的项目结构应该像*图
    2.1*所示：
- en: '![Figure 2.1 – Python package sample hierarchy](img/Figure_2.1_B19528.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.1 – Python 包示例层次结构](img/Figure_2.1_B19528.jpg)'
- en: Figure 2.1 – Python package sample hierarchy
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1 – Python 包示例层次结构
- en: 'You can then import your module using the full namespace:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以使用完整的命名空间导入你的模块：
- en: '[PRE52]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'It works! However, to define a proper Python package, it’s *strongly recommended*
    to create an empty `__init__.py` file at the root of each package and sub-package.
    In older Python versions, it was compulsory to make a package recognizable by
    the interpreter. This became optional in more recent versions, but there are actually
    some subtle differences between a package with an `__init__.py` file (a package)
    and one without (a **namespace package**). We won’t explain it further in this
    book, but you could check the documentation about namespace packages here if you
    wish to learn more details: [https://packaging.python.org/en/latest/guides/packaging-namespace-packages/](https://packaging.python.org/en/latest/guides/packaging-namespace-packages/).'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 它有效！然而，为了定义一个合适的Python包，*强烈推荐*在每个包和子包的根目录下创建一个空的`__init__.py`文件。在旧版本的Python中，必须创建该文件才能让解释器识别一个包。在较新的版本中，这已变为可选项，但带有`__init__.py`文件的包（一个包）和没有该文件的包（一个**命名空间包**）之间实际上存在一些微妙的区别。我们在本书中不会进一步解释这个问题，但如果你希望了解更多细节，可以查阅关于命名空间包的文档：[https://packaging.python.org/en/latest/guides/packaging-namespace-packages/](https://packaging.python.org/en/latest/guides/packaging-namespace-packages/)。
- en: 'Therefore, you generally always should create `__init__.py` files. In our example,
    our project structure would finally look like this:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你通常应该始终创建`__init__.py`文件。在我们的示例中，最终的项目结构应该如下所示：
- en: '![Figure 2.2 – Python package hierarchy with __init__.py files](img/Figure_2.2_B19528.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.2 – 带有`__init__.py`文件的Python包层次结构](img/Figure_2.2_B19528.jpg)'
- en: Figure 2.2 – Python package hierarchy with __init__.py files
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2 – 带有`__init__.py`文件的Python包层次结构
- en: It’s worth noting that even if empty `__init__.py` files are perfectly fine,
    you can actually write some code in them. In this case, it is executed the first
    time you import the package or one of its sub-modules. It’s useful to perform
    some initialization logic for your package. You now have a good overview of how
    to write some Python code. Feel free to write some small scripts to get acquainted
    with its peculiar syntax. We’ll now explore more advanced topics about the language
    that will prove useful during our journey with FastAPI.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，即使是空的`__init__.py`文件也是完全可以的，实际上你也可以在其中编写一些代码。在这种情况下，当你第一次导入该包或其子模块时，这些代码会被执行。这对于执行一些包的初始化逻辑非常有用。现在你已经对如何编写一些Python代码有了很好的概览。可以自由编写一些小脚本来熟悉它独特的语法。接下来我们将探讨一些关于语言的高级话题，这些将对我们在FastAPI之旅中的学习大有裨益。
- en: Operating over sequences – list comprehensions and generators
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在序列上操作 – 列表推导式和生成器
- en: 'In this section, we’ll cover what are probably the most idiomatic constructions
    in Python: list comprehensions and generators. You’ll see that they are very useful
    for reading and transforming sequences of data with minimal syntax.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍可能是Python中最具典型性的构造：列表推导式和生成器。你将看到，它们对于用最简洁的语法读取和转换数据序列非常有用。
- en: List comprehensions
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列表推导式
- en: 'In programming, a very common task is to transform a sequence (let’s say, a
    *list*) into another, for example, to filter out or transform elements. Usually,
    you would write such an operation as we did in one of the previous examples of
    this chapter:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程中，一个非常常见的任务是将一个序列（比如说，*列表*）转换成另一个序列，例如，过滤或转换元素。通常，你会像我们在本章之前的示例中那样编写这样的操作：
- en: chapter02_basics_02.py
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: chapter02_basics_02.py
- en: '[PRE53]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_basics_02.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_basics_02.py)'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_basics_02.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_basics_02.py)'
- en: With this approach, we simply iterate over each element, check a condition,
    and add the element in an accumulator if it passes this condition.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，我们简单地遍历每个元素，检查条件，并在元素满足条件时将其添加到累加器中。
- en: 'To go further in its readability philosophy, Python supports a neat syntax
    to perform this operation in only one statement: **list comprehensions**. Let’s
    see what our previous example looks like with this syntax:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步提升可读性，Python支持一种简洁的语法，使得只用一句话就能执行这个操作：**列表推导式**。让我们看看之前的示例在这种语法下的样子：
- en: chapter02_list_comprehensions_01.py
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: chapter02_list_comprehensions_01.py
- en: '[PRE54]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_list_comprehensions_01.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_list_comprehensions_01.py)'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_list_comprehensions_01.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_list_comprehensions_01.py)'
- en: That’s it! Basically, a list comprehension works by *packing* a `for` loop and
    wrapping it with square brackets. The element to add to the result list appears
    first, followed by the iteration. Optionally, we can add a condition, as we did
    here, to filter some elements of the list input.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！基本上，列表推导式通过*打包*一个`for`循环并将其用方括号包裹来工作。要添加到结果列表的元素出现在前面，然后是迭代。我们可以选择性地添加一个条件，就像这里一样，用来筛选列表输入中的一些元素。
- en: 'Actually, the result element can be any valid Python expression. In the following
    example, we use the `randint` function of the `random` standard module to generate
    a list of random integers:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，结果元素可以是任何有效的 Python 表达式。在下面的示例中，我们使用`random`标准模块的`randint`函数生成一个随机整数列表：
- en: chapter02_list_comprehensions_02.py
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: chapter02_list_comprehensions_02.py
- en: '[PRE55]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_list_comprehensions_02.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_list_comprehensions_02.py)'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_list_comprehensions_02.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_list_comprehensions_02.py)'
- en: 'This syntax is widely used by Python programmers and you’ll probably grow quite
    fond of it. The nice thing about this syntax is that it also works for *sets*
    and *dictionaries*. Quite simply, just replace the square brackets with curly
    braces to generate a set:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这种语法在 Python 程序员中被广泛使用，你可能会非常喜欢它。这个语法的好处在于它也适用于*集合*和*字典*。很简单，只需将方括号替换为大括号即可生成集合：
- en: chapter02_list_comprehensions_03.py
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: chapter02_list_comprehensions_03.py
- en: '[PRE56]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_list_comprehensions_03.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_list_comprehensions_03.py)'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_list_comprehensions_03.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_list_comprehensions_03.py)'
- en: 'To create a dictionary, specify both the key and the value separated by a colon:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个字典，指定键和值，并用冒号分隔：
- en: chapter02_list_comprehensions_04.py
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: chapter02_list_comprehensions_04.py
- en: '[PRE57]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_list_comprehensions_04.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_list_comprehensions_04.py)eee'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_list_comprehensions_04.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_list_comprehensions_04.py)eee'
- en: Generators
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成器
- en: You might think that if you replace the square brackets with parentheses, you
    could obtain a tuple. Actually, you get a **generator** object. The main difference
    between generators and list comprehensions is that elements are generated *on
    demand* and not computed and stored all at once in memory. You could see a generator
    as a recipe to generate values.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能认为，如果用圆括号替换方括号，你可以得到一个元组。实际上，你会得到一个**生成器**对象。生成器和列表推导式之间的主要区别在于，生成器的元素是*按需生成*的，而不是一次性计算并存储在内存中的。你可以把生成器看作是生成值的食谱。
- en: 'As we said, a generator can be defined simply by using the same syntax as list
    comprehensions, with parentheses:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所说，生成器可以通过使用与列表推导式相同的语法，并加上圆括号来定义：
- en: chapter02_list_comprehensions_05.py
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: chapter02_list_comprehensions_05.py
- en: '[PRE58]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_list_comprehensions_05.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_list_comprehensions_05.py)'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_list_comprehensions_05.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_list_comprehensions_05.py)'
- en: In this example, we define `even_generator` to output the even number of the
    `numbers` list. Then, we call the `list` constructor with this generator and assign
    it to the variable named `even`. This constructor will exhaust the iterator passed
    in the argument and build a proper list. We do it a second time and assign it
    to `even_bis`.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们定义了`even_generator`来输出`numbers`列表中的偶数。然后，我们使用这个生成器调用`list`构造函数，并将其赋值给名为`even`的变量。这个构造函数会耗尽传入参数的迭代器，并构建一个正确的列表。我们再执行一次，并将其赋值给`even_bis`。
- en: As you can see, `even` is a list with all the even numbers. However, `even_bis`
    is an *empty* list. This simple example is here to show you that a generator can
    be used *only once*. Once all the values have been produced, it’s over.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`even`是一个包含所有偶数的列表。然而，`even_bis`是一个*空*列表。这个简单的例子是为了向你展示生成器只能*使用一次*。一旦所有值都生成完毕，生成器就结束了。
- en: This can be useful because you can start to iterate on the generator, stop to
    do something else, and resume iterating.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常有用，因为你可以开始迭代生成器，暂停去做其他事情，然后再继续迭代。
- en: 'Another way to create generators is to define `2` to the limit passed in an
    argument:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 创建生成器的另一种方式是通过定义`2`作为传入参数的限制：
- en: chapter02_list_comprehensions_06.py
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: chapter02_list_comprehensions_06.py
- en: '[PRE59]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_list_comprehensions_06.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_list_comprehensions_06.py)'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_list_comprehensions_06.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_list_comprehensions_06.py)'
- en: As you can see in this function, we use the `yield` keyword instead of `return`.
    When the interpreter reaches this statement, it *pauses* the function execution
    and *yields* the value to the generator consumer. When the main program asks for
    another value, the function is resumed in order to yield again.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在这个函数中看到的，我们使用了`yield`关键字代替了`return`。当解释器执行到这个语句时，它会*暂停*函数的执行，并将值*传递*给生成器的消费者。当主程序请求另一个值时，函数会恢复执行以便再次生成值。
- en: 'This allows us to implement complex generators, even ones that will output
    different types of values over their course. Another interesting property of generator
    functions is that they allow us to execute some instructions when they have finished
    generating values. Let’s add a `print` statement at the end of the function we
    just reviewed:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够实现复杂的生成器，甚至是那些在生成过程中会输出不同类型值的生成器。生成器函数的另一个有趣的特性是，它们允许我们在生成完所有值之后执行一些指令。让我们在刚刚复习过的函数末尾添加一个`print`语句：
- en: chapter02_list_comprehensions_07.py
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: chapter02_list_comprehensions_07.py
- en: '[PRE60]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_list_comprehensions_07.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_list_comprehensions_07.py)'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_list_comprehensions_07.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_list_comprehensions_07.py)'
- en: 'If you execute it in a Python interpreter, you’ll get this output:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在Python解释器中执行它，你将得到以下输出：
- en: '[PRE61]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: We get `Generator exhausted` in the output, which means that our code *after*
    the last `yield` statement is well executed.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在输出中看到`Generator exhausted`，这意味着我们的代码在最后一个`yield`语句之后已经正确执行。
- en: 'This is especially useful when you want to perform some *cleanup operations*
    after your generator has been exhausted: close a connection, remove temporary
    files, and so on.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这特别有用，当你想在生成器耗尽后执行一些*清理操作*时：关闭连接、删除临时文件等等。
- en: Writing object-oriented programs
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写面向对象的程序
- en: As we said in the first section of this chapter, Python is a multi-paradigm
    language, and one of those paradigms is **object-oriented programming**. In this
    section, we’ll review how you can define classes and how you can instantiate and
    use objects. You’ll see that Python syntax is once again very lightweight.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章的第一部分所说，Python 是一种多范式语言，其中一个范式是 **面向对象编程**。在这一部分，我们将回顾如何定义类，以及如何实例化和使用对象。你会发现
    Python 的语法再次是非常简洁的。
- en: Defining a class
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义类
- en: 'Defining a class in Python is straightforward: use the `class` keyword, type
    the name of your class, and begin a new block. You can then define methods under
    it just like you would for regular functions. Let’s review an example:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中定义一个类非常简单：使用 `class` 关键字，输入类名，然后开始一个新块。你可以像定义普通函数一样在其下定义方法。让我们来看一个例子：
- en: chapter02_classes_objects_01.py
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: chapter02_classes_objects_01.py
- en: '[PRE62]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_classes_objects_01.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_classes_objects_01.py)'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_classes_objects_01.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_classes_objects_01.py)'
- en: Notice that the first argument of each method must be `self`, which is a reference
    to the current object instance (the equivalent of `this` in other languages).
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，每个方法的第一个参数必须是 `self`，它是当前对象实例的引用（相当于其他语言中的 `this`）。
- en: To instantiate a class, simply call the class as you would for a function and
    assign it to a variable. You can then access the methods using dot notation.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 要实例化一个类，只需像调用函数一样调用类，并将其赋值给一个变量。然后，你可以通过点表示法访问方法。
- en: Class and method naming
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 类和方法命名
- en: By convention, classes should be named using `MyWonderfulClass` but not `my_wonderful_class`.
    Methods should use snake case, like regular functions.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，类名应使用 `MyWonderfulClass` 而不是 `my_wonderful_class`。方法名应使用蛇形命名法，就像普通函数一样。
- en: 'Obviously, you can also set `__init__` method, whose goal is to initialize
    values:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，你也可以设置 `__init__` 方法，其目标是初始化值：
- en: chapter02_classes_objects_02.py
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: chapter02_classes_objects_02.py
- en: '[PRE63]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_classes_objects_02.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_classes_objects_02.py)'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_classes_objects_02.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_classes_objects_02.py)'
- en: In this example, `__init__` allows us to set a `default_name` property, which
    will be used by the `greet` method if no name is provided in the argument. As
    you can see, you can simply access this property through dot notation.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`__init__` 允许我们设置一个 `default_name` 属性，如果在参数中没有提供名称，`greet` 方法将使用该属性。如你所见，你可以通过点表示法轻松访问这个属性。
- en: 'Be careful though: `__init__` is not a constructor. In typical object-oriented
    languages, a constructor is a method to actually create the object in memory.
    In Python, when `__ init__` is called, the object is already created in memory
    (notice we have access to the `self` instance). Actually, there is a method to
    define the constructor, `__new__`, but it’s rarely used in common Python programs.'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 不过要小心：`__init__` 并不是构造函数。在典型的面向对象语言中，构造函数是用于实际在内存中创建对象的方法。在 Python 中，当 `__init__`
    被调用时，对象已经在内存中创建（请注意我们可以访问 `self` 实例）。实际上，确实有一个方法用于定义构造函数，`__new__`，但在常见的 Python
    程序中它很少被使用。
- en: Private methods and properties
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 私有方法和属性
- en: 'In Python, there is no such thing as *private* methods or properties. Everything
    will always be accessible from the outside. However, by convention, you can prefix
    your private methods and properties with an underscore to *suggest* that they
    should be considered private: `_private_method`.'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，并不存在 *私有* 方法或属性的概念。一切都可以从外部访问。然而，按照惯例，你可以通过在私有方法和属性前加下划线来 *表示* 它们应该被视为私有：`_private_method`。
- en: You now have the basics of object-oriented programming in Python! We’ll now
    focus on magic methods, which will allow us to do clever things with objects.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经掌握了 Python 中面向对象编程的基础！接下来我们将重点讲解魔法方法，它们可以让我们对对象做一些巧妙的操作。
- en: Implementing magic methods
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现魔法方法
- en: 'Magic methods are a set of predefined methods that bear a special meaning in
    the language. They are easy to recognize as they start and end with two underscores.
    Actually, we already saw one of those magic methods: `__init__`! Those methods
    are not called directly but are used by the interpreter when using other constructs
    such as standard functions or operators.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 魔法方法是一组在语言中具有特殊意义的预定义方法。它们很容易识别，因为它们的名称前后都有两个下划线。事实上，我们已经见过其中一个魔法方法：`__init__`！这些方法不是直接调用的，而是由解释器在使用其他构造函数，如标准函数或操作符时调用。
- en: To understand how they are useful, we’ll review the most used ones. Let’s start
    with `__repr__` and `__str__`.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解它们的作用，我们将回顾最常用的方法。我们从`__repr__`和`__str__`开始。
- en: Object representations – __repr__ and __str__
  id: totrans-298
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对象表示 —— __repr__和__str__
- en: 'When you define a class, it’s generally useful to be able to get a readable
    and clear string representation of an instance. For this purpose, Python provides
    two magic methods: `__repr__` and `__str__`. Let’s see how they work on a class
    representing a temperature in either degrees Celsius or degrees Fahrenheit:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 当你定义一个类时，通常需要能够获得一个实例的可读且清晰的字符串表示。为此，Python提供了两个魔法方法：`__repr__`和`__str__`。让我们看看它们如何在表示摄氏度或华氏度温度的类中工作：
- en: chapter02_classes_objects_03.py
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: chapter02_classes_objects_03.py
- en: '[PRE64]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_classes_objects_03.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_classes_objects_03.py)'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_classes_objects_03.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_classes_objects_03.py)'
- en: 'If you run this example, you’ll notice that `print(t)` prints the same thing
    as `print(str(t))`. Through `print`, the interpreter called the `__str__` method
    to get the string representation of our object. This is what `__str__` is for:
    giving a *nice string representation* of an object for the end user.'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行这个示例，你会注意到`print(t)`和`print(str(t))`打印的内容是一样的。通过`print`，解释器调用了`__str__`方法来获取我们对象的字符串表示。这就是`__str__`的作用：提供一个*优雅的字符串表示*，供最终用户使用。
- en: On the other hand, you saw that even though they’re very similar, we implemented
    `__repr__` in a different way. The purpose of this method is to give an *internal
    representation* of the object that is unambiguous. By convention, this should
    give the exact statement that would allow us to recreate the very same object.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，你会看到，尽管它们非常相似，我们实现了`__repr__`的方式却有所不同。这个方法的目的是给出对象的*内部表示*，并且它是唯一明确的。按照约定，这应该给出一个准确的语句，允许我们重建出完全相同的对象。
- en: Now that we can represent temperatures with our class, what would happen if
    we tried to compare them?
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经可以用我们的类来表示温度，那么如果我们尝试比较它们，会发生什么呢？
- en: Comparison methods – __eq__, __gt__, __lt__, and so on
  id: totrans-306
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 比较方法 —— __eq__、__gt__、__lt__，等等
- en: 'Of course, comparing two temperatures with different units would lead to unexpected
    results. Fortunately, magic methods allow us to overload the default operators
    to perform meaningful comparisons. Let’s expand on our previous example:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，比较不同单位的温度会导致意外的结果。幸运的是，魔法方法允许我们重载默认的操作符，以便进行有意义的比较。让我们扩展一下之前的例子：
- en: chapter02_classes_objects_04.py
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: chapter02_classes_objects_04.py
- en: '[PRE65]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_classes_objects_04.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_classes_objects_04.py)'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_classes_objects_04.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_classes_objects_04.py)'
- en: 'In the `__init__` method, we convert the temperature value into Kelvin given
    the current scale. This will help us to make comparisons. Then, let’s define `__eq__`
    and `__lt__`:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在`__init__`方法中，我们根据当前的单位将温度值转换为开尔文温标。这将帮助我们进行比较。接下来，我们定义`__eq__`和`__lt__`：
- en: chapter02_classes_objects_04.py
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: chapter02_classes_objects_04.py
- en: '[PRE66]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_classes_objects_04.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_classes_objects_04.py)'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_classes_objects_04.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_classes_objects_04.py)'
- en: 'As you can see, those methods simply accept another argument, which is the
    other object instance to compare with. We then just have to perform our comparison
    logic. By doing this, we can perform comparison just as we would for any variable:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这些方法只是接受另一个参数，即要与之比较的另一个对象实例。然后我们只需要执行比较逻辑。通过这样做，我们可以像处理任何变量一样进行比较：
- en: chapter02_classes_objects_04.py
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: chapter02_classes_objects_04.py
- en: '[PRE67]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_classes_objects_04.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_classes_objects_04.py)'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_classes_objects_04.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_classes_objects_04.py)'
- en: 'That’s it! If you wish to have all the comparison operators available, you
    should also implement all the other comparison magic methods: `__le__`, `__gt__`,
    and `__ge__`.'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！如果你希望所有比较操作符都可用，你还应该实现所有其他的比较魔法方法：`__le__`、`__gt__` 和 `__ge__`。
- en: The type of the other instance is not guaranteed
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个实例的类型无法保证
- en: In this example, we assumed the `other` variable was also a `Temperature` object.
    In the real world, however, this is not guaranteed and developers could try to
    compare `Temperature` with another object, which would likely lead to errors or
    weird behaviors. To prevent this, you should check the type of the `other` variable
    using `isinstance` to ensure we handle `Temperature`, or raise a proper exception
    otherwise.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们假设 `other` 变量也是一个 `Temperature` 对象。然而，在现实中，这并不能保证，开发者可能会尝试将 `Temperature`
    与另一个对象进行比较，这可能导致错误或异常行为。为避免这种情况，你应该使用 `isinstance` 检查 `other` 变量的类型，确保我们处理的是 `Temperature`，否则抛出适当的异常。
- en: Operators – __add__, __sub__, __mul__, and so on
  id: totrans-322
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 操作符 – __add__、__sub__、__mul__ 等等
- en: Similarly, you could also define what would happen when trying to add or multiply
    two `Temperature` objects. We won’t go into much detail here as it works exactly
    like the comparison operators.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，你还可以定义当尝试对两个 `Temperature` 对象进行加法或乘法操作时会发生什么。我们在这里不会详细讨论，因为它的工作方式与比较操作符完全相同。
- en: Callable object – __call__
  id: totrans-324
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可调用对象 – __call__
- en: 'The last magic method we’ll review is `__call__`. This one is a bit special
    because it enables you to call your object instance like a *regular function*.
    Let’s take an example:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要回顾的最后一个魔法方法是 `__call__`。这个方法有些特殊，因为它使你能够像调用 *普通函数* 一样调用你的对象实例。让我们看一个例子：
- en: chapter02_classes_objects_05.py
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: chapter02_classes_objects_05.py
- en: '[PRE68]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_classes_objects_05.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_classes_objects_05.py)'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_classes_objects_05.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_classes_objects_05.py)'
- en: 'The `__call__` method can be defined like any other method, with any argument
    you wish. The only difference is how you call it: you just pass the argument directly
    on the object instance variable as you would do for a regular function.'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '`__call__` 方法可以像定义其他方法一样定义，接受你希望的任何参数。唯一的区别是如何调用它：你只需要像调用普通函数那样，直接在对象实例变量上传递参数。'
- en: This pattern can be useful if you want to define a function that maintains some
    kind of local state, as we did here in our example, or in cases where you need
    to provide a **callable** object but have to set some parameters. Actually, this
    is the use case we’ll encounter when defining class dependencies for FastAPI.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想定义一个保持某种局部状态的函数，就像我们在这个例子中所做的那样，或者在需要提供 **可调用** 对象并设置一些参数的情况下，这种模式会很有用。实际上，这正是我们在为
    FastAPI 定义类依赖时会遇到的用例。
- en: 'As we saw, magic methods are an excellent way to implement operations for our
    custom classes and make them easy to use in a purely object-oriented way. We haven’t
    covered every magic method available but you can find the complete list in the
    official documentation: [https://docs.python.org/3/reference/datamodel.html#special-method-names](https://docs.python.org/3/reference/datamodel.html#special-method-names).'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，魔法方法是实现自定义类操作的一个绝佳方式，使它们能够以纯面向对象的方式易于使用。我们并没有涵盖所有可用的魔法方法，但你可以在官方文档中找到完整的列表：[https://docs.python.org/3/reference/datamodel.html#special-method-names](https://docs.python.org/3/reference/datamodel.html#special-method-names)。
- en: 'We’ll now focus on another essential characteristic of object-oriented programming:
    inheritance.'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将重点讨论面向对象编程的另一个重要特性：继承。
- en: Reusing logic and avoiding repetition with inheritance
  id: totrans-333
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过继承重用逻辑，避免重复代码
- en: 'Inheritance is one of the core concepts of object-oriented programming: it
    allows you to derive a new class from existing ones, enabling you to reuse some
    logic and overload the parts that are specific to this new class. Of course, this
    is supported in Python. We’ll take very simple examples to understand the mechanism
    underneath.'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 继承是面向对象编程的核心概念之一：它允许你从现有的类派生出一个新类，从而重用一些逻辑，并重载对这个新类特有的部分。当然，Python 也支持这种方式。我们将通过非常简单的例子来理解其底层机制。
- en: 'First of all, let’s take an example of very simple inheritance:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们来看一个非常简单的继承示例：
- en: chapter02_classes_objects_06.py
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: chapter02_classes_objects_06.py
- en: '[PRE69]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_classes_objects_06.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_classes_objects_06.py)'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_classes_objects_06.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_classes_objects_06.py)'
- en: 'The `Child` class inherits from the `A` class. The syntax is simple: the class
    we want to inherit from is specified between parentheses after the child class
    name.'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '`Child` 类继承自 `A` 类。语法很简单：我们想继承的类通过括号写在子类名后面。'
- en: The pass statement
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: pass 语句
- en: '`pass` is a statement that *does nothing*. Since Python relies only on indentation
    to denote blocks, it’s a useful statement to create an *empty block*, as you would
    do with curly braces in other programming languages.'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '`pass` 是一个*什么也不做*的语句。由于 Python 仅依赖缩进来表示代码块，它是一个有用的语句，可以用来创建一个*空的代码块*，就像在其他编程语言中使用大括号一样。'
- en: In this example, we don’t want to add some logic to the `Child` class, so we
    just write `pass`.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们不想给 `Child` 类添加任何逻辑，所以我们只写了 `pass`。
- en: Another way to do it is to add a docstring just below the class definition.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是在类定义下方添加文档字符串（docstring）。
- en: 'If you wish to overload a method but still want to get the result of the parent
    method, you can call the `super` function:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望重载一个方法，但仍然想获得父类方法的结果，可以调用 `super` 函数：
- en: chapter02_classes_objects_07.py
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: chapter02_classes_objects_07.py
- en: '[PRE70]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_classes_objects_07.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_classes_objects_07.py)'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_classes_objects_07.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_classes_objects_07.py)'
- en: 'You now know how to use basic inheritance in Python. But there is more: we
    can also have multiple inheritance!'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何在 Python 中使用基本的继承了。但还有更多：我们还可以使用多重继承！
- en: Multiple inheritance
  id: totrans-349
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多重继承
- en: 'As its name suggests, multiple inheritance allows you to derive a child class
    from multiple classes. This way, you can combine the logic of several classes
    into one. Let’s take an example:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名称所示，多重继承允许你从多个类派生一个子类。这样，你可以将多个类的逻辑组合成一个。我们来看一个例子：
- en: chapter02_classes_objects_08.py
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: chapter02_classes_objects_08.py
- en: '[PRE71]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_classes_objects_08.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_classes_objects_08.py)'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_classes_objects_08.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_classes_objects_08.py)'
- en: 'Once again, the syntax is quite straightforward: just list all the parent classes
    with a comma. Now, the `Child` class can call both methods, `f` and `g`.'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，语法非常简单：只需用逗号列出所有父类。现在，`Child` 类可以调用 `f` 和 `g` 两个方法。
- en: Mixins
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: Mixins
- en: Mixins are common patterns in Python that take advantage of the multiple inheritance
    feature. Basically, mixins are short classes containing a single feature that
    you often want to reuse. You can then compose concrete classes by combining mixins.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: Mixins 是 Python 中常见的设计模式，利用了多重继承特性。基本上，mixins 是包含单一功能的简短类，通常用于重用。然后，你可以通过组合这些
    mixins 来构建具体的类。
- en: 'However, what would happen if both `A` and `B` classes implemented a method
    named `f`? Let’s try it out:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果 `A` 和 `B` 两个类都实现了名为 `f` 的方法，会发生什么呢？我们来试试看：
- en: chapter02_classes_objects_09.py
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: chapter02_classes_objects_09.py
- en: '[PRE72]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_classes_objects_09.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_classes_objects_09.py)'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_classes_objects_09.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_classes_objects_09.py)'
- en: 'If you call the `f` method of `Child`, you’ll get the value `"A"`. In this
    simple case, Python will consider the first matching method following the order
    of the parent classes. However, for more complex hierarchies, the resolution may
    not be so obvious: this is the purpose of the **Method Resolution Order** (**MRO**)
    algorithm. We won’t go into much detail here but you can have a look at the official
    document explaining the algorithm implemented by Python: [https://www.python.org/download/releases/2.3/mro/](https://www.python.org/download/releases/2.3/mro/).'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你调用 `Child` 类的 `f` 方法，你将得到值 `"A"`。在这个简单的例子中，Python 会根据父类的顺序考虑第一个匹配的方法。然而，对于更复杂的继承结构，解析可能就不那么明显了：这就是
    **方法解析顺序**（**MRO**）算法的目的。我们在这里不会深入讨论，但你可以查看 Python 官方文档，了解该算法的实现：[https://www.python.org/download/releases/2.3/mro/](https://www.python.org/download/releases/2.3/mro/)。
- en: 'If you are confused about the MRO of your class, you can call the `mro` method
    on your class to get a list of considered classes in order:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对类的 MRO（方法解析顺序）感到困惑，可以在类上调用 `mro` 方法来获取按顺序考虑的类列表：
- en: '[PRE73]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Well done! You now have a good overview of object-oriented programming in Python.
    Those concepts will be helpful when defining dependencies in FastAPI.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 做得好！现在你对 Python 的面向对象编程有了一个很好的概览。这些概念在定义 FastAPI 中的依赖关系时会非常有帮助。
- en: We’ll now review some of the most recent and trending features in Python, upon
    which FastAPI relies heavily. We’ll start with **type hinting**.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将回顾一些 Python 中最新和最流行的特性，FastAPI 在这些特性上有很大的依赖。我们将从 **类型提示** 开始。
- en: Type hinting and type checking with mypy
  id: totrans-366
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 mypy 进行类型提示和类型检查
- en: 'In the first section of this chapter, we said that Python was a dynamically
    typed language: the interpreter doesn’t check types at compile time but rather
    at runtime. This makes the language a bit more flexible and the developer a bit
    more efficient. However, if you are experienced with that kind of language, you
    probably know that it’s easy to produce errors and bugs in this context: forgetting
    arguments, type mismatches, and so on.'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的第一部分，我们提到 Python 是一种动态类型语言：解释器不会在编译时检查类型，而是在运行时进行检查。这使得语言更加灵活，开发者也更加高效。然而，如果你对这种语言类型有经验，你可能知道在这种上下文中很容易产生错误和漏洞：忘记参数、类型不匹配等问题。
- en: This is why Python introduced type hinting starting in *version 3.5*. The goal
    is to provide a syntax to annotate the source code with `mypy`, is widely used
    by the community in this context.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 Python 从 *3.5 版本* 开始引入类型提示的原因。目的是提供一种语法，用于通过 `mypy` 注解源代码，`mypy` 在这个领域被广泛使用。
- en: Getting started
  id: totrans-369
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 入门
- en: 'To understand how type annotations work, we’ll review a simple annotated function:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解类型注解如何工作，我们将回顾一个简单的注解函数：
- en: chapter02_type_hints_01.py
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: chapter02_type_hints_01.py
- en: '[PRE74]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_type_hints_01.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_type_hints_01.py)'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_type_hints_01.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_type_hints_01.py)'
- en: As you can see here, we simply added the type of the `name` argument after a
    colon. We also specified the `str` or `int`, we can simply use them as type annotations.
    We’ll see a little later in this section how to annotate more complex types such
    as lists or dictionaries.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们在冒号后简单地添加了`name`参数的类型。我们还指定了`str`或`int`，我们可以简单地将它们用作类型注解。稍后在本节中，我们将看到如何注解更复杂的类型，如列表或字典。
- en: 'We’ll now install `mypy` to perform a type check on this file. This can be
    done like any other Python package:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将安装`mypy`来对这个文件进行类型检查。这可以像其他任何Python包一样完成：
- en: '[PRE75]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Then, you can run a type check on your source file:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以对你的源文件运行类型检查：
- en: '[PRE76]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'As you can see, `mypy` tells us that everything is good with our typing. Let’s
    try to modify our code a bit to provoke a type error:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`mypy`告诉我们我们的类型没有问题。让我们尝试稍微修改一下代码，触发一个类型错误：
- en: '[PRE77]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Quite simply, we just said that the return type of our function is now `int`,
    but we are still returning a string. If you run this code, it’ll execute perfectly
    well: as we said, the interpreter ignores type annotations. However, let’s see
    what `mypy` tells us about it:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 很简单，我们只是说我们的函数的返回类型现在是`int`，但我们仍然返回一个字符串。如果你运行这段代码，它会完美执行：正如我们所说，解释器会忽略类型注解。然而，让我们看看`mypy`会给我们什么反馈：
- en: '[PRE78]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'This time, it complains. It clearly tells us what is wrong here: the return
    value is a string, while an integer was expected!'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，它发出了警告。它清楚地告诉我们这里出了什么问题：返回值是字符串，而预期的是整数！
- en: Code editors and IDE integration
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 代码编辑器和IDE集成
- en: Having type checking is good, but it may be a bit tedious to run `mypy` manually
    on the command line. Fortunately, it integrates well with the most popular code
    editors and IDEs. Once configured, it’ll perform type checking while you type
    and show you errors directly on faulty lines. Type annotations also help the IDE
    to perform clever things such as *auto-completion*.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 有类型检查是好的，但手动在命令行上运行`mypy`可能有点繁琐。幸运的是，它与最流行的代码编辑器和IDE集成得很好。一旦配置完成，它将在你输入时执行类型检查，并直接在错误的行上显示错误。类型注解还帮助IDE执行一些聪明的操作，例如*自动补全*。
- en: 'You can check in the official documentation of `mypy` how to set it up for
    your favorite editor: [https://github.com/python/mypy#integrations](https://github.com/python/mypy#integrations).'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`mypy`的官方文档中查看如何为你最喜欢的编辑器进行配置：[https://github.com/python/mypy#integrations](https://github.com/python/mypy#integrations)。
- en: You understand the basics of type hinting in Python. We’ll now review more advanced
    examples, especially with non-scalar types.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经理解了Python中类型提示的基础知识。接下来，我们将回顾更高级的例子，特别是涉及非标量类型的情况。
- en: Type data structures
  id: totrans-388
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型数据结构
- en: 'So far, we’ve seen how to annotate variables for scalar types such as `str`
    or `int`. But we’ve seen that there are data structures such as lists and dictionaries
    that are widely used in Python. In the following example, we’ll show how to type-hint
    the basic data structures in Python:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了如何为标量类型（如`str`或`int`）注解变量。但我们也看到了像列表和字典这样的数据结构，它们在Python中被广泛使用。在下面的例子中，我们将展示如何为Python中的基本数据结构添加类型提示：
- en: chapter02_type_hints_02.py
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: chapter02_type_hints_02.py
- en: '[PRE79]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_type_hints_02.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_type_hints_02.py)'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_type_hints_02.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_type_hints_02.py)'
- en: You can see here that we can use the `list`, `tuple`, `set`, and `dict` standard
    classes as type hints. However, they expect you to provide the type of the values
    composing your structure. It’s the well-known concept of **generics** in object-oriented
    programming. In Python, they are defined using square brackets.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，这里我们可以使用`list`、`tuple`、`set`和`dict`这些标准类作为类型提示。然而，它们要求你提供构成结构的值的类型。这就是面向对象编程中广为人知的**泛型**概念。在Python中，它们是通过方括号定义的。
- en: 'Of course, there are more complex use cases. For example, having a list with
    elements of different types is perfectly valid in Python. To make this work with
    type checkers, we can simply use the `|` notation to specify several allowed types:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，还有更复杂的用例。例如，在Python中，拥有一个包含不同类型元素的列表是完全有效的。为了让类型检查器正常工作，我们可以简单地使用`|`符号来指定多个允许的类型：
- en: chapter02_type_hints_03.py
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: chapter02_type_hints_03.py
- en: '[PRE80]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_type_hints_03.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_type_hints_03.py)'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_type_hints_03.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_type_hints_03.py)'
- en: In this case, our list will accept either integers or floating-point numbers.
    Of course, `mypy` will complain if you try to add an element in this list that
    is neither an `int` nor a `float` type.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们的列表将接受整数或浮点数。当然，如果你尝试向列表中添加一个既不是 `int` 也不是 `float` 类型的元素，`mypy` 会报错。
- en: 'There is also another case where this is useful: quite often, you’ll have function
    arguments or return types that either return a value or `None`. Thus, you could
    write something like this:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种情况也非常有用：你会经常遇到这样的函数参数或返回类型，它们要么返回一个值，要么返回 `None`。因此，你可以写类似这样：
- en: chapter02_type_hints_04.py
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: chapter02_type_hints_04.py
- en: '[PRE81]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_type_hints_04.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_type_hints_04.py)'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_type_hints_04.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_type_hints_04.py)'
- en: The allowed value is either a string or `None`.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 允许的值是字符串或 `None`。
- en: Type annotations were different before Python 3.9
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 3.9 之前，类型注解有所不同
- en: 'Before Python 3.9, it wasn’t possible to annotate lists, tuples, sets, and
    dictionaries using the standard class. We needed to import special classes from
    the `typing` module: `l: List[int] = [1, 2, 3,` `4, 5]`.'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '在 Python 3.9 之前，无法使用标准类对列表、元组、集合和字典进行注解。我们需要从 `typing` 模块中导入特殊类：`l: List[int]
    = [1, 2, 3,` `4, 5]`。'
- en: 'The `|` notation wasn’t available either. We needed to use a special `Union`
    class from `typing`: `l: List[Union[int, float]] = [1, 2.5,` `3.14, 5]`'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '`|` 符号也不可用。我们需要使用 `typing` 模块中的特殊 `Union` 类：`l: List[Union[int, float]] = [1,
    2.5,` `3.14, 5]`'
- en: This way of annotating is now deprecated, but you may still find it in older
    code bases.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 这种注解方式现在已经被弃用，但你仍然可能会在旧的代码库中找到它。
- en: 'When dealing with complex types, it may be useful to *alias* and reuse them
    at will without the need to rewrite them each time. To do this, you can simply
    assign them as you would do for any variable:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 处理复杂类型时，*别名* 和复用它们可能会很有用，这样你就无需每次都重写它们。为此，你只需像为任何变量赋值一样进行赋值：
- en: chapter02_type_hints_05.py
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: chapter02_type_hints_05.py
- en: '[PRE82]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_type_hints_05.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_type_hints_05.py)'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_type_hints_05.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_type_hints_05.py)'
- en: 'By convention, types should be named using camel case, like classes. Talking
    about classes, let’s see how type hinting works with them:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，类型应该使用驼峰命名法，就像类名一样。说到类，我们来看看类型提示在类中的应用：
- en: chapter02_type_hints_06.py
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: chapter02_type_hints_06.py
- en: '[PRE83]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_type_hints_06.py
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_type_hints_06.py
- en: Actually, there is nothing special about classes’ type hinting. You just annotate
    the methods as you would for a regular function. If you need to use your class
    in an annotation, like here for a list of posts, you just have to use the class
    name.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，类的类型提示并没有什么特别的。你只需像对待普通函数一样注解类的方法。如果你需要在注解中使用类，例如这里的帖子列表，你只需要使用类名。
- en: Sometimes, you’ll have to write a function or method that accepts another function
    in an argument. In this case, you’ll need to give the **type signature** of this
    function.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你需要编写一个接受另一个函数作为参数的函数或方法。在这种情况下，你需要提供该函数的 **类型签名**。
- en: Type function signatures with Callable
  id: totrans-418
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Callable 标注类型函数签名
- en: 'A more advanced use case is to be able to have types for function signatures.
    For example, it can be useful when you need to pass functions as arguments of
    other functions. For this task, we can use the `Callable` class, available in
    the `collections.abc` module. In the following example, we’ll implement a function
    called `filter_list` expecting as arguments a list of integers and a function
    returning a Boolean given an integer:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更高级的使用场景是能够为函数签名指定类型。例如，当你需要将函数作为其他函数的参数时，这会非常有用。为此，我们可以使用 `Callable` 类，它在
    `collections.abc` 模块中可用。在以下示例中，我们将实现一个名为 `filter_list` 的函数，期望接受一个整数列表和一个给定整数返回布尔值的函数作为参数：
- en: chapter02_type_hints_07.py
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: chapter02_type_hints_07.py
- en: '[PRE84]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_type_hints_07.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_type_hints_07.py)'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_type_hints_07.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_type_hints_07.py)'
- en: What is the collections.abc module?
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是 `collections.abc` 模块？
- en: '`collections.abc` is a module from the standard Python library providing abstract
    base classes for the common objects we use daily in Python: iterators, generators,
    callables, sets, mappings, and so on. They are mainly useful in advanced use cases
    where we need to implement new custom objects that should behave *like* an iterator,
    generator, and so on. Here, we only use them as type hints.'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '`collections.abc` 是 Python 标准库中的一个模块，提供了常用对象的抽象基类，这些对象在 Python 中日常使用：迭代器、生成器、可调用对象、集合、映射等。它们主要用于高级用例，在这些用例中，我们需要实现新的自定义对象，这些对象应该像迭代器、生成器等一样工作。在这里，我们仅将它们作为类型提示使用。'
- en: 'You can see here that we define a type alias, `ConditionFunction`, thanks to
    `Callable`. Once again, this is a generic class that expects two things: first,
    the list of argument types and then the return type. Here, we expect a single
    integer argument and the return type is a Boolean.'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到这里我们通过 `Callable` 定义了一个类型别名 `ConditionFunction`。再次强调，这是一个泛型类，期望两个参数：首先是参数类型的列表，其次是返回类型。在这里，我们期望一个整数类型的参数，返回类型是布尔类型。
- en: 'We can then use this type in the annotation of the `filter_list` function.
    `mypy` will then ensure that the condition function passed in the argument conforms
    to this signature. For example, we could write a simple function to check the
    parity of an integer, as shown in the next sample:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以在 `filter_list` 函数的注解中使用这种类型。`mypy` 会确保传递给参数的条件函数符合此签名。例如，我们可以编写一个简单的函数来检查整数的奇偶性，如下所示：
- en: chapter02_type_hints_07.py
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: chapter02_type_hints_07.py
- en: '[PRE85]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_type_hints_07.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_type_hints_07.py)'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_type_hints_07.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_type_hints_07.py)'
- en: It’s worth noting, however, that there is no syntax to indicate optional or
    keyword arguments. In this case, you can write `Callable[..., bool]`, the ellipsis
    (`...)` here meaning *any number* *of arguments*.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，值得注意的是，Python 中没有语法来指示可选或关键字参数。在这种情况下，你可以写 `Callable[..., bool]`，其中的省略号（`...`）表示*任意数量*的*参数*。
- en: Any and cast
  id: totrans-431
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`Any` 和 `cast`'
- en: In some situations, the code is so dynamic or complicated that it won’t be possible
    to annotate it correctly or the type checker may not correctly infer the type.
    For this, we can use `Any` and `cast`. They are available in the `typing` module,
    which was introduced by Python to help with more specific use cases and constructs
    regarding type hints.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，代码非常动态或复杂，无法正确地进行注解，或者类型检查器可能无法正确推断类型。为此，我们可以使用 `Any` 和 `cast`。它们可在 `typing`
    模块中找到，该模块是 Python 引入的，旨在帮助处理类型提示方面的更具体的用例和构造。
- en: '`Any` is a type annotation telling the type checker the variable or argument
    can be anything. In this case, any type of value will be valid for the type checker:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '`Any` 是一种类型注解，告诉类型检查器变量或参数可以是任何类型。在这种情况下，类型检查器将接受任何类型的值：'
- en: chapter02_type_hints_08.py
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: chapter02_type_hints_08.py
- en: '[PRE86]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_type_hints_08.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_type_hints_08.py)'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_type_hints_08.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_type_hints_08.py)'
- en: 'The second one, `cast`, is a function that lets you override the type inferred
    by the type checker. It’ll force the type checker to consider the type you specify:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个方法，`cast`，是一个让你覆盖类型检查器推断的类型的函数。它会强制类型检查器考虑你指定的类型：
- en: chapter02_type_hints_09.py
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: chapter02_type_hints_09.py
- en: '[PRE87]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_type_hints_09.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_type_hints_09.py)'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_type_hints_09.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_type_hints_09.py)'
- en: 'Be careful though: the `cast` function is only meaningful for type checkers.
    As for every other type of annotation, the interpreter completely ignores it and
    *doesn’t* perform a real cast.'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 但要小心：`cast` 函数对类型检查器才有意义。对于其他类型的注解，解释器会完全忽略它，并且 *不会* 执行真正的类型转换。
- en: While convenient, try to refrain from using those utilities too often. If everything
    is `Any` or cast to a different type, you completely miss the benefits of static
    type checking.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管很方便，但尽量不要过于频繁地使用这些工具。如果一切都是 `Any` 或强制转换为其他类型，你将完全失去静态类型检查的好处。
- en: 'As we have seen, type hinting and type checking are really helpful in reducing
    errors while developing and maintaining high-quality code. But that’s not all.
    Actually, Python allows you to retrieve type annotations at runtime and perform
    some logic based on them. This enables you to do clever things such as **dependency
    injection**: just by type hinting an argument in a function, a library can automatically
    interpret it and inject the corresponding value at runtime. This concept is at
    the heart of FastAPI.'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，类型提示和类型检查在减少开发和维护高质量代码时非常有帮助。但这还不是全部。实际上，Python 允许你在运行时获取类型注解，并基于此执行一些逻辑。这使得你能够做一些聪明的事情，比如
    **依赖注入**：只需在函数中为参数添加类型提示，库就能自动解析并在运行时注入相应的值。这一概念是 FastAPI 的核心。
- en: Another key approach in FastAPI is **asynchronous I/O**. This will be the last
    subject we’ll cover in this chapter.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI 中的另一个关键方法是 **异步 I/O**。这是我们在本章中要讲解的最后一个主题。
- en: Working with asynchronous I/O
  id: totrans-445
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与异步 I/O 一起工作
- en: 'If you have already worked with JavaScript and Node.js, you have probably come
    across the concepts of *promises* and `async`/`await` keywords, which are characteristic
    of the asynchronous I/O paradigm. Basically, this is a way to make I/O operations
    non-blocking and allow the program to perform other tasks while the read or write
    operation is ongoing. The main motivation behind this is that I/O operations are
    *slow*: reading from disk, network requests are *million* times slower than reading
    from RAM or processing instructions. In the following example, we have a simple
    script that reads a file on disk:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经使用过 JavaScript 和 Node.js，你可能已经接触过 *promise* 和 `async`/`await` 关键字，这些都是异步
    I/O 范式的特点。基本上，这是使 I/O 操作非阻塞的方式，并允许程序在读取或写入操作进行时执行其他任务。这样做的主要原因是 I/O 操作是 *慢* 的：从磁盘读取、网络请求的速度比从
    RAM 中读取或处理指令慢 *百万* 倍。在下面的示例中，我们有一个简单的脚本，它读取磁盘上的文件：
- en: chapter02_asyncio_01.py
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: chapter02_asyncio_01.py
- en: '[PRE88]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_asyncio_01.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_asyncio_01.py)'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_asyncio_01.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_asyncio_01.py)'
- en: We see that the script will block until we have retrieved the data from the
    disk and, as we said, this can be a long time. 99% percent of the execution time
    of the program is spent on waiting for the disk. Usually, it’s not an issue for
    simple scripts like this because you probably won’t have to perform other operations
    in the meantime.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，脚本会被阻塞，直到从磁盘中检索到数据，正如我们所说，这可能需要很长时间。程序99%的执行时间都花费在等待磁盘上。对于像这样的简单脚本来说，这通常不是问题，因为你可能不需要在此期间执行其他操作。
- en: However, in other situations, it could be an opportunity to perform other tasks.
    The typical case that is of great interest in this book is web servers. Imagine
    we have a first user making a request that performs a 10-second-long database
    query before sending the response. If a second user makes another request in the
    meantime, they’ll have to wait for the first response to finish before getting
    their answer.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在其他情况下，这可能是执行其他任务的机会。本书中非常关注的典型案例是 Web 服务器。假设我们有一个用户发出请求，该请求需要执行一个持续10秒钟的数据库查询才能返回响应。如果此时第二个用户发出了请求，他们必须等到第一个响应完成后，才能收到自己的答复。
- en: To solve this, traditional Python web servers based on the **Web Server Gateway
    Interface** (**WSGI**), such as Flask or Django, spawn several **workers**. Those
    are sub-processes of the web server that are all able to answer requests. If one
    is busy processing a long request, others can answer new requests.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，传统的基于**Web服务器网关接口**（**WSGI**）的 Python Web 服务器（如 Flask 或 Django）会生成多个**工作进程**。这些是
    Web 服务器的子进程，都能够处理请求。如果其中一个忙于处理一个长时间的请求，其他进程可以处理新的请求。
- en: With asynchronous I/O, a single process won’t block when processing a request
    with a long I/O operation. While it waits for this operation to finish, it can
    answer other requests. When the I/O operation is done, it resumes the request
    logic and can finally answer the request.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 使用异步 I/O 时，单个进程在处理一个长时间 I/O 操作的请求时不会被阻塞。它在等待此操作完成的同时，可以处理其他请求。当 I/O 操作完成时，它会恢复请求逻辑，并最终返回响应。
- en: 'Technically, this is achieved through the concept of an `select` and `poll`
    calls, which are precisely there to ask for events about I/O operations at the
    operating system level. You can read very interesting details about this in the
    article *Async IO on Linux: select, poll, and epoll* by Julia Evans: [https://jvns.ca/blog/2017/06/03/async-io-on-linux--select--poll--and-epoll](https://jvns.ca/blog/2017/06/03/async-io-on-linux--select--poll--and-epoll).'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: '从技术上讲，这是通过`select`和`poll`调用实现的，正是通过它们来请求操作系统级别的 I/O 操作事件。你可以在 Julia Evans 的文章《Async
    IO on Linux: select, poll, and epoll》中阅读到非常有趣的细节：[https://jvns.ca/blog/2017/06/03/async-io-on-linux--select--poll--and-epoll](https://jvns.ca/blog/2017/06/03/async-io-on-linux--select--poll--and-epoll)。'
- en: Python first implemented asynchronous I/O in version 3.4 and it has since greatly
    evolved, notably with the introduction of the `async`/`await` keywords in version
    3.6\. All the utilities to manage this paradigm are available through the standard
    `asyncio` module. Not long after, the spiritual successor of WSGI for asynchronous-enabled
    web servers, **Asynchronous Server Gateway Interface** (**ASGI**), was introduced.
    FastAPI relies on this, and this is one of the reasons why it shows such *great
    performance*.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: Python 在 3.4 版本中首次实现了异步 I/O，之后它得到了极大的发展，特别是在 3.6 版本中引入了 `async`/`await` 关键字。所有用于管理这种编程范式的工具都可以通过标准的
    `asyncio` 模块获得。不久之后，异步启用 Web 服务器的 WSGI 的精神继任者——**异步服务器网关接口**（**ASGI**）被引入。FastAPI
    就是基于这一点，这也是它展示出如此*卓越性能*的原因之一。
- en: 'We’ll now review the basics of asynchronous programming in Python. The following
    example is a simple *Hello world* script using `asyncio`:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在来回顾一下 Python 中异步编程的基础知识。下面的示例是一个使用`asyncio`的简单*Hello world*脚本：
- en: chapter02_asyncio_02.py
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: chapter02_asyncio_02.py
- en: '[PRE89]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_asyncio_02.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_asyncio_02.py)'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_asyncio_02.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_asyncio_02.py)'
- en: When you wish to define an asynchronous function, you just have to add the `async`
    keyword before `def`. This allows you to use the `await` keyword inside it. Such
    async functions are called **coroutines**.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想定义一个异步函数时，只需要在`def`前面添加`async`关键字。这允许你在函数内部使用`await`关键字。这种异步函数被称为**协程**。
- en: 'Inside it, we first call the `print` function and then call the `asyncio.sleep`
    coroutine. This is the `async` equivalent of `time.sleep`, which blocks the program
    for a given number of seconds. Notice that we prefixed the call with the `await`
    keyword. This means that we want to wait for this coroutine to finish before proceeding.
    This is the main benefit of `async`/`await` keywords: writing code that *looks
    like* synchronous code. If we omitted `await`, the coroutine object would have
    been created but never executed.'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 在其中，我们首先调用`print`函数，然后调用`asyncio.sleep`协程。这是`async`版的`time.sleep`，它会让程序阻塞指定的秒数。请注意，我们在调用前加上了`await`关键字。这意味着我们希望等待这个协程完成后再继续。这就是`async`/`await`关键字的主要好处：编写*看起来像*同步代码的代码。如果我们省略了`await`，协程对象会被创建，但永远不会执行。
- en: Finally, notice that we use the `asyncio.run` function. This is the machinery
    that will create a new event loop, execute your coroutine, and return its result.
    It should be the main entry point of your `async` program.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，注意我们使用了`asyncio.run`函数。这是会创建一个新的事件循环，执行你的协程并返回其结果的机制。它应该是你`async`程序的主要入口点。
- en: 'This example is nice but not very interesting from an asynchronous point of
    view: since we are waiting for only one operation, this is not very impressive.
    Let’s see an example where we execute two coroutines concurrently:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例不错，但从异步的角度来看并不太有趣：因为我们只等待一个操作，所以这并不令人印象深刻。让我们看一个同时执行两个协程的例子：
- en: chapter02_asyncio_03.py
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: chapter02_asyncio_03.py
- en: '[PRE90]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_asyncio_03.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_asyncio_03.py)'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_asyncio_03.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/blob/main/chapter02/chapter02_asyncio_03.py)'
- en: Here, we have a `printer` coroutine that prints its name a given number of times.
    Between each print, it sleeps for 1 second.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们有一个`printer`协程，它会打印自己的名字指定次数。每次打印之间，它会睡眠1秒。
- en: 'Then, our main coroutine uses the `asyncio.gather` utility, which schedules
    several coroutines for concurrent execution. If you run this script, you’ll get
    the following result:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们的主协程使用了`asyncio.gather`工具，它将多个协程调度为并发执行。如果你运行这个脚本，你将得到以下结果：
- en: '[PRE91]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: We get a succession of `A` and `B`. It means our coroutines were executed concurrently
    and that we didn’t wait for the first one to finish before starting the second
    one.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了一连串的`A`和`B`。这意味着我们的协程是并发执行的，并且我们没有等第一个协程完成才开始第二个协程。
- en: 'You might wonder why we added the `asyncio.sleep` call in this example. Actually,
    if we removed it, we would have obtained this result:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道为什么我们在这个例子中添加了`asyncio.sleep`调用。实际上，如果我们去掉它，我们会得到如下结果：
- en: '[PRE92]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'That doesn’t look very concurrent, and indeed, it’s not. This is one of the
    main pitfalls of `asyncio`: writing code in a coroutine *doesn’t necessarily mean*
    that it won’t block. Regular operations such as computations *are* blocking and
    *will* block the event loop. Usually, this is not a problem since those operations
    are fast. The only operations that won’t block are proper I/O operations that
    are *designed* to work asynchronously. This is different from **multiprocessing**
    where operations are executed on child processes, which, by nature, doesn’t block
    the main one.'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来并不太并发，实际上确实不是。这是`asyncio`的主要陷阱之一：在协程中编写代码*不一定意味着*它不会阻塞。像计算这样的常规操作*是*阻塞的，并且*会*阻塞事件循环。通常这不是问题，因为这些操作很快。唯一不会阻塞的操作是设计为异步执行的I/O操作。这与**多进程**不同，后者的操作是在子进程中执行的，天生不会阻塞主进程。
- en: Because of this, you’ll have to be careful when choosing a third-party library
    for interacting with databases, APIs, and so on. Some have been adapted to work
    asynchronously and some alternatives have been developed in parallel with the
    standard ones. We’ll see some of them in the following chapters, especially when
    working with databases.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在选择与数据库、API等交互的第三方库时，你必须小心。有些库已经适配为异步工作，有些则与标准库并行开发。我们将在接下来的章节中看到其中一些，尤其是在与数据库交互时。
- en: We’ll end this quick introduction to asynchronous I/O here. There are some other
    subtleties underneath but, generally, the basics we’ve seen here will allow you
    to leverage the power of `asyncio` with FastAPI.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在此结束对异步 I/O 的简要介绍。虽然还有一些更深层次的细节，但一般来说，我们在这里学到的基础知识已经足够让你利用 `asyncio` 与 FastAPI
    一起工作。
- en: Summary
  id: totrans-476
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Congratulations! In this chapter, you discovered the basics of the Python language,
    a very clean and efficient language to work with. You were introduced to the more
    advanced concepts of list comprehensions and generators, which are idiomatic ways
    of handling sequences of data. Python is also a multi-paradigm language and you
    saw how to leverage the object-oriented syntax.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！在本章中，你了解了 Python 语言的基础，它是一种非常简洁高效的编程语言。你接触到了更高级的概念——列表推导式和生成器，它们是处理数据序列的惯用方法。Python
    也是一种多范式语言，你还学会了如何利用面向对象的语法。
- en: 'Finally, you discovered some of the most recent features of the language: type
    hinting, which allows static type checking to reduce errors and speed up development,
    and asynchronous I/O, a set of new tools and syntax to maximize performance and
    allow concurrency while doing I/O-bound operations.'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你了解了语言的一些最新特性：类型提示，它允许静态类型检查，从而减少错误并加速开发；以及异步 I/O，这是一组新的工具和语法，可以在执行 I/O 密集型操作时最大化性能并支持并发。
- en: You’re now ready to begin your journey with FastAPI! You’ll see that the framework
    takes advantage of all those Python features to propose a fast and enjoyable development
    experience. In the next chapter, you’ll learn how to write your very first REST
    API with FastAPI.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经准备好开始你的 FastAPI 之旅！你将会发现该框架充分利用了所有这些 Python 特性，提供了快速且愉悦的开发体验。在下一章中，你将学会如何使用
    FastAPI 编写你的第一个 REST API。
