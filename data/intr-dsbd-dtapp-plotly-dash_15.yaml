- en: '*Chapter 12*: Deploying Your App'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第12章*：部署你的应用'
- en: We have done a lot of work, and I'm sure you are looking forward to sharing
    that work with the world. With the app in its current state, we will go through
    the process of setting up a server and deploying the app on a public address.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经做了很多工作，相信你也期待将这些工作与世界分享。应用当前的状态下，我们将通过设置服务器并将应用部署到公共地址的过程。
- en: Essentially, what we will be doing is moving our data and code to a different
    computer and running the app in a similar way to what we have done so far. However,
    we need to set up a hosting account, a server, and a **Web Server Gateway Interface**
    (**WSGI**) in order for our app to be publicly available and visible. We will
    also need to establish a basic workflow for a development, deployment, and update
    cycle.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，我们所做的是将数据和代码移到另一台计算机，并以类似于我们目前所做的方式运行应用程序。然而，我们需要设置一个托管账户、一个服务器以及**Web服务器网关接口**（**WSGI**），以便我们的应用能够公开并可见。我们还需要为开发、部署和更新周期建立一个基本的工作流。
- en: We will take a brief look at the **Git** source control management system, as
    well as do some basic **Linux system administration**. We will cover just enough
    to get our app online, and we won't even be scratching the surface of what can
    be done with those systems—I only mention them as a reference for further research.
    The approach we follow is creating a very basic installation to get our app online
    as fast as possible. This will not be achieved using simple tools. On the contrary—we
    will be using some of the most powerful tools available, but we will use a very
    simple setup. This will allow us to keep things simple at the beginning, and then
    explore how to expand our apps and setup later.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将简要介绍**Git**源代码管理系统，并进行一些基本的**Linux系统管理**。我们将涵盖足够的内容，帮助我们的应用上线，但我们甚至不会触及这些系统的表面——我提到它们只是作为进一步研究的参考。我们所采用的方法是创建一个非常基础的安装，以尽可能快地将我们的应用上线。这不会通过简单的工具实现。相反——我们将使用一些最强大的工具，但我们会使用一个非常简单的设置。这样可以让我们在开始时保持简单，之后再探索如何扩展我们的应用和设置。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Establishing the general development, deployment, and update workflow
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建立一般的开发、部署和更新工作流
- en: Creating a hosting account and virtual server
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建托管账户和虚拟服务器
- en: Connecting to your server with **Secure Shell** (**SSH**)
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**安全外壳**（**SSH**）连接到您的服务器
- en: Running the app on the server
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在服务器上运行应用
- en: Setting up and running the app with a WSGI
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用WSGI设置和运行应用
- en: Setting up and configuring the web server
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置和配置Web服务器
- en: Managing maintenance and updates
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理维护和更新
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: We now need a Linux server connected to the internet; the data files; and our
    app's code. We will be installing `Gunicorn` (Green Unicorn, the WSGI) and `nginx`
    (the web server), as well as our app's Python packages as dependencies. We will
    install `Dash` and its main packages; Dash Bootstrap Components; `pandas`; and
    `sklearn`. An account on a source code management system such as Git will be needed,
    and we will be using GitHub as an example for this chapter.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要一台连接互联网的Linux服务器、数据文件和我们应用的代码。我们将安装`Gunicorn`（Green Unicorn，WSGI）和`nginx`（Web服务器），以及我们应用的Python依赖包。我们将安装`Dash`及其主要包；Dash
    Bootstrap Components；`pandas`；和`sklearn`。我们需要一个源代码管理系统的账户，例如Git，本章将以GitHub为例。
- en: Our development workflow so far has been to test certain functionality on JupyterLab
    and run it, and once it is working fine, we incorporate it to our app. This development
    workflow will not change. We will simply add a few steps and components for deployment
    after making our changes. So, let's start by establishing the workflow that we
    will be working with.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的开发工作流是在JupyterLab上测试某些功能并运行，一旦它工作正常，我们就将其集成到应用中。这个开发工作流不会改变。我们只是会在做出更改后，添加一些部署步骤和组件。那么，让我们首先建立我们将使用的工作流。
- en: Establishing the general development, deployment, and update workflow
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 建立一般的开发、部署和更新工作流
- en: When we discuss deployment, we are assuming that we are happy enough with what
    we have developed so far. This could be when we run our app for the first time,
    or after having introduced some changes or fixed some bugs. So, our data and code
    are ready to go. Our focus will be to set up the required infrastructure to enable
    us to run the code online.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们讨论部署时，我们假设我们对目前所开发的内容已经足够满意。这可能是在我们首次运行应用程序时，或者在进行了一些更改或修复了一些错误之后。所以，我们的数据和代码已经准备好了。我们的重点将是设置所需的基础设施，以便我们能够在网上运行代码。
- en: The setup we will be going through is going to be simple and straightforward.
    We will be using Linode as an example for our hosting provider. An important feature
    of Linode is that it follows a philosophy of "open cloud." This means that the
    server we will be working with will be a plain Linux server, using open source
    components and packages that you can customize the way you want and migrate to
    and from with ease. The potential challenge here is that with more freedom comes
    more complexity and responsibility. In [*Chapter 4*](B16780_04_Final_NM_ePub.xhtml#_idTextAnchor060),
    *Data Manipulation and Preparation – Paving the Way to Plotly Express*, we discussed
    the trade-off involved in choosing between higher- and lower-level software, and
    in this case, we will be working with a lower-level system to run our app.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要进行的设置将是简单而直接的。我们将以 Linode 作为我们的托管服务商示例。Linode 的一个重要特点是它遵循“开放云”的理念。这意味着我们将使用的服务器将是一个普通的
    Linux 服务器，使用开源组件和包，你可以根据自己的需求进行定制，并轻松地进行迁移。这里的潜在挑战是，随着更多自由度的增加，复杂性和责任也随之增加。在[*第4章*](B16780_04_Final_NM_ePub.xhtml#_idTextAnchor060)《数据处理与准备——铺平
    Plotly Express 之路》中，我们讨论了选择高层软件和低层软件之间的权衡，在这种情况下，我们将使用一个低层系统来运行我们的应用程序。
- en: If you are experienced in running and managing servers, then you will have the
    full flexibility that you need and you can skip most of the chapter. The good
    news for beginners is that even though you will be "on your own," we will be running
    a very simple setup with simple defaults. This should enable you to easily deploy
    your app, and you can gradually learn more about how you might want to customize
    your setup, knowing that you have full access to some of the top tools.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有服务器管理经验，那么你将拥有所需的全部灵活性，可以跳过本章的大部分内容。对于初学者的好消息是，尽管你将“独自一人”，我们将运行一个非常简单的设置，使用简单的默认配置。这应该能让你轻松部署应用程序，并且你可以逐步学习如何定制你的设置，同时知道你可以完全访问一些顶级工具。
- en: 'Our deployment workflow will contain three main components, outlined as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的部署工作流将包含以下三个主要组件：
- en: '**Your local workstation**: This has been extensively covered so far, and you
    should have experience with the local setup that we have been working with so
    far.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**本地工作站**：到目前为止，这一部分已经有了广泛的讨论，你应该已经熟悉我们迄今为止所使用的本地设置。'
- en: '**A source code management system**: You don''t really need this to get your
    app to run but it is a very good practice to follow, especially when your app
    grows in size and when more people are involved in its maintenance.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**源代码管理系统**：你实际上并不需要这个来运行你的应用程序，但它是一个非常好的做法，尤其是当你的应用程序变得越来越大，且更多人参与到维护工作中时。'
- en: '**A server with the required infrastructure and setup**: Your code and data
    will be running and served to the public from here.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**具有所需基础设施和设置的服务器**：你的代码和数据将在这里运行，并且对外提供服务。'
- en: 'To make things clearer, the following screenshot shows the elements we are
    discussing and, following that, a brief description of them and how they relate
    to each stage in the development and deployment cycle:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更清楚地说明，以下截图展示了我们正在讨论的各个元素，接下来是对它们的简要描述，以及它们如何与开发和部署周期中的每个阶段相关：
- en: '![Figure 12.1 – The three main components in the development, deployment, and
    update cycle](img/B16780_12_1.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.1 – 开发、部署和更新周期中的三个主要组件](img/B16780_12_1.jpg)'
- en: Figure 12.1 – The three main components in the development, deployment, and
    update cycle
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.1 – 开发、部署和更新周期中的三个主要组件
- en: One or more people write code on their local machines, and the code they write
    travels both ways between them and the central Git repository. Note that code
    does not travel between collaborators on the project—for example, by email; they
    only send their code changes/additions to the Git repository. There are many benefits
    to using a central Git repository. This is a large topic and there are special
    books for it, so we will only cover very basic concepts, and I encourage you to
    learn more. One of the most important things that Git facilitates is to have everyone
    collaborate on a single set of changes—this streamlines the process for everyone.
    There needs to be one or more administrators of the central repository, and that
    person(s) approves what goes into the main repository and what doesn't. Additionally,
    they need to be able to resolve conflicts. Two people might work on the same file
    separately, and they might both push changes that conflict with each other, so
    someone needs to decide what to do in such cases.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 一个或多个人在本地机器上编写代码，所写的代码在他们和中央 Git 仓库之间双向传输。需要注意的是，代码不会在项目协作者之间传输——例如，不能通过电子邮件发送；他们只能将代码更改或添加推送到
    Git 仓库。使用中央 Git 仓库有许多好处。这是一个很大的话题，专门有书籍讲解，我们这里只会涉及一些基本概念，并鼓励你深入学习。Git 最重要的一个功能是让每个人都在同一组更改上进行协作——这简化了每个人的工作流程。中央仓库需要有一名或多名管理员，这些人负责批准哪些内容可以进入主仓库，哪些不能。此外，他们还需要能够解决冲突。两个人可能会分别在同一个文件上工作，并且他们可能都会推送彼此冲突的更改，因此需要有人决定在这种情况下该如何处理。
- en: The approved version gets pushed from Git to the server and the website gets
    published. As you can see, code goes in one direction only at this stage. Even
    if you are working alone, it's highly advised to use Git to manage changes.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 批准的版本从 Git 推送到服务器，网站随后发布。如你所见，在这个阶段，代码仅在一个方向上传输。即使你是单独工作，强烈建议你使用 Git 来管理更改。
- en: Another important benefit is that every set of changes (which are called "commits")
    that are made contains metadata about when the changes were made, and by who.
    More importantly, the commits show to which branch of changes they belong. In
    case you need to roll back some changes, you can also "check out" a certain commit
    or a branch, and take the full repository back to a certain state. You can fix
    your bugs and make changes while your app is running, and then re-introduce them.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的好处是，每一次更改（称为“提交”）都会包含关于更改何时发生以及由谁完成的元数据。更重要的是，提交记录了它们所属的分支。如果你需要回滚某些更改，你也可以“检出”某个特定的提交或分支，将整个仓库恢复到某个状态。你可以在应用程序运行的同时修复错误并进行更改，然后再将其重新引入。
- en: This was an oversimplification of what Git does and how it works, but I think
    it's worth mentioning and learning more about. We will use it for deployment and
    introduce very basic commands. We will go through the process of making a change
    to one of our files in the final section of this chapter, to give an example of
    how a change can be introduced using Git.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是对 Git 的功能和工作原理的简化描述，但我认为值得提及并深入了解。我们将使用它进行部署，并介绍一些基本命令。在本章的最后部分，我们将通过修改其中一个文件的过程，展示如何使用
    Git 引入更改。
- en: At this stage, you have your code working locally with all the required data,
    and you want to push it to a central Git repository and then to your server for
    deployment. Alternatively, you might simply clone this book's repository and deploy
    it to your server as well.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，你的代码已经在本地成功运行，并且拥有所有需要的数据，接下来你希望将它推送到一个中央 Git 仓库，然后再部署到服务器。或者，你也可以简单地克隆这本书的仓库，并将它部署到你的服务器上。
- en: Now that we have established the general cycle of our work and explored the
    main components and steps, we are ready to start our work online, and we first
    do so by setting up a Linode account.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经建立了工作的一般周期，并探索了主要的组件和步骤，我们准备好开始我们的在线工作，首先通过设置 Linode 帐户来实现。
- en: Creating a hosting account and virtual server
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个托管帐户和虚拟服务器
- en: It's straightforward to set up an account on Linode, and you can do so from
    the signup page at [https://login.linode.com/signup](https://login.linode.com/signup).
    Once you register and provide your billing information, you can start by creating
    a "Linode." Virtual servers with their own **Internet Protocol** (**IP**) address
    are also called Linodes (Linux + node), similar to the name of the company.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linode 上设置账户非常简单，您可以从 [https://login.linode.com/signup](https://login.linode.com/signup)
    的注册页面进行操作。一旦注册并提供您的账单信息，您可以开始创建一个“Linode”。拥有自己**互联网协议**（**IP**）地址的虚拟服务器也叫 Linode（Linux
    + node），与公司的名称类似。
- en: The process is straightforward and can be done through the main dashboard that
    you land on when you log in.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 该过程非常简单，可以通过登录后进入的主仪表盘完成。
- en: 'The following screenshot shows some of the main options available to create
    and manage your account:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了一些创建和管理您账户的主要选项：
- en: '![Figure 12.2 – The main objects that you can create on Linode; most importantly,
    the "Linode"](img/B16780_12_2.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.2 – 您可以在 Linode 上创建的主要对象；最重要的是“Linode”](img/B16780_12_2.jpg)'
- en: Figure 12.2 – The main objects that you can create on Linode; most importantly,
    the "Linode"
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.2 – 您可以在 Linode 上创建的主要对象；最重要的是“Linode”
- en: 'Once you select the **Create** option and then select **Linode**, you are given
    several options to choose from. We will go with **Distributions**. You can think
    of distributions as bundles of software based on the Linux kernel but containing
    different components. Each distribution is customized for a certain use case.
    We will be using the Ubuntu distribution for our Linode. Other options can be
    interesting—for example, **Marketplace** provides the option to create a full
    installation of popular software with a few clicks. Feel free to explore these
    other options as well. *Figure 12.3* shows the distribution we selected, and after
    that you have a few simple options to choose from. Most importantly, you need
    to choose a plan, and there are many to choose from, giving you a lot of flexibility.
    You can use the smallest one for now, and then you can decide when/if you want
    to upgrade. In the following screenshot, you can see the Ubuntu distribution being
    selected:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您选择了**创建**选项并选择**Linode**，您将看到几个可供选择的选项。我们将选择**发行版**。您可以将发行版看作是基于 Linux 内核的不同软件包，包含不同的组件。每个发行版都针对特定的使用场景进行定制。我们将为我们的
    Linode 使用 Ubuntu 发行版。其他选项也可能很有趣——例如，**市场**提供了通过几次点击创建流行软件完整安装的选项。欢迎您也探索这些其他选项。*图
    12.3* 显示了我们选择的发行版，之后您会看到几个简单的选项可供选择。最重要的是，您需要选择一个计划，计划有很多种，可以为您提供很大的灵活性。您现在可以选择最小的计划，之后您可以根据需要决定是否升级。以下截图中，您可以看到正在选择
    Ubuntu 发行版：
- en: '![Figure 12.3 – Selecting and configuring a distribution on Linode](img/B16780_12_3.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.3 – 在 Linode 上选择并配置一个发行版](img/B16780_12_3.jpg)'
- en: Figure 12.3 – Selecting and configuring a distribution on Linode
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.3 – 在 Linode 上选择并配置一个发行版
- en: 'Once you have finalized the remaining options you can hit the **Create** button,
    and you should now land on the dashboard for your newly created Linode. The following
    screenshot shows the top of the screen for that interface:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您完成了剩余选项的设置，您可以点击**创建**按钮，然后您应该会进入新创建的 Linode 仪表盘。以下截图显示了该界面的顶部：
- en: '![Figure 12.4 – The Linodes dashboard containing several reports and details](img/B16780_12_4.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.4 – Linode 仪表盘，包含多个报告和详细信息](img/B16780_12_4.jpg)'
- en: Figure 12.4 – The Linodes dashboard containing several reports and details
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.4 – Linode 仪表盘，包含多个报告和详细信息
- en: You can see all the relevant details about your newly created Linode on this
    screen, and you can refer back to it to get performance data and other information,
    or in case you want to make any changes. Later on, you will probably want to either
    upgrade your plan or add volumes for extra storage, and so on.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此屏幕上查看有关您新创建的 Linode 的所有相关细节，您可以参考它以获取性能数据和其他信息，或者如果您想进行任何更改时使用。稍后，您可能会想要升级计划或添加更多存储空间等。
- en: For us, the interesting part of this screen is the **SSH Access** part. We will
    now use this to log in to our server, and we won't be using the web interface
    from now on.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 对我们来说，这个屏幕最有趣的部分是**SSH 访问**部分。我们将利用这一点登录到我们的服务器，从现在起我们将不再使用 Web 界面。
- en: Important note
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Linode provides several ways to interact with and manage your account. It provides
    an **application programming interface** (**API**) and a **command-line interface**
    (**CLI**), among other tools, from which you can do pretty much anything that
    you can do through the web interface. It's more convenient to use the web interface
    for simple tasks such as the one we just did. Using the API and/or the CLI becomes
    more useful for automating and operationalizing tasks on a large scale.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Linode 提供了多种与账户交互和管理账户的方式。它提供了**应用程序编程接口**（**API**）和**命令行接口**（**CLI**）等工具，你可以通过这些工具做几乎任何通过
    Web 界面可以做的事情。对于像我们刚才完成的简单任务，使用 Web 界面更加方便。使用 API 和/或 CLI 在大规模自动化和执行任务时更加有用。
- en: Now that we have our server running, we want to start working on it. This will
    mainly be done through the SSH interface.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们的服务器已经启动，我们就可以开始在上面工作了。这主要通过 SSH 界面来完成。
- en: Connecting to your server with SSH
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 SSH 连接到你的服务器
- en: SSH is a protocol for moving data securely, over an unsecured network. This
    will enable us to get access to and run code from the command line of our server,
    using the Terminal on our local machine.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: SSH 是一种在不安全的网络上安全传输数据的协议。这将使我们能够通过本地计算机的终端，访问并运行服务器上的代码。
- en: Let's start by copying the `ssh root@127.105.72.121` command by clicking on
    the clipboard icon next to it, which you can see in *Figure 12.4* as well.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们先通过点击旁边的剪贴板图标来复制`ssh root@127.105.72.121`命令，你可以在*图 12.4*中看到该图标。
- en: 'Now, open the terminal application on your local machine and paste the command,
    as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开本地计算机上的终端应用程序，并粘贴以下命令：
- en: '[PRE0]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As you can see, we had two main responses: one asking if we want to connect
    and add the IP to the list of known hosts, to which we answered `yes`; and another
    response, after having confirmed, asking us for our password.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们有两个主要的回应：一个是询问是否要连接并将 IP 添加到已知主机列表，我们回答了`yes`；另一个是在确认后，要求我们输入密码。
- en: 'Once you enter your password, which you have created for this specific server
    (Linode) and not for your account, you get the new prompt, as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你输入为该特定服务器（Linode）创建的密码，而不是为你的账户设置的密码，你将看到新的提示符，如下所示：
- en: '[PRE1]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You now have root access to your server from your own terminal application.
    A good thing to do immediately (and frequently) is to update your system''s packages.
    Two quick commands to do that are shown here:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经可以从自己的终端应用程序访问服务器的 root 权限。立即做一件好事（并且要经常做）就是更新系统的软件包。下面是两个可以快速完成这项工作的命令：
- en: '[PRE2]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Later on, you will probably need to manage updates to other packages that you
    install separately.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 以后，你可能需要管理你单独安装的其他软件包的更新。
- en: Having root access is very powerful and you can do anything as the root user,
    which means that this could also be a security risk. If someone else were able
    to accidentally sign in using your root user, they could potentially add or delete
    any files they want, with no restrictions whatsoever.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有 root 访问权限非常强大，你可以作为 root 用户做任何事情，这意味着这也可能带来安全风险。如果其他人能够不小心使用你的 root 用户登录，他们就可以任意添加或删除任何文件，完全没有任何限制。
- en: 'Because of that, we will use the recommended practice of creating a limited
    user immediately, and only signing in using that user. Proceed as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将遵循推荐的做法，立即创建一个受限用户，并仅使用该用户登录。按照以下步骤进行：
- en: 'Create a new user using whatever name you want, as follows:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的用户，使用你想要的任何名称，如下所示：
- en: '[PRE3]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You will be prompted to enter and re-enter a password for this user. By now,
    you will have three passwords: one for the Linode account, another for the root
    user of this Linode, and one for the limited user we just created. Optionally,
    you can also provide the full name, phone number, and other details. You can hit
    *Enter* and skip those options if you want. Even though this user is limited,
    we can add it to the `sudo` (superuser `do`!) group. This will allow this user
    to access root privileges temporarily, whenever we want to make some admin tasks
    or access sensitive files. Now that we have a new limited user, let''s add it
    to the `sudo` group, as follows:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 系统会提示你为该用户输入并重新输入密码。到现在为止，你已经有了三个密码：一个是 Linode 账户的密码，另一个是该 Linode 的 root 用户密码，还有一个是我们刚创建的受限用户的密码。你还可以选择提供全名、电话号码等详细信息。如果你想跳过这些选项，可以直接按*Enter*键。尽管这个用户是受限的，但我们可以将它添加到`sudo`（超级用户`do`！）组中。这样，当我们需要进行一些管理员任务或访问敏感文件时，这个用户可以暂时访问
    root 权限。现在我们已经创建了一个新的受限用户，接下来将其添加到`sudo`组中，步骤如下：
- en: '[PRE4]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Having created a limited user that can temporarily use `sudo` privileges, we
    can now sign out of root, and log back in again with the new user, as follows:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建了一个有限的用户并能暂时使用`sudo`权限后，我们可以退出 root 账户，然后重新登录使用新用户，如下所示：
- en: '[PRE5]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You should get a message that the connection to your IP address was lost, and
    you should see the prompt in the Terminal of your local machine. Now, we log in
    using the new user, the same way we did previously, as follows:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该会看到一条消息，表示与你的 IP 地址的连接已丢失，并且你应该看到本地机器终端中的提示符。现在，我们使用新用户登录，方法与之前相同，如下所示：
- en: '[PRE6]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Once you log in successfully, you will be given a new prompt showing the logged-in
    user, as seen here:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你成功登录，你将看到一个显示登录用户的新提示，如下所示：
- en: '[PRE7]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We are now ready to get started with building our app on the server, but before
    that, let''s see how we can access sensitive files and use `sudo` privileges,
    as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备在服务器上构建应用程序，但在此之前，让我们看看如何访问敏感文件并使用`sudo`权限，如下所示：
- en: 'Try to access one of the system''s log files—for example, using the `cat` command,
    as illustrated in the following code snippet:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试访问系统的一个日志文件，例如使用`cat`命令，如下代码片段所示：
- en: '[PRE8]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We were not given permission, which is the right outcome. Now, we can ask for
    `sudo` access by running the same command and preceding it with the `sudo` command,
    as follows:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们没有被授予权限，这是正确的结果。现在，我们可以通过运行相同的命令并在前面加上`sudo`命令来请求`sudo`访问，如下所示：
- en: '[PRE9]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Enter the password for this user and get access to the requested sensitive files.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入该用户的密码并获取访问所请求的敏感文件的权限。
- en: You will face this situation quite frequently, and you can easily use the `sudo`
    command to get temporary root access.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你将经常遇到这种情况，你可以轻松地使用`sudo`命令来获取临时的 root 权限。
- en: We have a good part of our server ready to go, but we are still not there yet.
    We now want to get our files and data on the server, and then install the required
    Python packages.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的服务器已经准备好了一大部分，但还没有完全就绪。接下来，我们需要将文件和数据上传到服务器，并安装所需的 Python 包。
- en: Running the app on the server
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在服务器上运行应用程序
- en: What we will do in this section is exactly what we did back in [*Chapter 1*](B16780_01_Final_NM_ePub.xhtml#_idTextAnchor015),
    *Overview of the Dash Ecosystem*. We will clone the code and data repository from
    GitHub and get them to the server, install the dependencies, and try to run the
    app.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中我们将做的事情正是我们在[*第 1 章*](B16780_01_Final_NM_ePub.xhtml#_idTextAnchor015)中所做的，*Dash
    生态系统概述*。我们将从 GitHub 克隆代码和数据仓库，将它们传送到服务器，安装依赖项，并尝试运行应用程序。
- en: You typically have Python already installed on such servers, but it's always
    good to check and know how to get it, in case you don't. An easy way to check
    if we have it installed, and to get the version in one go, is to run `python --version`
    from the command line. Keep in mind that the `python` command can be interpreted
    to mean Python 2\. The upgrade to Python 3 took a while to get fully implemented,
    and so, during that time, to differentiate between the two versions the `python3`
    command was used, to be explicit about wanting to run Python version 3\. This
    applies to the `pip` command, which can also be run as `pip3`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 你通常在这样的服务器上已经安装了 Python，但最好检查一下，确认如何获取它，以防没有安装。检查是否已安装以及获取版本的简单方法是从命令行运行`python
    --version`。请记住，`python`命令可以解释为 Python 2。升级到 Python 3 花了一段时间才完全实现，因此在那段时间里，为了区分两个版本，使用了`python3`命令，以明确表示希望运行
    Python 版本 3。这同样适用于`pip`命令，它也可以作为`pip3`运行。
- en: 'When I ran `python3 --version`, I got version 3.8.6\. By the time you read
    this, the default version might be different. Also, at the time of this writing,
    Python 3.9 was launched and was considered stable. This is what I got when I tried
    to run it from the command line:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当我运行`python3 --version`时，我得到了版本 3.8.6。等你阅读本文时，默认版本可能会有所不同。此外，在撰写本文时，Python 3.9
    已经发布，并被认为是稳定版本。这是我在命令行中尝试运行时得到的结果：
- en: '[PRE10]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: No explanation needed. We were also reminded that in order to install such a
    package, we need to use `sudo` as well. These are some examples of what you can
    use and what you might typically face, but Linux administration is another massive
    topic, and it's good to familiarize yourself with some of its basics.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 不需要解释。我们还被提醒，要安装这样的包，我们还需要使用`sudo`。这些是你可能会使用的示例以及可能遇到的情况，但 Linux 管理是一个庞大的话题，熟悉一些基本概念是很有帮助的。
- en: 'Let''s now activate a virtual environment and clone the GitHub repository,
    using the exact same steps we used in [*Chapter 1*](B16780_01_Final_NM_ePub.xhtml#_idTextAnchor015),
    *Overview of the Dash Ecosystem*, as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们激活虚拟环境并克隆 GitHub 仓库，使用与 [*第 1 章*](B16780_01_Final_NM_ePub.xhtml#_idTextAnchor015)，*Dash
    生态系统概览* 中相同的步骤，如下所示：
- en: 'Create a Python virtual environment in a folder called `dash_project` (or any
    other name you want). This will also create a new folder with the name you chose.
    Note that you might need to install `venv` for this to work, and you should get
    the command to do so, as in the previous example, as follows:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个名为 `dash_project`（或你选择的其他名字）的文件夹中创建一个 Python 虚拟环境。这也会创建一个新的文件夹，名称与你选择的名字一致。请注意，你可能需要安装
    `venv`，才能让这一步骤正常工作，具体命令如前面例子所示：
- en: '[PRE11]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Activate the virtual environment. You should now see the name of the environment
    in parentheses, indicating that the environment is activated, as illustrated in
    the following code snippet:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 激活虚拟环境。你现在应该能看到环境名称在括号中显示，表示环境已经被激活，如以下代码片段所示：
- en: '[PRE12]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Go into the environment folder by running the following command:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令进入环境文件夹：
- en: '[PRE13]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We now want to clone our GitHub repository, and get all available files and
    code on our server. We will use the book''s repository as an example, but I encourage
    you to run and clone your own instead. Run the following command:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们要克隆我们的 GitHub 仓库，并将所有可用的文件和代码获取到服务器上。我们将使用书中的仓库作为示例，但我鼓励你运行并克隆你自己的仓库。运行以下命令：
- en: '[PRE14]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next, we need to install the required packages, which we do by getting into
    the main folder and running the command for that, as follows:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要安装所需的包，通过进入主文件夹并运行相应的命令，如下所示：
- en: '[PRE15]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We can now enter into any chapter''s folder to run that particular version
    of the app. In the following code snippet, we can see what happens if we go into
    the final version of [*Chapter 11*](B16780_11_Final_NM_ePub.xhtml#_idTextAnchor151),
    *URLs and Multi-Page Apps*:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以进入任何章节的文件夹，运行该版本的应用程序。在以下的代码片段中，我们可以看到，如果我们进入 [*第 11 章*](B16780_11_Final_NM_ePub.xhtml#_idTextAnchor151)，*URLs
    和多页面应用程序*的最终版本，会发生什么：
- en: '[PRE16]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Going through the preceding sequence of steps produces the exact same result
    that we are familiar with when running our apps locally, as you can see in the
    following screenshot:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 按照之前的步骤操作，得到的结果与我们在本地运行应用程序时熟悉的完全相同，正如下面的截图所示：
- en: '![Figure 12.5 – The app running on the server](img/B16780_12_5.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.5 – 应用程序在服务器上运行](img/B16780_12_5.jpg)'
- en: Figure 12.5 – The app running on the server
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.5 – 应用程序在服务器上运行
- en: Getting the preceding message means that the code is working fine, with no issues.
    Of course, it also gives us a big warning that we are using a development server
    only and that we should not use it in a production deployment.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 得到之前的消息意味着代码正常运行，没有问题。当然，它也给了我们一个大大的警告，表示我们仅在使用开发服务器，不能将其用于生产环境部署。
- en: So, we will set up our web server. But before that, we need to use the interface
    that makes it easy for our web framework (Flask) to work with any web server we
    want. This interface is called a WSGI (pronounced Wiz-ghee, or whiskey!).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们将设置我们的 Web 服务器。但在此之前，我们需要使用一个接口，它使我们的 Web 框架（Flask）能够与任何我们想要的 Web 服务器协同工作。这个接口被称为
    WSGI（发音为 Wiz-ghee 或 whisky！）。
- en: 'Let''s first establish a basic understanding of the components and phases involved
    in serving our app that we will be working with. The following screenshot shows
    a simple sequence that requests and responses flow through when a user accesses
    our app from their browser:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们对涉及到的组件和阶段建立一个基本的理解，当用户从浏览器访问我们的应用程序时，请求和响应会经过一个简单的流程，如下图所示：
- en: '![Figure 12.6 – The components of our app, on a public server](img/B16780_12_6.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.6 – 我们应用程序的组件，部署在公共服务器上](img/B16780_12_6.jpg)'
- en: Figure 12.6 – The components of our app, on a public server
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.6 – 我们应用程序的组件，部署在公共服务器上
- en: The request starts form the left (as you can see in the preceding screenshot),
    and then goes through several components until it reaches Dash, which runs our
    `app.py` module. Then, our app's code generates a response that goes through the
    same components in the opposite direction, until it reaches the user's browser.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 请求从左侧开始（正如前面截图所示），然后经过多个组件，直到到达 Dash，运行我们的 `app.py` 模块。接着，我们的应用程序代码生成一个响应，反向通过相同的组件，直到到达用户的浏览器。
- en: 'Let''s briefly discuss each of those elements, as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要讨论一下这些元素，如下所示：
- en: '**Browser**: This is straightforward and can mean any **HyperText Transfer
    Protocol** (**HTTP**) client. When the user enters a **Uniform Resource Locator**
    (**URL**) and hits *Enter*, the browser makes a request to the web server.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**浏览器**：这是直接的，可以是任何 **超文本传输协议**（**HTTP**）客户端。当用户输入 **统一资源定位符**（**URL**）并按下
    *回车键*时，浏览器会向 Web 服务器发出请求。'
- en: '**Web server**: The job of the web server is to handle the requests that it
    receives. Our problem is that the server doesn''t execute Python code, so there
    needs to be some way for us to get the requests, interpret them, and return responses.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Web 服务器**：Web 服务器的工作是处理它接收到的请求。我们的问题是服务器不能执行 Python 代码，因此我们需要某种方式来获取请求，解释它们，并返回响应。'
- en: '**WSGI server**: This is the middleware that does the job of speaking the server''s
    language, as well as speaking Python. Having this set up means that our web framework
    (Flask, in this case) does not need to worry about handling the server or handling
    many requests. It can focus on creating the web app, and only needs to make sure
    that it conforms to the WSGI specification. This also means that with this set
    up, we are free to change our web server and/or WSGI server without having to
    make any changes to our app''s code.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**WSGI 服务器**：这是一个中间件，负责翻译服务器语言并与 Python 进行交互。设置好这个意味着我们的 Web 框架（在这个例子中是 Flask）不需要关心处理服务器或处理多个请求。它可以专注于创建
    Web 应用，只需要确保它符合 WSGI 规范。这也意味着有了这个设置，我们可以在不修改应用代码的情况下，随时更换 Web 服务器或 WSGI 服务器。'
- en: '**Web framework**: This is the Flask web framework with which Dash is built.
    A Dash app is basically a Flask app, and we have covered this quite extensively.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Web 框架**：这是 Dash 构建的 Flask Web 框架。Dash 应用本质上是一个 Flask 应用，我们已经对此做了相当广泛的介绍。'
- en: We don't need to know about web servers or WSGI servers any more than this for
    now. Let's see how simple it is to run our app using our WSGI server.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们无需了解更多关于 Web 服务器或 WSGI 服务器的知识。让我们看看使用 WSGI 服务器运行我们的应用是多么简单。
- en: Setting up and running the app with a WSGI
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 WSGI 设置并运行应用
- en: We have run our app using the `python app.py` command from the command line.
    Alternatively, we used the `app.run_server` method when running with `jupyter_dash`.
    We are going to do it now with Gunicorn, our WSGI server.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经通过命令行使用 `python app.py` 命令运行了我们的应用。或者，在使用 `jupyter_dash` 时，我们使用了 `app.run_server`
    方法。现在我们将通过 Gunicorn（我们的 WSGI 服务器）来运行它。
- en: 'The command is slightly different from the previous one and is run with the
    following pattern:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令与之前的略有不同，按照以下模式运行：
- en: '[PRE17]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We have two main differences here. First, we only use the module name, or the
    filename without the `.py` extension. Then, we add a colon, and then the server
    name. This is a simple variable that we have to define, and it can be done with
    one line of code, right after we define our top-level `app` variable, as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个主要的区别。首先，我们只使用模块名称，或者不带 `.py` 扩展名的文件名。然后，我们添加一个冒号，再加上服务器名称。这是一个简单的变量，我们需要定义它，且可以在定义完顶层的
    `app` 变量后，使用一行代码来完成，如下所示：
- en: '[PRE18]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now that we have defined our sever as `server`, and assuming our app is in
    a file called `app.py`, we can run the app from the command line, as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将服务器定义为 `server`，假设我们的应用文件名为 `app.py`，我们可以通过命令行运行应用，如下所示：
- en: '[PRE19]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: That's it for the WSGI server!
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些，关于 WSGI 服务器的内容完结了！
- en: 'Once that change has been made, we can go to the folder where our app is and
    run it with the preceding command. The following screenshot shows the output we
    get when running our app with the `gunicorn` command:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦做出更改，我们可以去到我们的应用所在文件夹，使用前述命令运行它。以下截图显示了我们使用 `gunicorn` 命令运行应用时得到的输出：
- en: '![Figure 12.7 – Running the app with the Gunicorn WSGI server](img/B16780_12_7.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.7 – 使用 Gunicorn WSGI 服务器运行应用](img/B16780_12_7.jpg)'
- en: Figure 12.7 – Running the app with the Gunicorn WSGI server
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.7 – 使用 Gunicorn WSGI 服务器运行应用
- en: This output shows that our app is working fine. We can also see that it is listening
    at a different port. The default port for Dash is `8050`, while here it is `8000`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出表明我们的应用运行正常。我们还可以看到它监听的是不同的端口。Dash 的默认端口是 `8050`，而这里是 `8000`。
- en: We have come one step closer to the browser and the user. It seems the code
    is working fine with the WSGI server. Let's now set up our web server to make
    our app publicly available.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们离浏览器和用户更近了一步。看起来代码在 WSGI 服务器上运行正常。现在让我们设置 Web 服务器，使我们的应用可以公开访问。
- en: Setting up and configuring the web server
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置和配置 Web 服务器
- en: We will be using nginx as our web server in this example. You can now stop the
    app using *Ctrl* + *C* from the command line. Alternatively, you can stop your
    app using the `kill` command, which requires you to know the ID of the process
    that is running your app. This is useful if you log in later and have no idea
    which processes are running, and want to identify the process responsible for
    your app.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，我们将使用nginx作为Web服务器。你现在可以通过命令行使用*Ctrl* + *C*停止应用程序。或者，你也可以使用`kill`命令停止应用程序，但这需要你知道运行应用程序的进程ID。如果你稍后登录并不知道哪些进程在运行，可以通过这种方式识别负责你应用程序的进程。
- en: 'You can run the `ps -A` process status command from the command line to get
    all the currently running processes. You can either scroll to find a process whose
    name contains `gunicorn` or add a pipe, and search for that process in the previous
    command''s output, as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从命令行运行`ps -A`进程状态命令，获取当前运行的所有进程。你可以滚动查找包含`gunicorn`的进程，或者通过管道在上一个命令的输出中搜索该进程，如下所示：
- en: '[PRE20]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Running the preceding command while the app is running gets us the output you
    see in the following screenshot:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序运行的同时运行上面的命令，会得到如下截图所示的输出：
- en: '![Figure 12.8 – How to find the process IDs for processes containing a certain
    text pattern](img/B16780_12_8.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![图12.8 – 如何查找包含特定文本模式的进程的进程ID](img/B16780_12_8.jpg)'
- en: Figure 12.8 – How to find the process IDs for processes containing a certain
    text pattern
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.8 – 如何查找包含特定文本模式的进程的进程ID
- en: The process IDs are the same as the ones that we got when we ran with Gunicorn,
    which you can also see in the preceding screenshot.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 进程ID与我们在运行Gunicorn时获得的ID相同，前面截图中也可以看到。
- en: 'To stop the app, you can use the `kill` command, as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 要停止应用程序，你可以使用`kill`命令，如下所示：
- en: '[PRE21]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now that we have checked that our app runs with our WSGI server, it is time
    to set up our web server.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经确认应用程序能够与我们的WSGI服务器一起运行，是时候设置Web服务器了。
- en: As mentioned before, even though we will use the simplest possible configuration
    to make things easy for us, we will still be using one of the most powerful web
    servers available.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，尽管我们将使用最简单的配置来简化操作，但我们仍将使用最强大的Web服务器之一。
- en: 'Let''s start by installing it. From the command line, while logged in to your
    server, run the following command:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从安装它开始。从命令行登录到你的服务器后，运行以下命令：
- en: '[PRE22]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We now want to create a configuration file for our app. Installing nginx does
    several things, one of which is creating a `sites-enabled` folder. We want to
    create our configuration file there, with basic options. We can use any text editor
    for that; a simple one to use that you can usually find on Linux machines is the
    `nano` editor. Running it as a command followed by a filename opens that file
    for editing (or creates one if it doesn't exist).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在要为我们的应用程序创建一个配置文件。安装nginx时会做几件事，其中之一是创建一个`sites-enabled`文件夹。我们想要在其中创建我们的配置文件，并设置基本选项。你可以使用任何文本编辑器，通常在Linux机器上能找到一个简单的编辑器`nano`。作为命令运行它，后面跟着文件名，打开该文件进行编辑（如果文件不存在，则创建它）。
- en: 'From the command line, run the following command to open and edit our file:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 从命令行运行以下命令来打开并编辑我们的文件：
- en: '[PRE23]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You should get an empty file, and you can copy and paste the following code,
    but make sure to replace the IP address after `server_name` with your own IP address:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该得到一个空文件，你可以复制并粘贴以下代码，但确保将`server_name`后的IP地址替换为你自己的IP地址：
- en: '[PRE24]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This code contains configuration for the `server` context, as you can see. It
    tells it to listen on port `80`, which is the default port for web servers. It
    also defines the `server_name` as the IP address. Later on, you can use this to
    define your own domain name.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这段代码包含了`server`上下文的配置。它告诉服务器监听端口`80`，这是Web服务器的默认端口。它还将`server_name`定义为IP地址。稍后，你可以用这个IP地址来定义你自己的域名。
- en: It then defines the behavior of the server for `location /` under another block.
    The most important thing for us is that we are making nginx a proxy server with
    the `proxy_pass` directive and telling it to listen to the URL and port that Gunicorn
    is listening to. So, now, the cycle should be complete. Our web server will be
    sending and receiving requests and responses through the correct URL and port,
    where the interface with our Python code is handled by Gunicorn.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它在另一个块中定义了`location /`的服务器行为。对我们来说最重要的是，我们通过`proxy_pass`指令将nginx设置为代理服务器，并告诉它监听Gunicorn正在监听的URL和端口。因此，现在，整个循环应该完成了。我们的Web服务器将通过正确的URL和端口发送和接收请求与响应，而与Python代码的接口将由Gunicorn处理。
- en: 'Installing nginx creates a default configuration file, which we need to unlink
    with the following command:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 nginx 会创建一个默认配置文件，我们需要用以下命令将其解除链接：
- en: '[PRE25]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We just need to reload nginx after making this change. Keep this in mind when
    you make any changes in the future. You should reload nginx for any changes to
    take place, which you can do with the following command:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要在做完这个更改后重新加载nginx。将来做任何更改时请记住这一点。你应该在任何更改发生时重新加载nginx，可以使用以下命令来实现：
- en: '[PRE26]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, we can run our app with `gunicorn app:server`, and then, using our browser,
    we can navigate to our IP address and see the app online, as can be seen in the
    following screenshot:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用`gunicorn app:server`来运行应用，然后，通过浏览器访问我们的IP地址，看到应用在线，如下截图所示：
- en: '![Figure 12.9 – The app deployed on a public address](img/B16780_12_9.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图12.9 – 应用部署在公共地址上](img/B16780_12_9.jpg)'
- en: Figure 12.9 – The app deployed on a public address
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.9 – 应用部署在公共地址上
- en: Congratulations! Your app is now available to anyone with an internet connection;
    it is on a public server, and you can share your work with the world.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你的应用现在对任何有互联网连接的人可用；它已经部署在公共服务器上，你可以与全世界分享你的工作。
- en: What happens after that? How do you make changes, and what if there were upgrades
    to the packages that you used?
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来会发生什么？你如何进行更改，如果你使用的包有升级怎么办？
- en: We tackle some simple guidelines that might be helpful to follow for the maintenance
    phase, after we have deployed our app.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们部署应用后，我们将讨论一些可能有助于维护阶段的简单指南。
- en: Managing maintenance and updates
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理维护和更新
- en: Several things will probably need to be managed and handled after publishing
    your app, and we cover a few of them.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 发布应用后，可能需要管理和处理一些事项，我们将讨论其中的几个。
- en: Fixing bugs and making changes
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修复 bug 和进行更改
- en: This should follow the same workflow we established at the beginning of this
    chapter. Any changes to our code, whether bug fixes or additions to our functionality,
    should be done the same way. We edit code locally, make sure it is running correctly,
    and then push to the central Git repository. Then, from the server, we pull the
    changes and rerun the app.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该遵循我们在本章开始时建立的相同工作流程。无论是修复 bug 还是增加功能，任何对代码的更改都应该以相同的方式进行。我们在本地编辑代码，确保其正确运行，然后推送到中央
    Git 仓库。接着，在服务器上拉取这些更改并重新运行应用。
- en: Updating Python packages
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新 Python 包
- en: There are several packages that our app depends on, and you will most likely
    have even more in your daily work. Those packages will release updates every now
    and then, and you need to make sure that they are up to date. Some of those updates
    are security updates and need to be handled as soon as possible, while others
    introduce new options to packages. In general, you can run `pip install --upgrade
    <package_name>` to achieve this, but you will still need to check if the new functionality
    might change the way your app is running or whether it will break your existing
    code. Well-maintained packages usually publish any such breaking changes and also
    provide instructions for upgrading, if needed.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用依赖于多个包，你在日常工作中可能会遇到更多。这些包会定期发布更新，你需要确保它们是最新的。其中一些更新是安全更新，必须尽快处理，而其他更新则会为包引入新选项。通常，你可以运行`pip
    install --upgrade <package_name>`来实现这一点，但你仍然需要检查新的功能是否会改变应用的运行方式，或者是否会破坏现有代码。维护良好的包通常会发布任何此类重大更改，并在需要时提供升级说明。
- en: 'Once you have decided to upgrade packages, you can run the upgrade locally
    to first test your app and make sure it is running with the new version, as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你决定升级包，可以先在本地运行升级，以测试应用并确保它与新版本兼容，如下所示：
- en: 'From the command line, go into the app''s folder on your local machine, as
    follows:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从命令行进入你本地机器上的应用文件夹，如下所示：
- en: '[PRE27]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Activate the virtual environment, like this:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 激活虚拟环境，方法如下：
- en: '[PRE28]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You should now see the name of your environment in parentheses `(env_name)`
    and you are now ready to upgrade the package of your choice, as follows:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你应该能看到你的环境名称在括号中`(env_name)`，你现在准备好升级你选择的包，如下所示：
- en: '[PRE29]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Assuming everything went fine, run your app, and make sure it is running as
    expected by executing the following command:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设一切正常，运行你的应用，并确保它按预期运行，执行以下命令：
- en: '[PRE30]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If everything went well, you now need to update your `requirements.txt` file
    to reflect the new version of the package, and possibly modified versions of other
    dependencies. We first use the `pip freeze` command. This takes all the available
    packages in the current environment, as well as their dependencies, together with
    the right version number and prints them out to `stdout`. Now, we want to take
    this output and redirect it to the `requirements.txt` file to overwrite it with
    the updated requirements. We can do those two steps in one go, but it''s good
    to familiarize yourself with the output of the first command first, which can
    be seen here:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一切顺利，现在你需要更新`requirements.txt`文件，以反映包的新版本，并可能修改了其他依赖项的版本。我们首先使用`pip freeze`命令。该命令将当前环境中的所有可用包及其依赖项以及正确的版本号一起输出到`stdout`。现在，我们想要将这个输出重定向到`requirements.txt`文件，以便用更新的要求覆盖它。我们可以一步完成这两个步骤，但首先了解第一个命令的输出是好的，可以看到如下：
- en: '[PRE31]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Commit the changes to the Git repository and push to GitHub. The `git add`
    command adds the file(s) to the staging area, which means they are now ready to
    be added to the history of the repository. The next step is to commit those additions
    with the `git commit` command, which also takes a message in which you state what
    has been done. We then submit the changes to the online repository with the `push`
    command, as follows:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将变更提交到Git仓库并推送到GitHub。`git add`命令将文件添加到暂存区，意味着它们现在已准备好被添加到仓库的历史记录中。下一步是使用`git
    commit`命令提交这些新增内容，该命令还需要一个消息，说明已做了什么更改。然后，我们使用`push`命令将变更提交到在线仓库，命令如下：
- en: '[PRE32]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now that you have the latest `requirements.txt` file on your central Git repository
    you can pull it to your server, just as we did in this chapter. After logging
    in to your server, moving into your project''s folder, and activating its virtual
    environment, you can pull the changes. The `git pull` command does two things.
    First, it fetches the latest changes of the repository from the remote server.
    Then, it merges the changes into the local copy, and you get the updated app.
    The command is shown here:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，既然你已经在中央Git仓库中拥有了最新的`requirements.txt`文件，你可以像本章中所做的那样将其拉取到你的服务器上。登录到服务器后，进入项目文件夹并激活虚拟环境，然后你可以拉取变更。`git
    pull`命令做了两件事。首先，它从远程服务器获取仓库的最新变更。然后，它将变更合并到本地副本中，你就得到了更新后的应用程序。命令如下所示：
- en: '[PRE33]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The change we fetched and merged in this case was the updated `requirements.txt`
    file. We now run the following command to install our packages on the server using
    the new versions:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在这个案例中获取并合并的变更是更新过的`requirements.txt`文件。现在我们运行以下命令，在服务器上安装使用新版本的包：
- en: '[PRE34]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This should start your app again, with the latest updates included. While we
    changed the requirements file in this case, we could have also changed the app's
    file, or maybe added new data. Whatever the change, this is the general cycle
    that we go through to incorporate those changes.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会重新启动你的应用程序，并包含最新的更新。虽然在这个案例中我们修改了requirements文件，但我们也可以修改应用程序文件，或者可能添加新的数据。无论是什么变更，这是我们在应用这些变更时经历的一般流程。
- en: Now that you have a new component to handle—your server—you will also be managing
    and maintaining it as well.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了一个新的组件需要处理——你的服务器——你还需要管理和维护它。
- en: Maintaining your server
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 维护你的服务器
- en: 'The following list provides a very brief and oversimplified set of things that
    you might be interested in, without instructions. The proper way is to learn more
    about Linux system administration, but these are likely things you will want to
    manage and can easily find guides and documentation for:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表简要列出了你可能感兴趣的事情，并且没有详细说明。正确的做法是深入学习Linux系统管理，但这些是你可能想要管理的内容，并且可以很容易找到相应的指南和文档：
- en: '**Adding a custom domain**: You probably want a nice name for your app, and
    not an IP address. This is straightforward, and you need to buy a domain name
    from a registrar and make the necessary changes to enable that. You can find many
    examples and guides on Linode''s documentation on how to achieve that.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**添加自定义域名**：你可能希望为你的应用程序起一个好名字，而不是一个IP地址。这是简单的，你需要从注册商购买一个域名，并进行必要的更改来启用它。你可以在Linode的文档中找到很多示例和指南，了解如何实现这一点。'
- en: '**Setting up a security certificate**: This is important and has become straightforward
    and free to do. Many guides and examples are available for that as well.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设置安全证书**：这是很重要的，现在已经变得简单且免费。很多指南和示例也可以参考。'
- en: '**Updating packages**: As we did the first time we logged in, it''s good to
    constantly update your server''s packages and especially make sure you have the
    latest security updates.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更新包**: 就像我们第一次登录时所做的那样，定期更新服务器的软件包非常重要，特别是确保拥有最新的安全更新。'
- en: '`sudo` group. There are other things that can be done as well, such as hardening
    your SSH access with authentication key pairs and configuring a firewall, among
    other actions.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sudo` 组。还有其他可以做的事情，比如使用认证密钥对增强SSH访问安全性，配置防火墙等其他操作。'
- en: We made a big leap in this chapter, and we quickly explored very powerful tools
    and techniques, so let's recap on what we covered in this chapter.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们迈出了重要的一步，快速探索了非常强大的工具和技术，因此让我们回顾一下本章涵盖的内容。
- en: Summary
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We started by establishing a simple workflow to manage the cycle of development,
    deployment, and updates. We defined three main components for this workflow and
    how they relate to one another. We discussed the relationship between local workstations,
    a central Git repository, and a web server, and set some guidelines on how work
    should flow between them.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先建立了一个简单的工作流程来管理开发、部署和更新的周期。我们为这个工作流程定义了三个主要组成部分及它们之间的关系。我们讨论了本地工作站、中央Git仓库和Web服务器之间的关系，并设定了一些工作流程应如何流动的准则。
- en: We then created a hosting account, set up a virtual server, and got ready to
    do work on the server locally. Then, we explored how we can access the server
    locally through SSH, and ran some basic security and administration tasks. We
    cloned our repository and saw that it can run on the server exactly as we do locally.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建了一个托管账户，设置了一个虚拟服务器，并准备在本地服务器上进行工作。然后，我们探讨了如何通过SSH本地访问服务器，并运行了一些基本的安全和管理任务。我们克隆了我们的代码库，并看到它可以在服务器上完全像在本地一样运行。
- en: We then discussed the two other required components for our app to be available
    publicly. We ran our app slightly differently by using a WSGI server. The last
    step was to install and configure a web server, using the simplest setup possible.
    Our app was then accessible on a public IP.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们讨论了我们的应用程序公开可用的另外两个必需组件。我们通过使用WSGI服务器稍微不同地运行我们的应用程序。最后一步是安装和配置一个Web服务器，使用尽可能简单的设置。然后我们的应用程序可以在公共IP上访问了。
- en: Finally, we explored which ongoing maintenance tasks might be interesting. Most
    importantly, we ran through the process of upgrading our Python packages, changing
    a file, committing it to Git, pushing it to the online repository, and merging
    the changes to our server. This is definitely something that you will be doing
    continuously.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们探讨了哪些正在进行的维护任务可能会很有趣。最重要的是，我们完成了升级Python包的过程，修改了一个文件，提交到Git，推送到在线仓库，并将更改合并到我们的服务器上。这绝对是你将会持续进行的工作。
- en: Our final chapter of the book will be about other directions that you might
    be interested in exploring and other areas that we haven't covered. You now know
    your way around Dash and can very easily navigate and find out whatever you need
    to know, yet there are many other things to explore. We will take a quick tour
    of those options in the last chapter.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的最后一章将讨论你可能有兴趣探索的其他方向和我们尚未涵盖的其他领域。你现在已经熟悉Dash，并可以非常轻松地导航和找到你需要了解的任何内容，但还有许多其他内容可以探索。我们将在最后一章中快速浏览这些选项。
