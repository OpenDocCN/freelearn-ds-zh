- en: Chapter 6. Adding NoSQL Persistence to Storm
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。将NoSQL持久性添加到Storm
- en: In this chapter, we will graduate to the next step in understanding Storm—we
    will add persistence to our topology. We have chosen Cassandra for very obvious
    reasons, which will be elaborated during this chapter. The intent is to make you
    understand how the Cassandra data store can be integrated with the Storm topology.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将毕业于理解Storm的下一步——我们将为我们的拓扑添加持久性。我们选择了Cassandra，原因是非常明显的，这将在本章中详细阐述。我们的目的是让您了解Cassandra数据存储如何与Storm拓扑集成。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: The advantages of Cassandra
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cassandra的优势
- en: Introduction to columnar databases and column family design fundamentals
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列式数据库和列族设计基础知识的介绍
- en: Setting up a Cassandra cluster
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置Cassandra集群
- en: Introducing the CQLSH, CLI, and Connector APIs
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍CQLSH、CLI和连接器API
- en: Storm topology wired to the Cassandra store
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Storm拓扑与Cassandra存储相连
- en: Understanding the mechanism of persistence
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解持久性的机制
- en: The best practices for Storm Cassandra applications
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Storm Cassandra应用程序的最佳实践
- en: The advantages of Cassandra
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Cassandra的优势
- en: This is the first and most obvious question anyone would ask, "Why are we using
    NoSQL?" Well, the very quick answer for looking at NoSQL instead of traditional
    data stores is the same as why the world is moving to big data—low cost, highly
    scalable, and reliable solutions that can store endless amounts of data.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这是任何人都会问的第一个和最明显的问题，“为什么我们要使用NoSQL？”嗯，对于选择NoSQL而不是传统数据存储的非常快速的答案与为什么世界正在转向大数据是一样的——低成本、高可扩展性和可靠的解决方案，可以存储无限量的数据。
- en: 'Now, the next question is why Cassandra, and why not anything else out of the
    NoSQL stack. Here the answer lies in the kind of problem and solution approach
    we are trying to implement. Well, we are handling real-time analytics, and everything
    we need should be accurate, fail-safe, and lightning fast. Therefore, Cassandra
    is the best choice because:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，下一个问题是为什么选择Cassandra，而不是NoSQL堆栈中的其他任何东西。答案在于我们正在尝试实现的问题和解决方案方法的性质。嗯，我们正在处理实时分析，我们需要的一切都应该准确、安全可靠和极快速。因此，Cassandra是最佳选择，因为：
- en: It has the fastest writes amongst its peers such as HBase and so on
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它在其同行中（如HBase等）拥有最快的写入速度
- en: It is linearly scalable with peer-to-peer design
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它具有点对点设计的线性可扩展性
- en: No single point of failure
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有单点故障
- en: Read and write requests can be handled without impacting each other's performance
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读写请求可以在不影响彼此性能的情况下处理
- en: Handles search queries comprising millions of transactions and lightning-fast
    speeds
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理包含数百万交易和极快速度的搜索查询
- en: Fail-safe and highly available with replication factors in place
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有复制因子的故障安全和高可用性
- en: Guarantees eventual consistency with the CAP theorem on NoSQL DBs
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在NoSQL数据库的CAP定理上保证最终一致性
- en: Column family design to handle a variety of formats
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列族设计以处理各种格式
- en: No or low licensing cost
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有或很低的许可成本
- en: Less development-ops or operational cost
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 较少的开发运维或运营成本
- en: It can be extended for integration on a variety of other big data components
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以扩展以集成各种其他大数据组件
- en: Columnar database fundamentals
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列式数据库基础知识
- en: One of the most important aspects of getting started with NoSQL data stores
    is getting to understand the fundamentals of columnar databases; or rather, let's
    use the actual term—column families.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 开始使用NoSQL数据存储最重要的一点是了解列式数据库的基础知识；或者更确切地说，让我们使用实际术语——列族。
- en: 'This is a concept that has a variety of implementations in different NoSQL
    databases, for instance:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个在不同的NoSQL数据库中有各种实现的概念，例如：
- en: '**Cassandra**: This is a key-value-pair-based NoSQL DB'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Cassandra**：这是一个基于键值对的NoSQL数据库'
- en: '**Mongo DB**: This is a document-based NoSQL DB'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Mongo DB**：这是一个基于文档的NoSQL数据库'
- en: '**Neo4J**: This is a graph DB'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Neo4J**：这是一个图形数据库'
- en: 'They differ from conventional RDBMS systems that are row-oriented in terms
    of the following:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 它们在以下方面与传统的面向行的关系数据库系统不同：
- en: Performance
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能
- en: Storage extendibility
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储可扩展性
- en: Fault tolerance
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容错性
- en: Low or no licensing cost
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 低或没有许可成本
- en: But having iterated all the differences and benefits of NoSQL DBs, you must
    clearly understand that the shift to NoSQL is a shift of the entire paradigm of
    data storage, availability, and access—they are not a replacement for RDBMS.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，尽管已经列举了所有NoSQL数据库的差异和优势，您必须清楚地理解，转向NoSQL是对数据存储、可用性和访问的整个范式的转变，它们并不是关系数据库的替代品。
- en: In the RDBMS world, we are all used to creating tables, but here in Cassandra,
    we create column families where we define the metadata of the columns, but the
    columns are actually stored as rows. Each row can have different sets of columns,
    thus making the whole column family relatively unstructured and extendible.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在关系数据库管理系统的世界中，我们都习惯于创建表，但在Cassandra中，我们创建列族，其中定义了列的元数据，但列实际上存储为行。每行可以有不同的列集，因此整个列族相对不太结构化和可扩展。
- en: Types of column families
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列族的类型
- en: 'There are two types of column families:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种类型的列族：
- en: '**Static column family**: As the name suggests, this has a static set of columns
    and is a very close surrogate of all well-known RDBMS tables, barring a few differences
    that are a result of its NoSQL heritage. Here is an example of a static column
    family:'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**静态列族**：顾名思义，它具有静态的列集，并且非常接近所有众所周知的关系数据库表，除了一些由于其NoSQL传统而产生的差异。以下是静态列族的一个示例：'
- en: '| Rowkey | Columns |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| 行键 | 列 |'
- en: '| --- | --- |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Raman | Name | E-mail | Cell no. | Age |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| Raman | 名字 | 电子邮件 | 电话号码 | 年龄 |'
- en: '|   | Raman Subramanian | aa@yahoo.com | 9999999999 | 20 |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| | Raman Subramanian | aa@yahoo.com | 9999999999 | 20 |'
- en: '| Edison | Name | E-mail | Cell no. | Age |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| Edison | 名字 | 电子邮件 | 电话号码 | 年龄 |'
- en: '|   | Edison Weasley | bb@yahoo.com | 88888888888 | 30 |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| | Edison Weasley | bb@yahoo.com | 88888888888 | 30 |'
- en: '| Amey | Name | E-mail | Cell no. | Age |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| Amey | 名字 | 电子邮件 | 电话号码 | 年龄 |'
- en: '|   | Amey Marriot | cc@yahoo.com | 7777777777 | 40 |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| | Amey Marriot | cc@yahoo.com | 7777777777 | 40 |'
- en: '| Sriman | Name | E-mail |   |   |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| Sriman | 名字 | 电子邮件 | | |'
- en: '|   | Sriman Mishra | dd@yahoo.com |   |   |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| | Sriman Mishra | dd@yahoo.com | | |'
- en: '**Dynamic column family**: This one gets the true essence of being unstructured
    and schema-less. Here, we don''t use predefined columns associated with the column
    family, but the same can be dynamically generated and supplied by the client application
    at the time of inserting data into the column family. During the creation or definition
    of a dynamic column family, we get to define the information about the column
    names and values by defining the comparators and validators. Here is an example
    of a dynamic column family:'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态列族**：这个真正体现了无结构和无模式的真正本质。在这里，我们不使用与列族关联的预定义列，而是可以由客户端应用程序在插入数据时动态生成和提供。在创建或定义动态列族时，我们可以通过定义比较器和验证器来定义有关列名和值的信息。以下是动态列族的一个示例：'
- en: '| Rowkey | Columns |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 行键 | 列 |'
- en: '| --- | --- |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Raman | Name | E-mail | Cell no. | Age |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| Raman | 名字 | 电子邮件 | 电话号码 | 年龄 |'
- en: '|   |   |   |   |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '|   |   |   |   |'
- en: '| Edison | Address | State | Territory |   |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| Edison | 地址 | 州 | 领土 |   |'
- en: '|   |   |   |   |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '|   |   |   |   |'
- en: '| Amey | Country | Sex | Cell no. | Age |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| Amey | 国家 | 性别 | 电话号码 | 年龄 |'
- en: '|   |   |   |   |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '|   |   |   |   |'
- en: '| Sriman | Nationality |   |   |   |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| Sriman | 国籍 |   |   |   |'
- en: '|   |   |   |   |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '|   |   |   |   |'
- en: Types of columns
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列的类型
- en: 'There are a variety of columns that Cassandra supports:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Cassandra支持各种列：
- en: '**Standard columns**: These columns contain a name; this is either static or
    dynamic and set by the writing application. A value (this is actually the attribute
    that stores the data) and timestamp are shown here:'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标准列**：这些列包含一个名称；这是由写入应用程序静态或动态设置的。这里显示了一个值（实际上是存储数据的属性）和时间戳：'
- en: '| Column_name |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| 列名 |'
- en: '| --- |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| --- |'
- en: '| value |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| 值 |'
- en: '| timestamp |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| 时间戳 |'
- en: Cassandra makes use of the timestamp associated with the column to find out
    the last update to the column. When data is queried from Cassandra, it orders
    by this timestamp and always returns the most recent value.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Cassandra利用与列相关联的时间戳来查找列的最后更新。当从Cassandra查询数据时，它按照这个时间戳排序，并始终返回最近的值。
- en: '**Composite columns**: Cassandra makes use of this storage mechanism to handle
    clustered rows. This is a unique way of handling all the logical rows together
    that share the same partition key into a single physical wide row. This enables
    Cassandra to accomplish the legendary feat of storing 2 billion columns per row.
    For example, let''s say I want to create a table where I capture live status updates
    from some social networking sites:'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复合列**：Cassandra利用这种存储机制来处理聚类行。这是一种处理所有逻辑行的独特方式，这些逻辑行共享相同的分区键，形成一个单个的物理宽行。这使得Cassandra能够完成存储每行20亿列的传奇壮举。例如，假设我想创建一个表，其中捕获来自一些社交网络站点的实时状态更新：'
- en: '[PRE0]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The live updates are being recorded under the `StatusUpdates` table that has
    the `username`, `message`, and `update_id` (which is actually a UUID) property.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 实时更新记录在`StatusUpdates`表下，该表具有`username`，`message`和`update_id`（实际上是UUID）属性。
- en: While designing a Cassandra column family, you should make extensive use of
    the functionality provided by UUIDs, which can be employed for sequencing data.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计Cassandra列族时，应充分利用UUID提供的功能，这可以用于对数据进行排序。
- en: The combination of the `user_id` and `update_id` properties from `timeseriesTable`
    can uniquely identify a row in chronology.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 来自`timeseriesTable`的`user_id`和`update_id`属性的组合可以唯一标识时间顺序中的一行。
- en: Cassandra makes use of the first column defined in the primary key as the partition
    key; this is also known as the row key.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Cassandra使用主键中定义的第一列作为分区键；这也被称为行键。
- en: '**Expiring columns**: These are special types of Cassandra columns that have
    a time to live (**TTL**) associated with them; the values stored in these columns
    are automatically deleted or erased after the TTL has elapsed. These columns are
    used for use cases where we don''t want to retain data older than a stated interval;
    for instance, if we don''t need data older than 24 hours. In our column family,
    I would associate a TTL of 24 hours with every column that is being inserted,
    and this data will be automatically deleted by Cassandra after 24 hours of its
    insertion.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过期列**：这些是Cassandra的特殊类型列，它们与时间到期（TTL）相关联；存储在这些列中的值在TTL过去后会自动删除或擦除。这些列用于我们不希望保留超过规定时间间隔的数据的用例；例如，如果我们不需要24小时前的数据。在我们的列族中，我会将每个插入的列关联一个24小时的TTL，并且这些数据将在插入后的24小时内被Cassandra自动删除。'
- en: '**Counter columns**: These are again specialized function columns that store
    a number incrementally. They have a special implementation and a specialized usage
    for situations where we use counters; for instance, if I need to count the number
    of occurrences of an event.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**计数列**：这些又是专门的功能列，用于递增存储数字。它们有一个特殊的实现和专门的用途，用于我们使用计数器的情况；例如，如果我需要计算事件发生的次数。'
- en: Setting up the Cassandra cluster
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置Cassandra集群
- en: Cassandra is a very scalable key-value store. It promises eventual consistency
    and its distributed ring-based architecture eliminates any single point of failure
    in the cluster, thus making it highly available. It's designed and developed to
    support very fast reads and writes over excessively large volumes of data .This
    fast write and read ability makes it a very strong contender to be used in an
    **online transaction processing** (**OLTP**) application to support large business
    intelligence systems.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Cassandra是一个非常可扩展的键值存储。它承诺最终一致性，其分布式基于环形的架构消除了集群中的任何单点故障，因此使其高度可用。它被设计和开发用于支持对大量数据进行非常快速的读写。这种快速的写入和读取能力使其成为用于支持大型业务智能系统的在线事务处理（OLTP）应用的一个非常强大的竞争者。
- en: Cassandra provides a column-family-based data model that is more flexible than
    typical key-value systems.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Cassandra提供了基于列族的数据模型，比典型的键值系统更灵活。
- en: Installing Cassandra
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装Cassandra
- en: 'Cassandra requires the most stable version of Java 1.6 that you can deploy,
    preferably the Oracle or Sun JVM. Perform the following steps to install Cassandra:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Cassandra需要部署的最稳定版本的Java 1.6，最好是Oracle或Sun JVM。执行以下步骤安装Cassandra：
- en: Download the most recent stable release (version 1.1.6 at the time of writing)
    from the Apache Cassandra site.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Apache Cassandra网站下载最新的稳定版本（写作时的版本为1.1.6）。
- en: 'Create a Cassandra directory under `/usr/local` as follows:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`/usr/local`下创建一个Cassandra目录，如下所示：
- en: '[PRE1]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Extract the downloaded TAR file to the `/usr/local` location. Use the following
    command:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将下载的TAR文件提取到`/usr/local`位置。使用以下命令：
- en: '[PRE2]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Cassandra needs a directory to store its data, log files, and cache files.
    Create `/usr/local/cassandra/tmp` to store this data:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Cassandra需要一个目录来存储其数据、日志文件和缓存文件。创建`/usr/local/cassandra/tmp`来存储这些数据：
- en: '[PRE3]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Update the `Cassandra.yaml` configuration file under `/usr/local/Cassandra/apache-cassandra-1.1.6/conf`.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`/usr/local/Cassandra/apache-cassandra-1.1.6/conf`下的`Cassandra.yaml`配置文件。
- en: 'The following properties will go into it:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 以下属性将进入其中：
- en: '[PRE4]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Calculate a token for each node using the following script and update the `initial_token`
    property to each node by adding a unique token value in `Cassandra.yaml`:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下脚本为每个节点计算一个token，并通过在`Cassandra.yaml`中添加唯一token值来更新每个节点的`initial_token`属性：
- en: '[PRE5]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Update the following property in the `conf/log4j-server.properties` file. Create
    the `temp` directory under `cassandra`:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`conf/log4j-server.properties`文件中的以下属性。在`cassandra`下创建`temp`目录：
- en: '[PRE6]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Increase the `rpc_timeout` property in `Cassandra.yaml` (if this timeout is
    very small and the network latency is high, Cassandra might assume the nodes are
    dead without waiting long enough for a response to propagate).
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 增加`Cassandra.yaml`中的`rpc_timeout`属性（如果此超时非常小且网络延迟很高，Cassandra可能会假定节点已死亡，而没有等待足够长的时间来传播响应）。
- en: Run the Cassandra server at `/usr/local/Cassandra/apache-cassandra-1.1.6 using
    bin/Cassandra –f`.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`/usr/local/Cassandra/apache-cassandra-1.1.6`上运行Cassandra服务器，使用`bin/Cassandra
    -f`。
- en: Run the Cassandra client at `/usr/local/Cassandra/apache-cassandra-1.1.6 using
    bin/Cassandra-cli` with a host and port.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`/usr/local/Cassandra/apache-cassandra-1.1.6`上使用`bin/Cassandra-cli`和主机和端口运行Cassandra客户端。
- en: 'Use the `bin/nodetool` ring utility at `/usr/local/Cassandra/apache-cassandra-1.1.6`
    to verify a properly connected cluster:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`/usr/local/Cassandra/apache-cassandra-1.1.6`下的`bin/nodetool` ring实用程序验证正确连接的集群：
- en: '[PRE7]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The preceding output displays a connected cluster. This configuration shows
    that it's correctly configured and connected.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的输出显示了一个连接的集群。此配置显示它已正确配置和连接。
- en: 'Here is a screenshot of the output:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出的屏幕截图：
- en: '![Installing Cassandra](img/00046.jpeg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![安装Cassandra](img/00046.jpeg)'
- en: Multiple data centers
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多个数据中心
- en: In practical scenarios, we would want to have Cassandra clusters distributed
    across different data centers so that the system is more reliable and resilient
    overall to localized network snags and physical disasters.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际场景中，我们希望将Cassandra集群分布在不同的数据中心，以便系统更可靠和更具抗灾性，以应对局部网络故障和物理灾难。
- en: Prerequisites for setting up multiple data centers
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置多个数据中心的先决条件
- en: 'The following are a set of prerequisites that should be used for setting up
    multiple data centers:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是设置多个数据中心时应使用的一组先决条件：
- en: Have Cassandra installed on each node
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每个节点上安装Cassandra
- en: Have the IP address of each node in the cluster
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在集群中每个节点的IP地址
- en: Identify the cluster names
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定集群名称
- en: Identify the seed nodes
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定种子节点
- en: Identify the snitch that is to be used
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定要使用的snitch
- en: Installing Cassandra data centers
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装Cassandra数据中心
- en: 'The following are a set of steps to set up Cassandra data centers:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是设置Cassandra数据中心的一组步骤：
- en: 'Let''s start with an assumption that we have already installed Cassandra on
    the following nodes:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们假设我们已经在以下节点上安装了Cassandra：
- en: 10.188.66.41 (seed1)
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 10.188.66.41（seed1）
- en: 10.196.43.66
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 10.196.43.66
- en: 10.188.247.41
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 10.188.247.41
- en: 10.196.170.59 (seed2)
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 10.196.170.59（seed2）
- en: 10.189.61.170
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 10.189.61.170
- en: 10.189.30.138
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 10.189.30.138
- en: Assign tokens using the token generation Python script defined in the previous
    section to each of the preceding nodes.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用前一节中定义的token生成Python脚本为每个前面的节点分配token。
- en: 'Let''s say we align to the following distribution of nodes and their tokens
    across the data centers:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设我们将节点及其token分布对齐到以下分布：
- en: '| Node | IP Address | Token | Data Center |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| 节点 | IP地址 | Token | 数据中心 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| node0 | 10.188.66.41 | 0 | Dc1 |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| node0 | 10.188.66.41 | 0 | Dc1 |'
- en: '| node1 | 10.196.43.66 | 56713727820156410577229101238628035245 | Dc1 |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| node1 | 10.196.43.66 | 56713727820156410577229101238628035245 | Dc1 |'
- en: '| node2 | 10.188.247.41 | 113427455640312821154458202477256070488 | Dc1 |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| node2 | 10.188.247.41 | 113427455640312821154458202477256070488 | Dc1 |'
- en: '| node3 | 10.196.170.59 | 10 | Dc2 |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| node3 | 10.196.170.59 | 10 | Dc2 |'
- en: '| node4 | 10.189.61.170 | 56713727820156410577229101238628035255 | Dc2 |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| node4 | 10.189.61.170 | 56713727820156410577229101238628035255 | Dc2 |'
- en: '| node5 | 10.189.30.138 | 113427455640312821154458202477256070498 | Dc2 |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| node5 | 10.189.30.138 | 113427455640312821154458202477256070498 | Dc2 |'
- en: 'Stop Cassandra on the nodes and clear the data from `data_dir` of Cassandra:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 停止节点上的Cassandra并清除Cassandra的`data_dir`中的数据：
- en: '[PRE8]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This command finds the Cassandra Java process ID (PID):'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令查找Cassandra Java进程ID（PID）：
- en: '[PRE9]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This is the command to kill the process with the specified PID:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这是用指定的PID杀死进程的命令：
- en: '[PRE10]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The preceding command clears the data from the default directories of Cassandra.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令清除了Cassandra的默认目录中的数据。
- en: 'Modify the following property settings in the `cassandra.yaml` file for each
    node:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为每个节点修改`cassandra.yaml`文件中的以下属性设置：
- en: '[PRE11]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here is what the updated configuration will look like:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 更新后的配置如下：
- en: '[PRE12]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: All the properties for these nodes are the same as those defined for the preceding
    `node0` except for the `initial_token` and `listen_address` properties.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些节点的属性与前面的`node0`定义的属性相同，除了`initial_token`和`listen_address`属性。
- en: Next, we will have to assign names to each data center and their racks; for
    example, `Dc1`, `Dc2` and `Rc1`, `Rc2`.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '接下来，我们将不得不为每个数据中心及其机架分配名称；例如，`Dc1`，`Dc2`和`Rc1`，`Rc2`。 '
- en: 'Go to the `cassandra-topology.properties` file and add an assignment for data
    center and rack names against the IP addresses of each node. For example:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到`cassandra-topology.properties`文件，并针对每个节点的IP地址添加数据中心和机架名称的赋值。例如：
- en: '[PRE13]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The next step is to start seed nodes one by one, followed by all the rest of
    the nodes.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是逐个启动种子节点，然后启动所有其他节点。
- en: Check that your ring is up and running.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查您的环是否正常运行。
- en: Introduction to CQLSH
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CQLSH介绍
- en: 'Now that we are through with the Cassandra setup, let''s get acquainted with
    the shell and a few basic commands:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经完成了Cassandra的设置，让我们熟悉一下shell和一些基本命令：
- en: 'Run CQL at `/usr/local/Cassandra/apache-cassandra-1.1.6` using `bin/cqlsh`
    with a host and port:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`/usr/local/Cassandra/apache-cassandra-1.1.6`上使用`bin/cqlsh`运行CQL，带有主机和端口：
- en: '[PRE14]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Create a keyspace either at the Cassandra client or at CQL, as follows:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Cassandra客户端或CQL中创建一个keyspace，如下所示：
- en: '[PRE15]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Create a column family at the Cassandra client or at CQL as follows:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Cassandra客户端或CQL中创建一个列族，如下所示：
- en: '[PRE16]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'For example, create the following table:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，创建以下表：
- en: '[PRE17]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Insert a few records into the column family from the command line:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从命令行插入一些记录到列族中：
- en: '[PRE18]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Retrieve the data from the column family:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从列族中检索数据：
- en: '[PRE19]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Introduction to CLI
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CLI介绍
- en: This section gets you acquainted with another tool that is used for interaction
    with Cassandra processes—the CLI shell.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 本节让您熟悉了另一个用于与Cassandra进程交互的工具——CLI shell。
- en: 'The following steps are used for interacting with Cassandra using the CLI shell:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤用于使用CLI shell与Cassandra进行交互：
- en: 'The following is the command to connect to the Cassandra CLI:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是连接到Cassandra CLI的命令：
- en: '[PRE20]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Create a keyspace:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个keyspace：
- en: '[PRE21]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Verify the creation of the keyspace using the following command:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令验证keyspace的创建：
- en: '[PRE22]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Create a column family:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个列族：
- en: '[PRE23]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Insert data into the column family:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将数据插入到列族中：
- en: '[PRE24]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In this example, the code `ss` is my row key.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，代码`ss`是我的行键。
- en: 'Retrieve data from the Cassandra column family:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Cassandra列族中检索数据：
- en: '[PRE25]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Using different client APIs to access Cassandra
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用不同的客户端API访问Cassandra
- en: Now that we are acquainted with Cassandra, let's move on to the next step where
    we will access (insert or update) data into the cluster programmatically. In general,
    the APIs we are talking about are wrappers written over the core Thrift API, which
    offers various CRUD operations over the Cassandra cluster using programmer-friendly
    packages.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经熟悉了Cassandra，让我们继续下一步，我们将以编程方式访问（插入或更新）数据到集群中。一般来说，我们谈论的API是在核心Thrift
    API上编写的包装器，它提供了使用程序员友好的包进行Cassandra集群上的各种CRUD操作。
- en: 'The client APIs that are used to access Cassandra are as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 用于访问Cassandra的客户端API如下：
- en: '**Thrift protocol**: The most basic of all APIs to access Cassandra is the
    **Remote Procedure Call** (**RPC**) protocol, which provides a language-neutral
    interface and thus exposes flexibility to communicate using Python, Java, and
    so on. Please note that almost all other APIs we''ll discuss use **Thrift** under
    the hood. It is simple to use and it provides basic functionality out of the box
    like ring discovery and native access. Complex features such as retry, connection
    pooling, and so on are not supported out of the box. However, there are a variety
    of libraries that have extended Thrift and added these much required features,
    and we will touch upon a few widely used ones in this chapter.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Thrift协议**：访问Cassandra的最基本的API是**远程过程调用**（**RPC**）协议，它提供了一个语言中立的接口，因此可以使用Python、Java等进行通信。请注意，我们将讨论的几乎所有其他API都在内部使用**Thrift**。它使用简单，并且提供了基本的功能，如环形发现和本地访问。然而，它不支持重试、连接池等复杂功能。然而，有许多库扩展了Thrift并添加了这些必要的功能，我们将在本章中介绍一些广泛使用的库。'
- en: '**Hector**: This has the privilege of being one of the most stable and extensively
    used APIs for Java-based client applications to access Cassandra. As mentioned
    earlier, it uses Thrift under the hood, so it essentially can''t offer any feature
    or functionality not supported by the Thrift protocol. The reason for its widespread
    use is that it has a number of essential features ready to use and available out
    of the box:'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Hector**：这是用于Java客户端应用程序访问Cassandra的最稳定和广泛使用的API之一。如前所述，它在内部使用Thrift，因此基本上不能提供Thrift协议不支持的任何功能或功能。它被广泛使用的原因是它具有许多基本功能，可以直接使用并且可用：'
- en: It has implementation for connection pooling
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它具有连接池的实现
- en: It has a ring discovery feature with an add-on of automatic failover support
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它具有环形发现功能，并附带自动故障转移支持
- en: It has a retry option for downed hosts in the Cassandra ring
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它在Cassandra环中具有对宕机主机的重试选项。
- en: '**Datastax Java driver**: This is, again, a recent addition to the stack of
    client access options to Cassandra, and hence goes well with the newer version
    of Cassandra. Here are its salient features:'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Datastax Java driver**：这是最近添加到Cassandra客户端访问选项堆栈中的一个选项，因此与较新版本的Cassandra兼容。以下是它的显著特点：'
- en: Connection pooling
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接池
- en: Reconnection policies
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新连接策略
- en: Load balancing
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 负载均衡
- en: Cursor support
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游标支持
- en: '**Astyanax**: This is a very recent addition to the bouquet of Cassandra client
    APIs and has been developed by Netflix, which definitely makes it more fabled
    than others. Let''s have a look at its credentials to see where it qualifies:'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Astyanax**：这是Cassandra客户端API花束的最新添加，由Netflix开发，这使它比其他更加神秘。让我们看看它的凭证，看看它是否符合条件：'
- en: It supports all of the functions of Hector and is much easier to use
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它支持Hector的所有功能，并且使用起来更加容易
- en: It promises better connection pooling than Hector
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它承诺比Hector更好地支持连接池
- en: It is better at handling failovers than Hector
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它比Hector更擅长处理故障转移
- en: 'It provides some out-of-the-box, database-like features (now that''s big news).
    At the API level, it provides functionality called Recipes in its terms, which
    provides:'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供了一些开箱即用的类似数据库的功能（这是个大新闻）。在API级别上，它提供了称为Recipes的功能，其中包括：
- en: Parallel row query execution
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 并行行查询执行
- en: Messaging queue functionality
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 消息队列功能
- en: Object storage
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 对象存储
- en: Pagination
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 分页
- en: It has numerous frequently required utilities like JSON Writer and CSV Importer
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它具有许多经常需要的实用程序，如JSON Writer和CSV Importer
- en: Storm topology wired to the Cassandra store
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Storm拓扑连接到Cassandra存储
- en: Now you have been educated and informed about why you should use Cassandra.
    You have been walked through setting up Cassandra and column family creation,
    and have even covered the various client/protocol options available to access
    the Cassandra data store programmatically. As mentioned earlier, Hector has so
    far been the most widely used API for accessing Cassandra, though the `Datastax`
    and `Astyanax` drivers are fast catching up. For our exercise, we'll use the Hector
    API.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解并知道为什么应该使用Cassandra。您已经学会了设置Cassandra和列族创建，并且甚至涵盖了可编程访问Cassandra数据存储的各种客户端/协议选项。正如前面提到的，Hector目前是访问Cassandra最广泛使用的API，尽管`Datastax`和`Astyanax`驱动程序正在迅速赶上。对于我们的练习，我们将使用Hector
    API。
- en: The use case we want to implement here is to use Cassandra to support real-time,
    adhoc reporting for telecom data that is being collated, parsed, and enriched
    using a Storm topology.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要实现的用例是使用Cassandra支持实时的电信数据的即时报告，这些数据正在使用Storm拓扑进行整理、解析和丰富。
- en: '![Storm topology wired to the Cassandra store](img/00047.jpeg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![Storm拓扑连接到Cassandra存储](img/00047.jpeg)'
- en: As depicted in the preceding figure, the use case requires live telecom **Call
    Detail Record** (**CDR**) capture using the data collection components (for practice,
    we can use sample records and a simulator shell script to mimic the live CDR feeds).
    The collated live feed is pushed into the RabbitMQ broker and then consumed by
    the Storm topology.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，用例需要使用数据收集组件（为了练习，我们可以使用样本记录和模拟器shell脚本来模拟实时CDR数据）进行实时电信**通话详单**（**CDR**）捕获。整理的实时数据被推送到RabbitMQ代理，然后被Storm拓扑消费。
- en: For the topology, we have an AMQP spout as the consumer, which reads the data
    of the queue and pushes it downstream to the topology bolts; here, we have wired
    in bolts to parse the message and convert it to **Plain Old Java Objects** (**POJO**'s).
    Then, we have a new entry in our topology, the Cassandra bolt, which actually
    stores the data in the Cassandra cluster.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 对于拓扑，我们有一个AMQP spout作为消费者，它读取队列的数据并将其推送到拓扑的bolt；在这里，我们已经连接了bolt来解析消息并将其转换为**普通旧Java对象**（**POJO**）。然后，我们在我们的拓扑中有一个新的条目，即Cassandra
    bolt，它实际上将数据存储在Cassandra集群中。
- en: From the Cassandra cluster, a UI-based consumer retrieves the data based on
    a search query defined by the user, thus providing the adhoc, real-time reporting
    over live data.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 从Cassandra集群中，基于用户定义的搜索查询，UI界面的消费者检索数据，从而提供即时的、实时的报告。
- en: 'For the sake of our implementation, we will query the data from CLI/CQLSH as
    shown here:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 为了我们的实现，我们将像这里所示从CLI/CQLSH查询数据：
- en: 'Create a keyspace:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个键空间：
- en: '[PRE26]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Create the column family:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建列族：
- en: '[PRE27]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The following changes need to be made to `pom.xml` in the project. The Hector
    dependency should be added to the `pom.xml` file so that it is fetched at the
    time of build and added to the `m2` repository, as shown:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需要对项目中的`pom.xml`进行以下更改。应该将Hector依赖项添加到`pom.xml`文件中，以便在构建时获取并添加到`m2`存储库，如下所示：
- en: '[PRE28]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: If you are working with a non-Maven project, follow the usual protocol—download
    the Hector core JAR file and add it to the project build path so that all the
    required dependencies are satisfied.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用非Maven项目，请遵循通常的协议——下载Hector核心JAR文件并将其添加到项目构建路径，以满足所有所需的依赖关系。
- en: 'Next, we''ll need to get the components in place in our Storm topology. We
    will start by creating a `CassandraController` Java component that will hold all
    Cassandra-related functionality, and it will be called from the `CassandraBolt`
    class in the topology to persist the data into Cassandra:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要在我们的Storm拓扑中放置组件。我们将首先创建一个`CassandraController` Java组件，它将保存所有与Cassandra相关的功能，并且将从拓扑中的`CassandraBolt`类中调用以将数据持久化到Cassandra中：
- en: '[PRE29]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Last but not least in our topology is actually the component that will write
    into Cassandra, the Storm bolt that will make use of `CassandraController` created
    earlier to write the real-time data into Cassandra:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们拓扑中最后一个组件实际上是将数据写入Cassandra的组件，这是一个Storm bolt，它将利用之前创建的`CassandraController`来将实时数据写入Cassandra：
- en: '[PRE30]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: So here we complete the last piece of the puzzle; we can now stream data into
    Cassandra using Storm in real time. Once you execute the topology end to end,
    you can verify the data in Cassandra by using the select or list commands on CLI/CQLSH.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们完成了最后一块拼图；现在我们可以使用Storm实时将数据流入Cassandra。一旦您执行了整个拓扑，您可以使用CLI/CQLSH上的select或list命令验证Cassandra中的数据。
- en: The best practices for Storm/Cassandra applications
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Storm/Cassandra应用程序的最佳实践
- en: 'When working with distributed applications that have SLAs operating 24/7 with
    a very high velocity and a miniscule average processing time, certain aspects
    become extremely crucial to be taken care of:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理具有24/7运行SLA、非常高速和微小平均处理时间的分布式应用程序时，某些方面变得极为重要：
- en: Network latency plays a big role in real-time applications and can make or break
    products, so make a very informed and conscious decision on the placement of various
    nodes in a data center or across data centers. In such situations, it's generally
    advisable to keep ping latency at a minimum.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络延迟在实时应用程序中起着重要作用，可能会成败产品，因此在数据中心或跨数据中心中放置各种节点时，要做出非常明智和有意识的决定，通常建议将ping延迟保持在最低限度。
- en: The replication factor should be around three for Cassandra.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cassandra的复制因子应该在三左右。
- en: Compaction should be part of routine Cassandra maintenance.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 压缩应该是常规Cassandra维护的一部分。
- en: Quiz time
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测验时间
- en: 'Q.1\. State whether the following statements are true or false:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: Q.1. 判断以下陈述是真是假：
- en: Cassandra is a document-based NoSQL.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Cassandra是基于文档的NoSQL。
- en: Cassandra has a single point of failure.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Cassandra有单点故障。
- en: Cassandra uses consistent hashing for key distribution.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Cassandra在键分发时使用一致性哈希。
- en: Cassandra works on master-slave architecture.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Cassandra工作在主从架构上。
- en: 'Q.2\. Fill in the blanks:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: Q.2. 填空：
- en: _______________attributes of the CAP theorem are adhered to by Cassandra.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Cassandra遵循CAP定理的_______________属性。
- en: _______________ is the salient feature that makes Cassandra a contender to be
    used in conjunction with Storm.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: _______________是使Cassandra成为与Storm一起使用的有力竞争者的显著特点。
- en: The ____________ is an API to access Cassandra using a Java client, and is a
    Greek mythological character—*brother of Cassandra*.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Cassandra是使用Java客户端访问Cassandra的API，并且是希腊神话中的角色-卡桑德拉的兄弟。
- en: Q.3\. Complete the use case mentioned in the chapter and demonstrate end-to-end
    execution to populate data into Cassandra.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: Q.3. 完成本章提到的用例，并演示将数据填充到Cassandra中的端到端执行。
- en: Summary
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you have covered the fundamentals of NoSQL in general and specifically
    Cassandra. You got hands-on experience in setting up the Cassandra cluster as
    well as got to know about varied APIs, drivers, and protocols that provide programmatic
    access to Cassandra. We also integrated Cassandra as a data store to our Storm
    topology for data insertion.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您已经涵盖了NoSQL的基础知识，特别是Cassandra。您已经亲身体验了设置Cassandra集群，并了解了各种API、驱动程序和协议，这些提供了对Cassandra的编程访问。我们还将Cassandra集成为我们的Storm拓扑的数据存储，用于数据插入。
- en: In the next chapter, we will touch upon some integral aspects of Cassandra,
    specifically consistency and availability.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将涉及Cassandra的一些重要方面，特别是一致性和可用性。
