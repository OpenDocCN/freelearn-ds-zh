- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Uploading, Downloading, and Manipulating Data
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 上传、下载和操作数据
- en: So far in this book, we have exclusively used simulated data in our Streamlit
    apps. This was useful for getting a good background on some of the basics of Streamlit,
    but most data science is not done on simulated data but on real-world datasets
    that data scientists already have, or on datasets provided by users.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本书中我们在Streamlit应用中使用的都是模拟数据。这对于掌握Streamlit的一些基本概念非常有用，但大多数数据科学工作不是基于模拟数据，而是基于数据科学家已经拥有的真实数据集，或者是用户提供的数据集。
- en: This chapter will focus on the world of data in Streamlit apps, covering everything
    you will need to know to bring datasets to life using Streamlit. We will cover
    data manipulation, using user-imported data, flow control, debugging Streamlit
    apps, and speeding up our data applications using caching through an example dataset
    called Palmer’s Penguins.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将重点介绍Streamlit应用中的数据世界，涵盖您需要了解的所有内容，教您如何通过Streamlit让数据集“活起来”。我们将讨论数据操作、使用用户导入的数据、流程控制、调试Streamlit应用，以及如何通过缓存加速我们的数据应用，示例数据集为Palmer’s
    Penguins。
- en: 'In particular, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 特别地，我们将覆盖以下主题：
- en: The setup – Palmer’s Penguins
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置 - Palmer’s Penguins
- en: Debugging Streamlit apps
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试Streamlit应用
- en: Data manipulation in Streamlit
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Streamlit中的数据操作
- en: Persistence with Session State
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用会话状态保持数据持久性
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, we will need to download the Palmer’s Penguins dataset, which
    can be found at [https://github.com/tylerjrichards/streamlit_apps/blob/main/penguin_app/penguins.csv](https://github.com/tylerjrichards/streamlit_apps/blob/main/penguin_app/penguins.csv).
    The setup for this chapter, along with an explanation of the dataset, can be found
    in the following section.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，我们需要下载Palmer’s Penguins数据集，您可以在[https://github.com/tylerjrichards/streamlit_apps/blob/main/penguin_app/penguins.csv](https://github.com/tylerjrichards/streamlit_apps/blob/main/penguin_app/penguins.csv)找到该数据集。本章的设置以及数据集的解释可以在以下章节中找到。
- en: The setup – Palmer’s Penguins
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置 - Palmer’s Penguins
- en: For this chapter, we’ll be using a delightful dataset about Arctic penguins
    that comes from the work of Dr. Kristen Gorman ([https://www.uaf.edu/cfos/people/faculty/detail/kristen-gorman.php](https://www.uaf.edu/cfos/people/faculty/detail/kristen-gorman.php))
    and the Palmer Station, Antarctica LTER ([https://pallter.marine.rutgers.edu/](https://pallter.marine.rutgers.edu/)).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，我们将使用一个关于北极企鹅的有趣数据集，该数据集来自Kristen Gorman博士([https://www.uaf.edu/cfos/people/faculty/detail/kristen-gorman.php](https://www.uaf.edu/cfos/people/faculty/detail/kristen-gorman.php))及Palmer站点，南极LTER
    ([https://pallter.marine.rutgers.edu/](https://pallter.marine.rutgers.edu/))的工作。
- en: Dataset Acknowledgment
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 数据集致谢
- en: Data from the Palmer LTER data repository was supported by the Office of Polar
    Programs, NSF Grants OPP-9011927, OPP-9632763, and OPP-0217282.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 来自Palmer LTER数据存储库的数据得到了极地项目办公室（Office of Polar Programs）的支持，NSF资助编号包括OPP-9011927、OPP-9632763和OPP-0217282。
- en: This data is a common alternative to the famous Iris datasets and includes data
    on 344 individual penguins with 3 species represented. The data can be found in
    the GitHub repository for this book ([https://github.com/tylerjrichards/Streamlit-for-Data-Science](https://github.com/tylerjrichards/Streamlit-for-Data-Science)),
    in the `penguin_app` folder entitled `penguins.csv`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 该数据集是著名的Iris数据集的常见替代方案，包含344只企鹅的个体数据，涵盖了3种企鹅物种。数据可以在本书的GitHub代码库中找到([https://github.com/tylerjrichards/Streamlit-for-Data-Science](https://github.com/tylerjrichards/Streamlit-for-Data-Science))，在`penguin_app`文件夹中，名为`penguins.csv`。
- en: As we’ve discussed before, Streamlit apps run from inside our Python script.
    This sets the base directory to the location of the Python file with our Streamlit
    app, which means we can access any other files that we put in our app directory.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论的，Streamlit应用程序是在我们的Python脚本内部运行的。这会将基础目录设置为Python文件所在的位置，意味着我们可以访问放置在应用程序目录中的任何其他文件。
- en: 'First, let’s create a folder for our new app in our existing `streamlit_apps`
    folder using the following code block:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们使用以下代码块，在现有的`streamlit_apps`文件夹中为我们的新应用程序创建一个文件夹：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'After this, download the data and put the resulting CSV file (named `penguins.csv`
    in the example) in the `penguin_app` folder. Now, our folder should have the `penguins.py`
    file and our `penguins.csv` file. For our first go around, we’re just going to
    print out the first five rows of our DataFrame using the `st.write()` function
    we learned about earlier by putting the following code in our `penguins.py` file:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，下载数据并将生成的 CSV 文件（示例中名为 `penguins.csv`）放入 `penguin_app` 文件夹中。现在，我们的文件夹应包含
    `penguins.py` 文件和 `penguins.csv` 文件。首次运行时，我们将仅通过在 `penguins.py` 文件中写入以下代码，使用 `st.write()`
    函数打印出 DataFrame 的前五行：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The preceding code will produce the following Streamlit app when we run `streamlit
    run penguins.py` in the terminal:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`streamlit run penguins.py`命令后，前述代码将生成以下的 Streamlit 应用：
- en: '![Figure 2.1 – The first five penguins ](img/B18444_02_01.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.1 – 前五只企鹅 ](img/B18444_02_01.png)'
- en: 'Figure 2.1: The first five penguins'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1：前五只企鹅
- en: Now that we have a good idea of what the data looks like, we will explore the
    dataset a bit more and then begin adding to our app.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对数据的样貌有了基本了解，我们将进一步探索数据集，并开始向应用程序中添加内容。
- en: Exploring Palmer’s Penguins
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 Palmer’s Penguins 数据集
- en: 'Before we begin working with this dataset, we should make some visualizations
    to better understand the data. As we saw before, we have many columns in this
    data, whether the bill length, the flipper length, the island the penguin lives
    on, or even the species of penguin. I’ve done the first visualization for us already
    in Altair, a popular visualization library that we will use extensively throughout
    this book because it is interactive by default and generally pretty:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始处理这个数据集之前，我们应该先制作一些可视化，以便更好地理解数据。如前所述，这些数据中有很多列，无论是喙长、鳍长、企鹅栖息的岛屿，还是企鹅的物种。我已经在
    Altair 中为我们做了第一个可视化，Altair 是一个流行的可视化库，我们将在本书中广泛使用它，因为它默认是交互式的，并且通常看起来很美观：
- en: '![](img/B18444_02_02.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18444_02_02.png)'
- en: 'Figure 2.2: Bill length and bill depth'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2：喙长与喙深
- en: From this, we can see that the Adelie penguins have a shorter bill length but
    generally have fairly deep bills. Now, what does it look like if we plot weight
    by flipper length?
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 从中我们可以看出，阿德利企鹅的喙较短，但一般拥有相对较深的喙。现在，如果我们将体重与鳍长作图，结果会是什么样呢？
- en: '![](img/B18444_02_03.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18444_02_03.png)'
- en: 'Figure 2.3: Bill length and weight'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.3：喙长与体重
- en: Now we see that Gentoo penguins seem to be heavier than the other two species,
    and that bill length and body mass are positively correlated. These findings are
    not a huge surprise, but getting to these simple findings was a little tedious.
    There are many more combinations of variables that we could plot, but could we
    instead make a data explorer Streamlit app do this for us?
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们看到，金图企鹅似乎比其他两种企鹅更重，而且喙长和体重是正相关的。这些发现并不令人感到意外，但达到这些简单结论的过程有点繁琐。我们可以绘制的变量组合还有很多，那么我们能否创建一个数据探索者
    Streamlit 应用来为我们完成这些工作呢？
- en: The final goal of this mini-app is to reduce the friction in exploratory data
    analysis by letting the user define the species of penguin they want to look at,
    along with the *x* and *y* variables to plot on a scatterplot. We’ll start by
    learning how to take those inputs, how to load the data into Streamlit, and then
    how to create a dynamic visualization.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这个小型应用的最终目标是通过让用户定义他们想查看的企鹅物种，以及要在散点图上绘制的 *x* 和 *y* 变量，从而减少探索性数据分析的摩擦。我们将从学习如何获取这些输入、如何将数据加载到
    Streamlit 中，接着学习如何创建动态可视化开始。
- en: 'In the last chapter, we learned about a Streamlit input called `st.number_input()`.
    This won’t help us here, but Streamlit has a very similar one called `st.selectbox()`,
    which allows us to ask the user to select one option from multiple options, and
    the function returns whatever the user selects. We will use this to get the three
    inputs for our scatterplot:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们了解了一个 Streamlit 输入组件 `st.number_input()`。这个组件在这里不适用，但 Streamlit 还有一个非常相似的输入组件
    `st.selectbox()`，它允许我们让用户从多个选项中选择一个，函数返回用户选择的内容。我们将使用这个来获取散点图的三个输入：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This code creates three new variables from three new select boxes in which
    the user can provide input in our Streamlit app. The following screenshot shows
    the Streamlit app from the preceding code:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码创建了三个新变量，这些变量来自于我们 Streamlit 应用中的三个新选择框，用户可以在其中提供输入。以下截图展示了前面代码生成的 Streamlit
    应用：
- en: '![](img/B18444_02_04.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18444_02_04.png)'
- en: 'Figure 2.4: User input on penguins'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.4：用户对企鹅的输入
- en: 'Now that we have the `selected_species` variable, we can filter our DataFrame
    and make a quick scatterplot using the selected *x* and *y* variables, as in this
    next block of code:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了 `selected_species` 变量，可以通过它过滤 DataFrame，并使用选定的 *x* 和 *y* 变量快速生成散点图，如下面这段代码所示：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This preceding bit of code adds to the previous example by loading our DataFrame,
    filtering by species, and then plotting in the same method from the previous chapter,
    which will result in the same app as before but with a scatterplot attached as
    well, as shown in the following screenshot:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这段前面的代码通过加载我们的 DataFrame、按物种过滤数据，然后使用上一章的方法进行绘图，进一步完善了之前的例子。最终结果是，与之前相同的应用程序，但这次附带了一个散点图，截图如下所示：
- en: '![](img/B18444_02_05.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18444_02_05.png)'
- en: 'Figure 2.5: First penguin scatterplot'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.5：第一个企鹅散点图
- en: Try to play around with this app and make sure that all the inputs and outputs
    are working correctly. Notice that if we hover over any individual point, we can
    see the underlying data, and if we change the Streamlit inputs, the entire graph
    changes.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试操作这个应用程序，并确保所有输入和输出都能正常工作。注意，当我们将鼠标悬停在任何一个单独的点上时，可以看到该点的底层数据；如果我们更改 Streamlit
    输入，整个图表也会随之变化。
- en: 'Our graph doesn’t explicitly show what species is being graphed, so let’s practice
    making dynamic text. The following adds dynamic text to our Streamlit app’s graph
    title with the f-strings, which are native to Python:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的图表没有明确显示正在绘制的是哪个物种，所以让我们练习一下动态文本的创建。以下内容使用了 Python 原生的 f-strings，将动态文本添加到我们
    Streamlit 应用程序的图表标题中：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The preceding code adds the species to our scatterplot and results in the following
    Streamlit app:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将物种添加到我们的散点图中，并生成了以下 Streamlit 应用程序：
- en: '![](img/B18444_02_06.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18444_02_06.png)'
- en: 'Figure 2.6: Dynamic graph titles'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.6：动态图表标题
- en: 'This looks great, but there are a few more edits that we can make as an improvement.
    Right now we can’t zoom into our chart, so most of the graph is blank. We can
    change this by either using Altair to edit the axes, or we can make the Altair
    chart interactive so that the user can zoom in wherever they’d like on the graph.
    The following code makes the Altair chart zoomable and extends the graph to fit
    the entire screen with the `use_container_width` parameter:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这个看起来很棒，但我们还能做一些改进。现在我们无法放大图表，所以大部分图表都是空白的。我们可以通过使用 Altair 编辑坐标轴，或者使 Altair
    图表可交互，以便用户可以在图表上任意放大来改进这一点。以下代码使 Altair 图表可以缩放，并通过 `use_container_width` 参数将图表扩展以适应整个屏幕：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The following screenshot shows our new and improved Palmer’s Penguins app,
    which has the appropriately sized chart and interactivity (I zoomed into some
    places on the graph that I thought were interesting just to show off the new interactive
    feature). I also placed my mouse over an individual point, which showed the underlying
    data for that point:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了我们改进后的 Palmer's Penguins 应用程序，它具有适当大小的图表和交互性（我对图表的一些地方进行了放大，以展示新的交互特性）。我还将鼠标放在了某个点上，这时显示了该点的底层数据：
- en: '![](img/B18444_02_07.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18444_02_07.png)'
- en: 'Figure 2.7: Screenshot with interaction'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.7：带有交互的截图
- en: 'At the beginning of this chapter, it seemed like a good idea to allow the user
    to select a species to filter the DataFrame by. But now, after making this app,
    it seems like it might be better to just allow the user to make changes to the
    *x* and *y* inputs, and always plot the species in different colors. The next
    bit of code does exactly that, removing the filtering mechanisms we added and
    adding a color parameter to the `altair` section of the code:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 本章开始时，我们觉得允许用户选择物种来过滤 DataFrame 是一个不错的主意。但现在，在制作了这个应用程序之后，似乎让用户只修改 *x* 和 *y*
    输入，而始终以不同颜色绘制物种，可能会更好。以下代码正是做到了这一点，它移除了我们添加的过滤机制，并在 `altair` 部分的代码中添加了一个颜色参数：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, our app has a color for each species (in this screenshot, you can probably
    see it in black-and-white, but you should see the different colors in your own
    app!), has interactivity, and allows for user input, all in 26 lines of code and
    3 Streamlit commands:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的应用程序为每个物种赋予了不同的颜色（在这张截图中，可能看起来是黑白的，但在你自己的应用程序中应该能看到不同的颜色！），并且具有交互性，允许用户输入，所有这些都只用了
    26 行代码和 3 条 Streamlit 命令：
- en: '![](img/B18444_02_08.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18444_02_08.png)'
- en: 'Figure 2.8: Penguins in color'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.8：彩色企鹅图
- en: The last step for this app is to allow the user to upload their own data. What
    if we wanted the research team, at any point, to be able to upload their own data
    to this app and see the results? Or what if there were three research groups,
    all with their own unique data with different column names, that wanted to use
    a method that we created? We’ll approach this problem one aspect at a time. First,
    how do we accept data from users of our app?
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应用程序的最后一步是允许用户上传自己的数据。如果我们希望研究团队能够随时向应用程序上传他们自己的数据并查看结果，该怎么办？或者如果有三个研究小组，每个小组都有自己独特的、不同列名的数据，且希望使用我们创建的方法，应该如何处理？我们将逐步解决这个问题。首先，我们如何接受应用程序用户的数据？
- en: Streamlit has a function called `file_uploader()`, which allows users of the
    app to upload data up to 200 MB in size (as a default). It works just like the
    other interactive widgets we’ve used before, with one exception. Our default in
    an interactive widget-like select box is just the first value in our list, but
    it does not make sense to have a default uploaded file before the user actually
    interacts with the app! The default user-uploaded file has a value of `None`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Streamlit有一个名为`file_uploader()`的函数，允许应用程序的用户上传最大为200 MB的数据（默认情况下）。它的工作原理与我们之前使用过的其他交互式小部件一样，有一个例外。交互式小部件（如选择框）的默认值通常是列表中的第一个值，但在用户实际上与应用程序交互之前，设置默认上传文件是没有意义的！上传文件的默认值为`None`。
- en: This begins to cover a very important concept in Streamlit development, which
    is flow control. Flow control can be understood as thinking carefully through
    all the steps of your application because Streamlit will try to run the entire
    app at once if we’re not explicit about things, such as wanting to wait until
    the user has uploaded a file to attempt to create a graphic or manipulate a DataFrame.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这开始涉及到Streamlit开发中的一个非常重要的概念——流控制。流控制可以理解为在构建应用程序时仔细考虑每一个步骤，因为如果我们没有明确指定，Streamlit会尝试一次性运行整个应用程序。例如，如果我们希望等用户上传文件之后再尝试创建图形或操作数据框，Streamlit就会立即执行所有步骤。
- en: Flow control in Streamlit
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Streamlit中的流控制
- en: 'As we talked about just before, there are two solutions to this data upload
    default situation. We can provide a default file to use until the user interacts
    with the application, or we can stop the app until a file is uploaded. Let’s start
    with the first option. The following code uses the `st.file_uploader()` function
    from within an `if` statement. If the user uploads a file, then the app uses that;
    if they do not, then we default to the file we have used before:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们刚刚所讨论的，这种数据上传默认情况有两种解决方案。我们可以提供一个默认文件，直到用户与应用程序互动，或者我们可以在文件上传之前停止应用程序。我们先从第一个选项开始。以下代码在`if`语句中使用了`st.file_uploader()`函数。如果用户上传了文件，应用程序则使用该文件；如果没有上传，应用程序则使用我们之前的默认文件：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'When we run the preceding code in our terminal, we see our three user inputs
    (the *x* axis, the *y* axis, and the dataset), and also the graph, even if we
    have yet to upload a file. The following screenshot shows this app:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在终端运行前面的代码时，我们会看到我们的三个用户输入（*x*轴、*y*轴和数据集），以及图形，尽管我们还没有上传文件。以下截图展示了这个应用程序：
- en: '![](img/B18444_02_09.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18444_02_09.png)'
- en: 'Figure 2.9: File input'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.9：文件输入
- en: The clear advantage of this approach is that there are always results shown
    in this application, but the results may not be useful to the user! For larger
    applications, this is a subpar solution as well because any data stored inside
    the app, regardless of use, is going to slow the application down. Later, in *Chapter
    7*, *Exploring Streamlit Components*, we’ll discuss all of our options for deployment,
    including a built-in deployment option called Streamlit Community Cloud.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的明显优势是，应用程序中总是会有结果显示，但这些结果可能对用户来说并不有用！对于更大型的应用程序来说，这也是一种不理想的解决方案，因为应用程序中存储的任何数据，无论是否使用，都会导致应用程序变慢。稍后，在*第7章*，*探索Streamlit组件*中，我们将讨论所有的部署选项，包括一个内置的部署选项——Streamlit社区云。
- en: 'Our second option is to stop the application entirely unless the user has uploaded
    a file. For that option, we’re going to use a new Streamlit function called `stop()`,
    which (predictably) stops the flow whenever it is called. It is best practice
    to use this to find errors in the app and to encourage the user to make some changes
    or describe the error that is happening. This is not necessary for us but is a
    good thing to know for future applications. The following code uses an `if-else`
    statement with `st.stop()` in the `else` statement to prevent the entire app from
    running when `st.file_uploader()` is unused:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种选择是完全停止应用程序，除非用户上传了文件。对于这种选择，我们将使用一个名为 `stop()` 的新 Streamlit 函数，当调用时它（可以预见）会停止流程。最好使用此方法查找应用程序中的错误，并鼓励用户做出一些更改或描述发生的错误。虽然我们目前不需要这样做，但了解它对未来的应用程序是很有帮助的。以下代码使用
    `if-else` 语句，并在 `else` 语句中使用 `st.stop()`，以防止在 `st.file_uploader()` 未被使用时整个应用程序运行：
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As we can see with the following screenshot, until we upload our own data,
    we will not see a scatterplot, and the application stops. The Streamlit app simply
    waits to run fully until the user has uploaded their file instead of throwing
    an error:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在下面的截图中所看到的，直到我们上传自己的数据，我们才会看到散点图，并且应用程序会停止。Streamlit 应用程序会在用户上传文件之前等待完全运行，而不是抛出错误：
- en: '![](img/B18444_02_10.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18444_02_10.png)'
- en: 'Figure 2.10: Streamlit stop()'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.10：Streamlit stop()
- en: Before we move on to data manipulation and create more complicated Streamlit
    apps, we should touch on some best practices for debugging Streamlit apps.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续进行数据处理并创建更复杂的 Streamlit 应用程序之前，我们应该先讨论一些调试 Streamlit 应用程序的最佳实践。
- en: Debugging Streamlit apps
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试 Streamlit 应用程序
- en: 'We broadly have two options for Streamlit development:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们大致有两种选择来进行 Streamlit 开发：
- en: Develop in Streamlit and `st.write()` as a debugger.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Streamlit 中开发并使用 `st.write()` 作为调试器。
- en: Explore in Jupyter and then copy to Streamlit.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Jupyter 中进行探索，然后复制到 Streamlit 中。
- en: Developing in Streamlit
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Streamlit 中开发
- en: In the first option, we write our code directly in Streamlit as we’re experimenting
    and exploring exactly what our application will do. We’ve basically been taking
    this option already, which works very well if we have less exploration work and
    more implementation work to do.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种选择中，我们直接在 Streamlit 中编写代码，进行实验并探索应用程序将做什么。我们基本上已经在采用这种方式，它非常适合当我们有较少的探索工作和更多的实现工作时。
- en: 'Pros:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 优点：
- en: What you see is what you get – there is no need to maintain both IPython and
    Python versions of the same app.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所见即所得 – 无需同时维护同一个应用程序的 IPython 和 Python 版本。
- en: Better experience for learning how to write production code.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供更好的体验，帮助学习如何编写生产级代码。
- en: 'Cons:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 缺点：
- en: A slower feedback loop (the entire app must run before feedback).
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 较慢的反馈循环（整个应用程序必须运行完才能获得反馈）。
- en: A potentially unfamiliar development environment.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能不熟悉的开发环境。
- en: Exploring in Jupyter and then copying to Streamlit
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Jupyter 中进行探索，然后复制到 Streamlit 中
- en: Another option is to utilize the extremely popular Jupyter data science product
    to write and test out the Streamlit app’s code before placing it in the necessary
    script and formatting it correctly. This can be useful for exploring new functions
    that will live in the Streamlit app, but it has serious downsides.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种选择是利用广受欢迎的 Jupyter 数据科学工具，在将代码放入必要的脚本并正确格式化之前，编写并测试 Streamlit 应用程序的代码。这对于探索将要在
    Streamlit 应用中使用的新功能非常有用，但也有一些严重的缺点。
- en: 'Pros:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 优点：
- en: The lightning-fast feedback loop makes it easier to experiment with very large
    apps.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快速的反馈循环使得实验非常大的应用程序变得更容易。
- en: Users may be more familiar with Jupyter.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户可能更熟悉 Jupyter。
- en: The full app does not have to be run to get results, as Jupyter can be run in
    individual cells.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结果无需运行整个应用程序，因为 Jupyter 可以在单个单元格中运行。
- en: 'Cons:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 缺点：
- en: Jupyter may provide deceptive results if run out of order.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 Jupyter 按顺序运行，可能会提供误导性结果。
- en: “Copying” code over from Jupyter is time-consuming.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将代码从 Jupyter “复制”过来非常耗时。
- en: Python versioning may be different between Jupyter and Streamlit.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 版本可能在 Jupyter 和 Streamlit 之间不同。
- en: My recommendation here is to develop Streamlit apps inside the environment where
    they are going to be run (that is, a Python file). For debugging, heavily utilize
    the `st.write()` function, which can print out nearly any Python object (dictionary,
    DataFrame, list, string, number, graph, and so on) that you may need. Try to only
    use another development environment such as Jupyter as a last resort! Now on to
    data manipulation.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我的建议是在应用将要运行的环境中开发 Streamlit 应用（即 Python 文件）。对于调试，建议大量使用 `st.write()` 函数，它可以打印出几乎所有
    Python 对象（字典、DataFrame、列表、字符串、数字、图表等）。尽量将 Jupyter 等其他开发环境作为最后的手段！接下来是数据处理部分。
- en: Data manipulation in Streamlit
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Streamlit 中的数据处理
- en: 'Streamlit runs our Python file from the top down as a script, so we can perform
    data manipulation with powerful libraries such as `pandas` in the same way that
    we might in a Jupyter notebook or a regular Python script. As we’ve discussed
    before, we can do all our regular data manipulation as normal. For our Palmer’s
    Penguins app, what if we wanted the user to be able to filter out penguins based
    on their gender? The following code filters our DataFrame using `pandas`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Streamlit 会像脚本一样从上到下运行我们的 Python 文件，因此我们可以像在 Jupyter Notebook 或常规 Python 脚本中一样，使用强大的库如
    `pandas` 进行数据处理。如前所述，我们可以照常进行常规的数据操作。在我们的 Palmer’s Penguins 应用中，如果我们希望用户能够根据性别筛选企鹅呢？以下代码使用
    `pandas` 过滤我们的 DataFrame：
- en: '[PRE9]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: A couple of things to note here. First, we’ve added another `selectbox` widget,
    with male, female, and all options. We could have done this by asking for a text
    input, but for data manipulation we want to restrict user action as much as possible.
    We also made sure to dynamically change the title, which is recommended for clarity
    as we want to show the user that the data has been filtered by their input directly
    in the graph.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有几点需要注意。首先，我们添加了另一个 `selectbox` 小部件，包含男性、女性和所有选项。我们本可以通过文本输入来实现，但为了数据操作，我们希望尽量限制用户的操作。同时，我们确保动态更改了标题，这是为了清晰起见，因为我们希望直接在图表中向用户展示数据已根据他们的输入进行过滤。
- en: An introduction to caching
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存简介
- en: As we create more computationally intensive Streamlit apps and begin to use
    and upload larger datasets, we should start thinking about the runtime of these
    apps and work to increase our efficiency whenever possible. The easiest way to
    make a Streamlit app more efficient is through caching, which is storing some
    results in memory so that the app does not repeat the same work whenever possible.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们创建越来越多计算密集型的 Streamlit 应用，并开始使用和上传更大的数据集，我们应该开始思考这些应用的运行时间，并在可能的情况下提高效率。使
    Streamlit 应用更高效的最简单方法是通过缓存，即将一些结果存储在内存中，以便应用在可能的情况下避免重复执行相同的工作。
- en: A good analogy for an app’s cache is a human’s short-term memory, where we keep
    bits of information close at hand that we think might be useful. When something
    is in our short-term memory, we don’t have to think very hard to get access to
    that piece of information. In the same way, when we cache a piece of information
    in Streamlit, we are making a bet that we’ll use that information often.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 应用缓存的一个很好的类比是人类的短期记忆，我们将可能有用的信息保存在身边。当某些信息存在于我们的短期记忆中时，我们不需要费力地去思考就能快速访问该信息。同样，当我们在
    Streamlit 中缓存某些信息时，我们是在下注，认为我们会经常使用这些信息。
- en: The way Streamlit caching works more specifically is by storing the results
    of a function in our app, and if that function is called with the same parameters
    by another user (or by us if we rerun the app), Streamlit does not run the same
    function but instead loads the result of the function from memory.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Streamlit 缓存工作方式的具体实现是将一个函数的结果存储在我们的应用中，如果其他用户（或我们重新运行应用时）使用相同的参数调用该函数，Streamlit
    不会再次运行相同的函数，而是从内存中加载该函数的结果。
- en: Let’s prove to ourselves that this works! First, we’ll create a function for
    our data upload part of the Penguins app, and then use the `time` library to artificially
    make the function take much longer than it would normally and see whether we can
    make our app faster using `st.cache_data`. There are two Streamlit caching functions,
    one for data (`st.cache_data`) and one for resources like database connections
    or machine learning models (`st.cache_resource`).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来验证这个方法是否有效！首先，我们将为 Penguins 应用的数据上传部分创建一个函数，然后使用 `time` 库人为地让该函数的执行时间比正常情况长，并查看是否能够通过
    `st.cache_data` 使我们的应用更快。Streamlit 有两个缓存函数，一个用于数据（`st.cache_data`），另一个用于像数据库连接或机器学习模型这样的资源（`st.cache_resource`）。
- en: Don’t worry, we’ll learn all about `st.cache_resource` in *Chapter 4*, *Machine
    Learning and AI with Streamlit*, but we don’t need it now so we’ll focus on caching
    data first.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 不用担心，我们将在*第 4 章*《使用 Streamlit 的机器学习与人工智能》中详细了解 `st.cache_resource`，但现在我们不需要它，因此我们先专注于缓存数据。
- en: 'As you can see in the following code, we first made a new function called `load_file()`,
    which waits 3 seconds, and then loads the file that we need. Normally, we would
    not intentionally slow down our app, but we want to know whether caching works:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在下面的代码中看到的，我们首先创建了一个名为 `load_file()` 的新函数，它等待 3 秒，然后加载我们需要的文件。通常情况下，我们不会故意拖慢应用程序的速度，但我们想知道缓存是否有效：
- en: '[PRE10]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now, let’s run this app and then select the hamburger icon in the top right
    and press the rerun button (we can also just press the *R* key to rerun).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们运行这个应用程序，然后选择右上角的汉堡菜单图标，按下重新运行按钮（我们也可以直接按*R*键来重新运行）。
- en: 'We notice that each time we rerun the app, it takes at least 3 seconds. Now,
    let’s add our cache decorator on top of the `load_file()` function and run our
    app again:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们注意到每次重新运行应用程序时，都会至少需要 3 秒钟。现在，让我们在 `load_file()` 函数上方添加缓存装饰器，然后再次运行应用程序：
- en: '[PRE11]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As we run the app a few times, we can notice that it is much faster! When we
    rerun the app, two things happen. First, Streamlit checks the cache to ascertain
    whether that same function with the same inputs has been run before and returns
    the Palmer’s Penguins data from memory, and second, it does not run the `load_file()`
    function at all, meaning we never run the `time.sleep(3)` command and also never
    spend the time required to load the data into Streamlit. We’ll explore this caching
    function in more detail, but this method offers us the majority of the efficiency
    gains. The last flow-related topic we will cover here is Streamlit’s `st.session_state`,
    which is used to hold information across sessions!
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行几次应用程序时，我们可以注意到它变得更快了！当我们重新运行应用程序时，会发生两件事。首先，Streamlit 会检查缓存，确定是否之前已经运行过相同输入的相同函数，并从内存中返回
    Palmer’s Penguins 数据；其次，它根本不会运行 `load_file()` 函数，这意味着我们从未运行过 `time.sleep(3)` 命令，也没有浪费时间将数据加载到
    Streamlit 中。我们将更详细地探讨这个缓存功能，但这种方法为我们带来了大部分的效率提升。我们在这里要讲的最后一个与流相关的主题是 Streamlit
    的 `st.session_state`，它用于在会话之间保存信息！
- en: Persistence with Session State
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Session State 保持持久性
- en: 'One of the most frustrating parts of the Streamlit operating model for developers
    starting out is the combination of two facts:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 对于刚开始的开发者来说，Streamlit 操作模型中最令人沮丧的部分是两个事实的结合：
- en: By default, information is not stored across reruns of the app.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，信息不会在应用程序的重新运行之间保存。
- en: On user input, Streamlits are rerun top-to-bottom.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在用户输入时，Streamlit 会从上到下重新运行。
- en: 'These two facts make it difficult to make certain types of apps! This is best
    shown in an example. Let’s say that we want to make a to-do app that makes it
    easy for you to add items to your to-do list. Adding user input in Streamlit is
    really simple, so we can create one quickly in a new file called `session_state_example.py`
    that looks like the following:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个事实使得某些类型的应用程序变得难以制作！最好的方式是通过一个示例来展示。假设我们想做一个待办事项应用程序，便于你将项目添加到待办事项列表中。在 Streamlit
    中添加用户输入非常简单，因此我们可以在名为 `session_state_example.py` 的新文件中快速创建一个，代码如下：
- en: '[PRE12]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This app seems to work well on first use. You can add to the list from the
    text box as shown below:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应用程序在第一次使用时似乎运行得很好。你可以从文本框中添加项目，见下图：
- en: '![A screenshot of a computer  Description automatically generated](img/B18444_02_11.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![计算机截图 说明自动生成](img/B18444_02_11.png)'
- en: 'Figure 2.11: To-do list'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.11：待办事项列表
- en: 'Now what do you think will happen if we try to add a second item? Let’s try
    it now by adding another item to our list:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果我们尝试添加第二个项目，你认为会发生什么呢？让我们现在尝试通过向列表中添加另一个项目来验证一下：
- en: '![A screenshot of a computer program  Description automatically generated](img/B18444_02_12.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![计算机程序截图 说明自动生成](img/B18444_02_12.png)'
- en: 'Figure 2.12: Second addition'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.12：第二次添加
- en: Once you try to add more than one item to the list, you will notice that it
    resets the original list and forgets what the first item you entered was! Now
    our to-do list does not contain our eat fruit addition from earlier.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你尝试将多个项目添加到列表中，你会注意到它会重置原始列表，并且忘记了你最初输入的第一个项目！现在我们的待办事项列表中没有之前添加的“吃水果”项目。
- en: 'Enter `st.session_state`. Session State is a Streamlit feature that is a global
    dictionary that persists through a user’s session. This allows us to get around
    the two annoyances we mentioned earlier in this section, by placing the user’s
    inputs into this global dictionary! We can add the Session State functionality
    by first checking if we have placed our to-do list in the `session_state` dictionary,
    and if not, setting our default values. And with each new button click, we can
    update our list that we placed in the `session_state` dictionary:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 输入`st.session_state`。Session State是Streamlit的一个特性，它是一个全局字典，在用户的会话中保持持久化。这使我们能够绕过本节中提到的两个烦恼，将用户的输入存放到这个全局字典中！我们可以通过首先检查是否将待办事项列表存放在`session_state`字典中来添加Session
    State功能，如果没有，就设置默认值。每次点击新按钮时，我们都可以更新我们放入`session_state`字典中的列表：
- en: '[PRE13]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now, our app will work just fine and will keep our to-do list until we leave
    the app or refresh the page. And we can add multiple to-do items!
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的应用程序将正常工作，并且会在离开应用或刷新页面之前保持我们的待办事项列表。我们还可以添加多个待办事项！
- en: '![A screenshot of a computer  Description automatically generated](img/B18444_02_13.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![计算机截图  描述自动生成](img/B18444_02_13.png)'
- en: 'Figure 2.13: Multiple additions'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.13：多个添加
- en: There are many applications of this, from keeping the state of Streamlit inputs
    to applying filters across multi-page apps (don’t worry, we will cover these later
    in this book). But whenever you want to keep information from the user across
    runs, `st.session_state` can help you out.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这有许多应用场景，从保持Streamlit输入的状态到在多页应用程序中应用过滤器（别担心，我们会在后面的书中讨论这些）。但每当你想在不同运行之间保持用户信息时，`st.session_state`都可以帮助你。
- en: Summary
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter was full of fundamental building blocks that we will use often
    throughout the remainder of this book, and that you will use to develop your own
    Streamlit applications.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 本章充满了我们将在本书其余部分中频繁使用的基本构建模块，这些模块也将帮助你开发自己的Streamlit应用程序。
- en: In terms of data, we covered how to bring our own DataFrames into Streamlit
    and how to accept user input in the form of a data file, which brings us past
    only being able to simulate data. In terms of other skill sets, we learned how
    to use our cache to make our data apps faster, how to control the flow of our
    Streamlit apps, and how to debug our Streamlit apps using `st.write()`. That’s
    it for this chapter. Next, we’ll move on to data visualization!
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据方面，我们介绍了如何将自己的DataFrame导入Streamlit，以及如何以数据文件的形式接受用户输入，这使得我们超越了仅能模拟数据的限制。在其他技能方面，我们学会了如何使用缓存加速数据应用程序，如何控制Streamlit应用的流程，以及如何使用`st.write()`调试Streamlit应用。这就是本章的内容，接下来我们将进入数据可视化部分！
- en: Learn more on Discord
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解更多信息请访问Discord
- en: 'To join the Discord community for this book – where you can share feedback,
    ask questions to the author, and learn about new releases – follow the QR code
    below:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 要加入本书的Discord社区——在这里你可以分享反馈、向作者提问、并了解新版本的发布——请扫描下方的二维码：
- en: '[https://packt.link/sl](https://packt.link/sl)'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/sl](https://packt.link/sl)'
- en: '![](img/QR_Code13440134443835796.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code13440134443835796.png)'
