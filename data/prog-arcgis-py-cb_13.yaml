- en: Chapter 13. Using Python with ArcGIS Pro
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 13 章：使用 ArcGIS Pro 中的 Python
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下主题：
- en: Using the new Python window in ArcGIS Pro
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 ArcGIS Pro 中使用新的 Python 窗口
- en: Coding differences between ArcGIS for Desktop and ArcGIS Pro
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ArcGIS for Desktop 和 ArcGIS Pro 之间的编码差异
- en: Installing Python for standalone ArcGIS Pro scripts
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为独立 ArcGIS Pro 脚本安装 Python
- en: Converting ArcGIS for Desktop Python code to ArcGIS Pro
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 ArcGIS for Desktop 的 Python 代码转换为 ArcGIS Pro
- en: Introduction
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In this chapter, we will briefly cover several concepts related to using Python
    in ArcGIS Pro. There are many similarities between using Python in ArcGIS for
    Desktop and ArcGIS Pro, so what you've learned up to this point will almost certainly
    translate to the new ArcGIS Pro environment. However, there are some differences
    in ArcGIS for Desktop and ArcGIS Pro, also there is a new Python Window that you
    can use.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将简要介绍与在 ArcGIS Pro 中使用 Python 相关的几个概念。在 ArcGIS for Desktop 和 ArcGIS Pro
    中使用 Python 之间存在许多相似之处，因此你到目前为止所学的知识几乎肯定可以迁移到新的 ArcGIS Pro 环境中。然而，ArcGIS for Desktop
    和 ArcGIS Pro 之间也有一些差异，还有一个你可以使用的新 Python 窗口。
- en: 'There are some differences between using Python in ArcGIS for Desktop and ArcGIS
    Pro. In general, you can break down the differences as follows:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ArcGIS for Desktop 和 ArcGIS Pro 中使用 Python 之间存在一些差异。一般来说，你可以将差异归纳如下：
- en: Functionality differences
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功能性差异
- en: Python version 3 instead of version 2
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Python 3 而不是版本 2
- en: Unsupported data formats
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不支持的数据格式
- en: Changes to functionality in ArcPy for ArcGIS Pro includes the removal of some
    geoprocessing tools, including the Coverage, Data Interoperability, Parcel Fabric,
    Schematics, and Tracking Analyst toolboxes. There are some additional tools in
    other toolboxes that are not available as well. The full list of geoprocessing
    tools that are not included can be found at [http://pro.arcgis.com/en/pro-app/tool-reference/appendices/unavailable-tools.htm](http://pro.arcgis.com/en/pro-app/tool-reference/appendices/unavailable-tools.htm).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: ArcGIS Pro 中 ArcPy 功能的变化包括移除一些地理处理工具，包括 Coverage、数据互操作性、地籍网、图表和追踪分析师工具箱。在其他工具箱中也有一些不可用的额外工具。未包含的地理处理工具的完整列表可以在[http://pro.arcgis.com/en/pro-app/tool-reference/appendices/unavailable-tools.htm](http://pro.arcgis.com/en/pro-app/tool-reference/appendices/unavailable-tools.htm)找到。
- en: ArcGIS Pro uses version 3.4 of Python, while ArcGIS for Desktop 10.3 uses version
    2.7\. There are some significant differences between the two releases and they
    are incompatible. A lot of the language is the same, but there are some significant
    differences related to strings, dictionaries, and other objects.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: ArcGIS Pro 使用 Python 3.4 版本，而 ArcGIS for Desktop 10.3 使用 2.7 版本。这两个版本之间存在一些显著差异，并且它们是不兼容的。大部分语言是相同的，但与字符串、字典和其他对象相关的某些重大差异。
- en: A number of data formats will not be supported in the new ArcGIS Pro environment,
    including personal geodatabases, raster catalogs, geometric networks, topologies,
    layer and map packages, and others. If you have been using one of these data formats
    in ArcGIS for Desktop, please keep in mind that they are not supported, so any
    scripts that you have written that use these formats will not be able to execute.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在新的 ArcGIS Pro 环境中，将不支持多种数据格式，包括个人地理数据库、栅格目录、几何网络、拓扑、图层和地图包等。如果你一直在 ArcGIS for
    Desktop 中使用这些数据格式之一，请记住它们不受支持，因此任何使用这些格式的脚本将无法执行。
- en: Using the new Python window in ArcGIS Pro
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 ArcGIS Pro 中使用新的 Python 窗口
- en: If you've been using the Python window in ArcGIS for Desktop, you'll already
    be pretty familiar with the Python window in ArcGIS Pro. However, there are some
    differences between the two and some improvements as well. In this recipe, you'll
    learn how to use the ArcGIS Pro Python window.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你一直在使用 ArcGIS for Desktop 中的 Python 窗口，那么你将非常熟悉 ArcGIS Pro 中的 Python 窗口。然而，两者之间有一些差异和一些改进。在本食谱中，你将学习如何使用
    ArcGIS Pro 的 Python 窗口。
- en: The Python window in ArcGIS Pro functions in much the same way as the window
    in ArcGIS for Desktop. It serves as an integrated tool used to execute Python
    code for geoprocessing operations. Using the Python Window, you can execute Python
    functionalities, including ArcPy, core Python functionalities, and third-party
    libraries. Python code that you write in the window can be saved or loaded from
    an existing script source. The inclusion of autocompletion functionality makes
    it easier to complete coding operations, including calling tools and passing parameters.
    In this recipe, you'll learn how to use the ArcGIS Pro Python window.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: ArcGIS Pro中的Python窗口在功能上与ArcGIS for Desktop中的窗口非常相似。它是一个集成工具，用于执行地理处理操作中的Python代码。使用Python窗口，你可以执行Python功能，包括ArcPy、核心Python功能和第三方库。你可以在窗口中编写的Python代码可以保存或从现有的脚本源加载。自动完成功能使得完成编码操作变得更容易，包括调用工具和传递参数。在本菜谱中，你将学习如何使用ArcGIS
    Pro的Python窗口。
- en: 'Follow these steps to learn how to use the ArcGIS Pro Python window:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤学习如何使用ArcGIS Pro的Python窗口：
- en: Open **ArcGIS Pro** and select a project or create a new project.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**ArcGIS Pro**并选择一个项目或创建一个新的项目。
- en: Click on the **ANALYSIS** menu item in ArcGIS Pro and then the **Python** tool,
    as shown in the following screenshot:![Using the new Python window in ArcGIS Pro](img/B04314_13_1.jpg)
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在ArcGIS Pro中单击**分析**菜单项，然后选择**Python**工具，如图所示：![使用ArcGIS Pro中的新Python窗口](img/B04314_13_1.jpg)
- en: This will display the **Python** window at the bottom of the ArcGIS Pro window,
    as seen in the following screenshot:![Using the new Python window in ArcGIS Pro](img/B04314_13_2.jpg)
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将在ArcGIS Pro窗口的底部显示**Python**窗口，如图所示：![使用ArcGIS Pro中的新Python窗口](img/B04314_13_2.jpg)
- en: The Python window can be pinned, unpinned, and resized.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Python窗口可以被固定、取消固定和调整大小。
- en: 'There are two basic sections of the Python window in ArcGIS Pro: **Transcript**
    and **Python prompt**. Both are shown in the following screenshot. You will write
    code in the Python prompt section one line at a time. The transcript section provides
    a record of Python code that has already been executed.![Using the new Python
    window in ArcGIS Pro](img/B04314_13_3.jpg)'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ArcGIS Pro中的Python窗口有两个基本部分：**转储**和**Python提示**。两者都在以下屏幕截图中显示。你将逐行在Python提示部分编写代码。转储部分提供了已执行的Python代码的记录。![使用ArcGIS
    Pro中的新Python窗口](img/B04314_13_3.jpg)
- en: 'After typing in a line of code, you press the *Enter* key on your keyboard
    and the code is executed and moved to the transcript section. Print messages are
    written to the transcript window as errors. Type the following line of code to
    import the ArcPy mapping module:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在输入一行代码后，你按下键盘上的*Enter*键，代码将被执行并移动到转储部分。打印消息作为错误写入转储窗口。输入以下代码行以导入ArcPy映射模块：
- en: '[PRE0]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The ArcGIS Pro Python window has a code completion functionality so that as
    you begin typing, various matching options will be presented that provide a current
    match to what you have typed. You can select one of the items from the presented
    list to complete the typing. You can see an illustration of this by typing `arc`
    in the Python prompt. The code completion functionality will present two options:
    `arcgis` and `arcpy`.'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ArcGIS Pro的Python窗口具有代码自动完成功能，因此当你开始输入时，将提供各种匹配选项，以提供当前与所输入内容相匹配的选项。你可以从提供的列表中选择一个项目来完成输入。你可以通过在Python提示中输入`arc`来查看这一功能的说明。代码自动完成功能将提供两个选项：`arcgis`和`arcpy`。
- en: You can access the built-in help system by using the `help()` method. Type `help(arcpy.ListFeatureClasses())`
    in order to see an illustration of the help documentation that is provided:![Using
    the new Python window in ArcGIS Pro](img/B04314_13_4.jpg)
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以通过使用`help()`方法访问内置的帮助系统。输入`help(arcpy.ListFeatureClasses())`以查看提供的帮助文档的说明：![使用ArcGIS
    Pro中的新Python窗口](img/B04314_13_4.jpg)
- en: You can save any Python code that you have written by right-clicking inside
    the transcript section and selecting **Save Transcript**. In addition to this,
    you can load an existing Python script into the window by right-clicking in the
    prompt section and selecting **Load Code**.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以通过在转储部分右键单击并选择**保存转储**来保存你编写的任何Python代码。此外，你还可以通过在提示部分右键单击并选择**加载代码**将现有的Python脚本加载到窗口中。
- en: The ArcGIS Pro Python window can be used to write basic Python geoprocessing
    scripts, execute tools, access ArcPy and its associated modules, Python core modules
    and third-party modules, load and execute existing Python scripts, save Python
    scripts for later use, and obtain help for ArcPy classes and functions. However,
    there are coding differences between ArcGIS for Desktop and ArcGIS Pro.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: ArcGIS Pro Python 窗口可用于编写基本的 Python 地理处理脚本、执行工具、访问 ArcPy 及其相关模块、Python 核心模块和第三方模块、加载和执行现有的
    Python 脚本、保存 Python 脚本以供以后使用，以及获取 ArcPy 类和函数的帮助。但是，ArcGIS for Desktop 和 ArcGIS
    Pro 之间存在编码差异。
- en: Coding differences between ArcGIS for Desktop and ArcGIS Pro
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ArcGIS for Desktop 和 ArcGIS Pro 之间的编码差异
- en: In this section, we'll discuss some of the differences between Python code written
    in ArcGIS for Desktop and ArcGIS Pro. Fortunately, there aren't many differences.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论 ArcGIS for Desktop 和 ArcGIS Pro 编写的 Python 代码之间的一些差异。幸运的是，差异并不多。
- en: ArcPy supports a variety of modules, including the data access, mapping, spatial
    analyst, network analyst, and time modules. As you have already learned, to use
    these modules, you must first import them into your script. For most of these
    modules, the way that you import them will be the same regardless of whether you're
    using ArcGIS for Desktop or ArcGIS Pro. However, there are some differences when
    importing the ArcPy mapping module.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: ArcPy 支持多种模块，包括数据访问、制图、空间分析、网络分析和时间模块。正如您已经学到的，要使用这些模块，您必须首先将它们导入到您的脚本中。对于这些模块中的大多数，您导入它们的方式将不取决于您是使用
    ArcGIS for Desktop 还是 ArcGIS Pro。然而，在导入 ArcPy 制图模块时有一些差异。
- en: 'In the ArcGIS Pro Python environment, you''ll need to use the following syntax
    to import the mapping module. The use of a two-character reference to the mapping
    module is in line with how all the other modules are imported:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ArcGIS Pro Python 环境中，您需要使用以下语法来导入制图模块。使用两个字符引用制图模块的方式与其他所有模块的导入方式一致：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This differs from how you reference the ArcPy mapping module in ArcGIS for
    Desktop, as seen in this code example:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这与您在 ArcGIS for Desktop 中引用 ArcPy 制图模块的方式不同，如以下代码示例所示：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Installing Python for ArcGIS Pro
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Python 用于 ArcGIS Pro
- en: Many of you will probably have become quite familiar with executing your Python
    ArcGIS for Desktop geoprocessing scripts in standalone environments. Examples
    of this would include executing a script from an integrated development environment,
    such as IDLE as a scheduled task, or from an operating system prompt. By default,
    ArcGIS Pro does not include this capability. ArcGIS Pro does include an embedded
    Python editor that will allow you to execute your code in the Python window as
    a script tool or a geoprocessing tool. However, if you need to be able to access
    ArcGIS Pro functionalities from a standalone environment, you will need to download
    and install a Python setup file from **My Esri** ([https://my.esri.com/#/downloads](https://my.esri.com/#/downloads)).
    This installer file will install Python 3.4.1 and other requirements needed by
    ArcGIS Pro.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你们中的许多人可能已经非常熟悉在独立环境中执行您的 Python ArcGIS for Desktop 地理处理脚本。这包括从集成开发环境（如 IDLE
    作为计划任务）或从操作系统提示符中执行脚本。默认情况下，ArcGIS Pro 不包括此功能。ArcGIS Pro 包含一个嵌入的 Python 编辑器，允许您将代码作为脚本工具或地理处理工具在
    Python 窗口中执行。但是，如果您需要能够从独立环境中访问 ArcGIS Pro 功能，您将需要从 **My Esri** ([https://my.esri.com/#/downloads](https://my.esri.com/#/downloads))
    下载并安装一个 Python 设置文件。此安装文件将安装 Python 3.4.1 和 ArcGIS Pro 所需的其他要求。
- en: Converting ArcGIS for Desktop Python code to ArcGIS Pro
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 ArcGIS for Desktop Python 代码转换为 ArcGIS Pro
- en: As I mentioned earlier in this chapter, there aren't many differences between
    the Python code you would write for ArcGIS for Desktop and ArcGIS Pro. We've already
    discussed the primary differences between the two. The versions of Python used
    are quite different with ArcGIS for Desktop 10.3, which runs Python 2.7 and ArcGIS
    Pro 1.0, which runs Python 3.4\. These two versions of Python are incompatible
    and there are some tools that you can use when migrating your existing code to
    ArcGIS Pro.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如我在本章前面提到的，ArcGIS for Desktop 和 ArcGIS Pro 的 Python 代码之间没有太多差异。我们已经讨论了两者之间的主要差异。Python
    的版本在 ArcGIS for Desktop 10.3 中有所不同，它运行 Python 2.7，而 ArcGIS Pro 1.0 运行 Python 3.4。这两个版本的
    Python 不兼容，并且在将现有代码迁移到 ArcGIS Pro 时，您可以使用一些工具。
- en: The first tool that we'll examine is the `AnalyzeToolsForPro`. This geoprocessing
    tool can be found in the `Management` toolbox. This tool analyzes Python scripts
    and custom geoprocessing tools, and toolboxes for functionalities that are not
    supported by ArcGIS Pro. This tool will identify any geoprocessing tools and environment
    settings that are not supported by ArcGIS Pro, the replacement of `arcpy.mapping`
    with `arcpy.mp`, and any unsupported data formats, such as personal geodatabases
    that are not supported by ArcGIS Pro. For issues related to Python 2 and Python
    3, the tool also uses the `2to3` utility to identify any Python-specific issues.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要检查的第一个工具是 `AnalyzeToolsForPro`。这个地理处理工具可以在 `Management` 工具箱中找到。这个工具可以分析不支持
    ArcGIS Pro 功能的 Python 脚本、自定义地理处理工具和工具箱。这个工具将识别任何不支持 ArcGIS Pro 的地理处理工具和环境设置，将
    `arcpy.mapping` 替换为 `arcpy.mp`，以及任何不支持的数据格式，例如 ArcGIS Pro 不支持的个人地理数据库。对于与 Python
    2 和 Python 3 相关的问题，该工具还使用 `2to3` 实用程序来识别任何 Python 特定问题。
- en: 'The following is the syntax for this tool:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是该工具的语法：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The input for this tool can be a geoprocessing toolbox, Python file, or tool
    name, and the optional report parameter is a output text file that includes any
    issues that were identified.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 该工具的输入可以是地理处理工具箱、Python 文件或工具名称，可选的报表参数是一个包含任何已识别问题的输出文本文件。
- en: You can also use the standalone `2to3` Python tool that will identify any Python-specific
    coding issues related to the differences between the two versions of the language.
    This is a command-line utility provided with Python 2 and 3 installations. The
    utility can be found in a path similar to `C:\Python34\Tools\Scripts\2to3.py`
    or `C:\Python27\Tools\Scripts\2to3.py`. This is not a perfect tool, but has been
    estimated to identify approximately 95 percent of the differences.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用独立的 `2to3` Python 工具，该工具可以识别与两种语言版本差异相关的任何 Python 特定编码问题。这是一个与 Python
    2 和 3 安装一起提供的命令行实用程序。该实用程序可以在类似 `C:\Python34\Tools\Scripts\2to3.py` 或 `C:\Python27\Tools\Scripts\2to3.py`
    的路径中找到。这不是一个完美的工具，但据估计可以识别大约 95% 的差异。
- en: Appendix A. Automating Python Scripts
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录 A. 自动化 Python 脚本
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Running Python scripts from the command line
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从命令行运行 Python 脚本
- en: Using sys.argv[ ] to capture command-line input
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 sys.argv[ ] 捕获命令行输入
- en: Adding Python scripts to batch files
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 Python 脚本添加到批处理文件中
- en: Scheduling batch files to run at prescribed times
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安排批处理文件在指定时间运行
- en: Introduction
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Python geoprocessing scripts can be executed either outside ArcGIS as standalone
    scripts or inside ArcGIS as script tools. Both methods have their advantages and
    disadvantages. Up to this point in the book, all our scripts have been run either
    inside ArcGIS as a script tool, from a Python development environment such as
    IDLE, or the Python window in ArcGIS. However, Python scripts can also be executed
    from the Windows operating system command line. The command line is a window that
    you can use to type in commands, rather than the usual point-and-click approach
    provided by Windows. This method of running Python scripts is useful for scheduling
    the execution of a script. There are a number of reasons why you might want to
    schedule your scripts. Many geoprocessing scripts take a long time to fully execute
    and need to be scheduled to run during nonworking hours on a regular basis. Additionally,
    some scripts need to be executed on a routine basis (every day, week, month, and
    so on), and should be scheduled for efficiency. In this chapter, you will learn
    how to execute scripts from the command line, place scripts inside a batch file,
    and schedule the execution of scripts at prescribed times. Keep in mind that any
    scripts run from the command line will still need access to an ArcGIS for Desktop
    license in order to use the `arcpy` module.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Python 地理处理脚本可以在 ArcGIS 外部作为独立脚本或内部作为脚本工具执行。这两种方法都有其优缺点。到目前为止，本书中的所有脚本都是在 ArcGIS
    内部作为脚本工具、从 Python 开发环境（如 IDLE）或 ArcGIS 中的 Python 窗口中运行的。然而，Python 脚本也可以从 Windows
    操作系统命令行执行。命令行是一个可以输入命令的窗口，而不是 Windows 提供的常规点按操作。这种方法运行 Python 脚本对于安排脚本的执行很有用。你可能有很多理由想要安排你的脚本。许多地理处理脚本需要很长时间才能完全执行，需要定期在工作时间之外安排运行。此外，一些脚本需要定期执行（每天、每周、每月等），并且应该安排以提高效率。在本章中，你将学习如何从命令行执行脚本、将脚本放入批处理文件中，以及安排在指定时间执行脚本。请记住，任何从命令行运行的脚本仍然需要访问
    ArcGIS for Desktop 许可证才能使用 `arcpy` 模块。
- en: Running Python scripts from the command line
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从命令行运行Python脚本
- en: Up to this point in the book, all your Python scripts have been run as either
    script tools in ArcGIS or from a Python development environment. The Windows command
    prompt provides yet another way of executing your Python scripts. The command
    prompt is used primarily to execute scripts that will be run as a part of a batch
    file and/or as scheduled tasks.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本书中您所有的Python脚本都是作为ArcGIS中的脚本工具或从Python开发环境中运行的。Windows命令提示符提供了执行Python脚本的另一种方式。命令提示符主要用于执行作为批处理文件的一部分或作为计划任务运行的脚本。
- en: Getting ready
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: There are a couple advantages of running Python geoprocessing scripts from the
    command prompt. These scripts can be scheduled to batch process your data during
    off hours for more efficient processing, and they are easier to debug due to the
    built-in Python error handling and debugging capabilities.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 从命令提示符运行Python地理处理脚本有几个优点。这些脚本可以安排在非工作时间批量处理您的数据，以提高处理效率，并且由于内置的Python错误处理和调试功能，它们更容易调试。
- en: In this recipe, you will learn how to use the Windows command prompt to execute
    a Python script. You will need administrative rights to complete this recipe,
    so you may need to contact your information technology support group to make this
    change.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，您将学习如何使用Windows命令提示符来执行Python脚本。您需要管理员权限才能完成此食谱，因此您可能需要联系您的信息技术支持团队以进行此更改。
- en: How to do it…
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Follow these steps to learn how to run a script from the Windows command prompt:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤学习如何在Windows命令提示符中运行脚本：
- en: In Windows, navigate to **Start** | **All Programs** | **Accessories** | **Command
    Prompt** which will display a window similar to the following screenshot:![How
    to do it…](img/B04314_A1_1.jpg)
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Windows中，导航到**开始** | **所有程序** | **附件** | **命令提示符**，这将显示与以下截图类似的窗口：![如何操作…](img/B04314_A1_1.jpg)
- en: The window will display the current directory. Your directory will differ to
    some degree. Let's change to the directory for this appendix.
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 窗口将显示当前目录。您的目录可能会有所不同。让我们切换到本附录的目录。
- en: Type `cd c:\ArcpyBook\Appendix1`.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入`cd c:\ArcpyBook\Appendix1`。
- en: Type `dir` to see a listing of the files and subdirectories. You should see
    only a single Python file called `ListFields.py`:![How to do it…](img/B04314_A1_2.jpg)
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入`dir`以查看文件和子目录的列表。您应该只看到一个名为`ListFields.py`的单个Python文件：![如何操作…](img/B04314_A1_2.jpg)
- en: You will need to make sure that the Python interpreter can be run from anywhere
    in your directory structure. Navigate to **Start** | **All Programs** | **Accessories**
    | **System Tools** | **Control Panel** as shown in the following screenshot:![How
    to do it…](img/B04314_A1_3.jpg)
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您需要确保Python解释器可以从目录结构中的任何位置运行。按照以下截图所示，导航到**开始** | **所有程序** | **附件** | **系统工具**
    | **控制面板**：![如何操作…](img/B04314_A1_3.jpg)
- en: Click on **System and Security**.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**系统和安全**。
- en: Click on **System**.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**系统**。
- en: Click on **Advanced system settings**.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**高级系统设置**。
- en: In the **System Properties** dialog box, select the **Advanced** tab and then
    the **Environment Variables** button, as shown in the following screenshot:![How
    to do it…](img/B04314_A1_4.jpg)
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**系统属性**对话框中，选择**高级**选项卡，然后点击**环境变量**按钮，如图所示：![如何操作…](img/B04314_A1_4.jpg)
- en: Find the **Path** system variable, as can be seen in the following screenshot,
    and click on **Edit…**:![How to do it…](img/B04314_A1_5.jpg)
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找**路径**系统变量，如图所示，并点击**编辑…**：![如何操作…](img/B04314_A1_5.jpg)
- en: Examine the entire text string for the `C:\Python27\ArcGIS10.3` directory. If
    the text string isn't found, add it to the end. Make sure that you add a semicolon
    before adding the path as shown in the following screenshot. Now, when you type
    `python` in the command prompt, it will look through each of the directories in
    the **Path** system variable, checking for an executable called `python.exe`.![How
    to do it…](img/B04314_A1_6.jpg)
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查整个文本字符串中是否存在`C:\Python27\ArcGIS10.3`目录。如果找不到文本字符串，请将其添加到末尾。确保在添加路径之前添加一个分号，如图所示。现在，当您在命令提示符中输入`python`时，它将遍历**路径**系统变量中的每个目录，检查是否存在名为`python.exe`的可执行文件。![如何操作…](img/B04314_A1_6.jpg)
- en: Click on **OK** to dismiss the **Edit System Variable** dialog box.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**确定**以关闭**编辑系统变量**对话框。
- en: Click on **OK** to dismiss the **Environment Variables** dialog box.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**确定**以关闭**环境变量**对话框。
- en: Click on **OK** to dismiss the **System Properties** dialog box.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**确定**以关闭**系统属性**对话框。
- en: Return to the command prompt.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到命令提示符。
- en: Type `python ListFields.py`. This will run the `ListFields.py` script. After
    a brief delay, you should see the following output:![How to do it…](img/B04314_A1_7.jpg)
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入`python ListFields.py`。这将运行`ListFields.py`脚本。在短暂的延迟后，你应该看到以下输出：![如何操作…](img/B04314_A1_7.jpg)
- en: The delay is caused by the first line of code that imports the `arcpy` module.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 延迟是由导入`arcpy`模块的第一行代码引起的。
- en: Tip
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Consider adding a `print` statement before `import` to inform users of the delay.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑在`import`之前添加一个`print`语句，以通知用户延迟。
- en: How it works…
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: The `ListFields.py` script provided for you in this recipe is a simple script
    that lists the attribute fields for `Burglary feature class`. The workspace and
    feature class name are hardcoded in the script. Typing `python` followed by the
    name of the script, which is `ListFields.py` in this case, triggered the execution
    of a script using the Python interpreter. As I mentioned earlier, the workspace
    and feature class names were hardcoded in this script. In the next recipe, you
    will learn how to pass in arguments to the script so that you can remove the hardcoding
    and make your script more flexible.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱中提供的`ListFields.py`脚本是一个简单的脚本，用于列出`Burglary`要素类的属性字段。脚本中的工作空间和要素类名称是硬编码的。输入`python`后跟脚本名称，在本例中为`ListFields.py`，将触发使用Python解释器执行脚本。如我之前提到的，此脚本中的工作空间和要素类名称是硬编码的。在下一个菜谱中，你将学习如何向脚本传递参数，以便你可以移除硬编码并使你的脚本更加灵活。
- en: Using sys.argv[ ] to capture command-line input
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`sys.argv[ ]`捕获命令行输入
- en: Instead of hardcoding your scripts with paths to specific datasets, you can
    make your scripts more flexible by allowing them to accept input in the form of
    parameters from the command prompt. These input parameters can be captured using
    Python's `sys.argv[]` object.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过允许脚本接受来自命令行的参数形式输入来使脚本更加灵活，而不是将脚本硬编码为特定数据集的路径。您可以使用Python的`sys.argv[]`对象捕获这些输入参数。
- en: Getting ready
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Python''s `sys.argv[]` object allows you to capture input parameters from the
    command line when a script is executed. We will use an example to illustrate how
    this works. Take a look at the following screenshot:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Python的`sys.argv[]`对象允许您在脚本执行时从命令行捕获输入参数。我们将通过一个示例来说明它是如何工作的。请看以下截图：
- en: '![Getting ready](img/B04314_A1_8.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作](img/B04314_A1_8.jpg)'
- en: Each word must be separated by a space. These words are stored in a zero-based
    list object called `sys.argv[]`. In the `sys.argv[]` object, the first item in
    the list referenced by the `0` index, stores the name of the script. In this case,
    it would be `ListFields.py`. Each successive word is referenced by the next integer.
    Therefore, the first parameter (`c:\ArcpyBook\data`) will be stored in `sys.argv[1]`,
    and the second parameter (`Burglaries.shp`) will be stored in `sys.argv[2]`. Each
    of the arguments in the `sys.argv[]` object can be accessed and used inside your
    geoprocessing script. In this recipe, you're going to update the `ListFields.py`
    script so that it accepts input parameters from the command line.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 每个单词必须由空格分隔。这些单词存储在一个以零为基础的列表对象中，称为`sys.argv[]`。在`sys.argv[]`对象中，通过`0`索引引用的列表中的第一个项目存储了脚本的名称。在这种情况下，它将是`ListFields.py`。每个后续的单词通过下一个整数引用。因此，第一个参数（`c:\ArcpyBook\data`）将存储在`sys.argv[1]`中，第二个参数（`Burglaries.shp`）将存储在`sys.argv[2]`中。`sys.argv[]`对象中的每个参数都可以在您的地理处理脚本中访问和使用。在本菜谱中，您将更新`ListFields.py`脚本，使其能够从命令行接受输入参数。
- en: How to do it...
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Follow these steps to create a Python script that can accept input parameters
    from the command prompt, using `sys.argv[]`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建一个Python脚本，该脚本可以使用`sys.argv[]`从命令行接受输入参数：
- en: Open `C:\ArcpyBook\Appendix1\ListFields.py` in IDLE.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在IDLE中打开`C:\ArcpyBook\Appendix1\ListFields.py`。
- en: 'Import the `sys` module:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`sys`模块：
- en: '[PRE4]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Create a variable to hold the workspace that will be passed into the script:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个变量来保存将要传递到脚本中的工作空间：
- en: '[PRE5]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Create a variable to hold the feature class that will be passed into the script:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个变量来保存将要传递到脚本中的要素类：
- en: '[PRE6]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Update the lines of code that set the workspace and call the `ListFields()`
    function:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新设置工作空间和调用`ListFields()`函数的代码行：
- en: '[PRE7]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Your completed script should appear as follows:'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您完成的脚本应如下所示：
- en: '[PRE8]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You can check your work by examining the `C:\ArcpyBook\code\Appendix1\ListFields_Step2.py`
    solution file.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以通过检查`C:\ArcpyBook\code\Appendix1\ListFields_Step2.py`解决方案文件来验证您的作品。
- en: Save the script.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存脚本。
- en: If necessary, open the command prompt and navigate to `C:\ArcpyBook\Appendix1`.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果需要，打开命令提示符并导航到`C:\ArcpyBook\Appendix1`。
- en: 'On the command line, type the following and press the *Enter* key:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令行中键入以下内容并按 *Enter* 键：
- en: '[PRE9]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Once again, you should see the output detailing the attribute fields for the
    `Burglaries_2009.shp` file. The difference is that your script no longer has a
    hardcoded workspace and feature class name. You now have a more flexible script,
    which is capable of listing the attribute fields for any feature class.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次，您应该会看到输出详细说明 `Burglaries_2009.shp` 文件的属性字段。不同之处在于您的脚本不再有硬编码的工作空间和要素类名称。现在您有一个更灵活的脚本，能够列出任何要素类的属性字段。
- en: How it works...
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The `sys` module contains a list object called `argv[]`, which is used to store
    the input parameters for the command-line execution of a Python script. The first
    item stored in the list is always the name of the script. So, in this case, `sys.argv[0]`
    contains `ListFields.py`. Two parameters are passed into the script, including
    the workspace and a feature class. These are stored in `sys.argv[1]` and `sys.argv[2]`,
    respectively. These values are then assigned to variables and used in the script.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`sys` 模块包含一个名为 `argv[]` 的列表对象，用于存储 Python 脚本命令行执行的输入参数。列表中存储的第一个项目总是脚本的名称。因此，在这种情况下，`sys.argv[0]`
    包含 `ListFields.py`。将两个参数传递到脚本中，包括工作空间和要素类。这些值分别存储在 `sys.argv[1]` 和 `sys.argv[2]`
    中。然后，将这些值分配给变量并在脚本中使用。'
- en: Adding Python scripts to batch files
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 Python 脚本添加到批处理文件中
- en: Scheduling your Python scripts to run at prescribed times will require that
    you create a batch file containing one or more scripts and or operating system
    commands. These batch files can then be added to the Windows scheduler to run
    at a specific time interval.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 安排您的 Python 脚本在指定时间运行需要您创建包含一个或多个脚本和/或操作系统命令的批处理文件。然后可以将这些批处理文件添加到 Windows 计划任务中，以在特定时间间隔运行。
- en: Getting ready
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Batch files are text files containing command-line sequences to run Python scripts
    or perform operating system commands. They have a file extension of `.bat`, which
    Windows recognizes as an executable file. Since batch files simply contain command-line
    sequences, they can be written with any text editor, though it is recommended
    that you use a basic text editor, such as Notepad. This is done so that you can
    avoid the inclusion of invisible special characters, which are sometimes inserted
    by programs, such as Microsoft Word. In this recipe, you will create a simple
    batch file that navigates to the directory containing your `ListFields.py` script
    and executes it.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 批处理文件是包含运行 Python 脚本或执行操作系统命令的命令行序列的文本文件。它们具有 `.bat` 扩展名，Windows 识别为可执行文件。由于批处理文件仅包含命令行序列，因此可以使用任何文本编辑器编写，尽管建议您使用基本的文本编辑器，如记事本。这样做是为了避免包含由程序（如
    Microsoft Word）有时插入的不可见特殊字符。在本食谱中，您将创建一个简单的批处理文件，该文件将导航到包含您的 `ListFields.py` 脚本的目录并执行它。
- en: How to do it...
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps to create a batch file:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建批处理文件：
- en: Open a Notepad.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开记事本。
- en: 'Add the following lines of text to the file:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下文本行添加到文件中：
- en: '[PRE10]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Save the file to your desktop as `ListFields.bat`. Make sure you change the
    **Save as Type** drop-down list to **All Files**, otherwise you'll wind up with
    a file called `ListFields.bat.txt`.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文件保存到您的桌面上，命名为 `ListFields.bat`。确保您将 **另存为类型** 下拉列表更改为 **所有文件**，否则您将得到一个名为
    `ListFields.bat.txt` 的文件。
- en: In Windows, navigate to your desktop and double-click on `ListFields.bat` to
    execute the sequence of commands.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Windows 中，导航到您的桌面，双击 `ListFields.bat` 以执行命令序列。
- en: A command prompt will be displayed during execution. After the commands have
    been executed, the command prompt will automatically close.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行过程中将显示命令提示符。命令执行完毕后，命令提示符将自动关闭。
- en: How it works...
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Windows treats a batch file as an executable, so double-clicking on the file
    will automatically execute the sequence of commands contained within the file
    in a new command prompt window. All the `print` statements will be written to
    the window. After the commands have been executed, the command prompt will automatically
    close. In the event that you need to keep a track of the output, you can write
    the statements to an output log file.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 将批处理文件视为可执行文件，因此双击文件将在新的命令提示符窗口中自动执行文件中包含的命令序列。所有的 `print` 语句都将写入窗口。命令执行完毕后，命令提示符将自动关闭。如果您需要跟踪输出，可以将这些语句写入输出日志文件。
- en: There's more...
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: Batch files can contain variables, loops, comments, and conditional logic. These
    functionalities are beyond the scope of this recipe. However, if you're writing
    and running a number of scripts for your organization, it's worthwhile spending
    some time learning more about batch files. Batch files have been around for a
    long time, so there is no shortage of information about these files on the Web.
    For more information about batch files, please consult the Wikipedia page for
    this topic.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 批处理文件可以包含变量、循环、注释和条件逻辑。这些功能超出了本教程的范围。然而，如果你为你的组织编写和运行了许多脚本，花些时间学习更多关于批处理文件的知识是值得的。批处理文件已经存在很长时间了，因此关于这些文件的网上信息并不匮乏。有关批处理文件的更多信息，请参阅此主题的维基百科页面。
- en: Scheduling batch files to run at prescribed times
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在指定时间安排批处理文件运行
- en: Once created, your batch files can then be scheduled to run at prescribed times
    using the Windows scheduler.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建，你的批处理文件就可以使用 Windows 计划任务安排在指定时间运行。
- en: Getting ready
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Many geoprocessing scripts are time-intensive and best run after hours when
    they can take full advantage of system resources and free up your time to concentrate
    on other tasks. In this recipe, you will learn how to use the Windows scheduler
    to schedule the execution of your batch file.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 许多地理处理脚本需要花费大量时间，最好在非工作时间运行，这样它们可以充分利用系统资源，并为你腾出时间来专注于其他任务。在本教程中，你将学习如何使用 Windows
    计划任务来安排批处理文件的执行。
- en: How to do it...
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps to schedule a batch file with the Windows scheduler:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 按以下步骤使用 Windows 计划任务安排批处理文件：
- en: Open the Windows scheduler by navigating to **Start** | **All Programs** | **Accessories**
    | **System Tools** | **Control Panel** | **Administrative Tools**. Select **Task
    Scheduler**. The scheduler should appear, as shown in the following screenshot:![How
    to do it...](img/B04314_A1_9.jpg)
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过导航到**开始** | **所有程序** | **附件** | **系统工具** | **控制面板** | **管理工具**来打开 Windows
    计划任务。选择**任务计划程序**。计划任务应该会显示，如下面的截图所示：![如何操作...](img/B04314_A1_9.jpg)
- en: Select the **Action** menu item and then **Create Basic Task** to display the
    **Create Basic Task Wizard** dialog box, as shown in the next screenshot.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**操作**菜单项，然后选择**创建基本任务**以显示**创建基本任务向导**对话框，如下面的截图所示。
- en: Give your task a name. In this case, we will call it `List Fields from a Feature
    Class`. Click on **Next**:![How to do it...](img/B04314_A1_11.jpg)
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给你的任务命名。在这种情况下，我们将称之为`从要素类列出字段`。点击**下一步**：![如何操作...](img/B04314_A1_11.jpg)
- en: Select a trigger for when the task should be executed. This can, and often will
    be a time-based trigger, but there can also be other types of triggers, such as
    a user login or computer start. In this case, let's just select **Daily**. Click
    on **Next**:![How to do it...](img/B04314_A1_12.jpg)
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择任务执行的时间触发器。这可以，并且通常是一个基于时间的触发器，但也可以有其他类型的触发器，例如用户登录或计算机启动。在这种情况下，我们只需选择**每日**。点击**下一步**：![如何操作...](img/B04314_A1_12.jpg)
- en: Select a start date/time as well as a recurrence interval. In the following
    screenshot, I have selected the date as `12/3/2012`, with the time as `1:00:00
    AM`, and a recurrence interval of `1` day. So, every day at 1:00 AM, this task
    will be executed. Click on **Next**:![How to do it...](img/B04314_A1_13.jpg)
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择开始日期/时间和重复间隔。在下面的截图中，我选择了日期为`12/3/2012`，时间为`凌晨1:00:00`，重复间隔为`1`天。因此，每天凌晨1:00，这个任务将被执行。点击**下一步**：![如何操作...](img/B04314_A1_13.jpg)
- en: Select **Start a program** as the action:![How to do it...](img/B04314_A1_14.jpg)
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**启动程序**作为操作：![如何操作...](img/B04314_A1_14.jpg)
- en: Browse to your script and add the parameters. Click on **Next**:![How to do
    it...](img/B04314_A1_15.jpg)
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 浏览到你的脚本并添加参数。点击**下一步**：![如何操作...](img/B04314_A1_15.jpg)
- en: Click on **Finish** to add a task to the scheduler:![How to do it...](img/B04314_A1_16.jpg)
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**完成**将任务添加到计划任务中：![如何操作...](img/B04314_A1_16.jpg)
- en: The tasks should now be displayed in the list of active tasks:![How to do it...](img/B04314_A1_17.jpg)
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 任务现在应该显示在活动任务列表中：![如何操作...](img/B04314_A1_17.jpg)
- en: How it works...
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The Windows task scheduler keeps track of all the active tasks and handles the
    execution of these tasks when the prescribed trigger is fired. In this recipe,
    we have scheduled our task to execute each day at 1:00 AM. At this time, the batch
    file we created will be triggered and the arguments we specified when creating
    the task will be passed into the script. Using the scheduler to automatically
    execute geoprocessing tasks after hours, without the need for GIS staff to interact
    with the scripts gives you more flexibility and increases your efficiency. You
    might also want to consider logging the errors in your Python scripts to a log
    file for more information about specific problems.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Windows任务计划程序跟踪所有活动任务，并在预定触发器被激活时处理这些任务的执行。在本配方中，我们已将任务计划为每天凌晨1:00执行。此时，我们创建的批处理文件将被触发，并在创建任务时指定的参数将被传递到脚本中。使用计划程序在非工作时间自动执行地理处理任务，无需GIS人员与脚本交互，这为您提供了更大的灵活性并提高了效率。您还可能希望考虑将Python脚本中的错误记录到日志文件中，以获取有关特定问题的更多信息。
- en: Appendix B. Five Python Recipes Every GIS Programmer Should Know
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录B. 每个GIS程序员都应该知道的五个Python配方
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Reading data from a delimited text file
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从分隔符文本文件中读取数据
- en: Sending e-mails
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送电子邮件
- en: Retrieving files from an FTP server
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从FTP服务器检索文件
- en: Creating ZIP files
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建ZIP文件
- en: Reading XML files
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取XML文件
- en: Introduction
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In this chapter, you will learn how to write scripts that perform general purpose
    tasks with Python. Tasks, such as reading and writing delimited text files, sending
    e-mails, interacting with FTP servers, creating `.zip` files, and reading and
    writing JSON and XML files, are common. Every GIS programmer should know how to
    write Python scripts that incorporate these functionalities.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何使用Python编写执行通用任务的脚本。这些任务，例如读取和写入分隔符文本文件、发送电子邮件、与FTP服务器交互、创建`.zip`文件以及读取和写入JSON和XML文件，都是常见的。每个GIS程序员都应该知道如何编写包含这些功能的Python脚本。
- en: Reading data from a delimited text file
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从分隔符文本文件中读取数据
- en: File handling with Python is a very important topic for GIS programmers. Text
    files have been used as an interchange format to exchange data between systems.
    They are simple, cross-platform, and easy to process. Comma and tab-delimited
    text files are among the most commonly used formats for text files, so we'll take
    an extensive look at the Python tools available to process these files. A common
    task for GIS programmers is to read comma-delimited text files containing *x*
    and *y* coordinates, along with other attribute information. This information
    is then converted into GIS data formats, such as shapefiles or geodatabases.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Python进行文件处理是GIS程序员非常重要的一个主题。文本文件已被用作系统间数据交换的互交换格式。它们简单、跨平台且易于处理。逗号和制表符分隔的文本文件是文本文件中最常用的格式之一，因此我们将详细探讨可用于处理这些文件的Python工具。GIS程序员的一个常见任务是读取包含*x*和*y*坐标以及其他属性信息的逗号分隔的文本文件。然后，这些信息被转换为GIS数据格式，如shapefile或地理数据库。
- en: Getting ready
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To use Python's built-in file processing functionality, you must first open
    the file. Once open, data within the file is processed using functions provided
    by Python, and finally, the file is closed.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Python内置的文件处理功能，您必须首先打开文件。一旦打开，文件内的数据将使用Python提供的函数进行处理，最后关闭文件。
- en: Tip
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Always remember to close the file when you're done. Python does not necessarily
    close the files for you, so it is possible that you could run out of resources
    or overwrite something. Also, some operating system platforms won't let the same
    file be simultaneously open for read-only and writing purposes.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 总是记得在完成时关闭文件。Python并不一定为您关闭文件，因此您可能会耗尽资源或覆盖某些内容。此外，某些操作系统平台不允许同时以只读和写入方式打开同一文件。
- en: In this recipe, you will learn how to open, read, and process a comma-delimited
    text file.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，您将学习如何打开、读取和处理逗号分隔的文本文件。
- en: How to do it…
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Follow these steps to create a Python script that reads a comma-delimited text
    file:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建一个读取逗号分隔的文本文件的Python脚本：
- en: 'In your `C:\ArcpyBook\data` folder, you will find a file called `N_America.A2007275.txt`.
    Open this file in a text editor. It should appear as follows:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的`C:\ArcpyBook\data`文件夹中，您将找到一个名为`N_America.A2007275.txt`的文件。在文本编辑器中打开此文件。它应该如下所示：
- en: '[PRE11]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note
  id: totrans-162
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This file contains data related to wildfire incidents that was derived from
    a satellite sensor from a single day in 2007\. Each row contains latitude and
    longitude information for the fire along with additional information, including
    the date and time, satellite type, confidence value, and other details. In this
    recipe, you are going to pull out only the latitude, longitude, and confidence
    value. The first item contains the latitude, the second contains longitude, and
    the final value contains the confidence value.
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此文件包含与2007年某一天卫星传感器收集的野火事件相关的数据。每一行包含火灾的纬度和经度信息，以及额外的信息，包括日期和时间、卫星类型、置信值和其他细节。在这个菜谱中，您将只提取纬度、经度和置信值。第一个条目包含纬度，第二个条目包含经度，最后一个值包含置信值。
- en: Open **IDLE** and create a file called `C:\ArcpyBook\Appendix2\ReadDelimitedTextFile.py`.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**IDLE**并创建一个名为`C:\ArcpyBook\Appendix2\ReadDelimitedTextFile.py`的文件。
- en: 'Use the Python `open()` function to open the file in order to read it:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Python的`open()`函数打开文件以读取它：
- en: '[PRE12]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Add a `for` loop to iterate all the rows:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`for`循环来迭代所有行：
- en: '[PRE13]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Use the `split()` function to split the values into a list, using a comma as
    the delimiter. The list will be assigned to a variable called `lstValues`. Make
    sure that you indent this line of code inside the for loop you just created:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`split()`函数将值拆分为一个列表，使用逗号作为分隔符。这个列表将被分配给一个名为`lstValues`的变量。确保将此行代码缩进到您刚刚创建的for循环中：
- en: '[PRE14]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Using the index values that reference latitude, longitude, and confidence values,
    create new variables:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用引用纬度、经度和置信值的索引值，创建新的变量：
- en: '[PRE15]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Print the values of each with the `print` statement:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`print`语句打印每个变量的值：
- en: '[PRE16]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Close the file:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭文件：
- en: '[PRE17]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The entire script should appear as follows:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 整个脚本应如下所示：
- en: '[PRE18]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You can check your work by examining the `C:\ArcpyBook\code\Appendix2`\`ReadDelimitedTextFile.py`
    solution file.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以通过检查`C:\ArcpyBook\code\Appendix2`\`ReadDelimitedTextFile.py`解决方案文件来验证您的操作。
- en: 'Save and run the script. You should see the following output:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并运行脚本。您应该看到以下输出：
- en: '[PRE19]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: How it works…
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Python's `open()` function creates a file object, which serves as a link to
    a file residing on your computer. You must call the `open()` function on a file
    before reading or writing data in a file. The first parameter for the `open()`
    function is a path to the file you'd like to open. The second parameter of the
    `open()` function corresponds to a mode, which is typically read (`r`), write
    (`w`), or append (`a`). A value of `r` indicates that you'd like to open the file
    for read-only operations, while a value of `w` indicates that you'd like to open
    the file for write operations. If the file you open in write mode already exists,
    it will overwrite any existing data in the file, so be careful when using this
    mode. Append (`a`) mode will open a file for write operations, but instead of
    overwriting any existing data, it will append data to the end of the file. So,
    in this recipe, we have opened the `N_America.A2007275.txt` file in read-only
    mode.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: Python的`open()`函数创建一个文件对象，该对象作为您计算机上文件的链接。在读取或写入文件数据之前，您必须在文件上调用`open()`函数。`open()`函数的第一个参数是要打开的文件的路径。`open()`函数的第二个参数对应于一个模式，通常是读取（`r`）、写入（`w`）或追加（`a`）。`r`的值表示您希望以只读方式打开文件，而`w`的值表示您希望以写入方式打开文件。如果您以写入模式打开的文件已存在，它将覆盖文件中的任何现有数据，因此在使用此模式时要小心。追加（`a`）模式将以写入方式打开文件，但不会覆盖任何现有数据，而是将数据追加到文件末尾。因此，在这个菜谱中，我们以只读模式打开了`N_America.A2007275.txt`文件。
- en: 'Inside the `for` loop, which is used to loop through each of the values in
    the text file one line at a time, the `split()` function is used to create a list
    object from a line of text that is delimited in some way. Our file is comma-delimited,
    so we can use `split(",")`. You can also split based on other delimiters, such
    as tabs, spaces, or any other delimiter. This new list object created by `split()`
    is stored in a variable called `lstValues`. This variable contains each of the
    wildfire values. This is illustrated in the following screenshot. You''ll notice
    that latitude is located in the first position, longitude is located in the second
    position, and so on. Lists are zero-based:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在`for`循环内部，该循环用于逐行遍历文本文件中的每个值，使用`split()`函数将一行文本（以某种方式分隔）创建为一个列表对象。我们的文件是以逗号分隔的，因此我们可以使用`split(",")`。您也可以根据其他分隔符进行分割，例如制表符、空格或任何其他分隔符。由`split()`创建的这个新列表对象存储在一个名为`lstValues`的变量中。这个变量包含每个野火值。这在下图中得到了说明。您会注意到纬度位于第一个位置，经度位于第二个位置，依此类推。列表是从零开始的：
- en: '![How it works…](img/B04314_A2_1.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作…](img/B04314_A2_1.jpg)'
- en: Using the index values (which references latitude, longitude, and confidence
    values), we create new variables called `latitude`, `longitude`, and `confid`.
    Finally, we print each of the values. A more robust geoprocessing script might
    write this information into a feature class using an `InsertCursor` object. We
    actually did this in a previous recipe in [Chapter 8](ch08.html "Chapter 8. Using
    the ArcPy Data Access Module with Feature Classes and Tables"), *Using the ArcPy
    Data Access Module with Feature Classes and Tables*.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 使用索引值（这些值引用纬度、经度和置信度值），我们创建了新的变量`latitude`、`longitude`和`confid`。最后，我们打印出每个值。一个更健壮的地理处理脚本可能会使用`InsertCursor`对象将此信息写入要素类。我们实际上在[第8章](ch08.html
    "第8章。使用ArcPy数据访问模块与要素类和表")的先前的配方中做了这件事，*使用ArcPy数据访问模块与要素类和表*。
- en: It would be possible to use the `readlines()` function to read the entire contents
    of the file into a Python list, which could then be iterated. Each row in the
    text file will be a unique value in the list. Since this function reads the entire
    file into a list, you need to use this method with caution, as large files can
    cause significant performance problems.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`readlines()`函数将整个文件内容读入Python列表中是可能的，然后可以遍历。文本文件中的每一行都将成为列表中的一个唯一值。由于这个函数将整个文件读入列表中，因此在使用此方法时需要谨慎，因为大文件可能会引起显著的性能问题。
- en: There's more...
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Similar to instances of reading files, there are a number of methods that you
    can use to write data to a file. The `write()` function is probably the easiest
    to use. It takes a single string argument and writes it to a file. The `writelines()`
    function can be used to write the contents of a list structure to a file. Before
    writing data to a text file, you will need to open the file in either a write
    or append mode.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 与读取文件实例类似，有几种方法可以将数据写入文件。`write()`函数可能是最容易使用的。它接受一个字符串参数并将其写入文件。`writelines()`函数可以用来将列表结构的内容写入文件。在将数据写入文本文件之前，您需要以写入或追加模式打开文件。
- en: Sending e-mails
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发送电子邮件
- en: There will be occasions when you may need to send an e-mail from a Python script.
    An example of this might be an alert for the successful completion or errors incurred
    in a long-running geoprocessing operation. On these and other occasions, sending
    an e-mail can be helpful.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，您可能需要从Python脚本中发送电子邮件。这可能是一个长时间运行的地理处理操作成功完成或发生错误的警报的例子。在这些和其他情况下，发送电子邮件可能会有所帮助。
- en: Getting ready
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Sending an e-mail through a Python script will require you to have access to
    a mail server. This can be a public e-mail service, such as Yahoo, Gmail, or others.
    It can also use outgoing mail servers that is configured with applications, such
    as Microsoft Outlook. In either case, you'll need to know the host name and port
    of the e-mail server. The Python `smtplib` module is used to create connections
    to the mail server and to send e-mails.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 通过Python脚本发送电子邮件需要您有权访问邮件服务器。这可能是一个公共电子邮件服务，如Yahoo、Gmail或其他服务。它也可以使用配置了应用程序的出站邮件服务器，例如Microsoft
    Outlook。在任一情况下，您都需要知道电子邮件服务器的主机名和端口号。Python的`smtplib`模块用于创建到邮件服务器的连接并发送电子邮件。
- en: The Python `email` module contains a `Message` class that represents e-mail
    messages. Each message contains both headers and a body. This class can't be used
    to send e-mails, it just handles its object representation. In this recipe, you'll
    learn how to use the `smtp` class to send e-mails containing an attachment through
    your script. The `Message` class can parse a stream of characters or a file containing
    an e-mail by using either the `message_from_file()` or `message_from_string()`
    functions. Both will create a new `Message` object. The body of the mail can be
    obtained by calling `Message.getpayload()`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Python的`email`模块包含一个`Message`类，它表示电子邮件消息。每个消息都包含标题和正文。这个类不能用来发送电子邮件，它只是处理其对象表示。在本食谱中，你将学习如何使用`smtp`类通过你的脚本发送包含附件的电子邮件。`Message`类可以使用`message_from_file()`或`message_from_string()`函数解析字符流或包含电子邮件的文件。两者都将创建一个新的`Message`对象。可以通过调用`Message.getpayload()`来获取邮件的正文。
- en: Note
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We are using the Google Mail service for this exercise. If you already have
    a Gmail account, then simply provide your username and password as the values
    for these variables. If you don't have a Gmail account, you'll need to create
    one or use a different mail service to complete this exercise. Gmail accounts
    are free. Google may block attempts to send an e-mail through scripts, so be aware
    that this may not work as expected if you're using Gmail.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个练习中使用Google Mail服务。如果你已经有了Gmail账户，那么只需简单地提供你的用户名和密码作为这些变量的值。如果你没有Gmail账户，你需要创建一个或使用不同的邮件服务来完成这个练习。Gmail账户是免费的。Google可能会阻止通过脚本发送电子邮件的尝试，所以如果你使用Gmail，请注意这可能不会按预期工作。
- en: How to do it…
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Follow these steps to create a script that can send e-mails:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建一个可以发送电子邮件的脚本：
- en: Open **IDLE** and create a file called `C:\ArcpyBook\Appendix2\SendEmail.py`.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**IDLE**并创建一个名为`C:\ArcpyBook\Appendix2\SendEmail.py`的文件。
- en: 'In order to send e-mails with attachments, you''re going to need to import
    the `smtplib` module along with the `os` module, and several classes from the
    e-mail module. Add the following import statements to your script:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了发送带有附件的电子邮件，你需要导入`smtplib`模块以及`os`模块，以及电子邮件模块中的几个类。将以下导入语句添加到你的脚本中：
- en: '[PRE20]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Create the following variables and assign your Gmail username and password
    as the values. Keep in mind that this method of e-mailing from your Python script
    can invite problems, as it requires that you include your username and password:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建以下变量，并将你的Gmail用户名和密码作为值分配。请记住，从你的Python脚本中发送电子邮件可能会引起问题，因为它需要你包含你的用户名和密码：
- en: '[PRE21]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Tip
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Note that including an e-mail `username` and `password` in a script is not secure
    so you wouldn't want to include these in a production script. There are ways of
    encrypting these values but that is beyond the scope of this recipe.
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，在脚本中包含电子邮件`用户名`和`密码`是不安全的，因此你不会想在生产脚本中包含这些信息。有加密这些值的方法，但这超出了本食谱的范围。
- en: 'Create a new Python function called `mail()`. This function will accept four
    parameters: `to`, `subject`, `text`, and `attach`. Each of these parameters should
    be self-explanatory. Create a new `MIMEMultipart` object and assign the `from`,
    `to`, and `subject` keys. You can also attach the text of the e-mail to this new
    `msg` object using `MIMEMultipart.attach()`:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的Python函数`mail()`。这个函数将接受四个参数：`to`、`subject`、`text`和`attach`。每个参数都应该很容易理解。创建一个新的`MIMEMultipart`对象，并分配`from`、`to`和`subject`键。你也可以使用`MIMEMultipart.attach()`将电子邮件文本附加到这个新的`msg`对象上：
- en: '[PRE22]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Attach the file to the e-mail:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文件附加到电子邮件中：
- en: '[PRE23]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Create a new SMTP object that references the Google Mail service, passes in
    the username and password to connect to the mail services, sends the e-mail, and
    closes the connection:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的SMTP对象，该对象引用Google Mail服务，传入用户名和密码以连接到邮件服务，发送电子邮件，并关闭连接：
- en: '[PRE24]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Call the `mail()` function, passing in the recipient of the e-mail, a subject
    for the e-mail, the text of the e-mail, and the attachment:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`mail()`函数，传入电子邮件的收件人、电子邮件的主题、电子邮件文本和附件：
- en: '[PRE25]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The entire script should appear as follows:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 整个脚本应该如下所示：
- en: '[PRE26]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You can check your work by examining the `C:\ArcpyBook\code\Appendix2`\`SendEmail`.py
    solution file.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以通过检查`C:\ArcpyBook\code\Appendix2`\`SendEmail`.py解决方案文件来检查你的工作。
- en: Save and run the script. For testing, I used my personal Yahoo account as the
    recipient. You'll notice that my inbox has a new message from my Gmail account;
    also, notice the attachment:![How to do it…](img/B04314_A2_2.jpg)
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并运行脚本。为了测试，我使用了我的个人Yahoo账户作为收件人。你会注意到我的收件箱中有一个来自我的Gmail账户的新消息；同时，注意附件：![如何做到这一点…](img/B04314_A2_2.jpg)
- en: How it works…
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The first parameter passed into the `mail()` function is the e-mail address
    that will receive the e-mail. This can be any valid e-mail address, but you'll
    want to supply a mail account that you can actually check, so that you can make
    sure your script runs correctly. The second parameter is just the subject line
    of the e-mail. The third parameter is the text. The final parameter is the name
    of a file that will be attached to the e-mail. Here, I've simply defined that
    the `bc_pop1996.csv` file should be attached. You can use any file you have access
    to, but you may want to just use this file for testing.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给`mail()`函数的第一个参数是接收电子邮件的电子邮件地址。这可以是任何有效的电子邮件地址，但您可能希望提供一个您实际上可以检查的邮箱账户，以确保您的脚本运行正确。第二个参数是电子邮件的主题行。第三个参数是文本内容。最后一个参数是要附加到电子邮件上的文件的名称。在这里，我简单地定义了应该将`bc_pop1996.csv`文件附加到电子邮件中。您可以使用您有权访问的任何文件，但您可能只想使用这个文件进行测试。
- en: We then create a new `MIMEMultipart` object inside the `mail()` function, and
    assign the `from`, `to`, and `subject` keys. You can also attach the text of the
    e-mail to this new `msg` object using `MIMEMultipart.attach()`. The `bc_pop1996.csv`
    file is then attached to the e-mail using a `MIMEBase` object and attached to
    the e-mail using `msg.attach(part)`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们然后在`mail()`函数内部创建一个新的`MIMEMultipart`对象，并分配`from`、`to`和`subject`键。您还可以使用`MIMEMultipart.attach()`将电子邮件的文本附加到这个新的`msg`对象上。然后，使用`MIMEBase`对象将`bc_pop1996.csv`文件附加到电子邮件上，并通过`msg.attach(part)`将其附加到电子邮件中。
- en: At this point, we've examined how a basic text e-mail can be sent. However,
    we want to send a more complex e-mail message that contains text and an attachment.
    This requires the use of MIME messages, which provide the functionality to handle
    multipart e-mails. MIME messages need boundaries between multiple parts of an
    e-mail along with extra headers to specify the content being sent. The `MIMEBase`
    class is an abstract subclass of `Message` and enables this type of an e-mail
    to be sent. Since it is an abstract class, you can't create actual instances of
    this class. Instead, you use one of the subclasses, such as `MIMEText`. The last
    step of the `mail()` function is to create a new SMTP object that references the
    Google Mail service, passes in the username and password in order to connect to
    the mail services, sends the e-mail, and then closes the connection.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经探讨了如何发送基本的文本电子邮件。然而，我们想要发送一个包含文本和附件的更复杂的电子邮件消息。这需要使用MIME消息，它提供了处理多部分电子邮件的功能。MIME消息需要在电子邮件的多个部分之间设置边界，并添加额外的标题来指定发送的内容。《MIMEBase`类是`Message`的抽象子类，使得发送这种类型的电子邮件成为可能。由于它是一个抽象类，您不能创建这个类的实际实例。相反，您可以使用其子类之一，例如`MIMEText`。`mail()`函数的最后一步是创建一个新的SMTP对象，该对象引用Google
    Mail服务，传入用户名和密码以连接到邮件服务，发送电子邮件，然后关闭连接。
- en: Retrieving files from an FTP server
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从FTP服务器检索文件
- en: Retrieving files from an FTP server for processing is a very common operation
    for GIS programmers and can be automated with a Python script.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 从FTP服务器检索文件进行处理的操作对于GIS程序员来说非常常见，可以使用Python脚本来自动化。
- en: Getting ready
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Connecting to an FTP server and downloading a file is accomplished through the
    `ftplib` module. A connection to an FTP server is created through the FTP object,
    which accepts a host, username, and password to create the connection. Once a
    connection has been opened, you can then search for and download files.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`ftplib`模块连接到FTP服务器并下载文件是完成操作。通过FTP对象创建对FTP服务器的连接，该对象接受主机、用户名和密码来建立连接。一旦建立了连接，您就可以搜索并下载文件。
- en: In this recipe, you will connect to the **National Interagency Fire Center Incident**
    FTP site and download a PDF file for a wildfire in Colorado. Before you run the
    following script, you will need to create a username/password through [http://gis.nwcg.gov/data_nifcftp.html](http://gis.nwcg.gov/data_nifcftp.html).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，您将连接到**国家机构火灾中心事件**FTP站点，并下载一份科罗拉多州野火事件的PDF文件。在运行以下脚本之前，您需要通过[http://gis.nwcg.gov/data_nifcftp.html](http://gis.nwcg.gov/data_nifcftp.html)创建一个用户名/密码。
- en: How to do it…
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps to create a script that connects to an FTP server and downloads
    a file:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建一个连接到FTP服务器并下载文件的脚本：
- en: Open **IDLE** and create a file called `C:\ArcpyBook\Appendix2\ftp.py`.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**IDLE**并创建一个名为`C:\ArcpyBook\Appendix2\ftp.py`的文件。
- en: We'll be connecting to an FTP server at the NIFC. Visit their website at [http://gis.nwcg.gov/data_nifcftp.html](http://gis.nwcg.gov/data_nifcftp.html)
    for more information.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将连接到 NIFC 的 FTP 服务器。有关更多信息，请访问他们的网站 [http://gis.nwcg.gov/data_nifcftp.html](http://gis.nwcg.gov/data_nifcftp.html)。
- en: 'Import the `ftplib`, `os`, and `socket` modules:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入 `ftplib`、`os` 和 `socket` 模块：
- en: '[PRE27]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Add the following variables that define the URL, directory, and filename:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下定义 URL、目录和文件名的变量：
- en: '[PRE28]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Add the following code block to create a connection. If there is a connection
    error, a message will be generated. If the connection was successful, a success
    message will be printed:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码块以创建连接。如果发生连接错误，将生成一条消息。如果连接成功，将打印成功消息：
- en: '[PRE29]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Add the following code block to anonymously log in to the server:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码块以匿名登录到服务器：
- en: '[PRE30]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Add the following code block to change to the directory specified in our `DIRN`
    variable:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码块以切换到我们 `DIRN` 变量中指定的目录：
- en: '[PRE31]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Use the `FTP.retrbinary()` function to retrieve the PDF file:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `FTP.retrbinary()` 函数检索 PDF 文件：
- en: '[PRE32]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Make sure you disconnect from the server:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保您从服务器断开连接：
- en: '[PRE33]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The entire script should appear as follows:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 整个脚本应如下所示：
- en: '[PRE34]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: You can check your work by examining the `C:\ArcpyBook\code\Appendix2`\`ftp`.py
    solution file.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以通过检查 `C:\ArcpyBook\code\Appendix2\ftp`.py 解决方案文件来验证您的操作。
- en: 'Save and run the script. If everything is successful, you should see the following
    output:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并运行脚本。如果一切顺利，您应该看到以下输出：
- en: '[PRE35]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Check your `C:\ArcpyBook\Appendix2` directory for the file. By default, FTP
    will download files to the current working directory.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查您的 `C:\ArcpyBook\Appendix2` 目录中的文件。默认情况下，FTP 将文件下载到当前工作目录。
- en: How it works…
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: To connect to an FTP server, you need to know the URL. You also need to know
    the directory and filename for the file that will be downloaded. In this script,
    we have hardcoded this information, so that you can focus on implementing the
    FTP-specific functionality. Using this information, we then created a connection
    to the NIFC FTP server. This is done through the `ftplib.FTP()` function, which
    accepts a URL to the host.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 要连接到 FTP 服务器，您需要知道 URL。您还需要知道要下载的文件的目录和文件名。在此脚本中，我们硬编码了此信息，以便您可以专注于实现 FTP 特定的功能。使用此信息，我们创建了与
    NIFC FTP 服务器的连接。这是通过 `ftplib.FTP()` 函数完成的，该函数接受主机的 URL。
- en: Keep in mind that you'll need to obtain a username/password to log in and download
    the data. Once logged in, the script then changes directories from the root of
    the FTP server to the path defined in the `DIRN` variable. This was accomplished
    with the `cwd(<path>)` function. The PDF file was retrieved by using the `retrbinary()`
    function. Finally, you will want to close your connection to the FTP server when
    you're done. This is done with the `quit()` method.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，您需要获取用户名/密码以登录并下载数据。登录后，脚本将更改目录，从 FTP 服务器的根目录切换到 `DIRN` 变量中定义的路径。这是通过 `cwd(<path>)`
    函数实现的。PDF 文件是通过使用 `retrbinary()` 函数检索的。最后，完成操作后，您将想要关闭与 FTP 服务器的连接。这可以通过 `quit()`
    方法完成。
- en: There's more…
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容…
- en: There are a number of additional FTP-related methods that you can use to perform
    various actions. Generally, these can be divided into directory-level operations
    and file-level operations. Directory level methods include the `dir()` method
    to obtain a list of files in a directory, `mkd()` to create a new directory, `pwd()`
    to get the current working directory, and `cwd()` to change the current directory.
    Keep in mind that the actions you attempt to perform through your script will
    be governed by the privileges assigned to your account, so you may not be able
    to successfully execute every method that I mention.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多其他与 FTP 相关的方法，您可以使用它们执行各种操作。通常，这些可以分为目录级操作和文件级操作。目录级方法包括 `dir()` 方法以获取目录中的文件列表，`mkd()`
    创建新目录，`pwd()` 获取当前工作目录，以及 `cwd()` 更改当前目录。请记住，您通过脚本尝试执行的操作将由分配给您的账户的权限控制，因此您可能无法成功执行我提到的每个方法。
- en: The `ftplib` module also includes various methods to work with files. You can
    upload and download files in a binary or plain text format. The `retrbinary()`
    and `storbinary()` methods are used to retrieve and store binary files, respectively.
    Plain text files can be retrieved and stored using `retrlines()` and `storlines()`.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`ftplib` 模块还包括各种用于处理文件的方法。您可以使用二进制或纯文本格式上传和下载文件。`retrbinary()` 和 `storbinary()`
    方法分别用于检索和存储二进制文件。纯文本文件可以使用 `retrlines()` 和 `storlines()` 检索和存储。'
- en: There are several others methods on the FTP class that you should be aware of.
    Deleting a file can be done with the `delete()` method, while renaming a file
    can be accomplished with `rename()`. You can also send commands to the FTP server
    through the `sendcmd()` method.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: FTP类有几个其他方法你应该知道。删除文件可以使用`delete()`方法完成，而重命名文件可以使用`rename()`方法完成。你还可以通过`sendcmd()`方法向FTP服务器发送命令。
- en: Creating ZIP files
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建ZIP文件
- en: GIS often requires the use of large files that will be compressed into a `.zip`
    format for ease of sharing. Python includes a module that you can use to decompress
    and compress files in this format.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: GIS通常需要使用大文件，这些文件将被压缩成`.zip`格式以便于分享。Python包含一个模块，你可以使用它来解压缩和压缩这种格式的文件。
- en: Getting ready
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'ZIP is a common compression and archive format and is implemented in Python
    through the `zipfile` module. The `ZipFile` class can be used to create, read,
    and write `.zip` files. To create a new `.zip` file, simply provide the filename
    along with a mode as `w`, which indicates that you want to write data to the file.
    In the following code example, we are creating a `.zip` file called `datafile.zip`.
    The second parameter, `w`, indicates that a new file will be created. A new file
    will be created or an existing file with the same name will be truncated in the
    write mode. An optional compression parameter can also be used when creating the
    file. This value can be set to either `ZIP_STORED` or `ZIP_DEFLATED`:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: ZIP是一种常见的压缩和存档格式，在Python中通过`zipfile`模块实现。`ZipFile`类可用于创建、读取和写入`.zip`文件。要创建一个新的`.zip`文件，只需提供文件名以及模式`w`，这表示你想要向文件写入数据。在以下代码示例中，我们正在创建一个名为`datafile.zip`的`.zip`文件。第二个参数`w`表示将创建一个新文件。在写入模式下，将创建一个新文件或截断具有相同名称的现有文件。在创建文件时还可以使用可选的压缩参数。此值可以设置为`ZIP_STORED`或`ZIP_DEFLATED`：
- en: '[PRE36]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In this exercise, you will use Python to create file, add files, and apply compression
    to a `.zip` file. You'll be archiving all the shapefiles located in the `C:\ArcpyBook\data`
    directory.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将使用Python创建文件，添加文件，并将压缩应用于`.zip`文件。你将存档位于`C:\ArcpyBook\data`目录中的所有shapefiles。
- en: How to do it…
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Follow these steps to learn how to create a script that builds a `.zip` file:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤学习如何创建一个构建`.zip`文件的脚本：
- en: Open **IDLE** and create a script called `C:\ArcpyBook\Appendix2\CreateZipfile.py`.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**IDLE**并创建一个名为`C:\ArcpyBook\Appendix2\CreateZipfile.py`的脚本。
- en: 'Import the `zipfile` and `os` modules:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`zipfile`和`os`模块：
- en: '[PRE37]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Create a new `.zip` file called `shapefiles.zip` in write mode and add a compression
    parameter:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以写入模式创建一个名为`shapefiles.zip`的新`.zip`文件并添加压缩参数：
- en: '[PRE38]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Next, we''ll use the `os.listdir()` function to create a list of files in the
    data directory:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将使用`os.listdir()`函数来创建数据目录中的文件列表：
- en: '[PRE39]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Loop through a list of all the files and write to the `.zip` file if the file
    ends with `shp`, `dbf`, or `shx`:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遍历所有文件的列表，如果文件以`shp`、`dbf`或`shx`结尾，则将其写入`.zip`文件：
- en: '[PRE40]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Print out a list of all the files that were added to the ZIP archive. You can
    use the `ZipFile.namelist()` function to create a list of files in the archive.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印出添加到ZIP存档中的所有文件的列表。你可以使用`ZipFile.namelist()`函数创建存档中的文件列表。
- en: '[PRE41]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Close the `.zip` archive:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭`.zip`存档：
- en: '[PRE42]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The entire script should appear as follows:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 整个脚本应如下所示：
- en: '[PRE43]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: You can check your work by examining the `C:\ArcpyBook\code\Appendix2`\`CreateZipfile_Step1`.py
    solution file.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以通过检查`C:\ArcpyBook\code\Appendix2`\`CreateZipfile_Step1`.py解决方案文件来验证你的工作。
- en: 'Save and run the script. You should see the following output:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并运行脚本。你应该看到以下输出：
- en: '[PRE44]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In Windows Explorer, you should be able to see the output `.zip` file, as shown
    in the following screenshot. Note the size of archive. This file was created without
    compression:![How to do it…](img/B04314_A2_4.jpg)
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Windows资源管理器中，你应该能够看到以下截图所示的输出`.zip`文件。注意存档的大小。此文件未进行压缩：![如何操作…](img/B04314_A2_4.jpg)
- en: 'Now, we''re going to create a compressed version of the `.zip` file to see
    the difference. Make the following changes to the line of code that creates the
    `.zip` file:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将创建`.zip`文件的压缩版本以查看差异。对创建`.zip`文件的代码行进行以下更改：
- en: '[PRE45]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: You can check your work by examining the `C:\ArcpyBook\code\Appendix2`\`CreateZipfile_Step2`.py
    solution file.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以通过检查`C:\ArcpyBook\code\Appendix2`\`CreateZipfile_Step2`.py解决方案文件来验证你的工作。
- en: Save and rerun the script.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并重新运行脚本。
- en: Take a look at the size of the new `shapefiles2.zip` file that you just created.
    Note the decreased size of the file due to compression:![How to do it…](img/B04314_A2_5.jpg)
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 看看您刚刚创建的`shapefiles2.zip`文件的大小。注意由于压缩导致的文件大小减少：![如何操作…](img/B04314_A2_5.jpg)
- en: How it works…
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: In this recipe, you created a new `.zip` file called `shapefiles.zip` in write
    mode. In the first iteration of this script, you didn't compress the contents
    of the file. However, in the second iteration, you did it by using the `DEFLATED`
    parameter that was passed into the constructor for the `ZipFile` object. The script
    then obtained a list of files in the data directory and looped through each of
    the files. Each file that has an extension of `.shp`, `.dbf`, or `.shx` is then
    written to the archive file, using the `write()` function. Finally, the names
    of each of the files written to the archive are printed to the screen.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，您以写入模式创建了一个名为`shapefiles.zip`的新`.zip`文件。在脚本的第一轮迭代中，您没有压缩文件内容。然而，在第二轮迭代中，您通过将`DEFLATED`参数传递给`ZipFile`对象的构造函数来执行压缩。然后脚本获取数据目录中的文件列表，并遍历每个文件。每个具有`.shp`、`.dbf`或`.shx`扩展名的文件随后使用`write()`函数写入归档文件。最后，将写入归档的每个文件的名称打印到屏幕上。
- en: There's more…
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容…
- en: The contents of an existing file stored in a ZIP archive can be read by using
    the `read()` method. The file should first be opened in a read mode, and then
    you can call the `read()` method passing a parameter that represents the filename
    that should be read. The contents of the file can then be printed to the screen,
    written to another file, or stored as a list or dictionary variable.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`read()`方法读取存储在ZIP存档中的现有文件的内容。首先应以读取模式打开文件，然后您可以调用`read()`方法，传递一个参数，表示要读取的文件名。然后可以将文件内容打印到屏幕上，写入另一个文件，或存储为列表或字典变量。
- en: Reading XML files
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 阅读XML文件
- en: XML files were designed as a way to transport and store data. They are platform-independent
    since the data is stored in a plain text file. Although similar to HTML, XML differs
    from HTML since the former is designed for display purposes, whereas XML data
    is designed for data. XML files are sometimes used as an interchange format for
    GIS data that is going between various software systems.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: XML文件被设计为一种传输和存储数据的方式。由于数据存储在纯文本文件中，因此它们是平台无关的。尽管与HTML相似，但XML与HTML不同，因为前者是为显示目的而设计的，而XML数据是为数据设计的。XML文件有时被用作GIS数据在不同软件系统之间交换的格式。
- en: Getting ready
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'XML documents have a tree-like structure that is composed of a `root` element,
    `child` elements, and element attributes. Elements are also called **nodes**.
    All XML files contain a `root` element. This `root` element is the parent to all
    other elements or child nodes. The following code example illustrates the structure
    of an XML document. Unlike HTML files, XML files are case sensitive:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: XML文档具有由`root`元素、`child`元素和元素属性组成的树状结构。元素也被称为**节点**。所有XML文件都包含一个`root`元素。这个`root`元素是所有其他元素或子节点的父元素。以下代码示例说明了XML文档的结构。与HTML文件不同，XML文件是区分大小写的：
- en: '[PRE46]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Tip
  id: totrans-299
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Python provides several programming modules that you can use to process XML
    files. The module that you use should be determined by the module that is right
    for the job. Don't try to force a single module to do everything. Each module
    has specific functions that they are good at performing.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: Python提供了几个编程模块，您可以使用它们来处理XML文件。您应该使用的模块应由适合工作的模块决定。不要试图强迫单个模块做所有事情。每个模块都有它们擅长执行的具体功能。
- en: In this recipe, you will learn how to read data from an XML file using the `nodes`
    and `element` attributes that are a part of the document.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，您将学习如何使用文档中的`nodes`和`element`属性从XML文件中读取数据。
- en: There are a number of ways that you can access nodes within an XML document.
    Perhaps, the easiest way to do so is to find nodes by tag name and then through
    walk the tree containing a list of the child nodes. Before doing so, you'll want
    to parse the XML document with the `minidom.parse()` method. Once parsed, you
    can then use the `childNodes` attribute to obtain a list of all the `child` nodes
    starting at root of the tree. Finally, you can search the nodes by tag names with
    the `getElementsByTagName(tag)` function, which accepts a tag name as an argument.
    This will return a list of all `child` nodes that are associated with the tag.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方法可以访问 XML 文档中的节点。也许，最简单的方法是通过标签名查找节点，然后遍历包含子节点列表的树。在这样做之前，你将想要使用 `minidom.parse()`
    方法解析 XML 文档。一旦解析，你可以使用 `childNodes` 属性来获取从树根开始的所有 `child` 节点的列表。最后，你可以使用接受标签名作为参数的
    `getElementsByTagName(tag)` 函数来搜索节点，这将返回与标签相关联的所有 `child` 节点的列表。
- en: You can also determine if a node contains an attribute by calling `hasAttribute(name)`,
    which will return a `true`/`false` value. Once you've determined that an attribute
    exists, a call to `getAttribute(name)` will obtain the value for the attribute.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过调用 `hasAttribute(name)` 来确定一个节点是否包含属性，这将返回一个 `true`/`false` 值。一旦确定属性存在，调用
    `getAttribute(name)` 将获取属性的值。
- en: In this exercise, you will parse an XML file and pull out values associated
    with a particular element (node) and attribute. We'll load an XML file containing
    wildfire data. In this file, we'll look for the `<fire>` node and the `address`
    attribute for each of these nodes. The addresses will be printed out.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将解析一个 XML 文件，并提取与特定元素（节点）和属性相关的值。我们将加载一个包含野火数据的 XML 文件。在这个文件中，我们将寻找
    `<fire>` 节点和每个这些节点的 `address` 属性。地址将被打印出来。
- en: How to do it…
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Open **IDLE** and create a script called `C:\ArcpyBook\Appendix2\XMLAccessElementAttribute.py`.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 **IDLE** 并创建一个名为 `C:\ArcpyBook\Appendix2\XMLAccessElementAttribute.py` 的脚本。
- en: 'The `WitchFireResidenceDestroyed.xml` file will be used. The file is located
    in your `C:\ArcpyBook\Appendix2` folder. You can see a sample of its contents,
    as follows:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将使用 `WitchFireResidenceDestroyed.xml` 文件。该文件位于你的 `C:\ArcpyBook\Appendix2` 文件夹中。你可以看到其内容的样本，如下所示：
- en: '[PRE47]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Import `minidom` from `xml.dom`:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `xml.dom` 导入 `minidom`：
- en: '[PRE48]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Parse the XML file:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解析 XML 文件：
- en: '[PRE49]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Generate a list of nodes from the XML file:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 XML 文件生成节点列表：
- en: '[PRE50]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Generate a list of all the `<fire>` nodes:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成所有 `<fire>` 节点的列表：
- en: '[PRE51]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Loop through the list of elements, test for the existence of the `address`
    attribute and print the value of the attribute, if it exists:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遍历元素列表，检查 `address` 属性是否存在，如果存在则打印属性值：
- en: '[PRE52]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: You can check your work by examining the `C:\ArcpyBook\code\Appendix2`\`XMLAccessElementAttribute`.py
    solution file.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以通过检查 `C:\ArcpyBook\code\Appendix2` 文件夹下的 `XMLAccessElementAttribute.py` 解决方案文件来验证你的工作。
- en: 'Save and run the script. You should see the following output:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并运行脚本。你应该看到以下输出：
- en: '[PRE53]'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: How it works…
  id: totrans-322
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Loading an XML document into your script is probably the most basic thing you
    can do with XML files. You can use the `xml.dom` module to do this through the
    use of the `minidom` object. The `minidom` object has a method called `parse()`,
    which accepts a path to an XML document and creates a **document object model**
    (**DOM**) tree object from the `WitchFireResidenceDestroyed.xml` file.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 将 XML 文档加载到你的脚本中可能是你可以用 XML 文件做的最基本的事情。你可以使用 `xml.dom` 模块通过 `minidom` 对象来完成这项操作。`minidom`
    对象有一个名为 `parse()` 的方法，它接受一个 XML 文档的路径，并从 `WitchFireResidenceDestroyed.xml` 文件创建一个
    **文档对象模型**（**DOM**）树对象。
- en: The `childNodes` property of the DOM tree generates a list of all the nodes
    in the XML file. You can then access each of the nodes using the `getElementsByTagName()`
    method. The final step is to loop through each of the `<fire>` nodes contained
    within the `eList` variable. For each node, we then check for the `address` attribute
    with the `hasAttribute()` method, and if it exists, we call the `getAttribute()`
    function and print the address to the screen.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: DOM 树的 `childNodes` 属性生成 XML 文件中所有节点的列表。然后你可以使用 `getElementsByTagName()` 方法访问每个节点。最后一步是遍历
    `eList` 变量中包含的所有 `<fire>` 节点。对于每个节点，我们使用 `hasAttribute()` 方法检查 `address` 属性，如果存在，则调用
    `getAttribute()` 函数并将地址打印到屏幕上。
- en: There's more…
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There will be times when you will need to search an XML document for a specific
    text string. This requires the use of the `xml.parsers.expat` module. You'll need
    to define a search class derived from the basic `expat` class and then create
    an object from this class. Once created, you can call the `parse()` method on
    the `search` object to search for data. Finally, you can then search the nodes
    by tag names with the `getElementsByTagName(tag)` function, which accepts a tag
    name as an argument. This will return a list of all child nodes that are associated
    with the tag.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 有时会需要搜索一个 XML 文档以查找特定的文本字符串。这需要使用 `xml.parsers.expat` 模块。您需要定义一个从基本 `expat`
    类派生的搜索类，然后从这个类创建一个对象。一旦创建，您就可以在 `search` 对象上调用 `parse()` 方法来搜索数据。最后，您可以使用 `getElementsByTagName(tag)`
    函数通过标签名称搜索节点，该函数接受一个标签名称作为参数。这将返回与该标签相关联的所有子节点的列表。
