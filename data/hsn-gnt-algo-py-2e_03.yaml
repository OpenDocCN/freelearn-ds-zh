- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Understanding the Key Components of Genetic Algorithms
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解遗传算法的关键组成部分
- en: In this chapter, we will dive deeper into the key components and the implementation
    details of genetic algorithms in preparation for the following chapters, where
    we will use genetic algorithms to create solutions for various types of problems.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入探讨遗传算法的关键组成部分及其实现细节，为接下来的章节做准备，在这些章节中我们将使用遗传算法为各种类型的问题创建解决方案。
- en: First, we will outline the basic flow of a genetic algorithm, and then break
    it down into its different components while demonstrating various implementations
    of selection methods, crossover methods, and mutation methods. Next, we will look
    into real-coded genetic algorithms, which facilitate search in a continuous parameter
    space. This will be followed by an overview of the intriguing topics of elitism,
    niching, and sharing in genetic algorithms. Finally, we will study the art of
    solving problems using genetic algorithms.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将概述遗传算法的基本流程，然后将其拆解为不同的组成部分，并展示选择方法、交叉方法和变异方法的各种实现。接下来，我们将探讨实数编码的遗传算法，这些算法便于在连续参数空间中进行搜索。接下来是对精英主义、物种分化和共享等遗传算法中的有趣话题的概述。最后，我们将学习如何利用遗传算法解决问题。
- en: 'By the end of this chapter, you will be able to do the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够做到以下几点：
- en: Be familiar with the key components of genetic algorithms
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 熟悉遗传算法的关键组成部分
- en: Understand the stages of the genetic algorithm flow
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解遗传算法流程的各个阶段
- en: Understand the genetic operators and become familiar with several of their variants
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解遗传操作符，并熟悉它们的几种变体
- en: Know the various options for stopping conditions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解停止条件的各种选择
- en: Understand what modifications need to be made to the basic genetic algorithm
    when it’s applied to real numbers
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解当遗传算法应用于实数时需要做出哪些修改
- en: Understand the mechanism of elitism
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解精英主义的机制
- en: Understand the concepts and implementation of niching and sharing
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解物种分化和共享的概念与实现
- en: Know the choices you have to make when you’re starting to work on a new problem
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解在开始处理新问题时需要做出的选择
- en: The basic flow of a genetic algorithm
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 遗传算法的基本流程
- en: 'The main stages of the basic genetic algorithm flow are shown in the following
    flowchart:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 基本遗传算法流程的主要阶段如下图所示：
- en: '![Figure 2.1: The basic flow of a genetic algorithm](img/B20851_02_001.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.1：遗传算法的基本流程](img/B20851_02_001.jpg)'
- en: 'Figure 2.1: The basic flow of a genetic algorithm'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1：遗传算法的基本流程
- en: These stages are described in detail in the following sections.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这些阶段将在接下来的部分中详细描述。
- en: Creating the initial population
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建初始种群
- en: The initial population is a set of valid candidate solutions (individuals) that
    are chosen randomly. Since genetic algorithms use a chromosome to represent each
    individual, the initial population is a set of chromosomes. These chromosomes
    should conform to the chromosome format that we chose for the problem at hand
    – for example, binary strings of a certain length.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 初始种群是一组有效的候选解（个体），它们是随机选择的。由于遗传算法使用染色体来表示每个个体，初始种群就是一组染色体。这些染色体应该符合我们为当前问题选择的染色体格式——例如，某个长度的二进制字符串。
- en: Calculating the fitness
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算适应度
- en: The value of the fitness function is calculated for each individual. This is
    done once for the initial population, and then for every new generation after
    applying the genetic operators of selection, crossover, and mutation. As the fitness
    of each individual is independent of the others, this calculation can be done
    concurrently.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 每个个体的适应度函数值都会被计算出来。初始种群会进行一次这样的计算，之后每一代新的个体会在应用选择、交叉和变异的遗传操作符后再进行计算。由于每个个体的适应度与其他个体无关，这一计算可以并行执行。
- en: Since the selection stage that follows the fitness calculation usually considers
    individuals with higher fitness scores to be better solutions, genetic algorithms
    are naturally geared toward finding the maximum value(s) of the fitness function.
    If we have a problem where the minimum value is desired, the fitness calculation
    should inverse the original value – for example, by multiplying it by a value
    of (-1).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 由于适应度计算后进行的选择阶段通常认为具有更高适应度的个体是更好的解，因此遗传算法天然倾向于寻找适应度函数的最大值。如果我们遇到一个要求最小值的问题，那么适应度计算应该将原始值反向处理——例如，将其乘以(-1)。
- en: Applying selection, crossover, and mutation
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用选择、交叉和变异
- en: Applying the genetic operators of selection, crossover, and mutation to the
    population results in the creation of a new generation that is based on better
    individuals than the current ones.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 应用选择、交叉和变异的遗传算子到种群中，能够生成一个新的世代，该世代基于比当前个体更优秀的个体。
- en: The **selection** operator is responsible for selecting individuals from the
    current population in a way that gives an advantage to better individuals. Examples
    of selection operators are given in the *Selection* *methods* section.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选择**算子负责以一种有利于优秀个体的方式，从当前种群中选择个体。选择算子的例子在*选择* *方法*部分中给出。'
- en: The **crossover** (or **recombination**) operator creates offspring from the
    selected individuals. This is usually done by taking two selected individuals
    at a time and interchanging parts of their chromosomes to create two new chromosomes
    representing the offspring. Examples of selection operators are given in the *Crossover*
    *methods* section.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**交叉**（或**重组**）算子通过将选定个体的染色体部分交换，创造出新的后代。通常是每次选择两个个体，并交换它们的部分染色体，生成两个新的染色体，代表后代。选择算子的例子在*交叉*
    *方法*部分中给出。'
- en: The **mutation** operator can randomly introduce a change to one or more of
    the chromosome values (genes) of each newly created individual. The mutation usually
    occurs with a very low probability. Examples of mutation operators are given in
    the *Mutation* *methods* section.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**变异**算子可以随机地对每个新生成个体的一个或多个染色体值（基因）进行变化。变异通常以非常低的概率发生。变异算子的例子在*变异* *方法*部分中给出。'
- en: Checking the stopping conditions
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查停止条件
- en: 'There can be multiple conditions to check against when determining whether
    the process can stop. The two most commonly used stopping conditions are as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在判断过程是否可以停止时，可能会有多个条件需要检查。以下是最常用的两种停止条件：
- en: A maximum number of generations has been reached. This also serves to limit
    the runtime and computing resources that are consumed by the algorithm.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 达到最大代数。这也有助于限制算法消耗的运行时间和计算资源。
- en: There was no noticeable improvement over the last few generations. This can
    be implemented by storing the best fitness value that was achieved at every generation
    and comparing the current best value to the one that was achieved a predefined
    number of generations ago. If the difference is smaller than a certain threshold,
    the algorithm can stop.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在最近几代中没有明显的改进。这可以通过存储每代获得的最佳适应度值，并将当前最佳值与预定义代数之前的最佳值进行比较来实现。如果它们之间的差异小于某个阈值，则算法可以停止。
- en: 'Here are some other possible stopping conditions:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一些可能的停止条件：
- en: The performance of the current best individual meets or exceeds the requirements
    of the specific use case
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前最佳个体的表现已经达到了或超过了特定应用场景的要求
- en: A predetermined amount of time has elapsed since the process began
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自过程开始以来已经经过了预定的时间
- en: A certain cost or budget has been consumed, such as CPU time and/or memory
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已消耗了某些成本或预算，例如 CPU 时间和/或内存
- en: The best solution has taken over a portion of the population that is larger
    than a preset threshold
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最优解已经占据了超过预设阈值的一部分种群
- en: To summarize, the genetic algorithm flow starts with a population of randomly
    generated candidate solutions (individuals), which are evaluated against the fitness
    function. The heart of the flow is a loop where the genetic operators of selection,
    crossover, and mutation are applied successively, followed by re-evaluation of
    the individuals. The loop continues until a stopping condition is encountered,
    upon which the best individual of the existing population is selected as our solution.
    Now, let’s look at selection methods.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，遗传算法的流程从一群随机生成的候选解（个体）开始，这些个体会根据适应度函数进行评估。流程的核心是一个循环，在循环中，遗传算子的选择、交叉和变异会依次应用，然后再对个体进行重新评估。该循环会持续进行，直到遇到停止条件，此时会选择现有种群中最优的个体作为我们的解。现在，让我们来看一下选择方法。
- en: Selection methods
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择方法
- en: Selection is used at the beginning of each cycle of the genetic algorithm flow
    to pick individuals from the current population that will be used as parents for
    the individuals of the next generation. The selection is probability-based, and
    the probability of an individual being picked is tied to its fitness value, in
    a way that it gives an advantage to individuals with higher fitness values.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在遗传算法流程的每个周期开始时使用选择，从当前种群中选择个体作为下一代个体的父母。选择是基于概率的，个体被选中的概率与其适应度值相关联，这样有助于高适应度值的个体获得优势。
- en: The following sections describe some of the commonly used selection methods
    and their characteristics.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的章节描述了一些常用的选择方法及其特点。
- en: Roulette wheel selection
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 轮盘赌选择
- en: In the roulette wheel selection method, also known as **fitness proportionate
    selection** (**FPS**), the probability of selecting an individual is directly
    proportionate to its fitness value. This is comparable to using a roulette wheel
    in a casino and assigning each individual a portion of the wheel proportional
    to its fitness value. When the wheel is turned, the odds of each individual being
    selected are proportional to the size of the portion of the wheel that it occupies.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在轮盘赌选择方法中，也称为**适应度比例选择**（**FPS**），选择个体的概率与其适应度值成正比。这类似于在赌场使用轮盘赌的方式，为每个个体分配一个与其适应度值成比例的轮盘部分。当轮盘转动时，每个个体被选中的概率与其所占轮盘部分的大小成正比。
- en: 'For example, suppose we have a population of six individuals with fitness values,
    as shown in the following table. The relative portion of the roulette wheel dedicated
    to each individual is calculated based on these fitness values:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们有一个六个个体的种群，其适应度值如下表所示。基于这些适应度值计算每个个体所占轮盘的相对部分：
- en: '| **Individual** | **Fitness** | **Relative Portion** |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| **个体** | **适应度** | **相对部分** |'
- en: '| A | 8 | 7% |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| A | 8 | 7% |'
- en: '| B | 12 | 11% |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| B | 12 | 11% |'
- en: '| C | 27 | 24% |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| C | 27 | 24% |'
- en: '| D | 4 | 3% |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| D | 4 | 3% |'
- en: '| E | 45 | 40% |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| E | 45 | 40% |'
- en: '| F | 17 | 15% |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| F | 17 | 15% |'
- en: 'Table 2.1: Fitness value table'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2.1：适应度值表
- en: 'The matching roulette wheel is depicted in the following diagram:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配的轮盘图如下所示：
- en: '![](img/B20851_02_002.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B20851_02_002.jpg)'
- en: 'Figure 2.2: Roulette wheel selection example'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2：轮盘赌选择示例
- en: Each time the wheel is turned, the selection point is used to choose a single
    individual from the entire population. The wheel is then turned again to select
    the next individual until we have enough individuals selected to fill the next
    generation. As a result, the same individual can be picked several times.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 每次转动轮盘时，选择点用于从整个种群中选择一个个体。然后再次转动轮盘以选择下一个个体，直到选出足够的个体填充下一代。因此，同一个个体可以被多次选择。
- en: Stochastic universal sampling
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 随机全局采样
- en: '**Stochastic universal sampling** (**SUS**) is a slightly modified version
    of the roulette wheel selection described previously. The same roulette wheel
    is used, with the same proportions, but instead of using a single selection point
    and turning the roulette wheel again and again until all needed individuals have
    been selected, we turn the wheel only once and use multiple selection points that
    are equally spaced around the wheel. This way, all the individuals are chosen
    at the same time, as depicted in the following diagram:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**随机全局采样**（**SUS**）是前述轮盘赌选择的略微修改版本。仍然使用相同的轮盘赌，具有相同的比例，但不同的是，我们只转动一次轮盘并使用多个等间隔的选择点，以一次性选择所有需要的个体，如下图所示：'
- en: '![](img/B20851_02_003.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B20851_02_003.jpg)'
- en: 'Figure 2.3: SUS example'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.3：SUS 示例
- en: This selection method prevents individuals with particularly high fitness values
    from saturating the next generation by getting chosen over and over again too
    many times. So, it provides weaker individuals with a chance to be chosen, reducing
    the somewhat unfair nature of the original roulette wheel selection method.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 该选择方法防止具有特别高适应度值的个体在过多次选择中主导下一代。因此，它为较弱的个体提供了被选中的机会，减少了原始轮盘赌选择方法的某种不公平性。
- en: Rank-based selection
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于排名的选择
- en: The rank-based selection method is similar to roulette wheel selection, but
    instead of directly using the fitness values to calculate the probabilities for
    selecting each individual, the fitness is used just to sort the individuals. Once
    sorted, each individual is given a rank representing their position, and the roulette
    probabilities are calculated based on these ranks.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 排名选择方法类似于轮盘赌选择，但它并不是直接使用适应度值来计算每个个体的选择概率，而是仅仅使用适应度值对个体进行排序。一旦排序完成，每个个体就会被分配一个表示其位置的排名，轮盘赌的概率则基于这些排名计算。
- en: 'For example, let’s take the same population of six individuals we previously
    used with the same fitness values. To that, we’ll add the rank of each individual.
    As the population size in our example is six, the highest-ranking individual gets
    a rank value of 6, the next one gets a rank value of 5, and so on. The relative
    portion of the roulette wheel dedicated to each individual is now calculated based
    on these rank values instead of using the fitness values:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们使用之前的六个个体的种群，并且他们的适应度值相同。然后，我们会为每个个体添加一个排名。因为在我们的例子中，种群大小为六，所以排名最高的个体获得排名6，第二个获得排名5，依此类推。现在，每个个体在轮盘赌中的相对部分是基于这些排名值计算的，而不是使用适应度值：
- en: '| **Individual** | **Fitness** | **Rank** | **Relative Portion** |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| **个体** | **适应度** | **排名** | **相对部分** |'
- en: '| A | 8 | 2 | 9% |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| A | 8 | 2 | 9% |'
- en: '| B | 12 | 3 | 14% |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| B | 12 | 3 | 14% |'
- en: '| C | 27 | 5 | 24% |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| C | 27 | 5 | 24% |'
- en: '| D | 4 | 1 | 5% |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| D | 4 | 1 | 5% |'
- en: '| E | 45 | 6 | 29% |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| E | 45 | 6 | 29% |'
- en: '| F | 17 | 4 | 19% |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| F | 17 | 4 | 19% |'
- en: 'Table 2.2: Fitness value table based on the relative portion'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 表2.2：基于相对部分的适应度值表
- en: 'The matching roulette wheel is depicted in the following diagram:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配的轮盘赌如以下图所示：
- en: '![](img/B20851_02_004.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B20851_02_004.jpg)'
- en: 'Figure 2.4: Rank-based selection example'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4：基于排名的选择示例
- en: Rank-based selection can be useful when a few individuals have much larger fitness
    values than all the rest. Using rank instead of raw fitness prevents these few
    individuals from taking over the entire population of the next generation as ranking
    eliminates the large differences.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当少数个体的适应度值远大于其他个体时，排名选择是有用的。使用排名代替原始适应度可以防止这些少数个体在下一代中占据主导地位，因为排名消除了大差异。
- en: Another useful case is when all individuals have similar fitness values. Here,
    rank-based selection will spread them apart, giving a clearer advantage to the
    better ones, even if the fitness differences are small.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的情况是当所有个体的适应度值相似时。在这种情况下，排名选择将把它们分开，即使适应度差异很小，也能给更优秀的个体更清晰的优势。
- en: Fitness scaling
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 适应度缩放
- en: 'While rank-based selection replaces each fitness value with the individual’s
    rank, fitness scaling applies a scaling transformation to the raw fitness values
    and replaces them with the transformation’s result. The transformation maps the
    raw fitness values into a desired range, as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 排名选择通过将每个适应度值替换为个体的排名，而适应度缩放则对原始适应度值应用缩放变换，并用变换后的结果替换原始值。该变换将原始适应度值映射到一个期望的范围，如下所示：
- en: '*scaled fitness = a × (raw fitness) + b*'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*缩放后的适应度 = a × (原始适应度) + b*'
- en: Here, *a* and *b* are constants that we can select to achieve the desired range
    of the scaled fitness.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，*a* 和 *b* 是我们可以选择的常数，用来实现所期望的缩放适应度范围。
- en: 'For example, if we use the same values from the previous examples, the range
    of the raw fitness values is between 4 (lowest fitness value, individual D) and
    45 (highest fitness value, individual E). Suppose we want to map the values into
    a new range, between 50 and 100\. We can calculate the values of the *a* and *b*
    constants using the following equations, representing these two individuals:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们使用之前示例中的相同值，原始适应度值的范围是从4（最低适应度值，个体D）到45（最高适应度值，个体E）。假设我们想将这些值映射到一个新的范围，介于50和100之间。我们可以使用以下方程计算*a*和*b*常数，这代表这两个个体：
- en: '*50 = a × 4 + b* (lowest fitness value)'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*50 = a × 4 + b*（最低适应度值）'
- en: '*100 = a × 45 + b* (highest fitness value)'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*100 = a × 45 + b*（最高适应度值）'
- en: 'Solving this simple system of linear equations will yield the following scaling
    parameter values:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 解这个简单的线性方程组将得到以下缩放参数值：
- en: '*a = 1.22, b =* *45.12*'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*a = 1.22, b =* *45.12*'
- en: 'This means that the scaled fitness values can be calculated as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着缩放后的适应度值可以通过以下方式计算：
- en: '*scaled fitness = 1.22 × (raw fitness) +* *45.12*'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '*缩放后的适应度 = 1.22 × (原始适应度) +* *45.12*'
- en: 'After adding a new column to the table containing the scaled fitness values,
    we can see that the range is indeed between 50 and 100, as desired:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在表格中新增一个包含缩放适应度值的列后，我们可以看到适应度值的范围确实在50到100之间，如预期的那样：
- en: '| **Individual** | **Fitness** | **Scaled Fitness** | **Relative Portion**
    |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| **个体** | **适应度** | **缩放后的适应度** | **相对比例** |'
- en: '| A | 8 | 55 | 13% |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| A | 8 | 55 | 13% |'
- en: '| B | 12 | 60 | 15% |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| B | 12 | 60 | 15% |'
- en: '| C | 27 | 78 | 19% |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| C | 27 | 78 | 19% |'
- en: '| D | 4 | 50 | 12% |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| D | 4 | 50 | 12% |'
- en: '| E | 45 | 100 | 25% |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| E | 45 | 100 | 25% |'
- en: '| F | 17 | 66 | 16% |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| F | 17 | 66 | 16% |'
- en: 'The matching roulette wheel is depicted in the following diagram:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配的轮盘在以下图示中展示：
- en: '![](img/B20851_02_005.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B20851_02_005.jpg)'
- en: 'Figure 2.5: Roulette wheel selection example after fitness scaling'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5：适应度缩放后轮盘选择示例
- en: As *Figure 2**.5* illustrates, scaling the fitness values to the new range provided
    a much more moderate partition of the roulette wheel compared to the original
    partition. The best individual (with a scaled fitness value of 100) is now only
    twice more likely to be selected than the worst one (with a scaled fitness value
    of 50), instead of being more than 11 times more likely to be chosen when using
    the raw fitness values.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图2.5*所示，将适应度值缩放到新的范围后，相比原始的分割，轮盘的分割更为温和。最佳个体（缩放适应度值为100）现在仅有原最差个体（缩放适应度值为50）的两倍机会被选择，而不是在使用原始适应度值时有超过11倍的选择概率。
- en: Tournament selection
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 锦标赛选择
- en: In each round of the tournament selection method, two or more individuals are
    randomly picked from the population, and the one with the highest fitness score
    wins and gets selected.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在每轮锦标赛选择方法中，会从种群中随机挑选两个或更多个体，拥有最高适应度分数的个体获胜并被选中。
- en: 'For example, suppose we have the same six individuals and the same fitness
    values we used in the previous examples. The following diagram illustrates randomly
    selecting three of them (A, B, and F), then announcing F as the winner since it
    has the largest fitness value (17) among these three individuals:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们有相同的六个个体，并使用与之前示例中相同的适应度值。以下图示展示了随机选择其中三个个体（A、B 和 F），然后宣布 F 为赢家，因为在这三者中，它的适应度值（17）是最大的：
- en: '![Figure 2.6: Tournament selection example with a tournament size of three](img/B20851_02_006.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图2.6：锦标赛规模为三的锦标赛选择示例](img/B20851_02_006.jpg)'
- en: 'Figure 2.6: Tournament selection example with a tournament size of three'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6：锦标赛规模为三的锦标赛选择示例
- en: The number of individuals participating at each tournament selection round (three
    in our example) is suitably called **tournament size**. The larger the tournament
    size, the higher the chances that the best individuals will participate in the
    tournaments, and the lesser the chances of low-scoring individuals winning a tournament
    and getting selected.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 每轮锦标赛选择中参与的个体数量（在我们的示例中为三人）通常被称为**锦标赛规模**。锦标赛规模越大，最佳个体参与锦标赛的机会越高，低分个体赢得锦标赛并被选中的机会越小。
- en: An interesting aspect of this selection method is that, so long as we can compare
    any two individuals and determine which of them is better, the actual value of
    the fitness function is not needed. Next, we’ll look at crossover methods.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这种选择方法的一个有趣方面是，只要我们能够比较任意两个个体并确定哪个个体更优秀，就不需要实际的适应度函数值。接下来，我们将讨论交叉方法。
- en: Crossover methods
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 交叉方法
- en: The crossover operator, also referred to as recombination, corresponds to the
    crossover that takes place during sexual reproduction in biology and is used to
    combine the genetic information of two individuals, serving as parents, to produce
    (usually two) offspring.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 交叉算子，也称为重组，类似于生物学中性繁殖过程中发生的交叉，用于将两个个体的遗传信息结合起来，作为父母产生（通常是两个）后代。
- en: The crossover operator is typically applied with some (high) probability value.
    Whenever crossover is *not* applied, both parents are directly cloned into the
    next generation.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 交叉算子通常以某个（较高的）概率值应用。每当交叉*不*被应用时，两个父代个体将直接克隆到下一代中。
- en: The following sections describe some of the commonly used crossover methods
    and their typical use cases. However, in certain situations, you may opt to use
    a problem-specific crossover method that will be more suitable for a particular
    case.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分描述了一些常用的交叉方法及其典型应用场景。然而，在某些情况下，你可能会选择使用特定问题的交叉方法，这样会更适合特定的案例。
- en: Single-point crossover
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单点交叉
- en: In the single-point crossover method, a location on the chromosomes of both
    parents is selected randomly. This location is referred to as the **crossover
    point** or **cut point**. Genes to the right of that point are swapped between
    the two parent chromosomes. As a result, we get two offspring, and each of them
    carries some genetic information from both parents.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在单点交叉方法中，随机选择父母染色体上的某个位置，称为**交叉点**或**切割点**。交叉点右侧的基因在两个父母染色体之间交换。因此，我们得到两个后代，每个后代都携带来自两个父母的一些遗传信息。
- en: 'The following diagram demonstrates a single-point crossover operation being
    conducted on a pair of binary chromosomes, with the crossover point located between
    the fifth and sixth genes:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示演示了在一对二进制染色体上进行单点交叉操作，交叉点位于第五和第六基因之间：
- en: '![Figure 2.7: Single-point crossover example](img/B20851_02_007.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图2.7：单点交叉示例](img/B20851_02_007.jpg)'
- en: 'Figure 2.7: Single-point crossover example'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7：单点交叉示例
- en: 'Source: [https://commons.wikimedia.org/wiki/File:Computational.science.Genetic.algorithm.Crossover.One.Point.svg](https://commons.wikimedia.org/wiki/File:Computational.science.Genetic.algorithm.Crossover.One.Point.svg).'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 来源：[https://commons.wikimedia.org/wiki/File:Computational.science.Genetic.algorithm.Crossover.One.Point.svg](https://commons.wikimedia.org/wiki/File:Computational.science.Genetic.algorithm.Crossover.One.Point.svg)。
- en: Image by Yearofthedragon.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图片由Yearofthedragon提供。
- en: In the next section, we will cover extensions of this method, namely two-point
    and k-point crossover.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将介绍这种方法的扩展，即两点交叉和k点交叉。
- en: Two-point and k-point crossover
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 两点交叉和k点交叉
- en: In the two-point crossover method, two crossover points on the chromosomes of
    both parents are selected randomly. The genes residing between these points are
    swapped between the two parent chromosomes.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在两点交叉方法中，随机选择父母染色体上的两个交叉点。在这两个交叉点之间的基因将在两个父母染色体之间交换。
- en: 'The following diagram demonstrates a two-point crossover carried out on a pair
    of binary chromosomes, with the first crossover point located between the third
    and fourth genes, and the other between the seventh and eighth genes:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示演示了在一对二进制染色体上进行两点交叉操作，第一次交叉点位于第三和第四基因之间，第二次交叉点位于第七和第八基因之间：
- en: '![Figure 2.8: Two-point crossover example](img/B20851_02_008.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图2.8：两点交叉示例](img/B20851_02_008.jpg)'
- en: 'Figure 2.8: Two-point crossover example'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.8：两点交叉示例
- en: 'Source: [https://commons.wikimedia.org/wiki/File:Computational.science.Genetic.algorithm.Crossover.Two.Point.svg](https://commons.wikimedia.org/wiki/File:Computational.science.Genetic.algorithm.Crossover.Two.Point.svg).'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 来源：[https://commons.wikimedia.org/wiki/File:Computational.science.Genetic.algorithm.Crossover.Two.Point.svg](https://commons.wikimedia.org/wiki/File:Computational.science.Genetic.algorithm.Crossover.Two.Point.svg)。
- en: Image by Yearofthedragon.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图片由Yearofthedragon提供。
- en: The two-point crossover method can be implemented by carrying out two single-point
    crossovers, each with a different crossover point. A generalization of this method
    is k-point crossover, where *k* represents a positive integer, and *k* crossover
    points are used.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 两点交叉方法可以通过执行两个单点交叉来实现，每次使用不同的交叉点。此方法的推广是k点交叉，其中*k*表示正整数，使用*k*个交叉点。
- en: Uniform crossover
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 均匀交叉
- en: 'In the uniform crossover method, each gene is independently determined by randomly
    choosing one of the parents. When the random distribution is 50%, each parent
    has the same chance of influencing the offspring, as illustrated in the following
    diagram:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在均匀交叉方法中，每个基因通过随机选择一个父母的基因来独立决定。当随机分布为50%时，每个父母对后代的影响机会相同，具体如以下图所示：
- en: '![Figure 2.9: Uniform crossover example](img/B20851_02_009.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图2.9：均匀交叉示例](img/B20851_02_009.jpg)'
- en: 'Figure 2.9: Uniform crossover example'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.9：均匀交叉示例
- en: Note that, in this example, the second offspring was created by complementing
    the choices made for the first offspring. However, both offspring can also be
    created independently of each other.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在这个示例中，第二个后代是通过补充第一个后代的选择而生成的。然而，两个后代也可以彼此独立地创建。
- en: Important note
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: In this example, we used integer-based chromosomes, but it would work similarly
    with binary ones.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们使用了基于整数的染色体，但如果使用二进制染色体也会类似。
- en: Since this method does not exchange entire segments of the chromosome, it has
    greater potential for diversity in the resulting offspring.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这种方法不会交换整个染色体的片段，因此它在产生后代时具有更大的多样性潜力。
- en: Crossover for ordered lists
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有序列表的交叉
- en: In the previous example, we saw the results of a crossover operation on two
    integer-based chromosomes. While each of the parents had every value between 0
    and 9 appear exactly once, each of the resulting offspring had certain values
    appearing more than once (for example, 2 in the top offspring and 1 in the other),
    and other values were missing (such as 4 in the top offspring and 5 in the other).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们看到对两个基于整数的染色体进行交叉操作的结果。虽然每个父代的基因值在0到9之间各自出现一次，但每个后代的基因值中某些出现了多次（例如，顶部的后代中有2，另一个后代中有1），而其他基因值则缺失（例如，顶部的后代缺少4，另一个后代缺少5）。
- en: In some tasks, however, integer-based chromosomes may represent indices of an
    ordered list. For example, suppose we have several cities; we know the distance
    between each, and we need to find the shortest possible route through all of them.
    This is known as the traveling salesman problem and will be covered in detail
    in one of the following chapters.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在某些任务中，基于整数的染色体可能表示有序列表的索引。例如，假设我们有几个城市，我们知道每两个城市之间的距离，需要找出穿越所有城市的最短路径。这就是旅行商问题，在接下来的章节中将详细讲解。
- en: If, for instance, we have four cities, a convenient way to represent a possible
    solution for this problem would be a four-integer chromosome showing the order
    of visiting the cities – for example, (1,2,3,4) or (3,4,2,1). A chromosome with
    two of the same values or missing one of the values, such as (1,2,2,4), will not
    represent a valid solution.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 举例来说，如果我们有四个城市，一个方便的方法是用四个整数表示这个问题的可能解，显示访问这些城市的顺序——例如，（1,2,3,4）或（3,4,2,1）。如果一个染色体中有两个相同的值或缺失其中一个值，比如（1,2,2,4），则不能表示一个有效的解。
- en: For such cases, alternative crossover methods were devised to ensure that the
    offspring that were created would still be valid. One of these methods, **ordered
    crossover** (**OX1**) will be covered in the following section.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这种情况，设计了替代的交叉方法，以确保产生的后代仍然有效。其中一种方法，**有序交叉**（**OX1**），将在接下来的章节中进行介绍。
- en: OX1
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: OX1
- en: The OX1 method strives to preserve the relative ordering of the parent’s genes
    as much as possible. We will demonstrate it by using chromosomes with a length
    of six.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: OX1 方法力图尽可能保持父代基因的相对顺序。我们将通过使用长度为六的染色体来展示这一方法。
- en: In this example, we used integer-based chromosomes, but it would work similarly
    with binary ones.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了基于整数的染色体，但对于二进制染色体，操作也类似。
- en: 'The first step is a two-point crossover with random cut points, as shown in
    the following diagram (with the parents depicted on the left-hand side):'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是进行一个带有随机切点的两点交叉，如下图所示（父代基因在左侧表示）：
- en: '![Figure 2.10: OX1 example – step 1](img/B20851_02_010.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.10：OX1 示例 – 第 1 步](img/B20851_02_010.jpg)'
- en: 'Figure 2.10: OX1 example – step 1'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.10：OX1 示例 – 第 1 步
- en: 'We will now start filling in the rest of the genes in each offspring by going
    over all the parent’s genes in their original order, starting after the second
    cut point. For the first parent, we find a *6*, but this is already present in
    the offspring, so we continue (with wrapping around) to *1*; this is already present
    too. The next in order is the *2*. Since *2* is not yet present in the offspring,
    we add it there, as shown in the following figure. For the second parent-offspring
    pair, we start with the parent’s *5*, which is already present in the offspring,
    then move on to *4*, which is present as well, and end up with *2*, which is not
    present yet and therefore gets added. This is shown in the following diagram as
    well:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将开始按照原始顺序遍历每个父代基因，从第二个切点后开始填充每个后代的基因。对于第一个父代，我们发现了一个*6*，但这个基因已经存在于后代中，因此继续（循环回绕）到*1*；这个基因也已经存在。接下来是*2*，由于*2*还没有出现在后代中，我们将它添加进去，如下图所示。对于第二个父代-后代配对，我们从父代的*5*开始，这个基因已经存在于后代中，然后移动到*4*，这个基因也存在，最后是*2*，它还没有出现，因此被添加到后代中。这一点在下图中也有展示：
- en: '![Figure 2.11: OX1 example – step 2](img/B20851_02_011.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.11：OX1 示例 – 第 2 步](img/B20851_02_011.jpg)'
- en: 'Figure 2.11: OX1 example – step 2'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.11：OX1 示例 – 第 2 步
- en: 'For the top parent, we now continue to *3* (already present in the offspring),
    and then *4*, which gets added to the offspring. For the other parent, the next
    gene is *6*. Since it’s not present in the matching offspring, it gets added to
    it. The results are illustrated in the following diagram:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 对于上面的父代，我们接着处理*3*（已在后代中），然后是*4*，这个基因被添加到后代中。对于另一个父代，下一个基因是*6*。由于它在匹配的后代中尚不存在，因此被添加到后代中。结果如下面的图所示：
- en: '![Figure 2.12: OX1 example – step 3](img/B20851_02_012.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.12: OX1 示例 – 步骤 3](img/B20851_02_012.jpg)'
- en: 'Figure 2.12: OX1 example – step 3'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '图 2.12: OX1 示例 – 步骤 3'
- en: 'We continue similarly with the next genes not yet present in the offspring
    and fill in the last available spots, as depicted in the following diagram:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续类似地处理下一些尚未出现在后代中的基因，并填补最后可用的位置，如下图所示：
- en: '![Figure 2.13: OX1 example – step 4](img/B20851_02_013.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.13: OX1 示例 – 步骤 4](img/B20851_02_013.jpg)'
- en: 'Figure 2.13: OX1 example – step 4'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '图 2.13: OX1 示例 – 步骤 4'
- en: 'This completes the process of producing two valid offspring chromosomes, as
    the following diagram demonstrates:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如下图所示，这完成了生成两个有效后代染色体的过程：
- en: '![Figure 2.14: OX1 example – step 5](img/B20851_02_014.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.14: OX1 示例 – 步骤 5](img/B20851_02_014.jpg)'
- en: 'Figure 2.14: OX1 example – step 5'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '图 2.14: OX1 示例 – 步骤 5'
- en: There are numerous other methods to implement crossover, some of which we will
    encounter later in this book. However, thanks to the versatility of genetic algorithms,
    you can always come up with your own methods. In the next section, we’ll consider
    mutation methods.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 实现交叉操作的方法有很多种，其中一些将在本书后面讨论。然而，得益于遗传算法的多样性，你总是可以提出自己的方法。在下一节，我们将讨论突变方法。
- en: Mutation methods
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 突变方法
- en: Mutation is the last genetic operator to be applied in the process of creating
    a new generation. The mutation operator is applied to the offspring that were
    created as a result of the selection and crossover operations.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 突变是创造新一代过程中应用的最后一个遗传算子。突变算子应用于通过选择和交叉操作产生的后代。
- en: The mutation operator is probability-based and usually occurs at a (very) low
    probability as it carries the risk of harming the performance of any individual
    it is applied to. In some versions of genetic algorithms, the mutation probability
    gradually increases as the generations advance to prevent stagnation and ensure
    the diversity of the population. On the other hand, if the mutation rate is increased
    excessively, the genetic algorithm will turn into the equivalent of a random search.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 突变算子是基于概率的，通常以（非常）低的概率发生，因为它有可能损害应用于任何个体的表现。在某些版本的遗传算法中，突变概率会随着代数的推进逐渐增加，以防止停滞并确保种群的多样性。另一方面，如果突变率过高，遗传算法将变成相当于随机搜索的算法。
- en: The following sections describe some of the commonly used mutation methods and
    their typical use cases. However, remember that you can always choose to use your
    own problem-specific mutation method that you deem more suitable for your particular
    use case.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 以下几节将介绍一些常用的突变方法及其典型应用场景。不过，记住你始终可以选择使用自己认为更适合特定用例的、针对问题的突变方法。
- en: Flip-bit mutation
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 翻转位突变
- en: 'When applying flip-bit mutation to a binary chromosome, one gene is randomly
    selected and its value is flipped (complemented), as shown in the following diagram:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在对二进制染色体应用翻转位突变时，随机选择一个基因并翻转（取反）它的值，如下图所示：
- en: '![Figure 2.15: Flip-bit mutation example](img/B20851_02_015.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.15: 翻转位突变示例](img/B20851_02_015.jpg)'
- en: 'Figure 2.15: Flip-bit mutation example'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '图 2.15: 翻转位突变示例'
- en: This can be extended to several random genes being flipped instead of just one.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以扩展为多个随机基因的翻转，而不仅仅是一个。
- en: Swap mutation
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 交换突变
- en: 'When applying the swap mutation to binary or integer-based chromosomes, two
    genes are randomly selected and their values are swapped, as shown in the following
    diagram:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在对二进制或基于整数的染色体应用交换突变时，随机选择两个基因并交换它们的值，如下图所示：
- en: '![Figure 2.16: Swap mutation example](img/B20851_02_016.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.16: 交换突变示例](img/B20851_02_016.jpg)'
- en: 'Figure 2.16: Swap mutation example'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '图 2.16: 交换突变示例'
- en: This mutation operation is suitable for the chromosomes of ordered lists as
    the new chromosome still carries the same genes as the original one.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这种突变操作适用于有序列表的染色体，因为新染色体仍然携带与原染色体相同的基因。
- en: Inversion mutation
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 反转突变
- en: 'When applying the inversion mutation to binary or integer-based chromosomes,
    a random sequence of genes is selected and the order of the genes in that sequence
    is reversed, as depicted in the following diagram:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在对二进制或基于整数的染色体应用反转突变时，随机选择一组基因并反转该序列中的基因顺序，如下图所示：
- en: '![Figure 2.17: Inversion mutation example](img/B20851_02_017.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.17: 反转突变示例](img/B20851_02_017.jpg)'
- en: 'Figure 2.17: Inversion mutation example'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '图 2.17: 反转突变示例'
- en: Similar to the swap mutation, the inversion mutation operation is suitable for
    the chromosomes of ordered lists.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 与交换变异类似，反转变异操作适用于有序列表的染色体。
- en: Scramble mutation
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 交换变异
- en: 'Another mutation operator that’s suitable for the chromosomes of ordered lists
    is the scramble mutation. When applied, a random sequence of genes is selected
    and the order of the genes in that sequence is shuffled (or scrambled), as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种适用于有序列表染色体的变异操作是交换变异。当应用时，会随机选择一段基因序列，并打乱该序列中基因的顺序（或交换），如下所示：
- en: '![Figure 2.18: Scramble mutation example](img/B20851_02_018.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.18：交换变异示例](img/B20851_02_018.jpg)'
- en: 'Figure 2.18: Scramble mutation example'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.18：交换变异示例
- en: In the next section, we will cover some other types of specialized operators
    that have been created for real-coded genetic algorithms.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论一些为实数编码遗传算法创建的其他专门操作符。
- en: Real-coded genetic algorithms
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实数编码遗传算法
- en: So far, we have seen chromosomes that represent binary or integer parameters.
    Consequently, the genetic operators were suitable for working on these types of
    chromosomes. However, we often encounter problems where the solution space is
    continuous. In other words, the individuals are made up of real (floating-point)
    numbers.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到表示二进制或整数参数的染色体。因此，遗传操作符适合用于这些类型的染色体。然而，我们经常遇到解空间是连续的问题。换句话说，个体由实数（浮动点数）构成。
- en: Historically, genetic algorithms used binary strings to represent integers as
    well as real numbers; however, this was not ideal. The precision of a real number
    represented using a binary string is limited by the length of the string (number
    of bits). Since we need to determine this length in advance, we may end up with
    binary strings that are too short, resulting in insufficient precision, or are
    overly long.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 历史上，遗传算法使用二进制字符串表示整数和实数；然而，这并不理想。使用二进制字符串表示实数的精度受到字符串长度（位数）的限制。由于我们需要预先确定这个长度，可能会出现二进制字符串过短，导致精度不足，或者过长的情况。
- en: Moreover, when a binary string is used to represent a number, the significance
    of each bit varies by its location – the most significant bit being on the left.
    This can cause imbalance related to schemas – the patterns occurring in the chromosomes.
    For example, the schema 1**** (representing all five-digit binary strings starting
    with 1) and the schema ****1 (representing all five-digit binary strings ending
    with 1) both have an order of 1 and a defining length of 0; however, the first
    one carries much more significance than the other.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当使用二进制字符串表示数字时，每个位的意义因其位置而异——最重要的位在最左边。这可能导致与模式相关的失衡——即在染色体中出现的模式。例如，模式1****（表示所有以1开头的五位二进制字符串）和模式****1（表示所有以1结尾的五位二进制字符串）都有一个顺序1和定义长度0；然而，第一个模式比第二个模式更具意义。
- en: Instead of using binary strings, arrays of real-valued numbers were found to
    be a simpler and better approach. For example, if we have a problem involving
    three real-valued parameters, the chromosome will look like *[x1, x2, x3]*, where
    *x1*, *x2*, and *x3* represent real numbers, such as [1.23, 7.2134, -25.309] or
    [-30.10, 100.2, 42.424].
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 替代使用二进制字符串，实值数字的数组被发现是更简单且更好的方法。例如，如果我们有一个涉及三个实值参数的问题，染色体看起来像 *[x1, x2, x3]*，其中
    *x1*、*x2* 和 *x3* 表示实数，如[1.23, 7.2134, -25.309] 或 [-30.10, 100.2, 42.424]。
- en: The various selection methods mentioned earlier in this chapter will work just
    the same for real-coded chromosomes as they only depend on the fitness of the
    individuals and not their representation.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 本章前面提到的各种选择方法对于实数编码的染色体同样适用，因为它们只依赖个体的适应度，而与表示方式无关。
- en: 'However, the crossover and mutation methods we’ve covered so far will not be
    suitable for the real-coded chromosomes, so specialized ones need to be used.
    One important point to remember is that these crossover and mutation operations
    are applied separately for each dimension of the array that forms the real-coded
    chromosome. For example, if [1.23, 7.213, -25.39] and [-30.10, 100.2, 42.42] are
    parents that have been selected for the crossover operation, the crossover will
    be done separately for the following pairs:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，至今为止我们所讨论的交叉和变异方法不适合实数编码的染色体，因此需要使用专门的方法。一个重要的要点是，这些交叉和变异操作是分别应用于构成实数编码染色体的每个维度的数组。例如，如果[1.23,
    7.213, -25.39]和[-30.10, 100.2, 42.42]是已选择用于交叉操作的父代，那么交叉操作将分别应用于以下对：
- en: 1.23 and -30.10 (first dimension)
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1.23和-30.10（第一维度）
- en: 7.213 and 100.2 (second dimension)
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 7.213和100.2（第二维度）
- en: -25.39 and 42.42 (third dimension)
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: -25.39和42.42（第三维度）
- en: 'This is illustrated in the following diagram:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这在下图中进行了说明：
- en: '![Figure 2.19: Real-coded chromosomes crossover example](img/B20851_02_019.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![图2.19：实数编码染色体交叉示例](img/B20851_02_019.jpg)'
- en: 'Figure 2.19: Real-coded chromosomes crossover example'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.19：实数编码染色体交叉示例
- en: Similarly, the mutation operator, when applied to a real-coded chromosome, will
    apply separately to each dimension.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，当变异算子应用于实数编码染色体时，它将分别作用于每一维度。
- en: Several of these real-coded crossover and mutation methods will be described
    in the following sections. Later, in [*Chapter 6*](B20851_06.xhtml#_idTextAnchor197),
    *Optimizing Continuous Functions*, we will get to see them in action.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的章节将描述几种实数编码交叉和变异方法。稍后，在 [*第6章*](B20851_06.xhtml#_idTextAnchor197) *优化连续函数*
    中，我们将看到这些方法的实际应用。
- en: Blend crossover
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 混合交叉
- en: 'In the **blend crossover** (**BLX**) method, each offspring is randomly selected
    from the following interval created by its parents:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在**混合交叉**（**BLX**）方法中，每个后代从由父代创建的以下区间中随机选择：
- en: '[paren t 1 − α(paren t 2 − paren t 1), paren t 2 + α(paren t 2 − paren t 1)]'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '[父代1 − α（父代2 − 父代1），父代2 + α（父代2 − 父代1）]'
- en: The parameter, α, is a constant, whose value lies between 0 and 1\. With larger
    values of α, the interval gets wider.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 参数α是一个常数，其值介于0和1之间。随着α值的增大，区间会变得更宽。
- en: 'For example, if the parents’ values are 1.33 and 5.72, the following will be
    the case:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果父代的值分别为1.33和5.72，则情况如下：
- en: An α value of 0 will yield an interval of [1.33, 5.72] (similar to the interval
    between the parents)
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: α值为0时，将生成区间[1.33, 5.72]（类似于父代之间的区间）
- en: An α value of 0.5 will yield an interval of [-0.865, 7.915] (twice as wide as
    the interval between the parents)
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: α值为0.5时，将生成区间[-0.865, 7.915]（是父代之间区间的两倍宽）
- en: An α value of 1.0 will yield an interval of [-3.06, 10.11] (three times wider
    than the interval between the parents)
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: α值为1.0时，将生成区间[-3.06, 10.11]（比父代之间的区间宽三倍）
- en: 'These examples are illustrated in the following diagram, where the parents
    are labeled as *p1* and *p2*, and the crossover interval is colored yellow:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例在下图中进行了说明，父代标记为*p1*和*p2*，交叉区间为黄色：
- en: '![Figure 2.20: Blend crossover example](img/B20851_02_020.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![图2.20：混合交叉示例](img/B20851_02_020.jpg)'
- en: 'Figure 2.20: Blend crossover example'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.20：混合交叉示例
- en: When using this crossover method, the α value is commonly set to 0.5.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此交叉方法时，α值通常设置为0.5。
- en: Simulated binary crossover
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟二进制交叉
- en: The idea behind **simulated binary crossover** (**SBX**) is to imitate the properties
    of the single-point crossover that is commonly used with binary-coded chromosomes.
    One of these properties is that the average of the parents’ values is equal to
    that of the offsprings’ values.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '**模拟二进制交叉**（**SBX**）的思想是模仿常用于二进制编码染色体的单点交叉的特性。其中一个特性是父代值的平均值等于后代值的平均值。'
- en: 'When applying SBX, the two offspring are created from the two parents using
    the following formula:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用SBX时，两个后代是通过以下公式由两个父代生成的：
- en: offsprin g 1 =  1 _ 2 [(1 + β)paren t 1 + (1 − β)paren t 2]
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 后代1 =  1_2 [(1 + β) 父代1 + (1 − β) 父代2]
- en: offsprin g 2 =  1 _ 2 [(1 − β)paren t 1 + (1 + β)paren t 2]
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 后代2 =  1_2 [(1 − β) 父代1 + (1 + β) 父代2]
- en: 'Here, β is a random number referred to as the spread factor. This formula has
    the following notable properties:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，β是一个称为扩展因子的随机数。此公式有以下显著特性：
- en: The average of the two offspring is equal to that of the parents, regardless
    of the value of β
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个后代的平均值等于父代的平均值，无论β值如何
- en: When the β value is 1, the offspring are duplicates of the parents
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当β值为1时，后代与父代相同
- en: When the β value is smaller than 1, the offspring are closer to each other than
    the parents were
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当β值小于1时，后代比父代更接近彼此
- en: When the β value is larger than 1, the offspring are farther apart from each
    other than the parents were
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当β值大于1时，后代比父代之间的距离更远
- en: 'For example, if the parents’ values are 1.33 and 5.72, the following will be
    the case:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果父代的值分别为1.33和5.72，则情况如下：
- en: A β value of 0.8 will yield 1.769 and 5.281 as offspring
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: β值为0.8时，后代将为1.769和5.281
- en: A β value of 1.0 will yield 1.33 and 5.72 as offspring
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: β值为1.0时，后代将为1.33和5.72
- en: A β value of 1.2 will yield 0.891 and 6.159 as offspring
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: β值为1.2时，后代将为0.891和6.159
- en: 'These cases are illustrated in the following diagram, where the parents are
    labeled as *p1* and *p2* and the offspring are labeled as *o1* and *o2*:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这些案例在下图中有所展示，其中父代标记为*p1*和*p2*，后代标记为*o1*和*o2*：
- en: '![      Figure 2.21: Simulated binary crossover example](img/B20851_02_021.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.21：模拟二进制交叉示例](img/B20851_02_021.jpg)'
- en: 'Figure 2.21: Simulated binary crossover example'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.21：模拟二进制交叉示例
- en: In each of the preceding cases, the average value of the two offspring is 3.525,
    which is equal to the average value of the two parents.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在前述的每种情况中，两个后代的平均值为3.525，等于两个父代的平均值。
- en: 'Another property of binary single-point crossover that we would like to preserve
    is the similarity between offspring and parents. This translates to the random
    distribution of the β value. The probability of β should be much higher for values
    around 1, where the offspring are similar to the parents. To achieve that, the
    β value is calculated using another random value, denoted by u, that is uniformly
    distributed over the interval [0, 1]. Once the value of *u* is picked, β is calculated
    as follows:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望保持二进制单点交叉的另一个特性，即后代与父母之间的相似性。这意味着β值的随机分布。β的概率应该在接近1的值附近更高，在这些值下，后代与父母相似。为了实现这一点，β值通过另一个随机值u计算，u在区间[0,
    1]上均匀分布。一旦选定*u*的值，β值的计算公式如下：
- en: 'If *u* ≤ 0.5, we get the following: β = (2u)  1 _ 1−η'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*u* ≤ 0.5，得到以下结果：β = (2u) 1 _ 1−η
- en: 'Otherwise, we get the following: β = [ 1 _ 2(1 − u)]  1 _ 1−η'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，我们得到如下结果：β = [ 1 _ 2(1 − u)] 1 _ 1−η
- en: Real mutation
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实变异
- en: One option for applying mutation in real-coded genetic algorithms is to replace
    any real value with a brand-new one, generated randomly. However, this can result
    in a mutated individual that has no relationship with the original individual.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在实值编码遗传算法中应用变异的一种选择是用一个全新的、随机生成的实值替换任何实值。然而，这可能会导致变异后的个体与原始个体没有任何关系。
- en: 'Another approach is to generate a random real number that resides in the vicinity
    of the original individual. An example of such a method is the **normally distributed**
    (or **Gaussian**) **mutation**: a random number is generated using a normal distribution
    with a mean value of zero and some predetermined standard deviation, as shown
    in the following plot:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是生成一个随机实数，位于原个体的附近。这种方法的一个例子是**正态分布**（或**高斯**）**变异**：使用均值为零、标准差为预定值的正态分布生成一个随机数，如下图所示：
- en: '![Figure 2.21: Gaussian mutation distribution example](img/B20851_02_022.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.21：高斯变异分布示例](img/B20851_02_022.jpg)'
- en: 'Figure 2.21: Gaussian mutation distribution example'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.21：高斯变异分布示例
- en: In the next two sections, we will go over a couple of advanced topics, namely
    **elitism** and **niching**.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的两节中，我们将介绍几个高级话题，即**精英策略**和**生态位分化**。
- en: Understanding elitism
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解精英策略
- en: While the average fitness of the genetic algorithm population generally increases
    as generations go by, it is possible that, at any point, the best individual(s)
    of the current generation will be lost. This is due to the selection, crossover,
    and mutation operators altering the individuals in the process of creating the
    next generation. In many cases, the loss is temporary as these individuals (or
    better individuals) will be re-introduced into the population in a future generation.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管遗传算法种群的平均适应度通常随着代数的增加而提高，但在任何时候，当前代最优秀的个体可能会丢失。这是因为选择、交叉和变异操作会在创建下一代的过程中改变个体。在许多情况下，这种丧失是暂时的，因为这些个体（或更优秀的个体）将在未来的代中重新引入种群。
- en: However, if we want to guarantee that the best individual(s) always make it
    to the next generation, we can apply the optional elitism strategy. This means
    that the top *n* individuals (*n* being a small, predefined parameter) are duplicated
    into the next generation before we fill the rest of the available spots with offspring
    that are created using selection, crossover, and mutation. The elite individuals
    who were duplicated are still eligible for the selection process, so they can
    still be used as the parents of new individuals.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们想确保最优秀的个体始终能够进入下一代，可以采用可选的精英策略。这意味着前* n *个个体（*n*是一个小的预定参数）会在我们通过选择、交叉和变异创造后代之前，复制到下一代。被复制的精英个体仍然有资格参与选择过程，因此它们仍然可以作为新个体的父母。
- en: Elitism can sometimes have a significant positive impact on the algorithm’s
    performance as it avoids the potential time waste needed for re-discovering good
    solutions that were lost in the genetic flow.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 精英主义有时可以对算法的性能产生显著的积极影响，因为它避免了在遗传流中重新发现丢失的优秀解所需的潜在时间浪费。
- en: Another interesting way to enhance the results of genetic algorithms is the
    use of niching, as described in the next section.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 增强遗传算法结果的另一种有趣方法是使用生态位化，下一节将对此进行描述。
- en: Niching and sharing
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生态位化与共享
- en: In nature, all environments are further divided into multiple sub-environments,
    or niches, populated by various species taking advantage of the unique resources
    available in each niche, such as food and shelter. For example, a forest environment
    is comprised of treetops, shrubs, the forest floor, tree roots, and so on; each
    of these accommodates different species that are specialized for living in that
    niche and take advantage of its resources.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在自然界中，所有环境进一步划分为多个子环境或生态位，由各种物种组成，这些物种利用各自生态位中的独特资源，如食物和栖息地。例如，森林环境由树顶、灌木丛、森林地面、树根等组成；这些不同部分分别适应不同物种，这些物种专门适应在各自的生态位中生活，并利用该生态位中的资源。
- en: When several different species coexist in the same niche, they all compete over
    the same resources, and a tendency is created to search for new, unpopulated niches
    and populate them.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 当多个不同物种在同一个生态位中共存时，它们会争夺相同的资源，从而形成一种倾向，即寻找新的、未被占据的生态位并进行填充。
- en: In the realm of genetic algorithms, this niching phenomenon can be used to maintain
    the diversity of the population, as well as to find several optimal solutions,
    each considered a niche.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在遗传算法的领域中，这种生态位化现象可以用于维持种群的多样性，并找到多个最优解，每个最优解被视为一个生态位。
- en: 'For example, suppose our genetic algorithm seeks to maximize a fitness function
    that has several peaks of varying heights, such as the one in the following plot:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们的遗传算法旨在最大化一个具有多个不同高度峰值的适应度函数，如下图所示：
- en: '![Figure 2.22: Expected genetic algorithm results without niching](img/B20851_02_023.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.22：没有生态位化的预期遗传算法结果](img/B20851_02_023.jpg)'
- en: 'Figure 2.22: Expected genetic algorithm results without niching'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.22：没有生态位化的预期遗传算法结果
- en: As the genetic algorithm tends to find the global maximum, we expect, after
    a while, to see most of the population concentrating around the top peak. This
    is indicated in the preceding figure by the locations of the × marks on the function
    graph, representing individuals in the current generation.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 随着遗传算法趋向于找到全局最大值，我们预计，经过一段时间后，种群的大部分个体会集中在最高峰值附近。这一点在前面的图中通过函数图上的 × 标记表示，这些标记代表当前代中的个体。
- en: However, there are implementations where, in addition to the global maximum,
    we would like to find some (or all) of the other peaks. To make this happen, we
    could think of each peak as a niche, offering resources in the amount proportional
    to its height. We then find a way to share (or divide) these resources among the
    individuals occupying them. This will ideally drive the population to be distributed
    accordingly, with the top peak attracting the most individuals as it offers the
    most reward, and the other peaks populated with decreasing portions of the population
    as they offer smaller amounts of reward.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，也有一些实现方式，除了寻找全局最大值之外，我们还希望找到其他一些（或所有）峰值。为了实现这一点，我们可以将每个峰值视为一个生态位，提供与其高度成比例的资源。然后，我们找到一种方法，将这些资源在占据这些生态位的个体之间共享（或分配）。理想情况下，这将推动种群按比例分布，最高的峰值吸引最多的个体，因为它提供了最多的奖励，而其他峰值则随着奖励的减少而被越来越少的个体占据。
- en: 'This ideal situation is depicted in the following figure:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这种理想情况在以下图中有所描述：
- en: '![Figure 2.23: Ideal genetic algorithm results with niching](img/B20851_02_024.jpg)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.23：带有生态位化的理想遗传算法结果](img/B20851_02_024.jpg)'
- en: 'Figure 2.23: Ideal genetic algorithm results with niching'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.23：带有生态位化的理想遗传算法结果
- en: The challenge now is to implement this sharing mechanism. One option to accomplish
    sharing is to divide the raw fitness value of each individual with (some function
    of) the combined distances from all the other individuals. Another option would
    be to divide the raw fitness of each individual by the number of other individuals
    within a certain radius around it.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的挑战是实现这种共享机制。一种实现共享的方式是将每个个体的原始适应度值与（某个函数）所有其他个体的综合距离进行除法。另一种选择是将每个个体的原始适应度值除以其周围一定半径内的其他个体数量。
- en: Serial niching versus parallel niching
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 串行生态位与并行生态位
- en: Unfortunately, the niching concept, as described previously, can prove hard
    to implement as it increases the complexity of the fitness calculation. In practice,
    it will also require the population size to be the original one multiplied by
    the number of the expected peaks (which is generally unknown).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，如前所述，细分概念可能难以实现，因为它增加了适应度计算的复杂性。在实践中，它还要求种群大小是原始种群大小与预期峰值数量的乘积（通常是未知的）。
- en: One way to overcome these issues is to find the peaks one at a time (serial
    niching) instead of attempting to find all of them at the same time (parallel
    niching). To implement serial niching, we use the genetic algorithm as usual and
    find the best solution. Then, we update the fitness function so that the area
    of the maximum point that was found is flattened, and repeat the process of the
    genetic algorithm.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 克服这些问题的一种方法是一次找到一个峰值（串行细分），而不是尝试同时找到所有峰值（并行细分）。为了实现串行细分，我们像往常一样使用遗传算法，找到最佳解。然后，我们更新适应度函数，将找到的最大点区域进行平滑处理，并重复遗传算法的过程。
- en: Ideally, we will now find the next best peak as the original peak is no longer
    present. We can repeat this process iteratively and find the next best peak at
    each iteration.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，我们现在将找到下一个最佳峰值，因为原始峰值不再存在。我们可以迭代地重复这个过程，在每次迭代中找到下一个最佳峰值。
- en: The art of solving problems using genetic algorithms
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用遗传算法解决问题的艺术
- en: Genetic algorithms provide us with a powerful and versatile tool that can be
    used to solve a wide array of problems and tasks. When we set to work on a new
    problem, we need to customize the tool and match it to that problem. This is done
    by making several choices, as described in the following paragraphs.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 遗传算法为我们提供了一个强大而多用途的工具，可以用来解决各种各样的问题和任务。当我们着手处理一个新问题时，我们需要定制这个工具并使其与问题相匹配。这是通过做出几个选择来实现的，如下文所述。
- en: First, we need to determine the **fitness function**. This is how each individual
    will be evaluated, where larger values represent better individuals. The function
    does not have to be mathematical. It can be represented by an algorithm, a call
    to an external service, or even a result of a game played, to list a few options.
    We just need a way to programmatically retrieve the fitness value for any given
    proposed solution (individual).
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要确定**适应度函数**。这是评估每个个体的标准，其中较大的值代表更优秀的个体。该函数不必是数学函数。它可以通过算法、调用外部服务，甚至是游戏结果来表示，举几个例子。我们只需要一种方法，能够程序化地获取任何给定方案（个体）的适应度值。
- en: Next, we need to choose an appropriate **chromosome encoding**. This is based
    on the parameters we send to the fitness function. So far, we have seen binary,
    integer, an ordered list, and real-coded examples. However, for some problems,
    we may need a mix of parameter types, or may even decide to create our own custom
    chromosome encoding.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要选择一个合适的**染色体编码**。这基于我们传递给适应度函数的参数。到目前为止，我们见过二进制、整数、有序列表和实数编码的示例。然而，对于一些问题，我们可能需要混合参数类型，甚至决定创建我们自己的自定义染色体编码。
- en: Next, we need to pick a **selection** method. Most selection methods will work
    for any kind of chromosome type. If the fitness function is not directly accessible,
    but we still have a way to tell which of several candidate solutions is the best,
    we can consider utilizing the tournament selection method.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要选择一个**选择**方法。大多数选择方法适用于任何类型的染色体。如果适应度函数无法直接访问，但我们仍然能够判断多个候选解中哪个是最好的，我们可以考虑使用锦标赛选择方法。
- en: As we have seen in the preceding sections, the choice of **crossover** and **mutation**
    operators will be linked to the chromosome encoding of the individuals. Binary-coded
    chromosomes will have different crossover and mutation schemes than those that
    fit real-coded problems. Similar to the choice of chromosome encoding, here, too,
    you can design methods for crossover and mutation that fit your unique use case.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的章节中看到的，**交叉**和**变异**算子的选择将与个体的染色体编码相关联。二进制编码的染色体与适合实数编码问题的染色体交叉和变异方案会有所不同。与染色体编码的选择类似，在这里，你也可以为交叉和变异设计适合你独特用例的方法。
- en: 'Lastly, there are the hyperparameters of the algorithm. The most common parameter
    values we need to set are as follows:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，还有算法的超参数。我们需要设置的最常见参数值如下：
- en: Population size
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 种群大小
- en: Crossover rate
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交叉率
- en: Mutation rate
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变异率
- en: Max number of generations
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最大代数
- en: Other stopping condition(s)
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他停止条件
- en: Elitism (used or not; what size)
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优胜劣汰（是否使用；大小）
- en: For these parameters, we can choose what we deem as reasonable values and then
    tweak them, similar to how hyperparameters are dealt with in almost any other
    optimization and learning algorithm.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些参数，我们可以选择我们认为合理的值，然后进行调整，类似于在几乎所有其他优化和学习算法中处理超参数的方式。
- en: If making all these choices appears to be an overwhelming task, don’t fret!
    In the chapters that follow, we will be iterating the process of making these
    choices time and again for the various types of problems we will tackle. After
    reading this book, you will be able to look at new problems and make your own
    wise choices.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 如果做出所有这些选择看起来是个压倒性的任务，不用担心！在接下来的章节中，我们将一次又一次地重复这一选择过程，以应对我们将要解决的各种类型的问题。读完本书后，你将能够面对新的问题并做出明智的选择。
- en: Summary
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you were introduced to the basic flow of the genetic algorithm.
    We then went over the key components of the flow, which included creating the
    population, calculating the fitness function, applying the genetic operators,
    and checking for stopping conditions.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你被介绍了遗传算法的基本流程。然后我们回顾了该流程的关键组成部分，包括创建种群、计算适应度函数、应用遗传操作符，以及检查停止条件。
- en: Next, we went over various methods of selection, including roulette wheel selection,
    SUS, rank-based selection, fitness scaling, and tournament selection, and demonstrated
    the differences between them.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们讨论了各种选择方法，包括轮盘赌选择、SUS、基于排名的选择、适应度缩放和锦标赛选择，并演示了它们之间的差异。
- en: We continued by reviewing several crossover methods, including single-point,
    two-point, and k-point crossover, as well as OX1 and partially matched crossover.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接着回顾了几种交叉方法，包括单点交叉、双点交叉和k点交叉，以及OX1交叉和部分匹配交叉。
- en: You were then introduced to several mutation methods, including flip-bit mutation,
    followed by the swap, inversion, and scramble mutations.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你被介绍了几种变异方法，包括翻转位变异，接着是交换、逆转和扰动变异。
- en: Real-coded genetic algorithms were presented next, along with their specialized
    chromosome encoding and their custom genetic operators of crossover and mutation.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来介绍了实数编码遗传算法，以及它们的专用染色体编码和自定义的交叉和变异遗传操作符。
- en: This was followed by an introduction to the concepts of elitism, niching, and
    sharing, as used in genetic algorithms.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 随后介绍了遗传算法中的精英主义、分群和共享等概念。
- en: In the last part of this chapter, you were presented with the various choices
    you need to make when approaching a problem to be solved using genetic algorithms,
    a procedure that will be repeated time and again throughout this book.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后部分，你被介绍了在使用遗传算法解决问题时需要做出的各种选择，这一过程将在全书中一次次重复。
- en: In the next chapter, the real fun begins – coding with Python! You will be introduced
    to DEAP, an evolutionary computation framework that can be used as a powerful
    tool for applying genetic algorithms to a wide array of tasks. DEAP will be used
    in the rest of this book as we develop Python programs that tackle numerous different
    challenges.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，真正的乐趣开始了——用Python编程！你将被介绍到DEAP，一个进化计算框架，可以作为应用遗传算法解决广泛任务的强大工具。在本书的其余部分，我们将使用DEAP来开发Python程序，解决许多不同的挑战。
- en: Further reading
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: For more information, please refer to [*Chapter 8*](B20851_08.xhtml#_idTextAnchor238),
    *Genetic Algorithms*, in the book *Artificial Intelligence with Python*, by Prateek
    Joshi, January 2017, available at [https://subscription.packtpub.com/book/big_data_and_business_intelligence/9781786464392/8](https://subscription.packtpub.com/book/big_data_and_business_intelligence/9781786464392/8).
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 欲了解更多信息，请参考[*第8章*](B20851_08.xhtml#_idTextAnchor238)，*遗传算法*，出自Prateek Joshi所著《Python人工智能》，2017年1月出版，详见[https://subscription.packtpub.com/book/big_data_and_business_intelligence/9781786464392/8](https://subscription.packtpub.com/book/big_data_and_business_intelligence/9781786464392/8)。
