- en: Chapter 2. Understanding OpenCL Data Transfer and Partitioning
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章：理解OpenCL数据传输和分区
- en: 'In this chapter, we''ll cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Creating OpenCL buffer objects
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建OpenCL缓冲区对象
- en: Retrieving information about OpenCL buffer objects
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取关于OpenCL缓冲区对象的信息
- en: Creating OpenCL sub-buffer objects
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建OpenCL子缓冲区对象
- en: Retrieving information about OpenCL sub-buffer objects
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取关于OpenCL子缓冲区对象的信息
- en: Understanding events and event-synchronization
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解事件和事件同步
- en: Copying data between memory objects
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在内存对象之间复制数据
- en: Using work items to partition data
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用工作项来分区数据
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In this chapter, we're going to explore how to invoke the OpenCL's data transfer
    APIs, query memory objects, and data/work partitioning between the GPUs and CPUs.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨如何调用OpenCL的数据传输API，查询内存对象，以及GPU和CPU之间的数据/工作分区。
- en: Tip
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Be aware that not all OpenCL SDKs support the compilation and execution on both
    GPUs and CPUs. AMD's OpenCL implementation supports its own AMD and Intel CPUs
    and GPUs; NVIDIA supports its GPUs and Intel supports its own Intel Core CPUs
    and Intel HD Graphics. Check with the vendor for supported devices.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，并非所有OpenCL SDK都支持在GPU和CPU上同时编译和执行。AMD的OpenCL实现支持其自己的AMD和Intel CPU以及GPU；NVIDIA支持其GPU，而Intel支持其自己的Intel
    Core CPU和Intel HD Graphics。请咨询供应商以了解支持的设备。
- en: In the **Open Computing Language** (**OpenCL**) development, you would inevitably
    need data to be processed, and the standard does not permit you to manipulate
    memory objects directly as you would do when you program in C or C++, because
    the data memory in the host is ultimately transferred to the devices in a heterogeneous
    environment for processing, and previously you would use the programming constructs
    in various libraries or languages to access them which is one of the reasons why
    OpenCL came about; hence to unify these approaches, the standard added abstractions
    to shield the developer from these concerns.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在**开放计算语言**（**OpenCL**）的开发中，你不可避免地需要处理数据，而该标准不允许你直接操作内存对象，就像你在C或C++编程时做的那样，因为在异构环境中，主机中的数据内存最终会被传输到设备上进行处理，之前你会使用各种库或语言的编程结构来访问它们，这也是OpenCL出现的原因之一；因此，为了统一这些方法，标准添加了抽象来保护开发者免受这些问题的困扰。
- en: With respect to data types, there are a few you need to be aware of other than
    the one-dimensional data buffer. OpenCL buffer objects can be used to load and
    store two/three-dimensional data. The next data type in OpenCL is the `image`
    object; these objects are used to store two or three dimensional images (we won't
    cover much of using the `image` objects in this book).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据类型方面，除了单维数据缓冲区之外，还有一些你需要注意的类型。OpenCL缓冲区对象可以用来加载和存储二维/三维数据。OpenCL中的下一个数据类型是`image`对象；这些对象用于存储二维或三维图像（本书不会过多涉及`image`对象的使用）。
- en: 'The OpenCL 1.1 new data transfer capabilities includes the following:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCL 1.1的新数据传输功能包括以下内容：
- en: Using sub-buffer objects to distribute regions of a buffer across multiple OpenCL
    devices
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用子缓冲区对象将缓冲区的区域分布到多个OpenCL设备上
- en: 3-component vector data types
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3分量向量数据类型
- en: Using the global work offset which enables kernels to operate on different portions
    of the NDRange—global work offset refers to the data points in the input data
    where work items can start processing
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用全局工作偏移，它使内核能够在NDRange的不同部分上操作——全局工作偏移指的是输入数据中的数据点，工作项可以从那里开始处理
- en: Reading, writing, or copying a 1D, 2D or 3D rectangular region of a buffer object
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取、写入或复制缓冲区对象的1D、2D或3D矩形区域
- en: Creating OpenCL buffer objects
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建OpenCL缓冲区对象
- en: In the previous chapter, we understood the need to create or wrap our host's
    memory objects into an abstraction that OpenCL can operate on, and in this recipe
    we'll explore how to create a particular type of memory object defined in the
    specification that is commonly used for general purpose computation—buffer object.
    The developer can choose to create a one, two or three dimensional memory object
    that best fits the computational model.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们了解了创建或包装我们的主机内存对象到OpenCL可以操作的一种抽象的需要，在本食谱中，我们将探讨如何创建规范中定义的特定类型的内存对象，这种对象通常用于通用计算——缓冲区对象。开发者可以选择创建一个一维、二维或三维的内存对象，以最适合计算模型。
- en: Creating buffer objects is simple in OpenCL and is akin to the way in which
    you would use C's memory allocation routines such as `malloc` and `alloca`. But,
    that's where the similarity ends for the reason that OpenCL cannot operate directly
    on memory structures created by those routines. What you can do is to create a
    memory structure that lives on the devices that can be mapped to the memory on
    the host and the data is transferred to the device by issuing memory transfer
    commands to the command queue (which you recall is the conduit to the device).
    What you need to decide is the sort of objects, and how much of these objects
    you would like the device to compute.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在OpenCL中创建缓冲区对象很简单，类似于您使用C的内存分配例程（如`malloc`和`alloca`）的方式。但是，相似之处到此为止，因为OpenCL不能直接操作由这些例程创建的内存结构。您可以做的只是创建一个存在于设备上的内存结构，该结构可以映射到主机上的内存，并通过向命令队列（您记得这是通往设备的通道）发出内存传输命令来将数据传输到设备。您需要决定的是对象的类型，以及您希望设备计算多少这样的对象。
- en: 'In this example, we''re going to learn how to create buffer objects based on
    user-defined structures also known as `structs` in the C/C++ language. Before
    that, let''s understand the API:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将学习如何根据用户定义的结构创建缓冲区对象，也称为C/C++语言中的`structs`。在那之前，让我们了解API：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You can create a buffer by specifying which `context` it should attach to (recall
    that contexts can be created with several devices), specify the size of the data,
    and where to reference it with `size` and `host_ptr` respectively, specify how
    memory is to be allocated and whether that memory is to be of type read, read-only,
    read-write, or write only via `flags`; lastly capture the resultant error code
    in `errcode_ret`. Note that `clCreateBuffer` doesn't queue the command to conduct
    the memory transfer from host to device memory.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过指定它应该附加到的`上下文`来创建一个缓冲区（记住上下文可以通过多个设备创建），指定数据的大小，以及如何使用`size`和`host_ptr`分别引用它，通过`flags`指定内存的分配方式和内存类型是只读、只读、读写或只写；最后在`errcode_ret`中捕获结果错误代码。请注意，`clCreateBuffer`不会将命令排队以从主机到设备内存进行内存传输。
- en: Getting ready
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Here''s a portion of the code from `Ch2/user_buffer/user_buffer.c` where you
    will see how to use the `clCreateBuffer` API to allocate memory for a user-defined
    structure. The problem we are trying to solve in this example is to send a million
    user-defined structures to the device for computation. The computation encapsulated
    by the kernel is a simple one—sum of all elements of each user-structure. The
    astute reader would have noticed we could have demonstrated this data structure
    with a vector data type in OpenCL, `int4`; the reason why we didn''t do it that
    way is a two fold: (a) it''s an example of application domain modeling, (b) because
    in a few paragraphs from current we wanted to illustrate how you could use the
    data type alignment construct, and don''t fret over the data types now because
    we''ll dive into the various data types in the next chapter. Continuing further,
    the user-defined structure is as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`Ch2/user_buffer/user_buffer.c`代码的一部分，您将看到如何使用`clCreateBuffer` API为用户定义的结构分配内存。在这个例子中，我们试图解决的问题是将一百万个用户定义的结构发送到设备进行计算。内核封装的计算非常简单——计算每个用户结构的所有元素的总和。细心的读者会注意到我们本可以用OpenCL的向量数据类型`int4`来演示这个数据结构；我们没有那样做的原因有两个：一是这是一个应用领域建模的例子，二是由于在当前的一小段文字中，我们想要展示如何使用数据类型对齐构造，现在不要担心数据类型，因为我们在下一章将深入探讨各种数据类型。继续前进，用户定义的结构如下：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: What you will need to do is to create a buffer on the host application using
    standard C/C++ dynamic/static memory allocation techniques such as `new`, `malloc`,
    and `alloca`. Next, you will need to initialize that data buffer, and finally
    you will have to invoke `clCreateBuffer` and you should make sure it's done prior
    to the call to `clSetKernelArg`; recall that we mentioned that kernels get scheduled
    for execution on the device, well before it executes the kernel code on the device
    it would need data and values to work against, and you can achieve this by an
    invocation to `clSetKernelArg` and you typically do this when the buffer object
    is created.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要做的是在主机应用程序中使用标准的C/C++动态/静态内存分配技术，如`new`、`malloc`和`alloca`来创建一个缓冲区。接下来，您需要初始化该数据缓冲区，最后您必须调用`clCreateBuffer`，并确保在调用`clSetKernelArg`之前完成；记住我们提到内核在执行设备上的内核代码之前会被调度到设备上，它需要数据和值来工作，您可以通过调用`clSetKernelArg`来实现这一点，通常在创建缓冲区对象时这样做。
- en: 'The API `clSetKernelArg` looks like the following code and it''ll be important
    for you to understand how it works:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: API `clSetKernelArg`看起来像以下代码，并且理解它是如何工作的将非常重要：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The kernel can take no arguments or at least one and probably more arguments,
    and how you configure them is simple. The following code snippet should complete
    the story:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 内核可以没有参数，或者至少有一个，可能还有更多参数，配置它们很简单。以下代码片段应该能完成这个故事：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Therefore, the kernel arguments are configured programmatically with the understanding
    that if the kernel function has `n` arguments then the `arg_index` would range
    from `0` to (`n – 1`).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，内核参数以编程方式配置，理解如果内核函数有`n`个参数，则`arg_index`的范围将从`0`到`n - 1`。
- en: How to do it…
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'We''ve included the main part of this recipe from `Ch2/user_buffer/user_buffer.c`,
    with the highlighted commentary:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`Ch2/user_buffer/user_buffer.c`中包含了此菜谱的主要部分，并带有高亮注释：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'On OSX, you would compile the program by running the following command on your
    terminal:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在OSX上，你可以在终端运行以下命令来编译程序：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'On the Ubuntu Linux 12.04 with Intel OpenCL SDK, the command will be as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在带有Intel OpenCL SDK的Ubuntu Linux 12.04上，命令将如下所示：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'On the Ubuntu Linux 12.04 with AMD APP SDK v2.8, the command will be as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在带有AMD APP SDK v2.8的Ubuntu Linux 12.04上，命令将如下所示：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Regardless of the platform, a binary executable `user_buffer` would be deposited
    locally.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 无论平台如何，都会在本地存储一个二进制可执行文件`user_buffer`。
- en: Note
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Running the application on both platforms, we would get the following result:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个平台上运行应用程序，我们会得到以下结果：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: How it works…
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'The application created a million of the `UserData` objects on the host. Refer
    to the following code snippet:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序在主机上创建了百万个`UserData`对象。参考以下代码片段：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The application then sends it to the device for computation after the program
    and kernel objects have been initialized, and we assign the recently created `UDObj`
    memory object to the kernel as its argument. Refer to the following code snippet:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序在程序和内核对象初始化后将其发送到设备进行计算，并将最近创建的`UDObj`内存对象分配给内核作为其参数。参考以下代码片段：
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, we issue a kernel execution command to the command-queue, `cQ`, and the
    code will run against the device, the following code snippet demonstrates the
    enqueuing of the kernel:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们向命令队列`cQ`发出内核执行命令，代码将在设备上运行，以下代码片段演示了内核的入队：
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'After that''s done, the data in the device''s memory is read back and we indicated
    that we wish to read the data back until the device has completed its execution
    by passing `CL_TRUE` to indicate blocking read which otherwise could result in
    partial data read back; finally the data is verified, demonstrated by the following
    code snippet:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，将设备内存中的数据读回，我们表示我们希望读取数据直到设备完成其执行，通过传递`CL_TRUE`来指示阻塞读取，否则可能会导致读取部分数据；最后，数据通过以下代码片段进行验证：
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Let's explore how we used `clCreateBuffer` further.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进一步探索如何使用`clCreateBuffer`。
- en: In this scenario, you would want to allocate memory on the device as read-only
    when it comes to providing input to the device and because you want to be sure
    nothing else is writing to the data store. Therefore, the flag `CL_MEM_READ_ONLY`
    is passed, but if your input data was meant to be readable and writable then you
    would need to indicate it using `CL_MEM_READ_WRITE`. Notice that we actually created
    a data store on the host via `ud_in` and, we wanted our OpenCL memory object to
    be the same size as `ud_in` and the `C` statement reflects this; finally we wanted
    OpenCL to know that the new memory object is to copy its values from `ud_in` and
    we provided the flag `CL_MEM_COPY_HOST_PTR` too, and we use the bitwise `OR` operator
    that is represented on the standard US keyboard as a pipe symbol, *|*, to merge
    these two flags.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，当向设备提供输入并且你想要确保没有其他东西正在写入数据存储时，你希望在设备上分配只读内存。因此，传递了标志`CL_MEM_READ_ONLY`，但如果你的输入数据旨在可读和可写，那么你需要使用`CL_MEM_READ_WRITE`来指示它。注意，我们实际上通过`ud_in`在主机上创建了一个数据存储，并且我们希望我们的OpenCL内存对象与`ud_in`和`C`语句的大小相同；最后，我们希望OpenCL知道新的内存对象将从`ud_in`复制其值，我们也提供了标志`CL_MEM_COPY_HOST_PTR`，并且我们使用标准美国键盘上表示为管道符号的位运算符`|`来合并这两个标志。
- en: Conceptually, you can visualize it to be an 1D-array-of-structs for short or
    an array-of-structures in general.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 从概念上讲，你可以将其视为一个结构体的一维数组，或者更一般地说，是一个结构体数组。
- en: '| `UserData` | `UserData` | `UserData` | …………………………………………… | `UserData` |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `UserData` | `UserData` | `UserData` | …………………………………………… | `UserData` |'
- en: Tip
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Provide the same declaration of the application data type to the OpenCL kernel
    file (`*.cl`) as well as the host application files (`*.c`, `*.h`, `*.cpp`, `*.hpp`);
    else the OpenCL runtime will emit errors to reflect that the struct it is looking
    for does not exist, and the replication is necessary as OpenCL prohibits the `C`
    header file inclusion mechanism.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 将相同的应用数据类型声明提供给 OpenCL 内核文件（`*.cl`）以及主机应用程序文件（`*.c`, `*.h`, `*.cpp`, `*.hpp`）；否则，OpenCL
    运行时会发出错误，以反映它正在寻找的结构不存在，并且复制是必要的，因为 OpenCL 禁止 `C` 头文件包含机制。
- en: Let's spend some time to understand the C `struct` we just used in this example.
    The C structure we just used, `UserData`, is an example of an application data
    type. OpenCL makes no requirement about the alignment of OpenCL data types outside
    of buffers and images; hence developers of OpenCL need to make sure the data is
    properly aligned. Fortunately, OpenCL has provided attribute qualifiers so that
    we can annotate our types, functions and variables to suit the algorithm and CPU/GPU
    architecture with the primary motivation being to improve memory bandwidth. The
    alignment needs to be a power of two and at least a perfect multiple of the lowest
    common multiple of all the alignments of all the members of the `struct` or `union`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们花些时间来理解我们在本例中使用的 C `struct`。我们刚刚使用的 C 结构 `UserData` 是一个应用数据类型的例子。OpenCL 对缓冲区和图像之外的
    OpenCL 数据类型的对齐没有要求；因此，OpenCL 开发者需要确保数据得到适当的对齐。幸运的是，OpenCL 提供了属性限定符，这样我们就可以注释我们的类型、函数和变量，以适应算法和
    CPU/GPU 架构，主要动机是提高内存带宽。对齐必须是 2 的幂，并且至少是结构或联合中所有成员对齐的最小公倍数的完美倍数。
- en: Note
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Refer to Section 6.11.1 Specifiying Attributes of Types in the OpenCL 1.2 specification
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅 OpenCL 1.2 规范中的第 6.11.1 节“指定类型的属性”
- en: Let's take a look at what is available to developers when it comes to aligning
    data types such as `enum`, `struct`, or `union`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看当涉及到对 `enum`、`struct` 或 `union` 等数据类型进行对齐时，开发者可以有哪些选择。
- en: Data alignment is a direct result of how various computer systems restrict the
    allowable addresses for the primitive data types, requiring that the address for
    some type of object must be a multiple of some value *K* (typically 2, 4, or 8),
    and this actually simplifies the design of the hardware between the processor
    and the memory system. For example, if the processor were to always fetch 8 bytes
    from memory with an address that must be a multiple of 8, then the value can be
    read or written in a single memory operation otherwise, the processor needs to
    perform two or more memory accesses.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 数据对齐是各种计算机系统限制原始数据类型允许地址的直接结果，要求某些类型对象的地址必须是某个值 *K*（通常是 2、4 或 8）的倍数，这实际上简化了处理器和内存系统之间硬件的设计。例如，如果处理器总是从地址必须是
    8 的倍数的内存中获取 8 字节，那么值可以在单一内存操作中读取或写入，否则，处理器需要执行两个或更多的内存访问。
- en: Alignment is enforced by making sure that every data type is organized and allocated
    in such a way that every object within the type satisfies its alignment restrictions.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 通过确保每个数据类型中的每个对象都按照满足其对齐限制的方式组织和分配来强制执行对齐。
- en: 'Let''s use an example for this illustration. Following is the generic manner
    in which alignment can be defined for application data type such as `UserData`.
    While examining the code, you will notice that without the `aligned` attribute,
    this data structure will be allocated on a 17-byte boundary assuming `int` is
    4-bytes and `char` is 1-byte on a 32-bit / 64-bit system architecture. Once this
    attribute is included, following is the alignment:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个例子来说明这一点。以下是为应用数据类型如 `UserData` 定义对齐的通用方式。在检查代码时，您会注意到如果没有 `aligned` 属性，这个数据结构将在假设
    `int` 是 4 字节且 `char` 是 1 字节（在 32 位/64 位系统架构上）的情况下，分配在 17 字节边界上。一旦包含了这个属性，对齐如下：
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The alignment is now determined by the OpenCL compiler to be aligned to 32-bytes
    instead of 17-bytes, that is, summing all the struct member''s sizes, and the
    specification designates the alignment size to be the largest power of 2 and therefore
    it is 25 because, the 24 is 1-byte too many; however if you were to change the
    previous alignment to the following alignment:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在对齐由 OpenCL 编译器确定为 32 字节对齐，而不是 17 字节，即求所有结构成员的大小之和，规范指定对齐大小为最大的 2 的幂，因此它是 25，因为
    24 多了 1 字节；然而，如果您将之前的对齐更改为以下对齐：
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then the alignment will be at least 8-bytes as shown in the following code:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，对齐至少为 8 字节，如下面的代码所示：
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Equivalently, you can also write in more explicit form as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，你也可以更明确地写成如下形式：
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In general, the golden rule of designing the data to be memory aligned is still
    a necessary practice; a rule of thumb I keep in mind is 16-byte aligned for 128-bit
    access and 32-byte aligned for 256-bit access.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，设计数据以内存对齐的金科玉律仍然是必要的实践；我牢记的一个经验法则是，对于 128 位访问，16 字节对齐，对于 256 位访问，32 字节对齐。
- en: 'On the other side of the story, you may find yourself wishing that the alignment
    wasn''t that large, and with OpenCL you can indicate that by using the `packed`
    attribute as in the following code assuming that `LargeUserData` is an imaginary
    large data structure:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在故事的另一面，你可能发现自己希望对齐程度不是那么大，使用 OpenCL 你可以通过使用 `packed` 属性来表示这一点，如下面的代码所示，假设 `LargeUserData`
    是一个假想的大型数据结构：
- en: '[PRE17]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: When you apply this attribute to a `struct` or `union`, you're effectively applying
    the attribute to every member of the data; applying to an `enum` means that the
    OpenCL compiler will select the smallest integral type found on that architecture.
    You can refer to the `Ch2/user_buffer_alignment/user_buffer_align.c` to review
    what's done and how to profile the performance of the application via AMD APP
    SDK in the `readme.txt` file.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '当你将此属性应用于 `struct` 或 `union` 时，你实际上是将属性应用于数据的每个成员；应用于 `enum` 意味着 OpenCL 编译器将选择在该架构上找到的最小整型。你可以参考
    `Ch2/user_buffer_alignment/user_buffer_align.c` 来查看所做的工作以及如何通过 AMD APP SDK 在 `readme.txt`
    文件中通过性能分析来分析应用程序。 '
- en: Retrieving information about OpenCL buffer objects
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检索 OpenCL 缓冲区对象的信息
- en: 'To retrieve information about a buffer or sub-buffer object, you''ll need to
    use the API `clGetMemObjectInfo` and its signature as in the following code:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 要检索有关缓冲区或子缓冲区对象的信息，你需要使用 API `clGetMemObjectInfo` 以及其签名，如下面的代码所示：
- en: '[PRE18]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: To query the memory object, simply pass the object to `memobj` specifying the
    type of information you want in `param_name`, inform OpenCL the size of the returned
    information in `param_value_size` and where to deposit it in `param_value`; the
    last parameter, `param_value_size_ret`, is largely optional but it returns the
    size of the value in `param_value_size`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要查询内存对象，只需将对象传递给 `memobj`，指定你想要在 `param_name` 中获取的信息类型，通知 OpenCL 返回信息的尺寸在 `param_value_size`
    中，以及在哪里存储它（`param_value`）；最后一个参数 `param_value_size_ret` 大部分是可选的，但它返回 `param_value`
    中值的尺寸。
- en: Getting ready
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Here''s an excerpt from the code in `Ch2/buffer_query/buffer_query.c` where
    it shows how to extract the information about the memory object, `UDObj` is encapsulated
    into a user-defined function `displayBufferDetails` because, the code can be long
    depending on how many attributes you wish to extract about a memory object and
    you would place the invocation to this function after you''ve created the buffer
    object or if you have been given a handle to the memory object. The following
    code illustrates how it would display the information about a memory object by
    abstracting the OpenCL memory retrieval APIs into the function `displayBufferDetails`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是从 `Ch2/buffer_query/buffer_query.c` 代码中摘录的一段，展示了如何提取内存对象的信息，`UDObj` 被封装到一个用户定义的函数
    `displayBufferDetails` 中，因为代码可能很长，这取决于你希望从内存对象中提取多少属性，你会在创建缓冲区对象之后或如果你已经得到了内存对象的句柄时调用此函数。以下代码演示了如何通过将
    OpenCL 内存检索 API 抽象到函数 `displayBufferDetails` 中来显示内存对象的信息：
- en: '[PRE19]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: How to do it…
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'We''ve included the main part of this recipe, as shown in the following code:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经包括了此菜谱的主要部分，如下面的代码所示：
- en: '[PRE20]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'On OSX, you will compile the program by running the following command on your
    terminal:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在 OSX 上，你将通过在终端运行以下命令来编译程序：
- en: '[PRE21]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'On Ubuntu Linux 12.04 with Intel OpenCL SDK, the command will be as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ubuntu Linux 12.04 上使用 Intel OpenCL SDK，命令将如下所示：
- en: '[PRE22]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'On Ubuntu Linux 12.04 with AMD APP SDK v2.8, the command will be as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ubuntu Linux 12.04 上使用 AMD APP SDK v2.8，命令将如下所示：
- en: '[PRE23]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Regardless of the platform, a binary executable `buffer_query` would be deposited
    locally.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 不论是哪个平台，一个名为 `buffer_query` 的二进制可执行文件将被本地存储。
- en: 'Executing the program on an OSX 10.6 and Ubuntu 12.04 with AMD APP SDK v2.7
    would present the following result:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在 OSX 10.6 和 Ubuntu 12.04 上使用 AMD APP SDK v2.7 运行程序将呈现以下结果：
- en: '[PRE24]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: How it works…
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'The host application proceeds to first create the buffer that it will send
    to the device, then the application queries for information about the buffer.
    The full list of attributes that can be queried is as shown in the following table:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 主应用程序首先创建它将发送到设备的缓冲区，然后应用程序查询有关缓冲区的信息。可以查询的完整属性列表如下表所示：
- en: '| cl_mem_info | Return type | Info. Returned in param_value |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| cl_mem_info | 返回类型 | 在param_value中返回的信息。|'
- en: '| --- | --- | --- |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `CL_MEM_TYPE` | `cl_mem_object_type` | It returns `CL_MEM_OBJECT_BUFFER`
    if `memobj` is created with `clCreateBuffer` or `clCreateSubBuffer`. |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `CL_MEM_TYPE` | `cl_mem_object_type` | 如果`memobj`是通过`clCreateBuffer`或`clCreateSubBuffer`创建的，则返回`CL_MEM_OBJECT_BUFFER`。|'
- en: '| `Cl_MEM_FLAGS` | `cl_mem_flags` | It returns the flags argument specified
    when `memobj` is created with `clCreateBuffer`, `clCreateSubBuffer`, `clCreateImage2D`,
    or `clCreateImage3D`. |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `Cl_MEM_FLAGS` | `cl_mem_flags` | 返回创建`memobj`时指定的标志参数。使用`clCreateBuffer`、`clCreateSubBuffer`、`clCreateImage2D`或`clCreateImage3D`创建`memobj`时返回。|'
- en: '| `CL_MEM_SIZE` | `size_t` | It returns the actual size of the data associated
    with `memobj` in bytes. |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `CL_MEM_SIZE` | `size_t` | 返回与`memobj`关联的数据的实际大小（以字节为单位）。|'
- en: '| `CL_MEM_HOST_PTR` | `void*` | If `memobj` is created with `clCreateBuffer`
    or `clCreateImage2d`, `clCreateImage3D`, then it returns the `host_ptr` argument
    specified when `memobj` is created.If `memobj` is created with `clCreateSubBuffer`,
    then it returns the `host_ptr` plus `origin` specified when `memobj` was created.See
    `clCreateBuffer` for what `host_ptr` is. |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `CL_MEM_HOST_PTR` | `void*` | 如果`memobj`是通过`clCreateBuffer`或`clCreateImage2d`、`clCreateImage3D`创建的，则返回创建`memobj`时指定的`host_ptr`参数。如果`memobj`是通过`clCreateSubBuffer`创建的，则返回创建`memobj`时指定的`host_ptr`加上`origin`。参见`clCreateBuffer`了解`host_ptr`是什么。|'
- en: '| `CL_MEM_MAP_COUNT` | `cl_uint` | Map count. |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `CL_MEM_MAP_COUNT` | `cl_uint` | 映射计数。|'
- en: '| `CL_MEM_REFERENCE_COUNT` | `cl_uint` | It returns `memobj`''s reference count.
    |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `CL_MEM_REFERENCE_COUNT` | `cl_uint` | 返回`memobj`的引用计数。|'
- en: '| `CL_MEM_CONTEXT` | `cl_context` | It returns the context specified when the
    memory is created. If `memobj` is created using `clCreateSubBuffer`, the context
    associated with the memory object specified as the `buffer` argument to `clCreateSubBuffer`
    is returned. |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `CL_MEM_CONTEXT` | `cl_context` | 返回创建内存时指定的上下文。如果`memobj`是通过`clCreateSubBuffer`创建的，则返回与内存对象关联的上下文，该上下文是作为`clCreateSubBuffer`的`buffer`参数指定的。|'
- en: '| `CL_MEM_ASSOCIATED_MEMOBJECT` | `cl_mem` | It return memory object from which
    `memobj` is created.In `clCreateSubBuffer`, it returns the `buffer` argument;
    else NULL is returned. |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `CL_MEM_ASSOCIATED_MEMOBJECT` | `cl_mem` | 返回创建`memobj`的内存对象。在`clCreateSubBuffer`中，它返回`buffer`参数；否则返回NULL。|'
- en: '| `CL_MEM_OFFSET` | `size_t` | Applicable to `memobj` created via `clCreateSubBuffer`.
    It returns offset or 0. |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| `CL_MEM_OFFSET` | `size_t` | 适用于通过`clCreateSubBuffer`创建的`memobj`。它返回偏移量或0。|'
- en: Creating OpenCL sub-buffer objects
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建OpenCL子缓冲区对象
- en: Sub-buffers are incredibly useful data types and as you continue to explore
    OpenCL in this chapter, you'll notice that this data type can be used to partition
    the data and distribute them across your OpenCL devices on your platform.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 子缓冲区是非常有用的数据类型，随着你继续在本章中探索OpenCL，你会注意到这种数据类型可以用来划分数据并将它们分布到你的平台上的OpenCL设备上。
- en: Note
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: At the time of this writing, sub-buffer support is not enabled on OpenCL delivered
    in the OSX 10.6, because the official version is OpenCL 1.0\. However, if you
    have OSX 10.7 then you'll be able to run this code without any problem.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，OSX 10.6中提供的OpenCL的子缓冲区支持尚未启用，因为官方版本是OpenCL 1.0。然而，如果你有OSX 10.7，那么你将能够无任何问题地运行此代码。
- en: 'Let''s take a look at the method signature and examine it:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看方法签名并检查它：
- en: '[PRE25]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The argument `buffer` refers to the buffer you created via `clCreateBuffer`,
    the `flags` argument refers to the options you wish this offer to have and if
    it''s zero then the default option is `CL_MEM_READ_WRITE`; this flag can adopt
    any values from the previous table. The argument `bufferType` is of a data structure:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 参数`buffer`指的是通过`clCreateBuffer`创建的缓冲区，`flags`参数指的是你希望此选项具有的选项，如果为零，则默认选项为`CL_MEM_READ_WRITE`；此标志可以采用前表中任何值。参数`bufferType`是一个数据结构：
- en: '[PRE26]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Therefore, you indicate where to start creating the region via the `origin`
    argument and how large it is going to be via the `size` argument.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你通过`origin`参数指示创建区域的起始位置，并通过`size`参数指示它的大小。
- en: Getting ready
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In the *How to do it...* section of this recipe there is an excerpt from `Ch2/sub_buffers/sub_buffer.c`
    where we create two sub-buffer objects and each of them holds one-half of the
    data; these two sub-buffers will be sent to each OpenCL device on my setup, and
    they''re computed and results are checked. Conceptually, here''s what the code
    is doing:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱的“如何做...”部分，有来自`Ch2/sub_buffers/sub_buffer.c`的摘录，其中我们创建了两个子缓冲区对象，每个对象包含一半的数据；这两个子缓冲区将发送到我的设置中的每个OpenCL设备上，它们将被计算并检查结果。从概念上讲，以下是代码所做的工作：
- en: '![Getting ready](img/sub_buffers.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![准备中](img/sub_buffers.jpg)'
- en: How to do it…
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We''ve included the main part of this recipe as shown in the following code:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将此菜谱的主要部分包含在以下代码中：
- en: '**/* Chop up the data evenly between all devices & create sub-buffers */**'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**/* 在所有设备之间均匀分割数据并创建子缓冲区 */**'
- en: '[PRE27]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '**/* Let OpenCL know that the kernel is suppose to receive an argument */**'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**/* 让OpenCL知道内核应该接收一个参数 */**'
- en: '[PRE28]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'As noted earlier, this application doesn''t work on OSX 10.6 and hence to compile
    it using the AMD APP SDK, you will enter the following command:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，此应用程序在OSX 10.6上无法工作，因此要使用AMD APP SDK编译它，你需要输入以下命令：
- en: '[PRE29]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'For the Intel OpenCL SDK, you will enter the following command:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Intel OpenCL SDK，你需要输入以下命令：
- en: '[PRE30]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'For NVIDIA on Ubuntu Linux 12.04, you will enter the following command:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Ubuntu Linux 12.04上的NVIDIA，你需要输入以下命令：
- en: '[PRE31]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Regardless of the platform, a binary executable `sub_buffer` would be deposited
    locally.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 无论平台如何，二进制可执行文件`sub_buffer`都会被本地存储。
- en: 'In the setup I have with Ubuntu Linux 12.04 with a NVIDIA GTX460 graphics chip
    with both NVIDIA''s and Intel''s OpenCL toolkit installed, I have the following
    output:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在我设置的Ubuntu Linux 12.04环境中，有一个NVIDIA GTX460显卡，安装了NVIDIA和Intel的OpenCL工具包，以下是我的输出结果：
- en: '[PRE32]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In the other setup with Ubuntu Linux 12.04 with an ATI 6870x2 graphics chip
    and AMD APP SDK installed, the difference in the output is only that the number
    of platforms is one and data is split between the CPU and GPU:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个Ubuntu Linux 12.04环境中，有一个ATI 6870x2显卡和AMD APP SDK安装的设置中，输出的差异仅在于平台数量为1，数据在CPU和GPU之间分割：
- en: '[PRE33]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: How it works…
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The application basically discovers all the OpenCL compliant devices and keeps
    tracks of how it discovered. Next, the application uses the prior information
    to divide the data among the devices before enqueuing the data for execution and
    the code snippet demonstrates the following:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序基本上会发现所有符合OpenCL规范的设备，并跟踪其发现过程。接下来，应用程序使用先前信息在将数据入队执行之前将数据分配到各个设备上，以下代码片段展示了以下内容：
- en: '[PRE34]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Finally, the data is checked for sanity after reading the data back from the
    device memory to the host memory as the following code snippet shows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在从设备内存将数据读回到主机内存后，会检查数据的有效性，如下代码片段所示：
- en: '[PRE35]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: What you've just seen is a data partitioning technique also known as the distributed
    array pattern on a one-dimensional block of data.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚才看到的是一种数据分区技术，也称为一维数据块上的分布式数组模式。
- en: Note
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Based on the distributed array pattern, there had been three general techniques
    that were developed, and they are over one-dimensional and two-dimensional blocks
    of data and finally the block-cyclic pattern.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 根据分布式数组模式，已经开发出三种一般技术，它们是一维和二维数据块，最后是块循环模式。
- en: Depending on whether you've installed one or more OpenCL toolkits from the vendors,
    the OpenCL will report the appropriate platforms and the OpenCL **Installable
    Client Driver** (**ICD**) allows multiple OpenCL implementations to co-exist on
    the same physical machine. Refer to the URL [http://www.khronos.org/registry/cl/extensions/khr/cl_khr_icd.txt](http://www.khronos.org/registry/cl/extensions/khr/cl_khr_icd.txt)
    for more information about ICDs. This explains why your program may display distinct
    numbers for each installed platforms. The ICD actually identifies the vendors
    who provided the OpenCL implementation on the machine you have setup and its main
    function is to expose the platforms to the host code so that the developer may
    choose to run the algorithm in question against. The ICD has two pieces of information—(a)
    entry points to the vendor's OpenCL implementation in the library on the filesystem
    on which it's been installed, (b) the suffix string used to identify the suffix
    for OpenCL extensions provided by that vendor.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你是否安装了一个或多个供应商的OpenCL工具包，OpenCL会报告适当的平台，并且OpenCL **可安装客户端驱动程序**（**ICD**）允许多个OpenCL实现共存于同一台物理机器上。有关ICD的更多信息，请参阅URL
    [http://www.khronos.org/registry/cl/extensions/khr/cl_khr_icd.txt](http://www.khronos.org/registry/cl/extensions/khr/cl_khr_icd.txt)。这解释了为什么你的程序可能为每个安装的平台显示不同的数字。ICD实际上标识了在您设置的机器上提供OpenCL实现的供应商，其主要功能是向主机代码暴露平台，以便开发者可以选择运行相关算法。ICD包含两条信息——（a）供应商OpenCL实现在文件系统上安装的库中的入口点，（b）用于识别该供应商提供的OpenCL扩展后缀的字符串。
- en: Retrieving information about OpenCL sub-buffer objects
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取OpenCL子缓冲区对象的信息
- en: The retrieval of information about OpenCL sub-buffers is very similar to that
    described in the previous recipe and involves the invocation of `clGetMemObjInfo`.
    Let's take a look at it.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 获取OpenCL子缓冲区信息的检索与之前菜谱中描述的非常相似，涉及到调用`clGetMemObjInfo`。让我们来看看它。
- en: Tip
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: OSX Caveat—you will need a OpenCL 1.1, at least the implementation to see this
    build and run; since OSX 10.6 doesn't support that version, you'll have to get
    a OSX 10.7 to get this code to run.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: OSX注意事项——你需要至少OpenCL 1.1的实现来看到这个构建和运行；由于OSX 10.6不支持这个版本，你将需要获取OSX 10.7来运行这段代码。
- en: Getting ready
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In the `Ch2/sub_buffer_query/subbuffer_query.c`, you''ll find an excerpt of
    the following code demonstrating how we would pass the sub-buffer memory object
    to our defined function `displayBufferDetails`:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Ch2/sub_buffer_query/subbuffer_query.c`中，你可以找到以下代码的摘录，展示了我们如何将子缓冲区内存对象传递给我们的定义函数`displayBufferDetails`：
- en: '[PRE36]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Tip
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'During my experimentation, I found that the NVIDIA CUDA 5 OpenCL toolkit was
    stricter in evaluating the attributes in the argument flags that''s passed to
    `clCreateSubBuffer` as compared to AMD''s APP SDK v2.7\. Take note that the bug
    may be fixed by the time you read this book. As a concrete example, the following
    code throws an error using NVIDIA as opposed to AMD when you write:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的实验过程中，我发现与AMD的APP SDK v2.7相比，NVIDIA CUDA 5 OpenCL工具包在评估传递给`clCreateSubBuffer`的参数标志中的属性时更为严格。请注意，当你阅读这本书的时候，这个错误可能已经被修复了。作为一个具体的例子，以下代码在NVIDIA上运行时会抛出错误，而在AMD上则不会，当你编写以下内容时：
- en: '`clCreateSubBuffer(buffer,CL_MEM_READ_WRITE|CL_MEM_COPY_HOST_PTR,…)` to reflect
    the fact that `CL_MEM_COPY_HOST_PTR` doesn''t make sense.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`clCreateSubBuffer(buffer,CL_MEM_READ_WRITE|CL_MEM_COPY_HOST_PTR,…)`以反映`CL_MEM_COPY_HOST_PTR`没有意义的事实。'
- en: How to do it…
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何去做…
- en: 'We''ve included the main part of this recipe, as shown in the following code:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经包括了本菜谱的主要部分，如下面的代码所示：
- en: '[PRE37]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'On the Ubuntu Linux 12.04 with AMD''s APP SDK v2.8, the following command would
    suffice:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ubuntu Linux 12.04和AMD的APP SDK v2.8上，以下命令就足够了：
- en: '[PRE38]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'For the Intel OpenCL SDK, you would enter the following command:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Intel OpenCL SDK，你需要输入以下命令：
- en: '[PRE39]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'For NVIDIA on Ubuntu Linux 12.04, you would enter the following command :'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Ubuntu Linux 12.04上的NVIDIA，你需要输入以下命令：
- en: '[PRE40]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Regardless of the platform, a binary executable `subbuffer_query` would be deposited
    locally.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 不论是哪个平台，一个二进制可执行文件`subbuffer_query`都会被本地存储。
- en: 'When you run the program, you should get something similar to the following
    output:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行程序时，你应该得到以下类似的输出：
- en: '[PRE41]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: How it works…
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The application could decipher whether it's an OpenCL sub-buffer object because
    of the two flags introduced in OpenCL 1.2\. They are `CL_MEM_OFFSET` and `CL_MEM_ASSOCIATED_MEMOBJECT`;
    using either one of the flags would reveal whether it's a sub-buffer, but the
    catch is that `CL_MEM_OFFSET` can be zero for a sub-buffer because that indicates
    to OpenCL where to start to extract the data from; a better, recommended option
    is to use `CL_MEM_ASSOCIATED_MEMOBJECT` since the presence implies the argument
    `memobj` is a sub-buffer. See the earlier recipe, *Retrieving information about
    OpenCL buffer objects*.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序能够解析它是否是一个OpenCL子缓冲区对象，这要归功于OpenCL 1.2中引入的两个标志。它们是`CL_MEM_OFFSET`和`CL_MEM_ASSOCIATED_MEMOBJECT`；使用任一标志都可以揭示它是否是一个子缓冲区，但要注意的是，对于子缓冲区，`CL_MEM_OFFSET`可以是零，因为这表示OpenCL从哪里开始提取数据；一个更好、更推荐的选择是使用`CL_MEM_ASSOCIATED_MEMOBJECT`，因为它的存在意味着参数`memobj`是一个子缓冲区。参见之前的菜谱，*获取OpenCL缓冲区对象信息*。
- en: Understanding events and event-synchronization
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解事件和事件同步
- en: The previous recipes demonstrated how you can create memory objects that encapsulates
    the data that is to be transferred from the host memory to the device memory,
    and discusses how you can partition the input data among the devices via sub-buffers.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的菜谱展示了如何创建封装要从一个主机内存传输到设备内存的数据的内存对象，并讨论了如何通过子缓冲区将输入数据分配到各个设备。
- en: In this recipe, we are going to develop an understanding of how the developer
    can make use of the event system in OpenCL to control execution of kernel commands
    as well as memory commands. This is beneficial to the developer because it offers
    myriad ways in which you can control execution flow in a heterogeneous environment.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将探讨开发者如何利用OpenCL的事件系统来控制内核命令以及内存命令的执行。这对开发者来说是有益的，因为它提供了多种控制异构环境中执行流程的方法。
- en: Events are, generally, passive mechanisms when the developers wish to be notified
    of an occurrence, and having the choice of conducting processing past that occurrence;
    contrasting to the say, polling where it's a more active mechanism as the application
    makes an active enquiry into the current state and decides what to do when a particular
    condition is met.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当开发者希望被通知某个事件发生，并可以选择对那个事件之后进行处理的操作时，事件通常是一种被动的机制；与轮询（polling）相对，轮询是一种更主动的机制，因为应用程序会主动查询当前状态，并在满足特定条件时决定下一步操作。
- en: 'Events in OpenCL fall into two categories as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCL中的事件分为以下两类：
- en: Host monitoring events
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主机监控事件
- en: Command events
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令事件
- en: In both the event types, the developer needs to create the events explicitly
    and associate them with the objects through waitlists; waitlists are nothing more
    than a container of events that the command must wait upon completion, that is,
    the event's status is `CL_COMPLETE` or `CL_SUCCESS` before progressing. The difference
    between these two event types (as we shall soon see) is in the manner in which
    the next subsequent command in the queue gets executed, host events are updated
    by the developer and when this is done it is indicative by the program source,
    command events in the waitlists on the other hand are updated by the OpenCL runtime.
    Considering that the events held up in the waitlists must be of a certain state
    before the next command executes means that waitlists are actually synchronization
    points since no progress can be made without emptying that list.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种事件类型中，开发者需要显式创建事件，并通过等待列表（waitlists）将它们与对象关联起来；等待列表实际上只是一个容器，其中包含命令必须等待完成的事件，也就是说，在执行下一个命令之前，事件的状态必须是`CL_COMPLETE`或`CL_SUCCESS`。这两种事件类型（正如我们很快将看到的）之间的区别在于队列中下一个后续命令的执行方式，主机事件由开发者更新，当完成更新时，程序源会指示这一点；另一方面，等待列表上的命令事件由OpenCL运行时更新。考虑到在等待列表中保留的事件必须在执行下一个命令之前达到某种状态，这意味着等待列表实际上是同步点，因为没有清空该列表就无法取得进展。
- en: Let's start by examining the host events. So far, we understood that commands
    needs to be placed onto the command queue so that they can be scheduled for execution,
    and what host monitoring events allow the developer is to monitor the state of
    enqueued command and we can, optionally, attach a callback function to the event
    so that when it returns with a state we desire, the callback function will execute.
    This is made possible via the APIs `clCreateUserEvent`, `clSetUserEventStatus`,
    `clReleaseEvent`, and `clSetEventCallback`. An example in the *How to do it* section
    would illustrate how this can be achieved.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先来检查主机事件。到目前为止，我们已经了解到需要将命令放入命令队列，以便它们可以被调度执行，而主机监控事件允许开发者监控已入队的命令状态，并且我们可以选择性地将回调函数附加到事件上，以便当它返回我们期望的状态时，回调函数将执行。这是通过API
    `clCreateUserEvent`、`clSetUserEventStatus`、`clReleaseEvent`和`clSetEventCallback`实现的。在*如何操作*部分的一个示例将说明如何实现这一点。
- en: Getting ready
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Assume that a kernel wishes to process two 1D memory objects named `objA` and
    `objB` and write the result to `objC` (for this example, we can ignore the output
    of `objC`). We wish that the copying of input data from `objB` should only take
    place when we have indicated to the host program.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一个内核希望处理两个名为`objA`和`objB`的1D内存对象，并将结果写入`objC`（对于这个例子，我们可以忽略`objC`的输出）。我们希望从`objB`复制输入数据只在我们指示主机程序时进行。
- en: How to do it…
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The full source is demonstrated in `Ch2/events/{events.c,sample_kernel.cl}`
    and we have to first create the necessary data structures as before; next we will
    create the event object as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的源代码在`Ch2/events/{events.c,sample_kernel.cl}`中演示，我们必须首先创建必要的数据结构，就像之前一样；接下来，我们将创建事件对象，如下所示：
- en: '[PRE42]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In this event object, we can next assign a call back function to the event
    and indicate that upon the event''s status changes to `CL_COMPLETE`, the callback
    would execute like the following code:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在此事件对象中，我们接下来可以为事件分配一个回调函数，并指示当事件的状态变为`CL_COMPLETE`时，回调函数将像以下代码那样执行：
- en: '[PRE43]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Then the host program would continue to conduct memory transfers for `objA`
    and `objB`, but it doesn't proceed to process any more OpenCL commands enqueued
    on the command queue till the status of the `event1` is set to `CL_COMPLETE`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，主机程序将继续为`objA`和`objB`执行内存传输，但不会继续处理命令队列上排队的任何更多OpenCL命令，直到`event1`的状态设置为`CL_COMPLETE`。
- en: '[PRE44]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Another API we will introduce is the `clWaitForEvents` with it''s signature:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要介绍的另一个API是`clWaitForEvents`，其签名如下：
- en: '[PRE45]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This is typically used to stall the host thread until all the commands in the
    event list have completed (the next code snippet demonstrates how).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常用于使主线程暂停，直到事件列表中的所有命令都完成（下一个代码片段将演示如何实现）。
- en: 'The next topic we look at are the command events, which are typically used
    when you wish to be notified of certain happenings associated with commands. A
    typical use case would be the following where you have a command-queue and you
    want to be notified of the status of an memory transfer command like `clEnqueueWriteBuffer`
    and take a particular action depending on that status:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要讨论的主题是命令事件，通常在你想被通知与命令相关联的某些事件时使用。一个典型的用例如下，你有一个命令队列，你希望被通知内存传输命令（如 `clEnqueueWriteBuffer`）的状态，并根据该状态采取特定行动：
- en: '[PRE46]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'You can easily extrapolate the scenario where you have a large heterogeneous
    computing environment with large numbers of CPUs and GPUs and obviously you wish
    to maximize your computational power, and the events mechanism in OpenCL allows
    the developer to design how to sequence those computations and coordinate those
    computations. However, as a best practice you probably want to clean up the event
    object associated with the commands, but you need to discover the state of the
    event you''re watching otherwise you might release the event prematurely, and
    here''s how you can do that by polling the API `clGetEventInfo` passing in the
    event you are watching; the following code demonstrates this idea:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以很容易地推断出你有一个大型异构计算环境，有大量的CPU和GPU，显然你希望最大化你的计算能力，OpenCL中的事件机制允许开发者设计如何排序这些计算并协调这些计算。然而，作为最佳实践，你可能希望清理与命令关联的事件对象，但你需要发现你正在观察的事件的状态，否则你可能会提前释放事件，以下是如何通过轮询API
    `clGetEventInfo` 并传入你正在观察的事件来完成这一操作；以下代码演示了这个想法：
- en: '[PRE47]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: There's more…
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: There are two scenarios that deserve mentioning and they address the situation
    where (a) you like to receive notification for a group of events (assuming that
    they are associated to memory objects) and (b) you like to stall the execution
    of any commands further down the pipeline, that is, command-queue, until this
    group of events you are watching for have completed. The API `clEnqueueMarkerWithWaitList`
    is for the former situation whereas `clEnqueueBarrierWithWaitList` suits the latter.
    You are encouraged to explore them in the OpenCL 1.2 specification.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种情况值得提及，它们涉及到（a）你希望为事件组接收通知（假设它们与内存对象相关联）和（b）你希望暂停管道中任何命令的执行，即命令队列，直到你正在观察的这一组事件完成。API
    `clEnqueueMarkerWithWaitList` 用于前者，而 `clEnqueueBarrierWithWaitList` 适用于后者。你被鼓励在OpenCL
    1.2规范中探索它们。
- en: Note
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you are still using OpenCL 1.1, you can use `clEnqueueMarker` and `clEnqueueBarrier`
    (which are the older versions of `clEnqueueMarkerWithWaitList` and `clEnqueueBarrierWithWaitList`)
    but be aware that they are both deprecated in OpenCL 1.2.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仍在使用OpenCL 1.1，你可以使用 `clEnqueueMarker` 和 `clEnqueueBarrier`（它们是 `clEnqueueMarkerWithWaitList`
    和 `clEnqueueBarrierWithWaitList` 的旧版本），但请注意，它们在OpenCL 1.2中都被弃用了。
- en: Copying data between memory objects
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在内存对象之间复制数据
- en: You will quickly realize how useful the event mechanism in OpenCL is in controlling
    the various parts of your algorithm, and it can be found in the common kernel
    and memory commands. This recipe will continue from creating memory objects and
    focus on how those memory objects can be transferred from the host memory to the
    device memory and vice versa and we'll be fixated on the data transfer APIs `clEnqueueReadBuffer`
    and `clEnqueueWriteBuffer`, which is for one-dimensional data blocks, and `clEnqueueReadBufferRect`
    and `clEnqueueWriteBufferRect` for two-dimensional data blocks; we'll also look
    at `clEnqueueCopyBuffer` for data transfers between memory objects in the device.
    First, we look at copying data between memory objects.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 你会很快意识到OpenCL中的事件机制在控制算法的各个部分时是多么有用，它可以在常见的内核和内存命令中找到。本食谱将从创建内存对象开始，重点关注这些内存对象如何从主机内存传输到设备内存，反之亦然，我们将专注于数据传输API
    `clEnqueueReadBuffer` 和 `clEnqueueWriteBuffer`，这是用于一维数据块，以及 `clEnqueueReadBufferRect`
    和 `clEnqueueWriteBufferRect` 用于二维数据块；我们还将查看 `clEnqueueCopyBuffer` 用于设备内存中内存对象之间的数据传输。首先，我们来看一下在内存对象之间复制数据。
- en: 'There will come times when you have to copy data between distinct memory objects,
    and OpenCL provides us a convenient way to do this via `clEnqueueCopyBuffer`.
    It can only take place between two different memory objects (for example, one
    is a plain buffer and the other is a sub-buffer) or between two similar objects
    (for example, both are sub-buffers or plain buffers) and the area of copy cannot
    overlap. Here''s the method signature:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 有时会需要在不同内存对象之间复制数据，OpenCL为我们提供了一个方便的方法，通过 `clEnqueueCopyBuffer` 来实现。这只能发生在两个不同的内存对象之间（例如，一个是普通缓冲区，另一个是子缓冲区）或者两个相似的对象之间（例如，两者都是子缓冲区或普通缓冲区），并且复制的区域不能重叠。以下是方法签名：
- en: '[PRE48]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The list of functions for copying data between memory objects are as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在内存对象之间复制数据的函数列表如下：
- en: '`clEnqueueCopyBuffer`'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clEnqueueCopyBuffer`'
- en: '`clEnqueueCopyImage`'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clEnqueueCopyImage`'
- en: '`clEnqueueCopyBufferToImage`'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clEnqueueCopyBufferToImage`'
- en: '`clEnqueueCopyImageToBuffer`'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clEnqueueCopyImageToBuffer`'
- en: '`clEnqueueCopyBufferRect`'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clEnqueueCopyBufferRect`'
- en: To copy a buffer, you need to indicate the source and destination `cl_mem` objects
    via `src_buffer` and `dst_buffer`, indicate where to start the copying by indicating
    the offsets of the `src_buffer` and `dst_buffer` via `src_offset` and `dst_offset`
    respectively together with the size of data to copy via `cb`. If you wish for
    the copying of the data to take place after some operations, you need to indicate
    the number of those operations and a valid array of `cl_event` objects that represent
    each operation via `num_events_in_wait_list` and `event_wait_list` respectively.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 要复制一个缓冲区，你需要通过 `src_buffer` 和 `dst_buffer` 指示源和目标 `cl_mem` 对象，通过 `src_offset`
    和 `dst_offset` 分别指示 `src_buffer` 和 `dst_buffer` 的偏移量以及要复制的数据大小通过 `cb`。如果你希望在某些操作之后进行数据复制，你需要指示这些操作的数量以及代表每个操作的
    `cl_event` 对象的有效数组，分别通过 `num_events_in_wait_list` 和 `event_wait_list`。
- en: Tip
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Take note that you can query the device on the status of the copying, when your
    data array is large, by passing an event object to the `event` argument. Another
    approach is to enqueue a `clEnqueueBarrier` command.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你可以通过传递事件对象到 `event` 参数来查询设备复制状态，当你的数据数组很大时。另一种方法是排队一个 `clEnqueueBarrier`
    命令。
- en: Getting ready
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: The following code is an extract from `Ch2/copy_buffer/copy_buffer.c`, and it
    illustrates how to enqueue a `clEnqueueCopyBuffer` command to the command queue,
    and the kernel uses this copy of the data for computation. This process is iterated
    among the detected OpenCL devices on the machine. The following diagram illustrates
    how the original data block (previous diagram) is copied to another `cl_mem` object
    (next diagram) and passed off to the OpenCL devices for computation.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是 `Ch2/copy_buffer/copy_buffer.c` 的摘录，它说明了如何将 `clEnqueueCopyBuffer` 命令排队到命令队列中，并且内核使用这个数据副本进行计算。这个过程在机器上检测到的所有OpenCL设备之间迭代。以下图解说明了原始数据块（前一个图）是如何复制到另一个
    `cl_mem` 对象（下一个图）并传递给OpenCL设备进行计算的。
- en: '![Getting ready](img/copy_buffers.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![准备就绪](img/copy_buffers.jpg)'
- en: How to do it…
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We''ve included the main part of this recipe, with the highlighted commentary:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经包括了这个菜谱的主要部分，并带有高亮注释：
- en: '[PRE49]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'On OSX, you can run the following command:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在OSX上，你可以运行以下命令：
- en: '[PRE50]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'On Ubuntu Linux 12.04 with Intel OpenCL SDK installed, you can run the following
    command:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装了Intel OpenCL SDK的Ubuntu Linux 12.04上，你可以运行以下命令：
- en: '[PRE51]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'On Ubuntu Linux 12.04 with NVIDIA CUDA 5 installed, you can run the following
    command:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装了NVIDIA CUDA 5的Ubuntu Linux 12.04上，你可以运行以下命令：
- en: '[PRE52]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: A binary executable named `copy_buffer` will be deposited on the directory.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 一个名为 `copy_buffer` 的二进制可执行文件将被放置在目录中。
- en: 'Depending on how many OpenCL SDKs are installed on your machine, your output
    may vary but on my OSX, the following is the output:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的机器上安装了多少个OpenCL SDK，你的输出可能会有所不同，但在我自己的OSX上，以下是这样的输出：
- en: '[PRE53]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: How it works…
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The application needed to compute the copied buffer, and you can tell this
    because `clSetKernelArg` was defined that way by this statement:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序需要计算复制的缓冲区，你可以通过以下语句定义 `clSetKernelArg` 来判断这一点：
- en: '[PRE54]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Next, we can perform a copy operation, which takes place in the device's memory,
    via `clEnqueueCopyBuffer` and finally retrieve the computed values via `clEnqueueReadBuffer`.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以通过 `clEnqueueCopyBuffer` 执行一个复制操作，该操作发生在设备的内存中，并通过 `clEnqueueReadBuffer`
    最终检索计算出的值。
- en: Tip
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The created command queue will default to in-order execution, instead of out-of-order
    execution so the device will execute the commands in the order of the queueing.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 创建的命令队列将默认为顺序执行，而不是乱序执行，因此设备将按照队列的顺序执行命令。
- en: Now, we are going to talk about the one-dimensional and two-dimensional data
    transfer APIs such as `clEnqueueReadBuffer`, `clEnqueueWriteBuffer`, `clEnqueueWriteBufferRect`,
    and `clEnqueueReadBufferRect` and we are doing this now because you have seen
    that most of our examples, so far, we demonstrated the creation of memory objects
    via `clCreateBuffer` by associating with a memory structure in the host and though
    that might suffice for some situations, you probably want APIs that gives you
    more control when memory objects in the device memory are to be written or read
    from. The control these APIs give you, the developer, is from the fact that they
    are enqueued onto the command-queue with any events the developer might craft;
    and that provides a good permutation of strategies and flexibilities for structuring
    I/O in heterogeneous environments.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将讨论一维和二维数据传输API，如`clEnqueueReadBuffer`、`clEnqueueWriteBuffer`、`clEnqueueWriteBufferRect`和`clEnqueueReadBufferRect`，我们现在这样做是因为你已经看到，到目前为止，我们的大部分示例都是通过`clCreateBuffer`与主机中的内存结构关联来演示内存对象的创建，尽管这可能适用于某些情况，你可能希望有更多控制的API，当设备内存中的内存对象需要写入或读取时。这些API给予开发者的控制，是因为它们被排入命令队列，并带有开发者可能创建的任何事件；这为在异构环境中构建I/O提供了良好的策略和灵活性。
- en: Note
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Be aware that there are similar APIs for reading and writing two or three dimensional
    images to/from host to the device memory. Their names are `clEnqueueReadImage`,
    `clEnqueueWriteImage`, `clEnqueueReadImageRect`, and `clEnqueueWriteImageRect`.
    Refer to the OpenCL 1.2 Specifications for more details.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，有类似的API用于从主机到设备内存读取和写入二维或三维图像。它们的名称是`clEnqueueReadImage`、`clEnqueueWriteImage`、`clEnqueueReadImageRect`和`clEnqueueWriteImageRect`。有关更多详细信息，请参阅OpenCL
    1.2规范。
- en: 'These APIs allows us to indicate to the device when we wish the data transfer
    to occur, very much like `clEnqueueCopyBuffer`. Let''s take a look at their method
    signatures:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这些API允许我们向设备指示我们希望数据传输何时发生，这与`clEnqueueCopyBuffer`非常相似。让我们看看它们的方法签名：
- en: '[PRE55]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: These two functions are very similar to one another, and they basically say
    if you wish to read/write to/from a memory buffer , that is, a `cl_mem` object,
    you need to indicate which command queue is it via `command_queue`, what buffer
    it is via `buffer`, whether to be a blocking-read/write via `blocking_read/blocking_write`,
    where to read/write from for what size via `offset` and `cb`, where to read the
    data or write the data to via `ptr`, should this read/write command occur after
    some events via `num_events_in_wait_list` and `event_wait-list`. The last argument
    in the function is `event`, which allows the reading or writing operation to be
    queried which is described in `clEnqueueCopyBuffer`.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数彼此非常相似，它们基本上说明如果你想要读写内存缓冲区，即`cl_mem`对象，你需要通过`command_queue`指定哪个命令队列，通过`buffer`指定哪个缓冲区，是否为阻塞读写通过`blocking_read/blocking_write`，通过`offset`和`cb`指定从哪里读取/写入什么大小的数据，通过`ptr`指定从哪里读取数据或写入数据到，是否在某个事件之后执行这个读写命令通过`num_events_in_wait_list`和`event_wait-list`。函数的最后一个参数是`event`，它允许查询读取或写入操作，这在`clEnqueueCopyBuffer`中有描述。
- en: Blocking reads in `clEnqueuReadBuffer` means that the command does not exit
    until the host pointer has been filled by the device memory buffer; similarly
    blocking-writes in `clEnqueueWriteBuffer` means that the command doesn't exit
    until the entire device memory buffer has been written to by the host pointer.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在`clEnqueuReadBuffer`中的阻塞读取意味着命令不会退出，直到主机指针被设备内存缓冲区填充；同样，在`clEnqueueWriteBuffer`中的阻塞写入意味着命令不会退出，直到整个设备内存缓冲区被主机指针写入。
- en: 'To see how these calls are used, you can refer to the earlier illustrated code
    in the recipe *Understanding events and event-synchronization* and for your convenience
    the following is the relevant code in `Ch2/events/events.c`:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解这些调用是如何使用的，你可以参考早期示例中的代码，在配方*理解事件和事件同步*中，为了方便起见，以下是在`Ch2/events/events.c`中的相关代码：
- en: '[PRE56]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Having the capability to model one-dimensional memory objects is fantastic,
    but OpenCL goes a notch further by facilitating two-dimensional memory object
    memory transfers.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 能够模拟一维内存对象的能力非常棒，但OpenCL更进一步，通过促进二维内存对象内存传输。
- en: Here is an example of reading a two-dimensional data blocks from the device's
    memory to the output buffer in the host memory; extracted from `Ch2/simple_2d_readwrite/simple_2d_readwrite.c`.
    The code illustrates the usage of the `buffer_origin`, `host_origin`, and `region`
    as in the API. The application will read from the `UDObj cl_mem` object, which
    represents the one-dimensional input data, `hostBuffer`, as a 2 x 2 matrix and
    writes them into the host memory data block represented by `outputPtr`. The application
    reads back the data from the device to host memory and checks for sanity.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个从设备内存读取二维数据块到主机内存输出缓冲区的示例；摘自`Ch2/simple_2d_readwrite/simple_2d_readwrite.c`。代码展示了如何使用`buffer_origin`、`host_origin`和`region`，正如API中所示。应用程序将从表示一维输入数据的`UDObj
    cl_mem`对象中读取，将其作为2 x 2矩阵写入由`outputPtr`表示的主机内存数据块。应用程序将从设备读取数据到主机内存，并检查数据是否合理。
- en: '[PRE57]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: In this example, we used the `for` loop and standard array indexing techniques
    in `C` to model how you might iterate through a two-dimensional array and referencing
    the elements so that we progressively copy the input. We won't dwell too much
    into this because, building and running it is very similar to the previous, and
    you should explore the directory to see how the build and program works via the
    Makefile.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了`C`语言中的`for`循环和标准数组索引技术来模拟如何遍历二维数组并引用元素，以便我们逐步复制输入。我们不会过多地深入这个话题，因为构建和运行它与之前非常相似，你应该探索目录以了解如何通过Makefile构建和运行程序。
- en: Using work items to partition data
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用工作项来分区数据
- en: In the previous chapter, we introduced how work can be partitioned in a one-dimensional
    array across several work items (you should flip back now if you cannot remember),
    and also how each work item would obtain an index in which the kernel can use
    to conduct the computation in the kernel code `vector_multiplication`. In this
    recipe, we are going to build on that by exploring two-dimensional data partitioning
    in more detail.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们介绍了如何在多个工作项之间对一维数组进行分区（如果你现在记不起来的话，应该翻回来看），以及每个工作项将如何获得一个索引，内核可以使用这个索引在内核代码`vector_multiplication`中进行计算。在本食谱中，我们将在此基础上，更详细地探索二维数据分区。
- en: By now, you should realize that one of the cornerstones of OpenCL is getting
    the data into the device/s for processing via kernels, and you've seen how data
    can be partitioned among different devices via kernels. In the former, you've
    seen how we used the distributed array pattern to partition the data among the
    devices; this refers to coarse grain data-parallelism. The latter refers to the
    coarse grained task-parallelism that OpenCL provides and it is coarse grained
    because OpenCL is capable of both data-parallelism and task-parallelism.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你应该意识到OpenCL的一个基石是将数据通过内核传输到设备/进行处理，你已经看到了数据如何通过内核在不同设备之间进行分区。在前者中，你看到了我们如何使用分布式数组模式将数据分区到设备中；这指的是粗粒度数据并行性。后者指的是OpenCL提供的粗粒度任务并行性，它之所以是粗粒度的，是因为OpenCL既能实现数据并行性，也能实现任务并行性。
- en: Most of the code you've seen so far have been using `clEnqueueTask` to execute
    the kernel based on the one-dimensional data blocks and to get your kernel to
    process two or three dimensional data we need to understand `clEnqueueNDRangeKernel`;
    and how data can be laid out conceptually in two or three dimensional space.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 你到目前为止看到的代码大部分都使用了`clEnqueueTask`来根据一维数据块执行内核，并且为了让内核处理二维或三维数据，我们需要理解`clEnqueueNDRangeKernel`；以及如何在二维或三维空间中概念性地布局数据。
- en: Tip
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: It is helpful to visualize the two or three dimensional data layout in the device
    memory to be row-based instead of column-based.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在设备内存中可视化二维或三维数据布局为基于行而不是基于列是有帮助的。
- en: The `NDRange` in `clEnqueueNDRangeKernel` refers to a data indexing scheme that
    is supposed to span an N-dimensional range of values and hence, the given name.
    Currently, *N* in this N-dimensional index space can be one, two, or three. Next,
    we can split each dimensional into chunks of sizes two, three, four, or more till
    we reached the maximum allowable by the parameter `CL_DEVICE_MAX_WORK_ITEM_DIMENSIONS`.
    Refer to the `Ch1/device_details/device_details.c` on how to obtain the values.
    This would decide how many processing groups we can run in parallel, and in OpenCL
    they are called **work groups**. The work groups would have a number of available
    processing elements that are called **work items** though I like to think of them
    as executable threads.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`clEnqueueNDRangeKernel`中的`NDRange`指的是一种数据索引方案，它应该跨越一个N维值的范围，因此得名。目前，在这个N维索引空间中，*N*可以是1、2或3。接下来，我们可以将每个维度分成大小为2、3、4或更大的块，直到达到参数`CL_DEVICE_MAX_WORK_ITEM_DIMENSIONS`允许的最大值。有关如何获取值的说明，请参阅`Ch1/device_details/device_details.c`。这将决定我们可以并行运行多少个处理组，在OpenCL中它们被称为**工作组**。工作组将有一些可用的处理单元，这些单元被称为**工作项**，尽管我喜欢把它们看作是可执行的线程。'
- en: 'Let''s work through an example using a two-dimensional data size of 12 rows
    by 12 columns, that is, a 12 x 12 matrix. Let''s look at the following diagram
    to understand how the work groups and work items are related to one another:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来理解，使用12行12列的二维数据大小，即一个12 x 12的矩阵。让我们看一下以下图表，以了解工作组和工作项之间的关系：
- en: '![Using work items to partition data](img/work_partition.jpg)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![使用工作项划分数据](img/work_partition.jpg)'
- en: 'In this example, I''ve decided to partition the two-dimensional space to create
    nine work groups where each work group is a 4 x 4 matrix. Next, to decide how
    many work items there should be in each work group, and you have two choices:
    a) assign one work-item to process each cell in your 4 x 4 matrix, b) assign one
    work item to process n-cells in your 4 x 4 matrix; in the second option it would
    be similar to vector processing where n-values are loaded together for the work
    item to process. Let''s assume that we''ve decided to choose the option a'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我决定将二维空间划分为九个工作组，其中每个工作组是一个4 x 4的矩阵。接下来，为了决定每个工作组中应该有多少个工作项，你有两个选择：a)
    将一个工作项分配给处理4 x 4矩阵中的每个单元格，b) 将一个工作项分配给处理4 x 4矩阵中的n个单元格；在第二种情况下，它类似于向量处理，其中n个值一起加载以供工作项处理。让我们假设我们已经决定选择选项a
- en: Tip
  id: totrans-261
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: We'll look at the various data types in the [Chapter 3](ch03.html "Chapter 3. Understanding
    OpenCL Data Types"), *Understanding OpenCL Data Types*.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第3章](ch03.html "第3章。理解OpenCL数据类型")中查看各种数据类型，*理解OpenCL数据类型*。
- en: 'At this time, let''s take a detailed look at the API `clEnqueueNDRangeKernel`
    with the following method signature, and understand how to input those values
    with our example:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们详细看看API `clEnqueueNDRangeKernel`及其以下方法签名，并了解如何通过我们的例子输入这些值：
- en: '[PRE58]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Let's look at what those variables in `clEnqueueNDRangeKernel` are for; the
    `command_queue` refers to the particular queue like the `kernel`, to execute on.
    Next, you need to indicate how many dimensions your input data has via `work_dim`;
    the next two variables `global_work_size` and `local_work_size` would indicate
    how many work groups there are and how many work items / work threads can execute
    in each work group. Recall that the kernel gets scheduled on the device, but it
    is the work group that gets assign compute units of the device and the work items
    execute on the processing element in the compute unit. Next, if you need the launch
    of the kernel to wait on a couple of events in your algorithm, you can indicate
    them through `num_events_in_wait_list` and `event_wait_list`, and finally if you
    wish to associate an event to this kernel's state you can pass in an event type
    to `event` in this API.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`clEnqueueNDRangeKernel`中的那些变量是用来做什么的；`command_queue`指的是特定的队列，如`kernel`，用于执行。接下来，你需要通过`work_dim`指示你的输入数据有多少维；接下来的两个变量`global_work_size`和`local_work_size`将指示有多少个工作组以及每个工作组中可以执行多少个工作项/工作线程。回想一下，内核在设备上被调度，但工作组会分配设备的计算单元，工作项在计算单元的处理器上执行。接下来，如果你需要内核的启动等待算法中的几个事件，你可以通过`num_events_in_wait_list`和`event_wait_list`来指示它们，最后，如果你希望将事件关联到这个内核的状态，你可以通过这个API中的`event`传递一个事件类型。
- en: 'The method signature should not look that intimidating to you by now. Given
    a 12 x 12 matrix partitioned into nine work groups where each work group is a
    4 x 4 matrix and each work item will process one data cell, we will code it like
    the following code snippet:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，方法签名不应该让你感到那么令人生畏。给定一个12 x 12的矩阵，划分为九个工作组，其中每个工作组是一个4 x 4的矩阵，每个工作项将处理一个数据单元格，我们将像以下代码片段那样编写代码：
- en: '[PRE59]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'To ensure you have got your calculations correct, you can use the following
    simple formula:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保你的计算正确，你可以使用以下简单的公式：
- en: Tip
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Number of work-groups = (global_work_size[0]*…*global_work_size[n-1]) / (local_work_size[0]*…*local_work_size[n-1])
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 工作组数量 = (global_work_size[0]*…*global_work_size[n-1]) / (local_work_size[0]*…*local_work_size[n-1])
- en: Next, we are going to take a look at how we can enable this task-parallelism
    and data-parallelism to be processed by the CPU and GPU where each device will
    copy a one-dimensional data array from the input buffer and treat it like a two-dimensional
    matrix for parallel computing, and finally output the results to a one-dimensional
    matrix.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看看如何使这项任务并行和数据并行能够由CPU和GPU处理，其中每个设备将从输入缓冲区复制一个一维数据数组，并将其视为二维矩阵进行并行计算，最后将结果输出到一个一维矩阵中。
- en: Getting ready
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In `Ch2/work_partition/work_partition.c`, we saw an excerpt where we need to
    copy a million elements from an input buffer to an output buffer using a two-dimensional
    data format. We proceed to partition the data into a 1024 x 1024 matrix where
    each work item processes a single cell and we create work groups of the size 64
    x 2 matrix.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Ch2/work_partition/work_partition.c` 中，我们看到了一个摘录，其中我们需要使用二维数据格式从输入缓冲区复制一百万个元素到输出缓冲区。我们继续将数据划分为一个1024
    x 1024的矩阵，其中每个工作项处理一个单元格，我们创建大小为64 x 2矩阵的工作组。
- en: Tip
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Caveat—during my experimentation, this program crashed when executing on the
    OSX 10.6 Intel Core i5 with OpenCL 1.0 as the work group can only be of size one
    in each dimension. We'll look in the [Chapter 3](ch03.html "Chapter 3. Understanding
    OpenCL Data Types"), *Understanding OpenCL Data Types* on how to make our programs
    more portable.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 注意——在我的实验中，这个程序在运行OSX 10.6 Intel Core i5和OpenCL 1.0时崩溃了，因为在每个维度上工作组只能有一个大小。我们将在第3章
    [理解OpenCL数据类型](ch03.html "Chapter 3. Understanding OpenCL Data Types") 中探讨如何使我们的程序更具可移植性。
- en: The kernel function, `copy2Dfloat4` is a typical function which is executed
    on the device and we like to express the idea of transferring a vector of elements
    from one point to another and once that's done, the application will conduct a
    data sanity check which will pass or fail the program; Refer to the `Ch2/work_partition/work_partition.cl`.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 内核函数 `copy2Dfloat4` 是一个典型的在设备上执行的功能，我们希望表达从一点到另一点传输元素向量的想法，一旦完成，应用程序将进行数据完整性检查，这将使程序通过或失败；请参阅
    `Ch2/work_partition/work_partition.cl`。
- en: How to do it…
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We''ve included the main part of this recipe, with the highlighted commentary
    in the following code:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在以下代码中包含了这个菜谱的主要部分，并突出显示了注释：
- en: '[PRE60]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'On OSX, you can run the following command:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在OSX上，你可以运行以下命令：
- en: '[PRE61]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'On Ubuntu Linux 12.04 with Intel OpenCL SDK installed, you can run the following
    command:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装了Intel OpenCL SDK的Ubuntu Linux 12.04上，你可以运行以下命令：
- en: '[PRE62]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'On Ubuntu Linux 12.04 with NVIDIA CUDA 5 installed, you can run the following
    command:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装了NVIDIA CUDA 5的Ubuntu Linux 12.04上，你可以运行以下命令：
- en: '[PRE63]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: A binary executable named `work_partition` will be deposited on the directory.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 一个名为 `work_partition` 的二进制可执行文件将被存放在目录中。
- en: 'On Ubuntu Linux 12.04 with AMD APP SDK v2.8 and NVIDIA CUDA 5 installed, I
    have the following output. If you ran the program using the Intel® OpenCL SDK,
    then you will not see the output related to the discrete graphics chip. In this
    example, we have demonstrated both coarse-grained and fine-grained data and task
    parallelism:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装了AMD APP SDK v2.8和NVIDIA CUDA 5的Ubuntu Linux 12.04上，我得到了以下输出。如果你使用Intel®
    OpenCL SDK运行了程序，那么你将不会看到与离散图形芯片相关的输出。在这个例子中，我们展示了粗粒度和细粒度的数据以及任务并行：
- en: '[PRE64]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: How it works…
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The host application allocates two buffers that are capable of storing a million
    elements of the data type `cl_float4`, which is a OpenCL `vector` data type. Next
    we proceed to build the program via `clBuildProgramWithSource` (refer to `Ch2/work_partition/work_partition.c`),
    and pick up all the kernels in the kernel file (`*.cl`). Each detected device
    will pick up a one-dimensional input buffer, transform it to a two-dimensional
    matrix, and partition the data among its parallel computing units where each work
    group will compute the following:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 主应用程序分配了两个缓冲区，可以存储一百万个`cl_float4`类型的数据元素，这是一种OpenCL的`vector`数据类型。接下来，我们通过`clBuildProgramWithSource`（参考`Ch2/work_partition/work_partition.c`）构建程序，并从内核文件（`*.cl`）中提取所有内核。每个检测到的设备都会提取一个一维输入缓冲区，将其转换为二维矩阵，并将数据分配到其并行计算单元中，其中每个工作组将计算以下内容：
- en: Obtain the index for the row via `get_global_id(0)`; which can be thought of
    as the thread's ID in the x-axis
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`get_global_id(0)`获取行的索引；这可以被视为x轴上的线程ID
- en: Obtain the index for the column via `get_global_id(1)`; which can be thought
    of as the thread's ID in the y-axis
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`get_global_id(1)`获取列的索引；这可以被视为y轴上的线程ID
- en: Together with the row and column indexes, perform a memory load of 4 elements
    and store the same via `C(x,y) = A(x,y)`
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与行和列索引一起，执行4个元素的内存加载，并通过`C(x,y) = A(x,y)`将其存储。
- en: The OpenCL runtime would have partition the data among the work groups, together
    with the IDs for the work items as well as work groups; hence there would not
    be a situation where the thread IDs being duplicated and hence waging mayhem on
    the computation (the OpenCL vendor has that responsibility of ensuring it doesn't
    occur). OpenCL knows how to do this because the dimensions of the input data,
    together with the number of work groups and number of executing work items are
    passed via the parameters `work_dim`, `global_work_size`, and `local_work_size`
    in the `clEnqueueNDRangeKernel` API.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCL运行时会将数据分配到工作组中，同时还包括工作项和工作组的ID；因此，不会出现线程ID重复的情况，从而避免对计算造成混乱（OpenCL供应商有责任确保这种情况不会发生）。OpenCL知道如何做到这一点，因为输入数据的维度、工作组的数量以及执行的工作项的数量都是通过`clEnqueueNDRangeKernel`
    API中的`work_dim`、`global_work_size`和`local_work_size`参数传递的。
- en: 'An example should clarify this: Assume that the imaginary input data has two-dimensions
    and the `global_work_size` is 8192 and `local_work_size` is 16*16, then we will
    have 8192/(16*16) = 32 work groups; to be able to reference any element in a two-dimensional
    data block, you will write some code similar to this to generate the global thread
    ID in (this is not the only way to do this, but it is the generally preferred
    method):'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例来澄清这一点：假设假设的输入数据具有二维，`global_work_size`为8192，`local_work_size`为16*16，那么我们将有32个工作组；为了能够引用二维数据块中的任何元素，你需要编写一些类似的代码来生成全局线程ID（这不是唯一的方法，但通常是首选方法）：
- en: '[PRE65]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The OpenCL kernel will complete its computation eventually because of an invocation
    to `clWaitForEvents` (we'll talk about this in the next chapter), and then the
    output buffer is stored with data from the device memory via `clEnqueueReadBuffer`
    and the data is sanity checked.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 由于调用了`clWaitForEvents`（我们将在下一章中讨论这一点），OpenCL内核最终将完成其计算，然后通过`clEnqueueReadBuffer`将设备内存中的数据存储到输出缓冲区，并对数据进行合理性检查。
