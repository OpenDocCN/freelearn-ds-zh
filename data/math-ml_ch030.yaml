- en: '18'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '18'
- en: What is Probability?
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是概率？
- en: When going about our lives, we almost always think in binary terms. A statement
    is either true or false. An outcome has either occurred or not.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们日常生活中，我们几乎总是以二元的方式来思考。一个陈述要么为真，要么为假。一个结果要么已经发生，要么没有发生。
- en: In practice, we rarely have the comfort of certainty. We have to operate with
    incomplete information. When a scientist observes the outcome of an experiment,
    can they verify their hypothesis with 100% certainty? No. Because they do not
    have complete control over all the variables (such as the weather or the alignment
    of stars), the observed effect might be unintentional. Each result will either
    strengthen or weaken our belief in the hypothesis, but none will provide ultimate
    proof.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，我们很少能够拥有绝对的确定性。我们必须在不完全的信息下操作。当科学家观察实验结果时，他们能以 100% 的确定性验证自己的假设吗？不能。因为他们无法完全控制所有变量（如天气或星星的排列），观察到的效果可能是偶然的。每个结果要么增强，要么削弱我们对假设的信心，但没有结果能提供最终的证明。
- en: In machine learning, our job is not simply to provide a prediction about some
    class label but to formulate a mathematical model that summarizes our knowledge
    about the data in a way that conveys information about the degree of our certainty
    in the prediction.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在机器学习中，我们的工作不仅仅是对某个类别标签进行预测，而是构建一个数学模型，总结我们对数据的理解，并以一种能够传达我们对预测准确度的信心的方式来表达。
- en: 'So, fitting a parametric function f : ℝ^n →ℝ^m to model the relation between
    the data and the variable to be predicted is not enough. We will need an entirely
    new vocabulary to formulate such models. We need to think in terms of probabilities.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '因此，拟合一个参数化函数 f : ℝ^n →ℝ^m 来建模数据与要预测变量之间的关系是不够的。我们需要一个全新的词汇来表达这样的模型。我们需要从概率的角度来思考。'
- en: 18.1 The language of thinking
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 18.1 思维的语言
- en: First, let’s talk about how we think. On the most basic level, our knowledge
    about the world is stored in propositions. In a mathematical sense, a proposition
    is a declaration that is either true or false. (In binary terms, true is denoted
    by 1 and false is denoted by 0.)
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们谈谈我们是如何思考的。从最基本的层面来看，我们对世界的知识存储在命题中。从数学角度来看，命题是一个要么为真，要么为假的声明。（在二进制的术语中，真用
    1 表示，假用 0 表示。）
- en: “The sky is blue.”
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: “天空是蓝色的。”
- en: “There are infinitely many prime numbers.”
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: “质数是无限多的。”
- en: “1 + 1 = 3.”
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: “1 + 1 = 3。”
- en: “I got the flu.”
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: “我得了流感。”
- en: Propositions are often abbreviated as variables such as A = ”it’s raining outside”.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 命题通常被缩写为变量，例如 A = “外面在下雨”。
- en: Determining the truth value of a given proposition using evidence and reasoning
    is called inference. To be able to formulate valid arguments and understand how
    inference works, we’ll take a quick visit to the world of mathematical logic.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 使用证据和推理来确定给定命题的真值被称为推理。为了能够制定有效的论证并理解推理是如何工作的，我们将简要了解一下数学逻辑的世界。
- en: 18.1.1 Thinking in absolutes
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 18.1.1 绝对思维
- en: 'So, we have propositions such as A = ”it’s raining outside” or B = ”the sidewalk
    is wet”. We need more expressive power: propositions are building blocks, and
    we want to combine them, yielding more complex propositions. (We’ll review the
    fundamentals of mathematical logic here, but check out Appendix [A](ch035.xhtml#its-just-logic)
    for more.)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有命题，例如 A = “外面在下雨” 或 B = “人行道是湿的”。我们需要更多的表达能力：命题是构建块，我们想要将它们组合起来，得到更复杂的命题。（我们将在这里回顾数学逻辑的基础知识，但请查看附录
    [A](ch035.xhtml#its-just-logic) 获取更多信息。）
- en: We can formulate complex propositions from simpler ones with logical connectives.
    Consider the proposition “if it is raining outside, then the sidewalk is wet”.
    This is the combination of A and B, strung together by the implication connective.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过逻辑连接词将简单命题构造为复杂命题。考虑命题“如果外面下雨，则人行道是湿的”。这是 A 和 B 的结合，通过蕴含连接词串联在一起。
- en: 'There are four essential connectives:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 有四个基本的连接词：
- en: NOT (¬), also known as negation,
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NOT (¬)，也称为否定，
- en: AND ( ∧), also known as conjunction,
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AND ( ∧)，也称为合取，
- en: OR (∨), also known as disjunction,
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OR (∨)，也称为析取，
- en: THEN (→), also known as implication.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: THEN (→)，也称为蕴含。
- en: 'Connectives are defined by the truth values of the resulting propositions.
    For instance, if A is true, then ¬A is false; if A is false, then ¬A is true.
    Denoting true by 1 and false by 0, we can describe connectives with truth tables.
    Here is the one for negation:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 连接词通过结果命题的真值来定义。例如，如果 A 为真，则 ¬A 为假；如果 A 为假，则 ¬A 为真。用 1 表示真，用 0 表示假，我们可以通过真值表来描述连接词。以下是否定的真值表：
- en: '![| | | |A-|¬A--| |0 | 1 | | | | |1 | 0 | | | ](img/file1606.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![| | | |A-|¬A--| |0 | 1 | | | | |1 | 0 | | | ](img/file1606.png)'
- en: AND (∧) and OR (∨) connect two propositions. A ∧B is true if both A and B are
    true, while A ∨B is true if either one is.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: AND (∧) 和 OR (∨) 用来连接两个命题。如果 A ∧B 为真，那么 A 和 B 都必须为真；如果 A ∨B 为真，那么 A 或 B 中至少有一个为真。
- en: '![| | | | | |A-|B--|A-∧-B--|A-∨-B-| |0 | 0 | 0 | 0 | | | | | | |0 | 1 | 0 |
    1 | |1 | 0 | 0 | 1 | | | | | | |1 | 1 | 1 | 1 | | | ](img/file1607.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![| | | | | |A-|B--|A-∧-B--|A-∨-B-| |0 | 0 | 0 | 0 | | | | | | |0 | 1 | 0 |
    1 | |1 | 0 | 0 | 1 | | | | | | |1 | 1 | 1 | 1 | | | ](img/file1607.png)'
- en: 'The implication connective THEN (→) formalizes the deduction of a conclusion
    B from a premise A. By definition, A →B is true if B is true or both A and B are
    false. An example: IF “it’s raining outside”, THEN “the sidewalk is wet”.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 连接词 THEN (→) 形式化了从前提 A 推导结论 B 的过程。根据定义，A →B 在 B 为真或 A 和 B 都为假时为真。举个例子：“如果外面在下雨”，那么“人行道是湿的”。
- en: '![| | | | |A--|B-|A--→-B--| | 0 |0 | 1 | | | | | | 0 |1 | 1 | | 1 |0 | 0 |
    | | | | | 1 |1 | 1 | | | ](img/file1608.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![| | | | |A--|B-|A--→-B--| | 0 |0 | 1 | | | | | | 0 |1 | 1 | | 1 |0 | 0 |
    | | | | | 1 |1 | 1 | | | ](img/file1608.png)'
- en: 'Note that A →B does not imply B →A. This common logical fallacy is called affirming
    the consequent, and we’ve all fallen victim to it at some point in our lives.
    To see a concrete example: if “it’s raining outside”, then “the sidewalk is wet”,
    but not the other way around. The sidewalk can be wet for other reasons, such
    as someone spilling a barrel of water.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，A →B 并不意味着 B →A。这种常见的逻辑谬误被称为肯定后件，我们在生活中都曾经陷入过这种错误。举个具体的例子：“外面在下雨”可以推出“人行道是湿的”，但反过来就不成立。人行道也可以因为其他原因变湿，例如有人打翻了一桶水。
- en: Connectives correspond to set operations. Why? Let’s take a look at the formal
    definition of set operations.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 连接词与集合运算相对应。为什么？让我们来看看集合运算的正式定义。
- en: Definition 75\. (The (reasonably) formal definition of set operations and relations)
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 75. （集合运算与关系的（合理的）正式定义）
- en: Let A and B be two sets.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 设 A 和 B 为两个集合。
- en: (a) The union of A and B is defined by
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: (a) A 和 B 的并集定义为
- en: '![A ∪ B := {x : (x ∈ A )∨ (x ∈ B )}, ](img/file1609.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![A ∪ B := {x : (x ∈ A )∨ (x ∈ B )}, ](img/file1609.png)'
- en: that is, A ∪B contains all elements that are in A or B.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 即 A ∪B 包含所有在 A 或 B 中的元素。
- en: (b) The intersection of A and B is defined by
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: (b) A 和 B 的交集定义为
- en: '![A ∩ B := {x : (x ∈ A )∧ (x ∈ B )}, ](img/file1610.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![A ∩ B := {x : (x ∈ A )∧ (x ∈ B )}, ](img/file1610.png)'
- en: that is, A ∩B contains all elements that are in A and B.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 即 A ∩B 包含所有既在 A 又在 B 中的元素。
- en: (c) We say that A is a subset of B, that is, A ⊆B if
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: (c) 我们说 A 是 B 的子集，即 A ⊆B，当且仅当
- en: '![(x ∈ A ) → (x ∈ B ) ](img/file1611.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![(x ∈ A ) → (x ∈ B ) ](img/file1611.png)'
- en: is true for all x ∈A.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有 x ∈A，命题成立。
- en: (d) The complement of A with respect to an Ω ⊃A is defined by
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: (d) A 相对于 Ω ⊃A 的补集定义为
- en: '![Ω ∖A := {x ∈ Ω : ¬ (x ∈ A )}, ](img/file1612.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![Ω ∖A := {x ∈ Ω : ¬ (x ∈ A )}, ](img/file1612.png)'
- en: that is, Ω ∖A contains all elements that are in Ω, but not in A.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 即 Ω ∖A 包含所有在 Ω 中但不在 A 中的元素。
- en: If you carefully read through the definitions, you can see how connectives and
    set operations relate. ∧ is intersection, ∨ is union, ¬ is the complement, and
    → is the subset relation. This is illustrated by Figure [18.1](#). (I’ve slightly
    abused the notation here, as statements such as A ∧B ⟺ A ∩B are mathematically
    incorrect. A and B cannot be a proposition and a set at the same time, thus the
    equivalence is not precise. )
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细阅读这些定义，你会发现连接词和集合运算之间的关系。∧ 是交集，∨ 是并集，¬ 是补集，→ 是子集关系。这在图 [18.1](#) 中有所说明。（在这里我稍微滥用了符号，因为像
    A ∧B ⟺ A ∩B 这样的表达式在数学上是不正确的。A 和 B 不能同时是命题和集合，因此这个等式并不精确。）
- en: '![PIC](img/file1613.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file1613.png)'
- en: 'Figure 18.1: Connectives and set operations'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.1：连接词和集合运算
- en: Why is this important? Because probability operates on sets, and sets play the
    role of propositions. We’ll see this later, but first, let’s dive deep into how
    mathematical logic formalizes scientific thinking.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么这很重要？因为概率作用于集合，而集合充当命题的角色。我们稍后会讨论这个问题，但首先，让我们深入了解数学逻辑如何形式化科学思维。
- en: Let’s refine the inference process of mathematical logic. A proposition is either
    true or false, fair and square. How can we determine that in practice? For example,
    how do we find the truth value of the proposition “there are infinitely many prime
    numbers“?
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们细化数学逻辑的推理过程。一个命题要么为真，要么为假，公平而明确。那么我们如何在实际中确定这一点呢？例如，我们如何找到命题“素数有无穷多个”的真值呢？
- en: 'By using evidence and deduction. Like Sherlock Holmes solving a crime by connecting
    facts, we rely on knowledge of the form “if A, then B“. Our knowledge about the
    world is stored in true implications. For example:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用证据和推理。就像福尔摩斯通过连接事实来破案一样，我们依赖于形式为“如果A，则B”的知识。我们对世界的知识是通过真实的蕴含存储的。例如：
- en: “If it is raining, then the sidewalk is wet.“
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “如果下雨，那么人行道会湿。”
- en: “If ![ABC ](img/file1614.png) is a right triangle, then A² + B² = C².“
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “如果![ABC](img/file1614.png)是一个直角三角形，那么A² + B² = C²。”
- en: “If a system is closed, then its entropy cannot decrease.“
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “如果一个系统是封闭的，那么它的熵不能减少。”
- en: As we have seen, the implication can be translated into the language of set
    theory (as all the other connectives). While ∧ corresponds to intersection and
    ∨ to union, the implication is the subset relation. Keep this in mind, as it’s
    going to be important.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，蕴含可以转化为集合论的语言（和其他所有连接词一样）。其中，∧对应交集，∨对应并集，而蕴含则是子集关系。记住这一点，因为它非常重要。
- en: 'During inference, we use implications in the following way:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在推理过程中，我们以以下方式使用蕴含：
- en: If A, then B.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果A，那么B。
- en: A.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: A。
- en: Therefore, B.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，B。
- en: 'This is called the modus ponens. If it sounds abstract, here is a concrete
    example:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为“假言推理”（modus ponens）。如果听起来有些抽象，下面是一个具体的例子：
- en: If it is raining, the sidewalk is wet.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果下雨，人行道是湿的。
- en: It is raining.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正在下雨。
- en: Therefore, the sidewalk is wet.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，人行道是湿的。
- en: 'Thus, we can infer the state of the sidewalk without looking at it. This is
    bigger than it sounds: modus ponens is a cornerstone of scientific thinking. We
    would still be living in caves without it. Modus ponens enables us to build robust
    skyscrapers of knowledge.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以在不查看人行道的情况下推断出它的状态。这比听起来更重要：假言推理是科学思维的基石。没有它，我们仍然会生活在洞穴里。假言推理使我们能够建立起强大的知识大厦。
- en: However, it’s not all perfect. Classical deductive logic might help to prove
    the infinity of prime numbers, but it fails spectacularly when confronted with
    inference problems outside the realms of mathematics and philosophy.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不完美。经典的演绎逻辑可能有助于证明素数的无穷性，但当面对数学和哲学以外的推理问题时，它会失败得很惨。
- en: 'Classical logic has a fatal flaw: it is unable to deal with uncertainty. Think
    about the simple proposition “it is raining outside”. If we are unable to actually
    observe the weather but have some indirect evidence (such as the fact that the
    sidewalk is wet, or the sky is cloudy, or it’s autumn out there), “it is raining
    outside” is probable but not certain.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 经典逻辑有一个致命的缺陷：它无法处理不确定性。想想这个简单的命题“外面在下雨”。如果我们无法实际观察天气，但有一些间接证据（比如人行道是湿的，或者天空多云，或者外面是秋天），那么“外面在下雨”是可能的，但不是确定的。
- en: We need a tool to measure the truth value on a 0 − 1 scale. This is where probabilities
    come in.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个工具来在0到1的范围内衡量真值。这就是概率派上用场的地方。
- en: 18.1.2 Thinking in probabilities
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 18.1.2 概率思维
- en: In a mathematical sense, probability is a function that assigns a numerical
    value between zero and one to various sets that represent events. (You can think
    of events as propositions.) Events are subsets of the event space, often denoted
    with the capital Greek letter omega (Ω). This is illustrated in Figure [18.2](#).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 从数学角度来看，概率是一个将介于零和一之间的数值分配给代表事件的各个集合的函数。（你可以把事件看作是命题。）事件是事件空间的子集，通常用大写希腊字母欧米伽（Ω）表示。图[18.2](#)展示了这一点。
- en: '![PIC](img/file1615.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file1615.png)'
- en: 'Figure 18.2: Events and the event space'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.2：事件与事件空间
- en: 'This sounds quite abstract, so let’s see a simple example: rolling a fair six-sided
    dice. We can encode all possible outcomes with the event space Ω = {1,2,3,4,5,6}.
    Events such as A = ”the outcome is even” or B = ”the outcome is larger than 3”
    are represented by the sets'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来相当抽象，让我们看看一个简单的例子：掷一个公平的六面骰子。我们可以用事件空间Ω = {1,2,3,4,5,6}来编码所有可能的结果。像A = “结果是偶数”或B
    = “结果大于3”这样的事件，可以通过集合表示为
- en: '![A = {2,4,6}, B = {4,5,6}. ](img/file1616.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![A = {2,4,6}, B = {4,5,6}. ](img/file1616.png)'
- en: 'As the dice is fair, the probability of each outcome is the same:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 由于骰子是公平的，每个结果的概率是相同的：
- en: '![ 1- P ({1}) = ⋅⋅⋅ = P({6}) = 6\. ](img/file1617.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![ 1- P ({1}) = ⋅⋅⋅ = P({6}) = 6\. ](img/file1617.png)'
- en: 'There are two properties that make such a function P a proper measure of probability:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个属性使得这样的函数P成为一个合适的概率度量：
- en: the probability of the event space is one,
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 事件空间的概率是1，
- en: and the probability of the union of disjoint events is the sum of probabilities.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不相交事件的并集的概率是各个事件概率之和。
- en: In our dice-rolling example, this is translated to, for instance,
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的掷骰子例子中，这可以转化为例如
- en: '![P (the outcome is even) = P({2,4,6}) = P({2}) + P({4}) + P({6}) 1 1 1 = --+
    --+ -- 6 6 6 = 1\. 2 ](img/file1618.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![P (结果为偶数) = P({2,4,6}) = P({2}) + P({4}) + P({6}) 1 1 1 = --+ --+ -- 6 6
    6 = 1\. 2 ](img/file1618.png)'
- en: We’ll talk about these properties extensively in the next section. As logical
    connectives can be represented in the language of set theory, set operations translate
    the semantics of logic into probabilities. Intersection is joint occurrence of
    events. Union is the occurrence of either one.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节中详细讨论这些性质。由于逻辑连接词可以用集合论语言表示，集合运算将逻辑的语义转化为概率。交集表示事件的联合发生，联集表示任一事件的发生。
- en: '![PIC](img/file1619.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file1619.png)'
- en: 'Figure 18.3: The probabilities of intersection and union'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.3：交集和并集的概率
- en: In this way, we are able to build models involving uncertainty and develop a
    calculus to work with said models. In the Tower of Babel that is mathematics,
    statistics deals with the modeling part, and probability theory deals with the
    calculus part.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们能够构建涉及不确定性的模型，并发展出一种微积分来操作这些模型。在数学的“巴别塔”中，统计学处理建模部分，而概率论处理微积分部分。
- en: Even technically well-trained engineers conflate modeling and working with models.
    For instance, when we talk about flipping fair coins, the probability of heads
    and tails are both 1∕2\. Even when we are absolutely sure about the model but
    have ten heads in a row, most would immediately jump to the conclusion that our
    coin is biased.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是技术上训练有素的工程师也常常混淆建模和使用模型。例如，当我们讨论抛公平硬币时，正反面朝上的概率都是1∕2。即使我们对模型完全确信，但如果连续十次都是正面，许多人也会立即得出结论：我们的硬币是有偏的。
- en: To make sure we are not making this mistake, first, we are going to learn what
    probability is.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们不犯这个错误，首先我们要学习概率是什么。
- en: 18.2 The axioms of probability
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 18.2 概率公理
- en: 'In the previous section, we have talked about probability as an extension of
    mathematical logic. Just like formal logic, probability has its axioms, which
    we need to understand to work with probability models. Now, we are going to seek
    the answer to a fundamental question: what is the mathematical model of probability
    and how do we work with it?'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们已经讨论了概率作为数学逻辑的扩展。就像形式逻辑一样，概率也有它的公理，我们需要理解这些公理才能使用概率模型。现在，我们要回答一个基本问题：概率的数学模型是什么，我们如何与它打交道？
- en: Probabilities are defined in the context of experiments and outcomes. To talk
    about probabilities, we need to define what we assign probabilities to. Formally
    speaking, we denote the probability of the event A by P(A). First, we’ll talk
    about what events are.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 概率是在实验和结果的背景下定义的。要讨论概率，我们需要定义我们将概率赋予什么。正式来说，我们用P(A)表示事件A的概率。首先，我们将讨论什么是事件。
- en: 18.2.1 Event spaces and σ-algebras
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 18.2.1 事件空间和σ-代数
- en: 'Let’s revisit the six-sided example from the previous section. There are six
    different mutually exclusive outcomes (that is, events that cannot occur at the
    same time), and together they form the event space, denoted by Ω:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下前一节中的六面骰子示例。这里有六种不同的互斥结果（也就是说，无法同时发生的事件），它们共同构成事件空间，记作Ω：
- en: '![Ω := {1,2,3,4,5,6}. ](img/file1620.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![Ω := {1,2,3,4,5,6}. ](img/file1620.png)'
- en: In general, the event space is the collection of all mutually exclusive outcomes.
    It can be any set.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，事件空间是所有互斥结果的集合。它可以是任何集合。
- en: What kind of events can we assign probabilities to? Obviously, the individual
    outcomes come to mind. However, we can think of events such as “the result is
    an odd number”, “the result is 2 or 6”, or “the result is not 1”. Following this
    logic, our expectations are that for any two events A and B,
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为哪些类型的事件赋予概率？显然，个别的结果是我们首先想到的。然而，我们也可以考虑像“结果是奇数”、“结果是2或6”或“结果不是1”这样的事件。根据这个逻辑，我们的预期是，对于任何两个事件A和B，
- en: “A or B”,
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “A或B”，
- en: “A and B”,
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “A和B”，
- en: and “not A”
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 和“非A”
- en: are events as well. These can be translated to the language of set theory and
    are formalized by the notion of σ-algebras.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这些也是事件。它们可以转化为集合论的语言，并通过σ-代数的概念进行形式化。
- en: Definition 76\.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 定义76\。
- en: (σ-algebras)
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: （σ-代数）
- en: 'Let Ω be an event space. A collection of its subsets Σ ⊆ 2^Ω is called an σ-algebra
    over Ω if the following properties hold:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 设Ω为一个事件空间。如果Ω的子集的集合Σ ⊆ 2^Ω满足以下条件，那么称Σ为Ω上的σ-代数：
- en: (a) Ω ∈ Σ. (That is, the set of all outcomes is an event.)
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: (a) Ω ∈ Σ。（也就是说，所有结果的集合是一个事件。）
- en: (b) For all A ∈ Σ, the set Ω∖A is also an element of Σ. (That is, σ-algebras
    are closed to complements.)
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: (b) 对于所有A ∈ Σ，集合Ω∖A也是Σ的元素。（也就是说，σ-代数对补集是封闭的。）
- en: (c) For all A[1],A[2],⋅⋅⋅∈ Σ, the set ∪[n=1]^∞A[n] is also an element of Σ.
    (That is, σ-algebras are closed to unions.)
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: (c) 对于所有A[1],A[2],⋅⋅⋅∈ Σ，集合∪[n=1]^∞A[n]也是Σ的一个元素。（也就是说，σ-代数对并运算是封闭的。）
- en: 'Since events are modeled by sets, logical concepts such as “and”, “or”, and
    “not” can be translated into set operations:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 由于事件是通过集合来建模的，因此诸如“与”、“或”和“非”等逻辑概念可以转化为集合运算：
- en: the joint occurrence of events A and B is equivalent to A ∩B,
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件A和B的联合发生相当于A ∩B，
- en: “A or B” is equivalent to A ∪B,
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “A或B”相当于A ∪B，
- en: and “not A” is equivalent to Ω ∖A.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “非A”相当于Ω ∖A。
- en: An immediate consequence of the definition is that, for any events A[1],A[2],⋅⋅⋅∈
    Σ, their intersection ∩[n=1]^∞A[n] is also a member of Σ. Indeed, as De Morgan’s
    laws (Theorem [153](ch037.xhtml#x1-377003r153)) suggest,
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 定义的一个直接结果是，对于任何事件A[1],A[2],⋅⋅⋅∈ Σ，它们的交集∩[n=1]^∞A[n]也是Σ的一个成员。事实上，正如德摩根定律（定理[153](ch037.xhtml#x1-377003r153)）所暗示的那样，
- en: '![ ∞ ∞ Ω ∖(∩ n=1 An ) = ∪n=1(Ω ∖ An). ](img/file1623.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![ ∞ ∞ Ω ∖(∩ n=1 An ) = ∪n=1(Ω ∖ An). ](img/file1623.png)'
- en: Since Ω ∖ (Ω ∖A) = A, we have
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Ω ∖ (Ω ∖A) = A，我们得到
- en: '![ ∞ ∞ ∩ n=1An = Ω ∖ (Ω ∖(∩n=1An )) ∞ = Ω ∖ ∪n=1( Ω◟-∖◝A◜n◞). ∈Σ ](img/file1624.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![ ∞ ∞ ∩ n=1An = Ω ∖ (Ω ∖(∩n=1An )) ∞ = Ω ∖ ∪n=1( Ω◟-∖◝A◜n◞). ∈Σ ](img/file1624.png)'
- en: Thus, the defining properties of σ-algebras guarantee that ∩[n=1]^∞A[n] is indeed
    an element of Σ. Another immediate consequence of the definition is that since
    Ω ∈ Σ, the empty set ∅ is also a member of Σ.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，σ-代数的定义特性保证了∩[n=1]^∞A[n]确实是Σ的一个元素。定义的另一个直接结果是，由于Ω ∈ Σ，空集∅也是Σ的一个成员。
- en: 'At first glance, σ-algebras seem a bit abstract. As usual, a bit of abstraction
    now will pay us huge dividends later in our studies. To bring this concept closer,
    here is a summary of σ-algebras in English:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，σ-代数似乎有点抽象。像往常一样，适当的抽象现在将为我们的后续学习带来巨大的回报。为了让这个概念更贴近实际，这里有一个关于σ-代数的英文总结：
- en: The set of all possible outcomes is an event.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有可能结果的集合是一个事件。
- en: For any event, it not occurring is an event as well.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于任何事件，它的不发生也是一个事件。
- en: For any events, their joint occurrence is an event as well.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于任何事件，它们的联合发生也是一个事件。
- en: For any events, at least one of them occurring is an event as well.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于任何事件，至少有一个事件发生也是一个事件。
- en: Now that we have the formal definition under our belt, let’s see the first example.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经掌握了正式定义，接下来看看第一个例子。
- en: 'Example 1\. Rolling a six-sided dice. There, the σ-algebra is simply the power
    set of the event space:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 示例1\. 投掷一个六面骰子。在这里，σ-代数就是事件空间的幂集：
- en: '![Ω = {1,2,3,4,5,6}, Σ = 2Ω. ](img/file1625.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![Ω = {1,2,3,4,5,6}, Σ = 2Ω. ](img/file1625.png)'
- en: (Recall that the power set of A is the set 2^A containing all subsets of A,
    as defined in Definition [108](ch037.xhtml#x1-374009r108).) Even though this is
    one of the simplest examples, it will serve as a prototype and a building block
    for constructing more complicated event spaces.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: （回想一下，A的幂集是集合2^A，它包含了A的所有子集，如定义在定义[108](ch037.xhtml#x1-374009r108)中的所述。）尽管这是最简单的一个例子，但它将作为一个原型，并为构建更复杂的事件空间提供一个基础。
- en: 'Example 2\. Tossing a coin n times. A single toss has two possible outcomes:
    heads or tails. For simplicity, we are going to encode heads with 0 and tails
    with 1\. Since we are tossing the coin n times, the result of an experiment will
    be an n-long sequence of ones and zeros, like this: (0,1,1,1,…,0,1). Thus, the
    complete event space is Ω = {0,1}^n.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 示例2\. 投掷硬币n次。一次投掷有两个可能的结果：正面或反面。为了简化，我们用0表示正面，用1表示反面。由于我们投掷硬币n次，实验的结果将是一个包含n个0和1的序列，如：(0,1,1,1,…,0,1)。因此，完整的事件空间是Ω
    = {0,1}^n。
- en: (We are not talking about probabilities just yet, but feel free to spend some
    time figuring out how to assign them to these events. Don’t worry if this is not
    clear; we will go through it in detail.)
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: （我们还没有讨论概率，但可以花些时间弄清楚如何将它们分配给这些事件。如果现在不清楚也没关系，我们稍后会详细讲解。）
- en: As in the previous example, the σ-algebra 2^Ω is a good choice. This covers
    all events that we need, for instance, “the number of tails is k”.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 就像之前的例子一样，σ-代数2^Ω是一个不错的选择。它涵盖了我们需要的所有事件，例如，“尾巴的个数是k”。
- en: In practice, σ-algebras are rarely given explicitly. Sure, for simple cases
    such as the above, it is possible.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，σ-代数很少被明确给出。当然，对于像上面的简单情况，是可以的。
- en: What about cases where the event spaces are not countable? For instance, suppose
    that we are picking a random number between 0 and 1\. Then, Ω = [0,1], but selecting
    Σ = 2^([0,1]) is extremely problematic. Recall that we want to assign a probability
    to every event in Σ. The power set 2^([0,1]) is so large that very strange things
    can occur. In certain scenarios, we can cut up sets into a finite number of pieces
    and reassemble two identical copies of the set from its pieces. (If you are interested
    in more, check out the [Banach-Tarski paradox](https://en.wikipedia.org/wiki/Banach%E2%80%93Tarski_paradox).)
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，在事件空间不可数的情况下该如何处理呢？例如，假设我们从0到1之间选择一个随机数。那么，Ω = [0,1]，但选择Σ = 2^([0,1])是极其有问题的。回想一下，我们希望为Σ中的每个事件分配一个概率。幂集2^([0,1])是如此之大，以至于会发生一些非常奇怪的事情。在某些情况下，我们可以将集合切割成有限个部分，并从这些部分重新组装成两个相同的集合。（如果你对更多内容感兴趣，可以查看[Banach-Tarski悖论](https://en.wikipedia.org/wiki/Banach%E2%80%93Tarski_paradox)。）
- en: To avoid weird things like the above-mentioned, we need another way to describe
    σ-algebras.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免像上述那样奇怪的情况，我们需要另一种方式来描述σ-代数。
- en: 18.2.2 Describing σ-algebras
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 18.2.2 描述σ-代数
- en: Let’s start with a simple yet fundamental property of σ-algebras that we’ll
    soon use to give a friendly description of σ-algebras.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个简单但基本的σ-代数性质开始，这个性质我们很快会用来对σ-代数给出一个友好的描述。
- en: Theorem 109\. (Intersection of event algebras.)
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 109。（事件代数的交集。）
- en: Let Ω be a sample space, and let Σ[1] and Σ[2] be two σ-algebras over it. Then
    Σ[1] ∩ Σ[2] is also a σ-algebra.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 设Ω为样本空间，Σ[1]和Σ[2]为其上的两个σ-代数。则Σ[1] ∩ Σ[2]也是一个σ-代数。
- en: Proof. As we saw in the definition of σ-algebras (Definition [76](ch030.xhtml#x1-282004r76)),
    there are three properties we need to verify to show that Σ[1] ∩ Σ[2] is indeed
    a σ-algebra. This is very simple to check, so I suggest taking a shot by yourself
    first before reading my explanation.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。正如我们在σ-代数的定义中所看到的（定义[76](ch030.xhtml#x1-282004r76)），我们需要验证三个性质以证明Σ[1] ∩ Σ[2]确实是一个σ-代数。这个验证非常简单，所以我建议你先自己试试看，再阅读我的解释。
- en: (a) As both Σ[1] and Σ[2] are σ-algebras, Ω ∈ Σ[1] and Ω ∈ Σ[2] both hold. Thus,
    by definition of the intersection, Ω ∈ Σ[1] ∩ Σ[2].
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: (a) 由于Σ[1]和Σ[2]都是σ-代数，Ω ∈ Σ[1]且Ω ∈ Σ[2]都成立。因此，根据交集的定义，Ω ∈ Σ[1] ∩ Σ[2]。
- en: (b) Let A ∈ Σ[1] ∩ Σ[2]. As both of them are σ-algebras, Ω ∖A ∈ Σ[1] and Ω ∖A
    ∈ Σ[2]. Thus, Ω ∖A is an element of the intersection as well.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: (b) 设A ∈ Σ[1] ∩ Σ[2]。由于它们都是σ-代数，Ω ∖ A ∈ Σ[1]且Ω ∖ A ∈ Σ[2]。因此，Ω ∖ A也是交集的元素。
- en: '(c) Let A[1],A[2],⋅⋅⋅ ∈ Σ[1] ∩ Σ[2] be arbitrary events. We can use the exact
    same argument as before: since both Σ[1] and Σ[2] are σ-algebras, we have'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: (c) 设A[1],A[2],⋅⋅⋅ ∈ Σ[1] ∩ Σ[2]为任意事件。我们可以使用之前完全相同的论证：由于Σ[1]和Σ[2]都是σ-代数，我们有
- en: '![⋃∞ ∞⋃ An ∈ Σ1 and An ∈ Σ2\. n=1 n=1 ](img/file1627.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![⋃∞ ∞⋃ An ∈ Σ1且An ∈ Σ2。n=1 n=1](img/file1627.png)'
- en: So, the union is also a member of the intersection, i.e.,
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，联合也是交集的成员，即，
- en: '![⋃∞ An ∈ Σ1 ∩ Σ2\. n=1 ](img/file1628.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![⋃∞ An ∈ Σ1 ∩ Σ2。 n=1](img/file1628.png)'
- en: With all that, we are ready to describe σ-algebras with a generating set.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们准备好通过生成集来描述σ-代数了。
- en: Theorem 110\. (Generated σ-algebras)
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 110。（生成的σ-代数）
- en: Let Ω be an event space and S ⊆ 2^Ω be an arbitrary collection of its sets.
    Then there is an unique smallest σ-algebra σ(S) that contains S.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 设Ω为一个事件空间，S ⊆ 2^Ω为其任意集合的集合。则存在唯一的最小σ-代数σ(S)，它包含S。
- en: (By smallest, we mean that if Σ is an σ-algebra containing S, then σ(S) ⊆ Σ.)
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: （所谓最小，指的是如果Σ是包含S的σ-代数，则σ(S) ⊆ Σ。）
- en: Proof. Our previous result shows that the intersection of σ-algebras is also
    an σ-algebra. So, let’s take all σ-algebras that contain S and take their intersection.
    Formally, we define
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。我们之前的结果表明，σ-代数的交集也是一个σ-代数。因此，让我们取所有包含S的σ-代数，并取它们的交集。正式地，我们定义
- en: '![σ (S ) = ∩ {Σ : Σ is an σ-algebra and S ⊆ Σ}. ](img/file1629.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![σ(S) = ∩ {Σ : Σ是一个σ-代数且S ⊆ Σ。}](img/file1629.png)'
- en: By definition, σ(S) is clearly the smallest, and it also contains S.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 根据定义，σ(S)显然是最小的，并且它也包含S。
- en: It’s also clear that the generated σ-algebra is unique as, if there would be
    another σ̂(S) satisfying the conditions, then due to the construction, σ̂ (S)
    ⊆σ(S) and σ(S) ⊆σ̂(S), hence σ̂(S) = σ(S).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 还显然，生成的σ-代数是唯一的，因为如果存在另一个σ̂(S)满足条件，那么根据构造，σ̂(S) ⊆ σ(S)且σ(S) ⊆ σ̂(S)，因此σ̂(S)
    = σ(S)。
- en: 'Right away, we can use this to precisely construct the σ-algebra for an extremely
    common task: picking a number between 0 and 1.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 立刻，我们可以利用这一点精确构造一个σ-代数，用于一个极其常见的任务：从0到1之间选一个数。
- en: Example 3\. Selecting a random number between 0 and 1\. It is clear that the
    event space is Ω = [0,1]. What about the events? In this situation, we want to
    ask questions such as the probability of a random number X falling between some
    a,b ∈ [0,1]. That is, events such as (a,b),(a,b],[a,b),[a,b] (whether or not we
    want strict inequality regarding a and b).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 示例3\. 在0到1之间选择一个随机数。显然，事件空间是Ω = [0,1]。那么事件呢？在这种情况下，我们想问的问题是，随机数X落在某些a,b ∈ [0,1]之间的概率是多少。即，像(a,b)、(a,b]、[a,b]、[a,b]这样的事件（无论我们是否需要a和b之间严格的不等式）。
- en: So, a proper σ-algebra can be given by the algebra generated by events of the
    form (a,b]. That is,
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一个合适的σ-代数可以通过由形如(a,b]的事件生成的代数给出。即，
- en: '![Σ = σ({(a,b] : 0 ≤ a <b ≤ 1}). ](img/file1634.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![Σ = σ({(a,b] : 0 ≤ a <b ≤ 1}). ](img/file1634.png)'
- en: This Σ has a rich structure. For instance, it contains simple events such as
    {x}, where x ∈ [0,1], but also more complex ones such as “X is a rational number”
    or “X is an irrational number”. Give yourself a few minutes to see why this is
    true. Don’t worry if you don’t see the solution—we’ll work this out in the problems
    section. (If you think this through, you’ll also see why we chose intervals of
    the form (a,b] instead of others such as (a,b) or [a,b].)
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这个Σ具有丰富的结构。例如，它包含了简单的事件，如{x}，其中x ∈ [0,1]，但也包含更复杂的事件，如“X是一个有理数”或“X是一个无理数”。花几分钟思考一下为什么这是对的。如果你没有看到答案，不用担心——我们将在问题部分讲解这个问题。（如果你思考这个问题，你也会明白为什么我们选择了形如(a,b]的区间，而不是(a,b)或[a,b]这样的其他形式。）
- en: 18.2.3 σ-algebras over real numbers
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 18.2.3 实数上的σ-代数
- en: From all the examples we have seen so far, it is clear that most commonly, we
    define probability spaces on ℕ or on ℝ. When Ω ⊆ℕ, the choice of σ-algebra is
    clear, as Σ = 2^Ω will always work.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们到目前为止看到的所有例子来看，很明显，最常见的做法是我们在ℕ或ℝ上定义概率空间。当Ω ⊆ℕ时，σ-代数的选择是明确的，因为Σ = 2^Ω总是适用的。
- en: However, as suggested in Example 3 above, selecting Σ = 2^Ω when Ω ⊆ℝ can lead
    to some weird stuff. Because we are interested in the probability of events such
    as [a,b], our standard choice is going to be the generated σ-algebra
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如上面示例3所示，选择Σ = 2^Ω当Ω ⊆ℝ时可能会导致一些奇怪的结果。因为我们关心的是事件的概率，例如[a,b]，所以我们的标准选择是生成的σ-代数。
- en: 'ℬ(ℝ) = σ({ (a,b) : a,b ∈ ℝ }), (18.1)'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 'ℬ(ℝ) = σ({ (a,b) : a,b ∈ ℝ }), (18.1)'
- en: called the Borel algebra, named after the famous French mathematician [Émile
    Borel](https://en.wikipedia.org/wiki/%C3%89mile_Borel). Due to its construction,
    ℬ contains all events that are important to us, such as intervals and unions of
    intervals. Elements of ℬ are called Borel sets.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 被称为Borel代数，以著名的法国数学家[埃米尔·博雷尔](https://en.wikipedia.org/wiki/%C3%89mile_Borel)的名字命名。由于其构造，ℬ包含了所有对我们重要的事件，如区间和区间的并集。ℬ的元素称为Borel集合。
- en: Because σ-algebras are closed to unions, you can see that all types of intervals
    can be found in ℬ(ℝ). This is summarized by the following theorem.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 因为σ-代数对并集是封闭的，可以看出所有类型的区间都可以在ℬ(ℝ)中找到。这个结果可以通过以下定理来总结。
- en: Theorem 111\.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 定理111\。
- en: For all a,b ∈ℝ, the sets [a,b], (a,b], [a,b), (−∞,a], (−∞,a), (a,∞), and [a,∞)
    are elements of ℬ(ℝ).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有a,b ∈ℝ，集合[a,b]、(a,b]、[a,b)、(−∞,a]、(−∞,a)、(a,∞)和[a,∞)都是ℬ(ℝ)的元素。
- en: As an exercise, try to come up with the proof by yourself. One trick to get
    the ideas flowing is to start drawing some figures. If you can visualize what
    happens, you’ll discover a proof quickly.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个练习，试着自己推导出证明。启发思路的一个技巧是开始画一些图形。如果你能够直观地理解发生了什么，你会很快发现证明。
- en: Proof. In general, for a given set S, we can show that it belongs to ℬ(ℝ) by
    writing it as the union/intersection/difference of known Borel sets. First, we
    have
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。一般来说，对于给定的集合S，我们可以通过将其表示为已知的Borel集合的并集/交集/差集来证明它属于ℬ(ℝ)。首先，我们有
- en: '![ ∞ ⋃ (a,∞ ) = (a,n), n=1 ](img/file1637.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![ ∞ ⋃ (a,∞ ) = (a,n), n=1 ](img/file1637.png)'
- en: so (a,∞) ∈ ℬ(ℝ). With a similar argument, we see that (−∞,a) ∈ ℬ(ℝ).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 所以 (a,∞) ∈ ℬ(ℝ)。通过类似的论证，我们可以得出(−∞,a) ∈ ℬ(ℝ)。
- en: Next,
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，
- en: '![(− ∞, a] = ℝ ∖ (a,∞ ), [a,∞ ) = ℝ ∖ (− ∞, a), ](img/file1638.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![(− ∞, a] = ℝ ∖ (a,∞ ), [a,∞ ) = ℝ ∖ (− ∞, a), ](img/file1638.png)'
- en: so (−∞,a],[a,∞) ∈ ℬ(ℝ) for all a. From these, the sets [a,b],(a,b],[a,b) can
    be produced by intersections.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 所以 (−∞,a],[a,∞) ∈ ℬ(ℝ) 对于所有的a。通过这些集合，可以通过交集生成[a,b],(a,b],[a,b)等集合。
- en: Now that we understand what events and σ-algebras are, we can take our first
    detailed look at probability. In the next section, we will introduce its precise
    mathematical definition.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们理解了事件和σ-代数的概念，我们可以开始详细地探讨概率。在下一节中，我们将引入其精确定义。
- en: 18.2.4 Probability measures
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 18.2.4 概率度量
- en: Let’s recap what we have learned so far! In the language of mathematics, experiments
    with intrinsic uncertainty are described using outcomes, event spaces, and events.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下到目前为止所学的内容！在数学语言中，具有内在不确定性的实验使用结果、事件空间和事件来描述。
- en: The collection of all possible mutually exclusive outcomes of an experiment
    is called the event space, denoted by Ω. Certain subsets of Ω are called events,
    to which we want to assign probabilities.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 实验的所有可能的互斥结果的集合称为事件空间，记作 Ω。Ω 的某些子集称为事件，我们希望为这些事件分配概率。
- en: These events form what is known as a σ-algebra, denoted by Σ. We denote the
    probability of an event A by P(A).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这些事件形成了所谓的 σ-代数，记作 Σ。我们用 P(A) 来表示事件 A 的概率。
- en: 'Intuitively speaking, we have three reasonable expectations about probability:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 直观来说，我们对概率有三个合理的期望：
- en: P(Ω) = 1, that is, the probability that at least one outcome occurs is 1\. In
    other words, our event space is a complete description of the experiment.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: P(Ω) = 1，也就是说，至少有一个结果发生的概率为 1\. 换句话说，我们的事件空间是对实验的完整描述。
- en: P(∅) = 0, that is, the probability that none of the outcomes occur is 0\. Again,
    this means that our event space is complete.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: P(∅) = 0，也就是说，任何结果都不发生的概率为 0\. 这再次意味着我们的事件空间是完整的。
- en: The probability that either of two events occurs for two mutually exclusive
    events is the sum of the individual probabilities.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于两个互斥事件，任意一个事件发生的概率是各自概率的和。
- en: These are formalized by the following definition.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这些通过以下定义被形式化。
- en: 'Definition 77\. (Probability measures and spaces) Let Ω be an event space and
    Σ be an σ-algebra over Ω. We say that the function P : Σ → [0,1] is a probability
    measure on Σ if the following properties hold:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '定义 77\.（概率度量和空间）设 Ω 为事件空间，Σ 为 Ω 上的 σ-代数。我们说函数 P : Σ → [0,1] 是 Σ 上的概率度量，如果满足以下性质：'
- en: (a) P(Ω) = 1.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: (a) P(Ω) = 1。
- en: (b) If A[1],A[2],… are mutually disjoint events (that is, A[i]∩A[j] = ∅ for
    all i≠j), then P(∪[n=1]^∞A[n]) = ∑ [n=1]^∞P(A[n]). This property is called the
    σ-additivity of probability measures.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: (b) 如果 A[1],A[2],… 是互不相交的事件（即，A[i]∩A[j] = ∅ 对于所有 i≠j），那么 P(∪[n=1]^∞A[n]) = ∑
    [n=1]^∞P(A[n])。这个性质称为概率度量的 σ-可加性。
- en: Along with the probability measure P, the structure (Ω,Σ,P) is said to form
    a probability space.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 与概率度量 P 一起，结构 (Ω,Σ,P) 被称为形成一个概率空间。
- en: As usual, let’s see some concrete examples first! We are going to continue with
    the ones we worked out when discussing σ-algebras.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 一如既往，让我们首先看看一些具体的例子！我们将继续使用在讨论 σ-代数时已经解决的例子。
- en: Example 1, continued. Rolling a six-sided dice. Recall that the event space
    and algebra were defined by
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 1，继续。掷一个六面骰子。回忆一下，事件空间和代数是通过以下方式定义的
- en: '![ Ω Ω = {1,2,3,4,5,6}, Σ = 2 . ](img/file1639.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![ Ω Ω = {1,2,3,4,5,6}, Σ = 2 . ](img/file1639.png)'
- en: If we don’t have any extra knowledge about our dice, it is reasonable to assume
    that each outcome is equally probable. That is, since there are six possible outcomes,
    we have
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们对骰子没有额外的知识，合理的假设是每个结果的概率相等。也就是说，由于有六种可能的结果，我们有
- en: '![P ({1}) = ⋅⋅⋅ = P({6}) = 1\. 6 ](img/file1640.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![P ({1}) = ⋅⋅⋅ = P({6}) = 1\. 6 ](img/file1640.png)'
- en: Notice that, in this case, knowing the probabilities for the individual outcomes
    is enough to determine the probability of any event. This is due to the (σ-)additivity
    of the probability. For instance, the event “the outcome of the dice roll is an
    odd number” is described by
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在这种情况下，知道单个结果的概率就足以确定任何事件的概率。这是因为概率的（σ-）可加性。例如，事件“掷骰子的结果是奇数”可以通过以下方式描述：
- en: '![ 3 P ({1,3,5} ) = P ({1})+ P ({3 })+ P ({5} ) = 6-. ](img/file1641.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![ 3 P ({1,3,5} ) = P ({1})+ P ({3 })+ P ({5} ) = 6-. ](img/file1641.png)'
- en: 'In English, the probability of any event can be written down with the following
    formula:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 用英语表达，任何事件的概率可以通过以下公式写出：
- en: '![P (event) = -favorable outcomes-. all possible outcomes ](img/file1642.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![P (event) = -favorable outcomes-. all possible outcomes ](img/file1642.png)'
- en: 'You might remember this from your elementary and high school studies (depending
    on the curriculum in your country). This is a useful formula, but there is a caveat:
    it only works if we assume that each outcome has an equal probability.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能记得这个公式，它来自你的小学和高中的学习（具体取决于你所在国家的课程）。这是一个有用的公式，但有一个警告：它只在假设每个结果的概率相等时有效。
- en: In the case when our dice is not uniformly weighted, the occurrences of individual
    outcomes are not equal. (Just think of a lead dice, where one side is significantly
    heavier than the others.) For now, we are not going to be concerned with this
    case. Later, this generalization will be discussed in detail.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的骰子不是均匀加权时，各种结果发生的概率是不相等的。（想象一下一个铅制骰子，其中一面明显比其他面重。）目前，我们不考虑这种情况，稍后会详细讨论这一普遍情况。
- en: Example 2, continued. Tossing a coin n times. Here, our event space and algebra
    was Ω = {0,1}^n and Σ = 2^Ω. For simplicity, let’s assume that n = 5.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 示例2，继续。投掷硬币n次。在这里，我们的事件空间和代数是Ω = {0,1}^n，Σ = 2^Ω。为了简化，假设n = 5。
- en: What is the probability of a particular result, say HHTTT? Going step by step,
    the probability that the first toss will be heads is 1∕2\. That is,
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 某一特定结果的概率是多少呢？例如HHTTT？逐步分析，第一次投掷为正面的概率是1∕2\. 也就是说，
- en: '![ 1 P(first toss is heads) =- 2 ](img/file1643.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![ 1 P（第一次投掷是正面） =- 2 ](img/file1643.png)'
- en: Since the first toss is independent of the second,
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 由于第一次投掷与第二次投掷是独立的，
- en: '![P(second toss is heads) = 1 2 ](img/file1644.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![P（第二次投掷是正面） = 1 2 ](img/file1644.png)'
- en: as well. To combine this and calculate the probability that the first two tosses
    are both heads, we can think in the following way. Among the outcomes where the
    first toss is heads, exactly half of them will have the second toss heads as well.
    So, we are looking for the half of the half. That is,
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 也是如此。为了结合这一点并计算第一次和第二次投掷都为正面的概率，我们可以这样思考。对于第一次投掷为正面的结果，其中一半的第二次投掷也是正面。因此，我们要寻找的是一半中的一半。也就是，
- en: '![P(first two tosses are heads) = P(first toss is heads)P(second toss is heads)
    1- = 4\. ](img/file1645.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![P（前两次投掷是正面） = P（第一次投掷是正面）P（第二次投掷是正面） 1- = 4\. ](img/file1645.png)'
- en: Going further with the same logic, we obtain
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 按照相同的逻辑继续推演，我们得到
- en: '![ 1 1 P (HHTTT ) = -5 = --. 2 32 ](img/file1646.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![ 1 1 P (HHTTT ) = -5 = --. 2 32 ](img/file1646.png)'
- en: If we look a bit deeper, we will notice that this follows the previously seen
    “favorable/all” formula. Indeed, as we can see with a bit of combinatorics, there
    are 2⁵ total possibilities, all of them having equal probability.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们稍微深入分析，就会发现这遵循了之前看到的“有利/总数”公式。事实上，通过一些组合学知识可以发现，总共有2⁵种可能性，且它们的概率相等。
- en: Considering this, what is the probability that out of our five tosses, exactly
    two of them are heads? In the language of sets, we can encode each five-toss experiment
    as a subset of {1,2,3,4,5}, the elements signifying the toss that resulted in
    heads. (So, for example, {1,4,5} would encode the outcome HTTHH.) With this, the
    experiments when there are two heads are exactly the two-element subsets of {1,2,3,4,5}.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，五次投掷中恰好有两个正面的概率是多少呢？用集合的语言来说，我们可以将每次五次投掷的实验编码为{1,2,3,4,5}的子集，元素表示结果为正面的投掷。（例如，{1,4,5}表示结果为HTTHH。）在这种情况下，恰好有两个正面的实验正是{1,2,3,4,5}的二元子集。
- en: From our combinatorics studies, we know that the number of subsets with given
    elements is
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们的组合学研究中，我们知道给定元素的子集数目是
- en: '![( ) n = ---n!----, k k!(n − k)! ](img/file1647.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![( ) n = ---n!----, k k!(n − k)! ](img/file1647.png)'
- en: where n is the size of our set and k is the desired size of the subsets. So,
    in total, there are ![(5) 2](img/file1648.png) number of occurrences with exactly
    two heads. Thus, following the “favorable/all” formula, we have
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 其中n是我们集合的大小，k是我们期望的子集大小。因此，总共有![(5) 2](img/file1648.png)次出现恰好两个正面的情况。按照“有利/总数”公式，我们有
- en: '![ ( ) P(two heads out of five tosses) = 5 -1-= 10\. 2 32 32 ](img/file1649.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![ ( ) P（五次投掷中出现两个正面） = 5 -1-= 10\. 2 32 32 ](img/file1649.png)'
- en: One more example, and we are ready to move forward.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 再举一个例子，我们就可以继续往下讲了。
- en: Example 3, continued. Selecting a random number between 0 and 1\. Here, our
    event space was Ω = [0,1], and our σ-algebra was the generated algebra
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 示例3，继续。选择一个0到1之间的随机数。在这里，我们的事件空间是Ω = [0,1]，我们的σ代数是生成的代数
- en: '![ ( ) Σ = σ {(a,b] : 0 ≤ a <b ≤ 1} . ](img/file1650.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![ ( ) Σ = σ {(a,b] : 0 ≤ a <b ≤ 1} . ](img/file1650.png)'
- en: Without any further information, it is reasonable to assume that every number
    can be selected with an equal probability. What does this even mean for an infinite
    event space such as Ω = [0,1]? We can’t divide 1 into infinitely many equal parts.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有任何进一步信息的情况下，合理的假设是每个数字都能以相等的概率被选中。这对于像Ω = [0,1]这样的无限事件空间意味着什么呢？我们无法将1分成无数个相等的部分。
- en: So, instead of thinking about individual outcomes, we should start thinking
    about events. Let’s denote our randomly selected number with X. If all numbers
    are “equally likely”, what is P(X ∈ (0,1∕2])? Intuitively, given our equally likely
    hypothesis, this probability should be proportional to the size of [0,1∕2]. Thus,
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们不应只考虑个别结果，而应开始考虑事件。我们用 X 来表示随机选取的数字。如果所有数字“同样可能”，那么 P(X ∈ (0,1∕2]) 是多少？直观上，基于我们“同样可能”的假设，这个概率应该与
    [0,1∕2] 的大小成正比。因此，
- en: '![P (X ∈ I) = |I|, ](img/file1651.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![P (X ∈ I) = |I|, ](img/file1651.png)'
- en: where I is some interval and jIj is its length. For instance,
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 I 是某个区间，jIj 是它的长度。例如，
- en: '![P (a <X <b) = P(a ≤ X < b) = P(a <X ≤ b) = P(a ≤ X ≤ b) = b− a. ](img/file1652.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![P (a <X <b) = P(a ≤ X < b) = P(a <X ≤ b) = P(a ≤ X ≤ b) = b− a. ](img/file1652.png)'
- en: By giving the probabilities on the generating set of the σ-algebra, the probabilities
    for all other events can be deduced. For instance,
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 通过给定 σ-代数生成集上的概率，可以推导出所有其他事件的概率。例如，
- en: '![P (X = x) = P(0 ≤ X ≤ x)− P (0 ≤ X <x) = x − x = 0\. ](img/file1653.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![P (X = x) = P(0 ≤ X ≤ x)− P (0 ≤ X <x) = x − x = 0\. ](img/file1653.png)'
- en: 'Thus, the probability of picking a given number is zero. There is an important
    lesson here: events with zero probability can happen. This sounds counterintuitive
    at first, but based on the above example, you can see that it is true.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，选中一个特定数字的概率是零。这里有一个重要的教训：概率为零的事件是可以发生的。一开始这听起来违反直觉，但根据上面的例子，你可以看到这是正确的。
- en: 18.2.5 Fundamental properties of probability
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 18.2.5 概率的基本性质
- en: Now that we are familiar with the mathematical model of probability, we can
    start working with them. Manipulating expressions of probabilities gives us the
    ability to deal with complex scenarios.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经熟悉了概率的数学模型，可以开始使用它们了。操作概率表达式让我们能够处理复杂的情景。
- en: 'If you recall, probability measures had three simple defining properties (see
    Definition [77](ch030.xhtml#x1-285008r77)):'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得，概率测度有三个简单的定义性质（见定义 [77](ch030.xhtml#x1-285008r77)）：
- en: (a) P(Ω) = 1,
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: (a) P(Ω) = 1，
- en: (b) P(∅) = 0, and
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: (b) P(∅) = 0，且
- en: (c) P![⋃ ∞ ( n=1 An)](img/file1654.png) = ∑ [n=1]^∞P(A[n]), if the events A[n]
    are mutually disjoint.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: (c) P![⋃ ∞ ( n=1 An)](img/file1654.png) = ∑ [n=1]^∞P(A[n])，如果事件 A[n] 互不相交。
- en: From these properties, many others can be deduced. For simplicity, here is a
    theorem summarizing the most important ones.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些性质中，许多其他性质可以推导出来。为了简化，下面是一个定理，概括了最重要的几个性质。
- en: Theorem 112\.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 112\。
- en: Let (Ω,Σ,P) be a probability space and let A,B ∈ Σ be two arbitrary events.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 设 (Ω,Σ,P) 是一个概率空间，A, B ∈ Σ 是两个任意事件。
- en: (a) P(A ∪B) = P(A) + P(B) −P(A ∩B).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: (a) P(A ∪B) = P(A) + P(B) −P(A ∩B)。
- en: (b) P(A) = P(A ∩B) + P(A ∖B). Specifically, P(Ω ∖A) + P(A) = 1.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: (b) P(A) = P(A ∩B) + P(A ∖B)。具体地，P(Ω ∖A) + P(A) = 1。
- en: (c) If A ⊆B, then P(A) ≤P(B).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: (c) 如果 A ⊆B，那么 P(A) ≤P(B)。
- en: The proof of this is so simple that it is left to you as an exercise. All of
    these follow from the additivity of probability measures with respect to disjoint
    events. (If you don’t see the solution, sketch some Venn diagrams!)
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这个证明非常简单，因此作为练习留给你自己。所有这些都来自于对互不相交事件的概率测度加法性。（如果你没看出解决办法，可以画一些维恩图！）
- en: Another fundamental tool is the law of total probability, which is used all
    the time when dealing with more complex events.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个基本工具是全概率法则，它在处理更复杂的事件时经常被使用。
- en: Theorem 113\. (Law of total probability)
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 113\. （全概率法则）
- en: Let (Ω,Σ,P) be a probability space and let A ∈ Σ be an arbitrary event. If A[1],A[2],⋅⋅⋅∈
    Σ are mutually disjoint events (that is, A[i] ∩A[j] = ∅if i≠j) for which ∪[n=1]^∞A[n]
    = Ω, then
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 设 (Ω,Σ,P) 是一个概率空间，A ∈ Σ 是一个任意事件。如果 A[1],A[2],⋅⋅⋅∈ Σ 是互不相交的事件（即 A[i] ∩A[j] =
    ∅ 当 i≠j 时），并且 ∪[n=1]^∞A[n] = Ω，那么：
- en: P(A) = ∑[n=1]^∞ P(A ∩ A[n]). (18.2)
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: P(A) = ∑[n=1]^∞ P(A ∩ A[n])。（18.2）
- en: We call mutually disjoint events whose union is the entire event space partitions.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们称那些互不相交且其并集构成整个事件空间的事件为分割事件。
- en: Proof. This simply follows from the σ-additivity of probability measures. Feel
    free to give the proof a shot by yourself to test your understanding.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。这简单地遵循了概率测度的 σ-加法性。可以自己尝试一下证明，来检验你的理解。
- en: If you can’t see this, no worries. Here is a brief explanation. Since A[1],A[2],…
    are mutually disjoint, A ∩A[1],A ∩A[2],… are mutually disjoint as well. Moreover,
    since ∪[n=1]^∞A[n] = Ω, we also have
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看不懂这个，没关系。这里有一个简短的解释。由于 A[1],A[2],… 是互不相交的，A ∩A[1],A ∩A[2],… 也是互不相交的。此外，由于
    ∪[n=1]^∞A[n] = Ω，我们还可以得到：
- en: '![∞⋃ ( ∞⋃ ) (An ∩ A) = An ∩ A n=1 n=1 = Ω ∩ A = A. ](img/file1656.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![∞⋃ ( ∞⋃ ) (An ∩ A) = An ∩ A n=1 n=1 = Ω ∩ A = A. ](img/file1656.png)'
- en: Thus, the σ-additivity of probability measures implies that
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，概率测度的 σ-加法性意味着：
- en: '![ ∞ P (A) = ∑ P (A ∩ A ), n=1 n ](img/file1657.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![ ∞ P (A) = ∑ P (A ∩ A ), n=1 n ](img/file1657.png)'
- en: which is what we had to show.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们要证明的。
- en: Let’s see an example right away! Suppose that we toss two dice. What is the
    probability that the sum of the results is 7?
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们立即看一个例子！假设我们投掷两个骰子。那么，结果之和为7的概率是多少？
- en: First, we should properly describe the probability space. For notational simplicity,
    let’s denote the result of the throws with X and Y . What we are looking for is
    P(X + Y = 7). Modeling the toss with two dice is the simplest if we impose order
    among them. With this in mind, the event space Ω is described by the Cartesian
    product
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们应该正确描述概率空间。为了简化符号，假设投掷的结果为 X 和 Y。我们要找的是 P(X + Y = 7)。如果我们对两个骰子投掷加上顺序的要求，那么建模就变得最简单。考虑到这一点，事件空间
    Ω 可以通过笛卡尔积来描述
- en: '![Ω = {1,2,3,4,5,6}× {1,2,3,4,5,6} = {(i,j) : i,j ∈ {1,2,3,4,5,6}}, ](img/file1658.png)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![Ω = {1,2,3,4,5,6}× {1,2,3,4,5,6} = {(i,j) : i,j ∈ {1,2,3,4,5,6}}, ](img/file1658.png)'
- en: and the outcomes are tuples of the form (i,j). (That is, the tuple (i,j) encodes
    the elementary event {X = i,Y = j}.) Since the tosses are independent of each
    other,
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是 (i,j) 形式的元组。（也就是说，元组 (i,j) 编码了基本事件 {X = i, Y = j}。）由于投掷是相互独立的，
- en: '![P (X = i,Y = j) = 1-⋅ 1-=-1-. 6 6 36 ](img/file1659.png)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![P (X = i,Y = j) = 1-⋅ 1-=-1-. 6 6 36 ](img/file1659.png)'
- en: (When it is clear, we omit the brackets of the event {X = i,Y = j}.)
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: (当事件{X = i, Y = j}明确时，我们可以省略括号。)
- en: Since the first throw falls between 1 and 6, we can partition the event space
    by forming
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 由于第一次投掷的结果在 1 到 6 之间，我们可以通过形成事件空间来划分它
- en: '![A := {X = n}, n = 1,...,6\. n ](img/file1660.png)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![A := {X = n}, n = 1,...,6\. n ](img/file1660.png)'
- en: Thus, the law of total probability gives
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，总概率法则给出了
- en: '![ 6 P (X + Y = 7) = ∑ P ({X + Y = 7} and {X = n }). n=1 ](img/file1661.png)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![ 6 P (X + Y = 7) = ∑ P ({X + Y = 7} 和 {X = n }). n=1 ](img/file1661.png)'
- en: However, if we know that X + Y = 7 and X = n, we know that Y = 7 −n must hold
    as well. So, continuing the calculation above,
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们知道 X + Y = 7 且 X = n，那么我们也知道 Y = 7 −n 必须成立。因此，继续上面的计算，
- en: '![ ∑6 ( ) P (X + Y = 7) = P {X + Y = 7} and {X = n} n=1 ∑6 = P(X = n,Y = 7
    − n) n=1 6 ∑ 1-- = 36 n=1 = 1\. 6 ](img/file1662.png)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![ ∑6 ( ) P (X + Y = 7) = P {X + Y = 7} 和 {X = n} n=1 ∑6 = P(X = n,Y = 7 −
    n) n=1 6 ∑ 1-- = 36 n=1 = 1\. 6 ](img/file1662.png)'
- en: So, the law of total probability helps us deal with complex events by decomposing
    them into simpler ones. We have seen this pattern dozens of times now, and once
    again, it proves to be essential.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，总概率法则通过将复杂事件分解为简单事件，帮助我们处理复杂的事件。我们现在已经看到了这种模式好几次了，而且它再次证明了其重要性。
- en: As yet another consequence of σ-additivity, we can calculate the probability
    of an increasing sequence of events by taking the limit.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 σ-加性（σ-additivity）的另一个结果，我们可以通过取极限来计算递增事件序列的概率。
- en: Theorem 114\. (Lower continuity of probability measures)
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 114. （概率测度的下连续性）
- en: Let (Ω,Σ,P) be a probability space and let A[1] ⊆A[2] ⊆⋅⋅⋅∈ Σ be an increasing
    sequence of events. Then,
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 设 (Ω, Σ, P) 是一个概率空间，且 A[1] ⊆ A[2] ⊆ ⋅⋅⋅ ∈ Σ 是一个递增事件序列。那么，
- en: P(∪[n=1]^∞ A[n]) = lim[n→∞] P(A[n]) (18.3)
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: P(∪[n=1]^∞ A[n]) = lim[n→∞] P(A[n]) (18.3)
- en: holds. This property is called the lower continuity of probability measures.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 成立。这个性质称为概率测度的下连续性。
- en: Proof. Since the events are increasing, that is, A[n−1] ⊆ A[n], we can write
    A[n] as
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。由于事件是递增的，即 A[n−1] ⊆ A[n]，我们可以将 A[n] 写为
- en: '![An = An−1 ∪ (An ∖An −1), ](img/file1664.png)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![An = An−1 ∪ (An ∖An −1), ](img/file1664.png)'
- en: where A[n−1] and A[n] ∖A[n−1] are disjoint.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 A[n−1] 和 A[n] ∖A[n−1] 是不相交的。
- en: Thus,
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，
- en: '![ ∞⋃ ∞⋃ An = (An ∖ An− 1), A0 := ∅, n=1 n=1 ](img/file1665.png)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![ ∞⋃ ∞⋃ An = (An ∖ An− 1), A0 := ∅, n=1 n=1 ](img/file1665.png)'
- en: which gives
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这给出了
- en: '![ ∑∞ P (∪∞n=1An ) = P(An ∖ An− 1) n=1 N∑ = lim P (An ∖ An− 1) N → ∞n=1 N =
    lim ∑ [P(A )− P (A )] N → ∞ n n−1 n=1 = lim P (AN ), N → ∞ ](img/file1666.png)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![ ∑∞ P (∪∞n=1An ) = P(An ∖ An− 1) n=1 N∑ = lim P (An ∖ An− 1) N → ∞n=1 N =
    lim ∑ [P(A )− P (A )] N → ∞ n n−1 n=1 = lim P (AN ), N → ∞ ](img/file1666.png)'
- en: where we used that P(∅) = 0.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 其中我们用到了 P(∅) = 0。
- en: We can state an analogue of the above theorem for a decreasing sequence of events.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为递减事件序列给出上述定理的类似命题。
- en: Theorem 115\. (Upper continuity of probability measures)
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 115. （概率测度的上连续性）
- en: Let (Ω,Σ,P) be a probability space and let A[1] ⊇A[2] ⊇⋅⋅⋅∈ Σ be a decreasing
    sequence of events. Then,
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 设 (Ω, Σ, P) 是一个概率空间，且 A[1] ⊇ A[2] ⊇ ⋅⋅⋅ ∈ Σ 是一个递减事件序列。那么，
- en: P(∩[n=1]^∞ A[n]) = lim[n→∞] P(A[n]) (18.4)
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: P(∩[n=1]^∞ A[n]) = lim[n→∞] P(A[n]) (18.4)
- en: holds. This property is called the upper continuity of probability measures.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 成立。这个性质称为概率测度的上连续性。
- en: Proof. For simplicity, let’s denote the infinite intersection by A := ∩[n=1]^∞A[n].
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。为了简化，我们将无穷交集记为 A := ∩[n=1]^∞ A[n]。
- en: By defining B[n] := A[1] ∖A[n], we have ∪[n=1]^∞B[n] = A[1] ∖A. Since A[n] is
    decreasing, B[n] is increasing, so we can apply Theorem [114](ch030.xhtml#x1-286007r114)
    to obtain
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 通过定义 B[n] := A[1] ∖A[n]，我们有 ∪[n=1]^∞B[n] = A[1] ∖A。由于 A[n] 是递减的，B[n] 是递增的，因此我们可以应用定理
    [114](ch030.xhtml#x1-286007r114) 得到
- en: '![P (A1 ∖A ) = nl→im∞ P (A1 ∖ An ) = P (A1) − lni→m∞ P (An). ](img/file1668.png)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![P (A1 ∖A ) = nl→im∞ P (A1 ∖ An ) = P (A1) − lni→m∞ P (An). ](img/file1668.png)'
- en: Since P(A[1] ∖A) = P(A[1]) −P(A), we obtain P(A) = lim[n→∞]P(A[n]).
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 P(A[1] ∖A) = P(A[1]) −P(A)，我们得到 P(A) = lim[n→∞]P(A[n])。
- en: 'Now that we have a mathematical definition of a probabilistic model, it is
    time to take a step toward the space where machine learning is done: ℝ^n.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了一个概率模型的数学定义，是时候迈出一步进入机器学习所在的空间：ℝ^n。
- en: 18.2.6 Probability spaces on ℝ^n
  id: totrans-277
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 18.2.6 ℝ^n 上的概率空间
- en: In machine learning, every data point is an elementary outcome, located somewhere
    in the Euclidean space ℝ^n. Because of this, we are interested in modeling experiments
    there.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在机器学习中，每个数据点是一个基本结果，位于欧几里得空间 ℝ^n 的某个位置。因此，我们有兴趣在这个空间中模拟实验。
- en: 'How can we define a probability space on ℝ^n? As we did with the real line
    in Section [18.2.1](ch030.xhtml#event-spaces-and-algebras), we describe a convenient
    σ-algebra by generating. There, we can use the higher dimensional counterpart
    of the (a,b) intervals: n-dimensional spheres. For this, we define the set'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 如何在 ℝ^n 上定义概率空间？正如我们在第 [18.2.1](ch030.xhtml#event-spaces-and-algebras) 节中对实数轴所做的那样，我们通过生成一个方便的
    σ-代数来描述它。在那里，我们可以使用 (a,b) 区间的高维对应物：n 维球体。为此，我们定义集合
- en: '![ n B (x,r) := {y ∈ ℝ : ∥x − y ∥ <r}, ](img/file1669.png)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![ n B (x,r) := {y ∈ ℝ : ∥x − y ∥ <r}, ](img/file1669.png)'
- en: where x is the center of the sphere, r/span>0 is its radius, and ∥⋅∥ denotes
    the usual Euclidean norm. (The B denotes the word ball. In mathematics, n-dimensional
    spheres are often called balls.) Similar to the real line, the Borel algebra is
    defined by
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 x 是球体的中心，r/span>0 是它的半径，∥⋅∥ 表示通常的欧几里得范数。（B 表示球体的意思。在数学中，n 维球体通常称为球。）与实数轴类似，Borel
    σ-代数的定义为
- en: 'ℬ(ℝ^n) := σ({B(x, r) : x ∈ ℝ^n, r > 0}) (18.5)'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 'ℬ(ℝ^n) := σ({B(x, r) : x ∈ ℝ^n, r > 0}) (18.5)'
- en: As we saw on the real line (see Section [18.2.3](ch030.xhtml#algebras-over-real-numbers)),
    the structure of ℬ(ℝ^n) is richer than what the definition suggests at first glance.
    Here, the analogue of interval is a rectangle, defined by
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在实数轴上所看到的（见第 [18.2.3](ch030.xhtml#algebras-over-real-numbers) 节），ℬ(ℝ^n)
    的结构比定义所暗示的更为丰富。这里，区间的类似物是矩形，其定义为
- en: '![(a,b) = (a1,b1)× ⋅⋅⋅× (an,bn) n = {x ∈ ℝ : ai <xi <bi,i = 1,...,n}, ](img/file1672.png)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![(a,b) = (a1,b1)× ⋅⋅⋅× (an,bn) n = {x ∈ ℝ : ai <xi <bi,i = 1,...,n}, ](img/file1672.png)'
- en: where A×B is the Cartesian product. (See Definition [110](ch037.xhtml#x1-378002r110).)
    Similarly, we can define [a,b],(a,b],[a,b), and others.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 A×B 是笛卡尔积。（见定义 [110](ch037.xhtml#x1-378002r110)）类似地，我们可以定义 [a,b]，(a,b]，[a,b]
    等等。
- en: Theorem 116\.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 116\.
- en: For any a,b ∈ ℝ^n, the sets [a,b],[a,b),(a,b],(a,∞),[a,∞),(−∞,a),(−∞,b] are
    elements of ℬ(ℝ^n).
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任意 a,b ∈ ℝ^n，集合 [a,b]，[a,b)，(a,b]，(a,∞)，[a,∞)，(−∞,a)，(−∞,b] 都是 ℬ(ℝ^n) 的元素。
- en: Proof. The proof goes along the same line as the counterpart for ℬ(ℝ). As such,
    it is left as an exercise to you.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。证明过程与 ℬ(ℝ) 中的对应部分相同。因此，留给你作为练习。
- en: As a hint, first, we can show that (a,b) can be written as a countable union
    of balls. We can also show that this holds true for sets such as
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 作为提示，首先，我们可以证明 (a,b) 可以写成可数个球的并集。我们还可以证明这种情况对于一些集合也成立，例如
- en: '![ℝ × ⋅⋅⋅× (◟−-∞◝,◜-ai)◞ × ⋅⋅⋅× ℝ i- th component ](img/file1673.png)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![ℝ × ⋅⋅⋅× (◟−-∞◝,◜-ai)◞ × ⋅⋅⋅× ℝ i- th component ](img/file1673.png)'
- en: as well. From these two, we can write the others as unions/intersections/differences.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这两个，我们可以将其他集合写成并集/交集/差集的形式。
- en: As an example, let’s throw a few darts at a rectangular wall. Suppose that we
    are terrible darts players and hitting any point on the wall is equally likely.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，假设我们在一面矩形墙上投掷几只飞镖。假设我们是糟糕的飞镖玩家，打到墙上的任何一点的概率是一样的。
- en: We can model this event space with Ω = [0,1] × [0,1] ⊆ℝ², representing our wall.
    What are the possible events? For instance, there is a circular darts board hanging
    on the wall, and we want to find the probability of hitting it. In this scenario,
    we can restrict the Borel sets defined by ([22.2.6](ch030.xhtml#probability-spaces-on-rn))
    to
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用 Ω = [0,1] × [0,1] ⊆ ℝ² 来模拟这个事件空间，代表我们的墙。可能的事件是什么？例如，墙上挂着一个圆形的飞镖靶，我们想找出打中它的概率。在这种情况下，我们可以将通过
    ([22.2.6](ch030.xhtml#probability-spaces-on-rn)) 定义的 Borel 集合限制为
- en: '![ ( ) ℬ Ω := {A ∩Ω : A ∈ ℬ(ℝn )}. ](img/file1674.png)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
  zh: '![ ( ) ℬ Ω := {A ∩Ω : A ∈ ℬ(ℝn )}. ](img/file1674.png)'
- en: Now that the event space and algebra is clear, we need to think about assigning
    probabilities. Our assumption is that hitting any point is equally likely. So,
    by generalizing the ![faallvo proassblibele ouotcutocmomeess](img/file1675.png)
    formula we have seen in the discrete case, we define the probability measure by
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 既然事件空间和代数已经清晰，我们需要思考如何赋予事件概率。我们的假设是，任何一个点的出现概率是相等的。所以，通过推广我们在离散情况下看到的![faallvo
    proassblibele ouotcutocmomeess](img/file1675.png)公式，我们定义了概率度量：
- en: '![P (A ) = volume-(A-). volume (Ω ) ](img/file1676.png)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
  zh: '![P (A ) = volume-(A-). volume (Ω ) ](img/file1676.png)'
- en: (In two dimensions, we have the area instead of volume.) This is illustrated
    by Figure [18.4](#).
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: （在二维空间中，我们使用的是面积而不是体积。）这在图[18.4](#)中有所说明。
- en: '![PIC](img/file1677.png)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file1677.png)'
- en: 'Figure 18.4: Probability space of throwing darts at a wall. Source: https://unsplash.com/photos/black-and-white-round-logo-i3WlrO7oAHA'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.4：投掷飞镖打墙的概率空间。来源：https://unsplash.com/photos/black-and-white-round-logo-i3WlrO7oAHA
- en: As we shall see later, this is a special case of uniform distributions, one
    of the most prevalent distributions in probability theory. However, there is a
    lot to talk about until then. Before we conclude our discussion of the fundamentals
    of probability, let’s discuss how can we interpret them.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们稍后将看到的，这其实是均匀分布的一个特殊案例，均匀分布是概率论中最常见的分布之一。然而，在那之前还有很多要讨论的内容。在我们结束对概率基础的讨论之前，让我们来讨论一下如何解释它们。
- en: 18.2.7 How to interpret probability
  id: totrans-301
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 18.2.7 如何解释概率
- en: Now that we know how to work with probabilities, it is time to study how can
    we assign probabilities to real-life events.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们知道了如何处理概率，接下来就该研究如何将概率赋予现实生活中的事件了。
- en: First, we are going to take a look at the frequentist interpretation, explaining
    probabilities with relative frequencies. (If you are one of those people who are
    religious about this question, calm down. We’ll discuss the Bayesian interpretation
    in detail, but it is not time yet.)
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将看看频率派解释，用相对频率来解释概率。（如果你是那些对此问题有宗教般信仰的人，冷静一下。我们会详细讨论贝叶斯解释，但现在还不是时候。）
- en: Let’s go back to the beginning and consider the coin-tossing experiment. If
    I toss a fair coin 1000 times, how many of them will be heads? Most people immediately
    answer 500, but this is not correct. There is no right answer, as any number of
    heads between 0 and 1000 can happen. Of course, most probably it will be around
    500, but with a very small probability, there can be zero heads as well.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到一开始，考虑掷硬币实验。如果我公平地投掷硬币1000次，其中多少次会是正面？大多数人会立刻回答500次，但这是不正确的。没有正确答案，因为正面次数可以是0到1000之间的任何一个数。当然，最有可能的是接近500，但也有非常小的概率会出现0次正面。
- en: In general, the probability of an event describes its relative frequency among
    infinitely many attempts. That is,
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，事件的概率描述了在无限多次尝试中该事件的相对频率。也就是说，
- en: '![ number of occurrences P (event) ≈ --------------------. number of attempts
    ](img/file1678.png)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![ number of occurrences P (event) ≈ --------------------. number of attempts
    ](img/file1678.png)'
- en: When the number of attempts goes toward infinity, the relative frequency of
    occurrences converges to the true underlying probability. In other words, if X[i]
    quantitatively describes our i-th attempt by
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 当尝试次数趋向于无限时，事件发生的相对频率会收敛到真实的基本概率。换句话说，如果X[i]定量描述了我们的第i次尝试，
- en: '![ ( |{ 1 if the event occurs Xi = | ( 0 otherwise, ](img/file1679.png)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
  zh: '![ ( |{ 1 if the event occurs Xi = | ( 0 otherwise, ](img/file1679.png)'
- en: then
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 然后
- en: '![ X + ⋅⋅⋅+ X P (event) = lim --1---------n. n→ ∞ n ](img/file1680.png)'
  id: totrans-310
  prefs: []
  type: TYPE_IMG
  zh: '![ X + ⋅⋅⋅+ X P (event) = lim --1---------n. n→ ∞ n ](img/file1680.png)'
- en: We can illustrate this by doing a quick simulation using the coin-tossing example.
    Don’t worry if you don’t understand the code; we’ll talk about it in detail in
    the next chapters.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过快速模拟掷硬币的例子来说明这一点。如果你不理解代码，不用担心；我们将在接下来的章节中详细讲解。
- en: '[PRE0]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let’s plot the results for some insight:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们绘制一些结果以获得一些洞察：
- en: '[PRE1]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '![PIC](img/file1681.png)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file1681.png)'
- en: 'Figure 18.5: The relative frequency of coin tosses'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.5：掷硬币的相对频率
- en: The relative frequency quite nicely stabilizes around 1∕2, which is the true
    probability of our fair coin landing on its heads. Is this an accident? No.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 相对频率很好地稳定在1/2左右，这就是我们公平硬币正面朝上的真实概率。这是偶然吗？不是。
- en: We will make all of this mathematically precise when talking about the law of
    large numbers in Section [20.5](ch032.xhtml#the-law-of-large-numbers), but first,
    we’ll introduce the Bayesian viewpoint, a probabilistic framework for updating
    our models given new observations.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第[20.5节](ch032.xhtml#the-law-of-large-numbers)讨论大数法则时将这一切数学化，但首先，我们将介绍贝叶斯观点，这是一种基于新观察更新模型的概率框架。
- en: 18.3 Conditional probability
  id: totrans-319
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 18.3 条件概率
- en: In the previous sections, we learned the foundations of probability. Now we
    can speak in terms of outcomes, events, and chances. However, in real-life applications,
    these basic tools are not enough to build useful predictive models.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们学习了概率的基础知识。现在我们可以使用结果、事件和机会来进行讨论。然而，在实际应用中，这些基本工具不足以构建有用的预测模型。
- en: To illustrate this, let’s build a probabilistic spam filter! For every email
    we receive, we want to estimate the probability P(email is spam). The closer this
    is to 1, the more likely that we are looking at a spam email.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，让我们构建一个概率垃圾邮件过滤器！对于我们收到的每封邮件，我们希望估算其垃圾邮件的概率 P(邮件是垃圾邮件)。这个概率越接近 1，说明我们看到的邮件越有可能是垃圾邮件。
- en: Based on our inbox, we might calculate the relative frequency of spam emails
    and obtain that
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 基于我们的收件箱，我们可能会计算出垃圾邮件的相对频率，并得出
- en: '![ number of our spam emails P(email is spam ) ≈-------------------------.
    number of emails in our inbox ](img/file1682.png)'
  id: totrans-323
  prefs: []
  type: TYPE_IMG
  zh: '![ 垃圾邮件数量 P(邮件是垃圾邮件 ) ≈-------------------------. 收件箱中的邮件数量 ](img/file1682.png)'
- en: However, this doesn’t help us at all. Based on this, we can randomly discard
    every email with probability P(email is spam), but that would be a horrible spam
    filter.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这对我们没有任何帮助。根据这个信息，我们可以以概率 P(邮件是垃圾邮件) 随机丢弃每封邮件，但这将是一个糟糕的垃圾邮件过滤器。
- en: To improve, we need to dig a bit deeper. When analyzing spam emails, we start
    to notice patterns. For instance, the phrase “act now” can be found almost exclusively
    in spam. After a quick count, we get that
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 为了改进，我们需要更深入地挖掘。当分析垃圾邮件时，我们开始注意到一些模式。例如，“立即行动”这一短语几乎只出现在垃圾邮件中。经过快速统计，我们得出
- en: '![ #spam emails with the phrase ”act now” P(email containing ”act now” is a
    spam ) = ---#emails with-the phrase-”act now”- ≈ 0.95\. ](img/file1683.png)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
  zh: '![ #包含“立即行动”短语的垃圾邮件 P(包含“立即行动”短语的邮件是垃圾邮件 ) = ---#包含“立即行动”短语的邮件- ≈ 0.95\. ](img/file1683.png)'
- en: This looks much more useful for our spam filtering efforts. By checking for
    the presence of the phrase “act now”, we can confidently classify an email as
    spam.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来对我们垃圾邮件过滤工作更有帮助。通过检查是否包含“立即行动”这一短语，我们可以自信地将一封邮件归类为垃圾邮件。
- en: Of course, there is much more to spam filtering, but this example demonstrates
    the importance of probabilities conditional on other events. To put this into
    mathematical form, we introduce the following definition.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，垃圾邮件过滤还有更多内容，但这个例子展示了基于其他事件的条件概率的重要性。为了将其数学化，我们引入以下定义。
- en: Definition 78\. (Conditional probability)
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 78.（条件概率）
- en: Let (Ω,Σ,P) be a probability space, let A,B ∈ Σ be two events, and suppose that
    P(A)/span>0\. The conditional probability of B given A is defined by
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 设(Ω,Σ,P) 是一个概率空间，设 A，B ∈ Σ 为两个事件，并假设 P(A)/span>0。给定 A 的条件下 B 的条件概率定义为
- en: '![P (B | A ) := P-(A-∩-B). P (A) ](img/file1684.png)'
  id: totrans-331
  prefs: []
  type: TYPE_IMG
  zh: '![P (B | A ) := P-(A-∩-B). P (A) ](img/file1684.png)'
- en: You can think about P(B∣A) as restricting the event space to A, as illustrated
    by Figure [18.6](#).
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将 P(B∣A) 理解为将事件空间限制在 A 中，如图[18.6](#)所示。
- en: '![PIC](img/file1685.png)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file1685.png)'
- en: 'Figure 18.6: A visual representation of conditional probability'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.6：条件概率的可视化表示
- en: When there are more conditions, say A[1] and A[2], the definition takes the
    form
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 当有更多条件时，例如 A[1] 和 A[2]，定义形式为
- en: '![ P-(B-∩-A1-∩A2-) P(B | A1,A2) = P (A1 ∩A2 ) , ](img/file1686.png)'
  id: totrans-336
  prefs: []
  type: TYPE_IMG
  zh: '![ P-(B-∩-A1-∩A2-) P(B | A1,A2) = P (A1 ∩A2 ) , ](img/file1686.png)'
- en: and so on for even more events.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 以此类推，适用于更多的事件。
- en: To bring this concept closer, let’s revisit the dice-rolling experiment. Suppose
    that your friend rolls a six-sided dice and tells you that the outcome is an odd
    number. Given this information, what is the probability that the result is 3?
    For simplicity, let’s denote the outcome of the roll with X. Mathematically speaking,
    this can be calculated by
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让这个概念更清晰，我们来回顾一下掷骰子实验。假设你的朋友掷了一个六面骰子，并告诉你结果是一个奇数。基于这一信息，结果是 3 的概率是多少？为了简化问题，我们用
    X 来表示掷骰子的结果。从数学角度讲，这可以通过以下公式计算：
- en: '![P (X = 3 | X ∈ {1,3,5}) = P-(X-=-3-and-X-∈-{1,3,5}) P (X ∈ {1,3,5}) ---P-(X--=-3)---
    = P (X ∈ {1,3,5}) = 1∕6- 1∕2 1- = 3\. ](img/file1687.png)'
  id: totrans-339
  prefs: []
  type: TYPE_IMG
  zh: '![P (X = 3 | X ∈ {1,3,5}) = P-(X-=-3-and-X-∈-{1,3,5}) P (X ∈ {1,3,5}) ---P-(X--=-3)---
    = P (X ∈ {1,3,5}) = 1∕6- 1∕2 1- = 3\. ](img/file1687.png)'
- en: This is the number that we expected.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们预期的数字。
- en: Although this simple example doesn’t demonstrate the usefulness of conditional
    probability, this is a cornerstone in machine learning. In essence, learning from
    data can be formulated as estimating P(label∣data). We are going to expand on
    this idea later in this chapter.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个简单的例子没有展示条件概率的实用性，但它是机器学习中的基石。实质上，从数据中学习可以表述为估计P(标签∣数据)。我们将在本章后面进一步扩展这个观点。
- en: 18.3.1 Independence
  id: totrans-342
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 18.3.1 独立性
- en: The idea behind conditional probability is that observing certain events changes
    the probability of others. Is this always the case, though?
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 条件概率的核心思想是，观察某些事件会改变其他事件的概率。但是，难道每次都是这样吗？
- en: In probabilistic modeling, recognizing when observing an event doesn’t influence
    another is equally important. This motivates the concept of independence.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在概率建模中，认识到观察一个事件不会影响另一个事件同样重要。这推动了独立性概念的发展。
- en: Definition 79\. (Independence of events)
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 79.（事件的独立性）
- en: Let (Ω,Σ,P) be a probability space and let A,B ∈ Σ be two events. We say that
    A and B are independent if
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 设(Ω,Σ,P)为一个概率空间，A, B ∈ Σ为两个事件。如果A和B是独立的，则我们说
- en: '![P (A ∩ B) = P (A )P(B ) ](img/file1688.png)'
  id: totrans-347
  prefs: []
  type: TYPE_IMG
  zh: '![P (A ∩ B) = P(A)P(B) ](img/file1688.png)'
- en: holds.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 成立。
- en: Equivalently, this can be formulated in terms of conditional probabilities.
    By the definition, if A and B are independent, we have
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 等效地，可以通过条件概率来表述此问题。根据定义，如果A和B是独立的，我们有
- en: '![P (B | A ) = P(A-∩-B-) P(A ) P(A-)P(B-) = P (A) = P(B ). ](img/file1689.png)'
  id: totrans-350
  prefs: []
  type: TYPE_IMG
  zh: '![P (B | A ) = P(A∩B) / P(A ) = P(A)P(B) ](img/file1689.png)'
- en: To see an example, let’s go back to coin tossing and suppose that we toss a
    coin two times. Let the result of the first and second toss be denoted by X[1]
    and X[2], respectively. What is the probability that both of these tosses are
    heads? As we saw when discussing this example in Section [18.2.4](ch030.xhtml#probability-measures),
    we can see that
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，回到掷硬币的情景，假设我们投掷一枚硬币两次。设第一次和第二次的投掷结果分别用X[1]和X[2]表示。那么这两次投掷都是正面的概率是多少？正如我们在[18.2.4](ch030.xhtml#probability-measures)节中讨论过的，我们可以看到
- en: '![P (X1 = heads and X2 = heads) = P(X1 = heads)P (X2 = heads) = 1\. 4 ](img/file1690.png)'
  id: totrans-352
  prefs: []
  type: TYPE_IMG
  zh: '![P (X1 = 正面且X2 = 正面) = P(X1 = 正面)P(X2 = 正面) = 1\. 4 ](img/file1690.png)'
- en: That is, the two events are independent of each other.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，这两个事件是彼此独立的。
- en: Regarding probability, there are many common misconceptions. One is about the
    interpretation of independence. Suppose that I toss a fair coin ten times, all
    of them resulting in heads. What is the probability that my next toss will be
    heads?
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 关于概率，有很多常见的误解。其中之一是关于独立性的解释。假设我投掷一枚公平的硬币十次，结果每次都是正面。那么我下一次投掷得到正面的概率是多少？
- en: Most would immediately conclude that this must be very small since having eleven
    heads in a row is highly unlikely. However, once we have the ten results available,
    we no longer talk about the probability of eleven coin tosses, just the last one!
    Since the coin tosses are independent of each other, the chance of heads for the
    eleventh toss (given the results of the previous ten) is still 50%.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数人会立即得出结论：这是一个非常小的概率，因为连续十一次得到正面是极不可能的。然而，一旦我们得到了前十次的结果，我们就不再讨论十一次投掷的概率，而只是讨论最后一次！由于硬币投掷彼此独立，第十一投（在前十次结果已知的条件下）得到正面的概率仍然是50%。
- en: This phenomenon is called the gambler’s fallacy, and I am pretty sure that at
    some point in your life, you fell victim to it. (I sure did.)
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 这种现象被称为赌徒谬误，我敢肯定，在你的一生中，你曾经成为过它的受害者。（我自己也有过。）
- en: In practical scenarios, working with conditional probabilities might be easier.
    (For instance, sometimes we can estimate them directly, while the standard probabilities
    are difficult to gauge.) Because of this, we need tools to work with them.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际场景中，处理条件概率可能更为简便。（例如，有时候我们可以直接估计条件概率，而标准概率则很难衡量。）因此，我们需要一些工具来处理它们。
- en: 18.3.2 The law of total probability revisited
  id: totrans-358
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 18.3.2 总概率法则再探
- en: Remember the law of total probability from Theorem [113](ch030.xhtml#x1-286004r113)?
    We can use conditional probabilities to put it into a slightly different form.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得定理[113](ch030.xhtml#x1-286004r113)中的总概率法则吗？我们可以使用条件概率将其转换为稍微不同的形式。
- en: Theorem 117\. (Law of total probability, conditional version)
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 117.（总概率法则，条件版）
- en: Let (Ω,Σ,P) be a probability space and let A ∈ Σ be an arbitrary event. If A[1],A[2],⋅⋅⋅∈
    Σ are mutually disjoint events (that is, A[i] ∩A[j] = ∅if i≠j) for which ∪[n=1]^∞A[n]
    = Ω, then
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 设(Ω, Σ, P)为一个概率空间，且A ∈ Σ为任意事件。如果A[1], A[2], ⋅⋅⋅ ∈ Σ为互不相交的事件（即A[i] ∩ A[j] = ∅，当i
    ≠ j时），并且∪[n=1]^∞A[n] = Ω，则
- en: P(A) = ∑[k=1]^∞ P(A | A[k]) P(A[k]) (18.6)
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: P(A) = ∑[k=1]^∞ P(A | A[k]) P(A[k]) (18.6)
- en: 'Proof. The proof is the trivial application of the law of total probability
    (Theorem [113](ch030.xhtml#x1-286004r113)) and the definition of conditional probabilities:
    as P(A ∩A[k]) = P(A∣A[k])P(A[k]),'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 证明：这个证明是全概率法则（定理[113](ch030.xhtml#x1-286004r113)）和条件概率定义的简单应用：因为P(A ∩ A[k])
    = P(A∣A[k])P(A[k])，
- en: P(A) = ∑[k=1]^∞ P(A ∩ A[k]) = ∑[k=1]^∞ P(A | A[k]) P(A[k])
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: P(A) = ∑[k=1]^∞ P(A ∩ A[k]) = ∑[k=1]^∞ P(A | A[k]) P(A[k])
- en: holds, which is what we had to show.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 成立，这就是我们需要证明的内容。
- en: Why is this useful for us? Let’s demonstrate this with an example. Suppose that
    we have three urns containing light and dark colored balls.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么这对我们有用呢？让我们通过一个例子来展示。假设我们有三个 urn，其中包含浅色和深色球。
- en: The first one contains 4 dark, the second one contains 2 light and 2 dark, while
    the last one contains 1 light and 3 dark balls.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个 urn 包含4个深色球，第二个 urn 包含2个浅色球和2个深色球，而最后一个 urn 包含1个浅色球和3个深色球。
- en: '![PIC](img/file1692.png)'
  id: totrans-368
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file1692.png)'
- en: 'Figure 18.7: Urns with colored balls'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.7：包含彩色球的 urn
- en: We randomly pick an urn; however, picking the first one is twice as likely as
    picking the other two. (That is, we pick the first urn 50% of the time, while
    the second and the third 25%–25% of the time.) From that urn, we also randomly
    pick a ball. What is the probability that we select a light ball? Without using
    the law of total probability, this is difficult to compute.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随机选择一个 urn；然而，选择第一个 urn 的概率是选择另外两个的两倍。（也就是说，我们选择第一个 urn 的概率是50%，而选择第二个和第三个
    urn 的概率分别为25%和25%。）然后，我们从该 urn 中随机挑选一个球。那么，我们选择一个浅色球的概率是多少？如果不使用全概率法则，这个计算是比较困难的。
- en: Let’s denote the color of the selected ball by X and suppose that the event
    A[n] describes picking the n-th urn. Then, we have
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 设选中的球的颜色为X，并假设事件A[n]表示选择了第n个 urn。那么，我们有
- en: '![ ∑3 ∑3 P (X = light) = P ({X = light} ∩ Ak) = P (X = light | Ak )P (Ak).
    k=1 k=1 ](img/file1693.png)'
  id: totrans-372
  prefs: []
  type: TYPE_IMG
  zh: '![ ∑3 ∑3 P (X = light) = P ({X = light} ∩ Ak) = P (X = light | Ak )P (Ak).
    k=1 k=1 ](img/file1693.png)'
- en: Without using conditional probabilities, calculating P({X = light}∩A[k]) is
    difficult (since we are not picking each urn with equal probability). However,
    we can simply calculate the conditionals by counting the number of light balls
    in each urn. That is, we have
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 不使用条件概率，计算P({X = light}∩A[k])是困难的（因为我们并非以等概率选择每个 urn）。但是，我们可以通过计算每个 urn 中浅色球的数量来简化条件概率的计算。也就是说，我们有
- en: '![P(X = light | A1 ) = 0 2 P(X = light | A2 ) = 4 1 P(X = light | A3 ) =-.
    4 ](img/file1694.png)'
  id: totrans-374
  prefs: []
  type: TYPE_IMG
  zh: '![P(X = light | A1 ) = 0 2 P(X = light | A2 ) = 4 1 P(X = light | A3 ) =-.
    4 ](img/file1694.png)'
- en: Since P(A[1]) = 1∕2,P(A[2]) = 1∕4, and P(A[3]) = 1∕4, the probability we are
    looking for is
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 由于P(A[1]) = 1/2, P(A[2]) = 1/4, 且P(A[3]) = 1/4，我们要寻找的概率是
- en: '![ ∑3 P (X = light) = P (X = light | Ak)P (Ak) k=1 1 2 1 1 1 = 0⋅ 2 + 4 ⋅ 4
    + 4 ⋅ 4 3 = --. 16 ](img/file1695.png)'
  id: totrans-376
  prefs: []
  type: TYPE_IMG
  zh: '![ ∑3 P (X = light) = P (X = light | Ak)P (Ak) k=1 1 2 1 1 1 = 0⋅ 2 + 4 ⋅ 4
    + 4 ⋅ 4 3 = --. 16 ](img/file1695.png)'
- en: Note that because the urns are not selected with equal probability,
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于 urn 的选择并非等概率，
- en: '![ number of light balls P (X = light) ⁄= ------------------, number of balls
    ](img/file1696.png)'
  id: totrans-378
  prefs: []
  type: TYPE_IMG
  zh: '![ 浅色球的数量 P (X = light) ⁄= ------------------, 球的总数 ](img/file1696.png)'
- en: as one would naively guess.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 如同直觉上猜测的那样。
- en: 'Another useful property of the conditional probability is that, due to its
    definition, we can use it to express the joint probability of events:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 条件概率的另一个有用性质是，由于其定义，我们可以利用它来表示事件的联合概率：
- en: '![P (A ∩ B ) = P (B | A )P (A). ](img/file1697.png)'
  id: totrans-381
  prefs: []
  type: TYPE_IMG
  zh: '![P (A ∩ B ) = P (B | A )P (A). ](img/file1697.png)'
- en: Even though this sounds trivial, there are cases when we can estimate/compute
    the conditional probability but not the joint probability. In fact, this simple
    identity can be generalized for an arbitrary number of conditions. This is called
    the chain rule. (Despite its name, it has nothing to do with the chain rule for
    differentiation.)
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这听起来很简单，但有时我们可以估计/计算条件概率，但却无法计算联合概率。事实上，这个简单的恒等式可以推广到任意数量的条件，这就是链式法则。（尽管它叫做链式法则，但与微分中的链式法则无关。）
- en: Theorem 118\. (The chain rule)
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 定理118. （链式法则）
- en: Let (Ω,Σ,P) be a probability space and A[1],A[2],⋅⋅⋅∈ Σ be arbitrary events.
    Then,
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 设(Ω, Σ, P)为一个概率空间，A[1], A[2], ⋅⋅⋅ ∈ Σ为任意事件。那么，
- en: P(A) = ∑[k=1]^∞ P(A | A[k]) P(A[k]) (18.7)
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: P(A) = ∑[k=1]^∞ P(A | A[k]) P(A[k]) (18.7)
- en: holds.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 成立。
- en: Proof. First, we notice that P(A[1] ∩⋅⋅⋅∩A[n]) can be written as
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 证明：首先，我们注意到P(A[1] ∩⋅⋅⋅∩A[n])可以写为
- en: '![ P (A1 ∩ ⋅⋅⋅∩An ) P (A1 ∩ ⋅⋅⋅∩ An −1) P (A1 ∩ A2) P(A1 ∩⋅⋅⋅∩An ) =------------------------------------...-----------P
    (A1), P (A1 ∩ ⋅⋅⋅ ∩An −1)P (A1 ∩ ⋅⋅⋅∩ An −2) P(A1 ) ](img/file1701.png)'
  id: totrans-388
  prefs: []
  type: TYPE_IMG
  zh: '![ P (A1 ∩ ⋅⋅⋅∩An ) P (A1 ∩ ⋅⋅⋅∩ An −1) P (A1 ∩ A2) P(A1 ∩⋅⋅⋅∩An ) =------------------------------------...-----------P
    (A1), P (A1 ∩ ⋅⋅⋅ ∩An −1)P (A1 ∩ ⋅⋅⋅∩ An −2) P(A1 ) ](img/file1701.png)'
- en: because the terms cancel out each other.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这些项互相抵消。
- en: Since
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 由于
- en: '![-P(A1-∩-Ak)-- P(A1 ∩ Ak−1) = P (Ak | A1,...,Ak− 1), ](img/file1702.png)'
  id: totrans-391
  prefs: []
  type: TYPE_IMG
  zh: '![-P(A1∩Ak) - P(A1 ∩ Ak−1) = P (Ak | A1,...,Ak− 1), ](img/file1702.png)'
- en: the chain rule ([18.7](ch030.xhtml#x1-291007r118)) follows.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 链式法则（[18.7](ch030.xhtml#x1-291007r118)）随之得出。
- en: 18.3.3 The Bayes theorem
  id: totrans-393
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 18.3.3 贝叶斯定理
- en: In essence, machine learning is about turning observations into predictive models.
    Probability theory gives us a language to express our models. For instance, going
    back to our spam filter example, we can notice that 5% of our emails are spam.
    However, this is not enough information to filter out spam emails. Upon inspection,
    we have observed that 95% of emails that contain the phrase “act now” are spam
    (but only 1% of all the emails contain “act now”). In the language of conditional
    probabilities, we have concluded that
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，机器学习是将观察转化为预测模型。概率论为我们提供了表达模型的语言。例如，回到我们的垃圾邮件过滤示例，我们可以注意到5%的邮件是垃圾邮件。然而，仅凭这些信息不足以过滤垃圾邮件。经过检查，我们观察到95%的包含“立即行动”这一短语的邮件是垃圾邮件（但只有1%的邮件包含“立即行动”）。用条件概率的语言来说，我们得出结论：
- en: '![P (spam | contains ”act now ”) = 0.95\. ](img/file1703.png)'
  id: totrans-395
  prefs: []
  type: TYPE_IMG
  zh: '![P (垃圾邮件 | 包含“立即行动”) = 0.95.](img/file1703.png)'
- en: With this, we can start looking for emails containing the phrase “act now” and
    discard them with 95% confidence. Is this spam filter effective? Not really, since
    there can be other frequent keywords in spam mails that we don’t check. How can
    we check this?
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们可以开始查找包含“立即行动”这一短语的邮件，并以95%的置信度将其丢弃。这个垃圾邮件过滤器有效吗？其实不太有效，因为垃圾邮件中可能还包含其他常见关键词，而我们并没有检查这些。我们该如何检查呢？
- en: For one, we can take a look at the conditional probability P(contains ”act now”∣spam),
    describing the frequency of the “act now” keyword among all the spam emails. A
    low frequency means that we are missing out on other keywords that we can use
    for filtering.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，我们可以看一下条件概率 P(包含“立即行动”|垃圾邮件)，它描述了在所有垃圾邮件中“立即行动”这一关键词的出现频率。低频率意味着我们错过了其他可以用于过滤的关键词。
- en: Generally speaking, we often want to compute/estimate the quantity P(A∣B), but
    our observations only allow us to infer P(B∣A). So, we need a way to reverse the
    condition and the event. With a bit of algebra, we can do this easily.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，我们通常希望计算/估算数量 P(A|B)，但我们的观察只能推断出 P(B|A)。因此，我们需要一种方法来反转条件和事件。通过一些代数运算，我们可以轻松做到这一点。
- en: Theorem 119\. (The Bayes formula)
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 119. （贝叶斯公式）
- en: Let (Ω,Σ,P) be a probability space, A,B be two arbitrary events, and suppose
    that P(A),P(B)/span>0\. Then,
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 设 (Ω, Σ, P) 为一个概率空间，A, B 为两个任意事件，且假设 P(A), P(B) > 0，那么，
- en: '![L(U,V ) = {f : U → V | f is linear}](img/equation_(26).png)(18.8)'
  id: totrans-401
  prefs: []
  type: TYPE_IMG
  zh: '![L(U,V ) = {f : U → V | f 是线性的}](img/equation_(26).png)(18.8)'
- en: holds.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 成立。
- en: Proof. By the definition of conditional probability, we have
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 证明：根据条件概率的定义，我们有
- en: '![ P(A-∩-B-) P(B | A ) = P(A ) = P(A-∩-B-)P(B-) P(B )P(A ) P-(B-) = P(A | B
    )P (A), ](img/file1705.png)'
  id: totrans-404
  prefs: []
  type: TYPE_IMG
  zh: '![ P(A∩B) P(B | A ) = P(A ) = P(A∩B)P(B) P(B )P(A ) P-(B-) = P(A | B )P (A),
    ](img/file1705.png)'
- en: which is what we had to show.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们需要证明的。
- en: To see how it works in action, let’s put it to the test in our spam filtering
    example. Given the information we know, we have
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证它的实际效果，让我们在垃圾邮件过滤示例中进行测试。根据我们所知道的信息，我们有
- en: '![P (spam | contains ”act now ”) = 0.95, P(contains ”act now ”) = 0.01, P (spam
    ) = 0.05\. ](img/file1706.png)'
  id: totrans-407
  prefs: []
  type: TYPE_IMG
  zh: '![P (垃圾邮件 | 包含“立即行动”) = 0.95, P(包含“立即行动”) = 0.01, P(垃圾邮件) = 0.05.](img/file1706.png)'
- en: So, according to the Bayes formula,
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，根据贝叶斯公式，
- en: '![ P-(spam--| contains-”act now-”)P(contains-”act now-”) P(contains ”act now”
    | spam) = P(spam) 0.95⋅0.01 = --------- 0.05 = 0.19\. ](img/file1707.png)'
  id: totrans-409
  prefs: []
  type: TYPE_IMG
  zh: '![ P-(垃圾邮件 | 包含“立即行动”) P(包含“立即行动”) P(包含“立即行动” | 垃圾邮件) = P(垃圾邮件) 0.95⋅0.01 =
    --------- 0.05 = 0.19. ](img/file1707.png)'
- en: Thus, by filtering only for the phrase “act now”, we are missing a lot of spam.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，仅仅过滤包含“立即行动”的邮件，我们会错过很多垃圾邮件。
- en: We can take the Bayes formula one step further by combining it with the law
    of total probability in Theorem [117](ch030.xhtml#x1-291003r117). (See the equation
    ([18.6](ch030.xhtml#x1-291003r117)).)
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将贝叶斯公式与定理[117](ch030.xhtml#x1-291003r117)中的全概率法则结合，进一步应用它。（见方程式([18.6](ch030.xhtml#x1-291003r117))。）
- en: Theorem 120\. (The Bayes theorem)
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 120. （贝叶斯定理）
- en: Let (Ω,Σ,P) be a probability space and let A,B ∈ Σ be arbitrary events. Moreover,
    let A[1],A[2],⋅⋅⋅∈ Σ be a partition of the event space Ω. (That is, the A[n]-s
    are pairwise disjoint and their union is the entire event space.) Then,
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 设(Ω, Σ, P)为一个概率空间，且A, B ∈ Σ为任意事件。此外，设A[1], A[2],⋅⋅⋅ ∈ Σ为事件空间Ω的一个划分。（即，A[n]是两两不相交的，并且它们的并集是整个事件空间。）那么，
- en: '![ ----P-(A-| B-)P-(B)--- P (B | A) = ∑ ∞ P (A | An)P (An) n=1 ](img/file1709.png)'
  id: totrans-414
  prefs: []
  type: TYPE_IMG
  zh: '![ ----P-(A-| B-)P-(B)--- P (B | A) = ∑ ∞ P (A | An)P (An) n=1 ](img/file1709.png)'
- en: holds.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 保持。
- en: Proof. The proof immediately follows from the Bayes formula (Theorem [119](ch030.xhtml#x1-292004r119))
    and the law of total probability (Theorem [117](ch030.xhtml#x1-291003r117).)
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。这个证明直接来自贝叶斯公式（定理[119](ch030.xhtml#x1-292004r119)）和全概率法则（定理[117](ch030.xhtml#x1-291003r117)）。
- en: 18.3.4 The Bayesian interpretation of probability
  id: totrans-417
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 18.3.4 概率的贝叶斯解释
- en: Historically, probability was introduced as the relative frequency of observed
    events in Section [18.2.7](ch030.xhtml#how-to-interpret-probability). However,
    the invention of conditional probabilities and the Bayes formula enabled another
    interpretation that slowly became prevalent in statistics and machine learning.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 历史上，概率是作为观察事件的相对频率引入的，见第[18.2.7节](ch030.xhtml#how-to-interpret-probability)。然而，条件概率和贝叶斯公式的发明使得另一种解释逐渐在统计学和机器学习中流行起来。
- en: In pure English, the Bayes formula can be thought of as updating our probabilistic
    models using new observations. Suppose that we are interested in the event B.
    Without observing anything, we can formulate a probabilistic model by assigning
    a probability to B, that is, estimating P(B). This is what we call the prior.
    However, observing another event A might change our probabilistic model.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 在纯英文中，贝叶斯公式可以被理解为通过新的观察结果来更新我们的概率模型。假设我们对事件B感兴趣。在没有任何观察的情况下，我们可以通过给B分配一个概率来构建一个概率模型，即估计P(B)。这就是我们所说的先验。然而，观察到另一个事件A可能会改变我们的概率模型。
- en: Thus, we would like to estimate the posterior probability P(B∣A). We can’t do
    this directly, but thanks to our prior model, we can tell P(A∣B). The quantity
    P(A∣B) is called the likelihood. Combining these with the Bayes formula, we can
    see that the posterior is proportional to the likelihood and the prior.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们希望估计后验概率P(B∣A)。我们不能直接这样做，但多亏了我们的先验模型，我们可以知道P(A∣B)。这个量P(A∣B)被称为似然。将这些与贝叶斯公式结合起来，我们可以看到后验与似然和先验成正比。
- en: '![PIC](img/file1710.png)'
  id: totrans-421
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file1710.png)'
- en: 'Figure 18.8: The Bayes formula, as the product of the likelihood and prior'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.8：贝叶斯公式，作为似然和先验的乘积
- en: Let’s see a concrete example that will make the idea clear. Suppose that we
    are creating a diagnostic test for an exotic disease. How likely is the disease
    present in a random person?
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个具体的例子，以便更清楚地理解这个概念。假设我们正在为一种罕见疾病开发诊断测试。那么，随机一个人是否患有这种疾病的概率有多大？
- en: Without knowing any specifics about the situation, we can only use statistics
    to formulate the probability model. Let’s say that only 2% of the population is
    affected. So, our probabilistic model is
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 在不了解任何具体情况的情况下，我们只能通过统计来构建概率模型。假设只有2%的人口受影响。那么，我们的概率模型是
- en: '![P (infected) = 0.02, P(healthy) = 0.98\. ](img/file1711.png)'
  id: totrans-425
  prefs: []
  type: TYPE_IMG
  zh: '![P (infected) = 0.02, P(healthy) = 0.98\. ](img/file1711.png)'
- en: However, once someone produces a positive test, things change. The goal is to
    estimate the posterior probability P(infected∣positive), a more accurate model.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一旦某人产生了阳性测试结果，情况就会发生变化。目标是估计后验概率P(infected∣positive)，一个更准确的模型。
- en: Since no medical test is perfect, false positives and false negatives can happen.
    From the manufacturer, we know that it gives true positives 99% of the time, but
    the chance of a false positive is 5%. In probabilistic terms, we have
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 由于没有任何医疗测试是完美的，因此可能会发生假阳性和假阴性。从制造商那里，我们知道该测试在99%的情况下会给出真正的阳性结果，但假阳性的概率是5%。用概率术语来说，我们有
- en: '![P (positive | infected) = 0.99, P (positive | healthy) = 0.05\. ](img/file1712.png)'
  id: totrans-428
  prefs: []
  type: TYPE_IMG
  zh: '![P (positive | infected) = 0.99, P (positive | healthy) = 0.05\. ](img/file1712.png)'
- en: With these, the Bayes theorem gives us
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这些，贝叶斯定理给出了
- en: '![ P (positive | infected)P(infected) P(infected | positive) = P-(positive-|
    infected)P(infected)+-P-(positive-| healthy)P-(healthy) = ------0.99⋅0.02------
    0.99⋅0.02 + 0.05 ⋅0.98 ≈ 0.29\. ](img/file1713.png)'
  id: totrans-430
  prefs: []
  type: TYPE_IMG
  zh: '![ P (positive | infected)P(infected) P(infected | positive) = P-(positive-|
    infected)P(infected)+-P-(positive-| healthy)P-(healthy) = ------0.99⋅0.02------
    0.99⋅0.02 + 0.05 ⋅0.98 ≈ 0.29\. ](img/file1713.png)'
- en: So, the chance of being infected upon producing a positive test is surprisingly
    29% (given these specific true and false positive rates).
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，在给出阳性测试结果时，感染的概率令人惊讶地为29%（假设这些特定的真正阳性和假阳性率）。
- en: These probabilistic thinking principles are also valid for machine learning.
    If we abstract away the process of learning from data, we are essentially 1) making
    observations, 2) updating our models given the new observations, and 3) starting
    the process all over again. The Bayes theorem gives a concrete tool for the job.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 这些概率思维原则同样适用于机器学习。如果我们抽象化地看待从数据中学习的过程，实际上我们是在进行1）观察，2）根据新的观察更新我们的模型，以及3）重新开始这个过程。贝叶斯定理为这个过程提供了具体的工具。
- en: 18.3.5 The probabilistic inference process
  id: totrans-433
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 18.3.5 概率推理过程
- en: As we have seen before, probability theory is the extension of mathematical
    logic. So far, we have discussed how logical connectives correspond to set operations
    and how probability generalizes the truth value by adding the component of uncertainty.
    What about the probabilistic inference process? Can we generalize classical inference
    and use probabilistic reasoning to construct arguments? Yes.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所见，概率论是数学逻辑的扩展。到目前为止，我们讨论了逻辑连接词如何与集合运算对应，以及概率如何通过加入不确定性成分来推广真值。那么，如何处理概率推理过程呢？我们能否将经典推理推广，利用概率推理来构建论证？答案是肯定的。
- en: To illustrate, let’s start with a story. It’s 6:00 AM. The alarm clock is blasting
    but you are having a hard time getting out of bed. You don’t feel well. Your muscles
    are weak, and your head is exploding. After a brief struggle, you manage to call
    a doctor and list all the symptoms. Your sore throat makes speaking painful.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，我们从一个故事开始。现在是早上6点，闹钟响个不停，但你起床非常困难。你感觉不舒服，肌肉无力，头痛欲裂。经过短暂的挣扎后，你终于拨通了医生的电话，列出了所有症状。喉咙痛让你说话都感到疼痛。
- en: “It’s probably just the flu,“ they say.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: “这可能只是流感，”他们说。
- en: Interactions like this are everyday occurrences. Yet, we hardly think about
    the reasoning process behind them. After all, you could have been hungover. Similarly,
    if the police find a murder weapon at your house, they’ll suspect that you are
    the killer. The two are related but not the same. For instance, the murder weapon
    could have been planted.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样的互动是日常常见的事。然而，我们很少考虑它们背后的推理过程。毕竟，你可能只是宿醉了。同样，如果警察在你家里发现谋杀武器，他们会怀疑你是凶手。两者之间有关联，但不完全相同。例如，谋杀武器可能是被安置的。
- en: 'The bulk of humanity’s knowledge is obtained in this manner: we collect evidence,
    then build hypotheses. How do we infer the underlying cause from observing the
    effect? Most importantly, how can we avoid fooling ourselves into false conclusions?'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 人类知识的主要来源就是通过这种方式获得的：我们收集证据，然后建立假设。我们如何从观察结果推断出潜在原因？最重要的是，我们如何避免自欺欺人，得出错误的结论？
- en: Let’s focus on “muscle fatigue, headache, sore throat →flu“. This is certainly
    not true in an absolute sense, as these symptoms resemble how you would feel after
    shouting and drinking excessively during a metal concert, which is far from the
    flu. Yet, a positive diagnosis of flu is plausible. Given the evidence at hand,
    our belief is increased in the hypothesis.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 我们来关注一下“肌肉疲劳、头痛、喉咙痛 → 流感”。从绝对意义上来说，这显然不对，因为这些症状更像是你在金属音乐会中大声喊叫和过度饮酒后会感觉到的那种不适，离流感相差甚远。然而，流感的阳性诊断是有可能的。鉴于当前的证据，我们对这一假设的信心增强了。
- en: Unfortunately, classical logic cannot deal with plausible, only with the absolute.
    Probability theory solves this problem by measuring plausibility on a 0 − 1 scale,
    instead of being stuck at the extremes. Zero is impossible. One is certain. All
    the values in between represent degrees of uncertainty.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，经典逻辑无法处理“可能性”，只能处理“绝对”。概率论通过在0到1的区间内测量可能性，解决了这个问题，而不是固守极端。零是不可能的。 一是确定的。介于两者之间的所有值表示不确定性的不同程度。
- en: Let’s put this into mathematical terms!
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用数学术语来表达这一点！
- en: 'How can we establish a probabilistic link between cause and effect? In classical
    logic, events are interesting in the context of other events. Before, implication
    and modus ponens provided the context. Translated to the language of probability,
    the question is the following: What is the probability of B, given that A is observed?
    The answer: conditional probabilities.'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何在因果关系之间建立概率联系？在经典逻辑中，事件在其他事件的上下文中才具有意义。之前，蕴涵和模态肯定提供了这种上下文。用概率的语言来说，问题是这样的：在观察到A的情况下，B发生的概率是多少？答案是：条件概率。
- en: Why does conditional probability generalize the concept of implication? It’s
    easier to draw a picture, so consider the two extreme cases in Figure [18.9](#).
    (Recall that implication corresponds to the subset relation, as we saw earlier.)
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么条件概率能够推广蕴含的概念？画图会更容易理解，考虑图 [18.9](#) 中的两个极端情况。（回忆一下，蕴含对应于子集关系，正如我们之前所看到的。）
- en: '![PIC](img/file1714.png)'
  id: totrans-444
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file1714.png)'
- en: 'Figure 18.9: Conditional probability as logical implication'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.9：条件概率作为逻辑蕴含
- en: 'Essentially, P(B∣A) = 1 means that A →B is true, while P(B∣A) = 0 means that
    it is not. We can take this analogy further: a small P(B∣A) means that A →B is
    likely to be false, and a large P(B∣A) means that it is likely to be true.'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，P(B∣A) = 1 表示 A →B 成立，而 P(B∣A) = 0 则表示不成立。我们可以进一步类比：小的 P(B∣A) 表示 A →B 可能为假，而大的
    P(B∣A) 则表示它很可能为真。
- en: This is illustrated by Figure [18.10](#).
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 这在图 [18.10](#) 中得到了说明。
- en: '![PIC](img/file1715.png)'
  id: totrans-448
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file1715.png)'
- en: 'Figure 18.10: Conditional probability as the extension of logical implication'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.10：条件概率作为逻辑蕴含的扩展
- en: 'Thus, the “probabilistic modus ponens” goes like this:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，“概率性模式假言推理”是这样的：
- en: P(B∣A) ≈ 1.
  id: totrans-451
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: P(B∣A) ≈ 1。
- en: A.
  id: totrans-452
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: A。
- en: Therefore, B is probable.
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，B是可能的。
- en: 'This is quite a relief, as now we have a solid theoretical justification for
    most of our decisions. Thus, the diagnostic process that kicked up our investigation
    makes a lot more sense now:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 这让人松了一口气，因为现在我们对大多数决策都有了坚实的理论依据。因此，启动我们调查的诊断过程现在更有意义了：
- en: P(flu∣headache, muscle fatigue, sore throat) ≈ 1.
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: P(流感∣头痛、肌肉疲劳、喉咙痛) ≈ 1。
- en: “Headache and muscle fatigue”.
  id: totrans-456
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: “头痛和肌肉疲劳”。
- en: Therefore, “flu” is probable.
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，“流感”是可能的。
- en: However, one burning question remains. How do we know that P(B∣A) ≈ 1 holds?
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，仍然有一个悬而未决的问题。我们如何知道 P(B∣A) ≈ 1 是成立的？
- en: Let’s focus on the probabilistic version of “headache, sore throat, muscle fatigue
    →flu“. We know that this is not certain, only plausible. Yet, the reverse implication
    “flu →headache, sore throat, muscle fatigue“ is almost certain.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们关注“头痛、喉咙痛、肌肉疲劳 →流感”的概率版本。我们知道这不是确定的，只是合理的。然而，反向蕴含“流感 →头痛、喉咙痛、肌肉疲劳”几乎是确定的。
- en: When naively arguing that the evidence implies the hypothesis, we have the opposite
    in mind. Instead of applying the modus ponens, we use the faulty argument
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们天真地认为证据意味着假设时，我们心里想的是相反的情况。我们没有应用模式假言推理，而是使用了错误的论证。
- en: A →B.
  id: totrans-461
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: A →B。
- en: B.
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: B。
- en: Therefore, A.
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，A。
- en: 'We have talked about this before: this logical fallacy is called affirming
    the consequent, and it’s completely wrong from a purely logical standpoint. However,
    the Bayes theorem provides a probabilistic twist.'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前讨论过：这种逻辑谬误叫做肯定后件，从纯粹逻辑的角度来看是完全错误的。然而，贝叶斯定理提供了一个概率性的转折。
- en: The proposition A →B translates to P(B∣A) = 1, which implies that when A is
    observed, B occurs as well. Why? Because then we have
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 命题 A →B 转化为 P(B∣A) = 1，这意味着当观察到 A 时，B 也会发生。为什么？因为这样我们就得到了
- en: '![ P-(B-| A-)P-(A) P(A | B) = P (B) = P-(A) P (B) ≥ P(A ). ](img/file1716.png)'
  id: totrans-466
  prefs: []
  type: TYPE_IMG
  zh: '![ P-(B-| A-)P-(A) P(A | B) = P (B) = P-(A) P (B) ≥ P(A ). ](img/file1716.png)'
- en: 'This is good news, as reversing the implication is not totally wrong. Instead,
    we have the probabilistic affirming the consequent:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 这是个好消息，因为反转蕴含并非完全错误。相反，我们有了概率性的肯定后件：
- en: A →B.
  id: totrans-468
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: A →B。
- en: B.
  id: totrans-469
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: B。
- en: Therefore, A is more probable.
  id: totrans-470
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，A 更可能。
- en: With this, the probabilistic reasoning process makes perfect sense. To recall,
    the issue with arguments such as “if you have muscle fatigue, sore throat, and
    a headache, then you have the flu“ is that the symptoms can be caused by other
    conditions, and in rare cases, the flu does not carry all of these symptoms.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，概率推理过程变得完全合理。回顾一下，“如果你有肌肉疲劳、喉咙痛和头痛，那么你得了流感”这样的论证有问题，因为这些症状也可能由其他疾病引起，而且在少数情况下，流感并不会出现所有这些症状。
- en: 'Yet, this kind of thinking can be surprisingly effective in real-life decision-making.
    Probability and conditional probability extend our reasoning toolkit with inductive
    methods in three steps:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种思维方式在现实生活中的决策中可以出奇有效。概率和条件概率通过三步推理扩展了我们的推理工具包：
- en: Generalizes the binary 0 − 1 truth values to allow the representation of uncertainty.
  id: totrans-473
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将二元的 0 − 1 真值扩展到允许表示不确定性。
- en: Defines the analogue of “if A, then B“-type implications using conditional probability.
  id: totrans-474
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义了“如果 A，则 B”类型的蕴含的类比，使用条件概率。
- en: Provides a method to infer the cause from observing the effect.
  id: totrans-475
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供了一种从观察效果推断原因的方法。
- en: 'These three ideas are seriously powerful, and their inception has enabled science
    to perform unbelievable feats. (If you are interested in learning more about the
    relation of probability theory and logic, I recommend you the great book Probability
    Theory: The Logic of Science by E. T. Jaynes.)'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: '这三个思路非常强大，它们的诞生使得科学能够取得难以置信的成就。（如果你对概率论与逻辑的关系感兴趣，我推荐你阅读E. T. Jaynes的经典著作《Probability
    Theory: The Logic of Science》）'
- en: There’s one more thing I would like to show you. Let’s go back to the mid-twentieth
    century and look at how a TV show shaped probabilistic thinking.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一件事我想给你展示。让我们回到二十世纪中期，看看一个电视节目是如何塑造概率思维的。
- en: 18.3.6 The Monty Hall paradox
  id: totrans-478
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 18.3.6 蒙提霍尔悖论
- en: Before we finish with conditional probability, we’ll touch on an important problem.
    Regarding probability, we often have seemingly contradictory phenomena, going
    against our intuitive expectations. These are called paradoxes. To master probabilistic
    thinking, we need to resolve them and eliminate common fallacies from our thinking
    processes. So far, we have already seen the gambler’s fallacy when talking about
    the concept of independence in Section [18.3.1](ch030.xhtml#independence). Now,
    we’ll discuss the famous Monty Hall paradox.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束条件概率之前，我们将讨论一个重要问题。在概率论中，我们经常会遇到一些看似矛盾的现象，违背了我们的直觉预期。这些现象被称为悖论。为了掌握概率思维，我们需要解决这些悖论，并消除我们思维过程中的常见谬误。到目前为止，我们在讨论独立性概念时已经看到过赌徒谬误（在[18.3.1](ch030.xhtml#independence)节中）。现在，我们将讨论著名的蒙提霍尔悖论。
- en: In the ’60s, there was a TV show in the United States called Let’s Make a Deal
    ( [https://en.wikipedia.org/wiki/Let\%27s_Make_a_Deal](https://en.wikipedia.org/wiki/Lets_Make_a_Deal)).
    As a contestant, you faced three closed doors, one having a car behind it (that
    you could take home), while the others had nothing. You had the opportunity to
    open one.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 在60年代，美国有一个叫《Let's Make a Deal》（[https://en.wikipedia.org/wiki/Let\%27s_Make_a_Deal](https://en.wikipedia.org/wiki/Lets_Make_a_Deal)）的电视节目。作为参赛者，你面对三扇关闭的门，其中一扇门后面藏着一辆车（你可以带回家），其他两扇门后面什么也没有。你有机会打开其中一扇门。
- en: '![PIC](img/file1717.png)'
  id: totrans-481
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file1717.png)'
- en: 'Figure 18.11: Three closed doors, one of which contains a reward behind it'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.11：三扇关闭的门，其中一扇门后面藏着奖励
- en: Suppose that after selecting door no. 1, Monty Hall — the show host — opens
    the third door, showing that it was not the winning one. Now, you have the opportunity
    to change your mind and open door no. 2 instead of the first one. Do you take
    it?
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 假设在选择了第一扇门后，节目主持人蒙提霍尔打开了第三扇门，显示它不是获胜的那扇门。现在，你有机会改变主意，选择打开第二扇门，而不是第一扇门。你会选择换门吗？
- en: '![PIC](img/file1718.png)'
  id: totrans-484
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file1718.png)'
- en: 'Figure 18.12: Monty opened the third door for you. Do you switch?'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.12：蒙提为你打开了第三扇门。你是否要换门？
- en: At first glance, your chances are 50%/50%, so you might not be better off by
    switching. However, this is not true!
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，你的获胜机会是50%/50%，因此你可能觉得换门没有什么优势。然而，这并不是真的！
- en: To set things straight, let’s do a careful probabilistic analysis. Let A[i]
    denote the event that the prize is behind the i-th door, while B[i] is the event
    of Monty opening the i-th door. Before Monty opens the third one, our model is
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 为了澄清问题，让我们进行一个仔细的概率分析。设A[i]表示奖品在第i扇门后面的事件，B[i]表示蒙提打开第i扇门的事件。在蒙提打开第三扇门之前，我们的模型是
- en: '![P (A1) = P(A2 ) = P (A3) = 1, 3 ](img/file1719.png)'
  id: totrans-488
  prefs: []
  type: TYPE_IMG
  zh: '![P (A1) = P(A2 ) = P (A3) = 1, 3 ](img/file1719.png)'
- en: and we want to calculate P(A[1]∣B[3]) and P(A[2]∣B[3]).
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在想计算P(A[1]∣B[3])和P(A[2]∣B[3])。
- en: By thinking from the perspective of the show host, which door would you open?
    If you know that the prize is behind the 1st door, you open the 2nd and 3rd one
    with equal probability. However, if the prize is actually behind the 2nd door
    (and the contestant selected the 1st one), you always open the 3rd one. That is,
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 从节目的主持人角度思考，你会选择打开哪扇门？如果你知道奖品在第一扇门后面，你会平等概率地打开第二和第三扇门。然而，如果奖品实际上在第二扇门后面（并且参赛者选择了第一扇门），你总是会打开第三扇门。也就是说，
- en: '![P (B | A ) = P (B | A ) = 1, 3 1 2 1 2 P (B3 | A2) = 1\. ](img/file1720.png)'
  id: totrans-491
  prefs: []
  type: TYPE_IMG
  zh: '![P (B | A ) = P (B | A ) = 1, 3 1 2 1 2 P (B3 | A2) = 1\. ](img/file1720.png)'
- en: Thus, by applying the Bayes formula, we have
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通过应用贝叶斯公式，我们得出
- en: '![ P(B3 | A1 )P(A1) P(A1 | B3 ) =---------------- P(B3 ) = -1∕6--, P(B3 ) ](img/file1721.png)'
  id: totrans-493
  prefs: []
  type: TYPE_IMG
  zh: '![ P(B3 | A1 )P(A1) P(A1 | B3 ) =---------------- P(B3 ) = -1∕6--, P(B3 ) ](img/file1721.png)'
- en: and
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 和
- en: '![ P(B3 | A2 )P(A2) P(A2 | B3 ) =---------------- P(B3 ) = -1∕3--. P(B3 ) ](img/file1722.png)'
  id: totrans-495
  prefs: []
  type: TYPE_IMG
  zh: '![ P(B3 | A2 )P(A2) P(A2 | B3 ) =---------------- P(B3 ) = -1∕3--. P(B3 ) ](img/file1722.png)'
- en: In conclusion, P(A[2]∣B[3]) is twice as large as P(A[1]∣B[3]), from which we
    deduce
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，P(A[2]∣B[3]) 是 P(A[1]∣B[3]) 的两倍， 从中我们可以推断出
- en: '![P (A1 | B3) = 1, P (A2 | B3) = 2-. 3 3 ](img/file1723.png)'
  id: totrans-497
  prefs: []
  type: TYPE_IMG
  zh: '![P (A1 | B3) = 1, P (A2 | B3) = 2-. 3 3 ](img/file1723.png)'
- en: So, you should always switch doors. Surprising, isn’t it? Here, the paradox
    is that contrary to what we might expect, changing our minds is the better option.
    With clear probabilistic thinking, we can easily resolve this.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，你应该总是换门。是不是很令人惊讶？这里的悖论是，尽管我们可能预期相反，改变主意才是更好的选择。通过清晰的概率思维，我们可以轻松解决这个问题。
- en: 18.4 Summary
  id: totrans-499
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 18.4 总结
- en: 'Phew! We are at the end of an intimidatingly long, albeit extremely essential
    chapter. Although we’ve talked about the mathematical details of probability for
    a couple of dozen pages, the most important takeaway can be summarized in a sentence:
    probability theory extends our reasoning toolkit by handling uncertainty. Instead
    of measuring the truthiness of a proposition on a true-or-false binary scale,
    it opens up a spectrum between 0 and 1, where 0 represents (almost) impossible,
    and 1 represents (almost) certain.'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 呼！我们终于结束了一个令人畏惧的、虽然极其重要的章节。尽管我们已经讨论了几十页关于概率的数学细节，但最重要的收获可以用一句话总结：概率理论通过处理不确定性，扩展了我们的推理工具包。它不是通过真或假的二元尺度来衡量命题的真实性，而是开启了一个从
    0 到 1 的谱系，其中 0 代表（几乎）不可能，1 代表（几乎）确定。
- en: Mathematically speaking, probabilistic models are defined by probability measures
    and spaces, that is, structures of the form (Ω,Σ,P), where Ω is the set of possible
    elementary outcomes, Σ is the collection of events, and P is a probability measure,
    satisfying
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 从数学角度看，概率模型由概率度量和空间定义，即形如 (Ω, Σ, P) 的结构，其中 Ω 是可能的基本结果的集合，Σ 是事件的集合，P 是概率度量，满足
- en: P(Ω) = 1
  id: totrans-502
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: P(Ω) = 1
- en: and P(∪[n=1]^∞−A[n]) = ∑ [n=1]^∞P(A[n]) for all mutually disjoint A[n] ∈ Σ,
  id: totrans-503
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 并且 P(∪[n=1]^∞−A[n]) = ∑ [n=1]^∞P(A[n]) 对所有互不相交的 A[n] ∈ Σ 成立，
- en: 'which are called the Kolmogorov axioms. Thinking in probabilities enables us
    to reason under uncertainty: if P(A) is the probabilistic version of the truth
    value of a statement, then the conditional probability'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 这些被称为 Kolmogorov 公理。思考概率使我们能够在不确定性下进行推理：如果 P(A) 是命题的概率版本，那么条件概率
- en: '![P (B | A) = P-(A-∩-B) P (A) ](img/file1724.png)'
  id: totrans-505
  prefs: []
  type: TYPE_IMG
  zh: '![P (B | A) = P-(A-∩-B) P (A) ](img/file1724.png)'
- en: is the probabilistic version of the implication A →B.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 是蕴含命题 A → B 的概率版本。
- en: However, all the tools we learned are just the tips of a massive iceberg. To
    build truly beefy and useful models, we need to once more turn qualitative into
    quantitative, as we did for many advances in science and mathematics. Can you
    recall the dice rolling experiment, where we used a mysterious variable X to represent
    the outcome of the roll? Thus, we could talk about events such as “X = k”, turning
    a probability space into a sequence of numbers.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们所学的所有工具仅仅是巨大冰山的一角。要构建真正强大且有用的模型，我们需要像科学和数学的许多进展那样，将定性转化为定量。你还记得骰子掷出实验吗？我们使用一个神秘的变量
    X 来表示掷骰子的结果。通过这种方式，我们可以讨论像“X = k”这样的事件，将一个概率空间转化为一系列数字。
- en: It’s not a coincidence; it’s a method. X is an instance of a random variable,
    the premier object of probability theory and statistics. Random variables translate
    between abstract probability spaces to numbers and vectors, our old friends. Let’s
    make them a permanent tool in our belt.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是巧合；它是一种方法。X 是随机变量的一个实例，随机变量是概率论和统计学中的重要对象。随机变量在抽象的概率空间与数字和向量之间进行转换，我们的老朋友。让我们把它们作为我们工具箱中的永久工具。
- en: 18.5 Problems
  id: totrans-509
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 18.5 问题
- en: Problem 1\. Let’s roll two six-sided dice! Describe the event space, σ-algebra,
    and the corresponding probabilities for this experiment.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 问题 1. 让我们掷两个六面骰子！描述这个实验的事件空间、σ-代数以及相应的概率。
- en: Problem 2\. Let Ω = [0,1], and the corresponding σ-algebra be the generated
    algebra
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 问题 2. 让 Ω = [0,1]，对应的 σ-代数是生成代数
- en: '![ ( ) Σ = σ {(a,b] : 0 ≤ a <b ≤ 1} . ](img/file1725.png)'
  id: totrans-512
  prefs: []
  type: TYPE_IMG
  zh: '![ ( ) Σ = σ {(a,b] : 0 ≤ a <b ≤ 1} . ](img/file1725.png)'
- en: 'Show that the following events are members of Σ:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 证明以下事件是 Σ 的成员：
- en: (a) S[1] = {x} for all x ∈ [0,1].
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: (a) S[1] = {x}，对于所有 x ∈ [0,1]。
- en: (b) S[2] = ∪[i=1]^n(a[i],b[i]). (Show that this is also true when the intervals
    […] are replaced with open and half-open versions (…),(…],[…).)
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: (b) S[2] = ∪[i=1]^n(a[i],b[i])。（证明当区间 […] 被替换为开区间和半开区间（…），（…]，（…）时，这也成立。）
- en: (c) S[3] = [0,1] ∩ℚ. (That is, the set of rational numbers in [0,1].)
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: (c) S[3] = [0,1] ∩ℚ。 （即 [0,1] 中的有理数集合。）
- en: (d) S[4] = [0,1] ∩(ℝ ∖ℚ). (That is, the set of irrational numbers in [0,1].)
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: (d) S[4] = [0,1] ∩(ℝ ∖ℚ)。 （即 [0,1] 中的无理数集合。）
- en: Problem 3\. Let’s roll two six-sided dice. What is the probability that
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 问题 3. 让我们掷两个六面骰子。计算以下事件的概率：
- en: (a) Both rolls are odd numbers?
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: (a) 两次掷骰子都是奇数吗？
- en: (b) At least one of them is an odd number?
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: (b) 至少有一个是奇数吗？
- en: (c) None of them are odd numbers?
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: (c) 它们都不是奇数吗？
- en: Problem 4\. Let Ω = ℝ² be the event space, where we define the open disks
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 问题 4\. 设 Ω = ℝ² 为事件空间，其中我们定义了开放圆盘
- en: '= ![D (x,r) := {z ∈ ℝ2 : ∥x − z∥ <r}, x = (x1,x2) ∈ ℝ2, r >0, ](img/file1728.png)'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: '= ![D (x,r) := {z ∈ ℝ2 : ∥x − z∥ <r}, x = (x1,x2) ∈ ℝ2, r >0, ](img/file1728.png)'
- en: and the open rectangles by
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 以及由开放矩形构成的集合
- en: '![R(x,y ) = (x1,y1)× (x2,y2) 2 = {z = (z1,z2) ∈ ℝ : x1 <z1 <y1,x2 <z2 <y2}.
    ](img/file1729.png)'
  id: totrans-525
  prefs: []
  type: TYPE_IMG
  zh: '![R(x,y ) = (x1,y1)× (x2,y2) 2 = {z = (z1,z2) ∈ ℝ : x1 <z1 <y1,x2 <z2 <y2}.
    ](img/file1729.png)'
- en: Show that the σ-algebras generated by these sets are the same, that is,
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 证明由这些集合生成的 σ-代数是相同的，即，
- en: '![ ( 2 ) ( 2 ) σ {D (x, r) : x ∈ ℝ ,r >0} = σ {R (x,y) : x,y ∈ ℝ } . ](img/file1730.png)'
  id: totrans-527
  prefs: []
  type: TYPE_IMG
  zh: '![ ( 2 ) ( 2 ) σ {D (x, r) : x ∈ ℝ ,r >0} = σ {R (x,y) : x,y ∈ ℝ } . ](img/file1730.png)'
- en: Problem 5\. Let’s consider a variant of the Monty Hall problem. Suppose there
    are a hundred doors instead of three; only one contains a reward. Upon picking
    a door, Monty opens ninety-eight other doors, all of which are empty. Should you
    switch now?
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 问题 5\. 让我们考虑蒙提霍尔问题的一个变体。假设有一百扇门，而不是三扇；只有一扇门背后藏有奖励。在选择一扇门后，蒙提会打开另外九十八扇门，所有这些门后都是空的。现在你应该换门吗？
- en: Join our community on Discord
  id: totrans-529
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加入我们的Discord社区
- en: Read this book alongside other users, Machine Learning experts, and the author
    himself. Ask questions, provide solutions to other readers, chat with the author
    via Ask Me Anything sessions, and much more. Scan the QR code or visit the link
    to join the community. [https://packt.link/math](https://packt.link/math)
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他用户、机器学习专家和作者本人的一起阅读此书。提出问题，为其他读者提供解决方案，通过“问我任何问题”环节与作者聊天，还有更多内容。扫描二维码或访问链接加入社区。[https://packt.link/math](https://packt.link/math)
- en: '![PIC](img/file1.png)'
  id: totrans-531
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/file1.png)'
