- en: Adding Interactivity and Animating Plots
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加交互性并制作动画图表
- en: As a book focusing on the use of Matplotlib through elaborate examples, we opted
    to defer or simplify our discussion of the internals. For those of you who want
    to understand the nuts and bolts that make Matplotlib tick, you are advised to
    read *Mastering matplotlib* by Duncan M. McGreggor. At some point during our Matplotlib
    journey, it becomes inevitable for us to discuss more about backends, which turn
    plotting commands to graphics. These backends can be broadly classified as non-interactive
    or interactive. We will give examples that are pertinent to each backend class.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一本通过精心设计的示例讲解 Matplotlib 使用的书籍，我们选择推迟或简化内部机制的讨论。对于那些想要了解 Matplotlib 内部工作原理的读者，建议阅读
    Duncan M. McGreggor 的 *Mastering matplotlib*。在我们 Matplotlib 的学习旅程中，讨论后端已不可避免，这些后端将绘图命令转化为图形。这些后端可以大致分为非交互式或交互式。我们将提供与每种后端类别相关的示例。
- en: Matplotlib was not designed as an animation package from the get-go, thus it
    will appear sluggish in some advanced usages. For animation-centric applications,
    PyGame is a very good alternative ([https://www.pygame.org](https://www.pygame.org));
    it supports OpenGL- and Direct3D-accelerated graphics for the ultimate speed in
    animating objects. Nevertheless, Matplotlib has acceptable performance most of
    the time, and we will guide you through the steps to create animations that are
    more engaging than static plots.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Matplotlib 并非一开始就作为动画包设计，因此在某些高级应用中可能会显得有些缓慢。对于以动画为中心的应用，PyGame 是一个非常好的替代方案（[https://www.pygame.org](https://www.pygame.org)）；它支持
    OpenGL 和 Direct3D 加速图形，在动画对象时提供极快的速度。然而，Matplotlib 在大多数时候的表现还是可以接受的，我们将指导你如何创建比静态图表更具吸引力的动画。
- en: 'The examples in this chapter will be based on unemployment rates and earnings
    by educational attainment (2016), available from `data.gov` and curated by the
    Bureau of Labor Statistics, U.S. Department of Labor. Here is the outline of this
    chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的示例将基于失业率和按教育水平划分的收入数据（2016年），这些数据来自`data.gov`并由美国劳工部劳工统计局整理。以下是本章的大纲：
- en: Scraping information from websites
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从网站抓取信息
- en: Non-interactive backends
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非交互式后端
- en: 'Interactive backends: Tkinter, Jupyter, and Plot.ly'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交互式后端：Tkinter、Jupyter 和 Plot.ly
- en: Creating an animated plot
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建动画图表
- en: Exporting an animation as a video
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将动画导出为视频
- en: Scraping information from websites
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从网站抓取信息
- en: Governments or jurisdictions around the world are increasingly embracing the
    importance of open data, which aims to increase citizen involvement and informs
    about decision making, making policies more open to public scrutiny. Some examples
    of open data initiatives around the world include `data.gov` (United States of
    America), `data.gov.uk` (United Kingdom), and `data.gov.hk` (Hong Kong).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 全球各地的政府或辖区越来越重视开放数据的重要性，开放数据旨在增加公民参与，并为决策提供信息，使政策更加公开接受公众审议。全球一些开放数据计划的示例包括`data.gov`（美国）、`data.gov.uk`（英国）和`data.gov.hk`（香港）。
- en: These data portals often provide Application Programming Interfaces (APIs; see
    [Chapter 7](7daeb59b-3e8e-4a33-9437-2839c6ed47e4.xhtml), *Visualizing Online Data*, for
    more details) for programmatic access to data. However, APIs are not available
    for some datasets; hence, we resort to good old web scraping techniques to extract
    information from websites.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数据门户通常提供应用程序编程接口（API；有关更多详细信息，请参见[第7章](7daeb59b-3e8e-4a33-9437-2839c6ed47e4.xhtml)，*在线数据可视化*）以便编程访问数据。然而，一些数据集没有
    API，因此我们需要使用经典的网页抓取技术从网站提取信息。
- en: BeautifulSoup ([https://www.crummy.com/software/BeautifulSoup/](https://www.crummy.com/software/BeautifulSoup/))
    is an incredibly useful package used to scrape information from websites. Basically,
    everything marked with an HTML tag can be scraped with this wonderful package,
    from text, links, tables, and styles, to images. Scrapy is also a good package
    for web scraping, but it is more like a framework for writing powerful web crawlers.
    So, if you just need to fetch a table from a page, BeautifulSoup offers simpler
    procedures.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: BeautifulSoup（[https://www.crummy.com/software/BeautifulSoup/](https://www.crummy.com/software/BeautifulSoup/)）是一个非常有用的工具包，用于从网站抓取信息。基本上，任何带有
    HTML 标签的内容都可以用这个神奇的工具包抓取，从文本、链接、表格和样式，到图片。Scrapy 也是一个很好的网页抓取工具包，但它更像是一个编写强大网络爬虫的框架。因此，如果你只需要从页面获取一个表格，BeautifulSoup
    提供了更简单的操作方法。
- en: 'We are going to use BeautifulSoup version 4.6 throughout this chapter. To install
    BeautifulSoup 4, we can once again rely on PyPI:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章节中，我们将一直使用 BeautifulSoup 版本 4.6。要安装 BeautifulSoup 4，我们可以再次依赖于 PyPI：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The data on USA unemployment rates and earnings by educational attainment (2016)
    is available at [https://www.bls.gov/emp/ep_table_001.htm](https://www.bls.gov/emp/ep_table_001.htm).
    Currently, BeautifulSoup does not handle HTML requests. So we need to use the `urllib.request`
    or `requests` package to fetch a web page for us. Of the two options, the `requests`
    package is probably easier to use, due to its higher-level HTTP client interface.
    If `requests` is not available on your system, you can install it through PyPI:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 美国教育程度（2016年）对应的失业率和收入数据可以在[https://www.bls.gov/emp/ep_table_001.htm](https://www.bls.gov/emp/ep_table_001.htm)找到。目前，BeautifulSoup
    无法处理 HTML 请求。因此，我们需要使用 `urllib.request` 或 `requests` 包来获取网页。在这两个选项中，`requests`
    包可能更容易使用，因为它具有更高级别的 HTTP 客户端接口。如果您的系统上没有安装 `requests`，可以通过 PyPI 安装它：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let''s take a look at the web page before we write the web scraping code. If
    we use the Google Chrome browser to visit the Bureau of Labor Statistics website,
    we can inspect the HTML code corresponding to the table we need by right-clicking:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写网页抓取代码之前，让我们先查看一下网页。如果我们使用 Google Chrome 浏览器访问劳工统计局网站，可以通过右键单击检查与我们需要的表格对应的
    HTML 代码：
- en: '![](img/9361cdab-a87a-426c-9a2e-8528e99a4a8e.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9361cdab-a87a-426c-9a2e-8528e99a4a8e.png)'
- en: A pop-up window for code inspection will be shown, which allows us to read the
    code for each of the elements on the page.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 将显示一个用于代码检查的弹出窗口，允许我们阅读页面上每个元素的代码。
- en: '![](img/bb44dc05-1da5-461e-8b1f-40c989b5beec.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bb44dc05-1da5-461e-8b1f-40c989b5beec.png)'
- en: More specifically, we can see that the column names are defined in the `<thead>...</thead>`
    section, while the table content is defined in the `<tbody>...</tbody>` section.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们可以看到列名在`<thead>...</thead>`部分中定义，而表格内容在`<tbody>...</tbody>`部分中定义。
- en: In order to instruct BeautifulSoup to scrape the information we need, we need
    to give clear directions to it. We can right-click on the relevant section in
    the code inspection window and copy the unique identifier in the format of the
    CSS selector.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了指示 BeautifulSoup 抓取我们需要的信息，我们需要给它清晰的指示。我们可以右键单击代码检查窗口中的相关部分，并复制格式为 CSS 选择器的唯一标识符。
- en: '![](img/68310554-690c-47c0-8ff6-dfe7d929a683.png)**Cascading Style Sheets**
    (**CSS**) selectors were originally designed for applying element-specific styles
    to a website. For more information, visit the following page: [https://www.w3schools.com/cssref/css_selectors.asp](https://www.w3schools.com/cssref/css_selectors.asp).'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/68310554-690c-47c0-8ff6-dfe7d929a683.png)**层叠样式表**（**CSS**）选择器最初是为了将特定于元素的样式应用于网站而设计的。有关更多信息，请访问以下页面：[https://www.w3schools.com/cssref/css_selectors.asp](https://www.w3schools.com/cssref/css_selectors.asp)。'
- en: 'Let''s try to get the CSS selectors for `thead` and `tbody`, and use the `BeautifulSoup.select()`
    method to scrape the respective HTML code:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试获取`thead`和`tbody`的 CSS 选择器，并使用 `BeautifulSoup.select()` 方法来抓取相应的 HTML 代码：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We see the following output from the previous code:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从前面的代码中看到以下输出：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, we are going to find all instances of `<th>...</th>` in `<thead>...</thead>`,
    which contains the name of each column. We will build a dictionary of lists with
    headers as keys to hold the data:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将查找`<thead>...</thead>`中所有`<th>...</th>`的实例，其中包含每列的名称。我们将构建一个以标题为键的列表字典来存储数据：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Finally, we parse the remaining rows (`<tr>...</tr>`) from the body (`<tbody>...</tbody>`)
    of the table and convert the data into a pandas DataFrame:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们解析表格主体（`<tbody>...</tbody>`）中剩余的行（`<tr>...</tr>`），并将数据转换为 pandas DataFrame：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '|  | **Educational attainment** | **Median usual weekly earnings ($)** | **Unemployment
    rate (%)** |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '|  | **教育程度** | **中位数周收入（美元）** | **失业率（%）** |'
- en: '| **0** | Doctoral degree | 1664.0 | 1.6 |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| **0** | 博士学位 | 1664.0 | 1.6 |'
- en: '| **1** | Professional degree | 1745.0 | 1.6 |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| **1** | 专业学位 | 1745.0 | 1.6 |'
- en: '| **2** | Master''s degree | 1380.0 | 2.4 |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| **2** | 硕士学位 | 1380.0 | 2.4 |'
- en: '| **3** | Bachelor''s degree | 1156.0 | 2.7 |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| **3** | 学士学位 | 1156.0 | 2.7 |'
- en: '| **4** | Associate''s degree | 819.0 | 3.6 |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| **4** | 专科学位 | 819.0 | 3.6 |'
- en: We have now fetched the HTML table and formatted it as a structured pandas DataFrame.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经获取了 HTML 表格并将其格式化为结构化的 pandas DataFrame。
- en: Non-interactive backends
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 非交互式后端
- en: The code for plotting graphs is considered the frontend in Matplotlib terminology.
    We first mentioned backends in [Chapter 6](bf358e3c-35c4-47c5-9683-7378dfa01c4e.xhtml),
    *Hello Plotting World!*, when we were talking about output formats. In reality,
    Matplotlib backends differ much more than just in the support of graphical formats.
    Backends handle so many things behind the scenes! And that determines the support
    for plotting capabilities. For example, LaTeX text layout is only supported by
    AGG, PDF, PGF, and PS backends.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制图形的代码在Matplotlib术语中被视为前端。我们在[第六章](bf358e3c-35c4-47c5-9683-7378dfa01c4e.xhtml)中首次提到了后端，*Hello
    Plotting World!*，当时我们在谈论输出格式。实际上，Matplotlib的后端在支持图形格式方面远不止差异如此简单。后端在幕后处理了许多事情！而这决定了绘图能力的支持。例如，LaTeX文本布局仅在AGG、PDF、PGF和PS后端中得到支持。
- en: We have been using non-interactive backends so far, which include AGG, Cairo,
    GDK, PDF, PGF, PS, and SVG. Most of these backends work without extra dependencies,
    yet Cairo and GDK would require the Cairo graphics library or GIMP Drawing Kit,
    respectively, to work.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们至今一直在使用非交互式后端，包括AGG、Cairo、GDK、PDF、PGF、PS和SVG。大多数这些后端不需要额外的依赖项，但Cairo和GDK分别需要Cairo图形库或GIMP绘图工具包才能工作。
- en: Non-interactive backends can be further classified into two groups--vector and
    raster. Vector graphics describe images in terms of points, paths, and shapes
    that are calculated using mathematical formulas. A vector graphic will always
    appear smooth, irrespective of scale and its size is usually much smaller than
    its raster counterpart. PDF, PGF, PS, and SVG backends belong to the "vector"
    group.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 非交互式后端可以进一步分为两类——向量和光栅。向量图形通过点、路径和形状来描述图像，这些点、路径和形状是通过数学公式计算得出的。无论缩放与否，向量图形总是显得平滑，其大小通常也远小于对应的光栅图形。PDF、PGF、PS和SVG后端属于“向量”类别。
- en: 'Raster graphics describe images in terms of a finite number of tiny color blocks
    (pixels). So, if we zoom in enough, we start to see a blurry image, or in other
    words, pixelation. By increasing the resolution or **Dots Per Inch** (**DPI**)
    of the image, we are less likely to observe pixelation. AGG, Cairo, and GDK belong
    to this group of backends. This table summarizes the key functionalities and differences
    among the non-interactive backends:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 光栅图形通过有限数量的小色块（像素）来描述图像。因此，如果我们足够放大，我们会开始看到模糊的图像，换句话说，就是像素化。通过增加图像的分辨率或**每英寸点数**（**DPI**），我们不太可能观察到像素化。AGG、Cairo和GDK属于这一组后端。下表总结了非交互式后端的主要功能和区别：
- en: '| **Backend** | **Vector/Raster** | **Output formats** |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| **后端** | **向量/光栅** | **输出格式** |'
- en: '| Agg | Raster | PNG |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| Agg | 光栅 | PNG |'
- en: '| Cairo | Vector/Raster | PDF, PNG, PS, or SVG |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| Cairo | 向量/光栅 | PDF、PNG、PS或SVG |'
- en: '| PDF | Vector | PDF |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| PDF | 向量 | PDF |'
- en: '| PGF | Vector | PDF or PGF |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| PGF | 向量 | PDF或PGF |'
- en: '| PS | Vector | PS |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| PS | 向量 | PS |'
- en: '| SVG | Vector | SVG |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| SVG | 向量 | SVG |'
- en: '| GDK (Deprecated in Matplotlib 2.0) | Raster | PNG, JPEG, or TIFF |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| GDK（在Matplotlib 2.0中已弃用） | 光栅 | PNG、JPEG或TIFF |'
- en: 'Normally, we don''t need to manually select a backend, as the default choice
    would work great for most tasks. On the other hand, we can specify a backend through
    the `matplotlib.use()` method before importing `matplotlib.pyplot`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们无需手动选择后端，因为默认选择在大多数任务中都能很好地工作。另一方面，我们可以通过在导入`matplotlib.pyplot`之前使用`matplotlib.use()`方法来指定后端：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '![](img/3e69075d-cffe-4138-80be-7f00b8b55f89.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3e69075d-cffe-4138-80be-7f00b8b55f89.png)'
- en: Interactive backends
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 交互式后端
- en: Matplotlib can build interactive figures that are far more engaging for readers.
    Sometimes, a plot might be overwhelmed with graphical elements, making it hard
    to discern individual data points. On other occasions, some data points may appear
    so similar that it becomes hard to spot the differences with the naked eye. An
    interactive plot can address these two scenarios by allowing us to zoom in, zoom
    out, pan, and explore the plot in the way we want.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Matplotlib可以构建更具互动性的图形，这对于读者更具吸引力。有时，图形可能被图形元素所淹没，使得难以分辨单个数据点。在其他情况下，一些数据点可能看起来非常相似，以至于肉眼很难分辨差异。交互式图形可以通过让我们进行放大、缩小、平移和按需探索图形来解决这两种情况。
- en: Through the use of interactive backends, plots in Matplotlib can be embedded
    in Graphical User Interface (GUI) applications. By default, Matplotlib supports
    the pairing of the Agg raster graphics renderer with a wide variety of GUI toolkits,
    including wxWidgets (Wx), GIMP Toolkit (GTK+), Qt, and Tkinter (Tk). As Tkinter
    is the de facto standard GUI for Python, which is built on top of Tcl/Tk, we can
    create an interactive plot just by calling `plt.show()` in a standalone Python
    script.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用交互式后端，Matplotlib中的图形可以嵌入到图形用户界面（GUI）应用程序中。默认情况下，Matplotlib支持将Agg光栅图形渲染器与多种GUI工具包配对，包括wxWidgets（Wx）、GIMP工具包（GTK+）、Qt和Tkinter（Tk）。由于Tkinter是Python的事实标准GUI，它建立在Tcl/Tk之上，因此我们可以通过在独立的Python脚本中调用`plt.show()`来创建交互式图形。
- en: Tkinter-based backend
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于Tkinter的后端
- en: 'Let''s try to copy the following code to a separate text file and name it `chapter6_gui.py`.
    After that, type `python chapter6_gui.py` in your terminal (Mac/Linux) or Command
    Prompt (Windows). If you are unsure about how to open a terminal or Command Prompt,
    refer to [Chapter 6](bf358e3c-35c4-47c5-9683-7378dfa01c4e.xhtml), *Hello Plotting
    World!*, for more details:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试将以下代码复制到一个单独的文本文件中，并命名为`chapter6_gui.py`。之后，在终端（Mac/Linux）或命令提示符（Windows）中输入`python
    chapter6_gui.py`。如果你不确定如何打开终端或命令提示符，请参阅[第6章](bf358e3c-35c4-47c5-9683-7378dfa01c4e.xhtml)，*Hello
    Plotting World!*，以获取更多详情：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We see a pop-up window similar to the following. We can pan, zoom to selection,
    configure subplot margins, save, and go back and forth between different views
    by clicking on the buttons on the bottom toolbar. If we put our mouse over the
    plot, we can also observe the exact coordinates in the bottom-right corner. This
    feature is extremely useful for dissecting data points that are close to each
    other.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到一个类似于下图的弹出窗口。我们可以通过点击底部工具栏上的按钮来平移、缩放选择区域、配置子图边距、保存，并在不同视图之间来回切换。如果将鼠标悬停在图形上，我们还可以在右下角查看精确的坐标。这一功能对于分析彼此接近的数据点非常有用。
- en: '![](img/520c0399-4fbd-4784-a3ed-3190e96dd92d.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](img/520c0399-4fbd-4784-a3ed-3190e96dd92d.jpg)'
- en: 'Next, we are going to extend the application by adding a radio button widget
    on top of the figure, such that we can switch between the display of weekly earnings
    or unemployment rates. The radio button can be found in `matplotlib.widgets`,
    and we are going to attach a data updating function to the `.on_clicked()` event
    of the button. You can paste the following code right before the `plt.show()`
    line in the previous code example (`chapter6_gui.py`). Let''s see how it works:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将通过在图形上方添加一个单选按钮小部件来扩展应用程序，使我们可以在显示每周收入或失业率之间切换。该单选按钮可以在`matplotlib.widgets`中找到，我们将把一个数据更新函数附加到按钮的`.on_clicked()`事件上。你可以将以下代码粘贴到前面代码示例（`chapter6_gui.py`）中的`plt.show()`行之前。让我们看看它是如何工作的：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '![](img/3f5d8413-3324-4c26-ac5a-3e9cad6c263a.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3f5d8413-3324-4c26-ac5a-3e9cad6c263a.png)'
- en: You will be welcomed by a new radio selector box at the top of the figure. Try
    switching between the two states and see if the figure is updated accordingly.
    The complete code is also available as `chapter6_tkinter.py` in our code repository.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到图形上方出现一个新的单选框。尝试在两个状态之间切换，看看图形是否会相应更新。完整的代码也可以在我们的代码库中找到，名为`chapter6_tkinter.py`。
- en: Interactive backend for Jupyter Notebook
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Jupyter Notebook的交互式后端
- en: 'Before we conclude this section, we are going to introduce two more interactive
    backends that are rarely covered by books. Starting with Matplotlib 1.4, there
    is an interactive backend specifically designed for Jupyter Notebook. To invoke
    that, we simply need to paste `%matplotlib notebook` at the start of our notebook.
    We are going to adapt one of the earlier examples in this chapter to use this
    backend:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束本节之前，我们将介绍两种书籍中很少涉及的交互式后端。从Matplotlib 1.4开始，专门为Jupyter Notebook设计了一个交互式后端。为了启用该功能，我们只需在笔记本的开始部分粘贴`%matplotlib
    notebook`。我们将改编本章前面的一个示例来使用这个后端：
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You will see an interactive interface coming up, with buttons similar to a
    Tkinter-based application:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到一个交互式界面，按钮类似于基于Tkinter的应用程序：
- en: '![](img/8b955965-8ea6-4b84-a397-f2532b6446f4.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8b955965-8ea6-4b84-a397-f2532b6446f4.png)'
- en: Plot.ly-based backend
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于Plot.ly的后端
- en: Lastly, we will talk about Plot.ly, which is a D3.js-based interactive graphing
    library with many programming language bindings, including Python. Plot.ly has
    quickly gained traction in the area of online data analytics due to its powerful
    data dashboard, high performance, and detailed documentation. For more information,
    please visit Plot.ly's website ([https://plot.ly](https://plot.ly)).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将讨论 Plot.ly，这是一个基于 D3.js 的交互式绘图库，支持多种编程语言，包括 Python。由于其强大的数据仪表盘、高性能以及详细的文档，Plot.ly
    在在线数据分析领域迅速获得了关注。欲了解更多信息，请访问 Plot.ly 的网站（[https://plot.ly](https://plot.ly)）。
- en: 'Plot.ly offers easy transformation of Matplotlib figures into online interactive
    charts through its Python bindings. To install Plotly.py, we can use PyPI:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Plot.ly 通过其 Python 绑定，提供了将 Matplotlib 图形轻松转换为在线交互式图表的功能。要安装 Plotly.py，我们可以使用
    PyPI：
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let us show you a quick example of integrating Matplotlib with Plot.ly:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个快速示例向你展示如何将 Matplotlib 与 Plot.ly 集成：
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '![](img/9c10384f-e542-4c5b-895d-c0e9ff2d5288.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9c10384f-e542-4c5b-895d-c0e9ff2d5288.png)'
- en: 'You may be greeted by the following error message when you run the preceding
    Plot.ly example:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的 Plot.ly 示例时，可能会看到以下错误消息：
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To circumvent this error, you can relaunch Jupyter Notebook by setting a higher
    `iopub_data_rate_limit`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 若要绕过此错误，可以通过设置更高的 `iopub_data_rate_limit` 重新启动 Jupyter Notebook：
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You may also notice that the tick labels cannot be displayed properly, despite
    clear specifications in the code. This issue is also reported on the official
    GitHub page ([https://github.com/plotly/plotly.py/issues/735](https://github.com/plotly/plotly.py/issues/735)).
    Unfortunately, there is no fix for this issue to date.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还注意到，尽管代码中明确指定了刻度标签，但它们无法正确显示。这个问题也在官方 GitHub 页面上有报告（[https://github.com/plotly/plotly.py/issues/735](https://github.com/plotly/plotly.py/issues/735)）。遗憾的是，目前尚未修复这个问题。
- en: We admit that there are numerous materials online that describe the integration
    of Matplotlib plots in different GUI applications. Due to page limits, we are
    not going to go through each of these backends here. For readers who want to read
    more about these interactive backends, Alexandre Devert has written an excellent
    chapter (*Chapter 8, User Interface*) in *matplotlib Plotting Cookbook*. In *Chapter
    8, User Interface* of that book, Alexandre has provided recipes for creating GUI
    applications using wxWidgets, GTK, and Pyglet as well.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们承认，网上有大量材料描述了如何将 Matplotlib 图形集成到不同的 GUI 应用程序中。由于篇幅限制，我们不会在这里逐一介绍这些后端。对于想要深入了解这些交互式后端的读者，Alexandre
    Devert 在 *matplotlib Plotting Cookbook* 中写了一个精彩的章节（*第8章，用户界面*）。在那本书的 *第8章，用户界面*
    中，Alexandre 还提供了使用 wxWidgets、GTK 和 Pyglet 创建 GUI 应用程序的方案。
- en: Creating animated plots
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建动画图形
- en: As explained at the start of this chapter, Matplotlib was not originally designed
    for making animations, and there are GPU-accelerated Python animation packages
    that may be more suitable for such a task (such as PyGame). However, since we
    are already familiar with Matplotlib, it is quite easy to adapt existing plots
    to animations.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本章开头所解释的那样，Matplotlib 最初并不是为了制作动画而设计的，而且有些 GPU 加速的 Python 动画包可能更适合这一任务（例如
    PyGame）。然而，由于我们已经熟悉 Matplotlib，因此将现有的图形转化为动画非常简单。
- en: Installation of FFmpeg
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 FFmpeg
- en: Before we start making animations, we need to install either FFmpeg, avconv,
    MEncoder, or ImageMagick on our system. These additional dependencies are not
    bundled with Matplotlib, and so we need to install them separately. We are going
    to walk you through the steps of installing FFmpeg.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始制作动画之前，我们需要在系统中安装 FFmpeg、avconv、MEncoder 或 ImageMagick。这些额外的依赖项并未与 Matplotlib
    一起打包，因此需要单独安装。我们将带你一步步安装 FFmpeg。
- en: 'For Debian-based Linux users, FFmpeg can be installed by issuing the following
    command in the terminal:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 对于基于 Debian 的 Linux 用户，可以在终端中输入以下命令来安装 FFmpeg：
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'FFmpeg may not be available on Ubuntu 14.04 or earlier. To install FFmpeg on
    Ubuntu 14.04, please follow the steps below:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ubuntu 14.04 或更早版本中，可能无法安装 FFmpeg。要在 Ubuntu 14.04 上安装 FFmpeg，请按照以下步骤操作：
- en: '`**sudo add-apt-repository ppa:mc3man/trusty-media**`'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`**sudo add-apt-repository ppa:mc3man/trusty-media**`'
- en: Press *Enter* to confirm the addition of the repository.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 按 *Enter* 确认添加仓库。
- en: '`**Also note that with apt-get a sudo apt-get dist-upgrade is needed for initial
    setup & with some package upgrades**`'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`**还需要注意，在初始设置和某些包升级时，使用 apt-get 时需要执行 sudo apt-get dist-upgrade**`'
- en: '`**More info: https://launchpad.net/~mc3man/+archive/ubuntu/trusty-media**`'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`**更多信息：https://launchpad.net/~mc3man/+archive/ubuntu/trusty-media**`'
- en: '`**Press [ENTER] to continue or ctrl-c to cancel adding it**`'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`**按 [ENTER] 继续或按 ctrl-c 取消添加**`'
- en: Update and upgrade a few packages before installing FFmpeg.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装 FFmpeg 之前，更新并升级一些软件包。
- en: '`**sudo apt-get update**`'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`**sudo apt-get update**`'
- en: '`**sudo apt-get dist-upgrade**`'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`**sudo apt-get dist-upgrade**`'
- en: 'Finally, proceed with the normal procedure of installing FFmpeg via `apt-get`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，按照正常程序通过 `apt-get` 安装 FFmpeg：
- en: '`**sudo apt-get install ffmpeg**`'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`**sudo apt-get install ffmpeg**`'
- en: 'For Mac users, Homebrew ([https://brew.sh/](https://brew.sh/)) is the simplest
    way to search and install the FFmpeg package. For those who don''t have Homebrew,
    you can paste the following code in your terminal to install it:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Mac 用户，Homebrew（[https://brew.sh/](https://brew.sh/)）是搜索和安装 FFmpeg 包的最简单方法。对于没有
    Homebrew 的用户，你可以将以下代码粘贴到终端中进行安装：
- en: '[PRE15]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'After that, we can install FFmpeg by issuing the following command in the terminal
    app:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们可以通过在终端应用中执行以下命令来安装 FFmpeg：
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Alternatively, you may install FFmpeg by copying the binaries ([https://evermeet.cx/ffmpeg/](https://evermeet.cx/ffmpeg/))
    to the system path (for example, `/usr/local/bin`). Readers may visit the following
    page for more details: [http://www.renevolution.com/ffmpeg/2013/03/16/how-to-install-ffmpeg-on-mac-os-x.html](http://www.renevolution.com/ffmpeg/2013/03/16/how-to-install-ffmpeg-on-mac-os-x.html)
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，你也可以通过将二进制文件（[https://evermeet.cx/ffmpeg/](https://evermeet.cx/ffmpeg/)）复制到系统路径中（例如，`/usr/local/bin`）来安装
    FFmpeg。读者可以访问以下页面以获取更多细节：[http://www.renevolution.com/ffmpeg/2013/03/16/how-to-install-ffmpeg-on-mac-os-x.html](http://www.renevolution.com/ffmpeg/2013/03/16/how-to-install-ffmpeg-on-mac-os-x.html)
- en: The installation steps for Windows users are quite a bit more involved, as we
    need to download the executable ourselves, followed by adding the executable to
    the system path. Therefore, we have prepared a series of screen captures to guide
    you through the process.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 用户的安装步骤要复杂一些，因为我们需要自己下载可执行文件，然后将其添加到系统路径中。因此，我们准备了一系列屏幕截图来引导你完成整个过程。
- en: First, we need to obtain a prebuilt binary from [http://ffmpeg.zeranoe.com/builds/](http://ffmpeg.zeranoe.com/builds/).
    Choose the CPU architecture that matches with your system, and select the latest
    release and static linked libraries.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要从 [http://ffmpeg.zeranoe.com/builds/](http://ffmpeg.zeranoe.com/builds/)
    获取一个预构建的二进制文件。选择与你的系统相匹配的 CPU 架构，并选择最新版本和静态链接库。
- en: '![](img/8ba57f3f-8638-460c-a285-5b0840821f3b.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8ba57f3f-8638-460c-a285-5b0840821f3b.png)'
- en: 'Next, we need to extract the downloaded ZIP file to the `C` drive as `c:\ffmpeg`,
    and add the folder `c:\ffmpeg\bin` to the `Path` variable. To do this, go to Control
    Panel and click on the System and Security link, followed by clicking on System.
    In the System window, click on the Advanced system settings link to the left:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要将下载的 ZIP 文件解压到 `C` 盘，路径为 `c:\ffmpeg`，并将文件夹 `c:\ffmpeg\bin` 添加到 `Path`
    变量中。为此，请进入控制面板，点击“系统和安全”链接，然后点击“系统”。在系统窗口中，点击左侧的“高级系统设置”链接：
- en: '![](img/983a0265-de22-4ced-8403-fd3b0437b8d1.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](img/983a0265-de22-4ced-8403-fd3b0437b8d1.png)'
- en: 'In the pop-up System Properties window, click on the Environmental Variables…
    button:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在弹出的系统属性窗口中，点击“环境变量…”按钮：
- en: '![](img/c47667f5-d7d4-497e-97d2-a08497cafc96.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c47667f5-d7d4-497e-97d2-a08497cafc96.png)'
- en: 'Select the Path entry, and click on the Edit… button:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 选择 Path 条目，点击“编辑…”按钮：
- en: '![](img/bff4d62b-e28a-42a9-bab1-4ace578e1fcd.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bff4d62b-e28a-42a9-bab1-4ace578e1fcd.png)'
- en: In the Edit environmental variable window, create a new entry that shows `c:\ffmpeg\bin`.
    Click on OK in all pop-up windows to save your changes. Restart Command Prompt
    and Jupyter Notebook and you are good to go.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在“编辑环境变量”窗口中，创建一个新条目，显示 `c:\ffmpeg\bin`。点击所有弹出窗口中的“确定”以保存更改。重新启动命令提示符和 Jupyter
    Notebook，之后你就可以开始使用了。
- en: '![](img/8742e3c3-9731-41fa-a5c1-9dc777763a84.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8742e3c3-9731-41fa-a5c1-9dc777763a84.png)'
- en: Visit Wikihow ([http://www.wikihow.com/Install-FFmpeg-on-Windows](http://www.wikihow.com/Install-FFmpeg-on-Windows))
    for instructions on installing FFmpeg on Windows 7.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 访问 Wikihow（[http://www.wikihow.com/Install-FFmpeg-on-Windows](http://www.wikihow.com/Install-FFmpeg-on-Windows)）获取有关如何在
    Windows 7 上安装 FFmpeg 的说明。
- en: Creating animations
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建动画
- en: 'Matplotlib provides two main interfaces for creating animations: `TimedAnimation`
    and `FuncAnimation`. `TimedAnimation` is useful for creating time-based animations,
    while `FuncAnimation` can be used to create animations according to a custom-defined
    function. Given the much higher level of flexibility offered by `FuncAnimation`,
    we will only explore the use of `FuncAnimation` in this section. Readers can refer
    to the official documentation ([https://matplotlib.org/api/animation_api.html](https://matplotlib.org/api/animation_api.html))
    for more information about `TimedAnimation`.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Matplotlib提供了两种创建动画的主要接口：`TimedAnimation`和`FuncAnimation`。`TimedAnimation`适用于创建基于时间的动画，而`FuncAnimation`则可以根据自定义函数创建动画。考虑到`FuncAnimation`提供了更高的灵活性，我们将在本节中仅探索`FuncAnimation`的使用。读者可以参考官方文档（[https://matplotlib.org/api/animation_api.html](https://matplotlib.org/api/animation_api.html)）了解更多关于`TimedAnimation`的信息。
- en: '`FuncAnimation` works by repeatedly calling a function that changes the properties
    of Matplotlib objects in each frame. In the following example, we''ve simulated
    the change in median weekly earnings by assuming a 5% annual increase. We are
    going to create a custom function--animate--which returns Matplotlib Artist objects
    that are changed in each frame. This function will be supplied to `animation.FuncAnimation()`
    together with a few more extra parameters:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`FuncAnimation`通过反复调用一个函数来改变每一帧中Matplotlib对象的属性。在以下示例中，我们通过假设年增长率为5%来模拟中位数周薪的变化。我们将创建一个自定义函数--animate--它返回在每一帧中发生变化的Matplotlib艺术对象。这个函数将与其他一些额外参数一起传递给`animation.FuncAnimation()`：'
- en: '[PRE17]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here is the screen capture of one of the video frames:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这是其中一个视频帧的屏幕截图：
- en: '![](img/15792b24-dce1-43c8-9640-3d4cc8dc3580.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](img/15792b24-dce1-43c8-9640-3d4cc8dc3580.png)'
- en: In this example, we output the animation in the form of MPEG-4-encoded videos.
    The video can also be embedded in Jupyter Notebook in the form of an H.264-encoded
    video. All you need to do is call the `Animation.to_html5_video()` method and
    supply the returned object to `IPython.display.HTML`. Video encoding and HTML5
    code generation will happen automatically behind the scenes.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将动画输出为MPEG-4编码的视频格式。视频也可以以H.264编码的视频格式嵌入到Jupyter Notebook中。你只需要调用`Animation.to_html5_video()`方法，并将返回的对象传递给`IPython.display.HTML`。视频编码和HTML5代码生成将在后台自动完成。
- en: Summary
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you further enriched your techniques for obtaining online data
    through the use of the BeautifulSoup web scraping library. You successfully learned
    the different ways of creating interactive figures and animations. These techniques
    will pave the way for you to create intuitive and engaging visualizations in more
    advanced applications.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你通过使用BeautifulSoup网页抓取库进一步丰富了获取在线数据的技巧。你成功地学习了创建交互式图形和动画的不同方法。这些技巧将为你在更高级的应用中创建直观且引人入胜的可视化铺平道路。
