- en: Chapter 1. The Groundwork – Julia's Environment
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章. 基础工作——Julia的环境
- en: Julia is a fairly young programming language. In 2009, three developers (Stefan
    Karpinski, Jeff Bezanson, and Viral Shah) at MIT in the Applied Computing group
    under the supervision of Prof. Alan Edelman started working on a project that
    lead to Julia. In February 2012, Julia was presented publicly and became open
    source. The source code is available on GitHub ([https://github.com/JuliaLang/julia](https://github.com/JuliaLang/julia)).
    The source of the registered packages can also be found on GitHub. Currently,
    all four of the initial creators, along with developers from around the world,
    actively contribute to Julia.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Julia是一门相对年轻的编程语言。2009年，三位开发者（Stefan Karpinski、Jeff Bezanson 和 Viral Shah）在麻省理工学院（MIT）应用计算组，在Alan
    Edelman教授的指导下，开始了一个项目，最终演变为Julia。2012年2月，Julia公开发布并开源。源代码可以在GitHub上找到（[https://github.com/JuliaLang/julia](https://github.com/JuliaLang/julia)）。已注册包的源代码也可以在GitHub上找到。目前，最初的四位创始人以及来自世界各地的开发者都在积极为Julia做出贡献。
- en: Note
  id: totrans-2
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The current release is 0.4 and is still away from its 1.0 release candidate.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 当前版本为0.4，距离1.0版本候选发布还有一段距离。
- en: Based on solid principles, its popularity is steadily increasing in the field
    of scientific computing, data science, and high-performance computing.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 基于稳固的原则，它在科学计算、数据科学和高性能计算领域的受欢迎程度正在稳步上升。
- en: 'This chapter will guide you through the download and installation of all the
    necessary components of Julia. This chapter covers the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将引导你完成所有必要的Julia组件的下载和安装。本章涵盖以下主题：
- en: How is Julia different?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Julia有什么不同？
- en: Setting up Julia's environment.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置Julia环境。
- en: Using Julia's shell and REPL.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Julia的Shell和REPL。
- en: Using Jupyter notebooks
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Jupyter笔记本
- en: Package management
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包管理
- en: Parallel computation
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并行计算
- en: Multiple dispatch
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多重分派
- en: Language interoperability
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语言互操作性
- en: Traditionally, the scientific community has used slower dynamic languages to
    build their applications, although they have required the highest computing performance.
    Domain experts who had experience with programming, but were not generally seasoned
    developers, always preferred dynamic languages over statically typed languages.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，科学界使用较慢的动态语言来构建应用程序，尽管这些应用程序需要最高的计算性能。有编程经验但并非经验丰富的开发者的领域专家总是更倾向于使用动态语言而非静态类型语言。
- en: Julia is different
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Julia与众不同
- en: Over the years, with the advancement in compiler techniques and language design,
    it is possible to eliminate the trade-off between performance and dynamic prototyping.
    So, the scientific computing required was a good dynamic language like Python
    together with performance like C. And then came Julia, a general purpose programming
    language designed according to the requirements of scientific and technical computing,
    providing performance comparable to C/C++, and with an environment productive
    enough for prototyping like the high-level dynamic language of Python. The key
    to Julia's performance is its design and **Low Level Virtual Machine** (LLVM)
    based Just-in-Time compiler which enables it to approach the performance of C
    and Fortran.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 随着编译器技术和语言设计的进步，随着时间的推移，性能与动态原型之间的权衡已经可以被消除。因此，科学计算所需的就是像Python这样的良好动态语言，同时又有像C一样的性能。然后，Julia诞生了，这是一种根据科学和技术计算需求设计的通用编程语言，提供了与C/C++相当的性能，并且其环境足够高效，适合像Python那样的高层次动态语言进行原型设计。Julia性能的关键在于它的设计和基于**低级虚拟机**（LLVM）的即时编译器，使得它能够接近C和Fortran的性能。
- en: 'The key features offered by Julia are:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Julia提供的主要特点是：
- en: A general purpose high-level dynamic programming language designed to be effective
    for numerical and scientific computing
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种设计为在数值和科学计算中有效的通用高层次动态编程语言
- en: A **Low-Level Virtual Machine** (**LLVM**) based **Just-in-Time** (**JIT**)
    compiler that enables Julia to approach the performance of statically-compiled
    languages like C/C++
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个基于**低级虚拟机**（**LLVM**）的**即时编译**（**JIT**）编译器，使得Julia能够接近像C/C++这类静态编译语言的性能
- en: 'The following quote is from the development team of Julia—Jeff Bezanson, Stefan
    Karpinski, Viral Shah, and Alan Edelman:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 以下引用来自Julia开发团队——Jeff Bezanson、Stefan Karpinski、Viral Shah和Alan Edelman：
- en: Note
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**We are greedy: we want more.**'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**我们是贪婪的：我们想要更多。**'
- en: We want a language that's open source, with a liberal license. We want the speed
    of C with the dynamism of Ruby. We want a language that's homoiconic, with true
    macros like Lisp, but with obvious, familiar mathematical notation like Matlab.
    We want something as usable for general programming as Python, as easy for statistics
    as R, as natural for string processing as Perl, as powerful for linear algebra
    as Matlab, as good at gluing programs together as the shell. Something that is
    dirt simple to learn, yet keeps the most serious hackers happy. We want it interactive
    and we want it compiled.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一种开源的语言，具有宽松的许可证。我们希望它能具备 C 的速度和 Ruby 的动态性。我们希望它是一种自同构的语言，拥有类似 Lisp 的真正宏功能，但又能像
    Matlab 一样具有明显且熟悉的数学符号。我们希望它在通用编程中和 Python 一样易用，在统计分析中和 R 一样方便，在字符串处理上和 Perl 一样自然，在线性代数上和
    Matlab 一样强大，在将程序结合在一起上和 Shell 一样优秀。我们希望它简单易学，同时也能满足最严苛黑客的需求。我们希望它是交互式的，并且是编译型的。
- en: (Did we mention it should be as fast as C?)
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: （我们是不是提到过它应该和 C 一样快？）
- en: It is quite often compared with Python, R, MATLAB, and Octave. These have been
    around for quite some time and Julia is highly influenced by them, especially
    when it comes to numerical and scientific computing. Although Julia is really
    good at it, it is not restricted to just scientific computing as it can also be
    used for web and general purpose programming.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 它常常与 Python、R、MATLAB 和 Octave 进行比较。这些语言已经存在了相当长的时间，Julia 受它们的影响很大，尤其是在数值和科学计算方面。虽然
    Julia 在这方面表现非常出色，但它并不限于科学计算，它也可以用于 Web 开发和通用编程。
- en: The development team of Julia aims to create a remarkable and never done before
    combination of power and efficiency without compromising the ease of use in one
    single language. Most of Julia's core is implemented in C/C++. Julia's parser
    is written in Scheme. Julia's efficient and cross-platform I/O is provided by
    the Node.js's libuv.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 的开发团队旨在创建一种前所未有的强大与高效结合，同时不妥协易用性的语言。Julia 的核心大部分是用 C/C++ 实现的，Julia 的解析器是用
    Scheme 编写的。Julia 高效且跨平台的 I/O 由 Node.js 的 libuv 提供支持。
- en: 'Features and advantages of Julia can be summarized as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 的特点和优势可以总结如下：
- en: It's designed for distributed and parallel computation.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它设计用于分布式和并行计算。
- en: Julia provides an extensive library of mathematical functions with great numerical
    accuracy.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Julia 提供了大量的数学函数库，具有出色的数值精度。
- en: Julia gives the functionality of multiple dispatch. Multiple dispatch refers
    to using many combinations of argument types to define function behaviors.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Julia 提供了多重调度功能。多重调度是指使用多种参数类型组合来定义函数行为。
- en: The Pycall package enables Julia to call Python functions in its code and Matlab
    packages using Matlab.jl. Functions and libraries written in C can also be called
    directly without any need for APIs or wrappers.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pycall 包使 Julia 可以在代码中调用 Python 函数，并使用 Matlab.jl 调用 Matlab 包。用 C 编写的函数和库也可以直接调用，无需任何
    API 或包装器。
- en: Julia provides powerful shell-like capabilities for managing other processes
    in the system.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Julia 提供了强大的类 Unix Shell 功能，用于管理系统中的其他进程。
- en: Unlike other languages, user-defined types in Julia are compact and quite fast
    as built-ins.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与其他语言不同，Julia 中的用户定义类型既紧凑又非常快速，堪比内建类型。
- en: Data analysis makes great use of vectorized code to gain performance benefits.
    Julia eliminates the need to vectorize code to gain performance. De-vectorized
    code written in Julia can be as fast as vectorized code.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据分析大量使用矢量化代码来提高性能。Julia 消除了为了提升性能而进行代码矢量化的需求。用 Julia 编写的非矢量化代码可以和矢量化代码一样快。
- en: It uses lightweight "green" threading also known as tasks or coroutines, cooperative
    multitasking, or one-shot continuations.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使用轻量级的“绿色”线程，也称为任务或协程、协作多任务处理或一次性延续。
- en: Julia has a powerful type system. The conversions provided are elegant and extensible.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Julia 拥有强大的类型系统。提供的转换既优雅又可扩展。
- en: It has efficient support for Unicode.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它对 Unicode 提供高效支持。
- en: It has facilities for metaprogramming and Lisp-like macros.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它具有元编程和类似 Lisp 的宏功能。
- en: It has a built-in package manager. (Pkg)
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它内置了包管理器（Pkg）。
- en: Julia provides efficient, specialized and automatic generation of code for different
    argument types.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Julia 提供了高效、专业化的代码生成，能够针对不同的参数类型进行自动化处理。
- en: It's free and open source with an MIT license.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是免费的，开源的，并且使用 MIT 许可证。
- en: Setting up the environment
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 环境设置
- en: 'Julia is available free. It can be downloaded from its website at the following
    address: [http://julialang.org/downloads/](http://julialang.org/downloads/). The
    website also has exhaustive documentation, examples, and links to tutorials and
    community. The documentation can be downloaded in popular formats.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 是免费的，可以从其官方网站下载，网址为：[http://julialang.org/downloads/](http://julialang.org/downloads/)。该网站还提供了详尽的文档、示例以及教程和社区的链接。文档可以以流行格式下载。
- en: Installing Julia (Linux)
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 Julia（Linux）
- en: Ubuntu/Linux Mint is one of the most famous Linux distros, and their deb packages
    of Julia are also provided. These are available for both 32-bit and 64-bit distributions.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Ubuntu/Linux Mint 是最著名的 Linux 发行版之一，它们也提供了 Julia 的 deb 包。这些包同时支持 32 位和 64 位版本。
- en: 'To install Julia, add the **PPA** (**personal package archive**). Ubuntu users
    are privileged enough to have PPA. It is treated as an apt repository to build
    and publish Ubuntu source packages. In the terminal, type the following:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装 Julia，请添加 **PPA**（**个人软件包档案**）。Ubuntu 用户有特权使用 PPA，它被视为一个 apt 仓库，用来构建和发布
    Ubuntu 源包。在终端中输入以下命令：
- en: '[PRE0]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This adds the PPA and updates the package index in the repository.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这会添加 PPA 并更新仓库中的软件包索引。
- en: 'Now install Julia:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在安装 Julia：
- en: '[PRE1]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The installation is complete. To check if the installation is successful in
    the Terminal type in the following:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成。要检查安装是否成功，请在终端中输入以下命令：
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This gives the installed Julia's version.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这会显示已安装的 Julia 版本。
- en: '![Installing Julia (Linux)](img/image_01_001.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![安装 Julia（Linux）](img/image_01_001.jpg)'
- en: 'To open the Julia''s interactive shell, type `julia` into the Terminal. To
    uninstall Julia, simply use `apt` to remove it:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要打开 Julia 的交互式 shell，在终端中输入 `julia`。要卸载 Julia，只需使用 `apt` 删除它：
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'For Fedora/RHEL/CentOS or distributions based on them, enable the EPEL repository
    for your distribution version. Then, click on the link provided. Enable Julia''s
    repository using the following:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Fedora/RHEL/CentOS 或基于它们的发行版，请启用你所在版本的 EPEL 仓库。然后，点击提供的链接。使用以下命令启用 Julia
    的仓库：
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Or copy the relevant `.repo` file available as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 或者复制相关的 `.repo` 文件，下载方式如下：
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Finally, in the Terminal type the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在终端中输入以下命令：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Installing Julia (Mac)
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 Julia（Mac）
- en: Users with Mac OS X need to click on the downloaded `.dmg` file to run the disk
    image. After that, drag the app icon into the **Applications** folder. It may
    prompt you to ask if you want to continue as the source has been downloaded from
    the Internet and so is not considered secure. Click on continue if it is downloaded
    for the Julia language official website.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Mac OS X 的用户需要点击下载的 `.dmg` 文件来运行磁盘映像。然后，将应用程序图标拖到 **Applications** 文件夹中。系统可能会提示你是否继续，因为该源来自互联网，因此被认为不安全。如果是从
    Julia 官方网站下载的，可以点击继续。
- en: 'Julia can also be installed using homebrew on the Mac as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以通过 homebrew 在 Mac 上安装 Julia，如下所示：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The installation is complete. To check if the installation is successful in
    the Terminal, type the following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成。要检查安装是否成功，请在终端中输入以下命令：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This gives you the installed Julia version.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这会显示已安装的 Julia 版本。
- en: Installing Julia (Windows)
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 Julia（Windows）
- en: Download the `.exe` file provided on the download page according to your system's
    configuration (32-bit/64-bit). Julia is installed on Windows by running the downloaded
    `.exe` file, which will extract Julia into a folder. Inside this folder is a batch
    file called `julia.bat`, which can be used to start the Julia console.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的系统配置（32 位/64 位），下载下载页面提供的 `.exe` 文件。通过运行下载的 `.exe` 文件来安装 Julia，这将把 Julia
    解压到一个文件夹中。在该文件夹内有一个批处理文件 `julia.bat`，可以用来启动 Julia 控制台。
- en: To uninstall, delete the `Julia` folder.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 要卸载，请删除 `Julia` 文件夹。
- en: Exploring the source code
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索源代码
- en: 'For enthusiasts, Julia''s source code is available and users are encouraged
    to contribute by adding features or by bug fixing. This is the directory structure
    of the tree:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 对于爱好者，Julia 的源代码是开放的，鼓励用户通过添加功能或修复漏洞来贡献代码。以下是目录结构：
- en: '| `base/` | Source code for Julia''s standard library |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `base/` | Julia 标准库的源代码 |'
- en: '| `contrib/` | Editor support for Julia source, miscellaneous scripts |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `contrib/` | Julia 源代码的编辑器支持，杂项脚本 |'
- en: '| `deps/` | External dependencies |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `deps/` | 外部依赖项 |'
- en: '| `doc/manual` | Source for the user manual |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `doc/manual` | 用户手册的源代码 |'
- en: '| `doc/stdlib` | Source for standard library function help text |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `doc/stdlib` | 标准库功能帮助文本的源代码 |'
- en: '| `examples/` | Example Julia programs |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `examples/` | Julia 示例程序 |'
- en: '| `src/` | Source for Julia language core |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `src/` | Julia 语言核心的源代码 |'
- en: '| `test/` | Test suites |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `test/` | 测试套件 |'
- en: '| `test/perf` | Benchmark suites |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `test/perf` | 基准测试套件 |'
- en: '| `ui/` | Source for various frontends |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `ui/` | 各种前端的源代码 |'
- en: '| `usr/` | Binaries and shared libraries loaded by Julia''s standard libraries
    |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `usr/` | Julia 标准库加载的二进制文件和共享库 |'
- en: Using REPL
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 REPL
- en: Read-Eval-Print-Loop is an interactive shell or the language shell that provides
    the functionality to test out pieces of code. Julia provides an interactive shell
    with a Just-in-Time compiler at the backend. We can give inputs in a line, it
    is compiled and evaluated, and the result is given in the next line.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Read-Eval-Print-Loop 是一个交互式 shell，或者称为语言 shell，提供了测试代码片段的功能。Julia 提供了一个带有即时编译器（Just-in-Time
    compiler）的交互式 shell。我们可以在一行中输入内容，系统会进行编译和评估，结果会在下一行显示。
- en: '![Using REPL](img/image_01_002.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![使用 REPL](img/image_01_002.jpg)'
- en: The benefit of using the REPL is that we can test out our code for possible
    errors. Also, it is a good environment for beginners. We can type in the expressions
    and press *Enter* to evaluate.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 REPL 的好处是我们可以测试代码是否有错误。此外，它还是初学者的一个很好的环境。我们可以输入表达式并按 *Enter* 键进行评估。
- en: 'A Julia library, or custom-written Julia program, can be included in the REPL
    using `include`. For example, I have a file called `hello.jl`, which I will include
    in the REPL by doing the following:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过 `include` 将一个 Julia 库或自定义编写的 Julia 程序包含到 REPL 中。例如，我有一个名为 `hello.jl` 的文件，我可以通过以下方式将其包含到
    REPL 中：
- en: '[PRE9]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Julia also stores all the commands written in the REPL in the `.julia_history`.
    This file is located at `/home/$USER` on Ubuntu, `C:\Users\username` on Windows,
    or `~/.julia_history` on OS X.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 还会将所有在 REPL 中输入的命令保存在 `.julia_history` 文件中。该文件位于 Ubuntu 的 `/home/$USER`、Windows
    的 `C:\Users\username` 或 macOS 的 `~/.julia_history`。
- en: As with a Linux Terminal, we can reverse-search using *Ctrl* + *R* in Julia's
    shell. This is a really nice feature as we can go back in the history of typed
    commands.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Linux 终端类似，我们可以在 Julia 的 shell 中使用 *Ctrl* + *R* 进行反向搜索。这是一个非常好的功能，因为我们可以回顾已经输入的命令历史。
- en: 'Typing `?` in the language shell will change the prompt to:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在语言 shell 中输入 `?` 将会将提示符更改为：
- en: '[PRE10]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '![Using REPL](img/image_01_003.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![使用 REPL](img/image_01_003.jpg)'
- en: 'To clear the screen, press *Ctrl* + *L*. To come out of the REPL press *Ctrl*
    + *D* or type the following:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 要清除屏幕，按 *Ctrl* + *L*。要退出 REPL，按 *Ctrl* + *D* 或输入以下命令：
- en: '[PRE11]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Using Jupyter Notebook
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Jupyter Notebook
- en: Data science and scientific computing are privileged to have an amazing interactive
    tool called Jupyter Notebook. With Jupyter Notebook you can to write and run code
    in an interactive web environment, which also has the capability to have visualizations,
    images, and videos. It makes testing of equations and prototyping a lot easier.
    It has the support of over 40 programming languages and is completely open source.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 数据科学和科学计算有幸拥有一个令人惊叹的交互式工具——Jupyter Notebook。使用 Jupyter Notebook，你可以在一个互动的网页环境中编写和运行代码，它还支持可视化、图片和视频等功能。它让方程的测试和原型设计变得更加轻松。它支持超过
    40 种编程语言，并且完全开源。
- en: GitHub supports Jupyter notebooks. The notebook with the record of computation
    can be shared via the Jupyter notebook viewer or other cloud storage. Jupyter
    notebooks are extensively used for coding machine-learning algorithms, statistical
    modeling and numerical simulation, and data munging.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub 支持 Jupyter 笔记本。包含计算记录的笔记本可以通过 Jupyter 笔记本查看器或其他云存储分享。Jupyter 笔记本广泛用于编写机器学习算法、统计建模、数值模拟和数据清洗。
- en: 'Jupyter Notebook is implemented in Python but you can run the code in any of
    the 40 languages provided you have their kernel. You can check if Python is installed
    on your system or not by typing the following into the Terminal:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Jupyter Notebook 是用 Python 实现的，但你可以运行任何 40 种语言的代码，只要你安装了相应的内核。你可以通过在终端中输入以下命令来检查是否已安装
    Python：
- en: '[PRE12]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This will give the version of Python if it is there on the system. It is best
    to have Python 2.7.x or 3.5.x or a later version.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回系统中 Python 的版本信息。如果系统中安装了 Python，最好是版本 2.7.x 或 3.5.x 或更高版本。
- en: 'If Python is not installed then you can install it by downloading it from the
    official website for Windows. For Linux, typing the following should work:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有安装 Python，你可以通过从官方网站下载并安装（适用于 Windows）。对于 Linux，输入以下命令应该可以安装：
- en: '[PRE13]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: It is highly recommended to install Anaconda if you are new to Python and data
    science. Commonly used packages for data science, numerical, and scientific computing
    including Jupyter notebook come bundled with Anaconda making it the preferred
    way to set up the environment. Instructions can be found at [https://www.continuum.io/downloads](https://www.continuum.io/downloads).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您是Python和数据科学的新手，强烈建议安装Anaconda。数据科学、数值和科学计算中常用的包，包括Jupyter笔记本，都与Anaconda捆绑在一起，这使得它成为设置环境的首选方式。安装说明可以在[https://www.continuum.io/downloads](https://www.continuum.io/downloads)上找到。
- en: 'Jupyter is present in the Anaconda package, but you can check if the Jupyter
    package is up to date by typing in the following:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Jupyter存在于Anaconda包中，但您可以通过键入以下命令检查Jupyter包是否是最新的：
- en: '[PRE14]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Another way to install Jupyter is by using `pip`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Jupyter的另一种方法是使用`pip`：
- en: '[PRE15]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To check if Jupyter is installed properly, type the following in the Terminal:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查Jupyter是否正确安装，请在终端中键入以下命令：
- en: '[PRE16]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: It should give the version of the Jupyter if it is installed.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Jupyter已安装，它应该会显示版本号。
- en: Now, to use Julia with Jupyter we need the `IJulia` package. This can be installed
    using Julia's package manager.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要在Jupyter中使用Julia，我们需要`IJulia`包。可以使用Julia的包管理器安装该包。
- en: After installing IJulia, we can create a new notebook by selecting Julia under
    the **Notebooks** section in Jupyter.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 安装IJulia后，我们可以在Jupyter中通过选择**笔记本**部分下的Julia来创建新的笔记本。
- en: '![Using Jupyter Notebook](img/image_01_004.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![使用Jupyter笔记本](img/image_01_004.jpg)'
- en: 'To get the latest version of all your packages, in Julia''s shell type the
    following:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取所有包的最新版本，在Julia的Shell中键入以下命令：
- en: '[PRE17]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'After that add the IJulia package by typing the following:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，通过键入以下命令添加IJulia包：
- en: '[PRE18]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In Linux, you may face some warnings, so it''s better to build the package:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux中，您可能会遇到一些警告，因此最好构建该包：
- en: '[PRE19]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'After IJulia is installed, come back to the Terminal and start the Jupyter
    notebook:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 安装IJulia后，返回终端并启动Jupyter笔记本：
- en: '[PRE20]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: A browser window will open. Under **New**, you will find options to create new
    notebooks with the kernels already installed. As we want to start a Julia notebook
    we will select **Julia 0.4.2**. This will start a new Julia notebook. You can
    try out a simple example.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 一个浏览器窗口将会打开。在**新建**选项下，您将找到已安装内核的选项来创建新笔记本。由于我们想要启动一个Julia笔记本，因此选择**Julia 0.4.2**。这将启动一个新的Julia笔记本。您可以尝试一个简单的示例。
- en: In this example, we are creating a histogram of random numbers. This is just
    an example we will be studying the components used in detail in coming chapters.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们正在创建一个随机数的直方图。这只是一个示例，我们将在接下来的章节中详细研究使用的组件。
- en: '![Using Jupyter Notebook](img/image_01_005.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![使用Jupyter笔记本](img/image_01_005.jpg)'
- en: Popular editors such as Atom and Sublime have a plugin for Julia. Atom has language—julia
    and Sublime has Sublime—IJulia, both of which can be downloaded from their package
    managers.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 流行的编辑器如Atom和Sublime都有Julia插件。Atom有语言—julia，Sublime有Sublime—IJulia，二者都可以从它们的包管理器下载。
- en: Package management
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包管理
- en: Julia provides a built-in package manager. Using Pkg we can install libraries
    written in Julia. For external libraries, we can also compile them from their
    source or use the standard package manager of the operating system. A list of
    registered packages is maintained at [http://pkg.julialang.org](http://pkg.julialang.org).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Julia提供了内置的包管理器。使用Pkg，我们可以安装用Julia编写的库。对于外部库，我们还可以从源代码进行编译，或使用操作系统的标准包管理器。注册包的列表可在[http://pkg.julialang.org](http://pkg.julialang.org)上找到。
- en: Pkg is provided in the base installation. The Pkg module contains all the package
    manager commands.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Pkg在基础安装中提供。Pkg模块包含所有包管理命令。
- en: Pkg.status() – package status
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Pkg.status() – 包状态
- en: The `Pkg.status()` is a function that prints out a list of currently installed
    packages with a summary. This is handy when you need to know if the package you
    want to use is installed or not.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`Pkg.status()`是一个函数，打印出当前已安装包的列表及其摘要。当您需要知道要使用的包是否已安装时，这非常方便。'
- en: When the `Pkg` command is run for the first time, the package directory is automatically
    created. It is required by the command that the `Pkg.status()` returns a valid
    list of the packages installed. The list of packages given by the `Pkg.status()`
    are of registered versions which are managed by Pkg.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当第一次运行`Pkg`命令时，包目录会自动创建。该命令要求`Pkg.status()`返回已安装包的有效列表。由`Pkg.status()`提供的包列表是由Pkg管理的已注册版本。
- en: '`Pkg.installed()` can also be used to return a list of all the installed packages
    with their versions.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`Pkg.installed()`也可以用来返回所有已安装包及其版本的列表。'
- en: '![Pkg.status() – package status](img/image_01_006.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![Pkg.status() – 包状态](img/image_01_006.jpg)'
- en: Pkg.add() – adding packages
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Pkg.add() – 添加包
- en: Julia's package manager is declarative and intelligent. You only have to tell
    it what you want and it will figure out what version to install and will resolve
    dependencies if there are any. Therefore, we only need to add the list of requirements
    that we want and it resolves which packages and their versions to install.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Julia的包管理器是声明式的且智能的。你只需要告诉它你想要什么，它会计算出需要安装的版本，并在有依赖关系时进行解决。因此，我们只需添加所需的包列表，它会自动解决需要安装的包及其版本。
- en: The `~/.julia/v0.4/REQUIRE` file contains the package requirements. We can open
    it using a text editor such as vi or atom, or use `Pkg.edit()` in Julia's shell
    to edit this file. After editing the file, run `Pkg.resolve()` to install or remove
    the packages.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`~/.julia/v0.4/REQUIRE`文件包含包的需求。我们可以使用文本编辑器如vi或atom打开它，或在Julia的shell中使用`Pkg.edit()`来编辑这个文件。编辑完文件后，运行`Pkg.resolve()`来安装或删除包。'
- en: We can also use `Pkg.add(package_name)` to add packages and `Pkg.rm(package_name)` to
    remove packages. Earlier, we used `Pkg.add("IJulia")`  to install the IJulia package.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`Pkg.add(package_name)`来添加包，使用`Pkg.rm(package_name)`来删除包。之前，我们使用`Pkg.add("IJulia")`来安装IJulia包。
- en: When we don't want to have a package installed on our system anymore, `Pkg.rm()` is
    used for removing the requirement from the `REQUIRE` file. Similar to `Pkg.add()`,
    `Pkg.rm()` first removes the requirement of the package from the `REQUIRE` file
    and then updates the list of installed packages by running `Pkg.resolve()` to
    match.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们不再想在系统中安装某个包时，可以使用`Pkg.rm()`从`REQUIRE`文件中删除该包的需求。与`Pkg.add()`类似，`Pkg.rm()`首先从`REQUIRE`文件中移除包的需求，然后通过运行`Pkg.resolve()`来更新已安装包的列表以匹配。
- en: Working with unregistered packages
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用未注册包
- en: 'Frequently, we would like to be able to use packages created by our team members
    or someone who has published on Git but they are not in the registered packages
    of Pkg. Julia allows us to do that by using a clone. Julia packages are hosted
    on Git repositories and can be cloned using mechanisms supported by Git. The index
    of registered packages is maintained at `METADATA.jl`. For unofficial packages,
    we can use the following:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常希望能够使用我们团队成员创建的或有人在Git上发布的包，但它们不在Pkg的注册包中。Julia通过使用克隆来支持这种情况。Julia包托管在Git仓库中，并可以使用Git支持的机制进行克隆。注册包的索引保存在`METADATA.jl`中。对于非官方包，我们可以使用以下命令：
- en: '[PRE21]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Sometimes unregistered packages have dependencies that require fulfilling before
    use. If that is the scenario, a `REQUIRE` file is needed at the top of the source
    tree of the unregistered package. The dependencies of the unregistered packages
    on the registered packages are determined by this `REQUIRE` file. When we run
    `Pkg.clone(url)`, these dependencies are automatically installed.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，未注册的包可能有依赖关系，在使用之前需要满足。如果是这种情况，那么在未注册包的源代码树顶部需要一个`REQUIRE`文件。该`REQUIRE`文件确定了未注册包对已注册包的依赖关系。当我们运行`Pkg.clone(url)`时，这些依赖关系会被自动安装。
- en: Pkg.update() – package update
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Pkg.update() – 包更新
- en: It's good to have updated packages.  Julia, which is under active development,
    has its packages frequently updated and new functionalities are added.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有更新的包是非常好的。Julia作为一个活跃开发的项目，它的包经常更新并添加新的功能。
- en: 'To update all of the packages, type the following:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新所有包，请键入以下命令：
- en: '[PRE22]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Under the hood, new changes are pulled into the METADATA file in the directory
    located at `~/.julia/v0.4/` and it checks for any new registered package versions
    which may have been published since the last update. If there are new registered
    package versions, `Pkg.update()` attempts to update the packages which are not
    dirty and are checked out on a branch. This update process satisfies the top-level
    requirements by computing the optimal set of package versions to be installed.
    The packages with specific versions that must be installed are defined in the
    REQUIRE file in Julia's directory (`~/.julia/v0.4/`).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在后台，新的更改被拉入位于`~/.julia/v0.4/`目录下的METADATA文件，并且检查自上次更新以来是否有任何新的注册包版本发布。如果有新的注册包版本，`Pkg.update()`将尝试更新那些未被修改且已签出的包。这一更新过程通过计算要安装的最优包版本集来满足顶级需求。必须安装的特定版本包在Julia的`~/.julia/v0.4/`目录中的REQUIRE文件中定义。
- en: METADATA repository
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: METADATA 仓库
- en: 'Registered packages are downloaded and installed using the official `METADATA.jl`
    repository. A different `METADATA` repository location can also be provided if
    required:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 注册的包会使用官方的 `METADATA.jl` 仓库进行下载和安装。如果需要，也可以提供不同的 `METADATA` 仓库位置：
- en: '[PRE23]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Developing packages
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开发包
- en: Julia allows us to view the source code and as it is tracked by Git, the full
    development history of all the installed packages is available. We can also make
    our desired changes and commit to our own repository, or do bug fixes and contribute
    enhancements upstream.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 允许我们查看源代码，并且由于它是由 Git 跟踪的，所有已安装包的完整开发历史都可用。我们还可以进行所需的修改并提交到我们自己的仓库，或者进行
    bug 修复并将增强功能贡献到上游。
- en: You may also want to create your own packages and publish them at some point
    in time. Julia's package manager allows you to do that too.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可能想在某个时候创建自己的包并发布它们。Julia 的包管理器也允许你这样做。
- en: It is a requirement that Git is installed on the system and the developer needs
    an account at their hosting provider of choice (GitHub, Bitbucket, and so on).
    Having the ability to communicate over SSH is preferred—to enable that, upload
    your public ssh-key to your hosting provider.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 系统上必须安装 Git，并且开发者需要在其选择的托管提供商（如 GitHub、Bitbucket 等）上拥有一个账户。最好能通过 SSH 进行通信—为了实现这一点，上传你的公钥到托管提供商。
- en: Creating a new package
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建新包
- en: It is preferable to have the `REQUIRE` file in the package repository. This
    should have the bare minimum of a description of the Julia version.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 最好在包的仓库中包含 `REQUIRE` 文件。这个文件应该至少包含关于 Julia 版本的基本描述。
- en: 'For example, if we would like to create a new Julia package called `HelloWorld`
    we would have the following:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想创建一个新的 Julia 包，名为 `HelloWorld`，我们将有如下内容：
- en: '[PRE24]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Here, `HelloWorld` is the package that we want to create and `MIT` is the license
    that our package will have. The license should be known to the package generator.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`HelloWorld` 是我们要创建的包，`MIT` 是我们的包将使用的许可证。许可证应该为包生成器所知。
- en: 'This will create a directory as follows: `~/.julia/v0.4/HelloWorld`. The directory
    that is created is initialized as a Git repository. Also, all the files required
    by the package are kept in this directory. This directory is then committed to
    the repository.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个目录，如下所示：`~/.julia/v0.4/HelloWorld`。创建的目录会初始化为一个 Git 仓库。同时，包所需的所有文件都保存在这个目录中。这个目录随后会被提交到仓库中。
- en: This can now be pushed to the remote repository for the world to use.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以将其推送到远程仓库，供全世界使用。
- en: Parallel computation using Julia
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Julia 进行并行计算
- en: Advancement in modern computing has led to multi-core CPUs in systems and sometimes
    these systems are combined together in a cluster capable of performing a task
    which a single system might not be able to perform alone, or if it did it would
    take an undesirable amount of time. Julia's environment of parallel processing
    is based on message passing. Multiple processes are allowed for programs in separate
    memory domains.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现代计算的发展导致系统中出现多核 CPU，有时这些系统会被组合成一个集群，能够执行单一系统可能无法独立完成的任务，或者即使完成了，所需时间也不可接受。Julia
    的并行处理环境基于消息传递。允许多个进程在独立的内存域中运行程序。
- en: Message passing is implemented differently in Julia from other popular environments
    such as MPI. Julia provides one-sided communication, therefore the programmer
    explicitly manages only one process in the two-process operation.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Julia 中，消息传递的实现方式与其他流行环境（如 MPI）不同。Julia 提供了单向通信，因此程序员只需显式地管理两个进程操作中的一个进程。
- en: 'Julia''s parallel programming paradigm is built on the following:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 的并行编程范式基于以下内容：
- en: Remote references
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 远程引用
- en: Remote calls
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 远程调用
- en: A request to run a function on another process is called a remote call. The
    reference to an object by another object on a particular process is called a remote
    reference. A remote reference is a construct used in most distributed object systems.
    Therefore, a call which is made with some specific arguments to the objects generally
    on a different process by the objects of the different process is called the remote
    call and this will return a reference to the remote object which is called the
    remote reference.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个进程上运行函数的请求称为远程调用。通过特定进程上的另一个对象对对象的引用称为远程引用。远程引用是大多数分布式对象系统中使用的构造。因此，通过某些特定的参数，由不同进程的对象发出的调用，通常会返回对远程对象的引用，这个引用被称为远程引用。
- en: The remote call returns a remote reference to its result. Remote calls return
    immediately. The process that made the call proceeds to its next operation. Meanwhile,
    the remote call happens somewhere else. A call to `wait()` on its remote reference
    waits for the remote call to finish. The full value of the result can be obtained
    using `fetch()`, and `put!()` is used to store the result to a remote reference.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 远程调用返回一个指向其结果的远程引用。远程调用会立即返回。发出调用的进程继续执行下一操作。与此同时，远程调用在其他地方发生。对其远程引用调用`wait()`会等待远程调用完成。可以使用`fetch()`获得结果的完整值，`put!()`用于将结果存储到远程引用中。
- en: 'Julia uses a single process default. To start Julia with multiple processors
    use the following:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Julia使用单进程作为默认设置。要以多个处理器启动Julia，请使用以下命令：
- en: '[PRE25]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: where n is the number of worker processes. Alternatively, it is possible to
    create extra processors from a running system by using `addproc(n)`. It is advisable
    to put n equal to the number of the CPU cores in the system.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 其中n是工作进程的数量。或者，也可以通过使用`addproc(n)`从运行中的系统创建额外的处理器。建议将n设置为系统中CPU核心的数量。
- en: '`pmap` and `@parallel` are the two most frequently used and useful functions.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`pmap`和`@parallel`是最常用且最有用的两个函数。'
- en: Julia provides a *parallel for loop,* used to run a number of processes in parallel.
    This is used as follows.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Julia提供了一个*并行for循环*，用于并行运行多个进程。它的使用方式如下。
- en: '![Parallel computation using Julia](img/B05321_01_8.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![使用Julia进行并行计算](img/B05321_01_8.jpg)'
- en: '*Parallel for loop* works by having multiple processes assigned iterations
    and then reducing the result (in this case (+)). It is somewhat similar to the
    map-reduce concept. Iterations will run independently over different processes
    and the results obtained by these processes will be combined at the end (like
    map-reduce). The resultant of one loop can also become the feeder for the other
    loop. The answer is the resultant of this whole parallel loop.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '*并行for循环*通过将多个进程分配给不同的迭代，然后对结果进行归约（在这个案例中是(+)）来工作。它与map-reduce概念有些相似。迭代将在不同的进程上独立执行，最终这些进程得到的结果会被组合在一起（就像map-reduce）。一个循环的结果也可以成为另一个循环的输入。答案是这个整个并行循环的结果。'
- en: It is very different than a normal iterative loop because the iterations do
    not take place in a specified sequence. As the iterations run on different processes,
    any writes that happens on variables or arrays are not globally visible. The variables
    used are copied and broadcasted to each process of the parallel for loop.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 它与普通的迭代循环非常不同，因为迭代不按照特定的顺序发生。由于迭代在不同的进程上运行，任何对变量或数组的写入在全局范围内是不可见的。所使用的变量会被复制并广播到每个并行for循环的进程中。
- en: 'For example:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE26]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This will not give the desired result as each process gets their own separate
    copy of `arr`. The vector will not be filled in with `i` as expected. We must
    avoid such *parallel for loops*.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这不会得到预期的结果，因为每个进程都会获得自己独立的`arr`副本。向量不会按预期填充`i`。我们必须避免使用这种*并行for循环*。
- en: '`pmap` refers to parallel map. For example:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`pmap`指的是并行映射。例如：'
- en: '![Parallel computation using Julia](img/B05321_01_7.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![使用Julia进行并行计算](img/B05321_01_7.jpg)'
- en: This code solves the problem if we have a number of large random matrices and
    we are required to obtain the singular values, in parallel.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码解决了当我们有多个大型随机矩阵，并且需要并行地获取其奇异值的问题。
- en: Julia's `pmap()` is designed differently. It is well suited for cases where
    a large amount of work is done by each function call, whereas `@parallel` is suited
    for handling situations which involve numerous small iterations. Both `pmap()` and `@parallel`
    for utilize worker nodes for parallel computation. However, the node from which
    the calling process originated does the final reduction in `@parallel` for.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Julia的`pmap()`设计得不同。它非常适合每次函数调用处理大量工作量的情况，而`@parallel`适用于涉及众多小迭代的情形。`pmap()`和`@parallel`都利用工作节点进行并行计算。然而，在`@parallel`中，调用进程发源的节点会进行最终的归约。
- en: Julia's key feature – multiple dispatch
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Julia的关键特性——多重分派
- en: A function is an object, mapping a tuple of arguments using some expression
    to a return value. When this function object is unable to return a value, it throws
    an exception. For different types of arguments the same conceptual function can
    have different implementations. For example, we can have a function to add two
    floating point numbers and another function to add two integers. But conceptually,
    we are only adding two numbers. Julia provides a functionality by which different
    implementations of the same concept can be implemented easily. The functions don't
    need to be defined all at once. They are defined in small abstracts. These small
    abstracts are different argument type combinations and have different behaviors
    associated with them. The definition of one of these behaviors is called a method.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是一个对象，它使用某些表达式将参数元组映射到返回值。当这个函数对象无法返回值时，它会抛出异常。对于不同类型的参数，同一个概念函数可以有不同的实现。例如，我们可以有一个函数来加两个浮点数，另一个函数来加两个整数。但从概念上讲，我们只是在加两个数字。Julia提供了一种功能，使得同一概念的不同实现能够轻松实现。这些函数不需要一次性定义。它们是通过小的抽象来定义的。这些小抽象对应不同的参数类型组合，并具有与之相关的不同行为。定义这些行为之一的过程叫做方法（method）。
- en: The types and the number of arguments that a method definition accepts is indicated
    by the annotation of its signatures. Therefore, the most suitable method is applied
    whenever a function is called with a certain set of arguments. To apply a method
    when a function is invoked is known as dispatch. Traditionally, object-oriented
    languages consider only the first argument in dispatch. Julia is different as
    all of the function's arguments are considered (not just only the first) and then
    it choses which method should be invoked. This is known as multiple dispatch.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 方法定义接受的参数类型和数量通过其签名的注释来表示。因此，每当使用一组特定的参数调用函数时，都会应用最合适的方法。在函数调用时应用一个方法被称为派发（dispatch）。传统的面向对象语言只考虑派发中的第一个参数。而Julia有所不同，它会考虑所有函数的参数（不仅仅是第一个），然后选择应该调用的方法。这被称为多重派发（multiple
    dispatch）。
- en: Multiple dispatch is particularly useful for mathematical and scientific code.
    We shouldn't consider that the operations belong to one argument more than any
    of the others. All of the argument types are considered when implementing a mathematical
    operator. Multiple dispatch is not limited to mathematical expressions as it can
    be used in numerous real-world scenarios and is a powerful paradigm for structuring
    the programs.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 多重派发对于数学和科学代码特别有用。我们不应该认为操作只属于某一个参数，而不属于其他参数。实现数学运算符时，会考虑所有的参数类型。多重派发不仅限于数学表达式，它可以应用于众多现实世界的场景，并且是一种强大的程序结构设计范式。
- en: Methods in multiple dispatch
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多重派发中的方法
- en: '`+` is a function in Julia using multiple dispatch. Multiple dispatch is used
    by all of Julia''s standard functions and operators. For various possible combinations
    of argument types and count, all of them have many methods defining their behavior.
    A method is restricted to take certain types of arguments using the `::` type-assertion
    operator:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`+` 是一个使用多重派发的Julia函数。Julia的所有标准函数和操作符都使用多重派发。对于各种可能的参数类型和数量的组合，每种组合都有许多方法来定义它们的行为。使用`::`类型断言操作符，方法限制只能接受某些类型的参数：'
- en: '[PRE27]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The function definition will only be applied for calls where `x` and `y` are
    both values of type `Float64`:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数定义仅适用于`x`和`y`都为`Float64`类型的值时的调用：
- en: '[PRE28]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: If we try to apply this definition to other types of arguments, it will give
    a method error.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试将这个定义应用到其他类型的参数，它将会给出方法错误。
- en: '![Methods in multiple dispatch](img/B05321_01_9.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![多重派发中的方法](img/B05321_01_9.jpg)'
- en: The arguments must be of precisely the same type as defined in the function
    definition.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 参数必须与函数定义中精确指定的类型相同。
- en: The function object is created in the first method definition. New method definitions
    add new behaviors to the existing function object. When a function is invoked,
    the number and types of the arguments are matched, and the most specific method
    definition matching will be executed.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 函数对象在第一个方法定义时创建。新的方法定义会为现有的函数对象添加新的行为。当函数被调用时，会匹配参数的数量和类型，并执行最具体的匹配方法定义。
- en: The following example creates a function with two methods. One method definition
    takes two arguments of the type `Float64` and adds them. The second method definition
    takes two arguments of the type `Number`, multiplies them by two and adds them.
    When we invoke the function with `Float64` arguments, then the first method definition
    is applied, and when we invoke the function with Integer arguments, the second
    method definition is applied as the number can take any numeric values. In the
    following example, we are playing with floating point numbers and integers using
    multiple dispatch.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例创建了一个具有两个方法的函数。第一个方法定义接受两个`Float64`类型的参数并将其相加。第二个方法定义接受两个`Number`类型的参数，将其乘以2并相加。当我们用`Float64`类型的参数调用该函数时，第一个方法定义会被应用；而当我们用整数类型的参数调用该函数时，第二个方法定义会被应用，因为数字可以接受任何数值。在以下示例中，我们通过多重派发来操作浮点数和整数。
- en: '![Methods in multiple dispatch](img/B05321_01_10.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![多重派发中的方法](img/B05321_01_10.jpg)'
- en: In Julia, all values are instances of the abstract type "Any". When the type
    declaration is not given with `::`, that means it is not specifically defined
    as the type of the argument, therefore Any is the default type of method parameter
    and it doesn't have the restriction of taking any type of value. Generally, one
    method definition is written in such a way that it will be applied to the certain
    arguments to which no other method definition applies. It is one of the Julia
    language's most powerful features.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在Julia中，所有值都是抽象类型"Any"的实例。当没有使用`::`进行类型声明时，表示该参数类型没有明确指定，因此`Any`是方法参数的默认类型，它没有限制可以接受任何类型的值。通常，一个方法定义是为了应用于某些没有其他方法定义适用的参数。它是Julia语言最强大的功能之一。
- en: It is efficient with a great ease of expressiveness to generate specialized
    code and implement complex algorithms without caring much about the low-level
    implementation using Julia's multiple dispatch and flexible parametric type system.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 利用Julia的多重派发和灵活的参数化类型系统，可以高效地生成专门的代码并实现复杂的算法，而无需过多关注底层实现，且表达能力非常强。
- en: Ambiguities – method definitions
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 歧义 – 方法定义
- en: Sometimes function behaviors are defined in such a way that there isn't a unique
    method to apply for a certain set of arguments. Julia throws a warning in such
    cases about this ambiguity, but proceeds by arbitrarily picking a method. To avoid
    this ambiguity we should define a method to handle such cases.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，函数的行为定义方式可能导致对于某些参数集没有唯一的方法可应用。在这种情况下，Julia会抛出关于这种歧义的警告，但会继续执行并随机选择一个方法。为了避免这种歧义，我们应该定义一个方法来处理这种情况。
- en: In the following example, we define a method definition with one argument of
    the type `Any` and another argument of the type `Float64`. In the second method
    definition, we just changed the order, but this doesn't differentiate it from
    the first definition. In this case, Julia will give a warning of ambiguous method
    definition but will allow us to proceed.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们定义了一个方法定义，具有一个类型为`Any`的参数和一个类型为`Float64`的参数。在第二个方法定义中，我们只是改变了参数的顺序，但这并没有将其与第一个定义区分开。在这种情况下，Julia会发出歧义的方法定义警告，但仍然允许我们继续执行。
- en: '![Ambiguities – method definitions](img/B05321_01_11.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![歧义 – 方法定义](img/B05321_01_11.jpg)'
- en: Facilitating language interoperability
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 促进语言互操作性
- en: Although Julia can be used to write most kinds of code, there are mature libraries
    for numerical and scientific computing which we would like to exploit. These libraries
    can be in C, Fortran or Python. Julia allows the ease of using the existing code
    written in Python, C, or Fortran. This is done by making Julia perform simple
    and efficient-to-call C, Fortran, or Python functions.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Julia可以用来编写大多数类型的代码，但我们希望利用一些成熟的数值计算和科学计算库。这些库可能是用C、Fortran或Python编写的。Julia允许轻松使用现有的Python、C或Fortran代码。通过让Julia调用简单且高效的C、Fortran或Python函数，可以轻松实现这一目标。
- en: The C/Fortran libraries should be available to Julia. An ordinary but valid
    call with `ccall` is made to this code. This is possible when the code is available
    as a shared library. Julia's JIT generates the same machine instructions as the
    native C call. Therefore, it is generally no different from calling through a
    C code with a minimal overhead.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: C/Fortran库应当可以供Julia使用。通过`ccall`进行常规但有效的调用。这种调用方式只有在代码作为共享库时才可行。Julia的JIT会生成与本地C调用相同的机器指令，因此与通过C代码调用没有什么不同，且开销极小。
- en: 'Importing Python code can be beneficial and sometimes needed, especially for
    data science, because it already has an exhaustive library of implementations
    of machine learning and statistical functions. For example, it contains scikit-learn
    and pandas. To use Python in Julia, we require `PyCall.jl`. To add `PyCall.jl`
    do the following:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 导入 Python 代码在数据科学中非常有用，甚至是必需的，因为 Python 已经有了一个完整的机器学习和统计函数库。例如，它包含了 scikit-learn
    和 pandas。要在 Julia 中使用 Python，我们需要 `PyCall.jl`。添加 `PyCall.jl` 的方法如下：
- en: '[PRE29]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '![Facilitating language interoperability](img/B05321_01_12.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![促进语言互操作性](img/B05321_01_12.jpg)'
- en: PyCall contains a macro `@pyimport` that facilitates importing Python packages
    and provides Julia wrappers for all of the functions and constants therein, including
    automatic conversion of types between Julia and Python.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: PyCall 提供了一个宏 `@pyimport`，可以简化导入 Python 包的过程，并为其中的所有函数和常量提供 Julia 封装，包括自动转换
    Julia 与 Python 之间的类型。
- en: PyCall also provides functionalities for lower-level manipulation of Python
    objects, including a PyObject type for opaque Python objects. It also has a `pycall`
    function (similar to Julia's `ccall` function), which can be used in Julia to
    call Python functions with type conversions. PyCall does not use the Python program
    but links directly to the `libpython` library. During the `Pkg.build`, it finds
    the location of the `libpython` by Punning python.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: PyCall 还提供了对 Python 对象的低级操作功能，包括一个用于不透明 Python 对象的 PyObject 类型。它还提供了一个 `pycall`
    函数（类似于 Julia 的 `ccall` 函数），可以在 Julia 中调用 Python 函数并进行类型转换。PyCall 不使用 Python 程序，而是直接链接到
    `libpython` 库。在 `Pkg.build` 过程中，它通过调用 Python 查找 `libpython` 的位置。
- en: Calling Python code in Julia
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Julia 中调用 Python 代码
- en: 'The `@pyimport` macro automatically makes the appropriate type conversions
    to Julia types in most of the scenarios based on a runtime inspection of the Python
    objects. It achieves better control over these type conversions by using lower-level
    functions. Using PyCall in scenarios where the return type is known can help in
    improving the performance, both by eliminating the overhead of runtime type inference,
    and also by providing more type information to the Julia compiler:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`@pyimport` 宏在大多数情况下会根据 Python 对象的运行时检查自动进行适当的类型转换为 Julia 类型。通过使用低级函数，它能更好地控制这些类型转换。在返回类型已知的情况下使用
    PyCall，可以帮助提升性能，既可以消除运行时类型推断的开销，又可以为 Julia 编译器提供更多的类型信息：'
- en: '`pycall(function::PyObject, returntype::Type, args...)`: This calls the given
    Python function (typically looked up from a module) with the given `args...` (of
    standard Julia types which are converted automatically to the corresponding Python
    types if possible), converting the return value to `returntype` (use a `returntype`
    of PyObject to return the unconverted Python object reference, or PyAny to request
    an automated conversion).'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pycall(function::PyObject, returntype::Type, args...)`：此函数调用给定的 Python 函数（通常从模块中查找），并传入给定的
    `args...`（这些参数是标准的 Julia 类型，如果可能的话，会自动转换为相应的 Python 类型），并将返回值转换为 `returntype`（如果要返回未转换的
    Python 对象引用，请使用 `returntype` 为 PyObject，或使用 PyAny 来请求自动转换）。'
- en: '`pyimport(s)`: This imports the Python modules (a string or symbol) and returns
    a pointer to it (a PyObject). Functions or other symbols in the module may then
    be looked up by s[name] where the name is a string (for the raw PyObject) or a
    symbol (for automatic type conversion). Unlike the `@pyimport` macro, this does
    not define a Julia module and members cannot be accessed with an `s.name`.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pyimport(s)`：此函数导入 Python 模块（可以是字符串或符号），并返回一个指向该模块的指针（一个 PyObject）。然后，可以通过
    s[name] 查找模块中的函数或其他符号，其中 name 可以是字符串（用于原始 PyObject）或符号（用于自动类型转换）。与 `@pyimport`
    宏不同，它不会定义一个 Julia 模块，成员不能通过 `s.name` 访问。'
- en: Summary
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned how Julia is different and how an LLVM-based JIT
    compiler enables Julia to approach the performance of C/C++. We introduced you
    to how to download Julia, install it, and build it from source. The notable features
    that we found were that the language is elegant, concise, and powerful and it
    has amazing capabilities for numeric and scientific computing.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了 Julia 的不同之处，以及基于 LLVM 的 JIT 编译器如何使 Julia 接近 C/C++ 的性能。我们介绍了如何下载、安装和从源代码构建
    Julia。我们发现的显著特点是，这种语言优雅、简洁、强大，并且在数值计算和科学计算方面具有惊人的能力。
- en: We worked on some examples of working with Julia via the command line (REPL)
    and saw how full of features the language shell is. The features found were tab-completion,
    reverse-search, and help functions. We also discussed why should we use Jupyter Notebook
    and went on to set up Jupyter with the IJulia package. We worked on a simple example
    to use the Jupyter Notebook and Julia's visualization package, Gadfly.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过命令行（REPL）进行了一些使用Julia的示例，并看到了这个语言的外壳功能丰富。所发现的功能包括自动补全、反向搜索和帮助功能。我们还讨论了为什么要使用Jupyter
    Notebook，并继续设置了带有IJulia包的Jupyter。我们用一个简单的例子演示了如何使用Jupyter Notebook和Julia的可视化包Gadfly。
- en: In addition, we learned about Julia's powerful built-in package management and
    how to add, update, and remove modules. Also, we went through the process of creating
    our own package and publishing it to the community. We also introduced you to
    one of the most powerful features of Julia—multiple dispatch—and worked on some
    basic examples of how to create method definitions to implement multiple dispatch.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们学习了Julia强大的内置包管理功能，以及如何添加、更新和删除模块。同时，我们也学习了如何创建自己的包并发布到社区。我们还向你介绍了Julia的一个强大特性——多重派发，并通过一些基本示例演示了如何创建方法定义来实现多重派发。
- en: In addition, we introduced you to the parallel computation, explaining how it
    is different from conventional message passing and how to make use of all the
    compute resources available. We also learned Julia's feature of language interoperability
    and how we can call a Python module or a library from the Julia program.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们向你介绍了并行计算，解释了它与传统的消息传递方式有何不同，以及如何利用所有可用的计算资源。我们还学习了Julia的语言互操作性特性，了解了如何从Julia程序中调用Python模块或库。
- en: References
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考文献
- en: '[http://julialang.org/](http://julialang.org/)'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://julialang.org/](http://julialang.org/)'
- en: '[https://github.com/JuliaLang](https://github.com/JuliaLang)'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/JuliaLang](https://github.com/JuliaLang)'
- en: '[https://github.com/JuliaStats](https://github.com/JuliaStats)'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/JuliaStats](https://github.com/JuliaStats)'
