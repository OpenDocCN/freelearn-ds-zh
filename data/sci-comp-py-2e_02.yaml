- en: Variables and Basic Types
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 变量和基本类型
- en: In this chapter, we will present the most important and basic types in Python.
    What is a type? It is a set consisting of data content, its representation, and
    all possible operations. Later in this book, we will make this definition much
    more precise when we introduce the concepts of a class in [Chapter 8](1654fae9-6203-4871-8352-e436445fa49a.xhtml): *Classes*.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍 Python 中最重要和最基本的类型。什么是类型？它是由数据内容、其表示以及所有可能的操作组成的集合。在本书的后续部分，当我们在[第8章](1654fae9-6203-4871-8352-e436445fa49a.xhtml)：*类*中介绍类的概念时，我们将更精确地定义这一概念。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Variables
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量
- en: Numeric types
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字类型
- en: Booleans
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布尔值
- en: Strings
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串
- en: 2.1 Variables
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.1 变量
- en: 'Variables are references to Python objects. They are created by assignments,
    for example:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 变量是 Python 对象的引用。它们通过赋值创建，例如：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Variables take names that consist of any combination of capital and small letters,
    the underscore `_`, and digits. A variable name must not start with a digit. Note
    that variable names are case sensitive. A good naming of variables is an essential
    part of documenting your work, so we recommend that you use descriptive variable
    names.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 变量的名称可以由大写字母、小写字母、下划线`_`和数字组成。变量名不能以数字开头。请注意，变量名是区分大小写的。良好的变量命名是文档化工作的重要部分，因此我们建议使用具有描述性的变量名。
- en: 'Python has 33 *reserved keywords*, which cannot be used as variable names (see *Table
    2.1*). Any attempt to use such a keyword as a variable name would raise a syntax
    error:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Python 有 33 个*保留关键字*，不能作为变量名使用（见*表 2.1*）。如果尝试将这些关键字作为变量名，将会引发语法错误：
- en: '![](img/9e2e5bf9-1c77-4493-b5ce-f9f3b88e15c2.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9e2e5bf9-1c77-4493-b5ce-f9f3b88e15c2.png)'
- en: 'Table 2.1: Reserved Python keywords'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2.1：保留的 Python 关键字
- en: 'As opposed to other programming languages, variables require no type declaration
    in Python. The type is automatically deduced:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他编程语言不同，Python 中的变量不需要声明类型。类型是自动推导的：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You can create several variables with a multiple assignment statement:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过多重赋值语句创建多个变量：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Variables can also be altered after their definition:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 变量在定义后也可以被修改：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The last two statements can be written by combining the two operations with
    an assignment directly by using increment operators:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两个语句可以通过结合这两种操作与赋值操作直接使用增量运算符来编写：
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 2.2 Numeric types
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.2 数字类型
- en: At some point, you will have to work with numbers, so we start by considering
    different forms of numeric types in Python. In mathematics, we distinguish between
    natural numbers (ℕ), integers (ℤ), rational numbers (ℚ), real numbers (ℝ), and
    complex numbers (ℂ). These are infinite sets of numbers. Operations differ between
    these sets and may even not be defined. For example, the usual division of two
    numbers in ℤ might not result in an integer — it is not defined on ℤ.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，你将不得不处理数字，因此我们首先考虑 Python 中不同的数字类型形式。在数学中，我们区分自然数（ℕ）、整数（ℤ）、有理数（ℚ）、实数（ℝ）和复数（ℂ）。这些是无限集合。不同集合之间的运算有所不同，有时甚至没有定义。例如，通常在
    ℤ 中进行除法操作可能不会得到一个整数——在 ℤ 中没有定义。
- en: 'In Python, like many other computer languages, we have numeric types:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，像许多其他计算机语言一样，我们有数字类型：
- en: The numeric type, `int`, which is at least theoretically the entire ℤ
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字类型`int`，它至少在理论上是整个 ℤ
- en: The numeric type, `float`, which is a finite subset of ℝ
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字类型`float`，它是 ℝ 的一个有限子集
- en: The numeric type, `complex`, which is a finite subset of ℂ
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字类型`complex`，这是 ℂ 的一个有限子集
- en: Finite sets have a smallest and a largest number and there is a minimum spacing
    between two numbers; see [Section 2.2.2](879c0554-386f-4bb1-8fa8-b86c43927545.xhtml), *Floating-point
    numbers*, for further details.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 有限集合有最小值和最大值，并且两个数字之间有最小间隔；有关更多细节，请参见[第2.2.2节](879c0554-386f-4bb1-8fa8-b86c43927545.xhtml)，*浮点数*。
- en: 2.2.1 Integers
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.2.1 整数
- en: The simplest numeric type is the integer type `int`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的数字类型是整数类型`int`。
- en: Plain integers
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 整数
- en: The statement `k = 3` assigns the variable `k` to an integer.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 语句`k = 3`将变量`k`赋值为一个整数。
- en: 'Applying an operation such as `+`, `-`, or `*` to integers returns an integer.
    The division operator, `//`, returns an integer, while `/` returns a `float`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 对整数应用`+`、`-`或`*`等运算符会返回一个整数。除法运算符`//`返回一个整数，而`/`返回一个`float`：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The set of integers in Python is unbounded; there is no largest integer. The
    limitation here is the computer's memory rather than any fixed value given by
    the language.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Python 中的整数集合是无限的；没有最大的整数。这里的限制是计算机的内存，而不是语言给出的固定值。
- en: If the division operator (`/`) in the preceding example returns 3, you have
    not installed the correct Python version.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在前面的示例中，除法运算符（`/`）返回3，则说明你没有安装正确的Python版本。
- en: 2.2.2 Floating-point numbers
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.2.2 浮动点数
- en: If you execute the statement `a = 3.0` in Python, you create a floating-point
    number (Python type: `float`). These numbers form a finite subset of rational numbers,
    ℚ.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在Python中执行语句`a = 3.0`，你创建了一个浮动点数（Python类型：`float`）。这些数字形成有理数的有限子集，ℚ。
- en: Alternatively, the constant could have been given in exponent notation as `a
    = 30.0e-1` or simply `a = 30.e-1`. The symbol `e` separates the exponent from
    the mantissa, and the expression reads in mathematical notation as ![](img/34c6a326-b6a8-4985-af30-2f6a912355f8.png).
    The name *floating-point number* refers to the internal representation of these
    numbers and reflects the floating position of the decimal point when considering
    numbers over a wide range.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，常量也可以用指数表示法给出，如 `a = 30.0e-1` 或简写为 `a = 30.e-1`。符号 `e` 将指数与尾数分开，该表达式在数学表示中读作
    ![](img/34c6a326-b6a8-4985-af30-2f6a912355f8.png)。*浮动点数* 这个名称指的是这些数字的内部表示，并反映了在考虑广泛范围内的数字时，小数点的浮动位置。
- en: Applying elementary mathematical operations, such as `+`, `-`, `*`, and `/`, to
    two floating-point numbers, or to an integer and a floating-point number, returns
    a floating-point number.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 对两个浮动点数，或一个整数与一个浮动点数应用基本的数学运算，如 `+`、`-`、`*` 和 `/`，将返回一个浮动点数。
- en: 'Operations between floating-point numbers rarely return the exact result expected
    from rational number operations:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 浮动点数之间的运算很少会返回与有理数运算中预期的精确结果：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This fact matters when comparing floating-point numbers:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这个事实在比较浮动点数时非常重要：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The reason for this becomes apparent when looking at the internal representation
    of floating-point numbers; see also [Section 15.2.6](e921daa2-c37c-4799-a8b8-669dc9ae4d17.xhtml),
    *Float comparisons*.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这背后的原因可以通过查看浮动点数的内部表示来显现；另请参见[第15.2.6节](e921daa2-c37c-4799-a8b8-669dc9ae4d17.xhtml)，*浮动点比较*。
- en: Floating-point representation
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 浮动点表示
- en: 'A floating-point number is represented by three quantities: the sign, the mantissa,
    and the exponent:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一个浮动点数由三个量表示：符号、尾数和指数：
- en: '![](img/615d5ecf-4f95-44a3-9c98-e91300ce69f1.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/615d5ecf-4f95-44a3-9c98-e91300ce69f1.png)'
- en: with* [![](img/b7b5b7b3-cd43-4acd-b154-f87023b187c9.png)]* and *[![](img/80605848-6ca8-447f-a52f-05ec9704073e.png)].*
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 其中* [![](img/b7b5b7b3-cd43-4acd-b154-f87023b187c9.png)]* 和 *[![](img/80605848-6ca8-447f-a52f-05ec9704073e.png)]*。
- en: '[*![](img/d356713b-dec1-479a-aebe-e9fd8582010c.png)*]is called the mantissa, [![](img/13125744-0665-46f3-a841-e66b76d162af.png)]
    the basis, and *e* the exponent, with [![](img/773505d0-7d4e-4df5-9bb4-dc90034fd4e8.png)]. ![](img/f6b98d33-ab3e-45ae-8896-4ebd7f803c80.png)
    is called the mantissa length. The condition [![](img/731b9c41-d370-4233-988a-6c2aa92c5bd2.png)]
    makes the representation unique and saves, in the binary case ([![](img/09b99dd9-1794-403f-89a4-364e14b6a5ad.png)]),
    one bit.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '[*![](img/d356713b-dec1-479a-aebe-e9fd8582010c.png)*]被称为尾数，[![](img/13125744-0665-46f3-a841-e66b76d162af.png)]是基数，*e*
    是指数，且[![](img/773505d0-7d4e-4df5-9bb4-dc90034fd4e8.png)]。![](img/f6b98d33-ab3e-45ae-8896-4ebd7f803c80.png)被称为尾数长度。条件[![](img/731b9c41-d370-4233-988a-6c2aa92c5bd2.png)]使得表示是唯一的，并在二进制情况下（[![](img/09b99dd9-1794-403f-89a4-364e14b6a5ad.png)]）节省了一个位。'
- en: Two-floating point zeros, [![](img/85d74507-c505-4b2d-bf9a-de895f79474d.png)]
    and [![](img/eea53272-b084-44c3-94b5-d13b7f26f9b2.png)], exist, both represented
    by the mantissa ![](img/b5ce2310-aa24-4ac9-93e8-55ebb4e05709.png).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 存在两个浮动点零，[![](img/85d74507-c505-4b2d-bf9a-de895f79474d.png)] 和 [![](img/eea53272-b084-44c3-94b5-d13b7f26f9b2.png)]，它们都由尾数
    ![](img/b5ce2310-aa24-4ac9-93e8-55ebb4e05709.png) 表示。
- en: On a typical Intel processor, [![](img/3ab8b74c-2a9e-4dc3-a6d3-9acdc1485486.png)].
    To represent a number in the `float` type, 64 bits are used, namely, 1 bit for
    the sign, ![](img/5d26973f-5573-4563-879e-1274e2f8d403.png) bits for the mantissa,
    and ![](img/ed7fbf30-ec56-4388-a342-d80506b81d79.png) bits for the exponent ![](img/766ba752-823f-4c34-b7de-73e7492d0707.png).
    The upper bound ![](img/b5e73e68-6101-4590-bb39-5a99dab93cea.png) for the exponent
    is consequently [![](img/545a2d24-00a4-48cc-80b9-a4d6ab49e17e.png)].
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型的英特尔处理器上，[![](img/3ab8b74c-2a9e-4dc3-a6d3-9acdc1485486.png)]。为了表示一个`float`类型的数字，使用64位，即1位用于符号，![](img/5d26973f-5573-4563-879e-1274e2f8d403.png)位用于尾数，![](img/ed7fbf30-ec56-4388-a342-d80506b81d79.png)位用于指数![](img/766ba752-823f-4c34-b7de-73e7492d0707.png)。因此，指数的上限![](img/b5e73e68-6101-4590-bb39-5a99dab93cea.png)是[![](img/545a2d24-00a4-48cc-80b9-a4d6ab49e17e.png)]。
- en: With this data, the smallest positive representable number is
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此数据，最小的可表示正数是
- en: '[^(![](img/59b1fc2c-de2a-4d2c-b2f4-8d5abbe63ecd.png))], and the largest [^(![](img/e21bd240-907b-4ee6-a79d-104715619589.png))]*.*'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '[^(![](img/59b1fc2c-de2a-4d2c-b2f4-8d5abbe63ecd.png))]，并且最大的 [^(![](img/e21bd240-907b-4ee6-a79d-104715619589.png))]*.*'
- en: 'Note that floating-point numbers are not equally spaced in ![](img/ca6cbce7-a4ce-46d0-99bb-dca5f1794c47.png).
    There is, in particular, a gap at zero (see also [29]). The distance between ![](img/3eb1eae7-94e1-480b-841a-2fed7ac10df9.png)
    and the first positive number is *![](img/67eab6d8-e466-4605-ba04-a14143e434da.png),* while
    the distance between the first and the second is smaller by a factor ![](img/8473ff72-9b9e-487c-879a-2dbe99db75fb.png). This
    effect, caused by the normalization *![](img/a9bba62c-f778-4468-ac75-a5daa0022e28.png)*,
    is visualized in *Figure 2.1*:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，浮点数在 ![](img/ca6cbce7-a4ce-46d0-99bb-dca5f1794c47.png) 中并非等间隔分布。特别地，零附近有一个间隙（另见
    [29]）。在 ![](img/3eb1eae7-94e1-480b-841a-2fed7ac10df9.png) 和第一个正数之间的距离是 *![](img/67eab6d8-e466-4605-ba04-a14143e434da.png)*，而第一个和第二个之间的距离则较小，缩小了一个因子
    ![](img/8473ff72-9b9e-487c-879a-2dbe99db75fb.png)。这种由标准化 *![](img/a9bba62c-f778-4468-ac75-a5daa0022e28.png)*
    引起的效应在 *图 2.1* 中得到了可视化：
- en: '![](img/f2749a48-1a66-4f9b-89c6-a75d5338a8f1.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f2749a48-1a66-4f9b-89c6-a75d5338a8f1.png)'
- en: 'Figure 2.1: The floating-point gap at zero. Here ![](img/d13b67f1-5714-4ab2-9464-57890ea60892.png)'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1：零处的浮点间隙。这里是 ![](img/d13b67f1-5714-4ab2-9464-57890ea60892.png)
- en: This gap is filled equidistantly with *subnormal* floating-point numbers to
    which such a result is rounded. Subnormal floating-point numbers have the smallest
    possible exponent and do not follow the normalization convention, *![](img/a9bba62c-f778-4468-ac75-a5daa0022e28.png)*.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这个间隙被等距填充，使用的是 *非规范化* 浮点数，并将此类结果四舍五入为这些数。非规范化浮点数具有最小的指数，并且不遵循标准化惯例 *![](img/a9bba62c-f778-4468-ac75-a5daa0022e28.png)*。
- en: Infinite and not a number
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 无限和非数字
- en: There are, in total, ![](img/de248920-9ba1-48a4-9ff0-67d55e999013.png) floating-point
    numbers. Sometimes, a numerical algorithm computes floating-point numbers outside
    this range.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 总共有 ![](img/de248920-9ba1-48a4-9ff0-67d55e999013.png) 个浮点数。有时，数值算法计算的浮点数超出了这个范围。
- en: 'This generates number overflow or underflow. In NumPy, the special floating-point
    number `inf` is assigned to overflow results:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这会导致数字溢出或下溢。在 NumPy 中，溢出结果会被赋值为特殊的浮点数 `inf`：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Working with `inf` may lead to mathematically undefined results. This is indicated in Python
    by assigning the result another special floating-point number, `nan`. This stands
    for *not-a-number*, that is, an undefined result of a mathematical operation.
    To demonstrate this, we continue the previous example:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `inf` 可能会导致数学上未定义的结果。Python 会通过将结果赋值给另一个特殊的浮点数 `nan` 来表示这一点。`nan` 代表 *非数字*，即数学运算的未定义结果。为证明这一点，我们继续前面的例子：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'There are special rules for operations with `nan` and `inf`. For instance, `nan` compared
    to anything (even to itself) always returns `False`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 对于与 `nan` 和 `inf` 的操作，有一些特殊规则。例如，`nan` 与任何数（甚至是它自己）比较时，总是返回 `False`：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: See *Exercise 4* for some surprising consequences of the fact that `nan` is never
    equal to itself.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 请参见 *练习 4*，它展示了 `nan` 永远不等于它自身的某些令人惊讶的后果。
- en: 'The float `inf` behaves much more as expected:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点数 `inf` 的行为更符合预期：
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: One way to check for `nan` and `inf` is to use the functions `isnan` and `isinf`.
    Often, you want to react directly when a variable gets the value `nan` or `inf`.
    This can be achieved by using the NumPy command `seterr`. The following command
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 检查 `nan` 和 `inf` 的一种方法是使用 `isnan` 和 `isinf` 函数。通常，当变量的值为 `nan` 或 `inf` 时，您希望直接作出反应。可以通过使用
    NumPy 命令 `seterr` 来实现这一点。以下命令
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: would raise a `FloatingPointError` if a calculation were to return one of those
    values.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个计算返回其中的某个值，则会引发 `FloatingPointError` 错误。
- en: Underflow – Machine epsilon
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 下溢 - 机器精度
- en: Underflow occurs when an operation results in a rational number that falls into
    the gap at zero; see *Figure 2.1*.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 下溢发生在操作结果是一个落入零附近间隙的有理数时；见 *图 2.1*。
- en: The *machine epsilon*, or rounding unit, is the largest number ![](img/6d100c01-69a0-4326-a8ed-b2b7ecbb38ef.png)
    such that ![](img/47f7d0b1-c2dd-4fa9-8bff-145c7015cb61.png).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*机器精度*，或称舍入单位，是使得 ![](img/6d100c01-69a0-4326-a8ed-b2b7ecbb38ef.png) 的最大数字，这样
    ![](img/47f7d0b1-c2dd-4fa9-8bff-145c7015cb61.png)。'
- en: 'Note that ![](img/a7c0bf81-47d4-4b9e-ac42-dd4d5f4dab79.png) on most of today''s computers.
    The value that applies on the actual machine you are running your code on is accessible
    using the following command:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，![](img/a7c0bf81-47d4-4b9e-ac42-dd4d5f4dab79.png) 在当今大多数计算机上是这样的。您当前运行代码的机器上适用的值可以使用以下命令访问：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The variable `sys.float_info` contains more information on the internal representation
    of the float type on your machine.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 变量`sys.float_info`包含关于浮动点类型在你机器上内部表示的更多信息。
- en: 'The function `float` converts other types to a floating-point number, if possible.
    This function is especially useful when converting an appropriate string to a
    number:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`float`将其他类型转换为浮动点数（如果可能）。这个函数在将适当的字符串转换为数字时特别有用：
- en: '[PRE14]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Other float types in NumPy
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: NumPy中的其他浮动点类型：
- en: 'NumPy also provides other float types, known from other programming languages
    as double-precision and single-precision numbers, namely, `float64` and `float32`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy还提供了其他浮动点类型，这些类型在其他编程语言中被称为双精度和单精度数字，分别是`float64`和`float32`：
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The second last line demonstrates that `a` and `a1` do not differ in accuracy. A
    difference in accuracy exists between `a` and its single-precision counterpart, `a2`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 倒数第二行演示了`a`和`a1`在精度上没有差别。`a`与它的单精度对应物`a2`之间存在精度差异。
- en: 'The NumPy function `finfo` can be used to display information on these floating-point
    types:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy函数`finfo`可以用来显示这些浮动点类型的信息：
- en: '[PRE16]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 2.2.3 Complex numbers
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.2.3 复数：
- en: Complex numbers are an extension of the real numbers frequently used in many
    scientific and engineering fields.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 复数是实数的扩展，广泛应用于许多科学和工程领域。
- en: Complex numbers in mathematics
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数学中的复数：
- en: Complex numbers consist of two floating-point numbers, the real part, ![](img/083c68b7-6261-47c5-ba34-1159100bf27c.png),
    of the number, and its imaginary part, ![](img/fb28559a-4054-4030-83de-a51af952b28f.png). In mathematics,
    a complex number is written as ![](img/f0d38862-1d90-4fbb-866c-6452f22f82fb.png),
    where ![](img/76735070-c450-4546-9eb6-5ec65378509d.png) defined by ![](img/7dfea4b2-f817-4a4d-8cd5-df416093471f.png)
    is the *imaginary unit*. The conjugate complex counterpart of ![](img/9a4dbac2-6452-4e15-8c32-e4dfbf9f777f.png)
    is ![](img/f3c4e8c1-1e17-44c0-8d58-e939be4cdc44.png).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 复数由两个浮动点数组成，一个是该数的实部 ![](img/083c68b7-6261-47c5-ba34-1159100bf27c.png)，另一个是它的虚部 ![](img/fb28559a-4054-4030-83de-a51af952b28f.png)。在数学中，复数写作 ![](img/f0d38862-1d90-4fbb-866c-6452f22f82fb.png)，其中 ![](img/76735070-c450-4546-9eb6-5ec65378509d.png)由 ![](img/7dfea4b2-f817-4a4d-8cd5-df416093471f.png)定义，称为*虚数单位*。共轭复数对 ![](img/9a4dbac2-6452-4e15-8c32-e4dfbf9f777f.png)是 ![](img/f3c4e8c1-1e17-44c0-8d58-e939be4cdc44.png)。
- en: If the real part ![](img/226b452e-93e2-4f55-95b9-a56845d21fc0.png) is zero,
    the number is called an imaginary number.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果实部 ![](img/226b452e-93e2-4f55-95b9-a56845d21fc0.png)为零，则该数字称为虚数。
- en: The j notation
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: j表示法：
- en: In Python, imaginary numbers are characterized by suffixing a floating-point
    number with the letter `j`, for example, `z = 5.2j`. A complex number is formed
    by the sum of a real number and an imaginary number, for example, `z = 3.5 + 5.2j`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，虚数通过在浮动点数后添加字母`j`来表示，例如，`z = 5.2j`。复数是由一个实数和一个虚数组成的，例如，`z = 3.5 + 5.2j`。
- en: While in mathematics the imaginary part is expressed as a product of a real
    number *b* with the imaginary unit ![](img/6c2f614f-c3d2-4a4b-873e-7afdc5a20e1c.png),
    the Python way of expressing an imaginary number is not a product: `j` is just
    a suffix to indicate that the number is imaginary.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在数学中，虚部表示为实数*b*与虚数单位 ![](img/6c2f614f-c3d2-4a4b-873e-7afdc5a20e1c.png)的乘积，但在Python中表示虚数并不是一个乘积：`j`只是一个后缀，用来表示该数是虚数。
- en: 'This is demonstrated by the following small experiment:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这通过以下小实验展示：
- en: '[PRE17]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The method `conjugate` returns the conjugate of `z`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 方法`conjugate`返回`z`的共轭：
- en: '[PRE18]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Real and imaginary parts
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实部和虚部：
- en: 'You may access the real and imaginary parts of a complex number ![](img/66674c49-3c36-41a0-835b-5a9128c904cb.png) using
    the `real` and `imag` attributes. Those attributes are read-only; in other words,
    they cannot be changed:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`real`和`imag`属性访问复数 ![](img/66674c49-3c36-41a0-835b-5a9128c904cb.png)的实部和虚部。这些属性是只读的；换句话说，它们不能被改变：
- en: '[PRE19]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'It is not possible to convert a complex number to a real number:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 不可能将复数转换为实数：
- en: '[PRE20]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Interestingly, the `real` and `imag` attributes as well as the conjugate method
    work just as well for complex arrays; see also [Section 4.3.1](e60692b7-f6d2-42df-a59f-bfaf357ea932.xhtml),
    *Array properties*. We demonstrate this by computing the *N*^(th) roots of unity,
    which are [![](img/aebd247a-5841-41fe-beb9-7e8703b90bdf.png)], that is, the ![](img/a2c3cdd6-df4f-4a77-914c-d73959af422d.png)
    solutions of the equation ![](img/58eb7ad5-3e96-4cc9-a2b5-b94a5d1f70d6.png):'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，`real`和`imag`属性以及共轭方法对复数数组同样适用；参见[第4.3.1节](e60692b7-f6d2-42df-a59f-bfaf357ea932.xhtml)，*数组属性*。我们通过计算*第N次*单位根来展示这一点，这些单位根是[![](img/aebd247a-5841-41fe-beb9-7e8703b90bdf.png)]，即方程![](img/58eb7ad5-3e96-4cc9-a2b5-b94a5d1f70d6.png)的![](img/a2c3cdd6-df4f-4a77-914c-d73959af422d.png)解：
- en: '[PRE21]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The resulting figure shows the 10 roots of unity. In *Figure 2.2,* it is completed
    by a title and axes labels and shown together with the unit circle. (For more
    details on how to make plots, see [Chapter 6](35749482-dbc7-41b2-aa19-dc63b242f18f.xhtml): *Plotting.*)
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 结果图显示了10个单位根。在*图2.2*中，它通过标题和坐标轴标签进行补充，并与单位圆一起显示。（有关如何绘制图表的更多细节，请参见[第6章](35749482-dbc7-41b2-aa19-dc63b242f18f.xhtml)：*绘图*。）
- en: '![](img/51d4e879-057e-4c49-a384-5d5fa6a0047f.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/51d4e879-057e-4c49-a384-5d5fa6a0047f.png)'
- en: 'Figure 2.2: Roots of unity together with the unit circle'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2：单位根与单位圆
- en: 'It is, of course, possible to mix the previous methods, as illustrated by the
    following examples:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，也可以混合使用前述方法，如以下示例所示：
- en: '[PRE22]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 2.3 Booleans
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.3 布尔值
- en: 'Boolean is a data type named after *George Boole* (1815-1864). A Boolean variable
    can take only two values, `True` or `False`. The main use of this type is in logical
    expressions. Here are some examples:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔值是一种数据类型，得名于*乔治·布尔*（1815-1864）。布尔变量只能取两个值，`True`或`False`。这种类型的主要用途是在逻辑表达式中。以下是一些示例：
- en: '[PRE23]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Boolean expressions are often used in conjunction with `if` statements:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔表达式常常与`if`语句结合使用：
- en: '[PRE24]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 2.3.1 Boolean operators
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.3.1 布尔运算符
- en: 'Boolean operations are performed using the keywords `and`, `or`, and `not`:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔操作通过关键字`and`、`or`和`not`来执行：
- en: '[PRE25]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The operators follow some precedence rules (see also [Section 1.3.5](cbb0e54a-9e37-4356-8553-6f051956f80e.xhtml), *Boolean
    expressions*) which would make the parentheses in the third and in the last line
    obsolete. Nevertheless, it is a good practice to use them in any case to increase
    the readability of your code.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 运算符遵循一些优先级规则（参见[第1.3.5节](cbb0e54a-9e37-4356-8553-6f051956f80e.xhtml)，*布尔表达式*），这些规则使得第三行和最后一行的括号变得不必要。然而，无论如何，使用括号是一种良好的实践，可以提高代码的可读性。
- en: 'Note, the `and` operator is implicitly chained in the following Boolean expressions:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`and`运算符在以下布尔表达式中是隐式链式连接的：
- en: '[PRE26]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 2.3.2 Boolean casting
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.3.2 布尔类型转换
- en: Most Python objects may be converted to Booleans; this is called *Boolean casting*.
    The built-in function `bool` performs that conversion. Note that most objects are
    cast to `True`, except `0`, the empty tuple, the empty list, the empty string,
    or the empty array. These are all cast to `False`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数Python对象都可以转换为布尔值；这称为*布尔类型转换*。内置函数`bool`执行这种转换。需要注意的是，大多数对象都会转换为`True`，除了`0`、空元组、空列表、空字符串或空数组，这些都转换为`False`。
- en: '![](img/7af5ff18-ba2e-4707-95be-406c33a9baf7.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7af5ff18-ba2e-4707-95be-406c33a9baf7.png)'
- en: 'Table 2.2: Casting rules for Booleans'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 表2.2：布尔值的类型转换规则
- en: 'It is *not* possible to cast arrays into Booleans unless they contain no or
    only one element; this is explained further in [Section 5.2.1](e60692b7-f6d2-42df-a59f-bfaf357ea932.xhtml), *Boolean
    arrays*. The previous table (see Table 2.2: C*asting rules for Booleans*) contains
    summarized rules for Boolean casting.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 除非数组不含元素或仅包含一个元素，否则*不*可能将数组转换为布尔值；这一点在[第5.2.1节](e60692b7-f6d2-42df-a59f-bfaf357ea932.xhtml)，*布尔数组*中有进一步的解释。前面的表格（参见表2.2：*布尔值类型转换规则*）总结了布尔类型转换的规则。
- en: 'We demonstrate this by means of some usage examples:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过一些使用示例来演示这一点：
- en: '[PRE27]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Automatic Boolean casting
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自动布尔类型转换
- en: 'Using an `if` statement with a non-Boolean type will cast it to a Boolean. In other
    words, the following two statements are always equivalent:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`if`语句时，如果是非布尔类型，将会自动将其转换为布尔值。换句话说，以下两个语句始终是等效的：
- en: '[PRE28]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'A typical example is testing whether a list is empty:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的例子是测试列表是否为空：
- en: '[PRE29]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: An empty list, or tuple, will return `False`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 一个空列表或元组将返回`False`。
- en: 'You can also use a variable in the `if` statement, for example, an integer:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在`if`语句中使用变量，例如一个整数：
- en: '[PRE30]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note that we used `%` for the *modulo operation*, which returns the remainder
    of an integer division. In this case, it returns `0` or `1` as the remainder after
    modulo 2.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们使用了`%`进行*取模运算*，它返回整数除法后的余数。在这种情况下，它返回`0`或`1`作为除以2后的余数。
- en: In this last example, the values `0` or `1` are cast to `bool`; see also [Section
    2.3.4](879c0554-386f-4bb1-8fa8-b86c43927545.xhtml), *Booleans and integers.*
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个最后的例子中，值`0`或`1`会被转换为`bool`；也请参见[第2.3.4节](879c0554-386f-4bb1-8fa8-b86c43927545.xhtml)，*布尔值和整数*。
- en: The Boolean operators `or`, `and`, and `not` will also implicitly convert some
    of their arguments to a Boolean.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔运算符`or`、`and`和`not`也会隐式地将其一些参数转换为布尔值。
- en: 2.3.3 Return values of and and or
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.3.3 `and`和`or`的返回值
- en: 'Note that the operators `and` and `or` do not necessarily produce Boolean values.
    This can be explained by the fact that the expression `*x* and *y*` is equivalent
    to:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，运算符`and`和`or`并不一定会产生布尔值。这可以通过以下等式来解释：`*x* and *y*`等价于：
- en: '[PRE31]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Correspondingly, the expression `x or y` is equivalent to:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 相应地，表达式`x or y`等价于：
- en: '[PRE32]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Interestingly, this means that when executing the statement `True or x`, the
    variable `x` need not even be defined! The same holds for `False and x`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，这意味着当执行语句`True or x`时，变量`x`甚至不需要被定义！`False and x`同样适用。
- en: 'Note that, unlike their counterparts in mathematical logic, these operators
    are no longer commutative in Python. Indeed, the following expressions are not
    equivalent:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，与数学逻辑中的对应运算符不同，这些运算符在Python中不再是交换律的。事实上，以下表达式并不等价：
- en: '[PRE33]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 2.3.4 Booleans and integers
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.3.4 布尔值和整数
- en: 'In fact, Booleans and integers are the same. The only difference is in the
    string representations of `0` and `1`, which, in the case of Booleans, is `False` and `True`, respectively.
    This allows constructions such as this:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，布尔值和整数是相同的。唯一的区别在于`0`和`1`的字符串表示形式，在布尔值中，它们分别是`False`和`True`。这使得可以构造如下：
- en: '[PRE34]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The last line in this example uses string formatting, which is explained in
    [Section 2.4.3](879c0554-386f-4bb1-8fa8-b86c43927545.xhtml), *String formatting.*
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子中的最后一行使用了字符串格式化，具体解释见[第2.4.3节](879c0554-386f-4bb1-8fa8-b86c43927545.xhtml)，*字符串格式化*。
- en: We note for readers already familiar with the concept of subclasses that the
    type `bool` is a subclass of the type `int` (see [Chapter 8](66c25bba-72d2-46a9-929a-1f57fa7a1684.xhtml): *Classes*).
    Indeed, all four inquiries – `isinstance(True, bool)`, `isinstance(False, bool)`, `isinstance(True,
    int)`, and `isinstance(False, int)` return the value `True` (see [Section 3.7](c4f97b8b-36c4-4db4-9e58-02aac275b257.xhtml), *Checking
    the type of a variable*).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们指出，对于已经熟悉子类概念的读者，`bool`类型是`int`类型的子类（请参见[第8章](66c25bba-72d2-46a9-929a-1f57fa7a1684.xhtml)：*类*）。实际上，所有四个查询——`isinstance(True,
    bool)`、`isinstance(False, bool)`、`isinstance(True, int)`和`isinstance(False, int)`都返回值`True`（请参见[第3.7节](c4f97b8b-36c4-4db4-9e58-02aac275b257.xhtml)，*检查变量的类型*）。
- en: Even rarely used statements such as `True+13` are correct.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是像`True+13`这样很少使用的语句也是正确的。
- en: 2.4 Strings
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.4 字符串
- en: 'The type `string` is a type used for text:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`string`类型是用于文本的类型：'
- en: '[PRE35]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: A string is enclosed either by single or double quotes. If a string contains
    several lines, it has to be enclosed by three double quotes `"""` or three single
    quotes `'''`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串可以由单引号或双引号括起来。如果字符串包含多行，则必须用三个双引号`"""`或三个单引号`'''`括起来。
- en: 'Strings can be indexed with simple indexes or slices (see  Chapter 3: *Container
    Types*, for a comprehensive explanation on slices):'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串可以通过简单的索引或切片来索引（请参见第3章：*容器类型*，了解关于切片的详细说明）：
- en: '[PRE36]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Strings are immutable; that is, items cannot be altered. They share this property
    with tuples. The command **`book[1] = ''a''`** returns:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串是不可变的；也就是说，项不能被更改。它们与元组共享这个特性。命令**`book[1] = 'a'`**返回：
- en: '[PRE37]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 2.4.1 Escape sequences and raw strings
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.4.1 转义序列和原始字符串
- en: 'The string `''\n''` is used to insert a line break and `''\t''` inserts a horizontal
    tabulator (TAB) into the string to align several lines:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串`'\n'`用于插入换行符，`'\t'`用于在字符串中插入水平制表符（TAB）以对齐多行：
- en: '[PRE38]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'These strings are examples of *escape sequences*. Escape sequences always start
    with a backslash, `\`. A multiline string automatically includes escape sequences:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这些字符串是*转义序列*的例子。转义序列总是以反斜杠`\`开始。多行字符串会自动包含转义序列：
- en: '[PRE39]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'A special escape sequence is `"\\"`, which represents the backslash symbol in text:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 一个特殊的转义序列是`"\\"`，它表示文本中的反斜杠符号：
- en: '[PRE40]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The same can be achieved by using a *raw string* instead:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的结果可以通过使用*原始字符串*来实现：
- en: '[PRE41]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Note that in raw strings, the backslash remains in the string and is used to
    escape some special characters:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在原始字符串中，反斜杠保持在字符串中并用于转义某些特殊字符：
- en: '[PRE42]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'A raw string is a convenient tool to construct strings in a readable manner.
    The result is the same:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 原始字符串是一种方便的工具，用于以可读的方式构建字符串。结果是相同的：
- en: '[PRE43]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 2.4.2 Operations on strings and string methods
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.4.2 字符串操作和字符串方法
- en: 'The addition of several strings results in their concatenation:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 多个字符串的相加会导致它们的连接：
- en: '[PRE44]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Consequently, multiplication by an integer is repeated addition:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，整数的乘法是重复加法：
- en: '[PRE45]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Multiplication by floating-point or complex numbers is undefined and results
    in a `TypeError`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 对浮点数或复数的乘法未定义，并会导致`TypeError`。
- en: 'When strings are compared, lexicographical order applies and the uppercase
    form precedes the lowercase form of the same letter:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当字符串进行比较时，采用字典顺序，大写形式排在相同字母的小写形式之前：
- en: '[PRE46]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Among the variety of string methods, we will mention here only the most important
    ones:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在众多字符串方法中，我们这里只提及最重要的几种：
- en: '**Splitting a string**: This method generates a list from a string by using
    a single or multiple blanks as separators. Alternatively, an argument can be given
    by specifying a particular substring as a separator:'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分割字符串**：该方法通过使用一个或多个空格作为分隔符生成一个列表。或者，可以通过指定特定的子字符串作为分隔符来传递一个参数：'
- en: '[PRE47]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '**Joining a list to a string**: This is the reverse operation of splitting:'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**将列表连接到字符串**：这是分割操作的反向操作：'
- en: '[PRE48]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '**Searching in a string**: This method returns the first index in the string,
    where a given search substring starts:'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在字符串中搜索**：该方法返回字符串中给定搜索子字符串开始的第一个索引位置：'
- en: '[PRE49]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: If the search string is not found, the return value of the method is `-1`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果搜索字符串未找到，方法的返回值是`-1`。
- en: '**String formatting:** This method inserts values of variables or results of
    expressions into a string. It is so important that we devote the following subsection
    to it.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**字符串格式化**：该方法将变量的值或表达式的结果插入字符串中。它非常重要，以至于我们将以下小节专门讨论它。'
- en: 2.4.3 String formatting
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.4.3 字符串格式化
- en: String formatting is the process of inserting values into a given string and
    determining the way in which they are displayed. This can be done in various ways.
    We first describe the related string method, `format`, and the more modern alternative,
    the so-called *f-string*.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串格式化是将值插入给定字符串并确定其显示方式的过程。这可以通过多种方式实现。我们首先描述相关的字符串方法`format`，以及更现代的替代方法——所谓的*f-string*。
- en: 'Here is an example regarding the use of the format method:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个关于使用format方法的例子：
- en: '[PRE50]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'And here is an example of the variant by using an *f-string*:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是使用*f-string*的变体例子：
- en: '[PRE51]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The function `format` is a string method; it scans the string for the occurrence
    of placeholders, which are enclosed by curly brackets. These placeholders are
    replaced in a way specified by the argument of the format method. How they are
    replaced depends on the format specification defined in each `{}` pair. Format
    specifications are indicated by a colon, `":"`, as their prefix.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`format`函数是一个字符串方法；它扫描字符串以查找占位符，这些占位符由花括号括起来。这些占位符根据`format`方法的参数以指定的方式进行替换。它们如何被替换，取决于每个`{}`对中定义的格式规范。格式规范由冒号`":"`作为前缀表示。'
- en: 'The format method offers a range of possibilities to customize the formatting
    of objects depending on their types. Of particular use in scientific computing
    are the formatting specifiers for the `float` type. You may choose either the
    standard fixed-point notation with `{:f}` or the exponential notation with `{:e}`:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: format方法提供了一系列的可能性，根据对象的类型定制其格式化方式。在科学计算中，`float`类型的格式化说明符尤为重要。你可以选择标准的定点表示法`{:f}`或指数表示法`{:e}`：
- en: '[PRE52]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Similarly, format specifiers can be used also in f-strings:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，格式说明符也可以在f-string中使用：
- en: '[PRE53]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The format specifiers allow specifying the rounding precision (digits following
    the decimal point in the representation). Also, the total number of symbols, including
    leading blanks, to represent the number can be set.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 格式说明符允许指定四舍五入精度（表示中小数点后的位数）。此外，还可以设置表示数字的符号总数，包括前导空格。
- en: 'In this example, the name of the object that gets its value inserted is given
    as an argument to the format method. The first `{}` pair is replaced by the first
    argument, and the following pairs by the subsequent arguments. Alternatively,
    it may also be convenient to use the key-value syntax:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，获取其值的对象名称作为参数传递给`format`方法。第一个`{}`对会被第一个参数替换，后续的`{}`对会被后续的参数替换。或者，使用键值对语法也可能很方便：
- en: '[PRE54]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Here, two values are processed – a string `name` without a format specifier,
    and a float `value` that is printed in fixed-point notation with one digit after
    the decimal point. (Refer to the complete reference documentation for more details
    on *string formatting.)*
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这里处理了两个值——一个没有格式说明符的字符串`name`，和一个浮点数`value`，它以固定点格式打印，保留小数点后一位。（详细内容请参考完整的字符串格式化文档。）
- en: '**Braces in the string**'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '**字符串中的大括号**'
- en: 'Sometimes, a string might contain a pair of curly braces, which should not
    be considered as placeholders for a `format` method. In that case, double braces
    are used:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，一个字符串可能包含一对大括号，但不应被视为`format`方法的占位符。在这种情况下，使用双大括号：
- en: '`r"we {} in LaTeX \begin{{equation}}".format(''like'')`'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`r"we {} in LaTeX \begin{{equation}}".format(''like'')`'
- en: This returns the following string: `'we like in LaTeX \\begin{equation}'`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回以下字符串：`'we like in LaTeX \\begin{equation}'`。
- en: 2.5 Summary
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.5 小结
- en: In this chapter, you met the basic data types in Python and saw the corresponding
    syntax elements. We will work mostly with numeric types such as integers, floats,
    and complex.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你了解了Python中的基本数据类型，并看到了相应的语法元素。我们将主要处理整数、浮点数和复数等数值类型。
- en: Booleans are needed for setting conditions, and by using strings, we often communicate
    results and messages.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔值在设置条件时是必需的，且通过使用字符串，我们常常传达结果和消息。
- en: 2.6 Exercises
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.6 练习
- en: '**Ex. 1:** Check whether ![](img/454aa923-95fe-4033-881c-b68b24473d7c.png)
    is a zero of the function:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '**例 1：** 检查！[](img/454aa923-95fe-4033-881c-b68b24473d7c.png) 是否是该函数的零点：'
- en: '*![](img/f3aee195-caa2-4f76-95d7-0c5fda083725.png)*'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '*![](img/f3aee195-caa2-4f76-95d7-0c5fda083725.png)*'
- en: '**Ex. 2:** According to de Moivre''s formula, the following holds:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '**例 2：** 根据德摩根公式，以下公式成立：'
- en: '![](img/5572ccc3-cd6a-47df-9126-121400fec998.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5572ccc3-cd6a-47df-9126-121400fec998.png)'
- en: Choose numbers *n* and *x* and verify that formula in Python.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 选择数字*n*和*x*并在Python中验证公式。
- en: '**Ex. 3:** Complex numbers. Verify Euler''s formula in the same way:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '**例 3：** 复数。以同样的方式验证欧拉公式：'
- en: '![](img/87cab0d6-37d2-4738-bbe5-b9606f42424d.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87cab0d6-37d2-4738-bbe5-b9606f42424d.png)'
- en: '**Ex. 4:** Suppose we are trying to check the convergence of a diverging sequence
    (here, the sequence is defined by the recursive relation ![](img/5bcda964-c7e2-47e7-8cf9-2bae91d8b1b5.png)
    and ![](img/0b4ceaa6-cea3-485e-aa01-10fc06d8fbee.png)):'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '**例 4：** 假设我们正试图检查一个发散序列的收敛性（这里，序列由递归关系定义：![](img/5bcda964-c7e2-47e7-8cf9-2bae91d8b1b5.png)
    和 ![](img/0b4ceaa6-cea3-485e-aa01-10fc06d8fbee.png)）：'
- en: '[PRE55]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Since the sequence does not converge, the code should print the
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于序列不收敛，代码应打印
- en: '`No convergence` message. Execute it to see what happens.'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`No convergence`消息。执行它来看看会发生什么。'
- en: What happens if you replace the line
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你替换掉这一行会发生什么？
- en: '[PRE56]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: with
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 使用
- en: '[PRE57]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: It should give exactly the same result, shouldn't it? Run the code again to
    see what happens.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 它应该给出完全相同的结果，不是吗？再次运行代码查看会发生什么。
- en: What happens if you replace `u=1.0` with `u=1` (without a decimal point)? Run
    the code to check your predictions.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你将`u=1.0`替换为`u=1`（没有小数点），会发生什么？运行代码来验证你的预测。
- en: Explain the unexpected behavior of this code.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解释这个代码的意外行为。
- en: '**Ex. 5:** An implication *C = (A ⇒ B)* is a Boolean expression that is defined
    as'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '**例 5：** 一个蕴含式 *C = (A ⇒ B)* 是一个布尔表达式，定义如下：'
- en: '*C* is `True` if *A* is `False`, or *A* and *B* are both `True`'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*C*当*A*为`False`或*A*和*B*都为`True`时是`True`'
- en: '*C* is `False` otherwise'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*C*在其他情况下是`False`'
- en: Write a Python function `implication(A, B)`.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个Python函数`implication(A, B)`。
- en: '**Ex. 6:** This exercise is to train Boolean operations. Two binary digits
    (bits) are added by using a logical device called a **half adder**. It produces
    a carry bit (the digit of the next higher value) and the sum as defined by the
    following table, and half adder circuit:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '**例 6：** 这个练习是用来训练布尔运算的。两个二进制数字（位）通过一个称为**半加器**的逻辑装置相加。它生成一个进位位（下一个更高位的数字）和根据下表定义的和，半加器电路：'
- en: '| **p** | **q** | **sum** | **carry** |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| **p** | **q** | **sum** | **carry** |'
- en: '| 1 | 1 | 0 | 1 |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 0 | 1 |'
- en: '| 1 | 0 | 1 | 0 |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 | 1 | 0 |'
- en: '| 0 | 1 | 1 | 0 |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 | 1 | 0 |'
- en: '| 0 | 0 | 0 | 0 |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 0 | 0 |'
- en: 'Definition of the half adder operation:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 半加器操作的定义：
- en: '![](img/c8bef38d-13a1-4935-bb44-83b698931dd6.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c8bef38d-13a1-4935-bb44-83b698931dd6.png)'
- en: 'Figure 2.3: A half adder circuit'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.3：半加法器电路
- en: 'A full adder consists of two half adders and sums two bits and an additional
    carry bit on the input (see also the following figure):'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 全加法器由两个半加法器组成，它可以对两个二进制位和一个额外的进位位进行求和（另请参见下图）：
- en: '![](img/52dc0ff0-c354-46a9-ab57-9278142e62f7.png)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![](img/52dc0ff0-c354-46a9-ab57-9278142e62f7.png)'
- en: 'Figure 2.4: A full adder circuit'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.4：全加法器电路
- en: Write a function that implements a half adder and another that implements a
    full adder. Test these functions.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个实现半加法器的函数，并编写另一个实现全加法器的函数。测试这些函数。
