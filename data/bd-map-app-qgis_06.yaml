- en: Chapter 6. Mastering the QGIS Python API
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章. 掌握QGIS Python API
- en: 'In this chapter, we will look at a number of more advanced aspects of the PyQGIS
    library, as well as various techniques for working with QGIS using Python. In
    particular, we will learn:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨PyQGIS库的许多更高级的方面，以及使用Python操作QGIS的各种技术。特别是，我们将学习：
- en: How to work with symbol layers
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何与符号层一起工作
- en: More advanced ways of using symbols to draw vector data onto a map
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用符号在地图上绘制矢量数据的高级方法
- en: How to implement your own symbols and renderers in Python
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在Python中实现自己的符号和渲染器
- en: How to create a custom map layer using Python
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用Python创建自定义地图层
- en: How to implement your own custom map canvas items
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何实现自己的自定义地图画布项
- en: How to use memory data providers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用内存数据提供者
- en: Working with symbol layers
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用符号层进行工作
- en: 'In the previous chapters, we created symbols to display vector features by
    instantiating one of the three basic subclasses of `QgsSymbolV2`:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们通过实例化`QgsSymbolV2`的三个基本子类之一来创建符号以显示矢量要素：
- en: '`QgsMarkerSymbolV2` for point geometries'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QgsMarkerSymbolV2`用于点几何形状'
- en: '`QgsLineSymbolV2` for line geometries'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QgsLineSymbolV2`用于线几何形状'
- en: '`QgsFillSymbolV2` for polygon geometries'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QgsFillSymbolV2`用于多边形几何形状'
- en: We did this either by calling one of the preceding class's static `createSimple()`
    methods, or by asking the `QgsSymbolV2` class to provide us with the default symbol
    for a given type of geometry. Irrespective of how we did it, the result was a
    ready-to-use symbol object that displays a given type of vector geometry.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这样做是通过调用前面类的一个静态`createSimple()`方法，或者通过请求`QgsSymbolV2`类为我们提供一个给定几何类型的默认符号。无论我们如何操作，结果都是一个现成的符号对象，用于显示给定的矢量几何类型。
- en: 'Internally, symbols consist of one or more symbol layers that are displayed
    one on top of the other, to draw the vector feature:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 内部，符号由一个或多个符号层组成，这些层一个接一个地显示，以绘制矢量要素：
- en: '![Working with symbol layers](img/00056.jpeg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![使用符号层](img/00056.jpeg)'
- en: Note
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The symbol layers are drawn in the order in which they are added to the symbol.
    So, in this example, **Symbol Layer 1** will be drawn *before* **Symbol Layer
    2**. This has the effect of drawing the second symbol layer on top of the first.
    Make sure you get the order of your symbol layers correct, or you might find a
    symbol layer completely obscured by another layer.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 符号层按它们添加到符号中的顺序绘制。因此，在这个例子中，**符号层1**将在**符号层2**之前绘制。这会导致第二个符号层在第一个符号层之上绘制。确保你正确地排列了符号层的顺序，否则你可能会发现符号层被另一个层完全遮挡。
- en: While the symbols we have been working with so far have had only one layer,
    there are some clever tricks you can perform with multilayer symbols. We will
    look at multilayer symbols in the section *Combining symbol layers*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们迄今为止所使用的符号只有一个层，但你可以使用多层符号执行一些巧妙的技巧。我们将在*组合符号层*这一节中查看多层符号。
- en: When you create a symbol, it will automatically be initialized with a default
    symbol layer. For example, a line symbol (an instance of `QgsLineSymbolV2`) will
    be created with a single layer of type `QgsSimpleLineSymbolLayerV2`. This layer
    is used to draw the line feature onto the map.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个符号时，它将自动使用默认的符号层进行初始化。例如，一个线符号（`QgsLineSymbolV2`的一个实例）将创建一个单层的`QgsSimpleLineSymbolLayerV2`类型。这个层用于在地图上绘制线要素。
- en: 'To work with symbol layers, you need to remove this default layer and replace
    it with your own symbol layer or layers. For example:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用符号层，你需要移除这个默认层，并用你自己的符号层或多个符号层替换它。例如：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The following methods can be used to manipulate the layers within a symbol:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下方法来操作符号内的层：
- en: '`symbol.symbolLayerCount()`: This returns the number of symbol layers within
    this symbol.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`symbol.symbolLayerCount()`: 这将返回此符号中符号层的数量。'
- en: '`symbol.symbolLayer(index)`: This returns the given symbol layer within the
    symbol. Note that the first symbol layer has an index of zero.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`symbol.symbolLayer(index)`: 这将返回符号中的给定符号层。请注意，第一个符号层的索引为零。'
- en: '`symbol.changeSymbolLayer(index, symbol_layer)`: This replaces a given symbol
    layer within the symbol.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`symbol.changeSymbolLayer(index, symbol_layer)`: 这将替换符号中的指定符号层。'
- en: '`symbol.appendSymbolLayer(symbol_layer)`: This appends a new symbol layer to
    the symbol.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`symbol.appendSymbolLayer(symbol_layer)`: 这将在符号中追加一个新的符号层。'
- en: '`symbol.insertSymbolLayer(index, symbol_layer)`: This inserts a symbol layer
    at a given index.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`symbol.insertSymbolLayer(index, symbol_layer)`: 这将在指定的索引处插入一个符号层。'
- en: '`symbol.deleteSymbolLayer(index)`: This removes the symbol layer at the given
    index.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`symbol.deleteSymbolLayer(index)`: 这将移除给定索引处的符号层。'
- en: Note
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Remember that to use the symbol once you''ve created it, you create an appropriate
    renderer and then assign that renderer to your map layer. For example:'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 记住，一旦创建符号，你需要创建一个适当的渲染器，然后将该渲染器分配给你的地图层。例如：
- en: '[PRE1]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The following symbol layer classes are available for you to use:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 以下符号层类可供您使用：
- en: '| PyQGIS class | Description | Example |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| PyQGIS类 | 描述 | 示例 |'
- en: '| --- | --- | --- |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `QgsSimpleMarkerSymbolLayerV2` | This displays a point geometry as a small
    colored circle. | ![Working with symbol layers](img/00057.jpeg) |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `QgsSimpleMarkerSymbolLayerV2` | 这将点几何形状显示为一个小彩色的圆圈。 | ![使用符号层](img/00057.jpeg)
    |'
- en: '| `QgsEllipseSymbolLayerV2` | This displays a point geometry as an ellipse.
    | ![Working with symbol layers](img/00058.jpeg) |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `QgsEllipseSymbolLayerV2` | 这将点几何形状显示为椭圆。 | ![使用符号层](img/00058.jpeg) |'
- en: '| `QgsFontMarkerSymbolLayerV2` | This displays a point geometry as a single
    character. You can choose the font and character to be displayed. | ![Working
    with symbol layers](img/00059.jpeg) |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `QgsFontMarkerSymbolLayerV2` | 这将点几何形状显示为单个字符。你可以选择要显示的字体和字符。 | ![使用符号层](img/00059.jpeg)
    |'
- en: '| `QgsSvgMarkerSymbolLayerV2` | This displays a point geometry using a single
    SVG format image. | ![Working with symbol layers](img/00060.jpeg) |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `QgsSvgMarkerSymbolLayerV2` | 这使用单个SVG格式图像显示点几何形状。 | ![使用符号层](img/00060.jpeg)
    |'
- en: '| `QgsVectorFieldSymbolLayer` | This displays a point geometry by drawing a
    **displacement line**. One end of the line is the coordinate of the point, while
    the other end is calculated using attributes of the feature. | ![Working with
    symbol layers](img/00061.jpeg) |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| `QgsVectorFieldSymbolLayer` | 这通过绘制**位移线**来显示点几何形状。线的一端是点的坐标，而另一端使用特征的属性计算得出。
    | ![使用符号层](img/00061.jpeg) |'
- en: '| `QgsSimpleLineSymbolLayerV2` | This displays a line geometry or the outline
    of a polygon geometry using a line of a given color, width, and style. | ![Working
    with symbol layers](img/00062.jpeg) |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `QgsSimpleLineSymbolLayerV2` | 这使用给定颜色、宽度和样式的线条显示线几何形状或多边形几何形状的轮廓。 | ![使用符号层](img/00062.jpeg)
    |'
- en: '| `QgsMarkerLineSymbolLayerV2` | This displays a line geometry or the outline
    of a polygon geometry by repeatedly drawing a marker symbol along the length of
    the line. | ![Working with symbol layers](img/00063.jpeg) |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| `QgsMarkerLineSymbolLayerV2` | 这通过沿线的长度重复绘制标记符号来显示线几何形状或多边形几何形状的轮廓。 | ![使用符号层](img/00063.jpeg)
    |'
- en: '| `QgsSimpleFillSymbolLayerV2` | This displays a polygon geometry by filling
    the interior with a given solid color and then drawing a line around the perimeter.
    | ![Working with symbol layers](img/00064.jpeg) |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `QgsSimpleFillSymbolLayerV2` | 这通过填充给定实心颜色并在周围绘制线条来显示多边形几何形状。 | ![使用符号层](img/00064.jpeg)
    |'
- en: '| `QgsGradientFillSymbolLayerV2` | This fills the interior of a polygon geometry
    using a color or grayscale gradient. | ![Working with symbol layers](img/00065.jpeg)
    |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| `QgsGradientFillSymbolLayerV2` | 这使用颜色或灰度渐变填充多边形几何形状的内部。 | ![使用符号层](img/00065.jpeg)
    |'
- en: '| `QgsCentroidFillSymbolLayerV2` | This draws a simple dot at the centroid
    of a polygon geometry. | ![Working with symbol layers](img/00066.jpeg) |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| `QgsCentroidFillSymbolLayerV2` | 这将在多边形几何形状的质心处绘制一个简单的点。 | ![使用符号层](img/00066.jpeg)
    |'
- en: '| `QgsLinePatternFillSymbolLayer` | This draws the interior of a polygon geometry
    using a repeated line. You can choose the angle, width, and color to use for the
    line. | ![Working with symbol layers](img/00067.jpeg) |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `QgsLinePatternFillSymbolLayer` | 这使用重复的线绘制多边形几何形状的内部。你可以选择用于线的角度、宽度和颜色。
    | ![使用符号层](img/00067.jpeg) |'
- en: '| `QgsPointPatternFillSymbolLayer` | This draws the interior of a polygon geometry
    using a repeated point. | ![Working with symbol layers](img/00068.jpeg) |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `QgsPointPatternFillSymbolLayer` | 这使用重复的点绘制多边形几何形状的内部。 | ![使用符号层](img/00068.jpeg)
    |'
- en: '| `QgsSVGFillSymbolLayer` | This draws the interior of a polygon geometry using
    a repeated SVG format image. | ![Working with symbol layers](img/00069.jpeg) |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `QgsSVGFillSymbolLayer` | 这使用重复的SVG格式图像绘制多边形几何形状的内部。 | ![使用符号层](img/00069.jpeg)
    |'
- en: These predefined symbol layers, either individually or in various combinations,
    give you enormous flexibility in how features are to be displayed. However, if
    these aren't enough for you, you can also implement your own symbol layers using
    Python. We will look at how this can be done later in this chapter.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这些预定义的符号层，无论是单独使用还是以各种组合方式，都为你提供了在显示特征时的巨大灵活性。然而，如果您觉得这些还不够，您也可以使用Python实现自己的符号层。我们将在本章后面讨论如何实现。
- en: Combining symbol layers
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 符号层的组合
- en: 'By combining symbol layers, you can achieve a range of complex visual effects.
    For example, you can combine an instance of `QgsSimpleMarkerSymbolLayerV2` with
    an instance of `QgsVectorFieldSymbolLayer` to display a point geometry using two
    symbols at once:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 通过组合符号层，你可以实现一系列复杂的视觉效果。例如，你可以将`QgsSimpleMarkerSymbolLayerV2`的一个实例与`QgsVectorFieldSymbolLayer`的一个实例结合起来，同时使用两个符号来显示点几何图形：
- en: '![Combining symbol layers](img/00070.jpeg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![组合符号层](img/00070.jpeg)'
- en: 'One of the main uses of symbol layers is to draw different LineString or PolyLine
    symbols to represent different types of roads. For example, you can draw a complex
    road symbol by combining multiple symbol layers, like this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 符号层的主要用途之一是绘制不同的LineString或PolyLine符号来表示不同类型的道路。例如，你可以通过组合多个符号层来绘制复杂的道路符号，如下所示：
- en: '![Combining symbol layers](img/00071.jpeg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![组合符号层](img/00071.jpeg)'
- en: 'This effect is achieved by using three separate symbol layers:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这种效果是通过使用三个独立的符号层实现的：
- en: '![Combining symbol layers](img/00072.jpeg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![组合符号层](img/00072.jpeg)'
- en: 'Here is the Python code used to generate the preceding map symbol:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是用于生成前面地图符号的Python代码：
- en: '[PRE2]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, you can set the line width, color, and style to create whatever
    effect you want. As always, you have to define the layers in the correct order,
    with the back-most symbol layer defined first. By combining line symbol layers
    in this way, you can create almost any type of road symbol that you want.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，你可以设置线宽、颜色和样式来创建你想要的效果。像往常一样，你必须按正确的顺序定义层，最底层的符号层首先定义。通过这种方式组合线符号层，你可以创建几乎任何类型的道路符号。
- en: 'You can also use symbol layers when displaying polygon geometries. For example,
    you can draw `QgsPointPatternFillSymbolLayer` on top of `QgsSimpleFillSymbolLayerV2`
    to have repeated points on top of a simple filled polygon, like this:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在显示多边形几何图形时使用符号层。例如，你可以在`QgsSimpleFillSymbolLayerV2`之上绘制`QgsPointPatternFillSymbolLayer`，以便在简单填充多边形上重复出现点，如下所示：
- en: '![Combining symbol layers](img/00073.jpeg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![组合符号层](img/00073.jpeg)'
- en: 'Finally, you can make use of **transparency** to allow the various symbol layers
    (or entire symbols) to blend into each other. For example, you can create a pinstripe
    effect by combining two symbol layers, like this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以利用**透明度**来使各种符号层（或整个符号）相互融合。例如，你可以通过组合两个符号层来创建点状条纹效果，如下所示：
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The result is quite subtle and visually pleasing:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 结果相当微妙且视觉上令人愉悦：
- en: '![Combining symbol layers](img/00074.jpeg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![组合符号层](img/00074.jpeg)'
- en: 'In addition to changing the transparency for a symbol layer, you can also change
    the transparency for the symbol as a whole. This is done by using the `setAlpha()`
    method, like this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 除了为符号层更改透明度外，你还可以更改整个符号的透明度。这通过使用`setAlpha()`方法完成，如下所示：
- en: '[PRE4]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The result looks like this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 结果看起来像这样：
- en: '![Combining symbol layers](img/00075.jpeg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![组合符号层](img/00075.jpeg)'
- en: Note
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that `setAlpha()` takes a floating point number between 0.0 and 1.0, while
    the transparency of a `QColor` object, like the ones we used earlier, is specified
    using an alpha value between 0 and 255.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`setAlpha()`接受一个介于0.0和1.0之间的浮点数，而`QColor`对象（如我们之前使用的）的透明度是通过介于0和255之间的alpha值指定的。
- en: Implementing symbol layers in Python
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Python中实现符号层
- en: 'If the built-in symbol layers aren''t flexible enough for your needs, you can
    implement your own symbol layers using Python. To do this, you create a subclass
    of the appropriate type of symbol layer (`QgsMarkerSymbolLayerV2`, `QgsLineSymbolV2`,
    or `QgsFillSymbolV2`) and implement the various drawing methods yourself. For
    example, here is a simple marker symbol layer that draws a cross for a Point geometry:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果内置的符号层不足以满足你的需求，你可以使用Python实现自己的符号层。为此，你创建适当的符号层类型的子类（`QgsMarkerSymbolLayerV2`、`QgsLineSymbolV2`或`QgsFillSymbolV2`）并自行实现各种绘图方法。例如，这里是一个简单的标记符号层，用于绘制点几何图形的十字：
- en: '[PRE5]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Using this custom symbol layer in your code is straightforward:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的代码中使用这个自定义符号层很简单：
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Running this code will draw a cross at the location of each point geometry,
    as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码将在每个点几何图形的位置绘制一个十字，如下所示：
- en: '![Implementing symbol layers in Python](img/00076.jpeg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![在Python中实现符号层](img/00076.jpeg)'
- en: 'Of course, this is a simple example, but it shows you how to use custom symbol
    layers implemented in Python. Let''s now take a closer look at the implementation
    of the `CrossSymbolLayer` class, and see what each method does:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这是一个简单的例子，但它展示了如何使用在Python中实现的自定义符号层。现在让我们更仔细地看看`CrossSymbolLayer`类的实现，并看看每个方法的作用：
- en: '`__init__()`: Notice how the `__init__` method accepts parameters that customize
    the way the symbol layer works. These parameters, which should always have default
    values assigned to them, are the **properties** associated with the symbol layer.
    If you want to make your custom symbol available within the **QGIS Layer Properties**
    window, you will need to register your custom symbol layer and tell QGIS how to
    edit the symbol layer''s properties. We will look at this shortly.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__init__()`: 注意 `__init__` 方法接受参数来定制符号层的工作方式。这些参数，它们应该始终分配有默认值，是与符号层关联的 **属性**。如果你想使你的自定义符号在
    **QGIS 图层属性** 窗口中可用，你需要注册你的自定义符号层并告诉 QGIS 如何编辑符号层的属性。我们很快就会看到这一点。'
- en: '`layerType()`: This method returns a unique name for your symbol layer.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`layerType()`: 此方法返回你的符号层的唯一名称。'
- en: '`properties()`: This should return a dictionary that contains the various properties
    used by this symbol layer. The properties returned by this method will be stored
    in the QGIS project file, and used later to restore the symbol layer.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`properties()`: 这应该返回一个包含此符号层使用的各种属性的字典。此方法返回的属性将存储在 QGIS 项目文件中，并在以后用于恢复符号层。'
- en: '`clone()`: This method should return a copy of the symbol layer. Since we have
    defined our properties as parameters to the `__init__` method, implementing this
    method simply involves creating a new instance of the class and copying the properties
    from the current symbol layer to the new instance.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clone()`: 此方法应返回符号层的副本。由于我们已经将属性定义为 `__init__` 方法的参数，实现此方法只需创建一个新实例的类，并将当前符号层的属性复制到新实例中。'
- en: '`startRender()`: This method is called before the first feature in the map
    layer is rendered. This can be used to define any objects that will be required
    to draw the feature. Rather than creating these objects each time, it is more
    efficient (and therefore faster) to create them only once to render all the features.
    In this example, we create the `QPen` object that we will use to draw the Point
    geometries.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`startRender()`: 在渲染地图层中的第一个要素之前调用此方法。这可以用来定义绘制要素所需的任何对象。与其每次都创建这些对象，不如只创建一次以渲染所有要素，这样更高效（因此更快）。在这个例子中，我们创建了将用于绘制点几何形状的
    `QPen` 对象。'
- en: '`stopRender()`: This method is called after the last feature has been rendered.
    This can be used to release the objects created by the `startRender()` method.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stopRender()`: 在渲染最后一个要素之后调用此方法。这可以用来释放由 `startRender()` 方法创建的对象。'
- en: '`renderPoint()`: This is where all the work is done for drawing point geometries.
    As you can see, this method takes two parameters: the point at which to draw the
    symbol, and the **rendering context** (an instance of `QgsSymbolV2RenderContext`)
    to use for drawing the symbol.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`renderPoint()`: 这是绘制点几何形状的所有工作所在。正如你所见，此方法接受两个参数：绘制符号的点，以及用于绘制符号的 **渲染上下文**（`QgsSymbolV2RenderContext`
    的实例）。'
- en: The rendering context provides various methods to access the feature being displayed,
    as well as information about the rendering operation, the current scale factor,
    and so on. Most importantly, it allows you to access the PyQt `QPainter` object
    required to actually draw the symbol on the screen.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染上下文提供了各种方法来访问正在显示的要素，以及有关渲染操作、当前比例因子等信息。最重要的是，它允许你访问用于在屏幕上实际绘制符号的 PyQt `QPainter`
    对象。
- en: 'The `renderPoint()` method is only used for symbol layers that draw point geometries.
    For line geometries, you should implement the `renderPolyline()` method, which
    has the following signature:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`renderPoint()` 方法仅用于绘制点几何形状的符号层。对于线几何形状，你应该实现 `renderPolyline()` 方法，该方法的签名如下：'
- en: '[PRE7]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `points` parameter will be a `QPolygonF` object that contains the various
    points that make up the LineString, and `context` will be the rendering context
    to use to draw the geometry.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`points` 参数将是一个包含构成 LineString 的各个点的 `QPolygonF` 对象，而 `context` 将是用于绘制几何形状的渲染上下文。'
- en: 'If your symbol layer is intended to work with polygons, you should implement
    the `renderPolygon()` method, which looks like this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的符号层旨在与多边形一起工作，你应该实现 `renderPolygon()` 方法，其外观如下：
- en: '[PRE8]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, `outline` is a `QPolygonF` object that contains the points that make up
    the exterior of the polygon, and `rings` is a list of `QPolygonF` objects that
    define the interior rings or "holes" within the polygon. As always, `context`
    is the rendering context to use when drawing the geometry.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`outline`是一个包含构成多边形外部的点的`QPolygonF`对象，而`rings`是一个包含定义多边形内部环或“洞”的`QPolygonF`对象列表。一如既往地，`context`是在绘制几何形状时使用的渲染上下文。
- en: 'A custom symbol layer created in this way will work fine if you just want to
    use it within your own external PyQGIS application. However, if you want to use
    a custom symbol layer within a running copy of QGIS, and in particular, if you
    want to allow end users to work with the symbol layer using the **Layer Properties**
    window, there are some extra steps you will have to take, which are as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式创建的自定义符号层，如果您只想在自己的外部PyQGIS应用程序中使用它，将正常工作。但是，如果您想在运行的QGIS副本中使用自定义符号层，特别是如果您想允许最终用户使用**图层属性**窗口与符号层一起工作，您需要采取一些额外步骤，如下所述：
- en: 'If you want the symbol to be visually highlighted when the user clicks on it,
    you will need to change your symbol layer''s `renderXXX()` method to see if the
    feature being drawn has been selected by the user, and if so, change the way it
    is drawn. The easiest way to do this is to change the geometry''s color. For example:'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您希望在用户点击符号时符号在视觉上突出显示，您需要更改符号层的`renderXXX()`方法，以查看正在绘制的要素是否被用户选中，如果是，则更改其绘制方式。最简单的方法是更改几何形状的颜色。例如：
- en: '[PRE9]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To allow the user to edit the symbol layer''s properties, you should create
    a subclass of `QgsSymbolLayerV2Widget`, which defines the user interface to edit
    the properties. For example, a simple widget for the purpose of editing the length
    and width of a `CrossSymbolLayer` can be defined as follows:'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要允许用户编辑符号层的属性，您应该创建`QgsSymbolLayerV2Widget`的子类，它定义了编辑属性的用户界面。例如，可以定义一个简单的用于编辑`CrossSymbolLayer`长度和宽度的用户界面小部件，如下所示：
- en: '[PRE10]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We define the contents of our widget using the standard `__init__()` initializer.
    As you can see, we define two fields, `lengthField` and `widthField`, which let
    the user change the `length` and `width` properties respectively for our symbol
    layer.
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用标准的`__init__()`初始化器定义我们小部件的内容。如您所见，我们定义了两个字段，`lengthField`和`widthField`，允许用户分别更改符号层的`length`和`width`属性。
- en: The `setSymbolLayer()` method tells the widget which `QgsSymbolLayerV2` object
    to use, while the `symbolLayer()` method returns the `QgsSymbolLayerV2` object
    this widget is editing. Finally, the two `XXXChanged()` methods are called when
    the user changes the value of the fields, allowing us to update the symbol layer's
    properties to match the value set by the user.
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`setSymbolLayer()`方法告诉小部件使用哪个`QgsSymbolLayerV2`对象，而`symbolLayer()`方法返回小部件正在编辑的`QgsSymbolLayerV2`对象。最后，当用户更改字段值时，会调用两个`XXXChanged()`方法，使我们能够更新符号层的属性以匹配用户设置的值。'
- en: 'Finally, you will need to register your symbol layer. To do this, create a
    subclass of `QgsSymbolLayerV2AbstractMetadata` and pass it to the `QgsSymbolLayerV2Registry`
    object''s `addSymbolLayerType()` method. Here is an example implementation of
    the metadata for our `CrossSymbolLayer` class, along with the code to register
    it within QGIS:'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，您需要注册您的符号层。为此，创建`QgsSymbolLayerV2AbstractMetadata`的子类，并将其传递给`QgsSymbolLayerV2Registry`对象的`addSymbolLayerType()`方法。以下是我们`CrossSymbolLayer`类的元数据示例实现，以及将其在QGIS中注册的代码：
- en: '[PRE11]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Note that the parameters for the `QgsSymbolLayerV2AbstractMetadata.__init__()`
    method are as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`QgsSymbolLayerV2AbstractMetadata.__init__()`方法的参数如下：
- en: '`name`: The unique name for the symbol layer, which must match the name returned
    by the symbol layer''s `layerType()` method.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`: 符号层的唯一名称，它必须与符号层的`layerType()`方法返回的名称匹配。'
- en: '`visibleName`: A display name for this symbol layer, as shown to the user within
    the **Layer Properties** window.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`visibleName`: 这是此符号层的显示名称，在**图层属性**窗口中向用户展示。'
- en: '`type`: The type of symbol that this symbol layer will be used for.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type`: 此符号层将要使用的符号类型。'
- en: The `createSymbolLayer()` method is used to restore the symbol layer based on
    the properties stored in the QGIS project file when the project was saved. The
    `createSymbolLayerWidget()` method is called to create the user interface widget
    that lets the user view and edit the symbol layer's properties.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`createSymbolLayer()`方法用于根据在项目保存时存储在QGIS项目文件中的属性恢复符号层。调用`createSymbolLayerWidget()`方法来创建用户界面小部件，允许用户查看和编辑符号层的属性。'
- en: Implementing renderers in Python
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Python 中实现渲染器
- en: 'If you need to choose symbols based on more complicated criteria than the built-in
    renderers will provide, you can write your own custom `QgsFeatureRendererV2` subclass
    using Python. For example, the following Python code implements a simple renderer
    that alternates between odd and even symbols as point features are displayed:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要根据比内置渲染器提供的更复杂的标准选择符号，你可以使用 Python 编写自己的自定义 `QgsFeatureRendererV2` 子类。例如，以下
    Python 代码实现了一个简单的渲染器，该渲染器在显示点特征时交替使用奇数和偶数符号：
- en: '[PRE12]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Using this renderer will cause the various point geometries to be displayed
    in alternating colors, for example:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此渲染器将导致各种点几何图形以交替颜色显示，例如：
- en: '![Implementing renderers in Python](img/00077.jpeg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![在 Python 中实现渲染器](img/00077.jpeg)'
- en: 'Let''s take a closer look at how this class was implemented, and what the various
    methods do:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看这个类是如何实现的，以及各种方法的作用：
- en: '`__init__()`: This is your standard Python initializer. Notice how we have
    to provide a unique name for the renderer when calling the `QgsFeatureRendererV2.__init__()`
    method; this is used to keep track of the various renderers within QGIS itself.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__init__()`: 这是你的标准 Python 初始化器。注意，在调用 `QgsFeatureRendererV2.__init__()` 方法时，我们必须为渲染器提供一个唯一的名称；这用于在
    QGIS 本身中跟踪各种渲染器。'
- en: '`clone()`: This creates a copy of this renderer. If your renderer uses properties
    to control how it works, this method should copy those properties into the new
    renderer object.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clone()`: 这将创建此渲染器的副本。如果你的渲染器使用属性来控制其工作方式，则此方法应将这些属性复制到新的渲染器对象中。'
- en: '`symbolForFeature()`: This returns the symbol to use for drawing the given
    feature.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`symbolForFeature()`: 这返回用于绘制给定特征的符号。'
- en: '`startRender()`: This gives you the opportunity to prepare your renderer and
    any symbols you use before the features are rendered. Note that you must call
    the `startRender()` method on each symbol that your renderer uses; as the renderer
    can make use of multiple symbols, you need to implement this so that your symbols
    are also given a chance to prepare for rendering.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`startRender()`: 这为你提供了在渲染特征之前准备你的渲染器和任何你使用的符号的机会。请注意，你必须为你的渲染器使用的每个符号调用 `startRender()`
    方法；因为渲染器可以使用多个符号，所以你需要实现这一点，以便你的符号也有机会为渲染做准备。'
- en: '`stopRender()`: This finishes rendering the features. Once again, you need
    to implement this so that your symbols can have a chance to clean up once the
    rendering process has finished.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stopRender()`: 这完成了特征的渲染。同样，你需要实现这一点，以便你的符号在渲染过程完成后有机会进行清理。'
- en: '`usedAttributes()`: This method should be implemented to return the list of
    feature attributes that the renderer makes use of. If your renderer does not use
    attributes to choose between the various symbols, then you do not need to implement
    this method.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`usedAttributes()`: 应实现此方法以返回渲染器使用的特征属性列表。如果你的渲染器不使用属性在各个符号之间进行选择，则不需要实现此方法。'
- en: If you wish, you can also implement your own widget that lets the user change
    the way the renderer works. This is done by subclassing `QgsRendererV2Widget`
    and setting up the widget to edit the renderer's various properties in the same
    way that we implemented a subclass of `QgsSymbolLayerV2Widget` to edit the properties
    for a symbol layer. You will also need to provide metadata for your new renderer
    (by subclassing `QgsRendererV2AbstractMetadata`) and use the `QgsRendererV2Registry`
    object to register your new renderer. If you do this, the user will be able to
    select your custom renderer for new map layers, and change the way your renderer
    works by editing the renderer's properties.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意，你也可以实现自己的小部件，让用户能够更改渲染器的工作方式。这是通过子类化 `QgsRendererV2Widget` 并设置小部件来编辑渲染器的各种属性来完成的，就像我们实现了
    `QgsSymbolLayerV2Widget` 的子类来编辑符号层的属性一样。你还需要通过子类化 `QgsRendererV2AbstractMetadata`
    为你的新渲染器提供元数据，并使用 `QgsRendererV2Registry` 对象来注册你的新渲染器。如果你这样做，用户将能够为新地图层选择你的自定义渲染器，并通过编辑渲染器的属性来更改渲染器的工作方式。
- en: Working with custom map layers
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与自定义地图图层一起工作
- en: Instead of using a standard map layer with a data provider, features, symbols,
    and so on, you can implement your own **custom map layer** entirely in Python.
    Custom map layers are generally used to draw specific data that is too complicated
    to represent as vector format data, or to draw special visual features such as
    a grid or a watermark onto the map.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用具有数据提供者、特征、符号等的标准地图层不同，您可以使用 Python 完全实现自己的**自定义地图层**。自定义地图层通常用于绘制作为矢量格式数据表示过于复杂的特定数据，或者用于在地图上绘制特殊视觉特征，如网格或水印。
- en: Custom map layers are implemented by subclassing the `QgsPluginLayer` class.
    The process is actually very simple, though you will need to translate between
    map and device coordinates so that the items you draw in your Python layer match
    up with the features drawn in the other layers within your canvas.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 通过继承 `QgsPluginLayer` 类来实现自定义地图层。实际上，这个过程非常简单，尽管您需要在不同坐标之间进行转换，以便您在 Python 层中绘制的项目与画布中其他层绘制的特征相匹配。
- en: Note
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Don't get confused by the name; you don't have to write a QGIS plugin to create
    your own `QgsPluginLayer` subclass.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 不要被名称所迷惑；您不需要编写 QGIS 插件来创建自己的 `QgsPluginLayer` 子类。
- en: 'Let''s see how we can create our own subclass of `QgsPluginLayer`. We''re going
    to create a simple grid that can appear as a layer within the map. Let''s start
    by defining the `QgsPluginLayer` subclass itself:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何创建自己的 `QgsPluginLayer` 子类。我们将创建一个简单的网格，它可以作为地图中的一个层出现。让我们首先定义 `QgsPluginLayer`
    子类本身：
- en: '[PRE13]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In our `__init__()` method, we give the plugin layer a unique name (`"GridLayer"`)
    and a user-visible name (`"Grid Layer"`), and then tell QGIS that the layer is
    valid.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `__init__()` 方法中，我们给插件层赋予一个唯一名称（`"GridLayer"`）和一个用户可见名称（`"Grid Layer"`），然后告诉
    QGIS 该层是有效的。
- en: 'Next, we need to set up the coordinate reference system and extent of our layer.
    Since we''re creating a grid that covers the entire Earth, we''ll use the standard
    EPSG 4236 coordinate system (that is, latitude/longitude coordinates), and set
    the extent of the layer to cover the entire surface of the Earth:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要设置我们层的坐标参考系统和范围。由于我们正在创建一个覆盖整个地球的网格，我们将使用标准的 EPSG 4236 坐标系统（即纬度/经度坐标），并将层的范围设置为覆盖整个地球表面：
- en: '[PRE14]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We''re now ready to define the method that draws the contents of the layer.
    As you might imagine, this method is called `draw()`. Let''s start by obtaining
    the `QPainter` object we''ll use to do the actual drawing:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备好定义绘制层内容的方法了。正如您所想象的，这个方法被称为 `draw()`。让我们首先获取我们将用于实际绘制的 `QPainter` 对象：
- en: '[PRE15]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, we want to find the portion of the Earth''s surface that is currently
    visible:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们想要找到当前可见的地球表面部分：
- en: '[PRE16]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This gives us the portion of the grid that we want to draw. To make sure the
    grid lines are on whole degrees of latitude and longitude, we round the extent
    up and down to the nearest whole number, like this:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们提供了想要绘制的网格部分。为了确保网格线位于整个纬度和经度上，我们将范围向上和向下取整到最接近的整数，如下所示：
- en: '[PRE17]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Next, we need to set up the painter to draw the grid lines:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要设置绘图器来绘制网格线：
- en: '[PRE18]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, we''re almost ready to start drawing the grid. To draw the grid lines,
    though, we''ll need some way of translating between latitude/longitude values
    and pixel coordinates on the computer screen. We''ll do this using a `QgsMapToPixel`
    object, which we can get from the rendering context:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们几乎准备好开始绘制网格了。但是，为了绘制网格线，我们需要一种方法来在经纬度值和计算机屏幕上的像素坐标之间进行转换。我们将使用 `QgsMapToPixel`
    对象来完成这项工作，我们可以从渲染上下文中获取它：
- en: '[PRE19]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, we''re finally ready to draw the grid lines. Let''s start by drawing a
    vertical grid line on each whole degree of longitude:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们终于准备好绘制网格线了。让我们从在每个整度经度上绘制一条垂直网格线开始：
- en: '[PRE20]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We can then do the same for the horizontal grid lines:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为水平网格线做同样的操作：
- en: '[PRE21]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The last thing we need to do is tell QGIS that our layer was drawn successfully.
    We do this by having our `draw()` method return `True`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的最后一件事是告诉 QGIS 我们已成功绘制了该层。我们通过让我们的 `draw()` 方法返回 `True` 来完成此操作：
- en: '[PRE22]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This completes our implementation of the `GridLayer` class. If you want to
    use this class within a QGIS script or plugin, you will need to register the class
    so that QGIS knows about it. Fortunately, doing this is straightforward:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们对 `GridLayer` 类的实现。如果您想在 QGIS 脚本或插件中使用此类，您需要注册该类，以便 QGIS 了解它。幸运的是，这样做很简单：
- en: '[PRE23]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If you run this program within QGIS and add the `GridLayer` to your project,
    you''ll see the grid lines drawn on the map:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在 QGIS 中运行此程序并将 `GridLayer` 添加到您的项目中，您将看到地图上绘制的网格线：
- en: '![Working with custom map layers](img/00078.jpeg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![使用自定义地图层](img/00078.jpeg)'
- en: Look carefully at the preceding image; you'll see that the grid lines are drawn
    in front of the polygon, but behind the circle. This is one of the main benefits
    of implementing your own map layer, as opposed to using a map canvas item; you
    can choose which layers appear in front or behind your custom map layer.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细观察前面的图像；您会看到网格线是在多边形之前、圆之后绘制的。这是实现自己的地图层而不是使用地图画布项的主要好处之一；您可以选择哪些图层出现在您的自定义地图层的前面或后面。
- en: Creating custom map canvas items
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义地图画布项
- en: 'A map canvas item is an item that is placed on top of the map canvas. Standard
    map canvas items include text annotations, vertex markers, and the visual highlighting
    of a feature. It is also possible to create your own custom map canvas items by
    subclassing `QgsMapCanvasItem`. To see how this works, let''s create a map canvas
    item that draws a compass rose onto the map:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 地图画布项是放置在地图画布上的项。标准地图画布项包括文本注释、顶点标记以及特征的视觉突出显示。您还可以通过继承 `QgsMapCanvasItem` 来创建自己的自定义地图画布项。为了了解这是如何工作的，让我们创建一个地图画布项，在地图上绘制罗盘玫瑰：
- en: '![Creating custom map canvas items](img/00079.jpeg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![创建自定义地图画布项](img/00079.jpeg)'
- en: 'We''ll start by creating the basic `QgsMapCanvasItem` subclass:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建基本的 `QgsMapCanvasItem` 子类：
- en: '[PRE24]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As you can see, we position the compass rose onto the map canvas by defining
    `center` and `size` instance variables, and provide methods to retrieve and set
    these values. We also implement the required `boundingRect()` method, which returns
    the overall bounding rectangle for the canvas item, in screen coordinates.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们通过定义 `center` 和 `size` 实例变量将罗盘玫瑰放置在地图画布上，并提供方法来检索和设置这些值。我们还实现了所需的 `boundingRect()`
    方法，它返回画布项的整体边界矩形，以屏幕坐标表示。
- en: This leaves us with the `paint()` method, which does the job of drawing the
    compass rose. While this method takes three parameters, the only parameter we'll
    be using is the first one, which is the `QPainter` object we will use to draw
    the compass rose.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这就留下了 `paint()` 方法，它负责绘制罗盘玫瑰。虽然此方法有三个参数，但我们只会使用第一个参数，即我们将用于绘制罗盘玫瑰的 `QPainter`
    对象。
- en: 'The compass rose might look quite complicated, but the code needed to implement
    it is quite straightforward. The most complicated part is figuring out the dimensions
    of the `"N"`, `"S"`, `"E"`, and `"W"` labels so that we have enough room left
    for the compass rose itself. Let''s start by calculating some basic information
    about the labels that we are going to display:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 罗盘玫瑰可能看起来相当复杂，但实现它的代码相当简单。最复杂的部分是确定 `"N"`、`"S"`、`"E"` 和 `"W"` 标签的尺寸，以便我们为罗盘玫瑰本身留出足够的空间。让我们先计算一下将要显示的标签的一些基本信息：
- en: '[PRE25]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We calculate the size of the font to use for the labels (in points), and then
    set our painter to use a boldfaced `"Times"` font of that size. We then get a
    `QFontMetrics` object that we will use to calculate the labels' dimensions, and
    define a hardwired pixel margin so that we leave a gap between the label and the
    compass rose itself.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们计算用于标签的字体大小（以点为单位），然后设置我们的画家使用该大小的粗体 `"Times"` 字体。然后我们获取一个 `QFontMetrics`
    对象，我们将使用它来计算标签的尺寸，并定义一个硬编码的像素边距，以便我们在标签和罗盘玫瑰本身之间留出间隙。
- en: 'Next, we want to draw the two central parts of the compass rose in light gray
    and black respectively. To do this, we''ll use a `QPainterPath` object to define
    the area to be filled in:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们希望用浅灰色和黑色分别绘制罗盘玫瑰的两个中心部分。为此，我们将使用 `QPainterPath` 对象来定义要填充的区域：
- en: '[PRE26]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Finally, we want to draw the labels at each of the four compass points:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们希望在四个罗盘点上绘制标签：
- en: '[PRE27]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This completes the implementation of our `QgsMapCanvasItem` subclass. To use
    it, we simply have to create and initialize a new `CompassRoseItem`. Here is an
    example of how we can display a `CompassRoseItem` within the map canvas:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了我们的 `QgsMapCanvasItem` 子类的实现。要使用它，我们只需创建并初始化一个新的 `CompassRoseItem`。以下是如何在地图画布中显示
    `CompassRoseItem` 的示例：
- en: '[PRE28]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Your new `QgsMapCanvasItem` will automatically be added to the map canvas when
    the object is initialized—you don''t need to explicitly add it to the canvas.
    To remove the compass rose from the map canvas, you can do the following:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 您的新 `QgsMapCanvasItem` 在对象初始化时将自动添加到地图画布上——您不需要显式将其添加到画布。要移除地图画布上的罗盘玫瑰，您可以执行以下操作：
- en: '[PRE29]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note that map canvas items float above the map layers, and unfortunately, cannot
    directly interact with the user—you can't intercept and respond to mouse events
    using a map canvas item.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，地图画布项浮在地图图层之上，不幸的是，它们不能直接与用户交互——你不能使用地图画布项拦截和响应用户的鼠标事件。
- en: Using memory-based layers
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用基于内存的图层
- en: While a map layer would normally display geospatial data taken from an external
    data source such as a shapefile, a raster DEM file, or a database, it is also
    possible to create geospatial features directly from your Python code. For example,
    imagine that you write a program to display the halfway point along a road. This
    halfway point could be represented as a `QgsPoint` geometry, which would be displayed
    on the map using an appropriate marker symbol. Since you are calculating the point,
    this isn't a feature you would want to store in a shapefile or database. Rather,
    the feature is calculated and displayed when your program is run.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，地图图层会显示来自外部数据源（如shapefile、栅格DEM文件或数据库）的地理空间数据，但也可以直接从你的Python代码中创建地理空间要素。例如，想象你编写了一个程序来显示道路的中点。这个中点可以用
    `QgsPoint` 几何体表示，它将使用适当的标记符号在地图上显示。由于你正在计算这个点，所以这不是你想要存储在shapefile或数据库中的要素。相反，要素是在程序运行时计算并显示的。
- en: This is an ideal application for a memory-based layer. This type of layer stores
    geospatial features in memory, allowing you to create new features on the fly
    and display them within a map layer.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种理想的基于内存图层的应用。这种类型的图层在内存中存储地理空间要素，允许你在运行时创建新要素并在地图图层中显示它们。
- en: 'To create a memory-based map layer, instantiate a new `QgsVectorLayer` object,
    just like normal. The initializer for this class looks like the following:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个基于内存的地图图层，实例化一个新的 `QgsVectorLayer` 对象，就像正常一样。这个类的初始化器看起来如下所示：
- en: '[PRE30]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This is slightly simplified—there is another parameter, `loadDefaultStyleFlag`,
    which doesn't apply to memory-based layers. Fortunately, there's a default value
    for this parameter, so we can ignore it.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是稍微简化了一下——还有一个参数 `loadDefaultStyleFlag`，它不适用于基于内存的图层。幸运的是，这个参数有一个默认值，所以我们可以忽略它。
- en: 'Let''s take a look at the three parameters needed to create a memory-based
    map layer:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看创建基于内存的地图图层所需的三个参数：
- en: '`path`: This string provides information that is needed to create the memory-based
    layer, including the type of information that the layer will store. We will look
    at this parameter in more detail shortly.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`path`：这个字符串提供了创建基于内存图层所需的信息，包括图层将存储的信息类型。我们将在稍后详细讨论这个参数。'
- en: '`baseName`: This is the name used for the memory-based layer. The name can
    be anything you like, though the user will see it in the QGIS layer legend.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`baseName`：这是用于基于内存图层的名称。名称可以是任何你喜欢的，尽管用户会在QGIS图层列表中看到它。'
- en: '`providerLib`: This should be set to `"memory"` for memory-based layers.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`providerLib`：对于基于内存的图层，应该设置为 `"memory"`。'
- en: 'To create a simple memory-based layer, you can do the following:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个简单的基于内存的图层，你可以这样做：
- en: '[PRE31]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This will create a memory-based layer named `"My Layer"`, which stores polygon
    features with no attributes.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个名为 `"My Layer"` 的基于内存的图层，其中存储没有属性的多边形要素。
- en: 'The `path` parameter will let us do much more than simply define the type of
    geometry to be stored in the layer. The `path` parameter has the following overall
    syntax:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`path` 参数将使我们能够做比仅仅定义要存储在图层中的几何类型更多的事情。`path` 参数具有以下总体语法：'
- en: '[PRE32]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This URL-like syntax starts with the type of geometry, and can have any number
    of key/value pairs that provide additional information about the memory layer.
    The following geometry types are currently supported:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类似于URL的语法以几何类型开始，可以包含任意数量的键/值对，这些键/值对提供了关于内存图层的额外信息。目前支持以下几何类型：
- en: '`Point`'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Point`'
- en: '`LineString`'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LineString`'
- en: '`Polygon`'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Polygon`'
- en: '`MultiPoint`'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MultiPoint`'
- en: '`MultiLineString`'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MultiLineString`'
- en: '`MultiPolygon`'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MultiPolygon`'
- en: 'Using the key/value pairs, you can also define:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 使用键/值对，你还可以定义：
- en: 'The coordinate reference system that the layer should use. For example:'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图层应使用的坐标参考系统。例如：
- en: '[PRE33]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The coordinate reference system can be defined using a CRS authority code,
    as in the preceding example, or you can specify the CRS in WKT format, for example:
    `crs=+proj=longlat +a=69000 +b=55000 +no_defs`.'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 坐标参考系统可以使用CRS权威代码定义，就像前面的例子一样，或者你可以指定WKT格式的CRS，例如：`crs=+proj=longlat +a=69000
    +b=55000 +no_defs`。
- en: Note
  id: totrans-197
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you don't define the coordinate reference system in this way, QGIS will prompt
    the user to select a CRS when your program is run. This could be very confusing
    for the user, so you should always specify a CRS when you create a memory layer.
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果您以这种方式没有定义坐标参考系统，当您的程序运行时，QGIS将提示用户选择一个CRS。这可能会使用户感到非常困惑，因此您在创建内存层时应该始终指定一个CRS。
- en: 'Attributes to store for each feature within the layer. Here is an example of
    an attribute definition:'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在层内为每个特征存储的属性。以下是一个属性定义的示例：
- en: '[PRE34]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The following types of fields are currently supported:'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当前支持以下类型的字段：
- en: '`integer`'
  id: totrans-202
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`integer`'
- en: '`double`'
  id: totrans-203
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`double`'
- en: '`string`'
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`string`'
- en: You can also specify the field length and precision by listing these in parentheses,
    for example, `field=height:double(10,2)` or `field=name:string(50)`.
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您还可以通过列出这些属性来指定字段长度和精度，例如，`field=height:double(10,2)`或`field=name:string(50)`。
- en: If you want to have multiple attributes, you simply have one `field=...`entry
    for each of the attributes you want to define.
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果您想要有多个属性，您只需为要定义的每个属性有一个`field=...`条目即可。
- en: Note
  id: totrans-207
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The memory layer's data provider has an `addAttributes()` method, which you
    might assume you'd use to define the attributes. However, the `addAttributes()`
    method only adds the attributes to the data provider, not the map layer, which
    can cause QGIS to crash. To avoid this, it is better to define your attributes
    within the path when you set up your map layer, rather than trying to add them
    later.
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 内存层的数据提供者有一个`addAttributes()`方法，您可能会认为您会使用它来定义属性。然而，`addAttributes()`方法只将属性添加到数据提供者，而不是地图层，这可能导致QGIS崩溃。为了避免这种情况，最好在设置地图层时在路径中定义您的属性，而不是尝试稍后添加它们。
- en: 'A spatial index for this layer''s features:'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该层特征的空问索引：
- en: '[PRE35]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Let''s use this to create a more complex memory layer that stores point geometries
    using a specified coordinate reference system, a spatial index, and some attributes.
    Here is how we might do this:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用这个方法来创建一个更复杂的内存层，该层使用指定的坐标参考系统、空间索引和一些属性来存储点几何形状。以下是我们可以如何实现这一点：
- en: '[PRE36]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Once we''ve instantiated our memory layer, we can create the various features
    we want to display, and then add them to the layer. The following pseudocode shows
    how this is done:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们实例化了我们的内存层，我们就可以创建我们想要显示的各种特征，然后将它们添加到层中。以下伪代码显示了如何完成此操作：
- en: '[PRE37]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: As you can see, we define the various features (which are instances of `QgsFeature`),
    and then add them all at once to the memory layer. You can add the features one
    at a time, of course, but it's generally more efficient to define a list of features
    and add them all at once.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们定义了各种特征（它们是`QgsFeature`的实例），然后一次性将它们全部添加到内存层中。当然，您也可以逐个添加特征，但通常定义一个特征列表并一次性添加它们会更有效率。
- en: 'Let''s now see how we can create a feature. We start by defining the underlying
    geometry that the feature will display. There are various ways of creating geometries,
    including:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看我们如何创建一个特征。我们首先定义特征将要显示的底层几何形状。有各种创建几何形状的方法，包括：
- en: 'Instantiating a `QgsPoint`, `QgsPolyLine`, `QgsPolygon`, or related object,
    and then using this to create a `QgsGeometry` object using one of the `QgsGeometry.fromXXX()`
    methods. For example:'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实例化一个`QgsPoint`、`QgsPolyLine`、`QgsPolygon`或相关对象，然后使用`QgsGeometry.fromXXX()`方法之一来创建`QgsGeometry`对象。例如：
- en: '[PRE38]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Creating a WKT-format string that represents the geometry, and then creating
    the `QgsGeometry` object using this string. For example:'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个表示几何形状的WKT格式字符串，然后使用该字符串创建`QgsGeometry`对象。例如：
- en: '[PRE39]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Creating a new `QgsGeometry` object out of an existing geometry by using one
    of the geometry manipulation methods. For example:'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用几何形状操作方法之一从现有几何形状中创建一个新的`QgsGeometry`对象。例如：
- en: '[PRE40]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Once we have the geometry, we''re ready to create the `QgsFeature` object itself:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了几何形状，我们就可以创建`QgsFeature`对象本身：
- en: '[PRE41]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Next, we want to set the attributes for this feature. Before we can do this
    though, we need to tell the feature which attributes it will store. This is done
    in the following way:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们想要设置该特征的属性。在我们能够这样做之前，我们需要告诉特征它将存储哪些属性。这是以下方式完成的：
- en: '[PRE42]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Finally, we can set the attribute values. For example:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以设置属性值。例如：
- en: '[PRE43]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Putting all this together, let''s build a complete example program that creates
    a memory layer, populates it with a few `QgsPoint` features, and updates the map
    canvas to show those points. Here is this example program:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有这些放在一起，让我们构建一个完整的示例程序，该程序创建一个内存层，用几个`QgsPoint`特征填充它，并更新地图画布以显示这些点。以下是此示例程序：
- en: '[PRE44]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Running this program from within QGIS will create a new memory-based map layer
    named `"Point Layer"` with three features in it, which represent the location
    of three famous towers in Western Europe:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在 QGIS 内运行此程序将创建一个名为 `"Point Layer"` 的新基于记忆的地图层，其中包含三个要素，代表西欧三个著名塔的位置：
- en: '![Using memory-based layers](img/00080.jpeg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![使用基于记忆的层](img/00080.jpeg)'
- en: To make this example useful, we would add symbols to draw the towers in a more
    meaningful way, and probably also display the name and height as a label beside
    each point. However, you can see how a memory layer can be used to create spatial
    data from within your program and include it as a layer within the map.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个例子更有用，我们会添加符号以更有意义的方式绘制塔，并且可能还会在每个点的旁边显示名称和高度作为标签。然而，您可以看到如何使用记忆层在程序内部创建空间数据并将其作为地图中的一个图层包含进来。
- en: Note that you aren't limited to using memory layers to represent actual geospatial
    data. You could just as easily use the memory layer to display information that
    doesn't represent a location. For example, you can use a memory layer to draw
    arrows onto a map, or to shade certain areas of the map using a semi-transparent
    polygon. Memory-based map layers are an extremely powerful tool, and one that
    you will often use when writing your own programs based on QGIS.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，您不仅限于使用基于记忆的层来表示实际的地理空间数据。您同样可以使用记忆层来显示不表示位置的信息。例如，您可以使用记忆层在地图上绘制箭头，或者使用半透明多边形来阴影地图的某些区域。基于记忆的地图层是一个非常强大的工具，您在编写基于
    QGIS 的程序时经常会使用它。
- en: Summary
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at many of the more advanced features of the QGIS
    Python API. We learned how the various built-in symbol layers can be used to draw
    geometries on the map, how to combine symbol layers in useful ways, and how to
    implement your own symbol layers using Python. We then looked at writing your
    own custom renderer to choose which symbol to use for each feature, and how to
    create your own custom map layer using Python code. We investigated the creation
    of custom map canvas items, and then saw how memory-based map layers can be used
    to programmatically add features to your map.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了 QGIS Python API 的许多高级功能。我们学习了如何使用各种内置符号层在地图上绘制几何形状，如何以有用的方式组合符号层，以及如何使用
    Python 实现自己的符号层。然后，我们探讨了编写自己的自定义渲染器以选择每个要素应使用的符号，以及如何使用 Python 代码创建自己的自定义地图层。我们研究了创建自定义地图画布项，然后看到了如何使用基于记忆的地图层以编程方式将要素添加到地图中。
- en: With this, we complete our tour of the more advanced aspects of PyQGIS. In the
    next chapter, we will learn how to create custom map tools that let the user select,
    add, edit, and delete features within a PyQGIS application.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们完成了对 PyQGIS 更高级方面的探索。在下一章中，我们将学习如何创建自定义地图工具，使用户能够在 PyQGIS 应用程序中选择、添加、编辑和删除要素。
