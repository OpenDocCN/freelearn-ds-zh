- en: Chapter 12. Error Handling and Troubleshooting
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章. 错误处理和故障排除
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下内容：
- en: Exploring the default Python error message
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索默认的Python错误信息
- en: Adding Python exception handling structures (try/except/finally)
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加Python异常处理结构（try/except/finally）
- en: Retrieving tool messages with GetMessages()
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用GetMessages()检索工具消息
- en: Filtering tool messages by severity level
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过严重程度级别过滤工具消息
- en: Returning individual messages with GetMessage()
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用GetMessage()返回单个消息
- en: Testing for and responding to specific error messages
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试并响应特定错误消息
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Various messages are returned during the execution of ArcGIS geoprocessing tools
    and functions. These messages can be informational in nature or indicate warning
    or error conditions that can result in the tool not creating the expected output
    or in outright failure of the tool to execute. These messages do not appear as
    message boxes. Instead, you will need to retrieve them using various ArcPy functions.
    To this point in the book, we have ignored the existence of these messages, warnings,
    and errors. This is mainly due to the fact that I wanted you to concentrate on
    learning some basic concepts, without adding the extra layer of code complexity
    that is necessary for creating robust geoprocessing scripts that can handle error
    situations gracefully. That being said, it's now time that you learn how to create
    the geoprocessing and Python exception handling structures that will enable you
    to create versatile geoprocessing scripts. These scripts can handle messages that
    indicate warnings, errors, and general information, which are generated while
    your script is running. These code details will help make your scripts more flexible
    and less error prone. You've already used the basic `try` and `except` blocks
    to perform some basic error handling. But, in this chapter, we'll go into more
    detail about why and how these structures are used.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '在执行ArcGIS地理处理工具和函数的过程中，会返回各种消息。这些消息可能是信息性的，或者指示警告或错误条件，可能导致工具无法创建预期的输出，或者工具执行完全失败。这些消息不会以消息框的形式出现。相反，您需要使用各种ArcPy函数来检索它们。到目前为止，本书中我们忽略了这些消息、警告和错误的存在。这主要是因为我想让您集中精力学习一些基本概念，而不添加创建健壮的地理处理脚本所需的额外代码复杂性，这些脚本可以优雅地处理错误情况。话虽如此，现在是时候学习如何创建地理处理和Python异常处理结构，这将使您能够创建灵活的地理处理脚本。这些脚本可以处理在脚本运行时生成的指示警告、错误和一般信息的消息。这些代码细节将帮助使您的脚本更加灵活，减少错误发生的可能性。您已经使用基本的`try`和`except`块执行了一些基本的错误处理。但是，在本章中，我们将更详细地介绍为什么以及如何使用这些结构。 '
- en: Exploring the default Python error message
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索默认的Python错误信息
- en: By default, Python will generate an error message anytime it encounters a problem
    in your script. These error messages will not always be very informative to the
    end user running the script. However, it is valuable to take a look at these raw
    messages. In later recipes, we'll use Python error handling structures to get
    a cleaner look at the errors and respond as necessary.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Python会在您的脚本中遇到问题时生成错误消息。这些错误消息并不总是对运行脚本的最终用户非常有信息性。然而，查看这些原始消息是有价值的。在后面的菜谱中，我们将使用Python错误处理结构来获取更清晰的错误视图，并根据需要进行响应。
- en: Getting ready
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we will create and run a script that intentionally contains
    error conditions. We will not include any geoprocessing or Python exception handling
    techniques in the script. We're intentionally doing this, because I want you to
    see the error information returned by Python.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将创建并运行一个故意包含错误条件的脚本。我们不会在脚本中包含任何地理处理或Python异常处理技术。我们故意这样做，因为我想让您看到Python返回的错误信息。
- en: How to do it…
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Follow the steps below to see a raw Python error message that is generated
    when an error occurs while a tool is being executed in a script:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤操作，以查看在脚本执行过程中工具执行时产生的原始Python错误信息：
- en: Open IDLE and create a new script.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开IDLE并创建一个新的脚本。
- en: Save the script to `c:\ArcpyBook\Ch12\ErrorHandling.py`.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将脚本保存到`c:\ArcpyBook\Ch12\ErrorHandling.py`。
- en: 'Import the `arcpy` module:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`arcpy`模块：
- en: '[PRE0]'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Set the workspace:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置工作空间：
- en: '[PRE1]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Call the `Buffer` tool. The `Buffer` tool requires a buffer distance be entered
    as one of its parameters. In this code block, we have intentionally left out the
    distance parameter:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`Buffer`工具。`Buffer`工具需要一个缓冲距离作为其参数之一。在这个代码块中，我们故意省略了距离参数：
- en: '[PRE2]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Run the script. You should see the following error message:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行脚本。你应该看到以下错误信息：
- en: '[PRE3]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: How it works…
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: What you see in the output error message isn't terribly informative. If you
    are a fairly experienced programmer, you'll generally be able to make out what
    the problem is. In this case we did not include a buffer distance. However, in
    many cases, the returned error message will not give you much information that
    you can use to resolve the problem. Errors in your code are simply a fact of life
    in programming. However, how your code responds to these errors, also called exceptions,
    is very important. You should plan to handle errors gracefully through the use
    of Python error handling structures, which examine `arcpy` generated exceptions
    and act accordingly. Without these structures in place, your scripts will fail
    immediately, frustrating your users in the process.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你在输出错误信息中看到的内容并不十分有用。如果你是一个经验丰富的程序员，你通常会能够识别出问题所在。在这种情况下，我们没有包括缓冲距离。然而，在许多情况下，返回的错误信息不会给你提供多少你可以用来解决问题的信息。代码中的错误是编程生活中不可避免的事实。然而，你的代码如何响应这些错误，也称为异常，是非常重要的。你应该计划使用
    Python 错误处理结构来优雅地处理错误，这些结构会检查 `arcpy` 生成的异常并相应地采取行动。如果没有这些结构，你的脚本将立即失败，从而让用户感到沮丧。
- en: Adding Python exception handling structures (try/except/finally)
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加 Python 异常处理结构（try/except/finally）
- en: Python has built-in exception handling structures that allow you to capture
    error messages that are generated. Using this error information, you can then
    display a more appropriate message to the end user and respond to the situation
    as needed.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Python 内置了异常处理结构，允许你捕获生成的错误信息。使用这些错误信息，你可以向最终用户显示更合适的消息，并根据需要做出响应。
- en: Getting ready
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Exceptions are unusual or error conditions that occur in your code. Exception
    statements in Python enable you to trap and handle errors in your code, allowing
    you to gracefully recover from error conditions. In addition to error handling,
    exceptions can be used for a variety of other things including event notification
    and special-case handling.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 异常是在你的代码中发生的异常或错误条件。Python 中的异常语句允许你捕获和处理代码中的错误，使你能够优雅地从错误条件中恢复。除了错误处理之外，异常还可以用于各种其他事情，包括事件通知和特殊情况处理。
- en: Python exceptions occur in two ways. Exceptions in Python can either be intercepted
    or triggered. When an error condition occurs in your code, Python automatically
    triggers an exception, which may or may not be handled by your code. It is up
    to you as a programmer to catch an automatically triggered exception. Exceptions
    can also be triggered manually by your code. In this case, you would also provide
    an exception handling routine to catch these manually triggered exceptions. You
    can manually trigger an exception by using the `raise` statement.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Python 异常以两种方式发生。Python 中的异常可以是拦截的或触发的。当你的代码中发生错误条件时，Python 会自动触发异常，这可能或可能不会被你的代码处理。作为程序员，是否捕获自动触发的异常取决于你。异常也可以通过你的代码手动触发。在这种情况下，你还需要提供一个异常处理例程来捕获这些手动触发的异常。你可以通过使用
    `raise` 语句手动触发异常。
- en: The `try`/`except` statement is a complete, compound Python statement used to
    handle exceptions. This variety of `try` statement starts with a `try` header
    line followed by a block of indented statements, then one or more optional `except`
    clauses that name exceptions to be caught, and an optional `else` clause at the
    end.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`try`/`except` 语句是一个完整的、复合的 Python 语句，用于处理异常。这种 `try` 语句以 `try` 标题行开始，后跟一个缩进的语句块，然后是一个或多个可选的
    `except` 子句，这些子句命名了要捕获的异常，以及一个可选的 `else` 子句。'
- en: The `try`/`except`/`else` statement works as follows. Once inside a `try` statement,
    Python marks the fact that you are in a `try` block and knows that any exception
    condition that occurs within this block will be forwarded to the various `except`
    statements for handling.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`try`/`except`/`else` 语句的工作方式如下。一旦进入 `try` 语句，Python 会标记你处于 `try` 块中，并且知道该块内发生的任何异常条件都将被转发到各个
    `except` 语句进行处理。'
- en: Each statement inside the `try` block is executed. Assuming that no exception
    conditions occur, the code pointer will then jump to the `else` statement and
    execute the code block contained within the `else` statement before moving to
    the next line of code below the `try` block. If an exception occurs inside the
    `try` block, Python searches for a matching exception code. If a matching exception
    is found, the code block inside the `except` block is executed. The code then
    picks up below the full `try` statement. The `else` statements are not executed
    in this case. If a matching exception header is not found, Python will propagate
    the exception to a `try` statement above this code block. In the event that no
    matching `except` header is found, the exception comes out of the top level of
    the process. This results in an unhandled exception and you wind up with the type
    of error message that we saw in our first recipe in this chapter.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`try` 块内的每个语句都会被执行。假设没有发生异常条件，代码指针将跳转到 `else` 语句并执行 `else` 语句中包含的代码块，然后移动到
    `try` 块下方的下一行代码。如果在 `try` 块内部发生异常，Python 将搜索匹配的异常代码。如果找到匹配的异常，`except` 块内的代码块将被执行。然后代码从
    `try` 语句的下方继续执行。在这种情况下，`else` 语句不会被执行。如果没有找到匹配的异常头，Python 将将异常传播到此代码块上方的 `try`
    语句。如果在整个过程中没有找到匹配的 `except` 头，异常将出现在进程的最顶层。这会导致未处理的异常，你最终会收到我们在本章第一个菜谱中看到的错误消息类型。'
- en: In this recipe, we're going to add in some basic Python exception handling structures.
    There are several variations of the `try`/`except`/`else`/`finally` exception
    handling structure. In this recipe, we'll start with a very simple `try`/`except`
    structure.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将添加一些基本的 Python 异常处理结构。`try`/`except`/`else`/`finally` 异常处理结构有多种变体。在这个菜谱中，我们将从一个非常简单的
    `try`/`except` 结构开始。
- en: How to do it…
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow the steps below to add Python error handling structures to a script:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤将 Python 错误处理结构添加到脚本中：
- en: If necessary, open the `c:\ArcpyBook\Ch12\ErrorHandling.py` file in IDLE.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果需要，在 IDLE 中打开 `c:\ArcpyBook\Ch12\ErrorHandling.py` 文件。
- en: 'Alter your script to include a `try`/`except` block:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改你的脚本以包含一个 `try`/`except` 块：
- en: '[PRE4]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Save and run the script. You should see the simple message `Error`. That's not
    any more helpful than the output we received in our first recipe. In fact, it's
    even less useful. However, the point of this recipe is simply to introduce you
    to the `try`/`except` error handling structure.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并运行脚本。你应该看到简单的消息 `Error`。这并不比我们在第一个菜谱中收到的输出更有帮助。事实上，它甚至更没有用。然而，这个菜谱的目的仅仅是向你介绍
    `try`/`except` 错误处理结构。
- en: How it works…
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: This is an extremely simple structure. The `try` block indicates that everything
    indented under the `try` statement will be subject to exception handling. If an
    exception of any type is found, control of the code processing jumps to the `except`
    section and prints the error message(s), which in this case is simply `Error`.
    Now, as I mentioned, this is hardly informative to your users, but hopefully it
    gives you a basic idea of how `try`/`except` blocks work, and as a programmer
    you will better understand any errors reported by your users. In the next recipe,
    you'll learn how to add tool-generated messages to this structure.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个极其简单的结构。`try` 块表示 `try` 语句下缩进的任何内容都将受到异常处理的影响。如果找到任何类型的异常，代码处理的控制将跳转到 `except`
    部分，并打印错误消息（在这种情况下是简单的 `Error`）。正如我提到的，这对用户来说几乎没有任何信息量，但希望这能给你一个基本的想法，了解 `try`/`except`
    块是如何工作的，并且作为程序员，你将更好地理解用户报告的任何错误。在下一个菜谱中，你将学习如何向这个结构添加工具生成的消息。
- en: There's more…
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The other type of `try` statement is the `try`/`finally` statement, which allows
    for finalization actions. When a `finally` clause is used in a `try` statement,
    its block of statements always run at the very end, whether an error condition
    occurs or not. The `try`/`finally` statement works as follows. If an exception
    occurs, Python runs the `try` block, then the `finally` block, and then execution
    continues past the entire `try` statement. If an exception does not occur during
    execution, Python runs the `try` block, then the `finally` block, and then execution
    is passed back to a higher level `try` statement. This is useful when you want
    to make sure an action takes place after a code block runs regardless of whether
    or not an error condition occurs.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种类型的`try`语句是`try`/`finally`语句，它允许执行最终化操作。当在`try`语句中使用`finally`子句时，其语句块总是在最后执行，无论是否发生错误条件。`try`/`finally`语句的工作方式如下。如果发生异常，Python将运行`try`块，然后运行`finally`块，然后执行继续到整个`try`语句之后。如果在执行过程中没有发生异常，Python将运行`try`块，然后运行`finally`块，然后执行返回到更高级别的`try`语句。这在确保代码块运行后无论是否发生错误条件都要执行某些操作时非常有用。
- en: Retrieving tool messages with GetMessages()
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 GetMessages() 获取工具消息
- en: ArcPy includes a `GetMessages()` function that you can use to retrieve messages
    generated when an ArcGIS tool is executing. Messages can include informational
    messages, such as the start and ends times of a tool execution as well as warnings
    and errors, which can result in something less than the desired result or complete
    failure of the tool to execute to completion.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: ArcPy 包含一个`GetMessages()`函数，你可以使用它来检索在 ArcGIS 工具执行时生成的消息。消息可以包括信息性消息，例如工具执行的开始和结束时间，以及警告和错误，这些可能导致结果不如预期或工具执行失败。
- en: Getting ready
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: During the execution of a tool, various messages are generated. These messages
    include informational messages, such as the start and end times of a tool execution,
    parameter values passed to the tool, and progress information. In addition, warnings
    and errors can also be generated by the tool. These messages can be read by your
    Python script, and your code can be designed to appropriately handle any warnings
    or errors that have been generated.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在工具执行过程中，会生成各种消息。这些消息包括信息性消息，例如工具执行的开始和结束时间、传递给工具的参数值以及进度信息。此外，工具还可以生成警告和错误。这些消息可以通过你的Python脚本读取，并且你可以设计代码来适当地处理已生成的任何警告或错误。
- en: ArcPy stores the messages from the last tool that was executed and you can retrieve
    these messages using the `GetMessages()` function, which returns a single string
    containing all messages from the tool that was last executed. You can filter this
    string by severity to return only certain types of messages, such as warnings
    or errors. The first message will always include the name of the tool executed,
    and the last message is the start and end time.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: ArcPy 存储了最后执行的工具的消息，你可以使用`GetMessages()`函数检索这些消息，该函数返回一个包含最后执行的工具所有消息的单个字符串。你可以通过严重性过滤这个字符串，以返回仅包含某些类型的消息，例如警告或错误。第一条消息将始终包含执行的工具的名称，最后一条消息是开始和结束时间。
- en: In this recipe, you will add a line of code to the `except` statement, which
    will print more descriptive information about the current tool run.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将在`except`语句中添加一行代码，这将打印关于当前工具运行更详细的信息。
- en: How to do it…
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Follow these steps to learn how to add a `GetMessages()` function to your script
    that generates a list of messages from the tool last executed.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤学习如何将`GetMessages()`函数添加到你的脚本中，以生成来自最后执行的工具的消息列表。
- en: If necessary, open the `c:\ArcpyBook\Ch12\ErrorHandling.py` file in IDLE.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果需要，在 IDLE 中打开`c:\ArcpyBook\Ch12\ErrorHandling.py`文件。
- en: 'Alter your script to include the `GetMessages()` function:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改你的脚本以包含`GetMessages()`函数：
- en: '[PRE5]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Save and run the script. This time, the error message should be much more informative.
    Also notice that there are other types of messages that are generated including
    the start and end times of the script''s execution:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并运行脚本。这次，错误消息应该更加详细。同时请注意，还会生成其他类型的消息，包括脚本执行的开始和结束时间：
- en: '[PRE6]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: How it works…
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `GetMessages()` function returns all the messages generated by the last
    tool that was run. I want to emphasize that it only returns messages from the
    last tool that was run. Keep this in mind if you have a script with multiple tools
    that are being run. Historical tool run messages are not accessible through this
    function. However, there is a `Result` object that you can use if you need to
    retrieve historical tool run messages.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetMessages()` 函数返回最后运行的工具生成的所有消息。我想强调的是，它只返回最后运行的工具的消息。如果您有一个运行多个工具的脚本，请记住这一点。通过此函数无法访问历史工具运行消息。然而，如果您需要检索历史工具运行消息，可以使用
    `Result` 对象。'
- en: Filtering tool messages by severity level
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过严重程度级别过滤工具消息
- en: As I mentioned in the last recipe, all tools generate a number of messages that
    can be classified as information, warning, or error messages. The `GetMessages()`
    method accepts a parameter that allows you to filter the messages that are returned.
    For example, you may not be interested in the informative or warning messages
    in your script. However, you are certainly interested in error messages as they
    indicate a fatal error that will not allow a tool to successfully execute. Using
    `GetMessages()`, you can filter the returned message to only error messages.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在上一个菜谱中提到的，所有工具都会生成一些可以被归类为信息、警告或错误消息的消息。`GetMessages()` 方法接受一个参数，允许您过滤返回的消息。例如，您可能对脚本中的信息或警告消息不感兴趣。然而，您当然对错误消息感兴趣，因为它们表明了一个致命的错误，这将阻止工具成功执行。使用
    `GetMessages()`，您可以过滤返回的消息，只保留错误消息。
- en: Getting ready
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Messages are classified into one of the three types, which are indicated by
    a severity level. **Informational messages** provide descriptive information concerning
    things such as a tools progress, start and end times of the tool, output data
    characteristics, and much more. The severity level of an informational message
    is indicated by a value of `0`. **Warning messages** are generated when a problem
    has occurred during execution that may affect the output. Warnings are indicated
    with a severity level of `1` and don't normally stop a tool from running. The
    last type of message is an **error message**, which is indicated with a numeric
    value of `2`. These indicate fatal events that prevent a tool from running. Multiple
    messages may be generated during the execution of a tool, and these are stored
    in a list. More information about message severity levels is provided in the following
    image. In this recipe, you will learn how to filter the messages generated by
    the `GetMessages()` function.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 消息被归类为三种类型之一，这些类型由严重程度级别指示。**信息性消息**提供了有关工具进度、工具的开始和结束时间、输出数据特征等方面的描述性信息。信息性消息的严重程度级别由
    `0` 的值表示。**警告消息**在执行过程中发生问题时生成，可能会影响输出。警告由 `1` 的严重程度级别表示，通常不会阻止工具运行。最后一种消息是**错误消息**，由
    `2` 的数值表示。这些表示阻止工具运行的事件。在工具执行过程中可能会生成多个消息，这些消息被存储在一个列表中。有关消息严重程度级别的更多信息，请参阅以下图像。在本菜谱中，您将学习如何过滤
    `GetMessages()` 函数生成的消息。
- en: '![Getting ready](img/4445OT_Chapter_12_01.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作](img/4445OT_Chapter_12_01.jpg)'
- en: How to do it…
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: Filtering the messages returned by a tool is really quite simple. You simply
    provide the severity level you'd like to return as a parameter to the `GetMessages()`
    function.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤工具返回的消息实际上非常简单。您只需将您希望返回的严重程度级别作为参数传递给 `GetMessages()` 函数。
- en: If necessary, open the `c:\ArcpyBook\Ch12\ErrorHandling.py` file in IDLE.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果需要，请在 IDLE 中打开 `c:\ArcpyBook\Ch12\ErrorHandling.py` 文件。
- en: 'Alter the `GetMessages()` function so that you pass in a value of `2` as the
    only parameter:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 `GetMessages()` 函数，使其只传递 `2` 作为唯一参数：
- en: '[PRE7]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Save and run the script to see the output:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并运行脚本以查看输出：
- en: '[PRE8]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: How it works…
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: As I mentioned, the `GetMessages()` method can accept an integer argument of
    `0`, `1`, or `2`. Passing a value of `0` indicates that all messages should be
    returned, while passing a value of `1` indicates that you wish to see warnings.
    In our case, we have passed a value of `2`, which indicates that we only want
    to see error messages. Therefore, you won't see any of the other information messages,
    such as the start and end times of the script.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我提到的，`GetMessages()` 方法可以接受 `0`、`1` 或 `2` 的整数参数。传递 `0` 的值表示应返回所有消息，而传递 `1`
    的值表示您希望看到警告。在我们的情况下，我们传递了一个 `2` 的值，这表示我们只想看到错误消息。因此，您将看不到其他任何信息消息，例如脚本的开始和结束时间。
- en: Testing for and responding to specific error messages
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试并响应特定错误信息
- en: All errors and warnings generate a specific error code. It is possible to check
    for specific error codes in your scripts and perform some type of action based
    on these errors. This can make your scripts even more versatile.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的错误和警告都会生成一个特定的错误代码。你可以在脚本中检查特定的错误代码，并根据这些错误执行某些操作。这可以使你的脚本更加灵活。
- en: Getting ready…
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中…
- en: 'All errors and warnings generated by a geoprocessing tool contain both a six
    digit code and a description.Your script can test for specific error codes and
    respond accordingly.You can get a listing of all the available error messages
    and codes in the ArcGIS Desktop help system by going to **Geoprocessing** | **Tool
    errors and warnings**.This is illustrated in the following screenshot.All errors
    will have a unique page that briefly describes the error by code number:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 由地理处理工具生成的所有错误和警告都包含一个六位代码和描述。你的脚本可以测试特定的错误代码并相应地做出反应。你可以在ArcGIS桌面帮助系统中通过访问**地理处理**
    | **工具错误和警告**来获取所有可用错误消息和代码的列表。这在下图中得到了说明。所有错误都将有一个独特的页面，简要描述错误代码：
- en: '![Getting ready…](img/4445_12_1.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![准备中…](img/4445_12_1.jpg)'
- en: How to do it…
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Follow these steps to learn how to write a code that responds to specific error
    code generated by the execution of a geoprocessing tool:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤学习如何编写一个响应由地理处理工具执行生成的特定错误代码的代码：
- en: Open the ArcGIS Desktop help system by going to **Start** | **Programs** | **ArcGIS**
    | **ArcGIS for Desktop Help**.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过访问**开始** | **程序** | **ArcGIS** | **ArcGIS for Desktop帮助**来打开ArcGIS桌面帮助系统。
- en: 'Go to **Geoprocessing** | **Tool errors and warnings** | **Tool errors 1-10000**
    |**Tool errors and warnings: 701-800**.'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往**地理处理** | **工具错误和警告** | **工具错误 1-10000** | **工具错误和警告：701-800**。
- en: 'Select **000735: <value>: Value is required**.This error indicates that a parameter
    required by the tool has not been provided.You’ll recall from running this script
    that we have not provided the buffer distance and that the error message generated,
    as a result, contains the error code that we are viewing in the help system.In
    the following code, you will find the full text of the error message.Notice the
    error code.'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '选择**000735: <value>: 值是必需的**。这个错误表示工具所需的参数尚未提供。你会记得在运行此脚本时，我们没有提供缓冲距离，因此生成的错误消息包含我们在帮助系统中查看的错误代码。在下面的代码中，你会找到错误消息的完整文本。注意错误代码。'
- en: '[PRE9]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If necessary, open the `c:\ArcpyBook\Ch12\ErrorHandling.py` file in IDLE.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果需要，在IDLE中打开`c:\ArcpyBook\Ch12\ErrorHandling.py`文件。
- en: 'In your script, alter the `except` statement, so that it appears as follows:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的脚本中，修改`except`语句，使其如下所示：
- en: '[PRE10]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Save and run the script.You should see various messages printed, as follows:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并运行脚本。你应该会看到各种消息被打印出来，如下所示：
- en: '[PRE11]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: How it works…
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: What you’ve done in this code block is use the `arcpy.GetReturnCode()` function
    to return the error code generated by the tool.Then, an `if` statement is used
    to test if the error code contains the value `735`, which is the code that indicates
    that a required parameter has not been provided to the tool.You then provided
    a default value for the buffer distance and called the `Buffer` tool again; providing
    the default buffer value this time.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码块中，你所做的是使用`arcpy.GetReturnCode()`函数来返回工具生成的错误代码。然后，使用一个`if`语句来测试错误代码是否包含值`735`，这个代码表示工具未提供所需的参数。你随后为缓冲距离提供了一个默认值，并再次调用了`Buffer`工具；这次提供了默认的缓冲值。
- en: Returning individual messages with GetMessage()
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用GetMessage()返回单个消息
- en: While `GetMessages()` returns a list containing all messages from the last tool
    run, you can also get individual messages from the string using `GetMessage()`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`GetMessages()`返回一个包含最后一次工具运行中所有消息的列表，但你也可以使用`GetMessage()`从字符串中获取单个消息。
- en: Getting ready
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: 'Up to this point, we have been returning all messages generated by the tool.
    However, you can return individual messages to your user through the `GetMessage()`
    method, which takes an integer as a parameter indicating the particular message
    you''d like to retrieve. Each message generated by the tool is placed into a message
    list or array. We discussed list objects earlier in the book, so you''ll remember
    that this is just a collection of some type of object. Just as a reminder: lists
    are zero-based, meaning that the first item in the list is located at position
    `0`. For example, `GetMessage(0)` would return the first message in the list,
    while `GetMessage(1)` would return the second message in the list. The first message
    will always be the tool being executed along with any parameters. The second message
    returns the start time of the script, while the last message returns the end time
    of the script.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在返回工具生成的所有消息。然而，你可以通过 `GetMessage()` 方法将单个消息返回给用户，该方法接受一个整数参数，表示你想要检索的特定消息。工具生成的每个消息都被放置在一个消息列表或数组中。我们在本书前面讨论了列表对象，所以你会记得这只是一个某种对象的集合。提醒一下：列表是从零开始的，意味着列表中的第一个元素位于位置
    `0`。例如，`GetMessage(0)` 会返回列表中的第一条消息，而 `GetMessage(1)` 会返回列表中的第二条消息。第一条消息总是执行的工具以及任何参数。第二条消息返回脚本的开始时间，而最后一条消息返回脚本的结束时间。
- en: How to do it...
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: If necessary, open the `c:\ArcpyBook\Ch12\ErrorHandling.py` file in IDLE.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果需要，在 IDLE 中打开 `c:\ArcpyBook\Ch12\ErrorHandling.py` 文件。
- en: 'Alter the `except` block as follows:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 `except` 块如下：
- en: '[PRE12]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Save and run the script to see the output:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并运行脚本以查看输出：
- en: '[PRE13]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: How it works...
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'We haven''t covered the `GetMessageCount()` function yet. This function returns
    the number of messages returned by the tool. Remember that our list of messages
    is zero-based, so we have to subtract one from the `GetMessageCount()`function
    to arrive at the last message in the list. Otherwise, we''d be attempting to access
    a message that does not exist. In this script, we have accessed the start and
    end times of the script. The second message is always the start time for the script,
    while the last message will always be the end time of the script. This concept
    is illustrated as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有介绍 `GetMessageCount()` 函数。这个函数返回工具返回的消息数量。请记住，我们的消息列表是从零开始的，所以我们必须从 `GetMessageCount()`
    函数中减去一，才能得到列表中的最后一条消息。否则，我们会尝试访问一个不存在的消息。在这个脚本中，我们已经访问了脚本的开始和结束时间。第二条消息总是脚本的开始时间，而最后一条消息总是脚本的结束时间。这个概念如下所示：
- en: '[PRE14]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Total message count is `6`, but the last message is number `5`. This is because
    the count starts with `0`. This is why you need to subtract `1` as stated previously.
    In this case, the start and end times are the same, because the script contains
    an error. However, it does illustrate how to access the individual messages generated
    by the tool.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 消息总数为 `6`，但最后一条消息是编号 `5`。这是因为计数从 `0` 开始。这就是为什么你需要减去 `1`，如前所述。在这种情况下，开始和结束时间相同，因为脚本中包含了一个错误。然而，它确实说明了如何访问工具生成的单个消息。
- en: Appendix A. Automating Python Scripts
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录 A. 自动化 Python 脚本
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下菜谱：
- en: Running Python scripts from the command line
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从命令行运行 Python 脚本
- en: Using sys.argv[] to capture command-line input
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 sys.argv[] 捕获命令行输入
- en: Adding Python scripts to batch files
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 Python 脚本添加到批处理文件中
- en: Scheduling batch files to run at prescribed times
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安排批处理文件在指定时间运行
- en: Introduction
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Python geoprocessing scripts can be executed either outside ArcGIS as a standalone
    script or inside ArcGIS as a script tool. Both methods have their advantages and
    disadvantages. Up to this point in the book, all our scripts have been run either
    inside ArcGIS as a script tool, or from a Python development environment such
    as IDLE, or the Python Window in ArcGIS. However, Python scripts can also be executed
    from the Windows operating system command line. The command line is a window that
    you can use to type in commands rather than the usual point-and-click approach
    provided by Windows. This method of running Python scripts is useful for scheduling
    the execution of a script. There are a number of reasons why you might want to
    schedule your scripts. Many geoprocessing scripts take a long time to fully execute
    and need to be scheduled to run during non-working hours on a regular basis. Additionally,
    some scripts need to be executed on a routine basis (every day, week, month, and
    so on), and should be scheduled for efficiency. In this chapter, you will learn
    how to execute scripts from the command line, place scripts inside batch files,
    and schedule the execution of scripts at prescribed times. Please keep in mind
    that any scripts run from the command line will still need access to an ArcGIS
    Desktop license in order to use the `arcpy` module.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Python 地理处理脚本可以作为独立脚本在 ArcGIS 外部执行，也可以作为脚本工具在 ArcGIS 内部执行。这两种方法都有其优点和缺点。到这本书的这一部分，我们所有的脚本要么在
    ArcGIS 内部作为脚本工具运行，要么从 Python 开发环境（如 IDLE 或 ArcGIS 中的 Python 窗口）运行。然而，Python 脚本也可以从
    Windows 操作系统命令行执行。命令行是一个你可以输入命令的窗口，而不是 Windows 提供的通常的点按和点击方法。运行 Python 脚本的方法对于安排脚本的执行非常有用。你可能有很多理由想要安排你的脚本。许多地理处理脚本需要很长时间才能完全执行，并且需要定期在工作时间之外安排运行。此外，一些脚本需要定期执行（每天、每周、每月等），并且应该为了效率而安排。在本章中，你将学习如何从命令行执行脚本，将脚本放入批处理文件中，并在指定的时间安排脚本的执行。请记住，任何从命令行运行的脚本仍然需要访问
    ArcGIS Desktop 许可证才能使用 `arcpy` 模块。
- en: Running Python scripts from the command line
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从命令行运行 Python 脚本
- en: Up to this point in the book, all your Python scripts have been run as either
    script tools in ArcGIS or from a Python development environment. The Windows command
    prompt provides yet another way of executing your Python scripts. The command
    prompt is used primarily to execute scripts that will be run as a part of a batch
    file and/or as scheduled tasks.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 到这本书的这一部分，你所有的 Python 脚本都作为 ArcGIS 中的脚本工具或从 Python 开发环境（如 IDLE 或 ArcGIS 中的 Python
    窗口）运行。Windows 命令提示符提供了执行你的 Python 脚本的另一种方式。命令提示符主要用于执行作为批处理文件的一部分运行或作为计划任务的脚本。
- en: Getting ready
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: There are a couple of advantages to running Python geoprocessing scripts from
    the command prompt. These scripts can be scheduled to batch process your data
    during off hours for more efficient processing, and they are easier to debug due
    to the built-in Python error handling and debugging capabilities.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 从命令提示符运行 Python 地理处理脚本有几个优点。这些脚本可以安排在非工作时间批量处理你的数据，以提高处理效率，并且由于内置的 Python 错误处理和调试功能，它们更容易调试。
- en: In this recipe, you will learn how to use the Windows command prompt to execute
    a Python script. You will need administrative rights to complete this recipe,
    so you may need to contact your information technology support group to make this
    change.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将学习如何使用 Windows 命令提示符来执行 Python 脚本。你需要管理员权限来完成这个菜谱，因此你可能需要联系你的信息技术支持团队来做出这个更改。
- en: How to do it…
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Follow these steps to learn how to run a script from the Windows command prompt:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤学习如何在 Windows 命令提示符中运行脚本：
- en: In Windows, go to **Start** | **All Programs** | **Accessories** | **Command
    Prompt** to display a window similar to the following screenshot:![How to do it…](img/4445_A1_1.jpg)
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Windows 中，转到 **开始** | **所有程序** | **附件** | **命令提示符** 以显示一个类似于以下截图的窗口：![如何操作…](img/4445_A1_1.jpg)
- en: The window will display the current directory. Your directory will differ to
    some degree. Let's change to the directory for this appendix.
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 窗口将显示当前目录。你的目录可能会有所不同。让我们更改到本附录的目录。
- en: Type `cd c:\ArcpyBook\Appendix1`.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入 `cd c:\ArcpyBook\Appendix1`。
- en: Type dir to see a listing of the files and sub-directories. You should see only
    a single Python file called `ListFields.py`:![How to do it…](img/4445_A1_2.jpg)
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入 `dir` 以查看文件和子目录的列表。你应该只看到一个名为 `ListFields.py` 的单个 Python 文件：![如何操作…](img/4445_A1_2.jpg)
- en: You will want to make sure that the Python interpreter can be run from anywhere
    in your directory structure. Go to **Start** | **All Programs** | **Accessories**
    | **System Tools** | **Control Panel**.![How to do it…](img/4445_A1_3.jpg)
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保Python解释器可以从目录结构的任何位置运行。转到**开始** | **所有程序** | **附件** | **系统工具** | **控制面板**。![如何操作…](img/4445_A1_3.jpg)
- en: Click on **System and Security**.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**系统和安全**。
- en: Click on **System**.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**系统**。
- en: Click on **Advanced system settings**.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**高级系统设置**。
- en: In the **System Properties** dialog box, select the **Advanced** tab and then
    the **Environment Variables** button as shown in the following screenshot:![How
    to do it…](img/4445_A1_4.jpg)
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**系统属性**对话框中，选择**高级**选项卡，然后点击**环境变量**按钮，如图以下截图所示：![如何操作…](img/4445_A1_4.jpg)
- en: Find the **Path** system variable seen in the screenshot below and click on
    **Edit**.![How to do it…](img/4445_A1_5.jpg)
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下面的截图中找到**路径**系统变量并点击**编辑**。![如何操作…](img/4445_A1_5.jpg)
- en: Examine the entire text string for the directory `c:\Python27\ArcGIS10.1`. If
    the text string isn't found, add it to the end. Make sure that you add a semi-colon
    before adding the path. Now, when you type `python` in the command prompt, it
    will look through each of the directories in the **Path** system variable, checking
    for an executable called `python.exe`.![How to do it…](img/4445_A1_6.jpg)
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查整个文本字符串中是否存在目录`c:\Python27\ArcGIS10.1`。如果找不到文本字符串，请将其添加到末尾。确保在添加路径之前添加一个分号。现在，当你在命令提示符中键入`python`时，它将遍历**路径**系统变量中的每个目录，检查是否存在名为`python.exe`的可执行文件。![如何操作…](img/4445_A1_6.jpg)
- en: Click on **OK** to dismiss the **Edit System Variable** dialog box.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**确定**以关闭**编辑系统变量**对话框。
- en: Click on **OK** to dismiss the **Environment Variables** dialog box.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**确定**以关闭**环境变量**对话框。
- en: Click on **OK** to dismiss the **System Properties** dialog box.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**确定**以关闭**系统属性**对话框。
- en: Return to the command prompt.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到命令提示符。
- en: Type `python ListFields.py`. This will run the `ListFields.py` script. After
    a brief delay, you should see the following output:![How to do it…](img/4445_A1_7.jpg)
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入`python ListFields.py`。这将运行`ListFields.py`脚本。经过短暂的延迟后，你应该会看到以下输出：![如何操作…](img/4445_A1_7.jpg)
- en: How it works…
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The `ListFields.py` script provided for you in this recipe is a simple script
    that lists the attribute fields for the `Burglaries_2009.shp` file. The workspace
    and shapefile name are hardcoded in the script. Typing `python` followed by the
    name of the script, which is `ListFields.py` in this case, triggered the execution
    of a script using the Python interpreter. As I mentioned, the workspace and shapefile
    name were hardcoded in this script. In the next recipe, you will learn how to
    pass in arguments to the script, so that you can remove the hardcoding and make
    your script more flexible.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱中提供的`ListFields.py`脚本是一个简单的脚本，用于列出`Burglaries_2009.shp`文件的属性字段。工作空间和shapefile名称在脚本中是硬编码的。键入`python`后跟脚本名称，在本例中为`ListFields.py`，将触发使用Python解释器执行脚本。如我所述，工作空间和shapefile名称在这个脚本中是硬编码的。在下一个食谱中，您将学习如何向脚本传递参数，以便您可以移除硬编码并使脚本更加灵活。
- en: Using sys.argv[ ] to capture command-line input
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用sys.argv[ ]捕获命令行输入
- en: Instead of hardcoding your scripts with paths to specific datasets, you can
    make your scripts more flexible by allowing them to accept input in the form of
    parameters from the command prompt. These input parameters can be captured using
    Python's `sys.argv[]` object.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 与在脚本中硬编码特定数据集的路径相比，您可以通过允许它们从命令提示符以参数形式接受输入来使您的脚本更加灵活。这些输入参数可以使用Python的`sys.argv[]`对象捕获。
- en: Getting ready
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Python''s `sys.argv[]` object allows you to capture input parameters from the
    command line when a script is executed. An example is useful for illustrating
    how this works. Take a look at the following screenshot:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Python的`sys.argv[]`对象允许您在脚本执行时从命令行捕获输入参数。一个示例可以用来说明它是如何工作的。看看下面的截图：
- en: '![Getting ready](img/4445_A1_8.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作](img/4445_A1_8.jpg)'
- en: Each word must be separated by a space. These words are stored in a zero-based
    list object called `sys.argv[]`. With `sys.argv[]`, the first item in the list,
    referenced by index `0`, stores the name of the script. In this case, it would
    be `ListFields.py`. Each successive word is referenced by the next integer. Therefore,
    the first parameter (`c:\ArcpyBook\data`) will be stored in `sys.argv[1]`, and
    the second parameter (`Burglaries.shp`) will be stored in `sys.argv[2]`. Each
    of the arguments in the `sys.argv[]` object can be accessed and used inside your
    geoprocessing script. In this recipe, you're going to update the `ListFields.py`
    script to accept input parameters from the command line.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 每个单词都必须用空格分隔。这些单词存储在一个名为 `sys.argv[]` 的零基列表对象中。使用 `sys.argv[]`，列表中的第一个项目，通过索引
    `0` 引用，存储脚本的名称。在这种情况下，它将是 `ListFields.py`。每个后续的单词通过下一个整数引用。因此，第一个参数（`c:\ArcpyBook\data`）将存储在
    `sys.argv[1]` 中，第二个参数（`Burglaries.shp`）将存储在 `sys.argv[2]` 中。`sys.argv[]` 对象中的每个参数都可以在您的地理处理脚本中访问和使用。在这个菜谱中，您将更新
    `ListFields.py` 脚本以接受来自命令行的输入参数。
- en: How to do it...
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps to create a Python script that can accept input parameters
    from the command prompt using `sys.argv[]`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建一个 Python 脚本，该脚本可以使用 `sys.argv[]` 从命令提示符接收输入参数：
- en: Open `C:\ArcpyBook\Appendix1\ListFields.py` in IDLE.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 IDLE 中打开 `C:\ArcpyBook\Appendix1\ListFields.py`。
- en: 'Import the `sys` module:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入 `sys` 模块：
- en: '[PRE15]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Create a variable to hold the workspace that will be passed into the script:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个变量来保存将被传递到脚本中的工作空间：
- en: '[PRE16]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Create a variable to hold the feature class that will be passed into the script:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个变量来保存将被传递到脚本中的要素类：
- en: '[PRE17]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Update the lines of code that set the workspace and call the `ListFields()`
    function:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新设置工作空间和调用 `ListFields()` 函数的代码行：
- en: '[PRE18]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Your completed script should appear as follows:'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您完成的脚本应如下所示：
- en: '[PRE19]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Save the script.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存脚本。
- en: If necessary, open the command prompt and navigate to `c:\ArcpyBook\Appendix1`.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如有必要，打开命令提示符并导航到 `c:\ArcpyBook\Appendix1`。
- en: 'On the command line, type the following and press on the *Enter* key:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令行中，键入以下内容并按 *Enter* 键：
- en: '[PRE20]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Once again you should see the output detailing the attribute fields for the
    `Burglaries_2009.shp` file. The difference is that your script no longer has a
    hardcoded workspace and feature class name. You now have a more flexible script
    capable of listing the attribute fields for any feature class.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行后，您应该看到输出详细说明 `Burglaries_2009.shp` 文件的属性字段。不同之处在于您的脚本不再有硬编码的工作空间和要素类名称。现在您有一个更灵活的脚本，能够列出任何要素类的属性字段。
- en: How it works...
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The `sys` module contains a list of objects called `argv[]`, which is used to
    store the input parameters for the command-line execution of a Python script.
    The first item stored in the list is always the name of the script. So, in this
    case, `sys.argv[0]` contains the word `ListFields.py`. Two parameters are passed
    into the script, including the workspace and a feature class. These are stored
    in `sys.argv[1]` and `sys.argv[2]` respectively. These values are then assigned
    to variables and used in the script.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`sys` 模块包含一个名为 `argv[]` 的对象列表，用于存储 Python 脚本命令行执行的输入参数。列表中存储的第一个项目始终是脚本的名称。因此，在这种情况下，`sys.argv[0]`
    包含单词 `ListFields.py`。脚本中传递了两个参数，包括工作空间和要素类。这些值分别存储在 `sys.argv[1]` 和 `sys.argv[2]`
    中。然后，将这些值分配给变量并在脚本中使用。'
- en: Adding Python scripts to batch files
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 Python 脚本添加到批处理文件中
- en: Scheduling your Python scripts to run at prescribed times will require that
    you create a batch file containing one or more scripts and/or operating system
    commands. These batch files can then be added to the Windows Scheduler to run
    at a specific time interval.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 要安排 Python 脚本在指定时间运行，您需要创建一个包含一个或多个脚本和/或操作系统命令的批处理文件。然后，可以将这些批处理文件添加到 Windows
    计划任务中，以便在特定时间间隔内运行。
- en: Getting ready
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Batch files are text files containing command-line sequences for running Python
    scripts or performing operating system commands. They have a file extension of
    `.bat`, which Windows recognizes as an executable file. Since batch files simply
    contain command-line sequences, they can be written with any text editor, though
    it is recommended that you use a basic text editor such as Notepad, so that you
    can avoid the inclusion of invisible special characters, which are sometimes inserted
    by programs such as Microsoft Word. In this recipe, you will create a simple batch
    file that navigates to the directory containing your `ListFields.py` script and
    executes it.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 批处理文件是包含运行 Python 脚本或执行操作系统命令的命令行序列的文本文件。它们具有 `.bat` 文件扩展名，Windows 识别为可执行文件。由于批处理文件仅包含命令行序列，因此可以使用任何文本编辑器编写，尽管建议您使用基本的文本编辑器，如记事本，这样您可以避免由
    Microsoft Word 等程序插入的无形特殊字符。在本食谱中，您将创建一个简单的批处理文件，该文件将导航到包含您的 `ListFields.py` 脚本的目录并执行它。
- en: How to do it...
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps to create a batch file:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建批处理文件：
- en: Open a notepad.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开记事本。
- en: 'Add the following lines of text to the file:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下文本行添加到文件中：
- en: '[PRE21]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Save the file to your desktop as `ListFields.bat`. Make sure you change the
    **Save as Type** drop-down list to **All Files**, or else you'll wind up with
    a file called `ListFields.bat.txt`.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文件保存到您的桌面上，命名为 `ListFields.bat`。确保将 **另存为类型** 下拉列表更改为 **所有文件**，否则您将得到一个名为 `ListFields.bat.txt`
    的文件。
- en: In Windows, navigate to your desktop and double-click on `ListFields.bat` to
    execute the sequence of commands.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Windows 中，导航到您的桌面，双击 `ListFields.bat` 以执行命令序列。
- en: A command prompt will be displayed during execution. After the commands have
    been executed, the command prompt will automatically close.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行过程中将显示命令提示符。在命令执行完毕后，命令提示符将自动关闭。
- en: How it works...
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Windows treats a batch file as an executable, so double-clicking on the file
    will automatically execute the sequence of commands contained within the file
    in a new command prompt window. All `print` statements will be written to the
    window. After the commands have been executed, the command prompt will automatically
    close. In the event that you need to keep track of the output, you can write the
    statements to an output log file.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 将批处理文件视为可执行文件，因此双击文件将自动在新的命令提示符窗口中执行文件中包含的命令序列。所有 `print` 语句都将写入窗口。在命令执行完毕后，命令提示符将自动关闭。如果需要跟踪输出，可以将语句写入输出日志文件。
- en: There's more...
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: Batch files can contain variables, loops, comments, and conditional logic. This
    functionality is beyond the scope of this recipe. However, if you'll be writing
    and running many scripts for your organization, it's worthwhile to spend some
    time learning more about batch files. Batch files have been around for a long
    time, so there is no shortage of information about these files on the Web. For
    more information about batch files, please consult the Wikipedia page for this
    topic.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 批处理文件可以包含变量、循环、注释和条件逻辑。此功能超出了本食谱的范围。然而，如果您将为您的组织编写和运行许多脚本，花些时间学习更多关于批处理文件的知识是值得的。批处理文件已经存在很长时间了，因此关于这些文件的网上信息并不匮乏。有关批处理文件的更多信息，请参阅此主题的维基百科页面。
- en: Scheduling batch files to run at prescribed times
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在指定时间安排批处理文件的运行
- en: Once created, your batch files can then be scheduled to run at prescribed times
    using the Windows Scheduler.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建，您就可以使用 Windows 计划任务在指定时间安排批处理文件的运行。
- en: Getting ready
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Many geoprocessing scripts are time-intensive and best run after hours when
    they can take full advantage of system resources and free up your time to concentrate
    on other tasks. In this recipe, you will learn how to use the Windows Scheduler
    to schedule the execution of your batch files.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 许多地理处理脚本需要大量时间，最好在非工作时间运行，这样它们可以充分利用系统资源，并为您腾出时间来专注于其他任务。在本食谱中，您将学习如何使用 Windows
    计划任务安排批处理文件的执行。
- en: How to do it...
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps to schedule a batch file with the Windows Scheduler:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤使用 Windows 计划任务安排批处理文件：
- en: Open the Windows Scheduler by going to **Start** | **Programs** | **Accessories**
    | **System Tools** | **Control Panel** | **Administrative Tools**. Select **Task
    Scheduler**. The scheduler should appear, as shown in the following screenshot:![How
    to do it...](img/4445_A1_9.jpg)
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过转到 **开始** | **程序** | **附件** | **系统工具** | **控制面板** | **管理工具** 打开 Windows 计划任务。选择
    **任务计划程序**。计划任务应该会像以下截图所示显示：![如何操作...](img/4445_A1_9.jpg)
- en: Select the **Action** menu item and then **Create Basic Task** to display the
    **Create Basic Task Wizard** dialog box, as shown in the next screenshot.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**操作**菜单项，然后**创建基本任务**以显示**创建基本任务向导**对话框，如图下所示。
- en: Give your task a name. In this case, we will call `it List Fields from a Feature
    Class`. Click on **Next**:![How to do it...](img/4445_A1_11.jpg)
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给您的任务起一个名字。在这种情况下，我们将称之为`List Fields from a Feature Class`。点击**下一步**：![如何操作...](img/4445_A1_11.jpg)
- en: Select a trigger for when the task should be executed. This can, and often will
    be, a time-based trigger, but there can also be other types of triggers such as
    a user login or computer start. In this case, let's just select **Daily**. Click
    on **Next**:![How to do it...](img/4445_A1_12.jpg)
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择任务执行时的触发器。这可以是，并且通常会是基于时间的触发器，但也可以有其他类型的触发器，例如用户登录或计算机启动。在这种情况下，让我们只选择**每日**。点击**下一步**：![如何操作...](img/4445_A1_12.jpg)
- en: Select a start date/time as well as a recurrence interval. In the following
    screenshot, I have selected the date as `12/3/2012`, with time as `1:00:00 AM`,
    and a recurrence interval of 1 day. So, every day at 1:00 AM, this task will be
    executed. Click on **Next**:![How to do it...](img/4445_A1_13.jpg)
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个开始日期/时间以及重复间隔。在下面的屏幕截图中，我选择了日期为`12/3/2012`，时间为`1:00:00 AM`，重复间隔为1天。因此，每天凌晨1:00，这个任务将被执行。点击**下一步**：![如何操作...](img/4445_A1_13.jpg)
- en: Select **Start a program** as the action:![How to do it...](img/4445_A1_14.jpg)
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**启动程序**作为操作：![如何操作...](img/4445_A1_14.jpg)
- en: Browse to your script and add the parameters. Click on **Next**:![How to do
    it...](img/4445_A1_15.jpg)
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 浏览到你的脚本并添加参数。点击**下一步**：![如何操作...](img/4445_A1_15.jpg)
- en: Click on **Finish** to add a task to the scheduler:![How to do it...](img/4445_A1_16.jpg)
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**完成**将任务添加到计划程序：![如何操作...](img/4445_A1_16.jpg)
- en: The tasks should now be displayed in the list of active tasks:![How to do it...](img/4445_A1_17.jpg)
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 任务现在应显示在活动任务列表中：![如何操作...](img/4445_A1_17.jpg)
- en: How it works...
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The Windows Task Scheduler keeps track of all the active tasks and handles the
    execution of these tasks when the prescribed trigger is fired. In this recipe,
    we have scheduled our task to execute each day at 1:00 AM. At that time, the batch
    file we created will be triggered and the arguments we specified when creating
    the task will be passed into the script. Using the scheduler to automatically
    execute geoprocessing tasks after hours without the need for GIS staff to interact
    with the scripts gives you more flexibility and increases your efficiency. You
    might also want to consider logging the errors in your Python scripts to a log
    file, for more information about specific problems.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: Windows任务计划程序会跟踪所有活动任务，并在预定触发器被触发时处理这些任务的执行。在这个菜谱中，我们已经安排了任务每天凌晨1:00执行。那时，我们将触发的批处理文件，以及我们在创建任务时指定的参数将被传递到脚本中。使用计划程序在非工作时间自动执行地理处理任务，无需GIS人员与脚本交互，这为您提供了更多的灵活性并提高了效率。您还可能希望考虑将Python脚本的错误记录到日志文件中，以获取有关特定问题的更多信息。
- en: Appendix B. Five Things Every GIS Programmer Should Know How to Do with Python
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录B.每个GIS程序员都应该知道如何用Python做的五件事
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下菜谱：
- en: Reading data from a delimited text file
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从分隔符文本文件中读取数据
- en: Sending e-mails
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送电子邮件
- en: Retrieving files from an FTP server
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从FTP服务器检索文件
- en: Creating ZIP files
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建ZIP文件
- en: Reading XML files
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取XML文件
- en: Introduction
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In this chapter, you will learn how to write scripts that perform general purpose
    tasks with Python. Tasks, such as reading and writing delimited text files, sending
    e-mails, interacting with FTP servers, creating `.zip` files, and reading and
    writing JSON and XML files. Every GIS programmer should know how to write Python
    scripts that incorporate this functionality.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何编写使用Python执行通用任务的脚本。任务，如读取和写入分隔符文本文件、发送电子邮件、与FTP服务器交互、创建`.zip`文件以及读取和写入JSON和XML文件。每个GIS程序员都应该知道如何编写包含此功能的Python脚本。
- en: Reading data from a delimited text file
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从分隔符文本文件中读取数据
- en: File handling with Python is a very important topic for GIS programmers. Text
    files are often used as an interchange format for exchanging data between systems.
    They are simple, cross-platform, and easy to process. Comma-and tab-delimited
    text files are among the most commonly used formats for text files, so we'll take
    an extensive look at the Python tools available for processing these files. A
    common task for GIS programmers is to read comma-delimited text files containing
    x and y coordinates along with other attribute information. This information is
    then converted into GIS data formats, such as shapefiles or geodatabases.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Python 处理文件是 GIS 程序员非常重要的一个话题。文本文件常被用作系统间数据交换的格式。它们简单、跨平台且易于处理。逗号和制表符分隔的文本文件是文本文件中最常用的格式之一，因此我们将详细探讨可用于处理这些文件的
    Python 工具。对于 GIS 程序员来说，一个常见的任务是读取包含 x 和 y 坐标以及其他属性信息的逗号分隔文本文件。然后，这些信息将被转换为 GIS
    数据格式，如 shapefile 或地理数据库。
- en: Getting ready
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To use Python's built-in file processing functionality, you must first open
    the file. Once open, data within the file is processed using functions provided
    by Python, and finally the file is closed. Always remember to close the file when
    you're done.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Python 的内置文件处理功能，您必须首先打开文件。一旦打开，文件内的数据将使用 Python 提供的函数进行处理，最后关闭文件。务必记住，完成操作后关闭文件。
- en: In this recipe, you will learn how to open, read, process, and close a comma-delimited
    text file.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，您将学习如何打开、读取、处理和关闭逗号分隔的文本文件。
- en: How to do it…
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps to create a Python script that reads a comma-delimited text
    file:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建一个读取逗号分隔文本文件的 Python 脚本：
- en: 'In your `c:\ArcpyBook\data` folder, you will find a file called `N_America.A2007275.txt`.
    Open this file in a text editor. It should appear as follows:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的 `c:\ArcpyBook\data` 文件夹中，您将找到一个名为 `N_America.A2007275.txt` 的文件。在文本编辑器中打开此文件。它应如下所示：
- en: '[PRE22]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This file contains wildfire incident data derived from a satellite sensor from
    a single day in 2007\. Each row contains latitude and longitude information for
    the fire along with additional information, including the date and time, the satellite
    type, confidence value, and others. In this recipe, you are going to pull out
    only the latitude, longitude, and confidence value.
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此文件包含来自 2007 年某一天卫星传感器的野火事件数据。每一行包含火灾的纬度和经度信息，以及额外的信息，包括日期和时间、卫星类型、置信值等。在这个菜谱中，您将只提取纬度、经度和置信值。
- en: Open IDLE and create a file called `c:\ArcpyBook\Appendix2\ReadDelimitedTextFile.py`.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 IDLE 并创建一个名为 `c:\ArcpyBook\Appendix2\ReadDelimitedTextFile.py` 的文件。
- en: 'Use the Python `open()` function to open the file for reading:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Python 的 `open()` 函数打开文件以进行读取：
- en: '[PRE23]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Read the content of the text file into a list:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文本文件的内容读取到一个列表中：
- en: '[PRE24]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Add a `for` loop to iterate all the rows that have been read into the `lstFires`
    variable:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向 `lstFires` 变量中读取的所有行添加一个 `for` 循环以迭代：
- en: '[PRE25]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Use the `split()` function to split the values into a list using a comma as
    the delimiter. The list will be assigned to a variable called `lstValues`. Make
    sure that you indent this line of code inside the `for` loop you just created:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `split()` 函数使用逗号作为分隔符将值拆分到一个列表中。这个列表将被分配给一个名为 `lstValues` 的变量。确保将此行代码缩进到您刚刚创建的
    `for` 循环中：
- en: '[PRE26]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Using the index values that reference latitude, longitude, and confidence values,
    create new variables:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用引用纬度、经度和置信值的索引值创建新的变量：
- en: '[PRE27]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Print the values of each with the `print` statement:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `print` 语句打印每个值：
- en: '[PRE28]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Close the file:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭文件：
- en: '[PRE29]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The entire script should appear as follows:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 整个脚本应如下所示：
- en: '[PRE30]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Save and run the script. You should see the following output:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并运行脚本。您应该看到以下输出：
- en: '[PRE31]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: How it works…
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Python's `open()` function creates a file object, which serves as a link to
    a file residing on your computer. You must call the `open()` function on a file
    before reading or writing data in a file. The first parameter for the `open()`
    function is a path to the file you'd like to open. The second parameter of the
    `open()` function corresponds to a mode, which is typically read (`r`), write
    (`w`), or append (`a`). A value of `r` indicates that you'd like to open the file
    for read-only operations, while a value of `w` indicates you'd like to open the
    file for write operations. If the file you open in write mode already exists,
    it will overwrite any existing data in the file, so be careful using this mode.
    Append mode (`a`) will open a file for write operations, but instead of overwriting
    any existing data, it will append data to the end of the file. So, in this recipe,
    we have opened the `N_America.A2007275.txt` file in read-only mode.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: Python的`open()`函数创建一个文件对象，该对象作为链接到您计算机上文件的桥梁。您必须在读取或写入文件数据之前调用`open()`函数。`open()`函数的第一个参数是您想要打开的文件的路径。`open()`函数的第二个参数对应于一个模式，通常是读取（`r`）、写入（`w`）或追加（`a`）。`r`的值表示您想要以只读方式打开文件，而`w`的值表示您想要以写入方式打开文件。如果您以写入模式打开的文件已经存在，它将覆盖文件中的任何现有数据，所以请小心使用此模式。追加模式（`a`）将以写入方式打开文件，但不会覆盖任何现有数据，而是将数据追加到文件末尾。因此，在这个菜谱中，我们以只读模式打开了`N_America.A2007275.txt`文件。
- en: The `readlines()` function then reads the entire contents of the file into a
    Python list, which can then be iterated. This list is stored in a variable called
    `lstFires`. Each row in the text file will be a unique value in the list. Since
    this function reads the entire file into a list, you need to use this method with
    caution, as large files can cause significant performance problems.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`readlines()`函数将整个文件内容读取到一个Python列表中，然后可以迭代这个列表。这个列表存储在一个名为`lstFires`的变量中。文本文件中的每一行都将是一个列表中的唯一值。由于这个函数将整个文件读取到列表中，您需要谨慎使用此方法，因为大文件可能会引起显著的性能问题。
- en: 'Inside the `for` loop, which is used to loop through each of the values in
    `lstFires`, the `split()` function is used to create a list object from a line
    of text that is delimited in some way. Our file is comma-delimited, so we can
    use `split(",")`. You can also split based on other delimiters such as tabs, spaces,
    or any other delimiter. This new list object created by `split()` is stored in
    a variable called `lstValues`. This variable contains each of the wildfire values.
    This is illustrated in the following screenshot. You''ll notice that latitude
    is located in the first position, longitude is located in the second position,
    and so on. Lists are zero based:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在`for`循环内部，该循环用于遍历`lstFires`中的每个值，使用`split()`函数从某种方式分隔的文本行创建一个列表对象。我们的文件是逗号分隔的，因此我们可以使用`split(",")`。您也可以根据其他分隔符（如制表符、空格或任何其他分隔符）进行分割。由`split()`创建的新列表对象存储在一个名为`lstValues`的变量中。这个变量包含每个野火值。这在上面的屏幕截图中有说明。您会注意到纬度位于第一个位置，经度位于第二个位置，依此类推。列表是从零开始的：
- en: '![How it works…](img/4445_A2_1.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理…](img/4445_A2_1.jpg)'
- en: Using the index values (which reference latitude, longitude, and confidence
    values), we create new variables called `latitude`, `longitude`, and `confid`.
    Finally, we print each of the values. A more robust geoprocessing script might
    write this information into a feature class using an `InsertCursor` object.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 使用索引值（这些值参考纬度、经度和置信度），我们创建了新的变量，分别称为`latitude`、`longitude`和`confid`。最后，我们打印出每个值。一个更健壮的地理处理脚本可能会使用`InsertCursor`对象将此信息写入一个要素类。
- en: There's more...
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Just as is the case with reading files, there are a number of methods that you
    can use to write data to a file. The `write()` function is probably the easiest
    to use. It takes a single string argument and writes it to a file. The `writelines()`
    function can be used to write the contents of a list structure to a file. Before
    writing data to a text file, you will need to open the file in either a write
    or append mode.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 正如读取文件的情况一样，有几种方法可以将数据写入文件。`write()`函数可能是最容易使用的。它接受一个字符串参数并将其写入文件。`writelines()`函数可以用来将列表结构的内容写入文件。在将数据写入文本文件之前，您需要以写入或追加模式打开文件。
- en: Sending e-mails
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发送电子邮件
- en: There will be occasions when you may need to send an e-mail from a Python script.
    An example might be an alert for the successful completion or error in a long-running
    geoprocessing operation. On these and other occasions, sending an e-mail can be
    helpful.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，您可能需要从Python脚本中发送电子邮件。一个例子可能是对于长时间运行的地理处理操作的完成或错误警报。在这些和其他情况下，发送电子邮件可能会有所帮助。
- en: Getting ready
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Sending an e-mail through a Python script will require that you have access
    to a mail server. This can be a public e-mail service, such as Yahoo, Gmail, or
    others. It can also use outgoing mail servers configured with applications, such
    as Microsoft Outlook. In either case, you'll need to know the host name and port
    of the e-mail server. The Python `smtplib` module is used to create connections
    to the mail server and to send e-mails.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 通过Python脚本发送电子邮件需要您有权访问邮件服务器。这可以是一个公共电子邮件服务，例如Yahoo、Gmail或其他服务。它也可以使用配置了应用程序的出站邮件服务器，例如Microsoft
    Outlook。在任一情况下，您都需要知道电子邮件服务器的主机名和端口号。Python的`smtplib`模块用于创建与邮件服务器的连接并发送电子邮件。
- en: The Python `email` module contains a `Message` class that represents e-mail
    messages. Each message contains both headers and a body. This class can't be used
    to send e-mails; it just handles its object representation. In this recipe, you'll
    learn how to use the `smtp` class to send e-mails containing an attachment through
    your script. The `Message` class can parse a stream of characters or a file containing
    an e-mail using either the `message_from_file()` or `message_from_string()` functions.
    Both will create a new `Message` object. The body of the mail can be obtained
    by calling `Message.getpayload()`.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: Python的`email`模块包含一个`Message`类，该类表示电子邮件消息。每个消息都包含标题和正文。此类不能用于发送电子邮件；它只是处理其对象表示。在本菜谱中，您将学习如何使用`smtp`类通过脚本发送包含附件的电子邮件。`Message`类可以使用`message_from_file()`或`message_from_string()`函数解析字符流或包含电子邮件的文件。两者都将创建一个新的`Message`对象。可以通过调用`Message.getpayload()`来获取邮件的正文。
- en: Note
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We are using the Google Mail service for this exercise. If you already have
    a Gmail account, then simply provide your username and password as the values
    for these variables. If you don't have a Gmail account, you'll need to create
    one or use a different mail service to complete this exercise; Gmail accounts
    are free.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个练习中使用Google Mail服务。如果您已经有了Gmail账户，那么只需简单地提供用户名和密码作为这些变量的值。如果您没有Gmail账户，您需要创建一个或使用不同的邮件服务来完成这个练习；Gmail账户是免费的。
- en: How to do it…
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Follow these steps to create a script that can send emails:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建一个可以发送电子邮件的脚本：
- en: Open IDLE and create a file called `c:\ArcpyBook\Appendix2\SendEmail.py`.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开IDLE并创建一个名为`c:\ArcpyBook\Appendix2\SendEmail.py`的文件。
- en: 'In order to send e-mails with attachments, you''re going to need to import
    the `smtplib` module along with the `os` module, and several classes from the
    e-mail module. Add the following `import` statements to your script:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了发送带有附件的电子邮件，您需要导入`smtplib`模块以及`os`模块，以及电子邮件模块中的几个类。将以下`import`语句添加到您的脚本中：
- en: '[PRE32]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Create the following variables and assign your Gmail username and password
    as the values. Do keep in mind that this method of e-mailing from your Python
    script can invite problems, as it requires that you include your username and
    password:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建以下变量，并将您的Gmail用户名和密码作为值分配。请记住，从Python脚本中发送电子邮件的方法可能会引起问题，因为它需要您包含用户名和密码：
- en: '[PRE33]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Create a new Python function called `mail()`. This function will accept four
    parameters: `to`, `subject`, `text`, and `attach`. Each of these parameters should
    be self-explanatory. Create a new `MIMEMultipart` object and assign the `from`,
    `to`, and `subject` keys. You can also attach the text of the e-mail to this new
    `msg` object using `MIMEMultipart.attach()`:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的Python函数`mail()`。此函数将接受四个参数：`to`、`subject`、`text`和`attach`。这些参数应该是自解释的。创建一个新的`MIMEMultipart`对象，并将`from`、`to`和`subject`键分配给它。您还可以使用`MIMEMultipart.attach()`将电子邮件文本附加到这个新的`msg`对象：
- en: '[PRE34]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Attach the file to the e-mail:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文件附加到电子邮件：
- en: '[PRE35]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Create a new SMTP object that references the Google Mail service, passes in
    the username and password to connect to the mail services, sends the e-mail, and
    closes the connection:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的SMTP对象，该对象引用Google Mail服务，传递用户名和密码以连接到邮件服务，发送电子邮件，并关闭连接：
- en: '[PRE36]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Call the `mail()` function, passing in the recipient of the e-mail, a subject
    for the e-mail, the text of the e-mail, and the attachment:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`mail()`函数，传入电子邮件的收件人、电子邮件的主题、电子邮件文本和附件：
- en: '[PRE37]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The entire script should appear as follows:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 整个脚本应该如下所示：
- en: '[PRE38]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Save and run the script. For testing, I used my personal Yahoo account as the
    recipient. You'll notice that my inbox has a new message from my Gmail account;
    also notice the attachment:![How to do it…](img/4445_A2_2.jpg)
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并运行脚本。为了测试，我使用了我的个人Yahoo账户作为收件人。你会注意到我的收件箱中有一封来自我的Gmail账户的新消息；也请注意附件：![如何做…](img/4445_A2_2.jpg)
- en: How it works…
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: The first parameter passed into the `mail()` function is the e-mail address
    that will receive the e-mail. This can be any valid e-mail address, but you'll
    want to supply a mail account that you can actually check, so that you can make
    sure your script runs correctly. The second parameter is just the subject line
    of the e-mail. The third parameter is the text of the e-mail. The final parameter
    is the name of a file that will be attached to the e-mail. Here, I've simply defined
    that the `bc_pop1996.csv` file should be attached. You can use any file you have
    access to, but you may want to just use this file for testing.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 将第一个参数传递给`mail()`函数的是将接收电子邮件的电子邮件地址。这可以是任何有效的电子邮件地址，但你希望提供一个你可以实际检查的邮件账户，这样你就可以确保你的脚本运行正确。第二个参数只是电子邮件的主题行。第三个参数是电子邮件的文本内容。最后一个参数是要附加到电子邮件中的文件的名称。在这里，我简单地定义了`bc_pop1996.csv`文件应该被附加。你可以使用你能够访问的任何文件，但你可能只想使用这个文件进行测试。
- en: We then create a new `MIMEMultipart` object inside the `mail()` function, and
    assign the `from`, `to`, and `subject` keys. You can also attach the text of the
    e-mail to this new `msg` object using `MIMEMultipart.attach()`. The `bc_pop1996.csv`
    file is then attached to the e-mail using a `MIMEBase` object and attached to
    the e-mail using `msg.attach(part)`.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在`mail()`函数内部创建一个新的`MIMEMultipart`对象，并分配`from`、`to`和`subject`键。你也可以使用`MIMEMultipart.attach()`将电子邮件的文本附加到这个新的`msg`对象上。然后，使用`MIMEBase`对象将`bc_pop1996.csv`文件附加到电子邮件上，并使用`msg.attach(part)`附加到电子邮件上。
- en: At this point, we've examined how a basic text e-mail can be sent. However,
    we want to send a more complex e-mail message that contains text and an attachment.
    This requires the use of MIME messages, which provides the functionality to handle
    multi-part e-mails. MIME messages need boundaries between the multiple parts,
    along with extra headers to specify the content being sent. The `MIMEBase` class
    is an abstract subclass of `Message` and enables this type of an e-mail to be
    sent. Because it is an abstract class, you can't create actual instances of this
    class. Instead, you use one of the subclasses, such as `MIMEText`. The last step
    of the `mail()` function is to create a new SMTP object that references the Google
    Mail service, passes in the username and password to connect to the mail services,
    sends the e-mail, and closes the connection.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经探讨了如何发送基本的文本电子邮件。然而，我们想要发送一个包含文本和附件的更复杂的电子邮件消息。这需要使用MIME消息，它提供了处理多部分电子邮件的功能。MIME消息需要在多个部分之间有边界，以及额外的头信息来指定发送的内容。《MIMEBase》类是《Message》的抽象子类，使得这种类型的电子邮件可以被发送。因为它是一个抽象类，所以你不能创建这个类的实际实例。相反，你使用其子类之一，例如`MIMEText`。`mail()`函数的最后一步是创建一个新的SMTP对象，该对象引用Google
    Mail服务，传递用户名和密码以连接到邮件服务，发送电子邮件，并关闭连接。
- en: Retrieving files from an FTP server
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从FTP服务器检索文件
- en: Retrieving files from an FTP server for processing is a very common operation
    for GIS programmers and can be automated with a Python script.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 从FTP服务器检索文件进行处理的操作对于GIS程序员来说非常常见，并且可以使用Python脚本来自动化。
- en: Getting ready
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Connecting to an FTP server and downloading a file is accomplished through the
    `ftplib` module. A connection to an FTP server is created through the FTP object,
    which accepts a host, username, and password to create the connection. Once a
    connection has been opened, you can then search for and download files.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`ftplib`模块实现连接到FTP服务器并下载文件。通过FTP对象创建对FTP服务器的连接，该对象接受主机、用户名和密码以创建连接。一旦打开连接，你就可以搜索和下载文件。
- en: In this recipe, you will connect to the National Interagency Fire Center Incident
    FTP site and download a Google Earth format file for a wildfire in Alaska.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将连接到国家间机构火灾中心事件FTP站点，并下载一个阿拉斯加野火的Google Earth格式文件。
- en: How to do it…
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Follow these steps to create a script that connects to an FTP server and downloads
    a file:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建一个连接到FTP服务器并下载文件的脚本：
- en: Open IDLE and create a file called `c:\ArcpyBook\Appendix2\ftp.py`.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开IDLE并创建一个名为`c:\ArcpyBook\Appendix2\ftp.py`的文件。
- en: We'll be connecting to an FTP server at the NIFC. Visit their website at [http://ftpinfo.nifc.gov/](http://ftpinfo.nifc.gov/)
    for more information.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将连接到NIFC的FTP服务器。访问他们的网站[http://ftpinfo.nifc.gov/](http://ftpinfo.nifc.gov/)获取更多信息。
- en: 'Import the `ftplib`, `os`, and so`c`ket modules:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`ftplib`、`os`和`socket`模块：
- en: '[PRE39]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Add the following variables that define the URL, directory, and filename:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下变量，以定义URL、目录和文件名：
- en: '[PRE40]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Add the following code block to create a connection. If there is a connection
    error, a message will be generated. If the connection was successful, a success
    message will be printed:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码块以创建连接。如果发生连接错误，将生成一条消息。如果连接成功，将打印成功消息：
- en: '[PRE41]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Add the following code block to anonymously log in to the server:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码块以匿名登录到服务器：
- en: '[PRE42]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Add the following code block to change to the directory specified in our `DIRN`
    variable:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码块以切换到`DIRN`变量中指定的目录：
- en: '[PRE43]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Use the `FTP.retrbinary()` function to retrieve the KMZ file:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`FTP.retrbinary()`函数检索KMZ文件：
- en: '[PRE44]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Make sure you disconnect from the server:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保您从服务器断开连接：
- en: '[PRE45]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The entire script should appear as follows:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 整个脚本应如下所示：
- en: '[PRE46]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Save and run the script. If everything is successful, you should see the following
    output:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并运行脚本。如果一切顺利，您应该看到以下输出：
- en: '[PRE47]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Check your `c:\ArcpyBook\Appendix2` directory for the file. By default, FTP
    will download files to the current working directory:![How to do it…](img/4445_A2_3.jpg)
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查您的`c:\ArcpyBook\Appendix2`目录中的文件。默认情况下，FTP会将文件下载到当前工作目录：![如何操作……](img/4445_A2_3.jpg)
- en: How it works…
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: To connect to an FTP server, you need to know the URL. You also need to know
    the directory and filename for the file that will be downloaded. In this script,
    we have hardcoded this information, so that you can focus on implementing the
    FTP-specific functionality. Using this information we then created a connection
    to the NIFC FTP server. This is done through the `ftplib.FTP()` function, which
    accepts a URL to the host.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 要连接到FTP服务器，您需要知道URL。您还需要知道将要下载的文件的目录和文件名。在这个脚本中，我们硬编码了这些信息，这样您可以专注于实现FTP特定的功能。使用这些信息，我们随后创建了一个连接到NIFC
    FTP服务器。这是通过`ftplib.FTP()`函数完成的，该函数接受主机的URL。
- en: Anonymous logins are accepted by the `nifc.gov` server, so we connect to the
    server in this manner. Keep in mind that if a server does not accept anonymous
    connections, you'll need to obtain a username/password. Once logged in, the script
    then changes directories from the root of the FTP server to the path defined in
    the `DIRN` variable. This was accomplished with the `cwd(<path>)` function. The
    `kmz` file was retrieved using the `retrbinary()` function. Finally, you will
    want to close your connection to the FTP server when you're done. This is done
    with the `quit()` method.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '`nifc.gov`服务器接受匿名登录，因此我们以这种方式连接到服务器。请注意，如果服务器不接受匿名连接，您将需要获取用户名/密码。一旦登录，脚本随后将FTP服务器的根目录更改为`DIRN`变量中定义的路径。这是通过`cwd(<path>)`函数实现的。使用`retrbinary()`函数检索了`kmz`文件。最后，您将想要在完成操作后关闭与FTP服务器的连接。这是通过`quit()`方法完成的。'
- en: There's more…
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多……
- en: There are a number of additional FTP-related methods that you can use to perform
    various actions. Generally, these can be divided into directory-level operations
    and file-level operations. Directory-level methods include the `dir()` method
    to obtain a list of files in a directory, `mkd()` to create a new directory, `pwd()`
    to get the current working directory, and `cwd()` to change the current directory.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多额外的FTP相关方法，您可以使用它们执行各种操作。通常，这些可以分为目录级操作和文件级操作。目录级方法包括`dir()`方法以获取目录中的文件列表，`mkd()`创建新目录，`pwd()`获取当前工作目录，以及`cwd()`更改当前目录。
- en: The `ftplib` module also includes various methods for working with files. You
    can upload and download files in binary or plain text format. The `retrbinary()`
    and `storbinary()` methods are used to retrieve and store binary files, respectively.
    Plain text files can be retrieved and stored using `retrlines()` and `storlines()`.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '`ftplib`模块还包括各种用于文件操作的方法。您可以使用二进制或纯文本格式上传和下载文件。`retrbinary()`和`storbinary()`方法分别用于检索和存储二进制文件。纯文本文件可以使用`retrlines()`和`storlines()`进行检索和存储。'
- en: There are several others methods on the FTP class that you should be aware of.
    Deleting a file can be done with the `delete()` method, while renaming a file
    can be accomplished with `rename()`. You can also send commands to the FTP server
    through the `sendcmd()` method.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: FTP 类还有其他一些方法你应该知道。删除文件可以使用 `delete()` 方法完成，而重命名文件可以使用 `rename()` 方法。你还可以通过
    `sendcmd()` 方法向 FTP 服务器发送命令。
- en: Creating ZIP files
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 ZIP 文件
- en: GIS often requires the use of large files that will be compressed into a `.zip`
    format for ease of sharing. Python includes a module that you can use to decompress
    and compress files in this format.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: GIS 常常需要使用大文件，这些文件将被压缩成 `.zip` 格式以便于共享。Python 包含了一个模块，你可以使用它来解压缩和压缩这种格式的文件。
- en: Getting ready
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Zip is a common compression and archive format and is implemented in Python
    through the `zipfile` module. The `ZipFile` class can be used to create, read,
    and write `.zip` files. To create a new `.zip` file, simply provide the filename
    along with a mode such as `w`, which indicates that you want to write data to
    the file. In the following code example, we are creating a `.zip` file called
    `datafile.zip`. The second parameter, `w`, indicates that a new file will be created.
    A new file will be created or an existing file with the same name will be truncated
    in the write mode. An optional compression parameter can also be used when creating
    the file. This value can be set to either `ZIP_STORED` or `ZIP_DEFLATED`:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: Zip 是一种常见的压缩和存档格式，在 Python 中通过 `zipfile` 模块实现。`ZipFile` 类可以用来创建、读取和写入 `.zip`
    文件。要创建一个新的 `.zip` 文件，只需提供文件名以及一个模式，例如 `w`，这表示你想要向文件中写入数据。在下面的代码示例中，我们正在创建一个名为
    `datafile.zip` 的 `.zip` 文件。第二个参数 `w` 表示将创建一个新文件。在写入模式下，将创建一个新文件，或者如果存在同名文件，则将其截断。在创建文件时还可以使用可选的压缩参数。此值可以设置为
    `ZIP_STORED` 或 `ZIP_DEFLATED`：
- en: '[PRE48]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: In this exercise, you will use Python to create file, add files, and apply compression
    to a `.zip`. You'll be archiving all the shapefiles located in the `c:\ArcpyBook\data`
    directory.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将使用 Python 创建文件、添加文件并对 `.zip` 文件应用压缩。你将存档位于 `c:\ArcpyBook\data` 目录中的所有
    shapefiles。
- en: How to do it…
  id: totrans-316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Follow these steps to learn how to create a script that build a `.zip` file:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤学习如何创建一个构建 `.zip` 文件的脚本：
- en: Open IDLE and create a script called `c:\ArcpyBook\Appendix2\CreateZipfile.py`.
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 IDLE 并创建一个名为 `c:\ArcpyBook\Appendix2\CreateZipfile.py` 的脚本。
- en: 'Import the `zipfile` and `os` modules:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入 `zipfile` 和 `os` 模块：
- en: '[PRE49]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Create a new `.zip` file called `shapefiles.zip` in write mode and add a compression
    parameter:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以写入模式创建一个名为 `shapefiles.zip` 的新 `.zip` 文件并添加一个压缩参数：
- en: '[PRE50]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Next, we''ll use the `os.listdir()` function to create a list of files in the
    data directory:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将使用 `os.listdir()` 函数创建数据目录中的文件列表：
- en: '[PRE51]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Loop through a list of all the files and write to the `.zip` file, if the file
    ends with `shp`, `dbf`, or `shx`:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遍历所有文件的列表，并将以 `shp`、`dbf` 或 `shx` 结尾的文件写入 `.zip` 文件：
- en: '[PRE52]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Print out a list of all the files that were added to the zip archive. You can
    use the ZipFile.namelist() function to create a list of files in the archive:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印出添加到 zip 存档中的所有文件的列表。你可以使用 ZipFile.namelist() 函数创建存档中的文件列表：
- en: '[PRE53]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Close the `.zip` archive:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭 `.zip` 存档：
- en: '[PRE54]'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The entire script should appear as follows:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 整个脚本应如下所示：
- en: '[PRE55]'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Save and run the script. You should see the following output:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并运行脚本。你应该看到以下输出：
- en: '[PRE56]'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: In Windows Explorer, you should be able to see the output `.zip` file as shown
    in the following screenshot. Note the size of the archive. This file was created
    without compression:![How to do it…](img/4445_A2_4.jpg)
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Windows 资源管理器中，你应该能够看到如下截图所示的输出 `.zip` 文件。注意存档的大小。此文件是在没有压缩的情况下创建的：![如何操作…](img/4445_A2_4.jpg)
- en: 'Now, we''re going to create a compressed version of the `.zip` file to see
    the difference. Make the following changes to the line of code that creates the
    `.zip` file:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将创建 `.zip` 文件的压缩版本以查看差异。对创建 `.zip` 文件的代码行进行以下更改：
- en: '[PRE57]'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Save and re-run the script.
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并重新运行脚本。
- en: Take a look at the size of the new `shapefiles2.zip` file that you just created.
    Note the decreased size of the file due to compression:![How to do it…](img/4445_A2_5.jpg)
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看你刚刚创建的新 `shapefiles2.zip` 文件的大小。注意由于压缩导致的文件大小减少：![如何操作…](img/4445_A2_5.jpg)
- en: How it works…
  id: totrans-340
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: In this recipe, you created a new `.zip` file called `shapefiles.zip` in write
    mode. In the first iteration of this script, you didn't compress the contents
    of the file. However, in the second iteration, you did by using the `DEFLATED`
    parameter passed into the constructor for the `ZipFile` object. The script then
    obtained a list of files in the data directory and looped through each of the
    files. Each file that has an extension of `.shp`, `.dbf`, or `.shx` is then written
    to the archive file using the `write()` function. Finally, the names of each of
    the files written to the archive is printed to the screen.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，你以写入模式创建了一个名为 `shapefiles.zip` 的新 `.zip` 文件。在脚本的第一次迭代中，你没有压缩文件的内容。然而，在第二次迭代中，你通过将
    `DEFLATED` 参数传递给 `ZipFile` 对象的构造函数来压缩了文件内容。然后脚本获取数据目录中的文件列表，并遍历每个文件。每个扩展名为 `.shp`、`.dbf`
    或 `.shx` 的文件随后使用 `write()` 函数写入存档文件。最后，将写入存档的每个文件的名称打印到屏幕上。
- en: There's more…
  id: totrans-342
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The contents of an existing file stored in a ZIP archive can be read using the
    `read()` method. The file should first be opened in a read mode, and then you
    can call the `read()` method passing in a parameter that represents the filename
    that should be read. The contents of the file can then be printed to the screen,
    written to another file, or stored as a list or dictionary variable.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `read()` 方法读取存储在 ZIP 存档中的现有文件的文件内容。首先应以读取模式打开文件，然后你可以调用 `read()` 方法，传入一个表示要读取的文件名的参数。然后可以将文件内容打印到屏幕上，写入另一个文件，或存储为列表或字典变量。
- en: Reading XML files
  id: totrans-344
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取 XML 文件
- en: XML files were designed as a way to transport and store data. They are platform
    independent, since the data is stored in a plain text file. Although similar to
    HTML, XML differs in that HTML is designed for display purposes, whereas XML data
    is designed for data. XML files are sometimes used as an interchange format for
    GIS data going between various software systems.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: XML 文件被设计为一种传输和存储数据的方式。由于数据存储在纯文本文件中，因此它们是平台无关的。尽管与 HTML 类似，但 XML 的不同之处在于 HTML
    是为显示目的而设计的，而 XML 数据是为数据而设计的。XML 文件有时被用作 GIS 数据在不同软件系统之间交换的格式。
- en: Getting ready
  id: totrans-346
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'XML documents have a tree-like structure composed of a root element, child
    elements, and element attributes. Elements are also called **nodes** . All XML
    files contain a **root** element. This root element is the parent to all other
    elements or child nodes. The following code example illustrates the structure
    of an XML document. Unlike HTML files, XML files are case sensitive:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: XML 文档由一个根元素、子元素和元素属性组成的树状结构。元素也被称为 **节点**。所有 XML 文件都包含一个 **根** 元素。这个根元素是所有其他元素或子节点的父元素。以下代码示例说明了
    XML 文档的结构。与 HTML 文件不同，XML 文件是区分大小写的：
- en: '[PRE58]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Python provides several programming modules that you can use to process XML
    files. The module that you use should be determined by the module that is right
    for the job. Don't try to force a single module to do everything. Each module
    has specific functions that they are good at performing. In this recipe, you will
    learn how to read data from an XML file using the `nodes` and `element` attributes
    that are a part of the document.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: Python 提供了多个编程模块，你可以使用这些模块来处理 XML 文件。你应该根据适合工作的模块来决定使用哪个模块。不要试图强迫单个模块做所有事情。每个模块都有它们擅长执行的具体功能。在这个示例中，你将学习如何使用文档中的
    `nodes` 和 `element` 属性从 XML 文件中读取数据。
- en: There are a number of ways that you can access nodes within an XML document.
    Perhaps, the easiest way to do so is to find nodes by tag name and then walk the
    tree containing a list of the child nodes. Before doing so, you'll want to parse
    the XML document with the `minidom.parse()` method. Once parsed, you can then
    use the `childNodes` attribute to obtain a list of all child nodes starting at
    the root of the tree. Finally, you can search the nodes by tag name with the `getElementsByTagName(tag)`
    function, which accepts a tag name as an argument. This will return a list of
    all child nodes associated with the tag.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方法可以访问 XML 文档中的节点。也许，最简单的方法是通过标签名称查找节点，然后遍历包含子节点列表的树。在这样做之前，你将想要使用 `minidom.parse()`
    方法解析 XML 文档。一旦解析，你可以使用 `childNodes` 属性获取从树根开始的所有子节点的列表。最后，你可以使用 `getElementsByTagName(tag)`
    函数通过标签名称搜索节点，该函数接受一个标签名称作为参数。这将返回与该标签相关联的所有子节点的列表。
- en: You can also determine if a node contains an attribute by calling `hasAttribute(name)`,
    which will return a `true`/`false` value. Once you've determined that an attribute
    exists, a call to `getAttribute(name)` will obtain the value for the attribute.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过调用 `hasAttribute(name)` 来确定一个节点是否包含属性，这将返回一个 `true`/`false` 值。一旦确定属性存在，调用
    `getAttribute(name)` 将获取属性的值。
- en: In this exercise, you will parse an XML file and pull out values associated
    with a particular element (node) and attribute. We'll be loading an XML file containing
    wildfire data. In this file, we'll be looking for the `<fire>` node and the `address`
    attribute from each of these nodes. The addresses will be printed out.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将解析一个 XML 文件并提取与特定元素（节点）和属性相关的值。我们将加载一个包含野火数据的 XML 文件。在这个文件中，我们将寻找 `<fire>`
    节点和每个这些节点的 `address` 属性。地址将被打印出来。
- en: How to do it…
  id: totrans-353
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: Open IDLE and create a script called `c:\ArcpyBook\Appendix2\XMLAccessElementAttribute.py`.
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 IDLE 并创建一个名为 `c:\ArcpyBook\Appendix2\XMLAccessElementAttribute.py` 的脚本。
- en: 'The `WitchFireResidenceDestroyed.xml` file will be used. The file is located
    in your `c:\ArcpyBook\Appendix2` folder. You can see a sample of its contents
    as follows:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将使用 `WitchFireResidenceDestroyed.xml` 文件。该文件位于你的 `c:\ArcpyBook\Appendix2` 文件夹中。你可以如下查看其内容样本：
- en: '[PRE59]'
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Import `minidom` from `xml.dom`:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `xml.dom` 导入 `minidom`：
- en: '[PRE60]'
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Parse the XML file:'
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解析 XML 文件：
- en: '[PRE61]'
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Generate a list of nodes from the XML file:'
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 XML 文件生成节点列表：
- en: '[PRE62]'
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Generate a list of all the `<fire>` nodes:'
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成所有 `<fire>` 节点的列表：
- en: '[PRE63]'
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Loop through the list of elements, test for the existence of the `address`
    attribute, and print the value of the attribute if it exists:'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遍历元素列表，检查 `address` 属性是否存在，如果存在则打印属性值：
- en: '[PRE64]'
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Save and run the script. You should see the following output:'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并运行脚本。你应该看到以下输出：
- en: '[PRE65]'
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: How it works…
  id: totrans-369
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Loading an XML document into your script is probably the most basic thing you
    can do with XML files. You can use the `xml.dom` module to do this through the
    use of the `minidom` object. The `minidom` object has a method called `parse()`,
    which accepts a path to an XML document and creates a **document object model**
    (**DOM**) tree object from the `WitchFireResidenceDestroyed.xml` file.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 将 XML 文档加载到你的脚本中可能是你可以用 XML 文件做的最基本的事情。你可以使用 `xml.dom` 模块通过 `minidom` 对象来实现这一点。`minidom`
    对象有一个名为 `parse()` 的方法，它接受一个 XML 文档的路径，并从 `WitchFireResidenceDestroyed.xml` 文件创建一个
    **文档对象模型** (**DOM**) 树对象。
- en: The `childNodes` property of the DOM tree generates a list of all nodes in the
    XML file. You can then access each of the nodes using the `getElementsByTagName()`
    method. The final step is to loop through each of the `<fire>` nodes contained
    within the `eList` variable. For each node, we then check for the `address` attribute
    with the `hasAttribute()` method, and if it exists we call the `getAttribute()`
    function and print the address to the screen.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: DOM 树的 `childNodes` 属性生成 XML 文件中所有节点的列表。然后你可以使用 `getElementsByTagName()` 方法访问每个节点。最后一步是遍历
    `eList` 变量中包含的所有 `<fire>` 节点。对于每个节点，我们使用 `hasAttribute()` 方法检查 `address` 属性是否存在，如果存在，我们调用
    `getAttribute()` 函数并将地址打印到屏幕上。
- en: There's more…
  id: totrans-372
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: There will be times when you will need to search an XML document for a specific
    text string. This requires the use of the `xml.parsers.expat` module. You'll need
    to define a search class derived from the basic `expat` class and then create
    an object from this class. Once created, you can call the `parse()` method on
    the search object to search for data. Finally, you can then search the nodes by
    tag name with the `getElementsByTagName(tag)` function, which accepts a tag name
    as an argument. This will return a list of all child nodes associated with the
    tag.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 有时会需要你在 XML 文档中搜索特定的文本字符串。这需要使用 `xml.parsers.expat` 模块。你需要定义一个从基本 `expat` 类派生的搜索类，然后从这个类创建一个对象。一旦创建，你就可以在搜索对象上调用
    `parse()` 方法来搜索数据。最后，你可以使用 `getElementsByTagName(tag)` 函数通过标签名搜索节点，该函数接受一个标签名作为参数。这将返回与该标签相关联的所有子节点的列表。
