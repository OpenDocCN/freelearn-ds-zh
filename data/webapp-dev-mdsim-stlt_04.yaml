- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Streamlit Essentials – Configuring the Environment, Managing Packages, and More
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Streamlit Essentials – 配置环境、管理软件包等
- en: This chapter covers the basics of building a Python web application using the
    Streamlit framework. It is designed for beginners who want to learn how to develop
    a web application from scratch and covers several important topics, including
    setting up a virtual environment, installing and managing packages, creating an
    app skeleton, and adding a menu and decoration to the app.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了使用 Streamlit 框架构建 Python Web 应用程序的基础知识。它是为想要从零开始学习如何开发 Web 应用程序的初学者设计的，涵盖了几个重要的主题，包括设置虚拟环境、安装和管理软件包、创建应用程序框架，以及为应用程序添加菜单和装饰。
- en: This chapter is the first of a section consisting of four more chapters. In
    these chapters, we will learn how to build basic web applications while developing
    essential Streamlit skills. We are adopting a *learning-by-doing* approach, so
    we are going to build, test, and deploy a real working web app – a **natural language
    processing** (**NLP**) app – from scratch. So, let’s make it!
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是一个由四个章节组成的部分的第一章。在这些章节中，我们将学习如何在开发基本 Streamlit 技能的同时构建基础的 Web 应用程序。我们采用的是一种*边做边学*的方法，因此我们将从零开始构建、测试和部署一个真正工作的
    Web 应用程序——一个**自然语言处理**（**NLP**）应用程序。那么，让我们开始吧！
- en: This chapter starts by recalling the concept of virtual environments and explains
    why they are important for Python development. Once the development environment
    has been set up, the focus moves on to creating the application skeleton, which
    involves defining the structure and layout of the app. This kind of skeleton is
    a very valuable resource to be used for future web app development. After that,
    we’ll cover how to add a menu and decoration to the app to create a nice, good-looking,
    and user-friendly web interface.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章首先回顾了虚拟环境的概念，并解释了它们在 Python 开发中的重要性。一旦开发环境设置完成，焦点将转向创建应用程序框架，这涉及到定义应用程序的结构和布局。这样的框架是一个非常有价值的资源，可以用于未来的
    Web 应用程序开发。之后，我们将介绍如何为应用程序添加菜单和装饰，以创建一个漂亮、好看且用户友好的 Web 界面。
- en: By the end of this chapter, you should have a basic understanding of how to
    build a Python web application using Streamlit and be able to create an app with
    custom menus and decorations while leveraging the skeleton that you’ve created.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你应该对如何使用 Streamlit 构建 Python Web 应用程序有一个基本的理解，并且能够利用你创建的框架，创建一个带有自定义菜单和装饰的应用程序。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要内容：
- en: Configuring our environment
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置我们的环境
- en: Installing and importing packages
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装和导入软件包
- en: App skeleton building
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序框架构建
- en: Building the menu and adding decorations
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建菜单并添加装饰
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In this chapter, we will use the following libraries, packages, and tools:'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用以下库、软件包和工具：
- en: Sublime Text
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Sublime Text
- en: Python 3
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 3
- en: '`pipenv`'
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pipenv`'
- en: '`streamlit`'
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`streamlit`'
- en: '`textblob`'
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`textblob`'
- en: '`spacy`'
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spacy`'
- en: '`neattext`'
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`neattext`'
- en: '`matplotlib`'
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`matplotlib`'
- en: '`wordcloud`'
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wordcloud`'
- en: 'The code for this chapter can be found in this book’s GitHub repository: [https://github.com/PacktPublishing/Web-App-Development-Made-Simple-with-Streamlit/tree/4306036e2ddf9a714f2f058f76363aac5b402d5b/Chapter04](https://github.com/PacktPublishing/Web-App-Development-Made-Simple-with-Streamlit/tree/4306036e2ddf9a714f2f058f76363aac5b402d5b/Chapter04)'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章的代码可以在本书的 GitHub 仓库中找到：[https://github.com/PacktPublishing/Web-App-Development-Made-Simple-with-Streamlit/tree/4306036e2ddf9a714f2f058f76363aac5b402d5b/Chapter04](https://github.com/PacktPublishing/Web-App-Development-Made-Simple-with-Streamlit/tree/4306036e2ddf9a714f2f058f76363aac5b402d5b/Chapter04)
- en: Configuring our environment
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置我们的环境
- en: 'We are finally here and building our first web application from scratch! From
    scratch means working from the beginning, even before an empty Python file. The
    approach is easy – we start by sitting and coding together. Let’s start by creating
    our virtual environment, which is dedicated exclusively to this new app we will
    develop:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们终于到了这里，正在从零开始构建我们的第一个 Web 应用程序！从零开始意味着从一开始就工作，甚至在空的 Python 文件之前。方法很简单——我们从坐下来一起编码开始。让我们先创建我们的虚拟环境，这个环境将专门用于我们将要开发的这个新应用程序：
- en: 'As we’ve already learned in previous chapters, we must fire up our Terminator
    terminal and create an empty directory named `web_app1` with the following instructions:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如我们在前面的章节中所学到的，我们必须启动我们的 Terminator 终端，并使用以下指令创建一个名为 `web_app1` 的空目录：
- en: '[PRE0]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, we must enter the following instruction in the terminal:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们必须在终端中输入以下指令：
- en: '[PRE1]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Finally, we must write the following:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们必须编写以下内容：
- en: '[PRE2]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The last instruction, as we saw previously and already know, will create the
    virtual environment with `pipenv`, as shown in *Figure 4**.1*:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所见并且已经知道，最后的指令将通过 `pipenv` 创建虚拟环境，如 *图 4.1* 所示：
- en: '![Figure 4.1: Creating a virtual environment in pipenv](img/B21147_04_01.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.1：在 pipenv 中创建虚拟环境](img/B21147_04_01.jpg)'
- en: 'Figure 4.1: Creating a virtual environment in pipenv'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1：在 pipenv 中创建虚拟环境
- en: Since it will help us a lot in managing code and Streamlit’s execution, let’s
    divide our Terminator terminal into two parts, splitting it horizontally.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它能大大帮助我们管理代码和 Streamlit 的执行，我们将 Terminator 终端分成两部分，水平分割。
- en: 'Write the following line in the lower tile:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下方的窗口中写入以下内容：
- en: '[PRE3]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '![Figure 4.2: Selecting a virtual environment](img/B21147_04_02.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.2：选择虚拟环境](img/B21147_04_02.jpg)'
- en: 'Figure 4.2: Selecting a virtual environment'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2：选择虚拟环境
- en: Once you are inside the virtual environment, in your terminal prompt, you will
    see its name in parentheses (in our case, `web_app1`).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦进入虚拟环境，你的终端提示符中会看到其名称，位于括号中（在我们的例子中是 `web_app1`）。
- en: 'We are inside `web_app1`, so we can open our editor, Sublime Text, by typing
    the following:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在 `web_app1` 内，所以可以通过输入以下内容来打开我们的编辑器 Sublime Text：
- en: '[PRE4]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Please be aware of the point (`.`) after the blank space; in other words, there
    is a blank space between `subl` and the point (`.`).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意空格后的点（`.`）；换句话说，`subl` 和点（`.`）之间有一个空格。
- en: 'By doing this, Sublime Text will fire up from our working folder:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，Sublime Text 将从我们的工作文件夹中启动：
- en: '![Figure 4.3: Launching Sublime Text from the virtual environment](img/B21147_04_03.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.3：从虚拟环境启动 Sublime Text](img/B21147_04_03.jpg)'
- en: 'Figure 4.3: Launching Sublime Text from the virtual environment'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3：从虚拟环境启动 Sublime Text
- en: With that, our virtual environment is working, and our editor is ready. This
    means that it’s time to deal with all the packages that are required by the web
    application. We need to install these packages to make the web app work correctly.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们的虚拟环境就正常工作了，编辑器也准备好了。这意味着现在可以处理网络应用程序所需的所有包。我们需要安装这些包，以使 Web 应用程序正常工作。
- en: Installing and importing packages
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装和导入包
- en: 'To make our web application work properly, we need the following Python packages:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的网络应用程序正常工作，我们需要以下 Python 包：
- en: '`streamlit`: This is the core – that is, the framework that makes the magic
    happen'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`streamlit`：这是核心——即使魔法发生的框架'
- en: '`textblob`: This is a nice package for basic sentiment analysis and some other
    basic NLP tasks (NLP is how computers understand human language, its meaning,
    its syntax, and so on)'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`textblob`：这是一个用于基本情感分析和其他一些基本 NLP 任务的不错包（NLP 是计算机理解人类语言、其含义、语法等的方式）'
- en: '`spacy`: This is quite an advanced package; it’s state of the art and can be
    used for almost any NLP task'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spacy`：这是一个相当先进的包；它是最先进的技术，可以用于几乎任何 NLP 任务'
- en: '`neattext`: A very simple package for text cleaning'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`neattext`：一个非常简单的文本清理包'
- en: '`matplotlib`: Python’s most famous package for plotting graphs, diagrams, and
    so on'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`matplotlib`：Python 最著名的用于绘制图表、图形等的包'
- en: '`wordcloud`: A package dedicated to nice word cloud creation and visualizations'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wordcloud`：一个专注于美观词云创建和可视化的包'
- en: 'We can install all these packages in our virtual environment (so we must already
    be inside the virtual environment) by typing the following unique instruction:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过输入以下唯一指令，在我们的虚拟环境中安装所有这些包（所以我们必须已经进入虚拟环境）：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Please note that this operation can take a few minutes to run:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此操作可能需要几分钟才能完成：
- en: '![Figure 4.4: Package installation](img/B21147_04_04.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.4：包安装](img/B21147_04_04.jpg)'
- en: 'Figure 4.4: Package installation'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4：包安装
- en: 'If you check the Pipfile from Sublime Text, you will see that all the packages
    have been installed correctly, as reported in *Figure 4**.5*:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你检查 Sublime Text 中的 Pipfile，你会看到所有包都已正确安装，如 *图 4.5* 所示：
- en: '![Figure 4.5: Pipfile with the installed packages](img/B21147_04_05.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.5：包含已安装包的 Pipfile](img/B21147_04_05.jpg)'
- en: 'Figure 4.5: Pipfile with the installed packages'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.5：包含已安装包的 Pipfile
- en: '*spaCy* is a very powerful package for NLP and requires a dedicated language
    model for each language we want to manage. So, before we start coding, we need
    to download the English language model. Let’s write the following instruction
    in our terminal:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '*spaCy* 是一个非常强大的 NLP 包，并且需要为每种我们要管理的语言下载专门的语言模型。因此，在我们开始编码之前，我们需要下载英语语言模型。让我们在终端中输入以下指令：'
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This instruction will download the `en_core_web_sm` English language model,
    whose size is 12.8 MB. The file’s name is quite self-explanatory: `en` means English,
    `core_web` means that the model has been trained on a dataset containing text
    coming from the web, and `sm` stands for small (if you want to get an idea of
    all languages, models, and their size, you can check spaCy’s official website):'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 该指令将下载`en_core_web_sm`英语语言模型，文件大小为12.8MB。文件名非常自解释：`en`表示英语，`core_web`表示该模型是在一个包含来自网络的文本数据集上训练的，`sm`表示小型（如果你想了解所有语言、模型及其大小，可以查看spaCy的官方网站）：
- en: '![Figure 4.6: Downloading the spaCy language model](img/B21147_04_06.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图4.6：下载spaCy语言模型](img/B21147_04_06.jpg)'
- en: 'Figure 4.6: Downloading the spaCy language model'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.6：下载spaCy语言模型
- en: 'Now, we have everything we need to start coding. There’s just one thing missing:
    the Python file! Without it, we cannot code. Let’s create it by typing a simple
    instruction:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们拥有了开始编码所需的一切。只差一个东西：Python文件！没有它，我们无法编码。让我们通过输入一个简单的指令来创建它：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here’s the output:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '![Figure 4.7: The app.py file](img/B21147_04_07.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图4.7：app.py文件](img/B21147_04_07.jpg)'
- en: 'Figure 4.7: The app.py file'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.7：app.py文件
- en: 'So far, everything is ready: our environment is OK, our packages have been
    installed, and our empty `app.py` file is there.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切准备就绪：我们的环境已经设置好，包已经安装完毕，我们的空`app.py`文件也已经存在。
- en: We are now ready to start writing the code for our first working web application.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经准备好开始编写第一个真正的Web应用代码了。
- en: 'The first step is to open the `app.py` file in Sublime Text and import all
    the libraries we have installed so that we can write the code, as shown in *Figure
    4**.8*:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是打开`app.py`文件，使用Sublime Text导入我们已经安装的所有库，以便编写代码，如*图4.8*所示：
- en: '![Figure 4.8: Importing the necessary libraries](img/B21147_04_08.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图4.8：导入必要的库](img/B21147_04_08.jpg)'
- en: 'Figure 4.8: Importing the necessary libraries'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.8：导入必要的库
- en: The preceding code imports `streamlit` with the `st` alias and imports all NLP
    packages (`textblob`, `spacy`, and `neattext`) and all the visualization libraries.
    Please note that for `matplotlib`, we are using the `Agg` engine since, with Streamlit,
    it works better than the default one.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码导入了`streamlit`并使用`st`别名，同时导入了所有的NLP包（`textblob`、`spacy`和`neattext`）以及所有的可视化库。请注意，对于`matplotlib`，我们使用了`Agg`引擎，因为在Streamlit中，它比默认引擎表现得更好。
- en: After importing, we are finally ready to write all the code for our first real
    web application. Let’s do it right now!
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 导入完成后，我们终于准备好编写第一个真正的Web应用代码了。现在就开始吧！
- en: App skeleton building
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用框架搭建
- en: 'First of all, we need a main function – a function that contains all the business
    logic of our app and the frontend too. This is the power of Streamlit – building
    the frontend directly inside Python code. There’s no need for different programming
    languages, files, and so on; everything is in one place using the same language.
    Writing this function is very easy – we can add the code shown in *Figure 4**.9*:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个主函数——一个包含应用所有业务逻辑和前端内容的函数。这就是Streamlit的强大之处——可以直接在Python代码中构建前端。无需使用不同的编程语言、文件等；一切都在同一个地方，使用相同的语言编写。编写这个函数非常简单——我们可以添加*图4.9*所示的代码：
- en: '![Figure 4.9: Importing the necessary libraries and the main function](img/B21147_04_09.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图4.9：导入必要的库和主函数](img/B21147_04_09.jpg)'
- en: 'Figure 4.9: Importing the necessary libraries and the main function'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.9：导入必要的库和主函数
- en: The first part of the code is quite self-explanatory – we are just importing
    all the libraries that were introduced a couple of pages before. Just note that
    when we import `matplotlib` (the library needed for plotting), we are specifying
    that we wish to use the `Agg` engine (without this instruction, `matplotlib` would
    use its default engine). With Streamlit’s initial versions, this `Agg` engine
    used to work better, but with the very recent versions, `matplotlib`’s standard
    engine performs well too. So, the suggestion is to try with and without this instruction
    and to use it only in the case of a real improvement.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的第一部分是非常自解释的——我们只是导入了前面几页中介绍的所有库。需要注意的是，当我们导入`matplotlib`（绘图所需的库）时，我们指定了希望使用`Agg`引擎（如果没有这个指令，`matplotlib`会使用默认的引擎）。在Streamlit的早期版本中，这个`Agg`引擎表现得更好，但在最近的版本中，`matplotlib`的标准引擎也表现良好。所以，建议是尝试有无这个指令，并且只有在真正有改进的情况下才使用它。
- en: 'So, thanks to `def`, we can create a function named `main`. At the moment,
    this function just prints a title on the screen (`st.title`): *NLP* *Web App*.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，感谢 `def`，我们可以创建一个名为 `main` 的函数。目前，这个函数只是将一个标题打印到屏幕上（`st.title`）：*NLP* *Web
    App*。
- en: 'That’s it – we are ready to launch the web application we’ve made with Streamlit.
    In our browser, we’ll see our beautiful title: *NLP* *Web App*.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样——我们已经准备好启动我们用 Streamlit 制作的 Web 应用程序。在浏览器中，我们将看到我们的漂亮标题：*NLP* *Web App*。
- en: 'To run the app in our terminal, we should write `streamlit run app.py`. However,
    since we are inside a `pipenv` environment, we have to type the following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 要在终端中运行应用程序，我们应该输入 `streamlit run app.py`。然而，由于我们处于 `pipenv` 环境中，我们需要输入以下命令：
- en: '[PRE8]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This instruction starts a web server that runs our Streamlit app on port `8501`.
    Our Streamlit app is the code contained in the `app.py` file.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这条指令启动了一个 Web 服务器，将我们的 Streamlit 应用程序运行在 `8501` 端口上。我们的 Streamlit 应用程序是 `app.py`
    文件中的代码。
- en: 'Immediately, the browser will open up on `localhost port 8501` and we will
    see the web app, as shown in *Figure 4**.10*:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器将立即在 `localhost port 8501` 上打开，我们将看到 Web 应用程序，如 *图 4.10* 所示：
- en: '![Figure 4.10: Web app running on localhost:8501](img/B21147_04_10.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.10：Web 应用程序在 localhost:8501 上运行](img/B21147_04_10.jpg)'
- en: 'Figure 4.10: Web app running on localhost:8501'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.10：Web 应用程序在 localhost:8501 上运行
- en: At the moment, the web application is doing nothing but showing the *NLP Web
    App* title, together with the *hamburger menu* at the top right. Please explore
    all the options contained in this menu.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，Web 应用程序什么也不做，只是显示 *NLP Web App* 标题，并在右上角显示 *汉堡菜单*。请探索菜单中的所有选项。
- en: 'What is important to understand now is that usually, all applications perform
    a set of tasks, let’s say three or four or *N* (any number), and for this reason,
    all applications have the same *skeleton*, a common structure or backbone that
    enables each task. These tasks can be included in an application menu and built
    up by a *selectbox*, allowing the user to choose what to do. We can put this selectbox
    on the left-hand side of our app. So, assuming that the tasks of *NLP Web App*
    will be `st.title` line:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在需要理解的是，通常所有应用程序都会执行一组任务，假设是三四个任务或 *N*（任何数字），因此所有应用程序都有相同的 *框架*，即一个通用的结构或支撑骨架，使每个任务得以实现。这些任务可以包含在应用程序菜单中，并通过
    *选择框* 构建，允许用户选择要执行的操作。我们可以将这个选择框放在应用程序的左侧。所以，假设 *NLP Web App* 的任务是 `st.title`
    这一行：
- en: '[PRE9]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, save the `app.py` file and click on **Always rerun** in the web app (in
    the top-right corner); in this way, all the new lines of code will be immediately
    executed as soon as we save them. As shown in *Figure 4**.11*, we have added the
    menu on the left-hand side of our web app. This menu contains the four tasks we
    included in the *activity* list. If you want, you can click on the **x** button
    to minimize the left-hand side column:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，保存 `app.py` 文件并点击 Web 应用程序中的 **Always rerun**（右上角）；这样，一旦我们保存新代码，所有新代码行都会立即执行。如
    *图 4.11* 所示，我们在 Web 应用程序的左侧添加了菜单。这个菜单包含了我们在 *活动* 列表中包含的四个任务。如果需要，你可以点击 **x** 按钮以最小化左侧栏：
- en: '![Figure 4.11: Left-hand side menu](img/B21147_04_11.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.11：左侧菜单](img/B21147_04_11.jpg)'
- en: 'Figure 4.11: Left-hand side menu'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.11：左侧菜单
- en: 'To let our menu do something, we have to add some logic for each of its items.
    We can do this by adding the following code in the main function. At the moment,
    we are just displaying some sub-headers any time we select a specific option on
    the menu:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们的菜单执行某些操作，我们必须为每个菜单项添加一些逻辑。我们可以通过在主函数中添加以下代码来实现。此时，当我们选择菜单中的某个特定选项时，我们只会显示一些子标题：
- en: '![Figure 4.12: Adding some logic to the main menu](img/B21147_04_12.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.12：向主菜单添加一些逻辑](img/B21147_04_12.jpg)'
- en: 'Figure 4.12: Adding some logic to the main menu'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.12：向主菜单添加一些逻辑
- en: 'The code in *Figure 4**.12* is quite easy: we create a list of four items (the
    `activity` variable) and use it to populate a *selectbox* on the sidebar. This
    means that this selectbox will show only four options. When we select one of these
    options (for example, `if`s (four ifs because we have four options) to understand
    the value of the selection in the selectbox. Simply put, we check `if` our selection
    in the selectbox is *equal to* any of the items in the menu; if so, we just print
    a subheader (for now, the related action is only printing a subheader; we’ll write
    a more complex action in the future) with the item’s name and a blank line. So,
    if we select **Sentiment Analysis**, we print a **Sentiment Analysis** subheader
    on the screen, as displayed in *Figure 4**.13*:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4.12*中的代码相当简单：我们创建了一个包含四个项目的列表（`activity`变量），并用它来填充侧边栏中的*selectbox*。这意味着这个selectbox只会显示四个选项。当我们选择其中一个选项时（例如，`if`s（四个if语句，因为我们有四个选项）来理解选择框中的值）。简单来说，我们检查`if`我们在选择框中的选择*等于*菜单中的任何一项；如果是，我们就打印一个子标题（目前，相关操作只是打印一个子标题；未来我们会编写更复杂的操作），子标题包含该项的名称和一个空白行。所以，如果我们选择**情感分析**，我们会在屏幕上打印一个**情感分析**的子标题，如*图
    4.13*所示：'
- en: '![Figure 4.13: “Sentiment Analysis” selection from the left-hand side menu](img/B21147_04_13.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.13：“情感分析”选项来自左侧菜单](img/B21147_04_13.jpg)'
- en: 'Figure 4.13: “Sentiment Analysis” selection from the left-hand side menu'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.13：“情感分析”选项来自左侧菜单
- en: 'At this point, it should be clear that any kind of logic has to be applied
    in the `main` function inside its specific `if` clause. For example, if we want
    the **About** section to do something more than just display a subheader containing
    the **About** text, we can write the code for its business logic in the following
    way:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，应该清楚，任何类型的逻辑都必须应用在`main`函数中的特定`if`条件下。例如，如果我们希望**关于**部分做一些比仅仅显示包含**关于**文本的子标题更复杂的操作，我们可以按以下方式编写其业务逻辑代码：
- en: '![Figure 4.14: Business logic inside the “About” section](img/B21147_04_14.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.14：“关于”部分中的业务逻辑](img/B21147_04_14.jpg)'
- en: 'Figure 4.14: Business logic inside the “About” section'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.14：“关于”部分中的业务逻辑
- en: To summarize, when the `choice` variable is *equal to* `st.write("")`), and
    then some text formatted with the Markdown language.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，当`choice`变量*等于*`st.write("")`时，接下来是一些使用Markdown语言格式化的文本。
- en: 'The code we wrote with the `st.markdown` instruction is quite self-explanatory;
    we are just printing (using the Markdown format) some information on the screen
    about our web application and a clickable link to Streamlit’s website, considering
    that the `[streamlit](`[https://streamlit.io](https://streamlit.io)`)` instruction
    is just the Markdown syntax to include hyperlinks in the text:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用`st.markdown`指令编写的代码非常容易理解；我们只是在屏幕上打印（使用Markdown格式）关于我们网站应用的一些信息，并提供一个可以点击的链接指向Streamlit网站，考虑到`[streamlit](`[https://streamlit.io](https://streamlit.io)`)`指令只是Markdown语法，用于在文本中插入超链接：
- en: '![Figure 4.15: The “About” section of our web app](img/B21147_04_15.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.15：我们网站应用的“关于”部分](img/B21147_04_15.jpg)'
- en: 'Figure 4.15: The “About” section of our web app'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.15：我们网站应用的“关于”部分
- en: So far, we’ve created a very neat skeleton (that is, a structure) for our web
    application, imported all the libraries we are going to use, created a main function
    where we created a menu (..., which will be displayed on the left-hand side of
    the app and is collapsible) containing all the tasks our web application is going
    to cover, and created the `if` clause.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经为网站应用创建了一个非常整洁的框架（即结构），导入了我们将使用的所有库，创建了一个主函数，在该函数中我们创建了一个菜单（...，该菜单将在应用的左侧显示，并且是可折叠的），其中包含我们网站应用将要涵盖的所有任务，并且创建了`if`条件。
- en: It’s incredible, but this simple skeleton can be applied to all the web applications
    we are going to build from now on. All we need to change or adapt is the list
    of tasks (the list inside the menu on the left-hand side) and the business logic
    for each of these items.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 真令人惊讶的是，这个简单的框架可以应用于我们今后构建的所有网站应用。我们需要更改或调整的只是任务列表（左侧菜单中的列表）以及每个项目的业务逻辑。
- en: The point is that, even if the web app is working well now, it is not very appealing.
    So, let’s try adding some decorations.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 重点是，即使现在网站应用运行良好，它也并不吸引人。因此，让我们尝试添加一些装饰。
- en: Building the menu and adding decorations
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建菜单并添加装饰
- en: '*NLP Web App* might be a good title for our application, but to be honest,
    it’s just some black text on a white background, so it’s not very appealing at
    the moment.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '*NLP Web App* 可能是一个不错的应用程序标题，但说实话，它现在只是一些黑色文字在白色背景上，因此并不是非常吸引人。'
- en: 'One of the greatest features of Streamlit is that we can use HTML very easily.
    So, let’s add some simple HTML code to our `main` function just to make everything
    much more stylish! We can change the old `st.title("NLP Web App")` first line
    of code that sits after the main function declaration with the following one:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Streamlit 的一个伟大特点是我们可以非常轻松地使用 HTML。所以，让我们在 `main` 函数中添加一些简单的 HTML 代码，来让一切看起来更加时尚！我们可以将位于主函数声明之后的旧代码
    `st.title("NLP Web App")` 替换为以下代码：
- en: '![Figure 4.16: Adding some HTML to our title](img/B21147_04_16.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.16：向我们的标题中添加一些 HTML](img/B21147_04_16.jpg)'
- en: 'Figure 4.16: Adding some HTML to our title'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.16：向我们的标题中添加一些 HTML
- en: 'In `title_template`, we are specifying the *background color* (blue), the *padding
    size*, and the *text style* (h1) and its *color* (cyan). With the `st.markdown`
    instruction, as we learned previously, we are just visualizing the HTML; you can
    play around and customize it as you want by changing the background and text color,
    padding, text, and more. This is the result:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `title_template` 中，我们指定了 *背景颜色*（蓝色）、*填充大小* 和 *文本样式*（h1）及其 *颜色*（青色）。通过 `st.markdown`
    指令，正如我们之前学到的，我们只是将 HTML 进行可视化；你可以通过更改背景和文本颜色、填充、文本等来自由调整。这是最终效果：
- en: '![Figure 4.17: A colored title for our app](img/B21147_04_17.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.17：我们应用程序的彩色标题](img/B21147_04_17.jpg)'
- en: 'Figure 4.17: A colored title for our app'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.17：我们应用程序的彩色标题
- en: The effect is very nice.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 效果非常棒。
- en: 'Now, let’s create a subtitle. To do this, we can use a subheader and use more
    or less the same HTML code. We just need to add another couple of lines of code,
    as shown in the following figure:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个副标题。为此，我们可以使用副标题并使用几乎相同的 HTML 代码。我们只需要再添加几行代码，如下图所示：
- en: '![Figure 4.18: The final code for the title and subheader](img/B21147_04_18.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.18：标题和副标题的最终代码](img/B21147_04_18.jpg)'
- en: 'Figure 4.18: The final code for the title and subheader'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.18：标题和副标题的最终代码
- en: 'We approached this the same way we approached `title_template` in *Figure 4**.16*:
    we defined some HTML in a variable (in this case, `subheader_template`) and then
    visualized it using `st.markdown` and by setting the `unsafe_allow_html` argument
    to `True`.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以与处理 `title_template` 在 *图 4.16* 中的方式相同的方式来处理这个问题：我们在一个变量中定义了一些 HTML（在这个例子中是
    `subheader_template`），然后通过 `st.markdown` 和设置 `unsafe_allow_html` 参数为 `True` 来进行可视化。
- en: 'As mentioned previously, everything is fully customizable according to your
    ideas. This is the final result:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，一切都可以根据你的想法完全自定义。这是最终的效果：
- en: '![Figure 4.19: The final colored title and subheader](img/B21147_04_19.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.19：最终的彩色标题和副标题](img/B21147_04_19.jpg)'
- en: 'Figure 4.19: The final colored title and subheader'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.19：最终的彩色标题和副标题
- en: Since we put these decorations at the very beginning of the main function –
    that is, before creating the left-hand side menu and the `if` clauses that are
    in charge of selecting various tasks – the colored HTML title and header will
    not change when we switch the various menu items since they are fixed on the top
    of the screen and give our web application a very good *style consistency*. In
    short, since we put this HTML code at the beginning of the main function, it will
    be applied to the entire web application and not to any specific task – everything
    will be affected by this title. The title will be a fixed element of our web application.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们把这些装饰代码放在了主函数的最前面，也就是在创建左侧菜单和负责选择各种任务的 `if` 条件语句之前，因此，当我们切换各种菜单项时，彩色 HTML
    标题和头部不会发生变化，因为它们固定在屏幕顶部，并且为我们的网页应用程序提供了非常好的 *样式一致性*。简而言之，由于我们将这段 HTML 代码放在了主函数的开头，它将应用于整个网页应用程序，而不是某个特定的任务——一切都会受到这个标题的影响。这个标题将成为我们网页应用程序的固定元素。
- en: 'If we look at our web application’s panel in the browser, we will see that
    the icon and the title are the default ones since the icon is Streamlit’s, and
    the title is just the name of our Python file (`app.py`):'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在浏览器中查看我们的网页应用程序面板，我们会看到图标和标题是默认的，因为图标是 Streamlit 的，而标题则是我们 Python 文件的名称（`app.py`）：
- en: '![Figure 4.20: The web app’s default icon and title in the browser](img/B21147_04_20.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.20：网页应用在浏览器中的默认图标和标题](img/B21147_04_20.jpg)'
- en: 'Figure 4.20: The web app’s default icon and title in the browser'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.20：网页应用在浏览器中的默认图标和标题
- en: 'Let’s customize these two very important features. In Streamlit, there is an
    instruction dedicated exactly to this purpose, but – and this is very important
    – it has to be placed immediately after the `streamlit import` line. This instruction
    is `set_page_config`. Let’s add it to our `app.py` file and then explain how it
    works:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定制这两个非常重要的特性。在Streamlit中，确实有一个专门用于这个目的的指令——但这是非常重要的——它必须紧接在`streamlit import`行后面。这条指令是`set_page_config`。让我们将它添加到我们的`app.py`文件中，然后解释它是如何工作的：
- en: '![Figure 4.21: The set_page_config instruction](img/B21147_04_21.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图4.21：set_page_config指令](img/B21147_04_21.jpg)'
- en: 'Figure 4.21: The set_page_config instruction'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.21：set_page_config指令
- en: '`set_page_config` accepts a certain number of arguments, as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`set_page_config`接受以下几个参数：'
- en: '`page_title`: The title of our page; this is a string'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`page_title`：我们的页面标题；这是一个字符串'
- en: '`page_icon`: An icon (an image file) or an emoji (the emoji itself or its code)'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`page_icon`：一个图标（图像文件）或一个表情符号（表情符号本身或其代码）'
- en: '`layout`: This can be `centered` or `wide`'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`layout`：这可以是`centered`或`wide`'
- en: '`initial_sidebar_state`: This can be `wide`, `expanded`, or `collapsed`'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`initial_sidebar_state`：这可以是`wide`、`expanded`或`collapsed`'
- en: You can experiment with different configurations and easily find information
    on how to use each instruction in Streamlit’s **Documentation** section, which
    includes input arguments and output results.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以尝试不同的配置，并且可以轻松找到Streamlit **文档**部分中的相关信息，其中包含输入参数和输出结果。
- en: 'The following screenshot explains the `set_page_config()` instruction. As you
    can see, there are several different configurations that we didn’t explore, and
    it’s possible to combine them to fully customize your web application. So, please
    don’t forget to carefully check the official Streamlit documentation to get the
    most value out of this incredible framework:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 下图解释了`set_page_config()`指令。如你所见，这里有一些我们没有探讨的不同配置，你可以将它们结合起来，以完全自定义你的Web应用程序。因此，请务必仔细查看Streamlit的官方文档，以便从这个令人惊叹的框架中获得最大价值：
- en: '![Figure 4.22: Streamlit’s official documentation](img/B21147_04_22.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图4.22：Streamlit的官方文档](img/B21147_04_22.jpg)'
- en: 'Figure 4.22: Streamlit’s official documentation'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.22：Streamlit的官方文档
- en: 'Now that we’ve looked at Streamlit’s official documentation, let’s have a look
    at our web application with the new page title and icon:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经查看了Streamlit的官方文档，接下来让我们看看具有新页面标题和图标的Web应用程序：
- en: '![Figure 4.23: Icon and title customization in the browser panel](img/B21147_04_23.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![图4.23：浏览器面板中的图标和标题定制](img/B21147_04_23.jpg)'
- en: 'Figure 4.23: Icon and title customization in the browser panel'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.23：浏览器面板中的图标和标题定制
- en: 'As you can see, in the browser tile related to our web application, we have
    a full set of customizations: an icon representing a thumb and a personalized
    title stating *NLP Web App*. This is the result of the code we saw in *Figure
    4**.21*.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，在浏览器的与我们Web应用程序相关的标签上，我们有一整套定制化内容：一个代表拇指的图标和一个个性化的标题，显示为*NLP Web App*。这就是我们在*图4.21*中看到的代码的结果。
- en: If you want to, you can see what happens upon changing the 👍 emoji we used as
    an icon with an image, such as a PNG file that you like. You can also check how
    the web application behaves when we set `initial_sidebar_state` to `wide`, `expanded`,
    or `collapsed` and `layout` to wide.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意，你可以尝试替换我们用作图标的👍表情符号，改为你喜欢的PNG文件等图像。你还可以查看当我们将`initial_sidebar_state`设置为`wide`、`expanded`或`collapsed`，并将`layout`设置为wide时，Web应用程序的表现。
- en: The decorations we added to our web app skeleton are clean, neat, and good-looking
    but up until now, excluding the **About** section, which can be considered closed,
    the rest need to be completed with some business logic to make the various **Text
    Analysis**, **Translation**, and **Sentiment Analysis** tasks work properly. This
    is exactly what we are going to do in the next chapter.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为Web应用程序框架添加的装饰简洁、整洁且美观，但直到现在，除了**关于**部分（可以认为已经完成），其余部分需要通过一些业务逻辑来完成，以便让各种**文本分析**、**翻译**和**情感分析**任务正常工作。这正是我们将在下一章中做的事情。
- en: 'The following figure shows all the code we wrote. It’s quite interesting to
    point out how, in only 64 lines of code, including empty lines and comments, we
    have built up a working web application that lives on the web and can be used
    by a browser and that contains a menu, some sections, HTML, titles, and decorations:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了我们所编写的所有代码。值得一提的是，在仅仅64行代码的情况下（包括空行和注释），我们已经构建了一个可以在网页上运行的Web应用程序，它可以被浏览器使用，并且包含菜单、一些部分、HTML、标题和装饰：
- en: '![](img/B21147_04_24.jpg)![](img/B21147_04_25.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21147_04_24.jpg)![](img/B21147_04_25.jpg)'
- en: 'Figure 4.24: The app.py file'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.24：app.py 文件
- en: The best part is that you can reuse it as you wish!
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 最棒的是，你可以根据需要随时重用它！
- en: Summary
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we began from scratch. First of all, we prepared our `pipenv`
    environment, installed all packages needed for the web application, and finally
    created an empty Python file.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们从零开始。首先，我们准备了`pipenv`环境，安装了 web 应用所需的所有包，最后创建了一个空的 Python 文件。
- en: After that, we built up a *skeleton* that can be reused any time we want to
    develop a new web application. This skeleton is made up of an initial part where
    we import all the packages we need and a *main* function that is dedicated to
    containing all the business logic of our web app.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们构建了一个可以随时重用的*骨架*，用于开发新的 web 应用程序。这个骨架由一个初始化部分组成，我们在其中导入所有需要的包，以及一个*主*函数，用来包含我们
    web 应用的所有业务逻辑。
- en: In the first part of the main function, some features must be applied to the
    entire web application, such as its title and subtitle, which we created with
    very beautiful and colorful HTML, and the web browser’s panel icon and title.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在主函数的第一部分，必须应用一些功能到整个 web 应用中，比如标题和副标题，我们通过非常漂亮且丰富多彩的 HTML 创建了它们，还有网页浏览器的面板图标和标题。
- en: In the second part of the main function, we created a menu that will be shown
    on the left-hand side of our web application and that lets the user choose from
    the various tasks our web application can perform. Upon selecting one of the tasks
    in the menu, the web application will show its specific section performing its
    specific task. We implemented this because we wanted to start with a very easy
    case. The **About** section now performs well, showing the name/title of the web
    application and some useful information – in this case, the working link to Streamlit’s
    website.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在主函数的第二部分，我们创建了一个菜单，显示在我们 web 应用的左侧，让用户从我们 web 应用可以执行的各种任务中进行选择。选择菜单中的一个任务后，web
    应用将展示相应的部分，并执行其特定的任务。我们之所以实现这个功能，是因为我们想从一个非常简单的案例开始。**关于**部分现在运行良好，展示了 web 应用的名称/标题以及一些有用的信息——在这个案例中，是指向
    Streamlit 网站的有效链接。
- en: Everything is working well and has been customized according to our willingness
    and future needs. This shows that this skeleton is a great weapon in our developer’s
    toolkit!
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 一切运作良好，并根据我们的意愿和未来需求进行了定制。这表明这个骨架是我们开发者工具包中的一大利器！
- en: In the next chapter, we’ll start building the complete business logic of our
    application by using and learning about some very powerful widgets such as columns
    and expanders, as well as some NLP techniques!
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始构建我们应用程序的完整业务逻辑，使用并学习一些非常强大的控件，比如列和展开器，以及一些 NLP 技术！
