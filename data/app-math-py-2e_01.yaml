- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: An Introduction to Basic Packages, Functions, and Concepts
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本包、函数和概念简介
- en: Before getting started on any practical recipes, we’ll use this opening chapter
    to introduce several core mathematical concepts and structures and their Python
    representations. We’ll look at basic numerical types, basic mathematical functions
    (trigonometric functions, exponential function, and logarithms), and matrices.
    Matrices are fundamental in most computational applications because of the connection
    between matrices and solutions of systems of linear equations. We’ll explore some
    of these applications in this chapter, but matrices will play an important role
    throughout this book.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始任何实际的例程之前，我们将利用本章的开头部分介绍几个核心的数学概念和结构及其在 Python 中的表示。我们将讨论基本数值类型、基本数学函数（如三角函数、指数函数和对数函数）以及矩阵。矩阵在大多数计算应用中至关重要，因为矩阵与线性方程组的解之间有着密切的联系。我们将在本章中探索一些应用，但矩阵将在全书中扮演重要角色。
- en: 'We’ll cover the following main topics in this order:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将按以下顺序讨论以下主要主题：
- en: Exploring Python numerical types
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索 Python 数值类型
- en: Understanding basic mathematical functions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解基本数学函数
- en: Diving into the world of NumPy
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深入 NumPy 的世界
- en: Working with matrices and linear algebra
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 矩阵和线性代数的应用
- en: NumPy arrays and the basic mathematical functions we will see in this chapter
    will be used throughout the rest of the book—they appear in essentially every
    recipe. Matrix theory, and other topics discussed here, underpin many of the computational
    methods that are used behind the scenes in packages discussed in this book. Some
    other topics are important to know about, though we will not necessarily use these
    in recipes in the book (for example, the alternative numerical types).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们将看到的 NumPy 数组和基本数学函数将在本书的其余部分中反复使用——它们几乎出现在每个例程中。矩阵理论及本章讨论的其他主题为本书中讨论的包背后许多计算方法提供了基础。尽管我们不会在书中的例程中使用某些主题（例如，替代的数值类型），但它们仍然是需要了解的重要内容。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In this chapter, and throughout this book, we will use Python version `3.10`,
    which is the most recent version of Python at the time of writing. Most of the
    code in this book will work on recent versions of Python from `3.6`. We will use
    features that were introduced in Python 3.6 at various points, including f-strings.
    This means that you may need to change `python3.10`, which appears in any terminal
    commands, to match your version of Python. This might be another version of Python,
    such as `python3.6` or `python3.7`, or a more general command such as `python3`
    or `python`. For the latter commands, you need to check that the version of Python
    is at least 3.6 by using the following command:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章及全书中，我们将使用 Python 版本 `3.10`，这是写作时的最新版本。本书中的大部分代码将在 Python `3.6` 及更高版本上运行。我们将在不同的部分使用
    Python 3.6 中引入的特性，包括 f-string。因此，你可能需要将终端命令中出现的 `python3.10` 改为你所使用的 Python 版本。这可能是
    Python 的另一个版本，如 `python3.6` 或 `python3.7`，或者一个更通用的命令，如 `python3` 或 `python`。对于后者的命令，你需要通过以下命令检查
    Python 的版本是否至少为 3.6：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Python has built-in numerical types and basic mathematical functions that suffice
    for small applications that involve only small calculations. The NumPy package
    provides a high-performance array type and associated routines (including basic
    mathematical functions that operate efficiently on arrays). This package will
    be used in many of the recipes in this chapter and the remainder of this book.
    We will also make use of the SciPy package in the latter recipes of this chapter.
    Both can be installed using your preferred package manager, such as `pip`:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Python 具有内建的数值类型和基本数学函数，足以应对仅涉及小型计算的小型应用程序。NumPy 包提供了一个高性能的数组类型和相关的例程（包括在数组上高效运作的基本数学函数）。这个包将在本章以及本书剩余部分的许多例程中使用。我们还将在本章后面的例程中使用
    SciPy 包。可以通过你喜欢的包管理工具（如 `pip`）来安装它们：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'By convention, we import these packages under a shorter alias. We import `numpy`
    as `np` and `scipy` as `sp` using the following `import` statements:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，我们以更简短的别名导入这些包。我们将 `numpy` 导入为 `np`，将 `scipy` 导入为 `sp`，并使用以下 `import` 语句：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: These conventions are used in the official documentation ([https://numpy.org/doc/stable/](https://numpy.org/doc/stable/)
    and [https://docs.scipy.org/doc/scipy/](https://docs.scipy.org/doc/scipy/)) for
    these packages, along with many tutorials and other materials that use these packages.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这些约定在官方文档中有所使用 ([https://numpy.org/doc/stable/](https://numpy.org/doc/stable/)
    和 [https://docs.scipy.org/doc/scipy/](https://docs.scipy.org/doc/scipy/))，以及使用这些包的许多教程和其他材料中。
- en: The code for this chapter can be found in the `Chapter 01` folder of the GitHub
    repository at [https://github.com/PacktPublishing/Applying-Math-with-Python-2nd-Edition/tree/main/Chapter%2001](https://github.com/PacktPublishing/Applying-Math-with-Python-2nd-Edition/tree/main/Chapter%2001).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在 GitHub 仓库的 `Chapter 01` 文件夹中找到，地址为 [https://github.com/PacktPublishing/Applying-Math-with-Python-2nd-Edition/tree/main/Chapter%2001](https://github.com/PacktPublishing/Applying-Math-with-Python-2nd-Edition/tree/main/Chapter%2001)。
- en: Exploring Python numerical types
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 Python 数值类型
- en: Python provides basic numerical types such as arbitrarily sized integers and
    floating-point numbers (double precision) as standard, but it also provides several
    additional types that are useful in specific applications where precision is especially
    important. Python also provides (built-in) support for complex numbers, which
    is useful for some more advanced mathematical applications. Let’s take a look
    at some of these different numerical types, starting with the `Decimal` type.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Python 提供了基本的数值类型，如任意大小的整数和浮点数（双精度），作为标准类型，但它还提供了几个额外的类型，这些类型在精度尤其重要的特定应用中非常有用。Python
    还提供了对复数的（内置）支持，这对于一些更高级的数学应用非常有用。让我们从 `Decimal` 类型开始，了解一下这些不同的数值类型。
- en: Decimal type
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Decimal 类型
- en: 'For applications that require decimal digits with accurate arithmetic operations,
    use the `Decimal` type from the `decimal` module in the Python Standard Library:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 对于需要精确算术运算的十进制数字的应用，可以使用 Python 标准库中 `decimal` 模块的 `Decimal` 类型：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Performing this calculation with float objects gives the result 2.6630000000000003,
    which includes a small error arising from the fact that certain numbers cannot
    be represented exactly using a finite sum of powers of 2\. For example, 0.1 has
    a binary expansion 0.000110011..., which does not terminate. Any floating-point
    representation of this number will therefore carry a small error. Note that the
    argument to `Decimal` is given as a string rather than a float.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 使用浮动对象执行此计算时，结果为 2.6630000000000003，这个结果包含了一个小误差，这是由于某些数字无法用有限的 2 的幂的和来精确表示。例如，0.1
    的二进制展开式为 0.000110011...，该展开式不会终止。因此，任何该数字的浮点表示都会带有一个小误差。请注意，传递给 `Decimal` 的参数是以字符串形式而不是浮点数形式给出的。
- en: The `Decimal` type is based on the IBM *General Decimal Arithmetic Specification*
    ([http://speleotrove.com/decimal/decarith.html](http://speleotrove.com/decimal/decarith.html)),
    which is an alternative specification for floating-point arithmetic that represents
    decimal numbers exactly by using powers of 10 rather than powers of 2\. This means
    that it can be safely used for calculations in finance where the accumulation
    of rounding errors would have dire consequences. However, the `Decimal` format
    is less memory efficient, since it must store decimal digits rather than binary
    digits (bits), and these are more computationally expensive than traditional floating-point
    numbers.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`Decimal` 类型基于 IBM 的 *通用十进制算术规范* ([http://speleotrove.com/decimal/decarith.html](http://speleotrove.com/decimal/decarith.html))，它是浮点算术的另一种规范，通过使用
    10 的幂而不是 2 的幂，精确表示十进制数。这意味着它可以安全地用于金融计算，在这些计算中，四舍五入误差的积累可能带来严重后果。然而，`Decimal`
    格式的内存效率较低，因为它必须存储十进制数字，而不是二进制数字（位），这些数字比传统的浮点数在计算上更为昂贵。'
- en: 'The `decimal` package also provides a `Context` object, which allows fine-grained
    control over the precision, display, and attributes of `Decimal` objects. The
    current (default) context can be accessed using the `getcontext` function from
    the `decimal` module. The `Context` object returned by `getcontext` has a number
    of attributes that can be modified. For example, we can set the precision for
    arithmetic operations:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`decimal` 包还提供了一个 `Context` 对象，它允许对 `Decimal` 对象的精度、显示和属性进行细粒度的控制。可以通过 `decimal`
    模块的 `getcontext` 函数访问当前（默认）上下文。`getcontext` 返回的 `Context` 对象具有可以修改的多个属性。例如，我们可以为算术运算设置精度：'
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: When we set the precision to `4`, rather than the default `28`, we see that
    the fourth power of 1.1 is rounded to four significant figures.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将精度设置为 `4` 而不是默认的 `28` 时，可以看到 1.1 的四次方被四舍五入为四位有效数字。
- en: 'The context can even be set locally by using the `localcontext` function, which
    returns a context manager that restores the original environment at the end of
    the `with` block:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`localcontext`函数，甚至可以在本地设置上下文，该函数返回一个上下文管理器，在`with`代码块结束时恢复原始环境：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This means that the context can be freely modified inside the `with` block,
    and will be returned to the default at the end.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着上下文可以在`with`代码块内自由修改，并将在结束时返回默认状态。
- en: Fraction type
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分数类型
- en: 'Alternatively, for working with applications that require accurate representations
    of integer fractions, such as when working with proportions or probabilities,
    there is the `Fraction` type from the `fractions` module in the Python Standard
    Library. The usage is similar, except that we typically give the numerator and
    denominator of the fraction as arguments:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，在处理需要精确表示整数分数的应用时，例如在处理比例或概率时，可以使用Python标准库中的`fractions`模块中的`Fraction`类型。其用法类似，不同之处在于我们通常将分数的分子和分母作为参数传递：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `Fraction` type simply stores two integers—the numerator and the denominator—and
    arithmetic is performed using the basic rules for the addition and multiplication
    of fractions.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`Fraction`类型仅存储两个整数——分子和分母——并通过基本的分数加法和乘法规则执行算术运算。'
- en: Complex type
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复数类型
- en: 'The square root function works fine for positive numbers but isn’t defined
    for negative numbers. However, we can extend the set of real numbers by formally
    adding a symbol, i—the **imaginary unit**—whose square is ![](img/Formula_01_001.png)
    (that is, ![](img/Formula_01_002.png)). A **complex number** is a number of the
    form ![](img/Formula_01_003.png), where ![](img/Formula_01_004.png) and ![](img/Formula_01_005.png)
    are *real numbers* (those that we are used to). In this form, the number ![](img/Formula_01_006.png)
    is called the **real part**, and ![](img/Formula_01_007.png) is called the **imaginary
    part**. Complex numbers have their own arithmetic (addition, subtraction, multiplication,
    division) that agrees with the arithmetic of real numbers when the imaginary part
    is zero. For example, we can add the complex numbers ![](img/Formula_01_008.png)
    and ![](img/Formula_01_009.png) to get ![](img/Formula_01_010.png), or multiply
    them together to get the following:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 平方根函数对于正数是有效的，但对于负数并未定义。然而，我们可以通过正式添加一个符号i——**虚数单位**——来扩展实数集，其平方为![](img/Formula_01_001.png)（即！[](img/Formula_01_002.png)）。**复数**是形如![](img/Formula_01_003.png)的数，其中![](img/Formula_01_004.png)和![](img/Formula_01_005.png)是*实数*（即我们通常所用的数字）。在这种形式下，数![](img/Formula_01_006.png)称为**实部**，而![](img/Formula_01_007.png)则称为**虚部**。复数具有自己的算术运算（加法、减法、乘法、除法），当虚部为零时，这些运算与实数的算术运算一致。例如，我们可以将复数![](img/Formula_01_008.png)和![](img/Formula_01_009.png)相加得到![](img/Formula_01_010.png)，或者将它们相乘得到如下结果：
- en: '![](img/Formula_01_011.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_01_011.jpg)'
- en: 'Complex numbers appear more often than you might think, and are often found
    behind the scenes when there is some kind of cyclic or oscillatory behavior. This
    is because the ![](img/Formula_01_012.png) and ![](img/Formula_01_013.png) trigonometric
    functions are the real and imaginary parts, respectively, of the complex exponential:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 复数的出现频率可能比你想象的要高，它们通常出现在存在某种周期性或振荡性行为的场景中。这是因为![](img/Formula_01_012.png)和![](img/Formula_01_013.png)三角函数分别是复指数的实部和虚部：
- en: '![](img/Formula_01_014.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_01_014.jpg)'
- en: 'Here, ![](img/Formula_01_015.png) is any real number. The details, and many
    more interesting facts and theories of complex numbers, can be found in many resources
    covering complex numbers. The following *Wikipedia* page is a good place to start:
    https://en.wikipedia.org/wiki/Complex_number.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，![](img/Formula_01_015.png)是任意实数。关于复数的更多细节以及更多有趣的事实和理论可以在许多关于复数的资源中找到。以下的*Wikipedia*页面是一个很好的起点：https://en.wikipedia.org/wiki/Complex_number。
- en: 'Python has support for complex numbers, including a literal character to denote
    the complex unit `1j` in code. This might be different from the idiom for representing
    the complex unit that you are familiar with from other sources on complex numbers.
    Most mathematical texts will often use the ![](img/Formula_01_016.png) symbol
    to represent the complex unit:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Python 支持复数，包括在代码中表示复数单位的字面量字符`1j`。这可能与你从其他关于复数的来源中所熟悉的复数单位表示法有所不同。大多数数学文献通常使用![](img/Formula_01_016.png)符号来表示复数单位：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The **complex conjugate** of a complex number is the result of making the imaginary
    part negative. This has the effect of swapping between two possible solutions
    to the equation ![](img/Formula_01_017.png).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 复数的**共轭复数**是将虚部取负的结果。这会产生方程![](img/Formula_01_017.png)的两个可能解之间的互换效果。
- en: Special *complex number*-aware mathematical functions are provided in the `cmath`
    module of the Python Standard Library.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Python标准库的`cmath`模块提供了特殊的*复数*数学函数。
- en: Now that we have seen some of the basic mathematical types that Python has to
    offer, we can start to explore some of the mathematical functions that it provides.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了Python提供的一些基本数学类型，接下来可以开始探索它提供的一些数学函数。
- en: Understanding basic mathematical functions
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解基本的数学函数
- en: Basic mathematical functions appear in many applications. For example, logarithms
    can be used to scale data that grows exponentially to give linear data. The exponential
    function and trigonometric functions are common fixtures when working with geometric
    information, the *gamma function* appears in combinatorics, and the *Gaussian
    error function* is important in statistics.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的数学函数在许多应用中都有出现。例如，使用对数可以将指数增长的数据进行缩放，得到线性数据。指数函数和三角函数是处理几何信息时常见的工具，*伽马函数*在组合数学中出现，*高斯误差函数*在统计学中非常重要。
- en: 'The `math` module in the Python Standard Library provides all of the standard
    mathematical functions, along with common constants and some utility functions,
    and it can be imported using the following command:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Python标准库中的`math`模块提供了所有标准数学函数，以及常见的常数和一些工具函数，可以通过以下命令导入：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Once it’s imported, we can use any of the mathematical functions that are contained
    in this module. For instance, to find the square root of a non-negative number,
    we would use the `sqrt` function from `math`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦导入，我们就可以使用该模块中的任何数学函数。例如，要找出一个非负数的平方根，可以使用`math`中的`sqrt`函数：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Attempting to use the `sqrt` function with a negative argument will raise a
    value error. The square root of a negative number is not defined for this `sqrt`
    function, which deals only with *real numbers*. The square root of a negative
    number—this will be a complex number—can be found using the alternative `sqrt`
    function from the `cmath` module in the Python Standard Library.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用`sqrt`函数并传入负数作为参数将引发值错误。负数的平方根对于这个`sqrt`函数是未定义的，因为它仅处理*实数*。负数的平方根——这将是一个复数——可以使用Python标准库中的`cmath`模块提供的替代`sqrt`函数来计算。
- en: 'The sine, cosine, and tangent trigonometric functions are available under their
    common abbreviations `sin`, `cos`, and `tan`, respectively, in the `math` module.
    The `pi` constant holds the value of π, which is approximately 3.1416:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 正弦、余弦和正切三角函数在`math`模块中分别以常见的缩写`sin`、`cos`和`tan`提供。常数`pi`表示π的值，约等于3.1416：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The inverse trigonometric functions are named `acos`, `asin`, and `atan` in
    the `math` module:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 反三角函数在`math`模块中命名为`acos`、`asin`和`atan`：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `log` function in the `math` module performs logarithms. It has an optional
    argument to specify the base of the logarithm (note that the second argument is
    positional only). By default, without the optional argument, it is the *natural
    logarithm* with base ![](img/Formula_01_018.png). The ![](img/Formula_01_019.png)
    constant can be accessed using `math.e`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Python标准库中的`math`模块提供了对数函数`log`。它有一个可选参数来指定对数的底（注意，第二个参数是位置参数）。默认情况下，如果没有指定可选参数，它将计算*自然对数*，底数为![](img/Formula_01_018.png)。可以使用`math.e`访问常数![](img/Formula_01_019.png)：
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `math` module also contains the `gamma` function, which is the gamma function,
    and the `erf` function, the Gaussian error function, which is important in statistics.
    Both functions are defined by integrals. The gamma function is defined by this
    integral:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`math`模块还包含`gamma`函数（伽马函数）和`erf`函数（高斯误差函数），这两个函数在统计学中非常重要，且都是通过积分定义的。伽马函数由以下积分定义：'
- en: '![](img/Formula_01_020.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_01_020.jpg)'
- en: 'The Gaussian error function is defined by this integral:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 高斯误差函数由这个积分定义：
- en: '![](img/Formula_01_021.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_01_021.jpg)'
- en: 'The integral in the definition of the error function cannot be evaluated using
    calculus, and instead must be computed numerically:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 误差函数定义中的积分无法使用微积分计算，而必须通过数值方法来计算：
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In addition to standard functions such as trigonometric functions, logarithms,
    and exponential functions, the `math` module contains various theoretic and combinatorial
    functions. These include the `comb` and `factorial` functions, which are useful
    in a variety of applications. The `comb` function called with arguments ![](img/Formula_01_022.png)
    and ![](img/Formula_01_023.png) returns the number of ways to choose ![](img/Formula_01_024.png)
    items from a collection of ![](img/Formula_01_025.png) without repeats if the
    order is not important. For example, picking 1 then 2 is the same as picking 2
    then 1\. This number is sometimes written ![](img/Formula_01_026.png). The factorial
    called with argument ![](img/Formula_01_027.png) returns the factorial ![](img/Formula_01_028.png):'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 除了标准函数，如三角函数、对数函数和指数函数外，`math`模块还包含各种理论和组合函数。这些包括`comb`和`factorial`函数，它们在多种应用中非常有用。调用`comb`函数，传入参数![](img/Formula_01_022.png)和![](img/Formula_01_023.png)，返回从![](img/Formula_01_025.png)个项目中选择![](img/Formula_01_024.png)个项目的方式数，而顺序不重要。如果顺序不重要，选1再选2与选2再选1是一样的。这个数字有时会写作![](img/Formula_01_026.png)。调用`factorial`函数，传入参数![](img/Formula_01_027.png)，返回该整数的阶乘![](img/Formula_01_028.png)：
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Applying the factorial to a negative number raises a `ValueError`. The factorial
    of an integer, ![](img/Formula_01_029.png), coincides with the value of the gamma
    function at ![](img/Formula_01_030.png); that is:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 对负数应用阶乘运算会引发`ValueError`。一个整数![](img/Formula_01_029.png)的阶乘等于伽马函数在![](img/Formula_01_030.png)处的值；即：
- en: '![](img/Formula_01_031.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_01_031.jpg)'
- en: 'The `math` module also contains a function that returns the *greatest common
    divisor* of its arguments called `gcd`. The greatest common divisor of ![](img/Formula_01_032.png)
    and ![](img/Formula_01_033.png) is the largest integer ![](img/Formula_01_034.png)
    such that ![](img/Formula_01_035.png) divides both ![](img/Formula_01_036.png)
    and ![](img/Formula_01_037.png) exactly:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`math`模块还包含一个函数，返回其参数的*最大公约数*，该函数名为`gcd`。![](img/Formula_01_032.png)与![](img/Formula_01_033.png)的最大公约数是最大的整数![](img/Formula_01_034.png)，使得![](img/Formula_01_035.png)可以整除![](img/Formula_01_036.png)和![](img/Formula_01_037.png)：'
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'There are also a number of functions for working with floating-point numbers.
    The `fsum` function performs addition on an iterable of numbers and keeps track
    of the sums at each step to reduce the error in the result. This is nicely illustrated
    by the following example:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些用于处理浮点数的函数。`fsum`函数对一个可迭代的数字进行加法运算，并在每一步中跟踪和，从而减少结果中的误差。以下示例很好地展示了这一点：
- en: '[PRE16]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `isclose` function returns `True` if the difference between the arguments
    is smaller than the tolerance. This is especially useful in unit tests, where
    there may be small variations in results based on machine architecture or data
    variability.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`isclose`函数返回`True`，如果两个参数的差小于容差。这在单元测试中特别有用，因为在不同的机器架构或数据波动下，结果可能会有微小的变化。'
- en: Finally, the `floor` and `ceil` functions from `math` provide the floor and
    ceiling of their argument. The **floor** of a number ![](img/Formula_01_038.png)
    is the largest integer ![](img/Formula_01_039.png) with ![](img/Formula_01_040.png),
    and the **ceiling** of ![](img/Formula_01_041.png) is the smallest integer ![](img/Formula_01_042.png)
    with ![](img/Formula_01_043.png). These functions are useful when converting between
    a float obtained by dividing one number by another and an integer.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`math`模块中的`floor`和`ceil`函数提供了其参数的下取整和上取整。一个数字![](img/Formula_01_038.png)的**下取整**是最大的整数![](img/Formula_01_039.png)，满足![](img/Formula_01_040.png)；而![](img/Formula_01_041.png)的**上取整**是最小的整数![](img/Formula_01_042.png)，满足![](img/Formula_01_043.png)。这些函数在将通过除法得到的浮点数转换为整数时非常有用。
- en: 'The `math` module contains functions that are implemented in C (assuming you
    are running CPython), and so are much faster than those implemented in Python.
    This module is a good choice if you need to apply a function to a relatively small
    collection of numbers. If you want to apply these functions to a large collection
    of data simultaneously, it is better to use their equivalents from the NumPy package,
    which is more efficient for working with arrays. In general, if you have imported
    the NumPy package already, then it is probably best to always use NumPy equivalents
    of these functions to limit the chance of error. With this in mind, let’s now
    introduce the NumPy package and its basic objects: multi-dimensional arrays.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`math` 模块包含用 C 实现的函数（假设你正在运行 CPython），因此比 Python 实现的函数要快得多。如果你需要对一个相对较小的数字集合应用某个函数，这个模块是一个不错的选择。如果你希望对大量数据同时应用这些函数，最好使用
    NumPy 包中的等效函数，因为它在处理数组时更高效。一般来说，如果你已经导入了 NumPy 包，那么最好始终使用 NumPy 等效的函数，以减少出错的机会。考虑到这一点，现在让我们介绍
    NumPy 包及其基本对象：多维数组。'
- en: Diving into the world of NumPy
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入了解 NumPy 的世界
- en: NumPy provides high-performance array types and routines for manipulating these
    arrays in Python. These arrays are useful for processing large datasets where
    performance is crucial. NumPy forms the base for the numerical and scientific
    computing stack in Python. Under the hood, NumPy makes use of low-level libraries
    for working with vectors and matrices, such as the **Basic Linear Algebra Subprograms**
    (**BLAS**) package, to accelerate computations.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 提供了高性能的数组类型和用于在 Python 中操作这些数组的函数。这些数组对于处理大型数据集（性能至关重要的场景）非常有用。NumPy 是
    Python 数值计算和科学计算栈的基础。在底层，NumPy 利用诸如 **基础线性代数子程序**（**BLAS**）包等低级库来加速计算。
- en: 'Traditionally, the NumPy package is imported under the shorter alias `np`,
    which can be accomplished using the following `import` statement:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，NumPy 包会以更短的别名 `np` 被导入，可以通过以下 `import` 语句实现：
- en: '[PRE17]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This convention is used in the NumPy documentation and in the wider scientific
    Python ecosystem (SciPy, pandas, and so on).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这个约定在 NumPy 文档中以及更广泛的科学 Python 生态系统（如 SciPy、pandas 等）中得到了应用。
- en: 'The basic type provided by the NumPy library is the `ndarray` type (henceforth
    referred to as a NumPy array). Generally, you won’t create your own instances
    of this type, and will instead use one of the helper routines such as `array`
    to set up the type correctly. The `array` routine creates NumPy arrays from an
    array-like object, which is typically a list of numbers or a list of lists (of
    numbers). For example, we can create a simple array by providing a list with the
    required elements:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 库提供的基本类型是 `ndarray` 类型（以下简称 NumPy 数组）。通常，你不会自己创建该类型的实例，而是会使用如 `array`
    之类的辅助函数来正确地设置类型。`array` 函数从类似数组的对象创建 NumPy 数组，这个对象通常是一个数字列表或数字的列表列表。例如，我们可以通过提供包含所需元素的列表来创建一个简单的数组：
- en: '[PRE18]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The NumPy array type (`ndarray`) is a Python wrapper around an underlying C
    array structure. The array operations are implemented in C and optimized for performance.
    NumPy arrays must consist of homogeneous data (all elements have the same type),
    although this type could be a pointer to an arbitrary Python object. NumPy will
    infer an appropriate data type during creation if one is not explicitly provided
    using the `dtype` keyword argument:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 数组类型（`ndarray`）是一个 Python 包装器，围绕着一个底层的 C 数组结构。数组操作是用 C 实现的，并进行了性能优化。NumPy
    数组必须包含同质数据（所有元素具有相同的类型），尽管该类型可以是指向任意 Python 对象的指针。如果在创建时没有显式提供类型，NumPy 会通过 `dtype`
    关键字参数推断出一个合适的数据类型：
- en: '[PRE19]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: NumPy offers type specifiers for numerous C-types that can be passed into the
    `dtype` parameter, such as `np.float32` used previously. Generally speaking, these
    type specifiers are of form `namexx` where the name is the name of a type—such
    as int, float, or complex—and `xx` is a number of bits—for example, 8, 16, 32,
    64, 128\. Usually, NumPy does a pretty good job of selecting a good type for the
    input given, but occasionally, you will want to override it. The preceding case
    is a good example— without the `dtype=np.float32` argument, NumPy would assume
    the type to be `int64`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 提供了许多 C 类型的类型说明符，可以传递到 `dtype` 参数中，例如之前使用的 `np.float32`。通常，这些类型说明符的格式为
    `namexx`，其中 `name` 是类型的名称——例如 int、float 或 complex，而 `xx` 是位数——例如 8、16、32、64、128。通常情况下，NumPy
    会很好地为给定的输入选择一个合适的类型，但有时你可能希望覆盖它。前述情况就是一个很好的例子——如果没有 `dtype=np.float32` 参数，NumPy
    会假设类型为 `int64`。
- en: Under the hood, a NumPy array of any shape is a buffer containing the raw data
    as a flat (one-dimensional) array and a collection of additional metadata that
    specifies details such as the type of the elements.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在底层，任何形状的 NumPy 数组都是一个缓冲区，包含作为扁平（单维）数组的原始数据和一组附加的元数据，后者指定了诸如元素类型等详细信息。
- en: 'After creation, the data type can be accessed using the `dtype` attribute of
    the array. Modifying the `dtype` attribute will have undesirable consequences
    since the raw bytes that constitute the data in the array will simply be reinterpreted
    as the new data type. For example, if we create an array using Python integers,
    NumPy will convert those to 64-bit integers in the array. Changing the `dtype`
    value will cause NumPy to reinterpret these 64-bit integers to the new data type:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 创建后，可以使用数组的 `dtype` 属性访问数据类型。修改 `dtype` 属性会导致不良后果，因为构成数组中数据的原始字节将被重新解释为新的数据类型。例如，如果我们使用
    Python 整数创建一个数组，NumPy 会将这些整数转换为数组中的 64 位整数。更改 `dtype` 值会导致 NumPy 重新解释这些 64 位整数为新的数据类型：
- en: '[PRE20]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Each 64-bit integer has been re-interpreted as two 32-bit floating-point numbers,
    which clearly give nonsense values. Instead, if you wish to change the data type
    after creation, use the `astype` method to specify the new type. The correct way
    to change the data type is shown here:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 64 位整数都被重新解释为两个 32 位的浮点数，这显然会导致无意义的值。相反，如果你希望在创建后更改数据类型，请使用 `astype` 方法来指定新类型。更改数据类型的正确方法如下所示：
- en: '[PRE21]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: NumPy also provides a number of routines for creating various standard arrays.
    The `zeros` routine creates an array of the specified shape, in which every element
    is `0`, and the `ones` routine creates an array in which every element is `1`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 还提供了一些用于创建各种标准数组的例程。`zeros` 例程创建一个指定形状的数组，数组中的每个元素都是 `0`，而 `ones` 例程创建一个数组，数组中的每个元素都是
    `1`。
- en: Element access
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 元素访问
- en: 'NumPy arrays support the `getitem` protocol, so elements in an array can be
    accessed as if they were a list and support all of the arithmetic operations,
    which are performed component-wise. This means we can use the index notation and
    the index to retrieve the element from the specified index, as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 数组支持 `getitem` 协议，因此可以像访问列表一样访问数组中的元素，并支持所有算术运算，这些运算是逐元素执行的。这意味着我们可以使用索引符号和索引来从指定索引中检索元素，如下所示：
- en: '[PRE22]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This also includes the usual slice syntax for extracting an array of data from
    an existing array. A slice of an array is again an array, containing the elements
    specified by the slice. For example, we can retrieve an array containing the first
    two elements of `ary`, or an array containing the elements at even indexes, as
    follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这也包括用于从现有数组中提取数据的常规切片语法。数组的切片本身也是一个数组，包含切片指定的元素。例如，我们可以获取包含 `ary` 中前两个元素的数组，或包含偶数索引元素的数组，如下所示：
- en: '[PRE23]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The syntax for a slice is `start:stop:step`. We can omit either, or both, of
    `start` and `stop` to take from the beginning or the end, respectively, of all
    elements. We can also omit the `step` parameter, in which case we also drop the
    trailing `:`. The `step` parameter describes the elements from the chosen range
    that should be selected. A value of `1` selects every element or, as in the recipe,
    a value of `2` selects every second element (starting from `0` gives even-numbered
    elements). This syntax is the same as for slicing Python lists.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 切片的语法是 `start:stop:step`。我们可以省略 `start` 或 `stop` 中的任意一个或两个，以分别从开头或结尾获取所有元素。我们还可以省略
    `step` 参数，在这种情况下也不需要末尾的 `:`。`step` 参数描述了应选择的选定范围内的元素。值为 `1` 时选择每个元素，或者像示例中，值为
    `2` 时选择每隔一个的元素（从 `0` 开始则为偶数索引的元素）。该语法与切片 Python 列表时相同。
- en: Array arithmetic and functions
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组算术和函数
- en: NumPy provides a number of **universal functions** (**ufuncs**), which are routines
    that can operate efficiently on NumPy array types. In particular, all of the basic
    mathematical functions discussed in the *Understanding basic mathematical functions*
    section have analogs in NumPy that can operate on NumPy arrays. Universal functions
    can also perform *broadcasting*, to allow them to operate on arrays of different—but
    compatible—shapes.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 提供了许多**通用函数**（**ufuncs**），这些是能够高效操作 NumPy 数组类型的例程。特别是，*理解基本数学函数*部分中讨论的所有基本数学函数，在
    NumPy 中都有对应的函数，可以作用于 NumPy 数组。通用函数还可以执行*广播*，使其能够在形状不同但兼容的数组上进行操作。
- en: 'The arithmetic operations on NumPy arrays are performed component-wise. This
    is best illustrated by the following example:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 对 NumPy 数组进行的算术运算是按组件进行的。以下示例很好地说明了这一点：
- en: '[PRE24]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Note that the arrays must be the same shape, which means they have the same
    length. Using an arithmetic operation on arrays of different shapes will result
    in a `ValueError`. Adding, subtracting, multiplying, or dividing by a number will
    result in an array where the operation has been applied to each component. For
    example, we can multiply all elements in an array by `2` by using the following
    command:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，数组必须具有相同的形状，这意味着它们具有相同的长度。对形状不同的数组进行算术运算将导致 `ValueError` 错误。与一个数字相加、相减、相乘或相除，将得到一个新的数组，其中运算将应用于每个组件。例如，我们可以使用以下命令将数组中的所有元素乘以
    `2`：
- en: '[PRE25]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As we can see, the printed array contains the numbers 2, 4, 6, and 8, which
    are the elements of the original array multiplied by 2.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，打印出来的数组包含数字 2、4、6 和 8，这些是原始数组的元素乘以 2 得到的结果。
- en: In the next section, we’ll look at various ways that you can create NumPy arrays
    in addition to the `np.array` routine that we used here.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将介绍除了这里使用的 `np.array` 函数外，您还可以用来创建 NumPy 数组的其他方法。
- en: Useful array creation routines
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有用的数组创建函数
- en: 'To generate arrays of numbers at regular intervals between two given endpoints,
    you can use either the `arange` routine or the `linspace` routine. The difference
    between these two routines is that `linspace` generates a number (the default
    is 50) of values with equal spacing between the two endpoints, including both
    endpoints, while `arange` generates numbers at a given step size up to, but not
    including, the upper limit. The `linspace` routine generates values in the closed
    interval ![](img/Formula_01_044.png), and the `arange` routine generates values
    in the half-open interval ![](img/Formula_01_045.png):'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成两个给定端点之间以固定间隔排列的数字数组，可以使用 `arange` 或 `linspace` 这两个函数。它们的区别在于，`linspace`
    生成两个端点之间等距的多个值（默认是 50 个值），包括两个端点，而 `arange` 按给定步长生成数字，直到但不包括上限。`linspace` 函数生成的是闭区间
    ![](img/Formula_01_044.png) 的值，而 `arange` 函数生成的是半开区间 ![](img/Formula_01_045.png)
    的值：
- en: '[PRE26]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note that the array generated using `linspace` has exactly five points, specified
    by the third argument, including the two endpoints, `0` and `1`. The array generated
    by `arange` has four points, and does not include the right endpoint, `1`; an
    additional step of `0.3` would equal `1.2`, which is larger than `1`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，使用 `linspace` 生成的数组恰好有五个点，这是通过第三个参数指定的，包括两个端点 `0` 和 `1`。而使用 `arange` 生成的数组有四个点，不包括右端点
    `1`；如果增加一个步长为 `0.3`，会得到 `1.2`，这大于 `1`。
- en: Higher-dimensional arrays
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高维数组
- en: 'NumPy can create arrays with any number of dimensions, which are created using
    the same `array` routine as simple one-dimensional arrays. The number of dimensions
    of an array is specified by the number of nested lists provided to the `array`
    routine. For example, we can create a two-dimensional array by providing a list
    of lists, where each member of the inner list is a number, such as the following:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 可以创建具有任意维度的数组，这些数组与创建简单的一维数组时使用的 `array` 函数相同。数组的维度数量由传递给 `array` 函数的嵌套列表的数量来指定。例如，我们可以通过提供一个列表的列表来创建二维数组，其中每个内部列表的成员都是一个数字，类似如下：
- en: '[PRE27]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: NumPy arrays have a `shape` attribute, which describes the arrangement of the
    elements in each dimension. For a two-dimensional array, the shape can be interpreted
    as the number of rows and the number of columns of the array.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 数组有一个 `shape` 属性，用来描述数组在每个维度上的排列方式。对于二维数组，`shape` 可以解释为数组的行数和列数。
- en: 'Arrays with three or more dimensions are sometimes called **tensors**. (In
    fact, one might call any sized array a tensor: a vector (one-dimensional array)
    is a 1-tensor; a two-dimensional array is a 2-tensor or matrix—see the next section.)
    Common **machine learning** (**ML**) frameworks such as TensorFlow and PyTorch
    implement their own class for tensors, which invariably behave in a similar way
    to NumPy arrays.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 具有三维或更多维度的数组有时被称为 **张量**。（事实上，任何维度的数组都可以称为张量：向量（一维数组）是一个 1-张量；二维数组是一个 2-张量或矩阵——请参见下一节。）常见的
    **机器学习** (**ML**) 框架，如 TensorFlow 和 PyTorch，都会实现自己的张量类，其行为通常与 NumPy 数组类似。
- en: 'NumPy stores the shape as the `shape` attribute on the `array` object, which
    is a tuple. The number of elements in this tuple is the number of dimensions:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 将数组的形状存储为 `array` 对象上的 `shape` 属性，该属性是一个元组。该元组中的元素数量即为数组的维度数：
- en: '[PRE28]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Since the data in a NumPy array is stored in a flat (one-dimensional) array,
    an array can be reshaped with little cost by simply changing the associated metadata.
    This is done using the `reshape` method on a NumPy array:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 NumPy 数组中的数据是存储在一个平坦的（一维的）数组中，因此通过简单地更改相关的元数据，可以以较低的成本重新塑造数组。这是通过在 NumPy
    数组上使用 `reshape` 方法来完成的：
- en: '[PRE29]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note that the total number of elements must remain unchanged. The `mat` matrix
    originally has shape `(2, 2)` with a total of four elements, and the latter is
    a one-dimensional array with shape `(4,)`, which again has a total of four elements.
    Attempting to reshape when there is a mismatch in the total number of elements
    will result in a `ValueError`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，元素的总数必须保持不变。`mat` 矩阵最初的形状是 `(2, 2)`，共有四个元素，后者是一个形状为 `(4,)` 的一维数组，也有四个元素。如果尝试在元素总数不匹配的情况下进行重塑，将导致
    `ValueError`。
- en: 'To create an array of higher dimensions, simply add more levels of nested lists.
    To make this clearer, in the following example, we separate out the lists for
    each element in the third dimension before we construct the array:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建更高维度的数组，只需添加更多层嵌套的列表。为了更清楚地说明这一点，在下面的示例中，我们在构建数组之前，先将第三维度中的每个元素的列表分开：
- en: '[PRE30]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The first element of the shape is the outermost, and the last element is the
    innermost.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 形状的第一个元素是最外层元素，最后一个元素是最内层元素。
- en: This means that adding a dimension to an array is a simple matter of providing
    the relevant metadata. Using the `array` routine, the `shape` metadata is described
    by the length of each list in the argument. The length of the outermost list defines
    the corresponding `shape` parameter for that dimension, and so on.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着向数组添加一个维度只需提供相关的元数据。使用 `array` 函数时，`shape` 元数据是通过每个列表的长度来描述的。最外层列表的长度定义了该维度的
    `shape` 参数，依此类推。
- en: The size in memory of a NumPy array does not significantly depend on the number
    of dimensions, but only on the total number of elements, which is the product
    of the `shape` parameters. However, note that the total number of elements tends
    to be larger in higher-dimensional arrays.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 数组在内存中的大小并不显著依赖于维度的数量，而仅仅取决于元素的总数，即 `shape` 参数的乘积。然而，请注意，在更高维数组中，元素的总数往往更大。
- en: 'To access an element in a multi-dimensional array, you use the usual index
    notation, but rather than providing a single number, you need to provide the index
    in each dimension. For a 2 × 2 matrix, this means specifying the row and column
    for the desired element:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问多维数组中的一个元素，您可以使用常规的索引表示法，但不仅仅是提供一个数字，而是需要提供每个维度的索引。对于一个 2 × 2 的矩阵，这意味着要指定所需元素的行和列：
- en: '[PRE31]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The index notation also supports slicing in each dimension, so we can extract
    all members of a single column by using the `mat[:, 0]` slice, like so:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 索引表示法也支持每个维度的切片，因此我们可以通过使用 `mat[:, 0]` 切片来提取单个列的所有元素，如下所示：
- en: '[PRE32]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Note that the result of the slice is a one-dimensional array.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，切片的结果是一个一维数组。
- en: The array creation functions, `zeros` and `ones`, can create multi-dimensional
    arrays by simply specifying a shape with more than one dimension parameter.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 数组创建函数 `zeros` 和 `ones` 可以通过简单地指定多个维度参数来创建多维数组。
- en: In the next section, we will look at the special case of two-dimensional NumPy
    arrays, which serve as matrices in Python.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将研究二维 NumPy 数组的特殊情况，它们在 Python 中作为矩阵使用。
- en: Working with matrices and linear algebra
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理矩阵和线性代数
- en: NumPy arrays also serve as *matrices*, which are fundamental in mathematics
    and computational programming. A **matrix** is simply a two-dimensional array.
    Matrices are central in many applications, such as geometric transformations and
    simultaneous equations, but also appear as useful tools in other areas such as
    statistics. Matrices themselves are only distinctive (compared to any other array)
    once we equip them with *matrix arithmetic*. Matrices have element-wise addition
    and subtraction operations, just as for NumPy arrays, a third operation called
    *scalar multiplication*, where we multiply every element of the matrix by a constant
    number, and a different notion of *matrix multiplication*. Matrix multiplication
    is fundamentally different from other notions of multiplication, as we will see
    later.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 数组也作为*矩阵*，在数学和计算编程中具有基础性作用。**矩阵**仅仅是一个二维数组。矩阵在许多应用中都起着核心作用，例如几何变换和线性方程组，同时在统计学等其他领域也作为有用的工具出现。矩阵本身只有在我们赋予它们*矩阵运算*之后，才会与其他数组有所区别。矩阵具有逐元素加法和减法运算，和
    NumPy 数组一样，还有一种称为*标量乘法*的第三种运算，即将矩阵中的每个元素与常数相乘，以及一种不同的*矩阵乘法*概念。矩阵乘法与其他乘法概念本质上是不同的，正如我们稍后将看到的。
- en: One of the most important attributes of a matrix is its shape, defined exactly
    as for NumPy arrays. A matrix with ![](img/Formula_01_046.png) rows and ![](img/Formula_01_047.png)
    columns is usually described as an ![](img/Formula_01_048.png) matrix. A matrix
    that has the same number of rows as columns is said to be a *square* matrix, and
    these matrices play a special role in the theory of vectors and matrices.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵的一个重要属性是它的形状，定义方式与 NumPy 数组相同。一个具有 ![](img/Formula_01_046.png) 行和 ![](img/Formula_01_047.png)
    列的矩阵通常描述为 ![](img/Formula_01_048.png) 矩阵。如果矩阵的行数与列数相等，则称其为*方阵*，这些矩阵在向量和矩阵理论中扮演着特殊的角色。
- en: 'The **identity matrix** (of size ![](img/Formula_01_049.png)) is a ![](img/Formula_01_050.png)
    matrix where the ![](img/Formula_01_051.png)-th entry is 1, and the ![](img/Formula_01_052.png)-th
    entry is zero for ![](img/Formula_01_053.png). There is an array creation routine
    that gives an ![](img/Formula_01_054.png) identity matrix for a specified ![](img/Formula_01_055.png)
    value:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**单位矩阵**（大小为 ![](img/Formula_01_049.png)）是一个 ![](img/Formula_01_050.png) 矩阵，其中第
    ![](img/Formula_01_051.png) 个元素为 1，而对于所有的 ![](img/Formula_01_052.png)，其他元素为零。存在一种数组创建方法，可以为指定的
    ![](img/Formula_01_055.png) 值生成一个 ![](img/Formula_01_054.png) 单位矩阵：'
- en: '[PRE33]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: As the name suggests, the identity matrix is a special matrix that
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 正如名称所示，单位矩阵是一个特殊的矩阵，具有以下性质：
- en: Basic methods and properties
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本方法和属性
- en: There are a large number of terms and quantities associated with matrices. We
    only mention two such properties here, since they will be useful later. These
    are the *transpose* of a matrix, where rows and columns are interchanged, and
    the *trace* of a square matrix, which is the sum of the elements along the *leading
    diagonal*. The leading diagonal consists of the elements ![](img/Formula_01_056.png)
    along the line from the top left of the matrix to the bottom right.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵与许多术语和量有关。我们在此只提到其中两个属性，因为它们在稍后的内容中会有用。这些属性是矩阵的*转置*，即行列互换，以及方阵的*迹*，它是沿着*主对角线*的元素之和。主对角线由矩阵从左上角到右下角的元素组成
    ![](img/Formula_01_056.png)。
- en: 'NumPy arrays can be easily transposed by calling the `transpose` method on
    the `array` object. In fact, since this is such a common operation, arrays have
    a convenience property `T` that returns the transpose of the matrix. The transposition
    reverses the order of the shape of a matrix (array) so that rows become columns
    and columns become rows. For example, if we start with a 3 × 2 matrix (three rows,
    two columns), then its transpose will be a 2 × 3 matrix, such as in the following
    example:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过调用 `transpose` 方法对 `array` 对象轻松地进行转置。事实上，由于这是一个非常常见的操作，数组还具有一个便捷属性 `T`，该属性返回矩阵的转置。转置操作会逆转矩阵（数组）形状的顺序，使得行变成列，列变成行。例如，如果我们从一个
    3 × 2 的矩阵（3 行 2 列）开始，则它的转置将是一个 2 × 3 的矩阵，如以下示例所示：
- en: '[PRE34]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Note
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `transpose` function does not actually modify the data in the underlying
    array but instead changes the shape and an internal flag that indicates the order
    of stored values to be from row-contiguous (C style) to column-contiguous (F style).
    This makes the operation very cheap.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`transpose` 函数并不会实际修改底层数组中的数据，而是会改变形状并设置一个内部标志，指示存储值的顺序从按行连续（C 风格）转变为按列连续（F
    风格）。这使得操作变得非常高效。'
- en: 'Another quantity associated with matrices that is occasionally useful is the
    *trace*. The trace of a square matrix ![](img/Formula_01_057.png), with entries
    as in the preceding code, is defined to be the sum of the elements along the leading
    diagonal, which consists of the elements starting from the top left diagonally
    to the bottom right. The formula for the trace is given as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个偶尔有用的与矩阵相关的量是 *迹*。方阵 ![](img/Formula_01_057.png) 的迹，如前面的代码所示，是沿主对角线的元素之和，主对角线由从左上角到右下角的元素组成。迹的公式如下：
- en: '![](img/Formula_01_058.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_01_058.jpg)'
- en: 'NumPy arrays have a `trace` method that returns the trace of a matrix:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 数组有一个 `trace` 方法，它返回矩阵的迹：
- en: '[PRE35]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The trace can also be accessed using the `np.trace` function, which is not bound
    to the array.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以使用 `np.trace` 函数来访问迹，该函数不绑定到数组。
- en: Matrix multiplication
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 矩阵乘法
- en: 'Matrix multiplication is an operation performed on two matrices, which preserves
    some of the structure and character of both matrices. Formally, suppose we are
    given two matrices ![](img/Formula_01_059.png), an ![](img/Formula_01_060.png)
    matrix, and ![](img/Formula_01_061.png), an ![](img/Formula_01_062.png) matrix,
    as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵乘法是对两个矩阵进行的操作，它保持了两个矩阵的一些结构和特征。形式上，假设给定两个矩阵 ![](img/Formula_01_059.png)，一个
    ![](img/Formula_01_060.png) 矩阵和 ![](img/Formula_01_061.png)，一个 ![](img/Formula_01_062.png)
    矩阵，如下所示：
- en: '![](img/Formula_01_063.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_01_063.jpg)'
- en: 'The matrix product ![](img/Formula_01_064.png) of ![](img/Formula_01_065.png)
    and ![](img/Formula_01_066.png) is an ![](img/Formula_01_067.png) matrix whose
    ![](img/Formula_01_068.png) -th entry is given by the following equation:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵积 ![](img/Formula_01_064.png) 的 ![](img/Formula_01_065.png) 和 ![](img/Formula_01_066.png)
    是一个 ![](img/Formula_01_067.png) 矩阵，其 ![](img/Formula_01_068.png) -th 元素由以下方程给出：
- en: '![](img/Formula_01_069.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_01_069.jpg)'
- en: 'Note that the number of columns of the first matrix **must** match the number
    of rows of the second matrix in order for matrix multiplication to be defined.
    We usually write ![](img/Formula_01_070.png) for the matrix product of ![](img/Formula_01_071.png)
    and ![](img/Formula_01_072.png), if it is defined. Matrix multiplication is a
    peculiar operation. It is not *commutative* like most other arithmetic operations:
    even if ![](img/Formula_01_073.png) and ![](img/Formula_01_074.png) can both be
    computed, there is no need for them to be equal. In practice, this means that
    the order of multiplication matters for matrices. This arises from the origins
    of matrix algebras as representations of linear maps, where multiplication corresponds
    to the composition of functions.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，第一个矩阵的列数 **必须** 与第二个矩阵的行数相匹配，以便定义矩阵乘法。我们通常写 ![](img/Formula_01_070.png)
    表示 ![](img/Formula_01_071.png) 和 ![](img/Formula_01_072.png) 的矩阵积，前提是它已定义。矩阵乘法是一个特殊的操作。它不像其他大多数算术运算那样是
    *交换律* 的：即使 ![](img/Formula_01_073.png) 和 ![](img/Formula_01_074.png) 都可以计算，它们也不一定相等。实际上，这意味着矩阵的乘法顺序很重要。这源于矩阵代数作为线性映射表示的起源，其中乘法对应于函数的组合。
- en: 'Python has an operator reserved for matrix multiplication, `@`, which was added
    in Python 3.5\. NumPy arrays implement the operator to perform matrix multiplication.
    Note that this is fundamentally different from the component-wise multiplication
    of arrays, `*`:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Python 为矩阵乘法保留了一个运算符 `@`，该运算符是在 Python 3.5 中新增的。NumPy 数组实现了该运算符来执行矩阵乘法。请注意，这与数组的按元素乘法
    `*` 从根本上是不同的：
- en: '[PRE36]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The identity matrix is a *neutral element* under matrix multiplication. That
    is, if ![](img/Formula_01_075.png) is any ![](img/Formula_01_076.png) matrix and
    ![](img/Formula_01_077.png) is the ![](img/Formula_01_078.png) identity matrix,
    then ![](img/Formula_01_079.png), and similarly, if ![](img/Formula_01_080.png)
    is an ![](img/Formula_01_081.png) matrix, then ![](img/Formula_01_082.png). This
    can be easily checked for specific examples using NumPy arrays:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 单位矩阵是矩阵乘法下的 *单位元素*。也就是说，如果 ![](img/Formula_01_075.png) 是任何 ![](img/Formula_01_076.png)
    矩阵，并且 ![](img/Formula_01_077.png) 是 ![](img/Formula_01_078.png) 单位矩阵，那么 ![](img/Formula_01_079.png)，同样地，如果
    ![](img/Formula_01_080.png) 是一个 ![](img/Formula_01_081.png) 矩阵，则 ![](img/Formula_01_082.png)。这可以通过使用
    NumPy 数组检查具体的例子来验证：
- en: '[PRE37]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: You can see that the printed resulting matrix is equal to the original matrix.
    The same is true if we reversed the order of ![](img/Formula_01_083.png) and ![](img/Formula_01_084.png)
    and performed the multiplication ![](img/Formula_01_085.png). In the next section,
    we’ll look at matrix inverses; a matrix ![](img/Formula_01_086.png) that when
    multiplied by ![](img/Formula_01_087.png) gives the identity matrix.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，打印出的结果矩阵等于原始矩阵。如果我们反转！[](img/Formula_01_083.png)和！[](img/Formula_01_084.png)的顺序并执行乘法！[](img/Formula_01_085.png)，结果也是一样的。在接下来的部分，我们将研究矩阵的逆；一个矩阵！[](img/Formula_01_086.png)，当它与！[](img/Formula_01_087.png)相乘时，得到单位矩阵。
- en: Determinants and inverses
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 行列式和逆
- en: 'The *determinant* of a square matrix is important in most applications because
    of its strong link with finding the inverse of a matrix. A matrix is *square*
    if the number of rows and columns are equal. In particular, a matrix that has
    a nonzero determinant has a (unique) inverse, which translates to unique solutions
    of certain systems of equations. The determinant of a matrix is defined recursively.
    Suppose that we have a generic ![](img/Formula_01_088.png) matrix, as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 一个矩阵的*行列式*在大多数应用中非常重要，因为它与求矩阵的逆有密切的关系。当矩阵的行数和列数相等时，该矩阵被称为*方阵*。特别地，一个行列式非零的矩阵具有（唯一的）逆矩阵，这意味着某些方程组有唯一解。矩阵的行列式是递归定义的。假设我们有一个通用的！[](img/Formula_01_088.png)矩阵，如下所示：
- en: '![](img/Formula_01_089.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_01_089.jpg)'
- en: 'The *determinant* of this generic matrix ![](img/Formula_01_090.png) is defined
    by the following formula:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这个通用矩阵！[](img/Formula_01_090.png)的*行列式*由以下公式定义：
- en: '![](img/Formula_01_091.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_01_091.jpg)'
- en: 'For a general ![](img/Formula_01_092.png) matrix where ![](img/Formula_01_093.png),
    we define the determinant recursively. For ![](img/Formula_01_094.png), the ![](img/Formula_01_095.png)--th
    submatrix ![](img/Formula_01_097.png) is the result of deleting the ![](img/Formula_01_098.png)
    th row and ![](img/Formula_01_099.png)th column from ![](img/Formula_01_100.png).
    The submatrix ![](img/Formula_01_101.png) is an ![](img/Formula_01_102.png) matrix,
    and so we can compute the determinant. We then define the determinant of ![](img/Formula_01_103.png)
    to be the following quantity:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个一般的！[](img/Formula_01_092.png)矩阵，其中！[](img/Formula_01_093.png)，我们递归定义行列式。对于！[](img/Formula_01_094.png)，第！[](img/Formula_01_095.png)子矩阵！[](img/Formula_01_097.png)是通过删除！[](img/Formula_01_098.png)行和！[](img/Formula_01_099.png)列从！[](img/Formula_01_100.png)得到的。子矩阵！[](img/Formula_01_101.png)是一个！[](img/Formula_01_102.png)矩阵，因此我们可以计算它的行列式。然后，我们定义！[](img/Formula_01_103.png)的行列式为以下量：
- en: '![](img/Formula_01_104.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_01_104.jpg)'
- en: In fact, the index 1 that appears in the preceding equation can be replaced
    by any ![](img/Formula_01_105.png) and the result will be the same.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，前面方程中出现的索引1可以被任何！[](img/Formula_01_105.png)替换，结果将是相同的。
- en: 'The NumPy routine for computing the determinant of a matrix is contained in
    a separate module called `linalg`. This module contains many common routines for
    *linear algebra*, which is the branch of mathematics that covers vector and matrix
    algebra. The routine for computing the determinant of a square matrix is the `det`
    routine:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 计算矩阵行列式的NumPy例程包含在一个名为`linalg`的单独模块中。这个模块包含许多常见的*线性代数*例程，线性代数是涵盖向量和矩阵代数的数学分支。计算方阵行列式的例程是`det`例程：
- en: '[PRE38]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Note that a floating-point rounding error has occurred in the calculation of
    the determinant.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在计算行列式时发生了浮点舍入误差。
- en: The SciPy package, if installed, also offers a `linalg` module, which extends
    NumPy’s `linalg`. The SciPy version not only includes additional routines, but
    it is also always compiled with BLAS and **Linear Algebra PACKage** (**LAPACK**)
    support, while for the NumPy version, this is optional. Thus, the SciPy variant
    may be preferable, depending on how NumPy was compiled, if speed is important.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果安装了SciPy包，它还提供了一个`linalg`模块，扩展了NumPy的`linalg`。SciPy版本不仅包括额外的例程，而且始终编译了BLAS和**线性代数包**（**LAPACK**）支持，而NumPy版本则是可选的。因此，根据NumPy的编译方式，如果对速度要求较高，SciPy变体可能更为优选。
- en: The **inverse** of an ![](img/Formula_01_106.png) matrix ![](img/Formula_01_107.png)
    is the (necessarily unique) ![](img/Formula_01_108.png) matrix ![](img/Formula_01_109.png),
    such that ![](img/Formula_01_110.png), where ![](img/Formula_01_111.png) denotes
    the ![](img/Formula_01_112.png) identity matrix and the multiplication performed
    here is matrix multiplication. Not every square matrix has an inverse; those that
    do not are sometimes called **singular** matrices. In fact, a matrix is non-singular
    (that is, has an inverse) if, and only if, the determinant of that matrix is not
    0\. When ![](img/Formula_01_113.png) has an inverse, it is customary to denote
    it by ![](img/Formula_01_114.png).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '**逆矩阵**是一个 ![](img/Formula_01_106.png) 矩阵 ![](img/Formula_01_107.png)，它是（必定唯一的）
    ![](img/Formula_01_108.png) 矩阵 ![](img/Formula_01_109.png)，使得 ![](img/Formula_01_110.png)，其中
    ![](img/Formula_01_111.png) 表示 ![](img/Formula_01_112.png) 单位矩阵，并且这里执行的乘法是矩阵乘法。并非每个方阵都有逆矩阵；那些没有逆矩阵的矩阵有时被称为
    **奇异** 矩阵。事实上，矩阵是非奇异的（即有逆矩阵的），当且仅当该矩阵的行列式不为 0。当 ![](img/Formula_01_113.png) 有逆矩阵时，通常表示为
    ![](img/Formula_01_114.png)。'
- en: 'The `inv` routine from the `linalg` module computes the inverse of a matrix
    if it exists:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`linalg` 模块中的 `inv` 函数计算一个矩阵的逆矩阵（如果存在的话）：'
- en: '[PRE39]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We can check that the matrix given by the `inv` routine is indeed the matrix
    inverse of `A` by matrix multiplying (on either side) by the inverse and checking
    that we get the 2 × 2 identity matrix:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过矩阵乘法（在任一侧）与逆矩阵相乘，检查由 `inv` 函数给出的矩阵是否确实是 `A` 的逆矩阵，并确认得到的是 2 × 2 单位矩阵：
- en: '[PRE40]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: There will be a floating-point error in these computations, which has been hidden
    away behind the `Approximately` comment, due to the way that matrix inverses are
    computed.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 由于计算矩阵逆的方式，计算中会出现浮点误差，这些误差被隐藏在 `Approximately` 注释后面。
- en: The `linalg` package also contains a number of other methods such as `norm`,
    which computes various norms of a matrix. It also contains functions for decomposing
    matrices in various ways and solving systems of equations.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`linalg` 包还包含许多其他方法，如 `norm`，它计算矩阵的各种范数。它还包含用于以各种方式分解矩阵和求解方程组的函数。'
- en: 'There are also the matrix analogs of the exponential function `expm`, the logarithm
    `logm`, sine `sinm`, cosine `cosm`, and tangent `tanm`. Note that these functions
    are not the same as the standard `exp`, `log`, `sin`, `cos`, and `tan` functions
    in the base NumPy package, which apply the corresponding function on an element-by-element
    basis. In contrast, the matrix exponential function is defined using a *power
    series* of matrices:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些矩阵的类似指数函数 `expm`、对数 `logm`、正弦 `sinm`、余弦 `cosm` 和正切 `tanm`。请注意，这些函数与基础 NumPy
    包中的标准 `exp`、`log`、`sin`、`cos` 和 `tan` 函数不同，后者是按元素逐个应用对应的函数。相比之下，矩阵指数函数是通过矩阵的 *幂级数*
    定义的：
- en: '![](img/Formula_01_115.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_01_115.jpg)'
- en: This is defined for any ![](img/Formula_01_116.png) matrix ![](img/Formula_01_117.png),
    and ![](img/Formula_01_118.png) denotes the ![](img/Formula_01_119.png)th *matrix
    power* of ![](img/Formula_01_120.png); that is, the ![](img/Formula_01_121.png)
    matrix multiplied by itself ![](img/Formula_01_122.png) times. Note that this
    “power series” always converges in an appropriate sense. By convention, we take
    ![](img/Formula_01_123.png), where ![](img/Formula_01_124.png) is the ![](img/Formula_01_125.png)
    identity matrix. This is completely analogous to the usual power series definition
    of the exponential function for real or complex numbers, but with matrices and
    matrix multiplication in place of numbers and (regular) multiplication. The other
    functions are defined in a similar fashion, but we will skip the details.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这是为任何 ![](img/Formula_01_116.png) 矩阵 ![](img/Formula_01_117.png) 定义的，且 ![](img/Formula_01_118.png)
    表示 ![](img/Formula_01_119.png) 第 *n* 次矩阵幂；即，矩阵 ![](img/Formula_01_120.png) 自乘
    ![](img/Formula_01_122.png) 次。注意，这个“幂级数”总是以某种适当的方式收敛。根据惯例，我们取 ![](img/Formula_01_123.png)，其中
    ![](img/Formula_01_124.png) 是 ![](img/Formula_01_125.png) 单位矩阵。这与通常用于实数或复数的指数函数幂级数定义完全相似，只不过用矩阵和矩阵乘法代替了数字和（常规）乘法。其他函数的定义也类似，但我们会跳过细节。
- en: In the next section, we’ll see one area where matrices and their theory can
    be used to solve systems of equations.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看到一个可以利用矩阵及其理论来求解方程组的领域。
- en: Systems of equations
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方程组
- en: 'Solving systems of (linear) equations is one of the main motivations for studying
    matrices in mathematics. Problems of this type occur frequently in a variety of
    applications. We start with a system of linear equations written as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 求解（线性）方程组是学习数学中矩阵的主要动机之一。此类问题在各种应用中频繁出现。我们从以下形式的线性方程组开始：
- en: '![](img/Formula_01_126.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_01_126.jpg)'
- en: Here, ![](img/Formula_01_127.png) is at least two, ![](img/Formula_01_128.png)
    and ![](img/Formula_01_129.png) are known values, and the ![](img/Formula_01_130.png)
    values are the unknown values that we wish to find.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，![](img/Formula_01_127.png) 至少为 2，![](img/Formula_01_128.png) 和 ![](img/Formula_01_129.png)
    是已知值，![](img/Formula_01_130.png) 值是我们希望找到的未知值。
- en: 'Before we can solve such a system of equations, we need to convert the problem
    into a matrix equation. This is achieved by collecting together the coefficients
    ![](img/Formula_01_131.png) into an ![](img/Formula_01_132.png) matrix and using
    the properties of matrix multiplication to relate this matrix to the system of
    equations. So, we construct the following matrix containing the coefficients taken
    from the equations:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能解这样的方程组之前，我们需要将问题转化为一个矩阵方程。这是通过将系数 ![](img/Formula_01_131.png) 收集成一个 ![](img/Formula_01_132.png)
    矩阵，并利用矩阵乘法的性质将此矩阵与方程组关联起来来实现的。因此，我们构建了以下矩阵，其中包含从方程中提取的系数：
- en: '![](img/Formula_01_133.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_01_133.jpg)'
- en: 'Then, if we take ![](img/Formula_01_134.png) to be the unknown (column) vector
    containing the ![](img/Formula_01_135.png) values and ![](img/Formula_01_136.png)
    to be the (column) vector containing the known values ![](img/Formula_01_137.png),
    then we can rewrite the system of equations as the following single matrix equation:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，如果我们将 ![](img/Formula_01_134.png) 视为包含 ![](img/Formula_01_135.png) 值的未知（列）向量，且将
    ![](img/Formula_01_136.png) 视为包含已知值 ![](img/Formula_01_137.png) 的（列）向量，那么我们可以将方程组重写为以下单一矩阵方程：
- en: '![](img/Formula_01_138.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_01_138.jpg)'
- en: 'We can now solve this matrix equation using matrix techniques. In this situation,
    we view a column vector as an ![](img/Formula_01_139.png) matrix, so the multiplication
    in the preceding equation is matrix multiplication. To solve this matrix equation,
    we use the `solve` routine in the `linalg` module. To illustrate the technique,
    we will solve the following system of equations as an example:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用矩阵技术来解这个矩阵方程。在这种情况下，我们将列向量视为一个 ![](img/Formula_01_139.png) 矩阵，因此前面方程中的乘法是矩阵乘法。为了解这个矩阵方程，我们使用
    `linalg` 模块中的 `solve` 函数。为了说明这个技术，我们将通过解决以下方程组作为示例：
- en: '![](img/Formula_01_140.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_01_140.jpg)'
- en: 'These equations have three unknown values: ![](img/Formula_01_141.png), ![](img/Formula_01_142.png),
    and ![](img/Formula_01_143.png). First, we create a matrix of coefficients and
    the vector ![](img/Formula_01_144.png). Since we are using NumPy as our means
    of working with matrices and vectors, we create a two-dimensional NumPy array
    for the matrix ![](img/Formula_01_145.png) and a one-dimensional array for ![](img/Formula_01_146.png):'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方程有三个未知值：![](img/Formula_01_141.png)、![](img/Formula_01_142.png) 和 ![](img/Formula_01_143.png)。首先，我们创建一个系数矩阵和向量
    ![](img/Formula_01_144.png)。由于我们使用 NumPy 来处理矩阵和向量，我们为矩阵 ![](img/Formula_01_145.png)
    创建一个二维 NumPy 数组，并为 ![](img/Formula_01_146.png) 创建一个一维数组：
- en: '[PRE41]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now, the solution to the system of equations can be found using the `solve`
    routine:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，方程组的解可以使用 `solve` 函数找到：
- en: '[PRE42]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This is indeed the solution to the system of equations, which can be easily
    verified by computing `A @ x` and checking the result against the `b` array. There
    may be a floating-point rounding error in this computation.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实是方程组的解，可以通过计算 `A @ x` 并将结果与 `b` 数组进行比较来轻松验证。计算中可能会有浮动点舍入误差。
- en: The `solve` function expects two inputs, which are the matrix of coefficients
    ![](img/Formula_01_149.png) and the right-hand side vector ![](img/Formula_01_148.png).
    It solves the system of equations using routines that decompose matrix ![](img/Formula_01_150.png)
    into simpler matrices to quickly reduce to an easier problem that can be solved
    by simple substitution. This technique for solving matrix equations is extremely
    powerful and efficient and is less prone to the floating-point rounding errors
    that dog some other methods. For instance, the solution to a system of equations
    could be computed by multiplying (on the left) by the inverse of the matrix ![](img/Formula_01_151.png),
    if the inverse is known. However, this is generally not as good as using the `solve`
    routine since it may be slower or result in larger numerical errors.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`solve`期望两个输入，分别是系数矩阵 ![](img/Formula_01_149.png) 和右侧向量 ![](img/Formula_01_148.png)。它通过分解矩阵
    ![](img/Formula_01_150.png) 到更简单的矩阵，快速减少到可以通过简单替换解决的问题，来解决方程组。这种解决矩阵方程的技术非常强大和高效，并且不太容易受到困扰一些其他方法的浮点舍入误差。例如，通过乘以（左侧的）矩阵
    ![](img/Formula_01_151.png) 的逆来计算方程组的解，如果逆矩阵已知的话。然而，这通常不如使用`solve`例程好，因为它可能会更慢或者导致更大的数值误差。
- en: 'In the example we used, the coefficient matrix ![](img/Formula_01_152.png)
    was square. That is, there is the same number of equations as there are unknown
    values. In this case, the system of equations has a unique solution if (and only
    if) the determinant of this matrix ![](img/Formula_01_152.png) is not ![](img/Formula_01_153.png).
    In cases where the determinant of ![](img/Formula_01_154.png) is ![](img/Formula_01_155.png),
    one of two things can happen: the system can have no solution, in which case we
    say that the system is *inconsistent*, or there can be infinitely many solutions.
    The difference between a consistent and inconsistent system is usually determined
    by the vector ![](img/Formula_01_156.png). For example, consider the following
    systems of equations:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们使用的例子中，系数矩阵 ![](img/Formula_01_152.png) 是方阵。也就是说，方程的未知数与方程数量相同。在这种情况下，如果（且仅当）矩阵
    ![](img/Formula_01_152.png) 的行列式不是 ![](img/Formula_01_153.png) 时，方程组有唯一解。在行列式
    ![](img/Formula_01_154.png) 是 ![](img/Formula_01_155.png) 的情况下，可以出现两种情况：系统可能没有解，此时我们称系统为*不一致*；或者可能有无限多个解。通常一致和不一致系统的区别由向量
    ![](img/Formula_01_156.png) 决定。例如，考虑以下方程组：
- en: '![](img/Formula_01_157.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_01_157.jpg)'
- en: The left-hand system of equations is consistent and has infinitely many solutions;
    for instance, taking ![](img/Formula_01_158.png) and ![](img/Formula_01_159.png)
    or ![](img/Formula_01_160.png) and ![](img/Formula_01_161.png) are both solutions.
    The right-hand system of equations is inconsistent, and there are no solutions.
    In both of the preceding systems of equations, the `solve` routine will fail because
    the coefficient matrix is singular.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧方程组是一致的，并且有无限多个解；例如，取 ![](img/Formula_01_158.png) 和 ![](img/Formula_01_159.png)
    或者 ![](img/Formula_01_160.png) 和 ![](img/Formula_01_161.png) 都是解。右侧方程组不一致，并且没有解。在这两个方程组中，由于系数矩阵是奇异的，`solve`例程将失败。
- en: The coefficient matrix does not need to be square for the system to be solvable—for
    example, if there are more equations than there are unknown values (a coefficient
    matrix has more rows than columns). Such a system is said to be *over-specified*
    and, provided that it is consistent, it will have a solution. If there are fewer
    equations than there are unknown values, then the system is said to be *under-specified*.
    Under-specified systems of equations generally have infinitely many solutions
    if they are consistent since there is not enough information to uniquely specify
    all the unknown values. Unfortunately, the `solve` routine will not be able to
    find solutions for systems where the coefficient matrix is not square, even if
    the system does have a solution.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 系数矩阵不需要是方阵才能解决系统——例如，如果方程数量多于未知数（系数矩阵的行数多于列数）。这样的系统被称为*过度规范*，只要是一致的，它就会有解。如果方程数量少于未知数，则系统称为*欠规范*。如果是一致的话，欠规范方程组通常有无限多个解，因为没有足够的信息来唯一确定所有未知数值。不幸的是，即使系统有解，`solve`例程也无法找到系数矩阵不是方阵的系统的解。
- en: In the next section, we’ll discuss eigenvalues and eigenvectors, which arise
    by looking at a very specific kind of matrix equation, similar to those seen previously.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论特征值和特征向量，它们通过观察一种非常特定的矩阵方程得出，类似于之前看到的方程。
- en: Eigenvalues and eigenvectors
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特征值和特征向量
- en: Consider the matrix equation ![](img/Formula_01_162.png), where ![](img/Formula_01_163.png)
    is a square (![](img/Formula_01_164.png)) matrix, ![](img/Formula_01_165.png)
    is a vector, and ![](img/Formula_01_166.png) is a number. Numbers ![](img/Formula_01_167.png)
    for which there is an ![](img/Formula_01_168.png) that solves this equation are
    called *eigenvalues*, and the corresponding vectors ![](img/Formula_01_169.png)
    are called *eigenvectors*. Pairs of eigenvalues and corresponding eigenvectors
    encode information about the matrix ![](img/Formula_01_170.png), and are therefore
    important in many applications where matrices appear.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑矩阵方程 ![](img/Formula_01_162.png)，其中 ![](img/Formula_01_163.png) 是一个方阵（![](img/Formula_01_164.png)），
    ![](img/Formula_01_165.png) 是一个向量， ![](img/Formula_01_166.png) 是一个数值。对于能解此方程的数字
    ![](img/Formula_01_167.png)，它们称为*特征值*，而对应的向量 ![](img/Formula_01_169.png) 称为*特征向量*。特征值和对应特征向量的对编码了关于矩阵
    ![](img/Formula_01_170.png) 的信息，因此在许多涉及矩阵的应用中非常重要。
- en: 'We will demonstrate computing eigenvalues and eigenvectors using the following
    matrix:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过以下矩阵演示如何计算特征值和特征向量：
- en: '![](img/Formula_01_171.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_01_171.jpg)'
- en: 'We must first define this as a NumPy array:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须首先将其定义为一个 NumPy 数组：
- en: '[PRE43]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The `eig` routine in the `linalg` module is used to find the eigenvalues and
    eigenvectors of a square matrix. This routine returns a pair `(v, B)`, where `v`
    is a one-dimensional array containing the eigenvalues and `B` is a two-dimensional
    array whose columns are the corresponding eigenvectors:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`linalg` 模块中的 `eig` 函数用于找到方阵的特征值和特征向量。此函数返回一个元组 `(v, B)`，其中 `v` 是一个包含特征值的单维数组，`B`
    是一个二维数组，其列是相应的特征向量：'
- en: '[PRE44]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: It is perfectly possible for a matrix with only real entries to have complex
    eigenvalues and eigenvectors. For this reason, the return type of the `eig` routine
    will sometimes be a complex number type such as `complex32` or `complex64`. In
    some applications, complex eigenvalues have a special meaning, while in others
    we only consider the real eigenvalues.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 仅包含实数项的矩阵完全有可能具有复特征值和复特征向量。因此，`eig` 函数的返回类型有时会是 `complex32` 或 `complex64` 等复数类型。在某些应用中，复特征值具有特殊含义，而在其他情况下，我们只考虑实特征值。
- en: 'We can extract an eigenvalue/eigenvector pair from the output of `eig` using
    the following sequence:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下顺序从 `eig` 的输出中提取特征值/特征向量对：
- en: '[PRE45]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The eigenvectors returned by the `eig` routine are *normalized* so that they
    have norm (length) 1\. (The *Euclidean norm* is defined to be the square root
    of the sum of the squares of the members of the array.) We can check that this
    is the case by evaluating in the norm of the vector using the `norm` routine from
    `linalg`:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`eig` 函数返回的特征向量是*标准化*的，使得它们的范数（长度）为1。（*欧几里得范数*定义为数组成员的平方和的平方根。）我们可以通过使用 `linalg`
    中的 `norm` 函数计算向量的范数来验证这一点：'
- en: '[PRE46]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Finally, we can check that these values do indeed satisfy the definition of
    an eigenvalue/eigenvector pair by computing the product `A @ x0` and checking
    that, up to floating-point precision, this is equal to `lambda0*x0`:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以通过计算积 `A @ x0` 并检查它是否等于 `lambda0*x0`（精度到浮动点），来验证这些值确实满足特征值/特征向量对的定义：
- en: '[PRE47]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The norm computed here represents the *distance* between the left-hand side
    (`lhs`) and the right-hand side (`rhs`) of the equation ![](img/Formula_01_172.png).
    Since this distance is extremely small (0 to 14 decimal places), we can be fairly
    confident that they are actually the same. The fact that this is not zero is likely
    due to floating-point precision error.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这里计算的范数表示方程 ![](img/Formula_01_172.png) 的左边（`lhs`）和右边（`rhs`）之间的*距离*。由于这个距离非常小（精确到14位小数），我们可以相当确信它们实际上是相同的。这个距离不为零，可能是由于浮动点精度误差。
- en: 'The theoretical procedure for finding eigenvalues and eigenvectors is to first
    find the eigenvalues ![](img/Formula_01_173.png) by solving the following equation:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找特征值和特征向量的理论过程是首先通过求解以下方程来找到特征值 ![](img/Formula_01_173.png)：
- en: '![](img/Formula_01_174.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_01_174.jpg)'
- en: 'Here, ![](img/Formula_01_175.png) is the appropriate identity matrix. The equation
    determined by the left-hand side is a polynomial in ![](img/Formula_01_176.png)
    and is called the **characteristic polynomial** of ![](img/Formula_01_177.png).
    The eigenvector corresponding to the eigenvalue ![](img/Formula_01_178.png) can
    then be found by solving the following matrix equation:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，![](img/Formula_01_175.png) 是合适的单位矩阵。左边方程所确定的是一个关于 ![](img/Formula_01_176.png)
    的多项式，称为 ![](img/Formula_01_177.png) 的**特征多项式**。对应于特征值 ![](img/Formula_01_178.png)
    的特征向量可以通过求解以下矩阵方程来找到：
- en: '![](img/Formula_01_179.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_01_179.jpg)'
- en: In practice, this process is somewhat inefficient, and there are alternative
    strategies for computing eigenvalues and eigenvectors numerically more efficiently.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，这个过程有些低效，存在其他更高效的计算特征值和特征向量的策略。
- en: 'We can only compute eigenvalues and eigenvectors for square matrices; for non-square
    matrices, the definition does not make sense. There is a generalization of eigenvalues
    and eigenvectors to non-square matrices called **singular values**. The trade-off
    that we have to make in order to do this is that we must compute two vectors ![](img/Formula_01_180.png)
    and ![](img/Formula_01_181.png), and a singular value ![](img/Formula_01_182.png)
    that solves the following equation:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只能对方阵计算特征值和特征向量；对于非方阵，定义是没有意义的。特征值和特征向量的一个推广应用是用于非方阵的称为**奇异值**。为了做到这一点，我们必须计算两个向量
    ![](img/Formula_01_180.png) 和 ![](img/Formula_01_181.png)，以及一个奇异值 ![](img/Formula_01_182.png)，它满足以下方程：
- en: '![](img/Formula_01_183.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_01_183.jpg)'
- en: If ![](img/Formula_01_184.png) is an ![](img/Formula_01_185.png) matrix, then
    ![](img/Formula_01_186.png) will have ![](img/Formula_01_187.png) elements and
    ![](img/Formula_01_188.png) will have ![](img/Formula_01_189.png) elements. The
    interesting ![](img/Formula_01_190.png) vectors are actually the (orthonormal)
    eigenvectors of the symmetric matrix ![](img/Formula_01_191.png) with the eigenvalue
    ![](img/Formula_01_192.png). From these values, we can find the ![](img/Formula_01_193.png)
    vectors using the previous defining equation. This will generate all of the interesting
    combinations, but there are additional vectors ![](img/Formula_01_194.png) and
    ![](img/Formula_01_195.png) where ![](img/Formula_01_196.png) and ![](img/Formula_01_197.png).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 ![](img/Formula_01_184.png) 是一个 ![](img/Formula_01_185.png) 矩阵，那么 ![](img/Formula_01_186.png)
    将有 ![](img/Formula_01_187.png) 个元素，且 ![](img/Formula_01_188.png) 将有 ![](img/Formula_01_189.png)
    个元素。感兴趣的 ![](img/Formula_01_190.png) 向量实际上是对称矩阵 ![](img/Formula_01_191.png) 的（正交规范化）特征向量，对应的特征值是
    ![](img/Formula_01_192.png)。根据这些值，我们可以使用之前的定义方程找到 ![](img/Formula_01_193.png)
    向量。这将生成所有有趣的组合，但还存在其他向量 ![](img/Formula_01_194.png) 和 ![](img/Formula_01_195.png)，其中
    ![](img/Formula_01_196.png) 和 ![](img/Formula_01_197.png)。
- en: 'The utility of singular values (and vectors) comes from the **singular value
    decomposition** (**SVD**), which writes the matrix ![](img/Formula_01_198.png)
    as a product:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 奇异值（和奇异向量）的实用性来自于**奇异值分解**（**SVD**），它将矩阵 ![](img/Formula_01_198.png) 写作一个乘积：
- en: '![](img/Formula_01_199.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_01_199.jpg)'
- en: 'Here, ![](img/Formula_01_200.png) has orthogonal columns and ![](img/Formula_01_201.png)
    has orthogonal rows, and ![](img/Formula_01_202.png) is a diagonal matrix, usually
    written so that the values decrease as one moves along the leading diagonal. We
    can write this formula out in a slightly different way, as follows:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，![](img/Formula_01_200.png) 具有正交列，![](img/Formula_01_201.png) 具有正交行，且 ![](img/Formula_01_202.png)
    是一个对角矩阵，通常写成沿主对角线的值递减。我们可以以稍微不同的方式写出这个公式，如下所示：
- en: '![](img/Formula_01_203.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_01_203.jpg)'
- en: What this says is that any matrix can be decomposed into a weight sum of *outer
    products*—pretend ![](img/Formula_01_204.png) and ![](img/Formula_01_205.png)
    are matrices with ![](img/Formula_01_206.png) rows and ![](img/Formula_01_207.png)
    column and matrix multiply ![](img/Formula_01_208.png) with the transpose of ![](img/Formula_01_209.png)
    – of vectors.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着任何矩阵都可以分解为*外积*的加权和——假设 ![](img/Formula_01_204.png) 和 ![](img/Formula_01_205.png)
    是具有 ![](img/Formula_01_206.png) 行和 ![](img/Formula_01_207.png) 列的矩阵，并且矩阵乘法 ![](img/Formula_01_208.png)
    与 ![](img/Formula_01_209.png) 的转置相乘——这些是向量。
- en: Once we have performed this decomposition, we can look for ![](img/Formula_01_210.png)
    values that are especially small, which contribute very little to the value of
    the matrix. If we throw away the terms with small ![](img/Formula_01_211.png)
    values, then we can effectively approximate the original matrix by a simpler representation.
    This technique is used in **principal component analysis** (**PCA**)—for example,
    to reduce a complex, high-dimensional dataset to a few components that contribute
    the most to the overall character of the data.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成了这种分解，我们可以寻找那些特别小的![](img/Formula_01_210.png)值，这些值对矩阵的值贡献很小。如果我们丢弃那些具有小![](img/Formula_01_211.png)值的项，那么就可以通过更简单的表示有效地逼近原始矩阵。这种技术被应用于**主成分分析**（**PCA**）——例如，将复杂的高维数据集简化为几个对数据整体特征贡献最大的成分。
- en: 'In Python, we can use the `linalg.svd` function to compute the SVD of a matrix.
    This works in a similar way to the `eig` routine described previously, except
    it returns the three components of the decomposition:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，我们可以使用`linalg.svd`函数来计算矩阵的SVD。它的工作方式类似于之前描述的`eig`例程，不同之处在于它返回分解的三个组件：
- en: '[PRE48]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The arrays returned from this function have shapes `(2, 2)`, `(2,)`, and `(4,
    4)`, respectively. As the names suggest, the `U` matrix and `VT` matrices are
    those that appear in the decomposition, and `s` is a one-dimensional vector containing
    the nonzero singular values. We can check that decomposition is correct by reconstructing
    the ![](img/Formula_01_212.png) matrix and evaluating the product of the three
    matrices:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数返回的数组形状分别为`(2, 2)`、`(2,)`和`(4, 4)`。顾名思义，`U`矩阵和`VT`矩阵是出现在分解中的矩阵，`s`是一个包含非零奇异值的一维向量。我们可以通过重构![](img/Formula_01_212.png)矩阵并计算三个矩阵的乘积来检查分解是否正确：
- en: '[PRE49]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Notice that the matrix has been reconstructed almost exactly, except for the
    first entry. The value in the top-left entry is very close to zero—within floating
    point error—so can be considered zero.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到矩阵几乎完全被重构，唯一的不同是第一个元素。左上角的值非常接近零——在浮动点误差范围内——因此可以视为零。
- en: 'Our method for constructing the matrix ![](img/Formula_01_213.png) is rather
    inconvenient. The SciPy version of the `linalg` module contains a special routine
    for reconstructing this matrix from the one-dimensional array of singular values
    called `linalg.diagsvd`. This routine takes the array of singular values, `s`,
    and the shape of the original matrix and constructs the matrix ![](img/Formula_01_214.png)
    with the appropriate shape:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们构造矩阵![](img/Formula_01_213.png)的方法相当不方便。SciPy版本的`linalg`模块包含一个特殊例程，可以通过奇异值的一维数组重构这个矩阵，叫做`linalg.diagsvd`。这个例程接受奇异值数组`s`和原始矩阵的形状，并构建具有适当形状的矩阵![](img/Formula_01_214.png)：
- en: '[PRE50]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: (Recall that the SciPy package is imported under the alias `sp`.) Now, let’s
    change pace and look at how we might be more efficient in the way we describe
    matrices in which most of the entries are zero. These are the so-called sparse
    matrices.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: （回顾一下，SciPy包是通过别名`sp`导入的。）现在，让我们换个节奏，看看如何更高效地描述大多数条目为零的矩阵。这些就是所谓的稀疏矩阵。
- en: Sparse matrices
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 稀疏矩阵
- en: Systems of linear equations such as those discussed earlier are extremely common
    throughout mathematics and, in particular, in mathematical computing. In many
    applications, the coefficient matrix will be extremely large, with thousands of
    rows and columns, and will likely be obtained from an alternative source rather
    than simply entering by hand. In many cases, it will also be a *sparse* matrix,
    where most of the entries are 0.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 之前讨论的线性方程组在数学中极为常见，尤其是在数学计算中。在许多应用中，系数矩阵通常非常大，包含成千上万的行列，并且很可能不是手动输入的，而是从其他来源获得的。在许多情况下，它还将是一个*稀疏*矩阵，其中大多数条目为0。
- en: A matrix is **sparse** if a large number of its elements are zero. The exact
    number of elements that need to be zero in order to call a matrix sparse is not
    well defined. Sparse matrices can be represented more efficiently—for example,
    by simply storing the indexes ![](img/Formula_01_215.png) and the values ![](img/Formula_01_216.png)
    that are nonzero. There are entire collections of algorithms for sparse matrices
    that offer great improvements in performance, assuming the matrix is indeed sufficiently
    sparse.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个矩阵的大多数元素为零，则该矩阵是**稀疏的**。确切的零元素数量，用于判断一个矩阵是否稀疏，并没有明确的定义。稀疏矩阵可以更有效地表示——例如，简单地存储非零元素的索引![](img/Formula_01_215.png)和值![](img/Formula_01_216.png)。对于稀疏矩阵，有一整套算法可以显著提升性能，前提是矩阵确实足够稀疏。
- en: Sparse matrices appear in many applications, and often follow some kind of pattern.
    In particular, several techniques for solving `sparse.csgraph` module. We will
    discuss these further in [*Chapter 5*](B19085_05.xhtml#_idTextAnchor178), *Working
    with Trees* *and Networks*.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 稀疏矩阵出现在许多应用中，通常遵循某种模式。特别是，有几种技术用于求解`sparse.csgraph`模块。我们将在[*第五章*](B19085_05.xhtml#_idTextAnchor178)中进一步讨论这些内容，*与树*
    *和网络*的工作。
- en: The `sparse` module contains several different classes representing the different
    means of storing a sparse matrix. The most basic means of storing a sparse matrix
    is to store three arrays, two containing integers representing the indices of
    nonzero elements, and the third the data of the corresponding element. This is
    the format of the `coo_matrix` class. Then, there are the `csc_matrix`) and the
    `csr_matrix`) formats, which provide efficient column or row slicing, respectively.
    There are three additional sparse matrix classes in `sparse`, including `dia_matrix`,
    which efficiently stores matrices where the nonzero entries appear along a diagonal
    band.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`sparse`模块包含几种不同的类，表示存储稀疏矩阵的不同方式。存储稀疏矩阵的最基本方式是存储三个数组，其中两个包含表示非零元素索引的整数，第三个数组包含相应元素的数据。这是`coo_matrix`类的格式。然后，还有`csc_matrix`和`csr_matrix`格式，分别提供高效的列或行切片操作。`sparse`模块中还有三个额外的稀疏矩阵类，其中包括`dia_matrix`，它高效地存储矩阵，其中非零元素出现在对角带上。'
- en: 'The `sparse` module from SciPy contains routines for creating and working with
    sparse matrices. We import the `sparse` module from SciPy using the following
    `import` statement:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: SciPy中的`sparse`模块包含创建和处理稀疏矩阵的例程。我们使用以下`import`语句从SciPy导入`sparse`模块：
- en: '[PRE51]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: A sparse matrix can be created from a full (dense) matrix or some other kind
    of data structure. This is done using the constructor for the specific format
    in which you wish to store the sparse matrix.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 稀疏矩阵可以从一个完整的（密集的）矩阵或其他类型的数据结构中创建。这是通过使用特定格式的构造函数来完成的，该格式指定了你希望存储稀疏矩阵的方式。
- en: 'For example, we can take a dense matrix and store it in CSR format by using
    the following command:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以通过使用以下命令，将一个密集矩阵存储为CSR格式：
- en: '[PRE52]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'If you are generating a sparse matrix by hand, the matrix probably follows
    some kind of pattern, such as the following *tridiagonal* matrix:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你手动生成稀疏矩阵，矩阵可能遵循某种模式，例如下面的*三对角*矩阵：
- en: '![](img/Formula_01_217.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_01_217.jpg)'
- en: 'Here, the nonzero entries appear on the diagonal and on either side of the
    diagonal, and the nonzero entries in each row follow the same pattern. To create
    such a matrix, we could use one of the array creation routines in `sparse` such
    as `diags`, which is a convenience routine for creating matrices with diagonal
    patterns:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，非零元素出现在对角线上以及对角线的两侧，并且每行中的非零元素遵循相同的模式。为了创建这样的矩阵，我们可以使用`sparse`中的一个数组创建例程，如`diags`，它是一个方便的例程，用于创建具有对角线模式的矩阵：
- en: '[PRE53]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'This will create a matrix ![](img/Formula_01_218.png), as described previously,
    and store it as a sparse matrix in CSR format. The first argument specifies the
    values that should appear in the output matrix, and the second argument is the
    positions relative to the diagonal position in which the values should be placed.
    So, the 0 index in the tuple represents the diagonal entry, -1 is to the left
    of the diagonal in the row, and +1 is to the right of the diagonal in the row.
    The `shape` keyword argument gives the dimensions of the matrix produced, and
    the `format` specifies the storage format for the matrix. If no format is provided
    using the optional argument, then a reasonable default will be used. The array
    `T` can be expanded to a full (*dense*) matrix using the `toarray` method:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个矩阵 ![](img/Formula_01_218.png)，如前所述，并将其存储为 CSR 格式的稀疏矩阵。第一个参数指定应出现在输出矩阵中的值，第二个参数是相对于对角线位置的值应放置的位置。因此，元组中的
    0 索引表示对角线条目，-1 表示位于行中对角线的左侧，+1 表示位于行中对角线的右侧。`shape` 关键字参数指定生成矩阵的维度，而 `format`
    指定矩阵的存储格式。如果未使用可选参数提供格式，则将使用合理的默认格式。数组 `T` 可以使用 `toarray` 方法扩展为完整的（*密集*）矩阵：
- en: '[PRE54]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: When the matrix is small (as it is here), there is little difference in performance
    between the sparse solving routine and the usual solving routines.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 当矩阵较小时（如这里所示），稀疏求解算法与常规求解算法在性能上几乎没有差异。
- en: 'Once a matrix is stored in a sparse format, we can use the sparse solving routines
    in the `linalg` submodule of `sparse`. For example, we can solve a matrix equation
    using the `spsolve` routine from this module. The `spsolve` routine will convert
    the matrix into CSR or CSC, which may add additional time to the computation if
    it is not provided in one of these formats:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦矩阵存储为稀疏格式，我们可以使用 `sparse` 模块中 `linalg` 子模块中的稀疏求解函数。例如，我们可以使用该模块中的 `spsolve`
    函数来求解矩阵方程。`spsolve` 函数会将矩阵转换为 CSR 或 CSC 格式，如果它没有以这两种格式之一提供，可能会增加计算的时间：
- en: '[PRE55]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The `sparse.linalg` module also contains many of the routines that can be found
    in the `linalg` module of NumPy (or SciPy) that accept sparse matrices instead
    of full NumPy arrays, such as `eig` and `inv`.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`sparse.linalg` 模块还包含许多 NumPy（或 SciPy）中 `linalg` 模块的常见函数，这些函数接受稀疏矩阵而非完整的 NumPy
    数组，如 `eig` 和 `inv`。'
- en: This concludes our tour of the basic tools for mathematics available in Python
    and its ecosystem. Let’s summarize what we’ve seen.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们对 Python 及其生态系统中可用的数学基本工具的简要介绍。让我们总结一下我们所看到的内容。
- en: Summary
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Python offers built-in support for mathematics with some basic numerical types,
    arithmetic, extended precision numbers, rational numbers, complex numbers, and
    a variety of basic mathematical functions. However, for more serious computations
    involving large arrays of numerical values, you should use the NumPy and SciPy
    packages. NumPy provides high-performance array types and basic routines, while
    SciPy provides more specific tools for solving equations and working with sparse
    matrices (among many other things).
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: Python 提供了内置的数学支持，包括一些基本的数值类型、算术运算、扩展精度数字、有理数、复数以及各种基本数学函数。然而，对于涉及大规模数值数组的更复杂计算，应该使用
    NumPy 和 SciPy 包。NumPy 提供高性能的数组类型和基本操作，而 SciPy 提供了更专业的工具，用于求解方程和处理稀疏矩阵（还有许多其他功能）。
- en: NumPy arrays can be multi-dimensional. Two-dimensional arrays have matrix properties
    that can be accessed using the `linalg` module from either NumPy or SciPy (the
    former is a subset of the latter). Moreover, there is a special operator in Python
    for matrix multiplication, `@`, which is implemented for NumPy arrays. SciPy also
    provides support for sparse matrices via the `sparse` module. We also touched
    on matrix theory and linear algebra, which underpins most of the numerical methods
    found in this book—often behind the scenes.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 数组可以是多维的。二维数组具有矩阵特性，可以通过 NumPy 或 SciPy 的 `linalg` 模块访问（前者是后者的一个子集）。此外，Python
    中有一个特殊的矩阵乘法运算符 `@`，它已在 NumPy 数组中实现。SciPy 还通过 `sparse` 模块提供对稀疏矩阵的支持。我们还简要介绍了矩阵理论和线性代数，这些是本书中大多数数值方法的基础——通常是幕后工作。
- en: In the next chapter, we’ll get started looking at some recipes.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始查看一些示例。
- en: Further reading
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'There are many mathematical textbooks describing the basic properties of matrices
    and linear algebra, which is the study of vectors and matrices. The following
    are good introductory texts for linear algebra:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多数学教材描述了矩阵和线性代数的基本性质，线性代数是研究向量和矩阵的学科。以下是适合线性代数入门的好书：
- en: '*Strang, G.* (2016). *Introduction to Linear Algebra*. *Wellesley, MA: Wellesley-Cambridge
    Press,* *Fifth Edition*.'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Strang, G.* (2016). *线性代数导论*。*马萨诸塞州韦尔斯利：韦尔斯利-剑桥出版社，* *第五版*。'
- en: '*Blyth, T.* and *Robertson, E.* (2013). *Basic Linear Algebra*. *London: Springer*
    *London, Limited*.'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Blyth, T.* 和 *Robertson, E.* (2013). *基础线性代数*。*伦敦：斯普林格* *伦敦有限公司*。'
- en: NumPy and SciPy are part of the Python mathematical and scientific computing
    ecosystem and have extensive documentation that can be accessed from the official
    website, [https://scipy.org](https://scipy.org). We will see several other packages
    from this ecosystem throughout this book.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 和 SciPy 是 Python 数学和科学计算生态系统的一部分，并且有着丰富的文档，可以从官方网站 [https://scipy.org](https://scipy.org)
    访问。在本书中，我们将看到该生态系统中的其他几个包。
- en: 'More information about the BLAS and LAPACK libraries that NumPy and SciPy use
    behind the scenes can be found at the following links:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 NumPy 和 SciPy 在后台使用的 BLAS 和 LAPACK 库的更多信息，可以通过以下链接找到：
- en: 'BLAS: [https://www.netlib.org/blas/](https://www.netlib.org/blas/)'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'BLAS: [https://www.netlib.org/blas/](https://www.netlib.org/blas/)'
- en: 'LAPACK: [https://www.netlib.org/lapack/](https://www.netlib.org/lapack/)'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'LAPACK: [https://www.netlib.org/lapack/](https://www.netlib.org/lapack/)'
