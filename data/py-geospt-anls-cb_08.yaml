- en: Chapter 8. Network Routing Analysis
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章 网络路由分析
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Finding the Dijkstra shortest path with pgRouting
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用pgRouting找到Dijkstra最短路径
- en: Finding the Dijkstra shortest path with NetworkX in pure Python
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用纯Python中的NetworkX找到Dijkstra最短路径
- en: Generating evacuation polygons based on an indoor shortest path
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据室内最短路径生成疏散多边形
- en: Creating centerlines from polygons
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从多边形创建中心线
- en: Building an indoor routing system in 3D
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在3D中构建室内路由系统
- en: Calculating indoor route walk time
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算室内路线步行时间
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Routing has become commonplace on navigation devices for road networks across
    the world. If you want to know how to drive from point A to point B, simply enter
    the start address and end address into your navigation software and it will calculate
    the shortest route for you in seconds.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 路由已成为全球道路网络导航设备上的常见功能。如果您想知道如何从点A开车到点B，只需将起始地址和结束地址输入到您的导航软件中，它将在几秒钟内为您计算出最短路线。
- en: 'Here''s a scenario you may come across: Route me to Prof. Dr. Smith''s office
    in the Geography Department for my meeting at any university anywhere. Hmm, sorry,
    there''s no routing network available on my navigation software. This is a reminder
    for you to not to forget to ask for directions on campus for your meeting location.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个你可能遇到的场景：把我带到任何大学地理系的Smith教授办公室，以便参加我的会议。嗯，抱歉，我的导航软件上没有可用的路由网络。这是提醒您不要忘记在校园内询问您的会议地点方向。
- en: This chapter is all about routing and, specifically, routing inside large building
    complexes from office *A33*, first floor in building *E01* to office *B55*, sixth
    floor in building *P7*.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章全部关于路由，特别是从办公室 *A33*（位于建筑 *E01* 的第一层）到办公室 *B55*（位于建筑 *P7* 的第六层）的室内大型建筑群内的路由。
- en: '![Introduction](img/50790OS_08_01.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![简介](img/50790OS_08_01.jpg)'
- en: We will explore the powerful routing capabilities of **pgRouting**, an extension
    of PostgreSQL. With pgRouting, we can calculate the shortest path using either
    the Dijkstra, A*, and/or K shortest path algorithms. Alongside pgRouting, we will
    use a pure Python solution with the NetworkX library to generate a route from
    the same source data.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探索**pgRouting**（PostgreSQL的一个扩展）强大的路由功能。使用pgRouting，我们可以使用Dijkstra、A*和/或K最短路径算法中的任何一个来计算最短路径。除了pgRouting，我们还将使用NetworkX库的纯Python解决方案，从相同的数据源生成路线。
- en: Note
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'BIG IMPORTANT NOTE. Pay attention to the input network dataset used and make
    sure that it is in the EPSG: 3857 coordinate system, a geometric Cartesian meter
    system. Routing calculations using world coordinates in EPSG: 4326 must be converted
    if used by such a system. Also, note that the GeoJSON coordinate system is interpreted
    by QGIS as EPSG:4326 even though the coordinates are stored in EPSG:3857!'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '重要提示。请注意使用的输入网络数据集，并确保它位于EPSG: 3857坐标系中，这是一个几何笛卡尔米制系统。如果使用EPSG: 4326世界坐标系进行路由计算，则必须进行转换。此外，请注意，即使坐标存储在EPSG:
    3857中，QGIS也将GeoJSON坐标系解释为EPSG: 4326！'
- en: Finding the Dijkstra shortest path with pgRouting
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用pgRouting找到Dijkstra最短路径
- en: There are a few Python libraries out there, such as **networkX** and **scikit-image**,
    that can find the shortest path over a raster or NumPy array. We want to focus
    on routing over a vector source and returning a vector dataset; therefore, pgRouting
    is a natural choice for us. Custom Python *Dijkstra* or the *A Star (A*)* shortest
    path algorithms exist but one that performs well on large networks is hard to
    find. The `pgRouting` extension of PostgreSQL is used by OSM and many other projects
    and is well tested.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有几个Python库，例如**networkX**和**scikit-image**，可以在栅格或NumPy数组上找到最短路径。我们希望专注于矢量源的路由并返回矢量数据集；因此，pgRouting是我们自然的选择。虽然存在自定义Python
    *Dijkstra* 或 *A Star (A*)* 最短路径算法，但找到一个在大网络上表现良好的算法是困难的。PostgreSQL的`pgRouting`扩展被OSM和其他许多项目使用，并且经过了良好的测试。
- en: Our example will have us load a Shapefile of an indoor network from one floor
    for simplicity's sake. An indoor network is comprised of network lines that go
    along the hallways and open walkable spaces within a building, leading to a door
    in most cases.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例将让我们为了简单起见，从一个楼层的室内网络加载Shapefile。室内网络由沿着建筑物走廊和开放步行空间的网络线组成，通常通向一扇门。
- en: Getting ready
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we are going to need to set up our PostGIS database with the
    pgRouting extension. On a Windows machine, you can install pgRouting by downloading
    a ZIP file for Postgresql 9.3 at [http://winnie.postgis.net/download/windows/pg93/buildbot/](http://winnie.postgis.net/download/windows/pg93/buildbot/).
    Then, extract the zip file into `C:\Program Files\PostgreSQL\9.3\`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们需要设置带有 pgRouting 扩展的 PostGIS 数据库。在 Windows 机器上，您可以通过下载 Postgresql 9.3
    的 ZIP 文件来安装 pgRouting，网址为 [http://winnie.postgis.net/download/windows/pg93/buildbot/](http://winnie.postgis.net/download/windows/pg93/buildbot/)。然后，将
    ZIP 文件解压到 `C:\Program Files\PostgreSQL\9.3\`。
- en: For Ubuntu Linux users, the pgRouting website explains the details at [http://docs.pgrouting.org/2.0/en/doc/src/installation/index.html#ubuntu-debian](http://docs.pgrouting.org/2.0/en/doc/src/installation/index.html#ubuntu-debian).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Ubuntu Linux 用户，pgRouting 网站在 [http://docs.pgrouting.org/2.0/en/doc/src/installation/index.html#ubuntu-debian](http://docs.pgrouting.org/2.0/en/doc/src/installation/index.html#ubuntu-debian)
    解释了详细信息。
- en: 'To enable this extension, you have a couple of options. First off, you can
    run the command-line `psql` tool to activate the extension as follows if you have
    your PostgreSQL running as explained in [Chapter 1](ch01.html "Chapter 1. Setting
    Up Your Geospatial Python Environment"), *Setting Up Your Geospatial Python Environment*:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用此扩展，您有几个选择。首先，如果您已按照 [第 1 章](ch01.html "第 1 章。设置您的地理空间 Python 环境") 中所述设置
    PostgreSQL，则可以运行命令行 `psql` 工具来激活扩展，如下所示：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You can use the **pgAdmin** user tool by simply opening up the `py_geoan_cb`
    database, right-clicking on **Extensions**, selecting **New Extension...,** and
    in the **Name** field, scrolling down to find the `pgRouting` entry and selecting
    it.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过打开 `py_geoan_cb` 数据库，右键单击 **Extensions**，选择 **New Extension...,** 并在 **Name**
    字段中向下滚动以找到 `pgRouting` 条目并选择它来使用 **pgAdmin** 用户工具。
- en: 'Now we need some data to do our routing calculations. The data used is a Shapefile
    located in your `/ch08/geodata/shp/e01_network_lines_3857.shp` folder. Take a
    look at [Chapter 3](ch03.html "Chapter 3. Moving Spatial Data from One Format
    to Another"), *Moving Spatial Data from One Format to Another*, on how to import
    the Shapefile or use `shp2pgsql`. Here is the command-line one-liner using `ogr2ogr`
    to import the Shapefile:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要一些数据进行路由计算。使用的数据是位于您 `/ch08/geodata/shp/e01_network_lines_3857.shp` 文件夹中的
    Shapefile。请参阅 [第 3 章](ch03.html "第 3 章。将空间数据从一个格式移动到另一个格式")，了解如何导入 Shapefile 或使用
    `shp2pgsql`。以下是使用 `ogr2ogr` 导入 Shapefile 的命令行单行命令：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note that you either use the same username and password from [Chapter 1](ch01.html
    "Chapter 1. Setting Up Your Geospatial Python Environment"), *Setting Up Your
    Geospatial Python Environment*, or your own defined username and password.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，您可以使用 [第 1 章](ch01.html "第 1 章。设置您的地理空间 Python 环境") 中相同的用户名和密码，或者您自己的定义的用户名和密码。
- en: For Windows users, you might need to insert the full path of your Shapefile,
    something that could look like `c:\somepath\geodata\shp\e01_network_lines.shp`.
    We explicitly set the input of the EPSG:3857 Web Mercator because, sometimes,
    ogr2ogr guesses the wrong projection and in this way, it ensures that it is correct
    on upload. Another thing to note is that we also explicitly define the output
    table column types because `ogr2ogr` uses numeric fields for our integers and
    this does not go well with `pgRouting`, so we explicitly pass the comma-separated
    list of field names and field types.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Windows 用户，您可能需要插入您的 Shapefile 的完整路径，这可能看起来像 `c:\somepath\geodata\shp\e01_network_lines.shp`。我们明确设置
    EPSG:3857 Web Mercator 的输入，因为有时 ogr2ogr 估计的投影是错误的，这样就可以确保上传时是正确的。另一个需要注意的事项是我们还明确定义了输出表列类型，因为
    `ogr2ogr` 使用数字字段来表示我们的整数，而这与 `pgRouting` 不兼容，所以我们明确传递了字段名称和字段类型的逗号分隔列表。
- en: Tip
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: For a detailed description of how ogr2ogr works, visit [http://gdal.org/ogr2ogr.html](http://gdal.org/ogr2ogr.html).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 要详细了解 ogr2ogr 的工作原理，请访问 [http://gdal.org/ogr2ogr.html](http://gdal.org/ogr2ogr.html)。
- en: Our new table includes two fields, one called `type` and the other, `type_id`.
    The `type_id` variable will store an integer used to identify what kind of network
    segment we are on, such as stairs, an indoor way, or elevator. The remaining fields
    are necessary for `pgRouting`, which is installed as shown in the following code,
    and include columns called `source`, `target`, and `cost`. The `source` and `target`
    columns both need to be integers, while the `cost` field is of a double precision
    type. These types are the requirements of the pgRouting functions.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新表包括两个字段，一个称为 `type`，另一个称为 `type_id`。`type_id` 变量将存储一个整数，用于识别我们所在的网络段类型，例如楼梯、室内路径或电梯。其余字段对于
    `pgRouting` 是必要的，如以下代码所示，包括名为 `source`、`target` 和 `cost` 的列。`source` 和 `target`
    列都需要是整数，而 `cost` 字段是双精度类型。这些类型是 pgRouting 函数的要求。
- en: 'Let''s go ahead and add these fields now to our `ch08_e01_networklines` table
    with the help of some SQL queries:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续添加这些字段到我们的 `ch08_e01_networklines` 表中，借助一些 SQL 查询：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Once the network dataset has its new columns, we need to run the create topology
    `pgr_createTopology()`function. This function takes the name of our network dataset,
    a tolerance value, geometry field name, and a primary key field name. The function
    will create a new table of points on the LineString intersections, that is, nodes
    on a network that are in the same schema:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦网络数据集有了新的列，我们需要运行创建拓扑的 `pgr_createTopology()` 函数。这个函数接受我们的网络数据集名称、容差值、几何字段名称和主键字段名称。该函数将在
    LineString 交点处创建一个新的点表，即网络中的节点，它们具有相同的模式：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `pgr_createTopology` function parameters include the name of the networklines
    LineStrings containing our cost and type fields. The second parameter is the distance
    tolerance in meters followed by the name of the geometry column and our primary
    key unique id called `ogc_fid`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`pgr_createTopology` 函数的参数包括包含我们的成本和类型字段的网络线 LineStrings 的名称。第二个参数是米为单位的距离容差，然后是几何列的名称和我们的主键唯一标识符
    `ogc_fid`。'
- en: Now that our tables and environment are set up, this allows us to actually create
    the shortest path called the Dijkstra route.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了表和环境，这使我们能够实际创建最短路径，称为迪杰斯特拉路线。
- en: To run the Python code, make sure you have the `psycopg2` and `geojson` modules
    installed as described in [Chapter 1](ch01.html "Chapter 1. Setting Up Your Geospatial
    Python Environment"), *Setting Up Your Geospatial Python Environment*.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行 Python 代码，请确保你已经按照[第1章](ch01.html "第1章。设置你的地理空间Python环境")中描述的安装了 `psycopg2`
    和 `geojson` 模块，*设置你的地理空间Python环境*。
- en: How to do it...
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Check out this code and follow along:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看以下代码并跟随操作：
- en: '[PRE4]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The resulting query, if you ran it inside `pgAdmin`, for example, would return
    the following:![How to do it...](img/50790OS_08_02.jpg)
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你在例如 `pgAdmin` 中运行这个查询，得到的结果如下：![如何操作...](img/50790OS_08_02.jpg)
- en: 'A route needs to be visualized on a map and not as a table. Go ahead and drag
    and drop your newly created `/ch08/geodata/ch08_shortest_path_pgrouting.geojson`
    file into QGIS. If all goes well, you should see this pretty little line, excluding
    the red arrows and text:'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一条路线需要在地图上可视化，而不是表格中。将你新创建的 `/ch08/geodata/ch08_shortest_path_pgrouting.geojson`
    文件拖放到 QGIS 中。如果一切顺利，你应该看到这条漂亮的小线，不包括红色箭头和文本：
- en: '![How to do it...](img/50790OS_08_03.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/50790OS_08_03.jpg)'
- en: How it works...
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Our code journey starts with setting up our database connection so that we can
    execute some queries against our uploaded data.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码之旅从设置数据库连接开始，以便我们可以对上传的数据执行一些查询。
- en: Now we are ready to run some routing, but wait, How do we set the start and
    end points that we want to route to and from? The natural way to do this is to
    input and the x, y coordinate pair for the start and end points. Unfortunately,
    the `pgr_dijkstra()` function takes only the start and end node IDs. This means
    that we need to get these node IDs from the new table called `ch08_e01_networklines_vertices_pgr`.
    To locate the nodes, we use a simple PostGIS function, `ST_Within()`, to find
    the nearest node within one meter from the input coordinate. Inside this query,
    our input geometry uses the `ST_GeomFromText()` function so that you can clearly
    see where things go in our SQL. Now, we'll execute our query and convert the response
    to an integer value as our node ID. This node ID is then ready for input in the
    next and final query.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好运行一些路由，但是等等，我们如何设置我们想要路由的起点和终点？自然的方法是输入起点和终点的x，y坐标对。不幸的是，`pgr_dijkstra()`
    函数只接受起点和终点节点ID。这意味着我们需要从名为 `ch08_e01_networklines_vertices_pgr` 的新表中获取这些节点ID。为了定位节点，我们使用一个简单的PostGIS函数
    `ST_Within()` 来找到距离输入坐标一米内的最近节点。在这个查询中，我们的输入几何形状使用 `ST_GeomFromText()` 函数，这样你就可以清楚地看到SQL中的事情。现在，我们将执行我们的查询并将响应转换为整数值作为我们的节点ID。这个节点ID就准备好输入到下一个和最终的查询中。
- en: The routing query will return a sequence number, node, edge, cost, and geometry
    for each segment along our final route. The geometry created is GeoJSON using
    the `ST_AsGeoJSON()` PostGIS function that feeds the creation of our final GeoJSON
    output route.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 路由查询将为最终路线上的每个段落返回一个序列号、节点、边、成本和几何形状。创建的几何形状是使用 `ST_AsGeoJSON()` PostGIS 函数创建的
    GeoJSON，该函数用于生成我们的最终GeoJSON输出路线。
- en: The pgRouting `pgr_dijkstra()`function's input arguments include an SQL query,
    start node ID, end node ID, directed value, and a `has_rcost` Boolean value. We
    set the `directed` and `has_rcost` values to `False`, while passing in the `start_node`
    and `end_node` IDs. This query performs a `JOIN` between the generated route IDs
    and input network IDs so that we have some geometry output to visualize.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: pgRouting的 `pgr_dijkstra()` 函数的输入参数包括一个SQL查询、起点节点ID、终点节点ID、有向值和一个 `has_rcost`
    布尔值。我们将 `directed` 和 `has_rcost` 值设置为 `False`，同时传递 `start_node` 和 `end_node` ID。此查询在生成的路线ID和输入网络ID之间执行
    `JOIN` 操作，以便我们有几何输出以进行可视化。
- en: Our journey then ends with processing the results and creating our output GeoJSON
    file. The routing query has returned a list of individual segments from start
    to end that aren't in the form of a single LineString, but a set of many LineStrings.
    This is why we need to create a list and append each route segment to a list by
    creating our GeoJSON `FeatureCollection` file.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们的旅程以处理结果和创建我们的输出GeoJSON文件结束。路由查询返回了一个从起点到终点的不以单个LineString形式存在的单独段落的列表，而是一组许多LineString。这就是为什么我们需要创建一个列表，并通过创建我们的GeoJSON
    `FeatureCollection` 文件将每个路线段追加到列表中的原因。
- en: Here, we use the `write_geojson()` function to output our final GeoJSON file
    called `ch08_shortest_path_pgrouting.geojson`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用 `write_geojson()` 函数输出我们的最终GeoJSON文件，名为 `ch08_shortest_path_pgrouting.geojson`。
- en: Note
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that this GeoJSON file is in the EPSG:3857 coordinate system and is interpreted
    by QGIS as EPSG:4326, which is incorrect. Geodata for routing, such as OSM data
    and custom datasets, has lots of possible mistakes, errors, and inconsistencies.
    Beware that the devil is hiding in the detail of the data this time and not so
    much in the code.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个GeoJSON文件位于EPSG:3857坐标系中，并被QGIS解释为EPSG:4326，这是不正确的。用于路由的地理数据，如OSM数据和自定义数据集，有很多可能的错误、错误和不一致。请注意，这次魔鬼隐藏在数据的细节中，而不是代码中。
- en: Go ahead and drag and drop your GeoJSON file into QGIS to see how your final
    route looks.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 将你的GeoJSON文件拖放到QGIS中，看看你的最终路线看起来如何。
- en: Finding the Dijkstra shortest path with NetworkX in pure Python
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用纯Python在NetworkX中找到Dijkstra最短路径
- en: This recipe is a pure Python solution to calculate the shortest path on a network.
    **NetworkX** is the library we will use with many algorithms to solve the shortest
    path problem, including Dijkstra ([http://networkx.github.io/](http://networkx.github.io/)).
    **NetworkX** relies on `numpy` and `scipy` to perform some graph calculations
    and help with performance. In this recipe, we will only use Python libraries to
    create our shortest path based on the same input Shapefile used in our previous
    recipe.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱是一个纯Python解决方案，用于计算网络上的最短路径。**NetworkX** 是我们将使用的库，它包含许多算法来解决最短路径问题，包括 Dijkstra
    ([http://networkx.github.io/](http://networkx.github.io/))。**NetworkX** 依赖于 `numpy`
    和 `scipy` 来执行一些图计算并帮助提高性能。在这个菜谱中，我们将仅使用Python库来创建基于我们之前菜谱中使用的相同输入Shapefile的最短路径。
- en: Getting ready
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Start with installing *NetworkX* on your machine with the `pip` installer as
    follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，使用以下`pip`安装程序在您的机器上安装*NetworkX*：
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: For the network graph algorithms, NetworkX requires `numpy` and `scipy`, so
    take a look at [Chapter 1](ch01.html "Chapter 1. Setting Up Your Geospatial Python
    Environment"), *Setting Up Your Geospatial Python Environment*, for instructions
    on these. We also use Shapely to generate our geometry outputs to create GeoJSON
    files, so check whether you have installed Shapely. One hidden requirement is
    that GDAL/OGR is used in the back end of NetworkX's `import Shapefile` function.
    As mentioned earlier, in [Chapter 1](ch01.html "Chapter 1. Setting Up Your Geospatial
    Python Environment"), you will find instructions on this subject.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 对于网络图算法，NetworkX需要`numpy`和`scipy`，因此请参阅[第1章](ch01.html "第1章。设置您的地理空间Python环境")，*设置您的地理空间Python环境*，了解有关这些内容的说明。我们还使用Shapely生成我们的几何输出以创建GeoJSON文件，因此请检查您是否已安装Shapely。一个隐藏的要求是GDAL/OGR在NetworkX的`import
    Shapefile`函数的后端使用。如前所述，在[第1章](ch01.html "第1章。设置您的地理空间Python环境")中，您将找到有关此主题的说明。
- en: The input data that represents our network is a Shapefile at `/ch08/geodata/shp/e01_network_lines_3857.shp`,
    containing our network dataset that is already prepared for routing, so make sure
    you download this chapter. Now you are ready to run the example.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 表示我们网络的输入数据是一个位于`/ch08/geodata/shp/e01_network_lines_3857.shp`的Shapefile，其中包含我们已准备好的用于路由的网络数据集，因此请确保您下载了本章。现在您已准备好运行示例。
- en: How to do it...
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'You need to run this code from the command line to generate the resulting output
    GeoJSON files that you can open in QGIS, so follow along:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您需要从命令行运行此代码以生成结果输出GeoJSON文件，您可以在QGIS中打开这些文件，因此请跟随操作：
- en: '[PRE6]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: How it works...
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: NetworkX has a nice function called `read_shp` that inputs a Shapefile directly.
    However, to start doing this, we need to define the `write_geojson` function to
    output our results as GeoJSON files. The input Shapefile is a completely connected
    network dataset. Sometimes, you may find that your input is not connected and
    this function call to `connected_component_subgraphs` finds nodes that are connected,
    only using these connected nodes. The inner function sets our network to `undirected`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: NetworkX有一个名为`read_shp`的不错函数，可以直接输入Shapefile。然而，要开始这样做，我们需要定义`write_geojson`函数以将我们的结果输出为GeoJSON文件。输入的Shapefile是一个完全连接的网络数据集。有时，您可能会发现您的输入没有连接，这个函数调用`connected_component_subgraphs`只使用这些连接的节点来找到节点。内部函数将我们的网络设置为`无向`。
- en: Note
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This function does not create a connected network dataset; this job is left
    for you to perform in QGIS or some other desktop GIS software. One solution is
    to execute this in PostgreSQL with the tools provided with the pgRouting extension.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数不会创建一个连接的网络数据集；这项工作留给你在QGIS或其他桌面GIS软件中执行。一个解决方案是在PostgreSQL中使用pgRouting扩展提供的工具执行此操作。
- en: Now, we'll generate the nodes on our network and export them to GeoJSON. This
    is, of course, not necessary, but it is nice to see where the nodes are on the
    map to debug your data. If any problems do occur in generating routes, you can
    visually identify them quite quickly.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将生成网络上的节点并将它们导出为GeoJSON。这当然不是必需的，但看到节点在地图上的位置以调试您的数据是很好的。如果在生成路线时出现任何问题，您可以非常快速地通过视觉识别它们。
- en: Next up, we set the array position of the start and end node to calculate our
    route. The NetworkX `shortest_path` algorithm requires you to define the source
    and target nodes.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们设置起始节点和结束节点的数组位置以计算我们的路线。NetworkX的`shortest_path`算法要求您定义源节点和目标节点。
- en: Tip
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: One thing to pay attention to is the fact that the source and target are coordinate
    pairs within an array of points.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一件事是，源和目标是在点数组内的坐标对。
- en: As nice as this array of points are, we need a path and, hence, the `get_path`
    and `get_full_path` functions are discussed next. Our `get_path` function takes
    two input nodes, that is, two pairs of coordinates, and returns a NumPy array
    of edge coordinates along the line. This is followed closely by the `get_full_path`
    function that internally uses the `get_path` function to output the complete list
    of all paths and coordinates along all paths.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个点数组很棒，但我们需要一个路径，因此接下来将讨论`get_path`和`get_full_path`函数。我们的`get_path`函数接受两个输入节点，即两个坐标对，并返回沿线的边坐标的NumPy数组。紧接着是`get_full_path`函数，它内部使用`get_path`函数输出所有路径和所有路径上的坐标的完整列表。
- en: All the edges and corresponding coordinates are then appended to a new list
    that needs to be combined—hence, the NumPy `vstack` function. Inside our `for`
    loop, we go through each path, getting the edges and coordinates to build our
    list that then gets concatenated together as our final NumPy array output.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 所有边和相应的坐标随后被追加到一个新的列表中，需要将其合并——因此，使用 NumPy 的 `vstack` 函数。在我们的 `for` 循环内部，我们遍历每条路径，获取边和坐标来构建我们的列表，然后将其连接在一起作为我们的最终
    NumPy 数组输出。
- en: Shapely was built with NumPy compatibility and, therefore, has an `asLineString()`function
    that can directly input a NumPy array of coordinates. Now we have the geometry
    of our final LineString route and can export it to GeoJSON with our function.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Shapely 是与 NumPy 兼容构建的，因此有一个 `asLineString()` 函数可以直接输入坐标的 NumPy 数组。现在我们有了最终
    LineString 路线的几何形状，可以使用我们的函数将其导出为 GeoJSON。
- en: '![How it works...](img/50790OS_08_04.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/50790OS_08_04.jpg)'
- en: Generating evacuation polygons based on an indoor shortest path
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于室内最短路径生成疏散多边形
- en: Architects and transportation planners, for example, need to plan where and
    how many exits a building will require based on various standards and safety policies.
    After a building is built, a facility manager and security team usually do not
    have access to this information. Imagine that there is an event to be planned
    and you want to see what areas can be evacuated within a certain time, which are
    constrained by your list of exits in the building.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，建筑师和交通规划师需要根据各种标准和安全政策来规划建筑所需的出入口位置和数量。一旦建筑建成，设施经理和安全团队通常无法获取这些信息。想象一下，你正在计划一个活动，并想查看在特定时间内可以疏散哪些区域，这些区域受建筑中出入口列表的限制。
- en: During this exercise, we want to create some polygons for a specific start point
    inside a major building, showing which areas can be evacuated in 10, 20, 30, and
    60 second intervals. We assume that people will walk at 5 km/hr or 1.39 m/s, which
    is their normal walking speed. If we panic and run, our normal run speed increases
    to 6.7 m/s or 24.12 km/hr.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们想在大型建筑内部的一个特定起点创建一些多边形，显示在 10、20、30 和 60 秒间隔内可以疏散哪些区域。我们假设人们以 5 公里/小时或
    1.39 米/秒的速度行走，这是他们的正常行走速度。如果我们恐慌并奔跑，我们的正常奔跑速度将增加到 6.7 米/秒或 24.12 公里/小时。
- en: Our results are going to generate a set of polygons representing our evacuation
    zones based on the building hallways. We need to define the start position of
    where the evacuation begins. This starting point of our calculation is equal to
    the starting point in our route that was discussed in the previous recipe, *Finding
    the Dijkstra shortest path with NetworkX in pure Python*.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的结果将生成一组多边形，代表基于建筑走廊的疏散区域。我们需要定义疏散开始的起始位置。我们计算的起始点等于之前配方中讨论的路线的起始点，*使用纯 Python
    中的 NetworkX 找到 Dijkstra 最短路径*。
- en: '![Generating evacuation polygons based on an indoor shortest path](img/50790OS_08_05.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![基于室内最短路径生成疏散多边形](img/50790OS_08_05.jpg)'
- en: This image shows the resulting polygons and points that are generated using
    our script. The results are styled and visualized using QGIS.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 此图像显示了使用我们的脚本生成的结果多边形和点。结果使用 QGIS 进行了样式化和可视化。
- en: Getting ready
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This example uses the network data loaded by our previous recipe, so make sure
    that you have loaded this data into your local PostgreSQL database. After you
    have loaded the data, you will have two tables, `geodata.ch08_e01_networklines_vertices_pgr`
    and `geodata.ch08_e01_networklines`. In combination with these tables, you need
    a single new Shapefile for our input polygons located at `/ch08/geodata/shp/e01_hallways_union_3857.shp`,
    representing the building hallways that are used to clip our resulting distance
    polygons.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例使用我们之前配方中加载的网络数据，所以请确保你已经将此数据加载到你的本地 PostgreSQL 数据库中。在数据加载完成后，你将有两个表，`geodata.ch08_e01_networklines_vertices_pgr`
    和 `geodata.ch08_e01_networklines`。结合这些表，你需要一个单独的新 Shapefile，用于我们的输入多边形，位于 `/ch08/geodata/shp/e01_hallways_union_3857.shp`，代表用于裁剪我们结果距离多边形的建筑走廊。
- en: How to do it...
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'There are lots of comments in the code for clarity purposes, so read along:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码中有许多注释，用于提高清晰度，所以请阅读：
- en: '[PRE7]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: How it works...
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The code starts with database boiler plate code plus a function to export the
    GeoJSON result files. To create an evacuation polygon, we require one input, which
    is the starting point for the distance calculation polygon on our network. As
    seen in the previous section, we need to find the node on the network closest
    to our starting coordinate. Therefore, we run a SQL `select` to find this node
    that's within one meter of our coordinate.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 代码从数据库模板代码和一个用于导出GeoJSON结果文件的函数开始。为了创建疏散多边形，我们需要一个输入，即我们网络中距离计算多边形的起始点。如前文所述，我们需要找到网络中距离我们的起始坐标最近的节点。因此，我们运行一个SQL
    `select`查询来找到这个距离我们的坐标一米的节点。
- en: Next up, we define the `combined_result` variable that will hold all the points
    reachable for all specified evacuation times in our list. Hence, it stores the
    results of each evacuation time in one single output.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个`combined_result`变量，它将存储我们列表中所有指定疏散时间的可到达点。因此，它将每个疏散时间的每个结果存储在一个单独的输出中。
- en: The hallways Shapefile is then prepared as Shapely geometry because we will
    need it to clip our output polygons to be inside the hallways. We are only interested
    in seeing which areas can be evacuated within the specified time scales of 10,
    20, 30, and 60 seconds. If the area is outside the hallways, you are located outside
    the building and, well, better said, you are safe.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们需要将输出多边形裁剪到走廊内，因此走廊的Shapefile被准备为Shapely几何形状。我们只对在指定的10秒、20秒、30秒和60秒时间尺度内可以疏散的区域感兴趣。如果区域在走廊之外，你位于建筑之外，换句话说，你很安全。
- en: Now, we will loop through each of our time intervals to create individual evacuation
    polygons for each time defined in our list. The `pgRouting` extension includes
    a function called `pgr_drivingDistance(),` which returns a list of nodes that
    are reachable within a specified cost. Parameters for this function include the
    *SQL query* that returns `id`, `source`, `target`, and `cost` columns. Our final
    four parameters include the start node ID that's represented by the `%s` variable
    and equals `start_node_id`. Then, the evacuation time in seconds stored within
    the `evac_time` variable followed by two false values. These last two false values
    are for the directed route or reverse cost calculation, which we are not using.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将遍历我们的每个时间间隔，为列表中定义的每个时间创建单独的疏散多边形。`pgRouting`扩展包括一个名为`pgr_drivingDistance()`的函数，该函数返回一个列表，其中包含在指定成本内可到达的节点。此函数的参数包括返回`id`、`source`、`target`和`cost`列的*SQL查询*。我们的最后四个参数包括表示`start_node_id`的`%s`变量，等于`start_node_id`。然后是存储在`evac_time`变量中的疏散时间（以秒为单位），后面跟着两个false值。这两个最后的false值用于有向路线或反向成本计算，我们不需要使用。
- en: Note
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In our case, the cost is calculated as a time value in seconds based on distance.
    We assume that you are walking at 5 km/hr. The cost is then calculated as the
    segment length in meters divided by 5000 m x 60 min x 60 sec to derive a cost
    value. Then, we pass in the start node ID along with our specified evacuation
    time in seconds. If you want to calculate in minutes, simply remove one of the
    x 60 in the equation.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，成本是根据距离计算的时间值（以秒为单位）。我们假设你以5公里/小时的速度行走。成本计算为段长度（以米为单位）除以5000米乘以60分钟乘以60秒，以得出成本值。然后，我们传入起始节点ID以及我们指定的疏散时间（以秒为单位）。如果你想按分钟计算，只需从方程中移除一个乘以60即可。
- en: The geometry of each node is then derived through a SQL JOIN between the vertices
    table and the result list of nodes with node IDs. Now that we have our set of
    geometry of points for each node reachable within our evacuation time, it's time
    to parse this result. Parsing is required to create our GeoJSON output, and it
    also feeds the points into our combined output, the `combined_result` variable,
    and the individual evacuation time polygons that are created with a convex hull
    algorithm from Shapely.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 每个节点的几何形状是通过在顶点表和具有节点ID的节点结果列表之间进行SQL JOIN操作来推导的。现在我们已经得到了每个节点在疏散时间内可到达的点的几何形状集合，是时候解析这个结果了。解析是创建我们的GeoJSON输出所必需的，它也将点输入到我们的组合输出中，即`combined_result`变量，以及使用Shapely中的凸包算法创建的个体疏散时间多边形。
- en: Tip
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: A better or more realistic polygon could be created using alpha shapes. Alpha
    shapes form a polygon from a set of points, hugging each point to retain a more
    realistic polygon that follow the shape of the points. The convex hull simply
    ensures that all the points are inside the resulting polygon. For a good read
    on alpha shapes, check out this post by Sean Gillies at [http://sgillies.net/blog/1155/the-fading-shape-of-alpha/](http://sgillies.net/blog/1155/the-fading-shape-of-alpha/)
    and this post at [http://blog.thehumangeo.com/2014/05/12/drawing-boundaries-in-python/](http://blog.thehumangeo.com/2014/05/12/drawing-boundaries-in-python/).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 alpha 形状可以创建更好的或更逼真的多边形。Alpha 形状从一组点形成多边形，紧贴每个点以保留更逼真的多边形，该多边形遵循点的形状。凸包只是确保所有点都在结果多边形内。要了解
    alpha 形状，请查看肖恩·吉利斯在 [http://sgillies.net/blog/1155/the-fading-shape-of-alpha/](http://sgillies.net/blog/1155/the-fading-shape-of-alpha/)
    的这篇帖子，以及 [http://blog.thehumangeo.com/2014/05/12/drawing-boundaries-in-python/](http://blog.thehumangeo.com/2014/05/12/drawing-boundaries-in-python/)
    的这篇帖子。
- en: What is included in the code is the alpha shapes module called `//ch08/code/alpha_shape.py`
    that you can try out with the input data points created, if you've followed along
    so far, to create a more accurate polygon.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中包含的模块是名为 `//ch08/code/alpha_shape.py` 的 alpha 形状模块，如果您已经跟随教程进行，可以使用创建的输入数据点尝试，以创建一个更精确的多边形。
- en: Our `route_results` variable stores the GeoJSON geometry used to create individual
    convex hull polygons. This variable is then used to populate the list of points
    for each evacuation set of points. It also provides the source of our GeoJSON
    export, creating `FeatureCollection`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `route_results` 变量存储了用于创建单个凸包多边形的 GeoJSON 几何形状。然后，该变量用于填充每个疏散点集的点列表。它还提供了我们的
    GeoJSON 导出的来源，创建 `FeatureCollection`。
- en: The final calculations include using Shapely to create the convex hull polygon,
    immediately followed by intersecting this new convex hull polygon with our input
    Shapefile that represents the building hallways. We are only interested in showing
    areas to evacuate, which boils down to only areas inside the building, hence the
    intersection.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的计算包括使用 Shapely 创建凸包多边形，紧接着与代表建筑走廊的输入 Shapefile 中的新凸包多边形相交。我们只对显示疏散区域感兴趣，这归结为仅显示建筑内部的区域，因此进行交集操作。
- en: 'The remaining code exports our results to the GeoJSON files in your `/ch08/geodata`
    folder. Go ahead and open this folder and drag and drop the GeoJSON files into
    QGIS to visualize your new results. You will want to grab the following files:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的代码将我们的结果导出到 `/ch08/geodata` 文件夹中的 GeoJSON 文件。请打开此文件夹，并将 GeoJSON 文件拖放到 QGIS
    中以可视化您的新结果。您需要获取以下文件：
- en: '`ch08-03_dist_poly_10.geojson`'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ch08-03_dist_poly_10.geojson`'
- en: '`ch08-03_dist_poly_20.geojson`'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ch08-03_dist_poly_20.geojson`'
- en: '`ch08-03_dist_poly_30.geojson`'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ch08-03_dist_poly_30.geojson`'
- en: '`ch08-03_dist_poly_60.geojson`'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ch08-03_dist_poly_60.geojson`'
- en: '`ch08-03_final_dis_poly.geojson`'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ch08-03_final_dis_poly.geojson`'
- en: Creating centerlines from polygons
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从多边形创建中心线
- en: For any routing algorithm to work, we need a set of network LineStrings to perform
    our shortest path query on. Here, you, of course, have some options, ones that
    you can download to the OSM data to clean up the roads. Secondly, you could digitize
    your own set of network lines or, thirdly, you can try to autogenerate these lines.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何路由算法要正常工作，我们需要一组网络 LineStrings 来执行最短路径查询。在这里，您当然有一些选择，您可以将这些选择下载到 OSM 数据中清理道路。其次，您可以数字化自己的网络线集合，或者第三，您可以尝试自动生成这些线。
- en: The generation of this network LineString is of utmost importance and determines
    the quality and types of routes that we can generate. In an indoor environment,
    we have no roads and street names; instead, we have hallways, rooms, lounges,
    elevators, ramps, and stairs. These features are our roads, bridges, and highway
    metaphors where we want to create routes for people to walk.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 生成此网络 LineString 的过程至关重要，它决定了我们可以生成的路线的质量和类型。在室内环境中，我们没有道路和街道名称；相反，我们有走廊、房间、休息室、电梯、坡道和楼梯。这些特征是我们的道路、桥梁和高速公路隐喻，我们希望为行人创建路线。
- en: How we can create basic network LineStrings from polygons that represent hallways
    is what we are going to show you in this recipe.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将向您展示如何从代表走廊的多边形创建基本的网络 LineStrings。
- en: '![Creating centerlines from polygons](img/50790OS_08_06.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![从多边形创建中心线](img/50790OS_08_06.jpg)'
- en: Getting ready
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This exercise requires us to have a plan of some sort in digital form with polygons
    representing hallways and other open spaces where people could walk. Our hallway
    polygon is courtesy of the Alpen-Adria-Universität Klagenfurt in Austria. The
    polygons were simplified to keep the rendering time low. The more complex your
    input geometry, the longer it will take to process.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习要求我们以某种形式在数字上有一个计划，其中多边形表示走廊和其他人们可以行走的空间。我们的走廊多边形由奥地利克拉根福特市的 Alpen-Adria-Universität
    提供的。多边形被简化以降低渲染时间。你的输入几何形状越复杂，处理所需的时间就越长。
- en: We are using the `scipy`, `shapely`, and `numpy` libraries, so read [Chapter
    1](ch01.html "Chapter 1. Setting Up Your Geospatial Python Environment"), *Setting
    Up Your Geospatial Python Environment*, if you have not done so already. Inside
    the `/ch08/code/` folder, you'll find the `centerline.py` module containing the
    `Centerline` class. This contains the actual code that generates centerlines and
    is imported by the `ch08/code/ch08-04_centerline.py` module.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用 `scipy`、`shapely` 和 `numpy` 库，所以如果你还没有这样做，请阅读[第1章](ch01.html "第1章。设置你的地理空间Python环境")，*设置你的地理空间Python环境*。在
    `/ch08/code/` 文件夹中，你可以找到包含 `Centerline` 类的 `centerline.py` 模块。这个模块包含了生成中心线的实际代码，并且被
    `ch08/code/ch08-04_centerline.py` 模块导入。
- en: How to do it...
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s dive into some code:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入一些代码：
- en: Note
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you decide to run the following code straightaway, beware that the creation
    of centerlines is a slow process and is not optimized for performance. This code
    could run for 5 min on a slow machine, so be patient and keep an eye on the console
    until it displays **FINISHED**.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你决定立即运行以下代码，请注意，生成中心线是一个缓慢的过程，并且没有针对性能进行优化。在慢速机器上，这段代码可能需要运行 5 分钟，所以请耐心等待，并关注控制台，直到它显示
    **完成**。
- en: 'The first task is to create a function to create our centerlines. This is the
    modified version of the Filip Todic orginal `centerlines.py` class:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个任务是创建一个创建我们中心线的函数。这是 Filip Todic 原始 `centerlines.py` 类的修改版本：
- en: '[PRE8]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now that we have a function that creates centerlines, we need some code to
    import a Shapefile polygon, run the centerlines script, and export our results
    to GeoJSON so we that can see it in QGIS:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有一个创建中心线的函数，我们需要一些代码来导入 Shapefile 多边形，运行中心线脚本，并将我们的结果导出为 GeoJSON，以便我们可以在
    QGIS 中查看：
- en: '[PRE9]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: How it works...
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Starting with `centerlines.py` that contains the `Centerline` class, there is
    a lot going on inside the class. We use the **Voronoi** polygons and extract **ridges**
    as centerlines. To create these Voronoi polygons, we need to convert our polygon
    into LineStrings representing inner and outer polygon edges. These edges then
    need to be converted to points to feed the Voronoi algorithm. The points are generated
    based on a *densify* algorithm that creates points every 0.5 m along the edge
    of a polygon and all the way around it. This helps the `Voronoi` function create
    a more accurate representation of the polygon, and hence provides a better centerline.
    On the negative side, the higher this distance is set, the more computing power
    needed.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 从包含 `Centerline` 类的 `centerlines.py` 开始，类内部有很多操作。我们使用 **Voronoi** 多边形并从中提取 **脊**
    作为中心线。为了创建这些 Voronoi 多边形，我们需要将我们的多边形转换为表示内部和外部多边形边的 LineStrings。然后，这些边需要被转换为点以供
    Voronoi 算法使用。这些点基于一个 *densify* 算法生成，该算法在多边形边缘每隔 0.5 米创建一个点，并围绕整个多边形。这有助于 `Voronoi`
    函数创建多边形更精确的表示，从而提供更好的中心线。不利的一面是，这个距离设置得越高，所需的计算能力就越多。
- en: The `ch08-04_centerline.py` code then imports this new Centerline class and
    actually runs it using our hallways polygon. The input polygons are read from
    a Shapefile using `pyshp`. Our generated shapes are then pumped into the `generate_centerlines`
    function to output a dictionary of LineStrings representing our centerlines.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`ch08-04_centerline.py` 代码导入这个新的 `Centerline` 类，并使用我们的走廊多边形实际运行它。输入的多边形是通过
    `pyshp` 从 Shapefile 中读取的。然后，我们生成的形状被泵入 `generate_centerlines` 函数，输出一个表示我们中心线的
    LineStrings 字典。
- en: That output dictionary is then exported to GeoJSON as we loop over the centerlines
    and use the standard `json.dumps` function to export it to our file.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在遍历中心线时，我们将输出字典导出为 GeoJSON，使用标准的 `json.dumps` 函数将其导出到我们的文件中。
- en: Building an indoor routing system in 3D
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 3D 中构建室内路由系统
- en: How to route through one or multiple buildings or floors is what this recipe
    is all about. This is, of course, the most complex situation involving complex
    data collection, preparation, and implementation processes. We cannot go into
    all the complex data details of collection and transformation from ACAD to PostGIS,
    for example; instead, the finished data is provided.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如何通过一个或多个建筑或楼层进行路由是本食谱的主要内容。这当然是最复杂的情况，涉及复杂的数据收集、准备和实施过程。例如，我们无法深入所有复杂的数据细节，从ACAD到PostGIS的转换；相反，提供的是完成后的数据。
- en: To create an indoor routing application, you need an already digitized routing
    network set of lines representing the areas where people can walk. Our data represents
    the first and second floor of a university building. The resulting indoor route,
    shown in the following screenshot, starts from the second floor and travels down
    the stairs to the first floor, all the way through the building, heading up the
    stairs again to the second floor, and finally reaching our destination.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建室内路由应用程序，您需要一个已经数字化的路由网络线集，表示人们可以行走的地方。我们的数据代表了一所大学的第一层和第二层。以下截图显示的结果室内路线从第二层开始，沿着楼梯下到第一层，穿过整个建筑，再次上楼梯到第二层，最终到达我们的目的地。
- en: '![Building an indoor routing system in 3D](img/50790OS_08_07.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![在3D中构建室内路由系统](img/50790OS_08_07.jpg)'
- en: Getting ready
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this recipe, we will need to complete quite a few tasks to prepare for
    the indoor 3D routing. Here''s a quick list of requirements:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个食谱，我们需要完成相当多的任务来准备室内3D路由。以下是一个快速的需求列表：
- en: A Shapefile for the first floor (`/ch08/geodata/shp/e01_network_lines_3857.shp`).
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一层的Shapefile（`/ch08/geodata/shp/e01_network_lines_3857.shp`）。
- en: A Shapefile for the second floor (`/ch08/geodata/shp/e02_network_lines_3857.shp`).
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二层的Shapefile（`/ch08/geodata/shp/e02_network_lines_3857.shp`）。
- en: PostgreSQL DB 9.1 + PostGIS 2.1 and pgRouting 2.0\. These were all installed
    in the *Finding the Dijkstra shortest path with pgRouting* recipe at the beginning
    of this chapter.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PostgreSQL DB 9.1 + PostGIS 2.1和pgRouting 2.0。这些都在本章开头的*使用pgRouting找到Dijkstra最短路径*食谱中安装了。
- en: Python modules, `psycopg2` and `geojson`.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python模块，`psycopg2`和`geojson`。
- en: 'Here is the list of tasks that we need to carry out:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是需要我们执行的任务列表：
- en: 'Import the Shapefile of the first floor networklines (skip this if you''ve
    completed the earlier recipe that imported this Shapefile) as follows:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按以下方式导入第一层网络线的Shapefile（如果已完成了导入此Shapefile的早期食谱，则跳过此步骤）：
- en: '[PRE10]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Import the Shapefile of the second floor networklines as follows:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按以下方式导入第二层网络线的Shapefile：
- en: '[PRE11]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Assign routing columns to the first floor networklines (skip this step if you''ve
    completed it in the previous recipe):'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为第一层网络线分配路由列（如果已在之前的食谱中完成，则跳过此步骤）：
- en: '[PRE12]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Assign routing columns to the second floor networklines as follows:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按以下方式为第二层网络线分配路由列：
- en: '[PRE13]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Create pgRouting 3D functions that allow you to route over your 3D networklines.
    These two PostgreSQL functions are critically important as they reflect the original
    pgRouting 2D functions that have now been converted to allow 3D routing. The order
    of installation is also very important, so make sure you install `pgr_pointtoid3d.sql`
    first! Both SQL files are located in your `/ch08/code/` folder:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建允许您在3D网络线上进行路由的pgRouting 3D函数。这两个PostgreSQL函数至关重要，因为它们反映了现在已转换为允许3D路由的原始pgRouting
    2D函数。安装顺序也非常重要，所以请确保首先安装`pgr_pointtoid3d.sql`！这两个SQL文件都位于您的`/ch08/code/`文件夹中：
- en: '[PRE14]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next, install `pgr_createTopology3d.sql`. This is a modified version of the
    original that now uses our new `pgr_pointtoid3d` functions as follows:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，安装`pgr_createTopology3d.sql`。这是原始版本的修改版，现在使用我们新的`pgr_pointtoid3d`函数如下：
- en: '[PRE15]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now we need to merge our two floor network lines into a single 3D LineString
    table that we will perform our 3D routing on. This set of SQL commands is stored
    for you at:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要将我们的两层楼网络线合并成一个单一的3D LineString表，我们将在该表上执行3D路由。这组SQL命令已为您存储在：
- en: '[PRE16]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The exact creation of the 3D routing table is very important to understand
    as it allows 3D routing queries. Our code is, therefore, listed as follows with
    SQL comments describing what we are doing at each step:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 理解3D路由表的精确创建非常重要，因为它允许3D路由查询。因此，我们的代码如下列出，带有SQL注释描述我们在每个步骤中做什么：
- en: '[PRE17]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Wow, that was a lot of stuff to get through, and now we are actually ready to
    run and create some 3D routes. Hurray!
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 哇，这需要处理很多东西，现在我们实际上已经准备好运行并创建一些3D路由了。太棒了！
- en: How to do it...
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let''s dive into some code full of comments for your reading pleasure:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们深入一些带有注释的代码，供你阅读愉快：
- en: '[PRE18]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: How it works...
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Using the `psycopg2` module, we can connect to our fancy new tables in the database
    and run some queries. The first query set finds the start and end nodes based
    on the *x*, *y*, and *Z* elevation values. The *Z* value is VERY important; otherwise,
    the wrong node will be selected. The *Z* value corresponds one to one with a layer/floor
    value. The 3D elevation data assigned to our `networklines_3857` dataset is simply
    one meter for floor one and two meters for floor two. This keeps things simple
    and easy to remember without actually using the real height of the floors, which,
    of course, you could do if you want to.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`psycopg2`模块，我们可以连接到数据库中我们新奇的表格并运行一些查询。第一个查询集基于*x*、*y*和*Z*海拔值找到起始和结束节点。*Z*值非常重要；否则，可能会选择错误的节点。*Z*值与层/楼层值一一对应。分配给我们的`networklines_3857`数据集的3D海拔数据对于一楼是简单的一米，对于二楼是两米。这样可以使事情简单且易于记忆，而不必实际使用楼层的高度，当然，如果你想的话，你也可以这样做。
- en: Our 3D routing is then able to run like any other normal 2D routing query because
    the data is now in 3D, thanks to our two new pgRouting functions. The query goes
    through, selects our data, and returns a nice GeoJSON string.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的数据现在已经是3D的，我们的3D路由能够像任何其他正常的2D路由查询一样运行，这要归功于我们新增的两个pgRouting函数。查询通过，选择我们的数据，并返回一个漂亮的GeoJSON字符串。
- en: You have seen the remaining code before. It exports the results to a GeoJSON
    file on disk so that you can open it in QGIS for viewing. We've managed to add
    a couple of properties to the new GeoJSON file, including the floor number, cost
    in terms of distance, and the route segment type that identifies whether a segment
    is an indoor way or is in the form of stairs.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 你之前已经见过这段剩余的代码了。它将结果导出到磁盘上的GeoJSON文件中，这样你就可以在QGIS中打开它进行查看。我们已经成功地向新的GeoJSON文件添加了一些属性，包括楼层号、以距离为单位的成本以及识别一个段是室内路径还是楼梯形式的路径段类型。
- en: Calculating indoor route walk time
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算室内路线步行时间
- en: Our indoor routing application would not be complete without letting us know
    how long it would take to walk to our indoor walk now, would it? We will create
    a couple of small functions that you can insert into your code in the previous
    recipe to print out the route walk times.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不让我们知道到达室内步行路径需要多长时间，我们的室内路由应用程序就不会完整，对吧？我们将创建几个小的函数，你可以将它们插入到前面的食谱中的代码中，以打印出路线步行时间。
- en: How to do it...
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Without further ado, let''s take a look at some code:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不再拖延，让我们看看一些代码：
- en: '[PRE19]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Your results should show you a dictionary as follows:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你的结果应该显示如下字典：
- en: '[PRE20]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, it is assumed that you have placed these functions into our previous recipe
    and have called the function to print the results to the console.
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里假设你已经将这些函数放入了前面的食谱中，并调用了函数将结果打印到控制台。
- en: How it works...
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We have two simple functions to create walk times for our indoor routes. The
    first function, called `format_walk_time()`, simply takes the resulting time and
    converts it to a human-friendly form, showing the minutes and seconds, respectively,
    that are required for output.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两个简单的函数来为我们的室内路线创建步行时间。第一个函数，称为`format_walk_time()`，简单地将结果时间转换为人类友好的形式，分别显示所需的分钟和秒。
- en: The second function, `calc_distance_walktime()`, does the work, expecting a
    list object including the distance. This distance then gets summed for each route
    segment into a total distance value that's stored in the `route_length` variable.
    Our `real_time` variable is then created by calling upon the `format_walk_time`
    function that passes in the `walk_time` value in seconds.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个函数`calc_distance_walktime()`执行工作，期望一个包含距离的列表对象。然后，这个距离被加到每个路线段中，形成一个存储在`route_length`变量中的总距离值。然后，我们通过调用`format_walk_time`函数创建`real_time`变量，该函数传递秒数的`walk_time`值。
- en: Now you have a sophisticated indoor route with specified walk times for your
    application.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你为你的应用程序拥有了一个复杂的室内路线，并指定了步行时间。
