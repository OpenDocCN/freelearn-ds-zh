- en: Math for Machine Learning
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 机器学习数学
- en: A machine learning user needs to have a fair understanding of machine learning
    concepts and algorithms. Familiarity with mathematics is an important aspect of
    machine learning. We learn to program by understanding the fundamental concepts
    and constructs of a language. Similarly, we learn machine learning by understanding
    concepts and algorithms using Mathematics, which is used to solve complex computational
    problems, and is a discipline for understanding and appreciating many computer
    science concepts. Mathematics plays a fundamental role in grasping theoretical
    concepts and in choosing the right algorithm. This chapter covers the basics of
    **linear algebra** and **calculus** for **machine learning**.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 机器学习用户需要对机器学习概念和算法有一定的了解。熟悉数学是机器学习的重要方面。我们通过理解语言的基本概念和结构来学习编程。同样，我们通过理解数学概念和算法来学习机器学习，数学用于解决复杂的计算问题，是理解和欣赏许多计算机科学概念的学科。数学在掌握理论概念和选择正确算法方面起着基本作用。本章涵盖了**机器学习**的**线性代数**和**微积分**的基础知识。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Linear algebra
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线性代数
- en: Environment setup
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 环境设置
- en: Setting up the Scala environment in Intellij
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Intellij中设置Scala环境
- en: Setting up the Scala environment on the command line
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在命令行上设置Scala环境
- en: Fields
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 领域
- en: Vectors
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向量
- en: Vector spaces
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向量空间
- en: 'Vector types:'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向量类型：
- en: Dense vector
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密集向量
- en: Sparse vector
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 稀疏向量
- en: Vectors in Spark
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spark中的向量
- en: Vector operations
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向量运算
- en: Hyperplanes
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 超平面
- en: Vectors in machine learning
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 机器学习中的向量
- en: Matrices
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 矩阵
- en: Introduction
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍
- en: 'Matrices types:'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 矩阵类型：
- en: Dense matrix
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密集矩阵
- en: CSC matrix
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CSC矩阵
- en: Matrix in Spark
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spark中的矩阵
- en: Matrix operations
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 矩阵运算
- en: Determinant
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行列式
- en: Eigenvalues and eigenvectors
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特征值和特征向量
- en: Singular value decomposition
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 奇异值分解
- en: Matrices in machine learning
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 机器学习中的矩阵
- en: Functions
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数
- en: Definition
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义
- en: 'Function types:'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数类型：
- en: Linear functions
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线性函数
- en: Polynomial functions
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多项式函数
- en: Identity functions
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 身份函数
- en: Constant functions
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常数函数
- en: Probability distribution functions
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 概率分布函数
- en: Gaussian functions
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高斯函数
- en: Functional composition
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功能组合
- en: Hypothesis
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设
- en: Gradient descent
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 梯度下降
- en: Prior, likelihood, and posterior
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 先验、似然和后验
- en: Calculus
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微积分
- en: Differential calculus
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微分计算
- en: Integral calculus
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 积分微积分
- en: Lagrange multipliers
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拉格朗日乘数
- en: Plotting
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绘图
- en: Linear algebra
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线性代数
- en: Linear algebra is the study of solving a system of linear equations and transformations.
    Vectors, matrices, and determinants are the fundamental tools of linear algebra.
    We will learn each of these in detail using **Breeze**. Breeze is the underlying
    linear algebra library used for numerical processing. Respective Spark objects
    are wrappers around Breeze, and act as a public interface to ensure the consistency
    of the Spark ML library even if Breeze changes internally.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 线性代数是解决线性方程组和变换的研究。向量、矩阵和行列式是线性代数的基本工具。我们将使用**Breeze**详细学习这些内容。Breeze是用于数值处理的基础线性代数库。相应的Spark对象是Breeze的包装器，并作为Spark
    ML库的公共接口，以确保即使Breeze在内部发生变化，Spark ML库的一致性也得到保证。
- en: Setting up the Scala environment in Intellij
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Intellij中设置Scala环境
- en: It is best to use an IDE like IntelliJ to edit Scala code, which provides faster
    development tools and coding assistance. Code completion and inspection makes
    coding and debugging faster and simpler, ensuring you focus on the end goal of
    learning math for machine learning.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 最好使用像IntelliJ这样的IDE来编辑Scala代码，它提供了更快的开发工具和编码辅助。代码完成和检查使编码和调试更快更简单，确保您专注于学习机器学习的最终目标。
- en: 'IntelliJ 2016.3 brings Akka, Scala.meta, Memory view, Scala.js, and Migrators
    to the IntelliJ IDE as part of the Scala plugin. Now, let''s set up the Scala
    environment in Intellij as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: IntelliJ 2016.3将Akka、Scala.meta、Memory view、Scala.js和Migrators作为Scala插件的一部分引入到IntelliJ
    IDE中。现在，让我们按照以下步骤在Intellij中设置Scala环境：
- en: 'Go to Under Preferences | Plugins, and verify if the Scala plugin is installed.
    SBT, which is a build tool for Scala, is configured by default as shown in the
    following screenshot:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到首选项 | 插件，并验证是否安装了Scala插件。SBT是Scala的构建工具，默认配置如下截图所示：
- en: '![](img/image_02_001.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_02_001.png)'
- en: Select File | New | Project from Existing resources | $GIT_REPO/Chapter_02/breeze
    or $GIT_REPO/Chapter_02/spark. Here, $GIT_REPO is the repository path where you
    have cloned the source code of the book.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择文件 | 新建 | 从现有资源创建项目 | $GIT_REPO/Chapter_02/breeze或$GIT_REPO/Chapter_02/spark。这里，$GIT_REPO是您克隆了书籍源代码的存储库路径。
- en: 'Import project by selecting the SBT option:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过选择SBT选项导入项目：
- en: '![](img/image_02_002.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_02_002.png)'
- en: Keep the default options of SBT, and click on Finish.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保持SBT的默认选项，然后单击完成。
- en: SBT will take a while to import references from `build.sbt`.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SBT将花一些时间从`build.sbt`中导入引用。
- en: '![](img/image_02_003.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_02_003.png)'
- en: Finally, right click on the source file and select Run 'Vector'.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在源文件上右键单击，然后选择运行'Vector'。
- en: '![](img/image_02_004.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_02_004.png)'
- en: Setting up the Scala environment on the Command Line
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在命令行上设置Scala环境
- en: 'To set up the environment locally, follow the steps listed next:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要在本地设置环境，请按照下面列出的步骤进行：
- en: Go to the root directory of `Chapter 2`, and choose the appropriate folder.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到`第2章`的根目录，并选择适当的文件夹。
- en: '[PRE0]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Alternatively, choose the following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，选择以下内容：
- en: '[PRE1]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Compile the code.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译代码。
- en: '[PRE2]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Run the compiled code, and choose the program to run (classes shown depend on
    whether `sbt run` is executed in the Spark or Breeze folder).
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行编译后的代码，并选择要运行的程序（显示的类取决于是否在Spark或Breeze文件夹中执行`sbt run`）。
- en: '[PRE3]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Fields
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 领域
- en: Fields are fundamental structures of mathematics defined in many different ways.
    We will now look at the most basic types.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 领域是数学中定义的基本结构。我们现在将看一下最基本的类型。
- en: Real numbers
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实数
- en: A real number is any number we can think of; real numbers include whole numbers
    (0, 1, 2, 3), rational numbers (2/6, 0.768, 0.222..., 3.4), and irrational numbers
    (π, &Sqrt;3). Real numbers can be positive, negative, or zero. Imaginary numbers,
    on the other hand, are like &Sqrt;−1 (the square root of minus 1); note that infinity
    is not a real number.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 实数是我们可以想到的任何数字；实数包括整数（0, 1, 2, 3）、有理数（2/6, 0.768, 0.222...，3.4）和无理数（π，&Sqrt;3）。实数可以是正数、负数或零。另一方面，虚数就像&Sqrt;−1（负1的平方根）；请注意，无穷大不是实数。
- en: Complex numbers
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复数
- en: Our understanding is that the square of a number can never be negative. In that
    case, how do we solve *x2* = *-9*? Sensibly, in math we have the concept of i,
    as a solution, that is, *x* = *3i*. Numbers such as i, -i, 3i, and 2.27i are called
    imaginary numbers. "A real number" + "an imaginary number" forms a "complex number".
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道一个数的平方永远不可能是负数。在这种情况下，我们如何解决*x2* = *-9*？在数学中，我们有i的概念，作为一个解，即*x* = *3i*。诸如i、-i、3i和2.27i的数字称为虚数。"一个实数"
    + "一个虚数"形成一个"复数"。
- en: '*Complex number = (real part) + (imaginary part) I*'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*复数 = (实部) + (虚部) I*'
- en: 'The following examples show complex number representation using the Breeze
    library for Mathematics:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了使用Breeze库进行数学运算的复数表示：
- en: '[PRE4]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This preceding code gives us the following result:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码给出了以下结果：
- en: '[PRE5]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Vectors
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向量
- en: A vector is a mathematical object described as an ordered set of numbers. It
    is similar to a Set, except that order is maintained in vectors. All members are
    part of real numbers. A vector having dimension n is geometrically represented
    as a point in *n*-dimensional space. The origin of a vector starts from zero.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 向量是一个数学对象，描述为一组有序的数字。它类似于一个集合，只是向量中保持顺序。所有成员都是实数的一部分。具有维度n的向量在几何上表示为*n*维空间中的一个点。向量的原点从零开始。
- en: 'Example:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 例子：
- en: '[PRE6]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Vector spaces
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向量空间
- en: Linear algebra is well known as an algebra of vector spaces. Vector objects
    of field type real or complex can be added and scaled by multiplying the vector
    with the scalar number *α*.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 线性代数被广泛认为是向量空间的代数。实数或复数类型的向量对象可以通过将向量与标量数*α*相乘来进行加法和缩放。
- en: 'Vector space is a collection of vector objects, which can be added and multiplied
    together. Two vectors can be combined to produce a third vector or another object
    in a vector space. The axioms of vector space have useful properties. Space in
    vector space helps in studying the properties of physical space, for example,
    to find how near or far away an object is. One of the examples of vector space
    is a collection of vectors in a three-dimensional Euclidean space. Vector space
    *V* over field *F* has the following properties:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 向量空间是一组可以相加和相乘的向量对象。两个向量可以组合成第三个向量或向量空间中的另一个对象。向量空间的公理具有有用的性质。向量空间中的空间有助于研究物理空间的性质，例如，找出物体的近或远。向量空间的一个例子是三维欧几里德空间中的向量集合。向量空间*V*在域*F*上具有以下属性：
- en: 'Vector addition: denoted by *v + w*, where *v* and *w* are element of space
    *V*'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向量加法：由*v + w*表示，其中*v*和*w*是空间*V*的元素
- en: 'Scalar multiplication: denoted by *α * v*, where *α* is an element of *F*'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标量乘法：用*α * v*表示，其中*α*是*F*的元素
- en: 'Associativity: represented by *u + (v + w) = (u + v) + w*, where *u*, *v*,
    and *w* are elements of space *V*'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结合性：由*u + (v + w) = (u + v) + w*表示，其中*u*、*v*和*w*是空间*V*的元素
- en: 'Commutative: indicated by *v + w = w + v*'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可交换：由*v + w = w + v*表示
- en: 'Distributive: denoted by *α * (v + w) = α * v + α * w*'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分配：由*α * (v + w) = α * v + α * w*表示
- en: In machine learning, features are the dimensions of vector space.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在机器学习中，特征是向量空间的维度。
- en: Vector types
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向量类型
- en: In Scala, we will use the Breeze library to represent a vector. The vector can
    be represented as a dense or a sparse vector.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在Scala中，我们将使用Breeze库来表示向量。向量可以表示为密集向量或稀疏向量。
- en: Vectors in Breeze
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Breeze中的向量
- en: Breeze uses two basic vector types-`breeze.linalg.DenseVector` and `breeze.linalg.SparseVector`-to
    represent the two vector types shown earlier.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Breeze使用两种基本向量类型-`breeze.linalg.DenseVector`和`breeze.linalg.SparseVector`-来表示前面显示的两种向量类型。
- en: '`DenseVector` is a wrapper around an array which supports numeric operations.
    Let''s first look at the dense vector computation; we will create a dense vector
    object using Breeze, and then update index three to a new value.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`DenseVector`是一个围绕数组的包装器，支持数值运算。让我们首先看一下密集向量的计算；我们将使用Breeze创建一个密集向量对象，然后将索引三更新为一个新值。'
- en: '[PRE7]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This gives us the following result: `DenseVector (2.0, 0.0, 3.0, 6.0, -1.0)`'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这给出了以下结果：`DenseVector (2.0, 0.0, 3.0, 6.0, -1.0)`
- en: '`SparseVector`is a vector with most of its values at zero, and supports numeric
    operations. Let''s look at the sparse vector computation; we will a create sparse
    vector object using Breeze, and then update the values by one.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`SparseVector`是一个大部分值为零的向量，并支持数值运算。让我们看一下稀疏向量的计算；我们将使用Breeze创建一个稀疏向量对象，然后将值更新为1。'
- en: '[PRE8]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This gives us the following result: `SparseVector((0,2.0), (2,4.0), (4,6.0))`'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这给出了以下结果：`SparseVector((0,2.0), (2,4.0), (4,6.0))`
- en: Vectors in Spark
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spark中的向量
- en: Spark MLlib uses Breeze and JBlas for internal linear algebraic operations.
    It uses its own class to represent a vector defined using the `org.apache.spark.mllib.linalg.Vector`
    factory. A local vector has integer-typed and 0-based indices. Its values are
    stored as double-typed. A local vector is stored on a single machine, and cannot
    be distributed. Spark MLlib supports two types of local vectors, dense and sparse,
    created using factory methods.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Spark MLlib使用Breeze和JBlas进行内部线性代数运算。它使用自己的类来表示使用`org.apache.spark.mllib.linalg.Vector`工厂定义的向量。本地向量具有整数类型和基于0的索引。其值存储为双精度类型。本地向量存储在单台机器上，不能分布。Spark
    MLlib支持两种类型的本地向量，使用工厂方法创建的密集和稀疏向量。
- en: 'The following code snippet shows how to create basic sparse and dense vectors
    in Spark:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了如何在Spark中创建基本的稀疏和密集向量：
- en: '[PRE9]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The preceding code produces the following output:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码产生以下输出：
- en: '[PRE10]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'There are various methods exposed by Spark for accessing and discovering vector
    values as shown next:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Spark提供了各种方法来访问和发现向量值，如下所示：
- en: '[PRE11]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The preceding code produces the following output:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码产生了以下输出：
- en: '[PRE12]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Vector operations
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向量操作
- en: Vectors can be added together, subtracted, and multiplied by scalars. Other
    operations on vectors include finding the mean, normalization, comparison, and
    geometrical representation.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 向量可以相加，相减，并且可以乘以标量。向量的其他操作包括找到平均值，归一化，比较和几何表示。
- en: '**The Add operation**: This code shows an element-wise add operation on vector
    objects:'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加法操作：此代码显示了向量对象上的逐元素加法操作：
- en: '[PRE13]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This last code gives us the result as follows: `DenseVector(4.0, 16.0, 11.1,
    6.3, 13.0)`'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码给出的结果如下：`DenseVector(4.0, 16.0, 11.1, 6.3, 13.0)`
- en: '**Multiply and Dot operation**: It is an algebraic operation, which takes two
    sequences of an equal length of numbers, and returns a single number; algebraically,
    it is the sum of the products of the corresponding entries of the two sequences
    of numbers. It is mathematically represented as follows:'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 乘法和点操作：这是一种代数操作，它接受两个相等长度的数字序列，并返回一个数字；代数上，它是两个数字序列对应条目的乘积的和。数学上表示如下：
- en: '![](img/image_02_005.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_02_005.png)'
- en: '[PRE14]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This preceding code gives us the following result:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码给出了以下结果：
- en: '[PRE15]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The last code gives us the result as follows: `0.9024889161, 0.9024889161`'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的代码给出的结果如下：`0.9024889161, 0.9024889161`
- en: '**Finding the** **Mean: **This operation returns the mean of the elements of
    the vector along the first array dimension, whose size does not equal `1`. It
    is mathematically represented as follows:'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寻找平均值：此操作返回向量元素沿第一个数组维度的平均值，其大小不等于`1`。数学上表示如下：
- en: '[PRE16]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This gives us the result as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这给出了以下结果：
- en: '`1.0`'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`1.0`'
- en: '[PRE17]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This gives us the result as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这给出了以下结果：
- en: '` (1.0,1.5)`'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh:  (1.0,1.5)
- en: '**Normalized vector**: Every vector has a magnitude, which is calculated using
    the Pythagoras theorem as *|v| = sqrt(x^2 + y^2 + z^2);* this magnitude is a length
    of a line from the origin point (`0,0,0`) to the point indicated by the vector.
    A vector is normal if its magnitude is `1`. Normalizing a vector means changing it
    so that it points in the same direction (beginning from the origin), but its magnitude
    is one. Hence, a normalized vector is a vector in the same direction, but with
    norm (length) `1`. It is denoted by ^X and is given by the following formula:'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 归一化向量：每个向量都有一个大小，使用毕达哥拉斯定理计算，如*|v| = sqrt(x^2 + y^2 + z^2);* 这个大小是从原点(`0,0,0`)到向量指示的点的长度。如果向量的大小是`1`，则向量是正规的。归一化向量意味着改变它，使其指向相同的方向（从原点开始），但其大小为一。因此，归一化向量是一个指向相同方向的向量，但其规范（长度）为`1`。它由^X表示，并由以下公式给出：
- en: '![](img/image_02_006.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_02_006.png)'
- en: Where ![](img/image_02_007.png) is the norm of ![](img/image_02_008.png). It
    is also called a unit vector.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 其中![](img/image_02_007.png)是![](img/image_02_008.png)的范数。它也被称为单位向量。
- en: '[PRE18]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This gives us the following result:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这给出了以下结果：
- en: '[PRE19]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '**Displaying the minimum and maximum element in a vector**:'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示向量中的最小和最大元素：
- en: '[PRE20]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This gives us the result as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这给出了以下结果：
- en: '`4, 2, -1, 3`'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`4, 2, -1, 3`'
- en: '**Compare operation**: This compares two vectors for equality and for less
    than, or greater than, operations:'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较操作：这比较两个向量是否相等，以及进行小于或大于的操作：
- en: '[PRE21]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This gives us the following result:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这给出了以下结果：
- en: '[PRE22]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '**Geometrical representation of a vector**:'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向量的几何表示：
- en: '![](img/image_02_009.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_02_009.png)'
- en: Hyperplanes
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 超平面
- en: 'Vectors of field type real numbers are difficult to visualize if *n* is not
    1,2, or 3\. Familiar objects like lines and planes make sense for any value of
    *n*. Line *L* along the direction defined by a vector *v*, through a point *P*
    labeled by a vector u, can be written as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*n*不是1,2或3，实数域的向量很难可视化。熟悉的对象如线和平面对于任何值的*n*都是有意义的。沿着向量*v*定义的方向的线*L*，通过向量*u*标记的点*P*，可以写成如下形式：
- en: '*L = {u + tv | t* *&in; R}*'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '*L = {u + tv | t* *&in; R}*'
- en: 'Given two non-zero vectors, *u* and *v*, they determine a plane if both the
    vectors are not in the same line, and one of the vectors is a scalar multiple
    of the other. The addition of two vectors is accomplished by laying the vectors
    head to tail in a sequence to create a triangle. If u and *v* lie in a plane,
    then their sum lies in the plane of *u* and *v*. The plane represented by two
    vectors *u* and *v* can be mathematically shown as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 给定两个非零向量*u*和*v*，如果这两个向量不在同一条直线上，并且其中一个向量是另一个的标量倍数，则它们确定一个平面。两个向量的加法是通过将向量头尾相接以创建一个三角形序列来完成的。如果*u*和*v*在一个平面上，那么它们的和也在*u*和*v*的平面上。由两个向量*u*和*v*表示的平面可以用数学方式表示如下：
- en: '*{P + su + tv | s, t* *&in; R}*'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '*{P + su + tv | s, t* *&in; R}*'
- en: 'We can generalize the notion of a plane as a set of *x + 1* vectors and *P,
    v1, . . . , vx* in *R*, n with *x ≤ n* determines a x-dimensional hyperplane:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将平面的概念推广为一组*x + 1*个向量和*P, v1, . . . , vx*在*R*, n中，其中*x ≤ n*确定一个x维超平面：
- en: '*(P + X x i=1 λivi | λi* *&in; **R)*'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '*(P + X x i=1 λivi | λi* *&in; **R)*'
- en: Vectors in machine learning
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 机器学习中的向量
- en: Features in machine learning are represented using the n-dimensional vector.
    In machine learning, data objects are required to be represented in the numeric
    format to allow processing and statistic analysis. For example, images are represented
    using the pixel vector.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在机器学习中，特征使用n维向量表示。在机器学习中，要求用数字格式表示数据对象，以便进行处理和统计分析。例如，图像使用像素向量表示。
- en: Matrix
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 矩阵
- en: 'A matrix over a field *F* is a two-dimensional array whose entries are elements
    of *F*. An example of a matrix over the field of real numbers is given as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在域*F*上的矩阵是一个二维数组，其条目是*F*的元素。实数域上的矩阵示例如下：
- en: '*1 2 3*'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '*1 2 3*'
- en: '*10 20 30*'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '*10 20 30*'
- en: The previous matrix has two rows and three columns; we call it a *2 × 3* matrix.
    It is traditional to refer to the rows and columns by numbers. Row 1 is (*1 2
    3*), and row 2 is (*10 20 30*); column 1 is (*1 10*) , column 2 is (*2 20*), and
    column 3 is (*3 30*). In general, a matrix with m rows and n columns is called
    an *m × n* matrix. For matrix *A*, the element (*i, j*) is defined to be the element
    in the ith row and the jth column, and is indexed using the Ai, j or Aij notation.
    We will often use the pythonese notation, *A[i, j]*. Row *i* is the vector (*A[i,
    0], A[i, 1], A[i, 2], , A[i, m − 1]*) and column j is the vector (*A[0, j], A[1,
    j], A[2, j], , A[n − 1, j]*).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 先前的矩阵有两行三列；我们称之为*2×3*矩阵。 传统上通过数字来指代行和列。 第1行是(*1 2 3*)，第2行是(*10 20 30*)；第1列是(*1
    10*)，第2列是(*2 20*)，第3列是(*3 30*)。 通常，具有m行n列的矩阵称为*m×n*矩阵。 对于矩阵*A*，元素(*i, j*)被定义为第i行和第j列中的元素，并使用Ai,
    j或Aij表示。 我们经常使用pythonese表示法，*A[i, j]*。 第*i*行是向量(*A[i, 0], A[i, 1], A[i, 2], ,
    A[i, m − 1]*)，第j列是向量(*A[0, j], A[1, j], A[2, j], , A[n − 1, j]*)。
- en: Types of matrices
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 矩阵类型
- en: In Scala, we will use the Breeze library to represent a matrix. A matrix can
    be represented as a dense or a CSC matrix.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在Scala中，我们将使用Breeze库来表示矩阵。 矩阵可以表示为密集矩阵或CSC矩阵。
- en: '**Dense matrix**: A dense matrix is created with a constructor method call.
    Its elements can be accessed and updated. It is a column major, and can be transposed
    to convert to row major.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**密集矩阵**：使用构造方法调用创建密集矩阵。 可以访问和更新其元素。 它是列主序的，可以转置为行主序。'
- en: '[PRE23]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '**Transposing a matrix**: Transposing a matrix means swapping its rows and
    columns. The transpose of a P × Q matrix, written MT, is a Q × P matrix such that
    (MT ) j, I = Mi, j for every I &in; P, j &in; Q. Vector transpose to create a
    matrix row.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**转置矩阵**：转置矩阵意味着交换其行和列。 P×Q矩阵的转置，写作MT，是一个Q×P矩阵，使得（MT）j, I = Mi, j对于每个I &in;
    P，j &in; Q。 向量转置以创建矩阵行。'
- en: '[PRE24]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The output of the preceding program is as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 上述程序的输出如下：
- en: '[PRE25]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '**CSC matrix: **The **CSC** matrix is known as the **Compressed Sparse Columns**
    matrix. Each column within the CSC matrix represents a sparse vector. The CSC
    matrix supports all matrix operations, and is constructed using `Builder`.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CSC矩阵**：**CSC**矩阵被称为**压缩稀疏列**矩阵。 CSC矩阵支持所有矩阵操作，并使用`Builder`构建。'
- en: '[PRE26]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Matrix in Spark
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spark中的矩阵
- en: 'A local matrix in Spark has integer-typed row and column indices. Values are
    double-typed. All the values are stored on a single machine. MLlib supports the
    following matrix types:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Spark中的本地矩阵具有整数类型的行和列索引。 值为双精度类型。 所有值都存储在单台机器上。 MLlib支持以下矩阵类型：
- en: '**Dense matrices**: Matrices where entry values stored are in a single, double
    array in a column-major order.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**密集矩阵**：条目值存储在列主序的单个双精度数组中。'
- en: '**Sparse matrices**: Matrices where non-zero entry values are stored in the
    CSC format in a column-major order. For example, the following dense matrix is
    stored in a one-dimensional array [`2.0, 3.0, 4.0, 1.0, 4.0, 5.0`] for the matrix
    size (3, 2):'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**稀疏矩阵**：非零条目值以列主序的CSC格式存储的矩阵。 例如，以下稠密矩阵存储在一维数组[`2.0, 3.0, 4.0, 1.0, 4.0, 5.0`]中，矩阵大小为(3,
    2)：'
- en: '`2.0 3.0``4.0 1.0``4.0 5.0`'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`2.0 3.0``4.0 1.0``4.0 5.0`'
- en: 'This is an example of a dense and sparse matrix:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个密集和稀疏矩阵的示例：
- en: '[PRE27]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '[PRE28]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Distributed matrix in Spark
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spark中的分布式矩阵
- en: A distributed matrix has long-type row and column indices. It has double-typed
    values, stored distributively in one or more RDDs. Four different types of distributed
    matrices have been implemented in Spark. All of them are subclasses of `DistributedMatrix`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: Spark中的分布式矩阵具有长类型的行和列索引。 它具有双精度值，以分布方式存储在一个或多个RDD中。 Spark中已实现了四种不同类型的分布式矩阵。
    它们都是`DistributedMatrix`的子类。
- en: '![](img/image_02_010.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_02_010.png)'
- en: '`RowMatrix`: A `RowMatrix` is a row-oriented distributed matrix without meaningful
    row indices. (In a row-oriented matrix, consecutive elements of the rows of an
    array are contiguous in memory). `RowMatrix` is implemented as an RDD of its rows.
    Each row is a local vector. The number of columns must be less than or equal to
    *2^31* for a `RowMatrix` so that a single local vector is communicated to the
    driver, and can also be stored or operated on using a single node.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`RowMatrix`：`RowMatrix`是一种无意义的行索引的面向行的分布式矩阵。 （在面向行的矩阵中，数组的行的连续元素在内存中是连续的）。
    `RowMatrix`实现为其行的RDD。 每行是一个本地向量。 列数必须小于或等于*2^31*，以便将单个本地向量传输到驱动程序，并且还可以使用单个节点进行存储或操作。'
- en: 'The following example shows how a row matrix (dense and sparse) is created
    from the `Vectors` class:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示了如何从`Vectors`类创建行矩阵（密集和稀疏）：
- en: '[PRE29]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Output of the preceding code is as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '[PRE30]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '`IndexedRowMatrix`: `IndexedRowMatrix` is similar to a `RowMatrix`, but with
    row indices, which can be used for identifying rows and executing joins. In the
    following code listing, we create a 4x3 `IndexedMatrix` with appropriate row indices:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`IndexedRowMatrix`：`IndexedRowMatrix`类似于`RowMatrix`，但具有行索引，可用于标识行并执行连接。 在以下代码清单中，我们创建一个4x3的`IndexedMatrix`，并使用适当的行索引：'
- en: '[PRE31]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Output of the code listing above is as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码清单的输出如下：
- en: '[PRE32]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '`CoordinateMatrix`: This is a distributed matrix stored in a coordinate list
    (COO) format, backed by an RDD of its entries.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`CoordinateMatrix`：这是以坐标列表（COO）格式存储的分布式矩阵，由其条目的RDD支持。'
- en: The COO format stores a list of (row, column, value) tuples. Entries are sorted
    (row index, then column index) to improve random access times. This format is
    good for incremental matrix construction.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: COO格式存储了一个（行，列，值）元组的列表。 条目按（行索引，然后列索引）排序，以提高随机访问时间。 此格式适用于增量矩阵构建。
- en: '[PRE33]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '[PRE34]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Matrix operations
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 矩阵操作
- en: There are different kinds of operations which can be performed on matrices.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 可以对矩阵执行不同类型的操作。
- en: '**Elementwise addition**: Given two matrices, a and b, addition of the two
    (a + b) means adding each element of two matrices.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**逐元素加法**：给定两个矩阵*a*和*b*，两者的加法（a + b）意味着将两个矩阵的每个元素相加。'
- en: Breeze
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: Breeze
- en: '[PRE35]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The output of the last code is given as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一段代码的输出如下：
- en: '[PRE36]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '**Elementwise multiplication**: In this operation, each element of the matrix
    *a* is multiplied by matrix'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**逐元素乘法**：在这个操作中，矩阵*a*的每个元素都与矩阵相乘'
- en: Breeze
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: Breeze
- en: '[PRE37]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The output of the preceding code is given as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 前面命令的输出如下：
- en: '[PRE38]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '**Elementwise comparison**: In this operation, each element of a is compared
    with b. The code in Breeze is given as follows:'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**逐元素比较**：在这个操作中，将矩阵*a*的每个元素与*b*进行比较。Breeze中的代码如下所示：'
- en: Breeze
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: Breeze
- en: '[PRE39]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The output for the preceding code is give as follows:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码的输出如下：
- en: '[PRE40]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '**Inplace addition**: This implies adding each element of a by 1.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原地加法**：这意味着将*a*的每个元素加1。'
- en: Breeze
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: Breeze
- en: 'The following is the output of the preceding code:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码的输出如下：
- en: '[PRE41]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '**Element-wise sum**: This is used to add all the elements of a matrix. The
    code in Breeze is given as follows:'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**逐元素求和**：这用于添加矩阵的所有元素。Breeze中的代码如下所示：'
- en: Breeze
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Breeze
- en: '[PRE42]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The following is the output for the preceding code:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 前述代码的输出如下：
- en: '[PRE43]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '**Element-wise max**: To find the maximum value out of all the elements in
    a matrix, we use'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**逐元素最大值**：为了找到矩阵中所有元素的最大值，我们使用'
- en: '[PRE44]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Breeze
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: Breeze
- en: 'The code in Breeze can be written as follows:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: Breeze中的代码可以写成如下形式：
- en: '[PRE45]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '**Element-wise argmax**: This is used to get the position of the element with
    the maximum value.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**逐元素argmax**：这用于获取具有最大值的元素的位置。'
- en: Breeze
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: Breeze
- en: 'Code:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 代码：
- en: '[PRE46]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The output of the preceding command is as follows:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 前面命令的输出如下：
- en: '[PRE47]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '**Ceiling**: This rounds off each element of the matrix to the next integer.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Ceiling**：这将每个矩阵元素四舍五入到下一个整数。'
- en: Breeze
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: Breeze
- en: 'Code:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 代码：
- en: '[PRE48]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码的输出如下：
- en: '[PRE49]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '**Floor**: Floor rounds off the value of each element to the nearest integer
    of a lower value.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Floor**：Floor将每个元素的值四舍五入为较低值的最接近整数。'
- en: Breeze
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: Breeze
- en: 'Code:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 代码：
- en: '[PRE50]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The output will be as follows:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE51]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Determinant
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行列式
- en: The `tr` M denotes the trace of a matrix *M*; it is the sum of the elements
    along the diagonal. The trace of a matrix is normally used as a measure of the
    "size" of a matrix. The determinant is known as the product of the elements along
    its diagonal.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`tr` M表示矩阵*M*的迹；它是沿对角线的元素的总和。矩阵的迹通常被用作矩阵的“大小”的度量。行列式被称为沿其对角线的元素的乘积。'
- en: '![](img/image_02_011.png)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_02_011.png)'
- en: The determinant is majorly used in the system of linear equations; it indicates
    if the columns are linearly related, and it also helps to find the inverse of
    a matrix. For large matrices, the determinant is calculated using laplace expansion.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 行列式主要用于线性方程组；它指示列是否线性相关，并且还有助于找到矩阵的逆。对于大矩阵，行列式是使用拉普拉斯展开来计算的。
- en: '[PRE52]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Eigenvalues and eigenvectors
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特征值和特征向量
- en: '*Ax = b* is a linear equation which emerges from static problems. Eigenvalues,
    on the other hand, are used for dynamic problems. Let''s consider A as a matrix
    with x as a vector; we will now solve the new equation in linear algebra, *Ax=
    λx*.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '*Ax = b*是从静态问题中产生的线性方程。另一方面，特征值用于动态问题。让我们将A视为一个具有x作为向量的矩阵；我们现在将在线性代数中解决新方程*Ax=
    λx*。'
- en: 'As *A* multiplies *x*, the vector *x* changes its direction. But there are
    certain vectors in the same direction as *Ax*-these are known as **eigenvectors,**
    for which the following equation holds good:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 当*A*乘以*x*时，向量*x*改变了它的方向。但是有一些向量与*Ax*的方向相同-这些被称为**特征向量**，对于这些特征向量，以下方程成立：
- en: '*Ax= λx*'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '*Ax= λx*'
- en: In the last equation, vector *Ax* is lambda times the vector *x*, and *λ* is
    known as eigenvalue. Eigenvalue *λ* gives the direction of a vector-if it is reversed,
    or is in the same direction.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一个方程中，向量*Ax*是向量*x*的λ倍，*λ*被称为特征值。特征值*λ*给出了向量的方向-如果它被反转，或者在相同的方向上。
- en: '*Ax= λx* also conveys that *det(A - λI) = 0*, where *I* is the identity matrix.
    This determines *n* eigenvalues.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '*Ax= λx*也传达了*det(A - λI) = 0*，其中*I*是单位矩阵。这确定了*n*个特征值。'
- en: 'The eigenvalue problem is defined as follows:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 特征值问题定义如下：
- en: '*A x = λ x*'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '*A x = λ x*'
- en: '*A x-λ x = 0*'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '*A x-λ x = 0*'
- en: '*A x-λ I x = 0*'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '*A x-λ I x = 0*'
- en: '*(A-λ I) x = 0*'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '*(A-λ I) x = 0*'
- en: If x is non-zero, the preceding equation will have a solution only if *|A-λ
    I| = 0*. Using this equation, we can find eigenvalues.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*x*不为零，则前述方程只有解当且仅当*|A-λ I| = 0*。使用这个方程，我们可以找到特征值。
- en: '[PRE53]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'This last code gives us the following result:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这段最后的代码给出了以下结果：
- en: '[PRE54]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Singular value decomposition
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 奇异值分解
- en: 'Singular value decomposition of a matrix *M*: *m x n* (real or complex) is
    a factorization with the form *UΣV**, where *U* is an *m x R* matrix. *Σ* is an
    *R x R* rectangular diagonal matrix with non-negative real numbers on the diagonal,
    and *V* is an *n x r* unitary matrix. *r* is equal to the rank of the matrix *M*.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵*M*的奇异值分解：*m x n*（实数或复数）是一个形式为*UΣV*的分解，其中*U*是一个*m x R*矩阵。*Σ*是一个*R x R*的矩形对角矩阵，对角线上有非负实数，*V*是一个*n
    x r*酉矩阵。*r*等于矩阵*M*的秩。
- en: The diagonal entries *Σii* of Sigma are known as the singular values of *M*.
    The columns of *U* and the columns of *V* are called the left-singular vectors
    and right-singular vectors of *M* respectively.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: Sigma的对角线条目*Σii*被称为*M*的奇异值。*U*的列和*V*的列分别称为*M*的左奇异向量和右奇异向量。
- en: 'The following is an example of an SVD in Apache Spark:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是Apache Spark中SVD的示例：
- en: '[PRE55]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Matrices in machine learning
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 机器学习中的矩阵
- en: Matrices are used as mathematical objects to represent images, datasets for
    real world machine learning applications like a face or text recognition, medical
    imaging, principal component analysis, numerical accuracy, and so on.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵被用作数学对象来表示图像、实际机器学习应用中的数据集，如面部或文本识别、医学成像、主成分分析、数值精度等。
- en: As an example, eigen decomposition is explained here. Many mathematical objects
    can be understood better by breaking them into constituent parts, or by finding
    properties which are universal.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，特征分解在这里得到解释。许多数学对象可以通过将它们分解为组成部分或找到普遍性质来更好地理解。
- en: Like when integers are decomposed into prime factors, matrix decomposition is
    called eigen decomposition, where we decompose a matrix into eigenvectors and
    eigenvalues.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 就像整数被分解成质因数一样，矩阵分解被称为特征分解，其中我们将矩阵分解为特征向量和特征值。
- en: 'Eigenvector *v* of a matrix *A* is such that multiplication by *A* alters only
    the scale of *v*, as shown next:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵*A*的特征向量*v*是这样的，乘以*A*只改变*v*的比例，如下所示：
- en: '*Av = λv*'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '*Av = λv*'
- en: 'The scalar *λ* is known as the eigenvalue corresponding to this eigenvector.
    The eigen decomposition of *A* is then given by the following:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 标量*λ*称为与该特征向量对应的特征值。然后矩阵*A*的特征分解如下：
- en: '*A = V diag(λ)V −1*'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '*A = V diag(λ)V −1*'
- en: The eigen decomposition of a matrix shares many facts about the matrix. The
    matrix is singular if and only if any of the eigenvalues is 0\. The eigen decomposition
    of a real symmetric matrix can also be used to optimize quadratic expressions
    and much more. Eigenvectors and eigenvalues are used for **Principal Component
    Analysis**.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵的特征分解与矩阵共享许多事实。如果任何一个特征值为0，则矩阵是奇异的。实对称矩阵的特征分解也可用于优化二次表达式等。特征向量和特征值用于**主成分分析**。
- en: 'The following example shows how a `DenseMatrix` is used to get eigenvalues
    and eigen vectors:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示了如何使用`DenseMatrix`来获取特征值和特征向量：
- en: '[PRE56]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'This gives us the following result:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们以下结果：
- en: '[PRE57]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Functions
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数
- en: To define a mathematical object like a function, we must first understand what
    a set is.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义数学对象如函数，我们必须首先了解集合是什么。
- en: A set is an unordered collection of objects like S = {-4, 4, -3, 3, -2, 2, -1,
    1, 0}. If a set S is not infinite, we use |S| to denote the number of elements,
    which is known as the Cardinality of the set. If *A* and *B* are finite sets,
    then *|A**&rarrb;**B|=|A|**&rarrb;**|B|*, which is known as the Cartesian product.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 集合是一个无序的对象集合，如S = {-4, 4, -3, 3, -2, 2, -1, 1, 0}。如果集合S不是无限的，我们用|S|表示元素的数量，这被称为集合的基数。如果*A*和*B*是有限集合，则*|A**&rarrb;**B|=|A|**&rarrb;**|B|*，这被称为笛卡尔积。
- en: For each input element in a set A, a function assigns a single output element
    from another set B. A is called the domain of the function, and B, the codomain.
    A function is a set of pairs *(x, y)*, with none of these pairs having the same
    first element.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 对于集合A中的每个输入元素，函数从另一个集合B中分配一个单一的输出元素。A称为函数的定义域，B称为值域。函数是一组*(x, y)*对，其中没有这些对具有相同的第一个元素。
- en: 'Example: The function with domain {1, 2, 3, . . .}, which doubles its input
    is the set {(1,2),(2,4),(3,6),(4,8),...}'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：定义域为{1, 2, 3, . . .}的函数，将其输入加倍得到集合{(1,2),(2,4),(3,6),(4,8),...}
- en: 'Example: The function with domain {1, 2, 3, . . .} &rarrb; {1, 2, 3, . . .},
    which multiplies the numbers forming its input is {((1,1),1),((1,2),2)),...,((2,1),2),((2,2),4),((2,3),6),...
    ((3,1),3),((3,2),6),((3,3),9),...'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：定义域为{1, 2, 3, . . .}，值域为{1, 2, 3, . . .}的函数，将其输入的数字相乘得到{((1,1),1),((1,2),2)),...,((2,1),2),((2,2),4),((2,3),6),...
    ((3,1),3),((3,2),6),((3,3),9),...
- en: The output of a given input is known as the image of that input. The image of
    q under a function f is denoted by *f (q)*. If *f(q)=s*, we say q maps to s under
    f. We write this as *q->s*. The set from which all the outputs are chosen is a
    codomain.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 给定输入的输出称为该输入的像。函数f下q的像用*f (q)*表示。如果*f(q)=s*，我们说q在f下映射到s。我们将其写为*q->s*。所有输出被选择的集合称为值域。
- en: 'We write this as *f: D -> F* when we want to say that f is a function with
    domain D and codomain *F*.'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '当我们想要说f是一个定义域为D，值域为*F*的函数时，我们将其写为*f: D -> F*。'
- en: Function types
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数类型
- en: '**Procedures versus Functions**:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '**程序与函数**：'
- en: A procedure is a description of a computation that, given an input, produces
    an output.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 过程是对计算的描述，给定一个输入，产生一个输出。
- en: Functions or computational problems don't indicate how to compute the output
    from the given input.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 函数或计算问题不指示如何从给定输入计算输出。
- en: Many methods might exist for the same specification.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的规范可能存在许多方法。
- en: A computational problem may allow several possible outputs for each input.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个输入，计算问题可能有几种可能的输出。
- en: We will write procedures in Breeze; often, these are called functions, but we
    will reserve that term for the mathematical objects.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在Breeze中编写程序；通常称为函数，但我们将保留该术语用于数学对象。
- en: '**One to One function**:'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一一函数**：'
- en: '*f : D -> F* is one-to-one if *f (x) = f (y)* implies *x = y;* that is, both
    *x* and *y* are in *D.*'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '*f : D -> F* 如果*f (x) = f (y)*意味着*x = y*，即*x*和*y*都在*D*中，则*f : D -> F*是一一函数。'
- en: '**Onto function**:'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**满射函数**：'
- en: '*F: D -> F* is onto if for every *z* element of *F*, there exists an element
    a in *D* such that *f (a) = z*.'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '*F: D -> F* 如果对于每个*F*的元素*z*，存在一个元素a在*D*中，使得*f (a) = z*，则称为满射。'
- en: A function is invertible if it is one-to-one and onto.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 如果函数是一一对应的并且满射的，则它是可逆的。
- en: '**Linear functions**: Linear functions are the functions whose graph is a straight
    line. A linear function has the form *z = f(x) = a + bx*. A linear function has
    one dependent variable, and one independent variable. The dependent variable is
    *z*, and the independent variable is *x*.'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**线性函数**：线性函数是其图形为直线的函数。线性函数的形式为*z = f(x) = a + bx*。线性函数有一个因变量和一个自变量。因变量是*z*，自变量是*x*。'
- en: '![](img/image_02_012.png)'
  id: totrans-307
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_02_012.png)'
- en: '**Polynomial function**: A polynomial function involves only non-negative integer
    powers of x such as a quadratic, a cubic, a quartic, and so on. We can give a
    general definition of a polynomial, and define its degree. A polynomial of degree
    n is a function of the form *f(x) = anx n + an−1x n−1 + . . . + a2x 2 + a1x +
    a0*, where a''s are real numbers, also known as coefficients of polynomials.'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多项式函数**：多项式函数只涉及x的非负整数幂，如二次的、三次的、四次的等等。我们可以给出多项式的一般定义，并定义它的次数。次数为n的多项式是形式为*f(x)
    = anx n + an−1x n−1 + . . . + a2x 2 + a1x + a0*的函数，其中a是实数，也称为多项式的系数。'
- en: 'For example: *f(x) = 4x 3 − 3x 2 + 2*'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：*f(x) = 4x 3 − 3x 2 + 2*
- en: '![](img/image_02_013.png)'
  id: totrans-310
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_02_013.png)'
- en: '**Identity function**: For any domain *D*, *idD: D -> D* maps each domain element
    *d* to itself.'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**恒等函数**：对于任何域*D*，*idD: D -> D*将每个域元素*d*映射到它自己。'
- en: '![](img/image_02_014.png)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_02_014.png)'
- en: '**Constant function**: this is a special function represented as a horizontal
    line.'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**常数函数**：这是一个特殊的函数，表示为一条水平线。'
- en: '![](img/image_02_015.png)'
  id: totrans-314
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_02_015.png)'
- en: '**Probability distribution function **: This used to define the relative likelihood
    of different outcomes of a particular experiment. It assigns a probability to
    each potential outcome. Probabilities of all outcomes must sum equal to 1\. Often,
    probability distribution is a uniform distribution. That means, it assigns the
    same probability to each outcome. When we roll a die, the possible outcomes are
    1, 2, 3, 4, 5, and probabilities are defined as *Pr(1) = Pr(2) = Pr(3) = Pr(4)
    = Pr(5) = 1/5*.'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**概率分布函数**：用于定义特定实验不同结果的相对可能性。它为每个潜在结果分配一个概率。所有结果的概率必须总和等于1。通常，概率分布是均匀分布。这意味着它为每个结果分配相同的概率。当我们掷骰子时，可能的结果是1、2、3、4、5，概率定义为*Pr(1)
    = Pr(2) = Pr(3) = Pr(4) = Pr(5) = 1/5*。'
- en: '**Gaussian Function**: When the number of events is large, then the Gaussian
    function can be used to describe events. Gaussian distribution is described as
    a continuous function, also known as normal distribution. Normal distribution
    has the mean equal to median, and has symmetry about the center.'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高斯函数**：当事件数量很大时，可以使用高斯函数来描述事件。高斯分布被描述为一个连续函数，也称为正态分布。正态分布的均值等于中位数，并且关于中心对称。'
- en: Functional composition
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数组合
- en: 'For functions *f: A -> B* and *g: B -> C*, the functional composition of function
    f and function *g* is the function *(g o f): A -> C*, defined by *(g o f)(x) =
    g(f(x))*. For example, if *f : {1,2,3} -> {A,B,C,D}* and *g : {A,B,C,D} -> {4,5}*,
    the composition of *g(y)=y2* and *f(x)=x+1* is *(g o f)(x)=(x+1)2*.'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '对于函数*f: A -> B*和*g: B -> C*，函数*f*和函数*g*的函数组合是函数*(g o f): A -> C*，由*(g o f)(x)
    = g(f(x))*定义。例如，如果*f : {1,2,3} -> {A,B,C,D}*和*g : {A,B,C,D} -> {4,5}*，*g(y)=y2*和*f(x)=x+1*的组合是*(g
    o f)(x)=(x+1)2*。'
- en: Function composition is applying a function to the results of another function.
    So, in *(g o f)(x) = g(f(x))*, first apply *f()*, and then *g()*. Some functions
    can be decomposed into two (or more) simpler functions.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 函数组合是将一个函数应用于另一个函数的结果。因此，在*(g o f)(x) = g(f(x))*中，首先应用*f()*，然后是*g()*。一些函数可以分解为两个（或更多）更简单的函数。
- en: Hypothesis
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 假设
- en: '*X* denotes the input variables, also called input features, and *y* denotes
    the output or target variable that we are trying to predict. The pair *(x, y)*
    is called a training example, and the dataset used to learn is a list of *m* training
    examples, where *{(x, y)}* is a training set. We will also use *X* to denote the
    space of input values, and *Y* to denote the space of output values. For a training
    set, to learn a function, *h: X → Y* so that *h(x)* is a predictor for the value
    of *y*. Function *h* is called a **hypothesis**.'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '*X*表示输入变量，也称为输入特征，*y*表示我们试图预测的输出或目标变量。对*(x, y)*这对被称为一个训练示例，用于学习的数据集是一个包含*m*个训练示例的列表，其中*{(x,
    y)}*是一个训练集。我们还将使用*X*表示输入值的空间，*Y*表示输出值的空间。对于一个训练集，为了学习一个函数*h: X → Y*，使得*h(x)*是*y*值的预测值。函数*h*被称为**假设**。'
- en: When the target variable to be predicted is continuous, we call the learning
    problem a regression problem. When *y* can take a small number of discrete values,
    we call it a classification problem.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 当要预测的目标变量是连续的时，我们称学习问题为回归问题。当*y*可以取少量离散值时，我们称之为分类问题。
- en: Let's say we choose to approximate *y* as a linear function of *x*.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们选择将*y*近似为*x*的线性函数。
- en: 'The hypothesis function is as follows:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 假设函数如下：
- en: '![](img/image_02_016.png)'
  id: totrans-325
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_02_016.png)'
- en: 'In this last hypothesis function, the *θi* ''s are parameters, also known as
    weights, which parameterize the space of linear functions mapping from *X* to
    *Y*. To simplify the notation, we also introduce the convention of letting *x0
    = 1* (this is the intercept term), such that:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个最后的假设函数中，*θi*是参数，也称为权重，它们参数化从*X*到*Y*的线性函数空间。为了简化表示法，我们还引入了一个约定，即让*x0 = 1*（这是截距项），如下所示：
- en: '![](img/image_02_017.png)'
  id: totrans-327
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_02_017.png)'
- en: On the RHS, we view *θ* and *x* both as vectors, and n is the number of input
    variables.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在RHS上，我们将*θ*和*x*都视为向量，n是输入变量的数量。
- en: Now before we proceed any further, it's important to note that we will now be
    transitioning from mathematical fundamentals to learning algorithms. Optimizing
    the cost function and learning *θ* will lay the foundation to understand machine
    learning algorithms.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在我们继续之前，重要的是要注意，我们现在将从数学基础过渡到学习算法。优化成本函数和学习*θ*将奠定理解机器学习算法的基础。
- en: Given a training set, how do we learn the parameters *θ*? One method that looks
    possible is to get *h(x)* close to *y* for the given training examples. We shall
    define a function that measures, for each value of the *θ*s, how close the *h(x(i))*s
    are to the corresponding *y (i)* s. We define this as a cost function.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个训练集，我们如何学习参数*θ*？一种可能的方法是让*h(x)*接近给定训练示例的*y*。我们将定义一个函数，用于衡量每个*θ*值的*h(x(i))*与相应的*y(i)*之间的接近程度。我们将这个函数定义为成本函数。
- en: '![](img/image_02_018.png)'
  id: totrans-331
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_02_018.png)'
- en: Gradient descent
  id: totrans-332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 梯度下降
- en: An SGD implementation of gradient descent uses a simple distributed sampling
    of the data examples. Loss is a part of the optimization problem, and therefore,
    is a true sub-gradient.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 梯度下降的SGD实现使用数据示例的简单分布式采样。损失是优化问题的一部分，因此是真子梯度。
- en: '![](img/image_02_019.png)'
  id: totrans-334
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_02_019.png)'
- en: This requires access to the full dataset, which is not optimal.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要访问完整的数据集，这并不是最佳的。
- en: '![](img/image_02_020.png)'
  id: totrans-336
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_02_020.png)'
- en: The parameter *miniBatchFraction* specifies the fraction of the full data to
    use. The average of the gradients over this subset
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 参数*miniBatchFraction*指定要使用的完整数据的分数。在这个子集上的梯度的平均值
- en: '![](img/image_02_021.png)'
  id: totrans-338
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_02_021.png)'
- en: is a stochastic gradient. *S* is a sampled subset of size *|S|= miniBatchFraction*.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 是随机梯度。*S*是大小为*|S|= miniBatchFraction*的样本子集。
- en: In the following code, we show how to use stochastic gardient descent on a mini
    batch to calculate the weights and the loss. The output of this program is a vector
    of weights and loss.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我们展示了如何使用随机梯度下降在小批量上计算权重和损失。该程序的输出是一组权重和损失的向量。
- en: '[PRE58]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Prior, likelihood, and posterior
  id: totrans-342
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 先验，似然和后验
- en: 'Bayes theorem states the following:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 贝叶斯定理陈述如下：
- en: '*Posterior = Prior * Likelihood*'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '*后验=先验*似然*'
- en: This can also be stated as *P (A | B) = (P (B | A) * P(A)) / P(B)* , where *P(A|B)*
    is the probability of *A* given *B*, also called posterior.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 这也可以表示为*P(A|B) = (P(B|A) * P(A)) / P(B)*，其中*P(A|B)*是给定*B*的* A*的概率，也称为后验。
- en: '**Prior**: Probability distribution representing knowledge or uncertainty of
    a data object prior or before observing it'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '**先验**：表示在观察数据对象之前或之前的知识或不确定性的概率分布'
- en: '**Posterior**: Conditional probability distribution representing what parameters
    are likely after observing the data object'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '**后验**：表示在观察数据对象后参数可能性的条件概率分布'
- en: '**Likelihood**: The probability of falling under a specific category or class.'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '**似然**：落入特定类别或类别的概率。'
- en: 'This is represented as follows:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 这表示为：
- en: '![](img/image_02_022.png)'
  id: totrans-350
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_02_022.png)'
- en: Calculus
  id: totrans-351
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微积分
- en: Calculus is a mathematical tool which helps the study of how things change.
    It provides a framework for modeling systems in which there is change, and a way
    to deduce the predictions of such models.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 微积分是一种数学工具，有助于研究事物的变化。它为建模存在变化的系统提供了一个框架，并推断了这些模型的预测。
- en: Differential calculus
  id: totrans-353
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微分微积分
- en: At the core of calculus lie derivatives, where the derivative is defined as
    the instantaneous rate of change of a given function with respect to one of its
    variables. The study of finding a derivative is known as differentiation. Geometrically,
    the derivative at a known point is given by the slope of a tangent line to the
    graph of the function, provided that the derivative exists, and is defined at
    that point.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 微积分的核心是导数，其中导数被定义为给定函数相对于其变量之一的瞬时变化率。寻找导数的研究被称为微分。几何上，已知点的导数由函数图的切线的斜率给出，前提是导数存在，并且在该点被定义。
- en: Differentiation is the reverse of Integration. Differentiation has several applications;
    like in physics, the derivative of displacement is velocity, and the derivative
    of velocity is acceleration. Derivatives are mainly used to find maxima or minima
    of a function.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 微分是积分的反向。微分有几个应用，比如在物理学中，位移的导数是速度，速度的导数是加速度。导数主要用于找到函数的最大值或最小值。
- en: Within machine learning, we deal with the functions that operate on variables
    or features having hundreds or more dimensions. We calculate derivatives of the
    function in each dimension of the variable, and combine these partial derivatives
    into a vector, which gives us what is called a gradient. Similarly, taking the
    second-order derivative of a gradient gives us a matrix termed as **Hessian**.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在机器学习中，我们处理对具有数百个或更多维度的变量或特征进行操作的函数。我们计算变量的每个维度的导数，并将这些偏导数组合成一个向量，这给我们所谓的梯度。类似地，对梯度进行二阶导数运算给我们一个被称为**海森**的矩阵。
- en: The knowledge of gradients and hessians helps us define things like directions
    of descent and rate of descent, which tell us how we should travel in our function
    space in order to get to the bottom-most point, in order to minimize the function.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 梯度和海森矩阵的知识帮助我们定义诸如下降方向和下降速率之类的事物，告诉我们应该如何在函数空间中移动，以便到达最底部点，以最小化函数。
- en: 'The following is an example of a simple objective function (linear regression
    with weights *x*, *N* data points, and *D* dimensions in a vectorized notation:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个简单目标函数的例子（使用向量化符号表示的带有权重*x*、*N*数据点和*D*维度的线性回归：
- en: '![](img/image_02_023.png)'
  id: totrans-359
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_02_023.png)'
- en: The method of Lagrange multipliers is a standard way in calculus to maximize
    or minimize functions when there are constraints involved.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 拉格朗日乘数法是微积分中在涉及约束时最大化或最小化函数的标准方法。
- en: Integral calculus
  id: totrans-361
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 积分微积分
- en: Integral calculus joins (integrates) the granular pieces together to find the
    total. It is also known as anti-differential, where differential is to divide
    into small chunks and study how it changes as described in the previous section.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 积分微积分将颗粒状的部分连接在一起以找到总数。它也被称为反微分，其中微分是将其分成小块并研究其在前一节中描述的变化。
- en: Integral is often used to find the area underneath the graph of a function.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 积分通常用于找到函数图形下方的面积。
- en: Lagranges multipliers
  id: totrans-364
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拉格朗日乘数
- en: In the math optimization problem, the method of Lagrange multipliers is used
    as a tool for finding the local minima and maxima of a function subject to equality
    constraints. An example involves finding the maximum entropy distribution subject
    to given constraints.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在数学优化问题中，拉格朗日乘数法被用作在等式约束下找到函数的局部极小值和极大值的工具。一个例子涉及找到在给定约束条件下的最大熵分布。
- en: This is best explained with an example. Let's say we have to maximize *K (x,
    y) = -x2 -y2 subject to y = x + 1*.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 这最好通过一个例子来解释。假设我们必须最大化*K(x, y) = -x2 -y2，以*y = x + 1*为约束。
- en: 'The constraint function is *g (x, y) = x-y+1=0*. The *L* multiplier then becomes
    this:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 约束函数为*g(x, y) = x-y+1=0*。然后*L*乘数变为这样：
- en: '![](img/image_02_024.png)'
  id: totrans-368
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_02_024.png)'
- en: 'Differentiating with respect to *x*, *y*, and lambda, and setting to *0* we
    get the following:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 关于*x*、*y*和λ的微分，并设置为*0*，我们得到以下结果：
- en: '![](img/image_02_025.png)![](img/image_02_026.png)![](img/image_02_027.png)'
  id: totrans-370
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_02_025.png)![](img/image_02_026.png)![](img/image_02_027.png)'
- en: Solving the preceding equations, we get *x=-0.5*, *y=0.5*, *lambda=-1*.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 解决上述方程，我们得到*x=-0.5*，*y=0.5*，*lambda=-1*。
- en: Plotting
  id: totrans-372
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘图
- en: In this segment, we will see how to use Breeze to create a simple line plot
    from the Breeze `DenseVector`.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将看到如何使用Breeze从Breeze `DenseVector`创建一个简单的线图。
- en: 'Breeze uses most of the functionality of Scala''s plotting facilities, although
    the API is different. In the following example, we create two vectors `x1` and
    `y` with some values, and plot a line and save it to a PNG file:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: Breeze使用了大部分Scala绘图工具的功能，尽管API不同。在下面的例子中，我们创建了两个向量`x1`和`y`，并绘制了一条线并将其保存为PNG文件：
- en: '[PRE59]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The preceding code generates the following Line Plot:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码生成了以下线图：
- en: '![](img/image_02_028.png)'
  id: totrans-377
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_02_028.png)'
- en: Breeze also supports histogram. This is drawn for various sample sizes `100,000`,
    and `100,0000` normally distributed random numbers into `100` buckets.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: Breeze还支持直方图。这是为各种样本大小`100,000`和`100,0000`绘制的，以及`100`个桶中的正态分布随机数。
- en: '[PRE60]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '![](img/image_02_029.png)'
  id: totrans-380
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_02_029.png)'
- en: 'A Gaussian distribution with 1000000 elements is shown in this next image:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 下一张图片显示了具有1000000个元素的高斯分布：
- en: '![](img/image_02_030.png)'
  id: totrans-382
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_02_030.png)'
- en: A Gaussian distribution with 100 elements
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 具有100个元素的高斯分布
- en: Summary
  id: totrans-384
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learnt the basics of linear algebra, which is useful for
    machine learning, and the basic constructs like vectors and matrix. You also learnt
    how to use Spark and Breeze to do basic operations on these constructs. We looked
    at techniques like SVD to transform data. We also looked at the importance of
    the function types in linear algebra. In the end, you learnt how to plot basic
    charts using Breeze. In the next chapter, we will cover an overview of Machine
    Learning systems, components and architecture.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了线性代数的基础知识，这对机器学习很有用，以及向量和矩阵等基本构造。您还学会了如何使用Spark和Breeze对这些构造进行基本操作。我们研究了诸如SVD之类的技术来转换数据。我们还研究了线性代数中函数类型的重要性。最后，您学会了如何使用Breeze绘制基本图表。在下一章中，我们将介绍机器学习系统、组件和架构的概述。
