- en: Chapter 1. Fundamentals of the Python Language for ArcGIS
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章：ArcGIS的Python语言基础
- en: Python supports many of the programming constructs found in other languages.
    In this chapter, we'll cover many of the basic language constructs found in Python.
    Initially, we'll cover how to create new Python scripts and edit existing scripts.
    From there, we'll delve into language features, such as adding comments to your
    code, creating and assigning data to variables, and built-in variable typing with
    Python, which makes coding with Python easy and compact.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Python支持许多在其他语言中找到的编程结构。在本章中，我们将介绍Python中许多基本语言结构。最初，我们将介绍如何创建新的Python脚本和编辑现有脚本。从那里，我们将深入探讨语言特性，例如在代码中添加注释、创建和分配数据给变量，以及Python的内置变量类型，这使得使用Python编程变得简单且紧凑。
- en: Next, we'll look at the various built-in data-types that Python offers, such
    as strings, numbers, lists, and dictionaries. Classes and objects are a fundamental
    concept in object-oriented programming and in the Python language. We'll introduce
    you to these complex data structures, which you'll use extensively when you write
    geoprocessing scripts with ArcGIS.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨Python提供的各种内置数据类型，例如字符串、数字、列表和字典。类和对象是面向对象编程和Python语言中的基本概念。我们将向您介绍这些复杂的数据结构，您在编写ArcGIS的地理处理脚本时将广泛使用它们。
- en: 'In addition, we''ll cover statements including decision support and looping
    structures for making decisions in your code and/or looping through a code block
    multiple times along with `with` statements, which are used extensively with the
    new `cursor` objects in the Arcpy Data Access module. Finally, you''ll learn how
    to access modules that provide additional functionality to the Python language.
    By the end of this chapter, you will have learned the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们将介绍包括决策支持和循环结构在内的语句，用于在代码中做出决策和/或多次遍历代码块，以及与Arcpy数据访问模块中的新`cursor`对象广泛使用的`with`语句。最后，您将学习如何访问提供Python语言额外功能的模块。到本章结束时，您将学习以下内容：
- en: How to create and edit new Python scripts
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建和编辑新的Python脚本
- en: Python language features
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python语言特性
- en: Comments and data variables
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注释和数据变量
- en: Built-in datatypes (Strings, Numbers, Lists, and Dictionaries)
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内置数据类型（字符串、数字、列表和字典）
- en: Complex data structures
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复杂数据结构
- en: Looping structures
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 循环结构
- en: Additional Python functionality
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 额外的Python功能
- en: Using IDLE for Python script development
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用IDLE进行Python脚本开发
- en: As I mentioned in the preface, when you install ArcGIS Desktop, Python is also
    installed along with a tool called IDLE that allows you to write your own code.
    **IDLE** stands for **Integrated DeveLopment Environment**. Because it is available
    with every ArcGIS Desktop installation, we'll use the IDLE development environment
    for many of the scripts that we write in this book along with the Python window
    embedded in ArcGIS Desktop. As you progress as a programmer, you may find other
    development tools that you prefer over IDLE. You can write your code in any of
    these tools.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在前言中提到的，当您安装ArcGIS桌面版时，Python也会安装，并附带一个名为IDLE的工具，允许您编写自己的代码。"**IDLE**"代表**集成开发环境**。因为它与每个ArcGIS桌面安装一起提供，所以我们将使用IDLE开发环境来编写本书中的许多脚本，以及ArcGIS桌面中嵌入的Python窗口。随着您作为程序员的进步，您可能会发现比IDLE更喜欢的其他开发工具。您可以使用这些工具中的任何一个来编写代码。
- en: The Python shell window
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python外壳窗口
- en: To start the IDLE development environment for Python, you can go to **Start**
    | **Programs** | **ArcGIS** | **Python 2.7** | **IDLE**. Please note that the
    version of Python installed with ArcGIS will differ depending upon the ArcGIS
    version that you have installed. For example, ArcGIS 10.0 uses Python 2.6 while
    ArcGIS 10.1 uses Python 2.7.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动Python的IDLE开发环境，您可以前往**开始** | **程序** | **ArcGIS** | **Python 2.7** | **IDLE**。请注意，ArcGIS安装的Python版本将取决于您安装的ArcGIS版本。例如，ArcGIS
    10.0使用Python 2.6，而ArcGIS 10.1使用Python 2.7。
- en: 'A Python shell window similar to the screenshot will be displayed:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 将显示与截图类似的Python外壳窗口：
- en: '![The Python shell window](img/4445_01_1.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![Python外壳窗口](img/4445_01_1.jpg)'
- en: The Python shell window is used for output and error messages generated by scripts.
    A common mistake for beginners is to assume that the geoprocessing scripts will
    be written in this shell window. That is not the case. You will need to create
    a separate code window to hold your scripts.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Python外壳窗口用于输出和脚本生成的错误信息。初学者常见的错误是认为地理处理脚本将在这个外壳窗口中编写。事实并非如此。您需要创建一个单独的代码窗口来存放您的脚本。
- en: Although the shell window isn't used to write entire scripts, it can be used
    to interactively write code and get immediate feedback. ArcGIS has a built-in
    Python shell window that you can use in much the same way. We'll examine the ArcGIS
    Python window in the next chapter.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然shell窗口不用于编写整个脚本，但它可以用来交互式地编写代码并立即获得反馈。ArcGIS内置了一个Python shell窗口，你可以以类似的方式使用它。我们将在下一章中检查ArcGIS
    Python窗口。
- en: The Python script window
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python脚本窗口
- en: 'Your scripts will be written in IDLE inside a separate window known as the
    **Python script window**. To create a new code window, select **File** | **New
    Window** from the IDLE shell window. A window similar to that in the following
    screenshot will be displayed:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你的脚本将写在IDLE中的单独窗口，称为**Python脚本窗口**。要创建一个新的代码窗口，从IDLE shell窗口中选择**文件** | **新建窗口**。将显示一个类似于以下截图的窗口：
- en: '![The Python script window](img/4445_01_2.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![Python脚本窗口](img/4445_01_2.jpg)'
- en: Your Python scripts will be written inside this new code window. Each script
    will need to be saved to a local or network drive. By default, scripts are saved
    with a `.py` file extension.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你的Python脚本将在这个新的代码窗口中编写。每个脚本都需要保存到本地或网络驱动器。默认情况下，脚本以`.py`文件扩展名保存。
- en: Editing existing Python scripts
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编辑现有的Python脚本
- en: 'Existing Python script files can be opened from Windows Explorer by right-clicking
    on the file and selecting **Edit with IDLE**, which brings up a new shell window
    along with the script loaded in the Python script editor. You can see an example
    of this in the following screenshot:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过在Windows资源管理器中右键单击文件并选择**使用IDLE编辑**来从Windows资源管理器打开现有的Python脚本文件，这将打开一个新的shell窗口以及加载到Python脚本编辑器中的脚本。你可以在以下截图中看到一个示例：
- en: '![Editing existing Python scripts](img/4445_01_3.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![编辑现有的Python脚本](img/4445_01_3.jpg)'
- en: 'In this instance, we have loaded the `ListFeatureClasses.py` script with IDLE.
    The code is loaded inside the script window:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们已经使用IDLE加载了`ListFeatureClasses.py`脚本。代码加载在脚本窗口内：
- en: '![Editing existing Python scripts](img/4445_01_4.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![编辑现有的Python脚本](img/4445_01_4.jpg)'
- en: Now that the code window is open, you can begin writing or editing code. You
    can also perform some basic script debugging with the IDLE interface. Debugging
    is the process of identifying and fixing errors in your code.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在代码窗口已打开，你可以开始编写或编辑代码。你还可以使用IDLE界面进行一些基本的脚本调试。调试是识别和修复代码中的错误的过程。
- en: Executing scripts from IDLE
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从IDLE执行脚本
- en: Once you've written a geoprocessing script in the IDLE code window or opened
    an existing script, you can execute the code from the interface. IDLE does provide
    functionality that allows you to check the syntax of your code before running
    the script. In the code window, select **Run** | **Check Module** to perform a
    syntax check of your code.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你在IDLE代码窗口中编写了地理处理脚本或打开了现有的脚本，你就可以从界面中执行代码。IDLE确实提供了在运行脚本之前检查代码语法的功能。在代码窗口中，选择**运行**
    | **检查模块**来执行代码的语法检查。
- en: Any syntax errors will be displayed in the shell window. If there aren't any
    syntax errors, you should just see the prompt in the shell window. While the IDLE
    interface can be used to check for syntax errors, it doesn't provide a way of
    checking for logical errors in your code nor does it provide more advanced debugging
    tools found in other development environments, such as PythonWin or Wingware.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 任何语法错误都会在shell窗口中显示。如果没有语法错误，你应该只看到shell窗口中的提示符。虽然IDLE界面可以用来检查语法错误，但它不提供检查代码中逻辑错误的方法，也不提供其他开发环境中常见的更高级的调试工具，例如PythonWin或Wingware。
- en: 'Once you''re satisfied that no syntax errors exist in your code, you can run
    the script. Select **Run** | **Run Module** to execute the script:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你确认代码中没有语法错误，你可以运行脚本。选择**运行** | **运行模块**来执行脚本：
- en: '![Executing scripts from IDLE](img/4445_01_7.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![从IDLE执行脚本](img/4445_01_7.jpg)'
- en: Any error messages will be written to the shell window along with output from
    `print` statements and system-generated messages. The `print` statement simply
    outputs a string to the shell window. It is often used for updating the status
    of a running script or for debugging the code.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 任何错误信息都将写入shell窗口，包括`print`语句的输出和系统生成的消息。`print`语句只是将字符串输出到shell窗口。它通常用于更新正在运行的脚本的状态或用于调试代码。
- en: Python language fundamentals
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python语言基础
- en: To effectively write geoprocessing scripts for ArcGIS, you are going to need
    to understand at least the basic constructs of the Python language. Python is
    easier to learn than most other programming languages, but it does take some time
    to learn and effectively use it. This section will teach you how to create variables,
    assign various datatypes to variables, understand the different types of data
    that can be assigned to variables, use different types of statements, use objects,
    read and write files, and import third-party Python modules.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有效地编写ArcGIS的地理处理脚本，您至少需要了解Python语言的基本结构。Python比大多数其他编程语言更容易学习，但学习并有效使用它需要一些时间。本节将教会您如何创建变量，将各种数据类型分配给变量，理解可以分配给变量的不同数据类型，使用不同类型的语句，使用对象，读写文件，以及导入第三方Python模块。
- en: Commenting code
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注释代码
- en: Python scripts should follow a common structure. The beginning of each script
    should serve as documentation detailing the script name, author, and a general
    description of the processing provided by the script. This documentation is accomplished
    in Python through the use of comments. Comments are lines of code that you add
    to your script that serve as a documentation of what functionality the script
    provides. These lines of code begin with a single pound sign (`#`) or a double
    pound sign (`##`), and are followed by whatever text you need to document the
    code. The Python interpreter does not execute these lines of code. They are simply
    used for documenting your code. In the next screenshot, the commented lines of
    code are displayed in red. You should also strive to include comments throughout
    your script to describe important sections of your script. This will be useful
    to you (or another programmer) when the time comes to update your scripts.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Python脚本应遵循常见的结构。每个脚本的开始应作为文档，详细说明脚本名称、作者以及脚本提供的处理的一般描述。此文档通过使用注释在Python中完成。注释是添加到脚本中以提供脚本提供的功能文档的代码行。这些代码行以单个井号（`#`）或双井号（`##`）开头，后跟您需要用于记录代码的任何文本。Python解释器不会执行这些代码行。它们仅用于记录您的代码。在下一张屏幕截图中，注释的代码行以红色显示。您还应该努力在脚本中包含注释，以描述脚本的重要部分。当您需要更新脚本时，这将对您（或另一位程序员）很有用。
- en: '![Commenting code](img/4445_01_5.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![注释代码](img/4445_01_5.jpg)'
- en: Tip
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Downloading the example code**'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.PacktPub.com](http://www.PacktPub.com). If you
    purchased this book elsewhere, you can visit [http://www.PacktPub.com/support](http://www.PacktPub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[http://www.PacktPub.com](http://www.PacktPub.com)的账户下载您购买的所有Packt书籍的示例代码文件。如果您在其他地方购买了这本书，您可以访问[http://www.PacktPub.com/support](http://www.PacktPub.com/support)并注册，以便将文件直接通过电子邮件发送给您。
- en: Importing modules
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导入模块
- en: 'Although Python includes many built-in functions, you will frequently need
    to access specific bundles of functionality, which are stored in external modules.
    For instance, the **Math module** stores specific functions related to processing
    numeric values and the **R module** provides statistical analysis functions. Modules
    are imported through the use of the `import` statement. When writing geoprocessing
    scripts with ArcGIS, you will always need to import the ArcPy module, which is
    the Python package for accessing GIS tools and functions provided by ArcGIS. `import`
    statements will be the first lines of code (not including comments) in your scripts:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Python包含许多内置函数，但您将经常需要访问存储在外部模块中的特定功能包。例如，**Math模块**存储与处理数值相关的特定函数，而**R模块**提供统计分析函数。模块通过使用`import`语句导入。在编写ArcGIS的地理处理脚本时，您始终需要导入ArcPy模块，这是用于访问ArcGIS提供的GIS工具和函数的Python包。`import`语句将是您脚本中的第一行代码（不包括注释）：
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Variables
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量
- en: 'At a high level, you can think of a variable as an area in your computer''s
    memory reserved for storing values while the script is running. Variables that
    you define in Python are given a name and a value. The values assigned to variables
    can then be accessed by different areas of your script as needed, simply by referring
    to the variable name. For example, you might create a variable that contains a
    feature class name, which is then used by the **Buffer** tool to create a new
    output dataset. To create a variable, simply give it a name followed by the assignment
    operator, which is just an equal sign (`=`), and then a value:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 从高层次来看，你可以将变量视为在脚本运行期间为存储值而保留在计算机内存中的一个区域。你定义的Python变量会被赋予一个名称和一个值。分配给变量的值可以通过引用变量名来访问脚本的不同区域。例如，你可能创建一个包含要素类名称的变量，然后由**缓冲**工具使用该变量创建新的输出数据集。要创建一个变量，只需给它一个名称，后跟赋值运算符（即等号`=`），然后是一个值：
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The following table illustrates the variable name and values assigned to the
    variable using the preceding code example:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格展示了使用前面的代码示例中变量名及其赋值：
- en: '| Variable name | Variable value |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| 变量名 | 变量值 |'
- en: '| --- | --- |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `fcParcels` | `Parcels` |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `fcParcels` | `Parcels` |'
- en: '| `fcStreets` | `Streets` |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `fcStreets` | `Streets` |'
- en: 'There are certain naming rules that you must follow when creating variables,
    including the following:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 创建变量时必须遵循某些命名规则，包括以下内容：
- en: Can contain letters, numbers, and underscores
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以包含字母、数字和下划线
- en: First character must be a letter
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个字符必须是一个字母
- en: No special characters in variable name other an underscore
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量名中除下划线外没有特殊字符
- en: Can't use Python keywords
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不能使用Python关键字
- en: There are a few dozen Python keywords that must be avoided including `class`,
    `if`, `for`, `while`, and others.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 有几十个Python关键字必须避免，包括`class`、`if`、`for`、`while`等。
- en: 'Some examples of legal variable names in Python:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Python中一些合法变量名的例子：
- en: '`featureClassParcel`'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`featureClassParcel`'
- en: '`fieldPopulation`'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fieldPopulation`'
- en: '`field2`'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`field2`'
- en: '`ssn`'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ssn`'
- en: '`my_name`'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`my_name`'
- en: 'Some examples of illegal variable names in Python:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Python中一些非法变量名的例子：
- en: '`class` (Python keyword)'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`class`（Python关键字）'
- en: '`return` (Python keyword)'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`return`（Python关键字）'
- en: '`$featureClass` (illegal character, must start with a letter)'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$featureClass`（非法字符，必须以字母开头）'
- en: '`2fields` (must start with a letter)'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2fields`（必须以字母开头）'
- en: '`parcels&Streets` (illegal character)'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parcels&Streets`（非法字符）'
- en: Python is a case-sensitive language, so pay particular attention to the capitalization
    and naming of variables in your scripts. Case-sensitivity issues are probably
    the most common source of errors for new Python programmers, so always consider
    this as a possibility when you encounter errors in your code. Let's look at an
    example. The following is a list of three variables; note that although each variable
    name is the same, the casing is different, resulting in three distinct variables.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Python是一种区分大小写的语言，因此在脚本中对变量的命名和大小写要特别注意。大小写问题可能是新Python程序员遇到的最常见的错误来源，所以当你遇到代码中的错误时，始终要考虑这一点。让我们来看一个例子。以下是一个包含三个变量的列表；请注意，尽管每个变量名相同，但大小写不同，因此产生了三个不同的变量。
- en: '`mapsize = "22x34"`'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mapsize = "22x34"`'
- en: '`MapSize = "8x11"`'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MapSize = "8x11"`'
- en: '`Mapsize = "36x48"`'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Mapsize = "36x48"`'
- en: 'If you print these variables, you will get the following output:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打印这些变量，你将得到以下输出：
- en: '[PRE2]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Python variable names need to be consistent throughout the script. Best practice
    is to use camel casing, wherein the first word of a variable name is all lowercase
    and then each successive word begins with an uppercase letter. This concept is
    illustrated in the following example with the variable name `fieldOwnerName`.
    The first word (`field`) is all lower case followed by an uppercase letter for
    the second word (`Owner`) and third word (`Name`):'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Python变量名在整个脚本中需要保持一致。最佳实践是使用驼峰命名法，即变量名的第一个单词全部小写，然后每个后续单词以大写字母开头。以下示例中的变量名`fieldOwnerName`展示了这一概念：第一个单词（`field`）全部小写，第二个单词（`Owner`）和第三个单词（`Name`）以大写字母开头：
- en: '[PRE3]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In Python, variables are dynamically typed. **Dynamic typing** means that you
    can define a variable and assign data to it without specifically defining that
    a variable name will contain a specific type of data. Commonly used datatypes
    that can be assigned to variables include the following:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，变量是动态类型的。**动态类型**意味着你可以定义一个变量并将其赋值，而不需要明确指定该变量名将包含特定类型的数据。可以分配给变量的常用数据类型包括以下几种：
- en: '| Datatype | Example value | Code example |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| 数据类型 | 示例值 | 代码示例 |'
- en: '| --- | --- | --- |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| String | `"Streets"` | `fcName = "Streets"` |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| 字符串 | `"Streets"` | `fcName = "Streets"` |'
- en: '| Number | `3.14` | `percChange = 3.14` |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| 数字 | `3.14` | `percChange = 3.14` |'
- en: '| Boolean | `True` | `ftrChanged = true` |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| 布尔 | `True` | `ftrChanged = true` |'
- en: '| List | `Streets, Parcels, Streams` | `lstFC = ["Streets", "Parcels", "Streams"]`
    |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| 列表 | `Streets, Parcels, Streams` | `lstFC = ["Streets", "Parcels", "Streams"]`
    |'
- en: '| Dictionary | `''0'':Streets,''1'':Parcels` | `dictFC = {''0'':Streets,''1'':Parcels]`
    |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| 字典 | `''0'':Streets,''1'':Parcels` | `dictFC = {''0'':Streets,''1'':Parcels]`
    |'
- en: '| Object | `Extent` | `spatialExt = map.extent` |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| 对象 | `Extent` | `spatialExt = map.extent` |'
- en: We will discuss each of these data-types in greater detail in the coming sections.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的章节中更详细地讨论这些数据类型。
- en: For instance, in C# you would need to define a variable's name and type before
    using it. This is not necessary in Python. To use a variable, simply give it a
    name and value, and you can begin using it right away. Python does the work behind
    the scenes to figure out what type of data is being held in the variable.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在 C# 中，在使用变量之前，你需要定义变量的名称和类型。在 Python 中，这并不是必需的。要使用变量，只需给它一个名称和值，你就可以立即开始使用它了。Python
    会幕后工作，以确定变量中存储的数据类型。
- en: 'For example, in C# .NET you would need to name and define the datatype for
    a variable before working with the variable. In the following code example, we''ve
    created a new variable called `aTouchdown`, which is defined as an integer variable,
    meaning that it can contain only integer data. We then assign the value `6` to
    the variable:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在 C# .NET 中，在处理变量之前，你需要命名并定义变量的数据类型。在下面的代码示例中，我们创建了一个名为 `aTouchdown` 的新变量，它被定义为整数变量，这意味着它只能包含整数数据。然后我们将值
    `6` 分配给这个变量：
- en: '[PRE4]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In Python, this same variable can be created and assigned data through dynamic
    typing. The Python interpreter is tasked with dynamically figuring out what type
    of data is assigned to the variable:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，可以通过动态类型创建并分配数据给相同的变量。Python 解释器负责动态确定分配给变量的数据类型：
- en: '[PRE5]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Your Python geoprocessing scripts for ArcGIS will often need to reference the
    location of a dataset on your computer or perhaps a shared server. References
    to these datasets will often consist of paths stored in a variable. In Python,
    pathnames are a special case that deserve some extra mention. The backslash character
    in Python is a reserved escape character and a line continuation character, thus
    there is a need to define paths using two back slashes, a single forward slash,
    or a regular single backslash prefixed with the letter `r`. These pathnames are
    always stored as strings in Python. You'll see an example of this in the following
    section.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 你的 Python 地理处理脚本对于 ArcGIS 通常需要引用计算机或共享服务器上数据集的位置。对这些数据集的引用通常由存储在变量中的路径组成。在 Python
    中，路径名是一个特殊情况，值得特别提及。Python 中的反斜杠字符是一个保留的转义字符和行续行字符，因此需要使用两个反斜杠、一个单斜杠或以字母 `r` 前缀的常规单斜杠来定义路径。这些路径名在
    Python 中始终以字符串的形式存储。你将在下面的部分中看到一个例子。
- en: 'Illegal path reference:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 非法路径引用：
- en: '[PRE6]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Legal path references:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 合法路径引用：
- en: '[PRE7]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: There may be times when you know that your script will need a variable, but
    don't necessarily know ahead of time what data will be assigned to the variable.
    In these cases, you could simply define a variable without assigning data to it.
    Data that is assigned to the variable can also be changed while the script is
    running.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你可能知道你的脚本将需要一个变量，但事先并不一定知道将分配什么数据给这个变量。在这些情况下，你可以简单地定义一个变量而不给它分配数据。在脚本运行时，分配给变量的数据也可以更改。
- en: Variables can hold many different kinds of data including primitive datatypes
    such as strings and numbers along with more complex data, such as lists, dictionaries
    and even objects. We're going to examine the different types of data that can
    be assigned to a variable along with various functions that are provided by Python
    for manipulating the data.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 变量可以存储许多不同类型的数据，包括原始数据类型，如字符串和数字，以及更复杂的数据，如列表、字典甚至对象。我们将检查可以分配给变量的不同数据类型，以及
    Python 提供的用于操作数据的各种函数。
- en: Built-in datatypes
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内置数据类型
- en: Python has a number of built-in data-types. The first built-in type that we
    will discuss is the `string` data-type. We've already seen several examples of
    `string` variables, but these types of variables can be manipulated in a lot of
    ways, so let's take a closer look at this data-type.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Python 有许多内置的数据类型。我们将首先讨论的第一个内置类型是 `string` 数据类型。我们已经看到了几个 `string` 变量的例子，但这类变量可以通过很多方式来操作，所以让我们更仔细地看看这个数据类型。
- en: Strings
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串
- en: Strings are ordered collections of characters used to store and represent text-based
    information. This is a rather dry way of saying that string variables hold text.
    String variables are surrounded by single or double quotes when being assigned
    to a variable. Examples could include a name, feature class name, a `Where` clause,
    or anything else that can be encoded as text.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串是有序字符集合，用于存储和表示基于文本的信息。这是一种相当枯燥的说法，即字符串变量包含文本。当分配给变量时，字符串变量被单引号或双引号包围。例如，可以包括一个名称、要素类名称、`Where`
    子句或任何可以编码为文本的内容。
- en: String manipulation
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 字符串操作
- en: 'Strings can be manipulated in a number of ways in Python. String concatenation
    is one of the more commonly used functions and is simple to accomplish. The `+`
    operator is used with string variables on either side of the operator to produce
    a new string variable that ties the two string variables together:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，字符串可以通过多种方式进行操作。字符串连接是更常用的函数之一，并且实现简单。`+` 操作符用于操作符两边的字符串变量，以产生一个新的字符串变量，将两个字符串变量连接在一起：
- en: '[PRE8]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Running this code example produces the following result:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码示例会产生以下结果：
- en: '[PRE9]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'String equality can be tested using Python''s `==` operator, which is simply
    two equal signs placed together. Don''t confuse the equality operator with the
    assignment operator, which is a single equal to sign. The equality operator tests
    two variables for equality, while the assignment operator assigns a value to a
    variable:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 Python 的 `==` 操作符测试字符串的相等性，它只是两个等号放在一起。不要将相等操作符与赋值操作符混淆，赋值操作符是一个单独的等号。相等操作符测试两个变量是否相等，而赋值操作符将值赋给变量：
- en: '[PRE10]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Running this code example produces the following result:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码示例会产生以下结果：
- en: '[PRE11]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Strings can be tested for containment using the `in` operator, which returns
    `True` if the first operand is contained in the second.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串可以使用 `in` 操作符进行包含性测试，如果第一个操作数包含在第二个操作数中，则返回 `True`。
- en: '[PRE12]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: I briefly mentioned that strings are an ordered collection of characters. What
    does this mean? It simply means that we can access individual characters or a
    series of characters from the string. In Python, this is referred to as **indexing**
    in the case of accessing an individual character, and **slicing** in the case
    of accessing a series of characters.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我简要地提到字符串是一个字符的有序集合。这意味着什么？这仅仅意味着我们可以从字符串中访问单个字符或一系列字符。在 Python 中，访问单个字符被称为
    **索引**，访问一系列字符被称为 **切片**。
- en: 'Characters in a string are obtained by providing the numeric offset contained
    within square brackets after a string. For example, you could obtain the first
    string character in the `fc` variable by using the syntax `fc[0]`. Negative offsets
    can be used to search backwards from the end of a string. In this case, the last
    character in a string is stored at index `-1`. Indexing always creates a new variable
    to hold the character:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在字符串后提供方括号内的数字偏移量，可以获取字符串中的字符。例如，你可以使用语法 `fc[0]` 获取 `fc` 变量的第一个字符串字符。可以使用负偏移量从字符串的末尾向前搜索。在这种情况下，字符串中的最后一个字符存储在索引
    `-1` 处。索引始终创建一个新的变量来保存字符：
- en: '[PRE13]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The following image illustrates how strings are an ordered collection of characters
    with the first character occupying position **0**, the second character occupying
    position **1**, and each successive character occupying the next index number:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像说明了字符串是如何成为一个字符的有序集合，第一个字符占据位置 **0**，第二个字符占据位置 **1**，每个后续字符占据下一个索引号：
- en: '![String manipulation](img/4445_01_6.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![字符串操作](img/4445_01_6.jpg)'
- en: While string indexing allows you to obtain a single character from a string
    variable, string slicing enables you to extract a contiguous sequence of strings.
    The format and syntax is similar to indexing, but with the addition of a second
    offset, which is used to tell Python how many characters to return.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然字符串索引允许你从一个字符串变量中获取单个字符，但字符串切片允许你提取一个连续的字符串序列。其格式和语法与索引类似，但增加了第二个偏移量，用于告诉
    Python 返回多少个字符。
- en: 'The following code example provides an example of string slicing. The `theString`
    variable has been assigned a value of `Floodplain.shp`. To obtain a sliced variable
    with the contents of `Flood`, you would use the `theString[0:5]` syntax:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例提供了一个字符串切片的例子。`theString` 变量已被分配值为 `Floodplain.shp`。要获取包含 `Flood` 内容的切片变量，你会使用
    `theString[0:5]` 语法：
- en: '[PRE14]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Python slicing returns the characters beginning with the first offset up to,
    but not including, the second offset. This can be particularly confusing for new
    Python programmers and is a common source of error. In our example, the returned
    variable will contain the characters `Flood`. The first character, which occupies
    position `0`, is `F`. The last character returned is index `4`, which corresponds
    to the character `d`. Notice that index number `5` is not included since Python
    slicing only returns characters up to but not including the second offset.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Python切片返回从第一个偏移量开始的字符，但不包括第二个偏移量。这对新Python程序员来说可能特别令人困惑，并且是错误的一个常见来源。在我们的例子中，返回的变量将包含字符`Flood`。第一个字符，占据位置`0`，是`F`。返回的最后一个字符是索引`4`，对应字符`d`。请注意，索引号`5`不包括在内，因为Python切片只返回到但不包括第二个偏移量的字符。
- en: Either of the offsets can be left off. This in effect creates a wild card. In
    the case of `theString[1:]`, you are telling Python to return all characters starting
    from the second character to the end of the string. In the second case, `theString[:-1]`,
    you are telling Python to start at character zero and return all characters except
    the last.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 可以省略任一偏移量。这实际上创建了一个通配符。在`theString[1:]`的情况下，你是在告诉Python返回从第二个字符到字符串末尾的所有字符。在第二种情况下，`theString[:-1]`，你是在告诉Python从字符零开始，返回除了最后一个字符之外的所有字符。
- en: 'Python is an excellent language for manipulating strings and there are many
    additional functions that you can use to process this type of data. Most of these
    are beyond the scope of this text, but in general all of the following string
    manipulation functions are available:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Python是处理字符串的出色语言，你可以使用许多其他函数来处理这类数据。大多数这些函数超出了本文的范围，但一般来说，以下所有字符串操作函数都是可用的：
- en: String length
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串长度
- en: Casing functions for conversion to upper and lower case
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大小写转换函数
- en: Removal of leading and trailing whitespace
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移除前导和尾随空格
- en: Finding a character within a string
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在字符串中查找字符
- en: Replacement of text
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本替换
- en: Splitting into a list of words based on a delimiter
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据分隔符拆分到单词列表
- en: Formatting
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 格式化
- en: Numbers
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数字
- en: Python also has built-in support for numeric data including `int`, `long`, `float`,
    and `complex` values. Numbers are assigned to variables in much the same way as
    strings, with the exception that you do not enclose the value in quotes and obviously
    it must be a numeric value.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Python还内置了对数值数据（包括`int`、`long`、`float`和`complex`值）的支持。数字的分配方式与字符串类似，只是不需要在值周围加上引号，并且显然它必须是一个数值。
- en: Python supports all the commonly used numeric operators including addition,
    subtraction, multiplication, division, and modulus or remainder. In addition,
    functions for returning the absolute value, conversion of strings to numeric datatypes,
    and rounding are also available.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Python支持所有常用的数值运算符，包括加法、减法、乘法、除法和取模或余数。此外，还有返回绝对值、将字符串转换为数值数据类型和四舍五入的函数。
- en: 'Although Python provides a few built-in mathematical functions, the `math`
    module can be used to access a wide variety of more advanced `math` functions.
    To use these functions, you must specifically import the `math` module as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Python提供了一些内置的数学函数，但可以使用`math`模块来访问更多高级的数学函数。要使用这些函数，你必须具体导入`math`模块，如下所示：
- en: '[PRE15]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Functions provided by the `math` module include those for returning the ceiling
    and floor of a number, the absolute value, trigonometric functions, logarithmic
    functions, angular conversion, and hyperbolic functions.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`math`模块提供的函数包括返回数字的上限和下限、绝对值、三角函数、对数函数、角度转换和双曲函数。'
- en: Lists
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 列表
- en: A third built-in datatype provided by Python is the `list`. A list is an ordered
    collection of objects that can hold any type of data supported by Python as well
    as being able to hold multiple datatypes at the same time. This could be numbers,
    strings, other lists, dictionaries, or objects. So, for instance, a list variable
    could hold numeric and string data at the same time. Lists are zero-based, with
    the first element in the list occupying position `0`. Each successive object in
    the list is incremented by one. In addition, lists have the special capability
    of dynamically growing and shrinking.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Python提供的第三个内置数据类型是`list`。列表是有序的对象集合，可以存储Python支持的所有类型的数据，同时还能同时存储多种数据类型。这可以是数字、字符串、其他列表、字典或对象。例如，一个列表变量可以同时存储数字和字符串数据。列表是零基的，列表中的第一个元素占据位置`0`。列表中的每个后续对象递增一个。此外，列表具有动态增长和缩小的特殊能力。
- en: Lists are created by assigning a series of values enclosed by brackets. To pull
    a value from a list, simply use an integer value in brackets along with the variable
    name. The following code example provides an illustration of this. You can also
    use slicing with lists to return multiple values. **Slicing** a list always returns
    a new list variable.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 列表是通过将一系列括号内的值赋值来创建的。要从列表中提取一个值，只需在变量名旁边使用括号内的整数值即可。下面的代码示例说明了这一点。您还可以使用列表的切片功能来返回多个值。**切片**列表始终返回一个新的列表变量。
- en: '[PRE16]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Lists are dynamic in nature, enabling them to grow, shrink, and change contents.
    This is all done without the need to create a new copy of the list. Changing values
    in a list can be accomplished either through indexing or slicing. Indexing allows
    you to change a single value, while slicing allows you to change multiple list
    items.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 列表本质上是动态的，这使得它们可以增长、缩小和更改内容，而无需创建列表的新副本。可以通过索引或切片来更改列表中的值。索引允许您更改单个值，而切片允许您更改多个列表项。
- en: Lists have a number of methods that allow you to manipulate the values that
    are part of the list. You can sort the contents of the list in either an ascending
    or descending order through the use of the `sort()` method. Items can be added
    to a list with the `append()` method, which adds an object to the end of the list,
    and with the `insert()` method which inserts an object at a position within the
    list. Items can be removed from a list with the `remove()` method which removes
    the first occurrence of a value from the list, or `the pop()` method which removes
    and returns the object last added to the list. The contents of the list can also
    be reversed with the `reverse()` method.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 列表有许多方法允许您操作列表中的值。您可以通过使用`sort()`方法按升序或降序对列表的内容进行排序。可以使用`append()`方法向列表中添加项，该方法将对象添加到列表的末尾，以及使用`insert()`方法在列表中的某个位置插入对象。可以使用`remove()`方法从列表中删除项，该方法从列表中删除第一个出现的值，或者使用`pop()`方法删除并返回最后添加到列表中的对象。还可以使用`reverse()`方法反转列表的内容。
- en: Tuples
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 元组
- en: 'Tuples are similar to lists but with some important differences. Just like
    lists, tuples contain a sequence of values. The only difference is that tuples
    can''t be changed, and they are referred to with parentheses instead of square
    brackets. Creating a tuple is as simple as placing a number of comma-separated
    values inside parentheses, as shown in the following code example:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 元组与列表类似，但有一些重要的区别。就像列表一样，元组包含一系列值。唯一的区别是元组不能被修改，并且它们用圆括号而不是方括号来引用。创建一个元组就像在圆括号内放置一系列以逗号分隔的值一样简单，如下面的代码示例所示：
- en: '[PRE17]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Like lists, tuple indices start with an index value of `0`. Access to values
    stored in a tuple occurs in the same way as lists. This is illustrated in the
    following code example:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 与列表一样，元组的索引从`0`开始。访问存储在元组中的值的方式与列表相同。以下代码示例说明了这一点：
- en: '[PRE18]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Tuples are typically used in place of a list when it is important for the contents
    of the structure to be static. You can't insure this with a list, but you can
    with a tuple.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当结构的内容需要是静态的时候，通常使用元组来代替列表。您不能通过列表来确保这一点，但可以通过元组来确保。
- en: Dictionaries
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字典
- en: 'Dictionaries are a second type of collection object in Python. They are similar
    to lists, except that dictionaries are an unordered collection of objects. Instead
    of fetching objects from the collection through the use of an offset, items in
    a dictionary are stored and fetched by a key. Each key in a dictionary has an
    associated value. Similar to lists, dictionaries can grow and shrink in place
    through the use of methods on the `dictionary` class. In the following code example,
    you will learn to create and populate a dictionary and see how values can be accessed
    through the use of a key. Dictionaries are created with the use of curly braces.
    Inside these braces each key is surrounded by quotes followed by a colon and then
    a value that is associated with the key. These key/value pairs are separated by
    commas:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 字典是 Python 中的第二种集合对象。它们与列表类似，但字典是一个无序的对象集合。与通过偏移量从集合中获取对象不同，字典中的项是通过键来存储和检索的。字典中的每个键都有一个关联的值。与列表类似，字典可以通过
    `dictionary` 类的方法在原地增长和缩小。在下面的代码示例中，你将学习如何创建和填充字典，并了解如何通过键访问值。字典是通过使用花括号创建的。在这些括号内，每个键都由引号包围，后跟一个冒号，然后是与键关联的值。这些键/值对由逗号分隔：
- en: '[PRE19]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Basic dictionary operations include getting the number of items in a dictionary,
    getting a value using the key, determining if a key exists, converting the keys
    to a list, and getting a list of values. Dictionary objects can be changed, expanded,
    and shrunk in place. What this means is that Python does not have to create a
    new `dictionary` object to hold the altered version of the dictionary. Assigning
    values to a dictionary key is accomplished by stating the key value in brackets
    and setting it equal to some value.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 基本字典操作包括获取字典中的项目数量、使用键获取值、确定键是否存在、将键转换为列表以及获取值列表。字典对象可以在原地更改、扩展和缩小。这意味着 Python
    不需要创建一个新的 `dictionary` 对象来保存字典的更改版本。向字典键赋值是通过在方括号中声明键值并将其设置为某个值来完成的。
- en: Tip
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Unlike lists, dictionaries can't be sliced due to the fact that their contents
    are unordered. Should you have the need to iterate over all values in a dictionary,
    simply use the `keys()` method, which returns a collection of all the keys in
    the dictionary and which can then be used individually to set or get the value.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 与列表不同，由于它们的元素是无序的，字典不能被切片。如果你需要遍历字典中的所有值，只需使用 `keys()` 方法，该方法返回字典中所有键的集合，然后可以单独使用这些键来设置或获取值。
- en: Classes and objects
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类和对象
- en: Classes and objects are a fundamental concept in object-oriented programming.
    While Python is more of a procedural language, it also supports object-oriented
    programming. In object-oriented programming, classes are used to create object
    instances. You can think of classes as blueprints for the creation of one or more
    objects. Each object instance has the same properties and methods, but the data
    contained in an object can and usually will differ. Objects are complex datatypes
    in Python composed of properties and methods, and can be assigned to variables
    just like any other datatype. Properties contain data associated with an object,
    while methods are actions that an object can perform.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 类和对象是面向对象编程中的基本概念。虽然 Python 更偏向于过程式语言，但它也支持面向对象编程。在面向对象编程中，类用于创建对象实例。你可以将类视为创建一个或多个对象的蓝图。每个对象实例都有相同的属性和方法，但对象中包含的数据可以并且通常会有所不同。对象是
    Python 中的复杂数据类型，由属性和方法组成，可以像任何其他数据类型一样分配给变量。属性包含与对象关联的数据，而方法则是对象可以执行的操作。
- en: 'These concepts are best illustrated with an example. In ArcPy, the `Extent`
    class is a rectangle specified by providing the coordinate of the lower-left corner
    and the coordinate of the upper-right corner in map units. The `Extent` class
    contains a number of properties and methods. Properties include `XMin`, `XMax`,
    `YMin`, and `YMax`, `spatialReference`, and others. The minimum and maximum of
    x and y properties provide the coordinates for the extent rectangle. The `spatialReference`
    property holds a reference to a `SpatialReference` object for the `Extent`. Object
    instances of the `Extent` class can be used both to set and get the values of
    these properties through dot notation. An example of this is seen in the following
    code example:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这些概念最好通过一个例子来解释。在 ArcPy 中，`Extent` 类是一个通过提供地图单位中左下角和右上角的坐标来指定的矩形。`Extent` 类包含许多属性和方法。属性包括
    `XMin`、`XMax`、`YMin` 和 `YMax`、`spatialReference` 以及其他属性。x 和 y 属性的最小值和最大值提供了范围矩形的坐标。`spatialReference`
    属性持有 `SpatialReference` 对象的引用，用于 `Extent`。`Extent` 类的对象实例可以通过点表示法来设置和获取这些属性的值。以下代码示例展示了这一点：
- en: '[PRE20]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Running this script yields the following output:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此脚本会产生以下输出：
- en: '[PRE21]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `Extent` class also has a number of methods, which are actions that an object
    can perform. In the case of this particular object, most of the methods are related
    to performing some sort of geometric test between the `Extent` object and another
    geometry. Examples include `contains()`, `crosses()`, `disjoint()`, `equals()`,
    `overlaps()`, `touches()`,and `within()`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`Extent` 类也有许多方法，这些是对象可以执行的操作。对于这个特定的对象，大多数方法都与在 `Extent` 对象和另一个几何体之间执行某种几何测试相关。例如包括
    `contains()`、`crosses()`、`disjoint()`、`equals()`、`overlaps()`、`touches()` 和 `within()`。'
- en: One additional object-oriented concept that you need to understand is dot notation.
    **Dot notation** provides a way of accessing the properties and methods of an
    object. It is used to indicate that a property or method belongs to a particular
    class.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要理解的一个额外的面向对象的概念是点表示法。**点表示法**提供了一种访问对象属性和方法的方式。它用于表示一个属性或方法属于特定的类。
- en: 'The syntax for using the dot notation includes an object instance followed
    by a dot and then the property or method. The syntax is the same regardless of
    whether you''re accessing a property or a method. A parenthesis, and zero or more
    parameters, at the end of the word following the dot indicates that a method is
    being accessed. Here are a couple of examples to better illustrate this concept:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 使用点表示法的语法包括一个对象实例，后面跟着一个点，然后是属性或方法。语法在访问属性或方法时都是相同的。在点后面的单词末尾的括号和零个或多个参数表示正在访问一个方法。以下是一些示例，以更好地说明这个概念：
- en: '[PRE22]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Statements
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 语句
- en: 'Each line of code that you write with Python is known as a **statement**. There
    are many different kinds of statements, including those that create and assign
    data to variables, decision support statements that branch your code based on
    a test, looping statements that execute a code block multiple times, and others.
    There are various rules that your code will need to follow as you create the statements
    that are part of your script. You''ve already encountered one type of statement:
    variable creation and assignment.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 你用 Python 编写的每一行代码都被称为一个**语句**。有各种不同的语句类型，包括那些创建和分配数据到变量的语句，基于测试分支代码的决策支持语句，执行代码块多次的循环语句，以及其他语句。当你创建脚本中的语句时，你的代码需要遵循各种规则。你已经遇到过一种类型的语句：变量创建和赋值。
- en: Decision support statements
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 决策支持语句
- en: 'The `if`/`elif`/`else` statement is the primary decision making statement in
    Python and tests for a true/false condition. Decision statements enable you to
    control the flow of your programs. Here are some example decisions that you can
    make in your code: if the variable holds a point feature class, get the X, Y coordinates;
    if the feature class name equals `Roads` then get the `Name` field.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`/`elif`/`else` 语句是 Python 中的主要决策语句，用于测试真/假条件。决策语句使你能够控制程序的流程。以下是一些你可以在代码中做出的决策示例：如果变量持有点要素类，获取
    X、Y 坐标；如果要素类名称等于 `Roads`，则获取 `Name` 字段。'
- en: Decision statements such as `if`/`elif`/`else` test for a true/false condition.
    In Python, a "true" value means any nonzero number or nonempty object. A "false"
    value indicates "not true" and is represented in Python with a zero number or
    empty object. Comparison tests return values of one or zero (true or false). Boolean
    and/or operators return a true or false operand value.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 决策语句，如 `if`/`elif`/`else`，用于测试真假条件。在 Python 中，“真”值表示任何非零数字或非空对象。假值表示“非真”，在 Python
    中用零数字或空对象表示。比较测试返回一个或零（真或假）的值。布尔和/或运算符返回真或假的操作数值。
- en: '[PRE23]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Python code must follow certain syntax rules. Statements execute one after
    another, until your code branches. Branching typically occurs through the use
    of `if`/`elif`/`else`. In addition, the use of looping structures, such as `for`
    and `while`, can alter the statement flow. Python automatically detects statement
    and block boundaries, so there is no need for braces or delimiters around your
    blocks of code. Instead, indentation is used to group statements in a block. Many
    languages terminate statements with the use of a semicolon, but Python simply
    uses the end of line character to mark the end of a statement. Compound statements
    include a "`:`" character. Compound statements follow the pattern: header terminated
    by a colon. Blocks of code are then written as individual statements and are indented
    underneath the header.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: Python 代码必须遵循某些语法规则。语句一个接一个地执行，直到你的代码分支。分支通常通过使用 `if`/`elif`/`else` 来实现。此外，使用循环结构，如
    `for` 和 `while`，可以改变语句流程。Python 自动检测语句和块边界，因此不需要在代码块周围使用大括号或分隔符。相反，缩进用于在块中分组语句。许多语言使用分号来终止语句，但
    Python 只使用行结束字符来标记语句的结束。复合语句包括一个 "`:`" 字符。复合语句遵循以下模式：以冒号结尾的标题。然后，代码块作为单个语句编写，并缩进在标题之下。
- en: Statement indentation deserves a special mention as it is critical to the way
    Python interprets code. As I mentioned, a contiguous section of code is detected
    by Python through the use of indentation. By default, all Python statements should
    be left-justified until looping, decision support, `try`/`except`, and `with`
    statements are used. This includes `for` and `while` loops, `if`/`else` statements,
    `try`/`except` statements, and `with` statements. All statements indented with
    the same distance belong to the same block of code until that block is ended by
    a line less indented.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 语句缩进值得特别提一下，因为它对 Python 解释代码的方式至关重要。正如我提到的，Python 通过缩进来检测连续的代码段。默认情况下，所有 Python
    语句都应该左对齐，直到使用循环、决策支持、`try`/`except` 和 `with` 语句。这包括 `for` 和 `while` 循环、`if`/`else`
    语句、`try`/`except` 语句和 `with` 语句。所有以相同距离缩进的语句都属于同一代码块，直到该块通过缩进较少的行结束。
- en: Looping statements
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 循环语句
- en: 'Looping statements allow your program to repeat lines of code over and over
    as necessary. `while` loops repeatedly execute a block of statements as long as
    the test at the top of the loop evaluates to true. When the condition test evaluates
    to false, Python begins interpreting code immediately after the `while` loop.
    In the next code example, a value of `10` has been assigned to the variable `x`.
    The test for the `while` loop then checks to see if `x` is less than `100`. If
    `x` is less than `100` the current value of `x` is printed to the screen and the
    value of `x` is incremented by `10`. Processing then continues with the `while`
    loop test. The second time, the value of `x` will be 20; so the test evaluates
    to true once again. This process continues until `x` is larger than `100`. At
    this time, the test will evaluate to false and processing will stop. It is very
    important that your `while` statements have some way of breaking out of the loop.
    Otherwise, you will wind up in an infinite loop. An infinite loop is a sequence
    of instructions in a computer program that loops endlessly, either due to the
    loop having no terminating condition, having one that can never be met, or one
    that causes the loop to start over:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 循环语句允许你的程序根据需要重复执行代码行。`while` 循环会重复执行循环顶部的测试为真的一块代码。当条件测试评估为假时，Python 会立即开始解释
    `while` 循环之后的代码。在下一个代码示例中，变量 `x` 被赋予了值 `10`。`while` 循环的测试会检查 `x` 是否小于 `100`。如果
    `x` 小于 `100`，则当前 `x` 的值会被打印到屏幕上，并且 `x` 的值会增加 `10`。然后，处理会继续进行 `while` 循环的测试。第二次，`x`
    的值将是 `20`；因此测试再次评估为真。这个过程会一直持续到 `x` 大于 `100`。此时，测试将评估为假，处理将停止。确保你的 `while` 语句有某种跳出循环的方法非常重要。否则，你可能会陷入无限循环。无限循环是计算机程序中的一系列指令，它会无限循环，要么是因为循环没有终止条件，要么是因为有一个永远无法满足的条件，或者是因为它会导致循环重新开始：
- en: '[PRE24]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '`for` loops execute a block of statements a predetermined number of times.
    They come in two varieties—a counted loop for running a block of code a set number
    of times, and a list loop that enables you to loop through all objects in a list.
    The list loop in the following example executes once for each value in the dictionary
    and then stops looping:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`for` 循环执行预定的次数的代码块。它们有两种类型——一个计数循环，用于运行固定次数的代码块，和一个列表循环，它允许你遍历列表中的所有对象。以下示例中的列表循环会为字典中的每个值执行一次，然后停止循环：'
- en: '[PRE25]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: There are times when it will be necessary for you to break out of the execution
    of a loop. The `break` and `continue` statements can be used to do this. `break`
    jumps out of the closest enclosing loop while `continue` jumps back to the top
    of the closest enclosing loop. These statements can appear anywhere inside the
    block of code.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你可能需要从循环的执行中跳出。`break` 和 `continue` 语句可以用来实现这一点。`break` 会跳出最近的封闭循环，而 `continue`
    会跳回到最近的封闭循环的顶部。这些语句可以出现在代码块内部的任何位置。
- en: Try statements
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`try` 语句'
- en: A `try` statement is a complete, compound statement that is used to handle exceptions.
    Exceptions are a high-level control device used primarily for error interception
    or triggering. Exceptions in Python can either be intercepted or triggered. When
    an error condition occurs in your code, Python automatically triggers an exception,
    which may or may not be handled by your code. It is up to you as a programmer
    to catch an automatically triggered exception. Exceptions can also be triggered
    manually by your code. In this case, you would also provide an exception handling
    routine to catch these manually triggered exceptions.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`try` 语句是一个完整的、复合语句，用于处理异常。异常是一种高级控制设备，主要用于错误拦截或触发。Python 中的异常可以被拦截或触发。当你的代码中出现错误条件时，Python
    会自动触发一个异常，这个异常可能或可能不会被你的代码处理。作为程序员，你有责任捕获自动触发的异常。异常也可以通过你的代码手动触发。在这种情况下，你还需要提供一个异常处理程序来捕获这些手动触发的异常。'
- en: 'There are two basic types of try statements: `try`/`except`/`else` and `try`/`finally`.
    The basic `try` statement starts with a `try` header line followed by a block
    of indented statements, then one or more optional except clauses that name exceptions
    to be caught, and an optional `else` clause at the end:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`try` 语句有两种基本类型：`try`/`except`/`else` 和 `try`/`finally`。基本的 `try` 语句从 `try`
    标题行开始，后面跟着一个缩进的语句块，然后是一个或多个可选的 `except` 子句，用于指定要捕获的异常，以及一个可选的 `else` 子句在末尾：'
- en: '[PRE26]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `try`/`except`/`else` statement works as follows. Once inside a `try` statement,
    Python marks the fact that you are in a `try` block and knows that any exception
    condition that occurs at this point will be sent to the various `except` statements
    for handling. If a matching exception is found, the code block inside the `except`
    block is executed. The code then picks up below the full `try` statement. The
    `else` statements are not executed in this case. Each statement inside the `try`
    block is executed. Assuming that no exception conditions occur, the code pointer
    will then jump to the `else` statement and execute the code block contained by
    the `else` statement before moving to the next line of code below the try block.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`try`/`except`/`else` 语句的工作原理如下。一旦进入 `try` 语句，Python 会标记你处于 `try` 块中，并且知道在此点发生的任何异常条件都将被发送到各种
    `except` 语句进行处理。如果找到匹配的异常，则执行 `except` 块内的代码块。然后代码从 `try` 语句的下方继续执行。在这种情况下不会执行
    `else` 语句。`try` 块内的每个语句都会被执行。假设没有发生异常条件，代码指针将跳转到 `else` 语句并执行 `else` 语句包含的代码块，然后再移动到
    try 块下方的下一行代码。'
- en: The other type of `try` statement is the `try`/`finally` statement which allows
    for finalization actions. When a `finally` clause is used in a `try` statement,
    its block of statements always run at the very end, whether an error condition
    occurs or not.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种 `try` 语句类型是 `try`/`finally` 语句，它允许执行最终化操作。当在 `try` 语句中使用 `finally` 子句时，其语句块总是在最后运行，无论是否发生错误条件。
- en: 'The `try`/`finally` statement works as follows. If an exception occurs, Python
    runs the `try` block, then the `finally` block, and then execution continues past
    the entire `try` statement. If an exception does not occur during execution, Python
    runs the `try` block, then the `finally` block. This is useful when you want to
    make sure an action happens after a code block runs, regardless of whether an
    error condition occurs. Cleanup operations, such as closing a file or a connection
    to a database are commonly placed inside a `finally` block to ensure that they
    are executed regardless of whether an exception occurs in your code:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`try`/`finally` 语句的工作原理如下。如果发生异常，Python 会运行 `try` 块，然后是 `finally` 块，之后继续执行
    `try` 语句之后的代码。如果在执行过程中没有发生异常，Python 会运行 `try` 块，然后是 `finally` 块。这在你想确保代码块运行后某个动作发生，无论是否发生错误条件时非常有用。清理操作，例如关闭文件或数据库连接，通常放置在
    `finally` 块中，以确保无论代码中是否发生异常都会执行：'
- en: '[PRE27]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: with statements
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`with` 语句'
- en: The `with` statement is handy when you have two related operations that need
    to be executed as a pair with a block of code in between. A common scenario for
    using `with` statements is opening, reading, and closing a file. Opening and closing
    a file are the related operations, and reading a file and doing something with
    the contents is the block of code in between. When writing geoprocessing scripts
    with ArcGIS, the new `cursor` objects introduced with version 10.1 of ArcGIS are
    ideal for using `with` statements. We'll discuss `cursor` objects in great detail
    in a later chapter, but I'll briefly describe these objects now. Cursors are an
    in-memory copy of records from the attribute table of a feature class or table.
    There are various types of cursors. Insert cursors allow you to insert new records,
    search cursors are a read-only copy of records, and update cursors allow you to
    edit or delete records. Cursor objects are opened, processed in some way, and
    closed automatically using a `with` statement.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`with` 语句在有两个相关操作需要作为一个对执行，并且中间有一个代码块时非常有用。使用 `with` 语句的常见场景是打开、读取和关闭文件。打开和关闭文件是相关操作，而读取文件和对其内容进行处理是中间的代码块。在编写使用
    ArcGIS 的地理处理脚本时，ArcGIS 10.1 版本引入的新 `cursor` 对象非常适合使用 `with` 语句。我们将在后面的章节中详细讨论
    `cursor` 对象，但现在我会简要描述这些对象。游标是特征类或表属性表的记录的内存副本。游标有多种类型。插入游标允许你插入新记录，搜索游标是记录的只读副本，而更新游标允许你编辑或删除记录。使用
    `with` 语句自动打开、以某种方式处理并关闭游标对象。'
- en: 'The closure of a file or cursor object is handled automatically by the `with`
    statement resulting in cleaner, more efficient coding. It''s basically like using
    a `try`/`finally` block but with fewer lines of code. In the following code example,
    the `with` block is used to create a new search cursor, read information from
    the cursor, and implicitly close the cursor:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 文件或游标对象的关闭由`with`语句自动处理，从而实现更干净、更高效的编码。这基本上就像使用`try`/`finally`块，但代码行数更少。在以下代码示例中，`with`块用于创建一个新的搜索游标，从游标中读取信息，并隐式关闭游标：
- en: '[PRE28]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: File I/O
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件输入/输出
- en: You will often find it necessary to retrieve or write information to files on
    your computer. Python has a built-in object type that provides a way to access
    files for many tasks. We're only going to cover a small subset of the file manipulation
    functionality provided, but we'll touch on the most commonly used functions including
    opening and closing files, and reading and writing data to a file.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 你经常会发现需要从你的电脑上的文件中检索或写入信息。Python有一个内置的对象类型，它提供了一种访问文件以执行许多任务的方法。我们只将涵盖文件操作功能的一小部分，但我们将涉及最常用的函数，包括打开和关闭文件，以及将数据读取和写入文件。
- en: 'Python''s `open()` function creates a file object, which serves as a link to
    a file residing on your computer. You must call the `open()` function on a file
    before reading and/or writing data to a file. The first parameter for the `open()`
    function is a path to the file you''d like to open. The second parameter corresponds
    to a mode, which is typically read (`r`), write (`w`), or append (`a`). A value
    of `r` indicates that you''d like to open the file for read only operations, while
    a value of `w` indicates you''d like to open the file for write operations. In
    the event that you open a file that already exists for write operations, this
    will overwrite any data currently in the file, so you must be careful with write
    mode. Append mode (`a`) will open a file for write operations, but instead of
    overwriting any existing data, it will append the new data to the end of the file.
    The following code example shows the use of the `open()` function for opening
    a text file in a read-only mode:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Python的`open()`函数创建一个文件对象，该对象作为链接到你的电脑上存储的文件。在读取和/或写入文件数据之前，你必须对文件调用`open()`函数。`open()`函数的第一个参数是你想要打开的文件的路径。第二个参数对应于一个模式，通常是读取（`r`）、写入（`w`）或追加（`a`）。`r`的值表示你想要以只读方式打开文件，而`w`的值表示你想要以写入方式打开文件。如果你以写入方式打开一个已经存在的文件，这将覆盖文件中当前的所有数据，所以你必须小心使用写入模式。追加模式（`a`）将以写入方式打开文件，但不会覆盖任何现有数据，而是将新数据追加到文件的末尾。以下代码示例显示了使用`open()`函数以只读模式打开文本文件的方法：
- en: '[PRE29]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: After you've completed read/write operations on a file, you should always close
    the file with the `close()` method.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成对一个文件的读写操作后，你应该始终使用`close()`方法关闭文件。
- en: After a file has been opened, data can be read from it in a number of ways and
    using various methods. The most typical scenario would be to read data one line
    at a time from a file through the `readline()` method. `readline()` can be used
    to read the file one line at a time into a string variable. You would need to
    create a looping mechanism in your Python code to read the entire file line by
    line. If you would prefer to read the entire file into a variable, you can use
    the `read()` method, which will read the file up to the **end of file** (**EOF**)
    marker. You can also use the `readlines()` method to read the entire contents
    of a file, separating each line into individual strings, until the EOF is found.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 文件一旦打开，就可以通过多种方式使用各种方法从其中读取数据。最典型的情况是使用`readline()`方法逐行从文件中读取数据。`readline()`可以用来将文件逐行读入一个字符串变量。你需要在Python代码中创建一个循环机制来逐行读取整个文件。如果你希望将整个文件读入一个变量，可以使用`read()`方法，它将读取文件直到文件结束标记（**EOF**）。你也可以使用`readlines()`方法来读取文件的整个内容，将每一行分隔成单独的字符串，直到找到EOF。
- en: 'In the following code example, we have opened a text file called `Wildfires.txt`
    in read-only mode and used the `readlines()` method on the file to read its entire
    contents into a variable called `lstFires`, which is a Python list containing
    each line of the file as a separate string value in the list. In this case, the
    `Wildfire.txt` file is a comma-delimited text file containing the latitude and
    longitude of the fire along with the confidence values for each file. We then
    loop through each line of text in `lstFires` and use the `split()` function to
    extract the values based on a comma as the delimiter, including the latitude,
    longitude, and confidence values. The latitude and longitude values are used to
    create a new `Point` object, which is then inserted into the feature class using
    an insert cursor:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码示例中，我们以只读模式打开了名为 `Wildfires.txt` 的文本文件，并使用文件上的 `readlines()` 方法将其全部内容读取到一个名为
    `lstFires` 的变量中，该变量是一个Python列表，包含文件中的每一行作为一个单独的字符串值。在这种情况下，`Wildfire.txt` 文件是一个以逗号分隔的文本文件，包含火灾的纬度和经度以及每个文件的置信度值。然后我们遍历
    `lstFires` 中的每一行文本，并使用 `split()` 函数根据逗号作为分隔符提取值，包括纬度、经度和置信度值。纬度和经度值用于创建一个新的 `Point`
    对象，然后使用插入游标将其插入到要素类中：
- en: '[PRE30]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Just as is the case with reading files, there are a number of methods that
    you can use to write data to a file. The `write()` function is probably the easiest
    to use and takes a single string argument and writes it to a file. The `writelines()`
    function can be used to write out the contents of a list structure to a file.
    In the following code example, we have created a list structure called `fcList`,
    which contains a list of feature classes. We can write this list to a file using
    the `writelines()` method:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 就像读取文件一样，有几种方法可以将数据写入文件。`write()` 函数可能是最容易使用的，它接受一个字符串参数并将其写入文件。`writelines()`
    函数可以用来将列表结构的内容写入文件。在下面的代码示例中，我们创建了一个名为 `fcList` 的列表结构，其中包含要素类的列表。我们可以使用 `writelines()`
    方法将此列表写入文件：
- en: '[PRE31]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Summary
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered some of the fundamental Python programming concepts
    that you'll need to understand before you can write effective geoprocessing scripts.
    We began the chapter with an overview of the IDLE development environment for
    writing and debugging Python scripts. You learned how to create a new script,
    edit existing scripts, check for syntax errors, and execute the script. We also
    covered the basic language constructs including importing modules, creating and
    assigning variables, if/else statements, looping statements, and the various data-types
    including strings, numbers, Booleans, lists, dictionaries, and objects. You also
    learned how to read and write text files.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了一些基本的Python编程概念，这些概念是在您能够编写有效的地理处理脚本之前需要理解的。我们以对编写和调试Python脚本的开发环境IDLE的概述开始本章。您学习了如何创建新脚本、编辑现有脚本、检查语法错误以及执行脚本。我们还介绍了基本的语言结构，包括导入模块、创建和分配变量、if/else语句、循环语句以及各种数据类型，包括字符串、数字、布尔值、列表、字典和对象。您还学习了如何读取和写入文本文件。
- en: In the next chapter, you will learn the basic techniques for writing geoprocessing
    scripts for ArcGIS with Python. You'll learn how to use the embedded Python window
    in ArcGIS Desktop, import the ArcPy package to your scripts, execute `ArcToolbox`
    tools from your scripts, use the help system when writing scripts, use variables
    to store data, and access the various ArcPy modules.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将学习使用Python编写ArcGIS地理处理脚本的基本技术。您将学习如何使用ArcGIS Desktop中的嵌入式Python窗口，将ArcPy包导入到脚本中，从脚本中执行
    `ArcToolbox` 工具，在编写脚本时使用帮助系统，使用变量来存储数据，以及访问各种ArcPy模块。
