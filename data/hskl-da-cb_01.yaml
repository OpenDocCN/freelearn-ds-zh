- en: Chapter 1. The Hunt for Data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章 数据的猎寻
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下食谱：
- en: Harnessing data from various sources
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用来自不同来源的数据
- en: Accumulating text data from a file path
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从文件路径积累文本数据
- en: Catching I/O code faults
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 捕捉I/O代码故障
- en: Keeping and representing data from a CSV file
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存和表示来自CSV文件的数据
- en: Examining a JSON file with the aeson package
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用aeson包检查JSON文件
- en: Reading an XML file using the HXT package
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用HXT包读取XML文件
- en: Capturing table rows from an HTML page
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 捕获HTML页面中的表格行
- en: Understanding how to perform HTTP GET requests
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解如何执行HTTP GET请求
- en: Learning how to perform HTTP POST requests
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何执行HTTP POST请求
- en: Traversing online directories for data
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遍历在线目录以获取数据
- en: Using MongoDB queries in Haskell
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Haskell中使用MongoDB查询
- en: Reading from a remote MongoDB server
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从远程MongoDB服务器读取数据
- en: Exploring data from a SQLite database
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索来自SQLite数据库的数据
- en: Introduction
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: '![Introduction](img/ch01.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![介绍](img/ch01.jpg)'
- en: Data is everywhere, logging is cheap, and analysis is inevitable. One of the
    most fundamental concepts of this chapter is based on gathering useful data. After
    building a large collection of usable text, which we call the corpus, we must
    learn to represent this content in code. The primary focus will be first on obtaining
    data and later on enumerating ways of representing it.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 数据无处不在，日志记录便宜，分析是不可避免的。本章的一个最基本的概念就是收集有用的数据。在建立了一个大规模的可用文本集合后，我们称之为语料库，我们必须学会在代码中表示这些内容。主要关注将首先是获取数据，随后是列举表示数据的各种方式。
- en: Gathering data is arguably as important as analyzing it to extrapolate results
    and form valid generalizable claims. It is a scientific pursuit; therefore, great
    care must and will be taken to ensure unbiased and representative sampling. We
    recommend following along closely in this chapter because the remainder of the
    book depends on having a source of data to work with. Without data, there isn't
    much to analyze, so we should carefully observe the techniques laid out to build
    our own formidable corpus.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 收集数据在某种程度上与分析数据一样重要，以便推断结果并形成有效的普遍性结论。这是一个科学的追求；因此，必须且将会非常小心地确保采样无偏且具有代表性。我们建议在本章中密切跟随，因为本书的其余部分都依赖于有数据源可供操作。如果没有数据，就几乎没有什么可以分析的，所以我们应该仔细观察在本章中提出的技术，以便构建我们自己的强大语料库。
- en: The first recipe enumerates various sources to start gathering data online.
    The next few recipes deal with using local data of different file formats. We
    then learn how to download data from the Internet using our Haskell code. Finally,
    we finish this chapter with a couple of recipes on using databases in Haskell.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条食谱列举了多种在线收集数据的来源。接下来的几个食谱涉及使用不同文件格式的本地数据。然后我们学习如何使用Haskell代码从互联网上下载数据。最后，我们以几个使用Haskell数据库的食谱结束本章。
- en: Harnessing data from various sources
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用来自不同来源的数据
- en: Information can be described as structured, unstructured, or sometimes a mix
    of the two—semi-structured.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 信息可以被描述为结构化、非结构化，或有时是两者的混合——半结构化。
- en: In a very general sense, structured data is anything that can be parsed by an
    algorithm. Common examples include JSON, CSV, and XML. If given structured data,
    we can design a piece of code to dissect the underlying format and easily produce
    useful results. As mining structured data is a deterministic process, it allows
    us to automate the parsing. This in effect lets us gather more input to feed our
    data analysis algorithms.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 从广义上讲，结构化数据是指任何可以被算法解析的数据。常见的例子包括JSON、CSV和XML。如果提供了结构化数据，我们可以设计一段代码来分析其底层格式，并轻松地生成有用的结果。由于挖掘结构化数据是一个确定性的过程，这使得我们可以自动化解析，从而让我们收集更多的输入来喂养我们的数据分析算法。
- en: Unstructured data is everything else. It is data not defined in a specified
    manner. Written languages such as English are often regarded as unstructured because
    of the difficulty in parsing a data model out of a natural sentence.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 非结构化数据是指其他所有的数据。它是没有按照特定方式定义的数据。像英语这样的书面语言通常被视为非结构化数据，因为从自然句子中解析出数据模型非常困难。
- en: In our search for good data, we will often find a mix of structured and unstructured
    text. This is called semi-structured text.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在寻找好数据的过程中，我们常常会发现结构化和非结构化文本的混合。这就是所谓的半结构化文本。
- en: This recipe will primarily focus on obtaining structured and semi-structured
    data from the following sources.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱将主要关注从以下来源获取结构化和半结构化数据。
- en: Tip
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Unlike most recipes in this book, this recipe does not contain any code. The
    best way to read this book is by skipping around to the recipes that interest
    you.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 与本书中的大多数食谱不同，这个食谱不包含任何代码。阅读本书的最佳方式是跳到那些你感兴趣的食谱。
- en: How to do it...
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现…
- en: We will browse through the links provided in the following sections to build
    up a list of sources to harness interesting data in usable formats. However, this
    list is not at all exhaustive.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过以下章节提供的链接浏览，以建立一个源列表，利用可用格式的有趣数据。然而，这个列表并不详尽。
- en: Some of these sources have an **Application Programming Interface** (**API**)
    that allows more sophisticated access to interesting data. An API specifies the
    interactions and defines how data is communicated.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些数据源提供**应用程序编程接口**（**API**），允许更复杂地访问有趣的数据。API 指定了交互方式并定义了数据如何传输。
- en: News
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 新闻
- en: The New York Times has one of the most polished API documentation to access
    anything from real-estate data to article search results. This documentation can
    be found at [http://developer.nytimes.com](http://developer.nytimes.com).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 《纽约时报》拥有最精炼的 API 文档之一，能够访问从房地产数据到文章搜索结果的各种内容。该文档可以在[http://developer.nytimes.com](http://developer.nytimes.com)找到。
- en: The Guardian also supports a massive datastore with over a million articles
    at [http://www.theguardian.com/data](http://www.theguardian.com/data).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 《卫报》还提供了一个包含超过一百万篇文章的大型数据存储库，网址为[http://www.theguardian.com/data](http://www.theguardian.com/data)。
- en: USA TODAY provides some interesting resources on books, movies, and music reviews.
    The technical documentation can be found at [http://developer.usatoday.com](http://developer.usatoday.com).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 《今日美国》提供有关书籍、电影和音乐评论的一些有趣资源。技术文档可以在[http://developer.usatoday.com](http://developer.usatoday.com)找到。
- en: The BBC features some interesting API endpoints including information on BBC
    programs, and music located at [http://www.bbc.co.uk/developer/technology/apis.html](http://www.bbc.co.uk/developer/technology/apis.html).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: BBC 提供一些有趣的 API 端点，包括 BBC 节目和音乐信息，网址为[http://www.bbc.co.uk/developer/technology/apis.html](http://www.bbc.co.uk/developer/technology/apis.html)。
- en: Private
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 私人
- en: Facebook, Twitter, Instagram, Foursquare, Tumblr, SoundCloud, Meetup, and many
    other social networking sites support APIs to access some degree of social information.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Facebook、Twitter、Instagram、Foursquare、Tumblr、SoundCloud、Meetup 等许多社交网络网站支持 API
    来访问一定程度的社交信息。
- en: For specific APIs such as weather or sports, Mashape is a centralized search
    engine to narrow down the search to some lesser-known sources. Mashape is located
    at [https://www.mashape.com/](https://www.mashape.com/)
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 对于特定的 API，如天气或体育，Mashape 是一个集中式搜索引擎，可以缩小搜索范围到一些较不为人知的来源。Mashape 的网址是[https://www.mashape.com/](https://www.mashape.com/)
- en: Most data sources can be visualized using the Google Public Data search located
    at [http://www.google.com/publicdata](http://www.google.com/publicdata).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数数据源可以通过位于[http://www.google.com/publicdata](http://www.google.com/publicdata)的
    Google 公共数据搜索进行可视化。
- en: For a list of all countries with names in various data formats, refer to the
    repository located at [https://github.com/umpirsky/country-list](https://github.com/umpirsky/country-list).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看包含各种数据格式的所有国家列表，请参考位于[https://github.com/umpirsky/country-list](https://github.com/umpirsky/country-list)的代码库。
- en: Academic
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 学术
- en: Some data sources are hosted openly by universities around the world for research
    purposes.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 一些数据源由世界各地的大学公开托管，用于研究目的。
- en: To analyze health care data, the University of Washington has published Institute
    for Health Metrics and Evaluation (IHME) to collect rigorous and comparable measurement
    of the world's most important health problems. Navigate to [http://www.healthdata.org](http://www.healthdata.org)
    for more information.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了分析医疗数据，华盛顿大学已发布健康指标与评估研究所（IHME），以收集世界上最重要的健康问题的严格且可比较的测量数据。更多信息请访问[http://www.healthdata.org](http://www.healthdata.org)。
- en: The MNIST database of handwritten digits from NYU, Google Labs, and Microsoft
    Research is a training set of normalized and centered samples for handwritten
    digits. Download the data from [http://yann.lecun.com/exdb/mnist](http://yann.lecun.com/exdb/mnist).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 来自纽约大学、谷歌实验室和微软研究院的 MNIST 手写数字数据库，是一个用于手写数字的标准化和居中样本的训练集。可以从[http://yann.lecun.com/exdb/mnist](http://yann.lecun.com/exdb/mnist)下载数据。
- en: Nonprofits
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 非营利组织
- en: Human Development Reports publishes annual updates ranging from international
    data about adult literacy to the number of people owning personal computers. It
    describes itself as having a variety of public international sources and represents
    the most current statistics available for those indicators. More information is
    available at [http://hdr.undp.org/en/statistics](http://hdr.undp.org/en/statistics).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 《人类发展报告》每年更新，涵盖从成人识字率到拥有个人电脑人数的国际数据。它自称拥有多种国际公共资源，并代表了这些指标的最新统计数据。更多信息请访问[http://hdr.undp.org/en/statistics](http://hdr.undp.org/en/statistics)。
- en: The World Bank is the source for poverty and world development data. It regards
    itself as a free source that enables open access to data about development in
    countries around the globe. Find more information at [http://data.worldbank.org/](http://data.worldbank.org/).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 世界银行是贫困和全球发展数据的来源。它自认为是一个自由来源，旨在提供全球各国发展的开放数据访问。更多信息请访问[http://data.worldbank.org/](http://data.worldbank.org/)。
- en: The World Health Organization provides data and analyses for monitoring the
    global health situation. See more information at [http://www.who.int/research/en](http://www.who.int/research/en).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 世界卫生组织提供全球健康状况监测的数据和分析。更多信息请访问[http://www.who.int/research/en](http://www.who.int/research/en)。
- en: 'UNICEF also releases interesting statistics, as the quote from their website
    suggests:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 联合国儿童基金会（UNICEF）还发布了有趣的统计数据，正如其网站上的引用所示：
- en: '*"The UNICEF database contains statistical tables for child mortality, diseases,
    water sanitation, and more vitals. UNICEF claims to play a central role in monitoring
    the situation of children and women—assisting countries in collecting and analyzing
    data, helping them develop methodologies and indicators, maintaining global databases,
    disseminating and publishing data. Find the resources at [http://www.unicef.org/statistics](http://www.unicef.org/statistics)."*'
  id: totrans-50
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*“联合国儿童基金会数据库包含儿童死亡率、疾病、水卫生等方面的统计表。联合国儿童基金会声称在监测儿童和妇女状况方面发挥着核心作用——帮助各国收集和分析数据，协助他们制定方法论和指标，维护全球数据库，传播和发布数据。可以在[http://www.unicef.org/statistics](http://www.unicef.org/statistics)找到相关资源。”*'
- en: The United Nations hosts interesting publicly available political statistics
    at [http://www.un.org/en/databases](http://www.un.org/en/databases).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 联合国在[http://www.un.org/en/databases](http://www.un.org/en/databases)发布有趣的公开政治统计数据。
- en: The United States government
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 美国政府
- en: If we crave the urge to discover patterns in the United States (U.S.) government
    like Nicholas Cage did in the feature film National Treasure (2004), then [http://www.data.gov/](http://www.data.gov/)
    is our go-to source. It's the U.S. government's active effort to provide useful
    data. It is described as a place to increase "public access to high-value, machine-readable
    datasets generated by the executive branch of the Federal Government". Find more
    information at [http://www.data.gov](http://www.data.gov).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们像尼古拉斯·凯奇在电影《国家宝藏》（2004年）中所做的那样，渴望发现美国政府中的模式，那么[http://www.data.gov/](http://www.data.gov/)将是我们的首选来源。它是美国政府积极提供有用数据的努力，旨在“增加公众对联邦政府执行部门生成的高价值、机器可读数据集的访问。”更多信息请访问[http://www.data.gov](http://www.data.gov)。
- en: The United States Census Bureau releases population counts, housing statistics,
    area measurements, and more. These can be found at [http://www.census.gov](http://www.census.gov).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 美国人口普查局发布人口统计、住房统计、区域测量等数据。这些数据可以在[http://www.census.gov](http://www.census.gov)找到。
- en: Accumulating text data from a file path
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从文件路径累积文本数据
- en: One of the easiest ways to get started with processing input is by reading raw
    text from a local file. In this recipe, we will be extracting all the text from
    a specific file path. Furthermore, to do something interesting with the data,
    we will count the number of words per line.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 开始处理输入的最简单方法之一是从本地文件读取原始文本。在这个例子中，我们将从特定的文件路径提取所有文本。此外，为了对数据做些有趣的事情，我们将统计每行的单词数。
- en: Tip
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Haskell is a purely functional programming language, right? Sure, but obtaining
    input from outside the code introduces impurity. For elegance and reusability,
    we must carefully separate pure from impure code.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Haskell是一种纯粹的函数式编程语言，对吗？没错，但从代码外部获取输入会引入不纯净性。为了优雅性和可重用性，我们必须仔细区分纯净代码和不纯净代码。
- en: Getting ready
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备开始
- en: 'We will first create an `input.txt` text file with a couple of lines of text
    to be read by the program. We keep this file in an easy-to-access directory because
    it will be referenced later. For example, the text file we''re dealing with contains
    a seven-line quote by Plato. Here''s what our terminal prints when we issue the
    following command:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个`input.txt`文本文件，文件中有几行文本供程序读取。我们将此文件保存在一个容易访问的目录中，因为稍后会用到。比如，我们正在处理的文本文件包含了一段柏拉图的七行引用。以下是我们执行以下命令时终端的输出：
- en: '[PRE0]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Tip
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Downloading the example code**'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you. The code will also be
    hosted on GitHub at [https://github.com/BinRoot/Haskell-Data-Analysis-Cookbook](https://github.com/BinRoot/Haskell-Data-Analysis-Cookbook).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从你的账户中下载所有购买的 Packt 书籍的示例代码文件，网址是[http://www.packtpub.com](http://www.packtpub.com)。如果你是在其他地方购买了本书，你可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)并注册以便直接将文件通过电子邮件发送给你。代码也将托管在
    GitHub 上，网址是[https://github.com/BinRoot/Haskell-Data-Analysis-Cookbook](https://github.com/BinRoot/Haskell-Data-Analysis-Cookbook)。
- en: How to do it...
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Create a new file to start coding. We call our file Main.hs.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新文件开始编写代码。我们将文件命名为Main.hs。
- en: 'As with all executable Haskell programs, start by defining and implementing
    the `main` function, as follows:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与所有可执行的 Haskell 程序一样，首先定义并实现`main`函数，如下所示：
- en: '[PRE1]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Use Haskell''s `readFile :: FilePath -> IO String` function to extract data
    from an `input.txt` file path. Note that a file path is just a synonym for `String`.
    With the string in memory, pass it into a `countWords` function to count the number
    of words in each line, as shown in the following steps:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '使用 Haskell 的`readFile :: FilePath -> IO String`函数来从`input.txt`文件路径中提取数据。请注意，文件路径实际上只是`String`的同义词。将字符串加载到内存后，将其传递给`countWords`函数，以便计算每行的单词数，如下所示：'
- en: '[PRE2]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Lastly, define our pure function, `countWords`, as follows:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，定义我们的纯函数`countWords`，如下所示：
- en: '[PRE3]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The program will print out the number of words per line represented as a list
    of numbers as follows:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 程序将打印出每行的单词数，并以数字列表的形式呈现，具体如下：
- en: '[PRE4]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How it works...
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Haskell provides useful input and output (I/O) capabilities for reading input
    and writing output in different ways. In our case, we use `readFile` to specify
    a path of a file to be read. Using the `do` keyword in `main` suggests that we
    are joining several IO actions together. The output of `readFile` is an I/O string,
    which means it is an I/O action that returns a `String` type.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Haskell 提供了有用的输入和输出（I/O）功能，可以以不同方式读取输入和写入输出。在我们的例子中，我们使用`readFile`来指定要读取的文件路径。使用`main`中的`do`关键字意味着我们将多个
    I/O 操作连接在一起。`readFile`的输出是一个 I/O 字符串，这意味着它是一个返回`String`类型的 I/O 操作。
- en: Now we're about to get a bit technical. Pay close attention. Alternatively,
    smile and nod. In Haskell, the I/O data type is an instance of something called
    a Monad. This allows us to use the `<-` notation to draw the string out of this
    I/O action. We then make use of the string by feeding it into our `countWords`
    function that counts the number of words in each line. Notice how we separated
    the `countWords` function apart from the impure `main` function.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们要进入一些技术细节，请注意。或者，你可以微笑并点头表示理解。在 Haskell 中，I/O 数据类型是名为 Monad 的实例。这允许我们使用`<-`符号从这个
    I/O 操作中提取字符串。然后，我们通过将字符串传递给`countWords`函数来使用它，从而计算每行的单词数。请注意，我们将`countWords`函数与不纯粹的`main`函数分开。
- en: Finally, we print the output of `countWords`. The `$` notation means we are
    using a function application to avoid excessive parenthesis in our code. Without
    it, the last line of `main` would look like `print (countWords input)`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们打印出`countWords`的输出。`$`符号表示我们使用函数应用来避免在代码中使用过多的括号。如果没有它，`main`的最后一行将是`print
    (countWords input)`。
- en: See also
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: 'For simplicity''s sake, this code is easy to read but very fragile. If an `input.txt`
    file does not exist, then running the code will immediately crash the program.
    For example, the following command will generate the error message:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简便起见，这段代码易于阅读，但非常脆弱。如果`input.txt`文件不存在，运行代码将立即使程序崩溃。例如，以下命令将生成错误信息：
- en: '[PRE5]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: To make this code fault tolerant, refer to the *Catching I/O code faults* recipe.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这段代码具有容错性，请参考 *捕获 I/O 代码错误* 的做法。
- en: Catching I/O code faults
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 捕获 I/O 代码错误
- en: Making sure our code doesn't crash in the process of data mining or analysis
    is a substantially genuine concern. Some computations may take hours, if not days.
    Haskell gifts us with type safety and strong checks to help ensure a program will
    not fail, but we must also take care to double-check edge cases where faults may
    occur.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 确保我们的代码在数据挖掘或分析过程中不会崩溃是一个非常重要的考虑因素。某些计算可能需要几个小时，甚至几天。Haskell 提供了类型安全和强类型检查，以帮助确保程序不会失败，但我们也必须小心，仔细检查可能发生故障的边缘情况。
- en: 'For instance, a program may crash ungracefully if the local file path is not
    found. In the previous recipe, there was a strong dependency on the existence
    of `input.txt` in our code. If the program is unable to find the file, it will
    produce the following error:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果没有找到本地文件路径，程序可能会异常崩溃。在前面的例子中，我们的代码强烈依赖于 `input.txt` 的存在。如果程序无法找到该文件，它将产生以下错误：
- en: '[PRE6]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Naturally, we should decouple the file path dependency by enabling the user
    to specify his/her file path as well as by not crashing in the event that the
    file is not found.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，我们应该通过允许用户指定文件路径以及在文件未找到时不让程序崩溃，从而解耦文件路径的依赖关系。
- en: Consider the following revision of the source code.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑对源代码进行以下修改。
- en: How to do it…
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到……
- en: 'Create a new file, name it `Main.hs`, and perform the following steps:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新文件，命名为 `Main.hs`，并执行以下步骤：
- en: 'First, import a library to catch fatal errors as follows:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，导入一个库来捕获致命错误，如下所示：
- en: '[PRE7]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Next, import a library to get command-line arguments so that the file path
    is dynamic. We use the following line of code to do this:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，导入一个库来获取命令行参数，使文件路径动态化。我们使用以下代码行来实现：
- en: '[PRE8]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Continuing as before, define and implement `main` as follows:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照之前的方式，定义并实现 `main` 如下：
- en: '[PRE9]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Define a `fileName` string depending on the user-provided argument, defaulting
    to `input.txt` if there is no argument. The argument is obtained by retrieving
    an array of strings from the library function, `getArgs :: IO [String]`, as shown
    in the following steps:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '根据用户提供的参数定义一个 `fileName` 字符串，如果没有参数则默认为 `input.txt`。该参数通过从库函数 `getArgs :: IO
    [String]` 中获取字符串数组来获取，如以下步骤所示：'
- en: '[PRE10]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now apply `readFile` on this path, but catch any errors using the library''s
    `catch :: Exception e => IO a -> (e -> IO a) -> IO a` function. The first argument
    to catch is the computation to run, and the second argument is the handler to
    invoke if an exception is raised, as shown in the following commands:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '现在在这个路径上应用 `readFile`，但使用库的 `catch :: Exception e => IO a -> (e -> IO a) ->
    IO a` 函数来捕获任何错误。`catch` 的第一个参数是要运行的计算，第二个参数是如果出现异常时要调用的处理程序，如以下命令所示：'
- en: '[PRE11]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `input` string will be empty if there were any errors reading the file.
    We can now use `input` for any purpose using the following command:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果读取文件时出现错误，`input` 字符串将为空。我们现在可以使用 `input` 来执行任何操作，如下所示：
- en: '[PRE12]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Don''t forget to define the `countWords` function as follows:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 别忘了定义 `countWords` 函数，如下所示：
- en: '[PRE13]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: How it works…
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: 'This recipe demonstrates two ways to catch errors, listed as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了两种捕获错误的方法，如下所示：
- en: Firstly, we use a case expression that pattern matches against any argument
    passed in. Therefore, if no arguments are passed, the `args` list is empty, and
    the last pattern, `"_"`, is caught, resulting in a default filename of `input.txt`.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们使用一个模式匹配的 `case` 表达式来匹配传入的任何参数。因此，如果没有传入参数，`args` 列表为空，最后的模式 `"_"` 会被捕获，从而得到默认的文件名
    `input.txt`。
- en: Secondly, we use the catch function to handle an error if something goes wrong.
    When having trouble reading a file, we allow the code to continue running by setting
    `input` to an empty string.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，我们使用 `catch` 函数来处理错误，如果出现问题。在读取文件时遇到麻烦时，我们通过将 `input` 设置为空字符串来允许代码继续运行。
- en: There's more…
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多……
- en: 'Conveniently, Haskell also comes with a `doesFileExist :: FilePath -> IO Bool`
    function from the `System.Directory` module. We can simplify the preceding code
    by modifying the `input <- …` line. It can be replaced with the following snippet
    of code:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '方便的是，Haskell 还提供了一个来自 `System.Directory` 模块的 `doesFileExist :: FilePath ->
    IO Bool` 函数。我们可以通过修改 `input <- …` 这一行来简化之前的代码。它可以被以下代码片段替换：'
- en: '[PRE14]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In this case, the code reads the file as an input only if it exists. Do not
    forget to add the following `import` line at the top of the source code:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，代码只有在文件存在时才会将其作为输入读取。不要忘记在源代码的顶部添加以下 `import` 语句：
- en: '[PRE15]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Keeping and representing data from a CSV file
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保留和表示来自 CSV 文件的数据
- en: '**Comma Separated Value** (**CSV**) is a format to represent a table of values
    in plain text. It''s often used to interact with data from spreadsheets. The specifications
    for CSV are described in RFC 4180, available at [http://tools.ietf.org/html/rfc4180](http://tools.ietf.org/html/rfc4180).'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**逗号分隔值**（**CSV**）是一种以纯文本表示数值表格的格式。它通常用于与电子表格中的数据进行交互。CSV的规格在RFC 4180中有描述，可以在[http://tools.ietf.org/html/rfc4180](http://tools.ietf.org/html/rfc4180)找到。'
- en: In this recipe, we will read a local CSV file called `input.csv` consisting
    of various names and their corresponding ages. Then, to do something useful with
    the data, we will find the oldest person.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将读取一个名为`input.csv`的本地CSV文件，里面包含各种姓名及其对应的年龄。然后，为了对数据做一些有意义的操作，我们将找到最年长的人。
- en: Getting ready
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Prepare a simple CSV file with a list of names and their corresponding ages.
    This can be done using a text editor or by exporting from a spreadsheet, as shown
    in the following figure:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 准备一个简单的CSV文件，列出姓名及其对应的年龄。可以使用文本编辑器完成此操作，或通过电子表格导出，如下图所示：
- en: '![Getting ready](img/6331OS_01_01.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作](img/6331OS_01_01.jpg)'
- en: 'The raw `input.csv` file contains the following text:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 原始的`input.csv`文件包含以下文本：
- en: '[PRE16]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The code also depends on the `csv` library. We may install the library through
    Cabal using the following command:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码还依赖于`csv`库。我们可以使用以下命令通过Cabal安装该库：
- en: '[PRE17]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: How to do it...
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Import the `csv` library using the following line of code:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码行导入`csv`库：
- en: '[PRE18]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Define and implement `main`, where we will read and parse the CSV file, as
    shown in the following code:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义并实现`main`，在这里我们将读取并解析CSV文件，如以下代码所示：
- en: '[PRE19]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Apply `parseCSV` to the filename to obtain a list of rows, representing the
    tabulated data. The output of `parseCSV` is `Either ParseError CSV`, so ensure
    that we consider both the `Left` and `Right` cases:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`parseCSV`应用于文件名，以获得一系列行，表示表格数据。`parseCSV`的输出是`Either ParseError CSV`，因此确保我们考虑`Left`和`Right`两种情况：
- en: '[PRE20]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now we can work with the CSV data. In this example, we find and print the row
    containing the oldest person, as shown in the following code snippet:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以处理CSV数据了。在这个例子中，我们找到并打印包含最年长的人的行，如下面的代码片段所示：
- en: '[PRE21]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'After running `main`, the code should produce the following output:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`main`后，代码应该产生以下输出：
- en: '[PRE22]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Tip
  id: totrans-135
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: We can also use the `parseCSVFromFile` function to directly get the CSV representation
    from a filename instead of using `readFile` followed `parseCSV`.
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们也可以使用`parseCSVFromFile`函数直接从文件名获取CSV表示，而不是使用`readFile`后接`parseCSV`。
- en: How it works...
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The CSV data structure in Haskell is represented as a list of records. `Record`
    is merely a list of `Fields`, and `Field` is a type synonym for `String`. In other
    words, it is a collection of rows representing a table, as shown in the following
    figure:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在Haskell中，CSV数据结构表示为一个记录列表。`Record`仅仅是`Fields`的列表，`Field`是`String`的类型别名。换句话说，它是表示表格的行的集合，如下图所示：
- en: '![How it works...](img/6331OS_01_02.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/6331OS_01_02.jpg)'
- en: The `parseCSV` library function returns an `Either` type, with the `Left` side
    being a `ParseError` and the `Right` side being the list of lists. The `Either
    l r` data type is very similar to the `Maybe a` type which has the `Just a` or
    `Nothing` constructor.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`parseCSV`库函数返回一个`Either`类型，`Left`侧是一个`ParseError`，`Right`侧是一个列表的列表。`Either
    l r`数据类型与`Maybe a`类型非常相似，后者有`Just a`或`Nothing`构造器。'
- en: We use the `either` function to handle the `Left` and `Right` cases. The `Left`
    case handles the error, and the `Right` case handles the actual work to be done
    on the data. In this recipe, the `Right` side is a `Record`. The fields in `Record`
    are accessible through any list operations such as `head`, `last`, `!!`, and so
    on.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`either`函数来处理`Left`和`Right`的情况。`Left`情况处理错误，`Right`情况处理数据上的实际操作。在这个例子中，`Right`侧是一个`Record`。`Record`中的字段可以通过任何列表操作进行访问，例如`head`、`last`、`!!`等。
- en: Examining a JSON file with the aeson package
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用aeson包检查JSON文件
- en: '**JavaScript Object Notation** (**JSON**) is a way to represent key-value pairs
    in plain text. The format is described extensively in RFC 4627 ([http://www.ietf.org/rfc/rfc4627](http://www.ietf.org/rfc/rfc4627)).'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript对象表示法**（**JSON**）是一种以纯文本表示键值对的方式。该格式在RFC 4627中有广泛描述（[http://www.ietf.org/rfc/rfc4627](http://www.ietf.org/rfc/rfc4627)）。'
- en: In this recipe, we will parse a JSON description about a person. We often encounter
    JSON in APIs from web applications.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将解析一个关于某人的JSON描述。我们常在来自Web应用程序的API中遇到JSON格式。
- en: Getting ready
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Install the `aeson` library from hackage using Cabal.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Cabal从hackage安装`aeson`库。
- en: 'Prepare an `input.json` file representing data about a mathematician, such
    as the one in the following code snippet:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 准备一个代表数学家的`input.json`文件，如下代码片段所示：
- en: '[PRE23]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We will be parsing this JSON and representing it as a usable data type in Haskell.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将解析这个JSON并将其表示为Haskell中的可用数据类型。
- en: How to do it...
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Use the `OverloadedStrings` language extension to represent strings as `ByteString`,
    as shown in the following line of code:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`OverloadedStrings`语言扩展将字符串表示为`ByteString`，如下代码行所示：
- en: '[PRE24]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Import `aeson` as well as some helper functions as follows:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下所示导入`aeson`及一些辅助函数：
- en: '[PRE25]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Create the data type corresponding to the JSON structure, as shown in the following
    code:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建与JSON结构对应的数据类型，如下代码所示：
- en: '[PRE26]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Provide an instance for the `parseJSON` function, as shown in the following
    code snippet:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下代码片段所示，为`parseJSON`函数提供一个实例：
- en: '[PRE27]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Define and implement `main` as follows:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下所示定义并实现`main`：
- en: '[PRE28]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Read the input and decode the JSON, as shown in the following code snippet:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 阅读输入并解码JSON，如下代码片段所示：
- en: '[PRE29]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now we will do something interesting with the data as follows:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将对数据做一些有趣的操作，如下所示：
- en: '[PRE30]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We can run the code to see the following output:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以运行代码以查看以下输出：
- en: '[PRE31]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: How it works...
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Aeson takes care of the complications in representing JSON. It creates native
    usable data out of a structured text. In this recipe, we use the `.:` and `.:?`
    functions provided by the `Data.Aeson` module.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: Aeson处理表示JSON的复杂性。它将结构化文本转换为本地可用的数据。在本食谱中，我们使用`Data.Aeson`模块提供的`.:`和`.:?`函数。
- en: As the `Aeson` package uses `ByteStrings` instead of `Strings`, it is very helpful
    to tell the compiler that characters between quotation marks should be treated
    as the proper data type. This is done in the first line of the code which invokes
    the `OverloadedStrings` language extension.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Aeson`包使用`ByteStrings`而非`Strings`，因此很有帮助的是告诉编译器引号中的字符应该被当作正确的数据类型处理。这是在代码的第一行通过调用`OverloadedStrings`语言扩展来实现的。
- en: Tip
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Language extensions such as `OverloadedStrings` are currently supported only
    by the **Glasgow Haskell Compiler** (**GHC**).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，`OverloadedStrings`等语言扩展目前仅**Glasgow Haskell Compiler**（**GHC**）支持。
- en: We use the `decode` function provided by Aeson to transform a string into a
    data type. It has the type `FromJSON a => B.ByteString -> Maybe a`. Our `Mathematician`
    data type must implement an instance of the `FromJSON` typeclass to properly use
    this function. Fortunately, the only required function for implementing `FromJSON`
    is `parseJSON`. The syntax used in this recipe for implementing `parseJSON` is
    a little strange, but this is because we're leveraging applicative functions and
    lenses, which are more advanced Haskell topics.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用Aeson提供的`decode`函数将字符串转换为数据类型。它的类型为`FromJSON a => B.ByteString -> Maybe
    a`。我们的`Mathematician`数据类型必须实现`FromJSON`类型类的实例才能正确使用此函数。幸运的是，实现`FromJSON`所需的唯一函数是`parseJSON`。本食谱中用于实现`parseJSON`的语法有些奇怪，但这是因为我们正在利用应用函数和镜头，这是更高级的Haskell主题。
- en: The `.:` function has two arguments, `Object` and `Text`, and returns a `Parser
    a` data type. As per the documentation, it retrieves the value associated with
    the given key of an object. This function is used if the key and the value exist
    in the JSON document. The `:?` function also retrieves the associated value from
    the given key of an object, but the existence of the key and value are not mandatory.
    So, we use `.:?` for optional key value pairs in a JSON document.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`.:`函数有两个参数，`Object`和`Text`，并返回一个`Parser a`数据类型。根据文档，它用于检索与给定键相关联的对象中的值。如果JSON文档中存在该键和值，则使用此函数。`:?`函数也从给定键的对象中检索关联值，但键和值的存在不是必需的。因此，对于JSON文档中的可选键值对，我们使用`.:?`。'
- en: There's more…
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'If the implementation of the `FromJSON` typeclass is too involved, we can easily
    let GHC automatically fill it out using the `DeriveGeneric` language extension.
    The following is a simpler rewrite of the code:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`FromJSON`类型类的实现过于复杂，我们可以轻松地让GHC通过`DeriveGeneric`语言扩展自动填充它。以下是代码的简化重写：
- en: '[PRE32]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Although Aeson is powerful and generalizable, it may be an overkill for some
    simple JSON interactions. Alternatively, if we wish to use a very minimal JSON
    parser and printer, we can use Yocto, which can be downloaded from [http://hackage.haskell.org/package/yocto](http://hackage.haskell.org/package/yocto).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Aeson功能强大且具有通用性，但对于一些简单的JSON交互，它可能显得过于复杂。作为替代，如果我们希望使用一个非常简洁的JSON解析器和打印器，可以使用Yocto，它可以从[http://hackage.haskell.org/package/yocto](http://hackage.haskell.org/package/yocto)下载。
- en: Reading an XML file using the HXT package
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 HXT 包读取 XML 文件
- en: '**Extensible Markup Language** (**XML**) is an encoding of plain text to provide
    machine-readable annotations on a document. The standard is specified by W3C ([http://www.w3.org/TR/2008/REC-xml-20081126/](http://www.w3.org/TR/2008/REC-xml-20081126/)).'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '**可扩展标记语言**（**XML**）是对纯文本的编码，旨在为文档提供机器可读的注释。该标准由 W3C 指定（[http://www.w3.org/TR/2008/REC-xml-20081126/](http://www.w3.org/TR/2008/REC-xml-20081126/)）。'
- en: In this recipe, we will parse an XML document representing an e-mail conversation
    and extract all the dates.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将解析一个表示电子邮件对话的 XML 文档，并提取所有日期。
- en: Getting ready
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'We will first set up an XML file called `input.xml` with the following values,
    representing an e-mail thread between Databender and Princess on December 18,
    2014 as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先设置一个名为 `input.xml` 的 XML 文件，包含以下值，表示 2014 年 12 月 18 日 Databender 和 Princess
    之间的电子邮件对话，如下所示：
- en: '[PRE33]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Using Cabal, install the HXT library which we use for manipulating XML documents:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Cabal 安装 HXT 库，我们用它来处理 XML 文档：
- en: '[PRE34]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: How to do it...
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何做的...
- en: 'We only need one import, which will be for parsing XML, using the following
    line of code:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们只需要一个导入，用于解析 XML，代码如下：
- en: '[PRE35]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Define and implement `main` and specify the XML location. For this recipe,
    the file is retrieved from `input.xml`. Refer to the following code:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义并实现 `main` 函数并指定 XML 的位置。对于此示例，文件从 `input.xml` 获取。参考以下代码：
- en: '[PRE36]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Apply the `readString` function to the input and extract all the date documents.
    We filter items with a specific name using the `hasName :: String -> a XmlTree
    XmlTree` function. Also, we extract the text using the `getText :: a XmlTree String`
    function, as shown in the following code snippet:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '将 `readString` 函数应用于输入并提取所有日期文档。我们使用 `hasName :: String -> a XmlTree XmlTree`
    函数筛选具有特定名称的项目。同时，我们使用 `getText :: a XmlTree String` 函数提取文本，如下所示的代码片段：'
- en: '[PRE37]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We can now use the list of extracted dates as follows:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以按如下方式使用提取的日期列表：
- en: '[PRE38]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'By running the code, we print the following output:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码后，我们打印出以下输出：
- en: '[PRE39]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: How it works...
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The library function, `runX`, takes in an **Arrow**. Think of an Arrow as a
    more powerful version of a Monad. Arrows allow for stateful global XML processing.
    Specifically, the `runX` function in this recipe takes in `IOSArrow XmlTree String`
    and returns an `IO` action of the `String` type. We generate this `IOSArrow` object
    using the `readString` function, which performs a series of operations to the
    XML data.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 库函数 `runX` 接受一个 **Arrow**。可以将 Arrow 看作是比 Monad 更强大的版本。Arrows 允许进行有状态的全局 XML
    处理。具体来说，本示例中的 `runX` 函数接受 `IOSArrow XmlTree String`，并返回一个类型为 `String` 的 `IO` 动作。我们使用
    `readString` 函数生成此 `IOSArrow` 对象，它对 XML 数据执行一系列操作。
- en: For a deep insight into the XML document, `//>` should be used whereas `/>`
    only looks at the current level. We use the `//>` function to look up the date
    attributes and display all the associated text.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 对于深入了解 XML 文档，应该使用 `//>`，而 `/>` 只查看当前级别。我们使用 `//>` 函数查找日期属性并显示所有关联文本。
- en: 'As defined in the documentation, the `hasName` function tests whether a node
    has a specific name, and the `getText` function selects the text of a text node.
    Some other functions include the following:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如文档中所定义，`hasName` 函数用于测试一个节点是否具有特定名称，`getText` 函数用于选择文本节点的文本。还有其他一些函数，包括：
- en: '`isText`: This is used to test for text nodes'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isText`：用于测试文本节点'
- en: '`isAttr`: This is used to test for an attribute tree'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isAttr`：用于测试属性树'
- en: '`hasAttr`: This is used to test whether an element node has an attribute node
    with a specific name'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hasAttr`：用于测试一个元素节点是否具有特定名称的属性节点'
- en: '`getElemName`: This is used to select the name of an element node'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getElemName`：用于选择元素节点的名称'
- en: All the Arrow functions can be found on the `Text.XML.HXT.Arrow.XmlArrow` documentation
    at [http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html](http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的箭头函数都可以在 `Text.XML.HXT.Arrow.XmlArrow` 文档中找到，链接：[http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html](http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-XmlArrow.html)。
- en: Capturing table rows from an HTML page
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从 HTML 页面捕获表格行
- en: Mining **Hypertext Markup Language** (**HTML**) is often a feat of identifying
    and parsing only its structured segments. Not all text in an HTML file may be
    useful, so we find ourselves only focusing on a specific subset. For instance,
    HTML tables and lists provide a strong and commonly used structure to extract
    data whereas a paragraph in an article may be too unstructured and complicated
    to process.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 挖掘**超文本标记语言**（**HTML**）通常是一项识别和解析其结构化部分的工作。并非HTML文件中的所有文本都是有用的，所以我们往往只关注特定的子集。例如，HTML表格和列表提供了一种强大且常用的结构来提取数据，而文章中的段落可能过于无结构和复杂，不易处理。
- en: In this recipe, we will find a table on a web page and gather all rows to be
    used in the program.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，我们将找到网页上的一个表格，并收集所有行以供程序使用。
- en: Getting ready
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We will be extracting the values from an HTML table, so start by creating an
    `input.html` file containing a table as shown in the following figure:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从HTML表格中提取值，所以首先创建一个包含表格的`input.html`文件，如下图所示：
- en: '![Getting ready](img/6331OS_01_03.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作](img/6331OS_01_03.jpg)'
- en: 'The HTML behind this table is as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 该表格背后的HTML如下所示：
- en: '[PRE40]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'If not already installed, use Cabal to set up the HXT library and the split
    library, as shown in the following command lines:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果尚未安装，请使用Cabal来设置HXT库和split库，如下命令所示：
- en: '[PRE41]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: How to do it...
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'We will need the `htx` package for XML manipulations and the `chunksOf` function
    from the split package, as presented in the following code snippet:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将需要`htx`包用于XML操作，以及来自split包的`chunksOf`函数，如以下代码片段所示：
- en: '[PRE42]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Define and implement `main` to read the `input.html` file.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义并实现`main`来读取`input.html`文件。
- en: '[PRE43]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Feed the HTML data into `readString`, thereby setting `withParseHTML` to `yes`
    and optionally turning off warnings. Extract all the `td` tags and obtain the
    remaining text, as shown in the following code:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将HTML数据传递给`readString`，设置`withParseHTML`为`yes`，并可选择关闭警告。提取所有`td`标签并获取剩余文本，如以下代码所示：
- en: '[PRE44]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The data is now usable as a list of strings. It can be converted into a list
    of lists similar to how CSV was presented in the previous CSV recipe, as shown
    in the following code:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在数据可以作为字符串列表使用。它可以像之前CSV配方中展示的那样，转换为列表的列表，如以下代码所示：
- en: '[PRE45]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'By folding through the data, identify the course with the largest capacity
    using the following code snippet:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过折叠数据，使用以下代码片段识别容量最大课程：
- en: '[PRE46]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Running the code will display the class with the largest capacity as follows:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码将显示容量最大的课程，如下所示：
- en: '[PRE47]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: How it works...
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This is very similar to XML parsing, except we adjust the options of `readString`
    to `[withParseHTML yes, withWarnings no]`.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这与XML解析非常相似，只是我们调整了`readString`的选项为`[withParseHTML yes, withWarnings no]`。
- en: Understanding how to perform HTTP GET requests
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解如何执行HTTP GET请求
- en: One of the most resourceful places to find good data is online. **GET requests**
    are common methods of communicating with an HTTP web server. In this recipe, we
    will grab all the links from a Wikipedia article and print them to the terminal.
    To easily grab all the links, we will use a helpful library called `HandsomeSoup`,
    which lets us easily manipulate and traverse a webpage through CSS selectors.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找好数据的最有资源的地方之一就是在线。**GET请求**是与HTTP网页服务器通信的常用方法。在这个配方中，我们将抓取维基百科文章中的所有链接并将其打印到终端。为了方便地抓取所有链接，我们将使用一个叫做`HandsomeSoup`的有用库，它可以让我们通过CSS选择器轻松地操作和遍历网页。
- en: Getting ready
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will be collecting all links from a Wikipedia web page. Make sure to have
    an Internet connection before running this recipe.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个维基百科网页中收集所有链接。在运行此配方之前，请确保已连接互联网。
- en: 'Install the `HandsomeSoup` CSS selector package, and also install the HXT library
    if it is not already installed. To do this, use the following commands:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 安装`HandsomeSoup` CSS选择器包，如果尚未安装HXT库，请安装它。为此，请使用以下命令：
- en: '[PRE48]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: How to do it...
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'This recipe requires `hxt` for parsing HTML and requires `HandsomeSoup` for
    the easy-to-use CSS selectors, as shown in the following code snippet:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此配方需要`hxt`来解析HTML，并需要`HandsomeSoup`来提供易于使用的CSS选择器，如以下代码片段所示：
- en: '[PRE49]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Define and implement `main` as follows:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式定义并实现`main`：
- en: '[PRE50]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Pass in the URL as a string to HandsomeSoup''s `fromUrl` function:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将URL作为字符串传递给HandsomeSoup的`fromUrl`函数：
- en: '[PRE51]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Select all links within the `bodyContent` field of the Wikipedia page as follows:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式选择维基百科页面中`bodyContent`字段内的所有链接：
- en: '[PRE52]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: How it works…
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The `HandsomeSoup` package allows easy CSS selectors. In this recipe, we run
    the `#bodyContent a` selector on a Wikipedia article web page. This finds all
    link tags that are descendants of an element with the `bodyContent` ID.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`HandsomeSoup` 包允许使用简易的 CSS 选择器。在此配方中，我们在 Wikipedia 文章网页上运行 `#bodyContent a`
    选择器。这将找到所有作为`bodyContent` ID元素后代的链接标签。'
- en: See also…
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见…
- en: Another common way to obtain data online is through POST requests. To find out
    more, refer to the *Learning how to perform HTTP POST requests* recipe.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种常见的在线获取数据的方法是通过 POST 请求。要了解更多信息，请参考*学习如何执行 HTTP POST 请求*的配方。
- en: Learning how to perform HTTP POST requests
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习如何执行 HTTP POST 请求
- en: A **POST request** is another very common HTTP server request used by many APIs.
    We will be mining the University of Virginia directory search. When sending a
    POST request for a search query, the **Lightweight Directory Access Protocol**
    (**LDAP**) server replies with a web page of search results.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '**POST 请求**是另一种非常常见的 HTTP 服务器请求，许多 API 都在使用它。我们将挖掘弗吉尼亚大学的目录搜索。当发送一个用于搜索查询的
    POST 请求时，**轻量级目录访问协议**（**LDAP**）服务器会返回一个包含搜索结果的网页。'
- en: Getting ready
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: For this recipe, access to the Internet is necessary.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方需要访问互联网。
- en: 'Install the `HandsomeSoup` CSS selector package, and also install the HXT library
    if it is not already installed:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 安装`HandsomeSoup` CSS 选择器包，如果尚未安装，还需要安装 HXT 库：
- en: '[PRE53]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: How to do it...
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Import the following libraries:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入以下库：
- en: '[PRE54]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Define the POST request specified by the directory search website. Depending
    on the server, the following POST request details would be different. Refer to
    the following code snippet:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义目录搜索网站指定的 POST 请求。根据服务器的不同，以下 POST 请求的细节会有所不同。请参考以下代码片段：
- en: '[PRE55]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Define and implement `main` to run the POST request on a query as follows:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义并实现 `main` 来运行如下的 POST 请求：
- en: '[PRE56]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Gather the HTML and parse it:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 收集 HTML 并进行解析：
- en: '[PRE57]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Find the table rows and print it out using the following:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找表格行并使用以下代码打印输出：
- en: '[PRE58]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Running the code will display all search results relating to `"poon"`, such
    as "Poonam" or "Witherspoon".
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码将显示与`"poon"`相关的所有搜索结果，如“Poonam”或“Witherspoon”。
- en: How it works...
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: A POST request needs the specified URI, headers, and body. By filling out a
    `Request` data type, it can be used to establish a server request.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: POST 请求需要指定的 URI、头信息和主体。通过填写`Request`数据类型，可以用来建立服务器请求。
- en: See also
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: Refer to the *Understanding how to perform HTTP GET requests* recipe for details
    on how to perform a GET request instead.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考*理解如何执行 HTTP GET 请求*的配方，了解如何执行 GET 请求的详细信息。
- en: Traversing online directories for data
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 遍历在线目录以获取数据
- en: A directory search typically provides names and contact information per query.
    By brute forcing many of these search queries, we can obtain all data stored in
    the directory listing database. This recipe runs thousands of search queries to
    obtain as much data as possible from a directory search. This recipe is provided
    only as a learning tool to see the power and simplicity of data gathering in Haskell.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 目录搜索通常会根据查询提供姓名和联系方式。通过强行进行多个搜索查询，我们可以获取目录列表数据库中存储的所有数据。此配方仅作为学习工具，用于展示 Haskell
    数据收集的强大和简便性。
- en: Getting ready
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Make sure to have a strong Internet connection.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 确保拥有强劲的互联网连接。
- en: 'Install the `hxt` and `HandsomeSoup` packages using Cabal:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Cabal 安装`hxt`和`HandsomeSoup`包：
- en: '[PRE59]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: How to do it...
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Set up the following dependencies:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置以下依赖项：
- en: '[PRE60]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Define a `SearchResult` type, which may either fault in an error or result
    in a success, as presented in the following code:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个 `SearchResult` 类型，它可能会失败并返回错误，或返回成功，如以下代码所示：
- en: '[PRE61]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Define the POST request specified by the directory search website. Depending
    on the server, the POST request will be different. Instead of rewriting code,
    we use the `myRequest` function defined in the previous recipe.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义目录搜索网站指定的 POST 请求。根据服务器的不同，POST 请求会有所不同。为了避免重写代码，我们使用在上一个配方中定义的 `myRequest`
    函数。
- en: 'Write a helper function to obtain the document from a HTTP POST request, as
    shown in the following code:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个辅助函数来获取 HTTP POST 请求的文档，如下所示：
- en: '[PRE62]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Scan the HTML document and return whether there is an error or provide the
    resulting data. The code in this function is dependent on the error messages produced
    by the web page. In our case, the error messages are the following:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 扫描 HTML 文档并返回是否有错误，或者提供结果数据。此函数中的代码依赖于网页生成的错误消息。在我们的案例中，错误消息如下：
- en: '[PRE63]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Define and implement `main`. We will use a helper function, `main''`, as shown
    in the following code snippet, to recursively brute force the directory listing:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义并实现 `main`。我们将使用一个辅助函数 `main'`，如下所示的代码片段中，将递归地强行列出目录：
- en: '[PRE64]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Run a search of the query and then recursively again on the next query:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行查询搜索，然后在下一个查询中递归执行：
- en: '[PRE65]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Write helper functions to define the next logical query as follows:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写辅助函数来定义下一个逻辑查询，如下所示：
- en: '[PRE66]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: How it works...
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: 'The code starts by searching for "a" in the directory lookup. This will most
    likely fault in an error as there are too many results. So, in the next iteration,
    the code will refine its search by querying for "aa", then "aaa", until there
    is no longer `TooManyResultsErr :: SearchResultErr`.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '代码开始时会在目录查找中搜索 "a"。这很可能会由于结果过多而发生错误。因此，在下一次迭代中，代码会通过查询 "aa" 来细化搜索，再接着是 "aaa"，直到不再出现
    `TooManyResultsErr :: SearchResultErr`。'
- en: 'Then, it will enumerate to the next logical search query "aab", and if that
    produces no result, it will search for "aac", and so on. This brute force prefix
    search will obtain all items in the database. We can gather the mass of data,
    such as names and department types, to perform interesting clustering or analysis
    later on. The following figure shows how the program starts:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它将枚举到下一个逻辑搜索查询 "aab"，如果没有结果，它将搜索 "aac"，依此类推。这个强制前缀搜索将获取数据库中的所有项目。我们可以收集大量数据，比如姓名和部门类型，稍后进行有趣的聚类或分析。下图展示了程序的启动方式：
- en: '![How it works...](img/6331OS_01_04.jpg)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/6331OS_01_04.jpg)'
- en: Using MongoDB queries in Haskell
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Haskell 中使用 MongoDB 查询
- en: MongoDB is a nonrelational schemaless database. In this recipe, we will obtain
    all data from MongoDB into Haskell.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB 是一个非关系型的无模式数据库。在这个方法中，我们将把所有数据从 MongoDB 获取到 Haskell 中。
- en: Getting ready
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We need to install MongoDB on our local machine and have a database instance
    running in the background while we run the code in this recipe.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在本地机器上安装 MongoDB，并在运行此方法中的代码时，确保后台有一个数据库实例在运行。
- en: 'MongoDB installation instructions are located at [http://www.mongodb.org](http://www.mongodb.org).
    On Debian-based operating systems, we can use `apt-get` to install MongoDB, using
    the following command line:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB 安装说明位于 [http://www.mongodb.org](http://www.mongodb.org)。在基于 Debian 的操作系统中，我们可以使用
    `apt-get` 安装 MongoDB，命令如下：
- en: '[PRE67]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Run the database daemon by specifying the database file path as follows:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 通过指定数据库文件路径，运行数据库守护进程，方法如下：
- en: '[PRE68]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Fill up a `"people"` collection with dummy data as follows:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 填充一个名为 `"people"` 的集合，插入虚拟数据，方法如下：
- en: '[PRE69]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Install the MongoDB package from Cabal using the following command:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令从 Cabal 安装 MongoDB 包：
- en: '[PRE70]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: How to do it...
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做……
- en: 'Use the `OverloadedString` and `ExtendedDefaultRules` language extensions to
    make the MongoDB library easier to use:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `OverloadedString` 和 `ExtendedDefaultRules` 语言扩展来使 MongoDB 库更容易使用：
- en: '[PRE71]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Define and implement `main` to set up a connection to the locally hosted database.
    Run MongoDB queries defined in the `run` function as follows:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义并实现 `main` 来设置与本地托管数据库的连接。运行 `run` 函数中定义的 MongoDB 查询，方法如下：
- en: '[PRE72]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'In `run`, we can combine multiple operations. For this recipe, `run` will only
    perform one task, that is, gather data from the `"people"` collection:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `run` 中，我们可以结合多个操作。对于这个方法，`run` 将只执行一个任务，即从 `"people"` 集合中收集数据：
- en: '[PRE73]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: How it works...
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: 'A pipe is established by the driver between the running program and the database.
    This allows running MongoDB operations to bridge the program with the database.
    The `find` function takes a query, which we construct by evoking the `select ::
    Selector -> Collection -> aQueryOrSelection` function.'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '驱动程序在运行的程序与数据库之间建立了管道。这使得运行 MongoDB 操作能够将程序与数据库连接起来。`find` 函数接收一个查询，我们通过调用
    `select :: Selector -> Collection -> aQueryOrSelection` 函数来构建查询。'
- en: Other functions can be found in the documentation at [http://hackage.haskell.org/package/mongoDB/docs/Database-MongoDB-Query.html](http://hackage.haskell.org/package/mongoDB/docs/Database-MongoDB-Query.html).
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 其他函数可以在文档中找到：[http://hackage.haskell.org/package/mongoDB/docs/Database-MongoDB-Query.html](http://hackage.haskell.org/package/mongoDB/docs/Database-MongoDB-Query.html)
- en: See also
  id: totrans-320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: If the MongoDB database is on a remote server, refer to the *Reading from a
    remote MongoDB server* recipe to set up a connection with remote databases.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 MongoDB 数据库在远程服务器上，请参考*从远程 MongoDB 服务器读取数据*这一方法，来设置与远程数据库的连接。
- en: Reading from a remote MongoDB server
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从远程 MongoDB 服务器读取数据
- en: In many cases, it may be more feasible to set up a MongoDB instance on a remote
    machine. This recipe will cover how to obtain data from a MongoDB hosted remotely.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，可能在远程计算机上设置MongoDB实例更加可行。本做法将介绍如何从远程托管的MongoDB获取数据。
- en: Getting ready
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We should create a remote database. MongoLab ([https://mongolab.com](https://mongolab.com))
    and MongoHQ ([http://www.mongohq.com](http://www.mongohq.com)) offer MongoDB as
    a service and have free options to set up a small development database.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应创建一个远程数据库。MongoLab（[https://mongolab.com](https://mongolab.com)）和MongoHQ（[http://www.mongohq.com](http://www.mongohq.com)）提供作为服务的MongoDB，并且有免费的选项来设置一个小型开发数据库。
- en: Tip
  id: totrans-326
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: These services will require us to accept their terms and conditions. For some
    of us, it may be best to host the database in our own remote server.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 这些服务要求我们接受其条款和条件。对某些人来说，将数据库托管在我们自己的远程服务器上可能是最好的选择。
- en: 'Install the MongoDB package from Cabal as follows:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 按如下方式从Cabal安装MongoDB包：
- en: '[PRE74]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Also, install the helper following helper libraries as follows:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 还需安装以下辅助库：
- en: '[PRE75]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: How to do it...
  id: totrans-332
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做……
- en: 'Use the `OverloadedString` and `ExtendedDefaultRules` language extensions required
    by the library. Import helper functions as follows:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用库所需的`OverloadedString`和`ExtendedDefaultRules`语言扩展。按如下方式导入辅助函数：
- en: '[PRE76]'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Specify the remote URI for the database connection as follows:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式指定数据库连接的远程URI：
- en: '[PRE77]'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The username, password, hostname, port address number, and database name must
    be extracted from the URI, as presented in the following code snippet:'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户名、密码、主机名、端口地址和数据库名称必须从URI中提取，如下代码片段所示：
- en: '[PRE78]'
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Create a database connection by reading the host port of the remote URI as
    follows:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过读取远程URI的主机端口来创建数据库连接，如下所示：
- en: '[PRE79]'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Optionally authenticate to the database and obtain data from the `"people"`
    collection as follows:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可选地，对数据库进行身份验证并按如下方式从`"people"`集合中获取数据：
- en: '[PRE80]'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: See also
  id: totrans-343
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: If the database is on a local machine, refer to the *Using MongoDB queries in
    Haskell* recipe.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数据库在本地计算机上，请参阅*在Haskell中使用MongoDB查询*这一做法。
- en: Exploring data from a SQLite database
  id: totrans-345
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索SQLite数据库中的数据
- en: SQLite is a relational database that enforces a strict schema. It is simply
    a file on a machine that we can interact with through **Structured Query Language**
    (**SQL**). There is an easy-to-use Haskell library to send these SQL commands
    to our database.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite是一个关系型数据库，它执行严格的模式。它仅仅是机器上的一个文件，我们可以通过**结构化查询语言**（**SQL**）与之交互。Haskell有一个易于使用的库来将这些SQL命令发送到我们的数据库。
- en: In this recipe, we will use such a library to extract all data from a SQLite
    database.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在本做法中，我们将使用这样的库来提取SQLite数据库中的所有数据。
- en: Getting ready
  id: totrans-348
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We need to install the SQLite database if it isn''t already set up. It can
    be obtained from [http://www.sqlite.org](http://www.sqlite.org). On Debian systems,
    we can get it from `apt-get` using the following command:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 如果SQLite数据库尚未设置，我们需要先安装它。可以从[http://www.sqlite.org](http://www.sqlite.org)获取。在Debian系统中，我们可以通过以下命令从`apt-get`获取：
- en: '[PRE81]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Now create a simple database to test our code, using the following commands:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 现在创建一个简单的数据库来测试我们的代码，使用以下命令：
- en: '[PRE82]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'We must also install the SQLite Haskell package from Cabal as follows:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须按如下方式从Cabal安装SQLite Haskell包：
- en: '[PRE83]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: This recipe will dissect the example code presented on the library's documentation
    page available at [http://hackage.haskell.org/package/sqlite-simple/docs/Database-SQLite-Simple.html](http://hackage.haskell.org/package/sqlite-simple/docs/Database-SQLite-Simple.html).
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 本做法将详细分析库文档页面上展示的示例代码，页面地址为[http://hackage.haskell.org/package/sqlite-simple/docs/Database-SQLite-Simple.html](http://hackage.haskell.org/package/sqlite-simple/docs/Database-SQLite-Simple.html)。
- en: How to do it…
  id: totrans-356
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做……
- en: 'Use the `OverloadedStrings` language extension and import the relevant libraries,
    as shown in the following code:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`OverloadedStrings`语言扩展并导入相关库，如下代码所示：
- en: '[PRE84]'
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Define a data type for each SQLite table field. Provide it with an instance
    of the `FromRow` typeclass so that we may easily parse it from the table, as shown
    in the following code snippet:'
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为每个SQLite表字段定义一个数据类型。为它提供`FromRow`类型类的实例，以便我们可以轻松地从表中解析它，如下代码片段所示：
- en: '[PRE85]'
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'And lastly, open the database to import everything as follows:'
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，按如下方式打开数据库并导入所有内容：
- en: '[PRE86]'
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
