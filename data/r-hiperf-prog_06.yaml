- en: Chapter 6. Simple Tweaks to Use Less RAM
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 6 章。减少 RAM 使用量的简单调整
- en: So far, we have learned the techniques to overcome CPU limitations and improve
    the speed of R programs. As you can recall from [Chapter 1](ch01.html "Chapter 1. Understanding
    R's Performance – Why Are R Programs Sometimes Slow?"), *Understanding R's Performance
    – Why Are R Programs Sometimes Slow?* that another key constraint of R is memory.
    All the data that an R program needs to perform its tasks on must be loaded into
    the computer's memory or RAM. RAM is also needed for any intermediate computations,
    so the amount of RAM needed to process a given dataset can be many times the size
    of the dataset, depending on the type of tasks or algorithms being executed. This
    can become a problem when a large dataset needs to be processed, or when there
    is little RAM available to complete the tasks.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了克服 CPU 限制并提高 R 程序速度的技术。如您从 [第 1 章](ch01.html "第 1 章。理解 R 的性能 –
    为什么 R 程序有时运行缓慢？") 回忆的那样，*理解 R 的性能 – 为什么 R 程序有时运行缓慢？* 另一个 R 的关键约束是内存。R 程序执行任务所需的所有数据都必须加载到计算机的内存或
    RAM 中。RAM 也用于任何中间计算，因此处理给定数据集所需的 RAM 量可能是数据集大小的多倍，这取决于正在执行的任务或算法的类型。当需要处理大型数据集或可用
    RAM 很少时，这可能会成为一个问题。
- en: In this chapter and the next, we will learn how to optimize the RAM utilization
    of R programs so that memory-intensive tasks can be executed successfully.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章和下一章中，我们将学习如何优化 R 程序的 RAM 利用率，以便成功执行内存密集型任务。
- en: 'This chapter covers:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了：
- en: Reusing objects without taking up more memory
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重复使用对象而不占用更多内存
- en: Removing intermediate data when it is no longer needed
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当不再需要时删除中间数据
- en: Calculating values on the fly instead of storing them persistently
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在线计算值而不是持久存储它们
- en: Swapping active and nonactive data
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交换活跃和非活跃数据
- en: Reusing objects without taking up more memory
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重复使用对象而不占用更多内存
- en: The first tweak takes advantage of how R manages the memory of objects using
    a **copy-on-modification** model. In this model, when a copy of an object `x`
    is made, for example with `y <- x`, it is not actually copied in the memory. Rather,
    the new variable `y` simply points to the same block of memory that contains `x`.
    The first time when `y` is modified, R copies the data into a new block of memory
    so that `x` and `y` have their own copies of the data. That is why this model
    of memory management is called copy-on-modification. What this means is that new
    objects can sometimes be created from existing objects without taking up additional
    memory. To identify potential memory bottlenecks and manage the memory utilization
    of R programs, it is helpful to understand when R copies data and when it does
    not.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个调整利用了 R 如何使用 **copy-on-modification** 模型来管理对象的内存。在这个模型中，当创建一个对象 `x` 的副本时，例如使用
    `y <- x`，实际上在内存中并没有进行复制。相反，新变量 `y` 简单地指向包含 `x` 的同一块内存。当 `y` 第一次被修改时，R 会将数据复制到一个新的内存块中，这样
    `x` 和 `y` 就有了它们自己的数据副本。这就是为什么这种内存管理模型被称为 copy-on-modification。这意味着有时可以从现有对象中创建新对象，而无需占用额外的内存。为了识别潜在的内存瓶颈并管理
    R 程序的内存利用率，了解 R 在何时复制数据以及何时不复制数据是有帮助的。
- en: 'Take for example the following code, which generates a numeric vector `x` with
    1 million elements and creates a list `y` that contains two copies of `x`. We
    can examine the size of the objects using the `object.size()` function:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 以以下代码为例，它生成一个包含 100 万个元素的数值向量 `x` 并创建一个包含 `x` 两个副本的列表 `y`。我们可以使用 `object.size()`
    函数检查对象的大小：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'At first glance, it looks like there are two objects: `x`, which takes up 7.6
    MB of the memory, and `y`, which takes up 15.3 MB. However, the memory utilization
    can be measured in a different way, and with surprising results:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，似乎有两个对象：`x`，它占用了 7.6 MB 的内存，而 `y`，它占用了 15.3 MB。然而，内存利用率可以通过不同的方式来衡量，并且结果令人惊讶：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `object_size()` function from the CRAN package `pryr` measures the sizes
    of `x` and `y` slightly differently and more accurately than `object.size()` from
    the base R. It reports that `y`, which contains two numeric vectors takes up only
    8 MB—the same as `x`, which is a single numeric vector of the same length. How
    can that be? The `address()` function from the `pryr` package reveals the actual
    blocks of memory that each object points to:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 来自 CRAN 包 `pryr` 的 `object_size()` 函数比基础 R 的 `object.size()` 函数稍微不同且更准确地测量了
    `x` 和 `y` 的大小。它报告说 `y`，包含两个数值向量，只占用了 8 MB 的内存——与 `x` 相同，`x` 是一个长度相同的单个数值向量。这怎么可能呢？来自
    `pryr` 包的 `address()` 函数揭示了每个对象指向的实际内存块：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As expected, `y`, a list, points to a different memory location than `x`, a
    numeric vector, indicating that it is a different object. But the two elements
    of `y` point to the original object `x` in the memory. R is smart about not copying
    objects unnecessarily. In this case, it simply created two pointers in `y` that
    point to `x`. This is so efficient that in fact, `x` and `y` combined together
    take up only 8 MB, which is the size of `x`!
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期，列表 `y` 指向的内存位置与数值向量 `x` 不同，表明它是一个不同的对象。但是，`y` 的两个元素在内存中指向原始对象 `x`。R 在不必要的情况下不会复制对象。在这种情况下，它只是在
    `y` 中创建了两个指向 `x` 的指针。这种方式非常高效，实际上，`x` 和 `y` 合并在一起只占用 8 MB，这是 `x` 的大小！
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Actually, a tiny bit of extra memory is needed to store `y` and its pointers
    to `x`, but that is negligible and does not show up in this measurement.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，需要一点额外的内存来存储 `y` 和它对 `x` 的指针，但这可以忽略不计，并且不会出现在这个测量中。
- en: 'When one of the vectors in `y` is modified, R creates a new copy, since this
    vector is now different from `x`:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `y` 中的某个向量被修改时，R 会创建一个新的副本，因为这个向量现在与 `x` 不同：
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `y[[1]]` vector now points to a different vector in the memory than `x`
    and `y[[2]]`. As a result, `y` takes up 16 MB of RAM while `x` and `y` combined
    still take up only 16 MB (since `y[[2]]` still points to `x`). Another way to
    track this is when an object is copied to use `tracemem()`, which gives an alert
    whenever the object being tracked is copied. See what happens to `y[[2]]` when
    it is modified:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`y[[1]]` 向量现在指向内存中与 `x` 和 `y[[2]]` 不同的向量。因此，`y` 占用 16 MB 的 RAM，而 `x` 和 `y`
    合并在一起仍然只占用 16 MB（因为 `y[[2]]` 仍然指向 `x`）。另一种跟踪这个情况的方法是在对象被复制到使用 `tracemem()` 时，它会随时给出警告，表明正在跟踪的对象被复制。看看当
    `y[[2]]` 被修改时会发生什么：'
- en: '[PRE5]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `tracemem[0x10f992000 -> 0x1108d6000]` line indicates that a copy of vector
    `y[[2]]` was made when it was modified and gives the memory address of the new
    copy. Now, `x`, `y[[1]]`, and `y[[2]]` are different objects in memory, hence
    the total memory used by `x` and `y` is 24 MB:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`tracemem[0x10f992000 -> 0x1108d6000]` 这一行表示在修改向量 `y[[2]]` 时创建了一个副本，并给出了新副本的内存地址。现在，`x`、`y[[1]]`
    和 `y[[2]]` 在内存中是不同的对象，因此 `x` 和 `y` 所使用的总内存为 24 MB：'
- en: '[PRE6]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: When an element of `y` is modified, a copy of `x` needs to be made so that the
    original object `x` is unmodified. Otherwise, modifying one object will cause
    unintended modifications to the other, resulting in errors in the program that
    might be difficult to find.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当修改 `y` 的一个元素时，需要创建 `x` 的副本以确保原始对象 `x` 保持不变。否则，修改一个对象可能会无意中修改另一个对象，导致程序中可能出现难以发现的错误。
- en: The way in which R determines whether an object should be copied is by tracking
    whether other objects refer to it. When `y` was created, R knew that `x` is being
    used elsewhere and a copy needs to be made when it is modified.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: R 判断一个对象是否应该被复制的方式是通过跟踪是否有其他对象引用它。当 `y` 被创建时，R 知道 `x` 正在别处被使用，并且在修改时需要创建一个副本。
- en: Note
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: R counts only up to two references, which is sufficient for it to determine
    whether to copy an object or not. As long as two or more variables refer to the
    same object, R will make a copy of it when it is modified.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: R 只计算到两个引用，这对于它判断是否复制对象是足够的。只要两个或更多变量引用同一个对象，R 在修改时会复制它。
- en: 'Now, when we modify `x` for the first time, R makes a copy of it because `x`
    had been referred to by `y` before. Even though `y` now has its own copies of
    the data, R errs on the side of caution and makes a copy of `x` to avoid potential
    conflicts. Subsequent modifications to `x`, however, do not lead to unnecessary
    copying, as the new copy of `x` is not being used anywhere else, as this example
    shows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们第一次修改 `x` 时，R 会创建它的一个副本，因为 `x` 之前已经被 `y` 引用。尽管 `y` 现在有自己的数据副本，但 R 为了谨慎起见，仍然创建
    `x` 的副本以避免潜在的冲突。然而，随后的对 `x` 的修改不会导致不必要的复制，因为新的 `x` 副本没有在其他地方使用，正如这个例子所示：
- en: '[PRE7]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In general, as long as a vector has not been referred to by any other object,
    R allows it to be modified in place, avoiding the CPU and RAM overheads to make
    copies of the vector.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，只要一个向量没有被其他任何对象引用，R 允许它原地修改，从而避免复制向量的 CPU 和 RAM 开销。
- en: Note
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'This example does not work in RStudio:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子在 RStudio 中不起作用：
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This is because RStudio keeps a reference of every object in its own environment,
    so R thinks that `x` is being referred to elsewhere. It creates a copy of `x`
    every time it is modified, to be safe.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为 RStudio 在其自己的环境中保留每个对象的引用，所以 R 认为在别处有对 `x` 的引用。每次修改时，它都会创建 `x` 的一个副本以确保安全。
- en: 'Now that we understand when R copies data, we can optimize R programs in order
    to avoid copying the data unnecessarily. For example, say we have two vectors
    containing the ages and genders of 1 million customers:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了R何时复制数据，我们可以优化R程序以避免不必要地复制数据。例如，假设我们有两个包含一百万客户年龄和性别的向量：
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The retailer uses "`cust #"` for customer IDs. We want to label each vector
    with the customer IDs so that we can easily look up the information by the customer
    ID, using expressions like `customer.age["cust 1"]`. One way to do this is to
    separately construct the names for each vector. The two vectors combined will
    then take up 84 MB of memory:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '零售商使用"`cust #"`作为客户ID。我们希望为每个向量标记客户ID，这样我们就可以通过客户ID轻松查找信息，使用像`customer.age["cust
    1"]`这样的表达式。一种方法是为每个向量单独构造名称。然后，这两个向量组合将占用84 MB的内存：'
- en: '[PRE10]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Alternatively, the names can be stored in a separate vector that the age and
    gender vectors then can refer to:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，名称可以存储在一个单独的向量中，年龄和性别向量随后可以引用：
- en: '[PRE11]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This simple change resulted in a saving of 8 MB of memory. On larger, more complex
    data structures, these savings from not copying data unnecessarily can be significant.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的更改节省了8 MB的内存。在更大的、更复杂的数据结构上，这些从避免不必要地复制数据中节省下来的内存可以非常显著。
- en: The same copy-on-modification behavior applies to function arguments. When an
    object is passed to a function, it is not copied; R simply provides a pointer
    to the object. If, however, the object is modified within the function, R creates
    a copy of that object in the function's environment so that the original object
    is not modified in any way outside the function. In programming language parlance,
    this is called **pass by value** because functions are given the value of their
    arguments. This is part of R's design as a *functional programming language*.
    Contrast this with **pass by reference**, which is sometimes used in other programming
    languages, such as Java and C/C++, where functions can be given references or
    pointers to the memory's addresses. In this case, functions can modify their arguments
    without creating additional copies in memory, and the modifications persist even
    after the functions exit.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的按修改复制行为也适用于函数参数。当一个对象传递给函数时，它不会被复制；R只是提供了一个指向该对象的指针。然而，如果对象在函数内部被修改，R会在函数的环境中创建该对象的副本，以确保原始对象在函数外部不会被以任何方式修改。在编程语言术语中，这被称为**按值传递**，因为函数被赋予了它们的参数值。这是R作为*函数式编程语言*设计的一部分。与此相对的是**按引用传递**，这在其他编程语言中有时被使用，例如Java和C/C++，在这些语言中，函数可以接收对内存地址的引用或指针。在这种情况下，函数可以修改它们的参数，而无需在内存中创建额外的副本，并且修改在函数退出后仍然持续。
- en: A consequence of R's pass by value model for functions means that many functions
    need to make a copy of the data they are given. For example, calling `sort(x)`
    returns a new vector with the sorted values of `x`, rather than sorting the values
    in place (which is often the practice in Java and C/C++). Calling functions like
    `sort()` often requires additional free memory that is at least as large as the
    original data and sometimes more.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: R函数按值传递模型的一个后果是，许多函数需要复制它们接收到的数据。例如，调用`sort(x)`返回一个包含`x`排序值的新的向量，而不是就地排序值（这在Java和C/C++中通常是做法）。调用像`sort()`这样的函数通常需要额外的内存，至少与原始数据一样大，有时更大。
- en: Removing intermediate data when it is no longer needed
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 当不再需要中间数据时移除它
- en: In large R programs, objects are created in many places. Often, an object that
    is created in an earlier part of the program is not needed in later parts of the
    program. When faced with memory limits, it is useful to free up memory taken up
    by objects when they are no longer needed, so that subsequent parts of the program
    can run successfully.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在大型R程序中，对象通常在多个地方创建。通常，在程序早期部分创建的对象在程序的后期部分不再需要。当面临内存限制时，释放不再需要的对象占用的内存是有用的，这样程序的后续部分可以成功运行。
- en: The main tool for this is the `rm()` function that removes a given list of objects
    from the current R environment.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 用于此的主要工具是`rm()`函数，它从当前R环境中移除给定列表的对象。
- en: 'In the following example, we have a data frame containing 500,000 transactions
    from a retail store and the items within each transaction. Each row of the data
    frame represents a unique transaction-item pair that occurred in a sales database.
    Although, we have to generate the data for this example in a real business context,
    this data could be extracted from a retailer''s sales database:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们有一个包含来自零售店的50万个交易的DataFrame以及每个交易中的商品。DataFrame的每一行代表在销售数据库中发生的唯一交易项对。尽管我们不得不在真实业务环境中生成这个示例的数据，但这些数据可以从零售商的销售数据库中提取：
- en: '[PRE12]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The data looks like this where, for example, the first nine rows indicate that
    transaction 1 includes items 680, 846, 196, and so on (the data that you generate
    might look different):'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 数据看起来像这样，例如，前九行表明交易1包含商品680、846、196等（你生成数据可能看起来不同）：
- en: '[PRE13]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Our task is to find common baskets of items, that is, items that appear frequently
    together in the same transactions, or frequent itemsets. The `apriori()` function
    in the `arules` CRAN package can be used to find these frequent itemsets. But
    it does not accept data in the form of transaction-item pairs that we can extract
    from a sales database. Instead, `arules` defines the `transactions` class that
    it accepts as input. We need to split the items column of the data frame into
    the different transactions and then coerce the resulting list into a `transactions`
    object:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的任务是找到常见的商品篮子，即在同一交易中频繁一起出现的商品，或者频繁项集。`arules` CRAN包中的`apriori()`函数可以用来找到这些频繁项集。但它不接受从销售数据库中提取的交易项对形式的数据。相反，`arules`定义了它接受的输入`transactions`类。我们需要将数据框的商品列拆分为不同的交易，然后将生成的列表强制转换为`transactions`对象：
- en: '[PRE14]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We can now call the `apriori()` function to find the frequent itemsets. In this
    example, we want itemsets that have a support of at least 0.3, that is, sets of
    items that appear in at least 30 percent of the transactions.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以调用`apriori()`函数来找到频繁项集。在这个例子中，我们想要支持度至少为0.3的项集，即至少在30%的交易中出现的商品集合。
- en: '[PRE15]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'When we started with the data frame of transaction-item pairs, we had to convert
    it into a few different formats before the data could be used by `apriori()`.
    Each of these intermediate data structures takes up valuable memory:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从交易项对的数据框开始时，我们必须将其转换为几种不同的格式，然后数据才能被`apriori()`使用。这些中间数据结构都占用了宝贵的内存：
- en: '[PRE16]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'When the dataset is large or when memory is scarce, `apriori()` might fail
    to execute as it runs out of memory. In such situations, `rm()` can be used to
    free up memory by deleting unneeded objects before calling `apriori()` or even
    between each data transformation step. The following code illustrates this:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据集很大或内存不足时，`apriori()`可能会因为内存不足而无法执行。在这种情况下，可以在调用`apriori()`之前或甚至在每个数据转换步骤之间使用`rm()`来释放内存，通过删除不需要的对象。以下代码说明了这一点：
- en: '[PRE17]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Another technique to automatically remove temporary variables is to encapsulate
    code in functions. This way, any variables created in the function will automatically
    be deleted when the function exists. For example, say we only need to remove temporary
    variables before calling `apriori()`, because that is when the code tends to run
    into memory limits. We can encapsulate all the previous lines of codes in a function:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 自动删除临时变量的另一种技术是将代码封装在函数中。这样，在函数中创建的任何变量在函数结束时都会自动删除。例如，如果我们只需要在调用`apriori()`之前删除临时变量，因为那时代码往往会遇到内存限制。我们可以将所有之前的代码行封装在一个函数中：
- en: '[PRE18]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: After calling `prepare_data()`, any temporary variables created within it are
    deleted without having to explicitly call `rm()`. In this case, only one temporary
    variable, `trans.list` is deleted. But the same technique can be used when more
    temporary variables are declared in the function. Not only is this means of removing
    temporary variables convenient, it also makes the code more readable and easier
    to maintain.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`prepare_data()`之后，不需要显式调用`rm()`，其中的任何临时变量都会被删除。在这种情况下，只有一个临时变量`trans.list`被删除。但同样的技术也可以在函数中声明更多临时变量时使用。这种方法不仅方便删除临时变量，而且使代码更易于阅读和维护。
- en: In large R programs, periodic removal of large data structures can help to minimize
    overall memory usage. When `rm()` is called, the memory might not be freed and
    returned to the operating system immediately. Rather, R's **garbage collector**
    automatically frees the memory when it is needed, or when the amount of memory
    from removed objects exceeds a threshold.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在大型 R 程序中，定期删除大型数据结构可以帮助最小化整体内存使用。当调用 `rm()` 时，内存可能不会立即释放并返回给操作系统。相反，R 的 **垃圾回收器**会在需要时自动释放内存，或者当从移除的对象中释放的内存量超过阈值时。
- en: Calculating values on the fly instead of storing them persistently
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在线计算值而不是持久存储
- en: While executing an R program, it is sometimes convenient to cache all the data
    needed by the program, including the results of intermediate computations into
    a RAM prior to execution. During the execution, as and when the program needs
    to access any part of the data, it can be done very rapidly as all the data has
    been loaded into the R workspace. Caching intermediate results in RAM can save
    computational time significantly, especially when they are accessed frequently,
    as unnecessary recalculation of the data is avoided.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行 R 程序时，有时方便将程序所需的所有数据，包括中间计算结果，在执行前缓存到 RAM 中。在执行过程中，当程序需要访问数据的任何部分时，由于所有数据都已加载到
    R 工作空间中，因此可以非常快速地进行。在 RAM 中缓存中间结果可以显著节省计算时间，尤其是在频繁访问时，因为避免了数据的重复计算。
- en: This is not a problem when the cached data can fit into RAM. However, it becomes
    a problem when there is not enough memory space to contain the data. The good
    news is, in many cases, the program does not need all parts of the data at the
    same time. One solution is to swap in and out portions of the data between RAM
    and the hard disk. Because disk I/O is slow, as we have established in [Chapter
    1](ch01.html "Chapter 1. Understanding R's Performance – Why Are R Programs Sometimes
    Slow?"), *Understanding R's Performance – Why Are R Programs Sometimes Slow?*,
    this approach might result in a slow execution. A better solution is to calculate
    and recalculate portions of the data that are needed at the moment. Yes, calculation
    costs computational time, but it is often less costly than disk I/O.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当缓存的数据可以适应 RAM 时，这不是问题。然而，当没有足够的内存空间来容纳数据时，它就变成了问题。好消息是，在许多情况下，程序不需要同时访问数据的所有部分。一种解决方案是在
    RAM 和硬盘之间交换数据的部分。因为磁盘 I/O 很慢，正如我们在[第 1 章](ch01.html "第 1 章。理解 R 的性能 – 为什么 R 程序有时运行缓慢？")中确立的，*理解
    R 的性能 – 为什么 R 程序有时运行缓慢？*，这种方法可能会导致执行缓慢。更好的解决方案是计算和重新计算当前需要的部分数据。是的，计算需要计算时间，但通常比磁盘
    I/O 成本低。
- en: 'Let''s look at an example from a common task in data science: hierarchical
    clustering. In some commonly used variants of hierarchical clustering, such as
    the single, complete, and average linkage, one important step in the algorithm
    is to calculate the distance matrix between every pair of observations in the
    dataset, and then decide which pair of observations is the closest to each other.
    This step can be accomplished by the following code, in which we have artificially
    created a random dataset `A`, with 10,000 observations (rows) and 10 features
    (columns). The code first calculates the distance matrix of `A`, sets the diagonal
    element of the distance matrix to `NA` because an observation is always closest
    to itself and finally finds the closest pair using the `which()` function. In
    this instance, observations 6778 and 6737 are found to be the closest pair. To
    execute this program, about 801 MB of RAM is required, as can be seen from the
    outputs of `object_size()` in the following code. This is because even though
    the dataset only occupies 800 KB, its distance matrix needs about a quadratic
    amount of the original space because it is storing all the pairwise distances:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个数据科学中常见的任务举例：层次聚类。在一些常用的层次聚类变体中，例如单链接、完全链接和平均链接，算法中的一个重要步骤是计算数据集中每对观测值之间的距离矩阵，然后决定哪一对观测值彼此最接近。这一步骤可以通过以下代码实现，其中我们人为地创建了一个随机数据集
    `A`，包含 10,000 个观测值（行）和 10 个特征（列）。代码首先计算 `A` 的距离矩阵，将距离矩阵的对角线元素设置为 `NA`，因为观测值总是最接近自身的，最后使用
    `which()` 函数找到最近的观测值对。在这个例子中，发现观测值 6778 和 6737 是最近的一对。要执行此程序，大约需要 801 MB 的 RAM，如下代码中
    `object_size()` 的输出所示。这是因为尽管数据集只占用 800 KB，但其距离矩阵需要大约原空间的平方量，因为它存储了所有成对距离：
- en: '[PRE19]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: On close inspection, we do not actually need the whole distance matrix at once
    to find the closest pair. It is possible to calculate the set of pairwise distances
    between the first observation and the rest of the observations to get the minimum
    pair for this set; repeat the process for the second observation and then compare
    the minimum of the two sets and so on. Doing this incurs additional steps and
    hence longer computational time, but it demands only a small fraction of RAM compared
    to that of the preceding code (because only a chunk of the distance matrix is
    maintained at a given time). The code to do this is shown below. It first calculates
    the distances between all the observations in `A` with the observation 1 in `A`
    (using the `pdist` package) and then finds and saves the closest pair only for
    this chunk to a temporary list `output`. This process is repeated for the observations
    2, 3, …, 10,000 in `A` using `lapply`. The set of closest pairs from every chunk
    is stored in the `temp_res` list. The final step is to find the minimum pair among
    this set and store it in the variable `res2`. Evaluating the output of `res2`
    reveals the same result as the one found using the preceding code. However, this
    time we need only 2.7 MB of memory for the `temp_res` list.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细观察后，我们实际上并不需要一次性获取整个距离矩阵来找到最近的一对。可以计算第一个观测值与剩余观测值之间的成对距离，以获取该集合的最小对；对第二个观测值重复此过程，然后比较两个集合的最小值，依此类推。这样做会带来额外的步骤，因此计算时间会更长，但与前面的代码相比，它只需要占用很小一部分
    RAM（因为一次只维护距离矩阵的一小部分）。下面的代码展示了如何执行此操作。它首先使用 `pdist` 包计算 `A` 中所有观测值与观测值 1 之间的距离，然后只为此块找到并保存最近的对到临时列表
    `output`。使用 `lapply` 对 `A` 中的观测值 2、3、…、10,000 重复此过程。每个块的最接近对集合存储在 `temp_res` 列表中。最后一步是找到这个集合中的最小对并将其存储在变量
    `res2` 中。评估 `res2` 的输出会显示与前面代码找到的结果相同。然而，这次我们只需要 `temp_res` 列表占用 2.7 MB 的内存。
- en: '[PRE20]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Indeed the time needed by the second approach is longer. We can speed this up
    by parallelizing the code, for example by substituting `lapply()` with `parLApply()`
    of the `parallel` package (see [Chapter 8](ch08.html "Chapter 8. Multiplying Performance
    with Parallel Computing"), *Multiplying Performance with Parallel Computing*).
    In practice, for a specific case of finding the closest pair of observations efficiently
    without storing a full distance matrix, we can leverage optimized k-nearest neighbor
    functions, like the `knn()` function in the `FNN` package. Where such an alternative
    optimized package is unavailable, the approach of calculating values on the fly
    as illustrated in the preceding code is useful to reduce memory use.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 确实，第二种方法所需的时间更长。我们可以通过并行化代码来加快速度，例如，用 `parallel` 包中的 `parLApply()` 替换 `lapply()`（参见第
    8 章 [Multiplying Performance with Parallel Computing](ch08.html "第 8 章. 使用并行计算提高性能")，*使用并行计算提高性能*）。在实践中，对于寻找最接近的一对观测值且不存储完整距离矩阵的特定情况，我们可以利用优化的
    k 近邻函数，如 `FNN` 包中的 `knn()` 函数。如果这样的替代优化包不可用，那么像前面代码中所示的计算即时值的做法对于减少内存使用是有用的。
- en: Swapping active and nonactive data
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 交换活跃和非活跃数据
- en: 'In some situations, large objects that are removed to free up memory are needed
    later in the program. R provides tools to save data to the disk and reload them
    later when enough memory is available. Returning to the retail sales data example,
    suppose that we need the `sales.data` data frame for further processing after
    mining for frequent itemsets. We can save it to the disk using `saveRDS()` and
    reload it later using `readRDS()`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，为了在程序中稍后使用而移除以释放内存的大对象是必需的。R 提供了将数据保存到磁盘并在有足够内存时稍后重新加载的工具。回到零售销售数据示例，假设我们在挖掘频繁项集之后需要
    `sales.data` 数据框进行进一步处理。我们可以使用 `saveRDS()` 将其保存到磁盘，然后使用 `readRDS()` 在稍后重新加载：
- en: '[PRE21]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `saveRDS()` and `readRDS()` functions save one object at a time without
    the name of the object. For example, the name `sales.data` is not saved. However,
    the column names `trans` and `items` are saved. As an alternative, the `save()`
    and `load()` functions can be used to handle multiple objects or even all objects
    in an environment, along with their variable names.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`saveRDS()` 和 `readRDS()` 函数每次保存一个对象，而不保存对象名称。例如，名称 `sales.data` 不会被保存。然而，列名称
    `trans` 和 `items` 被保存。作为替代，可以使用 `save()` 和 `load()` 函数来处理多个对象，甚至是一个环境中所有对象及其变量名称。'
- en: Summary
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about the copy-on-modification semantics of R's
    memory management. A good understanding of how this works enables us to find opportunities
    to reduce the memory consumption of R programs.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了R内存管理的修改时复制语义。对这一机制的良好理解使我们能够找到减少R程序内存消耗的机会。
- en: We also saw how temporary variables and intermediate computations can be removed
    from the environment when they are no longer needed, to free up memory for subsequent
    computations. Besides removing temporary variables explicitly, we learned two
    other ways to manage temporary variables automatically. First, on the fly computations
    produce intermediate data without creating variables that persist in the memory.
    Second, functions are a useful way to group related operations and automatically
    remove temporary variables when exiting the functions.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到了如何在不必要时从环境中移除临时变量和中间计算，以释放内存供后续计算使用。除了显式地移除临时变量外，我们还学习了两种自动管理临时变量的方法。首先，即时计算在内存中不创建持久变量的情况下产生中间数据。其次，函数是分组相关操作的有用方式，当退出函数时可以自动移除临时变量。
- en: Finally, we saw how to save data to the disk to free up memory and reload them
    later when needed.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们看到了如何将数据保存到磁盘上以释放内存，并在需要时重新加载它们。
- en: In the next chapter, we will explore more advanced techniques in order to optimize
    memory consumption and allow R programs to work with larger datasets, even data
    that is too big to fit in the memory.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨更多高级技术，以优化内存消耗，并允许R程序处理更大的数据集，甚至那些太大而无法装入内存的数据。
