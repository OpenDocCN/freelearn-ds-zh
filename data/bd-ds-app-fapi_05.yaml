- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Managing Pydantic Data Models in FastAPI
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 FastAPI 中管理 Pydantic 数据模型
- en: This chapter will cover in detail the definition of a data model with Pydantic,
    the underlying data validation library used by FastAPI. We’ll explain how to implement
    variations of the same model without repeating the same code again and again,
    thanks to class inheritance. Finally, we’ll show how to implement custom data
    validation logic into Pydantic models.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将详细讲解如何使用 Pydantic 定义数据模型，这是 FastAPI 使用的底层数据验证库。我们将解释如何在不重复代码的情况下实现相同模型的变种，得益于类的继承。最后，我们将展示如何将自定义数据验证逻辑实现到
    Pydantic 模型中。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主要内容：
- en: Defining models and their field types with Pydantic
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Pydantic 定义模型及其字段类型
- en: Creating model variations with class inheritance
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用类继承创建模型变种
- en: Adding custom data validation with Pydantic
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Pydantic 添加自定义数据验证
- en: Working with Pydantic objects
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Pydantic 对象
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To run the code examples, you’ll need a Python virtual environment, which we
    set up in [*Chapter 1*](B19528_01.xhtml#_idTextAnchor024), *Python Development*
    *Environment Setup*.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行代码示例，你需要一个 Python 虚拟环境，我们在 [*第 1 章*](B19528_01.xhtml#_idTextAnchor024)，*Python
    开发环境设置* 中进行了设置。
- en: You’ll find all the code examples for this chapter in the dedicated GitHub repository
    at [https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在专门的 GitHub 仓库中找到本章的所有代码示例，链接为：[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04)。
- en: Defining models and their field types with Pydantic
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Pydantic 定义模型及其字段类型
- en: Pydantic is a powerful library for defining data models using Python classes
    and type hints. This approach makes those classes completely compatible with static
    type checking. Besides, since there are regular Python classes, we can use inheritance
    and also define our very own methods to add custom logic.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Pydantic 是一个强大的库，用于通过 Python 类和类型提示定义数据模型。这种方法使得这些类与静态类型检查完全兼容。此外，由于它是常规的 Python
    类，我们可以使用继承，并且还可以定义我们自己的方法来添加自定义逻辑。
- en: 'In [*Chapter 3*](B19528_03.xhtml#_idTextAnchor058), *Developing a RESTful API
    with FastAPI*, you learned the basics of defining a data model with Pydantic:
    you have to define a class inheriting from `BaseModel` and list all the fields
    as class properties, each one with a type hint to enforce their type.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 3 章*](B19528_03.xhtml#_idTextAnchor058)，*使用 FastAPI 开发 RESTful API* 中，你学习了如何使用
    Pydantic 定义数据模型的基础：你需要定义一个继承自 `BaseModel` 的类，并将所有字段列为类的属性，每个字段都有一个类型提示来强制其类型。
- en: In this section, we’ll focus on model definition and see all the possibilities
    we have for defining the fields.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将重点关注模型定义，并查看我们在定义字段时可以使用的所有可能性。
- en: Standard field types
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标准字段类型
- en: 'We’ll begin by defining fields with standard types, which only involve simple
    type hints. Let’s review a simple model representing information about a person.
    You can see this in the following code snippet:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从定义标准类型字段开始，这只涉及简单的类型提示。让我们回顾一下一个表示个人信息的简单模型。你可以在以下代码片段中看到它：
- en: chapter04_standard_field_types_01.py
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: chapter04_standard_field_types_01.py
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_standard_field_types_01.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_standard_field_types_01.py)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_standard_field_types_01.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_standard_field_types_01.py)'
- en: 'As we said, you just have to write the names of the fields and type-hint them
    with the intended type. Of course, we are not limited to scalar types: we can
    use compound types, such as lists and tuples, or classes such as datetime and
    enum. In the following example, you can see a model using those more complex types:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所说，你只需要写出字段的名称，并使用预期的类型对其进行类型提示。当然，我们不仅限于标量类型：我们还可以使用复合类型，如列表和元组，或像 datetime
    和 enum 这样的类。在下面的示例中，你可以看到一个使用这些更复杂类型的模型：
- en: chapter04_standard_field_types_02.py
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: chapter04_standard_field_types_02.py
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_standard_field_types_02.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_standard_field_types_02.py)'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_standard_field_types_02.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_standard_field_types_02.py)'
- en: There are three things to notice in this example.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中有三点需要注意。
- en: 'First, we used the standard Python `Enum` class as a type for the `gender`
    field. This allows us to specify a set of valid values. If we input a value that’s
    not in this enumeration, Pydantic will raise an error, as illustrated in the following
    example:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用标准 Python `Enum` 类作为 `gender` 字段的类型。这允许我们指定一组有效值。如果输入的值不在该枚举中，Pydantic
    会引发错误，如以下示例所示：
- en: chapter04_standard_field_types_02.py
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: chapter04_standard_field_types_02.py
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_standard_field_types_02.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_standard_field_types_02.py)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_standard_field_types_02.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_standard_field_types_02.py)'
- en: 'If you run the preceding example, you’ll get this output:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行前面的示例，你将得到如下输出：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Actually, this is exactly what we did in [*Chapter 3*](B19528_03.xhtml#_idTextAnchor058),
    *Developing a RESTful API with FastAPI*, to limit the allowed values of the `path`
    parameter.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这正是我们在[*第3章*](B19528_03.xhtml#_idTextAnchor058)《使用 FastAPI 开发 RESTful API》中所做的，用以限制
    `path` 参数的允许值。
- en: 'Then, we used the `date` Python class as a type for the `birthdate` field.
    Pydantic is able to automatically parse dates and times given as ISO format strings
    or timestamp integers and instantiate a proper `date` or `datetime` object. Of
    course, if the parsing fails, you’ll also get an error. You can experiment with
    this in the following example:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将 `date` Python 类作为 `birthdate` 字段的类型。Pydantic 能够自动解析以 ISO 格式字符串或时间戳整数给出的日期和时间，并实例化一个合适的
    `date` 或 `datetime` 对象。当然，如果解析失败，你也会得到一个错误。你可以在以下示例中进行实验：
- en: chapter04_standard_field_types_02.py
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: chapter04_standard_field_types_02.py
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_standard_field_types_02.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_standard_field_types_02.py)'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_standard_field_types_02.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_standard_field_types_02.py)'
- en: 'And here is the output:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出结果：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Finally, we defined `interests` as a list of strings. Once again, Pydantic will
    check whether the field is a valid list of strings.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将 `interests` 定义为一个字符串列表。同样，Pydantic 会检查该字段是否是有效的字符串列表。
- en: 'Obviously, if everything is okay, we get a `Person` instance and have access
    to the properly parsed fields. This is what we show in the following code snippet:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，如果一切正常，我们将得到一个 `Person` 实例，并能够访问正确解析的字段。这就是我们在以下代码片段中展示的内容：
- en: chapter04_standard_field_types_02.py
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: chapter04_standard_field_types_02.py
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_standard_field_types_02.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_standard_field_types_02.py)'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_standard_field_types_02.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_standard_field_types_02.py)'
- en: 'As you can see, this is quite powerful, and we can have quite complex field
    types. But that’s not all: *fields can be Pydantic models themselves*, allowing
    you to have sub-objects! In the following code example, we expand the previous
    snippet to add an `address` field:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这非常强大，我们可以拥有相当复杂的字段类型。但这还不是全部：*字段本身可以是 Pydantic 模型*，允许你拥有子对象！在以下代码示例中，我们扩展了前面的代码片段，添加了一个
    `address` 字段：
- en: chapter04_standard_field_types_03.py
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: chapter04_standard_field_types_03.py
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_standard_field_types_03.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_standard_field_types_03.py)'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_standard_field_types_03.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_standard_field_types_03.py)'
- en: We just have to define another Pydantic model and use it as a type hint. Now,
    you can either instantiate a `Person` instance with an already valid `Address`
    instance or, even better, with a dictionary. In this case, Pydantic will automatically
    parse it and validate it against the address model.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需定义另一个 Pydantic 模型，并将其作为类型提示使用。现在，你可以使用已经有效的`Address`实例来实例化`Person`，或者更好的是，使用字典。在这种情况下，Pydantic
    会自动解析它并根据地址模型进行验证。
- en: 'In the following code snippet, we try to input an invalid address:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码片段中，我们尝试输入一个无效的地址：
- en: chapter04_standard_field_types_03.py
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: chapter04_standard_field_types_03.py
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_standard_field_types_03.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_standard_field_types_03.py)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_standard_field_types_03.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_standard_field_types_03.py)'
- en: 'This will generate the following validation error:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成以下验证错误：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Pydantic clearly shows the missing field in the sub-object. Once again, if
    everything goes well, we get a `Person` instance and its associated `Address`,
    as you can see in the following extract:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Pydantic 清晰地显示了子对象中缺失的字段。再次强调，如果一切顺利，我们将获得一个`Person`实例及其关联的`Address`，如下面的代码片段所示：
- en: chapter04_standard_field_types_03.py
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: chapter04_standard_field_types_03.py
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_standard_field_types_03.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_standard_field_types_03.py)'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_standard_field_types_03.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_standard_field_types_03.py)'
- en: Optional fields and default values
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可选字段和默认值
- en: Up to now, we’ve assumed that each field had to be provided when instantiating
    the model. Quite often, however, there are values that we want to be optional
    because they may not be relevant to each object instance. Sometimes, we also wish
    to set a default value for a field when it’s not specified.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们假设在实例化模型时，每个字段都必须提供。然而，通常情况下，有些值我们希望是可选的，因为它们可能对每个对象实例并不相关。有时，我们还希望为未指定的字段设置默认值。
- en: 'As you may have guessed, this is done quite simply, with the `| None` typing
    annotation, as illustrated in the following code snippet:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能猜到的，这可以通过`| None`类型注解非常简单地完成，如以下代码片段所示：
- en: chapter04_optional_fields_default_values_01.py
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: chapter04_optional_fields_default_values_01.py
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_optional_fields_default_values_01.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_optional_fields_default_values_01.py)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_optional_fields_default_values_01.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_optional_fields_default_values_01.py)'
- en: When defining a field with the `| None` type hint, it accepts a `None` value.
    As you can see in the preceding code, the default value can be simply assigned
    by putting the value after an equals sign.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当定义一个字段时，使用`| None`类型提示，它接受`None`值。如上面的代码所示，默认值可以通过将值放在等号后面简单地赋值。
- en: 'Be careful, though: *don’t assign default values such as this for dynamic types*
    such as datetimes. If you do, the datetime instantiation will be evaluated only
    once when the model is imported. The effect of this is that all the objects you
    instantiate will then share the same value instead of having a fresh value. You
    can observe this behavior in the following example:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 但要小心：*不要为动态类型*（如日期时间）赋予默认值。如果这样做，日期时间实例化只会在模型导入时评估一次。这样一来，你实例化的所有对象都会共享相同的值，而不是每次都生成一个新的值。你可以在以下示例中观察到这种行为：
- en: chapter04_optional_fields_default_values_02.py
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: chapter04_optional_fields_default_values_02.py
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_optional_fields_default_values_02.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_optional_fields_default_values_02.py)'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_optional_fields_default_values_02.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_optional_fields_default_values_02.py)'
- en: Even though we waited for 1 second between the instantiation of `o1` and `o2`,
    the `d` datetime is the same! This means that the datetime is evaluated only once
    when the class is imported.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们在实例化`o1`和`o2`之间等待了1秒钟，`d`日期时间仍然是相同的！这意味着日期时间只在类被导入时评估一次。
- en: 'You can have the same kind of problem if you want to have a default list, such
    as `l: list[str] = ["a", "b", "c"]`. Notice that this is true for every Python
    object, not only Pydantic models, so you should bear this in mind.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '如果你想要一个默认的列表，比如`l: list[str] = ["a", "b", "c"]`，你也会遇到同样的问题。注意，这不仅仅适用于Pydantic模型，所有的Python对象都会存在这个问题，所以你应该牢记这一点。'
- en: So, how do we assign dynamic default values? Fortunately, Pydantic provides
    a `Field` function that allows us to set some advanced options on our fields,
    including one to set a factory for creating dynamic values. Before showing you
    this, we’ll first introduce the `Field` function.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们该如何赋予动态默认值呢？幸运的是，Pydantic提供了一个`Field`函数，允许我们为字段设置一些高级选项，其中包括为创建动态值设置工厂。在展示这个之前，我们首先会介绍一下`Field`函数。
- en: In [*Chapter 3*](B19528_03.xhtml#_idTextAnchor058), *Developing a RESTful API
    with FastAPI*, we showed how to apply some validation to the request parameters
    to check whether a number was in a certain range or whether a string matched a
    regular expression. Actually, these options directly come from Pydantic! We can
    use the same techniques to apply validation to the fields of a model.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第3章*](B19528_03.xhtml#_idTextAnchor058)《使用FastAPI开发RESTful API》中，我们展示了如何对请求参数应用一些验证，检查一个数字是否在某个范围内，或一个字符串是否匹配正则表达式。实际上，这些选项直接来自Pydantic！我们可以使用相同的技术对模型的字段进行验证。
- en: 'To do this, we’ll use the `Field` function from Pydantic and use its result
    as the default value of the field. In the following example, we define a `Person`
    model with the `first_name` and `last_name` required properties, which should
    be at least three characters long, and an optional `age` property, which should
    be an integer between `0` and `120`. We show the implementation of this model
    in the following code snippet:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们将使用Pydantic的`Field`函数，并将其结果作为字段的默认值。在下面的示例中，我们定义了一个`Person`模型，其中`first_name`和`last_name`是必填字段，必须至少包含三个字符，`age`是一个可选字段，必须是介于`0`和`120`之间的整数。我们在下面的代码片段中展示了该模型的实现：
- en: chapter04_fields_validation_01.py
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: chapter04_fields_validation_01.py
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_fields_validation_01.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_fields_validation_01.py)'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_fields_validation_01.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_fields_validation_01.py)'
- en: As you can see, the syntax is very similar to the one we saw for `Path`, `Query`,
    and `Body`. The first positional argument defines the *default value* for the
    field. If the field is required, we use an ellipsis, `...`. Then, the keyword
    arguments are there to set options for the field, including some basic validation.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，语法与我们之前看到的`Path`、`Query`和`Body`非常相似。第一个位置参数定义了字段的*默认值*。如果字段是必填的，我们使用省略号`...`。然后，关键字参数用于设置字段的选项，包括一些基本的验证。
- en: You can view a complete list of the arguments accepted by `Field` in the official
    Pydantic documentation, at [https://pydantic-docs.helpmanual.io/usage/schema/#field-customization](https://pydantic-docs.helpmanual.io/usage/schema/#field-customization).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在官方Pydantic文档中查看`Field`接受的所有参数的完整列表，网址为[https://pydantic-docs.helpmanual.io/usage/schema/#field-customization](https://pydantic-docs.helpmanual.io/usage/schema/#field-customization)。
- en: Dynamic default values
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动态默认值
- en: 'In the previous section, we warned you about setting dynamic values as defaults.
    Fortunately, Pydantic provides the `default_factory` argument on the `Field` function
    to cover this use case. This argument expects you to pass a function that will
    be called during model instantiation. Thus, the resulting object will be evaluated
    at runtime each time you create a new object. You can see how to use it in the
    following example:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们曾提醒你不要将动态值设置为默认值。幸运的是，Pydantic在`Field`函数中提供了`default_factory`参数来处理这种用例。这个参数要求你传递一个函数，这个函数将在模型实例化时被调用。因此，每次你创建一个新对象时，生成的对象将在运行时进行评估。你可以在以下示例中看到如何使用它：
- en: chapter04_fields_validation_02.py
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: chapter04_fields_validation_02.py
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_fields_validation_02.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_fields_validation_02.py)'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_fields_validation_02.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_fields_validation_02.py)'
- en: 'You simply have to pass a function to this argument. Don’t put arguments on
    it: it’ll be Pydantic that will automatically call the function for you when instantiating
    a new object. If you need to call a function with specific arguments, you’ll have
    to wrap it into your own function, as we did for `list_factory`.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需将一个函数传递给这个参数。不要在其上放置参数：当你实例化新对象时，Pydantic会自动调用这个函数。如果你需要使用特定的参数调用一个函数，你需要将它包装成自己的函数，正如我们为`list_factory`所做的那样。
- en: 'Notice also that the first positional argument used for the default value (such
    as `None` or `...`) is completely omitted here. This makes sense: it’s not consistent
    to have both a default value and a factory. Pydantic will raise an error if you
    set those two arguments together.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 还请注意，默认值所使用的第一个位置参数（如`None`或`...`）在这里完全省略了。这是有道理的：同时使用默认值和工厂是不一致的。如果你将这两个参数一起设置，Pydantic会抛出错误。
- en: Validating email addresses and URLs with Pydantic types
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Pydantic类型验证电子邮件地址和URL
- en: For convenience, Pydantic provides some classes to use as field types to validate
    some common patterns, such as email addresses or URLs.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便，Pydantic提供了一些类，可以作为字段类型来验证一些常见模式，例如电子邮件地址或URL。
- en: In the following example, we’ll use `EmailStr` and `HttpUrl` to validate an
    email address and an HTTP URL.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将使用`EmailStr`和`HttpUrl`来验证电子邮件地址和HTTP URL。
- en: 'For `EmailStr` to work, you’ll need an optional dependency, `email-validator`,
    which you can install with the following command:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 要使`EmailStr`工作，你需要一个可选的依赖项`email-validator`，你可以使用以下命令安装：
- en: '[PRE15]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Those classes work like any other type or class: just use them as a type hint
    for your field. You can see this in the following extract:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类的工作方式与其他类型或类相同：只需将它们作为字段的类型提示使用。你可以在以下代码片段中看到这一点：
- en: chapter04_pydantic_types_01.py
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: chapter04_pydantic_types_01.py
- en: '[PRE16]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_pydantic_types_01.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_pydantic_types_01.py)'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_pydantic_types_01.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_pydantic_types_01.py)'
- en: 'In the following example, we check that the email address is correctly validated:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们检查电子邮件地址是否被正确验证：
- en: chapter04_pydantic_types_01.py
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: chapter04_pydantic_types_01.py
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_pydantic_types_01.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_pydantic_types_01.py)'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_pydantic_types_01.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_pydantic_types_01.py)'
- en: 'You will see the following output:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到以下输出：
- en: '[PRE18]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We also check that the URL is correctly parsed, as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还检查了URL是否被正确解析，如下所示：
- en: chapter04_pydantic_types_01.py
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: chapter04_pydantic_types_01.py
- en: '[PRE19]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_pydantic_types_01.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_pydantic_types_01.py)'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_pydantic_types_01.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_pydantic_types_01.py)'
- en: 'You will see the following output:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到以下输出：
- en: '[PRE20]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If you have a look at a valid example, shown next, you’ll see that the URL
    is parsed into an object, giving you access to the different parts of it, such
    as the scheme or hostname:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看下面的有效示例，你会发现URL被解析为一个对象，这样你就可以访问它的不同部分，比如协议或主机名：
- en: chapter04_pydantic_types_01.py
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: chapter04_pydantic_types_01.py
- en: '[PRE21]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_pydantic_types_01.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_pydantic_types_01.py)'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_pydantic_types_01.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_pydantic_types_01.py)'
- en: Pydantic provides quite a big set of types that can help you in various situations.
    We invite you to review the full list of them in the official documentation at
    [https://pydantic-docs.helpmanual.io/usage/types/#pydantic-types](https://pydantic-docs.helpmanual.io/usage/types/#pydantic-types).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Pydantic提供了一套非常丰富的类型，可以帮助你处理各种情况。我们邀请你查阅官方文档中的完整列表：[https://pydantic-docs.helpmanual.io/usage/types/#pydantic-types](https://pydantic-docs.helpmanual.io/usage/types/#pydantic-types)。
- en: You now have a better idea of how to define your Pydantic models finely by using
    more advanced types or leveraging the validation features. As we said, those models
    are at the heart of FastAPI, and you’ll probably have to define several variations
    for the same entity to account for several situations. In the next section, we’ll
    show how to do that with minimum repetition.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你对如何通过使用更高级的类型或利用验证功能来细化定义Pydantic模型有了更清晰的了解。正如我们所说，这些模型是FastAPI的核心，你可能需要为同一个实体定义多个变体，以应对不同的情况。在接下来的部分中，我们将展示如何做到这一点，同时最小化重复。
- en: Creating model variations with class inheritance
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用类继承创建模型变体
- en: 'In [*Chapter 3*](B19528_03.xhtml#_idTextAnchor058), *Developing a RESTful API
    with FastAPI*, we saw a case where we needed to define two variations of a Pydantic
    model in order to split the data we want to store in the backend and the data
    we want to show to the user. This is a common pattern in FastAPI: you define one
    model for creation, one for the response, and one for the data to store in the
    database.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第3章*](B19528_03.xhtml#_idTextAnchor058)，*使用FastAPI开发RESTful API*中，我们看到一个例子，在这个例子中我们需要定义Pydantic模型的两个变体，以便将我们想要存储在后端的数据和我们想要展示给用户的数据分开。这是FastAPI中的一个常见模式：你定义一个用于创建的模型，一个用于响应的模型，以及一个用于存储在数据库中的数据模型。
- en: 'We show this basic approach in the following example:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在以下示例中展示了这种基本方法：
- en: chapter04_model_inheritance_01.py
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: chapter04_model_inheritance_01.py
- en: '[PRE22]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_model_inheritance_01.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_model_inheritance_01.py)'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_model_inheritance_01.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_model_inheritance_01.py)'
- en: 'We have three models here, covering three situations:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们有三个模型，涵盖了三种情况：
- en: '`PostCreate` will be used for a `POST` endpoint to create a new post. We expect
    the user to give the title and the content; however, the **identifier** (**ID**)
    will be automatically determined by the database.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PostCreate`将用于`POST`端点来创建新帖子。我们期望用户提供标题和内容；然而，**标识符**（**ID**）将由数据库自动确定。'
- en: '`PostRead` will be used when we retrieve the data of a post. We want its title
    and content, of course, but also its associated ID in the database.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PostRead`将用于我们检索帖子数据时。我们当然希望获取它的标题和内容，还希望知道它在数据库中的关联ID。'
- en: '`Post` will carry all the data we wish to store in the database. Here, we also
    want to store the number of views, but we want to keep this secret to make our
    own statistics internally.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Post` 将包含我们希望存储在数据库中的所有数据。在这里，我们还想存储查看次数，但希望将其保密，以便内部进行统计。'
- en: You can see here that we are repeating ourselves quite a lot, especially with
    the `title` and `content` fields. In bigger examples with lots of fields and lots
    of validation options, this could quickly become unmanageable.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到这里我们重复了很多，特别是 `title` 和 `content` 字段。在包含许多字段和验证选项的大型示例中，这可能会迅速变得难以管理。
- en: 'The way to avoid this is to leverage model inheritance. The approach is simple:
    identify the fields that are common to every variation and put them in a model,
    which will be used as a base for every other. Then, you only have to inherit from
    that model to create your variations and add the specific fields. In the following
    example, we see what our previous example looks like with this method:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 避免这种情况的方法是利用模型继承。方法很简单：找出每个变种中共有的字段，并将它们放入一个模型中，作为所有其他模型的基类。然后，你只需从这个模型继承来创建变体，并添加特定的字段。在以下示例中，我们可以看到使用这种方法后的结果：
- en: chapter04_model_inheritance_02.py
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: chapter04_model_inheritance_02.py
- en: '[PRE23]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_model_inheritance_02.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_model_inheritance_02.py)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_model_inheritance_02.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_model_inheritance_02.py)'
- en: Now, whenever you need to add a field for the whole entity, all you have to
    do is to add it to the `PostBase` model as shown in the following code snippet.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每当你需要为整个实体添加一个字段时，所需要做的就是将其添加到 `PostBase` 模型中，如下所示的代码片段所示。
- en: It’s also very convenient if you wish to define methods on your model. Remember
    that Pydantic models are regular Python classes, so you can implement as many
    methods as you wish!
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望在模型中定义方法，这也是非常方便的。记住，Pydantic 模型是普通的 Python 类，因此你可以根据需要实现尽可能多的方法！
- en: chapter04_model_inheritance_03.py
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: chapter04_model_inheritance_03.py
- en: '[PRE24]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_model_inheritance_03.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_model_inheritance_03.py)'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_model_inheritance_03.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_model_inheritance_03.py)'
- en: Defining the `excerpt` method on `PostBase` means it’ll be available in every
    model variation.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `PostBase` 中定义 `excerpt` 方法意味着它将会在每个模型变种中都可用。
- en: While it’s not strictly required, this inheritance approach greatly helps to
    prevent code duplication and, ultimately, bugs. We’ll see in the next section
    that it’ll make even more sense with custom validation methods.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种继承方法不是强制要求的，但它大大有助于防止代码重复，并最终减少错误。我们将在下一节看到，使用自定义验证方法时，它将显得更加有意义。
- en: Adding custom data validation with Pydantic
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Pydantic 添加自定义数据验证
- en: Up to now, we’ve seen how to apply basic validation to our models through `Field`
    arguments or the custom types provided by Pydantic. In a real-world project, though,
    you’ll probably need to add your own custom validation logic for your specific
    case. Pydantic allows this by defining **validators**, which are methods on the
    model that can be applied at the field level or the object level.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了如何通过 `Field` 参数或 Pydantic 提供的自定义类型为模型应用基本验证。然而，在一个实际项目中，你可能需要为特定情况添加自定义验证逻辑。Pydantic
    允许通过定义 **validators** 来实现这一点，验证方法可以应用于字段级别或对象级别。
- en: Applying validation at the field level
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在字段级别应用验证
- en: 'This is the most common case: having a validation rule for a single field.
    To define a validation rule in Pydantic, we just have to write a static method
    on our model and decorate it with the `validator` decorator. As a reminder, decorators
    are syntactic sugar, allowing the wrapping of a function or a class with common
    logic without compromising readability.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最常见的情况：为单个字段定义验证规则。要在 Pydantic 中定义验证规则，我们只需要在模型中编写一个静态方法，并用 `validator` 装饰器装饰它。作为提醒，装饰器是一种语法糖，它允许用通用逻辑包装函数或类，而不会影响可读性。
- en: 'The following example checks a birth date by verifying that the person is not
    more than 120 years old:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例检查出生日期，确保这个人不超过 120 岁：
- en: chapter04_custom_validation_01.py
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: chapter04_custom_validation_01.py
- en: '[PRE25]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_custom_validation_01.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_custom_validation_01.py)'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_custom_validation_01.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_custom_validation_01.py)'
- en: As you can see, `validator` is a static class method (the first argument, `cls`,
    is the class itself), with the `v` argument being the value to validate. It’s
    decorated by the `validator` decorator, which expects the name of the argument
    to validate to be its first argument.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`validator` 是一个静态类方法（第一个参数，`cls`，是类本身），`v` 参数是要验证的值。它由 `validator` 装饰器装饰，要求第一个参数是需要验证的参数的名称。
- en: 'Pydantic expects two things for this method, as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Pydantic 对此方法有两个要求，如下所示：
- en: If the value is not valid according to your logic, you should raise a `ValueError`
    error with an explicit error message.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果值根据你的逻辑不合法，你应该抛出一个 `ValueError` 错误并提供明确的错误信息。
- en: 'Otherwise, you should return the value that will be assigned to the model.
    Notice that it doesn’t need to be the same as the input value: you can easily
    change it to fit your needs. That’s actually what we’ll do in an upcoming section,
    *Applying validation before* *Pydantic parsing*.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，你应该返回将被赋值给模型的值。请注意，它不需要与输入值相同：你可以根据需要轻松地更改它。这实际上是我们将在接下来的章节中做的，*在 Pydantic
    解析之前应用验证*。
- en: Applying validation at the object level
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在对象级别应用验证
- en: 'Quite often, the validation of one field is dependent on another—for example,
    when checking whether a password confirmation matches the password or enforcing
    a field to be required in certain circumstances. To allow this kind of validation,
    we need to access the whole object data. To do this, Pydantic provides the `root_validator`
    decorator, which is illustrated in the following code example:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 很多时候，一个字段的验证依赖于另一个字段——例如，检查密码确认是否与密码匹配，或在某些情况下强制要求某个字段为必填项。为了允许这种验证，我们需要访问整个对象的数据。为此，Pydantic
    提供了 `root_validator` 装饰器，如下面的代码示例所示：
- en: chapter04_custom_validation_02.py
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: chapter04_custom_validation_02.py
- en: '[PRE26]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_custom_validation_02.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_custom_validation_02.py)'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_custom_validation_02.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_custom_validation_02.py)'
- en: The usage of this decorator is similar to the `validator` decorator. The static
    class method is called along with the `values` argument, which is a *dictionary*
    containing all the fields. Thus, you can retrieve each of them and implement your
    logic.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此装饰器的方法类似于 `validator` 装饰器。静态类方法与 `values` 参数一起调用，`values` 是一个 *字典*，包含所有字段。这样，你可以获取每个字段并实现你的逻辑。
- en: 'Once again, Pydantic expects two things for this method, as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，Pydantic 对此方法有两个要求，如下所示：
- en: If the values are not valid according to your logic, you should raise a `ValueError`
    error with an explicit error message.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果根据你的逻辑，值不合法，你应该抛出一个 `ValueError` 错误并提供明确的错误信息。
- en: Otherwise, you should return a `values` dictionary that will be assigned to
    the model. Notice that you can change some values in this dictionary to fit your
    needs.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，你应该返回一个 `values` 字典，这个字典将被赋值给模型。请注意，你可以根据需要在这个字典中修改某些值。
- en: Applying validation before Pydantic parsing
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Pydantic 解析之前应用验证
- en: By default, your validators are run after Pydantic has done its parsing work.
    This means that the value you get already conforms to the type of field you specified.
    If the type is incorrect, Pydantic raises an error without calling your validator.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，验证器在 Pydantic 完成解析工作之后运行。这意味着你得到的值已经符合你指定的字段类型。如果类型不正确，Pydantic 会抛出错误，而不会调用你的验证器。
- en: 'However, you may sometimes wish to provide some custom parsing logic that allows
    you to transform input values that would have been incorrect for the type you
    set. In that case, you would need to run your validator before the Pydantic parser:
    this is the purpose of the `pre` argument on `validator`.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时你可能希望提供一些自定义解析逻辑，以允许你转换那些对于所设置类型来说原本不正确的输入值。在这种情况下，你需要在 Pydantic 解析器之前运行你的验证器：这就是
    `validator` 中 `pre` 参数的作用。
- en: 'In the following example, we show how to transform a string with values separated
    by commas into a list:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们展示了如何将一个由逗号分隔的字符串转换为列表：
- en: chapter04_custom_validation_03.py
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: chapter04_custom_validation_03.py
- en: '[PRE27]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_custom_validation_03.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_custom_validation_03.py)'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_custom_validation_03.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_custom_validation_03.py)'
- en: You can see here that our validator first checks whether we have a string. If
    we do, we split the comma-separated string and return the resulting list; otherwise,
    we directly return the value. Pydantic will run its parsing logic afterward, so
    you can still be sure that an error will be raised if `v` is an invalid value.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，在这里我们的验证器首先检查我们是否有一个字符串。如果有，我们将逗号分隔的字符串进行拆分，并返回结果列表；否则，我们直接返回该值。Pydantic
    随后会运行它的解析逻辑，因此你仍然可以确保如果 `v` 是无效值，会抛出错误。
- en: Working with Pydantic objects
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Pydantic 对象
- en: When developing API endpoints with FastAPI, you’ll probably get a lot of Pydantic
    model instances to handle. It’s then up to you to implement the logic to make
    a link between those objects and your services, such as your database or your
    machine learning model. Fortunately, Pydantic provides methods that make this
    very easy. We’ll review common use cases that will be useful for you during development.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 FastAPI 开发 API 接口时，你可能会处理大量的 Pydantic 模型实例。接下来，你需要实现逻辑，将这些对象与服务进行连接，比如数据库或机器学习模型。幸运的是，Pydantic
    提供了一些方法，使得这个过程变得非常简单。我们将回顾一些开发过程中常用的使用场景。
- en: Converting an object into a dictionary
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将对象转换为字典
- en: 'This is probably the action you’ll perform the most on a Pydantic object: convert
    it into a raw dictionary that’ll be easy to send to another API or use in a database,
    for example. You just have to call the `dict` method on the object instance.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是你在 Pydantic 对象上执行最多的操作：将其转换为一个原始字典，这样你就可以轻松地将其发送到另一个 API，或者例如用在数据库中。你只需在对象实例上调用
    `dict` 方法。
- en: 'The following example reuses the `Person` and `Address` models we saw in the
    *Standard field types* section of this chapter:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例重用了我们在本章的*标准字段类型*部分看到的 `Person` 和 `Address` 模型：
- en: chapter04_working_pydantic_objects_01.py
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: chapter04_working_pydantic_objects_01.py
- en: '[PRE28]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_working_pydantic_objects_01.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_working_pydantic_objects_01.py)'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_working_pydantic_objects_01.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_working_pydantic_objects_01.py)'
- en: 'As you can see, calling `dict` is enough to transform the whole data into a
    dictionary. Sub-objects are also recursively converted: the `address` key points
    to a dictionary with the address properties.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，调用 `dict` 就足以将所有数据转换为字典。子对象也会递归地被转换：`address` 键指向一个包含地址属性的字典。
- en: 'Interestingly, the `dict` method supports some arguments, allowing you to select
    a subset of properties to be converted. You can either state the ones you want
    to be included or the ones you want to exclude, as you can see in the following
    snippet:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，`dict` 方法支持一些参数，允许你选择要转换的属性子集。你可以指定你希望包括的属性，或者希望排除的属性，正如下面的代码片段所示：
- en: chapter04_working_pydantic_objects_02.py
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: chapter04_working_pydantic_objects_02.py
- en: '[PRE29]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_working_pydantic_objects_02.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_working_pydantic_objects_02.py)'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_working_pydantic_objects_02.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_working_pydantic_objects_02.py)'
- en: The `include` and `exclude` arguments expect a set with the keys of the fields
    you want to include or exclude.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`include` 和 `exclude` 参数期望一个集合，集合中包含你希望包含或排除的字段的键。'
- en: 'For nested structures such as `address`, you can also use a dictionary to specify
    which sub-field you want to include or exclude, as illustrated in the following
    example:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 对于像 `address` 这样的嵌套结构，你也可以使用字典来指定要包含或排除的子字段，以下示例演示了这一点：
- en: chapter04_working_pydantic_objects_02.py
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: chapter04_working_pydantic_objects_02.py
- en: '[PRE30]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_working_pydantic_objects_02.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_working_pydantic_objects_02.py)'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_working_pydantic_objects_02.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_working_pydantic_objects_02.py)'
- en: The resulting `address` dictionary only contains the city and the country. Notice
    that when using this syntax, scalar fields such as `first_name` and `last_name`
    have to be associated with the ellipsis, `...`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 结果的 `address` 字典仅包含城市和国家。请注意，当使用这种语法时，像 `first_name` 和 `last_name` 这样的标量字段必须与省略号
    `...` 一起使用。
- en: 'If you use a conversion quite often, it can be useful to put it in a method
    so that you can reuse it at will, as illustrated in the following example:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你经常进行某种转换，将其放入一个方法中以便于随时重用是很有用的，以下示例演示了这一点：
- en: chapter04_working_pydantic_objects_03.py
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: chapter04_working_pydantic_objects_03.py
- en: '[PRE31]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_working_pydantic_objects_03.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_working_pydantic_objects_03.py)'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_working_pydantic_objects_03.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_working_pydantic_objects_03.py)'
- en: Creating an instance from a sub-class object
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从子类对象创建实例
- en: In the *Creating model variations with class inheritance* section, we studied
    the common pattern of having specific model classes, depending on the situation.
    In particular, you’ll have a model dedicated to the creation endpoint, with only
    the required fields for creation, and a database model with all the fields we
    want to store.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *通过类继承创建模型变体* 这一节中，我们研究了根据具体情况创建特定模型类的常见模式。特别地，你会有一个专门用于创建端点的模型，其中只有创建所需的字段，以及一个包含我们想要存储的所有字段的数据库模型。
- en: 'Let’s look at the `Post` example again:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再看一下 `Post` 示例：
- en: chapter04_working_pydantic_objects_04.py
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: chapter04_working_pydantic_objects_04.py
- en: '[PRE32]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_working_pydantic_objects_04.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_working_pydantic_objects_04.py)'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_working_pydantic_objects_04.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_working_pydantic_objects_04.py)'
- en: Suppose we have an API that creates endpoints. In this context, we would get
    a `PostCreate` instance with only `title` and `content`. However, we need to build
    a proper `Post` instance before storing it in the database.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个创建端点的 API。在这种情况下，我们会得到一个只有 `title` 和 `content` 的 `PostCreate` 实例。然而，在将其存储到数据库之前，我们需要构建一个适当的
    `Post` 实例。
- en: 'A convenient way to do this is to jointly use the `dict` method and the unpacking
    syntax. In the following example, we implemented a creation endpoint using this
    approach:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 一种方便的做法是同时使用 `dict` 方法和解包语法。在以下示例中，我们使用这种方法实现了一个创建端点：
- en: chapter04_working_pydantic_objects_04.py
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: chapter04_working_pydantic_objects_04.py
- en: '[PRE33]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_working_pydantic_objects_04.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_working_pydantic_objects_04.py)'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_working_pydantic_objects_04.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_working_pydantic_objects_04.py)'
- en: As you can see, the path operation function gives us a valid `PostCreate` object.
    Then, we want to transform it into a `Post` object.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，路径操作函数为我们提供了一个有效的`PostCreate`对象。然后，我们想将其转换为`Post`对象。
- en: We first determine the missing `id` property, which is given to us by the database.
    Here, we use a dummy database based on a dictionary, so we simply take the highest
    key that’s already present in the database and increment it. In a real-world situation,
    this would have been automatically determined by the database.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先确定缺失的`id`属性，这是由数据库提供的。在这里，我们使用基于字典的虚拟数据库，因此我们只需取数据库中已存在的最大键并将其递增。在实际情况下，这个值会由数据库自动确定。
- en: 'The most interesting line here is the `Post` instantiation. You can see that
    we first assign the missing fields using keyword arguments and then unpack the
    dictionary representation of `post_create`. As a reminder, the effect of `**`
    in a function call is to transform a dictionary such as `{"title": "Foo", "content":
    "Bar"}` into keyword arguments such as this: `title="Foo", content="Bar"`. It’s
    a very convenient and dynamic approach to set all the fields we already have into
    our new model.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '这里最有趣的一行是`Post`实例化。你可以看到，我们首先使用关键字参数分配缺失的字段，然后解包`post_create`的字典表示。提醒一下，`**`在函数调用中的作用是将像`{"title":
    "Foo", "content": "Bar"}`这样的字典转换为像`title="Foo", content="Bar"`这样的关键字参数。这是一种非常方便和动态的方式，将我们已有的所有字段设置到新的模型中。'
- en: Notice that we also set the `response_model` argument on the path operation
    decorator. We explained this in [*Chapter 3*](B19528_03.xhtml#_idTextAnchor058),
    *Developing a RESTful API with FastAPI*, but basically, it prompts FastAPI to
    build a JSON response with only the fields of `PostRead`, even though we return
    a `Post` instance at the end of the function.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们还在路径操作装饰器中设置了`response_model`参数。我们在[*第3章*](B19528_03.xhtml#_idTextAnchor058)，*使用FastAPI开发RESTful
    API*中解释了这一点，但基本上，它提示FastAPI构建一个只包含`PostRead`字段的JSON响应，即使我们最终返回的是一个`Post`实例。
- en: Updating an instance partially
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部分更新实例
- en: In some situations, you’ll want to allow partial updates. In other words, you’ll
    allow the end user to only send the fields they want to change to your API and
    omit the ones that shouldn’t change. This is the usual way of implementing a `PATCH`
    endpoint.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，你可能需要允许部分更新。换句话说，你允许最终用户仅向你的API发送他们想要更改的字段，并省略不需要更改的字段。这是实现`PATCH`端点的常见方式。
- en: 'To do this, you would first need a special Pydantic model with all the fields
    marked as optional so that no error is raised when a field is missing. Let’s see
    what this looks like with our `Post` example, as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，你首先需要一个特殊的Pydantic模型，所有字段都标记为可选，这样在缺少某个字段时不会引发错误。让我们看看在我们的`Post`示例中这是什么样的：
- en: chapter04_working_pydantic_objects_05.py
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: chapter04_working_pydantic_objects_05.py
- en: '[PRE34]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_working_pydantic_objects_05.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_working_pydantic_objects_05.py)'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_working_pydantic_objects_05.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_working_pydantic_objects_05.py)'
- en: We are now able to implement an endpoint that will accept a subset of our `Post`
    fields. Since it’s an update, we’ll retrieve an existing post in the database
    thanks to its ID. Then, we’ll have to find a way to only update the fields in
    the payload and keep the others untouched. Fortunately, Pydantic once again has
    this covered, with handy methods and options.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在能够实现一个端点，接受`Post`字段的子集。由于这是一个更新操作，我们将通过其ID从数据库中检索现有的帖子。然后，我们需要找到一种方法，只更新负载中的字段，保持其他字段不变。幸运的是，Pydantic再次提供了便捷的方法和选项来解决这个问题。
- en: 'Let’s see how the implementation of such an endpoint could look in the following
    example:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在以下示例中实现这样的端点：
- en: chapter04_working_pydantic_objects_05.py
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: chapter04_working_pydantic_objects_05.py
- en: '[PRE35]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_working_pydantic_objects_05.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_working_pydantic_objects_05.py)'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_working_pydantic_objects_05.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter04/chapter04_working_pydantic_objects_05.py)'
- en: 'Our path operation function takes two arguments: the `id` property (from the
    path) and a `PostPartialUpdate` instance (from the body).'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的路径操作函数接受两个参数：`id`属性（来自路径）和`PostPartialUpdate`实例（来自请求体）。
- en: The first thing to do is to check whether this `id` property exists in the database.
    Since we use a dictionary for our dummy database, accessing a key that doesn’t
    exist will raise a `KeyError`. If this happens, we simply raise an `HTTPException`
    with the `404` status code.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要做的是检查这个`id`属性是否存在于数据库中。由于我们使用字典作为虚拟数据库，访问一个不存在的键会引发`KeyError`。如果发生这种情况，我们只需抛出一个`HTTPException`并返回`404`状态码。
- en: 'Now for the interesting part: updating an existing object. You can see that
    the first thing to do is transform `PostPartialUpdate` into a dictionary with
    the `dict` method. This time, however, we set the `exclude_unset` argument to
    `True`. The effect of this is that *Pydantic won’t output the fields that were
    not provided* in the resulting dictionary: we only get the fields that the user
    sent in the payload.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是有趣的部分：更新现有对象。你可以看到，首先要做的是使用`dict`方法将`PostPartialUpdate`转换为字典。然而，这次我们将`exclude_unset`参数设置为`True`。这样做的效果是，*Pydantic不会在结果字典中输出未提供的字段*：我们只会得到用户在有效负载中发送的字段。
- en: 'Then, on our existing `post_db` database instance, we call the `copy` method.
    This is a useful method for cloning a Pydantic object into another instance. The
    nice thing about this method is that it even accepts an `update` argument. This
    argument expects a dictionary with all the fields that should be updated during
    the copy: that’s exactly what we want to do with our `updated_fields` dictionary!'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在我们现有的`post_db`数据库实例上，调用`copy`方法。这个方法是克隆Pydantic对象到另一个实例的一个有用方法。这个方法的好处在于它甚至接受一个`update`参数。这个参数期望一个字典，包含所有在复制过程中应该更新的字段：这正是我们想用`updated_fields`字典来做的！
- en: And that’s it! We now have an updated `post` instance with only the changes
    required in the payload. You’ll probably use the `exclude_unset` argument and
    the `copy` method quite often while developing with FastAPI, so be sure to keep
    them in mind — they’ll make your life easier!
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！我们现在有了一个更新过的`post`实例，只有在有效负载中需要的更改。你在使用FastAPI开发时，可能会经常使用`exclude_unset`参数和`copy`方法，所以一定要记住它们——它们会让你的工作更轻松！
- en: Summary
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'Congratulations! You’ve learned about another important aspect of FastAPI:
    designing and managing data models with Pydantic. You should now be confident
    about creating models and applying validation at the field level, with built-in
    options and types, and also by implementing your own validation methods. You also
    know how to apply validation at the object level to check consistency between
    several fields. You also learned how to leverage model inheritance to prevent
    code duplication and repetition while defining your model variations. Finally,
    you learned how to correctly work with Pydantic model instances in order to transform
    and update them in an efficient and readable way.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你！你已经学习了FastAPI的另一个重要方面：使用Pydantic设计和管理数据模型。现在，你应该对创建模型、应用字段级验证、使用内建选项和类型，以及实现你自己的验证方法有信心。你还了解了如何在对象级别应用验证，检查多个字段之间的一致性。你还学会了如何利用模型继承来避免在定义模型变体时出现代码重复。最后，你学会了如何正确处理Pydantic模型实例，从而以高效且可读的方式进行转换和更新。
- en: 'You know almost all the features of FastAPI by now. There is one last very
    powerful feature for you to learn about: **dependency injection**. This allows
    you to define your own logic and values and directly inject them into your path
    operation functions, as you do for path parameters and payload objects, which
    you’ll be able to reuse everywhere in your project. That’s the subject of the
    next chapter.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你几乎已经掌握了FastAPI的所有功能。现在有一个最后非常强大的功能等着你去学习：**依赖注入**。这允许你定义自己的逻辑和数值，并将它们直接注入到路径操作函数中，就像你对路径参数和有效负载对象所做的那样，你可以在项目的任何地方重用它们。这是下一章的内容。
