- en: Selecting Subsets of Data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择数据的子集
- en: Every dimension of data in a Series or DataFrame is labeled through an Index
    object. It is this Index that separates pandas data structures from NumPy's n-dimensional
    array. Indexes provide meaningful labels for each row and column of data, and
    pandas users have the ability to select data through the use of these labels.
    Additionally, pandas allow its users to select data by the integer location of
    the rows and columns. This dual selection capability, one using labels and the
    other using integer location, makes for powerful yet confusing syntax to select
    subsets of data.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Series 或 DataFrame 中的每个数据维度都通过一个索引对象进行标记。正是这个索引将 pandas 数据结构与 NumPy 的 n 维数组区分开来。索引为每一行和每一列的数据提供有意义的标签，pandas
    用户可以通过使用这些标签来选择数据。此外，pandas 还允许用户通过行列的整数位置来选择数据。这种同时支持标签选择和整数位置选择的功能，使得选择数据子集的语法既强大又令人困惑。
- en: Selecting data through the use of labels or integer location is not unique to
    pandas. Python dictionaries and lists are built-in data structures that select
    their data in exactly one of these ways. Both dictionaries and lists have precise
    instructions and limited use-cases for what may be passed to the indexing operator.
    A dictionary's key (its label) must be an immutable object, such as a string,
    integer, or tuple. Lists must either use integers or slice objects for selection.
    Dictionaries can only select one object at a time by passing the key to the indexing
    operator. In some sense, pandas is combining the ability to select data using
    integers, as with lists, and labels, as with dictionaries.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 通过标签或整数位置选择数据并非 pandas 独有。Python 字典和列表是内建的数据结构，它们的选择方式正好是这两种方式之一。字典和列表都有明确的使用说明，并且其索引运算符的使用场景有限。字典的键（即标签）必须是不可变对象，例如字符串、整数或元组。列表必须使用整数或切片对象来进行选择。字典只能通过传递键来一次选择一个对象。从某种意义上讲，pandas
    将使用整数选择数据的能力（类似于列表）和使用标签选择数据的能力（类似于字典）结合在一起。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: Selecting Series data
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择 Series 数据
- en: Selecting DataFrame rows
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择 DataFrame 的行
- en: Selecting DataFrame rows and columns simultaneously
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同时选择 DataFrame 的行和列
- en: Selecting data with both integers and labels
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用整数和标签选择数据
- en: Speeding up scalar selection
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加速标量选择
- en: Slicing rows lazily
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 懒惰地切片行
- en: Slicing lexicographically
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按字典序切片
- en: Selecting Series data
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择 Series 数据
- en: Series and DataFrames are complex data containers that have multiple attributes
    that use the indexing operator to select data in different ways. In addition to
    the indexing operator itself, the `.iloc` and `.loc` attributes are available
    and use the indexing operator in their own unique ways. Collectively, these attributes
    are called the **indexers**.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Series 和 DataFrame 是复杂的数据容器，具有多个属性，使用索引运算符可以以不同的方式选择数据。除了索引运算符本身，`.iloc` 和 `.loc`
    属性也可以使用索引运算符以各自独特的方式进行数据选择。统称这些属性为**索引器**。
- en: 'The indexing terminology can get confusing. The term **indexing operator**
    is used here to distinguish it from the other indexers. It refers to the brackets,
    `[]` directly after a Series or DataFrame. For instance, given a Series `s`, you
    can select data in the following ways: `s[item]` and `s.loc[item]`. The first
    uses the indexing operator. The second uses the `.loc` indexer.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 索引术语可能会让人感到困惑。这里使用**索引运算符**一词，是为了与其他索引器区分开来。它指的是 Series 或 DataFrame 后面的括号 `[]`。例如，给定一个
    Series `s`，你可以通过以下方式选择数据：`s[item]` 和 `s.loc[item]`。第一个使用的是索引运算符，第二个使用的是 `.loc`
    索引器。
- en: Series and DataFrame indexers allow selection by integer location (like Python
    lists) and by label (like Python dictionaries). The `.iloc` indexer selects only
    by integer location and works similarly to Python lists. The `.loc` indexer selects
    only by index label, which is similar to how Python dictionaries work.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Series 和 DataFrame 的索引器允许通过整数位置（类似于 Python 列表）和标签（类似于 Python 字典）进行选择。`.iloc`
    索引器仅按整数位置进行选择，使用方式类似于 Python 列表。`.loc` 索引器仅按索引标签进行选择，类似于 Python 字典的工作方式。
- en: Getting ready
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Both `.loc` and .`iloc` work with Series and DataFrames. This recipe shows how
    to select Series data by integer location with `.iloc` and by label with `.loc`. These
    indexers not only take scalar values but also lists and slices.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`.loc` 和 `.iloc` 都可以与 Series 和 DataFrame 一起使用。这个示例展示了如何使用 `.iloc` 按整数位置选择 Series
    数据，以及如何使用 `.loc` 按标签选择数据。这些索引器不仅可以接受标量值，还可以接受列表和切片。'
- en: How to do it...
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Read in the college dataset with the institution name as the index, and select
    a single column as a Series with the indexing operator:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用学校数据集，设定机构名称为索引，并使用索引操作符选择单一列作为 Series：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `.iloc` indexer makes selections only by integer location. Passing an integer
    to it returns a scalar value:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`.iloc` 索引器仅通过整数位置进行选择。传递一个整数给它将返回一个标量值：'
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To select several different integer locations, pass a list to `.iloc`. This
    returns a Series:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要选择多个不同的整数位置，将一个列表传递给 `.iloc`。这将返回一个 Series：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To select an equally spaced partition of data, use slice notation:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要选择一个等距分布的数据分区，使用切片符号：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now we turn to the `.loc` indexer, which selects only with index labels. Passing
    a single string returns a scalar value:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们转向 `.loc` 索引器，它仅通过索引标签进行选择。传递一个字符串将返回一个标量值：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To select several disjoint labels, use a list:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要选择多个不连续的标签，使用列表：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To select an equally spaced partition of data, use slice notation. Make sure
    that the start and stop values are strings. You can use an integer to specify
    the step size of the slice:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要选择一个等距分布的数据分区，使用切片符号。确保 `start` 和 `stop` 值为字符串。可以使用整数来指定切片的步长：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: How it works...
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The values in a Series are referenced by integers beginning from 0\. Step 2
    selects the fourth element of the Series with the `.loc` indexer. Step 3 passes
    a three-item integer list to the indexing operator, which returns a Series with
    those integer locations selected. This feature is an enhancement over a Python
    list, which is incapable of selecting multiple disjoint items in this manner.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Series 中的值通过从 0 开始的整数引用。第 2 步使用 `.loc` 索引器选择 Series 的第四个元素。第 3 步将一个包含三个整数的列表传递给索引操作符，返回一个选择了这些整数位置的
    Series。这个功能是对 Python 列表的一种增强，因为 Python 列表无法以这种方式选择多个不连续的项。
- en: In step 4, slice notation with `start`, `stop`, and `step` values specified
    is used to select an entire section of a Series.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 4 步中，使用 `start`、`stop` 和 `step` 指定的切片符号选择 Series 的整个部分。
- en: Steps 5 through 7 replicate steps 2 through 4 with the label-based indexer,
    `.loc`.  The labels must be exact matches of values in the index. To ensure our
    labels are exact, we choose four labels at random from the index in step 6 and
    store them to a list before selecting their values as a Series. Selections with
    the `.loc` indexer always include the last element, as seen in step 7.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 第 5 步到第 7 步是使用基于标签的索引器 `.loc` 重复第 2 步到第 4 步的操作。标签必须与索引中的值完全匹配。为了确保标签完全匹配，我们在第
    6 步从索引中随机选择四个标签，并将它们存储到一个列表中，然后选择它们的值作为 Series。使用 `.loc` 索引器的选择总是包含最后一个元素，正如第
    7 步所示。
- en: There's more...
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: 'When passing a scalar value to the indexing operator, as with step 2 and step
    5, a scalar value is returned. When passing a list or slice, as in the other steps,
    a Series is returned. This returned value might seem inconsistent, but if we think
    of a Series as a dictionary-like object that maps labels to values, then returning
    the value makes sense. To select a single item and retain the item in its Series,
    pass in as a single-item list rather than a scalar value:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当将标量值传递给索引操作符时，如第 2 步和第 5 步所示，将返回一个标量值。当传递一个列表或切片时，如其他步骤所示，将返回一个 Series。这个返回值可能看起来不一致，但如果我们将
    Series 看作一个类似字典的对象，它将标签映射到值，那么返回值就有意义了。为了选择一个单独的项目并保留它在 Series 中，传递一个单项列表而不是标量值：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Care needs to be taken when using slice notation with `.loc`. If the `start`
    index appears after the `stop` index, then an empty Series is returned without
    an exception raised:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `.loc` 时需要小心切片符号。如果 `start` 索引出现在 `stop` 索引之后，那么会返回一个空的 Series，且不会抛出异常：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: See also
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: Pandas official documentation on indexing ([http://bit.ly/2fdtZWu](http://pandas.pydata.org/pandas-docs/stable/indexing.html))
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pandas 官方文档关于索引的内容（[http://bit.ly/2fdtZWu](http://pandas.pydata.org/pandas-docs/stable/indexing.html)）
- en: Selecting DataFrame rows
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择 DataFrame 行
- en: The most explicit and preferred way to select DataFrame rows is with the `.iloc`
    and `.loc` indexers. They are capable of selecting rows or columns independently
    and simultaneously.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 选择 DataFrame 行的最明确和推荐的方式是使用 `.iloc` 和 `.loc` 索引器。它们能够独立且同时选择行或列。
- en: Getting ready
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe shows you how to select rows from a DataFrame using the `.iloc`
    and `.loc` indexers.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这个教程展示了如何使用 `.iloc` 和 `.loc` 索引器从 DataFrame 中选择行。
- en: How to do it...
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'Read in the college dataset, and set the index as the institution name:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取学校数据集，并设置索引为机构名称：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '![](img/094f0eeb-dab6-43fd-8153-7542c88c2be8.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/094f0eeb-dab6-43fd-8153-7542c88c2be8.png)'
- en: 'Pass an integer to the `.iloc` indexer to select an entire row at that position:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向 `.iloc` 索引器传递一个整数，选择该位置的整行：
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To get the same row as the preceding step, pass the index label to the `.loc`
    indexer:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要获取与前一步相同的行，请将索引标签传递给 `.loc` 索引器：
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To select a disjointed set of rows as a DataFrame, pass a list of integers
    to the `.iloc` indexer:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 若要选择不连续的行作为 DataFrame，可以将整数列表传递给 `.iloc` 索引器：
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '![](img/e7daa02f-de1a-4925-99c9-a5c5df191793.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e7daa02f-de1a-4925-99c9-a5c5df191793.png)'
- en: 'The same DataFrame from step 4 may be reproduced using `.loc` by passing it
    a list of the exact institution names:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以通过将精确的机构名称列表传递给 `.loc`，重新生成第 4 步中的同一 DataFrame：
- en: '[PRE13]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Use slice notation with `.iloc` to select an entire segment of the data:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `.iloc` 的切片表示法选择数据的整个区段：
- en: '[PRE14]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '![](img/5dd7c6d4-8c2c-4e8d-898e-41d876967360.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5dd7c6d4-8c2c-4e8d-898e-41d876967360.png)'
- en: 'Slice notation also works with the `.loc` indexer and is inclusive of the last
    label:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切片表示法也适用于 `.loc` 索引器，并且包括最后一个标签：
- en: '[PRE15]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: How it works...
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Passing a scalar value, a list of scalars, or a slice object to the `.iloc`
    or `.loc` indexers causes pandas to scan the index labels for the appropriate
    rows and return them. If a single scalar value is passed, a Series is returned.
    If a list or slice object is passed, then a DataFrame is returned.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 将标量值、标量列表或切片对象传递给 `.iloc` 或 `.loc` 索引器，会导致 pandas 扫描索引标签，返回相应的行。如果传递的是单一的标量值，则返回一个
    Series。如果传递的是列表或切片对象，则返回一个 DataFrame。
- en: There's more...
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: 'In step 5, the list of index labels can be selected directly from the DataFrame
    returned in step 4 without the need for copying and pasting:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 5 步中，可以直接从第 4 步返回的 DataFrame 中选择索引标签列表，而无需复制和粘贴：
- en: '[PRE16]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: See also
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另见
- en: Refer to the *Examining the Index object* recipe from [Chapter 12](a5777e1a-6de5-44f6-b291-429cbceb505f.xhtml),
    *Index Alignment.*
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参考 [第 12 章](a5777e1a-6de5-44f6-b291-429cbceb505f.xhtml)中的 *检查 Index 对象*，*索引对齐*。
- en: Selecting DataFrame rows and columns simultaneously
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同时选择 DataFrame 的行和列
- en: Directly using the indexing operator is the correct method to select one or
    more columns from a DataFrame. However, it does not allow you to select both rows
    and columns simultaneously. To select rows and columns simultaneously, you will
    need to pass both valid row and column selections separated by a comma to either
    the `.iloc` or `.loc` indexers.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 直接使用索引操作符是选择一个或多个列的正确方法。然而，它不允许同时选择行和列。要同时选择行和列，你需要通过逗号分隔有效的行选择和列选择，传递给 `.iloc`
    或 `.loc` 索引器。
- en: Getting ready
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The generic form to select rows and columns will look like the following code:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 选择行和列的通用形式如下所示：
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `rows` and `columns` variables may be scalar values, lists, slice objects,
    or boolean sequences.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`rows` 和 `columns` 变量可以是标量值、列表、切片对象或布尔序列。'
- en: Passing a boolean sequence to the indexers is covered in [Chapter 11](9f721370-ae04-4425-aab9-d525335b96b3.xhtml),
    *Boolean Indexing*.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 向索引器传递布尔序列的内容，请参阅 [第 11 章](9f721370-ae04-4425-aab9-d525335b96b3.xhtml)，*布尔索引*。
- en: In this recipe, each step shows a simultaneous row and column selection using
    `.iloc` and its exact replication using `.loc`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在本步骤中，每个步骤展示了使用 `.iloc` 同时选择行和列，并使用 `.loc` 完全复现这一操作。
- en: How to do it...
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Read in the college dataset, and set the index as the institution name. Select
    the first three rows and the first four columns with slice notation:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取大学数据集，并将索引设置为机构名称。使用切片表示法选择前 3 行和前 4 列：
- en: '[PRE18]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '![](img/791eb470-4192-49a3-9429-1f9223b2eb6b.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/791eb470-4192-49a3-9429-1f9223b2eb6b.png)'
- en: 'Select all the rows of two different columns:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择两个不同列的所有行：
- en: '[PRE19]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '![](img/f80c5155-bf61-4a4a-970d-84ab736b3d2d.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f80c5155-bf61-4a4a-970d-84ab736b3d2d.png)'
- en: 'Select disjointed rows and columns:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择不连续的行和列：
- en: '[PRE20]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '![](img/08e1066e-11d4-4eac-9fbd-799884602e5f.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](img/08e1066e-11d4-4eac-9fbd-799884602e5f.png)'
- en: 'Select a single scalar value:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个单一的标量值：
- en: '[PRE21]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Slice the rows and select a single column:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切片行并选择单列：
- en: '[PRE22]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: How it works...
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: One of the keys to selecting rows and columns simultaneously is to understand
    the use of the comma in the brackets. The selection to the left of the comma always
    selects rows based on the row index. The selection to the right of the comma always
    selects columns based on the column index.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 同时选择行和列的一个关键是理解括号中逗号的使用。逗号左边的选择始终基于行索引选择行，逗号右边的选择始终基于列索引选择列。
- en: It is not necessary to make a selection for both rows and columns simultaneously.
    Step 2 shows how to select all the rows and a subset of columns. The colon represents
    a slice object that simply returns all the values for that dimension.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 并不一定需要同时选择行和列。第2步展示了如何选择所有行以及部分列。冒号表示一个切片对象，它只是返回该维度的所有值。
- en: There's more...
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: 'When selecting a subset of rows, along with all the columns, it is not necessary
    to use a colon following a comma. The default behavior is to select all the columns
    if there is no comma present. The previous recipe selected rows in exactly this
    manner. You can, however, use a colon to represent a slice of all the columns.
    The following lines of code are equivalent:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当选择部分行，同时包含所有列时，不需要在逗号后面使用冒号。如果没有逗号，默认行为是选择所有列。前面的例子就是以这种方式选择行的。你当然可以使用冒号来表示所有列的切片。以下代码是等效的：
- en: '[PRE23]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Selecting data with both integers and labels
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用整数和标签同时选择数据
- en: The `.iloc` and `.loc` indexers each select data by either integer or label
    location but are not able to handle a combination of both input types at the same
    time. In earlier versions of pandas, another indexer, `.ix`, was available to
    select data by both integer and label location. While this conveniently worked
    for those specific situations, it was ambiguous by nature and was a source of
    confusion for many pandas users. The `.ix` indexer has subsequently been deprecated
    and thus should be avoided.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`.iloc`和`.loc`索引器各自通过整数或标签位置选择数据，但不能同时处理这两种输入类型的组合。在早期版本的pandas中，曾经有一个索引器`.ix`，它可以通过整数和标签位置同时选择数据。尽管这个功能在特定情况下很方便，但它本质上存在歧义，给许多pandas用户带来了困惑。因此，`.ix`索引器已被弃用，应避免使用。'
- en: Getting ready
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Before the `.ix` deprecation, it was possible to select the first five rows
    and the columns of the college dataset from `UGDS_WHITE` through `UGDS_UNKN` using
    `college.ix[:5, 'UGDS_WHITE':'UGDS_UNKN']`. This is now impossible to do directly
    using `.loc` or `.iloc`. The following recipe shows how to find the integer location
    of the columns and then use `.iloc` to complete the selection.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在`.ix`被弃用之前，可以使用`college.ix[:5, 'UGDS_WHITE':'UGDS_UNKN']`来选择大学数据集中从`UGDS_WHITE`到`UGDS_UNKN`的前五行及所有列。现在，无法直接使用`.loc`或`.iloc`来做到这一点。以下示例展示了如何查找列的整数位置，然后使用`.iloc`完成选择。
- en: How to do it...
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Read in the college dataset and assign the institution name (`INSTNM`) as the
    index:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取大学数据集并将机构名称（`INSTNM`）指定为索引：
- en: '[PRE24]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Use the Index method `get_loc` to find the integer position of the desired
    columns:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用索引方法`get_loc`找到所需列的整数位置：
- en: '[PRE25]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Use `col_start` and `col_end` to select columns by integer location using `.iloc`:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`col_start`和`col_end`通过整数位置选择列，使用`.iloc`：
- en: '[PRE26]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '![](img/b14e2086-ab61-424c-b881-db682c2fe4c7.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b14e2086-ab61-424c-b881-db682c2fe4c7.png)'
- en: How it works...
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Step 2 first retrieves the column index through the `columns` attribute. Indexes
    have a `get_loc` method, which accepts an index label and returns its integer
    location. We find both the start and end integer locations for the columns that
    we wish to slice. We add one because slicing with `.iloc` is exclusive of the
    last item. Step 3 uses slice notation with the rows and columns.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 第2步首先通过`columns`属性检索列的索引。索引有一个`get_loc`方法，它接受一个索引标签并返回该标签的整数位置。我们找到希望切片的列的起始和结束整数位置。因为`.iloc`的切片是不包括最后一个项的，所以需要加1。第3步使用切片表示法处理行和列。
- en: There's more...
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: 'We can do a very similar operation to make `.loc` work with a mixture of integers
    and positions. The following shows how to select the 10th through 15th (inclusive)
    rows, along with columns `UGDS_WHITE` through `UGDS_UNKN`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以进行类似的操作，使`.loc`也能处理整数和位置的混合。以下示例展示了如何选择第10到第15行（包含），以及`UGDS_WHITE`到`UGDS_UNKN`的列：
- en: '[PRE27]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Doing this same operation with `.ix` (which is deprecated, so don''t do this)
    would look like this:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`.ix`（已弃用，因此不推荐这样做）执行相同操作的方式如下：
- en: '[PRE28]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'It is possible to achieve the same results by chaining `.loc` and `.iloc` together,
    but chaining indexers is typically a bad idea:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将`.loc`和`.iloc`链式调用，也能实现相同的结果，但通常不建议链式调用索引器：
- en: '[PRE29]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Speeding up scalar selection
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提高标量选择的速度
- en: Both the `.iloc` and `.loc` indexers are capable of selecting a single element,
    a scalar value, from a Series or DataFrame. However, there exist the indexers,
    `.iat` and `.at`, which respectively achieve the same thing at faster speeds.
    Like `.iloc`, the `.iat` indexer uses integer location to make its selection and
    must be passed two integers separated by a comma. Similar to `.loc`, the `.at`
    index uses labels to make its selection and must be passed an index and column
    label separated by a comma.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`.iloc`和`.loc`索引器都能够从Series或DataFrame中选择单个元素，即标量值。然而，也存在`.iat`和`.at`索引器，它们分别以更快的速度完成相同的任务。像`.iloc`一样，`.iat`索引器使用整数位置来进行选择，必须传递两个以逗号分隔的整数。类似于`.loc`，`.at`索引器使用标签进行选择，必须传递一个索引和一个列标签，以逗号分隔。'
- en: Getting ready
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe is valuable if computational time is of utmost importance. It shows
    the performance improvement of `.iat` and `.at` over `.iloc` and `.loc` when using
    scalar selection.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果计算时间至关重要，这个例子是非常有价值的。它展示了在进行标量选择时，`.iat`和`.at`相较于`.iloc`和`.loc`的性能提升。
- en: How to do it...
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Read in the `college` scoreboard dataset with the institution name as the index.
    Pass a college name and column name to `.loc` in order to select a scalar value:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取`college`成绩单数据集，将机构名称作为索引。将大学名称和列名传递给`.loc`以选择标量值：
- en: '[PRE30]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Achieve the same result with `.at`:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`.at`实现相同的结果：
- en: '[PRE31]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Use the `%timeit` magic command to find the difference in speed:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`%timeit`魔法命令来找出速度差异：
- en: '[PRE32]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Find the integer locations of the preceding selections and then time the difference
    between `.iloc` and `.iat`:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找前述选择的整数位置，然后计时`.iloc`和`.iat`之间的差异：
- en: '[PRE33]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: How it works...
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: The scalar indexers, `.iat` and `.at`, only accept scalar values. They fail
    if anything else is passed to them. They are drop-in replacements for `.iloc`
    and `.loc` when doing scalar selection. The `timeit` magic command times entire
    blocks of code when preceded by two percentage signs and a single time when preceded
    by one percentage sign. It shows that about 2.5 microseconds are saved on average
    by switching to the scalar indexers. This might not be much but can add up quickly
    if scalar selection is repeatedly done in a program.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 标量索引器`.iat`和`.at`只接受标量值。如果传递任何其他值，它们将失败。它们在进行标量选择时是`.iloc`和`.loc`的替代品。`timeit`魔法命令可以在前面加上两个百分号时计时整个代码块，加上一个百分号时计时单独的部分。它显示，通过切换到标量索引器，平均节省大约2.5微秒。虽然这可能不多，但如果在程序中重复进行标量选择，节省的时间会快速积累。
- en: There's more...
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多……
- en: 'Both `.iat` and `.at` work with Series as well. Pass them a single scalar value,
    and they will return a scalar:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`.iat`和`.at`同样适用于Series。将一个标量值传递给它们，它们将返回一个标量：'
- en: '[PRE35]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Slicing rows lazily
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 懒惰地切片行
- en: The previous recipes in this chapter showed how the `.iloc` and `.loc` indexers
    were used to select subsets of both Series and DataFrames in either dimension.
    A shortcut to select the rows exists with just the indexing operator itself. This
    is just a shortcut to show additional features of pandas, but the primary function
    of the indexing operator is actually to select DataFrame columns. If you want
    to select rows, it is best to use `.iloc` or `.loc`, as they are unambiguous.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 本章前面的示例展示了如何使用`.iloc`和`.loc`索引器在任一维度中选择Series和DataFrame的子集。使用单一索引操作符可以实现选择行的快捷方式。这只是一个展示pandas附加功能的快捷方式，但索引操作符的主要功能实际上是选择DataFrame列。如果你想选择行，最好使用`.iloc`或`.loc`，因为它们没有歧义。
- en: Getting ready
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we pass a slice object to both the Series and DataFrame indexing
    operators.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将切片对象传递给Series和DataFrame的索引操作符。
- en: How to do it...
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Read in the college dataset with the institution name as the index and then
    select every other row from index 10 to 20:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取包含机构名称作为索引的大学数据集，然后从索引10到20选择每隔一行：
- en: '[PRE36]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '![](img/8bb0dd64-541a-437e-aedb-323fbe9b57d4.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8bb0dd64-541a-437e-aedb-323fbe9b57d4.png)'
- en: 'This same slicing exists with Series:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Series中也有相同的切片操作：
- en: '[PRE37]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Both Series and DataFrames can slice by label as well with just the indexing
    operator:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Series和DataFrame也可以通过标签进行切片，只需使用索引操作符：
- en: '[PRE38]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '![](img/84ef652c-f107-4bd0-aec4-8404794a1d74.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](img/84ef652c-f107-4bd0-aec4-8404794a1d74.png)'
- en: 'Here is the same slice by label with a Series:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里是使用Series的相同标签切片：
- en: '[PRE39]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: How it works...
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: 'The indexing operator changes behavior based on what type of object is passed
    to it. The following pseudocode outlines how DataFrame indexing operator handles
    the object that it is passed:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 索引操作符的行为会根据传递给它的对象类型而改变。以下伪代码概述了DataFrame索引操作符如何处理传递给它的对象：
- en: '[PRE40]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The preceding logic covers all the most common cases but is not an exhaustive
    list. The logic for a Series is slightly different and actually more complex than
    it is for a DataFrame. Due to its complexity, it is probably a good idea to avoid
    using just the indexing operator itself on a Series and instead use the explicit
    `.iloc` and `.loc` indexers.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 前述的逻辑涵盖了所有最常见的情况，但并不是一个详尽无遗的列表。对于Series，逻辑稍微不同，实际上比DataFrame更复杂。由于其复杂性，最好避免仅仅在Series上使用索引操作符，而是使用明确的`.iloc`和`.loc`索引器。
- en: One acceptable use case of the Series indexing operator is when doing boolean
    indexing. See [Chapter 12](7daeb59b-3e8e-4a33-9437-2839c6ed47e4.xhtml), *Index
    Alignment* for more details.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Series索引操作符的一种可接受使用场景是进行布尔索引。详情请参见[第12章](7daeb59b-3e8e-4a33-9437-2839c6ed47e4.xhtml)，*索引对齐*。
- en: I titled this type of row slicing in this section as *lazy*, as it does not
    use the more explicit `.iloc` or `.loc`. Personally, I always use these indexers
    whenever slicing rows, as there is never a question of exactly what I am doing.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我将这一类型的行切片称为*懒惰切片*，因为它不使用更明确的`.iloc`或`.loc`。就我个人而言，每当进行行切片时，我总是使用这些索引器，因为这样做没有任何疑问，能够明确知道自己在做什么。
- en: There's more...
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: 'It is important to be aware that this lazy slicing does not work for columns,
    just for DataFrame rows and Series. It also cannot be used to select both rows
    and columns simultaneously. Take, for instance, the following code, which attempts
    to select the first ten rows and two columns:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，这种懒惰切片方法只适用于DataFrame的行和Series，不能用于列。此外，也不能同时选择行和列。例如，下面的代码试图选择前十行和两列：
- en: '[PRE41]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'To make a selection in this manner, you need to use `.loc` or `.iloc`. Here
    is one possible way that selects all the institution labels first and then uses
    the label-based indexer `.loc`:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 要以这种方式进行选择，你需要使用`.loc`或`.iloc`。这里有一种可能的方式，首先选择所有学院标签，然后使用基于标签的索引器`.loc`：
- en: '[PRE42]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Slicing lexicographically
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字典顺序切片
- en: The `.loc` indexer typically selects data based on the exact string label of
    the index. However, it also allows you to select data based on the lexicographic
    order of the values in the index. Specifically, `.loc` allows you to select all
    rows with an index lexicographically using slice notation. This works only if
    the index is sorted.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`.loc`索引器通常根据索引的精确字符串标签来选择数据。然而，它也允许你根据索引中值的字典顺序来选择数据。具体来说，`.loc`允许你使用切片符号按字典顺序选择所有行。这只有在索引已排序的情况下才有效。'
- en: Getting ready
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, you will first sort the index and then use slice notation inside
    the `.loc` indexer to select all rows between two strings.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实例中，你将首先对索引进行排序，然后在`.loc`索引器内部使用切片符号选择两个字符串之间的所有行。
- en: How to do it...
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Read in the college dataset, and set the institution name as the index:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取学院数据集，并将学院名称设置为索引：
- en: '[PRE43]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Attempt to select all colleges with names lexicographically between `''Sp''`
    and `''Su''`:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试选择所有名称在字典顺序上介于`'Sp'`和`'Su'`之间的学院：
- en: '[PRE44]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'As the index is not sorted, the preceding command fails. Let''s go ahead and
    sort the index:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于索引未排序，之前的命令会失败。让我们对索引进行排序：
- en: '[PRE45]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '![](img/eaefaacf-2f58-4a04-ae64-7f9a6321af9e.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eaefaacf-2f58-4a04-ae64-7f9a6321af9e.png)'
- en: 'Now, let''s rerun the same command from step 2:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们重新运行步骤2中的相同命令：
- en: '[PRE46]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '![](img/2fe10453-8789-4016-80eb-f99bf85cea0e.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2fe10453-8789-4016-80eb-f99bf85cea0e.png)'
- en: How it works...
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The normal behavior of `.loc` is to make selections of data based on the exact
    labels passed to it. It raises a `KeyError` when these labels are not found in
    the index. However, one special exception to this behavior exists whenever the
    index is lexicographically sorted, and a slice is passed to it. Selection is now
    possible between the `start` and `stop` labels of the slice, even if they are
    not exact values of the index.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`.loc`的正常行为是根据传入的精确标签来选择数据。当这些标签在索引中找不到时，它会引发`KeyError`。然而，当索引按字典顺序排序并传入切片时，存在一个特殊例外。在这种情况下，即使`start`和`stop`标签不是索引中的精确值，也可以在它们之间进行选择。'
- en: There's more...
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: With this recipe, it is easy to select colleges between two letters of the alphabet.
    For instance, to select all colleges that begin with the letter `D` through `S`,
    you would use `college.loc['D':'T']`. Slicing like this is still inclusive of
    the last index so this would technically return a college with the exact name
    `T`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个方法，选择字母表中两个字母之间的学院非常容易。例如，要选择所有以字母`D`到`S`开头的学院，你可以使用`college.loc['D':'T']`。像这样切片时，最后一个索引仍然包括在内，所以这将返回一个名称恰好为`T`的学院。
- en: 'This type of slicing also works when the index is sorted in the opposite direction.
    You can determine which direction the index is sorted with the index attribute,
    `is_monotonic_increasing` or `is_monotonic_decreasing`. Either of these must be
    `True` in order for lexicographic slicing to work. For instance, the following
    code lexicographically sorts the index from `Z` to `A`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的切片在索引按相反方向排序时也适用。你可以通过 `is_monotonic_increasing` 或 `is_monotonic_decreasing`
    属性来判断索引的排序方向。这两个属性中的任何一个必须为 `True`，才能使字典顺序切片生效。例如，以下代码会按字典顺序将索引从 `Z` 排序到 `A`：
- en: '[PRE47]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '![](img/ff1d8e8c-7a7e-4812-9426-1515879ecb40.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ff1d8e8c-7a7e-4812-9426-1515879ecb40.png)'
- en: Python sorts all capital letters before lowercase and all integers before capital
    letters.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Python 会将所有大写字母排在小写字母之前，所有整数排在大写字母之前。
