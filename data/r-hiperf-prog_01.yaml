- en: Chapter 1. Understanding R's Performance – Why Are R Programs Sometimes Slow?
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 1 章. 理解 R 的性能——为什么 R 程序有时运行缓慢？
- en: R is a great tool used for statistical analysis and data processing. When it
    was first developed in 1993, it was designed as a tool that would teach data analysis
    courses. Because it is so easy to use, it became more and more popular over the
    next 20 years, not only in academia, but also in government and industry. R is
    also an open source tool, so its users can use it for free and contribute new
    statistical packages to the R public repository called the **Comprehensive R Archive
    Network** (**CRAN**). As the CRAN library became richer with more than 6,000 well-documented
    and ready-to-use packages at the time of writing this book, the attractiveness
    of R increased even further. In these 20 years, the volume of data being created,
    transmitted, stored, and analyzed, by organizations and individuals alike, has
    also grown exponentially. R programmers who need to process and analyze the ever
    growing volume of data sometimes find that R's performance suffers under such
    heavy loads. Why does R sometimes not perform well, and how can we overcome its
    performance limitations? This book examines the factors behind R's performance
    and offers a variety of techniques to improve the performance of R programs, for
    example, optimizing memory usage, performing computations in parallel, or even
    tapping the computing power of external data processing systems.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: R 是一个用于统计分析与数据处理的优秀工具。当它在 1993 年首次开发时，它被设计为一个用于教授数据分析课程的工具。由于其使用简便，在接下来的 20
    年里，它越来越受欢迎，不仅在学术界，也在政府和企业界。R 还是一个开源工具，因此其用户可以免费使用它，并向 R 公共仓库（称为 **CRAN Comprehensive
    R Archive Network**）贡献新的统计包。在撰写本书时，随着 CRAN 库的丰富，拥有超过 6,000 个经过良好文档记录且可立即使用的包，R
    的吸引力进一步增加。在这 20 年里，组织和个人创造、传输、存储和分析的数据量也呈指数级增长。需要处理和分析不断增长的数据量的 R 程序员有时会发现，在如此重的负载下，R
    的性能受到影响。为什么 R 有时表现不佳，我们如何克服其性能限制？本书探讨了 R 性能背后的因素，并提供了各种技术来提高 R 程序的性能，例如优化内存使用、并行计算或甚至利用外部数据处理系统的计算能力。
- en: Before we can find the solutions to R's performance problems, we need to understand
    what makes R perform poorly in certain situations. This chapter kicks off our
    exploration of the high-performance R programming by taking a peek under the hood
    to understand how R is designed, and how its design can limit the performance
    of R programs.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们找到 R 性能问题的解决方案之前，我们需要了解是什么使得 R 在某些情况下表现不佳。本章通过揭开 R 的设计面纱，了解其设计如何限制 R 程序的性能，从而开启了我们对高性能
    R 编程的探索。
- en: We will examine three main constraints faced by any computational task—CPU,
    RAM, and disk **input/output** (**I/O**)—and then look at how these play out specifically
    in R programs. By the end of this chapter, you will have some insights into the
    bottlenecks that your R programs could run into.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将考察任何计算任务面临的主要限制——CPU、RAM 和磁盘 **输入/输出**（**I/O**）——然后看看这些限制在 R 程序中具体是如何体现的。到本章结束时，你将对你的
    R 程序可能遇到的瓶颈有所了解。
- en: 'This chapter covers the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主题：
- en: Three constraints on computing performance—CPU, RAM, and disk I/O
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算性能的三个限制因素——CPU、RAM 和磁盘 I/O
- en: R is interpreted on the fly
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: R 是即时解释的
- en: R is single-threaded
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: R 是单线程的
- en: R requires all data to be loaded into memory
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: R 需要将所有数据加载到内存中
- en: Algorithm design affects time and space complexity
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 算法设计影响时间和空间复杂度
- en: Three constraints on computing performance – CPU, RAM, and disk I/O
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算性能的三个限制因素——CPU、RAM 和磁盘 I/O
- en: First, let's see how R programs are executed in a computer. This is a very simplified
    version of what actually happens, but it suffices for us to understand the performance
    limitations of R. The following figure illustrates the steps required to execute
    an R program.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看 R 程序在计算机中的执行方式。这是一个非常简化的实际发生情况的版本，但它足以让我们了解 R 的性能限制。以下图展示了执行一个 R 程序所需的步骤。
- en: '![Three constraints on computing performance – CPU, RAM, and disk I/O](img/9263OS_01_01.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![计算性能的三个限制因素 – CPU、RAM 和磁盘 I/O](img/9263OS_01_01.jpg)'
- en: Steps to execute an R program
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 执行 R 程序的步骤
- en: 'Take for example, this simple R program, which loads some data from a CSV file,
    computes the column sums, and writes the results into another CSV file:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 以这个简单的 R 程序为例，它从 CSV 文件中加载数据，计算列总和，并将结果写入另一个 CSV 文件：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We use the numbering to understand the preceding diagram:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用编号来理解前面的图：
- en: When we load and run an R program, the R code is first loaded into RAM.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们加载和运行一个 R 程序时，R 代码首先被加载到 RAM 中。
- en: The R interpreter then translates the R code into machine code and loads the
    machine code into the CPU.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，R 解释器将 R 代码翻译成机器码，并将机器码加载到 CPU 中。
- en: The CPU executes the program.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CPU 执行程序。
- en: The program loads the data to be processed from the hard disk into RAM (`read.csv()`
    in the example).
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 程序将从硬盘将待处理的数据加载到 RAM 中（例如示例中的 `read.csv()`）。
- en: The data is loaded in small chunks into the CPU for processing.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据被分小块加载到 CPU 中进行处理。
- en: The CPU processes the data one chunk at a time, and exchanges chunks of data
    with RAM until all the data has been processed (in the example, the CPU executes
    the instructions of the `colSums()` function to compute the column sums on the
    data set).
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CPU 逐块处理数据，并与 RAM 交换数据块，直到所有数据都被处理（在示例中，CPU 执行 `colSums()` 函数的指令来计算数据集的列总和）。
- en: Sometimes, the processed data is stored back onto the hard drive (`write.csv()`
    in the example).
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有时，处理过的数据会被存储回硬盘上（例如示例中的 `write.csv()`）。
- en: 'From this depiction of the computing process, we can see a few places where
    performance bottlenecks can occur:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个计算过程的描述中，我们可以看到几个可能发生性能瓶颈的地方：
- en: The speed and performance of the CPU determines how quickly computing instructions,
    such as `colSums()` in the example, are executed. This includes the interpretation
    of the R code into the machine code and the actual execution of the machine code
    to process the data.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CPU 的速度和性能决定了计算指令，如示例中的 `colSums()`，的执行速度。这包括将 R 代码解释成机器码以及实际执行机器码来处理数据。
- en: The size of RAM available on the computer limits the amount of data that can
    be processed at any given time. In this example, if the `mydata.csv` file contains
    more data than can be held in the RAM, the call to `read.csv()` will fail.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算机上可用的 RAM 大小限制了任何给定时间可以处理的数据量。在这个例子中，如果 `mydata.csv` 文件包含的数据量超过了 RAM 的容量，`read.csv()`
    的调用将会失败。
- en: The speed at which the data can be read from or written to the hard disk (`read.csv()`
    and `write.csv()` in the example), that is, the speed of the disk input/output
    (I/O) affects how quickly the data can be loaded into the memory and stored back
    onto the hard disk.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据从硬盘读取或写入的速度（例如示例中的 `read.csv()` 和 `write.csv()`），即硬盘输入/输出（I/O）的速度，影响数据加载到内存和存储回硬盘的速度。
- en: Sometimes, you might encounter these limiting factors one at a time. For example,
    when a dataset is small enough to be quickly read from the disk and fully stored
    in the RAM, but the computations performed on it are complex, then only the CPU
    constraint is encountered. At other times, you might find them occurring together
    in various combinations. For example, when a dataset is very large, it takes a
    long time to load it from the disk, only one small chunk of it can be loaded at
    any given time into the memory, and it takes a long time to perform any computations
    on it. In either case, these are the symptoms of performance problems. In order
    to diagnose the problems and find solutions for them, we need to look at what
    is happening behind the scenes that might be causing these constraints to occur.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能会一次遇到这些限制因素中的一个。例如，当数据集足够小，可以快速从磁盘读取并完全存储在 RAM 中，但对其进行的计算很复杂时，那么只会遇到 CPU
    限制。在其他时候，你可能会发现它们以各种组合同时出现。例如，当数据集非常大时，从磁盘加载它需要很长时间，在任何给定时间只能将一小部分加载到内存中，并且对它的任何计算都需要很长时间。在两种情况下，这些都是性能问题的症状。为了诊断问题并找到解决方案，我们需要查看幕后可能引起这些限制发生的情况。
- en: Let's now take a look at how R is designed and how it works, and see what the
    implications are for its performance.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看 R 的设计和工作方式，以及它的性能意味着什么。
- en: R is interpreted on the fly
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: R 是即时解释的
- en: 'In computer science parlance, R is known as an interpreted language. This means
    that every time you execute an R program, the R interpreter interprets and executes
    the R code on the fly. The following figure illustrates what happens when you
    run any R code:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机科学术语中，R 被称为一种解释型语言。这意味着每次你执行一个 R 程序时，R 解释器都会即时解释并执行 R 代码。以下图示说明了当你运行任何 R
    代码时会发生什么：
- en: '![R is interpreted on the fly](img/9263OS_01_02.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![R 是即时解释的](img/9263OS_01_02.jpg)'
- en: Interpreted language versus compiled language
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 解释型语言与编译型语言
- en: R first parses your source code into an internal R object representation of
    all the statements and expressions in your R code. R then evaluates this internal
    R object to execute the code.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: R 首先将你的源代码解析成 R 内部对象表示，其中包括 R 代码中的所有语句和表达式。然后 R 评估这个内部 R 对象以执行代码。
- en: This is what makes R such a dynamic and interactive programming language. You
    can type R statements into the R console and get results immediately because the
    R interpreter parses and evaluates the code right away. The downside of this approach
    is that R code runs relatively slow because it is reinterpreted every time you
    run it, even when it has not changed.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么 R 是一种如此动态和交互式的编程语言。你可以将 R 语句输入到 R 控制台中并立即得到结果，因为 R 解释器会立即解析和评估代码。这种方法的不利之处在于，R
    代码运行相对较慢，因为每次运行它时都需要重新解释，即使它没有改变。
- en: Contrast this with a **compiled language** such as C or Fortran. When you work
    with a compiled language, you compile your source code into the machine code before
    you execute it. This makes compiled languages less interactive because the compilation
    step can take several minutes for large programs, even when you have made just
    a tiny change to the code. On the other hand, once the code has been compiled,
    it runs very quickly on the CPU since it is already in the computer's native language.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 与 C 或 Fortran 这样的**编译型语言**相比，当你使用编译型语言时，你需要在执行之前将源代码编译成机器代码。这使得编译型语言交互性较差，因为编译步骤可能需要几分钟，即使是对于大型程序，即使你只是对代码进行了微小的更改。另一方面，一旦代码被编译，它会在
    CPU 上非常快速地运行，因为它已经是计算机的本地语言。
- en: 'Due to R being an interpreted language, every time you run an R program, the
    CPU is busy doing two things: interpreting your code and executing the instructions
    contained in it. Therefore, the CPU''s speed can limit the performance of R programs.
    We will learn how to overcome CPU limitations in chapters 3 to 5.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 R 是一种解释型语言，每次你运行一个 R 程序时，CPU 都忙于做两件事：解释你的代码和执行其中的指令。因此，CPU 的速度可以限制 R 程序的性能。我们将在第
    3 章到第 5 章中学习如何克服 CPU 的限制。
- en: R is single-threaded
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: R 是单线程的。
- en: Another way in which R is CPU limited is that, by default, it runs only on a
    single thread on the CPU. It does not matter if you install R on a powerful server
    with 64 CPU cores, R will only use one of them. For example, finding the sum of
    a numeric vector is an operation that can be made to run in parallel in the CPU
    quite easily. If there are four CPU cores available, each core can be given roughly
    one quarter of the data to process. Each core computes the subtotal of the chunk
    of data it is given, and the four subtotals are then added up to find the total
    sum of the whole dataset. However in R, the `sum()` function runs serially, processing
    the entire dataset on one CPU core. In fact, many Big Data operations are of a
    similar nature to the summation example here, with the same task running independently
    on many subsets of data. In such a scenario, performing the operation sequentially
    would be an underuse of today's mostly parallel computing architectures. In [Chapter
    8](ch08.html "Chapter 8. Multiplying Performance with Parallel Computing"), *Multiplying
    Performance with Parallel Computing*, we will learn how to write parallel programs
    in R to overcome this limitation.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: R 在 CPU 上的限制还有另一个方面，即默认情况下，它只在 CPU 的一个线程上运行。无论你在具有 64 个 CPU 核心的强大服务器上安装 R，R
    都只会使用其中一个。例如，求一个数值向量的和是一个可以在 CPU 上非常容易并行运行的运算。如果有四个 CPU 核心可用，每个核心可以处理大约四分之一的数据。每个核心计算它所分配的数据块的小计，然后四个小计相加以找到整个数据集的总和。然而，在
    R 中，`sum()` 函数是串行运行的，在一个 CPU 核心上处理整个数据集。实际上，许多大数据操作与这里的求和示例具有相似的性质，相同的任务在许多数据子集上独立运行。在这种情况下，顺序执行操作将是今天大多数并行计算架构的浪费。在[第
    8 章](ch08.html "第 8 章。通过并行计算提高性能")《通过并行计算提高性能》中，我们将学习如何在 R 中编写并行程序以克服这一限制。
- en: R requires all data to be loaded into memory
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: R 需要将所有数据加载到内存中。
- en: All data that is processed in R has to be fully loaded into the RAM. This means
    that once the data has been loaded, all of it is available for processing by the
    CPU, which is great for performance. On the other hand, it also means that the
    maximum size of data that you can process depends on the amount of free RAM available
    on your system. Remember that not all the RAM on your computer is available to
    R. The operating system, background processes, and any other applications that
    are running in the CPU also compete for the RAM. What is available for R to use
    might be a fraction of the total RAM installed on the system.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在R中处理的所有数据都必须完全加载到RAM中。这意味着一旦数据被加载，CPU就可以对其进行处理，这对于性能来说是非常好的。另一方面，这也意味着你可以处理的数据的最大大小取决于系统上可用的空闲RAM量。记住，不是你电脑上的所有RAM都可以供R使用。操作系统、后台进程以及任何在CPU上运行的其他应用程序也会竞争使用RAM。R可用的RAM可能只是系统上安装的总RAM的一部分。
- en: On top of that, R also requires free RAM to store the results of its computations.
    Depending on what kinds of computations you are performing, you might need the
    available RAM to be twice or even more times as large as the size of your data.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，R还需要足够的RAM来存储其计算结果。根据你执行的计算类型，你可能需要的可用RAM是数据大小的两倍甚至更多。
- en: 32-bit versions of R are also limited by the amount of RAM they can access.
    Depending on the operating system, they might be limited to 2 GB to 4 GB of RAM
    even when there is actually more RAM available. Furthermore, due to memory address
    limits, data structures in 32-bit versions of R can contain at most *2^(31)-1
    = 2,147,483,647* elements. Because of these limits, you should use the 64-bit
    versions of R whenever you can.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: R的32位版本也受其可访问的RAM量所限制。根据操作系统不同，即使实际上有更多的RAM可用，它们可能也仅限于2 GB到4 GB的RAM。此外，由于内存地址限制，R的32位版本中的数据结构最多只能包含
    *2^(31)-1 = 2,147,483,647* 个元素。因为这些限制，你应该尽可能使用R的64位版本。
- en: Note
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In all versions of R prior to 3.0, even 64-bit versions, vectors and other data
    structures faced this 2,147,483,647-element limit. If you have data that exceeds
    this size, you need to use a 64-bit version of R 3.0 or one of its later versions.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在R 3.0版本之前的所有版本中，即使是64位版本，向量和其它数据结构都面临这个2,147,483,647个元素的限制。如果你的数据超过了这个大小，你需要使用R
    3.0或其后续版本的64位版本。
- en: What happens when we try to load a dataset that is larger than the available
    RAM? Sometimes, the data loads successfully, but once the available RAM is used
    up, the operating system starts to swap the data in RAM into a swapfile on the
    hard disk. This is not a feature of R; it depends on the operating system. When
    this happens, R thinks that all the data has been loaded into the RAM when in
    fact the operating system is hard at work in the background swapping data between
    RAM and the swapfile on the disk. When such a situation occurs, we have a disk
    I/O bottleneck on top of the memory bottleneck. Because disk I/O is so slow (hard
    drive's speed is typically measured in milliseconds, while RAM's speed in nanoseconds),
    it can cause R to appear as if it is frozen or becomes unresponsive. Of the three
    performance limitations we looked at, disk I/O often has the largest impact on
    R's performance.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试加载一个比可用RAM大的数据集时会发生什么？有时，数据加载成功，但一旦可用RAM被用尽，操作系统开始将RAM中的数据交换到硬盘上的交换文件中。这不是R的特性；这取决于操作系统。当这种情况发生时，R认为所有数据都已加载到RAM中，而实际上操作系统正在后台努力在RAM和硬盘上的交换文件之间交换数据。在这种情况下，我们除了内存瓶颈之外，还遇到了磁盘I/O瓶颈。由于磁盘I/O非常慢（硬盘的速度通常以毫秒计算，而RAM的速度以纳秒计算），这可能导致R看起来像是冻结了或者变得无响应。在我们讨论的三个性能限制中，磁盘I/O通常对R的性能影响最大。
- en: '[Chapter 6](ch06.html "Chapter 6. Simple Tweaks to Use Less RAM"), *Simple
    Tweaks to Use Less RAM* and [Chapter 7](ch07.html "Chapter 7. Processing Large
    Datasets with Limited RAM"), *Processing Large Datasets with Limited RAM* will
    discuss how to optimize memory usage and work with datasets that are too large
    to fit into the memory.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '[第6章](ch06.html "第6章。减少RAM使用的简单技巧"), *减少RAM使用的简单技巧* 和 [第7章](ch07.html "第7章。在有限RAM下处理大型数据集"),
    *在有限RAM下处理大型数据集* 将讨论如何优化内存使用以及如何处理无法装入内存的大型数据集。'
- en: Algorithm design affects time and space complexity
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 算法设计影响时间和空间复杂度
- en: 'There is one other performance factor that we have not discussed—your code.
    The types of computations and algorithms that you run can have a huge impact on
    performance. Computer scientists describe the performance characteristics of programs
    in terms of complexity. In particular, we are concerned about two types of complexities:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有讨论的一个性能因素是你的代码。你运行的计算类型和算法可以对性能产生巨大影响。计算机科学家用复杂度来描述程序的性能特征。特别是，我们关注两种类型的复杂度：
- en: '**Time complexity**: This refers to the computing time required to run an R
    program in relation to the size of the data being processed'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**时间复杂度**：这指的是运行R程序所需的计算时间与处理的数据大小之间的关系'
- en: '**Space complexity**: This refers to the memory that is required to run an
    R program in relation to the size of the data being processed'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**空间复杂度**：这指的是运行R程序所需的内存与处理的数据大小之间的关系'
- en: 'Let''s look at an example of time complexity. Suppose that we need to write
    a function to compute the *nth* Fibonacci number, that is, a number in the sequence
    0, 1, 1, 2, 3, 5, 8, 13, … where each number is the sum of the previous two numbers.
    A simple way to do this would be to write a recursive function such as:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看时间复杂性的一个例子。假设我们需要编写一个函数来计算第*n*个斐波那契数，即序列0, 1, 1, 2, 3, 5, 8, 13, …中的数，其中每个数是前两个数的和。一个简单的方法是编写一个递归函数，如下所示：
- en: '[PRE1]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Since the *nth* Fibonacci number is the sum of the *(n-1)th* and *(n-2)th*
    Fibonacci numbers, this function simply calls itself to compute the previous two
    numbers, then adds them up. Let''s see how long it takes to compute the 25th Fibonacci
    number using the `microbenchmark()` function from the `microbenchmark` package,
    which can be downloaded and installed from CRAN (we will take a closer look at
    how to use this function in [Chapter 2](ch02.html "Chapter 2. Profiling – Measuring
    Code''s Performance"), *Measuring Code''s Performance*):'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 由于第*n*个斐波那契数是第*(n-1)*个和第*(n-2)*个斐波那契数的和，这个函数只是调用自身来计算前两个数，然后将它们相加。让我们看看使用`microbenchmark()`函数计算第25个斐波那契数需要多长时间，这个函数可以从CRAN下载和安装（我们将在[第2章](ch02.html
    "第2章。性能分析 – 测量代码的性能")中更详细地了解如何使用这个函数，*测量代码的性能*）：
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: It took a median of 184 milliseconds. Because of the way the recursion works,
    there is a lot of unnecessary repetition. For example, to compute the 25th Fibonacci
    number, we need to compute the 23rd and 24th numbers in the sequence. But, computing
    the 24th number also involves computing the 23rd number, so the 23rd number is
    computed twice. And the 22nd number is needed to compute both the 23rd and 24th
    numbers, and so on.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 中位时间是184毫秒。由于递归的工作方式，存在大量的不必要的重复。例如，为了计算第25个斐波那契数，我们需要计算序列中的第23个和第24个数。但是，计算第24个数也涉及到计算第23个数，所以第23个数被计算了两次。而第22个数是计算第23个和第24个数所必需的，以此类推。
- en: 'We can reduce this repetition by computing each number only once. The following
    code presents an alternative implementation of the Fibonacci function that does
    just that. It computes the Fibonacci numbers in sequence from smallest to largest
    and remembers the numbers that it has computed in the numeric vector `fib`. Thus,
    each Fibonacci number is computed only once:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过只计算每个数字一次来减少这种重复。以下代码展示了斐波那契函数的另一种实现方式，它正是这样做的。它按顺序从最小到最大计算斐波那契数，并在数值向量`fib`中记住已计算的数字。因此，每个斐波那契数只计算一次：
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Tip
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Downloading the example code**'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从你购买的所有Packt书籍的账户中下载示例代码文件。[http://www.packtpub.com](http://www.packtpub.com)。如果你在其他地方购买了这本书，你可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)并注册，以便将文件直接通过电子邮件发送给你。
- en: By benchmarking this sequential function, we see that it takes a median of 0.04
    milliseconds to run, a reduction of 99.98 percent from the recursive version!
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 通过基准测试这个顺序函数，我们发现它运行的中位时间是0.04毫秒，比递归版本减少了99.98%！
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To demonstrate the concept of time complexity, we ran the benchmark for different
    values of *n* ranging from 0 to 50\. The median execution times are shown in the
    following figure:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示时间复杂度的概念，我们对*n*从0到50的不同值进行了基准测试。中位执行时间如下所示：
- en: '![Algorithm design affects time and space complexity](img/9263OS_01_06.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![算法设计影响时间和空间复杂度](img/9263OS_01_06.jpg)'
- en: Execution time of recursive versus sequential versions of Fibonacci function
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 斐波那契函数递归版本与顺序版本的执行时间对比
- en: As we increase the value of *n*, the execution time of the recursive version
    of the Fibonacci function increases exponentially. It is roughly proportional
    to *1.6^n*—every time *n* increases by 1, it gets multiplied by about 1.6 times.
    The execution time increased so fast that it took too long to compute the Fibonacci
    numbers after the 50th one. On the other hand, though it is imperceptible from
    the chart, the execution time of the sequential version increases linearly—every
    increase in *n* increases the execution time by 1.3 microseconds. Since the computational
    complexity of the sequential version is much lower than that of the recursive
    version, it will perform much better as *n* increases. As a case in point, with
    a modest value of *n=50*, the sequential version took a fraction of a millisecond
    to get computed while the recursive version took over eight hours!
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们增加*n*的值，斐波那契函数递归版本的执行时间呈指数增长。它大约与*1.6^n*成比例——每次*n*增加1，它大约乘以1.6倍。执行时间增长如此之快，以至于在计算第50个斐波那契数之后，计算时间过长。另一方面，尽管从图表上看不出，但顺序版本的执行时间呈线性增长——每次*n*的增加会使执行时间增加1.3微秒。由于顺序版本的计算复杂度远低于递归版本，随着*n*的增加，它的性能将表现得更好。作为一个例子，当*n=50*时，顺序版本仅用了几分之一毫秒就完成了计算，而递归版本则用了超过八个小时！
- en: Though we will not do it here, a similar exercise can be conducted in order
    to compare the space complexity of different algorithms. Given a certain amount
    of computational resources, your choice of algorithm and the design of your code
    can have a big impact on your R program's ability to achieve the desired level
    of performance.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们在这里不会这样做，但可以进行类似的练习来比较不同算法的空间复杂度。给定一定量的计算资源，您选择的算法和代码的设计可以对您的R程序实现所需性能水平的能力产生重大影响。
- en: Summary
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we saw how R programs can sometimes encounter the three constraints
    faced by computing performance—CPU, RAM, and disk I/O. We looked into R's design
    and learned how its interpreted and single-threaded nature can cause it to run
    slowly, and how it can encounter memory and disk I/O limitations when data becomes
    too big to fit into the RAM. Finally, we looked at how the design of R code plays
    an important role in determining the performance using a comparison between two
    implementations of the Fibonacci function with very different performance characteristics.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了R程序有时会遇到计算性能面临的三个约束——CPU、RAM和磁盘I/O。我们探讨了R的设计，并学习了其解释性和单线程特性如何导致其运行缓慢，以及当数据太大而无法适应RAM时，它如何遇到内存和磁盘I/O限制。最后，我们通过比较两个具有非常不同性能特性的斐波那契函数实现来了解R代码的设计在确定性能方面的重要作用。
- en: These performance issues are not insurmountable. The rest of this book will
    show you different ways to overcome or work around them and unlock the hidden
    potential of R.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这些性能问题并非不可克服。本书的其余部分将向您展示不同的方法来克服或绕过这些问题，并释放R的潜在能力。
