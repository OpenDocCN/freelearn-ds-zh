- en: 6\. How to Assess Performance
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6. 如何评估模型性能
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter will introduce you to model evaluation, where you evaluate or assess
    the performance of each model that you train before you decide to put it into
    production. By the end of this chapter, you will be able to create an evaluation
    dataset. You will be equipped to assess the performance of linear regression models
    using **mean absolute error** (**MAE**) and **mean squared error** (**MSE**).
    You will also be able to evaluate the performance of logistic regression models
    using accuracy, precision, recall, and F1 score.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍模型评估，您将评估或评估在决定将模型投入生产之前训练的每个模型的性能。通过本章学习，您将能够创建评估数据集。您将具备使用**平均绝对误差**（**MAE**）和**均方误差**（**MSE**）评估线性回归模型性能的能力。您还将能够使用准确率、精确率、召回率和F1得分来评估逻辑回归模型的性能。
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引言
- en: When you assess the performance of a model, you look at certain measurements
    or values that tell you how well the model is performing under certain conditions,
    and that helps you make an informed decision about whether or not to make use
    of the model that you have trained in the real world. Some of the measurements
    you will encounter in this chapter are MAE, precision, recall, and R2 score.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在评估模型性能时，您会查看一些衡量指标或数值，这些指标能告诉您模型在特定条件下的表现情况，从而帮助您做出是否将已训练的模型投入实际应用的明智决定。本章中您将遇到的一些衡量指标包括MAE、精确率、召回率和R2得分。
- en: You learned how to train a regression model in *Chapter 2, Regression*, and
    how to train classification models in *Chapter 3, Binary Classification*. Consider
    the task of predicting whether or not a customer is likely to purchase a term
    deposit, which you addressed in *Chapter 3, Binary Classification*. You have learned
    how to train a model to perform this sort of classification. You are now concerned
    with how useful this model might be. You might start by training one model, and
    then evaluating how often the predictions from that model are correct. You might
    then proceed to train more models and evaluate whether they perform better than
    previous models you have trained.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 您在*第二章：回归*中学会了如何训练回归模型，在*第三章：二分类*中学会了如何训练分类模型。请考虑预测客户是否可能购买定期存款的任务，这是您在*第三章：二分类*中涉及的内容。您已经学会了如何训练模型来执行这类分类任务。现在，您关心的是这个模型的实用性。您可以先训练一个模型，然后评估该模型的预测正确率。接着，您可能会训练更多的模型，并评估它们是否比您之前训练的模型表现更好。
- en: You have already seen an example of splitting data using `train_test_split`
    in *Exercise 3.06*, *A Logistic Regression Model for Predicting the Propensity
    of Term Deposit Purchases in a Bank*. You will go further into the necessity and
    application of splitting data in *Chapter 7, The Generalization of Machine Learning
    Models*, but for now, you should note that it is important to split your data
    into one set that is used for training a model, and a second set that is used
    for validating the model. It is this validation step that helps you decide whether
    or not to put a model into production.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经在*练习3.06*中看到了使用`train_test_split`拆分数据的例子，*《银行定期存款购买倾向的逻辑回归模型》*。在*第七章：机器学习模型的泛化*中，您将进一步了解拆分数据的必要性和应用，但目前，您应当注意到，拆分数据为两组是非常重要的：一组用于训练模型，另一组用于验证模型。正是这个验证步骤帮助您决定是否将模型投入生产。
- en: Splitting Data
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拆分数据
- en: 'You will learn more about splitting data in *Chapter 7, The Generalization
    of Machine Learning Models*, where we will cover the following:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在*第七章：机器学习模型的泛化*中进一步了解如何拆分数据，我们将讨论以下内容：
- en: Simple data splits using `train_test_split`
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`train_test_split`进行简单的数据拆分
- en: Multiple data splits using cross-validation
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用交叉验证进行多次数据拆分
- en: For now, you will learn how to split data using a function from `sklearn` called
    `train_test_split`.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，您将学习如何使用`sklearn`中的一个名为`train_test_split`的函数来拆分数据。
- en: It is very important that you do not use all of your data to train a model.
    You must set aside some data for validation, and this data must not have been
    used previously for training. When you train a model, it tries to generate an
    equation that fits your data. The longer you train, the more complex the equation
    becomes so that it passes through as many of the data points as possible.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 非常重要的一点是，您不能使用所有数据来训练模型。您必须将一部分数据保留用于验证，这部分数据之前不能用于训练。当您训练一个模型时，它会尝试生成一个适合您数据的方程式。训练时间越长，方程式会变得越复杂，以便尽可能多地通过数据点。
- en: When you shuffle the data and set some aside for validation, it ensures that
    the model learns to not overfit the hypotheses you are trying to generate.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当你对数据进行洗牌并将一部分数据留作验证集时，它能确保模型学会避免过拟合你尝试生成的假设。
- en: 'Exercise 6.01: Importing and Splitting Data'
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习6.01：导入和拆分数据
- en: In this exercise, you will import data from a repository and split it into a
    training and an evaluation set to train a model. Splitting your data is required
    so that you can evaluate the model later. This exercise will get you familiar
    with the process of splitting data; this is something you will be doing frequently.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将从一个代码库中导入数据，并将其拆分成训练集和评估集以训练一个模型。拆分数据是必须的，这样你以后可以评估模型的效果。这个练习将帮助你熟悉拆分数据的过程；这是你将频繁进行的操作。
- en: Note
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The Car dataset that you will be using in this chapter can be found in our
    GitHub repository: [https://packt.live/30I594E](https://packt.live/30I594E).'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在本章中使用的汽车数据集可以在我们的GitHub仓库中找到：[https://packt.live/30I594E](https://packt.live/30I594E)。
- en: It was taken from the UCI Machine Learning Repository.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 数据来源于UCI机器学习库。
- en: 'This dataset is about cars. A text file is provided with the following information:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数据集是关于汽车的。提供了一个文本文件，包含以下信息：
- en: '`buying` – the cost of purchasing this vehicle'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`buying` – 购买该车辆的成本'
- en: '`maint` – the maintenance cost of the vehicle'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`maint` – 车辆的维护成本'
- en: '`doors` – the number of doors the vehicle has'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`doors` – 车辆的门数'
- en: '`persons` – the number of persons the vehicle is capable of transporting'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`persons` – 车辆能够运输的乘客数量'
- en: '`lug_boot` – the cargo capacity of the vehicle'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lug_boot` – 车辆的行李厢容量'
- en: '`safety` – the safety rating of the vehicle'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`safety` – 车辆的安全评级'
- en: '`car` – this is the category that the model attempts to predict'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`car` – 这是模型尝试预测的类别'
- en: 'The following steps will help you complete the exercise:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助你完成练习：
- en: Open a new Colab notebook.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的Colab笔记本。
- en: 'Import the required libraries:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入所需的库：
- en: '[PRE0]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You started by importing a library called `pandas` in the first line. This library
    is useful for reading files into a data structure that is called a `DataFrame`,
    which you have used in previous chapters. This structure is like a spreadsheet
    or a table with rows and columns that we can manipulate. Because you might need
    to reference the library lots of times, we have created an alias for it, `pd`.
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你在第一行导入了一个叫做`pandas`的库。这个库对于将文件读取到一个叫做`DataFrame`的数据结构中非常有用，你在前几章中已经使用过这种结构。这个结构就像一个电子表格或表格，有行和列，我们可以对其进行操作。由于你可能需要多次引用该库，我们给它创建了一个别名`pd`。
- en: In the second line, you import a function called `train_test_split` from a module
    called `model_selection`, which is within `sklearn`. This function is what you
    will make use of to split the data that you read in using `pandas`.
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在第二行，你从名为`model_selection`的模块中导入了一个名为`train_test_split`的函数，该模块位于`sklearn`中。你将使用这个函数来拆分通过`pandas`读取的数据。
- en: 'Create a Python list:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个Python列表：
- en: '[PRE1]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The data that you are reading in is stored as a CSV file.
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你正在读取的数据存储为CSV文件。
- en: 'The browser will download the file to your computer. You can open the file
    using a text editor. If you do, you will see something similar to the following:'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 浏览器会将文件下载到你的计算机上。你可以使用文本编辑器打开该文件。如果你这么做，你会看到类似于以下内容：
- en: '![Figure 6.1: The car dataset without headers'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图6.1：没有标题的汽车数据集'
- en: '](img/B15019_06_01.jpg)'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15019_06_01.jpg)'
- en: 'Figure 6.1: The car dataset without headers'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图6.1：没有标题的汽车数据集
- en: Note
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: Alternatively, you can enter the dataset URL in the browser to view the dataset.
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 另外，你也可以在浏览器中输入数据集的URL来查看数据集。
- en: '`CSV` files normally have the name of each column written in the first row
    of the data. For instance, have a look at this dataset''s CSV file, which you
    used in *Chapter 3, Binary Classification*:'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`CSV`文件通常会在数据的第一行写出每一列的名称。例如，查看这个数据集的CSV文件，它是你在*第3章 二元分类*中使用过的：'
- en: '![Figure 6.2: CSV file without headers'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图6.2：没有标题的CSV文件'
- en: '](img/B15019_06_02.jpg)'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15019_06_02.jpg)'
- en: 'Figure 6.2: CSV file without headers'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图6.2：没有标题的CSV文件
- en: But, in this case, the column name is missing. That is not a problem, however.
    The code in this step creates a Python list called `_headers` that contains the
    name of each column. You will supply this list when you read in the data in the
    next step.
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 但在这种情况下，列名缺失。不过，这不是问题。此步骤中的代码创建了一个名为`_headers`的Python列表，包含了每一列的名称。你将在下一步读取数据时提供这个列表。
- en: 'Read the data:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取数据：
- en: '[PRE2]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this step, the code reads in the file using a function called `read_csv`.
    The first parameter, `'https://raw.githubusercontent.com/PacktWorkshops/The-Data-Science-Workshop/master/Chapter06/Dataset/car.data'`,
    is mandatory and is the location of the file. In our case, the file is on the
    internet. It can also be optionally downloaded, and we can then point to the local
    file's location.
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在此步骤中，代码使用名为`read_csv`的函数读取文件。第一个参数，`'https://raw.githubusercontent.com/PacktWorkshops/The-Data-Science-Workshop/master/Chapter06/Dataset/car.data'`，是必需的，表示文件的位置。在我们的例子中，文件位于互联网上。它也可以选择性地下载，然后我们可以指定本地文件的位置。
- en: The second parameter (`names=_headers`) asks the function to add the row headers
    to the data after reading it in. The third parameter (`index_col=None`) asks the
    function to generate a new index for the table because the data doesn't contain
    an index. The function will produce a DataFrame, which we assign to a variable
    called `df`.
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第二个参数（`names=_headers`）要求函数在读取数据后将行头添加到数据中。第三个参数（`index_col=None`）要求函数为表格生成一个新的索引，因为数据本身没有包含索引。该函数将生成一个DataFrame，我们将其赋值给名为`df`的变量。
- en: 'Print out the top five records:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印出前五条记录：
- en: '[PRE3]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The code in this step is used to print the top five rows of the DataFrame.
    The output from that operation is shown in the following screenshot:'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这一步中的代码用于打印出DataFrame的前五行。该操作的输出显示在以下截图中：
- en: '![Figure 6.3: The top five rows of the DataFrame'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图6.3：DataFrame的前五行'
- en: '](img/B15019_06_03.jpg)'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15019_06_03.jpg)'
- en: 'Figure 6.3: The top five rows of the DataFrame'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图6.3：DataFrame的前五行
- en: 'Create a training and an evaluation DataFrame:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建训练集和评估集的DataFrame：
- en: '[PRE4]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding code will split the DataFrame containing your data into two new
    DataFrames. The first is called `training` and is used for training the model.
    The second is called `evaluation` and will be further split into two in the next
    step. We mentioned earlier that you must separate your dataset into a training
    and an evaluation dataset, the former for training your model and the latter for
    evaluating your model.
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述代码将把包含你数据的DataFrame分割成两个新的DataFrame。第一个叫`training`，用于训练模型。第二个叫`evaluation`，将在下一步中进一步拆分。我们之前提到过，你必须将数据集分为训练集和评估集，前者用于训练模型，后者用于评估模型。
- en: At this point, the `train_test_split` function takes two parameters. The first
    parameter is the data we want to split. The second is the ratio we would like
    to split it by. What we have done is specified that we want our evaluation data
    to be 30% of our data.
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这一点上，`train_test_split`函数接受两个参数。第一个参数是我们想要分割的数据，第二个是我们希望分割的比例。我们所做的是指定评估数据占数据的30%。
- en: Note
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: The third parameter random_state is set to 0 to ensure reproducibility of results.
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第三个参数random_state设置为0，以确保结果的可复现性。
- en: 'Create a validation and test dataset:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建验证集和测试集：
- en: '[PRE5]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This code is similar to the code in *Step 6*. In this step, the code splits
    our evaluation data into two equal parts because we specified `0.5`, which means
    `50%`.
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这段代码与*第6步*中的代码类似。在此步骤中，代码将我们的评估数据分成两部分，因为我们指定了`0.5`，意味着`50%`。
- en: Note
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/3haKvl3](https://packt.live/3haKvl3).
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参考[https://packt.live/3haKvl3](https://packt.live/3haKvl3)。
- en: You can also run this example online at [https://packt.live/3g8zI9R](https://packt.live/3g8zI9R).
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你也可以在线运行这个例子，访问[https://packt.live/3g8zI9R](https://packt.live/3g8zI9R)。
- en: 'In previous chapters, we''ve seen how to split your data into train and test
    sets, but here, we''ll go one step further and split it into three: one to train
    a model, one to evaluate the model during training, and one to evaluate the model
    before putting it into production.'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们已经学习了如何将数据分割为训练集和测试集，但在这里，我们将进一步将数据分为三部分：一部分用于训练模型，一部分在训练过程中用于评估模型，还有一部分在模型投入生产之前用于最终评估模型。
- en: Now that you have your data split into different sets, you may proceed to train
    and evaluate models.
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在你已经将数据分割成不同的集合，可以开始训练和评估模型了。
- en: Assessing Model Performance for Regression Models
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回归模型的模型性能评估
- en: When you create a regression model, you create a model that predicts a continuous
    numerical variable, as you learned in *Chapter 2, Regression*. When you set aside
    your evaluation dataset, you have something that you can use to compare the quality
    of your model.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个回归模型时，你创建的模型会预测一个连续的数值变量，正如你在*第二章，回归分析*中学到的那样。当你设置评估数据集时，你可以使用它来比较模型的质量。
- en: 'What you need to do to assess your model quality is compare the quality of
    your prediction to what is called the ground truth, which is the actual observed
    value that you are trying to predict. Take a look at *Figure 6.4*, in which the
    first column contains the ground truth (called actuals) and the second column
    contains the predicted values:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为了评估你的模型质量，你需要将预测结果与所谓的真实值进行比较，真实值是你试图预测的实际观测值。请看一下*图 6.4*，其中第一列是实际值（称为实际值），第二列是预测值：
- en: '![Figure 6.4: Actual versus predicted values'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.4：实际值与预测值的比较'
- en: '](img/B15019_06_04.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15019_06_04.jpg)'
- en: 'Figure 6.4: Actual versus predicted values'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.4：实际值与预测值的比较
- en: Line `0` in the output compares the actual value in our evaluation dataset to
    what our model predicted. The actual value from our evaluation dataset is `4.891`.
    The value that the model predicted is `4.132270`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 输出中的第`0`行将我们评估数据集中的实际值与模型预测值进行比较。我们评估数据集中的实际值是`4.891`，模型预测的值是`4.132270`。
- en: Line `1` compares the actual value of `4.194` to what the model predicted, which
    is `4.364320`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 第`1`行将实际值`4.194`与模型预测的值`4.364320`进行比较。
- en: In practice, the evaluation dataset will contain a lot of records, so you will
    not be making this comparison visually. Instead, you will make use of some equations.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，评估数据集会包含大量记录，因此你不会通过视觉进行此比较。相反，你会使用一些方程式。
- en: 'You would carry out this comparison by computing the loss. The loss is the
    difference between the actuals and the predicted values in the preceding screenshot.
    In data mining, it is called a **distance measure**. There are various approaches
    to computing distance measures that give rise to different loss functions. Two
    of these are:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过计算损失来进行此比较。损失是前面截图中实际值与预测值之间的差异。在数据挖掘中，这称为**距离度量**。计算距离度量的方法有很多种，产生了不同的损失函数。以下是其中两种：
- en: Manhattan distance
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 曼哈顿距离
- en: Euclidean distance
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 欧几里得距离
- en: 'There are various loss functions for regression, but in this book, we will
    be looking at two of the commonly used loss functions for regression, which are:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 回归有多种损失函数，但在本书中，我们将研究两种常用的回归损失函数，它们是：
- en: Mean absolute error (MAE) – this is based on Manhattan distance
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平均绝对误差（MAE）——这是基于曼哈顿距离的
- en: Mean squared error (MSE) – this is based on Euclidean distance
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 均方误差（MSE）——这是基于欧几里得距离的
- en: The goal of these functions is to measure the usefulness of your models by giving
    you a numerical value that shows how much deviation there is between the ground
    truths and the predicted values from your models.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数的目标是通过给出一个数值，衡量你的模型的有效性，这个数值显示了真实值和模型预测值之间的偏差程度。
- en: Your mission is to train new models with consistently lower errors. Before we
    do that, let's have a quick introduction to some data structures.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你的任务是训练新的模型，确保它们的误差持续降低。在此之前，我们先快速介绍一些数据结构。
- en: Data Structures – Vectors and Matrices
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据结构——向量与矩阵
- en: In this section, we will look at different data structures, as follows.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍不同的数据结构，如下所示。
- en: Scalars
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 标量
- en: 'A scalar variable is a simple number, such as 23\. Whenever you make use of
    numbers on their own, they are scalars. You assign them to variables, such as
    in the following expression:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 标量变量是简单的数字，例如23。当你单独使用数字时，它们就是标量。你将它们赋值给变量，如以下表达式所示：
- en: '[PRE6]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If you had to store the temperature for 5 days, you would need to store the
    values in 5 different values, such as in the following code snippet:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要存储5天的温度数据，你需要将这些值存储在5个不同的变量中，例如以下代码片段所示：
- en: '[PRE7]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In data science, you will frequently work with a large number of data points,
    such as hourly temperature measurements for an entire year. A more efficient way
    of storing lots of values is called a vector. Let's look at vectors in the next
    topic.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据科学中，你将经常处理大量的数据点，例如一年内每小时的温度测量。存储大量值的更高效方式叫做向量。我们将在下一个主题中介绍向量。
- en: Vectors
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向量
- en: 'A vector is a collection of scalars. Consider the five temperatures in the
    previous code snippet. A vector is a data type that lets you collect all of the
    previous temperatures in one variable that supports arithmetic operations. Vectors
    look similar to Python lists and can be created from Python lists. Consider the
    following code snippet for creating a Python list:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 向量是标量的集合。考虑一下前面代码片段中的五个温度值。向量是一种数据类型，它允许你将所有这些温度值收集到一个变量中，该变量支持算术运算。向量看起来类似于
    Python 列表，可以从 Python 列表创建。考虑以下用于创建 Python 列表的代码片段：
- en: '[PRE8]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You can create a vector from the list using the `.array()` method from `numpy`
    by first importing `numpy` and then using the following snippet:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过首先导入 `numpy`，然后使用以下代码片段，从列表创建一个向量，方法是使用 `numpy` 的 `.array()` 方法：
- en: '[PRE9]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You can proceed to verify the data type using the following code snippet:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以继续使用以下代码片段验证数据类型：
- en: '[PRE10]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The code snippet will cause the compiler to print out the following:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码片段将导致编译器输出以下内容：
- en: '![Figure 6.5: The temps_ndarray vector data type'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.5：temps_ndarray 向量数据类型'
- en: '](img/B15019_06_05.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15019_06_05.jpg)'
- en: 'Figure 6.5: The temps_ndarray vector data type'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.5：temps_ndarray 向量数据类型
- en: 'You may inspect the contents of the vector using the following code snippet:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下代码片段检查向量的内容：
- en: '[PRE11]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This generates the following output:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成以下输出：
- en: '![Figure 6.6: The temps_ndarray vector'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.6：temps_ndarray 向量'
- en: '](img/B15019_06_06.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15019_06_06.jpg)'
- en: 'Figure 6.6: The temps_ndarray vector'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.6：temps_ndarray 向量
- en: 'Note that the output contains single square brackets, `[` and `]`, and the
    numbers are separated by spaces. This is different from the output from a Python
    list, which you can obtain using the following code snippet:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，输出中包含单个方括号 `[` 和 `]`，数字之间用空格分隔。这与 Python 列表的输出不同，后者可以通过以下代码片段获得：
- en: '[PRE12]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The code snippet yields the following output:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码片段产生以下输出：
- en: '![Figure 6.7: List of elements in temps_list'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.7：temps_list 中元素的列表'
- en: '](img/B15019_06_07.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15019_06_07.jpg)'
- en: 'Figure 6.7: List of elements in temps_list'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.7：temps_list 中元素的列表
- en: Note that the output contains single square brackets, `[` and `]`, and the numbers
    are separated by commas.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，输出中包含单个方括号 `[` 和 `]`，数字之间用逗号分隔。
- en: 'Vectors have a shape and a dimension. Both of these can be determined by using
    the following code snippet:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 向量有形状和维度。你可以通过以下代码片段来确定这两者：
- en: '[PRE13]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The output is a Python data structure called a **tuple** and looks like this:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 输出是一个名为 **tuple** 的 Python 数据结构，看起来像这样：
- en: '![Figure 6.8: Shape of the temps_ndarray vector'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.8：temps_ndarray 向量的形状'
- en: '](img/B15019_06_08.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15019_06_08.jpg)'
- en: 'Figure 6.8: Shape of the temps_ndarray vector'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.8：temps_ndarray 向量的形状
- en: Notice that the output consists of brackets, `(` and `)`, with a number and
    a comma. The single number followed by a comma implies that this object has only
    one dimension. The value of the number is the number of elements. The output is
    read as "a vector with five elements." This is very important because it is very
    different from a matrix, which we will discuss next.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，输出由括号 `(` 和 `)` 组成，包含一个数字和逗号。数字后跟逗号表示该对象只有一个维度。该数字的值是元素的数量。输出的意思是“一个包含五个元素的向量”。这非常重要，因为它与矩阵有很大不同，矩阵我们接下来将讨论。
- en: Matrices
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 矩阵
- en: A matrix is also made up of scalars but is different from a scalar in the sense
    that a matrix has both rows and columns3
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵也是由标量组成的，但与标量不同，矩阵既有行又有列
- en: 'There are times when you need to convert between vectors and matrices. Let''s
    revisit `temps_ndarray`. You may recall that it has five elements because the
    shape was `(5,)`. To convert it into a matrix with five rows and one column, you
    would use the following snippet:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你需要在向量和矩阵之间进行转换。让我们回顾一下 `temps_ndarray`。你可能记得它有五个元素，因为它的形状是 `(5,)`。要将其转换为一个具有五行一列的矩阵，你可以使用以下代码片段：
- en: '[PRE14]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The code snippet makes use of the `.reshape()` method. The first parameter,
    `-1`, instructs the interpreter to keep the first dimension constant. The second
    parameter, `1`, instructs the interpreter to add a new dimension. This new dimension
    is the column. To see the new shape, use the following snippet:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码片段使用了 `.reshape()` 方法。第一个参数 `-1` 指示解释器保持第一维不变。第二个参数 `1` 指示解释器添加一个新维度，这个新维度就是列。要查看新的形状，可以使用以下代码片段：
- en: '[PRE15]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You will get the following output:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到以下输出：
- en: '![Figure 6.9: Shape of the matrix'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.9：矩阵的形状'
- en: '](img/B15019_06_09.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15019_06_09.jpg)'
- en: 'Figure 6.9: Shape of the matrix'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.9：矩阵的形状
- en: 'Notice that the tuple now has two numbers, `5` and `1`. The first number, `5`,
    represents the rows, and the second number, `1`, represents the columns. You can
    print out the value of the matrix using the following snippet:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，元组现在有两个数字，`5`和`1`。第一个数字`5`表示行数，第二个数字`1`表示列数。你可以使用以下代码片段打印出矩阵的值：
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The output of the code is as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的输出如下：
- en: '![Figure 6.10: Elements of the matrix'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.10: 矩阵的元素'
- en: '](img/B15019_06_10.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15019_06_10.jpg)'
- en: 'Figure 6.10: Elements of the matrix'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '图6.10: 矩阵的元素'
- en: Notice that the output is different from that of the vector. First, we have
    an outer set of square brackets. Then, each row has its element enclosed in square
    brackets. Each row contains only one number because the matrix has only one column.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，输出与向量的输出不同。首先，我们有一个外部的方括号。然后，每一行都有其元素被方括号括起来。每一行只包含一个数字，因为矩阵只有一列。
- en: 'You may reshape the matrix to contain `1` row and `5` columns and print out
    the value using the following code snippet:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将矩阵重塑为`1`行`5`列，并使用以下代码片段打印出其值：
- en: '[PRE17]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The output will be as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '![Figure 6.11: Reshaping the matrix'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.11: 重塑矩阵'
- en: '](img/B15019_06_11.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15019_06_11.jpg)'
- en: 'Figure 6.11: Reshaping the matrix'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '图6.11: 重塑矩阵'
- en: Notice that you now have all the numbers on one row because this matrix has
    one row and five columns. The outer square brackets represent the matrix, while
    the inner square brackets represent the row.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，现在所有的数字都在一行中，因为该矩阵只有一行五列。外部的方括号表示矩阵，而内部的方括号表示行。
- en: 'Finally, you can convert the matrix back into a vector by dropping the column
    using the following snippet:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以通过以下代码片段删除列来将矩阵转换回向量：
- en: '[PRE18]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You can print out the value of the vector to confirm that you get the following:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以打印出向量的值，以确认你得到以下结果：
- en: '![Figure 6.12: The value of the vector'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.12: 向量的值'
- en: '](img/B15019_06_12.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15019_06_12.jpg)'
- en: 'Figure 6.12: The value of the vector'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '图6.12: 向量的值'
- en: Notice that you now have only one set of square brackets. You still have the
    same number of elements.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，现在你只有一组方括号。你仍然有相同数量的元素。
- en: Let's now look at an important metric – R2 score.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一个重要的度量指标——R2分数。
- en: R2 Score
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: R2分数
- en: The R2 score (pronounced "r squared") is sometimes called the "score" and measures
    the coefficient of determination of the model. Think of it as the model's ability
    to make good and reliable predictions. This measure is accessed using the `score()`
    method of the model and is available for every model.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: R2分数（发音为“r平方”）有时也被称为“得分”，用于衡量模型的决定系数。可以把它看作是模型进行准确可靠预测的能力。这个度量值可以通过模型的`score()`方法来获取，并且对每个模型都可用。
- en: Your goal is to train successive models with a higher R2 score. The R2 score
    has a range between **0** and **1**. Your goal is to try and get the model to
    have a score that is close to **1**.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 你的目标是训练多个模型，直到获得更高的R2分数。R2分数的范围在**0**和**1**之间。你的目标是尽量让模型的分数接近**1**。
- en: 'Exercise 6.02: Computing the R2 Score of a Linear Regression Model'
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习6.02：计算线性回归模型的R2分数
- en: As mentioned in the preceding sections, R2 score is an important factor in evaluating
    the performance of a model. Thus, in this exercise, we will be creating a linear
    regression model and then calculating the R2 score for it.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，R2分数是评估模型性能的一个重要因素。因此，在本练习中，我们将创建一个线性回归模型，并计算其R2分数。
- en: Note
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The fish toxicity dataset that you will be using in this chapter can be found
    in our GitHub repository: [https://packt.live/2sNChvv](https://packt.live/2sNChvv).'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中你将使用的鱼类毒性数据集可以在我们的GitHub仓库中找到：[https://packt.live/2sNChvv](https://packt.live/2sNChvv)。
- en: 'This dataset was taken from the UCI Machine Learning Repository: [https://packt.live/2TSyJTB](https://packt.live/2TSyJTB).'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 本数据集来自UCI机器学习库：[https://packt.live/2TSyJTB](https://packt.live/2TSyJTB)。
- en: 'The following attributes are useful for our task:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 以下属性对我们的任务有帮助：
- en: 'CIC0: information indices'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'CIC0: 信息指数'
- en: 'SM1_Dz(Z): 2D matrix-based descriptors'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'SM1_Dz(Z): 基于2D矩阵的描述符'
- en: 'GATS1i: 2D autocorrelations'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'GATS1i: 2D自相关'
- en: 'NdsCH: Pimephales promelas'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'NdsCH: Pimephales promelas'
- en: 'NdssC: atom-type counts'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'NdssC: 原子类型计数'
- en: 'MLOGP: molecular properties'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'MLOGP: 分子属性'
- en: 'Quantitative response, LC50 [-LOG(mol/L)]: This attribute represents the concentration
    that causes death in 50% of test fish over a test duration of 96 hours.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定量响应，LC50 [-LOG(mol/L)]：该属性表示在96小时测试期间，导致50%的测试鱼死亡的浓度。
- en: 'The following steps will help you to complete the exercise:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助你完成练习：
- en: Open a new Colab notebook to write and execute your code.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的 Colab 笔记本，编写并执行你的代码。
- en: 'Next, import the libraries mentioned in the following code snippet:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，导入以下代码片段中提到的库：
- en: '[PRE19]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In this step, you import `pandas`, which you will use to read your data. You
    also import `train_test_split()`, which you will use to split your data into training
    and validation sets, and you import `LinearRegression`, which you will use to
    train your model.
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这一步，你导入 `pandas`，用于读取数据。你还导入了 `train_test_split()`，用于将数据分割为训练集和验证集，并导入 `LinearRegression`，用于训练模型。
- en: 'Now, read the data from the dataset:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，从数据集读取数据：
- en: '[PRE20]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In this step, you create a Python list to hold the names of the columns in
    your data. You do this because the CSV file containing the data does not have
    a first row that contains the column headers. You proceed to read in the file
    and store it in a variable called `df` using the `read_csv()` method in pandas.
    You specify the list containing column headers by passing it into the `names`
    parameter. This CSV uses semi-colons as column separators, so you specify that
    using the `sep` parameter. You can use `df.head()` to see what the DataFrame looks
    like:'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这一步，你创建一个 Python 列表，用于存储数据中列的名称。这样做是因为包含数据的 CSV 文件没有第一行列头。你接着使用 `read_csv()`
    方法将文件读取并存储在名为 `df` 的变量中。通过将包含列头的列表传入 `names` 参数来指定列名。该 CSV 使用分号作为列分隔符，因此需要通过 `sep`
    参数指定。你可以使用 `df.head()` 来查看数据框的内容：
- en: '![Figure 6.13: The first five rows of the DataFrame'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 6.13：数据框的前五行'
- en: '](img/B15019_06_13.jpg)'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15019_06_13.jpg)'
- en: 'Figure 6.13: The first five rows of the DataFrame'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 6.13：数据框的前五行
- en: 'Split the data into features and labels and into training and evaluation datasets:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将数据分成特征和标签，并划分为训练集和评估集：
- en: '[PRE21]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In this step, you create two `numpy` arrays called `features` and `labels`.
    You then proceed to split them twice. The first split produces a `training` set
    and an `evaluation` set. The second split creates a `validation` set and a `test`
    set.
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这一步，你创建两个 `numpy` 数组，分别命名为 `features` 和 `labels`。然后，你将它们分割两次。第一次分割产生一个 `training`
    集和一个 `evaluation` 集。第二次分割创建一个 `validation` 集和一个 `test` 集。
- en: 'Create a linear regression model:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个线性回归模型：
- en: '[PRE22]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In this step, you create an instance of `LinearRegression` and store it in a
    variable called `model`. You will make use of this to train on the training dataset.
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这一步，你创建一个 `LinearRegression` 实例，并将其存储在名为 `model` 的变量中。你将使用它来训练训练数据集。
- en: 'Train the model:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 训练模型：
- en: '[PRE23]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In this step, you train the model using the `fit()` method and the training
    dataset that you made in *Step 4*. The first parameter is the `features` NumPy
    array, and the second parameter is `labels`.
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这一步，你使用 `fit()` 方法和在*步骤 4*中创建的训练数据集来训练模型。第一个参数是 `features` NumPy 数组，第二个参数是
    `labels`。
- en: 'You should get an output similar to the following:'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该得到类似以下的输出：
- en: '![Figure 6.14: Training the model'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 6.14：训练模型'
- en: '](img/B15019_06_14.jpg)'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15019_06_14.jpg)'
- en: 'Figure 6.14: Training the model'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 6.14：训练模型
- en: 'Make a prediction, as shown in the following code snippet:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进行预测，如以下代码片段所示：
- en: '[PRE24]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In this step, you make use of the validation dataset to make a prediction. This
    is stored in `y_pred`.
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这一步，你使用验证数据集进行预测，并将其存储在 `y_pred` 中。
- en: 'Compute the R2 score:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算 R2 分数：
- en: '[PRE25]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In this step, you compute `r2`, which is the R2 score of the model. The R2 score
    is computed using the `score()` method of the model. The next line causes the
    interpreter to print out the R2 score.
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这一步，你计算 `r2`，即模型的 R2 分数。R2 分数是通过模型的 `score()` 方法计算的。下一行会让解释器输出 R2 分数。
- en: 'The output is similar to the following:'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出结果类似于以下内容：
- en: '![Figure 6.15: R2 score'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 6.15：R2 分数'
- en: '](img/B15019_06_15.jpg)'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15019_06_15.jpg)'
- en: 'Figure 6.15: R2 score'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 6.15：R2 分数
- en: Note
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注：
- en: The MAE and R2 score may vary depending on the distribution of the datasets.
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: MAE 和 R2 分数可能会根据数据集的分布有所不同。
- en: You see that the R2 score we achieved is `0.56238`, which is not close to 1\.
    In the next step, we will be making comparisons.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以看到我们获得的 R2 分数是`0.56238`，它距离 1 还很远。在下一步，我们将进行比较。
- en: 'Compare the predictions to the actual ground truth:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将预测值与实际的真实值进行比较：
- en: '[PRE26]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In this step, you take a cursory look at the predictions compared to the ground
    truth. In *Step 8*, you will have noticed that the R2 score you computed for the
    model is far from perfect (perfect is a score of 1). In this step, in the first
    line, you create a DataFrame by making use of the `DataFrame` method in pandas.
    You provide a dictionary as an argument. The dictionary has two keys: `actuals`
    and `predicted`. `actuals` contains `y_vals`, which is the actual labels in the
    validation dataset. `predicted` contains `y_pred`, which contains the predictions.
    Both `y_vals` and `y_pred` are two-dimensional matrices, so you reshape them to
    1D vectors by using `.reshape(-1)`, which drops the second axis.'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这一步，你粗略地查看了预测值与真实值的对比。在*第8步*中，你会注意到你为模型计算的R2得分远非完美（完美得分为1）。在这一步中，在第一行，你通过使用pandas中的`DataFrame`方法创建了一个DataFrame。你提供了一个字典作为参数。该字典有两个键：`actuals`和`predicted`。`actuals`包含了`y_vals`，即验证数据集中的实际标签。`predicted`包含了`y_pred`，即预测值。`y_vals`和`y_pred`都是二维矩阵，所以你通过使用`.reshape(-1)`将它们重塑为1D向量，这样可以去掉第二个维度。
- en: The second line causes the interpreter to display the top five records.
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第二行会让解释器显示前五条记录。
- en: 'The output looks similar to the following:'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出结果看起来类似于以下内容：
- en: '![Figure 6.16: The actual versus predicted values of the model'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图6.16：模型的实际值与预测值'
- en: '](img/B15019_06_16.jpg)'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15019_06_16.jpg)'
- en: 'Figure 6.16: The actual versus predicted values of the model'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.16：模型的实际值与预测值
- en: Note
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/31aw6QE](https://packt.live/31aw6QE).
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参考[https://packt.live/31aw6QE](https://packt.live/31aw6QE)。
- en: You can also run this example online at [https://packt.live/3aASLbE](https://packt.live/3aASLbE).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在[https://packt.live/3aASLbE](https://packt.live/3aASLbE)上在线运行此示例。
- en: In this exercise, we computed the R2 score, which is an evaluation metric that
    can be used for comparing models.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在本练习中，我们计算了R2得分，它是一个评估指标，可以用于比较不同的模型。
- en: In the next topic, we will be looking at the mean absolute error, which is another
    evaluation metric.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个主题中，我们将讨论平均绝对误差，它是另一种评估指标。
- en: Mean Absolute Error
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 平均绝对误差
- en: The **mean absolute error** (**MAE**) is an evaluation metric for regression
    models that measures the absolute distance between your predictions and the ground
    truth. The absolute distance is the distance regardless of the sign, whether positive
    or negative. For example, if the ground truth is 6 and you predict 5, the distance
    is 1\. However, if you predict 7, the distance becomes -1\. The absolute distance,
    without taking the signs into consideration, is 1 in both cases. This is called
    the **magnitude**. The MAE is computed by summing all of the magnitudes and dividing
    by the number of observations.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '**平均绝对误差**（**MAE**）是回归模型的评估指标，用来衡量预测值与真实值之间的绝对距离。绝对距离是不考虑符号的距离，无论是正数还是负数。例如，如果真实值为6，预测值为5，则距离为1；但是如果预测值为7，则距离为-1。无论符号如何，绝对距离都是1。这就是所谓的**大小**。MAE通过将所有大小求和并除以观察次数来计算。'
- en: 'Exercise 6.03: Computing the MAE of a Model'
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习6.03：计算模型的MAE
- en: The goal of this exercise is to find the score and loss of a model using the
    same dataset as *Exercise 6.02*, *Computing the R2 Score of a Linear Regression
    Model*.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习的目标是使用与*练习6.02*相同的数据集，找到一个模型的得分和损失，*计算线性回归模型的R2得分*。
- en: In this exercise, we will be calculating the MAE of a model.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在本练习中，我们将计算模型的MAE。
- en: 'The following steps will help you with this exercise:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助你完成本练习：
- en: Open a new Colab notebook file.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的Colab笔记本文件。
- en: 'Import the necessary libraries:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入必要的库：
- en: '[PRE27]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In this step, you import the function called `mean_absolute_error` from `sklearn.metrics`.
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这一步，你从`sklearn.metrics`导入了一个名为`mean_absolute_error`的函数。
- en: 'Import the data:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入数据：
- en: '[PRE28]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In the preceding code, you read in your data. This data is hosted online and
    contains some information about fish toxicity. The data is stored as a CSV but
    does not contain any headers. Also, the columns in this file are not separated
    by a comma, but rather by a semi-colon. The Python list called `_headers` contains
    the names of the column headers.
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码中，你读取了数据。这些数据托管在网上，包含了一些关于鱼类毒性的资料。数据以CSV格式存储，但没有包含任何表头。此外，该文件中的列并非通过逗号分隔，而是通过分号分隔。名为`_headers`的Python列表包含了列的名称。
- en: In the next line, you make use of the function called `read_csv`, which is contained
    in the `pandas` library, to load the data. The first parameter specifies the file
    location. The second parameter specifies the Python list that contains the names
    of the columns in the data. The third parameter specifies the character that is
    used to separate the columns in the data.
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在下一行，你使用名为`read_csv`的函数，该函数包含在`pandas`库中，用于加载数据。第一个参数指定文件位置。第二个参数指定一个包含数据列名的
    Python 列表。第三个参数指定用于分隔数据中列的字符。
- en: 'Split the data into `features` and `labels` and into training and evaluation
    sets:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将数据拆分为`features`和`labels`，并划分为训练集和评估集：
- en: '[PRE29]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In this step, you split your data into training, validation, and test datasets.
    In the first line, you create a `numpy` array in two steps. In the first step,
    the `drop` method takes a parameter with the name of the column to drop from the
    DataFrame. In the second step, you use `values` to convert the DataFrame into
    a two-dimensional `numpy` array that is a tabular structure with rows and columns.
    This array is stored in a variable called `features`.
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这一步，你将数据划分为训练集、验证集和测试集。在第一行，你创建了一个`numpy`数组，分两步进行。第一步，`drop`方法传入一个列名，表示要从 DataFrame
    中删除的列。第二步，你使用`values`将 DataFrame 转换为一个二维的`numpy`数组，这是一种具有行列结构的表格。这个数组被存储在名为`features`的变量中。
- en: In the second line, you convert the column into a `numpy` array that contains
    the label that you would like to predict. You do this by picking out the column
    from the DataFrame and then using `values` to convert it into a `numpy` array.
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在第二行，你将列转换为包含要预测标签的`numpy`数组。你通过从 DataFrame 中提取该列，然后使用`values`将其转换为`numpy`数组。
- en: In the third line, you split the `features` and `labels` using `train_test_split`
    and a ratio of 80:20\. The training data is contained in `X_train` for the features
    and `y_train` for the labels. The evaluation dataset is contained in `X_eval`
    and `y_eval`.
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在第三行，你使用`train_test_split`以80:20的比例拆分`features`和`labels`。训练数据包含在`X_train`中的特征和`y_train`中的标签中。评估数据集包含在`X_eval`和`y_eval`中。
- en: In the fourth line, you split the evaluation dataset into validation and testing
    using `train_test_split`. Because you don't specify the `test_size`, a value of
    `25%` is used. The validation data is stored in `X_val` and `y_val`, while the
    test data is stored in `X_test` and `y_test`.
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在第四行，你使用`train_test_split`将评估数据集拆分为验证集和测试集。由于未指定`test_size`，因此默认值为`25%`。验证数据存储在`X_val`和`y_val`中，而测试数据存储在`X_test`和`y_test`中。
- en: 'Create a simple linear regression model and train it:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个简单的线性回归模型并进行训练：
- en: '[PRE30]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In this step, you make use of your training data to train a model. In the first
    line, you create an instance of `LinearRegression`, which you call `model`. In
    the second line, you train the model using `X_train` and `y_train`. `X_train`
    contains the `features`, while `y_train` contains the `labels`.
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这一步，你使用训练数据来训练模型。在第一行，你创建了一个`LinearRegression`实例，命名为`model`。在第二行，你使用`X_train`和`y_train`训练模型。`X_train`包含`features`，而`y_train`包含`labels`。
- en: 'Now predict the values of our validation dataset:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在预测我们验证数据集的值：
- en: '[PRE31]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: At this point, your model is ready to use. You make use of the `predict` method
    to predict on your data. In this case, you are passing `X_val` as a parameter
    to the function. Recall that `X_va`l is your validation dataset. The result is
    assigned to a variable called `y_pred` and will be used in the next step to compute
    the MAE of the model.
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此时，你的模型已经准备好使用了。你可以使用`predict`方法对数据进行预测。在此案例中，你将`X_val`作为参数传递给该函数。回顾一下，`X_val`是你的验证数据集。结果会被赋值给一个名为`y_pred`的变量，并将在下一步中用于计算模型的
    MAE。
- en: 'Compute the MAE:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算 MAE：
- en: '[PRE32]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In this step, you compute the MAE of the model by using the `mean_absolute_error`
    function and passing in `y_val` and `y_pred`. `y_val` is the label that was provided
    with your training data, and `y_pred` is the prediction from the model. The preceding
    code should give you an MAE value of ~ 0.72434:'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这一步，你使用`mean_absolute_error`函数计算模型的 MAE，传入`y_val`和`y_pred`。`y_val`是提供给训练数据的标签，而`y_pred`是模型的预测结果。前面的代码应该给出约为
    0.72434 的 MAE 值：
- en: '![Figure 6.17 MAE score'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 6.17 MAE 分数'
- en: '](img/B15019_06_17.jpg)'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15019_06_17.jpg)'
- en: Figure 6.17 MAE score
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 6.17 MAE 分数
- en: Both `y_val` and `y_pred` are a `numpy` array that contains the same number
    of elements. The `mean_absolute_error` function subtracts `y_pred` from `y_val`.
    This results in a new array. The elements in the resulting array have the absolute
    function applied to them so that all negative signs are dropped. The average of
    the elements is then computed.
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`y_val` 和 `y_pred` 都是包含相同数量元素的 `numpy` 数组。`mean_absolute_error` 函数将 `y_pred`
    从 `y_val` 中减去，得到一个新数组。结果数组中的元素应用了绝对值函数，确保所有负号被去除。然后计算元素的平均值。'
- en: 'Compute the R2 score of the model:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算模型的 R2 分数：
- en: '[PRE33]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'You should get an output similar to the following:'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该得到类似于以下的输出：
- en: '![Figure 6.18: The R2 score of the model'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 6.18：模型的 R2 分数'
- en: '](img/B15019_06_18.jpg)'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15019_06_18.jpg)'
- en: 'Figure 6.18: The R2 score of the model'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.18：模型的 R2 分数
- en: Note
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The MAE and R2 score may vary depending on the distribution of the datasets.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: MAE 和 R2 分数可能会根据数据集的分布而有所不同。
- en: A higher R2 score means a better model and uses an equation that computes the
    coefficient of determination.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 更高的 R2 分数意味着更好的模型，使用一个计算决定系数的方程。
- en: Note
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/349mG9P](https://packt.live/349mG9P).
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问本节的源代码，请参考 [https://packt.live/349mG9P](https://packt.live/349mG9P)。
- en: You can also run this example online at [https://packt.live/3aA1rza](https://packt.live/3aA1rza).
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在网上运行这个示例，访问 [https://packt.live/3aA1rza](https://packt.live/3aA1rza)。
- en: In this exercise, we have calculated the MAE, which is a significant parameter
    when it comes to evaluating models.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们计算了 MAE，这是评估模型时一个重要的参数。
- en: You will now train a second model and compare its R2 score and MAE to the first
    model to evaluate which is a better performing model.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你将训练第二个模型，并将其 R2 分数和 MAE 与第一个模型进行比较，以评估哪个模型表现更好。
- en: 'Exercise 6.04: Computing the Mean Absolute Error of a Second Model'
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 6.04：计算第二个模型的平均绝对误差（MAE）
- en: In this exercise, we will be engineering new features and finding the score
    and loss of a new model.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将生成新特征，并计算新模型的分数和损失。
- en: 'The following steps will help you with this exercise:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助你完成这个练习：
- en: Open a new Colab notebook file.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的 Colab 笔记本文件。
- en: 'Import the required libraries:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入所需的库：
- en: '[PRE34]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In the first step, you will import libraries such as `train_test_split`, `LinearRegression`,
    and `mean_absolute_error`. We make use of a pipeline to quickly transform our
    features and engineer new features using `MinMaxScaler` and `PolynomialFeatures`.
    `MinMaxScaler` reduces the variance in your data by adjusting all values to a
    range between 0 and 1\. It does this by subtracting the mean of the data and dividing
    by the range, which is the minimum value subtracted from the maximum value. `PolynomialFeatures`
    will engineer new features by raising the values in a column up to a certain power
    and creating new columns in your DataFrame to accommodate them.
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在第一步中，你将导入一些库，如 `train_test_split`、`LinearRegression` 和 `mean_absolute_error`。我们使用管道（pipeline）来快速转换特征，并通过
    `MinMaxScaler` 和 `PolynomialFeatures` 来生成新特征。`MinMaxScaler` 通过将所有值调整到 0 到 1 之间的范围来减少数据的方差。它通过减去数据的均值并除以范围（即最大值减去最小值）来实现这一点。`PolynomialFeatures`
    通过将列中的值提升到某个幂次来生成新特征，并在数据框中创建新列以容纳它们。
- en: 'Read in the data from the dataset:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从数据集中读取数据：
- en: '[PRE35]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In this step, you will read in your data. While the data is stored in a CSV,
    it doesn't have a first row that lists the names of the columns. The Python list
    called `_headers` will hold the column names that you will supply to the `pandas`
    method called `read_csv`.
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这一步，你将读取数据。虽然数据存储在一个 CSV 文件中，但它没有列出列名的第一行。名为 `_headers` 的 Python 列表将保存你要提供给
    `pandas` 方法 `read_csv` 的列名。
- en: In the next line, you call the `read_csv` `pandas` method and supply the location
    and name of the file to be read in, along with the header names and the file separator.
    Columns in the file are separated with a semi-colon.
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在下一行，你调用 `read_csv` 的 `pandas` 方法，并提供要读取的文件的位置和名称，以及列头名称和文件分隔符。文件中的列使用分号分隔。
- en: 'Split the data into training and evaluation sets:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将数据拆分为训练集和评估集：
- en: '[PRE36]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In this step, you begin by splitting the DataFrame called `df` into two. The
    first DataFrame is called `features` and contains all of the independent variables
    that you will use to make your predictions. The second is called `labels` and
    contains the values that you are trying to predict.
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在此步骤中，你首先将名为 `df` 的 DataFrame 拆分为两个部分。第一个 DataFrame 被命名为 `features`，包含你将用来进行预测的所有自变量。第二个
    DataFrame 被命名为 `labels`，其中包含你试图预测的值。
- en: In the third line, you split `features` and `labels` into four sets using `train_test_split`.
    `X_train` and `y_train` contain 80% of the data and are used for training your
    model. `X_eval` and `y_eval` contain the remaining 20%.
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在第三行，你使用 `train_test_split` 将 `features` 和 `labels` 拆分为四个数据集。`X_train` 和 `y_train`
    包含 80% 的数据，用于训练模型。`X_eval` 和 `y_eval` 包含剩余的 20% 数据。
- en: In the fourth line, you split `X_eval` and `y_eval` into two additional sets.
    `X_val` and `y_val` contain 75% of the data because you did not specify a ratio
    or size. `X_test` and `y_test` contain the remaining 25%.
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在第四行，你将 `X_eval` 和 `y_eval` 拆分为两个附加数据集。`X_val` 和 `y_val` 包含 75% 的数据，因为你没有指定比例或大小。`X_test`
    和 `y_test` 包含剩余的 25% 数据。
- en: 'Create a pipeline:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个管道：
- en: '[PRE37]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In this step, you begin by creating a Python list called `steps`. The list contains
    three tuples, each one representing a transformation of a model. The first tuple
    represents a scaling operation. The first item in the tuple is the name of the
    step, which you call `scaler`. This uses `MinMaxScaler` to transform the data.
    The second, called `poly`, creates additional features by crossing the columns
    of data up to the degree that you specify. In this case, you specify `2`, so it
    crosses these columns up to a power of 2\. Next comes your `LinearRegression`
    model.
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在此步骤中，你首先创建一个名为 `steps` 的 Python 列表。列表包含三个元组，每个元组代表模型的一次变换。第一个元组代表缩放操作，元组中的第一个项目是步骤的名称，叫做
    `scaler`。这个步骤使用 `MinMaxScaler` 来转换数据。第二个元组叫做 `poly`，它通过交叉数据的列来创建额外的特征，直到你指定的度数为止。在这个例子中，你指定了
    `2`，因此它会将这些列交叉到 2 次方。接下来是你的 `LinearRegression` 模型。
- en: 'Create a pipeline:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个管道：
- en: '[PRE38]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In this step, you create an instance of `Pipeline` and store it in a variable
    called `model`. `Pipeline` performs a series of transformations, which are specified
    in the steps you defined in the previous step. This operation works because the
    transformers (`MinMaxScaler` and `PolynomialFeatures`) implement two methods called
    `fit()` and `fit_transform()`. You may recall from previous examples that models
    are trained using the `fit()` method that `LinearRegression` implements.
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在此步骤中，你创建了一个 `Pipeline` 的实例，并将其存储在名为 `model` 的变量中。`Pipeline` 执行一系列变换，这些变换在你之前定义的步骤中有所说明。这个操作之所以有效，是因为转换器（`MinMaxScaler`
    和 `PolynomialFeatures`）实现了两个名为 `fit()` 和 `fit_transform()` 的方法。你可能还记得在之前的例子中，模型是使用
    `LinearRegression` 实现的 `fit()` 方法来训练的。
- en: 'Train the model:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 训练模型：
- en: '[PRE39]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'On the next line, you call the `fit` method and provide `X_train` and `y_train`
    as parameters. Because the model is a pipeline, three operations will happen.
    First, `X_train` will be scaled. Next, additional features will be engineered.
    Finally, training will happen using the `LinearRegression` model. The output from
    this step is similar to the following:'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在接下来的行中，你调用 `fit` 方法并提供 `X_train` 和 `y_train` 作为参数。因为模型是一个管道，三个操作将依次进行。首先，`X_train`
    会被缩放。接下来，将生成额外的特征。最后，使用 `LinearRegression` 模型进行训练。此步骤的输出类似于以下内容：
- en: '![Figure 6.19: Training the model'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 6.19：训练模型](img/B15019_06_19.jpg)'
- en: '](img/B15019_06_19.jpg)'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15019_06_19.jpg)'
- en: 'Figure 6.19: Training the model'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 6.19：训练模型
- en: 'Predict using the validation dataset:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用验证数据集进行预测：
- en: '[PRE40]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Compute the MAE of the model:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算模型的 MAE：
- en: '[PRE41]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In the first line, you make use of `mean_absolute_error` to compute the mean
    absolute error. You supply `y_val` and `y_pred`, and the result is stored in the
    `mae` variable. In the following line, you print out `mae`:'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在第一行，你使用 `mean_absolute_error` 来计算平均绝对误差。你传入 `y_val` 和 `y_pred`，结果存储在 `mae`
    变量中。接下来的行中，你打印出 `mae`：
- en: '![Figure 6.20: MAE score'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 6.20：MAE 分数](img/B15019_06_20.jpg)'
- en: '](img/B15019_06_20.jpg)'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15019_06_20.jpg)'
- en: 'Figure 6.20: MAE score'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 6.20：MAE 分数
- en: The loss that you compute at this step is called a validation loss because you
    make use of the validation dataset. This is different from a training loss that
    is computed using the training dataset. This distinction is important to note
    as you study other documentation or books, which might refer to both.
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你在此步骤中计算的损失被称为验证损失，因为你使用了验证数据集。这与使用训练数据集计算的训练损失不同。理解这一点很重要，因为你在阅读其他文档或书籍时，可能会看到这两者的概念。
- en: 'Compute the R2 score:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算 R2 分数：
- en: '[PRE42]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In the final two lines, you compute the R2 score and also display it, as shown
    in the following screenshot:'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在最后两行中，你计算了 R2 分数，并且显示了它，如下面的截图所示：
- en: '![Figure 6.21: R2 score'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 6.21：R2 分数'
- en: '](img/B15019_06_21.jpg)'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15019_06_21.jpg)'
- en: 'Figure 6.21: R2 score'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.21：R2 分数
- en: At this point, you should see a difference between the `R`2 score and the MAE
    of the first model and the second model (in the first model, the `MAE` and `R`2
    scores were `0.781629` and `0.498688` respectively).
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在此时，你应该能看到第一个模型和第二个模型之间的 `R2` 分数和 MAE 的差异（第一个模型的 `MAE` 和 `R2` 分别为 `0.781629`
    和 `0.498688`）。
- en: Note
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/2EjCaNn](https://packt.live/2EjCaNn).
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 若要访问此特定部分的源代码，请参考 [https://packt.live/2EjCaNn](https://packt.live/2EjCaNn)。
- en: You can also run this example online at [https://packt.live/2Yb5vRd](https://packt.live/2Yb5vRd).
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在网上运行这个示例，访问 [https://packt.live/2Yb5vRd](https://packt.live/2Yb5vRd)。
- en: In this exercise, you engineered new features that give you a model with a hypothesis
    of a higher polynomial degree. This model should perform better than simpler models
    up to a certain point. After engineering and training the new model, you computed
    the R2 score and MAE, which you can use to compare this model with the model you
    trained previously. We can conclude that this model is better as it has a higher
    R2 score and a lower MAE.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你构建了新的特征，使得你拥有一个假设更高多项式度的模型。这个模型在某个阶段应当比简单的模型表现得更好。构建并训练完新模型后，你计算了 R2
    分数和 MAE，这可以用来将这个模型与之前训练的模型进行比较。我们可以得出结论，认为这个模型更好，因为它具有更高的 R2 分数和更低的 MAE。
- en: Other Evaluation Metrics
  id: totrans-320
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他评估指标
- en: While we made use of `mean_absolute_error`, there are other model evaluation
    functions for regression. Recall that these are all cost (or loss) functions.
    These include `max_error`, `mean_squared_error`, `mean_squared_log_error`, and
    `median_absolute_error`. If you are working on a project with a data scientist,
    they will normally be responsible for telling you what evaluation metric to make
    use of. If not, then you can choose any metric of your liking.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们使用了 `mean_absolute_error`，但也有其他回归模型评估函数。请记住，这些都属于成本（或损失）函数。包括 `max_error`、`mean_squared_error`、`mean_squared_log_error`
    和 `median_absolute_error`。如果你和数据科学家一起工作，他们通常负责告诉你使用哪种评估指标。如果没有，那么你可以选择任何你喜欢的指标。
- en: The MAE is computed by subtracting every prediction from the ground truth, finding the
    absolute value, summing all the absolute values, and dividing by the number of
    observations. This type of distance measure is called Manhattan distance in data
    mining.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: MAE 是通过从每个预测中减去真实值，取绝对值，求和所有绝对值，然后除以观测值的数量来计算的。这种距离度量在数据挖掘中被称为曼哈顿距离。
- en: The **mean squared error** (**MSE**) is computed by taking the squares of the
    differences between the ground truths and the predictions, summing them, and then
    dividing by the number of observations. The MSE is large, and sometimes the square
    root of this is used, which is the **root mean squared error** (**RMSE**).
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '**均方误差** (**MSE**) 是通过计算地面真值和预测值之间差异的平方，求和后，再除以观测值的数量来计算的。MSE 较大时，有时会使用它的平方根，即
    **均方根误差** (**RMSE**)。'
- en: The **mean squared logarithmic error** (**MSLE**) introduces logarithms into
    the equation by adding one to both the ground truth and the prediction before
    taking the logarithms, then squaring the differences, then summing them, and dividing
    by the number of observations. MSLE has the property of having a lower cost for
    predictions that are above the ground truth than for those that are below it.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '**均方对数误差** (**MSLE**) 在方程中引入了对数，通过在对地面真值和预测值分别加 1 后再取对数，计算差异的平方，然后对它们求和，并除以观测值的数量。MSLE
    的特点是，对于高于地面真值的预测，其代价较低，而对于低于地面真值的预测则代价较高。'
- en: Finally, `median_absolute_error` finds the median value of the absolute errors,
    which are the differences between the ground truths and the predictions.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`median_absolute_error` 计算绝对误差的中位数，绝对误差是地面真值和预测值之间的差异。
- en: Let's now move toward evaluating the performance of classification models.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始评估分类模型的性能。
- en: Assessing Model Performance for Classification Models
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 评估分类模型的性能
- en: Classification models are used for predicting which class a group of features
    will fall under. You learned to create binary classification models in *Chapter
    3*, *Binary Classification*, and multi-class classification models in *Chapter
    4, Multiclass Classification with RandomForest*.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 分类模型用于预测一组特征将属于哪个类别。你在*第3章*《*二分类*》中学会了创建二分类模型，在*第4章，《使用随机森林进行多分类》*中学会了创建多分类模型。
- en: When you consider a classification model, you might start to ask yourself how
    accurate the model is. But how do you evaluate accuracy?
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 当你考虑一个分类模型时，你可能会问自己模型的准确性有多高。那么，如何评估准确性呢？
- en: You need to create a classification model before you can start assessing it.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始评估之前，你需要先创建一个分类模型。
- en: 'Exercise 6.05: Creating a Classification Model for Computing Evaluation Metrics'
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习6.05：创建一个用于计算评估指标的分类模型
- en: In this exercise, you will create a classification model that you will make
    use of later on for model assessment.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将创建一个分类模型，之后你将利用该模型进行评估。
- en: 'You will make use of the cars dataset from the UCI Machine Learning Repository.
    You will use this dataset to classify cars as either acceptable or unacceptable
    based on the following categorical features:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用UCI机器学习库中的汽车数据集。你将利用该数据集，将汽车分类为可接受或不可接受，依据以下分类特征：
- en: '`buying`: the purchase price of the car'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`buying`：汽车的购买价格'
- en: '`maint`: the maintenance cost of the car'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`maint`：汽车的维护成本'
- en: '`doors`: the number of doors on the car'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`doors`：车门的数量'
- en: '`persons`: the carrying capacity of the vehicle'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`persons`：车辆的载客量'
- en: '`lug_boot`: the size of the luggage boot'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lug_boot`：行李厢的大小'
- en: '`safety`: the estimated safety of the car'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`safety`：汽车的安全性估计'
- en: Note
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the dataset here: [https://packt.live/30I594E](https://packt.live/30I594E).'
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以在这里找到数据集：[https://packt.live/30I594E](https://packt.live/30I594E)。
- en: 'The following steps will help you achieve the task:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助你完成任务：
- en: Open a new Colab notebook.
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的Colab笔记本。
- en: 'Import the libraries you will need:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入你需要的库：
- en: '[PRE43]'
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In this step, you import `pandas` and alias it as `pd`. `pandas` is needed for
    reading data into a DataFrame. You also import `train_test_split`, which is needed
    for splitting your data into training and evaluation datasets. Finally, you also
    import the `LogisticRegression` class.
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这一步，你导入了`pandas`并将其别名设置为`pd`。`pandas`用于将数据读取到数据框中。你还导入了`train_test_split`，它用于将数据拆分为训练集和评估集。最后，你还导入了`LogisticRegression`类。
- en: 'Import your data:'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入你的数据：
- en: '[PRE44]'
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In this step, you create a Python list called `_headers` to hold the names of
    the columns in the file you will be importing because the file doesn't have a
    header. You  then proceed to read the file into a DataFrame named `df` by using
    `pd.read_csv` and specifying the file location as well as the list containing
    the file headers. Finally, you display the first five rows using `df.head()`.
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这一步，你创建了一个名为`_headers`的Python列表，用来保存你将要导入的文件中的列名，因为该文件没有标题。然后，你使用`pd.read_csv`读取文件并指定文件位置以及包含文件标题的列表，最后通过`df.head()`显示前五行数据。
- en: 'You should get an output similar to the following:'
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该得到类似于以下的输出：
- en: '![Figure 6.22: Inspecting the DataFrame'
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图6.22：检查数据框'
- en: '](img/B15019_06_22.jpg)'
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15019_06_22.jpg)'
- en: 'Figure 6.22: Inspecting the DataFrame'
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图6.22：检查数据框
- en: 'Encode categorical variables as shown in the following code snippet:'
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下代码片段对分类变量进行编码：
- en: '[PRE45]'
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In this step, you convert categorical columns into numeric columns using a technique
    called one-hot encoding. You saw an example of this in *Step 13* of *Exercise
    3.04*, *Feature Engineering – Creating New Features from Existing Ones*. You need
    to do this because the inputs to your model must be numeric. You get numeric variables
    from categorical variables using `get_dummies` from the `pandas` library. You
    provide your DataFrame as input and specify the columns to be encoded. You assign
    the result to a new DataFrame called `_df`, and then inspect the result using
    `head()`.
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这一步，你使用一种称为独热编码的技术，将分类列转换为数值列。你在*第13步*《*练习3.04*》的*特征工程——从现有特征创建新特征*中看到了这个示例。你需要这样做，因为模型的输入必须是数值型的。你可以通过`pandas`库中的`get_dummies`方法，从分类变量中得到数值型变量。你将数据框作为输入，指定需要编码的列，然后将结果赋值给一个新的数据框`_df`，最后使用`head()`查看结果。
- en: 'The output should now resemble the following screenshot:'
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出应类似于以下截图：
- en: '![Figure 6.23: Encoding categorical variables'
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图6.23：编码分类变量'
- en: '](img/B15019_06_23.jpg)'
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15019_06_23.jpg)'
- en: 'Figure 6.23: Encoding categorical variables'
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图6.23：编码分类变量
- en: Note
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: The output has been truncated for presentation purposes. Please find the complete
    output at [https://packt.live/3aBNlg7](https://packt.live/3aBNlg7).
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出已被截断以便展示。请在[https://packt.live/3aBNlg7](https://packt.live/3aBNlg7)查看完整的输出。
- en: 'Split the data into training and validation sets:'
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将数据分为训练集和验证集：
- en: '[PRE46]'
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In this step, you begin by extracting your feature columns and your labels into
    two NumPy arrays called `features` and `labels`. You then proceed to extract 70%
    into `X_train` and `y_train`, with the remaining 30% going into `X_eval` and `y_eval`.
    You then further split `X_eval` and `y_eval` into two equal parts and assign those
    to `X_val` and `y_val` for validation, and `X_test` and `y_test` for testing much
    later.
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这一步中，首先将特征列和标签提取到两个NumPy数组中，分别命名为`features`和`labels`。然后将70%的数据提取到`X_train`和`y_train`中，剩余的30%数据存入`X_eval`和`y_eval`中。接着，将`X_eval`和`y_eval`再分为两个相等的部分，分别赋值给`X_val`和`y_val`用于验证，以及`X_test`和`y_test`用于之后的测试。
- en: 'Train a logistic regression model:'
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 训练逻辑回归模型：
- en: '[PRE47]'
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In this step, you create an instance of `LogisticRegression` and train the model
    on your training data by passing in `X_train` and `y_train` to the `fit` method.
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这一步，你创建一个`LogisticRegression`实例，并通过将`X_train`和`y_train`传递给`fit`方法来训练模型。
- en: 'You should get an output that looks similar to the following:'
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该获得一个类似于以下的输出：
- en: '![Figure 6.24: Training a logistic regression model'
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图6.24：训练逻辑回归模型'
- en: '](img/B15019_06_24.jpg)'
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15019_06_24.jpg)'
- en: 'Figure 6.24: Training a logistic regression model'
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图6.24：训练逻辑回归模型
- en: 'Make a prediction:'
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进行预测：
- en: '[PRE48]'
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'In this step, you make a prediction on the validation dataset, `X_val`, and
    store the result in `y_pred`. A look at the first 10 predictions (by executing
    `y_pred[0:9]`) should provide an output similar to the following:'
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这一步，你对验证数据集`X_val`进行预测，并将结果存储在`y_pred`中。通过查看前10个预测结果（执行`y_pred[0:9]`），你应该能获得类似于以下的输出：
- en: '![Figure 6.25: Prediction for the validation set'
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图6.25：验证集的预测结果'
- en: '](img/B15019_06_25.jpg)'
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15019_06_25.jpg)'
- en: 'Figure 6.25: Prediction for the validation set'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.25：验证集的预测结果
- en: This model works because you are able to use it to make predictions. The predictions
    classify each car as acceptable (`acc`) or unacceptable (`unacc`) based on the
    features of the car. At this point, you are ready to apply various assessments
    to the model.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模型之所以有效，是因为你能够用它来进行预测。这些预测将每辆车分类为可接受(`acc`)或不可接受(`unacc`)，根据汽车的特征。在此时，你已经准备好对模型进行各种评估。
- en: Note
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/3aBNlg7](https://packt.live/3aBNlg7).
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此部分的源代码，请参考[https://packt.live/3aBNlg7](https://packt.live/3aBNlg7)。
- en: You can also run this example online at [https://packt.live/34eg7CH](https://packt.live/34eg7CH).
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以在线运行这个示例，网址是[https://packt.live/34eg7CH](https://packt.live/34eg7CH)。
- en: Thus, we have successfully created a classification model to make predictions,
    and we will assess the performance of the model in future exercises.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经成功创建了一个分类模型来进行预测，并将在未来的练习中评估该模型的表现。
- en: In this exercise, we trained this logistic regression model once so that we
    don't need to do it repeatedly because of the number of steps involved. In the
    next section, you will be looking at confusion matrices.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 在本次练习中，我们只训练了一次逻辑回归模型，以免重复执行，因为这个过程步骤较多。在接下来的部分，你将查看混淆矩阵。
- en: The Confusion Matrix
  id: totrans-385
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 混淆矩阵
- en: You encountered the confusion matrix in *Chapter 3, Binary Classification*.
    You may recall that the confusion matrix compares the number of classes that the
    model predicted against the actual occurrences of those classes in the validation
    dataset. The output is a square matrix that has the number of rows and columns
    equal to the number of classes you are predicting. The columns represent the actual
    values, while the rows represent the predictions. You get a confusion matrix by
    using `confusion_matrix` from `sklearn.metrics`.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 你在*第3章，二分类*中遇到过混淆矩阵。你可能记得，混淆矩阵将模型预测的类别数量与验证数据集中这些类别的实际出现情况进行比较。输出结果是一个方阵，行数和列数等于你要预测的类别数。列表示实际值，而行表示预测值。你可以通过使用`sklearn.metrics`中的`confusion_matrix`来得到混淆矩阵。
- en: 'Exercise 6.06: Generating a Confusion Matrix for the Classification Model'
  id: totrans-387
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习6.06：为分类模型生成混淆矩阵
- en: The goal of this exercise is to create a confusion matrix for the classification
    model you trained in *Exercise 6.05*, *Creating a Classification Model for Computing
    Evaluation Metrics*.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习的目标是为你在*练习 6.05*中训练的分类模型创建一个混淆矩阵，*创建一个用于计算评估指标的分类模型*。
- en: Note
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You should continue this exercise in the same notebook as that used in *Exercise
    6.05, Creating a Classification Model for Computing Evaluation Metrics.* If you
    wish to use a new notebook, make sure you copy and run the entire code from *Exercise
    6.05*, *Creating a Classification Model for Computing Evaluation Metrics*, and
    then begin with the execution of the code of this exercise.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 你应在与*练习 6.05, 创建一个用于计算评估指标的分类模型*相同的笔记本中继续此练习。如果你希望使用新的笔记本，请确保复制并运行*练习 6.05,
    创建一个用于计算评估指标的分类模型*中的所有代码，然后开始执行本练习的代码。
- en: 'The following steps will help you achieve the task:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助你完成任务：
- en: Open a new Colab notebook file.
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的Colab笔记本文件。
- en: 'Import `confusion_matrix`:'
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`confusion_matrix`：
- en: '[PRE49]'
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In this step, you import `confusion_matrix` from `sklearn.metrics`. This function
    will let you generate a confusion matrix.
  id: totrans-395
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这一步，你需要从`sklearn.metrics`导入`confusion_matrix`。此函数将帮助你生成混淆矩阵。
- en: 'Generate a confusion matrix:'
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成混淆矩阵：
- en: '[PRE50]'
  id: totrans-397
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In this step, you generate a confusion matrix by supplying `y_val`, the actual
    classes, and `y_pred`, the predicted classes.
  id: totrans-398
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这一步，你通过提供`y_val`（实际类别）和`y_pred`（预测类别）来生成混淆矩阵。
- en: 'The output should look similar to the following:'
  id: totrans-399
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出应类似于以下内容：
- en: '![Figure 6.26: Confusion matrix'
  id: totrans-400
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 6.26: 混淆矩阵'
- en: '](img/B15019_06_26.jpg)'
  id: totrans-401
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15019_06_26.jpg)'
- en: 'Figure 6.26: Confusion matrix'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '图 6.26: 混淆矩阵'
- en: Note
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/3hbreQz](https://packt.live/3hbreQz).
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参考[https://packt.live/3hbreQz](https://packt.live/3hbreQz)。
- en: You can also run this example online at [https://packt.live/2EebSMD](https://packt.live/2EebSMD).
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以在[https://packt.live/2EebSMD](https://packt.live/2EebSMD)上在线运行此示例。
- en: We can see that our data has four classes. The first column shows all of the
    data that should belong to the first class. The first row shows the number of
    predictions that were correctly placed in the first class. In this example, that
    number is `41`. The second row shows the number of predictions that were placed
    in the second class but should have been in the first class. In this example,
    that number is `7`. In the third row, you see the number of items that were predicted
    to be in the third class but should have been in the first class. That number
    is `7`. Finally, in the fourth row, you see the number of items that were wrongly
    classified into the fourth class when they should have been in the first class.
    In this case, the number is `1`.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到数据有四个类别。第一列显示所有应该属于第一类的数据。第一行显示正确放入第一类的预测数量。在本示例中，这个数字是`41`。第二行显示被预测为第二类，但应该属于第一类的数据数量。在本示例中，这个数字是`7`。第三行显示被预测为第三类，但应该属于第一类的数据数量。这个数字是`7`。最后，第四行显示被错误分类为第四类，实际上应该属于第一类的数据数量。在本例中，数字是`1`。
- en: More on the Confusion Matrix
  id: totrans-407
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于混淆矩阵的更多内容
- en: The confusion matrix helps you analyze the impact of the choices you would have
    to make if you put the model into production. Let's consider the example of predicting
    the presence of a disease based on the inputs to the model. This is a binary classification
    problem, where 1 implies that the disease is present and 0 implies the disease
    is absent. The confusion matrix for this model would have two columns and two
    rows.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 混淆矩阵帮助你分析如果将模型投入生产，你需要做出的决策的影响。假设我们预测某种疾病的存在与否，基于输入数据进行判断。这是一个二分类问题，其中1表示疾病存在，0表示疾病不存在。该模型的混淆矩阵将有两列和两行。
- en: The first column would show the items that fall into class `true negatives`.
    The second row would show the items that were wrongly classified as `false positives`.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 第一列会显示属于`真阴性`类别的项目。第二行会显示被错误分类为`假阳性`的项目。
- en: The second column would show the items that fall into class `false negatives`.
    Finally, the second row shows items that were correctly classified into class
    1 and are called `true positives`.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 第二列会显示属于`假阴性`类别的项目。最后，第二行显示正确分类到类别1的项目，这些称为`真正例`。
- en: False positives are the cases in which the samples were wrongly predicted to
    be infected when they are actually healthy. The implication of this is that these
    cases would be treated for a disease that they do not have.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 假阳性是指样本被错误预测为感染者，而实际上它们是健康的。其影响是这些病例会被误诊为患有某种疾病。
- en: False negatives are the cases that were wrongly predicted to be healthy when
    they actually have the disease. The implication of this is that these cases would
    not be treated for a disease that they actually have.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 假阴性是指那些被错误预测为健康的样本，实际上它们患有该病。其影响是这些病例不会得到治疗，尽管它们实际上患有该病。
- en: The question you need to ask about this model depends on the nature of the disease
    and requires domain expertise about the disease. For example, if the disease is
    contagious, then the untreated cases will be released into the general population
    and could infect others. What would be the implication of this versus placing
    cases into quarantine and observing them for symptoms?
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要问的关于这个模型的问题取决于疾病的性质，并需要关于该疾病的领域专业知识。例如，如果该疾病具有传染性，那么未治疗的病例将被释放到普通人群中，可能会感染其他人。与将这些病例隔离并观察其症状相比，这将产生什么影响？
- en: On the other hand, if the disease is not contagious, the question becomes that
    of the implications of treating people for a disease they do not have versus the
    implications of not treating cases of a disease.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果该疾病不具传染性，问题就变成了治疗那些不患病的人与不治疗患病人群的影响。
- en: It should be clear that there isn't a definite answer to these questions. The
    model would need to be tuned to provide performance that is acceptable to the
    users.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 应该清楚的是，这些问题并没有明确的答案。该模型需要进行调整，以提供对用户可接受的性能。
- en: Precision
  id: totrans-416
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 精确度
- en: 'Precision was introduced in *Chapter 3, Binary Classification*; however, we
    will be looking at it in more detail in this chapter. The precision is the total
    number of cases that were correctly classified as positive (called **true positive**
    and abbreviated as **TP**) divided by the total number of cases in that prediction
    (that is, the total number of entries in the row, both correctly classified (TP)
    and wrongly classified (FP) from the confusion matrix). Suppose 10 entries were
    classified as positive. If 7 of the entries were actually positive, then TP would
    be 7 and FP would be 3\. The precision would, therefore, be 0.7\. The equation
    is given as follows:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 精确度在*第 3 章，二分类*中已经介绍；然而，在本章中我们将更详细地讨论它。精确度是将正确分类为阳性的样本数量（称为**真正阳性**，缩写为**TP**）除以该预测中的总样本数（即该行中的所有条目总数，包括正确分类（TP）和错误分类（FP）来自混淆矩阵）。假设有
    10 个条目被分类为阳性。如果其中 7 个条目实际为阳性，那么 TP 就是 7，FP 就是 3。因此，精确度为 0.7。公式如下所示：
- en: '![Figure 6.27: Equation for precision'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.27：精确度公式'
- en: '](img/B15019_06_27.jpg)'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15019_06_27.jpg)'
- en: 'Figure 6.27: Equation for precision'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.27：精确度公式
- en: 'In the preceding equation:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述公式中：
- en: '`tp` is true positive – the number of predictions that were correctly classified
    as belonging to that class.'
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tp` 是真正阳性——正确分类为该类别的预测数量。'
- en: '`fp` is false positive – the number of predictions that were wrongly classified
    as belonging to that class.'
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fp` 是假阳性——被错误分类为该类别的预测数量。'
- en: The function in `sklearn.metrics` to compute precision is called `precision_score`.
    Go ahead and give it a try.
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于计算精确度的 `sklearn.metrics` 函数是 `precision_score`。不妨试试看。
- en: 'Exercise 6.07: Computing Precision for the Classification Model'
  id: totrans-425
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 6.07：计算分类模型的精确度
- en: In this exercise, you will be computing the precision for the classification
    model you trained in *Exercise 6.05*, *Creating a Classification Model for Computing
    Evaluation Metrics*.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 在本练习中，你将计算在*练习 6.05，创建分类模型以计算评估指标*中训练的分类模型的精确度。
- en: Note
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 注
- en: You should continue this exercise in the same notebook as that used in *Exercise
    6.05, Creating a Classification Model for Computing Evaluation Metrics.* If you
    wish to use a new notebook, make sure you copy and run the entire code from *Exercise
    6.05*, *Creating a Classification Model for Computing Evaluation Metrics*, and
    then begin with the execution of the code of this exercise.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在与*练习 6.05，创建分类模型以计算评估指标*相同的笔记本中继续此练习。如果你想使用新的笔记本，请确保复制并运行*练习 6.05，创建分类模型以计算评估指标*中的完整代码，然后开始执行本练习中的代码。
- en: 'The following steps will help you achieve the task:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助您完成任务：
- en: 'Import the required libraries:'
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入所需的库：
- en: '[PRE51]'
  id: totrans-431
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: In this step, you import `precision_score` from `sklearn.metrics`.
  id: totrans-432
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这一步，您需要从`sklearn.metrics`导入`precision_score`。
- en: 'Next, compute the precision score as shown in the following code snippet:'
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，计算精度得分，如下所示的代码片段所示：
- en: '[PRE52]'
  id: totrans-434
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: In this step, you compute the precision score using `precision_score`.
  id: totrans-435
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这一步，您使用`precision_score`计算精度得分。
- en: 'The output is a floating-point number between 0 and 1\. It might look like
    this:'
  id: totrans-436
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出是一个介于0和1之间的浮动数字。它可能看起来像这样：
- en: '![Figure 6.28: Precision score'
  id: totrans-437
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图6.28：精度得分'
- en: '](img/B15019_06_28.jpg)'
  id: totrans-438
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15019_06_28.jpg)'
- en: 'Figure 6.28: Precision score'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.28：精度得分
- en: Note
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The precision score can vary depending on the data.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 精度得分可能会因数据而异。
- en: In this exercise, you see the precision score for the classification model is
    `0.9245`. **92%** could be a good score and is acceptable in some domains, but
    is a low score in certain domains. So there is scope for improvement.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您会看到分类模型的精度得分是`0.9245`。**92%**可能是一个不错的分数，在一些领域是可以接受的，但在某些领域则较低。因此，还有改进的空间。
- en: Note
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/3kROW6R](https://packt.live/3kROW6R).
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参考[https://packt.live/3kROW6R](https://packt.live/3kROW6R)。
- en: You can also run this example online at [https://packt.live/3aCS8ye](https://packt.live/3aCS8ye).
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在线运行此示例，访问[https://packt.live/3aCS8ye](https://packt.live/3aCS8ye)。
- en: Think of the precision score as asking how often does this model make the correct
    prediction for a class? The value needs to be much closer to 1 than the score
    we just achieved.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 将精度得分视为问这个模型在某个类别上做出正确预测的频率吗？该值需要比我们刚刚达到的得分更接近1。
- en: Recall
  id: totrans-447
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 召回率
- en: 'Recall is the total number of predictions that were true divided by the number
    of predictions for the class, both true and false. Think of it as the true positive
    divided by the sum of entries in the column. The equation is given as follows:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 召回率是正确预测的总数除以该类别的预测总数（包括正确和错误的预测）。可以将其视为真正例除以列中的所有条目之和。公式如下：
- en: '![Figure 6.29: Equation for recall'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.29：召回率公式'
- en: '](img/B15019_06_29.jpg)'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15019_06_29.jpg)'
- en: 'Figure 6.29: Equation for recall'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.29：召回率公式
- en: The function for this is `recall_score`, which is available from `sklearn.metrics`.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数是`recall_score`，它可以从`sklearn.metrics`获得。
- en: 'Exercise 6.08: Computing Recall for the Classification Model'
  id: totrans-453
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习6.08：计算分类模型的召回率
- en: The goal of this exercise is to compute the recall for the classification model
    you trained in *Exercise 6.05*, *Creating a Classification Model for Computing
    Evaluation Metrics*.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习的目标是计算您在*练习6.05*中训练的分类模型的召回率，*创建一个计算评估指标的分类模型*。
- en: Note
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You should continue this exercise in the same notebook as that used in *Exercise
    6.05, Creating a Classification Model for Computing Evaluation Metrics.* If you
    wish to use a new notebook, make sure you copy and run the entire code from *Exercise
    6.05*, *Creating a Classification Model for Computing Evaluation Metrics*, and
    then begin with the execution of the code of this exercise.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该在与*练习6.05：创建一个计算评估指标的分类模型*中使用的相同笔记本中继续进行这个练习。如果您想使用新的笔记本，请确保复制并运行*练习6.05*中的所有代码，然后开始执行本练习的代码。
- en: 'The following steps will help you accomplish the task:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助您完成任务：
- en: Open a new Colab notebook file.
  id: totrans-458
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的Colab笔记本文件。
- en: 'Now, import the required libraries:'
  id: totrans-459
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，导入所需的库：
- en: '[PRE53]'
  id: totrans-460
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: In this step, you import `recall_score` from `sklearn.metrics`. This is the
    function that you will make use of in the second step.
  id: totrans-461
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这一步，您从`sklearn.metrics`导入`recall_score`。这是您将在第二步中使用的函数。
- en: 'Compute the recall:'
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算召回率：
- en: '[PRE54]'
  id: totrans-463
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: In this step, you compute the recall by using `recall_score`. You need to specify
    `y_val` and `y_pred` as parameters to the function. The documentation for `recall_score`
    explains the values that you can supply to `average`. If your model does binary
    prediction and the labels are `0` and `1`, you can set `average` to `binary`.
    Other options are `micro`, `macro`, `weighted`, and `samples`. You should read
    the documentation to see what they do.
  id: totrans-464
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这一步，您使用`recall_score`计算召回率。您需要将`y_val`和`y_pred`作为参数传递给该函数。`recall_score`的文档解释了您可以提供给`average`的值。如果您的模型进行二元预测，并且标签是`0`和`1`，您可以将`average`设置为`binary`。其他选项包括`micro`、`macro`、`weighted`和`samples`。您应该阅读文档以了解它们的作用。
- en: 'You should get an output that looks like the following:'
  id: totrans-465
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您应该得到如下所示的输出：
- en: '![Figure 6.30: Recall score'
  id: totrans-466
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 6.30：召回率得分'
- en: '](img/B15019_06_30.jpg)'
  id: totrans-467
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15019_06_30.jpg)'
- en: 'Figure 6.30: Recall score'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.30：召回率得分
- en: Note
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The recall score can vary, depending on the data.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 召回率得分会有所变化，具体取决于数据。
- en: As you can see, we have calculated the recall score in the exercise, which is
    `0.622`. This means that of the total number of classes that were predicted, `62%`
    of them were correctly predicted. On its own, this value might not mean much until
    it is compared to the recall score from another model.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们在练习中计算了召回率得分，结果为`0.622`。这意味着在所有预测的类别中，`62%`是正确预测的。单独看这个值可能不太有意义，直到将其与其他模型的召回率得分进行比较。
- en: Note
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/31axPp6](https://packt.live/31axPp6).
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问该部分的源代码，请参阅[https://packt.live/31axPp6](https://packt.live/31axPp6)。
- en: You can also run this example online at [https://packt.live/2YdNv8O](https://packt.live/2YdNv8O).
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在[https://packt.live/2YdNv8O](https://packt.live/2YdNv8O)在线运行这个示例。
- en: Let's now move toward calculating the F1 score, which also helps greatly in
    evaluating the model performance, which in turn aids in making better decisions
    when choosing models.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来计算 F1 分数，这也对评估模型表现有很大帮助，进而帮助你在选择模型时做出更好的决策。
- en: F1 Score
  id: totrans-476
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: F1 分数
- en: 'The F1 score is another important parameter that helps us to evaluate the model
    performance. It considers the contribution of both precision and recall using
    the following equation:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: F1 分数是另一个重要的参数，帮助我们评估模型的表现。它通过以下公式同时考虑精度和召回率的贡献：
- en: '![Figure 6.31: F1 score'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.31：F1 分数'
- en: '](img/B15019_06_31.jpg)'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15019_06_31.jpg)'
- en: 'Figure 6.31: F1 score'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.31：F1 分数
- en: The F1 score ranges from 0 to 1, with 1 being the best possible score. You compute
    the F1 score using `f1_score` from `sklearn.metrics`.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: F1 分数的范围是从 0 到 1，1 是最好的得分。你可以使用来自`sklearn.metrics`的`f1_score`来计算 F1 分数。
- en: 'Exercise 6.09: Computing the F1 Score for the Classification Model'
  id: totrans-482
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 6.09：计算分类模型的 F1 分数
- en: In this exercise, you will compute the F1 score for the classification model
    you trained in *Exercise 6.05*, *Creating a Classification Model for Computing
    Evaluation Metrics*.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 在此练习中，你将计算在*练习 6.05*中训练的分类模型的 F1 分数，*创建分类模型以计算评估指标*。
- en: Note
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You should continue this exercise in the same notebook as that used in *Exercise
    6.05, Creating a Classification Model for Computing Evaluation Metrics.* If you
    wish to use a new notebook, make sure you copy and run the entire code from *Exercise
    6.05*, *Creating a Classification Model for Computing Evaluation Metrics*, and
    then begin with the execution of the code of this exercise.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 你应在与*练习 6.05，创建分类模型以计算评估指标*相同的笔记本中继续此练习。如果你希望使用新的笔记本，确保复制并运行*练习 6.05*中的全部代码，*创建分类模型以计算评估指标*，然后再开始本练习的代码执行。
- en: 'The following steps will help you accomplish the task:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助你完成任务：
- en: Open a new Colab notebook file.
  id: totrans-487
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的 Colab 笔记本文件。
- en: 'Import the necessary modules:'
  id: totrans-488
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入必要的模块：
- en: '[PRE55]'
  id: totrans-489
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: In this step, you import the `f1_score` method from `sklearn.metrics`. This
    score will let you compute evaluation metrics.
  id: totrans-490
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在此步骤中，你将从`sklearn.metrics`导入`f1_score`方法。这个分数将帮助你计算评估指标。
- en: 'Compute the F1 score:'
  id: totrans-491
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算 F1 分数：
- en: '[PRE56]'
  id: totrans-492
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: In this step, you compute the F1 score by passing in `y_val` and `y_pred`. You
    also specify `average='macro'` because this is not binary classification.
  id: totrans-493
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在此步骤中，你通过传入`y_val`和`y_pred`来计算 F1 分数。同时，由于这不是二分类问题，你还需指定`average='macro'`。
- en: 'You should get an output similar to the following:'
  id: totrans-494
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该得到类似如下的输出：
- en: '![Figure 6.32: F1 score'
  id: totrans-495
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 6.32：F1 分数'
- en: '](img/B15019_06_32.jpg)'
  id: totrans-496
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15019_06_32.jpg)'
- en: 'Figure 6.32: F1 score'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.32：F1 分数
- en: Note
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/3iWCqkq](https://packt.live/3iWCqkq).
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问该部分的源代码，请参阅[https://packt.live/3iWCqkq](https://packt.live/3iWCqkq)。
- en: You can also run this example online at [https://packt.live/2Q84epY](https://packt.live/2Q84epY).
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在[https://packt.live/2Q84epY](https://packt.live/2Q84epY)在线运行这个示例。
- en: By the end of this exercise, you will see that the `F1` score we achieved is
    `0.6746`. There is a lot of room for improvement, and you would engineer new features
    and train a new model to try and get a better F1 score.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 在本练习结束时，你将看到我们获得的`F1`分数为`0.6746`。仍有很大的改进空间，你可以通过构建新特征和训练新模型来尝试获得更好的 F1 分数。
- en: Accuracy
  id: totrans-502
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准确率
- en: Accuracy is an evaluation metric that is applied to classification models. It
    is computed by counting the number of labels that were correctly predicted, meaning
    that the predicted label is exactly the same as the ground truth. The `accuracy_score()`
    function exists in `sklearn.metrics` to provide this value.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 准确率是应用于分类模型的评估指标。它通过计算正确预测的标签数量来得出，即预测标签与真实标签完全一致。`accuracy_score()`函数存在于`sklearn.metrics`中，用于提供此值。
- en: 'Exercise 6.10: Computing Model Accuracy for the Classification Model'
  id: totrans-504
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 6.10：计算分类模型的准确率
- en: The goal of this exercise is to compute the accuracy score of the model trained
    in *Exercise 6.04*, *Computing the Mean Absolute Error of a Second Model*.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习的目标是计算在*练习 6.04*中训练的模型的准确率分数，*计算第二个模型的平均绝对误差*。
- en: Note
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You should continue this exercise in the same notebook as that used in *Exercise
    6.05, Creating a Classification Model for Computing Evaluation Metrics.* If you
    wish to use a new notebook, make sure you copy and run the entire code from *Exercise
    6.05*, *Creating a Classification Model for Computing Evaluation Metrics*, and
    then begin with the execution of the code of this exercise.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在与*练习 6.05, 创建一个分类模型以计算评估指标*相同的笔记本中继续本练习。如果你希望使用一个新的笔记本，请确保复制并运行*练习 6.05*中的完整代码，然后开始执行本练习的代码。
- en: 'The following steps will help you accomplish the task:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助你完成任务：
- en: Continue from where the code for *Exercise 6.05*, *Creating a Classification
    Model for Computing Evaluation Metrics*, ends in your notebook.
  id: totrans-509
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从*练习 6.05*，*创建一个分类模型以计算评估指标*中的代码结束处开始，继续在你的笔记本中操作。
- en: 'Import `accuracy_score()`:'
  id: totrans-510
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`accuracy_score()`：
- en: '[PRE57]'
  id: totrans-511
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: In this step, you import `accuracy_score()`, which you will use to compute the
    model accuracy.
  id: totrans-512
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在此步骤中，你导入了`accuracy_score()`，该函数将用于计算模型的准确率。
- en: 'Compute the accuracy:'
  id: totrans-513
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算准确率：
- en: '[PRE58]'
  id: totrans-514
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: In this step, you compute the model accuracy by passing in `y_val` and `y_pred`
    as parameters to `accuracy_score()`. The interpreter assigns the result to a variable
    called `c`. The `print()` method causes the interpreter to render the value of
    `_accuracy`.
  id: totrans-515
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在此步骤中，通过将`y_val`和`y_pred`作为参数传递给`accuracy_score()`来计算模型的准确率。解释器将结果赋值给名为`c`的变量。`print()`方法会导致解释器呈现`_accuracy`的值。
- en: 'The result is similar to the following:'
  id: totrans-516
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 结果类似于以下内容：
- en: '![Figure 6.33 Accuracy score'
  id: totrans-517
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 6.33 准确率分数'
- en: '](img/B15019_06_33.jpg)'
  id: totrans-518
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15019_06_33.jpg)'
- en: Figure 6.33 Accuracy score
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.33 准确率分数
- en: Note
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/2Q6K5Ao](https://packt.live/2Q6K5Ao).
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问该特定部分的源代码，请参考[https://packt.live/2Q6K5Ao](https://packt.live/2Q6K5Ao)。
- en: You can also run this example online at [https://packt.live/2Ye55JT](https://packt.live/2Ye55JT).
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在线运行这个示例，网址是[https://packt.live/2Ye55JT](https://packt.live/2Ye55JT)。
- en: Thus, we have successfully calculated the accuracy of the model as being `0.876`.
    The goal of this exercise is to show you how to compute the accuracy of a model
    and to compare this accuracy value to that of another model that you will train
    in the future.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们成功地计算出了模型的准确率为`0.876`。本练习的目标是向你展示如何计算模型的准确率，并将此准确率与未来你将训练的另一个模型的准确率进行比较。
- en: Logarithmic Loss
  id: totrans-524
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对数损失
- en: The logarithmic loss (or log loss) is the loss function for categorical models.
    It is also called categorical cross-entropy. It seeks to penalize incorrect predictions.
    The `sklearn` documentation defines it as "the negative log-likelihood of the
    true values given your model predictions."
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 对数损失（或 log 损失）是分类模型的损失函数，也称为分类交叉熵。它旨在惩罚不正确的预测。`sklearn` 文档将其定义为“给定模型预测值下，真实值的负对数似然”。
- en: 'Exercise 6.11: Computing the Log Loss for the Classification Model'
  id: totrans-526
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 6.11：计算分类模型的对数损失
- en: The goal of this exercise is to predict the log loss of the model trained in
    *Exercise 6.05*, *Creating a Classification Model for Computing Evaluation Metrics*.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习的目标是预测在*练习 6.05*中训练的模型的对数损失，*创建一个分类模型以计算评估指标*。
- en: Note
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You should continue this exercise in the same notebook as that used in *Exercise
    6.05, Creating a Classification Model for Computing Evaluation Metrics.* If you
    wish to use a new notebook, make sure you copy and run the entire code from *Exercise
    6.05* and then begin with the execution of the code of this exercise.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在与*练习 6.05, 创建一个分类模型以计算评估指标*相同的笔记本中继续本练习。如果你希望使用一个新的笔记本，请确保复制并运行*练习 6.05*中的完整代码，然后开始执行本练习的代码。
- en: 'The following steps will help you accomplish the task:'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助您完成任务：
- en: Open your Colab notebook and continue from where *Exercise 6.05*, *Creating
    a Classification Model for Computing Evaluation Metrics*, stopped.
  id: totrans-531
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开您的 Colab 笔记本，并继续从*练习 6.05*，*创建分类模型以计算评估指标*，的停止处继续。
- en: 'Import the required libraries:'
  id: totrans-532
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入所需的库：
- en: '[PRE59]'
  id: totrans-533
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: In this step, you import `log_loss()` from `sklearn.metrics`.
  id: totrans-534
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在此步骤中，您导入了`log_loss()`来自`sklearn.metrics`。
- en: 'Compute the log loss:'
  id: totrans-535
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算对数损失：
- en: '[PRE60]'
  id: totrans-536
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'In this step, you compute the log loss and store it in a variable called `_loss`.
    You need to observe something very important: previously, you made use of `y_val`,
    the ground truths, and `y_pred`, the predictions.'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 在此步骤中，您计算对数损失并将其存储在一个名为`_loss`的变量中。您需要观察一个非常重要的事项：之前，您使用了`y_val`（真实值）和`y_pred`（预测值）。
- en: In this step, you do not make use of predictions. Instead, you make use of predicted
    probabilities. You see that in the code where you specify `model.predict_proba()`.
    You specify the validation dataset and it returns the predicted probabilities.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 在此步骤中，您不使用预测值，而是使用预测的概率。您可以看到在代码中，您指定了`model.predict_proba()`。您指定了验证数据集，并且它返回预测的概率。
- en: The `print()` function causes the interpreter to render the log loss.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: '`print()`函数使解释器呈现日志损失。'
- en: 'This should look like the following:'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该如下所示：
- en: '![Figure 6.34: Log loss output'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.34：对数损失输出'
- en: '](img/B15019_06_34.jpg)'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15019_06_34.jpg)'
- en: 'Figure 6.34: Log loss output'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.34：对数损失输出
- en: Note
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The value of loss can vary for different data.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 损失值对于不同的数据可能会有所变化。
- en: To access the source code for this specific section, please refer to [https://packt.live/2Q5plZR](https://packt.live/2Q5plZR).
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参考[https://packt.live/2Q5plZR](https://packt.live/2Q5plZR)。
- en: You can also run this example online at [https://packt.live/34eMIsm](https://packt.live/34eMIsm).
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在网上运行这个例子：[https://packt.live/34eMIsm](https://packt.live/34eMIsm)。
- en: Thus, we have successfully calculated the `log_loss` for a classification model.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经成功地计算了分类模型的`log_loss`。
- en: Receiver Operating Characteristic Curve
  id: totrans-549
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接收者操作特征曲线（ROC曲线）
- en: Recall the True Positive Rate, which we discussed earlier. It is also called
    **sensitivity**. Also recall that what we try to do with a logistic regression
    model is find a threshold value such that above that threshold value, we predict
    that our input falls into a certain class, and below that threshold, we predict
    that it doesn't.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下我们之前讨论的真正阳性率（True Positive Rate），它也被称为**灵敏度**。还记得我们尝试做的事情是，通过一个逻辑回归模型找到一个阈值，超过这个阈值时，我们预测输入属于某一类别，低于这个阈值时，我们预测输入不属于该类别。
- en: The Receiver Operating Characteristic (ROC) curve is a plot that shows how the
    true positive and false positive rates vary for a model as the threshold is changed.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 接收者操作特征（ROC）曲线是一个图表，显示了随着阈值的变化，模型的真正阳性率和假阳性率是如何变化的。
- en: Let's do an exercise to enhance our understanding of the ROC curve.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们做一个练习来加深对 ROC 曲线的理解。
- en: 'Exercise 6.12: Computing and Plotting ROC Curve for a Binary Classification
    Problem'
  id: totrans-553
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 6.12：计算并绘制二分类问题的 ROC 曲线
- en: The goal of this exercise is to plot the ROC curve for a binary classification
    problem. The data for this problem is used to predict whether or not a mother
    will require a caesarian section to give birth.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习的目标是绘制二分类问题的 ROC 曲线。该问题的数据用于预测一位母亲是否需要剖腹产分娩。
- en: Note
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The dataset that you will be using in this chapter can be found in our GitHub
    repository: [https://packt.live/36dyEg5](https://packt.live/36dyEg5).'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的数据集可以在我们的 GitHub 仓库中找到：[https://packt.live/36dyEg5](https://packt.live/36dyEg5)。
- en: 'From the UCI Machine Learning Repository, the abstract for this dataset follows:
    "This dataset contains information about caesarian section results of 80 pregnant
    women with the most important characteristics of delivery problems in the medical
    field." The attributes of interest are age, delivery number, delivery time, blood
    pressure, and heart status.'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 来自 UCI 机器学习库的数据集摘要如下：“此数据集包含 80 名孕妇的剖腹产结果信息，其中包含在医学领域中最重要的分娩问题特征。” 关注的属性包括年龄、分娩次数、分娩时间、血压和心脏状态。
- en: 'The following steps will help you accomplish this task:'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助您完成此任务：
- en: Open a Colab notebook file.
  id: totrans-559
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个 Colab 笔记本文件。
- en: 'Import the required libraries:'
  id: totrans-560
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入所需的库：
- en: '[PRE61]'
  id: totrans-561
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: In this step, you import `pandas`, which you will use to read in data. You also
    import `train_test_split` for creating training and validation datasets, and `LogisticRegression`
    for creating a model.
  id: totrans-562
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这一步，你导入`pandas`，用于读取数据。同时，你还导入`train_test_split`，用于创建训练集和验证集数据集，并导入`LogisticRegression`，用于创建模型。
- en: 'Read in the data:'
  id: totrans-563
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取数据：
- en: '[PRE62]'
  id: totrans-564
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'In this step, you read in your data. The dataset has an interesting format.
    The bottom part contains the data in CSV format, but the upper part contains some
    file descriptors. If you download and open the file from [https://packt.live/38qJe4A](https://packt.live/38qJe4A)
    and open the file using Notepad, you will see the following:'
  id: totrans-565
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这一步，你读取了数据集。数据集有一个有趣的格式。底部部分包含CSV格式的数据，而上面部分包含一些文件描述符。如果你从[https://packt.live/38qJe4A](https://packt.live/38qJe4A)下载并使用记事本打开文件，你将看到如下内容：
- en: '![Figure 6.35: Reading the dataset'
  id: totrans-566
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图6.35：读取数据集'
- en: '](img/B15019_06_35.jpg)'
  id: totrans-567
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15019_06_35.jpg)'
- en: 'Figure 6.35: Reading the dataset'
  id: totrans-568
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图6.35：读取数据集
- en: You will need to do a few things to work with this file. Skip 15 rows and specify
    the column headers and read the file without an index.
  id: totrans-569
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你需要做一些操作来处理这个文件。跳过15行，指定列头，并读取文件时不带索引。
- en: The code shows how you do that by creating a Python list to hold your column
    headers and then read in the file using `read_csv()`. The parameters that you
    pass in are the file's location, the column headers as a Python list, the name
    of the index column (in this case, it is None), and the number of rows to skip.
  id: totrans-570
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 代码展示了如何通过创建一个Python列表来存储列头，并使用`read_csv()`方法读取文件。你传入的参数包括文件的位置、作为Python列表的列头、索引列的名称（在这个例子中为None），以及要跳过的行数。
- en: 'The `head()` method will print out the top five rows and should look similar
    to the following:'
  id: totrans-571
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`head()`方法将打印出前五行，应该类似于以下内容：'
- en: '![Figure 6.36: The top five rows of the DataFrame'
  id: totrans-572
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图6.36：数据框的前五行'
- en: '](img/B15019_06_36.jpg)'
  id: totrans-573
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15019_06_36.jpg)'
- en: 'Figure 6.36: The top five rows of the DataFrame'
  id: totrans-574
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图6.36：数据框的前五行
- en: 'Split the data:'
  id: totrans-575
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切分数据：
- en: '[PRE63]'
  id: totrans-576
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: In this step, you begin by creating two `numpy` arrays, which you call `features`
    and `labels`. You then split these arrays into a `training` and an `evaluation`
    dataset. You further split the `evaluation` dataset into `validation` and `test`
    datasets.
  id: totrans-577
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这一步，你首先创建两个`numpy`数组，分别命名为`features`和`labels`。然后，你将这两个数组分割成`training`和`evaluation`数据集。接着，你进一步将`evaluation`数据集分割成`validation`和`test`数据集。
- en: 'Now, train and fit a logistic regression model:'
  id: totrans-578
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，训练并拟合一个逻辑回归模型：
- en: '[PRE64]'
  id: totrans-579
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: In this step, you begin by creating an instance of a logistic regression model.
    You then proceed to train or fit the model on the training dataset.
  id: totrans-580
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这一步，你首先创建一个逻辑回归模型的实例。然后，你开始在训练数据集上训练或拟合该模型。
- en: 'The output should be similar to the following:'
  id: totrans-581
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出应类似于以下内容：
- en: '![Figure 6.37: Training a logistic regression model'
  id: totrans-582
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图6.37：训练逻辑回归模型'
- en: '](img/B15019_06_37.jpg)'
  id: totrans-583
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15019_06_37.jpg)'
- en: 'Figure 6.37: Training a logistic regression model'
  id: totrans-584
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图6.37：训练逻辑回归模型
- en: 'Predict the probabilities, as shown in the following code snippet:'
  id: totrans-585
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下代码片段预测概率：
- en: '[PRE65]'
  id: totrans-586
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: In this step, the model predicts the probabilities for each entry in the validation
    dataset. It stores the results in `y_proba`.
  id: totrans-587
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这一步，模型为验证数据集中的每个条目预测概率，并将结果存储在`y_proba`中。
- en: 'Compute the true positive rate, the false positive rate, and the thresholds:'
  id: totrans-588
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算真正阳性率、假阳性率和阈值：
- en: '[PRE66]'
  id: totrans-589
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: In this step, you make a call to `roc_curve()` and specify the ground truth
    and the first column of the predicted probabilities. The result is a tuple of
    false positive rate, true positive rate, and thresholds.
  id: totrans-590
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这一步，你调用`roc_curve()`并指定真实值和预测概率的第一列。结果是一个包含假阳性率、真正阳性率和阈值的元组。
- en: 'Explore the false positive rates:'
  id: totrans-591
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 探索假阳性率：
- en: '[PRE67]'
  id: totrans-592
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'In this step, you instruct the interpreter to print out the false positive
    rate. The output should be similar to the following:'
  id: totrans-593
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这一步，你指示解释器打印出假阳性率。输出应类似于以下内容：
- en: '![Figure 6.38: False positive rates'
  id: totrans-594
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图6.38：假阳性率'
- en: '](img/B15019_06_38.jpg)'
  id: totrans-595
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15019_06_38.jpg)'
- en: 'Figure 6.38: False positive rates'
  id: totrans-596
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图6.38：假阳性率
- en: Note
  id: totrans-597
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: The false positive rates can vary, depending on the data.
  id: totrans-598
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 假阳性率可能会有所不同，取决于数据。
- en: 'Explore the true positive rates:'
  id: totrans-599
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 探索真正阳性率：
- en: '[PRE68]'
  id: totrans-600
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'In this step, you instruct the interpreter to print out the true positive rates.
    This should be similar to the following:'
  id: totrans-601
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这一步，你指示解释器打印出真正阳性率。输出应该类似于以下内容：
- en: '![Figure 6.39: True positive rates'
  id: totrans-602
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图6.39：真正阳性率'
- en: '](img/B15019_06_39.jpg)'
  id: totrans-603
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15019_06_39.jpg)'
- en: 'Figure 6.39: True positive rates'
  id: totrans-604
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图6.39：真正阳性率
- en: 'Explore the thresholds:'
  id: totrans-605
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 探索阈值：
- en: '[PRE69]'
  id: totrans-606
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'In this step, you instruct the interpreter to display the thresholds. The output
    should be similar to the following:'
  id: totrans-607
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这一步骤中，你指示解释器显示阈值。输出应类似于以下内容：
- en: '![Figure 6.40: Thresholds'
  id: totrans-608
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 6.40：阈值'
- en: '](img/B15019_06_40.jpg)'
  id: totrans-609
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15019_06_40.jpg)'
- en: 'Figure 6.40: Thresholds'
  id: totrans-610
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 6.40：阈值
- en: 'Now, plot the ROC curve:'
  id: totrans-611
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，绘制 ROC 曲线：
- en: '[PRE70]'
  id: totrans-612
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: In this step, you import `matplotlib.pyplot` as your plotting library. You alias
    it as `plt`. You then proceed to plot a line chart by specifying the false positive
    rates and true positive rates. The rest of the code decorates the chart with a
    title and labels for the horizontal and vertical axes.
  id: totrans-613
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这一步骤中，你导入`matplotlib.pyplot`作为绘图库，并将其命名为`plt`。然后，你通过指定假阳性率和真阳性率来绘制折线图。其余的代码为图表添加标题和水平、垂直坐标轴标签。
- en: 'The output should look similar to the following:'
  id: totrans-614
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出应类似于以下内容：
- en: '![Figure 6.41: ROC curve'
  id: totrans-615
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 6.41：ROC 曲线'
- en: '](img/B15019_06_41.jpg)'
  id: totrans-616
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15019_06_41.jpg)'
- en: 'Figure 6.41: ROC curve'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.41：ROC 曲线
- en: Note
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/322jiLa](https://packt.live/322jiLa).
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参考[https://packt.live/322jiLa](https://packt.live/322jiLa)。
- en: You can also run this example online at [https://packt.live/324ii9s](https://packt.live/324ii9s).
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以在线运行此示例，网址为[https://packt.live/324ii9s](https://packt.live/324ii9s)。
- en: In this exercise, you learned to plot how the true positive rate and false positive
    rate of the model vary as you change the prediction threshold. Recall that what
    the model does is output a value between 0 and 1\. This value is called a logit.
    Your job as a data scientist is to decide on a threshold value, for example, 0.5\.
    If the logit is above that threshold, you predict that the input falls into one
    class (positive, if it is a positive-or-negative prediction). If the logit is
    below the threshold, you will predict that the input belongs to the negative class.
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 在本练习中，你学习了如何绘制模型的真阳性率和假阳性率如何随着预测阈值的变化而变化。回想一下，模型所做的事情是输出一个介于 0 和 1 之间的值。这个值被称为
    logit。作为数据科学家，你的任务是决定一个阈值，例如 0.5。如果 logit 值高于该阈值，则预测输入属于某个类别（如果是正负预测，则为正类）。如果
    logit 值低于该阈值，则预测输入属于负类。
- en: For example, if your threshold is 0.5, then a logit of 0.33 is predicted as
    negative, while a logit of 0.80 is predicted as positive.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果阈值是 0.5，那么一个 logit 值为 0.33 将被预测为负类，而 logit 值为 0.80 将被预测为正类。
- en: However, if your threshold is 0.95, then a logit of 0.33 is predicted as negative,
    and a logit of 0.80 is still predicted as negative.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果阈值是 0.95，那么一个 logit 值为 0.33 将被预测为负类，而 logit 值为 0.80 仍然会被预测为负类。
- en: Now, recall that what you want your model to do is correctly classify as many
    data points as possible. Classification is controlled by your chosen threshold
    value. The logit (predicted probability) from the model will always be the same,
    but the class assigned to the prediction will depend on the threshold.
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回想一下，你希望模型做的是尽可能正确地分类尽可能多的数据点。分类是由你选择的阈值控制的。来自模型的 logit（预测概率）始终是相同的，但分配给预测的类别将取决于阈值。
- en: As you vary the threshold, the predictions change, and the number of true positives
    and true negatives changes.
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 随着阈值的变化，预测结果会发生变化，真阳性和真阴性的数量也会随之变化。
- en: The RoC shows you how the percentage of true positives and true negatives changes
    as the threshold varies from 0 to 1.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: ROC 曲线显示了随着阈值从 0 到 1 变化，真阳性和真阴性的百分比是如何变化的。
- en: The higher the threshold, the more confident the model needs to be before you
    classify a prediction as positive. Recall that the logit is the probability that
    the input belongs to a class and is a confidence score from 0 to 1.
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 阈值越高，模型在将预测分类为正类之前需要越有信心。回想一下，logit 是输入属于某个类别的概率，是一个从 0 到 1 的置信度得分。
- en: Area Under the ROC Curve
  id: totrans-628
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ROC 曲线下面积
- en: The **Area Under the Receiver Operating Characteristic Curve** (**ROC AUC**)
    is a measure of the likelihood that the model will rank a randomly chosen positive
    example higher than a randomly chosen negative example. Another way of putting
    it is to say that the higher this measure is, the better the model is at predicting
    a negative class as negative, and a positive class as positive. The value ranges
    from 0 to 1\. If the AUC is 0.6, it means that the model has a 60% probability
    of correctly distinguishing a negative class from a positive class based on the
    inputs. This measure is used to compare models.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: '**接收者操作特征曲线下的面积**（**ROC AUC**）是衡量模型将随机选择的正例排在随机选择的负例之前的可能性的指标。换句话说，AUC 值越高，模型在将负类预测为负类、将正类预测为正类方面的能力越强。该值范围从
    0 到 1。如果 AUC 为 0.6，表示模型有 60% 的概率根据输入正确区分负类和正类。该指标常用于模型比较。'
- en: 'Exercise 6.13: Computing the ROC AUC for the Caesarian Dataset'
  id: totrans-630
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 6.13：计算剖腹产数据集的 ROC AUC
- en: The goal of this exercise is to compute the ROC AUC for the binary classification
    model that you trained in *Exercise 6.12*, *Computing and Plotting ROC Curve for
    a Binary Classification Problem*.
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习的目标是计算你在*练习 6.12*中训练的二分类模型的 ROC AUC，即*计算并绘制二分类问题的 ROC 曲线*。
- en: Note
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You should continue this exercise in the same notebook as that used in *Exercise
    6.12, Computing and Plotting ROC Curve for a Binary Classification Problem.* If
    you wish to use a new notebook, make sure you copy and run the entire code from
    *Exercise 6.12* and then begin with the execution of the code of this exercise.
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 你应继续在与*练习 6.12，计算并绘制二分类问题的 ROC 曲线*相同的笔记本中进行此练习。如果你希望使用新的笔记本，请确保先复制并运行*练习 6.12*的完整代码，然后开始执行本练习的代码。
- en: 'The following steps will help you accomplish the task:'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助你完成任务：
- en: Open a Colab notebook to the code for *Exercise 6.12*, *Computing and Plotting
    ROC Curve for a Binary Classification Problem,* and continue writing your code.
  id: totrans-635
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个 Colab 笔记本，找到*练习 6.12*的代码，即*计算并绘制二分类问题的 ROC 曲线*，并继续编写你的代码。
- en: 'Predict the probabilities:'
  id: totrans-636
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 预测概率：
- en: '[PRE71]'
  id: totrans-637
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: In this step, you compute the probabilities of the classes in the validation
    dataset. You store the result in `y_proba`.
  id: totrans-638
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这一步，你将计算验证数据集中的类别概率，并将结果存储在 `y_proba` 中。
- en: 'Compute the ROC AUC:'
  id: totrans-639
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算 ROC AUC：
- en: '[PRE72]'
  id: totrans-640
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'In this step, you compute the ROC AUC and store the result in `_auc`. You then
    proceed to print this value out. The result should look similar to the following:'
  id: totrans-641
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这一步，你将计算 ROC AUC 并将结果存储在 `_auc` 中。然后继续打印出这个值。结果应与以下类似：
- en: '![Figure 6.42: Computing the ROC AUC'
  id: totrans-642
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 6.42：计算 ROC AUC'
- en: '](img/B15019_06_42.jpg)'
  id: totrans-643
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15019_06_42.jpg)'
- en: 'Figure 6.42: Computing the ROC AUC'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.42：计算 ROC AUC
- en: Note
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The AUC can be different, depending on the data.
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: AUC 的值可能因数据而异。
- en: To access the source code for this specific section, please refer to [https://packt.live/32jCrIT](https://packt.live/32jCrIT).
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参考 [https://packt.live/32jCrIT](https://packt.live/32jCrIT)。
- en: You can also run this example online at [https://packt.live/319zoDy](https://packt.live/319zoDy).
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以在[https://packt.live/319zoDy](https://packt.live/319zoDy) 上在线运行此示例。
- en: In this exercise, you learned to compute the ROC AUC, which is the measure of
    the likelihood that the model will rank a randomly chosen positive example higher
    than a randomly chosen negative example. In this example, the AUC is 0.1944, and
    there is room for improvement with this model.
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 在本练习中，你学习了如何计算 ROC AUC，这是衡量模型将随机选择的正例排在随机选择的负例之前的可能性的指标。在本示例中，AUC 为 0.1944，模型仍有改进的空间。
- en: When you are done selecting a model, you might be interested in saving it for
    use in the future. The next topic explores saving and loading models.
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成选择模型后，可能会对将其保存以备将来使用感兴趣。接下来的主题将探讨如何保存和加载模型。
- en: Saving and Loading Models
  id: totrans-651
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保存和加载模型
- en: You will eventually need to transfer some of the models you have trained to
    a different computer so they can be put into production. There are various utilities
    for doing this, but the one we will discuss is called `joblib`.
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 你最终需要将你训练的一些模型转移到另一台计算机上，以便它们可以投入生产。虽然有多种工具可以实现这一点，但我们将讨论的工具叫做`joblib`。
- en: '`joblib` supports saving and loading models, and it saves the models in a format
    that is supported by other machine learning architectures, such as `ONNX`.'
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: '`joblib` 支持保存和加载模型，并且它将模型保存为其他机器学习架构（如 `ONNX`）所支持的格式。'
- en: '`joblib` is found in the `sklearn.externals` module.'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: '`joblib`位于`sklearn.externals`模块中。'
- en: 'Exercise 6.14: Saving and Loading a Model'
  id: totrans-655
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习6.14：保存和加载模型
- en: In this exercise, you will train a simple model and use it for prediction. You
    will then proceed to save the model and then load it back in. You will use the
    loaded model for a second prediction, and then compare the predictions from the
    first model to those from the second model. You will make use of the car dataset
    for this exercise.
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 在本练习中，你将训练一个简单的模型并用它进行预测。然后，你将保存模型并重新加载。你将使用加载后的模型进行第二次预测，并将第一次模型的预测结果与第二次模型的预测结果进行比较。你将在本练习中使用汽车数据集。
- en: 'The following steps will guide you toward the goal:'
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将引导你朝着目标迈进：
- en: Open a Colab notebook.
  id: totrans-658
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个Colab笔记本。
- en: 'Import the required libraries:'
  id: totrans-659
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入所需的库：
- en: '[PRE73]'
  id: totrans-660
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Read in the data:'
  id: totrans-661
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取数据：
- en: '[PRE74]'
  id: totrans-662
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Inspect the data:'
  id: totrans-663
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查数据：
- en: '[PRE75]'
  id: totrans-664
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The output should be similar to the following:'
  id: totrans-665
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出结果应类似于以下内容：
- en: '![Figure 6.43: Inspecting the first five rows of the DataFrame'
  id: totrans-666
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图6.43：检查数据框的前五行'
- en: '](img/B15019_06_43.jpg)'
  id: totrans-667
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15019_06_43.jpg)'
- en: 'Figure 6.43: Inspecting the first five rows of the DataFrame'
  id: totrans-668
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图6.43：检查数据框的前五行
- en: 'Split the data into `features` and `labels`, and into training and validation
    sets:'
  id: totrans-669
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将数据分为`特征`和`标签`，并分为训练集和验证集：
- en: '[PRE76]'
  id: totrans-670
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Create a linear regression model:'
  id: totrans-671
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个线性回归模型：
- en: '[PRE77]'
  id: totrans-672
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The output will be as follows:'
  id: totrans-673
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '![Figure 6.44: Training a linear regression model'
  id: totrans-674
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图6.44：训练线性回归模型'
- en: '](img/B15019_06_44.jpg)'
  id: totrans-675
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15019_06_44.jpg)'
- en: 'Figure 6.44: Training a linear regression model'
  id: totrans-676
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图6.44：训练线性回归模型
- en: 'Fit the training data to the model:'
  id: totrans-677
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将训练数据拟合到模型：
- en: '[PRE78]'
  id: totrans-678
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Use the model for prediction:'
  id: totrans-679
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用模型进行预测：
- en: '[PRE79]'
  id: totrans-680
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Import `joblib`:'
  id: totrans-681
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`joblib`：
- en: '[PRE80]'
  id: totrans-682
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Save the model:'
  id: totrans-683
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存模型：
- en: '[PRE81]'
  id: totrans-684
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The output should be similar to the following:'
  id: totrans-685
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出结果应类似于以下内容：
- en: '![Figure 6.45: Saving the model'
  id: totrans-686
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图6.45：保存模型'
- en: '](img/B15019_06_45.jpg)'
  id: totrans-687
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15019_06_45.jpg)'
- en: 'Figure 6.45: Saving the model'
  id: totrans-688
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图6.45：保存模型
- en: 'Load it as a new model:'
  id: totrans-689
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其加载为一个新模型：
- en: '[PRE82]'
  id: totrans-690
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Use the new model for predictions:'
  id: totrans-691
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用新模型进行预测：
- en: '[PRE83]'
  id: totrans-692
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Compare the predictions:'
  id: totrans-693
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 比较预测结果：
- en: '[PRE84]'
  id: totrans-694
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The output should be similar to the following:'
  id: totrans-695
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出结果应类似于以下内容：
- en: '![Figure 6.46: Comparing predictions'
  id: totrans-696
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图6.46：比较预测结果'
- en: '](img/B15019_06_46.jpg)'
  id: totrans-697
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15019_06_46.jpg)'
- en: 'Figure 6.46: Comparing predictions'
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.46：比较预测结果
- en: Note
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/322VxTb](https://packt.live/322VxTb).
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此部分的源代码，请参阅[https://packt.live/322VxTb](https://packt.live/322VxTb)。
- en: You can also run this example online at [https://packt.live/3aAUz4q](https://packt.live/3aAUz4q).
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在线运行此示例，访问[https://packt.live/3aAUz4q](https://packt.live/3aAUz4q)。
- en: You can see that the predictions from the model before it was saved are exactly
    the same as the predictions from the model after it was saved and loaded back
    in. It is safe to conclude that saving and loading models does not affect their
    quality.
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，保存前的模型预测与保存后重新加载的模型预测完全相同。可以安全地得出结论，保存和加载模型不会影响其质量。
- en: In this exercise, you learned how to save and load models. You also checked
    and confirmed that the model predictions remain the same even when you save and
    load them.
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 在本练习中，你学习了如何保存和加载模型。你还检查并确认了即使保存并加载模型，模型的预测结果保持不变。
- en: 'Activity 6.01: Train Three Different Models and Use Evaluation Metrics to Pick
    the Best Performing Model'
  id: totrans-704
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动6.01：训练三种不同的模型并使用评估指标选择表现最佳的模型
- en: You work as a data scientist at a bank. The bank would like to implement a model
    that predicts the likelihood of a customer purchasing a term deposit. The bank
    provides you with a dataset, which is the same as the one in *Chapter 3*, *Binary
    Classification*. You have previously learned how to train a logistic regression
    model for binary classification. You have also heard about other non-parametric
    modeling techniques and would like to try out a decision tree as well as a random
    forest to see how well they perform against the logistic regression models you
    have been training.
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 你在银行担任数据科学家。银行希望实现一个模型，用于预测客户购买定期存款的可能性。银行为你提供了一份数据集，该数据集与*第三章*，*二分类*中的数据集相同。你之前已经学习了如何为二分类训练一个逻辑回归模型。你还听说过其他非参数建模技术，并希望尝试决策树和随机森林，看看它们与逻辑回归模型的表现如何。
- en: In this activity, you will train a logistic regression model and compute a classification
    report. You will then proceed to train a decision tree classifier and compute
    a classification report. You will compare the models using the classification
    reports. Finally, you will train a random forest classifier and generate the classification
    report. You will then compare the logistic regression model with the random forest
    using the classification reports to determine which model you should put into
    production.
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 在此活动中，你将训练一个逻辑回归模型并计算分类报告。接着，你将训练一个决策树分类器并计算分类报告。你将通过分类报告比较这些模型。最后，你将训练一个随机森林分类器并生成分类报告。然后，你将通过比较逻辑回归模型和随机森林模型的分类报告来决定将哪个模型投入生产。
- en: 'The steps to accomplish this task are:'
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此任务的步骤是：
- en: Open a Colab notebook.
  id: totrans-708
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个 Colab 笔记本。
- en: Load the necessary libraries.
  id: totrans-709
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载必要的库。
- en: Read in the data.
  id: totrans-710
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取数据。
- en: Explore the data.
  id: totrans-711
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 探索数据。
- en: Convert categorical variables using `pandas.get_dummies()`.
  id: totrans-712
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`pandas.get_dummies()`转换分类变量。
- en: Prepare the `X` and `y` variables.
  id: totrans-713
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备`X`和`y`变量。
- en: Split the data into training and evaluation sets.
  id: totrans-714
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将数据拆分为训练集和评估集。
- en: Create an instance of `LogisticRegression`.
  id: totrans-715
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`LogisticRegression`实例。
- en: Fit the training data to the `LogisticRegression` model.
  id: totrans-716
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将训练数据拟合到`LogisticRegression`模型中。
- en: Use the evaluation set to make a prediction.
  id: totrans-717
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用评估集进行预测。
- en: Use the prediction from the `LogisticRegression` model to compute the classification
    report.
  id: totrans-718
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`LogisticRegression`模型的预测结果来计算分类报告。
- en: 'Create an instance of `DecisionTreeClassifier`:'
  id: totrans-719
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`DecisionTreeClassifier`实例：
- en: '[PRE85]'
  id: totrans-720
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Fit the training data to the `DecisionTreeClassifier` model:'
  id: totrans-721
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将训练数据拟合到`DecisionTreeClassifier`模型中：
- en: '[PRE86]'
  id: totrans-722
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Using the `DecisionTreeClassifier` model, make a prediction on the evaluation dataset:'
  id: totrans-723
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`DecisionTreeClassifier`模型对评估数据集进行预测：
- en: '[PRE87]'
  id: totrans-724
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Use the prediction from the `DecisionTreeClassifier` model to compute the classification
    report:'
  id: totrans-725
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`DecisionTreeClassifier`模型的预测结果来计算分类报告：
- en: '[PRE88]'
  id: totrans-726
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Note
  id: totrans-727
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: We will be studying decision trees in detail in *Chapter 7, The Generalization
    of Machine Learning Models*.
  id: totrans-728
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将在*第7章，机器学习模型的泛化*中详细研究决策树。
- en: Compare the classification report from the linear regression model and the classification
    report from the decision tree classifier to determine which is the better model.
  id: totrans-729
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 比较线性回归模型的分类报告与决策树分类器的分类报告，以确定哪个模型更好。
- en: Create an instance of `RandomForestClassifier`.
  id: totrans-730
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`RandomForestClassifier`实例。
- en: Fit the training data to the `RandomForestClassifier` model.
  id: totrans-731
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将训练数据拟合到`RandomForestClassifier`模型。
- en: Using the `RandomForestClassifier` model, make a prediction on the evaluation dataset.
  id: totrans-732
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`RandomForestClassifier`模型对评估数据集进行预测。
- en: Using the prediction from the random forest classifier, compute the classification report.
  id: totrans-733
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用随机森林分类器的预测结果来计算分类报告。
- en: Compare the classification report from the linear regression model with the
    classification report from the random forest classifier to decide which model
    to keep or improve upon.
  id: totrans-734
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 比较线性回归模型的分类报告与随机森林分类器的分类报告，以决定保留哪个模型或进行改进。
- en: 'Compare the R2 scores of all three models. The output should be similar to the following:![Figure
    6.47: Comparing the R2 scores'
  id: totrans-735
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 比较所有三个模型的R²分数。输出应类似于以下内容：![图6.47：比较R²分数
- en: '](img/B15019_06_47.jpg)'
  id: totrans-736
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15019_06_47.jpg)'
- en: 'Figure 6.47: Comparing the R2 scores'
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.47：比较R²分数
- en: Note
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The solution to this activity can be found at the following address: [https://packt.live/2GbJloz](https://packt.live/2GbJloz).'
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可以在以下地址找到：[https://packt.live/2GbJloz](https://packt.live/2GbJloz)。
- en: Summary
  id: totrans-740
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter we observed that some of the evaluation metrics for classification
    models require a binary classification model. We saw that when we worked with
    more than two classes, we were required to use the one-versus-all approach. The
    one-versus-all approach builds one model for each class and tries to predict the
    probability that the input belongs to a specific class. We saw that once this
    was done, we then predicted that the input belongs to the class where the model
    has the highest prediction probability. We also split our evaluation dataset into
    two, it's because `X_test` and `y_test` are used once for a final evaluation of
    the model's performance. You can make use of them before putting your model into
    production to see how the model would perform in a production environment.
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们观察到一些分类模型的评估指标需要使用二分类模型。我们看到，当处理超过两个类别时，我们需要使用一对多（one-versus-all）方法。一对多方法为每个类别构建一个模型，并尝试预测输入属于某个特定类别的概率。我们看到，一旦完成这一过程，就可以预测输入属于概率最高的那个类别。我们还将评估数据集拆分成了两部分，这是因为`X_test`和`y_test`仅在模型性能的最终评估时使用。在将模型投入生产之前，你可以利用它们来查看模型在生产环境中的表现。
- en: You have learned how to assess the quality of a regression model by observing
    how the loss changes. You saw examples using the MAE, and also learned of the
    existence of MSE. You also learned about how to assess the quality of classification
    models in the activity. In the next chapter, you will learn how to train multiple
    models using cross-validation and also implement regularization techniques.
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经学会了如何通过观察损失值的变化来评估回归模型的质量。你看到了一些使用 MAE 的例子，并且也了解了 MSE 的存在。在活动中，你还学到了如何评估分类模型的质量。在下一章中，你将学习如何使用交叉验证训练多个模型，并实现正则化技术。
