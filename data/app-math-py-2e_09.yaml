- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Finding Optimal Solutions
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 寻找最优解
- en: In this chapter, we’ll address various methods for finding the best outcome
    in a given situation. This is called **optimization** and usually involves either
    minimizing or maximizing an objective function. An **objective function** is a
    function with one or more arguments that returns a single scalar value, representing
    the cost or payoff for a given choice of parameters. The problems regarding minimizing
    and maximizing functions are actually equivalent to one another, so we’ll only
    discuss minimizing object functions in this chapter. Minimizing a function, ![](img/Formula_09_001.png),
    is equivalent to maximizing the ![](img/Formula_09_002.png) function. More details
    on this will be provided when we discuss the first recipe.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将探讨寻找给定情境下最佳结果的各种方法。这被称为**优化**，通常涉及最小化或最大化目标函数。**目标函数**是一个包含一个或多个自变量的函数，返回一个标量值，表示给定参数选择的成本或收益。最小化和最大化函数的问题实际上是等价的，因此我们将在本章中只讨论最小化目标函数。最小化一个函数，![](img/Formula_09_001.png)，等同于最大化![](img/Formula_09_002.png)函数。关于这一点的更多细节将在我们讨论第一个食谱时提供。
- en: The algorithms available to us for minimizing a given function depend on the
    nature of the function. For instance, a simple linear function containing one
    or more variables has different algorithms available compared to a non-linear
    function with many variables. The minimization of linear functions falls within
    the category of **linear programming**, which is a well-developed theory. Linear
    functions can be solved with standard linear algebra techniques. For non-linear
    functions, we usually make use of the gradient of a function in order to find
    the minimum points. We will discuss several methods for minimizing various functions
    of different types.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 用于最小化给定函数的算法取决于函数的性质。例如，包含一个或多个变量的简单线性函数与具有多个变量的非线性函数所适用的算法是不同的。线性函数的最小化属于**线性规划**的范畴，这是一个成熟的理论。线性函数可以通过标准的线性代数技术解决。对于非线性函数，我们通常利用函数的梯度来寻找最小点。我们将讨论几种用于最小化不同类型函数的方法。
- en: Finding the minima and maxima of the functions of a single variable is especially
    simple and can be done easily if the derivatives of the function are known. If
    not, then the method described in the appropriate recipe will be applicable. The
    notes in the *Minimizing a non-linear function* recipe give some extra details
    about this.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找单变量函数的最小值和最大值尤其简单，如果已知函数的导数，则可以轻松完成。如果不知道导数，那么可以使用适当食谱中描述的方法。*最小化非线性函数*食谱中的备注提供了一些额外的细节。
- en: We’ll also provide a very short introduction to *game theory*. Broadly speaking,
    this is a theory surrounding decision-making and has wide-ranging implications
    in subjects such as economics. In particular, we’ll discuss how to represent simple
    two-player games as objects in Python, compute payoffs associated with certain
    choices, and compute Nash equilibria for these games.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将简要介绍一下*博弈论*。广义来说，博弈论是围绕决策制定的理论，具有广泛的应用，尤其在经济学等学科中尤为重要。具体来说，我们将讨论如何将简单的双人博弈表示为Python中的对象，计算与某些选择相关的收益，并计算这些博弈的纳什均衡。
- en: We will start by looking at how to minimize linear and non-linear functions
    containing one or more variables. Then, we’ll move on and look at gradient descent
    methods and curve fitting, using least squares. We’ll conclude this chapter by
    analyzing two-player games and Nash equilibria.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先学习如何最小化包含一个或多个变量的线性和非线性函数。然后，我们将继续探讨使用梯度下降法和最小二乘法的曲线拟合方法。最后，我们将通过分析双人博弈和纳什均衡来总结这一章。
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下食谱：
- en: Minimizing a simple linear function
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小化简单线性函数
- en: Minimizing a non-linear function
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小化非线性函数
- en: Using gradient descent methods in optimization
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在优化中使用梯度下降法
- en: Using least squares to fit a curve to data
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用最小二乘法对数据进行曲线拟合
- en: Analyzing simple two-player games
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析简单的双人博弈
- en: Computing Nash equilibria
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算纳什均衡
- en: Let’s get started!
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In this chapter, we will need the NumPy package, the SciPy package, and the
    Matplotlib package, as usual. We will also need the Nashpy package for the final
    two recipes. These packages can be installed using your favorite package manager,
    such as `pip`:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将需要NumPy、SciPy和Matplotlib包，和往常一样。对于最后两个食谱，我们还需要Nashpy包。可以使用你喜欢的包管理器（如`pip`）安装这些包：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The code for this chapter can be found in the `Chapter 09` folder of the GitHub
    repository at [https://github.com/PacktPublishing/Applying-Math-with-Python-2nd-Edition/tree/main/Chapter%2009](https://github.com/PacktPublishing/Applying-Math-with-Python-2nd-Edition/tree/main/Chapter%2009).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节的代码可以在 GitHub 仓库中的`Chapter 09`文件夹找到，地址为 [https://github.com/PacktPublishing/Applying-Math-with-Python-2nd-Edition/tree/main/Chapter%2009](https://github.com/PacktPublishing/Applying-Math-with-Python-2nd-Edition/tree/main/Chapter%2009)。
- en: Minimizing a simple linear function
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最小化一个简单的线性函数
- en: 'The most basic type of problem we face in optimization is finding the parameters
    where a function takes its minimum value. Usually, this problem is *constrained*
    by some bounds on the possible values of the parameters, which increases the complexity
    of the problem. Obviously, the complexity of this problem increases further if
    the function that we are minimizing is also complex. For this reason, we must
    first consider *linear functions*, which are in the following form:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在优化中面临的最基本问题是找到一个函数的最小值所在的参数。通常，这个问题会受到一些关于参数可能值的*约束*，这增加了问题的复杂性。显然，如果我们要最小化的函数本身也很复杂，那么问题的复杂性会进一步增加。因此，我们必须首先考虑*线性函数*，其形式如下：
- en: '![](img/Formula_09_003.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_09_003.png)'
- en: To solve this kind of problem, we need to convert the constraints into a form
    that can be used by a computer. In this case, we usually convert them into a linear
    algebra problem (matrices and vectors). Once this is done, we can use the tools
    from the linear algebra packages in NumPy and SciPy to find the parameters we
    seek. Fortunately, since this kind of problem occur quite frequently, SciPy has
    routines that handle this conversion and subsequent solving.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决这种问题，我们需要将约束转换成计算机能够处理的形式。在这种情况下，我们通常将其转换为线性代数问题（矩阵和向量）。完成这一步后，我们可以利用 NumPy
    和 SciPy 中线性代数包的工具来找到我们需要的参数。幸运的是，由于这种问题非常常见，SciPy 已经有处理这种转换和后续求解的例程。
- en: 'In this recipe, we’ll solve the following constrained linear minimization problem
    using routines from the SciPy `optimize` module:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们将使用 SciPy `optimize` 模块中的例程解决以下约束线性最小化问题：
- en: '![](img/Formula_09_004.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_09_004.png)'
- en: 'This will be subject to the following conditions:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这将受到以下条件的限制：
- en: '![](img/Formula_09_005.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_09_005.png)'
- en: '![](img/Formula_09_006.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_09_006.png)'
- en: '![](img/Formula_09_007.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_09_007.png)'
- en: '![](img/Formula_09_008.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_09_008.png)'
- en: Let’s see how to use the SciPy `optimize` routines to solve this linear programming
    problem.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用 SciPy 的`optimize`例程来解决这个线性规划问题。
- en: Getting ready
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'For this recipe, we need to import the NumPy package under the alias `np`,
    the Matplotlib `pyplot` module under the name `plt`, and the SciPy `optimize`
    module. We also need to import the `Axes3D` class from `mpl_toolkits.mplot3d`
    to make 3D plotting available:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们需要导入 NumPy 包（别名为`np`），Matplotlib 的 `pyplot` 模块（别名为`plt`），以及 SciPy 的
    `optimize` 模块。我们还需要从 `mpl_toolkits.mplot3d` 导入 `Axes3D` 类，以便进行 3D 绘图：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Let’s see how to use the routines from the `optimize` module to minimize a constrained
    linear system.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用 `optimize` 模块中的例程来最小化一个有约束的线性系统。
- en: How to do it...
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Follow these steps to solve a constrained linear minimization problem using
    SciPy:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤使用 SciPy 解决一个有约束的线性最小化问题：
- en: 'Set up the system in a form that SciPy can recognize:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将系统设置为 SciPy 能够识别的形式：
- en: '[PRE2]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next, we need to define a routine that evaluates the linear function at a value
    of ![](img/Formula_09_009.png), which is a vector (a NumPy array):'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要定义一个例程来评估在线性函数值为 ![](img/Formula_09_009.png) 时的函数值，该值是一个向量（NumPy 数组）：
- en: '[PRE10]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then, we create a new figure and add a set of `3d` axes that we can plot the
    function on:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们创建一个新图形，并添加一组 `3d` 坐标轴，以便在其上绘制函数：
- en: '[PRE12]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, we create a grid of values covering the region from the problem and plot
    the value of the function over this region:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个覆盖问题区域的值网格，并在该区域上绘制函数值：
- en: '[PRE16]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, we plot the line in the plane of the function values that corresponds
    to the critical line, `2*x0 + x1 == 6`, and plot the values that fall within the
    range on top of our plot:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们绘制函数值平面中对应于临界线`2*x0 + x1 == 6`的直线，并在我们的图上绘制落在该范围内的值：
- en: '[PRE22]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We repeat this plotting step for the second critical line, `x0 + x1 == -``4`:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们对第二条临界线`x0 + x1 == -4`重复进行绘图步骤：
- en: '[PRE26]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Next, we shade the region that lies within the two critical lines, which corresponds
    to the feasible region for the minimization problem:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们对位于两条临界线之间的区域进行着色，这对应于最小化问题的可行区域：
- en: '[PRE30]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The plot of the function values over the feasible region can be seen in the
    following diagram:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在下图中可以看到函数值在可行区域上的绘图：
- en: '![Figure 9.1 – The values of the linear function with the feasible region highlighted'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.1 – 线性函数的值，并突出显示了可行区域'
- en: '](img/9.1.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/9.1.jpg)'
- en: Figure 9.1 – The values of the linear function with the feasible region highlighted
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.1 – 线性函数的值，并突出显示了可行区域
- en: As we can see, the minimum value that lies within this shaded region occurs
    at the intersection of the two critical lines.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，位于这个阴影区域内的最小值出现在两条关键线的交点处。
- en: 'Next, we use `linprog` to solve the constrained minimization problem with the
    bounds we created in *step 1*. We print the resulting object in the terminal:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们使用`linprog`来解决在*步骤 1*中创建的约束最小化问题。我们在终端中打印出结果对象：
- en: '[PRE34]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Finally, we plot the minimum function value on top of the feasible region:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将在可行区域上方绘制最小函数值：
- en: '[PRE37]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The updated plot can be seen in the following diagram:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 更新后的图示可以在下图中看到：
- en: '![Figure 9.2 – The minimum value plotted on the feasible region'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.2 – 最小值绘制在可行区域上'
- en: '](img/9.2.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/9.2.jpg)'
- en: Figure 9.2 – The minimum value plotted on the feasible region
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.2 – 最小值绘制在可行区域上
- en: Here, we can see that the `linprog` routine has indeed found that the minimum
    is at the intersection of the two critical lines.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到`linprog`程序确实找到了最小值，它位于两条关键线的交点处。
- en: How it works...
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Constrained linear minimization problems are common in economic situations,
    where you try to minimize costs while maintaining other aspects of the parameters.
    In fact, a lot of the terminology from optimization theory mirrors this fact.
    A very simple algorithm for solving these kinds of problems is called the **simplex
    method**, which uses a sequence of array operations to find the minimal solution.
    Geometrically, these operations represent changing to different vertices of a
    simplex (which we won’t define here), and it is this that gives the algorithm
    its name.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 约束线性最小化问题在经济场景中非常常见，在这些问题中，你试图在保持其他参数的同时最小化成本。事实上，优化理论中的很多术语都反映了这一点。解决这些问题的一种非常简单的算法叫做**单纯形法**，它通过一系列阵列操作来找到最小解。从几何角度看，这些操作代表了在单纯形的不同顶点之间变化（我们在这里不会定义单纯形），正是这种变化赋予了算法这个名字。
- en: 'Before we continue, we’ll provide a brief outline of the process used by the
    simplex method to solve a constrained linear optimization problem. The problem,
    as presented to us, is not a matrix equation problem but a matrix inequality problem.
    We can remedy this problem by introducing **slack variables**, which turn an inequality
    into an equality. For example, the first constraint inequality can be rewritten
    as follows by introducing the slack variable, ![](img/Formula_09_010.png):'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，我们将简要概述单纯形法用于求解约束线性优化问题的过程。该问题，呈现给我们的并不是一个矩阵方程问题，而是一个矩阵不等式问题。我们可以通过引入**松弛变量**来解决这个问题，将不等式转化为等式。例如，通过引入松弛变量，第一条约束不等式可以重写为如下形式：![](img/Formula_09_010.png)。
- en: '![](img/Formula_09_011.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_09_011.png)'
- en: 'This satisfies the desired inequality, provided that ![](img/Formula_09_012.png)
    is not negative. The second constraint inequality is greater than or equal to
    type inequality that we must first change so that it’s of the less than or equal
    to type. We do this by multiplying all terms by -1\. This gives us the second
    row of the `A` matrix that we defined in the recipe. After introducing a second
    slack variable,![](img/Formula_09_013.png), we get the second equation:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 只要![](img/Formula_09_012.png)不为负数，这样就满足了所需的不等式。第二个约束不等式是“大于或等于”型的不等式，我们必须首先将其转化为“小于或等于”型的不等式。我们通过将所有项乘以-1来实现这一点。这就得到了我们在步骤中定义的`A`矩阵的第二行。在引入第二个松弛变量后，![](img/Formula_09_013.png)，我们得到了第二个方程：
- en: '![](img/Formula_09_014.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_09_014.png)'
- en: From this, we can construct a matrix whose columns contain the coefficients
    of the two parameter variables, ![](img/Formula_09_015.png) and ![](img/Formula_09_016.png)
    and the two slack variables, ![](img/Formula_09_017.png) and ![](img/Formula_09_018.png).
    The rows of this matrix represent the two bounding equations and the objective
    function. This system of equations can now be solved, using elementary row operations
    on this matrix, to obtain the values of ![](img/Formula_09_019.png) and ![](img/Formula_09_020.png),
    which minimize the objective function. Since solving matrix equations is easy
    and fast, this means that we can minimize linear functions quickly and efficiently.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，我们可以构建一个矩阵，其列包含两个参数变量的系数，![](img/Formula_09_015.png) 和 ![](img/Formula_09_016.png)，以及两个松弛变量，![](img/Formula_09_017.png)
    和 ![](img/Formula_09_018.png)。该矩阵的行表示两个边界方程和目标函数。现在，这个方程组可以通过对该矩阵进行基本的行操作来求解，以得到最小化目标函数的![](img/Formula_09_019.png)
    和 ![](img/Formula_09_020.png)的值。由于求解矩阵方程既简单又快速，这意味着我们可以迅速高效地最小化线性函数。
- en: Fortunately, we don’t need to remember how to reduce our system of inequalities
    into a system of linear equations, since routines such as `linprog` do this for
    us. We can simply provide the bounding inequalities as a matrix and vector pair,
    consisting of the coefficients of each, and a separate vector that defines the
    objective function. The `linprog` routine takes care of formulating and then solving
    the minimization problem.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们不需要记住如何将我们的不等式系统化简为线性方程组，因为像`linprog`这样的例程已经为我们做了这件事。我们只需提供边界不等式作为一个矩阵和向量对，包括每个不等式的系数，并提供一个定义目标函数的单独向量。`linprog`例程会负责公式化并解决最小化问题。
- en: In practice, the simplex method is not the algorithm used by the `linprog` routine
    to minimize the function. Instead, `linprog` uses an interior point algorithm,
    which is more efficient. (The method can actually be set to `simplex` or `revised-simplex`
    by providing the `method` keyword argument with the appropriate method name. In
    the printed resulting output, we can see that it only took five iterations to
    reach the solution.) The resulting object that is returned by this routine contains
    the parameter values at which the minimum occurs, stored in the `x` attribute,
    the value of the function at this minimum value stored in the `fun` attribute,
    and various other pieces of information about the solving process. If the method
    had failed, then the `status` attribute would have contained a numerical code
    that described why the method failed.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`linprog`例程并未使用单纯形法来最小化函数。相反，`linprog`使用了一个内部点算法，这种算法效率更高。（该方法实际上可以通过提供适当的方法名称和`method`关键字参数设置为`simplex`或`revised-simplex`。在打印的结果输出中，我们可以看到，达到解决方案仅需五次迭代。）该例程返回的结果对象包含在最小值处的参数值，存储在`x`属性中，最小值处函数的值存储在`fun`属性中，此外还包含关于求解过程的各种信息。如果方法失败，则`status`属性将包含一个数值代码，描述方法失败的原因。
- en: In *step 2* of this recipe, we created a function that represents the objective
    function for this problem. This function takes a single array as input, which
    contains the parameter space values at which the function should be evaluated.
    Here, we used the `tensordot` routine (with `axes=1`) from NumPy to evaluate the
    dot product of the coefficient vector, ![](img/Formula_09_021.png), with each
    input, ![](img/Formula_09_022.png). We have to be quite careful here, since the
    values that we pass into the function will be a 2 × 50 × 50 array in a later step.
    The ordinary matrix multiplication (`np.dot`) would not give the 50 × 50 array
    output that we desire in this case.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱的*第2步*中，我们创建了一个表示此问题目标函数的函数。该函数接受一个包含函数应评估的参数空间值的单一数组作为输入。在这里，我们使用了NumPy的`tensordot`例程（`axes=1`）来评估系数向量的点积，![](img/Formula_09_021.png)，与每个输入，![](img/Formula_09_022.png)。在这里我们必须非常小心，因为我们传入函数的值在后续步骤中将会是一个2
    × 50 × 50的数组。普通的矩阵乘法（`np.dot`）在这种情况下无法给出我们想要的50 × 50的数组输出。
- en: 'In *step 5* and *step 6*, we computed the points on the critical lines as those
    points with the following equation:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第5步*和*第6步*中，我们根据以下方程计算了临界线上的点：
- en: '![](img/Formula_09_023.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_09_023.png)'
- en: We then computed the corresponding ![](img/Formula_09_024.png) values so that
    we could plot the lines that lie on the plane defined by the objective function.
    We also need to *trim* the values so that we only include those that lie in the
    range specified in the problem. This is done by constructing the indexing array
    labeled `I` in the code, consisting of the points that lie within the boundary
    values.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们计算了相应的![](img/Formula_09_024.png)值，以便绘制在目标函数定义的平面上的线条。我们还需要*修剪*这些值，确保只包含那些在问题中指定的范围内的值。通过在代码中构造标记为
    `I` 的索引数组来完成这一步，该数组由位于边界值内的点组成。
- en: There’s more...
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: This recipe covered the constrained minimization problem and how to solve it
    using SciPy. However, the same method can be used to solve the constrained *maximization*
    problem. This is because maximization and minimization are *dual* to one another,
    in the sense that maximizing a function,![](img/Formula_09_025.png), is the same
    as minimizing the ![](img/Formula_09_026.png) function and then taking the negative
    of this value. In fact, we used this fact in this recipe to change the second
    constraining inequality from ≥ to ≤.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了受限最小化问题以及如何使用 SciPy 解决它。然而，相同的方法也可以用来解决受限的*最大化*问题。这是因为最大化和最小化是*对偶*的，从某种意义上来说，最大化一个函数![](img/Formula_09_025.png)与最小化![](img/Formula_09_026.png)函数并取其负值是一样的。事实上，我们在本节中就利用了这一点，将第二个约束不等式从
    ≥ 改为 ≤。
- en: In this recipe, we solved a problem with only two parameter variables, but the
    same method will work (except for the plotting steps) for a problem involving
    more than two such variables. We just need to add more rows and columns to each
    of the arrays to account for this increased number of variables – this includes
    the tuple of bounds supplied to the routine. The routine can also be used with
    sparse matrices, where appropriate, for extra efficiency when dealing with very
    large amounts of variables.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们解决了一个只有两个参数变量的问题，但相同的方法也适用于涉及更多变量的问题（除了绘图步骤）。我们只需要为每个数组增加更多的行和列来处理增加的变量数量——这包括传递给函数的边界元组。当处理大量变量时，该函数还可以在适当的情况下与稀疏矩阵一起使用，以提高效率。
- en: The `linprog` routine gets its name from *linear programming*, which is used
    to describe problems of this type – finding values of ![](img/Formula_09_027.png)
    that satisfy some matrix inequalities subject to other conditions. Since there
    is a very close connection between the theory of matrices and linear algebra,
    there are many very fast and efficient techniques available for linear programming
    problems that are not available in a non-linear context.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`linprog` 函数得名于*线性规划*，用于描述此类问题——找到满足某些矩阵不等式的![](img/Formula_09_027.png)的值，同时满足其他条件。由于矩阵理论与线性代数之间有着紧密的联系，因此线性规划问题有许多非常快速和高效的技术，而这些技术在非线性上下文中是不可用的。'
- en: Minimizing a non-linear function
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最小化非线性函数
- en: In the previous recipe, we saw how to minimize a very simple linear function.
    Unfortunately, most functions are not linear and usually don’t have nice properties
    that we would like. For these non-linear functions, we cannot use the fast algorithms
    that have been developed for linear problems, so we need to devise new methods
    that can be used in these more general cases. The algorithm that we will use here
    is called the Nelder-Mead algorithm, which is a robust and general-purpose method
    that’s used to find the minimum value of a function and does not rely on its gradient.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们展示了如何最小化一个非常简单的线性函数。不幸的是，大多数函数并非线性，通常也不具备我们希望的良好特性。对于这些非线性函数，我们无法使用为线性问题开发的快速算法，因此我们需要设计出可以在这些更一般化情况下使用的新方法。我们将在这里使用的算法叫做
    Nelder-Mead 算法，它是一种健壮的通用方法，用于寻找函数的最小值，并且不依赖于函数的梯度。
- en: In this recipe, we’ll learn how to use the Nelder-Mead simplex method to minimize
    a non-linear function containing two variables.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何使用 Nelder-Mead 单纯形法来最小化一个包含两个变量的非线性函数。
- en: Getting ready
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In this recipe, we will use the NumPy package imported as `np`, the Matplotlib
    `pyplot` module imported as `plt`, the `Axes3D` class imported from `mpl_toolkits.mplot3d`
    to enable 3D plotting, and the SciPy `optimize` module:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用导入的 NumPy 包（命名为 `np`）、Matplotlib 的 `pyplot` 模块（命名为 `plt`）、从 `mpl_toolkits.mplot3d`
    导入的 `Axes3D` 类来启用 3D 绘图，以及 SciPy 的 `optimize` 模块：
- en: '[PRE38]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Let’s see how to use these tools to solve a non-linear optimization problem.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用这些工具来解决非线性优化问题。
- en: How to do it...
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何进行...
- en: 'The following steps show you how to use the Nelder-Mead simplex method to find
    the minimum of a general non-linear objective function:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤展示了如何使用Nelder-Mead单纯形法找到一般非线性目标函数的最小值：
- en: 'Define the objective function that we will minimize:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义我们要最小化的目标函数：
- en: '[PRE39]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Next, create a grid of values that we can plot our objective function on:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个值的网格，以便我们可以在上面绘制目标函数：
- en: '[PRE42]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now, we evaluate the function on this grid of points:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们在这个点阵上评估该函数：
- en: '[PRE45]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Next, we create a new figure with a `3d` axes object and set the axis labels
    and the title:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个包含`3d`坐标轴对象的新图，并设置轴标签和标题：
- en: '[PRE46]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now, we can plot the objective function as a surface on the axes we just created:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以将目标函数作为表面绘制在刚才创建的坐标轴上：
- en: '[PRE51]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We choose an initial point that our minimization routine will start its iteration
    at and plot this on the surface:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们选择一个初始点，作为最小化例程开始迭代的起点，并将其绘制在表面上：
- en: '[PRE53]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The plot of the objective function’s surface, along with the initial point,
    can be seen in the following diagram. Here, we can see that the minimum value
    appears to occur at around 0.5 on the x axis and -0.5 on the y axis:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 目标函数表面的绘图，以及初始点，可以在以下图示中看到。这里，我们可以看到最小值似乎出现在x轴大约0.5，y轴大约-0.5的位置：
- en: '![Figure 9.3 – A non-linear objective function with a starting point'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.3 – 一个包含起始点的非线性目标函数'
- en: '](img/9.3.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/9.3.jpg)'
- en: Figure 9.3 – A non-linear objective function with a starting point
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.3 – 一个包含起始点的非线性目标函数
- en: 'Now, we use the `minimize` routine from the `optimize` package to find the
    minimum value and print the `result` object that it produces:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们使用`optimize`包中的`minimize`例程来寻找最小值，并打印出它生成的`result`对象：
- en: '[PRE55]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Finally, we plot the minimum value found by the `minimize` routine on top of
    the objective function surface:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将`minimize`例程找到的最小值绘制在目标函数的表面上：
- en: '[PRE58]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The updated plot of the objective function, including the minimum point found
    by the `minimize` routine, can be seen in the following diagram:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 更新后的目标函数图，包含`minimize`例程找到的最小点，可以在以下图示中看到：
- en: '![Figure 9.4 – An objective function with a starting point and a minimum point'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.4 – 一个包含起始点和最小点的目标函数'
- en: '](img/9.4.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/9.4.jpg)'
- en: Figure 9.4 – An objective function with a starting point and a minimum point
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.4 – 一个包含起始点和最小点的目标函数
- en: This shows that the method has indeed found the minimum point (bottom right)
    within the region starting from the initial point (top left).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明该方法确实在从初始点（左上角）开始的区域内找到了最小点（右下角）。
- en: How it works...
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The Nelder-Mead simplex method – not to be confused with the simplex method
    for linear optimization problems – is a simple algorithm for finding the minimum
    values of a non-linear function and works even when the objective function does
    not have a known derivative. (This is not the case for the function in this recipe;
    the only gain from using a gradient-based method is the speed of convergence.)
    The method works by comparing the values of the objective function at the vertices
    of a simplex, which is a triangle in a two-dimensional space. The vertex with
    the largest function value is *reflected* through the opposite edge and performs
    an appropriate expansion or contraction that, in effect, moves the simplex *downhill*.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Nelder-Mead单纯形法——与线性优化问题的单纯形法不同——是一种简单的算法，用于找到非线性函数的最小值，即使该目标函数没有已知的导数也能有效工作。（对于这个示例中的函数并非如此；使用基于梯度的方法唯一的收益是收敛速度的提升。）该方法通过比较单纯形顶点处目标函数的值来工作，单纯形在二维空间中是一个三角形。具有最大函数值的顶点会被*反射*至对边，并执行适当的扩展或收缩，从而使单纯形*向下*移动。
- en: The `minimize` routine from the SciPy `optimize` module is an entry point for
    many non-linear function minimization algorithms. In this recipe, we used the
    Nelder-Mead simplex algorithm, but there are also a number of other algorithms
    available. Many of these algorithms require knowledge of the gradient of the function,
    which might be computed automatically by the algorithm. The algorithm can be used
    by providing the appropriate name to the `method` keyword argument.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 来自SciPy `optimize`模块的`minimize`例程是许多非线性函数最小化算法的入口点。在这个例子中，我们使用了Nelder-Mead单纯形算法，但也有许多其他算法可供选择。许多这些算法需要了解函数的梯度，梯度可能由算法自动计算。通过提供适当的名称给`method`关键字参数，就可以使用该算法。
- en: The `result` object that’s returned by the `minimize` routine contains lots
    of information about the solution that has been found – or not found, if an error
    occurred – by the solver. In particular, the desired parameters that the calculated
    minimum occurs at are stored in the `x` attribute of the result, while the value
    of the function is stored in the `fun` attribute.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`minimize`例程返回的`result`对象包含了关于找到的解（如果没有找到解则为错误）的大量信息。特别地，计算出的最小值对应的目标参数存储在结果的`x`属性中，而函数值存储在`fun`属性中。'
- en: The `minimize` routine requires the function and a starting value of `x0`. In
    this recipe, we also provided a tolerance value that the minimum should be computed
    at using the `tol` keyword argument. Changing this value will modify the accuracy
    of the computed solution.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`minimize`例程需要目标函数和`x0`的起始值。在这个示例中，我们还提供了一个容差值，要求最小值使用`tol`关键字参数进行计算。更改该值将会修改计算解的精度。'
- en: There’s more...
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容……
- en: The Nelder-Mead algorithm is an example of a *gradient-free* minimization algorithm,
    since it does not require any information about the gradient (derivative) of the
    objective function. There are several such algorithms, all of which typically
    involve evaluating the objective function at several points, and then using this
    information to move toward the minimum value. In general, gradient-free methods
    tend to converge more slowly than gradient-descent models. However, they can be
    used for almost any objective function, even where it is not easy to compute the
    gradient either exactly or by means of approximation.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Nelder-Mead算法是一个*无梯度*最小化算法的例子，因为它不需要任何关于目标函数梯度（导数）的信息。有几种类似的算法，它们通常涉及在多个点上评估目标函数，然后利用这些信息向最小值移动。一般来说，无梯度方法的收敛速度通常比梯度下降模型慢。然而，它们可以用于几乎任何目标函数，即使在无法准确计算梯度或通过近似计算梯度的情况下也能使用。
- en: Optimizing the functions of a single variable is generally easier than the multidimensional
    case and has its own special function in the SciPy `optimize` library. The `minimize_scalar`
    routine performs minimization for functions of a single variable and should be
    used instead of `minimize` in this case.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 优化单变量函数通常比多维情况更容易，并且在SciPy的`optimize`库中有一个专门的函数。`minimize_scalar`例程用于执行单变量函数的最小化，在这种情况下应替代`minimize`使用。
- en: Using gradient descent methods in optimization
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在优化中使用梯度下降方法
- en: In the previous recipe, we used the Nelder-Mead simplex algorithm to minimize
    a non-linear function containing two variables. This is a fairly robust method
    that works even if very little is known about the objective function. However,
    in many situations, we do know more about the objective function, and this fact
    allows us to devise faster and more efficient algorithms for minimizing the function.
    We can do this by making use of properties such as the gradient of the function.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的示例中，我们使用了Nelder-Mead单纯形算法来最小化一个包含两个变量的非线性函数。这是一种相当稳健的方法，即使对目标函数了解甚少，它也能有效工作。然而，在许多情况下，我们对目标函数有更多的了解，这使我们能够设计出更快速、更高效的算法来最小化该函数。我们可以通过利用诸如函数梯度等属性来实现这一点。
- en: 'The *gradient* of a function of more than one variable describes the rate of
    change of the function in each of its component directions. This is a vector of
    the partial derivatives of the function with respect to each of the variables.
    From this gradient vector, we can deduce the direction in which the function is
    increasing most rapidly and, conversely, the direction in which the function is
    decreasing most rapidly from any given position. This gives us the basis for **gradient
    descent** methods for minimizing a function. The algorithm is very simple: given
    a starting position,![](img/Formula_09_028.png), we compute the gradient at ![](img/Formula_09_029.png)
    and the corresponding direction in which the gradient is most rapidly decreasing,
    and then make a small step in that direction. After a few iterations, this will
    move from the starting position to the minimum of the function.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 一个多变量函数的*梯度*描述了该函数在各个分量方向上的变化速率。这是该函数关于每个变量的偏导数向量。通过这个梯度向量，我们可以推断出函数增长最快的方向，反之，也可以推断出函数下降最快的方向。从任意给定位置出发，这为我们提供了**梯度下降**方法的基础，用于最小化一个函数。算法非常简单：给定一个起始位置，![](img/Formula_09_028.png)，我们计算在![](img/Formula_09_029.png)的梯度以及梯度下降最快的对应方向，然后朝着该方向迈出一个小步伐。经过几次迭代后，这将使我们从起始位置移动到函数的最小值。
- en: In this recipe, we will learn how to implement an algorithm based on the steepest
    descent algorithm to minimize an objective function within a bounded region.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将学习如何实现一个基于最速下降法的算法，在一个有界区域内最小化目标函数。
- en: Getting ready
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备开始
- en: 'For this recipe, we will need the NumPy package imported as `np`, the Matplotlib
    `pyplot` module imported as `plt`, and the `Axes3D` object imported from `mpl_toolkits.mplot3d`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个食谱，我们需要导入NumPy包作为`np`，Matplotlib的`pyplot`模块作为`plt`，以及从`mpl_toolkits.mplot3d`导入`Axes3D`对象：
- en: '[PRE59]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Let’s implement a simple gradient descent algorithm and use it to solve the
    minimization problem described in the previous recipe to see how it works.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现一个简单的梯度下降算法，并用它来解决前面食谱中描述的最小化问题，看看它是如何工作的。
- en: How to do it...
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'In the following steps, we will implement a simple gradient descent method
    to minimize an objective function with a known gradient function (we’re actually
    going to use a generator function so that we can see the method as it works):'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的步骤中，我们将实现一个简单的梯度下降法，用来最小化一个已知梯度函数的目标函数（实际上我们将使用一个生成器函数，以便在方法运行时看到它的工作过程）：
- en: 'We will start by defining a `descend` routine, which will carry out our algorithm.
    The function declaration is as follows:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将从定义一个`descend`例程开始，它将执行我们的算法。函数声明如下：
- en: '[PRE60]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Next, we need to implement this routine. We start by defining the variables
    that will hold the iterate values while the method is running:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要实现这个例程。我们从定义在方法运行过程中存储迭代值的变量开始：
- en: '[PRE61]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'We then start our loop, which will run the iterations. We immediately check
    whether we are making meaningful progress before continuing:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们开始我们的循环，它将执行迭代。在继续之前，我们立即检查是否在取得有意义的进展：
- en: '[PRE64]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The direction is minus the gradient vector. We compute this once and store
    it in the `direction` variable:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 方向是梯度向量的负值。我们计算一次并将其存储在`direction`变量中：
- en: '[PRE67]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Now, we update the previous and current values, `xnm1` and `xn` respectively,
    ready for the next iteration. This concludes the code for the `descend` routine:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们更新前一个和当前的值，分别是`xnm1`和`xn`，为下一次迭代做好准备。这就结束了`descend`例程的代码：
- en: '[PRE68]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Now, we can compute the gradient at the current value and yield all the appropriate
    values:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以计算当前值的梯度并生成所有适当的值：
- en: '[PRE70]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: This concludes the definition of the `descend` routine.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了`descend`例程的定义。
- en: 'We can now define a sample objective function to minimize:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以定义一个示例目标函数进行最小化：
- en: '[PRE72]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Next, we create a grid that we will evaluate and then plot the objective function
    on:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个网格，用于评估并绘制目标函数：
- en: '[PRE75]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Once the grid has been created, we can evaluate our function and store the
    result in the `z` variable:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦创建了网格，我们可以评估我们的函数并将结果存储在`z`变量中：
- en: '[PRE78]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Next, we create a three-dimensional surface plot of the objective function:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建目标函数的三维曲面图：
- en: '[PRE79]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Before we can start the minimization process, we need to define an initial
    point, `x0`. We plot this point on the objective function plot we created in the
    previous step:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在开始最小化过程之前，我们需要定义一个初始点`x0`。我们将这个点绘制在我们之前创建的目标函数图上：
- en: '[PRE87]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'The surface plot of the objective function, along with the initial value, can
    be seen in the following diagram:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 目标函数的表面图以及初始值可以在下图中看到：
- en: '![Figure 9.5 – The surface of the objective function with the initial position'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.5 – 目标函数的表面图和初始位置](img/9.5.jpg)'
- en: '](img/9.5.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/9.5.jpg)'
- en: Figure 9.5 – The surface of the objective function with the initial position
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.5 – 目标函数的表面图和初始位置
- en: 'Our `descend` routine requires a function that evaluates the gradient of the
    objective function, so we will define one:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的`descend`例程需要一个评估目标函数梯度的函数，因此我们将定义一个：
- en: '[PRE89]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'We will plot the iterations on a contour plot, so we set this up as follows:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将把迭代次数绘制在等高线图上，因此我们按以下方式进行设置：
- en: '[PRE97]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Now, we create a variable that holds the bounds in the ![](img/Formula_09_027.png)
    and ![](img/Formula_09_031.png) directions as a tuple of tuples. These are the
    same bounds from the `linspace` calls in *step 10*:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们创建一个变量，用来保存在![](img/Formula_09_027.png)和![](img/Formula_09_031.png)方向上的边界，这些边界是一个元组的元组。这些边界与*第10步*中的`linspace`调用的边界相同：
- en: '[PRE102]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'We can now use a `for` loop to drive the `descend` generator to produce each
    of the iterations and add the steps to the contour plot:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以使用`for`循环驱动`descend`生成器来生成每次迭代，并将步骤添加到等高线图中：
- en: '[PRE103]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Once the loop is complete, we print the final values to the Terminal:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 循环完成后，我们将最终的值打印到终端：
- en: '[PRE107]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'The output of the preceding `print` statements is as follows:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 之前`print`语句的输出如下：
- en: '[PRE110]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: Here, we can see that our routine used 37 iterations to find a minimum at approximately
    (0.5, -0.5), which is correct.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们的例程使用了37次迭代，找到了大约在(0.5, -0.5)的最小值，这是正确的。
- en: 'The contour plot with its iterations plotted can be seen in the following diagram:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 带有迭代次数的等高线图可以在下图中看到：
- en: '![Figure 9.6 – A contour plot of the objective function with the gradient descent
    iterating to a minimum value](img/9.6.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.6 – 目标函数的等高线图，梯度下降迭代到最小值](img/9.6.jpg)'
- en: Figure 9.6 – A contour plot of the objective function with the gradient descent
    iterating to a minimum value
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.6 – 目标函数的等高线图，显示梯度下降迭代到最小值
- en: Here, we can see that the direction of each iteration – shown by the dashed
    lines – is in the direction where the objective function is decreasing most rapidly.
    The final iteration lies at the center of the *bowl* of the objective function,
    which is where the minimum occurs.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到每次迭代的方向——由虚线表示——是目标函数下降最迅速的方向。最终的迭代位于目标函数的*碗*的中心，即最小值所在的位置。
- en: How it works...
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The heart of this recipe is the `descend` routine. The process that’s defined
    in this routine is a very simple implementation of the gradient descent method.
    Computing the gradient at a given point is handled by the `grad` argument, which
    is then used to deduce the direction of travel for the iteration by taking `direction
    = -grad`. We multiply this direction by a fixed scale factor (sometimes called
    the `0.2*direction` to the current position.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱的核心是`descend`例程。该例程中定义的过程是梯度下降法的一个非常简单的实现。在给定点计算梯度由`grad`参数处理，然后通过`direction
    = -grad`来推导迭代的行进方向。我们将这个方向乘以一个固定的比例因子（有时称为`0.2*direction`），然后加到当前位置。
- en: The solution in the recipe took 37 iterations to converge, which is a mild improvement
    on the Nelder-Mead simplex algorithm from the *Minimizing a non-linear function*
    recipe, which took 58 iterations. (This is not a perfect comparison, since we
    changed the starting position for this recipe.) This performance is heavily dependent
    on the step size that we choose. In this case, we fixed the maximum step size
    to be 0.2 times the size of the direction vector. This keeps the algorithm simple,
    but it is not particularly efficient.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱中的解法在收敛时花费了37次迭代，相较于*最小化非线性函数*食谱中的Nelder-Mead单纯形算法（该算法花费了58次迭代），这是一个轻微的改进。（这不是一个完美的比较，因为我们更改了这个食谱的起始位置。）该性能在很大程度上依赖于我们选择的步长。在这种情况下，我们将最大步长固定为方向向量大小的0.2倍。这使得算法保持简单，但效率并不是特别高。
- en: In this recipe, we chose to implement the algorithm as a generator function
    so that we could see the output of each step and plot this on our contour plot
    as we stepped through the iteration. In practice, we probably wouldn’t want to
    do this and instead return the calculated minimum once the iterations have finished.
    To do this, we can simply remove the `yield` statement and replace it with `return
    xn` at the very end of the function, at the main function’s indentation (that
    is, not inside the loop). If you want to guard against non-convergence, you can
    use the `else` feature of the `for` loop to catch cases where the loop finishes
    because it has reached the end of its iterator without hitting the `break` keyword.
    This `else` block could raise an exception to indicate that the algorithm has
    failed to stabilize to a solution. The condition we used to end the iteration
    in this recipe does not guarantee that the method has reached a minimum, but this
    will usually be the case.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们选择将算法实现为生成器函数，这样可以在每一步迭代中看到输出，并将其绘制在等高线图上。当我们逐步执行迭代时，我们可以看到每一步的结果。实际上，我们可能不想这样做，而是希望在迭代完成后直接返回计算得到的最小值。为了实现这一点，我们只需移除`yield`语句，并在函数的最后（即主函数的缩进位置，不在循环内部）将其替换为`return
    xn`。如果你想防止不收敛的情况，可以使用`for`循环的`else`特性来捕捉循环因到达迭代器末尾而没有触发`break`关键字的情况。这个`else`块可以引发异常，表示算法未能收敛到一个解。在这个例子中，我们用来结束迭代的条件并不能保证方法已经达到最小值，但通常情况下它是有效的。
- en: There’s more...
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: In practice, you would not usually implement the gradient descent algorithm
    for yourself and instead use a general-purpose routine from a library such as
    the SciPy `optimize` module. We can use the same `minimize` routine that we used
    in the previous recipe to perform minimization with a variety of different algorithms,
    including several gradient descent algorithms. These implementations are likely
    to have much higher performance and be more robust than a custom implementation
    such as this.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，你通常不会自己实现梯度下降算法，而是会使用像 SciPy `optimize` 模块这样的库中的通用函数。我们可以使用在前一个例子中使用的相同`minimize`函数，通过多种不同的算法执行最小化，包括几种梯度下降算法。这些实现通常会比像这种自定义实现具有更高的性能和更强的鲁棒性。
- en: 'The gradient descent method we used in this recipe is a very naive implementation
    and can be greatly improved by allowing the routine to choose the step size at
    each step. (Methods that are allowed to choose their own step size are sometimes
    called adaptive methods.) The difficult part of this improvement is choosing the
    size of the step to take in this direction. For this, we need to consider the
    function of a single variable, which is given by the following equation:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个例子中使用的梯度下降方法是一个非常简单的实现，可以通过允许算法在每一步选择步长来大大改进。（允许自己选择步长的方法有时被称为自适应方法。）这种改进的难点在于如何选择在此方向上采取的步长。为此，我们需要考虑一个单变量的函数，该函数由以下方程给出：
- en: '![](img/Formula_09_032.png)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_09_032.png)'
- en: Here, ![](img/Formula_09_033.png) represents the current point, ![](img/Formula_09_034.png)
    represents the current direction, and ![](img/Formula_09_035.png) is a parameter.
    For simplicity, we can use a minimization routine called `minimize_scalar` for
    scalar-valued functions from the SciPy `optimize` module. Unfortunately, it is
    not quite as simple as passing in this auxiliary function and finding the minimum
    value. We have to bound the possible value of ![](img/Formula_09_036.png) so that
    the computed minimizing point, ![](img/Formula_09_037.png), lies within the region
    that we are interested in.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，![](img/Formula_09_033.png)表示当前点，![](img/Formula_09_034.png)表示当前方向，![](img/Formula_09_035.png)是一个参数。为了简便起见，我们可以使用一个名为`minimize_scalar`的最小化例程来处理标量值函数，来自
    SciPy `optimize` 模块。不幸的是，这并不是像传入这个辅助函数并找到最小值那样简单。我们需要给`![](img/Formula_09_036.png)`的可能值设置边界，以便计算得到的最小化点，`![](img/Formula_09_037.png)`，位于我们感兴趣的区域内。
- en: 'To understand how we bound the values of ![](img/Formula_09_038.png), we must
    first look at the construction geometrically. The auxiliary function that we introduce
    evaluates the objective function along a single line in the given direction. We
    can picture this as taking a single cross section through the surface that passes
    through the current ![](img/Formula_09_039.png) point in the ![](img/Formula_09_040.png)
    direction. The next step of the algorithm is finding the step size, ![](img/Formula_09_041.png),
    that minimizes the values of the objective function along this line – this is
    a scalar function, which is much easier to minimize. The bounds should then be
    the range of ![](img/Formula_09_042.png) values, during which this line lies within
    the rectangle defined by the ![](img/Formula_09_043.png) and ![](img/Formula_09_044.png)
    boundary values. We determine the four values at which this line crosses those
    ![](img/Formula_09_045.png) and ![](img/Formula_09_046.png) boundary lines, two
    of which will be negative and two of which will be positive. (This is because
    the current point must lie within the rectangle.) We take the minimum of the two
    positive values and the maximum of the two negative values and pass these bounds
    to the scalar minimization routine. This is achieved using the following code:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解我们如何约束 ![](img/Formula_09_038.png) 的值，我们必须先从几何角度看构建过程。我们引入的辅助函数评估了沿给定方向的单条直线上的目标函数。我们可以将其想象为对表面进行单一的截面切割，切割面通过当前的
    ![](img/Formula_09_039.png) 点，并沿 ![](img/Formula_09_040.png) 方向延伸。算法的下一步是寻找步长
    ![](img/Formula_09_041.png)，它最小化沿该直线的目标函数值——这是一个标量函数，比较容易最小化。然后，边界值应该是 ![](img/Formula_09_042.png)
    的值范围，在此范围内，直线将位于由 ![](img/Formula_09_043.png) 和 ![](img/Formula_09_044.png) 边界值定义的矩形内。我们确定这条直线与
    ![](img/Formula_09_045.png) 和 ![](img/Formula_09_046.png) 边界线交叉的四个值，其中两个是负数，两个是正数。（这是因为当前点必须位于矩形内。）我们取两个正值中的最小值和两个负值中的最大值，并将这些边界传递给标量最小化程序。可以使用以下代码实现此过程：
- en: '[PRE111]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Once the step size has been chosen, the only remaining step is to update the
    current `xn` value, as follows:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦步长被选定，剩下的唯一步骤是更新当前的 `xn` 值，如下所示：
- en: '[PRE112]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: Using this adaptive step size increases the complexity of the routine, but the
    performance is massively improved. Using this revised routine, the method converged
    in just three iterations, which is far fewer than the number of iterations used
    by the naive code in this recipe (37 iterations) or by the Nelder-Mead simplex
    algorithm in the previous recipe (58 iterations). This reduction in the number
    of iterations is exactly what we expected by providing the method with more information
    in the form of the gradient function.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种自适应步长增加了程序的复杂性，但性能得到了显著提高。使用这种改进的程序，方法仅在三次迭代内收敛，这比本食谱中朴素代码使用的迭代次数（37 次）或上一食谱中
    Nelder-Mead 单纯形算法的迭代次数（58 次）要少得多。迭代次数的减少正是我们通过提供梯度函数这一信息而预期的结果。
- en: We created a function that returned the gradient of the function at a given
    point. We computed this gradient by hand before we started, which will not always
    be easy or even possible. Instead, it is much more common to replace the *analytic*
    gradient used here with a numerically computed gradient that’s been estimated
    using finite differences or a similar algorithm. This has an impact on performance
    and accuracy, as all approximations do, but these concerns are usually minor given
    the improvement in the speed of convergence offered by gradient descent methods.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个函数，返回给定点处的函数梯度。我们在开始之前手动计算了这个梯度，但这并不总是容易甚至可能的。相反，通常会将这里使用的*解析*梯度替换为一个数值计算梯度，该梯度通过有限差分或类似算法估算得到。这会对性能和精度产生影响，就像所有的近似方法一样，但鉴于梯度下降方法在收敛速度上的改进，这些问题通常是微不足道的。
- en: Gradient descent-type algorithms are particularly popular in machine learning
    applications. Most of the popular Python machine learning libraries – including
    PyTorch, TensorFlow, and Theano – offer utilities for automatically computing
    gradients numerically for data arrays. This allows gradient descent methods to
    be used in the background to improve performance.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 梯度下降类算法在机器学习应用中尤其流行。大多数流行的 Python 机器学习库——包括 PyTorch、TensorFlow 和 Theano——都提供了用于自动计算数据数组梯度的工具。这使得梯度下降方法可以在后台使用，从而提高性能。
- en: A popular variation of the gradient descent method is **stochastic gradient
    descent**, where the gradient is estimated by sampling randomly rather than using
    the whole set of data. This can dramatically reduce the computational burden of
    the method – at the cost of slower convergence – especially for high-dimensional
    problems such as those that are common in machine learning applications. Stochastic
    gradient descent methods are often combined with backpropagation to form the basis
    for training artificial neural networks in machine learning applications.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 梯度下降法的一个流行变体是**随机梯度下降法**，其中梯度是通过随机抽样估算的，而不是使用整个数据集。这可以显著减轻该方法的计算负担——虽然代价是收敛速度较慢——特别是在高维问题中，如机器学习应用中常见的问题。随机梯度下降法通常与反向传播结合，成为训练人工神经网络在机器学习中的基础。
- en: There are several extensions of the basic stochastic gradient descent algorithm.
    For example, the momentum algorithm incorporates the previous increment into the
    calculation of the next increment. Another example is the adaptive gradient algorithm,
    which incorporates per-parameter learning rates to improve the rate of convergence
    for problems that involve a large number of sparse parameters.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的随机梯度下降算法有几种扩展。例如，动量算法将前一个增量融入到下一个增量的计算中。另一个例子是自适应梯度算法，它结合了每个参数的学习率，以提高涉及大量稀疏参数问题的收敛速度。
- en: Using least squares to fit a curve to data
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用最小二乘法拟合曲线到数据
- en: Least squares is a powerful technique for finding a function from a relatively
    small family of potential functions that best describe a particular set of data.
    This technique is especially common in statistics. For example, least squares
    is used in linear regression problems – here, the family of potential functions
    is the collection of all linear functions. Usually, the family of functions that
    we try to fit has relatively few parameters that can be adjusted to solve the
    problem.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 最小二乘法是一种强大的技术，用于从相对较小的潜在函数家族中找到最能描述特定数据集的函数。该技术在统计学中尤为常见。例如，最小二乘法用于线性回归问题——在这里，潜在函数的家族是所有线性函数的集合。通常，我们尝试拟合的函数家族具有相对较少的可调参数，用以解决问题。
- en: The idea of least squares is relatively simple. For each data point, we compute
    the square of the residual – the difference between the value of the point and
    the expected value given a function – and try to make the sum of these squared
    residuals as small as possible (hence, least squares).
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 最小二乘法的理念相对简单。对于每个数据点，我们计算残差的平方——即点的值与给定函数的期望值之间的差异——并尝试将这些残差平方的和尽可能小（因此称为最小二乘法）。
- en: In this recipe, we’ll learn how to use least squares to fit a curve to a sample
    set of data.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将学习如何使用最小二乘法拟合一条曲线到样本数据集。
- en: Getting ready
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this recipe, we will need the NumPy package imported, as usual, as `np`,
    and the Matplotlib `pyplot` module imported as `plt`:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本教程，我们将像往常一样导入 NumPy 包，命名为 `np`，并导入 Matplotlib `pyplot` 模块，命名为 `plt`：
- en: '[PRE113]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'We will also need an instance of the default random number generator from the
    NumPy `random` module imported, as follows:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要从 NumPy `random` 模块导入默认的随机数生成器实例，如下所示：
- en: '[PRE114]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Finally, we need the `curve_fit` routine from the SciPy `optimize` module:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要 SciPy `optimize` 模块中的 `curve_fit` 函数：
- en: '[PRE115]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: Let’s see how to use this routine to fit a non-linear curve to some data.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用这个函数将一条非线性曲线拟合到一些数据上。
- en: How to do it...
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'The following steps show you how to use the `curve_fit` routine to fit a curve
    to a set of data:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤展示了如何使用 `curve_fit` 函数将一条曲线拟合到一组数据：
- en: 'The first step is to create the sample data:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是创建样本数据：
- en: '[PRE116]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Next, we produce a scatter plot of the data to see whether we can identify
    the underlying trend in the data:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们生成数据的散点图，以查看是否能识别数据中的潜在趋势：
- en: '[PRE120]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'The scatter plot that we have produced can be seen in the following diagram.
    Here, we can see that the data certainly doesn’t follow a linear trend (straight
    line). Since we know the trend is a polynomial, our next guess would be a quadratic
    trend. This is what we’re using here:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所生成的散点图如下所示。这里，我们可以看到数据显然不遵循线性趋势（直线）。既然我们知道趋势是多项式，那么我们接下来的猜测是二次趋势。这就是我们在这里使用的：
- en: '![Figure 9.7 – Scatter plot of the sample data – we can see that it does not
    follow a linear trend'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.7 – 样本数据的散点图 – 我们可以看到数据并没有遵循线性趋势'
- en: '](img/9.7.jpg)'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/9.7.jpg)'
- en: Figure 9.7 – Scatter plot of the sample data – we can see that it does not follow
    a linear trend
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.7 – 样本数据的散点图——我们可以看到它没有遵循线性趋势
- en: 'Next, we create a function that represents the model that we wish to fit:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个表示我们希望拟合的模型的函数：
- en: '[PRE124]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'Now, we can use the `curve_fit` routine to fit the model function to the sample
    data:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以使用 `curve_fit` 例程将模型函数拟合到样本数据中：
- en: '[PRE126]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'Finally, we plot the best fit curve on top of the scatter plot to evaluate
    how well the fitted curve describes the data:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将最佳拟合曲线绘制到散点图上，以评估拟合曲线对数据的描述效果：
- en: '[PRE129]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'The updated scatter plot can be seen in the following diagram:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 更新后的散点图可以在下图中看到：
- en: '![Figure 9.8 – A scatter plot with the curve of the best fit found using superimposed
    least squares'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.8 – 一个使用叠加最小二乘法找到的最佳拟合曲线的散点图'
- en: '](img/9.8.jpg)'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/9.8.jpg)'
- en: Figure 9.8 – A scatter plot with the curve of the best fit found using superimposed
    least squares
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.8 – 一个使用叠加最小二乘法找到的最佳拟合曲线的散点图
- en: Here, we can see that the curve we have found fits the data reasonably well.
    The coefficients are not exactly equal to the true model – this is the effect
    of the added noise.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们找到的曲线拟合数据的效果相当好。系数并不完全等于真实模型——这是由于添加的噪声效应。
- en: How it works...
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `curve_fit` routine performs least-squares fitting to fit the model’s curve
    to the sample data. In practice, this amounts to minimizing the following objective
    function:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '`curve_fit` 例程执行最小二乘法拟合，将模型的曲线拟合到样本数据中。在实践中，这相当于最小化以下目标函数：'
- en: '![](img/Formula_09_047.jpg)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_09_047.jpg)'
- en: Here, the pairs ![](img/Formula_09_048.png) are the points from the sample data.
    In this case, we are optimizing over a three-dimensional parameter space, with
    one dimension for each of the parameters. The routine returns the estimated coefficients
    – the point in the parameter space at which the objective function is minimized
    – and a second variable that contains estimates for the covariance matrix for
    the fit. We ignored this in this recipe.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，配对的 ![](img/Formula_09_048.png) 是样本数据中的点。在这种情况下，我们在一个三维参数空间中进行优化，每个维度对应一个参数。例程返回估计的系数——在参数空间中最小化目标函数的点——以及一个包含拟合协方差矩阵估计值的第二个变量。在这个例子中，我们忽略了这一部分。
- en: The estimated covariance matrix that’s returned from the `curve_fit` routine
    can be used to give a confidence interval for the estimated parameters. This is
    done by taking the square root of the diagonal elements divided by the sample
    size (100 in this recipe). This gives the standard error for the estimate that,
    when multiplied by the appropriate values corresponding to the confidence, gives
    us the size of the confidence interval. (We discussed confidence intervals in
    [*Chapter 6*](B19085_06.xhtml#_idTextAnchor226), *Working with Data* *and Statistics*.)
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `curve_fit` 例程返回的估计协方差矩阵可以用来为估计的参数提供置信区间。这是通过取对角元素的平方根并除以样本大小（本例中为 100）来实现的。这会给出估计的标准误差，当乘以对应于置信度的适当值时，就能得到置信区间的大小。（我们在[*第6章*](B19085_06.xhtml#_idTextAnchor226)
    *数据与统计学应用* 中讨论了置信区间。）
- en: You might have noticed that the parameters estimated by the `curve_fit` routine
    are close, but not exactly equal, to the parameters that we used to define the
    sample data in *step 1*. The fact that these are not exactly equal is due to the
    normally distributed noise that we added to the data. In this recipe, we knew
    that the underlying structure of the data was quadratic – that is, a degree 2
    polynomial – and not some other, more esoteric, function. In practice, we are
    unlikely to know so much about the underlying structure of the data, which is
    the reason we added noise to the sample.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，`curve_fit` 例程估计的参数与我们在*步骤 1* 中用来定义样本数据的参数接近，但并不完全相等。之所以没有完全相等，是因为我们向数据中添加了正态分布噪声。在这个例子中，我们知道数据的潜在结构是二次型的——也就是二次多项式——而不是其他更复杂的函数。实际上，我们不太可能如此清楚数据的潜在结构，这也是我们向样本中添加噪声的原因。
- en: There’s more...
  id: totrans-319
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: 'There is another routine in the SciPy `optimize` module for performing least-squares
    fitting called `least_squares`. This routine has a slightly less intuitive signature
    but does return an object containing more information about the optimization process.
    However, the way this routine is set up is perhaps more similar to the way that
    we constructed the underlying mathematical problem in the *How it works...* section.
    To use this routine, we define the objective function as follows:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: SciPy `optimize`模块中有另一个执行最小二乘拟合的例程，称为`least_squares`。这个例程的签名稍微不那么直观，但确实返回一个包含更多优化过程信息的对象。然而，这个例程的设置方式可能更类似于我们在*如何运作...*部分中构造底层数学问题的方式。要使用这个例程，我们定义目标函数如下：
- en: '[PRE132]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'We pass this function along with a starting estimate in the parameter space,
    `x0`, such as `(1, 0, 0)`. The additional parameters for the objective function,
    `func`, can be passed using the `args` keyword argument – for example, we could
    use `args=(x_data, y_data)`. These arguments are passed into the `x` and `y` arguments
    of the objective function. To summarize, we could have estimated the parameters
    using the following call to `least_squares`:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这个函数和在参数空间中的初始估计`x0`一起传递，例如`(1, 0, 0)`。目标函数`func`的附加参数可以通过`args`关键字参数传递——例如，我们可以使用`args=(x_data,
    y_data)`。这些参数会被传递到目标函数的`x`和`y`参数中。总结来说，我们可以通过以下方式调用`least_squares`来估计参数：
- en: '[PRE133]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: The `results` object that’s returned from the `least_squares` routine is actually
    the same as the one returned by the other optimization routines described in this
    chapter. It contains details such as the number of iterations used, whether the
    process was successful, detailed error messages, the parameter values, and the
    value of the objective function at the minimum value.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 从`least_squares`例程返回的`results`对象实际上与本章描述的其他优化例程返回的对象相同。它包含诸如使用的迭代次数、过程是否成功、详细的错误信息、参数值以及目标函数在最小值处的值等细节。
- en: Analyzing simple two-player games
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析简单的二人游戏
- en: Game theory is a branch of mathematics concerned with the analysis of decision-making
    and strategy. It has applications in economics, biology, and behavioral science.
    Many seemingly complex situations can be reduced to a relatively simple mathematical
    game that can be analyzed in a systematic way to find *optimal* solutions.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 博弈论是研究决策和策略分析的数学分支。它在经济学、生物学和行为科学中有广泛应用。许多看似复杂的情境可以简化为一个相对简单的数学博弈，经过系统分析后能够找到*最优*解决方案。
- en: 'A classic problem in game theory is the *prisoner’s dilemma*, which, in its
    original form, is as follows: two co-conspirators are caught and must decide whether
    to remain quiet or to testify against the other. If both remain quiet, they both
    serve a 1-year sentence; if one testifies but the other does not, the testifier
    is released and the other serves a 3-year sentence; and if both testify against
    one another, they both serve a 2-year sentence. What should each conspirator do?
    It turns out that the best choice each conspirator can make, given any reasonable
    distrust of the other, is to testify. Adopting this strategy, they will either
    serve no sentence or a 2-year sentence maximum.'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 博弈论中的经典问题是*囚徒困境*，其原始形式如下：两个同谋被抓获，必须决定是否保持沉默或指证对方。如果两人都保持沉默，他们都服刑1年；如果一个人作证而另一个人不作证，作证的人被释放，另一个人服刑3年；如果两人都相互作证，他们都服刑2年。那么每个同谋应该怎么做呢？事实证明，考虑到对对方的合理不信任，每个同谋做出的最佳选择是作证。采取这种策略，他们要么不服刑，要么最多服刑2年。
- en: 'Since this book is about Python, we will use a variation of this classic problem
    to illustrate just how universal the idea of this problem is. Consider the following
    problem: you and your colleague have to write some code for a client. You think
    that you could write the code faster in Python, but your colleague thinks that
    they could write it faster in C. The question is, which language should you choose
    for the project?'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这本书是关于Python的，我们将用这个经典问题的变种来说明这个问题的普遍性。考虑以下问题：你和你的同事必须为客户编写一些代码。你认为你可以用Python写得更快，但你的同事认为他们可以用C语言写得更快。问题是，你们应该为项目选择哪种语言？
- en: 'You think that you could write the Python code four times faster than in C,
    so you write C with speed 1 and Python with speed 4\. Your colleague says that
    they can write C slightly faster than Python, so they write C with speed 3 and
    Python with speed 2\. If you both agree on a language, then you write the code
    at the speed you predicted, but if you disagree, then the productivity of the
    faster programmer is reduced by 1\. We can summarize this as follows:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 你认为自己可以写出比 C 快四倍的 Python 代码，所以你以速度 1 写 C，速度 4 写 Python。你的同事说他们写 C 稍微比写 Python
    快一些，所以他们写 C 以速度 3，写 Python 以速度 2。如果你们都同意一个语言，那么你按照自己预测的速度写代码；但是如果你们意见不合，那么较快的程序员的生产力会减少
    1。我们可以总结如下：
- en: '| Colleague/You | C | Python |'
  id: totrans-330
  prefs: []
  type: TYPE_TB
  zh: '| 同事/你 | C | Python |'
- en: '| C | 3/1 | 3/2 |'
  id: totrans-331
  prefs: []
  type: TYPE_TB
  zh: '| C | 3/1 | 3/2 |'
- en: '| Python | 2/1 | 2/4 |'
  id: totrans-332
  prefs: []
  type: TYPE_TB
  zh: '| Python | 2/1 | 2/4 |'
- en: Figure 9.9 – A table of the predicted work speed in various configurations
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.9 – 预测各种配置下的工作速度表
- en: In this recipe, we will learn how to construct an object in Python to represent
    this simple two-player game, and then perform some elementary analysis regarding
    the outcomes of this game.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将学习如何在 Python 中构建一个对象来表示这个简单的两人游戏，并对游戏的结果进行一些基础分析。
- en: Getting ready
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this recipe, we will need the NumPy package imported as `np`, and the Nashpy
    package imported as `nash`:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个教程，我们需要导入 NumPy 包为 `np`，以及导入 Nashpy 包为 `nash`：
- en: '[PRE134]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: Let’s see how to use the `nashpy` package to analyze a simple two-player game.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用 `nashpy` 包来分析一个简单的两人游戏。
- en: How to do it...
  id: totrans-339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'The following steps show you how to create and perform some simple analysis
    of a two-player game using Nashpy:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将向你展示如何使用 Nashpy 创建并进行一些简单的两人博弈分析：
- en: 'First, we need to create matrices that hold the payoff information for each
    player (you and your colleague, in this example):'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要创建存储每个玩家回报信息的矩阵（在这个例子中是你和你的同事）：
- en: '[PRE135]'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'Next, we create a `Game` object that holds the game represented by these payoff
    matrices:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个 `Game` 对象，该对象包含了由这些回报矩阵表示的游戏：
- en: '[PRE137]'
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'We compute the utility for the given choices using index notation:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过索引符号计算给定选择的效用：
- en: '[PRE138]'
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'We can also compute the expected utilities based on the probabilities of making
    a specific choice:'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以根据选择某个特定决策的概率来计算期望效用：
- en: '[PRE142]'
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE142]'
- en: These expected utilities represent what we’d expect (on average) to see if we
    repeated the game numerous times with the specified probabilities.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 这些期望效用表示我们期望（平均来说）在多次重复游戏时看到的结果，按照指定的概率。
- en: How it works...
  id: totrans-354
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we built a Python object that represents a very simple two-player
    strategic game. The idea here is that there are two *players* who have decisions
    to make, and each combination of both players’ choices gives a specific payoff
    value. What we’re aiming to do here is find the best choice that each player can
    make. The players are assumed to make a single move simultaneously, in the sense
    that neither is aware of the other’s choice. Each player has a strategy that determines
    the choice they make.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们构建了一个 Python 对象，表示一个非常简单的两人战略游戏。这里的思路是有两个*玩家*需要做出决策，每种玩家选择的组合会给出一个特定的回报值。我们在这里的目标是找到每个玩家可以做出的最佳选择。假设两个玩家同时做出一个决定，在这个过程中，任何一个玩家都不知道对方的选择。每个玩家都有一个策略来决定他们的选择。
- en: In *step 1*, we create two matrices – one for each player – that are assigned
    to each combination of choices for the payoff value. These two matrices are wrapped
    by the `Game` class from Nashpy, which provides a convenient and intuitive (from
    a game-theoretic point of view) interface for working with games. We can quickly
    calculate the utility of a given combination of choices by passing in the choices
    using index notation.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤 1*中，我们为每个玩家创建两个矩阵，每个矩阵对应每种选择组合的回报值。这两个矩阵被 Nashpy 的 `Game` 类包装，提供了一个便捷且直观（从博弈论角度看）的界面来处理游戏。我们可以通过传入选择并使用索引符号，快速计算给定选择组合的效用。
- en: We can also calculate expected utilities based on a strategy where choices are
    chosen at random according to some probability distribution. The syntax is the
    same as for the deterministic case described previously, except we provide a vector
    of probabilities for each choice. We compute the expected utilities based on the
    probability that you choose Python 90% of the time, while your colleague chooses
    Python 50% of the time. The expected speeds are 2.45 and 2.05 for you and your
    colleague respectively.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以基于一种策略计算预期效用，其中根据某种概率分布随机选择。语法与前面描述的确定性情况相同，只是我们为每个选择提供一个概率向量。我们根据您90%的时间选择Python，而您的同事选择Python的概率为50%来计算预期速度，分别为2.45和2.05。
- en: There’s more...
  id: totrans-358
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: There is an alternative to computational game theory in Python. The Gambit project
    is a collection of tools used for computation in game theory that has a Python
    interface ([http://www.gambit-project.org/](http://www.gambit-project.org/)).
    This is a mature project built around C libraries and offers more performance
    than Nashpy.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，计算游戏理论的另一种方法是使用Gambit项目。Gambit项目是一个工具集，用于计算博弈论，具有Python接口（[http://www.gambit-project.org/](http://www.gambit-project.org/)）。这是一个成熟的项目，构建在C库的基础上，并提供比Nashpy更高的性能。
- en: Computing Nash equilibria
  id: totrans-360
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算纳什均衡
- en: 'A *Nash equilibrium* is a two-player strategic game – similar to the one we
    saw in the *Analyzing simple two-player games* recipe – that represents a *steady
    state* in which every player sees the *best possible* outcome. However, this doesn’t
    mean that the outcome linked to a Nash equilibrium is the best overall. Nash equilibria
    are more subtle than this. An informal definition of a Nash equilibrium is as
    follows: an action profile in which no individual player can improve their outcome,
    assuming that all other players adhere to the profile.'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '*纳什均衡*是一个两人策略游戏——类似于我们在*分析简单的两人游戏*配方中看到的——它代表了一个*稳定状态*，在这种状态下每个玩家都看到了*最佳可能的*结果。然而，这并不意味着与纳什均衡相关联的结果在总体上是最好的。纳什均衡比这更微妙。一个非正式的纳什均衡定义如下：在这个动作配置中，假设所有其他玩家遵循这个配置，没有一个个体玩家可以改善他们的结果。'
- en: 'We will explore the notion of a Nash equilibrium with the classic game of rock-paper-scissors.
    The rules are as follows. Each player can choose one of the options: rock, paper,
    or scissors. Rock beats scissors, but loses to paper; paper beats rock, but loses
    to scissors; scissors beats paper, but loses to rock. Any game in which both players
    make the same choice is a draw. Numerically, we represent a win by +1, a loss
    by -1, and a draw by 0\. From this, we can construct a two-player game and compute
    Nash equilibria for this game.'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过经典的剪刀石头布游戏探讨纳什均衡的概念。规则如下。每个玩家可以选择以下选项之一：剪刀，石头或布。石头打败剪刀，但输给布；纸打败石头，但输给剪刀；剪刀打败纸，但输给石头。如果两个玩家选择相同的选项，则为平局。数值上，我们用+1表示赢，-1表示输，0表示平局。从中，我们可以构建一个两人游戏并计算该游戏的纳什均衡。
- en: In this recipe, we will compute Nash equilibria for the classic game of rock-paper-scissors.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将计算经典剪刀石头布游戏的纳什均衡。
- en: Getting ready
  id: totrans-364
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this recipe, we will need the NumPy package imported as `np`, and the Nashpy
    package imported as `nash`:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，我们需要导入NumPy包作为`np`，并导入Nashpy包作为`nash`：
- en: '[PRE143]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: Let’s see how to use the `nashpy` package to compute Nash equilibria for a two-player
    strategy game.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用`nashpy`包来计算两人策略游戏的纳什均衡。
- en: How to do it...
  id: totrans-368
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 怎么做...
- en: 'The following steps show you how to compute Nash equilibria for a simple two-player
    game:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的步骤展示了如何计算一个简单两人游戏的纳什均衡：
- en: 'First, we need to create a payoff matrix for each player. We will start with
    the first player:'
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要为每个玩家创建一个收益矩阵。我们从第一个玩家开始：
- en: '[PRE144]'
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'The payoff matrix for the second player is the transpose of `rps_p1`:'
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个玩家的收益矩阵是`rps_p1`的转置：
- en: '[PRE149]'
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'Next, we create the `Game` object to represent the game:'
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建代表游戏的`Game`对象：
- en: '[PRE150]'
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'We compute the Nash equilibria for the game using the support enumeration algorithm:'
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用支持枚举算法计算游戏的纳什均衡：
- en: '[PRE151]'
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'We iterate over the equilibria and print the profile for each player:'
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们遍历均衡，并打印每个玩家的策略：
- en: '[PRE152]'
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '[PRE153]'
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '[PRE154]'
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'The output of these print statements is as follows:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 这些打印语句的输出如下：
- en: '[PRE155]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: How it works...
  id: totrans-388
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Nash equilibria are extremely important in game theory because they allow us
    to analyze the outcomes of strategic games and identify advantageous positions.
    They were first described by John F. Nash in 1950 and have played a pivotal role
    in modern game theory. A two-player game may have many Nash equilibria, but any
    finite two-player game must have at least one. The problem is finding all the
    possible Nash equilibria for a given game.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 纳什均衡在博弈论中极其重要，因为它们使我们能够分析战略博弈的结果，并识别有利的位置。它们最早由约翰·纳什在1950年描述，并在现代博弈论中发挥了关键作用。一个二人博弈可能有多个纳什均衡，但任何有限的二人博弈至少必须有一个纳什均衡。问题在于找到一个给定博弈的所有可能的纳什均衡。
- en: 'In this recipe, we used the support enumeration, which effectively enumerates
    all possible strategies and filters down to those that are Nash equilibria. In
    this recipe, the support enumeration algorithm found just one Nash equilibrium,
    which is a mixed strategy. This means that the only strategy for which there is
    no improvement involves picking one of the choices at random, each with a 1/3
    probability. This is hardly a surprise to anyone who has played rock-paper-scissors,
    since for any choice we make, our opponent has a 1 in 3 chance of choosing (at
    random) the move that beats our choice. Equally, we have a 1 in 3 chance of drawing
    or winning the game, so our expected value over all these possibilities is as
    follows:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个案例中，我们使用了支持集枚举法，它有效地枚举了所有可能的策略，并筛选出纳什均衡策略。在这个案例中，支持集枚举算法仅找到了一个纳什均衡，它是一种混合策略。这意味着唯一没有改进的策略是随机选择其中一个选项，每个选项的概率为1/3。对于玩过石头剪子布的人来说，这并不令人惊讶，因为无论我们做出什么选择，我们的对手都有1/3的概率（随机）选择一个能够击败我们选择的动作。同样，我们也有1/3的机会平局或获胜，因此我们在所有这些可能性下的期望值如下：
- en: '![](img/Formula_09_049.jpg)'
  id: totrans-391
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_09_049.jpg)'
- en: Without knowing exactly which of the choices our opponent will choose, there
    is no way to improve this expected outcome.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 在不知道我们的对手会选择哪个选项的情况下，没有办法改进这个预期结果。
- en: There’s more...
  id: totrans-393
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The Nashpy package also provides other algorithms for computing Nash equilibria.
    Specifically, the `vertex_enumeration` method, when used on a `Game` object, uses
    the *vertex enumeration* algorithm, while the `lemke_howson_enumeration` method
    uses the *Lemke-Howson* algorithm. These alternative algorithms have different
    characteristics and may be more efficient for some problems.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: Nashpy包还提供了其他计算纳什均衡的算法。具体来说，`vertex_enumeration`方法在`Game`对象上使用*顶点枚举*算法，而`lemke_howson_enumeration`方法使用*Lemke-Howson*算法。这些替代算法具有不同的特性，可能在某些问题中更高效。
- en: See also
  id: totrans-395
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: The documentation for the Nashpy package contains more detailed information
    about the algorithms and game theory involved. This includes a number of references
    to texts on game theory. This documentation can be found at [https://nashpy.readthedocs.io/en/latest/](https://nashpy.readthedocs.io/en/latest/).
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: Nashpy包的文档包含关于所涉及算法和博弈论的更详细信息。这其中包括许多关于博弈论的参考文献。该文档可以在[https://nashpy.readthedocs.io/en/latest/](https://nashpy.readthedocs.io/en/latest/)找到。
- en: Further reading
  id: totrans-397
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'As usual, the *Numerical Recipes* book is a good source of numerical algorithms.
    [*Chapter 10*](B19085_10.xhtml#_idTextAnchor395), *Minimization or Maximization
    of Functions*, deals with the maximization and minimization of functions:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，*Numerical Recipes*书是数值算法的一个很好的来源。[*第10章*](B19085_10.xhtml#_idTextAnchor395)，*函数的最小化与最大化*，讨论了函数的最大化和最小化：
- en: 'Press, W.H., Teukolsky, S.A., Vetterling, W.T., and Flannery, B.P., 2017\.
    *Numerical recipes: the art of scientific computing*. 3rd ed. Cambridge: Cambridge
    University Press.'
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Press, W.H., Teukolsky, S.A., Vetterling, W.T., 和 Flannery, B.P., 2017\. *数值计算的艺术：数值算法*。第三版。剑桥：剑桥大学出版社。
- en: 'More specific information on optimization can be found in the following books:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 关于优化的更多具体信息可以在以下书籍中找到：
- en: 'Boyd, S.P. and Vandenberghe, L., 2018\. *Convex optimization*. Cambridge: Cambridge
    University Press.'
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Boyd, S.P. 和 Vandenberghe, L., 2018\. *凸优化*。剑桥：剑桥大学出版社。
- en: 'Griva, I., Nash, S., and Sofer, A., 2009\. *Linear and nonlinear optimization*.
    2nd ed. Philadelphia: Society for Industrial and Applied Mathematics.'
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Griva, I., Nash, S., 和 Sofer, A., 2009\. *线性和非线性优化*。第二版。费城：工业与应用数学学会。
- en: 'Finally, the following book is a good introduction to game theory:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，以下书籍是博弈论的一个很好的入门书籍：
- en: 'Osborne, M.J., 2017\. *An introduction to game theory*. Oxford: Oxford University
    Press.'
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Osborne, M.J., 2017\. *博弈论导论*。牛津：牛津大学出版社。
