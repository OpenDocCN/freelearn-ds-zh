- en: Appendix C. NumPy Arrays
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录 C. `NumPy` 数组
- en: Introduction
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: 'Arrays are the fundamental data structure introduced by `NumPy`, and they are
    the base of all libraries for scientific computing and data analysis we discussed
    in this book. This appendix will give a brief overview of the following array
    features:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是`NumPy`引入的基本数据结构，它们是我们在本书中讨论的所有科学计算和数据分析库的基础。本附录将简要概述以下数组特性：
- en: Array creation and member access
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组创建和成员访问
- en: Indexing and slicing
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 索引和切片
- en: Array creation and member access
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组创建和成员访问
- en: '`NumPy` arrays are objects of the `ndarray` class, which represents a fixed-size
    multidimensional collection of homogeneous data.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '`NumPy`数组是`ndarray`类的对象，该类表示一个固定大小的多维同质数据集合。'
- en: 'Here, we will assume that the `NumPy` library has been imported using the following
    command line:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们假设已经通过以下命令行导入了`NumPy`库：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Once we have done that, we can create `ndarray` (from now on, informally called
    **array object** or simply **array**) from a list of lists as indicated in the
    following command line:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成这些步骤，我们可以从一个列表的列表创建`ndarray`（以后简称为**数组对象**或简单称为**数组**），如以下命令行所示：
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Contrary to Python lists and tuples, all entries of an array object must be
    of the same type. The types themselves are represented by `NumPy` objects and
    are referred to as `dtype` (from data type) of the array. In the preceding example,
    we explicitly specify `dtype` as `float64`, which represents a 64-bit floating-point
    value.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Python 列表和元组不同，数组对象的所有元素必须是相同类型的。这些类型由`NumPy`对象表示，并称为数组的`dtype`（数据类型）。在前面的示例中，我们明确指定`dtype`为`float64`，它表示一个64位浮动小数值。
- en: 'Arrays have several attributes that give information about the data layout.
    The more commonly used ones are as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 数组具有几个属性，用于提供关于数据布局的信息。最常用的属性如下：
- en: 'The shape of the array is computed using the following command:'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组的形状可以通过以下命令计算：
- en: '[PRE2]'
  id: totrans-14
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The preceding command returns the tuple `(3, 4)`, since this is a two-dimensional
    array with three rows and four columns. Somewhat surprisingly, the shape attribute
    is not read-only and we can use it to *reshape* the array:'
  id: totrans-15
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前面的命令返回元组`(3, 4)`，因为这是一个具有三行四列的二维数组。有些人可能会感到惊讶，`shape`属性并非只读，我们可以利用它来*重塑*数组：
- en: '[PRE3]'
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: After running the preceding example, run `a.shape(3,4)` to return to the original
    dimensions.
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行前面的示例后，运行`a.shape(3,4)`可以返回原始维度。
- en: 'The number of dimensions of the array is obtained using the following command:'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组的维度数量可以通过以下命令获取：
- en: '[PRE4]'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This, of course, returns `2`. An important notion in `NumPy` is the idea of
    *axes* of an array. A two dimensional array has two axes, numbered 0 and 1\. If
    we think of the array as representing a mathematical matrix, axis 0 is vertical
    and points down, and axis 1 is horizontal and points to the right. Certain array
    methods have an optional `axis` keyword argument that lets the user specify along
    which axis the operation is performed.
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当然，这将返回`2`。在`NumPy`中，一个重要的概念是数组的*轴*。二维数组有两个轴，编号为 0 和 1。如果我们把数组看作是一个数学矩阵，那么轴
    0 是垂直的，指向下方，轴 1 是水平的，指向右侧。某些数组方法有一个可选的`axis`关键字参数，允许用户指定在哪个轴上执行操作。
- en: 'To get the number of elements in the array, we can use the following command:'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要获取数组中元素的个数，可以使用以下命令：
- en: '[PRE5]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the preceding example, the output returned is `12`, as expected.
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的示例中，返回的输出是`12`，正如预期的那样。
- en: 'One final attribute of arrays is computing the *transpose* of an array. This
    can be done using the following command:'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组的一个最终属性是计算数组的*转置*。这可以通过以下命令完成：
- en: '[PRE6]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: An important thing that this creates is a *view* of the array `a`. The `NumPy`
    package is designed to work efficiently with very large arrays, and in most cases,
    avoids making copies of data unless absolutely necessary, or is explicitly directed
    to do so.
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这创建的一个重要内容是数组`a`的*视图*。`NumPy`包被设计成能高效处理非常大的数组，并且在大多数情况下，除非绝对必要，或明确指示，否则避免复制数据。
- en: 'Run the following lines of code:'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行以下代码行：
- en: '[PRE7]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note that the entry `2, 1` of the array `a` is changed, demonstrating that both
    variables, `a` and `b`, point to the same area in memory.
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请注意，数组`a`的条目`2, 1`已被更改，这表明变量`a`和`b`都指向内存中的同一位置。
- en: 'An array with uninitialized data can be created with the `empty()` function
    as follows:'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以通过`empty()`函数如下创建一个包含未初始化数据的数组：
- en: '[PRE8]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Using uninitialized data is not recommended, so it is perhaps preferable to
    use either the `zeros()` or `ones()` function as follows:'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用未初始化的数据是不推荐的，因此最好使用 `zeros()` 或 `ones()` 函数，如下所示：
- en: 'To use the `zeros()` function, execute the following command lines:'
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要使用 `zeros()` 函数，执行以下命令：
- en: '[PRE9]'
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To use the `ones()` function, execute the following command lines:'
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要使用 `ones()` 函数，执行以下命令：
- en: '[PRE10]'
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'There are also functions that create new arrays with the same shape and data
    type of an existing array:'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 也有一些函数可以创建具有与现有数组相同形状和数据类型的新数组：
- en: The functions `ones_like()` and `empty_like()` produce arrays of ones and uninitialized
    data with the same shape as a given array.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ones_like()` 和 `empty_like()` 函数生成与给定数组相同形状的全 1 数组和未初始化的数据数组。'
- en: '`NumPy` also has the `eye()` function that returns an identity array of the
    given dimension and `dtype`:'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NumPy` 还有一个 `eye()` 函数，可以返回给定维度和 `dtype` 的单位矩阵：'
- en: '[PRE12]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The number of rows and columns do not have to be the same. In this case, the
    resulting matrix will only be a left- or right- identity, as applicable:'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 行和列的数量不必相同。在这种情况下，生成的矩阵将仅是左单位矩阵或右单位矩阵，具体取决于情况：
- en: '[PRE13]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Arrays can also be created from existing data. The `copy()` function clones
    an array as follows:'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组也可以从现有数据创建。`copy()` 函数可以如下面这样克隆数组：
- en: '[PRE14]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `frombuffer()` function creates an array from an object that exposes the
    (one-dimensional) buffer interface. Here is an example:'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`frombuffer()` 函数从暴露（单维）缓冲区接口的对象创建数组。以下是一个示例：'
- en: '[PRE15]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `arange()` function is a `NumPy` extension of the Python range. It has a
    similar syntax, but allows ranges of floating-point values.
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`arange()` 函数是 `NumPy` 对 Python `range` 的扩展。它的语法类似，但允许浮动范围值。'
- en: 'The `loadtxt()` function reads an array from a text file. Suppose the text
    file `matrix.txt` contains the following data:'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`loadtxt()` 函数从文本文件中读取数组。假设文本文件 `matrix.txt` 包含以下数据：'
- en: '[PRE16]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then, we can read the data with the following command:'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，我们可以使用以下命令读取数据：
- en: '[PRE17]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Arrays can also be saved and loaded in the `.npy` format:'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组也可以以 `.npy` 格式保存和加载：
- en: '[PRE18]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Indexing and Slicing
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 索引和切片
- en: 'To illustrate indexing, let''s first create an array with random data using
    the following command:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明索引，我们先使用以下命令创建一个包含随机数据的数组：
- en: '[PRE19]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This creates an array of dimension `(6,5)` that contains random data. Individual
    elements of the array are accessed with the usual index notation, for example,
    `a[2,4]`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这会创建一个形状为 `(6,5)` 的数组，包含随机数据。数组的各个元素可以通过常规的索引表示法来访问，例如，`a[2,4]`。
- en: 'An important technique to manipulate data in `NumPy` is the use of **slices**.
    A slice can be thought of as a subarray of an array. For example, let''s say we
    want to extract a subarray with the middle two rows and first two columns of the
    array `a`. Consider the following command lines:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 操作 `NumPy` 数据的一个重要技巧是使用 **切片**。切片可以被认为是数组的一个子数组。例如，假设我们想要提取数组 `a` 中的中间两行和前两列的子数组。考虑以下命令：
- en: '[PRE20]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, let''s make a very important observation. *A slice is simply a view of
    an array, and no data is actually copied*. This can be seen by running the following
    commands:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们做一个非常重要的观察。*切片仅仅是数组的一种视图，并没有实际复制数据*。可以通过运行以下命令来验证：
- en: '[PRE21]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'So, changes in `b` affect the array `a`! If we really need a copy, we need
    to explicitly say we want one. This can be done using the following command line:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，`b` 的更改会影响数组 `a`！如果我们确实需要一个副本，我们需要明确表示我们想要一个副本。可以使用以下命令行来实现：
- en: '[PRE22]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In the slice notation `i:j`, we can omit either `i` or `j`, in which case the
    slice refers to the beginning or end of the corresponding axis:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在切片表示法 `i:j` 中，我们可以省略 `i` 或 `j`，在这种情况下，切片将表示对应轴的开始或结束：
- en: '[PRE23]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Omitting both `i` and `j` refers to a whole axis:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 省略 `i` 和 `j` 表示整个轴：
- en: '[PRE24]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Finally, we can use the notation `i:j:k` to specify a stride `k` in the slice.
    In the following example, we first create a larger random array to illustrate
    this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以使用 `i:j:k` 的表示法来指定切片中的步幅 `k`。在以下示例中，我们首先创建一个更大的随机数组来说明这一点：
- en: '[PRE25]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Let''s now consider slices of higher dimensional arrays. We will start by creating
    a really large three-dimensional array as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们考虑更高维度数组的切片。我们将通过创建一个非常大的三维数组来开始：
- en: '[PRE26]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Suppose we want to extract all elements with index `1` in the last axis. This
    can be done easily using an ellipsis object as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想提取最后一个轴中索引为 `1` 的所有元素。这可以通过使用省略号对象轻松实现，示例如下：
- en: '[PRE27]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The preceding command line is equivalent to the following one:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令行等同于以下命令：
- en: '[PRE28]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'It is also possible to augment the matrix along an axis when slicing, as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在切片时，也可以沿着某一轴扩展矩阵，如下所示：
- en: '[PRE29]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Compare the output of the preceding command line with the output of the following:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 将前一个命令行的输出与以下输出进行比较：
- en: '[PRE30]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
