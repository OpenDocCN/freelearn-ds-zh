- en: Chapter 3. Filtering and Summarizing Data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章. 过滤和汇总数据
- en: After loading data from either flat files or databases (as we have seen in [Chapter
    1](ch01.html "Chapter 1. Hello, Data!"), *Hello, Data!*), or directly from the
    web via some APIs (as covered in [Chapter 2](ch02.html "Chapter 2. Getting Data
    from the Web"), *Getting Data from the Web*), we often have to aggregate, transform,
    or filter the original dataset before the actual data analysis could take place.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在从平面文件或数据库（如我们在[第1章](ch01.html "第1章. 你好，数据！")中看到的）或通过某些API直接从网络（如[第2章](ch02.html
    "第2章. 从网络获取数据")中所述）加载数据后，我们通常必须在实际数据分析之前对原始数据集进行聚合、转换或过滤。
- en: 'In this chapter, we will focus on how to:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将重点关注如何：
- en: Filter rows and columns in data frames
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在数据框中过滤行和列
- en: Summarize and aggregate data
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 汇总并聚合数据
- en: Improve the performance of such tasks with the `dplyr` and `data.table` packages
    besides the base R methods
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了基础R方法外，使用`dplyr`和`data.table`包提高此类任务的性能
- en: Drop needless data
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除不需要的数据
- en: 'Although not loading the needless data is the optimal solution (see the *Loading
    a subset of text files* and *Loading data from databases* sections in [Chapter
    1](ch01.html "Chapter 1. Hello, Data!"), *Hello, Data!*), we often have to filter
    the original dataset inside R. This can be done with the traditional tools and
    functions from base R, such as `subset`, by using `which` and the `[` or `[[`
    operator (see the following code), or for example with the SQL-like approach of
    the `sqldf` package:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然不加载不需要的数据是最佳解决方案（见[第1章](ch01.html "第1章. 你好，数据！")中的*加载文本文件的子集*和*从数据库加载数据*部分），但我们通常必须在R中过滤原始数据集。这可以通过使用基础R的传统工具和函数，如`subset`，通过使用`which`和`[`或`[[`运算符（见以下代码）来完成，或者例如使用`sqldf`包的类似SQL的方法：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'I am sure that all readers who have a decent SQL background and are just getting
    in touch with R appreciate this alternative way of filtering data, but I personally
    prefer the following rather similar, native, and much more concise R version:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信所有有良好SQL背景并且刚刚接触R的读者都会欣赏这种过滤数据的不同方法，但我个人更喜欢以下类似、原生且更简洁的R版本：
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Please note the slight difference in the results. This is attributed to the
    fact that the `row.names` argument of `sqldf` is `FALSE` by default, which can
    of course be overridden to get the exact same results:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意结果之间的细微差异。这归因于`sqldf`的`row.names`参数默认为`FALSE`，当然，可以通过覆盖它来获得完全相同的结果：
- en: '[PRE2]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: These examples focused on how to drop rows from `data.frame`, but what if we
    also want to remove some columns?
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这些例子侧重于如何从`data.frame`中删除行，但如果我们还想删除一些列怎么办？
- en: 'The SQL approach is really straightforward; just specify the required columns
    instead of `*` in the `SELECT` statement. On the other hand, `subset` also supports
    this approach by the `select` argument, which can take vectors or an R expression
    describing, for example, a range of columns:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: SQL方法非常直接；只需在`SELECT`语句中指定所需的列，而不是使用`*`。另一方面，`subset`通过`select`参数也支持这种方法，它可以接受向量或R表达式，例如，描述一列范围的列：
- en: '[PRE3]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Tip
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Pass the unquoted column names as a vector via the `c` function to select an
    arbitrary list of columns in the given order, or exclude the specified columns
    by using the - operator, for example, `subset(mtcars, select = -c(hp, wt))`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`c`函数将未引用的列名作为向量传递，以按给定顺序选择任意列列表，或者使用-运算符排除指定的列，例如，`subset(mtcars, select
    = -c(hp, wt))`。
- en: Let's take this to the next step, and see how we can apply the forementioned
    filters on some larger datasets, when we face some performance issues with the
    `base` functions.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更进一步，看看我们如何可以在一些较大的数据集上应用前面提到的过滤器，当我们面对`base`函数的性能问题时。
- en: Drop needless data in an efficient way
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高效地删除不需要的数据
- en: R works best with datasets that can fit in the actual physical memory, and some
    R packages provide extremely fast access to this amount of data.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: R最适合可以实际物理内存中容纳的数据集，并且一些R包提供了对这么多数据的极快访问。
- en: Note
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Some benchmarks (see the *References* section at the end of the book) provide
    real-life examples of more efficient summarizing R functions than what the current
    open source (for example, MySQL, PostgreSQL, and Impala) and commercial databases
    (such as HP Vertica) provide.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一些基准测试（见本书末尾的*参考文献*部分）提供了比当前开源（例如MySQL、PostgreSQL和Impala）和商业数据库（如HP Vertica）提供的更有效的汇总R函数的实际例子。
- en: Some of the related packages were already mentioned in [Chapter 1](ch01.html
    "Chapter 1. Hello, Data!"), *Hello, Data!*, where we benchmarked reading a relatively
    large amount of data from the `hflights` package into R.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 一些相关的包已经在[第1章](ch01.html "第1章。你好，数据！")，*你好，数据！*中提到，我们在那里对从`hflights`包中读取相对大量数据到R进行了基准测试。
- en: 'Let''s see how the preceding examples perform on this dataset of a quarter
    of a million rows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看先前的示例在这个有25万行数据的集合上的表现：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `base::subset` function seems to perform pretty well, but can we make it
    any faster? Well, the second generation of the `plyr` package, called `dplyr`
    (the relevant details are discussed *High-performance helper functions* section
    in this chapter and [Chapter 4](ch04.html "Chapter 4. Restructuring Data"), *Restructuring
    Data*), provides extremely fast C++ implementations of the most common database
    manipulation methods in a rather intuitive way:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`base::subset`函数似乎表现得很不错，但我们能否让它更快？嗯，`plyr`包的第二代，称为`dplyr`（相关细节在本章的*高性能辅助函数*部分和[第4章](ch04.html
    "第4章。重构数据")，*重构数据*）以相当直观的方式提供了最常见数据库操作方法的极快C++实现：'
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Further, we can extend this solution by dropping some columns from the dataset
    just like we did with `subset` before, although now, we call the `select` function
    instead of passing an argument with the same name:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以通过删除数据集的一些列来扩展这个解决方案，就像我们之前使用`subset`做的那样，尽管现在我们调用的是`select`函数而不是传递同名参数：
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Therefore, it''s like calling the `filter` function instead of `subset`, and
    we get the results faster than the blink of an eye! The `dplyr` package can work
    with traditional `data.frame` or `data.table` objects, or can interact directly
    with the most widely used database engines. Please note that row names are not
    preserved in `dplyr`, so if you require them, it''s worth copying the names to
    explicit variables before passing them to `dplyr` or directly to `data.table`
    as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这就像调用`filter`函数而不是`subset`，我们得到的速度比眨眼还快！`dplyr`包可以与传统的`data.frame`或`data.table`对象一起工作，或者可以直接与最广泛使用的数据库引擎进行交互。请注意，`dplyr`中不保留行名，所以如果您需要它们，在将它们传递给`dplyr`或直接传递给`data.table`之前，值得将名称复制到显式变量中，如下所示：
- en: '[PRE7]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Drop needless data in another efficient way
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 以另一种高效的方式删除不必要的数据
- en: Let's see a quick example of the `data.table` solution on its own, without `dplyr`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个单独的`data.table`解决方案的快速示例，不使用`dplyr`。
- en: Note
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `data.table` package provides an extremely efficient way to handle larger
    datasets in a column-based, auto-indexed in-memory data structure, with backward
    compatibility for the traditional `data.frame` methods.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`data.table`包提供了一种极高效的方式来处理基于列、自动索引的内存数据结构中的大数据集，同时向后兼容传统的`data.frame`方法。'
- en: 'After loading the package, we have to transform the `hflights` traditional
    `data.frame` to `data.table`. Then, we create a new column, called `rownames`,
    to which we assign the `rownames` of the original dataset with the help of the
    := assignment operator specific to `data.table`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在加载包之后，我们必须将`hflights`传统的`data.frame`转换为`data.table`。然后，我们创建一个新列，称为`rownames`，我们将原始数据集的`rownames`分配给这个新列，这得益于`data.table`特有的:=赋值运算符：
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Well, it takes some time to get used to the custom `data.table` syntax and it
    might even seem a bit strange to the traditional R user at first sight, but it's
    definitely worth mastering in the long run. You get great performance, and the
    syntax turns out to be natural and flexible after the relatively steep learning
    curve of the first few examples.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，适应定制的`data.table`语法需要一些时间，对于传统的R用户来说，一开始可能看起来有点奇怪，但从长远来看，这绝对值得掌握。您将获得出色的性能，并且经过前几个示例相对陡峭的学习曲线后，语法最终会变得自然和灵活。
- en: 'As a matter of fact, the `data.table` syntax is pretty similar to SQL:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`data.table`语法与SQL非常相似：
- en: '[PRE9]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This could be described with SQL commands as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以用以下SQL命令来描述：
- en: '[PRE10]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Therefore, `[.data.table` (which stands for the `[` operator applied to a `data.table`
    object) has some different arguments as compared to the traditional `[.data.frame`
    syntax, as you have already seen in the preceding example.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`[.data.table`（表示将`[`运算符应用于`data.table`对象）与传统的`[.data.frame`语法相比有一些不同的参数，正如您在先前的示例中已经看到的。
- en: Note
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Now, we are not dealing with the assignment operator in detail, as this example
    might be too complex for such an introductory part of the book, and we are probably
    getting out of our comfort zone. Therefore, please find more details in [Chapter
    4](ch04.html "Chapter 4. Restructuring Data"), *Restructuring Data*, or head to
    `?data.table` for a rather technical overview.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们不会详细处理赋值操作符，因为这个例子可能对于本书的这一介绍性部分来说过于复杂，我们可能已经超出了我们的舒适区。因此，请参阅第 4 章（[Chapter
    4](ch04.html "Chapter 4. Restructuring Data")），*重构数据*，或前往 `?data.table` 以获取一个相当技术性的概述。
- en: It seems that the first argument (`i`) of the `[.data.table` operator stands
    for filtering, or in other words, for the `WHERE` statement in SQL parlance, while
    `[.data.frame` expects indices specifying which rows to keep from the original
    dataset. The real difference between the two arguments is that the former can
    take any R expression, while the latter traditional method expects mainly integers
    or logical values.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`[.data.table` 操作符的第一个参数（`i`）似乎代表过滤，或者说在 SQL 术语中，代表 `WHERE` 语句，而 `[.data.frame`
    则期望指定从原始数据集中保留哪些行的索引。这两个参数之间的真正区别在于，前者可以接受任何 R 表达式，而后一种传统方法主要期望整数或逻辑值。'
- en: 'Anyway, filtering is as easy as passing an R expression to the `i` argument
    of the `[` operator specific to `data.table`. Further, let''s see how we can select
    the columns in the `data.table` syntax, which should be done in the second argument
    (`j`) of the call on the basis of the abovementioned general `data.table` syntax:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，过滤操作就像是将 R 表达式传递给 `data.table` 特有的 `[` 操作符的 `i` 参数一样简单。进一步来说，让我们看看如何在 `data.table`
    语法中选取列，这应该在基于上述通用 `data.table` 语法的调用中的第二个参数（`j`）中完成：
- en: '[PRE11]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Okay, so we now have the two expected columns with the 3,481 observations.
    Note that `list` was used to define the required columns to keep, although the
    use of `c` (a function from base R to concatenate vector elements) is more traditionally
    used with `[.data.frame`. The latter is also possible with `[.data.table`, but
    then, you have to pass the variable names as a character vector and set `with`
    to `FALSE`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在我们有了两个预期的列，包含 3,481 个观测值。请注意，这里使用了 `list` 来定义需要保留的列，尽管使用 `c`（来自基础 R 的一个用于连接向量元素的函数）在
    `[.data.frame` 中更为传统。后者在 `[.data.table` 中也是可能的，但那时，你必须传递变量名作为一个字符向量，并将 `with`
    设置为 `FALSE`：
- en: '[PRE12]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Instead of `list`, you can use a dot as the function name in the style of the
    `plyr` package; for example: `hflights_dt[, .(DepTime, ArrTime)]`.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `list` 之外，你还可以使用点作为函数名，模仿 `plyr` 包的风格；例如：`hflights_dt[, .(DepTime, ArrTime)]`。
- en: Now that we are more or less familiar with our options for filtering data inside
    a live R session, and we know the overall syntax of the `dplyr` and `data.table`
    packages, let's see how these can be used to aggregate and summarize data in action.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对在实时 R 会话中过滤数据的选项有了一定的了解，并且我们知道 `dplyr` 和 `data.table` 包的总体语法，让我们看看这些如何在实际中用于聚合和总结数据。
- en: Aggregation
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 聚合
- en: 'The most straightforward way of summarizing data is calling the `aggregate`
    function from the `stats` package, which does exactly what we are looking for:
    splitting the data into subsets by a grouping variable, then computing summary
    statistics for them separately. The most basic way to call the `aggregate` function
    is to pass the numeric vector to be aggregated, and a factor variable to define
    the splits for the function passed in the `FUN` argument to be applied. Now, let''s
    see the average ratio of diverted flights on each weekday:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 总结数据最直接的方法是调用 `stats` 包中的 `aggregate` 函数，它正好符合我们的需求：通过分组变量将数据分割成子集，然后分别计算它们的摘要统计量。调用
    `aggregate` 函数的最基本方法是传递要聚合的数值向量，以及一个因子变量来定义 `FUN` 参数中传递给函数的分割。现在，让我们看看每个工作日的被改道航班平均比率：
- en: '[PRE13]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Well, it took some time to run the preceding script, but please bear in mind
    that we have just aggregated around a quarter of a million rows to see the daily
    averages for the number of diverted flights departing from the Houston airport
    in 2011.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，运行前面的脚本花了一些时间，但请记住，我们只是对大约二十五万行数据进行了聚合，以查看 2011 年从休斯顿机场出发的每日被改道的航班数量的平均值。
- en: In other words, which also makes sense for all those not into statistics, the
    percentage of diverted flights per weekday. The results are rather interesting,
    as it seems that flights are more often diverted in the middle of the week (around
    0.3 percent) than over the weekends (around 0.05 percent less), at least from
    Houston.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，这也适用于所有不热衷于统计学的人，即每周工作日中转航班的百分比。结果相当有趣，因为似乎航班在中周（大约0.3%）比周末（大约少0.05%）更常被转飞，至少从休斯顿来看。
- en: 'An alternative way of calling the preceding function is to supply the arguments
    inside of the `with` function, which seems to be a more human-friendly expression
    after all because it saves us from the repeated mention of the `hflights` database:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 调用上述函数的另一种方法是向`with`函数中提供参数，这最终似乎是一种更符合人类表达习惯的方式，因为它避免了反复提及`hflights`数据库：
- en: '[PRE14]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The results are not shown here, as they are exactly the same as those shown
    earlier. The manual for the `aggregate` function (see `?aggregate`) states that
    it returns the results in a convenient form. Well, checking the column names of
    the abovementioned returned data does not seem convenient, right? We can overcome
    this issue by using the formula notation instead of defining the numeric and factor
    variables separately:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有显示结果，因为它们与之前显示的完全相同。`aggregate`函数的手册（见`?aggregate`）指出，它以方便的形式返回结果。然而，检查上述返回数据的列名似乎并不方便，对吧？我们可以通过使用公式符号而不是单独定义数值和因子变量来克服这个问题：
- en: '[PRE15]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The gain by using the formula notation is at least two-fold:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 使用公式符号的好处至少有两倍：
- en: There are relatively few characters to type
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要输入的字符相对较少
- en: The headers and row names are correct in the results
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结果中的标题和行名是正确的
- en: This version also runs a bit faster than the previous `aggregate` calls; please
    see the all-out benchmark at the end of this section
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个版本也比之前的`aggregate`调用运行得快一些；请参阅本节末尾的全面基准测试。
- en: The only downside of using the formula notation is that you have to learn it,
    which might seem a bit awkward at first, but as formulas are highly used in a
    bunch of R functions and packages, particularly for defining models, it's definitely
    worth learning how to use them in the long run.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 使用公式符号的唯一缺点是你必须学习它，一开始可能会觉得有点尴尬，但鉴于公式在许多R函数和包中高度使用，尤其是在定义模型时，从长远来看，学习如何使用它们绝对是值得的。
- en: Note
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The formula notation is inherited from the S language with the following general
    syntax: `response_variable ~ predictor_variable_1 + … + predictor_variable_n`.
    The notation also includes some other symbols, such as `-` for excluding variables
    and `:` or `*` to include the interaction between the variables with or without
    themselves. See [Chapter 5](ch05.html "Chapter 5. Building Models (authored by
    Renata Nemeth and Gergely Toth)"), *Building Models (authored by Renata Nemeth
    and Gergely Toth)*, and `?formula` in the R console for more details.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 公式符号是从S语言继承而来的，其一般语法如下：`response_variable ~ predictor_variable_1 + … + predictor_variable_n`。该符号还包括一些其他符号，例如`-`用于排除变量，以及`:`或`*`用于包括变量之间的交互，无论是否包括自身。有关更多详细信息，请参阅[第5章](ch05.html
    "第5章。构建模型（由Renata Nemeth和Gergely Toth编写)"), *构建模型（由Renata Nemeth和Gergely Toth编写)*，以及R控制台中的`?formula`。
- en: Quicker aggregation with base R commands
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用基础R命令进行更快的聚合
- en: 'An alternative solution to aggregate data might be to call the `tapply` or
    `by` function, which can apply an R function over a *ragged* array. The latter
    means that we can provide one or more `INDEX` variables, which will be coerced
    to factor, and then, run the provided R function separately on all cells in each
    subset. The following is a quick example:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合数据的另一种解决方案可能是调用`tapply`或`by`函数，这些函数可以将R函数应用于一个*错落有致的*数组。这意味着我们可以提供一个或多个`INDEX`变量，这些变量将被强制转换为因子，然后，在每个子集中的所有单元格上分别运行提供的R函数。以下是一个快速示例：
- en: '[PRE16]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Please note that `tapply` returns an `array` object instead of convenient data
    frames; on the other hand, it runs a lot quicker than the abovementioned aggregate
    calls. Thus, it might be reasonable to use `tapply` for the computations and then,
    convert the results to `data.frame` with the appropriate column names.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`tapply`返回一个`array`对象而不是方便的数据框；另一方面，它比上述聚合调用运行得快得多。因此，对于计算，使用`tapply`然后，将结果转换为具有适当列名的`data.frame`可能是合理的。
- en: Convenient helper functions
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方便的辅助函数
- en: Such conversions can be done easily and in a very user-friendly way by, for
    example, using the `plyr` package, a general version of the `dplyr` package, which
    stands for *plyr specialized f* *or data frames*.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的转换可以通过例如使用 `plyr` 包，这是 `dplyr` 包的通用版本，代表 *plyr 专门用于数据框* 来轻松且用户友好地完成。
- en: 'The `plyr` package provides a variety of functions to apply data from `data.frame`,
    `list`, or `array` objects, and can return the results in any of the mentioned
    formats. The naming scheme of these functions is easy to remember: the first character
    of the function name stands for the class of the input data, and the second character
    represents the output format, all followed by *ply* in all cases. Besides the
    three abovementioned R classes, there are some special options coded by the characters:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`plyr` 包提供了一系列函数，用于从 `data.frame`、`list` 或 `array` 对象中应用数据，并且可以以任何提到的格式返回结果。这些函数的命名方案易于记忆：函数名的第一个字符代表输入数据的类别，第二个字符代表输出格式，所有这些都在
    `ply` 后面。除了上述三个 R 类别之外，还有一些由字符编码的特殊选项：'
- en: '`d` stands for `data.frame`'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`d` 代表 `data.frame`'
- en: '`s` stands for `array`'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s` 代表 `array`'
- en: '`l` stands for `list`'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`l` 代表 `list`'
- en: '`m` is a special input type, which means that we provide multiple arguments
    in a tabular format for the function'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`m` 是一个特殊的输入类型，这意味着我们以表格格式为函数提供多个参数'
- en: '`r` input type expects an integer, which specifies the number of times the
    function will be replicated'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`r` 输入类型期望一个整数，该整数指定函数将被复制的次数'
- en: '`_` is a special output type that does not return anything for the function'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_` 是一个特殊的输出类型，该函数不返回任何内容'
- en: 'Thus, the following most frequently used combinations are available:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，以下最常用的组合是可用的：
- en: '`ddply` takes `data.frame` as input and returns `data.frame`'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ddply` 以 `data.frame` 作为输入并返回 `data.frame`'
- en: '`ldply` takes `list` as input but returns `data.frame`'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ldply` 以 `list` 作为输入但返回 `data.frame`'
- en: '`l_ply` does not return anything, but it''s really useful for example, to iterate
    through a number of elements instead of a `for` loop; as with a set `.progress`
    argument, the function can show the current state of iterations, the remaining
    time'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`l_ply` 不返回任何内容，但它非常有用，例如，用于遍历多个元素而不是 `for` 循环；与 `.progress` 参数集一起，该函数可以显示迭代的当前状态和剩余时间'
- en: 'Please find more details, examples, and use cases of `plyr` in [Chapter 4](ch04.html
    "Chapter 4. Restructuring Data"), *Restructuring Data*. Here, we will only concentrate
    on how to summarize data. To this end, we will use `ddply` (not to be confused
    with the `dplyr` package) in all the following examples: taking `data.frame` as
    the input argument and returning data with the same class.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 请在[第4章](ch04.html "第4章。数据重构")中查找更多关于 `plyr` 的详细信息、示例和使用案例，*数据重构*。在这里，我们将只关注如何总结数据。为此，我们将使用
    `ddply`（不要与 `dplyr` 包混淆）在所有后续示例中：以 `data.frame` 作为输入参数，并返回具有相同类别的数据。
- en: 'So, let''s load the package and apply the `mean` function on the `Diverted`
    column over each subset by `DayOfWeek`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们加载这个包，并通过对每个 `DayOfWeek` 子集的 `Diverted` 列应用 `mean` 函数来使用 `ddply`：
- en: '[PRE17]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `.` function of the `plyr` package provides us with a convenient way of
    referring to a variable (name) as is; otherwise, the content of the `DayOfWeek`
    columns would be interpreted by `ddply`, resulting in an error.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`plyr` 包中的 `.` 函数为我们提供了一种方便的方式来直接引用变量（名称）；否则，`DayOfWeek` 列的内容将被 `ddply` 解释，从而导致错误。'
- en: 'An important thing to note here is that `ddply` is much quicker than our first
    attempt with the `aggregate` function. On the other hand, I am not yet pleased
    with the results, `V1` and such creative column names have always freaked me out.
    Instead of updating the names of the `data.frame` post processing let''s call
    the `summarise` helper function instead of the previously applied anonymous one;
    here, we can also provide the desired name for our newly computed column:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的一个重要事项是，`ddply` 比我们第一次使用 `aggregate` 函数时的尝试要快得多。另一方面，我对结果还不满意，`V1` 和其他如此有创意的列名总是让我感到不安。与其在后处理中更新
    `data.frame` 的名称，不如调用 `summarise` 辅助函数而不是之前应用的匿名函数；在这里，我们也可以为我们的新计算列提供所需的名称：
- en: '[PRE18]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Okay, much better. But, can we do even better?
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 好多了。但是，我们能否做得更好？
- en: High-performance helper functions
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高性能辅助函数
- en: Hadley Wickham, the author of `ggplot`, `reshape`, and several other R packages,
    started working on the second generation, or rather a specialized version, of
    `plyr` in 2008\. The basic concept was that `plyr` is most frequently used to
    transform one `data.frame` to another `data.frame`; therefore, its operation requires
    extra attention. The `dplyr` package, `plyr` specialized for data frames, provides
    a faster implementation of the `plyr` functions, written in raw C++, and `dplyr`
    can also deal with remote databases.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`ggplot`、`reshape`和几个其他R包的作者Hadley Wickham，从2008年开始着手开发`plyr`的第二代，或者说是一个专门的版本。基本概念是`plyr`最常用于将一个`data.frame`转换成另一个`data.frame`；因此，它的操作需要额外的注意。`dplyr`包，专门针对数据框的`plyr`，提供了一个更快的`plyr`函数实现，使用原始C++编写，并且`dplyr`还可以处理远程数据库。'
- en: However, the performance improvements also go hand-in-hand with some other changes;
    for example, the syntax of `dplyr` has changed a lot as compared to `plyr`. Although
    the previously mentioned `summarise` function does exist in `dplyr`, we do not
    have the `ddplyr` function any more, as all functions in the package are dedicated
    to act as some component of `plyr::ddplyr`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，性能提升也伴随着一些其他的变化；例如，与`plyr`相比，`dplyr`的语法发生了很大变化。尽管之前提到的`summarise`函数在`dplyr`中仍然存在，但我们不再有`ddplyr`函数，因为该包中的所有函数都致力于作为`plyr::ddplyr`的一些组件。
- en: 'Anyway, to keep the theoretical background short, if we want to summarize the
    subgroups of a dataset, we have to define the groups before aggregation:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，为了使理论背景简短，如果我们想总结数据集的子组，我们必须在聚合之前定义这些组：
- en: '[PRE19]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The resulting object is the very same `data.frame` that we had previously with
    one exception: a bunch of metadata was merged to the object by the means of attributes.
    To keep the following output short, we do not list the whole structure (`str`)
    of the object, but only the attributes are shown:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 结果对象与我们之前拥有的`data.frame`完全相同，只有一个例外：通过属性的方式将一些元数据合并到了对象中。为了使接下来的输出更简洁，我们没有列出对象的整个结构（`str`），只显示了属性：
- en: '[PRE20]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'From this metadata, the `indices` attribute is important. It simply lists the
    IDs of each row for one of the weekdays, so later operations can easily select
    the subgroups from the whole dataset. So, let''s see how the proportion of diverted
    flights looks like with some performance boost due to using `summarise` from `dplyr`
    instead of `plyr`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些元数据中，`indices`属性很重要。它简单地列出了一个工作日中每行的ID，因此后续操作可以轻松地从整个数据集中选择子组。那么，让我们看看使用`dplyr`的`summarise`而不是`plyr`带来的性能提升，看看被转移的航班比例是什么样的：
- en: '[PRE21]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The results are pretty familiar, which is good. However, while running this
    example, did you measure the execution time? This was close to an instant, which
    makes `dplyr` even better.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 结果相当熟悉，这很好。然而，在运行这个示例时，你是否测量了执行时间？这几乎是瞬间的，这使得`dplyr`更加出色。
- en: Aggregate with data.table
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`data.table`进行聚合
- en: 'Do you remember the second argument of `[.data.table`? It''s called `j`, which
    stands for a `SELECT` or an `UPDATE` SQL statement, and the most important feature
    is that it can be any R expression. Thus, we can simply pass a function there
    and set groups with the help of the `by` argument:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你还记得`[.data.table`的第二个参数吗？它被称为`j`，代表一个`SELECT`或`UPDATE` SQL语句，最重要的特性是它可以是一个任意的R表达式。因此，我们只需在那里传递一个函数，并通过`by`参数设置组：
- en: '[PRE22]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'I am pretty sure that you are not in the least surprised by how fast the results
    were returned by `data.table`, as people can get used to great tools very quickly.
    Further, it was very concise as compared to the previous two-line `dplyr` call,
    right? The only downside of this solution is that the weekdays are ordered by
    some hardly intelligible rank. Please see [Chapter 4](ch04.html "Chapter 4. Restructuring
    Data"), *Restructuring Data*, for more details on this; for now, let''s fix the
    issue quickly by setting a key, which means that we order `data.table` first by
    `DayOfWeek`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我很确定你对`data.table`返回结果的速度不会感到丝毫惊讶，因为人们可以非常快地习惯于优秀的工具。此外，与之前的两行`dplyr`调用相比，它非常简洁，对吧？这个解决方案的唯一缺点是，工作日是按照一些几乎无法理解的排名顺序排列的。请参阅[第4章](ch04.html
    "第4章。重构数据")，*重构数据*，了解更多关于此问题的细节；现在，让我们通过设置一个键来快速解决这个问题，这意味着我们首先按`DayOfWeek`对`data.table`进行排序：
- en: '[PRE23]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To specify a name for the second column in the resulting tabular object instead
    of `V1`, you can specify the `summary` object as a named list, for example, as
    `hflights_dt[, list('mean(Diverted)' = mean(Diverted)), by = DayOfWeek]`, where
    you can use `.` (dot) instead of `list`, just like in `ply` `r`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要为结果表格的第二列指定一个名称而不是`V1`，你可以将`summary`对象指定为一个命名列表，例如，`hflights_dt[, list('mean(Diverted)'
    = mean(Diverted)), by = DayOfWeek]`，其中你可以使用`.`（点）而不是`list`，就像在`ply` `r`中一样。
- en: Besides getting the results in the expected order, summarizing data by an already
    existing key also runs relatively fast. Let's verify this with some empirical
    evidence on your machine!
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 除了以预期的顺序获得结果外，通过已存在的键对数据进行汇总也相对较快。让我们用一些在你的机器上的经验证据来验证这一点！
- en: Running benchmarks
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行基准测试
- en: As already discussed in the previous chapters, with the help of the `microbenchmark`
    package, we can run any number of different functions for a specified number of
    times on the same machine to get some reproducible results on the performance.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如前几章所述，借助`microbenchmark`包，我们可以在同一台机器上对指定次数的不同函数进行多次运行，以获得一些可重复的性能结果。
- en: 'To this end, we have to define the functions that we want to benchmark first.
    These were compiled from the preceding examples:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为了达到这个目的，我们首先需要定义我们想要基准测试的函数。这些是从前面的例子中编译出来的：
- en: '[PRE24]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'However, as mentioned before, the `summarise` function in `dplyr` needs some
    prior data restructuring, which also takes time. To this end, let''s define another
    function that also includes the creation of the new data structure along with
    the real aggregation:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如前所述，`dplyr`中的`summarise`函数需要一些先前的数据重构，这也需要时间。为此，让我们定义另一个函数，它包括创建新的数据结构以及实际的聚合：
- en: '[PRE25]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Similarly, benchmarking `data.table` also requires some additional variables
    for the test environment; as `hlfights_dt` is already sorted by `DayOfWeek`, let''s
    create a new `data.table` object for benchmarking:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，对`data.table`进行基准测试也需要测试环境中的一些额外变量；由于`hlfights_dt`已经按`DayOfWeek`排序，让我们创建一个新的`data.table`对象进行基准测试：
- en: '[PRE26]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Further, it probably makes sense to verify that it has no keys:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，验证它没有键可能是有意义的：
- en: '[PRE27]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Okay, now, we can define the `data.table` test cases along with a function
    that also includes the transformation to `data.table`, and adding an index just
    to be fair with `dplyr`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在，我们可以定义`data.table`测试用例，以及一个包括转换到`data.table`的函数，并且为了公平起见，也为`dplyr`添加索引：
- en: '[PRE28]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now that we have all the described implementations ready for testing, let''s
    load the `microbenchmark` package to do its job:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好所有描述的实现以供测试，让我们加载`microbenchmark`包来完成其工作：
- en: '[PRE29]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The results are pretty spectacular: from more than 2,000 milliseconds, we could
    improve our tools to provide the very same results in only a bit more than 1 millisecond.
    The spread can be demonstrated easily on a violin plot with a logarithmic scale:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 结果相当引人注目：从超过2,000毫秒，我们能够将我们的工具改进到只需略多于1毫秒就能提供完全相同的结果。这种差异可以通过对数刻度的小提琴图轻松展示：
- en: '[PRE30]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '![Running benchmarks](img/2028OS_03_01.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![运行基准测试](img/2028OS_03_01.jpg)'
- en: Therefore, `dplyr` seems to be the most efficient solution, although if we also
    take the extra step (to group `data.frame`) into account, it makes the otherwise
    clear advantage rather unconvincing. As a matter of fact, if we already have a
    `data.table` object, and we can save the transformation of a traditional `data.frame`
    object into `data.table`, then `data.table` performs better than `dplyr`. However,
    I am pretty sure that you will not really notice the time difference between the
    two high-performance solutions; both of these do a very good job with even larger
    datasets.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`dplyr`似乎是最有效的解决方案，尽管如果我们还考虑额外的步骤（将`data.frame`分组），那么它原本的明显优势就变得不那么有说服力了。事实上，如果我们已经有一个`data.table`对象，并且我们可以将传统的`data.frame`对象转换为`data.table`，那么`data.table`的性能将优于`dplyr`。然而，我相当确信你不会真正注意到这两种高性能解决方案之间的时间差异；这两个都能很好地处理更大的数据集。
- en: 'It''s worth mentioning that `dplyr` can work with `data.table` objects as well;
    therefore, to ensure that you are not locked to either package, it''s definitely
    worth using both if needed. The following is a POC example:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，`dplyr`也可以与`data.table`对象一起工作；因此，为了确保你不会局限于任何一个包，如果需要的话，使用两个包绝对是有价值的。以下是一个POC示例：
- en: '[PRE31]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Okay, so now we are pretty sure to use either `data.table` or `dplyr` for computing
    group averages in the future. However, what about more complex operations?
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，所以现在我们相当确信在将来计算分组平均值时将使用`data.table`或`dplyr`。然而，对于更复杂的操作呢？
- en: Summary functions
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 汇总函数
- en: As we have discussed earlier, all aggregating functions can take any valid R
    functions to apply on the subsets of the data. Some of the R packages make it
    extremely easy for the users, while a few functions do require you to fully understand
    the package concept, custom syntax, and options to get the most out of the high-performance
    opportunities.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所讨论的，所有聚合函数都可以接受任何有效的R函数来应用于数据的子集。一些R包使得用户使用起来极其简单，而一些函数则要求你完全理解包的概念、自定义语法和选项，以便充分利用高性能的机会。
- en: For such more advanced topics, please see [Chapter 4](ch04.html "Chapter 4. Restructuring
    Data"), *Restructuring Data*, and the further readings listed in the *References*
    section at the end of the book.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些更高级的主题，请参阅第4章[重构数据](ch04.html "Chapter 4. Restructuring Data")，*重构数据*，以及书中末尾*参考文献*部分列出的进一步阅读材料。
- en: 'Now, we will concentrate on a very simple `summary` function, which is extremely
    common in any general data analysis project: counting the number of cases per
    group. This quick example will also highlight some of the differences among the
    referenced alternatives mentioned in this chapter.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将集中讨论一个非常简单的`summary`函数，这在任何一般数据分析项目中都非常常见：按组计数案例数量。这个快速示例也将突出本章中提到的参考替代方案之间的某些差异。
- en: Adding up the number of cases in subgroups
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在子组中累加案例数量
- en: 'Let''s focus on `plyr`, `dplyr` and `data.table` now, as I am pretty sure that
    you can construct the `aggregate` and `tapply` versions without any serious issues.
    On the basis of the previous examples, the current task seems fairly easy: instead
    of the `mean` function, we can simply call the `length` function to return the
    number of elements in the `Diverted` column:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们关注`plyr`、`dplyr`和`data.table`，因为我非常确信你可以构建`aggregate`和`tapply`版本而不会遇到任何严重问题。基于之前的示例，当前任务似乎相当简单：我们可以简单地调用`length`函数来返回`Diverted`列中的元素数量，而不是使用`mean`函数：
- en: '[PRE32]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, we also know that a relatively low number of flights leave Houston on
    Saturday. However, do we really have to type so much to answer such a simple question?
    Further, do we really have to name a variable in which we can count the number
    of cases? You already know the answer:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们也知道周六从休斯顿起飞的航班相对较少。然而，我们真的需要输入这么多来回答这样一个简单的问题吗？进一步说，我们真的需要命名一个变量来计算案例数量吗？你已经知道答案：
- en: '[PRE33]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In short, there is no need to choose a variable from `data.frame` to determine
    its length, as it's a lot easier (and faster) to simply check the number of rows
    in the (sub)datasets.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，没有必要从`data.frame`中选择一个变量来确定其长度，因为简单地检查（子）数据集中的行数要容易得多（并且更快）。
- en: 'However, we can also return the very same results in a much easier and quicker
    way. Probably, you have already thought of using the good old `table` function
    for such a straightforward task:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们也可以以更简单、更快捷的方式得到相同的结果。可能你已经想到了使用古老的`table`函数来完成这样的直接任务：
- en: '[PRE34]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The only problem with the resulting object is that we have to transform it
    further, for example, to `data.frame` in most cases. Well, `plyr` already has
    a helper function to do this in one step, with a very intuitive name:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结果对象唯一的问题是，我们还需要进一步转换它，例如，在大多数情况下转换为`data.frame`。嗯，`plyr`已经有一个辅助函数可以在一步中完成这个操作，名字非常直观：
- en: '[PRE35]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Therefore, we end up with some rather simple examples for counting data, but
    let us also see how to implement summary tables with `dplyr`. If you simply try
    to modify our previous `dplyr` commands, you will soon realize that passing the
    `length` or `nrow` function, as we did in `plyr`, simply does not work. However,
    reading the manuals or some related questions on StackOverflow soon points our
    attention to a handy helper function called `n`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们得到了一些相当简单的计数数据示例，但让我们也看看如何使用`dplyr`实现汇总表。如果你简单地尝试修改我们之前的`dplyr`命令，你很快就会意识到，像在`plyr`中那样传递`length`或`nrow`函数，根本不起作用。然而，阅读手册或StackOverflow上的一些相关问题很快就会将我们的注意力引到一个方便的辅助函数`n`：
- en: '[PRE36]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'However, to be honest, do we really need this relatively complex approach?
    If you remember the structure of `hflights_DayOfWeek`, you will soon realize that
    there is a lot easier and quicker way to find out the overall number of flights
    on each weekday:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，坦白说，我们真的需要这种相对复杂的方法吗？如果你记得`hflights_DayOfWeek`的结构，你很快就会意识到，有一种更容易、更快的方法可以找出每个工作日的总航班数：
- en: '[PRE37]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Further, just to make sure that we do not forget the custom (yet pretty) syntax
    of `data.table`, let us compute the results with another helper function:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，为了确保我们不会忘记`data.table`的自定义（但相当漂亮）语法，让我们使用另一个辅助函数来计算结果：
- en: '[PRE38]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Summary
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we introduced some effective and convenient ways of filtering
    and summarizing data. We discussed some use cases on filtering the rows and columns
    of datasets. We also learned how to summarize data for further analysis. After
    getting familiar with the most popular implementations of such tasks, we compared
    them with reproducible examples and a benchmarking package.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了一些有效且便捷的数据过滤和汇总方法。我们讨论了一些关于过滤数据集行和列的用例。我们还学习了如何汇总数据以进行进一步分析。在熟悉了此类任务最流行的实现方式后，我们通过可重复的示例和基准测试包对它们进行了比较。
- en: In the next chapter, we will continue this journey of restructuring datasets
    and creating new variables.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续这段重构数据集和创建新变量的旅程。
