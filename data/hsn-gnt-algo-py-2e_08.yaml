- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Optimizing Continuous Functions
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化连续函数
- en: This chapter describes how **continuous search-space** optimization problems
    can be solved by genetic algorithms. We will start by describing the chromosomes
    and genetic operators commonly used for genetic algorithms with real number-based
    populations and go over the tools offered by the **Distributed Evolutionary Algorithms
    in Python** (**DEAP**) framework for this domain. We will then cover several hands-on
    examples of continuous function optimization problems and their Python-based solutions
    using the DEAP framework. These include the optimization of the *Eggholder function*,
    *Himmelblau’s function*, as well as the constrained optimization of *Simionescu’s
    function*. Along the way, we will learn about finding multiple solutions using
    **niching** and **sharing** and handling **constraints**.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章描述了如何通过遗传算法解决**连续搜索空间**优化问题。我们将首先描述常用于基于实数种群的遗传算法的染色体和遗传操作符，并介绍**Python中的分布式进化算法**（**DEAP**）框架在该领域提供的工具。接下来，我们将通过几个实际案例，讲解连续函数优化问题及其基于Python的解决方案，这些案例包括*Eggholder函数*的优化、*Himmelblau函数*的优化以及*Simionescu函数*的约束优化。在此过程中，我们将学习如何利用**细分**和**共享**来寻找多个解，并处理**约束条件**。
- en: 'By the end of this chapter, you will be able to do the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章结束时，您将能够执行以下操作：
- en: Understand chromosomes and genetic operators used for real numbers
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解用于实数的染色体和遗传操作符
- en: Use DEAP to optimize continuous functions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用DEAP优化连续函数
- en: Optimize the Eggholder function
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化Eggholder函数
- en: Optimize Himmelblau’s function
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化Himmelblau函数
- en: Perform constrained optimization with Simionescu’s function
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Simionescu函数进行约束优化
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In this chapter, we will be using Python 3 with the following supporting libraries:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用Python 3并配合以下支持库：
- en: '**deap**'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**deap**'
- en: '**numpy**'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**numpy**'
- en: '**matplotlib**'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**matplotlib**'
- en: '**seaborn**'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**seaborn**'
- en: Important note
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: If you use the **requirements.txt** file we provide (see [*Chapter 3*](B20851_03.xhtml#_idTextAnchor091)),
    these libraries are already included in your environment.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用我们提供的**requirements.txt**文件（请参见[*第3章*](B20851_03.xhtml#_idTextAnchor091)），这些库已包含在您的环境中。
- en: 'The programs used in this chapter can be found in the book’s GitHub repository
    at the following link:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的程序可以在本书的GitHub仓库中找到，链接如下：
- en: '[https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/tree/main/chapter_06](https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/tree/main/chapter_06)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/tree/main/chapter_06](https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/tree/main/chapter_06)'
- en: 'Check out the following video to see the code in action:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频，看看代码的实际效果：
- en: '[https://packt.link/OEBOd](https://packt.link/OEBOd)'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/OEBOd](https://packt.link/OEBOd)'
- en: Chromosomes and genetic operators for real numbers
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用于实数的染色体和遗传操作符
- en: In previous chapters, we focused on search problems that inherently deal with
    the methodic evaluation of states and transitions between states. Consequently,
    the solutions for these problems were best represented by lists (or arrays) of
    binary or integer parameters. In contrast to that, this chapter covers problems
    where the solution space is **continuous**, meaning the solutions are made up
    of real (floating-point) numbers. As we mentioned in [*Chapter 2*](B20851_02.xhtml#_idTextAnchor053),
    *Understanding the Key Components of Genetic Algorithms*, representing real numbers
    using binary or integer lists was found to be far from ideal and, instead, lists
    (or arrays) of real-valued numbers are now considered to be a simpler and better
    approach.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，我们关注的是本质上处理状态评估和状态间转换的搜索问题。因此，这些问题的解决方案最好用二进制或整数参数的列表（或数组）表示。与此不同，本章讨论的是解空间为**连续**的问题，即解由实数（浮动点数）构成。如我们在[*第2章*](B20851_02.xhtml#_idTextAnchor053)中提到的，*理解遗传算法的关键组成部分*，发现用二进制或整数列表表示实数远非理想，反而使用实值数的列表（或数组）被认为是一种更简单、更好的方法。
- en: 'Reiterating the example from [*Chapter 2*](B20851_02.xhtml#_idTextAnchor053),
    if we have a problem involving three real-valued parameters, the chromosome will
    look like the following:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 重述[*第2章*](B20851_02.xhtml#_idTextAnchor053)中的示例，如果我们有一个涉及三个实值参数的问题，那么染色体将如下所示：
- en: '[x 1, x 2, x 3]'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '[x 1, x 2, x 3]'
- en: 'Here, x 1, x 2, x 3 represent real numbers, such as the following:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，x 1、x 2、x 3表示实数，例如以下值：
- en: '[1.23, 7.2134, -25.309] or [-30.10, 100.2, 42.424]'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '[1.23, 7.2134, -25.309] 或者 [-30.10, 100.2, 42.424]'
- en: In addition, we mentioned that while the various *selection* methods work the
    same for either integer-based or real-based chromosomes, specialized *crossover*
    and *mutation* methods are needed for the real-coded chromosomes. These operators
    are usually applied on a dimension-by-dimension basis, illustrated as follows.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们提到过，虽然各种*选择*方法对于整数型和实值型染色体的工作方式相同，但实值编码的染色体需要专门的*交叉*和*变异*方法。这些算子通常是逐维应用的，示例如下。
- en: 'Suppose we have two parent chromosomes: paren t x = [x 1, x 2, x 3] and paren
    t y = [y 1, y 2, y 3]. As the crossover operation is applied separately to each
    dimension, an offspring [o 1, o 2, o 3] will be created, as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有两个父代染色体：父x = [x 1, x 2, x 3] 和父y = [y 1, y 2, y 3]。由于交叉操作是分别应用于每个维度，因此将创建一个后代
    [o 1, o 2, o 3]，如下所示：
- en: o 1 is the result of a crossover operator between x 1 and y 1
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: o 1 是x 1和y 1之间交叉算子的结果。
- en: o 2 is the result of a crossover operator between x 2 and y 2
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: o 2 是x 2和y 2之间交叉算子的结果。
- en: o 3 is the result of a crossover operator between x 3 and y 3
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: o 3 是x 3和y 3之间交叉算子的结果。
- en: Similarly, the *mutation* operator will be individually applied to each dimension
    so that each of the components o 1, o 2, and o 3 can be subject to mutation.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，*变异*算子将分别应用于每个维度，使得每个组件o 1、o 2和o 3都可以进行变异。
- en: 'Some commonly used real-coded operators are the following:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 一些常用的实值算子如下：
- en: '**Blend Crossover** (also known as **BLX**), where each offspring is randomly
    selected from the following interval created by its parents:'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**混合交叉**（也称为**BLX**），其中每个后代是从父母之间创建的以下区间中随机选择的：'
- en: '[paren t x − α(paren t y − paren t x), paren t y + α(paren t y − paren t x)]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[父x − α（父y − 父x），父y + α（父y − 父x）]'
- en: The α value is commonly set to 0.5, resulting in a selection interval twice
    as wide as the interval between the parents.
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: α值通常设置为0.5，导致选择区间的宽度是父母区间的两倍。
- en: '**Simulated Binary Crossover** (**SBX**), where two offspring are created from
    two parents using the following formula, guaranteeing that the average of the
    offspring values is equal to that of the parents’ values:'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模拟二进制交叉**（**SBX**），其中使用以下公式从两个父代生成两个后代，确保后代值的平均值等于父代值的平均值：'
- en: offsprin g 1 =  1 _ 2 [(1 + β)paren t x + (1 − β)paren t y]
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 后代 1 =  1 _ 2 [(1 + β）父x + (1 − β）父y]
- en: offsprin g 2 =  1 _ 2 [(1 − β)paren t x + (1 + β)paren t y]
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 后代 2 =  1 _ 2 [(1 − β）父x + (1 + β）父y]
- en: The value of β, also known as the *spread factor*, is calculated using a combination
    of a randomly chosen value and a pre-determined parameter known as η (eta), *distribution
    index*, or *crowding factor*. With larger values of η, offspring will tend to
    be more similar to their parents. Common values of η are between 10 and 20.
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: β的值，也称为*扩展因子*，是通过随机选择的一个值和预定的参数η（eta）、*分布指数*或*拥挤因子*的组合计算得到的。随着η值的增大，后代将更倾向于与父母相似。常见的η值在10到20之间。
- en: '**Normally distributed** (or **Gaussian**) **mutation**, where the original
    value is replaced with a random number that is generated using a normal distribution,
    with predetermined values for mean and standard deviation.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**正态分布**（或**高斯**）**变异**，其中原始值被替换为使用正态分布生成的随机数，并且有预定的均值和标准差。'
- en: In the next section, we will see how real-coded chromosomes and genetic operators
    are supported by the DEAP framework.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看到DEAP框架如何支持实值编码的染色体和遗传算子。
- en: Using DEAP with continuous functions
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用DEAP优化连续函数
- en: The DEAP framework can be used for optimizing continuous functions in a very
    similar manner to what we have seen so far, when we solved discrete search problems.
    All that’s needed are a few subtle modifications.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: DEAP框架可以用来优化连续函数，方式与我们之前解决离散搜索问题时非常相似。所需的只是一些细微的修改。
- en: For the chromosome encoding, we can use a list (or array) of floating-point
    numbers. One thing to keep in mind, though, is that the existing genetic operators
    of DEAP will `numpy.ndarray` class due to the way these objects are being sliced,
    as well as the way they are being compared to each other.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 对于染色体编码，我们可以使用一个浮动点数的列表（或数组）。需要注意的一点是，DEAP现有的遗传算子将使用`numpy.ndarray`类，因为这些对象是通过切片的方式操作的，以及它们之间的比较方式。
- en: Using `numpy.ndarray`-based individuals will require redefining the genetic
    operators accordingly. This is further covered in the DEAP documentation, under
    *Inheriting from NumPy*. For this reason, as well as for performance reasons,
    **ordinary** Python lists or arrays of floating-point numbers are generally **preferred**
    when using DEAP.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `numpy.ndarray` 类型的个体将需要相应地重新定义遗传操作符。关于这方面的内容，可以参考 DEAP 文档中的 *从 NumPy 继承*
    部分。出于这个原因，以及性能方面的考虑，通常建议在使用 DEAP 时使用 **普通** 的 Python 列表或浮点数数组。
- en: 'As for real-coded genetic operators, the DEAP framework offers several implementations
    out of the box, contained in the crossover and the mutation modules:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 至于实数编码的遗传操作符，DEAP 框架提供了多个现成的实现，包含在交叉和变异模块中：
- en: '**cxBlend()** is DEAP’s implementation of *Blend Crossover*, using the **alpha**
    argument as the α value'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**cxBlend()** 是 DEAP 的 *混合交叉* 实现，使用 **alpha** 参数作为 α 值。'
- en: '**cxSimulatedBinary()** implements *Simulated Binary Crossover*, using the
    **eta** argument as the η (crowding factor) value'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**cxSimulatedBinary()** 实现了 *模拟二进制交叉*，使用 **eta** 参数作为 η（拥挤因子）值。'
- en: '**mutGaussian()** implements *normally distributed mutation*, using the **mu**
    and **sigma** arguments as the values for the mean and standard deviation, respectively'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**mutGaussian()** 实现了 *正态分布变异*，使用 **mu** 和 **sigma** 参数分别作为均值和标准差的值。'
- en: 'In addition, since the optimization of continuous functions is typically done
    on a particular **bounded region** rather than on the entire space, DEAP provides
    a couple of operators that accept boundary parameters and guarantee that the resulting
    individuals will reside within these boundaries:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于连续函数的优化通常在特定的 **有界区域** 内进行，而不是在整个空间中，DEAP 提供了几个接受边界参数的操作符，确保生成的个体位于这些边界内：
- en: '**cxSimulatedBinaryBounded()** is a bounded version of the **cxSimulatedBinary()**
    operator, accepting the **low** and **up** arguments as the lower and upper boundaries
    of the search space, respectively.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**cxSimulatedBinaryBounded()** 是 **cxSimulatedBinary()** 操作符的有界版本，接受 **low**
    和 **up** 参数，分别作为搜索空间的下界和上界。'
- en: '**mutPolynomialBounded()** is a bounded *mutation* operator that uses a polynomial
    function (instead of Gaussian) for the probability distribution. This operator
    also accepts the **low** and **up** arguments as the lower and upper boundaries
    of the search space. In addition, it uses the **eta** parameter as a crowding
    factor, where a high value will yield a mutant close to its original value, while
    a small value will produce a mutant very different from its original value.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**mutPolynomialBounded()** 是一个有界的 *变异* 操作符，它使用多项式函数（而不是高斯函数）作为概率分布。该操作符还接受
    **low** 和 **up** 参数，分别作为搜索空间的下界和上界。此外，它使用 **eta** 参数作为拥挤因子，较高的值会使变异体接近原始值，而较小的值则会生成与原始值差异较大的变异体。'
- en: In the next section, we will demonstrate the usage of bounded operators when
    optimizing a classic benchmark function.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将演示在优化经典基准函数时使用有界操作符的方法。
- en: Optimizing the Eggholder function
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化 Eggholder 函数
- en: 'The Eggholder function, depicted in the following diagram, is often used as
    a benchmark for function optimization algorithms. Finding the single **global
    minimum** of this function is considered a difficult task due to the large number
    of local minima, which give it the eggholder shape:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Eggholder 函数，如下图所示，常被用作函数优化算法的基准。由于具有大量局部最小值，这使得找到该函数的单一 **全局最小值** 成为一项艰巨的任务，正因如此，它呈现出蛋托形状：
- en: '![Figure 6.1: The Eggholder function ](img/B20851_06_01.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.1：Eggholder 函数](img/B20851_06_01.jpg)'
- en: 'Figure 6.1: The Eggholder function'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1：Eggholder 函数
- en: 'Source: [https://en.wikipedia.org/wiki/File:Eggholder_function.pdf](https://en.wikipedia.org/wiki/File:Eggholder_function.pdf)'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 来源：[https://en.wikipedia.org/wiki/File:Eggholder_function.pdf](https://en.wikipedia.org/wiki/File:Eggholder_function.pdf)
- en: 'The function can be mathematically expressed as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数的数学表达式如下：
- en: f(x, y) = − (y + 47) ⋅ sin √ ___________ | x _ 2  + (y + 47)|  − x ⋅ sin √ ___________ |x
    − (y + 47)|
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: f(x, y) = − (y + 47) ⋅ sin √ ___________ | x _ 2  + (y + 47)|  − x ⋅ sin √ ___________ |x
    − (y + 47)|
- en: It is usually evaluated on the search space bounded by [-512, 512] in each dimension.
    The global minimum of the function is known to be at *x=512, y = 404.2319*, where
    the function’s value is *-959.6407*.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 它通常在每个维度的搜索空间范围 [-512, 512] 上进行评估。已知该函数的全局最小值位于 *x=512, y = 404.2319*，此时函数值为
    *-959.6407*。
- en: In the next subsection, we will attempt to find the global minimum using the
    genetic algorithms method.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的小节中，我们将尝试使用遗传算法方法找到全局最小值。
- en: Optimizing the Eggholder function with genetic algorithms
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用遗传算法优化Eggholder函数
- en: 'The genetic algorithm-based program we created for optimizing the Eggholder
    function resides in the `01_optimize_eggholder.py` Python program located at the
    following link:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为优化Eggholder函数创建的基于遗传算法的程序位于以下链接的`01_optimize_eggholder.py` Python程序中：
- en: '[https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_06/01_optimize_eggholder.py](https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_06/01_optimize_eggholder.py)'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_06/01_optimize_eggholder.py](https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_06/01_optimize_eggholder.py)'
- en: 'The following steps highlight the main parts of this program:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤突出显示了该程序的主要部分：
- en: 'The program starts by setting the function constants, namely the number of
    input dimensions (2, as this function is defined over the *x*-*y* plane), and
    the search space boundaries that were mentioned previously:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 程序开始时设置函数常量，即输入维度的数量（2，因为该函数在*x*-*y*平面上定义），以及前面提到的搜索空间边界：
- en: '[PRE0]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Since we are dealing with floating-point numbers confined by certain boundaries,
    we next define a helper function that creates random floating-point numbers, uniformly
    distributed within the given range:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们处理的是受特定边界限制的浮动点数，接下来我们定义一个辅助函数来生成在给定范围内均匀分布的随机浮动点数：
- en: Note
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 注
- en: This function assumes that the upper and lower boundaries are the same for all
    dimensions.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数假设所有维度的上限和下限是相同的。
- en: '[PRE1]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We next define the **attrFloat** operator. This operator utilizes the previous
    helper function to create a single, random floating-point number within the given
    boundaries. The **attrFloat** operator is then used by the **individualCreator**
    operator to create random individuals. This is followed by **populationCreator**,
    which can generate the desired number of individuals:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义**attrFloat**操作符。该操作符利用先前的辅助函数在给定边界内创建一个单一的随机浮动点数。然后，**attrFloat**操作符由**individualCreator**操作符使用，用于创建随机个体。接着是**populationCreator**，它可以生成所需数量的个体：
- en: '[PRE2]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Given that the object to be minimized is the Eggholder function, we use it
    directly as the fitness evaluator. As the individual is a list of floating-point
    numbers with a dimension (or length) of 2, we extract the **x** and **y** values
    from the individual accordingly, and then calculate the function:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于待最小化的对象是Eggholder函数，我们直接使用它作为适应度评估函数。由于个体是一个浮动点数的列表，维度（或长度）为2，我们相应地从个体中提取**x**和**y**值，然后计算该函数：
- en: '[PRE3]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next are the genetic operators. Given that the *selection* operator is independent
    of the individual type, and we’ve had a good experience so far using the *tournament
    selection* with a tournament size of 2, coupled with the *elitist approach*, we’ll
    continue to use it here. The *crossover* and *mutation* operators, on the other
    hand, need to be specialized for floating-point numbers within given boundaries,
    and therefore we use the DEAP-provided **cxSimulatedBinaryBounded** operator for
    crossover and the **mutPolynomialBounded** operator for mutation:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是遗传操作符。由于*选择*操作符与个体类型无关，并且到目前为止我们在使用*锦标赛选择*（锦标赛大小为2）结合*精英主义方法*方面经验良好，因此我们将在此继续使用它。另一方面，*交叉*和*变异*操作符需要针对给定边界内的浮动点数进行专门化，因此我们使用DEAP提供的**cxSimulatedBinaryBounded**操作符进行交叉，使用**mutPolynomialBounded**操作符进行变异：
- en: '[PRE4]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As we have done multiple times, we use our modified version of DEAP’s simple
    genetic algorithm flow, where we added *elitism*—keeping the best individuals
    (members of the hall of fame) and moving them to the next generation, untouched
    by the genetic operators:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如我们多次操作所示，我们使用了修改过的DEAP简单遗传算法流程，我们在其中加入了*精英主义*——保留最好的个体（名人堂成员），并将它们传递到下一代，不受遗传操作符的影响：
- en: '[PRE5]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We will start with the following parameters for the genetic algorithm settings.
    As the Eggholder function may be somewhat difficult to optimize, we use a relatively
    large population size considering the low dimension count:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将从以下遗传算法设置参数开始。由于Eggholder函数可能有些难以优化，考虑到低维度的数量，我们使用相对较大的种群大小：
- en: '[PRE6]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In addition to the previous ordinary genetic algorithm constants, we now need
    a new one, the **crowding factor** (eta) that is used by both the crossover and
    mutation operations:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除了之前的常规遗传算法常数外，我们现在需要一个新的常数——**拥挤因子**（eta），它被交叉和变异操作使用：
- en: '[PRE7]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Important note
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: It is also possible to define separate crowding factors for crossover and mutation.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以为交叉和变异分别定义不同的拥挤因子。
- en: 'We are finally ready to run the program. The results obtained with these settings
    are shown as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们终于准备好运行程序了。使用这些设置得到的结果如下所示：
- en: '[PRE8]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This means that we have found the global minimum.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们已经找到了全局最小值。
- en: 'If we examine the statistics plot generated by the program, shown next, we
    can tell that the algorithm found some local minima values right away and then
    made small incremental improvements until it eventually found the global minima:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看程序生成的统计图（如下所示），可以看出算法一开始就找到了某些局部最小值，随后进行了小幅度的增量改进，直到最终找到了全局最小值：
- en: '![Figure 6.2: Stats of the first program optimizing the Eggholder function](img/B20851_06_02.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图6.2: 优化Eggholder函数的第一个程序的统计数据](img/B20851_06_02.jpg)'
- en: 'Figure 6.2: Stats of the first program optimizing the Eggholder function'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '图6.2: 优化Eggholder函数的第一个程序的统计数据'
- en: One interesting area is around generation 180—let’s explore it further in the
    next subsection.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有趣的区域是第180代左右——让我们在下一个小节中进一步探讨。
- en: Improving the speed with an increased mutation rate
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过增加变异率来提高速度
- en: 'If we zoom in at the lower part of the fitness axis, we will notice a relatively
    large improvement of the best result found (red line) around generation 180, accompanied
    by a large swing of the average results (green line):'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们放大适应度轴的下部区域，会注意到在第180代左右，最佳结果（红线）有了相对较大的改善，同时平均结果（绿线）发生了较大波动：
- en: '![Figure 6.3: Enlarged section of the first program’s stats graph](img/B20851_06_03.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图6.3: 第一个程序的统计图放大部分](img/B20851_06_03.jpg)'
- en: 'Figure 6.3: Enlarged section of the first program’s stats graph'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '图6.3: 第一个程序的统计图放大部分'
- en: One way to interpret this observation is that perhaps introducing more noise
    can lead to better results faster. This could be another manifestation of the
    familiar principle of **exploration versus exploitation** we’ve discussed several
    times before—increasing the exploration (which manifests itself as noise in the
    diagram) may help us locate the global minimum faster. An easy way to increase
    the measure of exploration is to boost the probability of mutations. Hopefully,
    the use of elitism—keeping the best results untouched—will keep us from over-exploring,
    which leads to random search-like behavior.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 解释这个现象的一种方式是，或许引入更多噪声能够更快地得到更好的结果。这可能是我们之前讨论过的**探索与开发**原则的另一种表现——增加探索（在图中表现为噪声）可能帮助我们更快地找到全局最小值。增加探索度的一个简单方法是提高变异的概率。希望使用精英主义——保持最佳结果不变——可以防止我们过度探索，这会导致类似随机搜索的行为。
- en: 'To test this idea, let’s increase the probability of mutation from 0.1 to 0.5:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证这个想法，我们将变异概率从0.1提高到0.5：
- en: '[PRE9]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Running the modified program, we again found the global minimum, but much faster,
    as is evident from the output, as well as from the statistic plot shown next,
    where the red line (the best result) reaches the optimum quickly, while the average
    score (green) is noisier than before and is more distanced from the best result:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 运行修改后的程序后，我们再次找到了全局最小值，但速度要快得多，从输出结果以及接下来展示的统计图中可以明显看出，红线（最佳结果）很快就达到了最优，而平均分数（绿色）比之前更嘈杂，并且离最佳结果更远：
- en: '![Figure 6.4: Stats of the program optimizing the Eggholder function with an
    increased mutation probability](img/B20851_06_04.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图6.4: 优化Eggholder函数的程序统计数据，变异概率增大](img/B20851_06_04.jpg)'
- en: 'Figure 6.4: Stats of the program optimizing the Eggholder function with an
    increased mutation probability'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '图6.4: 优化Eggholder函数的程序统计数据，变异概率增大'
- en: We will keep this idea in mind when dealing with our next benchmark function,
    known as Himmelblau’s function.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在处理下一个基准函数——Himmelblau函数时会牢记这一点。
- en: Optimizing Himmelblau’s function
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化Himmelblau函数
- en: 'Another frequently used function for benchmarking optimization algorithms is
    Himmelblau’s function, depicted in the following diagram:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常用的优化算法基准函数是Himmelblau函数，如下图所示：
- en: '![Figure 6.5: Himmelblau’s function ](img/B20851_06_05.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图6.5: Himmelblau函数](img/B20851_06_05.jpg)'
- en: 'Figure 6.5: Himmelblau’s function'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '图6.5: Himmelblau函数'
- en: 'Source: [https://commons.wikimedia.org/wiki/File:Himmelblau_function.svg](https://commons.wikimedia.org/wiki/File:Himmelblau_function.svg)'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 来源：[https://commons.wikimedia.org/wiki/File:Himmelblau_function.svg](https://commons.wikimedia.org/wiki/File:Himmelblau_function.svg)
- en: Image by Morn the Gorn
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图片由Morn the Gorn提供
- en: 'The function can be mathematically expressed as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数可以用以下数学表达式表示：
- en: f(x, y) = (x 2 + y − 11) 2 + (x + y 2 − 7) 2
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: f(x, y) = (x 2 + y − 11) 2 + (x + y 2 − 7) 2
- en: It is usually evaluated on the search space bounded by [-5, 5] in each dimension.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 它通常在每个维度边界为[-5, 5]的搜索空间中进行评估。
- en: 'Although this function seems simpler in comparison to the Eggholder function,
    it draws interest as it is **multi-modal**; in other words, it has more than one
    global minimum. To be exact, the function has four global minima evaluating to
    0, which can be found in the following locations:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管与Eggholder函数相比，这个函数看起来更简单，但它引起了人们的兴趣，因为它是**多模态**的；换句话说，它有多个全局最小值。准确来说，这个函数有四个全局最小值，值为0，分别位于以下位置：
- en: x=3.0, y=2.0
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: x=3.0, y=2.0
- en: x=−2.805118, y=3.131312
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: x=−2.805118, y=3.131312
- en: x=−3.779310, y=−3.283186
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: x=−3.779310, y=−3.283186
- en: x=3.584458, y=−1.848126
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: x=3.584458, y=−1.848126
- en: 'These locations are depicted in the following function contour diagram:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这些位置在以下的函数等高线图中进行了描述：
- en: '![Figure 6.6: Contour diagram of Himmelblau’s function ](img/B20851_06_06.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.6：Himmelblau函数的等高线图](img/B20851_06_06.jpg)'
- en: 'Figure 6.6: Contour diagram of Himmelblau’s function'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.6：Himmelblau函数的等高线图
- en: 'Source: [https://commons.wikimedia.org/wiki/File:Himmelblau_contour.svg](https://commons.wikimedia.org/wiki/File:Himmelblau_contour.svg)'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 来源：[https://commons.wikimedia.org/wiki/File:Himmelblau_contour.svg](https://commons.wikimedia.org/wiki/File:Himmelblau_contour.svg)
- en: Image by Nicoguaro
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图片由Nicoguaro提供
- en: When optimizing multi-modal functions, we are often interested in finding all
    (or most) minima locations. However, let’s start with finding one, which we are
    going to do in the next subsection.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在优化多模态函数时，我们通常希望找到所有（或大多数）最小值的位置。然而，让我们先从找到一个最小值开始，这将在下一小节中完成。
- en: Optimizing Himmelblau’s function with genetic algorithms
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用遗传算法优化Himmelblau函数
- en: 'The genetic algorithm-based program we created for finding a single minimum
    of Himmelblau’s function resides in the `02_optimize_himmelblau.py` Python program,
    located at the following link:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为找到Himmelblau函数的单一最小值所创建的基于遗传算法的程序位于`02_optimize_himmelblau.py` Python程序中，具体位置见以下链接：
- en: '[https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_06/02_optimize_himmelblau.py](https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_06/02_optimize_himmelblau.py)'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_06/02_optimize_himmelblau.py](https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_06/02_optimize_himmelblau.py)'
- en: 'The program is similar to the one we used for optimizing the Eggholder function,
    with a few differences highlighted as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序与我们用来优化Eggholder函数的程序类似，下面列出了几个主要的区别：
- en: 'We set the boundaries for this function to [-5.0, 5.0]:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们为此函数设定了边界为[-5.0, 5.0]：
- en: '[PRE10]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We now use Himmelblau’s function as the fitness evaluator:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们使用Himmelblau函数作为适应度评估器：
- en: '[PRE11]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Since the function we optimize has several minima, it may be interesting to
    observe the distribution of the solutions found at the end of the run. We, therefore,
    add a scatter graph containing the locations of the four global minima and the
    final population on the same *x*-*y* plane:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们优化的函数有多个最小值，因此观察运行结束后找到的解的分布可能很有趣。因此，我们添加了一个散点图，显示了四个全局最小值的位置以及最终种群在同一*x*-*y*平面上的分布：
- en: '[PRE12]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We also print the members of the hall of fame—the best individuals found during
    the run:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还打印了名人堂成员——在运行过程中找到的最佳个体：
- en: '[PRE13]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Running the program, the results indicate that we found one of the four minima
    (x=3.0, y=2.0):'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 运行程序后，结果显示我们找到了四个最小值中的一个（x=3.0, y=2.0）：
- en: '[PRE14]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The printout of the hall-of-fame members suggests they all represent the same
    solution:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 名人堂成员的输出表明它们都代表相同的解：
- en: '[PRE15]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The following diagram, illustrating the distribution of the entire population,
    further confirms that the genetic algorithms have converged to one of the four
    functions’ minima—the one residing at (x=3.0, y=2.0):'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了整个种群的分布，进一步确认了遗传算法已经收敛到四个函数最小值中的一个——即位于(x=3.0, y=2.0)的最小值：
- en: '![Figure 6.7: Scatter graph of the population at the end of the first run,
    alongside the four functions’ minima](img/B20851_06_07.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.7：第一次运行结束时，种群的散点图，显示了四个函数的最小值](img/B20851_06_07.jpg)'
- en: 'Figure 6.7: Scatter graph of the population at the end of the first run, alongside
    the four functions’ minima'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.7：第一次运行结束时种群的散点图，显示了四个函数的最小值
- en: In addition, it is evident that many of the individuals in the population have
    either the `x` or the `y` component of the minima we found.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，可以明显看出，种群中的许多个体具有我们找到的最小值的`x`或`y`分量。
- en: 'These results represent what we generally expect from the genetic algorithm—to
    identify a global optimum and converge to it. Since, in this case, we have several
    minima, it is expected to converge to one of them. Which one it will be is largely
    based on the random initialization of the algorithm. As you may recall, in all
    our programs so far, we have been using a fixed random seed (of value 42):'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这些结果代表了我们通常从遗传算法中期望的结果——识别全局最优解并向其收敛。由于在此情况下我们有多个最小值，因此预计算法会收敛到其中一个。最终会收敛到哪个最小值，主要取决于算法的随机初始化。正如你可能记得的，我们迄今为止在所有程序中都使用了固定的随机种子（值为42）：
- en: '[PRE16]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This is done to enable the repeatability of the results; however, in real life,
    we will typically use different random seed values for different runs, either
    by commenting out these lines or by explicitly setting the constant to different
    values.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做是为了使结果具有可重复性；然而，在现实中，我们通常会为不同的运行使用不同的随机种子值，方法是注释掉这些行或显式地将常量设置为不同的值。
- en: 'For example, if we set the seed value to 13, we will end up with the solution
    (x=−2.805118, y=3.131312), as illustrated in the following diagram:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们将种子值设置为13，我们将得到解(x=−2.805118, y=3.131312)，如下图所示：
- en: '![Figure 6.8: Scatter graph of the population at the end of the second run,
    alongside the four functions’ minima](img/B20851_06_08.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图6.8：第二次运行结束时种群的散点图，显示了四个函数的最小值](img/B20851_06_08.jpg)'
- en: 'Figure 6.8: Scatter graph of the population at the end of the second run, alongside
    the four functions’ minima'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.8：第二次运行结束时种群的散点图，显示了四个函数的最小值
- en: 'If we proceed to change the seed value to 17, the program execution will yield
    the solution (x=3.584458, y=−1.848126), as illustrated by the following diagram:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将种子值更改为17，程序执行将得到解(x=3.584458, y=−1.848126)，如下图所示：
- en: "![Figure 6.9: Scatter graph of the population at the end of the third run,\
    \ alongside the four fu\uFEFFnctions’ minima](img/B20851_06_09.jpg)"
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![图6.9：第三次运行结束时种群的散点图，显示了四个函数的最小值](img/B20851_06_09.jpg)'
- en: 'Figure 6.9: Scatter graph of the population at the end of the third run, alongside
    the four functions’ minima'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.9：第三次运行结束时种群的散点图，显示了四个函数的最小值
- en: However, what if we wanted to find *all* global minima in a single run? As we
    will see in the next subsection, genetic algorithms offer us a way to pursue this
    goal.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们想在一次运行中找到*所有*的全局最小值呢？正如我们将在下一小节中看到的，遗传算法为我们提供了一种追求这一目标的方法。
- en: Using niching and sharing to find multiple solutions
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用分区和共享来寻找多个解
- en: In [*Chapter 2*](B20851_02.xhtml#_idTextAnchor053), *Understanding the Key Components
    of Genetic Algorithms*, we mentioned that **niching** and **sharing** in genetic
    algorithms mimic the way a natural environment is divided into multiple sub-environments
    or *niches*. These niches are populated by different species, or sub-populations,
    taking advantage of the unique resources available in each niche, while specimens
    that coexist in the same niche have to compete over the same resources. Implementing
    a sharing mechanism within the genetic algorithm will encourage individuals to
    explore new niches and can be used for finding several optimal solutions, each
    considered a niche. One common way to accomplish sharing is to divide the raw
    fitness value of each individual with (some function of) the combined distances
    from all the other individuals, effectively penalizing a crowded population by
    sharing the local bounty between its individuals.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第2章*](B20851_02.xhtml#_idTextAnchor053)《理解遗传算法的关键组件》中，我们提到过遗传算法中的**分区**和**共享**模拟了自然环境被划分为多个子环境或*生态位*的方式。这些生态位由不同的物种或子种群填充，利用每个生态位中独特的资源，而在同一生态位中的个体则必须竞争相同的资源。在遗传算法中实现共享机制将鼓励个体探索新的生态位，并可用于寻找多个最优解，每个解都被认为是一个生态位。实现共享的常见方法是将每个个体的原始适应度值与所有其他个体的距离的（某些函数的）合并值相除，从而通过在个体之间共享局部资源来有效地惩罚拥挤的种群。
- en: 'Let’s try to apply this idea to Himmelblau’s function optimization process
    and see whether it can help locate all four minima in a single run. This attempt
    is implemented in the `03_optimize_himmelblau_sharing.py` program, located at
    the following link:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试将这个思路应用于Himmelblau函数的优化过程，看看它是否能帮助在一次运行中找到所有四个极小值。这个尝试实现于`03_optimize_himmelblau_sharing.py`程序中，位于以下链接：
- en: '[https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_06/03_optimize_himmelblau_sharing.py](https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_06/03_optimize_himmelblau_sharing.py)'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_06/03_optimize_himmelblau_sharing.py](https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_06/03_optimize_himmelblau_sharing.py)'
- en: 'The program is based on the previous one, but we had to make some important
    modifications, described as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序基于之前的程序，但我们必须做了一些重要的修改，描述如下：
- en: 'For starters, the implementation of a sharing mechanism usually requires us
    to optimize a function that produces positive fitness values and to look for *maxima*
    values rather than *minima*. This enables us to divide the raw fitness values
    as a way to decrease fitness and practically share the resources between neighboring
    individuals. As Himmelblau’s function produces values between 0 and (roughly)
    2,000, we can instead use a modified function that returns 2,000 minus the original
    value, which will guarantee that all function values are positive, while transforming
    the minima points into maxima points that return the value of 2,000\. As the locations
    of these points are not going to change, finding them will still serve our original
    purpose:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，实现共享机制通常需要我们优化一个产生正适应度值的函数，并寻找*最大值*，而不是*最小值*。这使我们能够通过划分原始适应度值来减少适应度，并实际在相邻个体之间共享资源。由于Himmelblau函数产生的值介于0到（大约）2,000之间，我们可以使用一个修改后的函数，该函数返回2,000减去原始值，这样可以保证所有函数值都是正的，同时将极小值转换为极大值，返回值为2,000。由于这些点的位置不会改变，找到它们仍然能达到我们最初的目的：
- en: '[PRE17]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To complete the conversion, we redefine the fitness strategy to be a *maximizing*
    one:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了完成转换，我们将适应度策略重新定义为*最大化*策略：
- en: '[PRE18]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To enable the implementation of *sharing*, we first create two additional constants:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了实现*共享*，我们首先创建了两个额外的常量：
- en: '[PRE19]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, we need to implement the sharing mechanism. One convenient location for
    this implementation is within the *selection* genetic operator. The selection
    operator is where the fitness values of all individuals are examined and used
    to select the parents for the next generation. This enables us to inject some
    code that recalculates these fitness values just before the selection takes place
    and then retrieves the original fitness values before continuing, for the purpose
    of tracking. To make this happen, we implemented a new **selTournamentWithSharing()**
    function, which has the same signature as the original **tools.selTournament()**
    function we have been using until now:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要实现共享机制。一个便捷的实现位置是在*选择*遗传算子中。选择算子是检查所有个体适应度值并用于选择下一代父母的位置。这使得我们能够注入一些代码，在选择操作发生之前重新计算这些适应度值，然后在继续之前恢复原始的适应度值，以便进行跟踪。为了实现这一点，我们实现了一个新的**selTournamentWithSharing()**函数，它与我们一直使用的原始**tools.selTournament()**函数具有相同的函数签名：
- en: '[PRE20]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This function starts by setting the original fitnesses aside so that they can
    be retrieved later. It then iterates over each individual and calculates a number,
    `sharingSum`, by which its fitness value will be divided. This sum value is accumulated
    by calculating the distance between the location of the current individual and
    the location of each of the other individuals in the population. If the distance
    is smaller than the threshold defined by the `DISTANCE_THRESHOLD` constant, the
    following value is added to the accumulating sum:'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该函数首先将原始的适应度值存放在一旁，以便稍后可以恢复。接着，它遍历每个个体，通过计算一个数字`sharingSum`来决定如何划分其适应度值。这个和是通过计算当前个体与种群中每个其他个体位置之间的距离来累加的。如果距离小于`DISTANCE_THRESHOLD`常量定义的阈值，则会将以下值加到累积和中：
- en: 1 −  𝒹𝒾𝓈𝓉𝒶𝓃𝒸ℯ  ___________________  DISTANC E − THRESHOLD  ×  1 _______________  SHARIN
    G − EXTENT
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 1 −  𝒹𝒾𝓈𝓉𝒶𝓃𝒸ℯ  ___________________  DISTANCE − THRESHOLD ×  1  ______________  SHARING
    − EXTENT
- en: 'This means that the *reduction* in the fitness value will be greater in the
    following scenarios:'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这意味着在以下情况下，适应度值的*下降*会更大：
- en: The (normalized) distance between the individuals is smaller
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 个体之间的（归一化）距离较小
- en: The value of the **SHARING_EXTENT** constant is larger
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SHARING_EXTENT**常数的值较大'
- en: 'After recalculating the fitness value for each individual, *tournament selection*
    is conducted using the new fitness values:'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在重新计算每个个体的适应度值后，使用新的适应度值进行*锦标赛选择*：
- en: '[PRE21]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Lastly, the original fitness values are retrieved:'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，检索原始适应度值：
- en: '[PRE22]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'As a final touch, we added a plot showing the locations of the best individuals—the
    hall-of-fame members—on the *x*-*y* plane, alongside the known optima location,
    similar to what we already do for the entire population:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们添加了一个图表，展示了最佳个体——名人堂成员——在*x*-*y*平面上的位置，并与已知的最优位置进行对比，类似于我们对整个种群所做的操作：
- en: '[PRE23]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'When we run this program, the results don’t disappoint. Examining the members
    of the hall of fame, it seems that we have located all four optima locations:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这个程序时，结果并没有让人失望。通过检查名人堂成员，似乎我们已经找到了所有四个最优位置：
- en: '[PRE24]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The following diagram, illustrating the distribution of the hall-of-fame members,
    further confirms that:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示展示了名人堂成员的分布，进一步证实了这一点：
- en: '![Figure 6.10: Scatter graph of the best solutions at the end of the run, alongside
    the four functions’ minima, when using niching](img/B20851_06_10.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![图6.10：使用生态位分割法时，在运行结束时最佳解的散点图，以及四个函数的最小值](img/B20851_06_10.jpg)'
- en: 'Figure 6.10: Scatter graph of the best solutions at the end of the run, alongside
    the four functions’ minima, when using niching'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.10：使用生态位分割法时，在运行结束时最佳解的散点图，以及四个函数的最小值。
- en: 'Meanwhile, the diagram depicting the distribution of the *entire* population
    demonstrates how the population is scattered around the four solutions:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，展示整个种群分布的图表表明，种群是如何围绕四个解散布的：
- en: '![Figure 6.11: Scatter graph of the population at the end of the run, alongside
    the four functions’ minima, when using niching](img/B20851_06_11.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![图6.11：使用生态位分割法时，在运行结束时种群的散点图，以及四个函数的最小值](img/B20851_06_11.jpg)'
- en: 'Figure 6.11: Scatter graph of the population at the end of the run, alongside
    the four functions’ minima, when using niching'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.11：使用生态位分割法时，在运行结束时种群的散点图，以及四个函数的最小值。
- en: As impressive as this may seem, we need to remember that what we did here can
    prove harder to implement in real-life situations. For one, the modifications
    we added to the selection process increase the calculation complexity and the
    time consumed by the algorithm. In addition, the population size usually needs
    to be increased so that it can sufficiently cover all areas of interest. The values
    of the sharing constants may be difficult to determine in some cases—for example,
    if we don’t know in advance how close together the various peaks may be. However,
    we can always use this technique to roughly locate areas of interest and then
    further explore each one of them using the standard version of the algorithm.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这看起来令人印象深刻，但我们需要记住，我们所做的事情在实际情况中可能更难以实现。首先，我们对选择过程所做的修改增加了计算复杂度和算法的耗时。此外，通常需要增加种群规模，以便它能够充分覆盖所有感兴趣的区域。在某些情况下，共享常数的值可能很难确定——例如，如果我们事先不知道各个峰值之间可能有多近。然而，我们可以始终使用这一技术大致确定感兴趣区域，然后使用标准版本的算法进一步探索每一个区域。
- en: An alternative approach for finding several optima points falls within the realm
    of **constrained optimization**, which is the subject of the next section.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找多个最优点的另一种方法属于**约束优化**的范畴，这是下一节的内容。
- en: Simionescu’s function and constrained optimization
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Simionescu的函数与约束优化
- en: At first glance, Simionescu’s function may not look particularly interesting.
    However, it has a constraint attached to it that makes it intriguing to work with
    as well as pleasant to look at.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 初看之下，Simionescu的函数可能看起来并不特别有趣。然而，它附带的约束条件使得它在处理时既富有挑战性，又令人赏心悦目。
- en: 'The function is usually evaluated on the search space bounded by [-1.25, 1.25]
    in each dimension and can be mathematically expressed as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数通常在每个维度由[-1.25, 1.25]限定的搜索空间内进行评估，可以用以下数学表达式表示：
- en: f(x, y) = 0.1xy
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: f(x, y) = 0.1xy
- en: 'Here, the values of *x, y* are subject to the following condition:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，*x, y*的值满足以下条件：
- en: x 2 + y 2 ≤ [1 + 0.2 ⋅ cos(8 ⋅ arctan  x _ y )] 2
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: x 2 + y 2 ≤ [1 + 0.2 ⋅ cos(8 ⋅ arctan  x _ y )] 2
- en: 'This constraint effectively limits the values of *x* and *y* that are considered
    valid for this function. The result is depicted in the following contour diagram:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 该约束有效地限制了被认为对该函数有效的*x*和*y*值。结果如下图所示：
- en: '![Figure 6.12: Contour diagram of the constrained Simionescu’s function](img/B20851_06_12.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![图6.12：受约束的Simionescu函数的轮廓图](img/B20851_06_12.jpg)'
- en: 'Figure 6.12: Contour diagram of the constrained Simionescu’s function'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.12：受约束的Simionescu函数的轮廓图
- en: 'Source: [https://commons.wikimedia.org/wiki/File:Simionescu%27s_function.PNG](https://commons.wikimedia.org/wiki/File:Simionescu%27s_function.PNG)'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 来源：[https://commons.wikimedia.org/wiki/File:Simionescu%27s_function.PNG](https://commons.wikimedia.org/wiki/File:Simionescu%27s_function.PNG)
- en: Image by Simiprof
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 图片来自Simiprof
- en: 'The flower-shaped border is created by the constraint, while the colors of
    the contours denote the actual value—red for the highest values and purple for
    the lowest. If it weren’t for the constraint, the minima points would have been
    at (1.25, -1.25) and (-1.25, 1.25). However, after applying the constraint, the
    global minima of the function are located at the following locations:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 花朵状的边界是由约束所形成的，而轮廓的颜色表示实际值——红色表示最高值，紫色表示最低值。如果没有约束，最小值点将位于(1.25, -1.25)和(-1.25,
    1.25)的位置。然而，在应用约束后，函数的全局最小值位于以下位置：
- en: '*x*=0.84852813, *y*=–0.84852813'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*x*=0.84852813, *y*=–0.84852813'
- en: '*x*=−0.84852813, *y*=0.84852813'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*x*=−0.84852813, *y*=0.84852813'
- en: These represent the tips of the two opposite petals containing the purple contours.
    Both minima evaluate to the value of -0.072.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这些代表了包含紫色轮廓的两个相对花瓣的尖端。两个最小值的评估结果均为-0.072。
- en: In the next subsection, we will attempt to find these minima using our real-coded
    genetic algorithms approach.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的小节中，我们将尝试使用实值编码的遗传算法方法来寻找这些最小值。
- en: Constrained optimization with genetic algorithms
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 受约束优化与遗传算法
- en: We have already dealt with constraints in [*Chapter 5*](B20851_05.xhtml#_idTextAnchor177),
    *Constraint Satisfaction*, when we tackled constraints within the realm of search
    problems. However, while search problems presented us with invalid states or combinations,
    here we need to address constraints in the continuous space, defined as mathematical
    inequalities.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在[*第5章*](B20851_05.xhtml#_idTextAnchor177)《约束满足》中处理过约束问题，当时我们讨论了搜索问题中的约束条件。然而，虽然搜索问题为我们呈现了无效状态或组合，但在这里，我们需要处理的是连续空间中的约束，这些约束被定义为数学不等式。
- en: 'The approaches for both cases, however, are similar, and the differences lie
    in the implementation. Let’s revisit these approaches:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，两个案例的处理方法相似，差异在于实现方式。让我们重新回顾这些方法：
- en: The best approach, when available, is to eliminate the possibility of a constraint
    violation. We have actually been doing it all along in this chapter as we have
    used bounded regions for our functions. These are actually simple constraints
    on each input variable. We were able to go around them by generating initial populations
    within the given boundaries and by utilizing bounded genetic operators such as
    **cxSimulatedBinaryBounded()**, which produced results within the given boundaries.
    Unfortunately, this approach can prove difficult to implement when the constraints
    are more complex than just the upper and lower bounds for an input variable.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最好的方法是在可能的情况下消除约束违规的可能性。实际上，在本章中我们一直在这样做，因为我们使用了带有边界的区域来处理函数。这些实际上是对每个输入变量的简单约束。我们通过在给定边界内生成初始种群，并利用如**cxSimulatedBinaryBounded()**等有界遗传算子，使得结果保持在给定的边界内。不幸的是，当约束比仅仅是输入变量的上下限更复杂时，这种方法可能难以实现。
- en: Another approach is to discard candidate solutions that violate any given constraint.
    As we mentioned before, this approach leads to the loss of information contained
    in these solutions and can considerably slow down the optimization process.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一种方法是丢弃违反任何给定约束条件的候选解。正如我们之前提到的，这种方法会导致这些解中包含的信息丧失，并可能显著减慢优化过程的速度。
- en: The next approach is to repair any candidate solution that violates a constraint
    by modifying it so it will no longer violate the constraint(s). This can prove
    difficult to implement and, at the same time, may lead to significant loss of
    information.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一种方法是修复任何违反约束的候选解，通过修改它使其不再违反约束。这可能会证明很难实现，同时也可能导致显著的信息丧失。
- en: Finally, the approach that worked for us in [*Chapter 5*](B20851_05.xhtml#_idTextAnchor177),
    *Constraint Satisfaction*, was to penalize candidate solutions that violated a
    constraint by degrading the solution’s score and making it less desirable. For
    search problems, we implemented this approach by creating a cost function that
    added a fixed cost to each constraint violation. Here, in the continuous space
    case, we can either use a fixed penalty or increase the penalty based on the degree
    to which the constraint was violated.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，适用于我们在[*第五章*](B20851_05.xhtml#_idTextAnchor177)中的方法，*约束满足*，是通过降低违反约束的候选解的得分并使其不那么可取来惩罚违反约束的解。对于搜索问题，我们通过创建一个成本函数来实现这一方法，该函数为每个约束违反加上一个固定的成本。在连续空间的情况下，我们可以使用固定的惩罚，也可以根据违反约束的程度增加惩罚。
- en: When taking the last approach—penalizing the score for constraint violations—we
    can utilize a feature offered by the DEAP framework, namely the **penalty function**,
    as we will demonstrate in the next subsection.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 当采取最后一种方法——对约束违反进行惩罚——时，我们可以利用DEAP框架提供的一个特性，即**惩罚函数**，我们将在下一小节中演示这一点。
- en: Optimizing Simionescu’s function using genetic algorithms
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用遗传算法优化Simionescu函数
- en: 'The genetic algorithm-based program we created for optimizing Simionescu’s
    function resides in the `04_optimize_simionescu.py` Python program, located at
    the following link:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为优化Simionescu函数创建的基于遗传算法的程序位于`04_optimize_simionescu.py` Python程序中，链接如下：
- en: '[https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_06/04_optimize_simionescu.py](https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_06/04_optimize_simionescu.py)'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_06/04_optimize_simionescu.py](https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_06/04_optimize_simionescu.py)'
- en: 'The program is very similar to the first one we used in this chapter, created
    originally for the Eggholder function, with the following highlighted differences:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序与我们在本章中第一次使用的程序非常相似，最初是为Eggholder函数创建的，具有以下突出差异：
- en: 'The constants setting the boundaries are adjusted to match the domain of Simionescu’s
    function:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置边界的常量已调整，以匹配Simionescu函数的域：
- en: '[PRE25]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In addition, a new constant determines a fixed penalty (or cost) for violating
    the constraint:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，一个新的常量决定了违反约束时的固定惩罚（或成本）：
- en: '[PRE26]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The fitness is now determined by the definition of Simionescu’s function:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 适应度现在由Simionescu函数的定义决定：
- en: '[PRE27]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Here is where the interesting part begins: we now define a new **feasible()**
    function that specifies the valid input domain using the constraints. This function
    returns a value of **True** for *x, y* values that comply with the constraints,
    and a value of **False** otherwise:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有趣的部分从这里开始：我们现在定义一个新的**feasible()**函数，该函数通过约束条件指定有效的输入域。对于符合约束条件的*x, y*值，该函数返回**True**，否则返回**False**：
- en: '[PRE28]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We then use DEAP’s **toolbox.decorate()** operator in combination with the
    **tools.DeltaPenalty()** function to modify (*decorate*) the original fitness
    function so that the fitness values will be penalized whenever the constraints
    are not satisfied. **DeltaPenalty()** accepts the **feasible()** function and
    the fixed penalty value as parameters:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用DEAP的**toolbox.decorate()**操作符与**tools.DeltaPenalty()**函数结合，以修改（*装饰*）原始的适应度函数，使得每当不满足约束条件时，适应度值会受到惩罚。**DeltaPenalty()**接受**feasible()**函数和固定惩罚值作为参数：
- en: '[PRE29]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Important note
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The **DeltaPenalty()** function can also accept a third parameter that represents
    the distance from the feasible region, causing the penalty to increase with the
    distance.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '**DeltaPenalty()**函数还可以接受第三个参数，表示距离可行区域的距离，使得惩罚随着距离的增加而增加。'
- en: 'Now, the program is ready to use! The results indicate that we have indeed
    found one of the two known minima locations:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，程序已经可以使用了！结果表明，我们确实找到了已知的两个最小值之一：
- en: '[PRE30]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: What about the second location? Read on—we will be looking for it in the next
    subsection.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个位置怎么样？继续阅读——我们将在下一小节中寻找它。
- en: Using constraints to find multiple solutions
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用约束条件找到多个解
- en: Earlier in this chapter, when optimizing Himmelblau’s function, we were looking
    for more than one minimum location, and observed two possible ways to do that—one
    was changing the random seed, and the other was using **niching and sharing**.
    Here, we will demonstrate a third option, powered by... constraints!
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章早些时候，优化Himmelblau函数时，我们寻求多个最小解，并观察到两种可能的做法——一种是改变随机种子，另一种是使用**分区和共享**。在这里，我们将展示第三种方法，通过...约束来实现！
- en: The niching technique we used for Himmelblau’s function is sometimes called
    *parallel niching* as it attempts to locate several solutions at the same time.
    As we already mentioned, it is prone to several practical drawbacks. *Serial niching*
    (or *sequential niching*), on the other hand, is a method used to find one solution
    at a time. To implement serial niching, we use the genetic algorithm as usual
    and find the best solution. We then update the fitness function so that the area
    of the solution(s) already found is penalized, thereby encouraging the algorithm
    to explore other areas of the problem space. This can be repeated multiple times
    until no additional viable solutions are found.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为Himmelblau函数使用的分区技术有时被称为*并行分区*，因为它试图同时定位多个解。正如我们之前提到的，它存在一些实际缺陷。另一方面，*串行分区*（或*顺序分区*）是一种每次寻找一个解的方法。为了实现串行分区，我们像往常一样使用遗传算法来找到最佳解。然后我们更新适应度函数，以便惩罚已找到解的区域，从而鼓励算法探索问题空间中的其他区域。这一过程可以重复多次，直到没有找到额外的可行解。
- en: Interestingly, penalizing the areas around the previously found solutions can
    be implemented by imposing constraints on the search space and, as we just learned
    how to apply constraints to the function at hand, we can use this knowledge to
    implement serial niching, demonstrated as follows.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，通过对搜索空间施加约束，惩罚靠近先前找到的解的区域是可实现的，正如我们刚刚学会如何向函数应用约束，我们可以利用这些知识来实现串行分区，示例如下：
- en: 'To find the second minimum for Simionescu’s function, we created the `05_ optimize_simionescu_second.py`
    Python program, located at the following link:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找到Simionescu函数的第二个最小值，我们创建了`05_optimize_simionescu_second.py` Python程序，位于以下链接：
- en: '[https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_06/05_optimize_simionescu_second.py](https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_06/05_optimize_simionescu_second.py)'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_06/05_optimize_simionescu_second.py](https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_06/05_optimize_simionescu_second.py)'
- en: 'The program is almost identical to the previous one, with a couple of changes,
    as follows:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序几乎与之前的程序相同，只做了以下几个小修改：
- en: 'We first add a constant that defines the *distance threshold* from previously
    found solutions—new solutions that are closer than this threshold value to any
    of the old ones will be penalized:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先添加了一个常数，用于定义*距离阈值*，该阈值用于与先前找到的解的距离——新解如果距离任何旧解小于此阈值，则会受到惩罚：
- en: '[PRE31]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We then add a second constraint to the definition of the **feasible()** function
    using a conditional statement with multiple clauses. The new constraint applies
    to input values closer than the threshold to the already found solution (x=0.848,
    y = -0.848):'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们接着通过使用一个带有多个子句的条件语句，向**feasible()**函数的定义中添加了第二个约束条件。新的约束适用于距离已经找到的解（x=0.848,
    y = -0.848）阈值更近的输入值：
- en: '[PRE32]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'When running this program, the results indicate that we have indeed found the
    second minimum:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 运行该程序时，结果表明我们确实找到了第二个最小值：
- en: '[PRE33]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: You are encouraged to add this minimum point as another constraint to the `feasible()`
    function and verify that running the program again does *not* find any other equally
    minimum-valued locations in the input space.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 鼓励你将这个最小点作为另一个约束添加到`feasible()`函数中，并验证再次运行程序时，*不会*找到输入空间中任何其他同样的最小值位置。
- en: Summary
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you were introduced to continuous search-space optimization
    problems and how they can be represented and solved using genetic algorithms,
    specifically by utilizing the DEAP framework. We then explored several hands-on
    examples of continuous function optimization problems—the Eggholder function,
    Himmelblau’s function, and Simionescu’s function—along with their Python-based
    solutions. In addition, we covered approaches for finding multiple solutions and
    for handling constraints.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了连续搜索空间优化问题，以及如何使用遗传算法表示并解决这些问题，特别是通过利用DEAP框架。接着，我们探索了几个实际的连续函数优化问题——埃格霍尔德函数、希梅尔布劳函数和西蒙内斯库函数——以及它们基于Python的解决方案。此外，我们还讲解了寻找多重解和处理约束的方法。
- en: In the next four chapters of the book, we will demonstrate how the various techniques
    we’ve learned so far in this book can be applied when solving **machine learning**
    (**ML**)- and **artificial intelligence** (**AI**)-related problems. The first
    of these chapters will provide a quick overview of **supervised learning** (**SL**)
    and then demonstrate how genetic algorithms can improve the outcome of learning
    models by selecting the most relevant portions of the given dataset.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书接下来的四章中，我们将演示我们目前所学的各种技术如何应用于解决**机器学习**（**ML**）和**人工智能**（**AI**）相关问题。这些章节的第一章将提供一个关于**监督学习**（**SL**）的快速概述，并展示遗传算法如何通过选择给定数据集的最相关部分来改善学习模型的结果。
- en: Further reading
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For more information, please refer to the following resources:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如需更多信息，请参考以下资源：
- en: '*Mathematical optimization: finding minima* *of functions*:'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*数学优化：寻找* *函数的最小值*：'
- en: '[http://scipy-lectures.org/advanced/mathematical_optimization/](http://scipy-lectures.org/advanced/mathematical_optimization/)'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[http://scipy-lectures.org/advanced/mathematical_optimization/](http://scipy-lectures.org/advanced/mathematical_optimization/)'
- en: '*Optimization Test Functions* *and Datasets*:'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*优化测试函数* *和数据集*：'
- en: '[https://www.sfu.ca/~ssurjano/optimization.html](https://www.sfu.ca/~ssurjano/optimization.html)'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://www.sfu.ca/~ssurjano/optimization.html](https://www.sfu.ca/~ssurjano/optimization.html)'
- en: '*Introduction to* *Constrained Optimization*:'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*约束优化简介*：'
- en: '[https://web.stanford.edu/group/sisl/k12/optimization/MO-unit3-pdfs/3.1introandgraphical.pdf](https://web.stanford.edu/group/sisl/k12/optimization/MO-unit3-pdfs/3.1introandgraphical.pdf)'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://web.stanford.edu/group/sisl/k12/optimization/MO-unit3-pdfs/3.1introandgraphical.pdf](https://web.stanford.edu/group/sisl/k12/optimization/MO-unit3-pdfs/3.1introandgraphical.pdf)'
- en: 'Constraint handling in DEAP:'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DEAP中的约束处理：
- en: '[https://deap.readthedocs.io/en/master/tutorials/advanced/constraints.html](https://deap.readthedocs.io/en/master/tutorials/advanced/constraints.html)'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://deap.readthedocs.io/en/master/tutorials/advanced/constraints.html](https://deap.readthedocs.io/en/master/tutorials/advanced/constraints.html)'
