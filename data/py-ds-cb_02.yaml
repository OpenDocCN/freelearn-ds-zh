- en: Chapter 2. Python Environments
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章. Python环境
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将介绍以下几个配方：
- en: Using NumPy libraries
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用NumPy库
- en: Plotting with matplotlib
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用matplotlib绘图
- en: Machine learning with scikit-learn
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用scikit-learn进行机器学习
- en: Introduction
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In this chapter, we will introduce you to the Python environment, which will
    be used extensively throughout this book. We will start with NumPy, which is a
    Python library that is used to handle arrays and matrices efficiently. It forms
    the basis for most of the other libraries used in this book. We will then introduce
    a Python plotting library called matplotlib. Our final recipe is about a machine
    learning library called scikit-learn.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将介绍Python环境，这将在本书中被广泛使用。我们将从NumPy开始，它是一个用于高效处理数组和矩阵的Python库。它是本书中大多数其他库的基础。接着，我们将介绍一个名为matplotlib的Python绘图库。最后，我们将介绍一个名为scikit-learn的机器学习库。
- en: Using NumPy libraries
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用NumPy库
- en: NumPy provides an efficient way of handling very large arrays in Python. Most
    of the Python scientific libraries use NumPy internally for the array and matrix
    operations. In this book, we will be using NumPy extensively. We will introduce
    NumPy in this recipe.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy提供了一种高效的方式来处理Python中的大型数组。大多数Python科学计算库在内部都使用NumPy进行数组和矩阵操作。在本书中，我们将广泛使用NumPy。在这一节中，我们将介绍NumPy。
- en: Getting ready
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will write a series of Python statements manipulating arrays and matrices,
    and learn how to use NumPy on the way. Our intent is to get you used to working
    with NumPy arrays, as NumPy will serve as the basis for most of the recipes in
    this book.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写一系列Python语句来操作数组和矩阵，并在过程中学习如何使用NumPy。我们的目的是让你习惯于使用NumPy数组，因为NumPy将作为本书中大多数配方的基础。
- en: How to do it…
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Let''s start by creating some simple matrices and arrays:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一些简单的矩阵和数组开始：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now we will write a small convenience function in order to inspect our NumPy
    objects:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将编写一个小的便利函数来检查我们的NumPy对象：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let''s see some alternate ways of creating arrays:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看创建数组的其他几种方法：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We will now look at the creation of some special matrices:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在来看看创建一些特殊矩阵的方法：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Armed with the knowledge of array and matrix creation, let''s see some shaping
    operations:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 掌握了数组和矩阵创建的知识后，我们来看一些变形操作：
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, proceed to see some matrix operations:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，继续查看一些矩阵操作：
- en: '[PRE5]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Finally, let''s see some reverse, copy, and grid operations:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看一些反向、复制和网格操作：
- en: '[PRE6]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let''s look at some random number generation routines in the NumPy library:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下NumPy库中的一些随机数生成方法：
- en: '[PRE7]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: How it works…
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'Let''s start by including the NumPy library:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从导入NumPy库开始：
- en: '[PRE8]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let''s proceed with looking at the various ways in which we can create an array
    in NumPy:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续看一下在NumPy中创建数组的各种方式：
- en: '[PRE9]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: An array can be created from a list. In the preceding example, we declared a
    list of three elements. We can then use `np.array()` to convert the list to a
    NumPy one-dimensional array.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 数组可以通过列表创建。在前面的示例中，我们声明了一个包含三个元素的列表。然后，我们可以使用`np.array()`将列表转换为一个NumPy一维数组。
- en: 'The datatype can also be specified, as seen in the last line of the preceding
    code:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类型也可以被指定，如前面代码中的最后一行所示：
- en: 'We will now move from arrays to matrices:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将从数组转向矩阵：
- en: '[PRE10]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We will create a matrix from a `listoflist`. Once again, we can specify the
    datatype.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个`listoflist`创建一个矩阵。同样，我们可以指定数据类型。
- en: 'Before we move further, we will define a `display_shape` function. We will
    use this function frequently further on:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，我们将定义一个`display_shape`函数。我们将在后面频繁使用这个函数：
- en: '[PRE11]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Every NumPy object has the following three properties:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 每个NumPy对象都有以下三个属性：
- en: '**size**: The number of elements in the given NumPy object'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**size**: 给定NumPy对象中的元素数量'
- en: '**ndim**: The number of dimensions'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**ndim**: 维度的数量'
- en: '**shape**: The shape returns a tuple with the dimensions of the object'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**shape**: shape返回一个包含对象维度的元组'
- en: This function prints out all the three properties in addition to printing the
    original element.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数除了打印原始元素外，还会打印出所有三个属性。
- en: 'Let''s call this function with the matrix that we created previously:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调用之前创建的矩阵来使用这个函数：
- en: '[PRE12]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '![How it works…](img/B04041_02_01.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的…](img/B04041_02_01.jpg)'
- en: As you can see, our matrix has nine elements in it, and there are two dimensions.
    Finally, we can see the shape displays both the dimensions and number of elements
    in each dimension. In this case, we have a matrix with three rows and three columns.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们的矩阵包含九个元素，并且有两个维度。最后，我们可以看到形状显示了每个维度的大小和元素的数量。在这种情况下，我们有一个三行三列的矩阵。
- en: 'Let''s now see a couple of other ways of creating arrays:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看创建数组的其他几种方式：
- en: '[PRE13]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The NumPy arrange function returns evenly spaced values in the given interval.
    In this case, we want an evenly spaced number between 1 and 10\. Refer to the
    following link for more information about arange:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 的 arrange 函数返回给定区间内均匀间隔的值。在此情况下，我们想要一个从 1 到 10 之间均匀间隔的数字。有关 arange 的更多信息，请参考以下链接：
- en: '[http://docs.scipy.org/doc/numpy/reference/generated/numpy.arange.html](http://docs.scipy.org/doc/numpy/reference/generated/numpy.arange.html)'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://docs.scipy.org/doc/numpy/reference/generated/numpy.arange.html](http://docs.scipy.org/doc/numpy/reference/generated/numpy.arange.html)'
- en: '[PRE14]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'NumPy''s `linspace` is similar to arrange. The difference is how we will request
    the number of samples that are required. With `linspace`, we can say how many
    elements we need between the given range. By default, it returns 50 elements.
    However, in arange, we will need to specify the step size:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 的 `linspace` 类似于 arrange。不同之处在于我们会请求所需样本的数量。使用 `linspace`，我们可以指定在给定范围内需要多少个元素。默认情况下，它返回
    50 个元素。然而，在 arange 中，我们需要指定步长：
- en: '[PRE15]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'NumPy provides you with several functions to create special types of arrays:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 提供了多种函数来创建特殊类型的数组：
- en: '[PRE16]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `ones()` and `zeros()` functions are used to create a matrix with 1 and
    0 respectively:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`ones()` 和 `zeros()` 函数分别用于创建一个包含 1 和 0 的矩阵：'
- en: '![How it works…](img/B04041_02_02.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的…](img/B04041_02_02.jpg)'
- en: 'Identity that the matrices are created, as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵的单位矩阵创建如下：
- en: '[PRE17]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `k` parameter controls the index where value `1` has to start:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`k` 参数控制值 `1` 开始的索引位置：'
- en: '[PRE18]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '![How it works…](img/B04041_02_03.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的…](img/B04041_02_03.jpg)'
- en: 'The shape of the arrays can be controlled by the `reshape` function:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的形状可以通过 `reshape` 函数来控制：
- en: '[PRE19]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'By passing `-1`, we can reshape the array to as many dimensions as needed:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 通过传递 `-1`，我们可以将数组重塑为所需的任意维度：
- en: '[PRE20]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '![How it works…](img/B04041_02_04.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的…](img/B04041_02_04.jpg)'
- en: 'The `ravel` and `flatten` functions can be used to convert a matrix to a one-dimensional
    array:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`ravel` 和 `flatten` 函数可用于将矩阵转换为一维数组：'
- en: '[PRE21]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '![How it works…](img/B04041_02_05.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的…](img/B04041_02_05.jpg)'
- en: 'Let''s look at some matrix operations, such as addition:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一些矩阵操作，比如加法：
- en: '[PRE22]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We will also look at element-wise multiplication:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将看一下逐元素乘法：
- en: '[PRE23]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The following code shows a matrix multiplication operation:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了一个矩阵乘法操作：
- en: '[PRE24]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Finally, we will transpose a matrix:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将对矩阵进行转置：
- en: '[PRE25]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `min` and `max` functions can be used to find the minimum and maximum elements
    in a matrix. The `sum` function can be used to find the sum of the rows or columns
    in a matrix:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`min` 和 `max` 函数可用于找到矩阵中的最小值和最大值。`sum` 函数可用于找到矩阵中每行或每列的总和：'
- en: '[PRE26]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '![How it works…](img/B04041_02_06.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的…](img/B04041_02_06.jpg)'
- en: 'The elements of a matrix can be reversed in the following way:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵的元素可以通过以下方式进行反转：
- en: '[PRE27]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `copy` function can be used to copy a matrix, as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`copy` 函数可用于复制一个矩阵，如下所示：'
- en: '[PRE28]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Finally, let''s look at the mgrid functionality:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看 mgrid 功能：
- en: '[PRE29]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `mgrid` functionality can be used to get the coordinates in the m-dimension.
    In the preceding example, we have three dimensions. In each dimension, our values
    range from `0` to `3`. Let us print `xx`, `yy`, and `zz` to understand a bit more:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`mgrid` 功能可用于获取 m 维度的坐标。在前面的示例中，我们有三个维度。在每个维度中，我们的值范围从 `0` 到 `3`。让我们打印 `xx`，`yy`
    和 `zz` 来更好地理解：'
- en: '![How it works…](img/B04041_02_07.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的…](img/B04041_02_07.jpg)'
- en: Let's see the first element of each array. [`0`,`0`,`0`] is the first coordinate
    in our three-dimensional space. The second element in all three arrays, [`0`,`0`,`1`]
    is another point in our space. Similarly, using `mgrid`, we captured all the points
    in our three-dimensional coordinate system.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看每个数组的第一个元素。[`0`,`0`,`0`] 是我们三维空间中的第一个坐标。所有三个数组中的第二个元素，[`0`,`0`,`1`] 是我们空间中的另一个点。类似地，使用
    `mgrid`，我们捕获了三维坐标系统中的所有点。
- en: 'NumPy provides us with a module called random in order to give routines, which
    can be used to generate random numbers. Let''s look at some examples of random
    number generation:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 为我们提供了一个名为 random 的模块，用于生成随机数。让我们看看一些随机数生成的例子：
- en: '[PRE30]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Using the `randint` function in the random module, we can generate random integer
    numbers. We can pass the `start`, `end`, and `size` parameters. In our case, our
    start is `1`, our end is `100`, and our size is `10`. We want 10 random integers
    between 1 and 100\. Let''s look at the output that is returned:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 使用随机模块中的`randint`函数，我们可以生成随机整数。我们可以传递`start`、`end`和`size`参数。在我们的例子中，起始值是`1`，结束值是`100`，大小是`10`。我们希望获得
    1 到 100 之间的 10 个随机整数。让我们看看返回的输出：
- en: '![How it works…](img/B04041_02_23.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的…](img/B04041_02_23.jpg)'
- en: 'Random numbers from other distributions can also be produced. Let''s see an
    example where we get 10 random numbers from a `normal` distribution:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以生成其他分布的随机数。让我们来看一个例子，获取 10 个来自`normal`分布的随机数：
- en: '[PRE31]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Using the `normal` function, we will generate a random sample from a `normal`
    distribution. The mean and standard deviation parameters of the `normal` distribution
    are specified by the `loc` and `scale` parameters. Finally, `size` determines
    the number of samples.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`normal`函数，我们将从`normal`分布中生成一个随机样本。`normal`分布的均值和标准差参数由`loc`和`scale`参数指定。最后，`size`决定了样本的数量。
- en: 'By passing a tuple with the row and column values, we can generate a random
    matrix as well:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 通过传递一个包含行和列值的元组，我们也可以生成一个随机矩阵：
- en: '[PRE32]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In the preceding example, we generated a 3 x 3 matrix, which is shown in the
    following code:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们生成了一个 3 x 3 的矩阵，代码如下所示：
- en: '![How it works…](img/B04041_02_24.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的…](img/B04041_02_24.jpg)'
- en: There's more…
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'You can refer to the following link for some excellent NumPy documentation:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以参考以下链接，查看一些优秀的 NumPy 文档：
- en: '[http://www.numpy.org/](http://www.numpy.org/)'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.numpy.org/](http://www.numpy.org/)'
- en: See also
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参见
- en: '*Plotting with matplotlib* recipe in [Chapter 3](ch03.xhtml "Chapter 3. Data
    Analysis – Explore and Wrangle"), *Analyzing Data - Explore & Wrangle*'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第 3 章](ch03.xhtml "第 3 章 数据分析 – 探索与整理")中的*使用 matplotlib 绘图*示例，*分析数据 - 探索与整理*
- en: '*Machine Learning with Scikit Learn* recipe in [Chapter 3](ch03.xhtml "Chapter 3. Data
    Analysis – Explore and Wrangle"), *Analyzing Data - Explore & Wrangle*'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第 3 章](ch03.xhtml "第 3 章 数据分析 – 探索与整理")中的*机器学习与 Scikit Learn*示例，*分析数据 - 探索与整理*
- en: Plotting with matplotlib
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 matplotlib 绘图
- en: Matplotlib Python is a two-dimensional plotting library. All kinds of plots,
    including histograms, scatter plots, line plots, dot plots, heat maps, and others,
    can be generated by Python. In this book, we will use the `pyplot` interface of
    `matplotlib` for all our visualization requirements.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Matplotlib Python 是一个二维绘图库。Python 可以生成各种图形，包括直方图、散点图、折线图、点图、热图等。在本书中，我们将使用`matplotlib`的`pyplot`接口来满足我们所有的可视化需求。
- en: Getting ready
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: In this recipe, we will introduce basic plotting mechanisms using `pyplot`.
    We will use `pyplot` in almost all our recipes for visualization in this book.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将介绍使用`pyplot`的基本绘图机制。我们将在本书中的几乎所有示例中使用`pyplot`来进行可视化。
- en: 'We used matplotlib version 1.3.1 for all the recipes in this book. In your
    command line, you can invoke the `__version__` attribute to check for the version:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本书中的所有示例中都使用了 matplotlib 版本 1.3.1。在你的命令行中，你可以调用`__version__`属性来检查版本：
- en: '![Getting ready](img/B04041_02_14.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![准备就绪](img/B04041_02_14.jpg)'
- en: How to do it…
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Let''s start by looking at how to plot simple graphs using matplotlib''s `pyplot`
    module:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从查看如何使用 matplotlib 的`pyplot`模块绘制简单图形开始：
- en: '[PRE33]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now we will proceed to look at some advanced topics, including generating heat
    maps and labeling the *x* and *y* axes:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将继续探讨一些高级主题，包括生成热图和标记 *x* 和 *y* 轴：
- en: '[PRE34]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: How it works…
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'We will start by importing the required modules. While using `pyplot`, it''s
    recommended that you import NumPy:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从导入所需的模块开始。在使用`pyplot`时，建议你导入 NumPy：
- en: '[PRE35]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Let''s start by following the code from the main function. There may be graphs
    from the previously run program. It is good practice to close them all, as we
    will use more graphs in our program:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从主函数的代码开始。可能会有之前程序运行生成的图形。关闭它们是个好习惯，因为我们将在程序中使用更多的图形：
- en: '[PRE36]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We will proceed by generating some data using NumPy to demonstrate plotting
    using `pyplot`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续使用 NumPy 生成一些数据，以演示如何使用`pyplot`进行绘图：
- en: '[PRE37]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We generated 100 elements in both our x and y variables. Our y is a square of
    our x variable.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 x 和 y 变量中各生成了 100 个元素。我们的 y 是 x 变量的平方。
- en: 'Let''s proceed to doing a simple line plot:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续进行一个简单的折线图：
- en: '[PRE38]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'When our program has multiple plots, it''s a good practice to number each plot.
    Variable `figure_no` is used to number our plots. Let''s look at the `simple_line_plot`
    function:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的程序中有多个图表时，给每个图表编号是一种好的做法。变量 `figure_no` 用于编号我们的图表。让我们看看 `simple_line_plot`
    函数：
- en: '[PRE39]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'As you can see, we started numbering our plots by calling the figure function
    in `pyplot`. We passed the figure no variable from our main program. After this,
    we simply called the plot function with our x and y values. We can make our plot
    meaningful by giving names to our x and y axes using the `xlabel` and `ylabel`
    functions respectively. Finally, we can also give a title to our plot. That is
    it. Our first simple line plot is ready. The plot will not be displayed till the
    `show()` function is called. In our code, we will invoke the `show()` function
    in order to see all the plots together. Our plot will look as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们通过在 `pyplot` 中调用 figure 函数来开始编号图表。我们将 `figure_no` 变量从主程序中传入。之后，我们简单地调用
    plot 函数，并传入我们的 x 和 y 值。我们可以通过使用 `xlabel` 和 `ylabel` 函数分别为 x 轴和 y 轴命名，使得图表更有意义。最后，我们还可以为图表添加标题。就这样，我们的第一个简单折线图就准备好了。直到调用
    `show()` 函数，图表才会显示。在我们的代码中，我们将调用 `show()` 函数以查看所有图表。我们的图表如下所示：
- en: '![How it works…](img/B04041_02_08.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的…](img/B04041_02_08.jpg)'
- en: Here, we plotted the values `x` on the x axis and `x squared` on the y axis.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将 `x` 值绘制在 x 轴上，将 `x 的平方` 绘制在 y 轴上。
- en: We created a simple line plot. We can see a nice curve as our **y values** are
    squares of our **x values**.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个简单的折线图。我们可以看到一条漂亮的曲线，因为我们的**y 值**是**x 值**的平方。
- en: 'Let''s move on to our next plot:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们进行下一个图表：
- en: '[PRE40]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We will increment our figure number and call the `simple_dots` function. We
    want to plot our *x* and *y* values as dots instead of a line. Let''s look at
    the `simple_dots` function:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将增加图表编号并调用 `simple_dots` 函数。我们想将我们的 *x* 和 *y* 值绘制为点，而不是折线。让我们看一下 `simple_dots`
    函数：
- en: '[PRE41]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Every line is similar to our previous function except the following line:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 每一行都与我们之前的函数类似，除了以下这一行：
- en: '[PRE42]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The `or` parameter says that we need dots `(o)`, and the dots should be in
    in the color red (r). The following is the output of the preceding command:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`or` 参数表示我们需要点 `(o)`，并且点的颜色是红色 (r)。以下是前一个命令的输出：'
- en: '![How it works…](img/B04041_02_09.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的…](img/B04041_02_09.jpg)'
- en: Let's move to our next plot.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续下一个图表。
- en: 'We are going to see a scatter plot. Let''s generate some data using NumPy:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要查看一个散点图。让我们使用 NumPy 生成一些数据：
- en: '[PRE43]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We sampled 100 data points from a uniform distribution. Now we will proceed
    to call the `simple_scatter` function in order to generate our scatter plot:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从均匀分布中抽取了 100 个数据点。现在我们将调用 `simple_scatter` 函数来生成我们的散点图：
- en: '[PRE44]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'In the `simple_scatter` function, all the lines are similar to the previous
    plotting routines except for the following line:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `simple_scatter` 函数中，所有行都与之前的绘图程序类似，除了以下这一行：
- en: '[PRE45]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Instead of calling the plot function in `pyplot`, we invoked the `scatter`
    function. Our plot will look as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有在 `pyplot` 中调用 plot 函数，而是调用了 `scatter` 函数。我们的图表如下所示：
- en: '![How it works…](img/B04041_02_10.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的…](img/B04041_02_10.jpg)'
- en: 'Let''s move on to our final plot, which is a scatter plot, but the points are
    colored based on the class label that they belong to:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们进行最终的图表绘制，这是一个散点图，但点的颜色根据它们所属的类别标签进行区分：
- en: '[PRE46]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: We will increment our figure in order to keep track of our graph. In the next
    line, we will assign some random labels, either `1` or `0`, to our points. Finally,
    we will call the `scatter_with_color` function with our *x*, *y*, and label variables.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将增加图表编号以跟踪我们的图表。在接下来的代码行中，我们将为数据点分配一些随机标签，标签为 `1` 或 `0`。最后，我们将调用 `scatter_with_color`
    函数，传入我们的 *x*、*y* 和标签变量。
- en: 'In the function, let''s look at the line that differentiates this code from
    the previous scatter plot code:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数中，让我们看一下与之前的散点图代码不同的一行：
- en: '[PRE47]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We will pass our labels to a `c` parameter, which stands for color. Each label
    will be assigned a unique color. In our example, all the points that are labeled
    as `0` will get a color that is different from the points that are labeled as
    `1`, as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将标签传递给 `c` 参数，表示颜色。每个标签将被分配一个唯一的颜色。在我们的例子中，所有标签为 `0` 的点将与标签为 `1` 的点有不同的颜色，如下所示：
- en: '![How it works…](img/B04041_02_11.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的…](img/B04041_02_11.jpg)'
- en: Let's move on to plotting some heat maps, and axis labeling.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续绘制一些热图，并添加坐标轴标签。
- en: 'Once again, we will start with the main function:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们将从主函数开始：
- en: '[PRE48]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: As a good practice, we will close all the previous figures by calling the `close`
    function. We will proceed with generating some data. Our x is an array of five
    elements, starting from `1` and ending with `5`. Our y is an array of five elements,
    starting from `100` and ending with `500`. We defined the two `x_label` and `y_label`
    lists, which will serve as the labels for our plot. Finally, we invoked the `x_y_axis_labeling`
    function in order to demonstrate the concept of labeling our tickers in the *x*
    and *y* axes.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 作为良好的实践，我们将在生成新图形之前，通过调用 `close` 函数关闭所有之前的图形。接下来，我们将生成一些数据。我们的 x 是一个包含五个元素的数组，起始值为
    `1`，结束值为 `5`。我们的 y 是一个包含五个元素的数组，起始值为 `100`，结束值为 `500`。我们定义了两个 `x_label` 和 `y_label`
    列表，它们将作为我们绘图的标签。最后，我们调用了 `x_y_axis_labeling` 函数，目的是演示如何在 *x* 轴和 *y* 轴上标记刻度。
- en: 'Let''s look at the following function:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下以下函数：
- en: '[PRE49]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We will do a simple dot plot by calling pyplot's dot function. However, in this
    case, we want our points to be displayed as `+` instead of `o`. Hence, we will
    specify `+r`. Our color of choice is red, hence `r`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过调用 pyplot 的 dot 函数来绘制简单的点图。然而，在这种情况下，我们希望我们的点显示为 `+` 而不是 `o`。因此，我们将指定 `+r`。我们选择的颜色是红色，因此
    `r`。
- en: 'In the next two lines, we will specify what our x axis and y axis tickers need
    to be. By calling the `xticks` function, we will pass on our x values and their
    labels. In addition, we will say that we want the text to be rotated vertically
    so that they don''t overlap each other. Similarly, we will specify the tickers
    for the *y* axis. Let''s look at our plot, as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的两行中，我们将指定我们的 x 轴和 y 轴的刻度标记。通过调用 `xticks` 函数，我们将传递我们的 x 值及其标签。此外，我们会设置文本垂直旋转，以避免它们重叠。类似地，我们将为
    *y* 轴指定刻度标记。让我们来看一下我们的图表，如下所示：
- en: '![How it works…](img/B04041_02_12.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的…](img/B04041_02_12.jpg)'
- en: 'Let''s see how to generate heat maps using `pyplot`:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用 `pyplot` 生成热图：
- en: '[PRE50]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We will generate some data for our heat map. In this case, we generated a 10
    x 10 matrix filled with values from a normal distribution of a mean specified
    by a `loc` variable of `0.5` and standard deviation specified by a `scale` variable
    of `0.2`. We will invoke the `plot_heat_map` function with this matrix. The second
    parameter is the figure number:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将生成一些数据用于热图。在这个例子中，我们生成了一个 10 x 10 的矩阵，矩阵中的值来自一个正态分布，其均值由 `loc` 变量指定为 `0.5`，标准差由
    `scale` 变量指定为 `0.2`。我们将使用这个矩阵调用 `plot_heat_map` 函数。第二个参数是图形编号：
- en: '[PRE51]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We will call the `pcolor` function in order to generate a heat map. The next
    line invokes the `colorbar` function to display the color gradients for our range
    of values:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将调用 `pcolor` 函数来生成热图。下一行调用了 `colorbar` 函数，用于显示我们值范围的颜色渐变：
- en: '![How it works…](img/B04041_02_13.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的…](img/B04041_02_13.jpg)'
- en: There's more…
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: For more information on matplotlib, you can refer to the general matplotlib
    documentation at [http://matplotlib.org/faq/usage_faq.html](http://matplotlib.org/faq/usage_faq.html).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 matplotlib 的更多信息，你可以参考 matplotlib 的常规文档，网址为 [http://matplotlib.org/faq/usage_faq.html](http://matplotlib.org/faq/usage_faq.html)。
- en: 'The following link is an excellent tutorial on `pyplot`:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 以下链接是关于 `pyplot` 的一个极好的教程：
- en: '[http://matplotlib.org/users/pyplot_tutorial.html](http://matplotlib.org/users/pyplot_tutorial.html)'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://matplotlib.org/users/pyplot_tutorial.html](http://matplotlib.org/users/pyplot_tutorial.html)'
- en: 'Matplotlib provides excellent three-dimensional plotting capabilities. Refer
    to the following link for more information:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Matplotlib 提供了出色的三维绘图功能。有关更多信息，请参考以下链接：
- en: '[http://matplotlib.org/mpl_toolkits/mplot3d/tutorial.html](http://matplotlib.org/mpl_toolkits/mplot3d/tutorial.html)'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://matplotlib.org/mpl_toolkits/mplot3d/tutorial.html](http://matplotlib.org/mpl_toolkits/mplot3d/tutorial.html)'
- en: The pylab module in matplotlib combines the name space of NumPy with `pyplot`.
    Pylab can also be used to generate the various types of plots shown in this recipe.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: matplotlib 中的 pylab 模块将 NumPy 的命名空间与 `pyplot` 结合在一起。Pylab 还可以用来生成本食谱中展示的各种类型的图表。
- en: Machine learning with scikit-learn
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 scikit-learn 进行机器学习
- en: 'Scikit-learn is a versatile machine learning library in Python. We will use
    this library extensively in this book. We used scikit-learn version 0.15.2 for
    all the recipes in this book. In the command line, you can invoke the `__version__`
    attribute to check for the version:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Scikit-learn 是一个多功能的 Python 机器学习库。在本书中，我们将广泛使用这个库。我们在本书中的所有示例中使用了 scikit-learn
    版本 0.15.2。在命令行中，你可以通过调用 `__version__` 属性来检查版本：
- en: '![Machine learning with scikit-learn](img/B04041_02_15.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![使用 scikit-learn 进行机器学习](img/B04041_02_15.jpg)'
- en: Getting ready
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we will demonstrate some of the capabilities of scikit-learn
    and learn about some of their API organization so that we can follow it seamlessly
    in our future recipes.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们将展示scikit-learn的一些功能，并了解它们的API组织方式，以便在未来的例子中能顺利使用它。
- en: How to do it…
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Scikit-learn provides us with an inbuilt dataset. Let''s see how to access
    this dataset and use it:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: Scikit-learn为我们提供了一个内建的数据集。让我们看看如何访问这个数据集并使用它：
- en: '[PRE52]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Let''s proceed with seeing how we can invoke some machine learning functionalities
    in scikit-learn:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续查看如何在scikit-learn中调用一些机器学习功能：
- en: '[PRE53]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: How it works…
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: 'Let''s load the scikit learn library and import the module that contains the
    various functions in order to extract the inbuilt datasets:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们加载scikit-learn库，并导入包含各种函数的模块，以便提取内建数据集：
- en: '[PRE54]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The first dataset that we will look at is the iris dataset. Refer to [https://en.wikipedia.org/wiki/Iris_flower_data_set](https://en.wikipedia.org/wiki/Iris_flower_data_set)
    for more information.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将查看的第一个数据集是iris数据集。欲了解更多信息，请参考[https://en.wikipedia.org/wiki/Iris_flower_data_set](https://en.wikipedia.org/wiki/Iris_flower_data_set)。
- en: 'Introduced by Sir Donald Fisher, this is a classic dataset for a classification
    problem:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 由Sir Donald Fisher引入，这是一个经典的分类问题数据集：
- en: '[PRE55]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The `load_iris` function, when invoked, returns a dictionary object. The predictor
    `x`, response variable `y`, response variable names, and feature names can be
    extracted by querying the dictionary object with the appropriate keys.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`load_iris`函数在调用时，会返回一个字典对象。通过使用适当的键查询字典对象，可以提取出预测变量`x`、响应变量`y`、响应变量名称以及特征名称。'
- en: 'Let''s proceed to print them and see their values:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续打印它们并查看它们的值：
- en: '[PRE56]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '![How it works…](img/B04041_02_16.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理…](img/B04041_02_16.jpg)'
- en: As you can see, our predictors have 150 instances and four attributes. Our `response`
    variable has 150 instances and a class label for each of the rows in our predictor
    set. We will then print out the attribute names, petal and sepal width and length,
    and finally, the class labels. In most of our future recipes, we will use this
    dataset extensively.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们的预测变量有150个实例和四个属性。我们的`响应`变量有150个实例，每个预测实例都有一个类标签。接下来，我们将打印出特征名称——花瓣和萼片的宽度和长度，最后是类标签。在我们未来的大部分例子中，我们将广泛使用这个数据集。
- en: 'Let''s proceed to inspect another inbuilt dataset called the Boston housing
    dataset used in a regression problem:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续检查另一个内建的数据集——波士顿房价数据集，该数据集用于回归问题：
- en: '[PRE57]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The data is loaded pretty much the same as was iris, and the various components
    of the data, including the predictors and response variables, are queried using
    the respective keys from the dictionary. Let''s print these variables in order
    to inspect them:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 数据的加载与iris数据集非常相似，数据的各个组件，包括预测变量和响应变量，都是通过使用字典中的相应键进行查询的。让我们打印这些变量，以便检查它们：
- en: '![How it works…](img/B04041_02_17.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理…](img/B04041_02_17.jpg)'
- en: As you can see, our predictor set x has 506 instances and 13 attributes. Our
    response variable has 506 entries. Finally, we will also print out the names of
    our attributes.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们的预测变量集`x`有506个实例和13个特征。我们的响应变量有506个条目。最后，我们还将打印出特征名称。
- en: 'Scikit-learn also provides us with functions that will help us produce a random
    classification dataset with some desired properties:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: Scikit-learn还为我们提供了帮助我们生成具有某些期望属性的随机分类数据集的函数：
- en: '[PRE58]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The `make_classification` function is a function that can be used to generate
    a classification dataset. In our example, we generated a dataset with 50 instances
    that are dictated by the `n_samples` parameter, five attributes, `n_features`
    parameters, and two classes set by the `n_classes` parameter. Let''s inspect the
    output of this function:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`make_classification`函数是一个可以用来生成分类数据集的函数。在我们的例子中，我们生成了一个包含50个实例的数据集，其中实例数由`n_samples`参数决定，特征数由`n_features`参数决定，类别数由`n_classes`参数设置。让我们检查该函数的输出：'
- en: '[PRE59]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '![How it works…](img/B04041_02_18.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理…](img/B04041_02_18.jpg)'
- en: As you can see, our predictor x has 150 instances with five features. Our response
    variable has 150 instances, with a class label for each of the prediction instances.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们的预测变量`x`有150个实例和五个特征。我们的响应变量有150个实例，每个预测实例都有一个类标签。
- en: We will print out the second record in our predictor set, `x`. You can see that
    we have a vector of dimension `5`, relating to the five features that we requested.
    Finally, we will also print the response variable, `y`. For the second row of
    our predictors, the class label is `1`.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将打印出预测变量集 `x` 中的第二条记录。你可以看到，我们有一个维度为 `5` 的向量，表示我们请求的五个特征。最后，我们还将打印出响应变量 `y`。对于我们预测变量集中的第二行，类标签为
    `1`。
- en: 'Scikit-learn also provides us with the functions that can generate data with
    nonlinear relationships:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: Scikit-learn 还为我们提供了能够生成具有非线性关系的数据的函数：
- en: '[PRE60]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'You should be familiar with `pyplot` now from the previous recipe. Let''s see
    our plot first to understand the nonlinear relationship:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该已经熟悉了前一个示例中的 `pyplot`。让我们先看看我们的图表，以便理解非线性关系：
- en: '![How it works…](img/B04041_02_19.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的…](img/B04041_02_19.jpg)'
- en: As you can see, our classification has produced two concentric circles. Our
    `x` is a dataset with two variables. Variable `y` is the class label. As shown
    by the concentric circle, the relationship between our prediction variable is
    nonlinear.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们的分类结果生成了两个同心圆。我们的 `x` 是一个包含两个变量的数据集。变量 `y` 是类标签。正如同心圆所示，我们的预测变量之间的关系是非线性的。
- en: 'Another interesting function to produce a nonlinear relationship is `make_moons`
    from scikit-learn:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的函数来生成非线性关系是 scikit-learn 中的 `make_moons`：
- en: '[PRE61]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Let''s look at its plot in order to understand the nonlinear relationship:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过查看其图表来理解非线性关系：
- en: '![How it works…](img/B04041_02_20.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的…](img/B04041_02_20.jpg)'
- en: The crescent-shaped plot shows that the attributes in our predictor set x are
    nonlinearly related to each other.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 弯月形的图表显示了我们的预测变量集 `x` 中的属性是非线性相关的。
- en: Let's switch gears to understand the API structure of scikit-learn. One of the
    major advantages of using scikit-learn is its clean API structure. All the data
    modeling classes deriving from the `BaseEstimator` class have to strictly implement
    the `fit` and `transform` functions. We will see some examples to learn more about
    this.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们换个角度来理解 scikit-learn 的 API 结构。使用 scikit-learn 的一个主要优势是它干净的 API 结构。所有从
    `BaseEstimator` 类派生的数据建模类都必须严格实现 `fit` 和 `transform` 函数。我们将通过一些例子进一步了解这一点。
- en: 'Let''s start with the preprocessing module in scikit-learn:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 scikit-learn 的预处理模块开始：
- en: '[PRE62]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'We will use the `PolynomialFeatures` class in order to demonstrate the ease
    of using scikit-learn''s SDK. Refer to the following link for polynomials:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `PolynomialFeatures` 类来展示使用 scikit-learn SDK 的简便性。有关多项式的更多信息，请参见以下链接：
- en: '[https://en.wikipedia.org/wiki/Polynomial](https://en.wikipedia.org/wiki/Polynomial)'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://zh.wikipedia.org/wiki/多项式](https://zh.wikipedia.org/wiki/Polynomial)'
- en: 'With a set of predictor variables, we may want to add some more variables to
    our predictor set in order to see if our model accuracy can be improved. We can
    use the polynomials of the existing features as a new feature. The `PolynomialFeatures`
    class helps us do this:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一组预测变量，我们可能想要添加更多的变量到预测集，以查看我们的模型准确度是否能够提高。我们可以使用现有特征的多项式作为新特征。`PolynomialFeatures`
    类可以帮助我们做到这一点：
- en: '[PRE63]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'We will first create a dataset. In this case, our dataset has two instances
    and two attributes:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建一个数据集。在此情况下，我们的数据集包含两个实例和两个属性：
- en: '[PRE64]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'We will proceed to instantiate our `PolynomialFeatures` class with the required
    degree of polynomials. In this case, it will be a second degree:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续实例化 `PolynomialFeatures` 类，并设置所需的多项式的阶数。在此情况下，我们选择的是二阶多项式：
- en: '[PRE65]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Then, there are two functions, fit and transform. The `fit` function is used
    to do the necessary calculations for the transformation. In this case, fit is
    redundant, but we will see some more examples of how fit is used later in this
    recipe.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，有两个函数，`fit` 和 `transform`。`fit` 函数用于执行转换所需的计算。在此情况下，`fit` 是多余的，但稍后我们将看到更多
    `fit` 函数使用的例子。
- en: 'The `transform` function takes the input and, based on the calculations performed
    by fit, transforms the given input:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`transform` 函数接收输入，并根据 `fit` 执行的计算来转换给定的输入：'
- en: '[PRE66]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Alternatively, in this case, fit and transform can be called in one shot. Let''s
    look at the value and shape of our original and transformed x variable:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，在这种情况下，`fit` 和 `transform` 可以一次性调用。让我们看看原始 `x` 变量和转换后 `x` 变量的值和形状：
- en: '![How it works…](img/B04041_02_22.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的…](img/B04041_02_22.jpg)'
- en: 'Any class that implements a machine learning method in scikit-learn has to
    deliver from BaseEstimator. See the following link for BaseEstimator:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在 scikit-learn 中，任何实现机器学习方法的类都必须继承自 BaseEstimator。请参阅以下链接了解 BaseEstimator：
- en: '[http://scikit-learn.org/stable/modules/generated/sklearn.base.BaseEstimator.html](http://scikit-learn.org/stable/modules/generated/sklearn.base.BaseEstimator.html)'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://scikit-learn.org/stable/modules/generated/sklearn.base.BaseEstimator.html](http://scikit-learn.org/stable/modules/generated/sklearn.base.BaseEstimator.html)'
- en: BaseEstimator expects that the implementation class provides both the `fit`
    and `transform` methods. This way the API is kept very clean.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: BaseEstimator 期望实现类提供 `fit` 和 `transform` 方法。这样可以保持 API 的简洁。
- en: 'Let''s see another example. Here, we imported a class called `DecisionTreeClassifier`
    from the module tree. `DecisionTreeClassifier` implements the decision tree algorithm:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看另一个例子。这里，我们从树模块中导入了一个名为 `DecisionTreeClassifier` 的类。`DecisionTreeClassifier`
    实现了决策树算法：
- en: '[PRE67]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Let''s put this class into action:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这个类付诸实践：
- en: '[PRE68]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Let's use the iris dataset to see how the tree algorithm can be used. We will
    load the iris dataset in the `x` and `y` variables. We will then instantiate `DecisonTreeClassifier`.
    We will proceed to build the model by invoking the `fit` function and passing
    our `x predictor` and `y response` variable. This will build the tree model. Now,
    we are ready with our model to do some predictions. We will use the `predict`
    function in order to predict the class labels for the given input. As you can
    see, we leveraged the same fit and predict method as in `PolynomialFeatures`.
    There are two other methods, `predict_proba`, which gives the probability of the
    prediction, and `predict_log_proba`, which provides the logarithm of the prediction
    probability.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用鸢尾花数据集来看看决策树算法如何应用。我们将在 `x` 和 `y` 变量中加载鸢尾花数据集。接下来，我们将实例化 `DecisionTreeClassifier`。然后通过调用
    `fit` 函数，并传入我们的 `x 预测变量` 和 `y 响应变量`，来构建模型。这将构建出决策树模型。现在，我们已经准备好模型进行预测。我们将使用 `predict`
    函数来预测给定输入的类别标签。如你所见，我们使用了与 `PolynomialFeatures` 中相同的 `fit` 和 `predict` 方法。还有两个其他方法，`predict_proba`，它给出预测的概率，以及
    `predict_log_proba`，它提供预测概率的对数值。
- en: 'Let''s now see another interesting utility called pipe lining. Various machine
    learning methods can be chained together using pipe lining:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一个有趣的工具叫做管道（pipe lining）。不同的机器学习方法可以通过管道链式连接在一起：
- en: '[PRE69]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Let''s start by instantiating the data processing routines, `PolynomialFeatures`
    and `DecisionTreeClassifier`:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从实例化数据处理例程 `PolynomialFeatures` 和 `DecisionTreeClassifier` 开始：
- en: '[PRE70]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'We will define a list of tuples to indicate the order of our chaining. We want
    to run the polynomial feature generation, followed by our decision tree:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将定义一个元组列表来表示我们的链式操作顺序。我们希望先运行多项式特征生成，然后是决策树：
- en: '[PRE71]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: We can now instantiate our Pipeline object with the list declared using the
    steps variable. Now, we can proceed to do business as usual by calling the `fit`
    and `predict` methods.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过使用 `steps` 变量声明的列表来实例化我们的 Pipeline 对象。接下来，我们可以像往常一样通过调用 `fit` 和 `predict`
    方法继续进行业务操作。
- en: 'We can invoke the `named_steps` attribute in order to inspect the models in
    the various stages of our pipeline:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以调用 `named_steps` 属性来检查管道各个阶段的模型：
- en: '![How it works…](img/B04041_02_21.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的…](img/B04041_02_21.jpg)'
- en: There's more…
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容…
- en: 'There are a lot more dataset creation functions available in scikit-learn.
    Refer to the following link:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在 scikit-learn 中有许多其他数据集创建函数。请参考以下链接：
- en: '[http://scikit-learn.org/stable/datasets/](http://scikit-learn.org/stable/datasets/)'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://scikit-learn.org/stable/datasets/](http://scikit-learn.org/stable/datasets/)'
- en: 'While creating nonlinear datasets using `make_circle` and `make_moons`, we
    mentioned that a lot of desired properties can be added to the dataset. The data
    can be corrupted slightly by inducing incorrect class labels. Refer to the following
    link for a list of options that are available in order to introduce such nuances
    in the data:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `make_circle` 和 `make_moons` 创建非线性数据集时，我们提到可以为数据集添加很多期望的属性。通过引入不正确的类别标签，数据可能会稍微被污染。请参考以下链接，了解可以引入这些细微变化的数据选项：
- en: '[http://scikit-learn.org/stable/modules/generated/sklearn.datasets.make_circles.html](http://scikit-learn.org/stable/modules/generated/sklearn.datasets.make_circles.html)'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://scikit-learn.org/stable/modules/generated/sklearn.datasets.make_circles.html](http://scikit-learn.org/stable/modules/generated/sklearn.datasets.make_circles.html)'
- en: '[http://scikit-learn.org/stable/modules/generated/sklearn.datasets.make_moons.html](http://scikit-learn.org/stable/modules/generated/sklearn.datasets.make_moons.html)'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://scikit-learn.org/stable/modules/generated/sklearn.datasets.make_moons.html](http://scikit-learn.org/stable/modules/generated/sklearn.datasets.make_moons.html)'
- en: See also
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: '*Plotting* recipe in [Chapter 2](ch02.xhtml "Chapter 2. Python Environments"),
    *Working with Python Environments*'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第2章](ch02.xhtml "第2章。Python 环境")中的*绘图*教程，*使用 Python 环境*'
