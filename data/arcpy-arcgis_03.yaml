- en: Chapter 3. Creating the First Python Script
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。创建第一个Python脚本
- en: Now that we have Python configured to fit our needs, we can create Python scripts.
    This chapter will explore how to use ArcGIS **ModelBuilder** to model a simple
    analysis as the basis for our script. ModelBuilder is very useful on its own and
    for creating Python scripts as it has an operational and a visual component, and
    all models can be outputted as Python scripts. This will allow us to compare how
    the more familiar ModelBuilder utilizes tools in the ArcToolbox to how Python
    handles the same tools. We will also discuss iteration and when it is best to
    use Python over ModelBuilder.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将Python配置得符合我们的需求，我们可以创建Python脚本。本章将探讨如何使用ArcGIS **ModelBuilder**来建模一个简单的分析作为脚本的基础。ModelBuilder本身非常有用，并且对于创建Python脚本也非常有用，因为它具有操作和可视化组件，并且所有模型都可以输出为Python脚本。这将使我们能够比较更熟悉的ModelBuilder如何利用ArcToolbox中的工具与Python如何处理相同的工具。我们还将讨论迭代以及在何时使用Python而不是ModelBuilder最佳。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Modeling a simple analysis using ModelBuilder
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用ModelBuilder建模简单分析
- en: Exporting the model out to a Python script
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将模型导出到Python脚本
- en: Prerequisites
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前提条件
- en: '"Along with ArcGIS ModelBuilder, a data set and scripts are required."'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: “除了ArcGIS ModelBuilder外，还需要数据集和脚本。”
- en: For this chapter, the accompanying data and scripts should be downloaded from
    Packt Publishing's website. The completed scripts are available for comparison
    purposes and the data will be used for this chapter's analysis.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，相关的数据和脚本应从Packt Publishing的网站下载。完成的脚本可用于比较目的，数据将用于本章的分析。
- en: ModelBuilder
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ModelBuilder
- en: ArcGIS has been in development since the 1970s. During that time, it included
    a variety of programming languages and tools to help GIS analysts automate analyses
    and map production. These include the Avenue scripting language in the ArcGIS
    3x series and the **ARC Macro Language** (**AML**) in the ARC/Info workstation
    days, as well as VBScript up until ArcGIS 10x when Python was introduced. Another
    useful tool introduced in ArcGIS 9x was ModelBuilder, a visual programming environment
    used for both modeling analysis and creating tools that can be used repeatedly
    with different input feature classes.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: ArcGIS自1970年代以来一直在开发中。在这段时间里，它包含各种编程语言和工具，以帮助GIS分析师自动化分析和地图制作。这些包括ArcGIS 3x系列中的Avenue脚本语言以及ARC/Info工作站时代的**ARC宏语言（AML**），以及直到ArcGIS
    10x时的VBScript，当时引入了Python。ArcGIS 9x中引入的另一项有用工具是ModelBuilder，这是一个用于建模分析和创建可重复使用不同输入要素类的工具的可视化编程环境。
- en: Another useful feature of ModelBuilder is an export function that allows modelers
    to create Python scripts directly from a model. This will make it easier to compare
    how inputs in a ModelBuilder tool are accepted versus how a Python script calls
    the same tool and supplies the inputs to it, or how the feature classes that are
    created are named and placed within the file structure. ModelBuilder is a fantastic
    tool that will make it easy for a GIS analyst to bridge the gap from normal GIS
    workflows to automated Python-based workflows.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: ModelBuilder的另一个有用功能是导出功能，允许模型师直接从模型创建Python脚本。这将使比较ModelBuilder工具中的输入如何被接受与Python脚本如何调用同一工具并向其提供输入，或者创建的要素类如何命名和放置在文件结构中变得更加容易。ModelBuilder是一个出色的工具，它将使GIS分析师轻松地从常规GIS工作流程过渡到基于Python的自动化工作流程。
- en: Creating a model and exporting to Python
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建模型并导出到Python
- en: This chapter will depend on the downloadable `SanFrancisco.gdb` file geodatabase,
    available from the Packt Publishing website. The San Francisco GDB contains data
    downloaded from [data.sfgov.org](http://data.sfgov.org) and the US Census' American
    Factfinder website available at [factfinder2.census.gov](http://factfinder2.census.gov).
    All census and geographic data included in the geodatabase is from the 2010 census.
    The data is contained within a feature dataset called **SanFrancisco**. The data
    in this feature dataset is in NAD 83 California State Plane Zone 3 and the linear
    unit of measure is the US Foot (this corresponds to SRID 2227 in the European
    Petroleum Survey Group, or EPSG, format).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将依赖于可从Packt Publishing网站下载的`SanFrancisco.gdb`文件地理数据库。旧金山GDB包含从[data.sfgov.org](http://data.sfgov.org)和位于[factfinder2.census.gov](http://factfinder2.census.gov)的美国人口普查局的美国事实查找网站下载的数据。地理数据库中包含的所有人口普查和地理数据均来自2010年人口普查。数据包含在名为**SanFrancisco**的要素数据集中。该要素数据集中的数据位于NAD
    83加利福尼亚州平面坐标系3区，线性度量单位为美国英尺（这对应于欧洲石油调查组，或EPSG，格式中的SRID 2227）。
- en: The analysis we will create with the model, and eventually export to Python
    for further refinement, will use bus stops along a specific line in San Francisco.
    These bus stops will be buffered to create a representative region around each
    bus stop. The buffered areas will then be intersected with census blocks to find
    out how many people are within each representative region around the bus stops.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用模型创建的分析，并将其最终导出到Python中进行进一步优化，将使用旧金山的特定线路上的公交车站。这些公交车站将被缓冲以创建每个公交车站周围的代表性区域。然后，这些缓冲区域将与人口普查区相交，以找出每个代表性区域周围有多少人。
- en: Modeling the Select and Buffer tools
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 建模选择和缓冲工具
- en: 'Using ModelBuilder, we will first model the basis of the bus stop analysis.
    Once it has been modeled, it will be exported as an automatically generated Python
    script. Follow these steps to begin the analysis:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模型构建器，我们首先将构建公交车站分析的基础模型。一旦建模完成，它将被导出为自动生成的Python脚本。按照以下步骤开始分析：
- en: Open up **ArcCatalog** and create a folder connection to the folder containing
    `SanFrancisco.gdb`. Right-click on geodatabase and add a new toolbox called **Chapter3Tools**.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**ArcCatalog**并创建一个文件夹连接到包含`SanFrancisco.gdb`的文件夹。右键单击地理数据库，添加一个名为**Chapter3Tools**的新工具箱。
- en: Next, open **ModelBuilder** and create a Model, saving it in the **Chapter3Tools**
    toolbox as **Chapter3Model1.**
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，打开**模型构建器**并创建一个模型，将其保存在**Chapter3Tools**工具箱中，命名为**Chapter3Model1**。
- en: Drag the **Bus_Stops** feature class and the **Select** tool from the **Analysis/Extract**
    toolset in **ArcToolbox**.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**ArcToolbox**中的**分析/提取**工具集拖动**Bus_Stops**要素类和**选择**工具。
- en: Open the **Select** tool and name the output feature class `Inbound71`. Make
    sure that the feature class is written to the **Chapter3Results** feature dataset
    into the model.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**选择**工具，并将输出要素类命名为`Inbound71`。确保要素类被写入到**Chapter3Results**要素数据集中。
- en: 'Open the **Expression** SQL Query Builder and create the following SQL expression:
    **NAME = ''71 IB'' AND BUS_SIGNAG = ''Ferry Plaza''**.![Modeling the Select and
    Buffer tools](img/8662OS_03_01.jpg)'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**表达式**SQL查询构建器，创建以下SQL表达式：**NAME = '71 IB' AND BUS_SIGNAG = 'Ferry Plaza'**。![建模选择和缓冲工具](img/8662OS_03_01.jpg)
- en: The next step is to add a **Buffer** tool from the **Analysis/Proximity** toolset.
    The **Buffer** tool will be used to create buffers around each bus stop. The buffered
    bus stops allow us to intersect with census data in the form of census blocks,
    creating the representative regions around each bus stop.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是添加来自**分析/邻近**工具集的**缓冲**工具。**缓冲**工具将用于创建每个公交车站周围的缓冲区。缓冲的公交车站允许我们与以人口普查区形式的人口普查数据进行交集，从而创建每个公交车站周围的代表性区域。
- en: Connect the output of the **Select** tool (**Inbound71**) to the **Buffer**
    tool. Open up the **Buffer** tool and add 400 to the **Distance** field, and make
    the units **Feet**. Leave the rest of the options blank. Click on **OK** and return
    to the model.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**选择**工具的输出（**Inbound71**）连接到**缓冲**工具。打开**缓冲**工具，并将400添加到**距离**字段，单位为**英尺**。其余选项留空。点击**确定**并返回模型。
- en: '![Modeling the Select and Buffer tools](img/8662OS_03_02.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![建模选择和缓冲工具](img/8662OS_03_02.jpg)'
- en: Adding the Intersect tool
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加**交集**工具
- en: 'Now that we have selected the bus line of interest, and buffered the stops
    to create representative regions, we will need to intersect the regions with the
    census blocks to find the population of each representative region:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经选择了感兴趣的公交线路，并将车站缓冲以创建代表性区域，我们需要将这些区域与人口普查区相交，以找出每个代表性区域的居民人数：
- en: First, add the **CensusBlocks2010** feature class from the **SanFrancisco**
    feature dataset to the model.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将**CensusBlocks2010**要素类从**SanFrancisco**要素数据集添加到模型中。
- en: Next, add the **Intersect** tool, located in the **Analysis/Overlay** toolset
    in **ArcToolbox**. While we could use **Spatial Join** to achieve a similar result,
    I am using the **Intersect** tool to capture the area of intersect for use later
    in the model and script.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加位于**ArcToolbox**中**分析/叠加**工具集的**交集**工具。虽然我们可以使用**空间连接**来实现类似的结果，但我使用**交集**工具来捕获交集区域，以便在模型和脚本中稍后使用。
- en: 'At this point, our model should look like this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的模型应该看起来像这样：
- en: '![Adding the Intersect tool](img/8662OS_03_03.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![添加交集工具](img/8662OS_03_03.jpg)'
- en: Tallying the analysis results
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 统计分析结果
- en: After we created this simple analysis, the next step is to determine the results
    for each bus stop. Finding the number of people that live in census blocks touched
    by the 400 feet buffer of each bus stop involves examining each row of data in
    the final feature class and selecting rows that correspond to the bus stop. Once
    these are selected, a sum of the selected rows would be calculated either using
    the **Field Calculator** or the **Summarize** tool. All of these methods will
    work, and yet none are perfect. They take too long, and worse, are not repeatable
    automatically if an assumption in the model is adjusted (if the buffer is adjusted
    from 400 feet to 500 feet, for instance).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建了这个简单的分析之后，下一步是确定每个公交车站的结果。找出受每个公交车站400英尺缓冲区影响的普查区中居住的人数，需要检查最终要素类中的每一行数据，并选择与公交车站对应的行。一旦这些行被选中，就可以使用
    **字段计算器** 或 **汇总** 工具计算选中行的总和。所有这些方法都可行，但都不是完美的。它们花费的时间太长，更糟糕的是，如果模型中的假设被调整（例如，缓冲区从400英尺调整为500英尺），则这些方法无法自动重复。
- en: This is where the traditional uses of ModelBuilder begin to fail analysts. It
    should be easy to instruct the model to select all rows associated with each bus
    stop, and then generate a summed population figure for each bus stop's representative
    region. It would be even better to have the model create a spreadsheet to contain
    the final results of the analysis. It's time to use Python to take this analysis
    to the next level.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是传统使用 ModelBuilder 的方式开始让分析师感到失败的地方。应该很容易指示模型选择与每个公交车站相关的所有行，并为每个公交车站的代表区域生成人口总和。如果模型能够创建一个包含分析最终结果的电子表格就更好了。现在是时候使用
    Python 将这一分析提升到下一个层次了。
- en: Exporting the model and adjusting the script
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导出模型并调整脚本
- en: While modeling analysis in ModelBuilder has its drawbacks, there is one fantastic
    option built into ModelBuilder; the ability to create a model and then export
    the model to Python. Along with the ArcGIS help documentation, it is the best
    way to discover the correct Python syntax to use when writing ArcPy scripts.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 ModelBuilder 中的建模分析有其缺点，但 ModelBuilder 中内置了一个非常棒的功能；即创建模型并将其导出到 Python 的能力。结合
    ArcGIS 帮助文档，这是发现编写 ArcPy 脚本时应该使用正确 Python 语法的最有效方法。
- en: Create a folder that can hold the exported scripts next to the **SanFrancisco**
    geodatabase (for example, `C:\Projects\Scripts`). This will hold both the exported
    scripts that ArcGIS automatically generates, and the versions that we will build
    from those generated scripts.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **SanFrancisco** 地数据库旁边创建一个可以存放导出脚本的文件夹（例如，`C:\Projects\Scripts`）。这将包含 ArcGIS
    自动生成的导出脚本，以及我们将从这些生成的脚本中构建的版本。
- en: Open the model called **Chapter3Model1** and click on the **Model** menu in
    the upper left. Select **Export** from the menu, and then select **To Python Script**.
    Save the script in the script folder as `Chapter3Model1.py`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 打开名为 **Chapter3Model1** 的模型，并在左上角的 **模型** 菜单中点击。从菜单中选择 **导出**，然后选择 **导出到 Python
    脚本**。将脚本保存在脚本文件夹中，命名为 `Chapter3Model1.py`。
- en: Note
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that there is also the option to export the model as a graphic. Creating
    a graphic of the model is a good way to share what the model is doing with other
    analysts without the need to share the model and the data, and can also be useful
    when sharing Python scripts as well.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，还有将模型导出为图形的选项。创建模型的图形是一个很好的方法，可以在不共享模型和数据的情况下与其他分析师分享模型正在做什么，当共享 Python 脚本时也很有用。
- en: The automatically generated script
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动生成的脚本
- en: 'Open the automatically generated script in an IDE. It should look like this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在 IDE 中打开自动生成的脚本。它应该看起来像这样：
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let''s examine this script line by line. The first line is preceded by a pound
    sign (#), which again means that this line is a comment; however, it is not ignored
    by the Python interpreter when the script is executed as usual but is used to
    help Python interpret the encoding of the script as described here: [http://legacy.python.org/dev/peps/pep-0263](http://legacy.python.org/dev/peps/pep-0263).'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行检查这个脚本。第一行前面有一个井号（#），这意味着这一行是一个注释；然而，当脚本按常规执行时，Python 解释器不会忽略这一行，而是用它来帮助
    Python 解释脚本编码，如这里所述：[http://legacy.python.org/dev/peps/pep-0263](http://legacy.python.org/dev/peps/pep-0263)。
- en: The second commented line and the third line are included for decorative purposes.
    The next four lines, all commented, are used to provide readers with information
    about the script, what it is called and when it was created, along with a description
    that is pulled from the model's properties. Another decorative line is included
    to separate out the informative header from the body of the script visually. While
    the commented information section is nice to include in a script for other users
    of the script, it is not necessary.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行注释和第三行注释是为了装饰目的。接下来的四行注释（全部注释）用于向读者提供有关脚本的信息，包括脚本的名称和创建时间，以及从模型属性中提取的描述。还包含了一行装饰性注释，用于在视觉上将信息性标题与脚本的主体分开。虽然将注释信息包含在脚本中供其他脚本用户使用是友好的，但并非必需。
- en: The body of the script, or the executable portion of the script, starts with
    the `import arcpy` line. Import statements are, by convention, included at the
    top of the body of the script. In this instance, the only module that is being
    imported is ArcPy.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本的主体或脚本的执行部分从`import arcpy`行开始。按照惯例，导入语句包含在脚本主体的顶部。在这种情况下，只导入了ArcPy模块。
- en: ModelBuilder's export function creates not only an executable script, but also
    comments each section to help mark the different sections of the script. The comments
    let the user know where the variables are located and where the ArcToolbox tools
    are being executed. The comments will grow to be superfluous as the reader grows
    to understand the code, but it was nice of ESRI to include the comments.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: ModelBuilder的导出功能不仅创建了一个可执行脚本，还为每个部分添加了注释，以帮助标记脚本的各个部分。这些注释让用户知道变量所在的位置以及ArcToolbox工具正在执行的位置。随着读者对代码的理解加深，注释可能会变得多余，但ESRI包含这些注释是很友好的。
- en: Below the import statements are the variables. In this case, the variables represent
    the file paths to the input and output feature classes. The variable names are
    derived from the names of the feature classes (the base names of the file paths).
    The file paths are assigned to the variables using the assignment operator (=),
    and the parts of the file paths are separated by two backslashes.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在导入语句下方是变量。在这种情况下，变量代表输入和输出要素类的文件路径。变量名称是从要素类的名称（文件路径的基本名称）派生出来的。文件路径通过赋值运算符（=）分配给变量，文件路径的部分通过两个反斜杠分隔。
- en: File paths in Python
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python中的文件路径
- en: It would be good to review how file paths are used in Python compared to how
    they are represented in Windows. In Python, file paths are strings, and strings
    in Python have special characters used to represent tabs (\t), newlines (\n),
    or carriage returns (\r), among many others. These special characters all incorporate
    single backslashes, making it very hard to create a file path that uses single
    backslashes. This would not be a big deal, except that file paths in Windows Explorer
    all use single backslashes.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 很好地回顾一下在Python中与在Windows中表示方式相比，文件路径的使用方式。在Python中，文件路径是字符串，Python中的字符串有特殊字符用于表示制表符（\t）、换行符（\n）或回车符（\r），以及其他许多字符。这些特殊字符都包含单个反斜杠，这使得创建使用单个反斜杠的文件路径变得非常困难。这本来不是什么大问题，但是Windows资源管理器中的文件路径全部使用单个反斜杠。
- en: 'There are a number of methods used to avoid this issue. Python was developed
    within the Linux environment, where file paths have forward slashes. This more
    Pythonic representation is also available when using Python in a Windows environment,
    demonstrated as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方法可以避免这个问题。Python是在Linux环境中开发的，那里的文件路径使用正斜杠。这种更符合Python风格的表示方式在Windows环境中使用Python时也是可用的，如下所示：
- en: '[PRE1]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Within a Python script, the file path with the forward slashes will work, while
    the Windows Explorer version might cause the script to throw an exception.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python脚本中，使用正斜杠的文件路径将正常工作，而Windows资源管理器版本可能会使脚本抛出异常。
- en: 'Another method used to avoid the issue with special characters is the one employed
    by ModelBuilder when it automatically creates the Python scripts from a model.
    In this case, the backslashes are escaped using a second backslash. The preceding
    script uses this second method to produce the following results:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 避免特殊字符问题的另一种方法是ModelBuilder在从模型自动创建Python脚本时使用的方法。在这种情况下，反斜杠是通过使用第二个反斜杠来转义的。前面的脚本使用第二种方法产生了以下结果：
- en: '[PRE2]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The third method, which I prefer, is to create what is known as a raw string.
    This is the same as a regular string, but it includes an **r** before the script
    begins. This r alerts the Python Interpreter that the following script does not
    contain any special characters or escape characters. Here is an example of how
    it is used:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个方法，我比较喜欢，是创建一个所谓的原始字符串。这与常规字符串相同，但在脚本开始前包含一个**r**。这个**r**会通知Python解释器，接下来的脚本不包含任何特殊字符或转义字符。以下是一个使用示例：
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Using raw strings will make it easier to grab a file path from Windows Explorer
    and add it to a string inside a script. It will also make it easier to avoid accidentally
    forgetting to include a set of double backslashes in a file path, which happens
    all the time and is the cause of many script bugs.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 使用原始字符串将使从Windows资源管理器获取文件路径并将其添加到脚本中的字符串内变得更加容易。它还将使避免在文件路径中意外忘记包含一组双反斜杠变得更加容易，这种情况经常发生，是许多脚本错误的原因。
- en: 'Continuing the script analysis: the ArcPy tools'
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继续分析脚本：ArcPy工具
- en: 'The next, and most important, section of the script is where the analysis is
    executed. The same tools that we created in the model, the **Select**, the **Buffer**,
    and the **Intersect** tools, are included in this section. The same parameters
    that we supplied in the model are also included here: the inputs and outputs,
    plus the SQL statement in the Select tool, and the buffer distance in the **Buffer**
    tool.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个，也是最重要的脚本部分是执行分析的地方。在这个部分中包含了我们在模型中创建的工具，即**Select**、**Buffer**和**Intersect**工具。模型中提供的相同参数也包含在这里：输入和输出，以及Select工具中的SQL语句和Buffer工具中的缓冲距离。
- en: 'The tool parameters are supplied to the tools in the script in the same order
    as they appear in the tool interfaces in the model. Here is the **Select** tool
    in the script:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 工具参数按照在模型工具界面中出现的顺序提供给脚本中的工具。以下是脚本中的**Select**工具：
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'It works like this. The arcPy module has a method, or a special property, called
    `Select_analysis`. This method, when called, requires three parameters: the input
    feature class (or shapefile), the output feature class, and the SQL statement.
    In this example, the input is represented by the variable `Bus_Stops` and the
    output feature class is represented by the variable `Inbound71`, both of which
    are defined in the variable section. The SQL statement is included as the third
    parameter. Note that it could also be represented by a variable, if the variable
    was defined above this line; the SQL statement, as a string, could be assigned
    to a variable and the variable could replace the SQL statement as the third parameter.
    Here is an example of parameter replacement using a variable:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 它的工作原理是这样的。arcPy模块有一个名为`Select_analysis`的方法或特殊属性。当调用此方法时，需要三个参数：输入要素类（或shapefile）、输出要素类和SQL语句。在这个例子中，输入由变量`Bus_Stops`表示，输出要素类由变量`Inbound71`表示，这两个变量都在变量部分定义。SQL语句作为第三个参数包含在内。请注意，如果变量在上文定义，它也可以表示为变量；作为字符串的SQL语句可以分配给变量，然后变量可以替换SQL语句作为第三个参数。以下是一个使用变量替换参数的示例：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: While ModelBuilder is good about assigning input and output feature classes
    to variables, it does not assign variables to every portion of the parameter.
    This will be an important thing to correct when we adjust and build our own scripts.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然ModelBuilder在将输入和输出要素类分配给变量方面做得很好，但它不会将变量分配给参数的每个部分。当我们调整和构建自己的脚本时，这将是一个重要的纠正点。
- en: The **Buffer** tool accepts a similar set of parameters as the **Select** tool.
    There is an input feature class represented by a variable, an output feature class
    variable, and the distance that we provided (400 feet in this case), along with
    a series of parameters that are supplied by default. Note that the parameters
    rely on keywords, and these key words can be adjusted within the text of the script
    to adjust the resulting buffer output. For instance, Feet could be adjusted to
    Meters and the buffer would much larger. Check the help section of the tool to
    better understand how the other parameters will affect the buffer and to find
    the key words arguments that will be accepted by the **Buffer** tool in ArcPy.
    Also, as noted earlier, all of the parameters could be assigned to variables,
    which can save time if the same parameters are used repeatedly throughout a script.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**Buffer** 工具接受与 **Select** 工具相似的参数集。它有一个由变量表示的输入要素类，一个输出要素类变量，以及我们提供的距离（在这个例子中是400英尺），以及一系列默认提供的参数。请注意，这些参数依赖于关键字，并且这些关键字可以在脚本的文本中调整，以调整最终的缓冲输出。例如，英尺可以调整为米，缓冲区会更大。请查看工具的帮助部分，以更好地了解其他参数将如何影响缓冲区，以及ArcPy中**Buffer**工具将接受的键词参数。此外，如前所述，所有参数都可以分配给变量，如果在脚本中重复使用相同的参数，这可以节省时间。'
- en: 'Sometimes the supplied parameter is merely an empty string, as is the case
    here with the last parameter:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 有时提供的参数只是一个空字符串，就像这里最后一个参数的情况：
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The empty string, which in this case signifies that there is not a dissolve
    field for this buffer, is found quite frequently within ArcPy. It could also be
    represented by two single quotes, but ModelBuilder has been built to use double
    quotes to encase strings.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 空字符串，在这种情况下表示这个缓冲区没有溶解字段，在ArcPy中非常常见。它也可以用两个单引号表示，但ModelBuilder已经被构建为使用双引号来包含字符串。
- en: The Intersect tool and string manipulation
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**Intersect** 工具和字符串操作'
- en: The last tool, the Intersect tool, uses a different method to represent the
    files that need to be intersected together when the tool is executed. Because
    the tool accepts multiple files in the input section (meaning there is no limit
    to the number of files that can be intersected together in one operation), it
    stores all of the file paths within one string. The string uses the hash or pound
    sign (#) to separate the file paths within the input string. This slight deviation
    must be dealt with if we are to use the Intersect tool in a Script tool. If we
    are building a tool from this script, we will not know the files that will be
    intersected before they are run, so we need to know the methods to deal with inserting
    variables into strings.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个工具，**Intersect** 工具，在工具执行时使用不同的方法来表示需要相交的文件。因为这个工具接受输入部分中的多个文件（这意味着在一个操作中可以相交的文件数量没有限制），它将所有文件路径存储在一个字符串中。这个字符串使用井号或磅号（#）来分隔输入字符串中的文件路径。如果我们想在脚本工具中使用**Intersect**工具，我们必须处理这种轻微的偏差。如果我们从这个脚本构建一个工具，我们将在它们运行之前不知道将要相交的文件，因此我们需要了解将变量插入字符串的方法。
- en: There are three methods to insert variables into strings. Each method has different
    advantages and disadvantages of a technical nature. It's good to know about all
    three of them as they have uses beyond our needs here, so let's review them.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种方法可以将变量插入到字符串中。每种方法都有其技术上的优缺点。了解这三种方法都很好，因为它们的应用范围超出了我们在这里的需求，所以让我们来回顾一下。
- en: The string manipulation method 1–string addition
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串操作方法1-字符串相加
- en: 'String addition is an odd concept at first as it would not seem possible to
    add strings together, unlike integers or floats, which are numbers. However, within
    Python and other programming languages, this is a normal step. Using the plus
    sign (+), strings are added together to make longer strings or allow variables
    to be added to the middle of existing strings. Here are some examples of this
    process:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串相加最初可能是一个奇特的概念，因为它看起来不可能将字符串相加，这与整数或浮点数不同，它们是数字。然而，在Python和其他编程语言中，这却是一个正常的步骤。使用加号（+），字符串可以相加形成更长的字符串，或者允许变量被添加到现有字符串的中间。以下是一些这个过程的示例：
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The output is as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The output is as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Two or more strings can be added together, and can even be assigned to a third
    variable. This process can be useful for situations such as the input string for
    the Intersect tool. The string can be broken up and variables representing the
    file paths can be inserted into the middle of the string:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 两个或多个字符串可以相加，甚至可以分配给第三个变量。这个过程在诸如 Intersect 工具的输入字符串等情况下可能很有用。字符串可以被拆分，代表文件路径的变量可以插入到字符串的中间：
- en: '[PRE11]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This is a powerful and useful way to insert the file paths into the input string.
    As long as the separators are still included in the string, the string will still
    be valid and the Intersect tool will run as expected. Here is what the string
    will look like when the string addition is completed:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种强大且有用的方法，可以将文件路径插入到输入字符串中。只要分隔符仍然包含在字符串中，字符串仍然有效，Intersect 工具将按预期运行。以下是字符串相加完成后的字符串看起来像什么：
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The output is as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Another similar offshoot of string addition is string multiplication, where
    strings are multiplied by an integer to produce repeated versions of the string:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种与字符串相加类似的分支是字符串乘法，其中字符串通过一个整数相乘来产生字符串的重复版本：
- en: '[PRE14]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The output is as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE15]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The string manipulation method 2–string formatting #1'
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '字符串操作方法 2–字符串格式化 #1'
- en: The second method of string manipulation, known as string formatting, involves
    adding placeholders into the string that will accept specific kinds of data. This
    means that these special strings can accept other strings as well as integers
    and float values. These placeholders use the modulo (%) and a key letter to indicate
    the type of data to expect. Strings are represented using **%s**, floats are represented
    using **%f**, and integers are represented using **%d**. The floats can also be
    adjusted to limit the digits included by adding a modifying number after the modulo.
    If there is more than one placeholder in a string, the values are passed to the
    string in a tuple.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串操作的第二种方法，称为字符串格式化，涉及在字符串中添加将接受特定类型数据的占位符。这意味着这些特殊字符串可以接受其他字符串以及整数和浮点值。这些占位符使用取模
    (%) 和一个键字母来指示预期的数据类型。字符串使用 **%s** 表示，浮点数使用 **%f** 表示，整数使用 **%d** 表示。浮点数还可以通过在取模后添加一个修改数字来调整，以限制包含的数字位数。如果字符串中有多个占位符，则值以元组的形式传递到字符串中。
- en: 'This method has become less popular since the third method discussed in the
    following section was introduced in Python 2.6, but it is still valuable to know
    as many older scripts use it. Here is an example of this method:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 自从 Python 2.6 中引入了下一节讨论的第三种方法以来，这种方法已经变得不那么流行了，但了解它仍然很有价值，因为许多较老的脚本仍在使用它。以下是这个方法的示例：
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The output is as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE17]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here is an example when using a float placeholder:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个使用浮点占位符的示例：
- en: '[PRE18]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The output is as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE19]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The output is as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE20]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here is an example using an integer placeholder:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个使用整数占位符的示例：
- en: '[PRE21]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The output is as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE22]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'For the **Intersect** tool, the %s symbol can be used to accept the file path
    string variables:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 **Intersect** 工具，可以使用 %s 符号来接受文件路径字符串变量：
- en: '[PRE23]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The string manipulation method 3–string formatting #2'
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '字符串操作方法 3–字符串格式化 #2'
- en: 'The final method, the most recently introduced, is also known as string formatting.
    It is similar to the string formatting discussed earlier, with the added benefit
    of not requiring a specific type of placeholder. The placeholders, or tokens as
    they are also known, are only required to be in order to be accepted. The format
    function is built into strings; by adding `.format` to the string, and passing
    in parameters, the string accepts the values:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一种方法，也是最近引入的，也称为字符串格式化。它与前面讨论的字符串格式化类似，但增加了不需要特定类型占位符的好处。占位符，或称为标记，只需按顺序排列即可被接受。格式化函数是字符串内建的；通过在字符串中添加
    `.format` 并传递参数，字符串接受这些值：
- en: '[PRE24]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The tokens don't have to be in order within the string, and can even be repeated.
    The order is derived from the parameters supplied to the `.format` function that
    passes the values to the string.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 标记不需要在字符串中按顺序排列，甚至可以重复。顺序是从传递给 `.format` 函数的参数中派生出来的，该函数将值传递到字符串中。
- en: 'For the **Intersect** tool, the string formatting would look like this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 **Intersect** 工具，字符串格式化看起来像这样：
- en: '[PRE25]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The third method has become my go-to method for string manipulation because
    of the ability to add the values repeatedly and make it possible to avoid supplying
    the wrong type of data to a specific placeholder, unlike the second method.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种方法因为能够重复添加值并使其能够避免向特定占位符提供错误类型的数据，而不同于第二种方法，已经成为我字符串操作的首选方法。
- en: Adjusting the Script
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调整脚本
- en: Now is the time to take the automatically generated script and adjust it to
    fit our needs. We want the script to both produce the output data, and to have
    it analyze the data and tally the results into a spreadsheet. This spreadsheet
    will hold an averaged population value for each bus stop. The average will be
    derived from each census block that the buffered representative region surrounding
    the stops intersected. Save the original script as `Chapter3Model1Modified`.`py`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候将自动生成的脚本进行调整，以适应我们的需求。我们希望脚本既能生成输出数据，又能分析数据并将结果汇总到电子表格中。这个电子表格将包含每个公交车站的平均人口值。平均值将从与公交车站周围的缓冲代表区域相交的每个普查区块中得出。将原始脚本保存为`Chapter3Model1Modified`.`py`。
- en: Adding the CSV module to the script
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将CSV模块添加到脚本中
- en: For this script, we will use the **CSV** module, a useful module to create Comma
    Separated Value spreadsheets. Its simple syntax will make it a useful tool to
    create script outputs. It should be noted that ArcGIS for Desktop also installs
    the **xlrd** and **xlwt** modules, used to read or generate Excel spreadsheets
    respectively, when it is installed.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个脚本，我们将使用**CSV**模块，这是一个用于创建逗号分隔值电子表格的有用模块。其简单的语法将使其成为创建脚本输出的有用工具。需要注意的是，当ArcGIS
    for Desktop安装时，它也会安装**xlrd**和**xlwt**模块，分别用于读取或生成Excel电子表格。
- en: 'Just below the import arcPy line, add `import csv`. This will allow us to use
    the csv module to create the spreadsheet:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在import arcPy行下方添加`import csv`。这将允许我们使用csv模块创建电子表格：
- en: '[PRE26]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The next adjustment is made to the **Intersect** tool. Notice that the two
    paths included in the input string are also defined as variables in the variable
    section. Remove the file paths from the input strings and replace them with numbered
    placeholder tokens, and then add the format function and supply the variables
    as placeholders:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个调整是对**Intersect**工具进行的。注意，输入字符串中包含的两个路径也在变量部分定义为变量。从输入字符串中删除文件路径，并用编号占位符替换它们，然后添加格式函数并供应变量作为占位符：
- en: '[PRE27]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Accessing the data: Using a cursor'
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问数据：使用游标
- en: Now that the script is in place to generate the raw data we need, we need a
    way to access the data held in the output feature class from the **Intersect**
    tool. This access will allow us to aggregate the rows of data representing each
    bus stop. We also need something to hold the aggregate data in the memory, to
    be written to the spreadsheet.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在脚本已经到位，可以生成我们需要的原始数据，我们需要一种方法来访问**Intersect**工具输出特征类中存储的数据。这种访问将允许我们聚合代表每个公交车站的数据行。我们还需要某种东西来在内存中存储聚合数据，以便写入电子表格。
- en: 'To accomplish the second part, we will use a Python dictionary. To accomplish
    the first part, we will use a method built into the ArcPy module: the Data Access
    Search Cursor.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成第二部分，我们将使用Python字典。为了完成第一部分，我们将使用ArcPy模块中内置的方法：数据访问搜索游标。
- en: 'The Python dictionary will be added below the **Intersect** tool. A dictionary
    in Python is created using curly brackets. Add the following line to the script:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Python字典将在**Intersect**工具下方添加。在Python中，使用花括号创建字典。将以下行添加到脚本中：
- en: dataDictionary = {}
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: dataDictionary = {}
- en: 'This script will use the Bus Stop IDs as keys for the dictionary. The values
    will be lists, which will hold all of the population values associated with each
    Bus Stop ID. Add the following lines to generate a Data Cursor:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本将使用公交车站ID作为字典的键。值将是列表，将包含与每个公交车站ID相关的所有人口值。添加以下行以生成数据游标：
- en: '[PRE28]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This iteration combines a few ideas in Python and ArcPy. The with … as statement
    is used to create a variable (cursor) that represents the `arcpy.da.SearchCursor`
    object. It could also be written like this:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这个迭代结合了Python和ArcPy中的几个想法。使用with … as语句创建一个变量（游标），该变量代表`arcpy.da.SearchCursor`对象。它也可以写成这样：
- en: '[PRE29]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The advantage of the with ... as structure is that the cursor object is erased
    from memory when the iteration is completed, which eliminates locks on the feature
    classes being evaluated.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: with … as结构的优势在于，当迭代完成后，游标对象将从内存中删除，从而消除了对正在评估的特征类的锁定。
- en: The `arcpy.da.SearchCursor()` function requires an input feature class, and
    a list of fields to be returned. Optionally, a SQL statement can limit the number
    of rows returned.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`arcpy.da.SearchCursor()` 函数需要一个输入要素类和一个要返回的字段列表。可选地，一个 SQL 语句可以限制返回的行数。'
- en: The next line, `for row in cursor`, is the iteration through the data. It is
    not a normal Pythonic iteration, a distinction that will have ramifications in
    certain instances. For instance, however, it does allow for row-by-row access
    to data contained within the supplied feature class. Note that when using a Search
    Cursor, each row of data is returned as a tuple, which cannot be modified. The
    data can be accessed using indexes, as shown in the preceding code, where the
    two members of the tuple are assigned to variables.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个行，`for row in cursor`，是遍历数据。它不是一个正常的 Python 遍历，这种区别在某些情况下会产生影响。例如，然而，它确实允许逐行访问包含在提供的要素类中的数据。请注意，当使用搜索游标时，每一行数据都作为元组返回，无法修改。可以使用索引访问数据，如前述代码所示，其中元组的两个成员被分配给变量。
- en: The if/else conditional allows the data to be sorted. As noted earlier, the
    Bus Stop IDs, which are the first member of the data included in the tuple, will
    be used as a key. The conditional evaluates whether the Bus Stop ID is included
    in the dictionary's existing keys (which are contained in a list and accessed
    using the `dictionary.keys()` method). If it is not, it is added to the keys,
    and assigned a value that is a list containing (at first) one piece of data, the
    population value contained in that row. If it does exist in the keys, the list
    is appended with the next population value associated with that Bus Stop ID. With
    this code, we have now sorted each census block population according to the Bus
    Stop with which it is associated.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: if/else 条件语句允许对数据进行排序。如前所述，公交站 ID，即元组中包含的数据的第一个成员，将被用作键。条件语句评估公交站 ID 是否包含在字典的现有键中（这些键包含在一个列表中，并使用
    `dictionary.keys()` 方法访问）。如果没有，它将被添加到键中，并分配一个包含（最初）一个数据片段的列表作为值，即该行中包含的人口值。如果它已经存在于键中，则将下一个与该公交站
    ID 相关的人口值附加到列表中。使用此代码，我们现在已根据与之关联的公交站对每个普查区人口进行排序。
- en: 'Next, we need to add code to create the spreadsheet. This code will use the
    same with ... as structure, and will generate an average population value by using
    two built-in Python functions, `sum`, which creates a sum from a list of numbers,
    and `len`, which will get the length of a list, tuple, or string:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要添加代码来创建电子表格。此代码将使用相同的 with ... as 结构，并使用两个内置 Python 函数 `sum` 和 `len`
    来生成平均人口值，其中 `sum` 从数字列表创建总和，而 `len` 将获取列表、元组或字符串的长度：
- en: '[PRE30]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The average population value is retrieved from the dictionary using the Bus
    Stop ID key, and then assigned to the variable `averagePop`. The two data pieces,
    the `BusStopID` and the `averatePop` variable are then added to a list, which
    is supplied to a `CSVwriter` object, which knows how to accept the data and write
    it to a file located at the file path supplied to the built-in Python `the open()`
    function, used to create simple files.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 使用公交站 ID 键从字典中检索平均人口值，并将其分配给变量 `averagePop`。然后将两个数据片段，`BusStopID` 和 `averatePop`
    变量添加到一个列表中，该列表被提供给一个 `CSVwriter` 对象，该对象知道如何接受数据并将其写入文件，该文件位于提供给内置 Python `open()`
    函数的文件路径中，用于创建简单文件。
- en: 'The script is complete, although it is nice to add one more line at the end
    to give us visual confirmation that the script has run:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本已完成，尽管在末尾添加一行以提供脚本已运行的视觉确认是件好事：
- en: '[PRE31]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This will create an output indicating that the script has run. Once it is done,
    go to the location of the output csv file and open it, using Excel or Notepad,
    and see the results of the analysis. Our first script is complete!
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个输出，表明脚本已运行。一旦完成，请转到输出 csv 文件的所在位置，并使用 Excel 或记事本打开它，查看分析结果。我们的第一个脚本已完成！
- en: The final script
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最终脚本
- en: 'Here is how the script should look in the end:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这是脚本最终应该看起来的样子：
- en: '[PRE32]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Summary
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered how to craft a model of an analysis and export it
    to a script. After discussing the script, we adjusted the script to include a
    results analysis and summation, which was outputted to a CSV file. In particular,
    we discussed how to use ModelBuilder to create an analysis and export it as a
    script, and how to adjust the script to be more Pythonic. We also briefly touched
    on the use of Search Cursors, which will be covered in greater detail in [Chapter
    5](ch05.html "Chapter 5. ArcPy Cursors – Search, Insert, and Update"), *ArcPy
    Cursors – Search, Insert, and Update.* Also, we saw how built-in modules such
    as the CSV module can be used along with ArcPy to capture analysis output in formatted
    spreadsheets.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了如何构建分析模型并将其导出为脚本。在讨论脚本之后，我们对脚本进行了调整，以包含结果分析和总结，这些内容被输出到CSV文件中。特别是，我们讨论了如何使用ModelBuilder创建分析和将其导出为脚本，以及如何调整脚本使其更符合Python风格。我们还简要提到了搜索游标的使用，这将在第5章（[Chapter
    5](ch05.html "第5章。ArcPy游标 – 搜索、插入和更新")）中更详细地介绍，即*ArcPy游标 – 搜索、插入和更新*。此外，我们还看到了如何使用内置模块，如CSV模块，与ArcPy一起使用，以捕获格式化的电子表格中的分析输出。
- en: In the next chapter, we will discuss how to create more complex scripts and
    build functions to avoid repeating code. These functions will make it possible
    to write code once and use it forever. This reuse of code will demonstrate how
    Python goes beyond automation of analysis to become a new productivity toolset.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论如何创建更复杂的脚本并构建函数以避免代码重复。这些函数将使得代码一旦编写就可以永久使用。这种代码的重用将展示Python如何超越分析自动化，成为一套新的生产力工具集。
