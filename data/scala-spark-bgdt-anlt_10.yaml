- en: Everything is Connected - GraphX
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一切都相连 - GraphX
- en: '"Technology made large populations possible; large populations now make technology
    indispensable."'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: “技术使大规模人口成为可能；大规模人口现在使技术成为必不可少。”
- en: '- Joseph Wood Krutch'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '- Joseph Wood Krutch'
- en: In this chapter, we'll learn how many real-world problems can be modeled (and
    resolved) using graphs. We see that Apache Spark comes with its own graph library,
    and what you learned about RDDs can be used here too (this time as vertex and
    edge RDDs).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何使用图表对许多现实世界的问题进行建模（和解决）。我们看到Apache Spark自带了自己的图表库，你学到的关于RDD的知识也可以在这里使用（这次作为顶点和边的RDD）。
- en: 'In a nutshell, the following topics will be covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，本章将涵盖以下主题：
- en: A brief introduction to graph theory
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图论简介
- en: GraphX
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GraphX
- en: VertexRDD and EdgeRDD
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: VertexRDD和EdgeRDD
- en: Graph operators
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图操作符
- en: Pregel API
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pregel API
- en: PageRank
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PageRank
- en: A brief introduction to graph theory
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图论简介
- en: To better understand graphs, let's look at Facebook and how you typically use
    Facebook. Every day you use your smart phone to post messages on your friend's
    wall or update your status. Your friends are all posting messages and photos and
    videos of their own.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解图表，让我们看看Facebook以及你通常如何使用Facebook。每天你都在用智能手机在朋友的墙上发布消息或更新你的状态。你的朋友们都在发布自己的消息、照片和视频。
- en: You have friends, your friends have friends, who have friends, and so on. Facebook
    has settings that let you make new friends or remove friends from your friend
    list. Facebook also has permissions, which allow granular control on who sees
    what and who can communicate with who.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你有朋友，你的朋友有朋友，他们有朋友，依此类推。Facebook有设置，让你添加新朋友或从朋友列表中删除朋友。Facebook还有权限，可以对谁看到什么以及谁可以与谁交流进行细粒度控制。
- en: Now, when you consider that there are a billion Facebook users, the friends
    and friend's friends list for all users gets quite large and complicated. It is
    hard to even comprehend and manage all the different relationships or friendships.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你考虑到有十亿Facebook用户时，所有用户的朋友和朋友的朋友列表变得非常庞大和复杂。甚至很难理解和管理所有不同的关系或友谊。
- en: So, if someone wants to find out if you and another person *X* are related at
    all, they can simply start by looking at all your friends and all your friends'
    friends, and so on, and try to get to the person *X*. If person *X* is a friend
    of a friend, then you and person *X* are indirectly connected.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果有人想找出你和另一个人*X*是否有任何关系，他们可以简单地从你所有的朋友和你所有朋友的朋友开始，依此类推，试图找到*X*。如果*X*是一个朋友的朋友，那么你和*X*是间接连接的。
- en: Search for a celebrity or two in your Facebook account and see if someone is
    a friend of your friend. Maybe you can try to add them as a friend.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的Facebook账户中搜索一两个名人，看看是否有人是你朋友的朋友。也许你可以尝试添加他们为朋友。
- en: 'We need to build the storage and retrieval of such data about people and their
    friends so as to allow us to answer questions such as:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要构建关于人和他们朋友的存储和检索，以便让我们能够回答诸如：
- en: Is X a friend of Y?
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: X是Y的朋友吗？
- en: Are X and Y connected directly or within two steps?
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: X和Y直接连接还是在两步之内连接？
- en: How many friends does X have?
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: X有多少个朋友？
- en: We can start by trying out a simple data structure such as an array such that
    every person has an array of friends. So now, it's easy to just take the length
    of the array to answer 3\. We can also just scan the array and quickly answer
    1\. Now, question 2 will need little more work, take the array of friends of *X*
    and for each such friend scan the array of friends.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从尝试一个简单的数据结构开始，比如每个人都有一个朋友数组。现在，只需取数组的长度就可以回答3。我们也可以扫描数组并快速回答1。现在，问题2需要更多的工作，取*X*的朋友数组，对于每个这样的朋友扫描朋友数组。
- en: 'We have sort of solved the problem by having a specialized data structure as
    shown in the following example where we create a case class `Person` and then
    add friends to build a relationship like this `john` | `ken` | `mary` | `dan`:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用专门的数据结构来解决了这个问题，如下例所示，我们创建了一个`Person`的案例类，然后添加朋友来建立这样的关系`john` | `ken`
    | `mary` | `dan`：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If we build out the `Person()` instances for all Facebook users and add the
    friends to the arrays as the preceding code shows, then eventually, we will be
    able to perform lots of the queries on who is a friend and what is the relationship
    between any two persons.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们为所有Facebook用户构建`Person()`实例并像前面的代码所示将朋友添加到数组中，那么最终，我们将能够执行许多关于谁是朋友以及任何两个人之间的关系的查询。
- en: 'The following diagram shows the data structures'' `Person()` instances and
    how they are related to each other logically:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了数据结构的`Person()`实例以及它们在逻辑上是如何相关的：
- en: '![](img/00008.jpeg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00008.jpeg)'
- en: 'If you want to use the preceding graph and just find out **John**''s friends,
    **John**''s friend''s friends and so on so that we can quickly find out direct
    friends, indirect friends (friends level 2), and level 3 (friends'' friends''
    friends), you will see something like the following diagram:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想使用前面的图表，只需找出**John**的朋友，**John**的朋友的朋友等等，这样我们就可以快速找出直接朋友、间接朋友（朋友的朋友），以及第3级（朋友的朋友的朋友），你会看到类似以下图表：
- en: '![](img/00014.jpeg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00014.jpeg)'
- en: We can easily extend the `Person()` class and provide more and more functionality
    to answer different questions. That is not the point here, what we want to look
    at is the preceding diagram showing `Person` and friends of the `Person` and how
    drawing all the friends of each `Person` yields in a mesh of relationships between
    persons.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松地扩展`Person()`类并提供越来越多的功能来回答不同的问题。这不是重点，我们想要看的是前面的图表显示了`Person`和`Person`的朋友，以及如何绘制每个`Person`的所有朋友会产生人与人之间的关系网。
- en: We now introduce the graph theory, which stems from the field of Mathematics.
    Graph theory defines a graph as a structure made up of vertices, nodes, or points,
    which are connected by edges, arcs, and lines. If you consider a set of `Vertices`
    as `V` and a set of `Edges` as `E`, then a `Graph G` can be defined as an ordered
    pair of `V` and `E`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们介绍图论，它源自数学领域。图论将图定义为由顶点、节点或点构成的结构，这些结构由边缘、弧和线连接。如果你将一组`Vertices`视为`V`，一组`Edges`视为`E`，那么`Graph
    G`可以被定义为`V`和`E`的有序对。
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In our example of the Facebook friends drawing, we can simply consider each
    of the persons as a vertex in the set of vertices and then each link between any
    two persons can be considered as an edge in the set of edges.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的Facebook朋友绘图示例中，我们可以简单地将每个人视为顶点集中的一个顶点，然后将任意两个人之间的每个链接视为边缘集中的一条边。
- en: 'By this logic, we can list the **Vertices** and **Edges** as shown in the following
    diagram:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 按照这个逻辑，我们可以列出如下图中的**Vertices**和**Edges**：
- en: '![](img/00016.jpeg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00016.jpeg)'
- en: This depiction as a mathematical graph yields to various methodologies of traversing
    and querying the Graph using mathematical techniques. When the techniques are
    applied to computer science as a way to develop programmatical methods to perform
    the math necessary, the formal approach is, of course, to develop algorithms to
    implement the mathematical rules at a scalable efficient level.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 将这种数学图的描述转化为各种使用数学技术进行遍历和查询图的方法。当这些技术被应用于计算机科学，作为开发程序方法来执行必要的数学运算时，正式的方法当然是开发算法，以在可扩展高效的水平上实现数学规则。
- en: 'We have already attempted to implement a simple graph-like program using the
    case class `Person`, but this is just the simplest use case, which should make
    it obvious that there are a lot of sophisticated extensions possible, such as
    the following questions to be answered:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经尝试使用`Person`这个案例类来实现一个类似图的程序，但这只是最简单的用例，这应该让人明白，还有很多复杂的扩展可能，比如以下问题需要回答：
- en: What's the best way from X to Y? An example of such a question can be your car
    GPS telling you the best way to go to the grocery store.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从X到Y的最佳方式是什么？这样一个问题的例子可以是你的车载GPS告诉你去杂货店的最佳路线。
- en: Recognize the critical edges, which can cause partitions of the graph? An example
    of such a question is to determine the critical links connecting the internet
    services/water pipes/power lines of various cities in the state. A critical edge
    breaks connectivity and produces two subgraphs of well-connected cities, but there
    will not be any communication between the two subgraphs.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别可能导致图分区的关键边缘？这样一个问题的例子是确定连接州内各个城市的互联网服务/水管/电力线的关键链路。关键边缘会打破连接，并产生两个互相连接良好的子图，但两个子图之间不会有任何通信。
- en: Answering the preceding questions yields to several algorithms such as minimum
    spanning tree, shortest path , page rank, **ALS** (**alternating least squares**),
    and max-cut min-flow algorithms, and so on, which are applicable to a broad set
    of use cases.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 回答上述问题会产生一些算法，例如最小生成树、最短路径、页面排名、**ALS**（**交替最小二乘法**）和最大割最小流算法等，适用于广泛的用例。
- en: The other examples are LinkedIn profiles and connections, Twitter followers,
    Google page rank, airline scheduling, GPS in your car, and so on, where you can
    clearly see a graph of vertices and edges. Using graph algorithms, the graph seen
    earlier in the Facebook, LinkedIn, Google examples can be analyzed using various
    algorithms to yield different business use cases.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 其他的例子包括LinkedIn的个人资料和联系人、Twitter的关注者、Google的页面排名、航空公司的航班安排、你车上的GPS等等，你可以清楚地看到顶点和边的图。使用图算法，可以使用各种算法分析先前在Facebook、LinkedIn、Google示例中看到的图，以产生不同的商业用例。
- en: 'Shown below are illustration of some real-life use cases of graphs which show
    the use of graphs and graph algorithms in some real-life use cases such as:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些图的实际用例的示例，展示了图和图算法在一些实际用例中的使用，例如：
- en: help determine flight routes between airports
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 帮助确定机场之间的航班路线
- en: plan how to layout water pipelines to all the households in the locality
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 规划如何布置本地所有家庭的水管道
- en: make your car GPS to plan the route to drive to the grocery
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让你的车载GPS规划驾驶到杂货店的路线
- en: design how the internet traffic is routed from city to city, state to state
    and country to country
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计互联网流量如何从城市到城市、州到州、国家到国家的路由
- en: '![](img/00018.jpeg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00018.jpeg)'
- en: Let's now start digging deeper into how we can use Spark GraphX.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们深入了解如何使用Spark GraphX。
- en: GraphX
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GraphX
- en: As shown in the preceding section, we can model many real-life use cases as
    Graphs with a set of vertices and a set of edges linking the vertices. We also
    wrote simple code trying to implement some basic graph operations and queries
    such as, *Is X a friend of Y* ? However, as we explored further, the algorithms
    only get more complicated along with use cases and also the size of graphs is
    much much larger than can be handled on one machine.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面的部分所示，我们可以将许多实际用例建模为具有一组顶点和一组连接顶点的边的图。我们还编写了简单的代码，试图实现一些基本的图操作和查询，比如* X是Y的朋友吗*？然而，随着我们的探索，算法变得更加复杂，用例也更加复杂，图的规模远远大于一个机器可以处理的规模。
- en: It is not possible to fit one billion Facebook users along with all their friendship
    relations into one machine or even a few machines.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 将十亿Facebook用户及其所有的友谊关系放入一个甚至几个机器中是不可能的。
- en: What we need to do is to look beyond the one machine and few machines thrown
    together and rather start considering highly scalable architectures to implement
    the complex graph algorithms, which can handle the volume of data and complex
    interconnections of the data elements. We have already seen an introduction to
    Spark, how Spark solves some challenges of distributed computing and big data
    analytics. We also saw real-time stream processing and Spark SQL along with DataFrames
    and RDDs. Can we also solve the challenges of graph algorithms? The answer to
    this is GraphX, which comes with Apache Spark and just like other libraries, sits
    on top of Spark Core.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的是超越单台机器和几台机器的组合，而是开始考虑高度可扩展的架构，以实现复杂的图算法，可以处理数据的数量和数据元素的复杂相互关系。我们已经看到了Spark的介绍，Spark如何解决分布式计算和大数据分析的一些挑战。我们还看到了实时流处理和Spark
    SQL以及DataFrames和RDDs。我们是否也可以解决图算法的挑战？答案是GraphX，它与Apache Spark一起提供，并且与其他库一样，位于Spark
    Core之上。
- en: GraphX extends the spark RDD by providing a graph abstraction on top of the
    RDD concept. Graphs in GraphX are created using the concept of vertices or nodes
    to represent the objects and edges or links to describe the relation between objects
    and GraphX provides the means to realize many use cases, which suit the graph
    processing paradigm. In this section, we will learn about GraphX, how to create
    vertices, edges, and graphs comprising vertices and edges. We will also write
    code to learn by example some techniques surrounding graph algorithms and processing.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: GraphX通过在RDD概念之上提供图抽象来扩展Spark RDD。GraphX中的图是使用顶点或节点来表示对象，使用边或链接来描述对象之间的关系，并且GraphX提供了实现适合图处理范式的许多用例的手段。在本节中，我们将学习GraphX，如何创建顶点、边和包含顶点和边的图。我们还将编写代码，通过示例学习围绕图算法和处理的一些技术。
- en: 'To get started , you will need to import some packages as listed here:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，您需要导入以下列出的一些包：
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The fundamental data structure of GraphX is a graph, which abstractly represents
    a graph with arbitrary objects associated with vertices and edges. The graph provides
    basic operations to access and manipulate the data associated with vertices and
    edges as well as the underlying structure. Like Spark RDDs, the graph is a functional
    data structure in which mutating operations return new graphs. This immutable
    nature of the `Graph` object makes it possible to do large-scale parallel computations
    without the risk of running into synchronization problems.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: GraphX的基本数据结构是图，它抽象地表示具有与顶点和边关联的任意对象的图。图提供了基本操作，用于访问和操作与顶点和边关联的数据，以及底层结构。与Spark
    RDD一样，图是一个功能性数据结构，其中变异操作返回新的图。`Graph`对象的不可变性使得可以进行大规模并行计算，而不会遇到同步问题的风险。
- en: Concurrent updates or modification of objects is the primary reason for complex
    multithreading programming done in many programs.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 并发更新或修改对象是许多程序中进行复杂多线程编程的主要原因。
- en: The graph defines the basic data structure and there is a helper class `GraphOps`,
    which contains additional convenience operations and graph algorithms.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图定义了基本的数据结构，还有一个辅助类`GraphOps`，其中包含额外的便利操作和图算法。
- en: 'A graph is defined as follows as a class template with two attributes specifying
    the data type of the two pieces, which make up the graph, namely, the vertices
    and the edges:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图被定义为一个类模板，具有两个属性，指定构成图的两个部分的数据类型，即顶点和边：
- en: '[PRE3]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: A graph consists of vertices and edges as we already discussed. The set of vertices
    is in a special data structure known as `VertexRDD`. Similarly, the set of edges
    is in a special data structure known as `EdgeRDD`. Together the vertices and edges
    form the graph and all the subsequent operations can be done using the two data
    structures.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们已经讨论过的，图由顶点和边组成。顶点集合存储在称为`VertexRDD`的特殊数据结构中。同样，边的集合存储在称为`EdgeRDD`的特殊数据结构中。顶点和边一起形成图，所有后续操作都可以使用这两个数据结构进行。
- en: 'So, the declaration of the class `Graph` looks like this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`Graph`类的声明如下：
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now, let's look at the two main components of the `Graph` class, the `VertexRDD`,
    and the `EdgeRDD`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看`Graph`类的两个主要组件，即`VertexRDD`和`EdgeRDD`。
- en: VertexRDD and EdgeRDD
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: VertexRDD和EdgeRDD
- en: A `VertexRDD` contains the set of vertices or nodes in a special data structure
    and an `EdgeRDD` contains the set of edges or links between the nodes/vertices
    again in a special data structure. Both the `VertexRDD` and the `EdgeRDD` are
    based on RDDs and the `VertexRDD` deals with every single node in the graph while
    the `EdgeRDD` contains all links between all nodes. In this section, we will look
    at how to create `VertexRDD` and `EdgeRDD` and then use these objects in building
    a graph.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`VertexRDD`包含一组顶点或节点，存储在特殊的数据结构中，而`EdgeRDD`包含一组边或链接，连接了节点/顶点，同样存储在特殊的数据结构中。`VertexRDD`和`EdgeRDD`都基于RDD，并且`VertexRDD`处理图中的每个单个节点，而`EdgeRDD`包含所有节点之间的所有链接。在本节中，我们将看看如何创建`VertexRDD`和`EdgeRDD`，然后在构建图时使用这些对象。'
- en: VertexRDD
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: VertexRDD
- en: As seen earlier, the `VertexRDD` is an RDD containing the vertices and their
    associated attributes. Each element in the RDD represents a vertex or node in
    the graph. In order to maintain the uniqueness of the vertex, we need to have
    a way of assigning a unique ID to each of the vertexes. For this purpose, GraphX
    defines a very important identifier known as `VertexId`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`VertexRDD`是一个包含顶点及其关联属性的RDD。RDD中的每个元素表示图中的一个顶点或节点。为了保持顶点的唯一性，我们需要一种方法为每个顶点分配一个唯一的ID。为此，GraphX定义了一个非常重要的标识符，称为`VertexId`。
- en: '`VertexId` is defined as a 64-bit vertex identifier that uniquely identifies
    a vertex within a graph. It does not need to follow any ordering or any constraints
    other than uniqueness.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`VertexId`被定义为一个64位的顶点标识符，用于唯一标识图中的顶点。它不需要遵循任何顺序或除唯一性之外的任何约束。'
- en: 'The declaration of `VertexId` is as follows as simply an alias for a 64-bit
    `Long` number:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`VertexId`的声明如下，只是64位`Long`数字的别名：'
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `VertexRDD` extends an RDD of a pair of VertexID and vertex attributes represented
    by `RDD[(VertexId, VD)]`. It also ensures that there is only one entry for each
    vertex and by preindexing the entries for fast, efficient joins. Two VertexRDDs
    with the same index can be joined efficiently.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`VertexRDD`扩展了由`RDD[(VertexId, VD)]`表示的一对VertexID和顶点属性的RDD。它还确保每个顶点只有一个条目，并通过预索引条目以进行快速、高效的连接。具有相同索引的两个VertexRDD可以有效地连接。'
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`VertexRDD` also implements many functions, which provide important functionality
    related to graph operations. Each function typically accepts inputs of vertices
    represented by `VertexRDD`.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`VertexRDD`还实现了许多函数，提供了与图操作相关的重要功能。每个函数通常接受由`VertexRDD`表示的顶点作为输入。'
- en: 'Let''s load vertices into a `VertexRDD` of users. For this, we shall first
    declare a case class `User` as shown here:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将用户加载到`VertexRDD`中。为此，我们首先声明一个`User` case类，如下所示：
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, using the file `users.txt`, create the `VertexRDD`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用文件`users.txt`，创建`VertexRDD`：
- en: '| **VertexID** | **Name** | **Occupation** |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| **VertexID** | **Name** | **Occupation** |'
- en: '| 1 | John | Accountant |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| 1 | John | 会计师 |'
- en: '| 2 | Mark | Doctor |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| 2 | Mark | 医生 |'
- en: '| 3 | Sam | Lawyer |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| 3 | Sam | 律师 |'
- en: '| 4 | Liz | Doctor |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| 4 | Liz | 医生 |'
- en: '| 5 | Eric | Accountant |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| 5 | Eric | 会计师 |'
- en: '| 6 | Beth | Accountant |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| 6 | Beth | 会计师 |'
- en: '| 7 | Larry | Engineer |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| 7 | Larry | 工程师 |'
- en: '| 8 | Marry | Cashier |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| 8 | Marry | 收银员 |'
- en: '| 9 | Dan | Doctor |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| 9 | Dan | 医生 |'
- en: '| 10 | Ken | Librarian |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| 10 | Ken | 图书管理员 |'
- en: 'Each line of the file `users.txt` contains **VertexId** , the **Name**, and
    the **Occupation**, so we can use the `String` split function here:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 文件`users.txt`的每一行包含**VertexId**，**Name**和**Occupation**，因此我们可以在这里使用`String`
    split函数：
- en: '[PRE8]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: EdgeRDD
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: EdgeRDD
- en: The `EdgeRDD` represents the set of Edges between the vertices and is a member
    of the Graph class as seen earlier. `EdgeRDD`, just like `VertexRDD`, extends
    from RDD and takes both Edge attributes and Vertex attributes.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`EdgeRDD`表示顶点之间的边的集合，并且是Graph类的成员，就像之前看到的那样。`EdgeRDD`和`VertexRDD`一样，都是从RDD扩展而来，并且都带有Edge属性和Vertex属性。'
- en: '`EdgeRDD[ED, VD]` extends `RDD[Edge[ED]]` by storing the edges in columnar
    format on each partition for performance. It may additionally store the vertex
    attributes associated with each edge to provide the triplet view:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`EdgeRDD[ED, VD]`通过在每个分区上以列格式存储边缘来扩展`RDD[Edge[ED]]`，以提高性能。它还可以存储与每条边相关联的顶点属性，以提供三元组视图：'
- en: '[PRE9]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: EdgeRDD also implements many functions, which provide important functionality
    related to graph operations. Each function typically accepts inputs of edges represented
    by EdgeRDD. Each Edge consists of a source vertexId, destination vertexId and
    edge attributes such as a `String`, `Integer`, or any case class. In the following
    example, we use a `String` friend as the attribute. Later in this chapter, we
    use the distance in miles (`Integer`) as the attribute.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: EdgeRDD还实现了许多函数，提供了与图操作相关的重要功能。每个函数通常接受由EdgeRDD表示的边的输入。每个Edge包括源vertexId、目标vertexId和边属性，例如`String`、`Integer`或任何case类。在下面的示例中，我们使用`String`
    friend作为属性。在本章的后面，我们将使用英里数（`Integer`）作为属性。
- en: 'We can create EdgeRDD by reading a file of pairs of vertexIds:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过读取一对vertexIds的文件来创建EdgeRDD：
- en: '| **Source Vertex ID** | **Target/Destination Vertex ID** | **Distance in Miles**
    |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| **源顶点ID** | **目标/目的地顶点ID** | **英里数** |'
- en: '| 1 | 3 | 5 |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 3 | 5 |'
- en: '| 3 | 1 | 5 |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 1 | 5 |'
- en: '| 1 | 2 | 1 |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 2 | 1 |'
- en: '| 2 | 1 | 1 |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 1 | 1 |'
- en: '| 4 | 10 | 5 |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 10 | 5 |'
- en: '| 10 | 4 | 5 |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| 10 | 4 | 5 |'
- en: '| 1 | 10 | 5 |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 10 | 5 |'
- en: '| 10 | 1 | 5 |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| 10 | 1 | 5 |'
- en: '| 2 | 7 | 6 |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 7 | 6 |'
- en: '| 7 | 2 | 6 |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 2 | 6 |'
- en: '| 7 | 4 | 3 |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 4 | 3 |'
- en: '| 4 | 7 | 3 |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 7 | 3 |'
- en: '| 2 | 3 | 2 |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 3 | 2 |'
- en: 'Each line of the `friends.txt` file contains the source `vertexId` and destination
    `vertexId`, so we can use the `String` split function here:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`friends.txt`文件的每一行包含源`vertexId`和目标`vertexId`，因此我们可以在这里使用`String` split函数：'
- en: '[PRE10]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We now have vertices and edges, so it is time to put everything together and
    explore how we can build a `Graph` from the lists of vertices and edges:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了顶点和边缘，是时候将所有内容放在一起，探索如何从顶点和边缘列表构建`Graph`：
- en: '[PRE11]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Using the `Graph` object, we can look at the vertices and edges using the `collect()`
    function, which will show all vertices and edges. Each vertex is of the form (`VertexId`,
    `User`) and each edge is of the form (`srcVertexId`, `dstVertexId`, `edgeAttribute`).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Graph`对象，我们可以使用`collect()`函数查看顶点和边，这将显示所有顶点和边。每个顶点的形式为（`VertexId`，`User`），每条边的形式为（`srcVertexId`，`dstVertexId`，`edgeAttribute`）。
- en: '[PRE12]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now that we have a graph created, we will look at various operations in the
    next section.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '现在我们创建了一个图，我们将在下一节中查看各种操作。 '
- en: Graph operators
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图操作符
- en: Let's start with the operations we can directly perform using `Graph` object,
    such as filtering the vertices and edges of the graph to filter out based on some
    attribute of the object. We will also see an example of `mapValues()`, which can
    transform the graph to yield a custom RDD.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从我们可以直接使用`Graph`对象执行的操作开始，例如根据对象的某个属性过滤图的顶点和边缘。我们还将看到`mapValues()`的示例，它可以将图转换为生成自定义RDD。
- en: First, let's examine the vertices and the edges using the `Graph` object we
    created in the previous section and then look at some graph operators.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们使用前一节中创建的`Graph`对象检查顶点和边，然后查看一些图操作符。
- en: '[PRE13]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Filter
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过滤
- en: 'A function call to `filter()` restricts the vertex set to the set of vertices
    satisfying the given predicate. This operation preserves the index for efficient
    joins with the original RDD, and it sets bits in the bitmask rather than allocating
    new memory:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 对`filter()`的函数调用将顶点集限制为满足给定谓词的顶点集。此操作保留了用于与原始RDD进行高效连接的索引，并且在位掩码中设置位，而不是分配新内存：
- en: '[PRE14]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Using `filter`, we can filter out everything but the vertex for user `Mark`,
    which can be done either using the vertexId or the `User.name` attribute. We can
    also filter for the `User.occupation` attribute.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`filter`，我们可以过滤掉除了用户`Mark`的顶点之外的所有内容，可以使用顶点ID或`User.name`属性来完成。我们还可以过滤`User.occupation`属性。
- en: 'The following is the code to accomplish the same:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是实现相同目的的代码：
- en: '[PRE15]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We can also perform `filter` on the edges too, using either the source vertexId
    or the destination vertexId. So we can filter out the edges to show only the edges,
    which originate from `John` (vertexId = 1):'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以对边进行`filter`操作，使用源顶点ID或目标顶点ID。因此，我们可以过滤出仅显示从`John`（vertexId = 1）发出的边。
- en: '[PRE16]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: MapValues
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MapValues
- en: '`mapValues()` maps each vertex attribute, preserving the index so as not to
    change the vertexId. Changing the vertexId would have changed the index so much
    that subsequent operations would fail and the vertices will not be reachable anymore.
    Hence, it is important to not change the vertexIds.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`mapValues()`映射每个顶点属性，保留索引以不改变vertexId。改变vertexId会导致索引变化，从而导致后续操作失败，顶点将不再可达。因此，重要的是不要改变vertexIds。'
- en: 'The declaration of this function is shown here:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数的声明如下所示：
- en: '[PRE17]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`mapValues()` can also operate on the edges and maps the values in an edge
    partitioning preserving the structure but changing the values:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`mapValues()`也可以在边上操作，并映射边分区中的值，保留结构但更改值：'
- en: '[PRE18]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The following is the example code invoking `mapValues()` in the vertices and
    edges. MapValues on vertices transforms the vertices to list of pairs of (`vertexId`
    , `User.name`). MapValues on edges transforms the edges to triplets of (`srcId`,
    `dstId`, `string`):'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在顶点和边上调用`mapValues()`的示例代码。在顶点上的MapValues将顶点转换为（`vertexId`，`User.name`）对的列表。在边上的MapValues将边转换为（`srcId`，`dstId`，`string`）的三元组：
- en: '[PRE19]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: aggregateMessages
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: aggregateMessages
- en: The core aggregation operation in GraphX is `aggregateMessages`, which applies
    a user-defined `sendMsg` function to each edge triplet in the graph and then uses
    the `mergeMsg` function to aggregate these messages at their destination vertex.
    `aggregateMessages` is used in many graph algorithms, where we have to exchange
    information between vertices.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: GraphX中的核心聚合操作是`aggregateMessages`，它对图中的每个边三元组应用用户定义的`sendMsg`函数，然后使用`mergeMsg`函数在目标顶点处聚合这些消息。`aggregateMessages`在许多图算法中使用，其中我们必须在顶点之间交换信息。
- en: 'The following is the signature for this API:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是此API的签名：
- en: '[PRE20]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The key functions are the `sendMsg` and `mergeMsg`, which determine what gets
    sent either to source vertex or destination vertex of an edge. Then, `mergeMsg`
    processes the messages received from all the Edges and performs a computation
    or aggregation.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 关键函数是`sendMsg`和`mergeMsg`，它们确定发送到边的源顶点或目标顶点的内容。然后，`mergeMsg`处理从所有边接收到的消息并执行计算或聚合。
- en: 'The following is a simple example of calling `aggregateMessages` on the `Graph`
    graph, where we send a message to all destination vertices. The merge strategy
    at each vertex is to just add all the messages being received:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在`Graph`图上调用`aggregateMessages`的简单示例，我们向所有目标顶点发送消息。每个顶点的合并策略只是将接收到的所有消息相加：
- en: '[PRE21]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: TriangleCounting
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TriangleCounting
- en: A triangle is created if two neighbors of a vertex are connected by an edge.
    In other words, a user will create a triangle with the two friends who are friends
    with each other.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个顶点的两个邻居通过一条边相连，就会形成一个三角形。换句话说，用户将与彼此为朋友的两个朋友创建一个三角形。
- en: Graph has a function `triangleCount()`, which computes the triangles in the
    graph.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图形具有一个名为`triangleCount()`的函数，用于计算图中的三角形。
- en: 'The following is the code used to count the triangles in the graph by first
    invoking the `triangleCount` function and then by joining the triangles with the
    vertices (users) to generate the output of each user and the triangle the user
    belongs to:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是用于计算图中三角形数量的代码，首先调用`triangleCount`函数，然后通过将三角形与顶点（用户）连接来生成每个用户和用户所属的三角形的输出：
- en: '[PRE22]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The diagram of the two triangles we just computed in the preceding code shows
    the two triangles, (**John**, **Mark**, **Sam**) and (**Ken**, **Mary**, **Beth**):'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚在前面的代码中计算的两个三角形的图示如下，(**John**, **Mark**, **Sam**)和(**Ken**, **Mary**, **Beth**)：
- en: '![](img/00023.jpeg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00023.jpeg)'
- en: Pregel API
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Pregel API
- en: Graphs are inherently recursive data structures as properties of vertices depend
    on properties of their neighbors, which in turn depend on properties of their
    own neighbors. As a consequence, many important graph algorithms iteratively recompute
    the properties of each vertex until a fixed-point condition is reached. A range
    of graph-parallel abstractions have been proposed to express these iterative algorithms.
    GraphX exposes a variant of the Pregel API.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图形本质上是递归数据结构，因为顶点的属性取决于其邻居的属性，而邻居的属性又取决于它们自己的邻居的属性。因此，许多重要的图算法会迭代地重新计算每个顶点的属性，直到达到固定点条件。已经提出了一系列图并行抽象来表达这些迭代算法。GraphX公开了Pregel
    API的变体。
- en: At a high level, the Pregel operator in GraphX is a bulk-synchronous parallel
    messaging abstraction constrained to the topology of the graph. The Pregel operator
    executes in a series of steps in which vertices receive the sum of their inbound
    messages from the previous super step, compute a new value for the vertex property,
    and then send messages to neighboring vertices in the next super step. Using Pregel,
    messages are computed in parallel as a function of the edge triplet and the message
    computation has access to both the source and destination vertex attributes. Vertices
    that do not receive a message are skipped within a super step. The Pregel operators
    terminate iteration and return the final graph when there are no messages remaining.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在高层次上，GraphX中的Pregel运算符是一种受限于图的拓扑结构的批量同步并行消息传递抽象。Pregel运算符在一系列步骤中执行，其中顶点接收来自上一个超级步骤的入站消息的总和，计算顶点属性的新值，然后在下一个超级步骤中向相邻顶点发送消息。使用Pregel，消息并行计算作为边三元组的函数，并且消息计算可以访问源和目标顶点属性。在超级步骤中，不接收消息的顶点将被跳过。当没有剩余消息时，Pregel运算符终止迭代并返回最终图。
- en: 'Some algorithms which come built-in using Pregel API are as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Pregel API内置的一些算法如下：
- en: ConnectedComponents
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ConnectedComponents
- en: ShortestPaths
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ShortestPaths
- en: Traveling salesman
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 旅行推销员
- en: PageRank (covered in the next section)
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PageRank（在下一节中介绍）
- en: 'The Pregel API signature is shown in the following code, which shows the various
    arguments needed. The exact usage will be shown in the subsequent sections, so
    you can refer to this signature for clarification:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Pregel API的签名如下所示，显示了所需的各种参数。确切的用法将在后续部分中显示，因此您可以参考此签名以进行澄清：
- en: '[PRE23]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: ConnectedComponents
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ConnectedComponents
- en: Connected components are essentially subgraphs within a graph, where the vertices
    are connected to each other in some way. This means that every vertex in the same
    component has an edge to/from some other vertex in the component. Whenever no
    other edge exists to connect a vertex to a component, a new component is created
    with that specific vertex. This continues until all vertices are in some component.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 连接组件本质上是图中的子图，其中顶点以某种方式相互连接。这意味着同一组件中的每个顶点都与组件中的某个其他顶点有边相连。每当没有其他边存在以连接顶点到组件时，就会创建一个具有特定顶点的新组件。这将继续，直到所有顶点都在某个组件中。
- en: 'The graph object provides a `connectComponents()` function to compute the connected
    components. This uses the Pregel API underneath to calculate the component a vertex
    belongs to. The following is the code to calculate connected components in the
    graph. Obviously, in this example, we had only one connected component, so it
    shows one as the component number for all users:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图对象提供了一个`connectComponents()`函数来计算连接的组件。这使用Pregel API来计算顶点所属的组件。以下是计算图中连接组件的代码。显然，在这个例子中，我们只有一个连接的组件，所以它显示所有用户的组件编号为1：
- en: '[PRE24]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Traveling salesman problem
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 旅行推销员问题
- en: Traveling salesman problem tried to find the shortest path through an undirected
    graph traversing every vertex, for example, user, John, wants to drive to every
    other user minimizing the total distance driven. As the number of vertices and
    edges increase, the number of permutations also increases polynomially to cover
    all the possible paths from vertex to vertex. The time complexity increases polynomially
    to a point that the problem can take a very long time to solve. Rather than solve
    it completely and accurately, an approach known as a **greedy** algorithm is used
    to solve the problem as optimally as possible.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 旅行推销员问题试图在遍历每个顶点的无向图中找到最短路径，例如，用户John想要驾驶到每个其他用户，最小化总驾驶距离。随着顶点和边的数量增加，排列的数量也会多项式增加，以覆盖从顶点到顶点的所有可能路径。时间复杂度多项式增加到一个问题可能需要很长时间来解决。与其完全准确地解决它，不如使用一种称为**贪婪**算法的方法尽可能地解决问题。
- en: To solve the traveling salesman problem, the greedy approach is to quickly choose
    the shortest edge, knowing that this could be a nonoptimal selection if we traverse
    further depth-wise.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决旅行推销员问题，贪婪方法是快速选择最短边，知道这可能是一个非最优选择，如果我们继续更深层次地遍历。
- en: 'A diagram of the greedy algorithm on the graph of users and friends is as follows,
    where we see the traversal picking the shortest weighted edge at each vertex.
    Also note that the vertices **Larry** (**7**) and **Liz** (**4**) are never visited:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了在用户和朋友图上的贪婪算法的图表，我们可以看到遍历每个顶点时选择最短加权边。还要注意，顶点**Larry**（**7**）和**Liz**（**4**）从未被访问：
- en: '![](img/00025.jpeg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00025.jpeg)'
- en: ShortestPaths
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ShortestPaths
- en: 'Shortest paths algorithm finds the path between two vertices by starting at
    the source Vertex and then traversing the edges connecting the vertices to other
    vertices until it reaches the target vertex. The shortest paths algorithm works
    by exchanging messages between various vertices. Also this shortest paths algorithm
    is not directly a part of the `Graph` or `GraphOps` objects, rather must be invoked
    using `lib.ShortestPaths()`:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 最短路径算法通过从源顶点开始，然后遍历连接顶点到其他顶点的边，直到到达目标顶点，找到两个顶点之间的路径。最短路径算法通过在各个顶点之间交换消息来工作。此最短路径算法不是`Graph`或`GraphOps`对象的直接部分，而是必须使用`lib.ShortestPaths()`来调用：
- en: '[PRE25]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '`ShortestPaths` picks the shortest paths in terms of number of hops between
    the two vertices. The following diagram shows three ways **John** can reach **Larry**
    and two of the paths are of length 2 and one of length 3\. From the results of
    the preceding code, it clearly shows that the path chosen from **Larry** to John
    is of length 2.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`ShortestPaths`选择两个顶点之间的最短路径，以跳数计算。以下图表显示了**John**到**Larry**有三种方式，其中两种路径长度为2，一种长度为3。从前面代码的结果来看，清楚地显示了从**Larry**到John选择的路径长度为2。'
- en: 'The same is shown in the output in above code block as a vector containing
    the length of the path and the nodes `(7,(Map(1 -> 2),User(Larry,Engineer)))`:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码块的输出中，显示了一个包含路径长度和节点的向量`(7,(Map(1 -> 2),User(Larry,Engineer)))`。
- en: '![](img/00031.jpeg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00031.jpeg)'
- en: 'We can also compute the shortest path using weighted edges, which means every
    edge connecting users is not the same. For example, if we can consider the edge
    value/weight/attribute as the distance between where each user lives, we get a
    weighted graph. In this case, the shortest path is calculated by the distance
    between two users in miles:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用加权边来计算最短路径，这意味着连接用户的每条边都不相同。例如，如果我们可以将边值/权重/属性视为每个用户所住地点之间的距离，我们就得到了一个加权图。在这种情况下，最短路径是通过英里数计算两个用户之间的距离：
- en: '[PRE26]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The following is a diagram that uses Pregel API to compute the **Single Source
    Shortest Path** from **John** to **Larry** starting from initialization and iteration
    by iteration until we reach the best paths.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个使用Pregel API从**John**到**Larry**计算**单源最短路径**的图表，从初始化开始，逐次迭代直到找到最佳路径。
- en: 'Initialization of the graph is done by setting the value of vertex representing
    **John** to zero and all other vertices to positive infinity:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将代表**John**的顶点的值设置为零，将所有其他顶点设置为正无穷来初始化图：
- en: '![](img/00010.jpeg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00010.jpeg)'
- en: Once the initialization is complete, we will use Pregel for four iterations
    of recomputing the vertex values. In each iteration, we go through all the vertices
    and, at each vertex, check whether there is a better path from a source vertex
    to a destination vertex. If there is such an edge/path, then the vertex value
    is updated.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化完成后，我们将使用Pregel进行四次迭代来重新计算顶点的值。在每次迭代中，我们遍历所有顶点，并在每个顶点处检查是否有从源顶点到目标顶点的更好路径。如果有这样的边/路径，那么顶点的值将被更新。
- en: Let's define two functions *distance(v)* and *distance(s, t)*, where *distance(v)*
    gives the value of a vertex and *distance(s,t)* gives the value of the edge connecting
    *s* to *t*.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义两个函数*distance(v)*和*distance(s, t)*，其中*distance(v)*给出一个顶点的值，*distance(s,t)*给出连接*s*到*t*的边的值。
- en: In Iteration 1, every user except John is set to infinity and John is at 0,
    since he is the source vertex. Now, we use Pregel to loop through the vertices
    and check whether there is anything better than infinity. Using Ken as an example,
    we will check if *distance("John") + distance("John", "Ken") < distance("Ken")*.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一次迭代中，除了John之外的每个用户都被设置为无穷大，John的值为0，因为他是源顶点。现在，我们使用Pregel循环遍历顶点，并检查是否有比无穷大更好的路径。以Ken为例，我们将检查*distance("John")
    + distance("John", "Ken") < distance("Ken")*。
- en: This is equivalent to checking whether *0 + 5 < Infinity*, which is `true`;
    so we update Ken's distance to *5*.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当于检查*0 + 5 < 无穷大*，结果是`true`；所以我们将Ken的距离更新为*5*。
- en: Similarly, we check for Mary, *distance("Ken") + distance("Ken", "Mary") < distance("Mary")*,
    which turns out to be `false`, since at that time Ken is still at infinity. Hence,
    in iteration 1, we could only update the users who are connected to John.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们检查Mary，*distance("Ken") + distance("Ken", "Mary") < distance("Mary")*，结果是`false`，因为那时Ken仍然是无穷大。因此，在第一次迭代中，我们只能更新与John相连的用户。
- en: In the next iteration, Mary, Liz, Eric and so on, are all updated since now
    we have updated values for Ken, Mark, and Sam from iteration 1\. This continues
    for a number of iterations specified in the Pregel API call.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一次迭代中，Mary、Liz、Eric等等，都会被更新，因为现在我们已经更新了Ken、Mark和Sam在第一次迭代中的数值。这将持续一段时间，具体次数由Pregel
    API调用中指定。
- en: 'Shown below are the illustrations of the various iterations when computing
    single source shortest path on the graph:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是在计算图上的单源最短路径时的各种迭代的示例：
- en: '![](img/00038.jpeg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00038.jpeg)'
- en: 'The shortest paths from **John** to **Larry** after four iterations shows that
    the shortest path is five miles. The path from **John** to **Larry** can be seen
    if you follow the path **John** | **Mark** | **Sam** | **Larry**:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 经过四次迭代后，从**John**到**Larry**的最短路径显示为五英里。从**John**到**Larry**的路径可以通过**John** |
    **Mark** | **Sam** | **Larry**来看到。
- en: '![](img/00275.jpeg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00275.jpeg)'
- en: PageRank
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PageRank
- en: '**PageRank** is one of the most important algorithms in the graph processing
    space. Originating at Google, the algorithm named after Larry page, the founder
    of Google, has evolved into many types of use cases based on the concept of ranking
    vertices or nodes based on relationships or edges.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '**PageRank**是图处理领域中最重要的算法之一。这个算法起源于谷歌，以谷歌创始人拉里·佩奇的名字命名，基于根据关系或边对顶点或节点进行排名的概念，已经发展成许多类型的用例。'
- en: Google PageRank works by counting the number and quality of links to a page
    to determine a rough estimate of how important the website is. The underlying
    assumption is that more important websites are likely to receive more links from
    other websites. For more information, you can read the description at [https://en.wikipedia.org/wiki/PageRank](https://en.wikipedia.org/wiki/PageRank)
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: Google PageRank通过计算指向页面的链接数量和质量来确定网站的重要性的大致估计。基本假设是更重要的网站很可能会从其他网站获得更多的链接。有关更多信息，您可以阅读[https://en.wikipedia.org/wiki/PageRank](https://en.wikipedia.org/wiki/PageRank)中的描述。
- en: Using Google PageRank as an example, you can improve the relative importance
    of a web page on your company website or maybe your blog by promoting the web
    page among other popular websites and technical blogs. Using this approach, your
    blog website may appear in Google search results about some article higher than
    other similar web pages, if there are a lot of third-party websites, which show
    your blog website and the content.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 以Google PageRank为例，您可以通过在其他流行网站和技术博客中推广网页来提高公司网站或博客上网页的相对重要性。使用这种方法，如果有很多第三方网站展示您的博客网站和内容，您的博客网站可能会在Google搜索结果中关于某篇文章的排名比其他类似网页更高。
- en: '**Search Engine Optimization** (**SEO**) is one of the biggest industries in
    the marketing world, where pretty much every website out there is investing into
    this technology. SEO involves various techniques and strategies essentially to
    improve how far up your website appears in any search engine results when anyone
    searches for some relevant words. This is based on Google PageRank-like concept.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '**搜索引擎优化**（**SEO**）是营销世界中最大的行业之一，几乎每个网站都在投资这项技术。SEO涉及各种技术和策略，基本上是为了提高你的网站在任何搜索引擎结果中出现的排名，当有人搜索相关词语时。这是基于Google
    PageRank的概念。'
- en: If you consider web pages as nodes/vertices and the hyperlinks between the web
    pages as edges, we essentially created a graph. Now, if you can count the rank
    of a web page as the number of hyperlinks/edges pointed into such as your `myblog.com`
    site having links on `cnn.com` or `msnbc.com` so that a user can click on the
    link and come to your `myblog.com` page. This can be a factor representing the
    importance of the `myblog.com` vertex. If we apply this simple logic recursively,
    we eventually end up with a rank assigned to each vertex calculated using the
    number of incoming edges and PageRank based on the ranks of the source vertices.
    A page that is linked to by many pages with high PageRank receives a high rank
    itself. Let's look at how to solve the PageRank problem at a big data scale using
    Spark GraphX. As we have seen, PageRank measures the importance of each vertex
    in a graph, assuming an edge from **a** to **b** represents the value of **b**
    boosted by **a**. For example, if a Twitter user is followed by many others, the
    user will be ranked highly.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你把网页看作节点/顶点，网页之间的超链接看作边，我们实际上创建了一个图。现在，如果你可以把网页的排名看作指向它的超链接/边的数量，比如你的`myblog.com`网站在`cnn.com`或`msnbc.com`上有链接，这样用户就可以点击链接来到你的`myblog.com`页面。这可以作为代表`myblog.com`顶点重要性的因素。如果我们递归应用这个简单的逻辑，最终我们会得到每个顶点的排名，这是根据入边的数量和基于源顶点排名的PageRank计算得出的。一个被许多具有高PageRank的页面链接的页面本身也会获得高排名。让我们看看如何使用Spark
    GraphX解决大数据规模下的PageRank问题。正如我们所见，PageRank衡量了图中每个顶点的重要性，假设从**a**到**b**的边代表了**b**由**a**提升的价值。例如，如果一个Twitter用户被许多其他用户关注，那么该用户将被高排名。
- en: 'GraphX comes with static and dynamic implementations of PageRank as methods
    on the `pageRank` object. Static PageRank runs for a fixed number of iterations,
    while dynamic PageRank runs until the ranks converge. `GraphOps` allows calling
    these algorithms directly as methods on the graph:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: GraphX提供了PageRank的静态和动态实现，作为`pageRank`对象的方法。静态PageRank运行固定次数的迭代，而动态PageRank则运行直到排名收敛。`GraphOps`允许直接调用这些算法作为图上的方法：
- en: '[PRE27]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The diagram of the PageRank algorithm on the graph is as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: PageRank算法在图上的图表如下：
- en: '![](img/00309.jpeg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00309.jpeg)'
- en: Summary
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have introduced graph theory using Facebook as an example;
    Apache Spark's graph processing library GraphX, `VertexRDD`, and EdgeRDDs; graph
    operators, `aggregateMessages`, `TriangleCounting`, and the Pregel API; and use
    cases such as the PageRank algorithm. We have also seen the traveling salesman
    problem and connected components and so on. We have seen how the GraphX API can
    be used to develop graph processing algorithms at scale.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们以Facebook为例介绍了图论；Apache Spark的图处理库GraphX，`VertexRDD`和EdgeRDDs；图操作符，`aggregateMessages`，`TriangleCounting`和Pregel
    API；以及PageRank算法等用例。我们还看到了旅行推销员问题和连通组件等。我们看到了GraphX API如何用于开发大规模图处理算法。
- en: In [Chapter 11](part0343.html#A73GU1-21aec46d8593429cacea59dbdcd64e1c), *Learning
    Machine Learning - Spark MLlib and ML*, we will explore the exciting world of
    Apache Spark's Machine Learning library.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第11章](part0343.html#A73GU1-21aec46d8593429cacea59dbdcd64e1c)中，*学习机器学习 - Spark
    MLlib和ML*，我们将探索Apache Spark的机器学习库的激动人心的世界。
