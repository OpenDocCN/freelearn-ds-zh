- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Vectors and Vector Spaces
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 向量和向量空间
- en: ”I want to point out that the class of abstract linear spaces is no larger than
    the class of spaces whose elements are arrays. So what is gained by abstraction?
    First of all, the freedom to use a single symbol for an array; this way we can
    think of vectors as basic building blocks, unencumbered by components. The abstract
    view leads to simple, transparent proofs of results.”
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “我想指出的是，抽象线性空间的类并不比元素为数组的空间类大。那么抽象带来了什么好处呢？首先，我们可以使用单一符号表示数组；这样我们可以把向量看作是基本构建块，不受分量的束缚。抽象视角导致结果简单、透明的证明。”
- en: ''
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: — Peter D. Lax, in Chapter 1 of his book Linear Algebra and its Applications
  id: totrans-4
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: — 彼得·D·拉克斯，在他的书《线性代数及其应用》第一章中
- en: 'The mathematics of machine learning rests upon three pillars: linear algebra,
    calculus, and probability theory. Linear algebra describes how to represent and
    manipulate data; calculus helps us fit the models; while probability theory helps
    interpret them.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 机器学习的数学基础建立在三大支柱之上：线性代数、微积分和概率论。线性代数描述了如何表示和操作数据；微积分帮助我们拟合模型；而概率论则帮助解释这些模型。
- en: 'These build on top of each other, and we will start at the beginning: representing
    and manipulating data.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这些内容相互依赖，我们将从最基础开始：表示和操作数据。
- en: 'To guide us throughout this section, we will look at the famous Iris dataset
    ( [https://en.wikipedia.org/wiki/Iris_flower_data_set](https://en.wikipedia.org/wiki/Iris_flower_data_set)).
    This contains the measurements from three species of Iris: the lengths and widths
    of sepals and petals. Each data point includes these four measurements, for which
    we also have the corresponding species: Iris setosa, Iris virginica, or Iris versicolor.
    (Sepals are the typically green, leaf-like structures at the base of a flower
    that protect the developing bud before it opens. Petals are the colorful, soft
    parts of a flower that attract pollinators like insects or birds.)'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将以著名的鸢尾花数据集为指导（[https://en.wikipedia.org/wiki/Iris_flower_data_set](https://en.wikipedia.org/wiki/Iris_flower_data_set)）。这包含了三种鸢尾花的测量数据：萼片和花瓣的长度和宽度。每个数据点包括这四个测量值，以及相应的鸢尾花种类：山鸢尾、维吉尼亚鸢尾或变色鸢尾。（萼片是花朵基部的通常是绿色的、类似叶片的结构，在花开放之前保护发育中的芽。花瓣是花朵的色彩鲜艳、柔软的部分，吸引传粉者如昆虫或鸟类。）
- en: The dataset can be loaded right away from scikit-learn ([https://scikit-learn.org/](https://scikit-learn.org/)),
    so let’s take a look!
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 数据集可以直接从 scikit-learn（[https://scikit-learn.org/](https://scikit-learn.org/)）加载，让我们来看一下！
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Before going into the mathematical definitions, let’s establish a common vocabulary
    first. The measurements themselves are stored in a tabular format. Rows represent
    samples, and columns represent measurements. A particular measurement type is
    often called a feature. As X.shape tells us, the Iris dataset has 150 data points
    and four features:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入数学定义之前，让我们先建立一个共同的词汇表。测量数据本身以表格格式存储。行代表样本，列代表测量值。特定的测量类型通常称为特征。正如 X.shape
    所示，鸢尾花数据集有 150 个数据点和四个特征：
- en: '[PRE2]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: (Don’t worry if you are not familiar with NumPy. We’ll learn about the details
    in due time. For now, it’s enough to understand that an array’s shape describes
    its dimensions.)
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: （如果你对 NumPy 不熟悉也不要担心。我们会逐步学习细节。现在，理解数组的形状描述其维度就足够了。）
- en: 'For a given sample, the corresponding species is called the label. In our case,
    this is either Iris setosa, Iris virginica, or Iris versicolor. Here, the labels
    are encoded with the numbers 0, 1, and 2:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 对于给定的样本，相应的鸢尾花种类称为标签。在我们的情况下，这可以是山鸢尾、维吉尼亚鸢尾或变色鸢尾。这里，标签用数字 0、1 和 2 编码：
- en: '[PRE4]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In mathematical terms, the Iris dataset forms a matrix, and the data points
    form vectors. Simply speaking, matrices are tables, while vectors are tuples.
    (Tuples are just finite and ordered sequences of objects, like (1.297,−2.35,32.3,29.874).)
    However, this simplistic view doesn’t show us the big picture. Vectors and matrices
    have a beautiful geometrical and algebraic structure, and exploring their mathematical
    theory allows us to see the patterns behind the data.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 从数学角度来看，鸢尾花数据集形成一个矩阵，数据点形成向量。简而言之，矩阵是表格，而向量是元组。（元组只是对象的有限和有序序列，例如 (1.297,−2.35,32.3,29.874)。）然而，这种简单化的观点并没有展示出整体图景。向量和矩阵具有美丽的几何和代数结构，探索它们的数学理论使我们能够看到数据背后的模式。
- en: How so? Say, besides representing the data points in a compact form, we want
    to perform operations on them, like addition and scalar multiplication. Why do
    we need to add data points together? To give you a simple example, it is often
    beneficial if the features are on the same scale. If a given feature is distributed
    on a smaller scale than the others, it will have less influence on the predictions.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 怎么回事呢？假设除了将数据点以紧凑的形式表示外，我们还想对它们进行操作，如加法和标量乘法。为什么我们需要将数据点相加？举个简单的例子，如果特征都在同一尺度上，通常会更有利。如果某个特征的分布尺度比其他特征小，它对预测的影响会较小。
- en: 'Think about this: if somebody is whispering to you something from the next
    room while speakers blast loud music right next to your ear, you won’t hear anything
    of what the person is saying to you. Large-scale features are the blasting music,
    while the smaller ones are the whisper. You may obtain much more information from
    the whisper, but you need to quiet down the music first.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 想一想这个场景：如果有人在隔壁房间低声对你说话，而扬声器就在你耳边放着大声的音乐，那么你根本听不到那个人说的任何话。大规模的特征就像那震耳欲聋的音乐，而较小的特征就像那低语。你可能从低语中获得更多信息，但首先你需要把音乐调小。
- en: To see this phenomenon in action, let’s take a look at the distribution of the
    features of our dataset!
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到这个现象的实际效果，让我们看看数据集特征的分布情况！
- en: '[PRE6]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '![PIC](img/file3.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file3.png)'
- en: 'Figure 1.1: The raw features of the Iris dataset'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1：鸢尾花数据集的原始特征
- en: You can see in the figure above that some are more stretched out (like sepal
    length), while others are narrower (like sepal width). In practical scenarios,
    this can hurt the predictive performance of our algorithms.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从上图中看到，有些特征的分布较为扩展（如花萼长度），而有些则较为紧凑（如花萼宽度）。在实际应用中，这可能会影响我们算法的预测性能。
- en: To solve it, we can remove the mean and the standard deviation of a dataset.
    If the dataset consists of the vectors x[1],x[2],…,x[150] , we can calculate their
    mean by
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们可以去除数据集的均值和标准差。如果数据集由向量 x[1], x[2], …, x[150] 组成，我们可以通过以下方式计算它们的均值：
- en: '![ 150 μ = -1--∑ x ∈ ℝ4 150 i=1 i ](img/file4.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![ 150 μ = -1--∑ x ∈ ℝ4 150 i=1 i ](img/file4.png)'
- en: and their standard deviation by
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 以及它们的标准差
- en: '![ ┌ ---------------- ││ 1 1∑50 σ = ∘ ---- (xi − μ )2 ∈ ℝ4, 150 i=1 ](img/file5.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![ ┌ ---------------- ││ 1 1∑50 σ = ∘ ---- (xi − μ )2 ∈ ℝ4, 150 i=1 ](img/file5.png)'
- en: where the subtraction and square operation in (x[i] −μ)² is taken elementwise.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 其中在 (x[i] −μ)² 中的减法和平方操作是逐元素进行的。
- en: The components of μ = (μ[1],μ[2],μ[3],μ[4]) and σ = (σ[1],σ[2],σ[3],σ[4]) are
    the means and variances of the individual features. (Recall that the Iris dataset
    contains 150 samples and 4 features per sample.)
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: μ = (μ[1], μ[2], μ[3], μ[4]) 和 σ = (σ[1], σ[2], σ[3], σ[4]) 这些分量是各个特征的均值和方差。（回想一下，鸢尾花数据集包含150个样本，每个样本有4个特征。）
- en: In other words, the mean describes the average of samples, while the standard
    deviation represents the average distance from the mean. The larger the standard
    deviation is, the more spread out the samples are.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，均值描述了样本的平均值，而标准差则代表了样本与均值的平均距离。标准差越大，样本的分布就越广。
- en: With these quantities, the scaled dataset can be described as
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 利用这些量，尺度化的数据集可以描述为
- en: '![x1-−-μ- x2-−-μ- x150-−-μ σ , σ ,..., σ , ](img/file6.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![x1-−-μ- x2-−-μ- x150-−-μ σ , σ ,..., σ , ](img/file6.png)'
- en: where both the subtraction and the division are taken elementwise.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 其中减法和除法都是逐元素进行的。
- en: If you are familiar with Python and NumPy, this is how it is done. (Don’t worry
    if you are not – everything you need to know about them will be explained in the
    next chapter, with example code.)
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉 Python 和 NumPy，操作是这样的。（如果你不熟悉也没关系——关于它们的所有内容将在下一章中解释，并附有示例代码。）
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '![PIC](img/file9.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file9.png)'
- en: 'Figure 1.2: The scaled features of the Iris dataset'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.2：鸢尾花数据集的尺度化特征
- en: If you compare the modified version to the original, you can see that its features
    are on the same scale. In other words, we transformed the dataset to a more expressive
    one. From a (very) abstract point of view, machine learning is nothing else but
    a series of learned data transformations, turning raw data into a form where prediction
    is simple.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将修改后的版本与原始数据进行比较，你会发现它的特征都在相同的尺度上。换句话说，我们将数据集转换成了一个更具表现力的数据集。从一个（非常）抽象的角度来看，机器学习其实就是一系列学到的数据转换，将原始数据转换成一种预测简单的形式。
- en: In a mathematical setting, manipulating data and modeling its relations to the
    labels arise from the concept of vector spaces and transformations between them.
    Let’s take the first steps by making the definition of vector spaces precise!
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在数学环境中，数据操作和标签之间关系的建模源于向量空间及其之间的变换概念。让我们通过精确定义向量空间来迈出第一步！
- en: 1.1 What is a vector space?
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.1 什么是向量空间？
- en: Representing multiple measurements as a tuple (x[1],x[2],…,x[n]) is a natural
    idea that has a ton of merits. The tuple form suggests that the components belong
    together in a precise order, giving a clear and concise way to store information.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 将多个测量值表示为一个元组（x[1], x[2], …, x[n]）是一个自然的想法，具有很多优点。元组的形式暗示了各个分量按精确的顺序排列，提供了一种清晰简洁的方式来存储信息。
- en: 'However, this comes at a cost: now we have to work with more complex objects.
    Despite dealing with tuples like (x[1],…,x[n]) instead of numbers, there are similarities.
    For instance, any two tuple x = (x[1],…,x[n]) and y = (y[1],…,y[n])'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这也有代价：现在我们不得不处理更复杂的对象。尽管我们处理的是像 (x[1], …, x[n]) 这样的元组而不是数字，但它们之间仍有相似性。例如，任何两个元组
    x = (x[1], …, x[n]) 和 y = (y[1], …, y[n])，
- en: can be added together by x+ y = (x[1] + y[1],…,x[n] + y[n]),
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以通过 x + y = (x[1] + y[1], …, x[n] + y[n]) 来相加，
- en: 'and can be multiplied with scalars: if c ∈ℝ, then cx = (cx[1],…,cx[n]).'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并且可以与标量相乘：如果 c ∈ ℝ，则 cx = (cx[1], …, cx[n])。
- en: It’s almost like using a number.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这几乎就像使用一个数字一样。
- en: These operations have clear geometric interpretations as well. Addition is the
    same as translation, while multiplication with a scalar is a simple stretching.
    (Or squeezing, if |c|<1.)
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这些运算也有明确的几何解释。加法与平移相同，而与标量的乘法则是简单的拉伸。（如果 |c| < 1，则是压缩。）
- en: '![PIC](img/file10.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file10.png)'
- en: 'Figure 1.3: Geometric interpretation of addition and scalar multiplication'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.3：加法和标量乘法的几何解释
- en: On the other hand, if we want to follow our geometric intuition (which we definitely
    do), it is unclear how to define vector multiplication. Even though the definition
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果我们想要遵循几何直觉（我们肯定是这么做的），那么如何定义向量乘法就不太清楚了。尽管有定义，
- en: '![xy = (x1y1,...,xnyn) ](img/file11.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![xy = (x1y1,...,xnyn)](img/file11.png)'
- en: makes sense algebraically, we don’t see what it means in a geometric sense.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 从代数角度来看是有意义的，但我们无法从几何角度理解它的含义。
- en: When we think about vectors and vector spaces, we are thinking about a mathematical
    structure that fits our intuitive views and expectations. So, let’s turn these
    into the definition!
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们思考向量和向量空间时，我们是在思考一种数学结构，这种结构符合我们的直觉观点和预期。让我们将这些转化为定义！
- en: Definition 2\. (Vector spaces)
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 2.（向量空间）
- en: A vector space is a mathematical structure (V,F,+,⋅), where
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 向量空间是一个数学结构（V, F, +, ⋅），其中
- en: (a) V is the set of vectors,
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: (a) V 是向量的集合，
- en: (b) F is a field of scalars (most commonly the real numbers ℝ or the complex
    numbers ℂ),
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: (b) F 是标量域（最常见的是实数 ℝ 或复数 ℂ），
- en: '(c) + : V ×V → V is the addition operation, satisfying the following properties:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '(c) + : V × V → V 是加法运算，满足以下性质：'
- en: x+ y = y + x (commutativity),
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: x + y = y + x（交换律），
- en: x+ (y + z) = (x+ y) + z (associativity),
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: x + (y + z) = (x + y) + z（结合律），
- en: there is an element 0 ∈V such that x + 0 = x (existence of the null vector),
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存在一个元素 0 ∈ V，使得 x + 0 = x（零向量的存在性），
- en: and there is an inverse −x ∈V for each x ∈V such that x+(−x) = 0 (existence
    of additive inverses)
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于每个 x ∈ V，都存在一个逆元素 −x ∈ V，使得 x + (−x) = 0（加法逆元的存在性）
- en: for all vectors x,y,z ∈V ,
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有的向量 x, y, z ∈ V，
- en: '(d) and ⋅ : F ×V →V is the scalar multiplication operation, satisfying'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '(d) 以及 ⋅ : F × V → V 是标量乘法运算，满足'
- en: a(bx) = (ab)x (associativity),
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: a(bx) = (ab)x（结合律），
- en: a(x+ y) = ax + ay (distributivity),
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: a(x + y) = ax + ay（分配律），
- en: and 1x = x
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 且 1x = x
- en: for all scalars a,b ∈F and vectors x,y ∈V .
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有的标量 a, b ∈ F 和向量 x, y ∈ V。
- en: This definition is overloaded with new concepts, so let’s unpack it.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这个定义包含了很多新的概念，我们来逐步拆解它。
- en: First, looking at operations like addition and scalar multiplication as functions
    might be unusual for you, but this is a perfectly natural representation. (We’ll
    learn about functions later in detail, but for now, feel free to think about them
    intuitively.) In writing, we use the notation x + y , but when thinking about
    + as a function of two variables, we might as well write +(x,y). The form x +
    y is called infix notation, while +(x,y) is called prefix notation.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将加法和标量乘法等运算视为函数对你来说可能不太习惯，但这是一种完全自然的表示方式。（我们稍后会详细学习函数，但现在可以直观地理解它们。）在写作中，我们使用符号
    x + y，但当将 + 视为两个变量的函数时，我们也可以写作 +(x, y)。形式 x + y 称为中缀表示法，而 +(x, y) 则称为前缀表示法。
- en: In vector spaces, the inputs of addition are two vectors and the result is a
    single vector, thus + is a function that maps the Cartesian product V ×V to V
    .
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在向量空间中，加法的输入是两个向量，结果是一个单一的向量，因此 + 是一个将笛卡尔积V × V 映射到V的函数。
- en: Similarly, scalar multiplication takes a scalar and a vector, resulting in a
    vector; meaning a function that maps F ×V to V .
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，标量乘法接收一个标量和一个向量，结果是一个向量；也就是说，它是一个将F × V 映射到V的函数。
- en: '(The Cartesian product V ×V is just a set of ordered pairs:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: （笛卡尔积V × V 只是一个有序对的集合：
- en: '![V × V = {(u,v) : u,v ∈ V }. ](img/file12.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![V × V = {(u,v) : u,v ∈ V }. ](img/file12.png)'
- en: Feel free to check out the set theory appendix (Appendix [C](ch037.xhtml#basics-of-set-theory))
    for more details, but for now, the intuitive understanding is enough.)
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 随时可以查看集合论附录（附录[C](ch037.xhtml#basics-of-set-theory)）了解更多细节，但目前，直观理解已经足够了。
- en: This is also good place to note that mathematical definitions are always formalized
    in hindsight, after the objects themselves are somewhat crystallized and familiar
    to the users. Mathematics is often presented as definitions first, theorems second.
    This is not how it is done in practice. Examples motivate definitions, not the
    other way around.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这里也需要指出，数学定义总是在事后形式化的，即在对象本身有一定的具体化并且对用户变得熟悉之后。数学通常是先定义，再定理。这并不是实际操作中的做法。示例激发定义，而不是相反。
- en: In general, the field of scalars can be something other than real or complex
    numbers. The term field refers to a well-defined mathematical structure, which
    makes a natural notion mathematically precise. Without going into the technical
    details, we will think about fields as “a set of numbers where addition and multiplication
    work just as for real numbers”.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，标量域可以是实数或复数以外的其他东西。域这个术语指的是一个定义明确的数学结构，它使自然概念在数学上变得精确。我们不深入技术细节，只需把域理解为“一个数字集合，其中加法和乘法的运算方式与实数相同”。
- en: Since we are not concerned with the most general case, we will use ℝ or ℂ to
    avoid unnecessary difficulty. If you are not familiar with the exact mathematical
    definition of a field, don’t worry – just think of ℝ each time you read the word
    “field”.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不关心最一般的情况，我们将使用ℝ或ℂ以避免不必要的困难。如果你不熟悉域的精确数学定义，不必担心——每次看到“域”这个词时，直接理解为ℝ就好。
- en: When everything is clear from the context, (V,ℝ,+,⋅) will often be referred
    to as V for notational simplicity. So, if the field F is not specified, it is
    implicitly assumed to be ℝ. When we want to emphasize this, we’ll call these real
    vector spaces.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当上下文中的所有内容都很清晰时，(V,ℝ,+,⋅)通常会简化为V以方便表示。所以，如果没有特别指定域F，则隐式假设F为ℝ。如果我们想要强调这一点，我们会称这些为实向量空间。
- en: At first sight, Definition [2](ch007.xhtml#x1-20004r2) is certainly too complex
    to comprehend. It seems like just a bunch of sets, operations, and properties
    thrown together. However, to help us build a mental model, we can imagine a vector
    as an arrow, starting from the null vector. (Recall that the null vector 0 is
    that special one for which x + 0 = x holds for all x. Thus, it can be considered
    as an arrow with zero length; the origin.)
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 初看起来，定义[2](ch007.xhtml#x1-20004r2)确实太复杂，难以理解。它看起来像是一堆集合、运算和属性的堆砌。然而，为了帮助我们建立一个心理模型，我们可以将向量想象成一支箭，从零向量开始。（回想一下，零向量0是那个对于所有x都有x
    + 0 = x成立的特殊向量。因此，它可以被视为一支零长度的箭；原点。）
- en: To further familiarize ourselves with the concept, let’s see some examples of
    vector spaces!
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地熟悉这一概念，让我们看一些向量空间的示例！
- en: 1.1.1 Examples of vector spaces
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.1.1 向量空间的示例
- en: Examples are one of the best ways of building insight into seemingly difficult
    concepts like vector spaces. We humans, usually think in terms of models instead
    of abstractions. (Yes, this includes pure mathematicians. Even though they might
    deny it.)
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 示例是构建对看似复杂的概念（如向量空间）理解的最佳方式之一。我们人类通常以模型而非抽象的形式进行思考。（是的，这也包括纯粹的数学家，尽管他们可能会否认这一点。）
- en: Example 1\. The most ubiquitous instance of the vector space is (ℝ^n,ℝ,+,⋅),
    the same one we used to motivate the definition itself. (ℝ^n refers to the n-fold
    Cartesian product of the set of real numbers. If you are unfamiliar with this
    notion, check the set theory tutorial in Appendix C.)
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 1. 向量空间最常见的实例是 (ℝ^n, ℝ, +, ⋅)，这就是我们用来激发定义本身的那个实例。（ℝ^n是实数集的n重笛卡尔积。如果你不熟悉这一概念，可以查看附录C中的集合论教程。）
- en: (ℝ^n,ℝ,+,⋅) is the canonical model, the one we use to guide us throughout our
    studies. If n = 2, we are simply talking about the familiar Euclidean plane.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: (ℝ^n,ℝ,+,⋅) 是标准模型，我们用它来指导我们整个学习过程。如果 n = 2，那么我们讨论的就是熟悉的欧几里得平面。
- en: '![PIC](img/file13.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file13.png)'
- en: 'Figure 1.4: The Euclidean plane as a vector space'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.4：欧几里得平面作为一个向量空间
- en: Using ℝ² or ℝ³ for visualization can help a lot. What works here will usually
    work in the general case, although sometimes this can be dangerous. Math relies
    on both intuition and logic. We develop ideas using our intuition, but we confirm
    them with our logic.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 ℝ² 或 ℝ³ 进行可视化会有很大帮助。这里有效的做法通常在一般情况下也有效，尽管有时这可能是危险的。数学依赖于直觉和逻辑。我们通过直觉发展思想，但用逻辑来验证它们。
- en: Example 2\. Vector spaces are not just a collection of finite tuples. An example
    is the space of polynomial functions with real coefficients, defined by
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 2\. 向量空间不仅仅是有限元组的集合。一个例子是具有实系数的多项式函数空间，定义为
- en: '![ ∑n ℝ [x ] = { pixi : pi ∈ ℝ, n = 0,1,...}. i=0 ](img/file14.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![ ∑n ℝ [x ] = { pixi : pi ∈ ℝ, n = 0,1,...}. i=0 ](img/file14.png)'
- en: Two polynomials p(x) and q(x) can be added together by
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 两个多项式 p(x) 和 q(x) 可以通过以下方式相加
- en: '![ ∑n i p(x)+ q(x) := (pi + qi)x , k=1 ](img/file15.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![ ∑n i p(x)+ q(x) := (pi + qi)x , k=1 ](img/file15.png)'
- en: and can be multiplied with a real scalar by
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 并且可以通过与实数标量相乘来运算
- en: '![ ∑n cp(x) = cpixi. k=1 ](img/file16.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![ ∑n cp(x) = cpixi. k=1 ](img/file16.png)'
- en: 'With these operations, (ℝ[x],ℝ,+,⋅) is a vector space. Although most of the
    time we percieve polynomials as functions, they can be represented as tuples of
    coefficients as well:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些运算，(ℝ[x],ℝ,+,⋅) 是一个向量空间。虽然我们大多数时候把多项式看作是函数，但它们也可以表示为系数的元组：
- en: '![∑n pixi ← → (p0,...,pn). i=0 ](img/file17.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![∑n pixi ← → (p0,...,pn). i=0 ](img/file17.png)'
- en: Note that n – the degree of the polynomial – is unbounded. As a consequence,
    this vector space has a significantly richer structure than ℝ^n.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，n——多项式的次数——是没有上限的。因此，这个向量空间的结构比 ℝ^n 更加丰富。
- en: 'Example 3\. The previous example can be further generalized. Let C([0,1]) denote
    the set of all continuous real functions f : [0,1] →ℝ. Then (C(ℝ),ℝ,+,⋅) is a
    vector space, where the addition and scalar multiplication are defined elementwise:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 3\. 之前的例子可以进一步推广。设 C([0,1]) 表示所有连续实值函数 f : [0,1] →ℝ 的集合。那么 (C(ℝ),ℝ,+,⋅)
    是一个向量空间，其中加法和标量乘法是按元素定义的：'
- en: '![(f + g )(x) := f(x)+ g(x), (cf)(x) = cf (x ) ](img/file18.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![(f + g )(x) := f(x)+ g(x), (cf)(x) = cf (x ) ](img/file18.png)'
- en: for all f,g ∈C(ℝ) and c ∈ℝ. (Although continuity is a concept that we haven’t
    defined yet, feel free to think of a continuous function as one whose graph can
    be drawn without lifting your pen.)
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有 f,g ∈C(ℝ) 和 c ∈ℝ。（尽管连续性是我们还未定义的概念，但可以把连续函数看作是图像可以在不抬起笔的情况下绘制的函数。）
- en: 'Yes, that is right: functions can be thought of as vectors as well. Spaces
    of functions play a significant role in mathematics, and they come in several
    different forms. We often restrict the space to continuous functions, differentiable
    functions, or basically any subset that is closed under the given operations.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，没错：函数也可以看作是向量。函数空间在数学中扮演着重要角色，它们有多种不同的形式。我们经常将空间限制为连续函数、可微分函数，或者基本上是任何在给定运算下封闭的子集。
- en: (In fact, ℝ^n can be also thought of as a function space. From an abstract viewpoint,
    each vector x = (x[1],…,x[n]) is a mapping from {1,2,…,n} to ℝ.)
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: （事实上，ℝ^n 也可以看作是一个函数空间。从抽象的角度来看，每个向量 x = (x[1],…,x[n]) 是从 {1,2,…,n} 到 ℝ 的映射。）
- en: Function spaces are encountered in more advanced topics, such as [inverting
    ResNet architectures](http://proceedings.mlr.press/v97/behrmann19a/behrmann19a.pdf),
    which we won’t deal with in this book. However, it is worth seeing examples that
    are different (and not as straightforward) as ℝ^n.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 函数空间出现在更高级的主题中，例如 [反转 ResNet 架构](http://proceedings.mlr.press/v97/behrmann19a/behrmann19a.pdf)，我们在本书中不会讨论这些内容。然而，看到一些不同的（而且不那么直观的）例子是值得的，像
    ℝ^n 这样的例子就不算是直观的。
- en: 1.2 The basis
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.2 基底
- en: Although our vector spaces contain infinitely many vectors, we can reduce the
    complexity by finding special subsets that can express any other vector.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们的向量空间包含无限多个向量，但我们可以通过找到特殊的子集来简化复杂度，这些子集能够表示任何其他向量。
- en: To make this idea precise, let’s consider our recurring example ℝ^n. There,
    we have a special vector set
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个概念更加明确，让我们考虑我们反复提到的例子 ℝ^n。在这里，我们有一个特殊的向量集合
- en: '| e[1] | = (1,0,…,0) |  |  |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| e[1] | = (1,0,…,0) |  |  |'
- en: '| e[2] | = (0,1,…,0) |  |  |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| e[2] | = (0,1,…,0) |  |  |'
- en: '|  | ![.. .](img/file19.png) |  |  |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '|  | ![.. .](img/file19.png) |  |  |'
- en: '| e[n] | = (0,0,…,1) |  |  |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| e[n] | = (0,0,…,1) |  |  |'
- en: which can be used to express each vector x = (x[1],…,x[n]) as
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以用来将每个向量 x = (x[1],…,x[n]) 表示为
- en: '![ n x = ∑ xe , x ∈ ℝ, e ∈ ℝn i i i i i=1 ](img/file20.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![ n x = ∑ xe , x ∈ ℝ, e ∈ ℝn i i i i i=1 ](img/file20.png)'
- en: For instance, e[1] = (1,0) and e[2] = (0,1) in ℝ².
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，e[1] = (1,0) 和 e[2] = (0,1) 在ℝ²中。
- en: What we have just seen feels extremely trivial and it seems to only complicate
    things. Why would we need to write vectors in the form of x = ∑ [i=1]^nx[i]e[i],
    instead of simply using the coordinates (x[1],…,x[n]) ? Because, in fact, the
    coordinate notation depends on the underlying vector set ({e[1],…,e[n]} in our
    case) used to express other vectors.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚看到的内容似乎极其简单，而且看起来只是让事情变得更加复杂。为什么我们需要将向量写成x = ∑ [i=1]^nx[i]e[i]的形式，而不是简单地使用坐标(x[1],…,x[n])？因为，实际上，坐标表示法依赖于用来表示其他向量的基础向量集（在我们这里是{e[1],…,e[n]}）。
- en: A vector is not the same as its coordinates! A single vector can have multiple
    different coordinates in different systems, and switching between these is a useful
    tool.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 向量不同于它的坐标！同一个向量在不同的坐标系统中可以有多个不同的坐标，转换这些坐标是一个有用的工具。
- en: Thus, the set E = {e[1],…,e[n]}⊆ℝ^n is rather special, as it significantly reduces
    the complexity of representing vectors. With the vector addition and scalar multiplication
    operations, it spans our vector space entirely. E is an instance of a vector space
    basis, a set that serves as a skeleton of ℝ^n.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，集合E = {e[1],…,e[n]}⊆ℝ^n非常特殊，因为它显著简化了向量的表示。通过向量加法和标量乘法操作，它完全生成了我们的向量空间。E是向量空间基的一个例子，作为ℝ^n的骨架。
- en: In this section, we are going to introduce and study the concept of vector space
    basis in detail.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将详细介绍并研究向量空间基的概念。
- en: 1.2.1 Linear combinations and independence
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2.1 线性组合与独立性
- en: Let’s zoom out from the special case ℝ^n and start talking about general vector
    spaces. From our motivating example regarding bases, we have seen that sums of
    the form
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从特殊情况ℝ^n缩小视野，开始讨论一般的向量空间。通过我们关于基的启发式例子，我们已经看到像这样的和式
- en: '![∑n xivi, i=1 ](img/file21.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![∑n xivi, i=1 ](img/file21.png)'
- en: where the v[i]-s are vectors and the x[i] coefficients are scalars, play a crucial
    role. These are called linear combinations. A linear combination is called trivial
    if all of the coefficients are zero.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 其中v[i]是向量，x[i]系数是标量，这些在线性组合中起着至关重要的作用。当所有系数为零时，线性组合被称为平凡的。
- en: Given a set of vectors, the same vector can potentially be expressed as a linear
    combination in multiple ways. For example, if v[1] = (1,0),v[2] = (0,1), and v[3]
    = (1,1), then
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一组向量，同一个向量可能以多种方式表示为线性组合。例如，如果v[1] = (1,0)，v[2] = (0,1)，v[3] = (1,1)，那么
- en: '| (2,1) | = 2v[1] + v[2] |  |  |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| (2,1) | = 2v[1] + v[2] |  |  |'
- en: '|  | = v[1] + v[3]. |  |  |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '|  | = v[1] + v[3]. |  |  |'
- en: This suggests that the set S = {v[1],v[2],v[3]} is redundant, as it contains
    duplicate information. The concept of linear dependence and independence makes
    this precise.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明集合S = {v[1],v[2],v[3]}是多余的，因为它包含了重复的信息。线性相关性和独立性的概念使得这一点更加明确。
- en: Definition 3\. (Linear dependence and independence)
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 3\. （线性相关性与独立性）
- en: Let V be a vector space and S = {v[1],…,v[n]} be a subset of its vectors. S
    is said to be linearly dependent if it only contains the zero vector, or there
    is a nonzero v[k] that can be expressed as a linear combination of the other vectors
    v[1],…,v[k−1],v[k+1],…,v[n].
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 设V是一个向量空间，S = {v[1],…,v[n]}是其向量的一个子集。如果S只包含零向量，或者存在一个非零向量v[k]，它可以表示为其他向量v[1],…,v[k−1],v[k+1],…,v[n]的线性组合，则称S是线性相关的。
- en: S is said to be linearly independent if it is not linearly dependent.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: S被称为线性独立的，如果它不是线性相关的。
- en: Linear dependence and independence can be looked at from a different angle.
    If
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 线性相关性和独立性可以从不同角度来看。如果
- en: '![ k∑−1 ∑n vk = xivi + xivi, i=1 i=k+1 ](img/file22.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![ k∑−1 ∑n vk = xivi + xivi, i=1 i=k+1 ](img/file22.png)'
- en: for some nonzero v[k], then by subtracting v[k], we obtain that the null vector
    can be obtained as a nontrivial linear combination
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些非零v[k]，通过减去v[k]，我们得到零向量可以通过非平凡的线性组合得到。
- en: '![ ∑n 0 = xivi i=1 ](img/file23.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![ ∑n 0 = xivi i=1 ](img/file23.png)'
- en: for some scalars x[i], where x[k] = −1\. This is an equivalent definition of
    linear dependence. With this, we have proved the following theorem.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些标量x[i]，其中x[k] = −1。这是线性相关的等价定义。通过这一点，我们证明了以下定理。
- en: Theorem 2\.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 2\.
- en: Let V be a vector space and S = {v[1],…,v[n]}be a subset of its vectors.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 设V是一个向量空间，S = {v[1],…,v[n]}是其向量的一个子集。
- en: (a) S is linearly dependent if and only if the null vector 0 can be obtained
    as a nontrivial linear combination.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: (a) S是线性相关的，当且仅当零向量0可以通过非平凡的线性组合得到。
- en: (b) S is linearly independent if and only if whenever 0 = ∑ [i=1]^nx[i]v[i],
    all coefficients x[i] are zero.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: (b) 当且仅当 0 = ∑ [i=1]^nx[i]v[i] 时，所有系数 x[i] 都为零，S 是线性无关的。
- en: 1.2.2 Spans of vector sets
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2.2 向量集的张成
- en: Linear combinations provide a way to take a small set of vectors and generate
    a whole lot of others from them. For a set of vectors S, taking all of its possible
    linear combinations is called spanning, and the generated set is called the span.
    Formally, it is defined by
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 线性组合提供了一种方法，通过一个小的向量集合生成更多的向量。对于一个向量集合 S，取其所有可能的线性组合叫做张成，生成的集合叫做张成集合。形式化地，它定义为
- en: '![ ∑n span(S ) = { xivi : n ∈ ℕ, vi ∈ S,xi is a scalar}. i=1 ](img/file24.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![ ∑n span(S ) = { xivi : n ∈ ℕ, vi ∈ S,xi 是标量}. i=1 ](img/file24.png)'
- en: Note that the vector set S is not necessarily finite. To help illustrate the
    concept of span, we can visualize the process in three dimensions. The span of
    two linearly independent vectors is a plane.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，向量集合 S 不一定是有限的。为了帮助说明张成的概念，我们可以在三维空间中可视化这个过程。两个线性无关向量的张成是一个平面。
- en: '![PIC](img/file25.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file25.png)'
- en: 'Figure 1.5: The span of two linearly independent vectors u,v ∈ℝ³'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.5：两个线性无关向量 u,v ∈ ℝ³ 的张成
- en: When we talk about the span of a finite set {v[1],…,v[n]}, we denote the span
    as
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们讨论有限集合 {v[1],…,v[n]} 的张成时，我们表示其张成为
- en: '![span (v ,...,v ). 1 n ](img/file26.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![span (v ,...,v ). 1 n ](img/file26.png)'
- en: This helps us avoid overcomplicating notations by naming every set.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这样可以避免通过给每个集合命名来过度复杂化符号。
- en: Proposition 1\. Let V be a vector space and S,S[1],S[2] ⊆V be subsets of its
    vectors.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 命题 1\. 设 V 为一个向量空间，S, S[1], S[2] ⊆ V 为其向量的子集。
- en: (a) If S[1] ⊆S[2], then span(S[1]) ⊆ span(S[2]).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: (a) 如果 S[1] ⊆ S[2]，则 span(S[1]) ⊆ span(S[2])。
- en: (b) span(span(S)) = span(S).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: (b) span(span(S)) = span(S)。
- en: This is our very first proof! Give it a read, and if it’s too difficult, move
    on and revisit it later. Just make sure that you understand what the proposition
    says.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们第一次证明！读一读，如果太难，跳过，稍后再回来看。只要确保你理解了命题的内容。
- en: Proof. The property (a) follows directly from the definition. To prove (b),
    we have to show that span(S) ⊆ span(span(S)) and span(span(S)) ⊆ span(S).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。性质 (a) 直接由定义得出。为了证明 (b)，我们需要证明 span(S) ⊆ span(span(S)) 和 span(span(S)) ⊆
    span(S)。
- en: '(This is one of those steep learning curve moments, but think about it for
    a second: two sets A and B are equal if and only if A ⊆ B and B ⊆A.)'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: （这是一个学习曲线较陡的时刻，但想一想：两个集合 A 和 B 相等的充要条件是 A ⊆ B 且 B ⊆ A。）
- en: The former follows from the definition. For the latter, let x ∈ span(span(S)).
    Then
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 前者由定义得出。对于后者，设 x ∈ span(span(S))。那么
- en: '![ ∑n x = xivi i=1 ](img/file27.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![ ∑n x = xivi i=1 ](img/file27.png)'
- en: for some v[i] ∈ span(S). Because of v[i] being in the span of S, we have
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些 v[i] ∈ span(S)。由于 v[i] 在 S 的张成中，我们得到
- en: '![ ∑m vi = vi,juj j=1 ](img/file28.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![ ∑m vi = vi,juj j=1 ](img/file28.png)'
- en: for some u[j] ∈S. Thus,
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些 u[j] ∈ S。因此，
- en: '![ ∑n ∑n ∑m ∑m ∑n x = xivi = xi vi,juj = ( xivi,j)uj, i=1 i=1 j=1 j=1 i=1 ](img/file29.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![ ∑n ∑n ∑m ∑m ∑n x = xivi = xi vi,juj = ( xivi,j)uj, i=1 i=1 j=1 j=1 i=1 ](img/file29.png)'
- en: implying that x ∈ span(S) as well.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着 x ∈ span(S)。
- en: Because of span(span(S)) = span(S), if S is linearly dependent, we can remove
    the redundant vectors and still keep the span the same.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 span(span(S)) = span(S)，如果 S 是线性相关的，我们可以去除冗余的向量，仍然保持张成不变。
- en: 'Think about it: if S = {v[1],…,v[n]} and, say, v[n] = ∑ [i=1]^(n−1)x[i]v[i]
    , then v[n] ∈ span(S ∖{v[n]}). So,'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 想一想：如果 S = {v[1],…,v[n]}，假设 v[n] = ∑ [i=1]^(n−1)x[i]v[i]，那么 v[n] ∈ span(S ∖{v[n]}）。因此，
- en: '![span(S ∖{vn }) = span (span(S ∖ {vn})) = span (S ). ](img/file30.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![span(S ∖{vn }) = span (span(S ∖ {vn})) = span (S ). ](img/file30.png)'
- en: (The operation A ∖B is the set difference, containing all that are elements
    of A, but not elements of B. Feel free to check out Appendix C for more details.)
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: （操作 A ∖B 是集合差，包含所有属于 A 但不属于 B 的元素。详情请参见附录 C。）
- en: Among sets of vectors, those that generate the entire vector space are special.
    After all this setup, we are ready to make a formal definition. Any set of vectors
    S that have the property span(S) = V is called a generating set for V .
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在向量集合中，那些能生成整个向量空间的集合是特别的。经过这些铺垫，我们已经准备好做一个正式的定义。任何满足 span(S) = V 的向量集合 S 称为
    V 的生成集。
- en: 'S can be thought of as a “lossless compression” of V , as it contains all the
    information needed to reconstruct any element in V , yet it is smaller than the
    entire space. Thus, we want to reduce the size of the generating set as much as
    possible. This leads us to one of the most important concepts in linear algebra:
    minimal generating sets, or bases, as we prefer to call them.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: S 可以被看作是 V 的“无损压缩”，因为它包含了重建 V 中任何元素所需的所有信息，同时它比整个空间要小。因此，我们希望尽可能减少生成集的大小。这引出了线性代数中的一个最重要的概念：最小生成集，或者我们更愿意称之为基。
- en: 1.2.3 Bases, the minimal generating sets
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2.3 基与最小生成集
- en: With all the intuition we have built so far, let’s jump into the definition
    right away!
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 结合我们迄今为止建立的所有直觉，让我们立即进入定义吧！
- en: Definition 4\. (Basis)
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 4.（基）
- en: 'Let V be a vector space and S be a subset of its vectors. S is a basis of V
    if:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 设 V 为一个向量空间，S 为其向量的子集。如果 S 是 V 的基，则：
- en: (a) S is linearly independent,
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: (a) S 是线性无关的，
- en: (b) and span(S) = V .
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: (b) 且 span(S) = V。
- en: The elements of a basis set are called basis vectors.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 基集的元素称为基向量。
- en: It can be shown that these defining properties mean that every vector x can
    be uniquely written as a linear combination of S. (This is left as an exercise
    for the reader.)
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 可以证明这些定义性质意味着每个向量 x 都可以唯一地表示为 S 的线性组合。（这部分留给读者练习。）
- en: Let’s see some examples! In ℝ³, the set {(1,0,0),(0,1,0),(0,0,1)} is a basis,
    but so is {(1,1,1),(1,1,0),(0,1,1)}. So, there can be more than one basis for
    the same vector space.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一些例子！在 ℝ³ 中，集合 {(1,0,0),(0,1,0),(0,0,1)} 是一个基，但 {(1,1,1),(1,1,0),(0,1,1)}
    也是一个基。所以，同一个向量空间可以有多个基。
- en: For ℝ^n, the most commonly used basis is {e[1],…,e[n]}, where e[i] is a vector
    whose all coordinates are 0, except the i-th one, which is 1\. This is called
    the standard basis.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 ℝ^n，最常用的基是 {e[1],…,e[n]}，其中 e[i] 是一个向量，其所有坐标为 0，除了第 i 个坐标是 1。这个基称为标准基。
- en: In terms of the “information” contained in a set of vectors, bases hit the sweet
    spot. Adding any new vector to a basis set would introduce redundancy; removing
    any of its elements would cause the set to be incomplete.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 就“信息”而言，基向量集正好处于一个最佳的点上。向基集添加任何新向量会引入冗余；移除其中任何元素会导致集合不完整。
- en: These notions are formalized in the two theorems below.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这些概念在下面的两个定理中得到了形式化。
- en: Theorem 3\.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 3。
- en: 'Let V be a vector space and S = {v[1],…,v[n]} be a subset of vectors. The following
    are equivalent:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 设 V 为一个向量空间，S = {v[1],…,v[n]} 为其向量的子集。以下是等价的：
- en: (a) S is a basis.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: (a) S 是一个基。
- en: (b) S is linearly independent and for any x ∈V ∖S, the vector set S ∪{x} is
    linearly dependent. In other words, S is a maximal linearly independent set.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: (b) S 是线性无关的，且对于任何 x ∈V ∖S，向量集 S ∪{x} 是线性相关的。换句话说，S 是一个最大线性无关集。
- en: 'Proof. To show the equivalence of two propositions, we have to prove two things:
    that (a) implies (b); and that (b) implies (a). Let’s start with the first one!'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。为了证明两个命题的等价性，我们需要证明两件事：一是 (a) 推导出 (b)；二是 (b) 推导出 (a)。让我们从第一个开始！
- en: (a) ![=⇒](img/file31.png) (b) If S is a basis, then any x ∈V can be written
    as
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: (a) ![=⇒](img/file31.png) (b) 如果 S 是基，那么任何 x ∈V 都可以表示为
- en: '![ n ∑ x = xivi i=1 ](img/file32.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![ n ∑ x = xivi i=1 ](img/file32.png)'
- en: for some x[i] ∈ℝ. Thus, by definition, S ∪{x} is linearly dependent.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些 x[i] ∈ℝ。因此，根据定义，S ∪{x} 是线性相关的。
- en: '(b) ![=⇒](img/file33.png) (a) Our goal is to show that any x can be written
    as a linear combination of the vectors in S. By our assumption, S ∪{x} is linearly
    dependent, so 0 can be written as a nontrivial linear combination:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: (b) ![=⇒](img/file33.png) (a) 我们的目标是证明任何 x 都可以表示为 S 中向量的线性组合。根据我们的假设，S ∪{x}
    是线性相关的，因此 0 可以表示为一个非平凡的线性组合：
- en: '![ ∑n 0 = αx + xivi, i=1 ](img/file34.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![ ∑n 0 = αx + xivi, i=1 ](img/file34.png)'
- en: where not all coefficients are zero. Because S is linearly independent, α cannot
    be zero (as it would imply the linear dependence of S, which would go against
    our assumptions). Thus,
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 其中并非所有系数都为零。由于 S 是线性无关的，α 不能为零（否则意味着 S 是线性相关的，这与我们的假设相悖）。因此，
- en: '![ ∑n x = − xivi, i=1 α ](img/file35.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![ ∑n x = − xivi, i=1 α ](img/file35.png)'
- en: showing that S is a basis.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 证明 S 是一个基。
- en: Next, we are going to show that every vector of a basis is essential.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们要证明基的每个向量都是必不可少的。
- en: Theorem 4\.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 4。
- en: Let V be a vector space and S = {v[1],…,v[n]}a basis. Then, for any v[i] ∈S,
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 设 V 为一个向量空间，S = {v[1],…,v[n]} 是一个基。那么，对于任何 v[i] ∈S，
- en: '![span(S ∖ {vi}) ⊂ V, ](img/file36.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![span(S ∖ {vi}) ⊂ V, ](img/file36.png)'
- en: that is, the span of S ∖{v[i]}is a proper subset of V .
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 即，S ∖{v[i]} 的跨度是 V 的一个真子集。
- en: Proof. We are going to prove this by contradiction. Without loss of generality,
    we can assume that i = 1\. If
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。我们将通过反证法来证明这一点。无损一般性，我们可以假设 i = 1。如果
- en: '![span(S ∖{v1 }) = V, ](img/file37.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![span(S ∖{v1 }) = V, ](img/file37.png)'
- en: then
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 然后
- en: '![ n ∑ v1 = xivi. i=2 ](img/file38.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![ n ∑ v1 = xivi. i=2 ](img/file38.png)'
- en: This means that S = {v[1],…,v[n]} is not linearly independent, contradicting
    our assumptions.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着 S = {v[1],…,v[n]} 不是线性无关的，这与我们的假设相矛盾。
- en: In other words, the above results mean that a basis is a maximal linearly independent
    and a minimal generating set at the same time.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，上述结果意味着基既是最大线性无关集，又是最小生成集。
- en: Given a basis S = {v[1],…,v[n]}, we implictly write the vector x = ∑ [i=1]^nx[i]v[i]
    as x = (x[1],…,x[n]). Since this decomposition is unique, we can do this without
    issues. The coefficients x[i] are also called coordinates. (Note that the coordinates
    strongly depend on the basis. Given two different bases, the coordinates of the
    same vector can be different.)
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个基 S = {v[1],…,v[n]}，我们隐式地将向量 x = ∑ [i=1]^nx[i]v[i] 写作 x = (x[1],…,x[n])。由于这种分解是唯一的，我们可以毫无问题地这样做。系数
    x[i] 也称为坐标。（请注意，坐标强烈依赖于基。给定两个不同的基，相同向量的坐标可能不同。）
- en: 1.2.4 Finite dimensional vector spaces
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2.4 有限维向量空间
- en: As we have seen previously, a single vector space can have many different bases,
    so bases are not unique. A very natural question that arises in this context is
    the following. If S[1] and S[2] are two bases for V , then does jS[1]j = jS[2]j
    hold? (Where jSj denotes the cardinality of the set S, that is, its “size”.)
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所见，一个向量空间可以有许多不同的基，所以基不是唯一的。在这个背景下，出现了一个非常自然的问题。若 S[1] 和 S[2] 是 V 的两个基，那么是否有
    jS[1]j = jS[2]j 这一关系？（其中 jSj 表示集合 S 的基数，即其“大小”。）
- en: In other words, can we do better if we select our basis more cleverly? It turns
    out that we cannot, and the sizes of any two basis sets is equal. We are not going
    to prove this, but here is the theorem in its entirety.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，如果我们更聪明地选择基，能不能得到更好的结果呢？事实证明，我们不能，任何两个基集合的大小都是相等的。我们不打算证明这一点，但这里是该定理的完整内容。
- en: Theorem 5\.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 5。
- en: Let ![V ](img/file39.png) be a vector space, and let ![S1 ](img/file40.png)
    and ![S2 ](img/file41.png) be two bases of ![V ](img/file42.png). Then, ![|S1|
    = |S2| ](img/file43.png).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 设 ![V ](img/file39.png) 为一个向量空间，且 ![S1 ](img/file40.png) 和 ![S2 ](img/file41.png)
    是 ![V ](img/file42.png) 的两个基。则有 ![|S1| = |S2| ](img/file43.png)。
- en: This gives us a way to define the dimension of a vector space, which is simply
    the cardinality of its basis. We’ll denote the dimension of V as dim(V ). For
    example, ℝ^n is n-dimensional, as shown by the standard basis {(1,0,…,0),…,(0,0,…,1)}.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们提供了一种定义向量空间维度的方法，维度就是其基的基数。我们将 V 的维度表示为 dim(V)。例如，ℝ^n 是 n 维的，如标准基 {(1,0,…,0),…,(0,0,…,1)}
    所示。
- en: 'If you recall the previous theorems, we assumed that a basis is finite. You
    might ask the question: is this always true? The answer is no. Examples 2 and
    3 show that this is not the case. For instance, the countably infinite set {1,x,x²,x³,…}
    is a basis for ℝ[x]. So, according to the theorem above, no finite basis can exist
    there.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你回顾之前的定理，我们假设基是有限的。你可能会问：这总是成立吗？答案是否定的。例子 2 和 3 表明情况并非如此。例如，可数无限集 {1,x,x²,x³,…}
    是 ℝ[x] 的一个基。因此，根据上述定理，那里不可能存在有限基。
- en: 'This marks an important distinction between vector spaces: those with finite
    bases are called finite-dimensional. I have some good news: all finite-dimensional
    real vector spaces are essentially ℝ^n. (Recall that we call a vector space real
    if its scalars are the real numbers.)'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这标志着向量空间之间的一个重要区别：具有有限基的向量空间被称为有限维的。我有一个好消息：所有有限维的实向量空间本质上是 ℝ^n。（回想一下，如果一个向量空间的标量是实数，我们就称这个向量空间为实向量空间。）
- en: 'To see why, suppose that V is an n-dimensional real vector space with basis
    {v[1],…,v[n]}, and define the mapping φ : V →ℝ^n by'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '为了理解这一点，假设 V 是一个 n 维实向量空间，其基为 {v[1],…,v[n]}，并定义映射 φ : V →ℝ^n，如下所示：'
- en: '![ ∑n φ : xivi → (x1,...,xn). i=1 ](img/file44.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![ ∑n φ : xivi → (x1,...,xn). i=1 ](img/file44.png)'
- en: φ is invertible and preserves the structure of V , that is, the addition and
    scalar multiplication operations. Indeed, if u,v ∈V and α,β ∈ℝ, then φ(αu + βv)
    = αφ(x) + βφ(y). Such mappings are called isomorphisms. The word itself is derived
    from ancient Greek, with isos meaning same and morphe meaning shape. Even though
    this sounds abstract, the existence of an isomorphism between two vector spaces
    mean that they have the same structure. So, ℝ^n is not just an example of finite
    dimensional real vector spaces, it is a universal model of them. Note that if
    the scalars are not the real numbers, the isomorphism to ℝ^n is not true. (We’ll
    talk more about transformations like this in later chapters.)
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: φ是可逆的并且保持V的结构，也就是加法和标量乘法操作。事实上，如果u,v ∈V且α,β ∈ℝ，则有φ(αu + βv) = αφ(x) + βφ(y)。这样的映射称为同构。这个词本身来源于古希腊语，isos意味着相同，morphe意味着形状。尽管这听起来很抽象，但两个向量空间之间存在同构，意味着它们具有相同的结构。因此，ℝ^n不仅仅是有限维实数向量空间的一个例子，它是这些空间的普遍模型。注意，如果标量不是实数，那么到ℝ^n的同构就不成立。（我们将在后面的章节中讨论类似的变换。）
- en: Considering that we’ll almost exclusively deal with finite dimensional real
    vector spaces, this is good news. Using ℝ^n is not just a heuristic, it is a good
    mental model.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到我们几乎完全处理的是有限维实数向量空间，这是个好消息。使用ℝ^n不仅仅是启发式的，它是一个良好的思维模型。
- en: 1.2.5 Why are bases so important?
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2.5 为什么基底如此重要？
- en: If every finite-dimensional real vector space is essentially the same as ℝ^n,
    what do we gain from abstraction? Sure, we can just work with ℝ^n without talking
    about bases, but to develop a deep understanding of the core mathematical concepts
    in machine learning, we need the abstraction.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果每个有限维实数向量空间本质上与ℝ^n相同，那么我们从抽象中得到什么呢？当然，我们可以不谈基底，直接使用ℝ^n，但为了深入理解机器学习中的核心数学概念，我们需要这种抽象。
- en: Let’s look ahead briefly and see an example. If you have some experience with
    neural networks, you know that matrices play an essential role there. Without
    any context, matrices are just a table of numbers with seemingly arbitrary rules
    of computation. Have you ever wondered why matrix multiplication is defined the
    way it is?
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要展望一下并看看一个例子。如果你对神经网络有一些经验，你会知道矩阵在其中扮演着至关重要的角色。没有任何背景，矩阵只不过是一个数字表格，似乎有任意的计算规则。你是否曾经想过，为什么矩阵乘法是按这种方式定义的？
- en: Although we haven’t precisely defined matrices yet, you have probably encountered
    them previously. We’ll learn all about them in Chapter [3](ch009.xhtml#linear-algebra-in-practice)
    and Chapter [4](ch010.xhtml#linear-transformations), but for the two matrices
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们还没有精确定义矩阵，你可能之前已经遇到过它们。我们将在第[3](ch009.xhtml#linear-algebra-in-practice)章和第[4](ch010.xhtml#linear-transformations)章全面学习它们，但对于这两个矩阵
- en: '![ ⌊ ⌋ ⌊ ⌋ |a1,1 a1,2 ... a1,n| | b1,1 b1,2 ... b1,n| ||a2,1 a2,2 ... a2,n||
    || b2,1 b2,2 ... b2,n|| | . . . . | | . . . . | A = || .. .. .. .. || , B = ||
    .. .. .. .. || , ||a a ... a || ||b b ... b || ⌈ n,1 n,2 n,n⌉ ⌈ n,1 n,2 n,n⌉ ](img/file45.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![ ⌊ ⌋ ⌊ ⌋ |a1,1 a1,2 ... a1,n| | b1,1 b1,2 ... b1,n| ||a2,1 a2,2 ... a2,n||
    || b2,1 b2,2 ... b2,n|| | . . . . | | . . . . | A = || .. .. .. .. || , B = ||
    .. .. .. .. || , ||a a ... a || ||b b ... b || ⌈ n,1 n,2 n,n⌉ ⌈ n,1 n,2 n,n⌉ ](img/file45.png)'
- en: their product AB is defined by
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 它们的积AB定义为
- en: '![ ⌊∑ ∑ ∑ ⌋ nk=1 a1,kbk,1 nk=1 a1,kbk,2 ... nk=1a1,kbk,n ||∑n ∑n ∑n || || k=1
    a2,kbk,1 k=1 a2,kbk,2 ... k=1a2,kbk,n|| AB = || ... ... ... ... || , |∑n ∑n ∑n
    | |⌈ k=1 an,kbk,1 k=1 an,kbk,2 ... k=1an,kbk,n|⌉ ](img/file46.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![ ⌊∑ ∑ ∑ ⌋ nk=1 a1,kbk,1 nk=1 a1,kbk,2 ... nk=1a1,kbk,n ||∑n ∑n ∑n || || k=1
    a2,kbk,1 k=1 a2,kbk,2 ... k=1a2,kbk,n|| AB = || ... ... ... ... || , |∑n ∑n ∑n
    | |⌈ k=1 an,kbk,1 k=1 an,kbk,2 ... k=1an,kbk,n|⌉ ](img/file46.png)'
- en: that is, the (i,j)-th element of AB is defined by
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 即，AB的(i,j)-th元素定义为
- en: '![ n ∑ a b . i,kk,j k=1 ](img/file47.png)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![ n ∑ a b . i,kk,j k=1 ](img/file47.png)'
- en: This definition feels random. Why not just take the componentwise product (a[i,j]b[i,j])[i,j=1]^n?
    The definition becomes crystal clear once we look at a matrix as a tool to describe
    linear transformations between vector spaces, as the elements of the matrix describe
    the images of basis vectors. In this context, multiplication of matrices is just
    the composition of linear transformations.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这个定义感觉有些随意。为什么不直接取元素逐一相乘(a[i,j]b[i,j])[i,j=1]^n呢？一旦我们将矩阵视为描述向量空间之间线性变换的工具，这个定义就变得非常清晰，因为矩阵的元素描述了基向量的像。在这个背景下，矩阵的乘法仅仅是线性变换的组合。
- en: Instead of just putting out the definition and telling you how to use it, I
    want you to understand why it is defined that way. In the next chapters, we are
    going to learn every nook and cranny of matrix multiplication.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我不想仅仅给出定义并告诉你如何使用它，而是希望你理解为什么它是这样定义的。在接下来的章节中，我们将学习矩阵乘法的每一个细节。
- en: 1.2.6 The existence of bases
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2.6 基的存在性
- en: 'At this point, you might ask the question: for a given vector space, are we
    guaranteed to find a basis? Without such a guarantee, the previous setup might
    be wasted. (As there might not be a basis to work with.)'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，你可能会问：对于给定的向量空间，我们是否能保证找到一个基？如果没有这样的保证，前面的设置可能会变得没有意义。（因为可能没有可以使用的基。）
- en: Fortunately, this is not the case. As the proof is extremely difficult, we will
    not show this, but this is so important that we should at least state the theorem.
    If you are interested in how this can be done, I included a proof sketch. Feel
    free to skip this, as it is not going to be essential for our purposes.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，情况并非如此。由于证明极其困难，我们不会展示这个过程，但这个问题非常重要，我们至少应该陈述定理。如果你对如何做到这一点感兴趣，我附上了一个证明的概述。可以跳过它，因为它对我们的目的并不至关重要。
- en: Theorem 6\.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 6。
- en: Every vector space has a basis.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 每个向量空间都有一个基。
- en: Proof. (Sketch.) The proof of this uses an advanced technique called transfinite
    induction, which is way beyond our scope. (Check out Naive Set Theory by Paul
    Halmos for details.) Instead of being precise, let’s just focus on building intuition
    about how to construct a basis for any vector space.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。（概述。）这个证明使用了一种叫做超限归纳的高级技术，远超我们的范围。（可以参考Paul Halmos的《Naive Set Theory》了解更多。）我们不精确地展示，而是专注于建立直觉，了解如何为任何向量空间构造基。
- en: For our vector space V , we will build a basis one by one. Given any non-null
    vector v[1], if span(S[1])≠V , the set S[1] = {v[1]} is not yet a basis. Thus,
    we can find a vector v[2] ∈ V ∖ span(S[1]) so that S[2] := S[1] ∪{v[2]} is still
    linearly independent.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的向量空间V，我们将逐个构造基。给定任意非零向量v[1]，如果span(S[1])≠V，集合S[1] = {v[1]}还不是基。因此，我们可以找到一个向量v[2]
    ∈ V ∖ span(S[1])，使得S[2] := S[1] ∪{v[2]}依然是线性无关的。
- en: Is S[2] a basis? If not, we can continue the process. In case the process stops
    in finitely many steps, we are done. However, this is not guaranteed. Think about
    ℝ[x], the vector space of polynomials, which is not finite-dimensional, as we
    saw in Section [1.2.4](ch007.xhtml#finite-dimensional-vector-spaces).
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: S[2]是基吗？如果不是，我们可以继续这个过程。如果过程在有限的步骤中停止，我们就完成了。然而，这并不能得到保证。想一想ℝ[x]，即多项式的向量空间，它是无限维的，正如我们在第[1.2.4节](ch007.xhtml#finite-dimensional-vector-spaces)中所看到的。
- en: This is where we need to employ some set-theoretical heavy machinery (which
    we don’t have).
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这时，我们需要使用一些集合论的重型工具（我们并不具备）。
- en: If the process doesn’t stop, we need to find a set S[ℵ[0]] that contains all
    S[i] as a subset. (Finding this S[ℵ[0]] set is the tricky part.) Is S[ℵ[0]] a
    basis? If not, we continue the process.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果过程没有停止，我们需要找到一个包含所有S[i]作为子集的集合S[ℵ[0]]。（找到这个S[ℵ[0]]集合是最棘手的部分。）S[ℵ[0]]是基吗？如果不是，我们继续这个过程。
- en: This is difficult to show, but the process eventually stops, and we can’t add
    any more vectors to our linearly independent vector set without destroying the
    independence property. When this happens, we have found a maximal linearly independent
    set — that is, a basis.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程很难展示，但最终会停止，我们无法再将任何向量添加到我们线性无关的向量集合中而不破坏无关性。当这一点发生时，我们已经找到了一个最大线性无关集——也就是基。
- en: For finite dimensional vector spaces, the above process is easy to describe.
    In fact, one of the pillars of linear algebra is the so-called Gram-Schmidt process,
    used to explicitly construct special bases for vector spaces. As several quintessential
    results rely on this, we are going to study it in detail during the next chapters.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 对于有限维向量空间，上述过程很容易描述。事实上，线性代数的支柱之一就是所谓的Gram-Schmidt过程，用于显式构造向量空间的特殊基。由于几个经典的结果依赖于此，我们将在接下来的章节中详细研究它。
- en: 1.2.7 Subspaces
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2.7 子空间
- en: Before we get our hands dirty with vectors in Python, there is one more subject
    we need to talk about, one that will come in handy when talking about linear transformations.
    (But again, linear transformations are at the heart of machine learning. Everything
    we learn is to get to know them better.) For a given vector space V , we are often
    interested in one of its subsets that is a vector space in its entirety. This
    is described by the concept of subspaces.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们动手处理Python中的向量之前，还有一个主题我们需要讨论，它在讨论线性变换时会非常有用。（但再次强调，线性变换是机器学习的核心。我们学习的一切都是为了更好地理解它们。）对于给定的向量空间V，我们通常对它的一个子集感兴趣，且这个子集本身也是一个向量空间。这就是子空间的概念。
- en: Definition 5\. (Subspaces)
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 5。（子空间）
- en: Let V be a vector space. The set U ⊆V is a subspace of V if it is closed under
    addition and scalar multiplication.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 设V是一个向量空间。如果集合U ⊆V对加法和标量乘法是封闭的，那么U是V的一个子空间。
- en: U is a proper subspace if it is a subspace and U ⊂V .
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: U 是一个真子空间，当且仅当它是一个子空间并且 U ⊂V。
- en: 'By definition, subspaces are vector spaces themselves, so we can define their
    dimension as well. There are at least two subspaces of each vector space: itself
    and {0}. These are called trivial subspaces. Besides those, the span of a set
    of vectors is always a subspace. One such example is illustrated in Figure [1.5](#).'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 根据定义，子空间本身就是向量空间，因此我们也可以定义它们的维度。每个向量空间至少有两个子空间：它本身和 {0}。这些被称为平凡子空间。除此之外，一组向量的跨度总是一个子空间。一个这样的例子在图
    [1.5](#) 中说明。
- en: One of the most important aspects of subspaces is that we can use them to create
    more subspaces. This notion is made precise below.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 子空间的一个最重要的方面是，我们可以利用它们来创建更多的子空间。这个概念将在下文中具体说明。
- en: Definition 6\. (Direct sum of subspaces)
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 6\. （子空间的直和）
- en: Let V be a vector space and U[1],U[2] be two of its subspaces. The direct sum
    of U[1] and U[2] is defined by
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 设 V 是一个向量空间，U[1] 和 U[2] 是它的两个子空间。U[1] 和 U[2] 的直和定义为
- en: '![U1 + U2 = {u1 + u2 : u1 ∈ U1, u2 ∈ U2}. ](img/file48.png)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![U1 + U2 = {u1 + u2 : u1 ∈ U1, u2 ∈ U2}. ](img/file48.png)'
- en: You can easily verify that U[1] + U[2] is a subspace indeed, moreover U[1] +
    U[2] = span(U[1] ∪U[2]). Subspaces and their direct sum play an essential role
    in several topics, such as matrix decompositions. For example, we’ll see later
    that many of them are equivalent to decomposing a linear space into a sum of vector
    spaces.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以很容易地验证 U[1] + U[2] 确实是一个子空间，此外 U[1] + U[2] = span(U[1] ∪U[2])。子空间及其直和在多个主题中起着至关重要的作用，例如矩阵分解。例如，稍后我们将看到，其中许多是将一个线性空间分解为多个向量空间之和的等价问题。
- en: The ability to select a basis whose subsets span certain given subspaces often
    comes in handy. This is formalized by the next result.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 选择一个基，其子集能够跨越某些给定子空间的能力通常非常有用。这个结果在下文中得到了形式化。
- en: Theorem 7\.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 7\.
- en: Let V be a vector space and U[1],U[2] be two of its subspaces such that U[1]
    + U[2] = V . Moreover, let {p[1],…,p[k]} ⊆ U[1] be a basis of U[1] and {q[1],…,q[l]}⊆U[2]
    be a basis of U[2]. Then the union
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 设 V 是一个向量空间，U[1] 和 U[2] 是它的两个子空间，且 U[1] + U[2] = V。同时，设 {p[1],…,p[k]} ⊆ U[1]
    是 U[1] 的一个基，{q[1],…,q[l]} ⊆ U[2] 是 U[2] 的一个基。那么，联合
- en: '![{p1,...,pk} ∪ {q1,...,ql} ](img/file49.png)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![{p1,...,pk} ∪ {q1,...,ql} ](img/file49.png)'
- en: is a basis in V .
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 是 V 中的一个基。
- en: Proof. This follows directly from the direct sum’s definition. If V = U[1] +
    U[2], then any x ∈V can be written in the form x = a + b, where a ∈U[1] and b
    ∈U[2].
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 证明：这一点直接从直和的定义中得出。如果 V = U[1] + U[2]，那么任何 x ∈V 都可以表示为 x = a + b，其中 a ∈U[1] 且
    b ∈U[2]。
- en: In turn, since p[1],…,p[k] form a basis in U[1] and q[1],…,q[l] form a basis
    in U[2], the vectors a and b can be written as
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 反过来，由于 p[1],…,p[k] 在 U[1] 中形成一个基，q[1],…,q[l] 在 U[2] 中形成一个基，向量 a 和 b 可以写成
- en: '![ k l a = ∑ a p , b = ∑ bq . i=1 i i i=1 i i ](img/file50.png)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![ k l a = ∑ a p , b = ∑ bq . i=1 i i i=1 i i ](img/file50.png)'
- en: Thus, any x takes the form
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，任何 x 都可以表示为
- en: '![ ∑k ∑ l x = aipi + biqi, i=1 i=1 ](img/file51.png)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![ ∑k ∑ l x = aipi + biqi, i=1 i=1 ](img/file51.png)'
- en: which is the definition of the basis.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这是基的定义。
- en: We are barely scratching the surface. Bases are essential, but they only provide
    the skeleton for the vector spaces encountered in practice. To properly represent
    and manipulate data, we need to build a geometric structure around this skeleton.
    How can we measure the “distance” between two measurements? What about their similarity?
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仅仅是触及了表面。基是至关重要的，但它们仅提供了实践中遇到的向量空间的骨架。为了正确地表示和操作数据，我们需要在这个骨架上构建几何结构。我们如何衡量两个测量值之间的“距离”？它们的相似度又如何呢？
- en: 'Besides all that, there is an even more crucial question: how on earth will
    we represent vectors inside a computer? In the next section, we will take a look
    at the data structures of Python, laying the foundation for the data manipulations
    and transformations we’ll do later.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，还有一个更加关键的问题：我们到底如何在计算机中表示向量？在下一节中，我们将看看 Python 中的数据结构，为我们之后进行的数据操作和转换打下基础。
- en: 1.3 Vectors in practice
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.3 向量在实践中的应用
- en: So far, we have mostly talked about the theory of vectors and vector spaces.
    However, our ultimate goal is to build computational models for discovering and
    analyzing patterns in data. To put theory into practice, we will take a look at
    how vectors are represented in computations.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们主要讨论了向量和向量空间的理论。然而，我们的最终目标是构建计算模型，用于发现和分析数据中的模式。为了将理论付诸实践，我们将看看向量在计算中的表示方式。
- en: In computer science, there is a stark contrast between how we think about mathematical
    structures and how we represent them inside a computer. Until this point, our
    goal was to develop a mathematical framework that enables us to reason about the
    structure of data and its transformations. We want a language that is
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机科学中，我们对于数学结构的理解与如何在计算机内部表示它们之间有着显著的差异。到目前为止，我们的目标是开发一个数学框架，使我们能够推理数据的结构及其转换过程。我们希望有一种语言，它
- en: expressive,
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表达力强，
- en: easy to speak,
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易于使用，
- en: as compact as possible.
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽可能紧凑。
- en: However, our goals change when we aim to do computations instead of pure logical
    reasoning. We want implementations that are
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们旨在进行计算而非纯粹的逻辑推理时，我们的目标发生了变化。我们需要的是那些能够实现计算的工具。
- en: easy to work with,
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易于使用，
- en: memory-efficient,
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存高效，
- en: fast to access, manipulate and transform.
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快速访问、操作和转换。
- en: These are often contradicting requirements, and particular situations might
    prefer one over the other. For instance, if we have plenty of memory but want
    to perform lots of computations, we can sacrifice size for speed. Because of all
    the potential use-cases, there are multiple formats to represent the same mathematical
    concepts. These are called data structures.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这些要求常常是相互矛盾的，具体情况可能会更倾向于某一方。例如，如果我们有大量内存，但需要进行大量计算，我们可以牺牲空间来换取速度。由于所有潜在的使用场景，表示相同数学概念的格式有很多种。这些都被称为数据结构。
- en: Different programming languages implement vectors differently. Because Python
    is ubiquitous in data science and machine learning, it’ll be our language of choice.
    In this chapter, we are going to study all the possible data structures in Python
    to see which one is suitable to represent vectors for high performance computations.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的编程语言以不同的方式实现向量。因为Python在数据科学和机器学习中无处不在，所以它将是我们的首选语言。在本章中，我们将研究Python中的所有可能的数据结构，看看哪种最适合表示高性能计算中的向量。
- en: 1.3.1 Tuples
  id: totrans-277
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.3.1 元组
- en: 'In standard Python, there are (at least) two built-in data structures that
    can be used to represent vectors: tuples and lists. Let’s start with tuples! They
    can be simply defined by enumerating their elements between two parentheses, separating
    them with commas.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在标准的Python中，至少有两种内置数据结构可以用来表示向量：元组和列表。我们先从元组开始！它们可以通过将元素列在两个括号之间，并用逗号分隔来定义。
- en: '[PRE10]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: A single tuple can hold elements of various types. Even though we’ll exclusively
    deal with floats in computational linear algebra, this property is extremely useful
    for general-purpose programming.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 单个元组可以包含各种类型的元素。尽管在计算线性代数中我们将专门处理浮点数，但这个特性对于通用编程非常有用。
- en: We can access the elements of a tuple by indexing. Just like in several other
    programming languages, indexing starts from zero. This is in stark contrast with
    mathematics, where we often start indexing from one. Accordingly, in most languages
    designed for scientific computing, such as Fortran, Matlab, or Julia, indexing
    starts from one.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过索引访问元组的元素。就像在其他一些编程语言中一样，索引从零开始。这与数学中的做法大相径庭，数学中我们通常从一开始索引。因此，在大多数为科学计算设计的语言中，如Fortran、Matlab或Julia，索引是从一开始的。
- en: (Don’t tell this to anybody else, but indexing from zero used to drive me crazy.
    I am a mathematician by training.)
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: （不要告诉别人，但从零开始索引曾经让我疯狂。我是受过数学训练的。）
- en: '[PRE14]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The size of a tuple can be accessed by calling the built-in len function.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 元组的大小可以通过调用内置的 len 函数来访问。
- en: '[PRE16]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Besides indexing, we can also access multiple elements by slicing.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 除了索引，我们还可以通过切片访问多个元素。
- en: '[PRE18]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Slicing works by specifying the first and last elements with an optional step
    size, using the syntax object[first:last:step].
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 切片的工作方式是通过指定第一个和最后一个元素，以及可选的步长，使用语法 object[first:last:step]。
- en: Tuples are rather inflexible, as you cannot change their components. Attempting
    to do so results in a TypeError, Python’s standard way of telling you that the
    object does not support the method you are trying to call. (In our case, item
    assignment.)
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 元组相当不灵活，因为你不能改变它们的组件。尝试这么做会导致TypeError，这是Python告诉你对象不支持你尝试调用的方法的标准方式。（在我们的例子中，是项赋值。）
- en: '[PRE20]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Besides that, extending the tuple with additional elements is also not supported.
    As we cannot change the state of a tuple object in any way after it has been instantiated,
    they are immutable. Depending on the use-case, immutability can be an advantage
    and a disadvantage as well. Immutable objects eliminate accidental changes, but
    each operation requires the creation of a new object, resulting in a computational
    overhead. Thus, tuples are not going to be optimal to represent large amounts
    of data in complex computations.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，扩展元组以添加额外元素也不受支持。由于我们无法在实例化后以任何方式改变元组对象的状态，它们是不可变的。根据用例，不可变性既可能是优点也可能是缺点。不可变对象消除了意外更改，但每个操作都需要创建一个新对象，导致计算开销。因此，在复杂计算中表示大量数据时，元组并不是最佳选择。
- en: This issue is solved by lists. Let’s take a look at them, and the new problems
    they introduce!
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 列表解决了这个问题。让我们来看看它们以及它们引入的新问题！
- en: 1.3.2 Lists
  id: totrans-300
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.3.2 列表
- en: Lists are the workhorses of Python. In contrast with tuples, lists are extremely
    flexible and easy to use, albeit this comes at the cost of runtime. Similarly
    to tuples, a list object can be created by enumerating its objects between square
    brackets, separated by commas.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 列表是Python的工作马。与元组相比，列表非常灵活且易于使用，尽管这会牺牲运行时的性能。类似于元组，列表对象可以通过在方括号内枚举其对象并用逗号分隔来创建。
- en: '[PRE22]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Just like tuples, accessing the elements of a list is done by indexing or slicing.
    We can do all kinds of operations on a list: overwrite its elements, append items,
    or even remove others.'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 与元组一样，通过索引或切片访问列表的元素。我们可以对列表执行各种操作：覆盖其元素，追加项目，甚至移除其他项目。
- en: '[PRE24]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This example illustrates that lists can hold elements of various types as well.
    Adding and removing elements can be done with methods like append, push, pop,
    and remove.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例说明列表也可以容纳各种类型的元素。添加和删除元素可以通过诸如append、push、pop和remove之类的方法完成。
- en: Before trying that, let’s quickly take note of the memory address of our example
    list, accessed by calling the id function.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试之前，让我们快速记录一下我们示例列表的内存地址，通过调用id函数访问。
- en: '[PRE26]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This number simply refers to an address in my computer’s memory, where the v_list
    object is located. Quite literally, as this book is compiled on my personal computer.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数字简单地指代了我的计算机内存中的一个地址，那里是v_list对象的位置。确实，因为这本书是在我的个人电脑上编译的。
- en: Now, we are going to perform a few simple operations on our list and show that
    the memory address doesn’t change. Thus, no new object is created.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将对我们的列表执行几个简单操作，并展示内存地址不会改变。因此，不会创建新对象。
- en: '[PRE28]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Unfortunately, adding lists together achieves a result that is completely different
    from our expectations.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，将列表相加得到的结果与我们的期望完全不同。
- en: '[PRE36]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Instead of adding the corresponding elements together, like we want vectors
    to behave, the lists are concatenated. This feature is handy when writing general-purpose
    applications. However, this is not well-suited for scientific computations. “Scalar
    multiplication” also has strange results.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 不像我们希望向量行为一样将相应元素相加，而是将列表连接起来。这个特性在编写通用应用程序时非常方便。然而，这对科学计算并不适用。“标量乘法”也会产生奇怪的结果。
- en: '[PRE38]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Multiplying a list with an integer repeats the list by the specified number
    of times. Given the behavior of the + operator on lists, this seems logical as
    multiplication with an integer is repeated addition:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 用整数乘以列表会重复列表指定次数。鉴于+运算符在列表上的行为，这似乎是合乎逻辑的，因为整数乘法是重复加法：
- en: '![a⋅b = b◟+--⋅◝⋅⋅◜+--b◞. a times ](img/file52.png)'
  id: totrans-328
  prefs: []
  type: TYPE_IMG
  zh: '![a⋅b = b◟+--⋅◝⋅⋅◜+--b◞。a次](img/file52.png)'
- en: Overall, lists can do much more than we need to represent vectors. Although
    we potentially want to change elements of our vectors, we don’t need to add or
    remove elements from them, and we also don’t need to store objects other than
    floats. Can we sacrifice these extra features and obtain an implementation that’s
    suitable for our purposes yet has lightning-fast computational performance? Yes.
    Enter NumPy arrays.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，列表可以做比我们需要表示向量更多的事情。虽然我们可能想要更改向量的元素，但我们不需要添加或删除它们的元素，也不需要存储除浮点数之外的对象。我们能够牺牲这些额外的功能并获得适合我们目的但具有闪电般快速计算性能的实现吗？是的。进入NumPy数组。
- en: 1.3.3 NumPy arrays
  id: totrans-330
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.3.3 NumPy数组
- en: Even though Python’s built-in data structures are amazing, they are optimized
    for ease of use, not for scientific computation. This problem was realized early
    on in the language’s development and was addressed by the [NumPy](https://numpy.org/)
    library.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Python的内建数据结构非常出色，但它们是为易用性优化的，而不是为了科学计算。这一问题在语言开发初期就被意识到，并通过[NumPy](https://numpy.org/)库得到了解决。
- en: One of the main selling points of Python is how fast and straightforward it
    is to write code, even for complex tasks. This comes at the price of speed. However,
    in machine learning, speed is crucial for us. When training a neural network,
    a small set of operations are repeated millions of times. Even a small percentage
    of improvement in performance can save hours, days, or even weeks in the case
    of extremely large models.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: Python的主要卖点之一就是它写代码的速度快且直接，即使是复杂任务也能轻松完成。这种便利性是以速度为代价的。然而，在机器学习中，速度对我们来说至关重要。在训练神经网络时，一小部分操作需要重复数百万次。即使是性能的微小改进，也能节省大量的时间，尤其是在处理极大型模型时，可能节省数小时、数天甚至数周的时间。
- en: 'The C language is at the other end of the spectrum. While C code is hard to
    write, it executes blazingly fast when done correctly. As Python is written in
    C, a tried and true method for achieving fast performance is to call functions
    written in C from Python. In a nutshell, this is what NumPy provides: C arrays
    and operations, all in Python.'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: C语言位于技术谱系的另一端。虽然C代码编写起来较为困难，但当正确编写时，它的执行速度极快。由于Python是用C语言编写的，获取快速性能的一个行之有效的方法是从Python调用用C语言编写的函数。简而言之，这就是NumPy提供的功能：C数组和操作，全部在Python中实现。
- en: To get a glimpse into the deep underlying issues with Python’s built-in data
    structures, we should put numbers and arrays under our magnifying glass. Inside
    a computer’s memory, objects are represented as fixed-length 0-1 sequences. Each
    component is called a bit. Bits are usually grouped into 8-, 16-, 32-, 64-, or
    even 128 sized chunks. Depending on what we want to represent, identical sequences
    can mean different things. For instance, the 8-bit sequence 00100110 can represent
    the integer 38 or the ASCII character “&.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 为了深入了解Python内建数据结构的底层问题，我们应该将数字和数组放在显微镜下观察。在计算机的内存中，对象被表示为固定长度的0-1序列。每个组成部分称为比特（bit）。比特通常按8位、16位、32位、64位或甚至128位的块进行分组。根据我们希望表示的内容，相同的序列可以表示不同的意义。例如，8位序列00100110可以表示整数38或ASCII字符“&”。
- en: '![PIC](img/file53.png)'
  id: totrans-335
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file53.png)'
- en: 'Figure 1.6: An 8-bit object in memory'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.6：内存中的8位对象
- en: By specifying the data type, we can decode binary objects. 32-bit integers are
    called int32 types, 64-bit floats are float64, and so on.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 通过指定数据类型，我们可以解码二进制对象。32位整数称为int32类型，64位浮点数称为float64，以此类推。
- en: Since a single bit contains very little information, memory is addressed by
    dividing it into 32- or 64-bit sized chunks and numbering them consecutively.
    This address is a hexadecimal number, starting from 0\. (For simplicity, let’s
    assume that the memory is addressed by 64 bits. This is customary in modern computers.)
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 由于单个比特包含的信息非常有限，因此内存是通过将其划分为32位或64位大小的块并依次编号来进行寻址的。这个地址是一个十六进制数，从0开始。（为了简化，假设内存是通过64位进行寻址的，这是现代计算机中的常见做法。）
- en: A natural way to store a sequence of related objects (with matching data type)
    is to place them next to each other in the memory. This data structure is called
    an array.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 存储一系列相关对象（具有相同数据类型）的一种自然方式是将它们放置在内存中的相邻位置。这种数据结构被称为数组。
- en: '![PIC](img/file54.png)'
  id: totrans-340
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file54.png)'
- en: 'Figure 1.7: An array of int64 objects'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.7：一个int64类型对象的数组
- en: By storing the memory address of the first object, say 0x23A0, we can instantly
    retrieve the k-th element by accessing the memory at 0x23A0 + k.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 通过存储第一个对象的内存地址，例如0x23A0，我们可以通过访问内存位置0x23A0 + k，瞬间获取第k个元素。
- en: We call this the static array or often the C array because this is how it is
    done in the magnificent C language. Although this implementation of arrays is
    lightning fast, it is relatively inflexible. First, you can only store objects
    of a single type. Second, you have to know the size of your array in advance,
    as you cannot use memory addresses that overextend the pre-allocated part. Thus,
    before you start working with your array, you have to allocate memory for it.
    (That is, reserve space so that other programs won’t overwrite it.)
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 我们称这种数据结构为静态数组，或者通常称之为C数组，因为它在强大的C语言中是如此实现的。虽然这种数组实现速度极快，但它相对不灵活。首先，您只能存储单一类型的对象。其次，您必须预先知道数组的大小，因为不能使用超出预分配部分的内存地址。因此，在开始使用数组之前，您必须为其分配内存。（即预留空间，以防止其他程序覆盖它。）
- en: However, in Python, you can store arbitrarily large and different objects in
    the same list, with the option of removing and adding elements to it.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在 Python 中，你可以在同一个列表中存储任意大和不同的对象，并且可以随时移除或添加元素。
- en: '[PRE40]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In the example above, l[0] is an integer so large that it doesn’t fit into 128
    bits. Also, there are all kinds of objects in our list, including a function.
    How is this possible?
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，l[0] 是一个非常大的整数，甚至无法容纳在 128 位中。此外，我们的列表中包含各种各样的对象，包括一个函数。这是怎么回事？
- en: Python’s list provides a flexible data structure by
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的列表提供了一个灵活的数据结构，
- en: Overallocating the memory, and
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 内存的过度分配，以及
- en: Keeping memory addresses to the objects in the list instead of the objects themselves.
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将列表中对象的内存地址保存，而不是对象本身。
- en: (At least in the most widespread CPython implementation ( [https://docs.python.org/3/faq/design.html\#how-are-lists-implemented-in-cpython](https://docs.python.org/3/faq/design.html/#how-are-lists-implemented-in-cpython)).)
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: （至少在最广泛使用的 CPython 实现中（[https://docs.python.org/3/faq/design.html\#how-are-lists-implemented-in-cpython](https://docs.python.org/3/faq/design.html/#how-are-lists-implemented-in-cpython)）。）
- en: '![PIC](img/file55.png)'
  id: totrans-352
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file55.png)'
- en: 'Figure 1.8: CPython implementation of lists'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.8：CPython 实现的列表
- en: By checking the memory addresses of each object in our list l, we can see that
    they are all over the memory.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 通过检查我们列表 l 中每个对象的内存地址，我们可以看到它们分布在内存的各个位置。
- en: '[PRE42]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Due to the overallocation, deletion or insertion can always be done simply by
    shifting the remaining elements. Since the list stores the memory address of its
    elements, all types of objects can be stored within a single structure.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 由于过度分配，删除或插入操作始终可以通过简单地移动剩余元素来完成。由于列表存储的是元素的内存地址，因此所有类型的对象都可以存储在单一结构中。
- en: However, this comes at a cost. Because the objects are not contiguous in memory,
    we lose locality of reference ([https://en.wikipedia.org/wiki/Locality_of_reference](https://en.wikipedia.org/wiki/Locality_of_reference)),
    meaning that since we frequently access distant locations of the memory, our reads
    are much slower. Thus, looping over a Python list is not efficient.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这也有其代价。因为对象在内存中不是连续的，所以我们失去了引用局部性（[https://en.wikipedia.org/wiki/Locality_of_reference](https://en.wikipedia.org/wiki/Locality_of_reference)），意味着由于我们频繁地访问内存中遥远的位置，读取速度会变得更慢。因此，循环遍历
    Python 列表的效率不高。
- en: So, NumPy arrays are essentially the good old C arrays in Python, with the user-friendly
    interface of Python lists. (If you have ever worked with C, you know how big of
    a blessing this is.) Let’s see how to work with them!
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，NumPy 数组本质上就是 Python 中的老式 C 数组，并且具备 Python 列表的用户友好界面。（如果你曾经使用过 C，你会知道这有多么令人感激。）让我们看看如何使用它们！
- en: First, we import the numpy library. (To save on the characters, it is customary
    to import it as np.)
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们导入 numpy 库。（为了节省字符，通常将其导入为 np。）
- en: '[PRE44]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The main data structure is np.ndarray, short for n-dimensional array. We can
    use the np.array function to create NumPy arrays from standard Python containers
    or initialize from scratch. (Yes, I know. This is confusing, but you’ll get used
    to it. Just take a mental note that np.ndarray is the class, and np.array is the
    function you use to create NumPy arrays from Python objects.)
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 主要的数据结构是 np.ndarray，表示 n 维数组。我们可以使用 np.array 函数从标准 Python 容器创建 NumPy 数组或从头开始初始化。（是的，我知道这有点混乱，但你很快就会习惯的。请记住，np.ndarray
    是类，而 np.array 是你用来从 Python 对象创建 NumPy 数组的函数。）
- en: '[PRE45]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: We can even initialize NumPy arrays using random numbers.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以使用随机数初始化 NumPy 数组。
- en: '[PRE51]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Most importantly, when we have a given array, we can initialize another one
    with the same dimensions using the np.zeros_like, np.ones_like, and np.empty_like
    functions.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是，当我们有一个给定的数组时，我们可以使用 np.zeros_like、np.ones_like 和 np.empty_like 函数初始化具有相同维度的另一个数组。
- en: '[PRE53]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Just like Python lists, NumPy arrays support item assignments and slicing.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 Python 列表一样，NumPy 数组支持项赋值和切片操作。
- en: '[PRE55]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: However, as expected, you can only store a single data type within each ndarray.
    When trying to assign a string as the first element, we get an error message.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如预期的那样，你只能在每个 ndarray 中存储单一的数据类型。当试图将一个字符串作为第一个元素赋值时，我们会得到一条错误信息。
- en: '[PRE59]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: As you might have guessed, every ndarray has a data type attribute that can
    be accessed at ndarray.dtype. If a conversion can be made between the value to
    be assigned and the data type, it is automatically performed, making the item
    assignment successful.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所料，每个 ndarray 都有一个数据类型属性，可以通过 ndarray.dtype 访问。如果可以在要分配的值与数据类型之间进行转换，它将自动执行，从而使项的赋值成功。
- en: '[PRE61]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: NumPy arrays are iterable, just like other container types in Python.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 数组是可迭代的，就像 Python 中的其他容器类型一样。
- en: '[PRE67]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Are these suitable to represent vectors? Yes. We’ll see why!
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 这些适合用来表示向量吗？是的，我们稍后会看到原因！
- en: 1.3.4 NumPy arrays as vectors
  id: totrans-394
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.3.4 NumPy数组作为向量
- en: Let’s talk about vectors once more. From now on, we are going to use NumPy ndarray-s
    to model vectors.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再谈谈向量。从现在开始，我们将使用NumPy的ndarray来表示向量。
- en: '[PRE69]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The addition and scalar multiplication operations are supported by default and
    perform as expected.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 加法和标量乘法操作默认支持，并且表现如预期。
- en: '[PRE70]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Because of the dynamic typing of Python, we can (often) plug NumPy arrays into
    functions intended for scalars.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Python的动态类型，我们通常可以将NumPy数组传入设计用于标量的函数中。
- en: '[PRE78]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'So far, NumPy arrays satisfy almost everything we require to represent vectors.
    There is only one box to be checked: performance. To investigate this, we measure
    the execution time with Python’s built-in timeit tool.'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，NumPy数组几乎满足我们表示向量所需的所有条件。还有一个条件需要检查：性能。为了调查这一点，我们将使用Python内置的timeit工具来测量执行时间。
- en: In its first argument, timeit ([https://docs.python.org/3/library/timeit.html](https://docs.python.org/3/library/timeit.html))
    takes a function to be executed and timed. Instead of passing a function object,
    it also accepts executable statements as a string. Since function calls have a
    significant computational overhead in Python, we are passing code rather than
    a function object in order to be more precise with the time measurements.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 在它的第一个参数中，timeit ([https://docs.python.org/3/library/timeit.html](https://docs.python.org/3/library/timeit.html))
    接受一个要执行并计时的函数。除了传递函数对象，它也接受作为字符串的可执行语句。由于在Python中函数调用有显著的计算开销，我们传递的是代码而非函数对象，以便更精确地进行时间测量。
- en: Below, we compare adding together two NumPy arrays vs. Python lists containing
    a thousand zeros.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的对比中，我们将比较两个NumPy数组与包含千个零的Python列表相加的速度。
- en: '[PRE80]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: NumPy arrays are much-much faster. This is because they are
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy数组要快得多。这是因为它们的操作是
- en: contiguous in memory,
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在内存中是连续的，
- en: homogeneous in type,
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型一致，
- en: with operations implemented in C.
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在C语言中实现的。
- en: This is just the tip of the iceberg. We have only seen a small part of it, but
    NumPy provides much more than a fast data structure. As we progress in the book,
    we’ll slowly dig deeper and deeper, eventually discovering the vast array of functionalities
    it provides.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是冰山一角。我们仅仅看到了其中的一小部分，但NumPy提供的功能远不止一个快速的数据结构。随着书中的内容逐渐深入，我们会慢慢探索其更广泛的功能，最终揭示它所提供的丰富功能。
- en: 1.3.5 Is NumPy really faster than Python?
  id: totrans-419
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.3.5 NumPy真的比Python更快吗？
- en: NumPy is designed to be faster than vanilla Python. Is this really the case?
    Not all the time. If you use it wrong, it might even hurt performance! To know
    when it is beneficial to use NumPy, we will look at why exactly it is faster in
    practice.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy的设计目标是比原生Python更快。这真的是这样吗？并不总是。如果使用不当，它甚至可能会降低性能！为了了解何时使用NumPy最有利，我们将探讨它在实践中为什么更快。
- en: To simplify the investigation, our toy problem will be random number generation.
    Suppose that we need just a single random number. Should we use NumPy? Let’s test
    it! We are going to compare it with the built-in random number generator by running
    both ten million times, measuring the execution time.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化调查，我们的玩具问题将是随机数生成。假设我们只需要一个随机数。我们应该使用NumPy吗？让我们测试一下！我们将其与内置的随机数生成器进行比较，运行十百万次并测量执行时间。
- en: '[PRE82]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: For generating a single random number, NumPy is significantly slower. Why is
    this the case? What if we need an array instead of a single number? Will this
    also be slower?
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成单个随机数时，NumPy明显较慢。为什么会这样？如果我们需要一个数组而不是一个数字呢？这样也会更慢吗？
- en: This time, let’s generate a list/array of a thousand elements.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，让我们生成一个包含千个元素的列表/数组。
- en: '[PRE84]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: (Again, I don’t want to wrap the timed expressions in lambdas since function
    calls have an overhead in Python. I want to be as precise as possible, so I pass
    them as strings to the timeit function.)
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: （再次说明，我不想把计时表达式包装在lambda中，因为在Python中函数调用有开销。我希望尽可能精确地计时，所以我将它们作为字符串传递给timeit函数。）
- en: Things are looking much different now. When generating an array of random numbers,
    NumPy wins hands down.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 现在情况看起来完全不同了。在生成一个随机数数组时，NumPy毫无疑问是最优选择。
- en: There are some curious things about this result as well. First, we generated
    a single random number 10000000 times. Second, we generated an array of 1000 random
    numbers 10000 times. In both cases, we have 10000000 random numbers in the end.
    Using the built-in method, it took ˜2x time when we put them in a list. However,
    with NumPy, we see a ˜30x speedup compared to itself when working with arrays!
    (The actual numbers might be different on your computer.)
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结果也有一些有趣的地方。首先，我们生成了一个随机数，重复了 10000000 次。其次，我们生成了一个包含 1000 个随机数的数组，重复了 10000
    次。在这两种情况下，最终我们都得到了 10000000 个随机数。使用内置方法时，当我们将它们放入列表中时，耗时大约是两倍。然而，在使用 NumPy 时，相比于自身处理数组时，我们看到的加速效果约为
    30 倍！（实际的数字可能会因计算机不同而有所差异。）
- en: To see what happens behind the scenes, we are going to profile the code using
    cProfiler ([https://docs.python.org/3/library/profile.html](https://docs.python.org/3/library/profile.html)).
    With this, we’ll see exactly how many times a given function was called and how
    much time we spent inside it.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解背后的情况，我们将使用 cProfiler 来分析代码（[https://docs.python.org/3/library/profile.html](https://docs.python.org/3/library/profile.html)）。通过这个工具，我们可以准确看到每个函数被调用的次数以及花费的时间。
- en: Let’s take a look at the built-in function first. In the following function,
    we create 10000000 random numbers, just as before.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先来看一下内置函数。在以下函数中，我们会像之前一样生成 10000000 个随机数。
- en: '[PRE86]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: From Jupyter Notebooks, where this book is written, cProfiler can be called
    with the magic command %prun.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的写作环境 Jupyter Notebook 中，可以使用魔法命令 %prun 调用 cProfiler。
- en: '[PRE87]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: There are two important columns here for our purposes. ncalls shows how many
    times a function was called, while tottime is the total time spent in a function,
    excluding time spent in subfunctions.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个重要的列。ncalls 显示函数被调用的次数，而 tottime 是函数内花费的总时间，不包括在子函数中花费的时间。
- en: The built-in function random.random() was called 10000000 times as expected.
    Take note of the total time spent in the function. (I can’t give you an exact
    figure here, as it depends on the machine this book is built on.)
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，内置函数 random.random() 被调用了 10000000 次。注意函数内花费的总时间。（我不能给你一个准确的数字，因为这取决于本书编写时的机器。）
- en: What about the NumPy version? The results are surprising.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 那么 NumPy 版本呢？结果令人惊讶。
- en: '[PRE89]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Similarly, as before, the numpy.random.random() function was indeed called 10000000
    times, as expected. Yet, the script spent significantly more time in this function
    than in the Python built-in random before. Thus, it is more costly per call.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，正如之前所说，numpy.random.random() 函数确实被调用了 10000000 次，正如预期的那样。然而，脚本在这个函数中花费的时间比之前的
    Python 内置 random 函数要长得多。因此，每次调用的成本更高。
- en: When we start working with large arrays and lists, things change dramatically.
    Next, we generate a list/array of 1000 random numbers, while measuring the execution
    time.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始处理大型数组和列表时，情况发生了显著变化。接下来，我们将生成一个包含 1000 个随机数的列表/数组，并测量执行时间。
- en: '[PRE91]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: As we see, about 60% of the time was spent on the list comprehensions. (Note
    that tottime doesn’t count subfunction calls like calls to random.random() here.)
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，大约 60% 的时间花费在列表推导式上。（请注意，tottime 不包括像 random.random() 这样的子函数调用。）
- en: Now we are ready to see why NumPy is faster when used right.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备好了解为什么在正确使用的情况下 NumPy 更快了。
- en: '[PRE93]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: With each of the 10000 function calls, we get a numpy.ndarray of 1000 random
    numbers. The reason why NumPy is fast when used right is that its arrays are extremely
    efficient to work with. They are like C arrays instead of Python lists.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每一个 10000 次函数调用，我们都会得到一个包含 1000 个随机数的 numpy.ndarray。NumPy 快速的原因在于，它的数组在操作时非常高效。它们像
    C 语言中的数组，而不是 Python 列表。
- en: As we have seen, there are two significant differences between them.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，它们之间有两个显著的差异。
- en: Python lists are dynamic, so for instance, you can append and remove elements.
    NumPy arrays have fixed lengths, so you cannot add or delete without creating
    a new one.
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 列表是动态的，例如，你可以添加或移除元素。NumPy 数组具有固定的长度，因此无法在不创建新数组的情况下添加或删除元素。
- en: Python lists can hold several data types simultaneously, while a NumPy array
    can only contain one.
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 列表可以同时容纳多种数据类型，而 NumPy 数组只能包含一种数据类型。
- en: So, NumPy arrays are less flexible but significantly more performant. When this
    additional flexibility is not needed, NumPy outperforms Python.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，NumPy 数组虽然不如 Python 列表灵活，但在性能上显著优于后者。当不需要额外的灵活性时，NumPy 超越了 Python。
- en: To see precisely at which size does NumPy overtakes Python in random number
    generation, we can compare the two by measuring the execution times for several
    sizes.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 为了精确地看到 NumPy 在什么大小时超过 Python 的随机数生成速度，我们可以通过测量多个大小的执行时间来进行比较。
- en: '[PRE95]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '![PIC](img/file63.png)'
  id: totrans-458
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file63.png)'
- en: 'Figure 1.9: Runtime of random array generation'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.9：随机数组生成的运行时间
- en: Around 20, NumPy starts to beat Python in performance. Of course, this number
    might be different for other operations like calculating the sine or adding numbers
    together, but the tendency will be the same. Python will slightly outperform NumPy
    for small input sizes, but NumPy wins by a large margin as the size grows.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 在大约 20 时，NumPy 的性能开始超过 Python。当然，这个数字对于其他操作（例如计算正弦或加法）可能不同，但趋势是相同的。对于小输入规模，Python
    会稍微超过 NumPy，但随着规模的增加，NumPy 会大幅领先。
- en: 1.4 Summary
  id: totrans-461
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.4 小结
- en: In this chapter, we have learned what vectors are and why we must use them in
    data science and machine learning. Vectors are not just a bunch of numbers bundled
    together but a mathematical structure that allows us to reason about data more
    effectively, both in theory and in practice. Contrary to popular belief, vectors
    are vectors not because they have direction and magnitude but because you can
    add them together.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了什么是向量，以及为什么在数据科学和机器学习中必须使用它们。向量不仅仅是一堆捆绑在一起的数字，它是一种数学结构，允许我们更有效地推理数据，无论在理论上还是实践中。与常见观点相反，向量之所以是向量，不是因为它们有方向和大小，而是因为你可以将它们相加。
- en: This is formalized by the concept of vector spaces, providing the mathematical
    framework for our studies. Vector spaces are best described by bases, that is,
    minimal and linearly independent generating sets. Understanding vector spaces
    and their bases will pay enormous dividends when we study linear transformations,
    the most important building block of predictive models.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 这一点通过向量空间的概念得到了形式化，为我们的研究提供了数学框架。向量空间最好通过基来描述，也就是最小且线性独立的生成集。理解向量空间及其基在我们研究线性变换时将带来巨大的回报，线性变换是预测模型中最重要的构建模块。
- en: 'Besides the leap of abstraction provided by vectors, we reap significant benefits
    in practice by vectorizing our code, compressing complex logic into one-liners
    such as data scaling:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 除了向量所提供的抽象跃迁外，通过向量化我们的代码，我们在实践中获得了显著的收益，将复杂的逻辑压缩成如数据缩放等一行代码：
- en: '[PRE97]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Besides the conceptual jump from scalars to vectors and matrices, efficient
    data processing is made possible by NumPy (short for Numerical Python), the number
    one library in the machine learning toolkit. If a tensor library doesn’t use NumPy,
    it is inspired by it. We already understand its basics and know why and when to
    use it.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 除了从标量到向量和矩阵的概念跃迁，NumPy（数值 Python 的简称）使得高效的数据处理成为可能，它是机器学习工具包中的首选库。如果一个张量库没有使用
    NumPy，那么它一定是受到 NumPy 启发的。我们已经理解了它的基本概念，并且知道何时以及为什么要使用它。
- en: In the next chapter, we continue exploring vector spaces. Bases are cool and
    all, but besides them, vector spaces have a beautiful and rich geometric structure.
    Let’s see it!
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们继续探索向量空间。基是很酷的，但除了基，向量空间还有一个美丽而丰富的几何结构。让我们来看看！
- en: 1.5 Problems
  id: totrans-468
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.5 问题
- en: Problem 1\. Not all vector spaces are infinite. There are some that only contain
    a finite number of vectors, as we shall see next in this problem. Define the set
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 问题 1：并非所有的向量空间都是无限的。我们将在下一个问题中看到一些只包含有限个向量的向量空间。定义集合
- en: '![ℤ2 := {0,1}, ](img/file64.png)'
  id: totrans-470
  prefs: []
  type: TYPE_IMG
  zh: '![ℤ2 := {0,1}, ](img/file64.png)'
- en: where the operations +,⋅ are defined by the rules
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 运算符 + 和 ⋅ 由以下规则定义
- en: '| 0 + 0 | = 0 |  |  |'
  id: totrans-472
  prefs: []
  type: TYPE_TB
  zh: '| 0 + 0 | = 0 |  |  |'
- en: '| 0 + 1 | = 1 |  |  |'
  id: totrans-473
  prefs: []
  type: TYPE_TB
  zh: '| 0 + 1 | = 1 |  |  |'
- en: '| 1 + 0 | = 1 |  |  |'
  id: totrans-474
  prefs: []
  type: TYPE_TB
  zh: '| 1 + 0 | = 1 |  |  |'
- en: '| 1 + 1 | = 0 |  |  |'
  id: totrans-475
  prefs: []
  type: TYPE_TB
  zh: '| 1 + 1 | = 0 |  |  |'
- en: and
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 和
- en: '| 0 ⋅ 0 | = 0 |  |  |'
  id: totrans-477
  prefs: []
  type: TYPE_TB
  zh: '| 0 ⋅ 0 | = 0 |  |  |'
- en: '| 0 ⋅ 1 | = 0 |  |  |'
  id: totrans-478
  prefs: []
  type: TYPE_TB
  zh: '| 0 ⋅ 1 | = 0 |  |  |'
- en: '| 1 ⋅ 0 | = 0 |  |  |'
  id: totrans-479
  prefs: []
  type: TYPE_TB
  zh: '| 1 ⋅ 0 | = 0 |  |  |'
- en: '| 1 ⋅ 1 | = 1. |  |  |'
  id: totrans-480
  prefs: []
  type: TYPE_TB
  zh: '| 1 ⋅ 1 | = 1. |  |  |'
- en: This is called binary (or modulo-2) arithmetic.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 这称为二进制（或模 2）算术。
- en: (a) Show that (ℤ[2],ℤ[2],+,⋅) is a vector space.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: (a) 证明 (ℤ[2],ℤ[2],+,⋅) 是一个向量空间。
- en: (b) Show that(ℤ[2]^n,ℤ[2],+,⋅) is also a vector space, where ℤ[2]^n is the n-fold
    Cartesian product
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: (b) 证明 (ℤ[2]^n, ℤ[2], +, ⋅) 也是一个向量空间，其中 ℤ[2]^n 是 n 次笛卡尔积
- en: '![ n ℤ 2 = ℤ◟2-×-⋅⋅◝◜⋅×-ℤ2◞, n times ](img/file65.png)'
  id: totrans-484
  prefs: []
  type: TYPE_IMG
  zh: '![ n ℤ 2 = ℤ◟2-×-⋅⋅◝◜⋅×-ℤ2◞, n 次 ](img/file65.png)'
- en: 'and the addition and scalar multiplication are defined elementwise:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 加法和标量乘法是逐元素定义的：
- en: '| x+ y | = (x[1] + y[1],…,x[n] + y[n]), x,y ∈ℤ[2]^n, |  |  |'
  id: totrans-486
  prefs: []
  type: TYPE_TB
  zh: '| x + y | = (x[1] + y[1],…,x[n] + y[n]), x,y ∈ ℤ[2]^n, |  |  |'
- en: '| cx | = (cx[1],…,cx[n]), c ∈ℤ[2]. |  |  |'
  id: totrans-487
  prefs: []
  type: TYPE_TB
  zh: '| cx | = (cx[1],…,cx[n]), c ∈ ℤ[2]. |  |  |'
- en: Problem 2\. Are the following vector sets linearly independent?
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 问题 2：以下向量集是线性无关的吗？
- en: (a) S[1] = {(1,0,0),(1,1,0),(1,1,1)}⊆ℝ³
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: (a) S[1] = {(1,0,0),(1,1,0),(1,1,1)}⊆ℝ³
- en: (b) S[2] = {(1,1,1),(1,2,4),(1,3,9)}⊆ℝ³
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: (b) S[2] = {(1,1,1),(1,2,4),(1,3,9)}⊆ℝ³
- en: (c) S[3] = {(1,1,1),(1,1,−1),(1,−1,−1)}⊆ℝ³
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: (c) S[3] = {(1,1,1),(1,1,−1),(1,−1,−1)}⊆ℝ³
- en: (d) S[4] = {(π,e),(−42,13∕6),(π³,−2)}⊆ℝ²
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: (d) S[4] = {(π,e),(−42,13∕6),(π³,−2)}⊆ℝ²
- en: Problem 3\. Let V be a finite n-dimensional vector space and let S = {v[1],…,v[m]}
    be a linearly independent set of vectors, m/span>n. Show that there is a basis
    set B such that S ⊂B.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 问题 3\. 设 V 是一个有限的 n 维向量空间，S = {v[1],…,v[m]} 是一组线性无关的向量，且 m/span>n。证明存在一个基集 B，使得
    S ⊂ B。
- en: Problem 4\. Let V be a vector space and S = {v[1],…,v[n]} be its basis. Show
    that every vector x ∈V can be uniquely written as a linear combination of vectors
    in S. (That is, if x = ∑ [i=1]^nα[i]v[i] = ∑ [i=1]^nβ[i]v[i], then α[i] = β[i]
    for all i = 1,…,n.)
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 问题 4\. 设 V 是一个向量空间，S = {v[1],…,v[n]} 是它的基。证明每个向量 x ∈ V 都可以唯一地表示为 S 中向量的线性组合。（即，如果
    x = ∑ [i=1]^n α[i]v[i] = ∑ [i=1]^n β[i]v[i]，则对于所有 i = 1,…,n，α[i] = β[i]。）
- en: Problem 5\. Let V be an arbitrary vector space and U[1],U[2] ⊆V be two of its
    subspaces. Show that U[1] + U[2] = span(U[1] ∪U[2]).
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 问题 5\. 设 V 是一个任意的向量空间，U[1] 和 U[2] ⊆ V 是其两个子空间。证明 U[1] + U[2] = span(U[1] ∪ U[2])。
- en: 'Hint: to prove the equality of these two sets, you need to show two things:
    1) if x ∈U[1] + U[2], then x ∈ span(U[1] ∪U[2]) as well, 2) if x ∈ span(U[1] ∪U[2]),
    then x ∈U[1] + U[2] as well.'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：要证明这两个集合的相等性，你需要证明两件事：1）如果 x ∈ U[1] + U[2]，则 x ∈ span(U[1] ∪ U[2])，2）如果 x
    ∈ span(U[1] ∪ U[2])，则 x ∈ U[1] + U[2]。
- en: Problem 6\. Consider the vector space of polynomials with real coefficients,
    defined by
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 问题 6\. 考虑由实系数多项式构成的向量空间，定义为：
- en: '![ n ℝ [x] = {p(x) = ∑ pxi : p ∈ ℝ, n = 0,1,...}. i i i=0 ](img/file66.png)'
  id: totrans-498
  prefs: []
  type: TYPE_IMG
  zh: '![ n ℝ [x] = {p(x) = ∑ pxi : p ∈ ℝ, n = 0,1,...}. i i i=0 ](img/file66.png)'
- en: (a) Show that
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: （a）证明：
- en: '![ ∑n i xℝ[x] := {p(x) = pix : pi ∈ ℝ, n = 1,2,...} i=1 ](img/file67.png)'
  id: totrans-500
  prefs: []
  type: TYPE_IMG
  zh: '![ ∑n i xℝ[x] := {p(x) = pix : pi ∈ ℝ, n = 1,2,...} i=1 ](img/file67.png)'
- en: is a proper subspace of ℝ[x].
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 是 ℝ[x] 的一个适当子空间。
- en: (b) Show that
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: （b）证明：
- en: '![f : ℝ[x] → xℝ [x ], p(x) ↦→ xp(x) ](img/file68.png)'
  id: totrans-503
  prefs: []
  type: TYPE_IMG
  zh: '![f : ℝ[x] → xℝ [x ], p(x) ↦→ xp(x) ](img/file68.png)'
- en: 'is a bijective and linear. (A function f : X →Y is bijective if every y ∈Y
    has exactly one x ∈X for which f(x) = y. If you are not comfortable with this
    notion, feel free to revisit this problem after [Chapter 9](#).)'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: '是双射且线性的。（如果函数 f : X → Y 是双射的，那么对每个 y ∈ Y，都有唯一的 x ∈ X 使得 f(x) = y。如果你不熟悉这个概念，可以在
    [第 9 章](#)之后再回顾这个问题。）'
- en: 'In general, a linear and bijective function f : U →V between vector spaces
    is called an isomorphism. Given the existence of such a function, we call the
    vector spaces U and V isomorphic, meaning that they have an identical algebraic
    structure.'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: '一般来说，向量空间之间的线性且双射的函数 f : U → V 被称为同构映射。给定这样的函数的存在，我们称向量空间 U 和 V 是同构的，意味着它们具有相同的代数结构。'
- en: 'Combining (a) and (b), we obtain that ℝ[X] is isomorphic with its proper subspace
    xℝ[X]. This is quite an interesting phenomenon: a vector space that is algebraically
    identical to its proper subspace. (Note that this cannot happen in finite dimensions,
    such as ℝ^n.)'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 结合（a）和（b），我们得到 ℝ[X] 与其适当子空间 xℝ[X] 同构。这是一个非常有趣的现象：一个代数上与其适当子空间相同的向量空间。（注意，这在有限维空间中是无法发生的，比如
    ℝ^n。）
- en: Join our community on Discord
  id: totrans-507
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 社区
- en: Read this book alongside other users, Machine Learning experts, and the author
    himself. Ask questions, provide solutions to other readers, chat with the author
    via Ask Me Anything sessions, and much more. Scan the QR code or visit the link
    to join the community. [https://packt.link/math](https://packt.link/math)
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他用户、机器学习专家以及作者本人一起阅读本书。提出问题，提供解决方案给其他读者，参与作者的问我任何问题（AMA）环节，还有更多内容。扫描二维码或访问链接加入社区。[https://packt.link/math](https://packt.link/math)
- en: '![PIC](img/file1.png)'
  id: totrans-509
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file1.png)'
