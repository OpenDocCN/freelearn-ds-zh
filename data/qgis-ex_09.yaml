- en: Chapter 9. Automating Analysis with Processing Scripts
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章. 使用Processing脚本自动化分析
- en: In the previous chapter, we introduced the Processing Graphical modeler, and
    you learned how to use it to automate complex geoprocessing analyses. But this
    is not the only way to automate your work. QGIS's Processing framework also allows
    you to write your own scripts in Python and use them like any other algorithm
    later. This is what we will discuss in this chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们介绍了Processing图形模型器，并学习了如何使用它来自动化复杂的地处理分析。但这并不是自动化您工作的唯一方式。QGIS的Processing框架还允许您使用Python编写自己的脚本，并在以后像使用任何其他算法一样使用它们。这就是本章将要讨论的内容。
- en: 'In this chapter, we will go through the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: Python scripts in Processing
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Processing中的Python脚本
- en: Defining the input and output
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义输入和输出
- en: Implementing the algorithm
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现算法
- en: Writing help and saving
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写帮助并保存
- en: Sharing scripts
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分享脚本
- en: Python scripts in Processing
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Processing中的Python脚本
- en: 'You have already learned how to create models and automate analysis tasks with
    the help of the graphical modeler from the QGIS Processing framework. Although
    the Processing modeler is user friendly and easy to use, it has some limitations:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经学会了如何使用QGIS处理框架中的图形模型器创建模型和自动化分析任务。尽管Processing模型器用户友好且易于使用，但它有一些限制：
- en: In the models, you can use only algorithms that are already available in Processing.
    Moreover, some algorithms that are available from the Processing toolbox are not
    available in the modeler.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在模型中，您只能使用Processing中已经可用的算法。此外，一些在Processing工具箱中可用的算法在模型器中不可用。
- en: There is no support for conditional statements and loops.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不支持条件语句和循环。
- en: So, if you need to implement something more complex and advanced, you'll need
    another tool. Fortunately, the modeler is not the only way to automate analyses
    with Processing. Processing also allows us to combine its own power with the power
    of the Python programming language by developing Python scripts. Such scripts
    can then be used like any other algorithm from the Processing toolbox or modeler,
    or executed as batch processes.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果您需要实现更复杂和高级的功能，您将需要另一个工具。幸运的是，模型器并不是自动化分析的唯一方式。Processing还允许我们通过开发Python脚本来结合其自身的能力与Python编程语言的力量。然后，这些脚本可以像Processing工具箱或模型器中的任何其他算法一样使用，或者作为批处理过程执行。
- en: Before we start implementing our scripts, it is necessary to understand how
    to use Processing algorithms from the QGIS Python console, because this knowledge
    is necessary for successful use of the existing Processing algorithms within scripts.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始实现脚本之前，了解如何从QGIS Python控制台使用Processing算法是必要的，因为这种知识对于在脚本中成功使用现有的Processing算法是必需的。
- en: 'Now, open the Python console by clicking on the ![Python scripts in Processing](img/image00513.jpeg)
    button on the **Plugins** toolbar. Alternatively, you can use the *Ctrl* + *Alt*
    + *P* keyboard shortcut or open it by going to **Plugins** | **Python Console**.
    A new dock widget will appear at the bottom of the QGIS window, as shown in the
    following screenshot:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过点击**插件**工具栏上的![Processing中的Python脚本](img/image00513.jpeg)按钮打开Python控制台。或者，您可以使用*Ctrl*
    + *Alt* + *P*键盘快捷键或通过转到**插件** | **Python控制台**来打开它。QGIS窗口底部将出现一个新的浮动窗口，如下面的截图所示：
- en: '![Python scripts in Processing](img/image00514.jpeg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![Processing中的Python脚本](img/image00514.jpeg)'
- en: The Python console consists of two main areas. At the top, there is the output
    area, where executed commands and their output will be printed. Below it is the
    input area, where you should enter the code to be executed. Here, code is entered
    line by line. There is also a toolbar on the left-hand side of the Python console.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Python控制台由两个主要区域组成。在顶部是输出区域，其中将打印执行命令及其输出。在其下方是输入区域，您应在此处输入要执行的代码。在这里，代码是逐行输入的。Python控制台的左侧还有一个工具栏。
- en: Tip
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you want to learn more about the Python console, click on the **Help** button
    from its toolbar and read the built-in documentation.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于Python控制台的信息，请点击其工具栏上的**帮助**按钮并阅读内置文档。
- en: 'To start using Processing from the Python console, we should import it with
    this command:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 要从Python控制台开始使用Processing，我们应该使用以下命令导入它：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This line will load all Processing functions and make them available for us.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码将加载所有Processing函数并使它们对我们可用。
- en: Listing the available algorithms
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列出可用算法
- en: You may want to run an existing Processing algorithm from your script instead
    of reimplementing its functionality yourself. To do this, it is necessary to get
    the name of that algorithm, which is not what you see in the toolbox, but a special
    name—the so-called command-line name.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望从你的脚本中运行现有的 Processing 算法，而不是自己重新实现其功能。为此，需要获取该算法的名称，这并不是你在工具箱中看到的名字，而是一个特殊名称——所谓的命令行名称。
- en: Note
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Every algorithm in Processing has two names: a human-readable and user-friendly
    name that is used in the toolbox and modeler, and another internal command-line
    name that has no ambiguous characters in it, such as spaces, semicolons, and so
    on. It also contains information about the algorithm provider. Command-line names
    are unique.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Processing 中的每个算法都有两个名称：一个用于工具箱和模型器中的人可读且用户友好的名称，以及另一个内部命令行名称，其中不包含任何歧义字符，例如空格、分号等。它还包含有关算法提供者的信息。命令行名称是唯一的。
- en: 'To list all available Processing algorithms with their command-line names,
    run this Python console command:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 要列出所有可用的 Processing 算法及其命令行名称，请运行以下 Python 控制台命令：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You will get a very long output that might look like this (truncated):'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到一个非常长的输出，可能看起来像这样（已截断）：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: To the left, you can see human-readable algorithm names that are also used in
    the toolbox, and to the right are the corresponding command-line names.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在左侧，你可以看到在工具箱中也使用的人可读算法名称，而在右侧是相应的命令行名称。
- en: 'As the number of algorithms—even in a default QGIS installation—is really big,
    it may be difficult to find the command-line name of the desired algorithm. Fortunately,
    it is possible to reduce the output of the `alglist()` command. Just pass to it
    a string parameter representing a substring that should exist in the algorithm''s
    name. For example, to display only algorithms with the word `count` in their names,
    execute the following code:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 由于算法的数量——即使在默认的 QGIS 安装中——也非常大，可能很难找到所需算法的命令行名称。幸运的是，可以通过 `alglist()` 命令减少输出。只需向其中传递一个字符串参数，表示应存在于算法名称中的子串。例如，要仅显示名称中包含“count”一词的算法，请执行以下代码：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The result will be much shorter, and it will be easy to find the algorithm
    you are looking for:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将更短，并且更容易找到你正在寻找的算法：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now we know how to get the command-line name of the required algorithm. But
    in order to run the algorithm, we will need to know some more information.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何获取所需算法的命令行名称。但为了运行该算法，我们还需要了解一些更多信息。
- en: Getting information about an algorithm
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取算法信息
- en: To execute an algorithm, we need not only its name but also the syntax. This
    includes information about the list of algorithm input and output, as well as
    the order in which they should be passed to the algorithm. All of this information
    can be obtained with the help of the `processing.alghelp()` command. This command
    accepts only one argument—the command-line algorithm name—and returns a list of
    algorithm inputs and outputs, with their types.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行一个算法，我们不仅需要其名称，还需要其语法。这包括有关算法输入和输出的列表，以及它们应该按何种顺序传递给算法的信息。所有这些信息都可以通过 `processing.alghelp()`
    命令获得。此命令仅接受一个参数——命令行算法名称，并返回一个包含算法输入和输出的列表，以及它们的类型。
- en: 'As an example, let''s look at the `Create grid` algorithm we used in previous
    chapters. Its command-line name is `qgis:creategrid` (you can easily check this
    using the information from the preceding section), so to get information about
    its syntax, we should execute the next command in the QGIS Python console:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 以往章节中使用的 `Create grid` 算法为例。它的命令行名称是 `qgis:creategrid`（你可以通过前述部分的信息轻松检查这一点），因此要获取其语法信息，我们应该在
    QGIS Python 控制台中执行下一个命令：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here is the output of this command:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这是此命令的输出：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'From this output, we can see that the human-readable algorithm name is `Create`
    `grid` and it accepts four input fields: `TYPE` (selection from a predefined list
    of values), `EXTENT` (the extent), `HSPACING`, and `VSPACING` (both of these are
    numbers). The algorithm has produced one vector output. The most interesting part,
    however, is below the parameters and outputs list; it''s the list of available
    values for the `TYPE` selection parameter. The numbers on the left are values
    that can be passed to the algorithm, and on the right, you can see the human-readable
    description of each value. For example, if you want to create a grid with the
    diamond cells, then it is necessary to pass a value of `2` to the `TYPE` parameter.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个输出中，我们可以看到人类可读的算法名称是`Create` `grid`，它接受四个输入字段：`TYPE`（从预定义值列表中选择）、`EXTENT`（范围）、`HSPACING`和`VSPACING`（这两个都是数字）。该算法已生成一个矢量输出。然而，最有趣的部分是在参数和输出列表下方；它是`TYPE`选择参数的可用值列表。左侧的数字是可以传递给算法的值，右侧可以看到每个值的可读描述。例如，如果您想创建一个菱形单元格的网格，那么必须将值`2`传递给`TYPE`参数。
- en: 'Now let''s see how different parameter types should be passed to the algorithm:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一下不同的参数类型应该如何传递给算法：
- en: '**Raster or vector layer and tables** (`ParameterVector`, `ParameterRaster`,
    and `ParameterTable`): It is possible to specify the name of the corresponding
    layer or table, if that layer is already loaded in QGIS. Also, you can use the
    path to the layer file. Finally, it is possible to pass an instance of the corresponding
    QGIS class, for example, `QgsVectorLayer`. If this is an optional input and you
    don''t want to use it, just use the `None` value.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**栅格或矢量图层和表格** (`ParameterVector`, `ParameterRaster`, 和 `ParameterTable`):
    如果该图层已在QGIS中加载，则可以指定相应图层或表格的名称。您还可以使用图层文件的路径。最后，可以传递相应QGIS类的实例，例如，`QgsVectorLayer`。如果这是一个可选输入并且您不想使用它，只需使用`None`值。'
- en: '**Selection from predefined values** (`ParameterSelection`): This should be
    represented by the numerical index of the corresponding value. Mapping between
    values and indexes is displayed as part of the `processing.alghelp()` function
    output, as shown earlier. There is also a separate command for listing such matches—the
    `processing.algoptions()` function. This command accepts only one argument—the
    command-line name of the algorithm—and its output is a match between the option
    index and value for all algorithm parameters with the selection type.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**从预定义值中选择** (`ParameterSelection`): 应该用对应值的数值索引表示。值与索引之间的映射作为`processing.alghelp()`函数输出的部分显示，如前所述。还有一个单独的命令用于列出此类匹配项——`processing.algoptions()`函数。此命令仅接受一个参数——算法的命令行名称——其输出是所有具有选择类型的算法参数的选项索引与值的匹配。'
- en: '**Multiple input** (`ParameterMultipleInput`): This should be passed as a string
    delimited with semicolons (`;`). Each value can be a layer name or the path to
    the file.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多个输入** (`ParameterMultipleInput`): 应该用分号（`;`）分隔的字符串传递。每个值可以是图层名称或文件的路径。'
- en: '**Field of the table** (`ParameterTableField`): This is just a string with
    the field name. Note that this values is case-sensitive.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**表格字段** (`ParameterTableField`): 这只是一个包含字段名称的字符串。请注意，这个值是区分大小写的。'
- en: '**User-defined table** (`ParameterFixedTable`): This is defined as a list of
    values separated by commas and enclosed in double quotes. Also, it is possible
    to pass a 2D list or array with the values; for example, a small 2 x 2 table can
    be passed as two-dimensional Python list, like this: `[[0, 1], [2, 3]]`. Keep
    in mind that values should start from the topmost row and go from left to right.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户定义的表格** (`ParameterFixedTable`): 这被定义为用逗号分隔的值列表，并用双引号括起来。此外，还可以传递一个包含值的二维列表或数组；例如，一个小型的2
    x 2表格可以作为一个二维Python列表传递，如下所示：`[[0, 1], [2, 3]]`。请注意，值应从最顶部的行开始，从左到右排列。'
- en: '**Coordinate reference system** (`ParameterCrs`): Use the EPSG code of the
    corresponding CRS.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**坐标参考系统** (`ParameterCrs`): 使用相应CRS的EPSG代码。'
- en: '**Extent** (`ParameterExtent`): This is represented as string containing the
    `xmin`, `xmax`, `ymin`, and `ymax` values delimited by commas (`,`).'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**范围** (`ParameterExtent`): 这表示为包含`xmin`、`xmax`、`ymin`和`ymax`值的字符串，这些值由逗号（`,`）分隔。'
- en: '**Numerical** (`ParameterNumber`), **boolean** (`ParameterBoolean`)**, and
    string** (`ParameterString`) **parameters**: These are represented by the corresponding
    native Python data types: `int`, `float`, `boolean`, `str`, or `unicode`. Also,
    such parameters may have default values. To use them, specify `None` in the place
    of the corresponding parameter.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数值** (`ParameterNumber`)、**布尔** (`ParameterBoolean`) 和 **字符串** (`ParameterString`)
    **参数**：这些由相应的原生 Python 数据类型表示：`int`、`float`、`boolean`、`str` 或 `unicode`。此外，此类参数可能有默认值。要使用它们，在相应参数的位置指定
    `None`。'
- en: For output data, the rules are much simpler. If you want to save a layer, table,
    file, or HTML output in a particular place, just pass a path to the file. In the
    case of raster and vector output, the extension of the file will determine the
    output format. If the given extension is not supported by the algorithm, the output
    will be saved in the default format (which depends on the algorithm), and the
    corresponding extension will be added to the specified file path. To write the
    output to a temporary file, pass the `None` value.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 对于输出数据，规则要简单得多。如果你想将图层、表格、文件或 HTML 输出保存到特定位置，只需传递文件路径。在栅格和矢量输出的情况下，文件的扩展名将决定输出格式。如果给定的扩展名不受算法支持，输出将保存为默认格式（这取决于算法），并将相应的扩展名添加到指定的文件路径中。要写入临时文件，传递
    `None` 值。
- en: You don't need to define any variables for numerical and string output when
    running an algorithm from the Python console. These will be calculated and returned
    automatically, without any actions from your side. See the *Executing the algorithm
    and loading the results* section of this chapter for more information about accessing
    such kinds of output.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当从 Python 控制台运行算法时，你不需要为数值和字符串输出定义任何变量。这些将自动计算并返回，无需你采取任何行动。有关访问此类输出的更多信息，请参阅本章的
    *执行算法和加载结果* 部分。
- en: Now that you know the algorithm syntax and how to pass parameters to it, we
    can execute the algorithm from the QGIS Python console.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了算法语法以及如何向其传递参数，我们可以从 QGIS Python 控制台执行算法。
- en: Executing the algorithm and loading the results
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行算法和加载结果
- en: 'To execute the algorithm from the QGIS Python console, we need to use the `processing.runalg()`
    method. Generally, this method is called in the following way:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 要从 QGIS Python 控制台执行算法，我们需要使用 `processing.runalg()` 方法。通常，该方法以以下方式调用：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, `algorithm_name` is the command-line algorithm name, `param1...paramN`
    are algorithm parameters, and `output1...outputM` are algorithm outputs. Parameters
    and outputs should be passed in the same order as shown by the `alghelp()` method,
    considering information about defining input and output from the previous section.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`algorithm_name` 是命令行算法名称，`param1...paramN` 是算法参数，而 `output1...outputM`
    是算法输出。参数和输出应该按照 `alghelp()` 方法显示的顺序传递，考虑到上一节中定义输入和输出的信息。
- en: Note
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As we mentioned previously, you don't need to specify any variables for numeric,
    string, or boolean outputs.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，对于数值、字符串或布尔输出，你不需要指定任何变量。
- en: If the algorithm reports its execution progress, a message bar with the progress
    indicator will be displayed in the main QGIS window during execution.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果算法报告其执行进度，在执行过程中，主 QGIS 窗口将显示一个带有进度指示器的消息栏。
- en: Unlike algorithm execution from the toolbox, the `runalg()` method does not
    load any results into QGIS. You can load them manually with the help of the QGIS
    API or in the following way using the helper methods provided by Processing.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 与从工具箱中执行算法不同，`runalg()` 方法不会将任何结果加载到 QGIS 中。你可以使用 QGIS API 或以下方式使用 Processing
    提供的辅助方法手动加载它们。
- en: On successful execution of the algorithm, the `runalg()` method returns a dictionary
    in which the output names (as shown by the `alghelp()` method) are the keys and
    their values are paths to the generated files or contain calculated values.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 算法成功执行后，`runalg()` 方法返回一个字典，其中输出名称（如 `alghelp()` 方法所示）是键，它们的值是生成文件的路径或包含计算值。
- en: 'To load a generated raster or vector layer, pass the path to the corresponding
    file to the `load()` method. For example, if the result of algorithm execution
    is saved in the `res` variable and the output name is `OUTPUT`, then to load this
    layer into QGIS, execute this code:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要加载生成的栅格或矢量图层，将对应文件的路径传递给 `load()` 方法。例如，如果算法执行的结果保存在 `res` 变量中，输出名称为 `OUTPUT`，那么要将此图层加载到
    QGIS 中，请执行以下代码：
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Then, the layer will be loaded into QGIS.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，该图层将被加载到 QGIS 中。
- en: To access numeric or string output in the results dictionary, just use the corresponding
    key names.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问结果字典中的数字或字符串输出，只需使用相应的键名。
- en: 'Let''s load data from the Brooklyn tree cadastre (this is the `trees` layer
    in our dataset), and try to understand how the next small example works and what
    it does. Run these commands in the QGIS Python console one by one. If necessary,
    use the `processing` helper methods, such as `alglist()` and `alghelp()`, and
    examine the results by printing them or loading into QGIS, as mentioned previously:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从布鲁克林树木地籍（这是我们数据集中的`trees`层）加载数据，并尝试理解下一个小型示例是如何工作以及它做了什么。请在QGIS Python控制台中逐个运行这些命令。如果需要，可以使用`processing`辅助方法，例如`alglist()`和`alghelp()`，并按照之前所述通过打印或加载到QGIS中来检查结果：
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If you have read the previous sections carefully, you should understand that
    these commands are used to generate a hexagonal density map from the point layer.
    In the first line, we import the `processing` module with all its algorithms.
    In the second line, the `Create grid` algorithm is executed, and it creates a
    hexagonal grid (a parameter with value equal to `3` represents hexagonal grid
    type) using the extent of the `trees` layer and cell size equal to `1000`. The
    result is saved in a temporary file, as we pass the `None` value as the last argument.
    In line `3`, the algorithm `Count points in polygon` is executed. As a polygon
    layer, it uses an output of the `Create grid` algorithm (`resGrid['OUTPUT']`),
    and as point layer, already opened trees layer in QGIS is used. Again, the result
    is stored in the temporary file. Then, in line `4`, the `Extract by attribute`
    algorithm is called to save only nonempty cells (a parameter with value `1` corresponds
    to the not equal to operator, `!=`). With the last line, the final result is loaded
    into QGIS.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您仔细阅读了前面的章节，您应该理解这些命令是用来从点层生成六边形密度图的。在第一行，我们导入`processing`模块及其所有算法。在第二行，执行`Create
    grid`算法，并使用`trees`层的范围和`1000`的单元格大小创建一个六边形网格（值为`3`的参数表示六边形网格类型）。结果保存在一个临时文件中，因为我们传递了`None`值作为最后一个参数。在行`3`，执行`Count
    points in polygon`算法。作为一个多边形层，它使用`Create grid`算法的输出（`resGrid['OUTPUT']`），作为点层，使用QGIS中已经打开的树木层。同样，结果也保存在临时文件中。然后，在行`4`，调用`Extract
    by attribute`算法来保存非空单元格（值为`1`的参数对应于不等于运算符，`!=`）。最后，使用最后一行，将最终结果加载到QGIS中。
- en: Now, that you know how to get all of the necessary information about Processing
    algorithms and can use them from the QGIS Python console, we can dive into Processing
    script development.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经知道了如何获取有关Processing算法的所有必要信息，并且可以从QGIS Python控制台使用它们，我们可以深入到Processing脚本开发中。
- en: Defining inputs and outputs
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义输入和输出
- en: As we have already said, despite models, you can create your own Processing
    scripts using the Python programming language. Basically, Processing script is
    Python code plus some additional metadata required by Processing.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所说的，尽管有模型，您可以使用Python编程语言创建自己的Processing脚本。基本上，Processing脚本就是Python代码加上Processing所需的一些附加元数据。
- en: 'Every Processing script starts with a special block of metadata. This information
    is needed by Processing to register a script as an algorithm and use it from the
    toolbox, modeler, and so on. Each metadata entry is placed on a new line, starting
    with the double Python comment symbol (`##`), and has the following structure:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Processing脚本都以一个特殊的元数据块开始。Processing需要这些信息来注册脚本作为算法，并从工具箱、模型器等中使用它。每个元数据条目都放在新的一行上，以双Python注释符号（`##`）开始，并具有以下结构：
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Metadata items can be divided into three groups: items that describe the script,
    items that describe script input, and items that describe script output.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 元数据项可以分为三组：描述脚本的项目、描述脚本输入的项目和描述脚本输出的项目。
- en: 'There are only three items that describe the script:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 描述脚本的只有三个项目：
- en: '`group`: This is used to define the name of the subgroup inside the **Scripts**
    group in the toolbox where the script will be shown. For example, if you put the
    following line `##Density maps=group` into the script header, it will be placed
    under the **Density** maps subgroup. If this item is omitted, the script will
    be placed under the **Scripts** subgroup, which is under **User**.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`group`：这用于定义脚本将在工具箱中的**Scripts**组内的子组名称。例如，如果您在脚本标题中放入以下行`##Density maps=group`，它将被放置在**Density
    maps**子组下。如果省略此项目，脚本将放置在**User**下的**Scripts**子组中。'
- en: '`name`: This defines the script name. By default, the script name is generated
    from the name of the script file by dropping the extension and replacing underscores
    with spaces. If you don''t want to use long, descriptive filenames for your scripts
    but still want nice names in the Processing toolbox, use the `name` metadata item.
    Its syntax is the same as that in the `group` item, for example, `##Hexagonal
    density map=name`.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`：这定义了脚本名称。默认情况下，脚本名称是通过删除扩展名并将下划线替换为空格从脚本文件名生成的。如果您不想使用长描述性文件名来为您的脚本命名，但仍然想在Processing工具箱中拥有好名字，请使用`name`元数据项。其语法与`group`项相同，例如，`##Hexagonal_density_map=name`。'
- en: '`nomodeler`: This item is a flag. Scripts with such metadata can be used only
    from the toolbox. They will be not available in the modeler. Its usage is like
    this: `##nomodeler`.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nomodeler`：这是一个标志项。带有此类元数据的脚本只能从工具箱中使用，它们在模型器中不可用。其用法如下：`##nomodeler`。'
- en: The number of metadata items that are used to describe script input is a much
    larger. Scripts support almost all inputs available in Processing. It is necessary
    to mention that the item name will also be a variable name, and it can be used
    in the script code. The value entered or selected by the user while executing
    the script will be assigned to the corresponding variable.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 用于描述脚本输入的元数据项的数量要大得多。脚本支持几乎在Processing中可用的所有输入。有必要指出，项目名称也将是变量名，并且可以在脚本代码中使用。用户在执行脚本时输入或选择的值将被分配给相应的变量。
- en: Also, the item name will be used as as the caption for the corresponding widget
    in the algorithm execution dialog. To improve appearance, underscores will be
    replaced by spaces. So, if you have an item with the name `My_cool_parameter`
    in the script, then its widget will have a caption as **My** **cool** **parameter**.
    To access the value of this parameter, we need to use the `My_cool_parameter`
    variable.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，项目名称将被用作算法执行对话框中相应小部件的标题。为了改善外观，下划线将被替换为空格。因此，如果您在脚本中有一个名为`My_cool_parameter`的项目，那么其小部件的标题将是**My**
    **cool** **parameter**。要访问此参数的值，我们需要使用`My_cool_parameter`变量。
- en: 'Let''s look at the available input parameters:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看可用的输入参数：
- en: '`raster`: This describes the input raster layer. Here is a usage example: `##Raster_layer=raster`.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`raster`：这描述了输入栅格图层。这里是一个用法示例：`##Raster_layer=raster`。'
- en: '`vector`: This describes the input vector layer. Note that this item should
    be used if your script accepts vector layers with any geometry type—point, line
    or polygon. If you want to limit the supported geometry types, use one of the
    following items. An example of its usage is `##Vector_layer=vector`.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vector`：这描述了输入矢量图层。请注意，如果您的脚本接受任何几何类型的矢量图层（点、线或多边形），则应使用此项目。如果您想限制支持的几何类型，请使用以下项目之一。其用法示例为：`##Vector_layer=vector`。'
- en: '`vector point`: This describes the input point vector layer. This item will
    accept only layers with point geometry. Note that such a limitation is applied
    only to layers that are already loaded into QGIS. If the user wants to specify
    a file from the disk, it is their responsibility to select the layer with the
    correct geometry type. Its usage is like this: `##Vector_layer=vector point`.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vector point`：这描述了输入点矢量图层。此项目仅接受具有点几何的图层。请注意，这种限制仅适用于已加载到QGIS中的图层。如果用户想指定磁盘上的文件，则选择具有正确几何类型的图层是他们的责任。其用法如下：`##Vector_layer=vector
    point`。'
- en: '`vector line`: This describes the input line vector layer. This item will accept
    only vectors with line geometry. Again, note that such a limitation is applied
    only to layers that are already loaded into QGIS. If the user wants to specify
    a file from the disk, it is their responsibility to select the layer with the
    correct geometry type. Its usage is like this: `##Vector_layer=vector line`.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vector line`：这描述了输入线矢量图层。此项目仅接受具有线几何的矢量。同样，请注意，这种限制仅适用于已加载到QGIS中的图层。如果用户想指定磁盘上的文件，则选择具有正确几何类型的图层是他们的责任。其用法如下：`##Vector_layer=vector
    line`。'
- en: '`vector polygon`: This describes the input polygon vector layer. This item
    will accept only vectors with polygon geometry. Once again, note that such a limitation
    is applied only to layers that are already loaded in QGIS. If the user wants to
    specify a file from the disk, it is their responsibility to select the layer with
    the correct geometry type. An example usage is as follows: `##Vector_layer=vector
    polygon`.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vector polygon`: 这描述了输入的多边形矢量层。此项目仅接受具有多边形几何形状的矢量。再次提醒，这种限制仅适用于已在QGIS中加载的层。如果用户想指定来自磁盘的文件，则选择具有正确几何类型的层是他们的责任。一个用法示例如下：`##Vector_layer=vector
    polygon`。'
- en: '`table`: This is used to define an input geometryless table. Its usage is like
    this: `##Table_to_join=table`.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`table`: 这用于定义一个无几何信息的输入表。其用法如下：`##Table_to_join=table`。'
- en: '`multiple raster`: This is used to define a compound input that consists of
    several raster layers. An example usage is as follows: `##Layers_to_mosaic=multiple
    raster`.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`multiple raster`: 这用于定义由多个栅格层组成的复合输入。一个用法示例如下：`##Layers_to_mosaic=multiple
    raster`。'
- en: '`multiple vector`: This is used to define compound input that consists of several
    vector layers. Note that this input allows us to select any vector layer, regardless
    of its geometry type. Its usage is like this: `##Layers_to_merge=multiple vector`.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`multiple vector`: 这用于定义由多个矢量层组成的复合输入。请注意，此输入允许我们选择任何矢量层，无论其几何类型如何。其用法如下：`##Layers_to_merge=multiple
    vector`。'
- en: '`selection`: This describes selection from a list of predefined values. The
    values specified after the item type are separated by semicolons. An example usage
    is as follows: `##Method=selection Nearest neighbor;Average;Cubic`.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`selection`: 这描述了从预定义值列表中的选择。项目类型之后指定的值由分号分隔。一个用法示例如下：`##Method=selection Nearest
    neighbor;Average;Cubic`。'
- en: '`boolean`: This defines a Boolean (also often called logical) input. It is
    necessary to specify a default value. Its usage is like this: `##Smooth_results=boolean
    False`.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boolean`: 这定义了一个布尔（也常称为逻辑）输入。必须指定一个默认值。其用法如下：`##Smooth_results=boolean False`。'
- en: '`extent`: This defines the input extent. Its usage is like this: `##Grid_extent=extent`.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`extent`: 这定义了输入范围。其用法如下：`##Grid_extent=extent`。'
- en: '`file`: This is used to define an input file (in text or in any other format
    that cannot be recognized by Processing as raster, vector, or table). An example
    usage is as follows: `##Index_data=file`.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`file`: 这用于定义一个输入文件（在文本或其他Processing无法识别为栅格、矢量或表的任何格式中）。一个用法示例如下：`##Index_data=file`。'
- en: '`folder`: This describes the input directory. Its usage is like this: `##Input_directory=directory`.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`folder`: 这描述了输入目录。其用法如下：`##Input_directory=directory`。'
- en: '`number`: This defines a numerical (integer or floating-point) input. It is
    necessary to specify a default value. If the default value does not have a decimal
    separator, then the parameter will accept only integer values. Currently, it is
    not possible to define minimum and maximum limits for such parameters in scripts.
    An example usage is as follows: `##Width=number 1000.0`.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`number`: 这定义了一个数值（整数或浮点数）输入。必须指定一个默认值。如果默认值没有小数分隔符，则该参数将仅接受整数值。目前，在脚本中无法为这类参数定义最小和最大限制。一个用法示例如下：`##Width=number
    1000.0`。'
- en: '`field`: This describes an attribute field in the vector layer or geometryless
    table. It is necessary to specify the name of the corresponding input that represents
    the parent layer or table. For example, if a vector layer is defined as `##Input_layer=vector`,
    then the field of this layer will be defined as `##Classification_field=field
    Input_layer`.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`field`: 这描述了矢量层或无几何信息表中的属性字段。必须指定表示父层或表的对应输入的名称。例如，如果矢量层被定义为 `##Input_layer=vector`，那么这个层的字段将被定义为
    `##Classification_field=field Input_layer`。'
- en: '`string`: This is used to define a string input. It is necessary to specify
    a default value. Its usage is like this: `##Field_name=string NUMPOINTS`.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`string`: 这用于定义一个字符串输入。必须指定一个默认值。其用法如下：`##Field_name=string NUMPOINTS`。'
- en: '`longstring`: This defines a multiline string input. It is necessary to specify
    a default value. An example of its usage is as follows: `##Options=longstring
    my cool options`.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`longstring`: 这定义了一个多行字符串输入。必须指定一个默认值。其用法的一个例子如下：`##Options=longstring my cool
    options`。'
- en: '`crs`: This describes the coordinate reference system. By default, EPSG:4326
    is used. If you want another default CRS, specify its `EPSG` code. Its usage is
    like this: `##Assign_CRS=crs EPSG:3857`.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`crs`: 这描述了坐标参考系统。默认情况下，使用EPSG:4326。如果您想指定另一个默认CRS，请指定其`EPSG`代码。其用法如下：`##Assign_CRS=crs
    EPSG:3857`。'
- en: Input layers and tables are always passed to the script as strings containing
    paths to the corresponding files. To create a QGIS object (`QgsVectorLayer` or
    `QgsRasterLayer`) from such a string, we need to use the `processing.getObjectFromUri()`
    function. Multiple raster or vector inputs are also passed as strings that contain
    paths to individual files separated by semicolons.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 输入图层和表始终作为包含对应文件路径的字符串传递给脚本。要从这样的字符串创建QGIS对象（`QgsVectorLayer`或`QgsRasterLayer`），我们需要使用`processing.getObjectFromUri()`函数。多个栅格或矢量输入也作为包含由分号分隔的各个文件路径的字符串传递。
- en: 'Here are all the available outputs:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这里列出了所有可用的输出：
- en: '`output raster`: This represents the raster layer generated by the script.
    Its usage is like this: `##NDVI_raster=output raster`.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`输出栅格`: 这代表由脚本生成的栅格图层。其用法如下：`##NDVI栅格输出=输出栅格`。'
- en: '`output vector`: This represents the vector layer generated by the script.
    An example of its usage is as follows: `##Vector_grid=output vector`.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`输出矢量`: 这代表由脚本生成的矢量图层。其用法示例如下：`##矢量网格输出=输出矢量`。'
- en: '`output table`: This represents a geometryless table generated by the script.
    This can be, for example, a CVS or DBF table. Its usage is like this: `##Nearest_points=output
    table`.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`输出表格`: 这代表由脚本生成的无几何表格。这可以是CVS或DBF表格。其用法如下：`##最近点输出=输出表格`。'
- en: '`output html`: This describes the output in HTML format. Such an output is
    mainly used for different textual reports that may or may not include graphics.
    An example of its usage is as follows: `##Statistics=output html`.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`输出HTML`: 这描述了HTML格式的输出。这种输出主要用于可能包含或不包含图形的不同文本报告。其用法示例如下：`##统计输出=输出HTML`。'
- en: '`output file`: This is used for files in formats different from HTML and all
    others supported by QGIS formats. For example, these can be plain text files,
    LiDAR data, and so on. Its usage is like this: `##Points_connection=output file`.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`输出文件`: 这用于格式不同于HTML以及QGIS支持的所有其他格式的文件。例如，这些可以是纯文本文件、LiDAR数据等。其用法如下：`##点连接输出=输出文件`。'
- en: '`output directory`: This describes the output directory. It is mainly used
    for algorithms that produce many files, for example, when splitting the vector
    layer by attribute values. An example of its usage is as follows: `##Splitted_files=output
    directory`.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`输出目录`: 这描述了输出目录。它主要用于生成许多文件的算法，例如，当按属性值分割矢量图层时。其用法示例如下：`##分割文件输出=输出目录`。'
- en: Note
  id: totrans-110
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that currently, Processing cannot load files from such output directories,
    even if these files are in the supported format. You need to manually open each
    file from the output directory.
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，目前，处理工具无法从这样的输出目录中加载文件，即使这些文件是支持的格式。您需要手动从输出目录打开每个文件。
- en: '`output number`: This represents a numerical value generated by the algorithm.
    This value not saved anywhere and can only be used as the input in another algorithm.
    For example, one can implement script to calculate optimal cell size for the vector
    grid, then the numerical output from such algorithm can be used as input in the
    Create grid algorithm. An example of its usage is as follows: `##Maximum_value=output
    number`.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`输出数值`: 这代表由算法生成的数值。此值不会保存到任何地方，只能用作另一个算法的输入。例如，可以编写脚本以计算矢量网格的最佳单元格大小，然后此类算法的数值输出可以用作创建网格算法的输入。其用法示例如下：`##最大值输出=输出数值`。'
- en: '`output string`: This is similar to the output number described previously.
    It represents a string literal generated by the algorithm. Its usage is like this:
    `##Select_condition=output string`.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`输出字符串`: 这与前面描述的输出数值类似。它代表由算法生成的字符串字面量。其用法如下：`##选择条件输出=输出字符串`。'
- en: Numerical and string outputs are also called hidden outputs (because they are
    not shown in QGIS and in Processing's results dialog), and are not automatically
    initialized with values. You should manually assign the corresponding values to
    them.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 数值和字符串输出也称为隐藏输出（因为它们在QGIS和处理的输出对话框中不显示），并且不会自动初始化为值。您应手动分配相应的值给它们。
- en: All other output will always be a string value with the path to the corresponding
    output file or directory. If user does not specify any filename, then the output
    will be saved to the automatically created temporary file, and the name of this
    file will be used as the output value.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 所有其他输出都将始终是一个字符串值，包含对应输出文件或目录的路径。如果用户未指定任何文件名，则输出将保存到自动创建的临时文件中，该文件的名称将用作输出值。
- en: It is worth mentioning that after successful algorithm execution, Processing
    will automatically load all output files in the supported formats. So, you don't
    need to add any `processing.load()` function calls to your script.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，在成功执行算法后，Processing 将自动加载所有支持的格式中的输出文件。因此，您不需要在脚本中添加任何 `processing.load()`
    函数调用。
- en: Implementing the algorithm
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现算法
- en: Now, when we know how to define input and output, we are ready to develop Python
    scripts for Processing.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们知道如何定义输入和输出时，我们就准备好为 Processing 开发 Python 脚本了。
- en: 'There are two ways to create a script:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 创建脚本有两种方法：
- en: Use your favorite text editor or IDE
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用您喜欢的文本编辑器或集成开发环境（IDE）
- en: Use Processing's built-in code editor
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Processing 的内置代码编辑器
- en: Which method to use is a matter of taste and habits. In this book, we will use
    the built-in script editor. You can open it from the Processing toolbox. Locate
    and expand the **Scripts** group, expand the **Tools** subgroup, and double-click
    on the **Create new script** item. Alternatively, you can start typing `Create
    new script` in the filter field. The toolbox's content will be filtered, and you
    can easily locate the corresponding item.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 使用哪种方法是一个口味和习惯的问题。在这本书中，我们将使用内置脚本编辑器。您可以从 Processing 工具箱中打开它。定位并展开 **脚本** 组，展开
    **工具** 子组，然后双击 **创建新脚本** 项。或者，您可以在过滤器字段中开始键入 `创建新脚本`。工具箱的内容将被过滤，您可以轻松找到相应的项。
- en: '![Implementing the algorithm](img/image00515.jpeg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![实现算法](img/image00515.jpeg)'
- en: The **Script editor** looks like an ordinary text editor as shown in the preceding
    screenshot. There is a toolbar at the top, and all of the remaining area is used
    up by the editor itself.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**脚本编辑器**看起来像前面截图所示的普通文本编辑器。顶部有一个工具栏，其余所有区域都由编辑器本身占用。'
- en: Now we will see how to create Processing Python scripts by developing a script
    to find the shortest path between two points on the road network. Such an analysis
    is very common in many areas of application such as infrastructure planning, trip/travel
    planning, and so on.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将通过开发一个用于在道路网络上找到两点之间最短路径的脚本，来了解如何创建 Processing Python 脚本。这种分析在许多应用领域都非常常见，例如基础设施规划、旅行/出行规划等。
- en: QGIS has a simple built-in network analysis library that allows us to find the
    shortest path between two points using **Dijkstra's algorithm**, and also perform
    some other interesting things, such as building areas of accessibility (also known
    as service areas) and matching points to the nearest lines.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: QGIS 拥有一个简单的内置网络分析库，允许我们使用 **Dijkstra 算法**在两点之间找到最短路径，并且还可以执行一些其他有趣的事情，例如构建可达区域（也称为服务区域）以及将点匹配到最近的线。
- en: First, we need to determine the script input and output. As input, we need a
    roads layer, a start point, and an end point. As Processing does not support points
    as input, the simplest workaround is to pass two vectors, one for the start point
    and the other for the end point. This solution also allows us to define multiple
    start and end points and find the shortest path between each pair of start and
    end points. As for the output, our script obviously will have only one output—a
    vector layer with the shortest path (or paths) calculated.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要确定脚本的输入和输出。作为输入，我们需要一个道路图层、一个起点和一个终点。由于 Processing 不支持点作为输入，最简单的解决方案是传递两个矢量，一个用于起点，另一个用于终点。这种解决方案还允许我们定义多个起点和终点，并找到每对起点和终点之间的最短路径。至于输出，我们的脚本显然只有一个输出——一个包含计算出的最短路径（或路径）的矢量图层。
- en: 'So, the script header will look like this. If you have read the previous sections
    carefully, you should have no problem understanding it:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，脚本头将看起来像这样。如果您仔细阅读了前面的章节，应该没有问题理解它：
- en: '[PRE11]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the first two lines, we define the group where our script will be placed
    and the script name. Then, we define the input and output. Note that we use precise
    definitions for input vector layers, so that when the user runs the script in
    the input comboboxes, they will see only layers with the geometry type that matches
    the parameter definition. For example, in the Road layer combobox only line vector
    layers will be listed.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两行中，我们定义了脚本将放置的组以及脚本名称。然后，我们定义了输入和输出。请注意，我们使用精确的定义来指定输入矢量图层，这样当用户在输入组合框中运行脚本时，他们只会看到与参数定义匹配的几何类型的图层。例如，在道路图层组合框中，只会列出线矢量图层。
- en: 'After the script header, a script body starts. It contains Python code that
    implements the desired algorithm. The script body can be divided into two parts:
    the import section and the code itself.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本头之后，脚本主体开始。它包含实现所需算法的Python代码。脚本主体可以分为两部分：导入部分和代码本身。
- en: Only very simple scripts can be implemented by using Python's basic commands
    alone. Any more or less complex algorithm will require additional classes or libraries,
    for example, from the Python standard library, QGIS and Processing libraries,
    or even some third-party packages. To use these libraries in your code, you need
    to import them.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 仅使用Python的基本命令，只能实现非常简单的脚本。任何更复杂或更简单的算法都需要额外的类或库，例如来自Python标准库、QGIS和Processing库，甚至是一些第三方包。要在您的代码中使用这些库，您需要导入它们。
- en: 'Usually, this is done on an iterative basis: you write the code, and when a
    new class or library is needed, add the corresponding import statement. As a rule,
    all import statements are placed at the very beginning of the source''s file.
    For the sake of simplicity, in our sample script, we will provide all the necessary
    imports from the start. The corresponding code will look as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这是基于迭代进行的：您编写代码，当需要新的类或库时，添加相应的导入语句。通常，所有导入语句都放置在源文件的非常开始处。为了简化，在我们的示例脚本中，我们将从开始提供所有必要的导入。相应的代码将如下所示：
- en: '[PRE12]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As you can see, all imports are divided into three logical blocks with empty
    lines between them. In the first line, we import the `QVariant` class from the
    `QtCore` package of the `PyQt4` library. This class contains the definition of
    the universal variant data type, which will be used to declare attributes of the
    vector layer.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，所有导入都被分为三个逻辑块，它们之间用空行隔开。在第一行，我们从`PyQt4`库的`QtCore`包中导入`QVariant`类。这个类包含了通用变体数据类型的定义，它将被用来声明矢量层的属性。
- en: In the second block, we import various non-GUI classes from the QGIS core library
    (the first line of the block) and the QGIS network analysis library (the second
    line of the block). We need these QGIS core classes to construct our output vector
    features representing the shortest paths. Moreover, classes from the QGIS network
    analysis library provide us with all that is necessary for performing network
    analysis.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个块中，我们导入了来自QGIS核心库（块的第一个行）和QGIS网络分析库（块的第二个行）的各种非GUI类。我们需要这些QGIS核心类来构建表示最短路径的输出矢量特征。此外，来自QGIS网络分析库的类为我们提供了执行网络分析所需的一切。
- en: Finally, in the last block, we import some classes from different modules of
    the QGIS Processing framework. The `GeoAlgorithmExecutionException` class will
    be used to raise exceptions from our script, and `VectorWriter` is a helper class
    that allows us to easily write output vector data in any QGIS-supported format.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在最后一个块中，我们从QGIS处理框架的不同模块中导入了一些类。`GeoAlgorithmExecutionException`类将被用来从我们的脚本中引发异常，而`VectorWriter`是一个辅助类，它允许我们轻松地将输出矢量数据写入任何QGIS支持的格式。
- en: 'Now we can implement the algorithm itself. As you learned in previous sections,
    all our inputs—the roads layer, as well as layers with the start and end points—are
    passed in the form of paths to the corresponding files, so it is necessary to
    create layer objects from them for further usage. This done with the following
    code:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以实现算法本身。如您在前面章节中学到的，所有我们的输入——道路层以及起点和终点的层——都是以对应文件路径的形式传递的，因此有必要从它们中创建层对象以供进一步使用。这可以通过以下代码完成：
- en: '[PRE13]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We use the `getObjectFromUri()` function from the processing package. It accepts
    the path to the file or any other URI and returns a valid layer (raster or vector,
    depending on the URI) from it. Note that we specify the names of the inputs defined
    in the script header as arguments in the `getObjectFromUri()` function calls.
    As we have already mentioned in the *Defining inputs and outputs* section, the
    representing input value has the same name as the corresponding input.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用处理包中的`getObjectFromUri()`函数。它接受文件路径或任何其他URI，并从中返回一个有效的层（根据URI是栅格或矢量）。请注意，我们在`getObjectFromUri()`函数调用中将脚本头中定义的输入名称作为参数指定。正如我们在“定义输入和输出”部分中提到的，代表输入值具有与相应输入相同的名称。
- en: 'As we use separate layers for start and end points, it is necessary to verify
    that both the layers have the same number of features because if the number of
    points is different, it will be impossible to create start-point-end-point pairs;
    some points will be without pairs. Here is the code for such a check:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们为起始点和结束点使用单独的层，因此有必要验证这两个层具有相同数量的特征，因为如果点的数量不同，将无法创建起始点-结束点对；一些点将没有配对。以下是此类检查的代码：
- en: '[PRE14]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We use the `featureCount()` method to get the number of features in the layers
    with the start and end points and compare them. If the numbers are not equal,
    an exception is raised and algorithm execution is aborted.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`featureCount()`方法来获取具有起始点和结束点的层的特征数量，并进行比较。如果数字不相等，将引发异常并终止算法执行。
- en: Tip
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Always raise `GeoAlgorithmExecutionException` when you need to abort script
    execution because of any error. In this case, the user will see a standard dialog
    with an error message, and also the error will be stored in the log.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在需要由于任何错误而终止脚本执行时，始终抛出`GeoAlgorithmExecutionException`。在这种情况下，用户将看到一个带有错误消息的标准对话框，并且错误将被记录在日志中。
- en: Often, algorithms need some time to complete, so it is good practice to inform
    the user about the progress of execution and provide some information about the
    completed steps so that the user will know that the program has not frozen. To
    do this, each algorithm in Processing provides a special `progress` object. With
    its help, you can easily display different types of messages to the user (information,
    debug, ordinal text, and so on), as well as show the progress of execution with
    the progress bar.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，算法需要一些时间才能完成，因此通知用户执行进度并提供有关已完成步骤的信息是良好的实践，这样用户就会知道程序没有冻结。为此，Processing中的每个算法都提供了一个特殊的`progress`对象。借助它，您可以轻松地向用户显示不同类型的消息（信息、调试、顺序文本等），以及使用进度条显示执行进度。
- en: 'Our script is no exception. There are several potentially long-running tasks
    that should be performed during the analysis. The first is collecting the coordinates
    of all start and end points from the corresponding layers. These coordinates will
    be used later in the step of road graph generation. The corresponding code is
    given here:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的脚本也不例外。在分析过程中应执行几个可能需要较长时间的任务。首先是收集所有起始点和结束点的坐标，这些坐标将在后续的路线图生成步骤中使用。相应的代码如下：
- en: '[PRE15]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the first line, we show the user an information message with the `progress.setInfo()`
    command.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行，我们使用`progress.setInfo()`命令向用户显示一条信息消息。
- en: Note
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There are also separate commands for displaying plain text (`setText()`), debug
    information (`setDebugInfo()`), console output (`setConsoleInfo()`), and other
    message types.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 除了显示普通文本（`setText()`）、调试信息（`setDebugInfo()`）、控制台输出（`setConsoleInfo()`）和其他消息类型外，还有专门的命令。
- en: This message will be displayed in the **Log** tab of the algorithm dialog.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 此消息将在算法对话框的**日志**选项卡中显示。
- en: Then we use an iterator on the features of the layer with the start points,
    extract the geometry of each feature, convert it into a `QgsPoint` instance, and
    store it in the `points` list.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们对具有起始点的层的特征使用迭代器，提取每个特征的几何形状，将其转换为`QgsPoint`实例，并将其存储在`points`列表中。
- en: Using the same approach, we create another list, called `tmp`, with the data
    from the layer containing our end points. In the last line, we merge these two
    lists into one, so our `points` list will contain the start points and then the
    end points. We need to put all the points in a single list because later, all
    the points will have to be tied to our road network. This operation is performed
    for all points at once and at the same time as graph creation. As the number of
    points in both layers is equal, we can easily access pairs of the start and end
    points using very simple math. Assuming that the number of points in each layer
    is *N* and knowing that list indexes in Python start with *0*, we can say that
    the start points will have indexes from *0* to *N-1*, while the end points will
    have indexes will be from *N* to *2N-1*. So, if we know the index of a start point,
    it is easy to get the index of the corresponding end point by adding the total
    number of points in any input layer to the index of the start point.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 使用相同的方法，我们创建另一个名为`tmp`的列表，其中包含包含我们的终点的层的资料。在最后一行，我们将这两个列表合并为一个，因此我们的`points`列表将包含起点和终点。我们需要将所有点放入一个单独的列表中，因为稍后所有点都必须与我们的道路网络相关联。此操作是在创建图的同时一次性对所有点进行的。由于两个层中的点数相等，我们可以很容易地使用非常简单的数学方法访问起点和终点的配对。假设每个层中的点数为*N*，并且知道Python中列表索引从*0*开始，我们可以这样说，起点将具有从*0*到*N-1*的索引，而终点的索引将从*N*到*2N-1*。因此，如果我们知道一个起点的索引，很容易通过将任何输入层中的点总数加到起点的索引上来得到相应的终点的索引。
- en: 'As our script will produce an output vector layer, it is necessary to prepare
    a special object for saving features in it. Fortunately, Processing has the `VectorWriter`
    class, which provides us with a convenient way to save vector data in any OGR-supported
    format or QGIS memory layer, without writing many lines of code. Here is the code
    for creating such a writer object:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的脚本将生成一个输出矢量层，因此有必要准备一个特殊对象来保存其中的要素。幸运的是，Processing有`VectorWriter`类，它为我们提供了一个方便的方式来以任何OGR支持的格式或QGIS内存层保存矢量数据，而无需编写很多代码。以下是创建此类写入对象的代码：
- en: '[PRE16]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the first five lines of code here, we create an instance of the `QgsFields`
    container, where our attributes'' definitions will be saved, and populate it.
    Our example script output layer will have four attributes:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里的前五行代码中，我们创建了一个`QgsFields`容器的实例，其中将保存我们的属性定义，并对其进行填充。我们的示例脚本输出层将具有四个属性：
- en: '`id`: This is the integer numeric identifier of the path'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id`：这是路径的整数数字标识符'
- en: '`startPoint`: These are the coordinates of the start point of the path in the
    (*x*, *y*) format'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`startPoint`：这些是路径起点的坐标，以(*x*, *y*)格式表示'
- en: '`endPoint`: These are the coordinates of the end point of the path in the (*x*,
    *y*) format'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`endPoint`：这些是路径终点的坐标，以(*x*, *y*)格式表示'
- en: '`length`: This is the total length of the path'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`length`：这是路径的总长度'
- en: In the last line, an instance of the `VectorWriter` class was created. We pass
    the paths to the output file defined by the user, the list of attributes that
    we created previously, the geometry type, and the coordinate reference system
    to the constructor. Note that as the path to the output file, we specify the same
    variable that we used in the script header to describe the output. Also, the coordinate
    reference system is taken from the input roads layer, so our output will be in
    the same CRS.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一行，创建了一个`VectorWriter`类的实例。我们将用户定义的输出文件路径、我们之前创建的属性列表、几何类型和坐标参考系统传递给构造函数。请注意，作为输出文件路径，我们指定了在脚本标题中用来描述输出的相同变量。此外，坐标参考系统是从输入的道路层中获取的，因此我们的输出将使用相同的CRS。
- en: 'Almost all the preparation steps needed for now are done, and now we can use
    the QGIS network analysis library to create a graph from our roads layer. This
    step is required because network analysis operates with the graph and not with
    the vector layer. Before creating the graph, it is necessary to instantiate all
    the required classes and adjust the settings. The following lines of code show
    you how to do this:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 目前所需的大部分准备工作都已完成，现在我们可以使用QGIS网络分析库从我们的道路层创建一个图。这一步是必要的，因为网络分析是使用图而不是矢量层进行的。在创建图之前，必须实例化所有所需的类并调整设置。以下代码行展示了如何进行此操作：
- en: '[PRE17]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'First, we instantiate the so-called director, which is a base class that adjusts
    some settings of the graph creation process. The director accepts the parameters
    explained here:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们实例化所谓的导演，这是一个基类，它调整图创建过程中的某些设置。导演接受以下解释的参数：
- en: The line vector layer from which a graph will be constructed.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建图表的线向量层。
- en: The index of the attribute field where the road's direction is stored. As we
    don't take road directions into account, we'll pass `-1` here.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储道路方向的属性字段索引。由于我们不考虑道路方向，我们将传递`-1`。
- en: The attribute value that represents the direct road direction for one-way roads.
    Direct direction means that you can move on such a road only from the start point
    to the end point of the road. In our example, we won't use direction information,
    so we pass an empty string here.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表示单行道路直接方向的属性值。直接方向意味着你只能从道路的起点移动到终点。在我们的例子中，我们不会使用方向信息，因此我们传递一个空字符串。
- en: The attribute value that represents the reverse road direction for one-way roads.
    When a road has reverse direction, you can only move from the end point to the
    start point of the road. In our example, we won't use direction information, so
    we pass an empty string here.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表示单行道路反向方向的属性值。当道路有反向方向时，你只能从道路的终点移动到起点。在我们的例子中，我们不会使用方向信息，因此我们传递一个空字符串。
- en: 'The attribute value that represents bidirectional, or two-way, roads. Bidirectional
    roads are the most common roads. They allow us to move in both directions: from
    the start to the end, and from the end to the start. In our example, we don''t
    use direction information, so again we pass an empty string here.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表示双向或双向道路的属性值。双向道路是最常见的道路。它们允许我们在两个方向上移动：从起点到终点，以及从终点到起点。在我们的例子中，我们不使用方向信息，因此我们在这里传递一个空字符串。
- en: 'The default road direction. This argument defines how to treat roads that have
    no direction information in the field specified by the first argument. It can
    be one of these values: `1` for direct direction, `2` for reverse direction, and
    `3` for bidirectional roads. For the sake of simplicity, we will treat all roads
    as two-way roads, so we will use the value `3`.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认的道路方向。此参数定义了如何处理第一个参数指定的字段中无方向信息的道路。它可以取以下值之一：`1`表示直接方向，`2`表示反向方向，`3`表示双向道路。为了简化，我们将所有道路视为双向道路，因此我们将使用值`3`。
- en: The shortest path between two points can be calculated using different criteria
    (in the QGIS network analysis library, these are called properters) or even their
    combination—length, travel time, travel cost, and so on. There is only one built-in
    criteria for now in the network analysis library—`QgsDistanceArcProperter`—which
    takes the road length into account. Of course, we can add our own criteria, but
    for the sake of simplicity in our demo script, we will use a built-in criteria.
    The properter is instantiated in the second line and added to the already created
    director in the third line.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 两个点之间的最短路径可以使用不同的标准（在QGIS网络分析库中，这些称为属性）或甚至它们的组合——长度、旅行时间、旅行成本等来计算。目前网络分析库中只有一个内置标准——`QgsDistanceArcProperter`——它考虑道路长度。当然，我们可以添加我们自己的标准，但为了简化我们的演示脚本，我们将使用内置标准。属性在第二行实例化，并在第三行添加到已创建的导演中。
- en: In the fourth line, we create the so-called builder—a class that generates a
    graph using settings specified by the director. The only argument that we pass
    to the builder is the coordinate reference system we want to use. Usually, this
    is the same CRS as that of the input road layer.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在第四行，我们创建所谓的构建器——一个使用导演指定的设置生成图表的类。我们传递给构建器的唯一参数是我们想要使用的坐标参考系统。通常，这和输入道路层的CRS相同。
- en: 'Now that all the settings are done, we can create the graph, which will be
    used to find the shortest path, as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有设置都已完成，我们可以创建图表，该图表将用于寻找最短路径，如下所示：
- en: '[PRE18]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As graph generation is a time-consuming operation, especially on a dense road
    network and for a large number of start and end points, we show an information
    message to the user before generating the graph itself.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 由于图生成是一个耗时操作，尤其是在密集的道路网络和大量起点和终点的情况下，我们在生成图表本身之前会向用户显示一条信息消息。
- en: The most important line in this snippet is the second one, where the `makeGraph()`
    method is called. The arguments are `builder`, which holds all the settings for
    the process of graph generation, and `points`, which is a list of our start and
    end points. As points may not be located exactly on the road, it is necessary
    to match them to the nearest road link. This happens in the same step as graph
    creation, and the `makeGraph()` method returns a list of so-called tied points,
    or in other words, points that are placed exactly on the nearest road segment.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码中最重要的一行是第二行，其中调用了`makeGraph()`方法。参数是`builder`，它包含图形生成过程的全部设置，以及`points`，这是一个起点和终点的列表。由于点可能不在道路上精确定位，因此有必要将它们匹配到最近的道路链接。这发生在创建图的同时，`makeGraph()`方法返回一个所谓的绑定点的列表，换句话说，就是放置在最近道路段上的点。
- en: In the third line, we get the graph object itself from the builder and store
    it for further usage. As we don't need the original points now (all further work
    will be done with the tied points), we delete them in the last line to free the
    memory.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三行，我们从构建器获取图对象本身，并存储它以供进一步使用。由于现在我们不需要原始点（所有进一步的工作都将使用绑定点），我们在最后一行删除它们以释放内存。
- en: Note
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: More information about the QGIS network analysis library is available in *PyQGIS
    Developer Cookbook* at [http://docs.qgis.org/testing/en/docs/pyqgis_developer_cookbook/network_analysis.html](http://docs.qgis.org/testing/en/docs/pyqgis_developer_cookbook/network_analysis.html).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 关于QGIS网络分析库的更多信息可以在*PyQGIS开发者手册*中找到，链接为[http://docs.qgis.org/testing/en/docs/pyqgis_developer_cookbook/network_analysis.html](http://docs.qgis.org/testing/en/docs/pyqgis_developer_cookbook/network_analysis.html)。
- en: 'Now that we have our road graph and points matched to the nearest road links,
    we can start finding the shortest path for each start-point-end-point pair. But
    first, we need to perform some helper actions, as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经有了我们的道路图和与最近的道路链接匹配的点，我们可以开始为每个起点-终点对查找最短路径。但首先，我们需要执行一些辅助操作，如下所示：
- en: '[PRE19]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The first two lines are used to prepare values for progress reporting. The progress
    bar displays values from `0` to `100` percent, and we need to process `count`
    pairs of points (equal to the number of features in any input point layer). Then,
    a single step value will be equal to `100` divided to the number of pairs.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 前两行用于为进度报告准备值。进度条显示从`0`到`100`的百分比，我们需要处理`count`对点（等于任何输入点层中的特征数量）。然后，单个步骤值将等于`100`除以对数。
- en: In the last two lines, we just prepare a vector feature instance for our output
    routes and assign previously defined attributes to it.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后两行，我们只为我们的输出路线准备一个向量特征实例，并将其分配给之前定义的属性。
- en: 'Finding the shortest path is done in the loop, as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 最短路径的查找是在循环中完成的，如下所示：
- en: '[PRE20]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the first line, we inform the user about next algorithm step. In lines `3`
    and `4`, we get the next pair of the start and end points from the list of tied
    points. In the next two lines, indexes of these points on the road graph are obtained.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行，我们通知用户下一个算法步骤。在第`3`行和第`4`行，我们从绑定点的列表中获取下一个起点和终点的对。在接下来的两行中，我们获取这些点在道路图上的索引。
- en: In line 8, the actual route calculation takes place. The `dijkstra()` method
    returns a tree with the shortest path from the tree root defined by the point
    with the `idxStart` index (this is our start point from the current point pair)
    to all other graph nodes.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在第`8`行，实际路线计算发生。`dijkstra()`方法返回一个树，其中包含从具有`idxStart`索引的点（这是当前点对中的起点）到所有其他图节点的最短路径。
- en: From lines `10` to `23`, we go through the shortest path tree and collect all
    the points that form a way from the end point to the start point.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 从第`10`行到第`23`行，我们遍历最短路径树，收集从终点到起点的所有形成路径的点。
- en: After that, from lines `25` to `30`, we create a line geometry from the collected
    points, assign it to the feature, and also set its attributes. Then the feature
    is passed to the writer object and stored in the output layer.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，从第`25`行到第`30`行，我们从收集到的点创建一个线几何形状，将其分配给特征，并设置其属性。然后，将特征传递给写入对象并存储在输出层中。
- en: Finally, in line `32`, we update the progress bar to inform the user about the
    algorithm's execution status.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在第`32`行，我们更新进度条以通知用户算法的执行状态。
- en: 'When all the point pairs are processed, we need to carry out a cleanup and
    delete unused objects, such as the road graph and output writer:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有点对都处理完毕后，我们需要进行清理并删除未使用的对象，例如道路图和输出写入器：
- en: '[PRE21]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'That''s all! Now you can save the script and test it by clicking on the **Run**
    algorithm button on the **Script** **editor** toolbar. The algorithm dialog will
    look like what is shown in the following screenshot:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！现在您可以保存脚本并通过在**脚本** **编辑器**工具栏上点击**运行**算法按钮来测试它。算法对话框将看起来如下面的截图所示：
- en: '![Implementing the algorithm](img/image00516.jpeg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![实现算法](img/image00516.jpeg)'
- en: 'You can load the `roads`, `start_points`, and `end_points` layers from your
    dataset and run the algorithm with this data. Alternatively, you can use your
    own layer with a road network, create two point layers for start and end points,
    populate them with features, and execute the script. Here is what the results
    may look like:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从数据集中加载`roads`、`start_points`和`end_points`层，并使用这些数据运行算法。或者，您可以使用自己的带有道路网络的层，为起点和终点创建两个点层，用特征填充它们，并执行脚本。以下是一些可能的结果示例：
- en: '![Implementing the algorithm](img/image00517.jpeg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![实现算法](img/image00517.jpeg)'
- en: It is necessary to mention that while the QGIS network analysis library provides
    all the necessary tools for network analysis and can easily be extended by the
    user, it also has some limitations and is not suitable for work with very large
    and dense road networks. For such situations, it is better to use more powerful
    tools, such as pgRouting.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 必须提到的是，虽然QGIS网络分析库提供了所有必要的网络分析工具，并且可以很容易地由用户扩展，但它也有一些限制，并且不适合处理非常大的密集道路网络。在这种情况下，最好使用更强大的工具，如pgRouting。
- en: Writing help and saving
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 写作帮助和保存
- en: As in the case of model, it is good practice to document your scripts. A script's
    documentation contains its description as well as information about all inputs
    and outputs. This helps users to understand the purpose of the script.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 就像模型一样，记录您的脚本是一个好的做法。脚本的文档包含其描述以及所有输入和输出的信息。这有助于用户理解脚本的目的。
- en: To create a help file for the script, open it in the built-in Processing script
    editor and click on the **Edit** **script** **help** button on the editor toolbar.
    A **Help** editor dialog, familiar to us from the *Filling model metadata and
    saving* section of [Chapter 8](part0062.xhtml#aid-1R42S1 "Chapter 8. Automating
    Analysis with Processing Models"), *Automating Analysis with Processing Models*,
    opens.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 要为脚本创建帮助文件，请在内置的Processing脚本编辑器中打开它，并在编辑器工具栏上点击**编辑** **脚本** **帮助**按钮。一个**帮助**编辑器对话框，类似于我们在[第8章](part0062.xhtml#aid-1R42S1
    "第8章。使用处理模型自动化分析")的*填充模型元数据和保存*部分中看到的，*使用处理模型自动化分析*，将打开。
- en: '![Writing help and saving](img/image00518.jpeg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![写作帮助和保存](img/image00518.jpeg)'
- en: This dialog is divided into three areas. On the top, there is a preview area.
    Here the current help content is displayed so that you can see in real-time mode
    how the final result will look. In the bottom-left part is the elements tree,
    where all the help sections are listed, including algorithm description, parameters,
    input, and other information. In the bottom-right part, there is an editing area.
    Here, we will enter the description of the corresponding element.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 此对话框分为三个区域。在顶部是预览区域。在这里显示当前的帮助内容，以便您可以在实时模式下看到最终结果的外观。在左下角是元素树，其中列出了所有帮助部分，包括算法描述、参数、输入和其他信息。在右下角是编辑区域。在这里，我们将输入相应元素的描述。
- en: To edit the description of the element, select it in the elements list and enter
    some text in the **Element** **description** field. To save the changes, just
    select another element in the elements tree.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 要编辑元素的描述，请在元素列表中选择它，并在**元素** **描述**字段中输入一些文本。要保存更改，只需在元素树中选择另一个元素。
- en: 'Go through all the items in the elements tree and enter the descriptions. For
    example, for **Algorithm** **description**, you can use this text:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历元素树中的所有项目并输入描述。例如，对于**算法**描述，您可以使用以下文本：
- en: '[PRE22]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You can describe all the other fields yourself. Try to be short and, at the
    same time, give as much useful information as possible. Don't explain obvious
    things; it's better to concentrate on important details. For example, in the description
    of the start and end points layers, it is worth mentioning that the number of
    features in them should be equal. When you're done, click on the **OK** button
    to close the **Help editor** dialog.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以自己描述所有其他字段。尽量简短，同时尽可能提供尽可能多的有用信息。不要解释明显的事情；最好专注于重要细节。例如，在起点和终点层的描述中，值得提到的是它们中的特征数量应该相等。完成之后，点击**确定**按钮关闭**帮助编辑器**对话框。
- en: To save the script help, click on the **Save** button on the **Script editor**
    toolbar. The script will be saved and its help will be written alongside, with
    the script file using the same name as used by the script with the addition of
    the `.help` suffix.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 要保存脚本帮助，请点击 **脚本编辑器** 工具栏上的 **保存** 按钮。脚本将被保存，其帮助将与之并排写入，脚本文件使用与脚本相同的名称，并添加 `.help`
    后缀。
- en: Sharing scripts
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分享脚本
- en: If you have created a useful script that may help other users, it would be good
    to share it with the community so that others don't need to reinvent the wheel.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你创建了一个可能帮助其他用户的实用脚本，那么与社区分享它将是一个好主意，这样其他人就不需要重新发明轮子。
- en: The most obvious and easiest way to share a Processing Python script is just
    to send it to those who are interested, or upload it to any file-sharing or hosting
    site and make the link to this file available to everyone. It is necessary to
    remember that in contrast to the models, script help is stored in a separate file,
    not in the script itself. So, you should not forget to include the script help
    file when uploading or sending.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 分享 Processing Python 脚本最明显且最简单的方法就是将其发送给感兴趣的人，或者上传到任何文件共享或托管网站，并使该文件的链接对每个人可用。有必要记住，与模型不同，脚本帮助存储在单独的文件中，而不是在脚本本身中。因此，在上传或发送时，你不应该忘记包括脚本帮助文件。
- en: A slightly more complex way—but at the same time, very convenient and user-friendly—is
    to publish your script on the Processing models and scripts community repository.
    This repository was created in the spring of 2014, and provides a centralized
    way to share Processing scripts and models among QGIS users.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 一种稍微复杂但同时也非常方便且用户友好的方法是，将你的脚本发布到 Processing 模型和脚本社区仓库。这个仓库是在 2014 年春季创建的，为 QGIS
    用户之间共享 Processing 脚本和模型提供了一个集中的方式。
- en: To put your script into the repository, you need to fork the *GitHub* repository
    ([https://github.com/qgis/QGIS-Processing](https://github.com/qgis/QGIS-Processing)),
    commit your script and its help file in your fork in the scripts directory, and
    issue a pull request.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 要将你的脚本放入仓库，你需要 fork *GitHub* 仓库 ([https://github.com/qgis/QGIS-Processing](https://github.com/qgis/QGIS-Processing))，在你的
    fork 中的脚本目录中提交你的脚本及其帮助文件，并发出一个 pull request。
- en: Tip
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'To learn more about Git, use one of Packt Publishing''s books, for example,
    *Git: Version Control for Everyone*, by Ravishankar Somasundaram, and refer to
    the GitHub documentation at [https://help.github.com/](https://help.github.com/).'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '要了解更多关于 Git 的信息，请使用 Packt Publishing 的书籍之一，例如，Ravishankar Somasundaram 的 *Git:
    Version Control for Everyone*，并参考 GitHub 文档 [https://help.github.com/](https://help.github.com/)。'
- en: Another option is to send the model to the Qgis-developer mailing list, or send
    it directly to one of Processing's developers and ask them to put it into the
    repository.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项是将模型发送到 Qgis-developer 邮件列表，或者直接发送给 Processing 的开发者之一，并请他们将其放入仓库中。
- en: To get scripts from this repository, use the **Get scripts from on-line script
    collection** tool, which is located in the **Tools** subgroup under the **Scripts**
    item in the **Processing** toolbox.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 要从该仓库获取脚本，请使用 **从在线脚本集合获取脚本** 工具，该工具位于 **Processing** 工具箱下的 **脚本** 项下的 **工具**
    子组中。
- en: Summary
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, you learned how to develop your own Python scripts for the
    QGIS Processing framework and automate analysis with their help. Python scripts
    are an alternative to Processing''s models and give us more flexibility than models.
    You learned how to get information about available Processing algorithms and how
    to call them from the Python console. Then, you got to know the main parts of
    a Processing script: the header with meta-information and the script body. Finally,
    we developed a simple script to calculate the shortest path between two points
    for a given road network.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何为 QGIS 处理框架开发自己的 Python 脚本，并利用它们自动化分析。Python 脚本是 Processing 模型的替代品，比模型提供了更多的灵活性。你学习了如何获取有关可用
    Processing 算法的信息，以及如何从 Python 控制台调用它们。然后，你了解了 Processing 脚本的主要部分：包含元信息的头部和脚本主体。最后，我们开发了一个简单的脚本，用于计算给定道路网络中两点之间的最短路径。
- en: In the next chapter, you will get to know another way to extent the QGIS functionality—by
    developing your own Python plugin.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将了解另一种扩展 QGIS 功能的方法——通过开发你自己的 Python 插件。
