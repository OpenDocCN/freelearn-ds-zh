- en: Chapter 10. Real-time Data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 10 章：实时数据
- en: 'This chapter will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下示例：
- en: Streaming Twitter for real-time sentiment analysis
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为实时情感分析流式传输 Twitter 数据
- en: Reading IRC chat room messages
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取 IRC 聊天室消息
- en: Responding to IRC messages
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应 IRC 消息
- en: Polling a web server for the latest updates
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向 Web 服务器轮询以获取最新更新
- en: Detecting real-time file directory changes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测实时文件目录变化
- en: Communicating in real time through sockets
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过套接字进行实时通信
- en: Detecting faces and eyes through a camera stream
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过摄像头流检测面部和眼睛
- en: Streaming camera frames for template matching
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于模板匹配的摄像头流
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: '![Introduction](img/ch10.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![Introduction](img/ch10.jpg)'
- en: It's fairly easy to first collect data and then analyze it later. However, doing
    both steps together may be necessary for some tasks. The gratifying nature of
    analyzing data the moment it is received is the core subject of this chapter.
    We will cover how to manage real-time data input from Twitter tweets, Internet
    Relay Chat (IRC), web servers, file-change notifications, sockets, and webcams.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 首先收集数据然后再分析它是相当容易的。然而，有些任务可能需要将这两个步骤结合在一起。实时分析接收到的数据是本章的核心内容。我们将讨论如何管理来自 Twitter
    推文、Internet Relay Chat（IRC）、Web 服务器、文件变更通知、套接字和网络摄像头的实时数据输入。
- en: The first three recipes will focus on dealing with real-time data from Twitter.
    These topics will include streaming posts by users as well as posts related to
    keywords.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 前三个示例将重点处理来自 Twitter 的实时数据。这些主题将包括用户发布的内容以及与关键词相关的帖子。
- en: Next, we will use two separate libraries to interact with IRC servers. The first
    recipe will demonstrate how to join an IRC chat room and start listening for messages,
    and the next recipe will show us how to listen for direct messages on an IRC server.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用两个独立的库与 IRC 服务器进行交互。第一个示例将展示如何加入一个 IRC 聊天室并开始监听消息，接下来的示例将展示我们如何在 IRC
    服务器上监听直接消息。
- en: If real-time data is not supported, a common fallback is to query for that data
    often. This process is calling **polling**, and we will learn a quick way to poll
    a web server in one of the recipes.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不支持实时数据，常见的解决方法是频繁查询该数据。这一过程称为 **轮询**，我们将在某个示例中学习如何快速轮询 Web 服务器。
- en: We will also detect changes in a file directory when a file is modified, deleted,
    or created. Imagine implementing Dropbox, OneDrive, or Google Drive in Haskell.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将在文件目录中检测到文件被修改、删除或创建的变化。可以想象在 Haskell 中实现 Dropbox、OneDrive 或 Google Drive。
- en: Finally, we will create a simple server-client interaction with sockets and
    play around with real-time webcam streams.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将创建一个简单的服务器-客户端交互，使用套接字并操作实时网络摄像头流。
- en: Streaming Twitter for real-time sentiment analysis
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为实时情感分析流式传输 Twitter 数据
- en: Twitter is flooded with content that arrives every second. A great way to start
    investigating real-time data is by examining tweets.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Twitter 上充满了每秒钟涌现的内容。开始调查实时数据的一个好方法是检查推文。
- en: This recipe will show how to write code that reacts to tweets relating to a
    specific search query. We use an external web-endpoint to determine whether the
    sentiment is positive, neutral, or negative.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例将展示如何编写代码来响应与特定搜索查询相关的推文。我们使用外部 Web 端点来确定情感是积极、消极还是中立。
- en: Getting ready
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Install the `twitter-conduit` package:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 `twitter-conduit` 包：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'For parsing JSON, let''s use `yocto`:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解析 JSON，我们使用 `yocto`：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How to do it…
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Follow these steps to set up the Twitter credentials and begin coding:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤设置 Twitter 凭证并开始编码：
- en: Create a new Twitter app by navigating to [https://apps.twitter.com](https://apps.twitter.com).
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过访问 [https://apps.twitter.com](https://apps.twitter.com) 创建一个新的 Twitter 应用。
- en: 'Find the OAuth Consumer Key and OAuth Consumer Secret from this Twitter Application
    Management page. Set the environmental variables on our system for `OAUTH_CONSUMER_KEY`
    and `OAUTH_CONSUMER_SECRET` respectively. Most Unix-based systems with sh-compatible
    shells support the `export` command:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从此 Twitter 应用管理页面找到 OAuth 消费者密钥和 OAuth 消费者密钥。分别为 `OAUTH_CONSUMER_KEY` 和 `OAUTH_CONSUMER_SECRET`
    设置系统环境变量。大多数支持 sh 兼容 shell 的 Unix 系统支持 `export` 命令：
- en: '[PRE2]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Moreover, find the OAuth Access Token and OAuth Access Secret through the same
    Twitter Application Management page and set the environmental variables accordingly:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，通过相同的 Twitter 应用管理页面找到 OAuth 访问令牌和 OAuth 访问密钥，并相应地设置环境变量：
- en: '[PRE3]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Tip
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: We put our keys, tokens, and secret pins in the environmental variables instead
    of simply hardcoding them into the program because these variables are as important
    as passwords. Just like passwords should never be publicly visible, we try our
    best to keep these tokens and keys out of direct reach from the source code.
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将密钥、令牌和秘密PIN存储在环境变量中，而不是直接将它们硬编码到程序中，因为这些变量与密码一样重要。就像密码永远不应公开可见，我们尽力将这些令牌和密钥保持在源代码之外。
- en: Download the `Common.hs` file from the sample directory of the `twitter-conduit`
    package, which is located at [https://github.com/himura/twitter-conduit/tree/master/sample](https://github.com/himura/twitter-conduit/tree/master/sample).
    Study the `userstream.hs` sample file.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`twitter-conduit`包的示例目录中下载`Common.hs`文件，路径为[https://github.com/himura/twitter-conduit/tree/master/sample](https://github.com/himura/twitter-conduit/tree/master/sample)。研究`userstream.hs`示例文件。
- en: 'First, we import all the relevant libraries:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们导入所有相关的库：
- en: '[PRE4]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In `main`, run our real-time sentiment analyzer for a search query:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main`中，运行我们的实时情感分析器以进行搜索查询：
- en: '[PRE5]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Tap into the Twitter real-time stream with our Twitter API credentials by using
    the `runTwitterFromEnv''` function provided by the `Common` module. We will use
    some crazy syntax such as `$$+-` or `^!`. Please do not be intimidated by them.
    They''re mainly used for succinctness. Every time an event is triggered, such
    as a new tweet or a new follow, we will call our `process` function on it:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Common`模块提供的`runTwitterFromEnv'`函数，通过我们的Twitter API凭证连接到Twitter的实时流。我们将使用一些非常规的语法，如`$$+-`或`^!`。请不要被它们吓到，它们主要用于简洁表达。每当触发事件时，例如新的推文或新的关注，我们将调用我们的`process`函数进行处理：
- en: '[PRE6]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Once we have our event-triggered input, we will run `process` to obtain an
    output, such as discovering the sentiment of a text. In this example, we append
    the sentiment output to a comma-separated file:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们获得事件触发的输入，就会运行`process`以获取输出，例如发现文本的情感。在本示例中，我们将情感输出附加到逗号分隔文件中：
- en: '[PRE7]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If the event-triggered input is not a tweet but instead a friendship event
    or something else, do nothing:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果事件触发的输入不是推文，而是朋友关系事件或其他内容，则不执行任何操作：
- en: '[PRE8]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Define a helper function to clean up the input by removing all `@user` mentions,
    `#hashtags`, or `http://websites`:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个辅助函数，通过移除所有`@user`提及、`#hashtags`或`http://websites`来清理输入：
- en: '[PRE9]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Use an external API to run the sentiment analysis on a body of text. In this
    example, we use the Sentiment140 API because of its ease and simplicity. Please
    see [http://help.sentiment140.com/api](http://help.sentiment140.com/api) for more
    information. To prevent getting rate-limited, also supply the `appid` parameter
    with an e-mail address or obtain a commercial license:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用外部API对文本内容进行情感分析。在本示例中，我们使用Sentiment140 API，因为它简单易用。更多信息请参考[http://help.sentiment140.com/api](http://help.sentiment140.com/api)。为了防止被限制访问，也请提供`appid`参数，并附上电子邮件地址或获取商业许可证：
- en: '[PRE10]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Extract the sentiment value from the JSON response from our API:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从我们的API的JSON响应中提取情感值：
- en: '[PRE11]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Run the code to see tweets displayed right as they are posted publicly by anyone
    worldwide. The sentiment value will be a rational number between 0 and 1, where
    0 is a negative sentiment and 1 is a positive sentiment:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，查看推文在全球任何人公开发布时即刻显示。情感值将是介于0和1之间的有理数，其中0表示负面情感，1表示正面情感：
- en: '[PRE12]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Have a look at the following output:'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 查看以下输出：
- en: '![How to do it…](img/6331OS_10_01.jpg)'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作…](img/6331OS_10_01.jpg)'
- en: 'We can also analyze the data in bulk from the `output.csv` file. Here''s a
    visual representation of the sentiments:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以从`output.csv`文件中批量分析数据。以下是情感分析的可视化表现：
- en: '![How to do it…](img/6331OS_10_02.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作…](img/6331OS_10_02.jpg)'
- en: How it works…
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'The Twitter-conduit package uses the conduit design pattern from the original
    package placed at [https://hackage.haskell.org/package/conduit](https://hackage.haskell.org/package/conduit).
    The conduit documentation states:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Twitter-conduit包使用了来自原始包的conduit设计模式，原始包位于[https://hackage.haskell.org/package/conduit](https://hackage.haskell.org/package/conduit)。conduit文档中指出：
- en: '*Conduit is a solution to the streaming data problem, allowing for production,
    transformation, and consumption of streams of data in constant memory. It is an
    alternative to lazy I/O which guarantees deterministic resource handling, and
    fits in the same general solution space as enumerator/iteratee and pipes.*'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '*Conduit是解决流数据问题的方案，允许在恒定内存中进行数据流的生产、转换和消费。它是惰性I/O的替代方案，保证了确定性的资源处理，并且与枚举器/迭代器和管道处于相同的通用解决方案空间中。*'
- en: To interact with Twitter's Application Programming Interface (API), it is necessary
    to obtain the access and application tokens and keys. We store these values in
    our environment variables and let the Haskell code retrieve it from there.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与Twitter的应用程序编程接口（API）进行交互，必须获得访问令牌和应用程序密钥。我们将这些值存储在环境变量中，并让Haskell代码从中检索。
- en: The `Common.hs` file takes care of monotonous authentication code, which should
    be left untouched.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`Common.hs`文件负责处理单调的认证代码，应该保持不变。'
- en: The function that reacts to each Twitter event is `process`. We can modify `process`
    to accompany our specific needs. More specifically, we can modify the sentiment
    function to use a different `sentiment` analysis service.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 反应每个Twitter事件的函数是`process`。我们可以修改`process`以满足我们特定的需求。更具体地说，我们可以修改情感分析函数，以使用不同的`sentiment`分析服务。
- en: There's more…
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容…
- en: 'Our code listens to any tweets that match our query. This Twitter-conduit library
    also supports two other real-time streams: `statusesFilterByFollow` and `userstream`.
    The former retrieves all tweets from a list of prescribed users. The latter retrieves
    all tweets from the users that the account follows.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码监听任何与我们查询匹配的推文。这个Twitter-conduit库还支持另外两种实时流：`statusesFilterByFollow`和`userstream`。前者获取指定用户列表的所有推文，后者获取该账户关注的用户的所有推文。
- en: 'For example, modify our code by replacing the `statusesFilterByTrack` query
    with the UIDs of some Twitter users:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，通过将`statusesFilterByTrack`查询替换为一些Twitter用户的UID来修改我们的代码：
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Moreover, to only retrieve tweets from the users that we are following, we
    can instead modify our code by replacing the `statusesFilterByTrack` query with
    `userstream`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，为了仅获取我们关注的用户的推文，我们可以通过将`statusesFilterByTrack`查询替换为`userstream`来修改我们的代码：
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Many more examples can be found through [https://github.com/himura/twitter-conduit/tree/master/sample](https://github.com/himura/twitter-conduit/tree/master/sample).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 通过[https://github.com/himura/twitter-conduit/tree/master/sample](https://github.com/himura/twitter-conduit/tree/master/sample)可以找到更多示例。
- en: Reading IRC chat room messages
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 阅读IRC聊天室消息
- en: The Internet Relay Chat (IRC) is one of the oldest and most vibrant group chat
    room services out there. The Haskell community has a substantially welcoming presence
    on the Freenode IRC server (`irc.freenode.org`) in the `#haskell` channel.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Internet Relay Chat（IRC）是最古老且最活跃的群聊服务之一。Haskell社区在Freenode IRC服务器（`irc.freenode.org`）的`#haskell`频道中拥有非常友好的存在。
- en: In this recipe, we will build an IRC bot that joins a room and listens to text
    conversations. Our program will emulate an IRC client and connect to one of the
    many existing IRC servers. This recipe requires no external libraries at all.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将构建一个IRC机器人，加入一个聊天室并监听文本对话。我们的程序将模拟一个IRC客户端，并连接到现有的IRC服务器之一。这个配方完全不需要外部库。
- en: Getting ready
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 做好准备
- en: Make sure an Internet connection is enabled.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 确保启用互联网连接。
- en: 'To test out the IRC bot, it helps to install an IRC client. For instance, one
    of the top IRC clients is **Hexchat**, which can be downloaded from [http://hexchat.github.io](http://hexchat.github.io).
    For a terminal-based IRC client, **Irssi** is a favorite: [http://www.irssi.org](http://www.irssi.org).'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试IRC机器人，最好安装一个IRC客户端。例如，顶级的IRC客户端之一是**Hexchat**，可以从[http://hexchat.github.io](http://hexchat.github.io)下载。对于基于终端的IRC客户端，**Irssi**是最受欢迎的：[http://www.irssi.org](http://www.irssi.org)。
- en: 'Review the *Roll your own IRC bot* article on the Haskell wiki: [http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot](http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot).
    This recipe is heavily based on the code presented on the wiki.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在Haskell wiki上查看*自己动手制作IRC机器人*文章：[http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot](http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot)。这个配方的代码大多基于wiki上的内容。
- en: How to do it…
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'In a new file called `Main.hs`, insert the following code:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个名为`Main.hs`的新文件中，插入以下代码：
- en: 'Import the relevant packages:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入相关的包：
- en: '[PRE15]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Specify the IRC server specifics:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定IRC服务器的具体信息：
- en: '[PRE16]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Connect to the server and listen to all text being passed in a chat room:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接到服务器并监听聊天室中的所有文本：
- en: '[PRE17]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Define our listener. For this recipe, we will just echo all events to the console:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义我们的监听器。对于这个配方，我们将仅将所有事件回显到控制台：
- en: '[PRE18]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: See also
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: To see another way to interact with IRC, see the next recipe, *Responding to
    IRC messages*.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解另一种与IRC交互的方式，请查看下一个配方，*回应IRC消息*。
- en: Responding to IRC messages
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回应IRC消息
- en: Another way to interact with IRC in Haskell is by using the `Network.SimpleIRC`
    package. This package encapsulates much of the low-level networking and also provides
    useful IRC interfaces.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种与IRC交互的方式是使用`Network.SimpleIRC`包。此包封装了许多底层网络操作，并提供了有用的IRC接口。
- en: In this recipe, we will respond to messages in a channel. If any user types
    in the trigger phrase, in our case "host?", then we will reply to that user with
    their host address.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将回应频道中的消息。如果有用户输入触发词，在本案例中为“host?”，我们将回复该用户其主机地址。
- en: Getting ready
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Install the `Network.SimpleIRC` package:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 安装`Network.SimpleIRC`包：
- en: '[PRE19]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To test out the IRC bot, it is helpful to install an IRC client. A decent IRC
    client is Hexchat, which can be downloaded from [http://hexchat.github.io](http://hexchat.github.io).
    For a terminal-based IRC client, Irssi is one of the best: [http://www.irssi.org](http://www.irssi.org).'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试IRC机器人，安装IRC客户端会很有帮助。一个不错的IRC客户端是Hexchat，可以从[http://hexchat.github.io](http://hexchat.github.io)下载。对于基于终端的IRC客户端，Irssi是最好的之一：[http://www.irssi.org](http://www.irssi.org)。
- en: How to do it…
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Create a new file, which we call `Main.hs`, and do the following:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的文件，我们称之为`Main.hs`，并执行以下操作：
- en: 'Import the relevant libraries:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入相关的库：
- en: '[PRE20]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Create an event handler when a message is received. If the message is "host?",
    then reply to the user with information about their host:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建接收到消息时的事件处理程序。如果消息是“host?”，则回复用户其主机信息：
- en: '[PRE21]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Define on which events to listen:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义要监听的事件：
- en: '[PRE22]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Set up the IRC server configuration. Connect to any list of channels and bind
    our event:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置IRC服务器配置。连接到任意一组频道，并绑定我们的事件：
- en: '[PRE23]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Connect to the server. Don''t run in a new thread, but print debug messages,
    as specified by the corresponding Boolean parameters:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接到服务器。不要在新线程中运行，而是打印调试信息，按照相应的布尔参数来指定：
- en: '[PRE24]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Run the code, and open an IRC client to test it out:![How to do it…](img/6331OS_10_03.jpg)
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，打开IRC客户端进行测试：![如何操作…](img/6331OS_10_03.jpg)
- en: See also
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: To connect to an IRC server without using an external library, see the previous
    recipe, *Reading IRC chat room messages*.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 若要在不使用外部库的情况下连接IRC服务器，请参见之前的教程，*读取IRC聊天室消息*。
- en: Polling a web server for latest updates
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 轮询web服务器以获取最新更新
- en: Some websites change dramatically very often. For instance, Google News and
    Reddit are usually loaded with recent postings the moment we refresh the page.
    To maintain the latest data at all times, it might be best to run an HTTP request
    often.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 一些网站的变化非常频繁。例如，Google新闻和Reddit通常在我们刷新页面时，立刻加载最新的帖子。为了随时保持最新数据，最好是频繁地发送HTTP请求。
- en: 'In this recipe, we poll new Reddit posts every 10 seconds as summarized in
    the following diagram:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们每10秒轮询一次新的Reddit帖子，如下图所示：
- en: '![Polling a web server for latest updates](img/6331OS_10_04.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![轮询web服务器以获取最新更新](img/6331OS_10_04.jpg)'
- en: How to do it…
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'In a new file called `Main.hs`, perform the following steps:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个名为`Main.hs`的新文件中，执行以下步骤：
- en: 'Import the relevant libraries:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入相关的库：
- en: '[PRE25]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Define the URL to poll:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义要轮询的URL：
- en: '[PRE26]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Define the function to obtain the latest data from an HTTP GET request:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个函数来获取最新的HTTP GET请求数据：
- en: '[PRE27]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Polling is simply the act of recursively conducting a task after waiting for
    a specified amount of time. In this case, we will wait 10 seconds before asking
    for the latest web data:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 轮询实际上是等待指定时间后递归地执行任务。在这种情况下，我们会等10秒钟再请求最新的网页数据：
- en: '[PRE28]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Run the polling:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行轮询：
- en: '[PRE29]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'After each web request, analyze the data. In this recipe, count the number
    of times Imgur shows up:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每次Web请求后，分析数据。在本教程中，统计Imgur出现的次数：
- en: '[PRE30]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Detecting real-time file directory changes
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测实时文件目录变化
- en: In this recipe, we will instantly detect when a new file is created, modified,
    or deleted. Similar to the popular file synchronization software Dropbox, we will
    be able to do interesting actions every time such an event occurs.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将实时检测文件是否被创建、修改或删除。类似于流行的文件同步软件Dropbox，我们每次遇到这样的事件时，都会执行一些有趣的操作。
- en: Getting ready
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Install the `fsnotify` package:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 安装`fsnotify`包：
- en: '[PRE31]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: How to do it…
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'In a new file called `Main.hs`, perform these steps:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个名为`Main.hs`的新文件中，执行以下步骤：
- en: 'Import the relevant libraries:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入相关的库：
- en: '[PRE32]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Run the file watcher on the current directory:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在当前目录上运行文件监视器：
- en: '[PRE33]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Handle each of the file change events. In this recipe, we just print out the
    action to the console:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理每个文件变化事件。在本教程中，我们仅将操作输出到控制台：
- en: '[PRE34]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Run the code and start modifying some files in the same directory. For example,
    create a new file, edit it, and then remove it:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并开始修改同一目录中的一些文件。例如，创建一个新文件，编辑它，然后删除它：
- en: '[PRE35]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: How it works…
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The `fsnotify` library binds to the event-notification services specific to
    a platform-specific filesystem. On Unix-based systems, this is usually `inotify`
    ([http://dell9.ma.utexas.edu/cgi-bin/man-cgi?inotify](http://dell9.ma.utexas.edu/cgi-bin/man-cgi?inotify)).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`fsnotify`库绑定到特定平台文件系统的事件通知服务。在基于Unix的系统中，这通常是`inotify`（[http://dell9.ma.utexas.edu/cgi-bin/man-cgi?inotify](http://dell9.ma.utexas.edu/cgi-bin/man-cgi?inotify)）。'
- en: Communicating in real time through sockets
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过套接字实时通信
- en: Sockets provide a convenient way of communicating between programs in real time.
    Think of them as a chat client.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 套接字提供了一种方便的实时程序间通信方式。可以把它们想象成一个聊天客户端。
- en: In this recipe, we will pass messages from one program to another and obtain
    responses.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将从一个程序向另一个程序发送消息并获取响应。
- en: How to do it…
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Insert the following code in a new file called `Main.hs`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码插入到名为`Main.hs`的新文件中：
- en: 'Create the server code:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建服务器代码：
- en: '[PRE36]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Create a socket connection to listen on, and attach our handler, `sockHandler`,
    on it:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个套接字连接以进行监听，并在其上附加我们的处理程序`sockHandler`：
- en: '[PRE37]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Define the handler to process each message received:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义处理每个接收到的消息的处理程序：
- en: '[PRE38]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Define how to process messages sent by the client:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义如何处理客户端发送的消息：
- en: '[PRE39]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Send messages to the client through user input:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过用户输入向客户端发送消息：
- en: '[PRE40]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now, create the client code in a new file, `client.hs`. First, import the libraries:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在一个新文件`client.hs`中创建客户端代码。首先，导入库：
- en: '[PRE41]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Connect the client to the corresponding port and set up the responder and listener
    threads:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将客户端连接到相应的端口，并设置响应者和监听线程：
- en: '[PRE42]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Get user input and send it as a message:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取用户输入并将其作为消息发送：
- en: '[PRE43]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Listen to incoming messages from the server:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 监听来自服务器的传入消息：
- en: '[PRE44]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Test out the code by first running the server:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 先运行服务器，测试代码：
- en: '[PRE45]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Next, on a separate terminal, run the client:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在一个单独的终端中运行客户端：
- en: '[PRE46]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We can now send messages between the two by typing and hitting *Enter*:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以通过键入并按下*Enter*键在两者之间发送消息：
- en: '[PRE47]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: How it works…
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The `hGetLine` function is blocking the code execution, which means that code
    execution halts at that point until a message is received. This allows us to wait
    for messages to conduct real-time reactions.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`hGetLine`函数会阻塞代码执行，这意味着代码执行在此处暂停，直到接收到消息为止。这允许我们等待消息并进行实时反应。'
- en: We first specify a port on the computer, which is simply a number that is not
    yet reserved by other programs. The server sets up the socket, and the client
    connects to it without needing to set it up. The messages passed between the two
    happen in real time.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先在计算机上指定一个端口，这只是一个尚未被其他程序占用的数字。服务器设置套接字，客户端连接到它，而无需进行设置。两者之间传递的消息是实时发生的。
- en: 'A visualization of the server-client model is demonstrated in the following
    diagram:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示演示了服务器-客户端模型的可视化：
- en: '![How it works…](img/6331OS_10_05.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的…](img/6331OS_10_05.jpg)'
- en: Detecting faces and eyes through a camera stream
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过摄像头流检测人脸和眼睛
- en: The camera is another source for real-time data. As frames come and go, we can
    perform powerful analysis using the OpenCV library.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 摄像头是另一个实时数据的来源。随着帧的进出，我们可以使用OpenCV库进行强大的分析。
- en: In this recipe, we conduct facial detection through a live camera stream.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们通过实时摄像头流进行人脸检测。
- en: Getting ready
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Install the OpenCV, SDL, and FTGL libraries for image manipulation and computer
    vision:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 安装OpenCV、SDL和FTGL库以进行图像处理和计算机视觉：
- en: '[PRE48]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Install an OpenCV library using cabal:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 使用cabal安装OpenCV库：
- en: '[PRE49]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: How to do it…
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Create a new source file, `Main.hs`, and follow these steps:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的源文件`Main.hs`，并按照以下步骤操作：
- en: 'Import the relevant libraries:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入相关库：
- en: '[PRE50]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Define the source of the camera stream. We will be using the built-in webcam.
    To instead use a video, we can replace `camera 0` with `videoFile "./myVideo.mpeg"`:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义摄像头流的来源。我们将使用内置的摄像头。若要改用视频，可以将`camera 0`替换为`videoFile "./myVideo.mpeg"`：
- en: '[PRE51]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Shrink the size of the stream for faster performance:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 缩小流的大小以提高性能：
- en: '[PRE52]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Detect the faces in an image using the training dataset provided by OpenCV:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用OpenCV提供的训练数据集检测图像中的人脸：
- en: '[PRE53]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Detect the eyes in the image using the training data set provided by OpenCV:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用OpenCV提供的训练数据集检测图像中的眼睛：
- en: '[PRE54]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Draw rectangles around faces and eyes:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在人脸和眼睛周围画矩形框：
- en: '[PRE55]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Capture the camera''s stream, detect the faces and eyes, draw rectangles, and
    display them in two different windows:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 捕获摄像头流，检测面部和眼睛，绘制矩形，并在两个不同的窗口中显示它们：
- en: '[PRE56]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Perform the real-time camera streaming and stop once a key is pressed:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行实时摄像头流并在按下某个键后停止：
- en: '[PRE57]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Run the code and look at the webcam to detect faces and eyes as shown in the
    screenshot that follows this command:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看网络摄像头，以检测面部和眼睛，结果如以下命令后的截图所示：
- en: '[PRE58]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '![How to do it…](img/6331OS_10_06.jpg)'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何做…](img/6331OS_10_06.jpg)'
- en: How it works…
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: To detect faces, eyes, or other objects, we use the `haarDetect` function, which
    performs a classifier trained from many positive and negative test cases. These
    test cases are provided by OpenCV and are typically located in `/usr/share/opencv/haarcascades/`
    on Unix-based systems.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检测面部、眼睛或其他物体，我们使用`haarDetect`函数，它执行从许多正面和负面测试案例中训练出来的分类器。这些测试案例由OpenCV提供，通常位于Unix系统中的`/usr/share/opencv/haarcascades/`目录下。
- en: The cv-combinator library provides a convenient abstraction to OpenCV's low-level
    manipulations. To run any useful code, we must define a source, a process, and
    a final destination (also referred to as a *sink*). In our case, the source was
    the machine's built-in camera. We first resize the image to something more manageable
    (`resizer`), split the stream into two in parallel (`--<`), draw boxes around
    faces in one while drawing boxes around eyes in the other, and finally output
    the streams to two separate windows. For more documentation of the cv-combinators
    package, see [https://hackage.haskell.org/package/cv-combinators](https://hackage.haskell.org/package/cv-combinators).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: cv-combinator库提供了OpenCV底层操作的便捷抽象。为了运行任何有用的代码，我们必须定义一个源、一个过程和一个最终目标（也称为*sink*）。在我们的案例中，源是机器内置的摄像头。我们首先将图像调整为更易处理的大小（`resizer`），然后将流分成两个并行流（`--<`），在一个流中绘制面部框，在另一个流中绘制眼睛框，最后将这两个流输出到两个独立的窗口。有关cv-combinators包的更多文档，请参见[https://hackage.haskell.org/package/cv-combinators](https://hackage.haskell.org/package/cv-combinators)。
- en: Streaming camera frames for template matching
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摄像头流的模板匹配
- en: Template matching is a machine-learning technique to find areas of an image
    that match a given template image. We will apply template matching to every frame
    of a real-time video stream to locate an image.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 模板匹配是一种机器学习技术，用于寻找与给定模板图像匹配的图像区域。我们将把模板匹配应用于实时视频流的每一帧，以定位图像。
- en: Getting ready
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Install the OpenCV and c2hs toolkits:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 安装OpenCV和c2hs工具包：
- en: '[PRE59]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Install the CV library from cabal. Be sure to include the `–fopencv24` or `–fopencv23`
    parameter depending on which version of OpenCV is installed:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 从cabal安装CV库。确保根据安装的OpenCV版本包含`–fopencv24`或`–fopencv23`参数：
- en: '[PRE60]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Also, create a small template image. In this recipe, we use an image of Lena,
    which is usually used in many image-processing experiments. We name this image
    file `lena.png`:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，创建一个小的模板图像。在这个实例中，我们使用的是Lena的图像，这个图像通常用于许多图像处理实验。我们将此图像文件命名为`lena.png`：
- en: '![Getting ready](img/6331OS_10_07.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作](img/6331OS_10_07.jpg)'
- en: How to do it…
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'In a new file, `Main.hs`, start with these steps:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个新的文件`Main.hs`中，从以下步骤开始：
- en: 'Import the relevant libraries:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入相关库：
- en: '[PRE61]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Load the template image and start the template matching on a camera stream:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载模板图像并开始对摄像头流进行模板匹配：
- en: '[PRE62]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Perform an action on each frame of the camera stream. Specifically, use template
    matching to locate the template and draw a circle around it:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对摄像头流的每一帧执行操作。具体来说，使用模板匹配来定位模板并围绕其绘制一个圆圈：
- en: '[PRE63]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Run the code using the following command and show an image of the template.
    A black circle will be drawn around the found image:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行代码并显示模板图像。会在找到的图像周围绘制一个黑色圆圈：
- en: '[PRE64]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '![How to do it…](img/6331OS_10_08.jpg)'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何做…](img/6331OS_10_08.jpg)'
- en: There's more…
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容……
- en: More OpenCV examples can be found at [https://github.com/aleator/CV/tree/master/examples](https://github.com/aleator/CV/tree/master/examples).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 更多OpenCV示例可以在[https://github.com/aleator/CV/tree/master/examples](https://github.com/aleator/CV/tree/master/examples)找到。
