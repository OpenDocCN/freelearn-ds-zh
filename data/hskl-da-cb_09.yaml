- en: Chapter 9. Parallel and Concurrent Design
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章。并行与并发设计
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下食谱：
- en: Using the Haskell Runtime System (RTS) options
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Haskell运行时系统（RTS）选项
- en: Evaluating a procedure in parallel
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并行评估程序
- en: Controlling parallel algorithms in sequence
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按顺序控制并行算法
- en: Forking I/O actions for concurrency
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为并发操作分叉I/O动作
- en: Communicating with a forked I/O action
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与分叉的I/O操作通信
- en: Killing forked threads
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 终止分叉线程
- en: Parallelizing pure functions using the Par monad
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Par单子并行化纯函数
- en: Mapping over a list in parallel
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并行映射列表
- en: Accessing tuple elements in parallel
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并行访问元组元素
- en: Implementing MapReduce to count word frequencies
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现MapReduce以计算单词频率
- en: Manipulating images in parallel using Repa
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Repa并行处理图像
- en: Benchmarking runtime performance in Haskell
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Haskell中的运行时性能基准测试
- en: Using the criterion package to measure performance
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用criterion包来测量性能
- en: Benchmarking runtime performance in the terminal
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在终端中进行运行时性能基准测试
- en: Introduction
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: '![Introduction](img/ch09.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![介绍](img/ch09.jpg)'
- en: One of the greatest accomplishments in the study of data analysis is the intelligent
    approach to parallel and concurrent design. As we collect more and more data,
    we are able to discover more and more patterns. However, this comes at a price
    of time and space. More data may take more time to compute or more space in terms
    of memory. It is a very real problem that this chapter will try to solve.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 数据分析研究中的一项伟大成就是对并行和并发设计的智能应用。随着我们收集越来越多的数据，我们能够发现越来越多的模式。然而，这也以时间和空间为代价。更多的数据可能需要更多的计算时间或更多的内存空间。这是一个非常现实的问题，本章将尝试解决它。
- en: The first few recipes will cover how to evoke pure procedures in parallel and
    in sequence. The following recipes on forking will deal with concurrency using
    I/O actions. We will then delve deeper by learning how to access a list and tuple
    elements in parallel. Then, we will implement MapReduce in Haskell to solve a
    time-consuming problem efficiently.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 前几个食谱将介绍如何并行和顺序地调用纯程序。接下来的分叉食谱将涉及使用I/O动作的并发。然后，我们将深入学习如何并行访问列表和元组元素。接着，我们将在Haskell中实现MapReduce来高效解决一个费时的问题。
- en: We will end the review of parallel and concurrent design by learning how to
    benchmark runtime performance. Sometimes, the easiest way to discover if code
    is successfully running in parallel is by timing it against a nonparallel version
    of the code. If the computation time between the two appears to be the same, then
    it is very likely that something is wrong. Either the code is not running in parallel
    or the cost of evoking parallelism outweighs the benefits.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过学习如何进行运行时性能基准测试，结束对并行和并发设计的回顾。有时候，发现代码是否成功地并行运行的最简单方法是将其与非并行版本的代码进行时间对比。如果两者的计算时间看起来相同，那么很可能出现了问题。要么代码没有并行运行，要么激活并行的成本超过了其带来的好处。
- en: Using the Haskell Runtime System options
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Haskell运行时系统选项
- en: The **Runtime System** (**RTS**) in Haskell configures special options such
    as scheduling, profiling, and managing storage for a compiled Haskell program.
    In order to write multithreaded code, we must specify our own RTS options as outlined
    in this recipe.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Haskell中的**运行时系统**（**RTS**）配置了如调度、分析和管理已编译Haskell程序存储等特殊选项。为了编写多线程代码，我们必须按照本食谱中概述的方式指定自己的RTS选项。
- en: For further reading, the GHC Commentary on the official Haskell Wiki web page
    has a very detailed explanation of the runtime system available at [https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts](https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如需进一步阅读，GHC官方Haskell Wiki网页上的GHC评论部分提供了关于运行时系统的详细说明，网址为[https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts](https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts)。
- en: How to do it…
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作……
- en: 'Open a terminal, compile a code, and run it using the RTS option. Imagine that
    our file is named `Main.hs`, and issue the following commands:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 打开终端，编译代码，并使用RTS选项运行它。假设我们的文件名为`Main.hs`，然后执行以下命令：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How it works…
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: In order to make use of multiple threads, we must compile our code with the
    `threaded` and `rtsopts` flags enabled.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了利用多个线程，我们必须在编译代码时启用`threaded`和`rtsopts`标志。
- en: Now that it is compiled with `rtsopts`, we can run our program with special
    instructions placed between the `+RTS` and `-RTS` flags. If there is a `+RTS`
    flag without a `–RTS` flag, then we assume that the RTS options continue until
    the end of the line.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，它已经用 `rtsopts` 编译，我们可以使用特殊指令在 `+RTS` 和 `-RTS` 标志之间运行程序。如果存在 `+RTS` 标志但没有
    `–RTS` 标志，则假设 RTS 选项会持续到行尾。
- en: We set the number of threads to use by placing `-Nx` within the RTS argument,
    which stands for "use x threads". So, to use two threads, we should type *-N2*.
    To use all possible threads, we simply type *-N*.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在 RTS 参数中放入 `-Nx` 来设置使用的线程数，其中 `x` 表示“使用 x 个线程”。因此，要使用两个线程，我们应输入 *-N2*。要使用所有可能的线程，我们只需输入
    *-N*。
- en: There's more…
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多……
- en: Another way to specify the RTS options is during compile time, using the `--with-rtsopts`
    flag. More advanced methods include modifying environment variables or overriding
    runtime system hooks. More information on these can be found on the official Haskell
    user guide available at [https://www.haskell.org/ghc/docs/7.4.1/html/users_guide/runtime-control.html](https://www.haskell.org/ghc/docs/7.4.1/html/users_guide/runtime-control.html).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 指定 RTS 选项的另一种方法是在编译时使用 `--with-rtsopts` 标志。更高级的方法包括修改环境变量或覆盖运行时系统钩子。有关更多信息，请参见官方
    Haskell 用户指南，网址为 [https://www.haskell.org/ghc/docs/7.4.1/html/users_guide/runtime-control.html](https://www.haskell.org/ghc/docs/7.4.1/html/users_guide/runtime-control.html)。
- en: Evaluating a procedure in parallel
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并行评估一个过程
- en: In this recipe, we will conduct two time-consuming tasks in parallel. We will
    use the `rpar` function provided by the `parallel` package from hackage. The `rpar`
    function annotates its argument to be evaluated in parallel. Then, we call `runEval`
    to actually perform the computation.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将并行执行两个耗时的任务。我们将使用来自 hackage 的 `parallel` 包中的 `rpar` 函数。`rpar` 函数将其参数标注为并行执行。然后，我们调用
    `runEval` 来实际执行计算。
- en: Getting ready
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Install the `parallel` package using cabal as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 cabal 安装 `parallel` 包，如下所示：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How to do it…
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现……
- en: 'Import the parallel package as follows:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式导入 parallel 包：
- en: '[PRE2]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Evaluate two tasks in parallel, and wait for both tasks to finish before returning
    as seen in the following code snippet:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下代码片段所示，评估两个任务并行执行，并在两个任务都完成后再返回结果：
- en: '[PRE3]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'A time-consuming task can be created as follows:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以按如下方式创建一个耗时任务：
- en: '[PRE4]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Another time-consuming task can be created as follows:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一个耗时任务可以按如下方式创建：
- en: '[PRE5]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Compile the code with the `threaded` and `rtsopts` flags enabled, as follows:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式编译代码，启用 `threaded` 和 `rtsopts` 标志：
- en: '[PRE6]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Run it by specifying the number of cores:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过指定核心数来运行它：
- en: '[PRE7]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Tip
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The time-consuming calculations (`task1` and `task2`) in this recipe require
    a huge amount of memory and may exceed the limitations of the machine in use.
    Adjust the tasks to be more manageable, such as 4^8^9 or 4^8^8\. In this recipe,
    specifically, the overhead cost of parallelizing these simple mathematical calculations
    may be greater than the benefits.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 本配方中的耗时计算（`task1` 和 `task2`）需要大量内存，可能会超出正在使用的机器的限制。可以调整任务以使其更易于管理，例如 4^8^9 或
    4^8^8。特别是，本配方中，将这些简单的数学计算并行化所带来的开销可能大于其带来的收益。
- en: How it works…
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: Time-consuming functions are annotated with `rpar`, which suggests that the
    computation should occur in parallel. Once `runEval` is applied, the sparked code
    runs in parallel. Future parts of the code can continue with the execution until
    the output of these parallel-running threads are needed.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 耗时函数通过 `rpar` 标注，表示计算应当并行进行。一旦应用了 `runEval`，所触发的代码便会并行运行。代码的其他部分可以继续执行，直到这些并行运行的线程的输出被需要。
- en: In our recipe, we run `task1` and `task2` in parallel. We immediately return
    the result to be used in future parts of the code, and the code only waits for
    the tasks to complete once necessary. The computation is being processed in the
    background until it is needed later.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的配方中，我们并行执行 `task1` 和 `task2`。我们立即返回结果，以便在代码的未来部分使用，并且代码只在必要时等待任务完成。计算在后台进行，直到稍后需要时才会被处理。
- en: See also
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参见
- en: To explore examples of using a sequence in a parallel design, refer to the *Controlling
    parallel algorithms in sequence* recipe.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 要探索在并行设计中使用序列的示例，请参阅 *在序列中控制并行算法* 配方。
- en: Controlling parallel algorithms in sequence
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在序列中控制并行算法
- en: In this recipe, we will conduct two time-consuming tasks in parallel. We will
    use the `rpar` function and the `rseq` function provided by the `parallel` package
    from hackage. The `rpar` function annotates its argument to be evaluated in parallel.
    The other function, `rseq`, forces sequential evaluations in what is called the
    **weak head normal form**.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将并行执行两个耗时的任务。我们将使用`parallel`包中提供的`rpar`函数和`rseq`函数。`rpar`函数将其参数标记为并行计算。另一个函数`rseq`则强制按**弱头正常形式**进行顺序计算。
- en: Getting ready
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'Install the `parallel` package using cabal as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令通过cabal安装`parallel`包：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: How to do it…
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Import the parallel package as follows:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式导入并使用并行包：
- en: '[PRE9]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Perform a time-consuming task as follows:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式执行一个耗时任务：
- en: '[PRE10]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Perform another time-consuming task as follows:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式执行另一个耗时任务：
- en: '[PRE11]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Compile the code with the `threaded` and `rtsopts` flags enabled as follows:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令编译代码，并启用`threaded`和`rtsopts`标志：
- en: '[PRE12]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Run it by specifying the number of cores as follows:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式通过指定核心数来运行它：
- en: '[PRE13]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: How it works…
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Time-consuming functions are annotated with `rpar` or `rseq`, which describe
    whether a computation should happen in parallel or in a sequence. If a function
    is sparked to be run in parallel, then future parts of the code can be made to
    run until that value is needed. In that case, the code blocks until the parallel
    operation is complete. If a function is required to be in sequence, the code will
    wait until the function has computed a result, and only then will it move on.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 耗时函数通过`rpar`或`rseq`进行标注，分别描述计算是否应并行执行或按顺序执行。如果一个函数被启动为并行执行，那么在该值被需要之前，后续代码部分可以继续执行。在这种情况下，代码会被阻塞，直到并行操作完成。如果需要按顺序执行函数，代码会等待该函数计算出结果，只有在此之后才会继续执行。
- en: In our recipe, we run `task1` and `task2` in parallel. We then run `rseq` on
    the values to demonstrate the concept of sequencing. The first time we call `rseq`,
    we are forcing the code to wait until `task1`, which is represented by the variable
    `a`, is complete. Depending on the parallel design of the algorithm, it may not
    be necessary to sequence it at all. We also force `task2`, which is represented
    by the variable `b`, to wait until the value is calculated just to demonstrate
    how sequencing works.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的食谱中，我们并行运行`task1`和`task2`。然后，我们对这些值运行`rseq`，以演示顺序的概念。第一次调用`rseq`时，我们强制代码等待`task1`（由变量`a`表示）完成。根据算法的并行设计，可能根本不需要强制顺序计算。我们还强制`task2`（由变量`b`表示）等待计算完成，以此来展示顺序是如何工作的。
- en: See also
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参见
- en: To see an example of only parallel design without sequencing, refer to the *Evaluating
    a procedure in parallel* recipe.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 若要查看仅并行设计而没有顺序控制的示例，请参见*并行评估过程*食谱。
- en: Forking I/O actions for concurrency
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为了并发执行，进行I/O操作的分叉
- en: A quick and easy way to launch an I/O type function in the background is by
    calling the `forkIO` function provided by the `Control.Concurrent` package. In
    this recipe, we will demonstrate simple input/output concurrently in Haskell.
    We will get the number of seconds to wait from the user input, and in the background,
    it will sleep and print a message once the thread wakes up.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 一种快速且简单的方法是通过调用`Control.Concurrent`包中的`forkIO`函数将I/O类型函数在后台启动。在本食谱中，我们将展示在Haskell中如何并发地处理简单的输入/输出。我们将从用户输入中获取等待的秒数，然后在后台使其休眠，等线程醒来后打印一条消息。
- en: How to do it…
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Import the built-in concurrency package as follows:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式导入内建的并发包：
- en: '[PRE14]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Ask the user the number of seconds the program has to sleep for. Then, sleep
    for that many seconds by calling our `sleep` function defined in the following
    code snippet. Finally, recursively call `main` again to demonstrate that the user
    can continue to input while a thread is running in the background:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提示用户程序需要休眠的秒数。然后，通过调用我们在以下代码片段中定义的`sleep`函数，使程序睡眠相应的秒数。最后，递归地再次调用`main`，以演示用户可以在后台线程运行的同时继续输入：
- en: '[PRE15]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Define a function that takes in the number of seconds to sleep, and apply `threadDelay
    :: Int -> IO ()` to that value as follows:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '定义一个函数，该函数接受要睡眠的秒数，并按如下方式将`threadDelay :: Int -> IO ()`应用于该值：'
- en: '[PRE16]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'When we run the program, we can quickly input multiple numbers before receiving
    an output as follows:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们运行程序时，可以快速输入多个数字，直到收到输出，示例如下：
- en: '[PRE17]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `print` and `putrStrLn` functions are not atomic, so you may also get interleaved
    output.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`print`和`putrStrLn`函数不是原子的，因此您可能会看到输出交错的情况。'
- en: See also
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参见
- en: To send data to a forked action, refer to the *Communicating with a forked I/O
    action* recipe.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要向派生的操作发送数据，请参考*与派生的I/O操作进行通信*的配方。
- en: Communicating with a forked I/O action
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与派生的I/O操作进行通信
- en: A quick and easy way to launch an I/O type function in the background is by
    calling the `forkIO` function provided by the `Control.Concurrent` package. In
    this recipe, we will be communicating with forked I/O actions by sending messages
    using a variable type called `MVar`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 启动一个I/O类型的后台函数的快速简便方法是调用`Control.Concurrent`包提供的`forkIO`函数。在本配方中，我们将通过使用一种称为`MVar`的变量类型发送消息来与派生的I/O操作进行通信。
- en: Getting ready
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'Install the `HTTP` package from cabal as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 按如下方式从cabal安装`HTTP`包：
- en: '[PRE18]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: How to do it…
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作……
- en: 'Import the relevant packages as follows:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式导入相关包：
- en: '[PRE19]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Create a new variable that will be used by the fork process. The `newEmptyMVar`
    function is of the `IO (MVar a)` type, so we will extract the expression out and
    label it `m` as follows:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新变量，将被派生进程使用。`newEmptyMVar`函数的类型为`IO (MVar a)`，所以我们将表达式提取并标记为`m`，如下所示：
- en: '[PRE20]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'After running the fork, send it some data by calling `putMVar :: MVar a ->
    a -> IO ()`, as shown in the following lines of code. The variable will hold the
    given value, and the forked process waiting on that data will resume:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在运行派生进程后，通过调用`putMVar :: MVar a -> a -> IO ()`向其发送数据，如下代码所示。该变量将保存给定的值，派生的进程等待该数据并恢复：'
- en: '[PRE21]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We can reuse the expression and send it more data as follows:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以重用表达式并发送更多数据，如下所示：
- en: '[PRE22]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To make sure `main` does not terminate before the forked process is finished,
    we just force `main` to wait for 10 seconds by calling the `threadDelay` function.
    This is for demonstration purposes only, and a complete solution should terminate
    `main` immediately once the fork is complete, as presented in the following code
    snippet:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了确保`main`在派生进程完成之前不会终止，我们通过调用`threadDelay`函数强制`main`等待10秒。这仅用于演示目的，完整的解决方案应该在派生完成后立即终止`main`，如下代码片段所示：
- en: '[PRE23]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Define the code that will be forked to run in parallel as follows:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式定义将并行运行的派生代码：
- en: '[PRE24]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Create a function to perform an HTTP GET request on a URL as follows:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数以对URL执行HTTP GET请求，如下所示：
- en: '[PRE25]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The output of the program will then be as follows:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 程序的输出将如下所示：
- en: '[PRE26]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: See also
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: To see a simpler example of using `forkIO`, refer to the *Forking I/O actions
    for concurrency* recipe.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看使用`forkIO`的更简单示例，请参考*并发中的I/O操作派生*的配方。
- en: Killing forked threads
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 终止派生线程
- en: When we create a new thread, we can keep track of its corresponding thread ID
    to kill it later manually.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建一个新线程时，可以跟踪其对应的线程ID，以便稍后手动终止它。
- en: 'In this recipe, we will be creating a command-line interface for forking new
    processes to download a huge file. A download will be initiated with the `d` command
    followed by a number. So, running `d 1` will launch a thread to download item
    #1.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，我们将创建一个命令行界面，用于派生新进程下载一个巨大文件。通过`d`命令后跟数字可以启动下载。运行`d 1`将启动一个线程以下载项目#1。
- en: 'We will learn how to kill threads while they are still running. Our command
    to kill threads will look like `k 1` in order to kill the downloaded item #1.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将学习如何在线程仍然运行时终止它们。我们的终止线程命令将像`k 1`，以便终止下载的项目#1。
- en: How to do it…
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作……
- en: 'In a new file, which we call `Main.hs`, insert the following code:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个新文件中，我们称之为`Main.hs`，插入以下代码：
- en: 'Import the required packages as follows:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式导入所需的包：
- en: '[PRE27]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Let `main` call the helper `download` function:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让`main`调用辅助的`download`函数：
- en: '[PRE28]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Define a function to take the user queries and appropriately respond as follows:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个函数以接受用户查询并做出适当响应，如下所示：
- en: '[PRE29]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Respond to a download request:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 响应下载请求：
- en: '[PRE30]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Respond to a kill request:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 响应终止请求：
- en: '[PRE31]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Respond to an invalid request:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 响应无效请求：
- en: '[PRE32]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Pretend to download a huge file as follows:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假装下载一个巨大文件，如下所示：
- en: '[PRE33]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Run the code and evoke a couple of downloads and kill commands as follows:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并按如下方式调用几个下载和终止命令：
- en: '[PRE34]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: How it works...
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: The program keeps track of a mapping from the download number to thread IDs.
    Whenever a new download is initiated, we insert the corresponding thread ID to
    the map. To kill a thread, we call `killThread` on the respective thread ID.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 程序跟踪从下载编号到线程ID的映射。每当启动一个新的下载时，我们会将相应的线程ID插入映射中。要终止一个线程，我们调用`killThread`对相应的线程ID进行操作。
- en: Parallelizing pure functions using the Par monad
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Par单子并行化纯函数
- en: The Par monad from the `Control.Monad.Par` package is used to speed up pure
    functions using parallel threads. Information flow is guided by variables called
    `IVar`. We can `put` values to `IVar` in parallel or `get` values from it.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Control.Monad.Par`包中的Par monad来加速使用并行线程的纯函数。信息流由称为`IVar`的变量引导。我们可以并行`put`值到`IVar`或者从中`get`值。
- en: Getting ready
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备好
- en: 'Install the Par monad on cabal as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在cabal上安装Par monad如下：
- en: '[PRE35]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: How to do it…
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 怎么做…
- en: 'Import the Par monad as follows:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入Par monad如下：
- en: '[PRE36]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Run a computation in parallel, and perform some interesting function such as
    counting the number of digits and printing it out.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 并行运行计算，并执行一些有趣的功能，如计算数字的数量并打印输出。
- en: '[PRE37]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Define an I/O type action as follows:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义I/O类型动作如下：
- en: '[PRE38]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Perform a time-consuming task as follows:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行一个耗时任务，如下所示：
- en: '[PRE39]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Perform another time-consuming task as follows:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行另一个耗时任务如下：
- en: '[PRE40]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Compile the code with the `threaded` and `rtsopts` flags enabled, using the
    following command:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令启用`threaded`和`rtsopts`标志编译代码：
- en: '[PRE41]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Run it by specifying the number of cores as follows:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过以下方式指定核心数来运行它：
- en: '[PRE42]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: There's more…
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'The natural nonparallelized version of the code certainly looks cleaner. In
    the following example, we see the same principle at work mathematically as the
    previous example but without the use of monads. However, we no longer have the
    power of concurrency:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的自然非并行化版本确实看起来更清洁。在以下示例中，我们看到与前一个示例中数学上的相同原理，但没有单子的使用。然而，我们不再具有并发的能力：
- en: '[PRE43]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: See also
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: For dealing with computations that use I/O, refer to the *Forking I/O actions
    for concurrency* recipe.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 处理使用I/O的计算，请参阅*并发执行I/O操作*配方。
- en: Mapping over a list in parallel
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在并行中映射列表
- en: In this recipe, we will be applying the map function in parallel. Given a list
    of values, we will be using multiple threads to apply a function over each value.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在此配方中，我们将并行应用map函数。给定一组值，我们将使用多个线程在每个值上应用函数。
- en: How to do it…
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 怎么做…
- en: 'Import the parallel strategies as follows:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入并行策略如下：
- en: '[PRE44]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Map over a list using the `rdeepseq` strategy using the following code snippet:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码片段使用`rdeepseq`策略映射列表：
- en: '[PRE45]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The first few characters of the printed output are shown here after compiling
    and running the code as follows:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译并运行代码后，在此处显示打印输出的前几个字符：
- en: 'Compile the code with the `threaded` and `rtsopts` flags enabled as follows:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令启用`threaded`和`rtsopts`标志编译代码：
- en: '[PRE46]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Run the code by specifying the number of cores as follows:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过以下方式指定核心数来运行代码：
- en: '[PRE47]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: How it works…
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它的工作原理…
- en: The `parMap` function has the type `Strategy b -> (a -> b) -> [a] -> [b]`. It
    looks exactly like the type signature of the map function, except that it takes
    in something called Strategy. A **Strategy** decouples the method of parallelism
    from the implementation of code. An example of a Strategy is `rdeepseq`, which
    fully evaluates its argument. For example, Haskell is lazy evaluated, so the code
    `length [5^5^5, 6^6^6]` will not evaluate the value of `5^5^5` or `6^6^6`. We
    can use the `rdeepseq` example to better control what computations should be evaluated
    when run in parallel.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`parMap`函数的类型为`Strategy b -> (a -> b) -> [a] -> [b]`。它看起来与map函数的类型签名完全相同，只是接受称为Strategy的东西。**Strategy**将并行方法与代码实现分离。Strategy的一个示例是`rdeepseq`，它完全评估其参数。例如，Haskell是惰性评估的，所以代码`length
    [5^5^5, 6^6^6]`不会评估`5^5^5`或`6^6^6`的值。我们可以使用`rdeepseq`示例更好地控制在并行运行时应评估哪些计算。'
- en: 'In contrast, a slow and simple version of the code is shown as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，代码的缓慢且简单版本如下所示：
- en: '[PRE48]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Try timing the runtime to see the significant differences in using multiple
    threads.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试计时运行时间，以查看使用多线程时的显著差异。
- en: There's more…
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'There are many Strategies depending on how the parallelism should be evoked,
    which are as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 根据应该调用并行性的方式有许多策略，如下所示：
- en: '`r0` is the simplest Strategy that simply does not evaluate the expression'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`r0`是最简单的策略，只是不评估表达式'
- en: '`dot` is used to compose two Strategies together for finer control in more
    complicated expressions'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dot`用于组合两个策略，以便在更复杂的表达式中进行更精细的控制'
- en: '`rseq` will immediately evaluate the expression'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rseq`将立即评估表达式'
- en: '`rpar` will annotate the expression to be evaluated in parallel'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rpar` 将注释要并行评估的表达式'
- en: See also
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: If dealing with tuples, refer to the *Accessing tuple elements in parallel*
    recipe
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果处理元组，请参阅*并行访问元组元素*配方
- en: For more details on timing code, refer to the *Benchmarking runtime performance
    in Haskell* recipe or the *Benchmarking runtime performance in the terminal* recipe
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关时间测试代码的更多细节，请参阅 *Haskell 中的运行时性能基准测试* 配方或 *终端中的运行时性能基准测试* 配方。
- en: Accessing tuple elements in parallel
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并行访问元组元素
- en: In this recipe, we will cover how to access elements of a tuple in parallel.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将介绍如何并行访问元组元素。
- en: How to do it…
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现…
- en: 'Import the built-in package as follows:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下所示，导入内置包：
- en: '[PRE49]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Evaluate the expression in a tuple in parallel. We perform this task twice
    with different strategies to demonstrate how strategies are easily swapped to
    change the parallel nature of the code as follows:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 并行计算元组中的表达式。我们使用不同的策略执行此任务两次，展示如何轻松切换策略以改变代码的并行特性，如下所示：
- en: '[PRE50]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Define time-consuming tasks as follows:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下所示，定义耗时任务：
- en: '[PRE51]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Compile the code with the `threaded` and `rtsopts` flags enabled, as follows:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下所示，使用启用 `threaded` 和 `rtsopts` 标志编译代码：
- en: '[PRE52]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Run it by specifying the number of cores as follows:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下所示，通过指定核心数量来运行：
- en: '[PRE53]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: There's more…
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: When dealing with tuples of more than two elements, other helper methods exist
    such as `parTuple3`, `parTuple4`, `parTuple5`, `parTuple6`, `parTuple7`, `parTuple8`,
    and `parTuple9`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理超过两个元素的元组时，还有其他辅助方法，如 `parTuple3`、`parTuple4`、`parTuple5`、`parTuple6`、`parTuple7`、`parTuple8`
    和 `parTuple9`。
- en: See also
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参见
- en: If dealing with lists, refer to the *Mapping over a list in parallel* recipe.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果处理的是列表，请参阅 *并行映射列表* 配方。
- en: Implementing MapReduce to count word frequencies
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现 MapReduce 以计算单词频率
- en: MapReduce is a framework for efficient parallel algorithms that take advantage
    of divide and conquer. If a task can be split into smaller tasks, and the results
    of each individual task can be combined to form the final answer, then MapReduce
    is likely the best framework for this job.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: MapReduce 是一个高效并行算法框架，利用了分治法。如果一个任务可以被分解成更小的任务，而且每个单独任务的结果可以合并形成最终答案，那么 MapReduce
    很可能是执行此任务的最佳框架。
- en: In the following figure, we can see that a large list is split up, and the mapper
    functions work in parallel on each split. After all the mapping is complete, the
    second phase of the framework kicks in, reducing the various calculations into
    one final answer.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在下图中，我们可以看到一个大的列表被拆分开来，映射函数在每个拆分部分上并行工作。所有映射完成后，框架的第二阶段启动，将各种计算归约为一个最终答案。
- en: In this recipe, we will be counting word frequencies in a large corpus of text.
    Given many files of words, we will apply the MapReduce framework to find the word
    frequencies in parallel.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将统计大量文本中的单词频率。给定多个单词文件，我们将应用 MapReduce 框架并行地找到单词频率。
- en: '![Implementing MapReduce to count word frequencies](img/6331OS_09_01.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![实现 MapReduce 以计算单词频率](img/6331OS_09_01.jpg)'
- en: Getting ready
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Install the `parallel` package using cabal as follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 cabal 安装 `parallel` 包，如下所示：
- en: '[PRE54]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Create multiple files with words. In this recipe, we download a huge text file
    and split it up using the UNIX `split` command as follows:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 创建多个包含单词的文件。在这个配方中，我们下载一个巨大的文本文件并使用 UNIX `split` 命令将其拆分，如下所示：
- en: '[PRE55]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: How to do it…
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现…
- en: 'Import the relevant packages as follows:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下所示，导入相关包：
- en: '[PRE56]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Define the MapReduce logic. The mapping functions should all occur before the
    reducing logic as follows:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义 MapReduce 逻辑。映射函数应都出现在归约逻辑之前，如下所示：
- en: '[PRE57]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Define the `mapper` function to count the frequency of words as follows:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下所示，定义 `mapper` 函数以计算单词频率：
- en: '[PRE58]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Count the number of times a word occurs in a string as follows:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下所示，计算一个字符串中某个单词出现的次数：
- en: '[PRE59]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Get the words out of an arbitrary corpus of characters as follows:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下所示，从任意字符语料库中提取单词：
- en: '[PRE60]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Reduce the list of word frequencies into one final answer as follows:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下所示，将单词频率列表归约为一个最终答案：
- en: '[PRE61]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Set up the MapReduce problem and run it:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置 MapReduce 问题并运行它：
- en: '[PRE62]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Ask to use input, and then display the frequency of each word entered:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请求输入，然后显示每个输入单词的频率：
- en: '[PRE63]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Compile the code with the `threaded` and `rtsopts` flags enabled, as follows:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下所示，使用启用 `threaded` 和 `rtsopts` 标志编译代码：
- en: '[PRE64]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Run it by specifying the number of cores as follows:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下所示，通过指定核心数量来运行：
- en: '[PRE65]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Manipulating images in parallel using Repa
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Repa 并行操作图像
- en: Repa is a powerful library for manipulating high-dimensional arrays in parallel.
    We will use it to read and edit the pixels of an image.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: Repa 是一个强大的库，用于并行处理高维数组。我们将使用它来读取和编辑图像的像素。
- en: Getting ready
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Install **Developer''s Image Library** (**DevIL**), a cross-platform image
    manipulation toolkit. It can be downloaded from [http://openil.sourceforge.net/download.php](http://openil.sourceforge.net/download.php)
    or through `apt-get` on Debian systems as follows:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 安装**开发者图像库**（**DevIL**），这是一个跨平台的图像处理工具包。可以从[http://openil.sourceforge.net/download.php](http://openil.sourceforge.net/download.php)下载，或者通过在Debian系统上使用`apt-get`命令安装，具体如下：
- en: '[PRE66]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Install the Repa package from cabal for the DevIL toolkit as follows:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 从cabal安装Repa包，用于DevIL工具包，如下所示：
- en: '[PRE67]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Create two images named `image1.png` and `image2.png` that have the same dimensions,
    which are shown as follows:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 创建两个名为`image1.png`和`image2.png`的图像，它们具有相同的尺寸，如下所示：
- en: '![Getting ready](img/6331OS_09_02.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![准备中](img/6331OS_09_02.jpg)'
- en: 'Here comes the second image:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是第二张图片：
- en: '![Getting ready](img/6331OS_09_03.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![准备中](img/6331OS_09_03.jpg)'
- en: How to do it…
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Import the following libraries as follows:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入以下库，如下所示：
- en: '[PRE68]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Read the images, process them, and produce an output image as follows:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取图像，处理它们，并生成输出图像，具体如下：
- en: '[PRE69]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Create the helper function to process the images as follows:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个辅助函数以处理图像，代码如下：
- en: '[PRE70]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Compile the code with the `threaded` and `rtsopts` flags enabled, as follows:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用启用`threaded`和`rtsopts`标志来编译代码，如下所示：
- en: '[PRE71]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Run it by specifying the number of cores, as follows:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过指定核心数来运行，具体如下：
- en: '[PRE72]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The output is as follows:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '![How to do it…](img/6331OS_09_04.jpg)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作…](img/6331OS_09_04.jpg)'
- en: How it works…
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: The images are read as three-dimensional Repa arrays of pixels, where each pixel
    is represented by a Word8\. The first two dimensions index the images by width
    and height, and the last dimension selects the color channel (red, green, blue,
    or alpha).
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 图像被读取为三维的Repa像素数组，其中每个像素由一个Word8表示。前两个维度按宽度和高度索引图像，最后一个维度选择颜色通道（红色、绿色、蓝色或透明度）。
- en: We run the `zipWith` function provided by Repa to combine two images into one
    with our intersect/merge rule. In order to actually run this process efficiently
    in parallel, we must call the `computeP` function.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们运行由Repa提供的`zipWith`函数，将两张图像合并为一张，使用我们的交集/合并规则。为了实际高效地并行执行该过程，我们必须调用`computeP`函数。
- en: Benchmarking runtime performance in Haskell
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Haskell中基准测试运行时性能
- en: Benchmarking runtime is the process of timing how long it takes for the code
    to run. We can understand whether our parallel or concurrent code is in fact faster
    than the naive implementation by proper benchmarking. This recipe will demonstrate
    how to time code runtime in Haskell.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 基准测试运行时是计时代码运行所需时间的过程。通过适当的基准测试，我们可以理解我们的并行或并发代码是否真的比朴素实现更快。本配方将展示如何在Haskell中计时代码运行时。
- en: How to do it…
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Import the necessary libraries as follows:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入必要的库，如下所示：
- en: '[PRE73]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Create a function to print out the duration of a pure task. Evaluate the pure
    expression a very large number of times (10^6), and then calculate the average
    CPU time it takes to run one pure task. The `getCPUTime` function returns the
    number of picoseconds since the start of the program''s execution, as shown in
    the following code snippet:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数，用于打印纯任务的持续时间。评估纯表达式非常多次（10^6），然后计算执行一个纯任务所需的平均CPU时间。`getCPUTime` 函数返回自程序执行开始以来经过的皮秒数，如下代码片段所示：
- en: '[PRE74]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Test out the timing function as follows:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试定时函数，如下所示：
- en: '[PRE75]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The measurements for conducting a pure task are printed out. Actual measurements
    will differ depending on the state of the machine.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进行纯任务的测量值会被打印出来。实际测量值会根据机器的状态而有所不同。
- en: '[PRE76]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: See also
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: The *Benchmarking runtime performance in the terminal* recipe for producing
    benchmark results outside the Haskell environment.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '*终端中基准测试运行时性能*，用于在Haskell环境之外生成基准测试结果的配方。'
- en: Using the criterion package to measure performance
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`criterion`包来测量性能
- en: For more reliable performance measures, the `criterion` package comes in handy.
    The package description points out a major flaw in using simple procedures to
    time pure code.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得更可靠的性能测量，`criterion`包非常有用。该包的描述指出，使用简单的程序来计时纯代码存在一个重大缺陷。
- en: '*"Because GHC optimizes aggressively when compiling with -O, it is potentially
    easy to write innocent-looking benchmark code that will only be evaluated once,
    for which all but the first iteration of the timing loop will be timing the cost
    of doing nothing."*'
  id: totrans-283
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"因为GHC在使用-O进行编译时会进行激进优化，因此很容易编写看似无害的基准代码，这些代码只会被评估一次，导致除第一次外的所有定时循环都在计时‘无事可做’的成本。"*'
- en: Getting ready
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: 'Create a `small.txt` file with a few words. Create a file, `big.txt`, filled
    with text as follows:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个包含几个单词的`small.txt`文件。创建一个文件`big.txt`，并填充如下文本：
- en: '[PRE77]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Install the `criterion` library as follows:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 按如下方式安装`criterion`库：
- en: '[PRE78]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: How to do it…
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做……
- en: 'Import the package as follows:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式导入包：
- en: '[PRE79]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Define the I/O function we wish to time as follows:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义我们希望计时的I/O函数如下：
- en: '[PRE80]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Benchmark the desired function as follows:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下所示基准测试所需的功能：
- en: '[PRE81]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Run the code as follows:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式运行代码：
- en: '[PRE82]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: How it works…
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: 'By calling this library''s `defaultMain` function in `main`, we can leverage
    some very powerful benchmarking features. For instance, try running the following
    command to see a plethora of features supported by criterion:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在`main`中调用该库的`defaultMain`函数，我们可以利用一些非常强大的基准测试功能。例如，尝试运行以下命令，查看criterion支持的众多功能：
- en: '[PRE83]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Benchmarking runtime performance in the terminal
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在终端中基准测试运行时性能
- en: Benchmarking runtime is the process of timing how long it takes the code to
    run. This skill is invaluable since it helps compare performance. By externally
    measuring the runtime as opposed to instrumenting it within the code, we can easily
    proceed without understanding the inner working of the code. If we're on a Unix-like
    system such as Linux or OS X, we can use the `time` command, and on Windows systems,
    we can use `Measure-Command` with PowerShell.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 基准测试运行时是计时代码运行所需时间的过程。这个技能非常宝贵，因为它有助于比较性能。通过在外部测量运行时，而不是在代码内部进行检测，我们可以轻松进行，不必理解代码的内部工作原理。如果我们使用的是类似Unix的系统，如Linux或OS
    X，可以使用`time`命令，而在Windows系统上，我们可以使用PowerShell中的`Measure-Command`。
- en: Getting ready
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: Make sure our machine is either Unix-like (such as Linux or OS X) or Windows.
    Otherwise, we must search online for a way to time execution.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 确保我们的机器是类Unix系统（如Linux或OS X）或Windows。如果不是，我们必须在线搜索计时执行的方法。
- en: How to do it…
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做……
- en: 'On Unix-like systems, there is a built-in `time` command. When running any
    piece of code from the terminal, we can prefix it with `time` as follows:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类Unix系统中，内置了`time`命令。运行任何代码时，我们可以在终端前加上`time`，如下所示：
- en: '[PRE84]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: The argument to this command is run, and the system resource usage is immediately
    summarized. The actual accuracy of the results depends on the machine.
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该命令的参数是run，系统资源使用情况会立即总结。结果的实际准确性取决于机器。
- en: 'On Windows, we can use the `Measure-Command` feature in PowerShell. Open PowerShell,
    go to the correct directory, and execute the following command:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Windows上，我们可以使用PowerShell中的`Measure-Command`功能。打开PowerShell，进入正确的目录，并执行以下命令：
- en: '[PRE85]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'You will see a result with the following format:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将看到以下格式的结果：
- en: '[PRE86]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: See also
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: To time execution within the Haskell code itself, refer to the *Benchmarking
    runtime performance in Haskell* recipe.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Haskell代码内部计时执行，请参考*在Haskell中基准测试运行时性能*的教程。
