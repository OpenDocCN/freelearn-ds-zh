- en: Everything is Connected - GraphX
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一切皆相连 - GraphX
- en: '"Technology made large populations possible; large populations now make technology
    indispensable."'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: “技术使得大规模人口成为可能；而大规模人口现在使得技术变得不可或缺。”
- en: '- Joseph Wood Krutch'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '- Joseph Wood Krutch'
- en: In this chapter, we'll learn how many real-world problems can be modeled (and
    resolved) using graphs. We see that Apache Spark comes with its own graph library,
    and what you learned about RDDs can be used here too (this time as vertex and
    edge RDDs).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将学习如何使用图形模型（并解决）许多现实世界的问题。我们看到Apache Spark有自己的图形库，你在学习RDD时学到的内容在这里也能派上用场（这次作为顶点和边的RDD）。
- en: 'In a nutshell, the following topics will be covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，本章将涵盖以下主题：
- en: A brief introduction to graph theory
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图论简要介绍
- en: GraphX
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GraphX
- en: VertexRDD and EdgeRDD
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: VertexRDD 和 EdgeRDD
- en: Graph operators
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图形操作符
- en: Pregel API
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pregel API
- en: PageRank
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PageRank
- en: A brief introduction to graph theory
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图论简要介绍
- en: To better understand graphs, let's look at Facebook and how you typically use
    Facebook. Every day you use your smart phone to post messages on your friend's
    wall or update your status. Your friends are all posting messages and photos and
    videos of their own.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解图形，让我们来看一下Facebook以及你通常如何使用Facebook。每天你使用智能手机在朋友的墙上发布消息或更新你的状态。你的朋友们也都在发布自己的消息、照片和视频。
- en: You have friends, your friends have friends, who have friends, and so on. Facebook
    has settings that let you make new friends or remove friends from your friend
    list. Facebook also has permissions, which allow granular control on who sees
    what and who can communicate with who.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你有朋友，你的朋友有朋友，他们有朋友，依此类推。Facebook有设置让你可以交新朋友或从朋友列表中删除朋友。Facebook也有权限设置，可以精细控制谁能看到什么，以及谁可以与谁沟通。
- en: Now, when you consider that there are a billion Facebook users, the friends
    and friend's friends list for all users gets quite large and complicated. It is
    hard to even comprehend and manage all the different relationships or friendships.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你考虑到有十亿Facebook用户时，所有用户的朋友和朋友的朋友列表变得非常庞大和复杂。要理解和管理所有不同的关系或友谊是很困难的。
- en: So, if someone wants to find out if you and another person *X* are related at
    all, they can simply start by looking at all your friends and all your friends'
    friends, and so on, and try to get to the person *X*. If person *X* is a friend
    of a friend, then you and person *X* are indirectly connected.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，如果有人想了解你和另一个人*X*是否有任何关系，他们可以简单地从查看你所有的朋友以及你朋友的朋友开始，依此类推，试图找到*X*。如果*X*是朋友的朋友，那么你和*X*是间接连接的。
- en: Search for a celebrity or two in your Facebook account and see if someone is
    a friend of your friend. Maybe you can try to add them as a friend.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的Facebook账户中搜索一两位名人，看看是否有人是你朋友的朋友。也许你可以尝试将他们添加为朋友。
- en: 'We need to build the storage and retrieval of such data about people and their
    friends so as to allow us to answer questions such as:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要构建存储和检索关于人及其朋友的数据，以便让我们能够回答如下问题：
- en: Is X a friend of Y?
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: X是Y的朋友吗？
- en: Are X and Y connected directly or within two steps?
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: X和Y是否直接连接，或者在两步内连接？
- en: How many friends does X have?
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: X有多少个朋友？
- en: We can start by trying out a simple data structure such as an array such that
    every person has an array of friends. So now, it's easy to just take the length
    of the array to answer 3\. We can also just scan the array and quickly answer
    1\. Now, question 2 will need little more work, take the array of friends of *X*
    and for each such friend scan the array of friends.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从尝试一个简单的数据结构开始，比如数组，这样每个人都有一个朋友数组。现在，只需要取数组的长度就能回答问题3。我们还可以直接扫描数组并快速回答问题1。现在，问题2则需要多一点工作，取出*X*的朋友数组，并对每个朋友扫描他们的朋友数组。
- en: 'We have sort of solved the problem by having a specialized data structure as
    shown in the following example where we create a case class `Person` and then
    add friends to build a relationship like this `john` | `ken` | `mary` | `dan`:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过构建一个专门的数据结构（如下面的例子所示），解决了这个问题，在这个例子中，我们创建了一个`Person`的case类，然后通过添加朋友来建立类似于`john`
    | `ken` | `mary` | `dan`的关系。
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If we build out the `Person()` instances for all Facebook users and add the
    friends to the arrays as the preceding code shows, then eventually, we will be
    able to perform lots of the queries on who is a friend and what is the relationship
    between any two persons.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们为所有Facebook用户构建`Person()`实例，并按照前面的代码将朋友添加到数组中，那么最终，我们将能够执行大量关于谁是朋友以及两个人之间关系的查询。
- en: 'The following diagram shows the data structures'' `Person()` instances and
    how they are related to each other logically:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了数据结构中的 `Person()` 实例以及它们之间的逻辑关系：
- en: '![](img/00008.jpeg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00008.jpeg)'
- en: 'If you want to use the preceding graph and just find out **John**''s friends,
    **John**''s friend''s friends and so on so that we can quickly find out direct
    friends, indirect friends (friends level 2), and level 3 (friends'' friends''
    friends), you will see something like the following diagram:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想使用上面的图，仅仅找出**约翰**的朋友，**约翰**朋友的朋友，依此类推，这样我们就可以快速找到直接朋友、间接朋友（朋友的二级关系）、三级朋友（朋友的朋友的朋友），你会看到类似以下的图示：
- en: '![](img/00014.jpeg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00014.jpeg)'
- en: We can easily extend the `Person()` class and provide more and more functionality
    to answer different questions. That is not the point here, what we want to look
    at is the preceding diagram showing `Person` and friends of the `Person` and how
    drawing all the friends of each `Person` yields in a mesh of relationships between
    persons.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松扩展 `Person()` 类并提供更多功能来回答不同的问题。这并不是重点，我们想要关注的是前面那个图示，展示了 `Person` 和 `Person`
    的朋友，以及如何将每个 `Person` 的所有朋友绘制出来，从而形成一个人物之间的关系网。
- en: We now introduce the graph theory, which stems from the field of Mathematics.
    Graph theory defines a graph as a structure made up of vertices, nodes, or points,
    which are connected by edges, arcs, and lines. If you consider a set of `Vertices`
    as `V` and a set of `Edges` as `E`, then a `Graph G` can be defined as an ordered
    pair of `V` and `E`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们引入图论，它源于数学领域。图论将图定义为由顶点、节点或点组成的结构，这些顶点通过边、弧和线连接。如果你将顶点集合视为 `V`，边集合视为 `E`，那么图
    `G` 可以定义为有序对 `V` 和 `E`。
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In our example of the Facebook friends drawing, we can simply consider each
    of the persons as a vertex in the set of vertices and then each link between any
    two persons can be considered as an edge in the set of edges.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们 Facebook 朋友图的例子中，我们可以简单地将每个人视为顶点集合中的一个顶点，然后两个人之间的每一条链接可以视为边集合中的一条边。
- en: 'By this logic, we can list the **Vertices** and **Edges** as shown in the following
    diagram:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这个逻辑，我们可以列出**顶点**和**边**，如下图所示：
- en: '![](img/00016.jpeg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00016.jpeg)'
- en: This depiction as a mathematical graph yields to various methodologies of traversing
    and querying the Graph using mathematical techniques. When the techniques are
    applied to computer science as a way to develop programmatical methods to perform
    the math necessary, the formal approach is, of course, to develop algorithms to
    implement the mathematical rules at a scalable efficient level.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这种作为数学图的描述引出了多种遍历和查询图的数学方法。当这些技术应用于计算机科学，作为开发程序方法来执行必要的数学运算时，正式的做法当然是开发算法，以可扩展、高效的方式实现数学规则。
- en: 'We have already attempted to implement a simple graph-like program using the
    case class `Person`, but this is just the simplest use case, which should make
    it obvious that there are a lot of sophisticated extensions possible, such as
    the following questions to be answered:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经尝试使用案例类 `Person` 实现一个简单的图形程序，但这只是最简单的用例，应该显而易见的是，存在许多复杂的扩展是可能的，比如以下问题需要解答：
- en: What's the best way from X to Y? An example of such a question can be your car
    GPS telling you the best way to go to the grocery store.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 X 到 Y 的最佳路径是什么？一个这样的例子是你的车载 GPS 告诉你去超市的最佳路线。
- en: Recognize the critical edges, which can cause partitions of the graph? An example
    of such a question is to determine the critical links connecting the internet
    services/water pipes/power lines of various cities in the state. A critical edge
    breaks connectivity and produces two subgraphs of well-connected cities, but there
    will not be any communication between the two subgraphs.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何识别关键边，这些边可能导致图的分割？一个这样的例子是确定连接各个城市互联网服务/水管/电力线路的关键链接。关键边会切断连通性，产生两个连接良好的城市子图，但这两个子图之间将无法进行任何通信。
- en: Answering the preceding questions yields to several algorithms such as minimum
    spanning tree, shortest path , page rank, **ALS** (**alternating least squares**),
    and max-cut min-flow algorithms, and so on, which are applicable to a broad set
    of use cases.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 回答上述问题可以得出若干算法，如最小生成树、最短路径、网页排名、**ALS**（**交替最小二乘法**）、最大割最小流算法等，这些算法适用于广泛的使用场景。
- en: The other examples are LinkedIn profiles and connections, Twitter followers,
    Google page rank, airline scheduling, GPS in your car, and so on, where you can
    clearly see a graph of vertices and edges. Using graph algorithms, the graph seen
    earlier in the Facebook, LinkedIn, Google examples can be analyzed using various
    algorithms to yield different business use cases.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 其他示例包括LinkedIn的个人资料和连接、Twitter的粉丝、Google的页面排名、航空公司调度、汽车中的GPS等等，你可以清楚地看到一个包含顶点和边的图。通过使用图算法，可以使用不同的算法来分析Facebook、LinkedIn和Google等示例中看到的图，从而得出不同的商业用例。
- en: 'Shown below are illustration of some real-life use cases of graphs which show
    the use of graphs and graph algorithms in some real-life use cases such as:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些现实生活中图的实际应用示例，展示了图和图算法在一些现实生活中的用例中的应用，例如：
- en: help determine flight routes between airports
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 帮助确定机场之间的航班路线
- en: plan how to layout water pipelines to all the households in the locality
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 规划如何将水管道布局到本地区的所有家庭
- en: make your car GPS to plan the route to drive to the grocery
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让你的汽车GPS规划开车去超市的路线
- en: design how the internet traffic is routed from city to city, state to state
    and country to country
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计如何从一个城市到另一个城市、一个州到另一个州、一个国家到另一个国家的互联网流量路由
- en: '![](img/00018.jpeg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00018.jpeg)'
- en: Let's now start digging deeper into how we can use Spark GraphX.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们深入探讨如何使用Spark GraphX。
- en: GraphX
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GraphX
- en: As shown in the preceding section, we can model many real-life use cases as
    Graphs with a set of vertices and a set of edges linking the vertices. We also
    wrote simple code trying to implement some basic graph operations and queries
    such as, *Is X a friend of Y* ? However, as we explored further, the algorithms
    only get more complicated along with use cases and also the size of graphs is
    much much larger than can be handled on one machine.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一部分所示，我们可以将许多现实生活中的用例建模为一个包含顶点集合和边集合的图，这些边连接着顶点。我们还编写了简单的代码，尝试实现一些基本的图操作和查询，比如，*X是否是Y的朋友*？然而，随着我们进一步探索，算法变得更加复杂，用例也增多，而且图的规模远远大于单台机器能够处理的范围。
- en: It is not possible to fit one billion Facebook users along with all their friendship
    relations into one machine or even a few machines.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 不可能将十亿个Facebook用户及其所有的友谊关系都装入一台机器或甚至几台机器中。
- en: What we need to do is to look beyond the one machine and few machines thrown
    together and rather start considering highly scalable architectures to implement
    the complex graph algorithms, which can handle the volume of data and complex
    interconnections of the data elements. We have already seen an introduction to
    Spark, how Spark solves some challenges of distributed computing and big data
    analytics. We also saw real-time stream processing and Spark SQL along with DataFrames
    and RDDs. Can we also solve the challenges of graph algorithms? The answer to
    this is GraphX, which comes with Apache Spark and just like other libraries, sits
    on top of Spark Core.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的是超越仅仅将一台机器或几台机器拼凑在一起，开始考虑高度可扩展的架构，以实现复杂的图算法，这些算法能够处理数据量和数据元素之间复杂的互联关系。我们已经看到Spark的介绍，Spark如何解决分布式计算和大数据分析中的一些挑战。我们还看到了实时流处理、Spark
    SQL以及DataFrames和RDD。我们能否解决图算法的挑战？答案是GraphX，它随Apache Spark一起提供，就像其他库一样，位于Spark
    Core之上。
- en: GraphX extends the spark RDD by providing a graph abstraction on top of the
    RDD concept. Graphs in GraphX are created using the concept of vertices or nodes
    to represent the objects and edges or links to describe the relation between objects
    and GraphX provides the means to realize many use cases, which suit the graph
    processing paradigm. In this section, we will learn about GraphX, how to create
    vertices, edges, and graphs comprising vertices and edges. We will also write
    code to learn by example some techniques surrounding graph algorithms and processing.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: GraphX通过提供一个基于RDD概念的图抽象，扩展了Spark的RDD。GraphX中的图是通过顶点或节点的概念来表示对象，边或链接用于描述对象之间的关系。GraphX提供了实现许多适合图处理范式的用例的手段。在这一部分，我们将学习GraphX，如何创建顶点、边和包含顶点和边的图。我们还将编写代码，通过示例学习一些与图算法和处理相关的技术。
- en: 'To get started , you will need to import some packages as listed here:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，你需要导入以下列出的几个包：
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The fundamental data structure of GraphX is a graph, which abstractly represents
    a graph with arbitrary objects associated with vertices and edges. The graph provides
    basic operations to access and manipulate the data associated with vertices and
    edges as well as the underlying structure. Like Spark RDDs, the graph is a functional
    data structure in which mutating operations return new graphs. This immutable
    nature of the `Graph` object makes it possible to do large-scale parallel computations
    without the risk of running into synchronization problems.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: GraphX的基本数据结构是图，它抽象地表示一个图，图中的顶点和边与任意对象相关联。图提供了基本操作，用于访问和操作与顶点和边相关联的数据，以及底层结构。与Spark的RDD类似，图是一种函数式数据结构，变更操作会返回新的图。这种`Graph`对象的不可变性使得可以进行大规模的并行计算，而不会面临同步问题。
- en: Concurrent updates or modification of objects is the primary reason for complex
    multithreading programming done in many programs.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的并发更新或修改是许多程序中复杂多线程编程的主要原因。
- en: The graph defines the basic data structure and there is a helper class `GraphOps`,
    which contains additional convenience operations and graph algorithms.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图定义了基本的数据结构，并且有一个辅助类`GraphOps`，其中包含了额外的便利操作和图算法。
- en: 'A graph is defined as follows as a class template with two attributes specifying
    the data type of the two pieces, which make up the graph, namely, the vertices
    and the edges:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图的定义如下，作为一个类模板，其中有两个属性指定构成图的两部分的数据类型，即顶点和边：
- en: '[PRE3]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: A graph consists of vertices and edges as we already discussed. The set of vertices
    is in a special data structure known as `VertexRDD`. Similarly, the set of edges
    is in a special data structure known as `EdgeRDD`. Together the vertices and edges
    form the graph and all the subsequent operations can be done using the two data
    structures.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前讨论的，图由顶点和边组成。顶点集合存储在一个特殊的数据结构中，称为`VertexRDD`。类似地，边集合存储在另一个特殊的数据结构中，称为`EdgeRDD`。顶点和边一起构成了图，所有后续操作都可以使用这两种数据结构进行。
- en: 'So, the declaration of the class `Graph` looks like this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，`Graph`类的声明如下所示：
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now, let's look at the two main components of the `Graph` class, the `VertexRDD`,
    and the `EdgeRDD`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下`Graph`类的两个主要组成部分：`VertexRDD`和`EdgeRDD`。
- en: VertexRDD and EdgeRDD
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: VertexRDD和EdgeRDD
- en: A `VertexRDD` contains the set of vertices or nodes in a special data structure
    and an `EdgeRDD` contains the set of edges or links between the nodes/vertices
    again in a special data structure. Both the `VertexRDD` and the `EdgeRDD` are
    based on RDDs and the `VertexRDD` deals with every single node in the graph while
    the `EdgeRDD` contains all links between all nodes. In this section, we will look
    at how to create `VertexRDD` and `EdgeRDD` and then use these objects in building
    a graph.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`VertexRDD`包含顶点或节点的集合，这些顶点存储在一个特殊的数据结构中；`EdgeRDD`包含节点/顶点之间边或连接的集合，存储在另一个特殊的数据结构中。`VertexRDD`和`EdgeRDD`都基于RDD，`VertexRDD`处理图中的每一个节点，而`EdgeRDD`包含所有节点之间的连接。在本节中，我们将介绍如何创建`VertexRDD`和`EdgeRDD`，并使用这些对象来构建图。'
- en: VertexRDD
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: VertexRDD
- en: As seen earlier, the `VertexRDD` is an RDD containing the vertices and their
    associated attributes. Each element in the RDD represents a vertex or node in
    the graph. In order to maintain the uniqueness of the vertex, we need to have
    a way of assigning a unique ID to each of the vertexes. For this purpose, GraphX
    defines a very important identifier known as `VertexId`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`VertexRDD`是一个包含顶点及其相关属性的RDD。RDD中的每个元素代表图中的一个顶点或节点。为了保持顶点的唯一性，我们需要为每个顶点分配一个唯一的ID。为此，GraphX定义了一个非常重要的标识符，称为`VertexId`。
- en: '`VertexId` is defined as a 64-bit vertex identifier that uniquely identifies
    a vertex within a graph. It does not need to follow any ordering or any constraints
    other than uniqueness.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`VertexId`被定义为一个64位的顶点标识符，它唯一标识图中的一个顶点。它不需要遵循任何排序或约束，唯一性是唯一要求。'
- en: 'The declaration of `VertexId` is as follows as simply an alias for a 64-bit
    `Long` number:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`VertexId`的声明如下，简单地说，它是一个64位`Long`类型数字的别名：'
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `VertexRDD` extends an RDD of a pair of VertexID and vertex attributes represented
    by `RDD[(VertexId, VD)]`. It also ensures that there is only one entry for each
    vertex and by preindexing the entries for fast, efficient joins. Two VertexRDDs
    with the same index can be joined efficiently.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`VertexRDD`扩展了一个包含顶点ID和顶点属性的RDD，表示为`RDD[(VertexId, VD)]`。它还确保每个顶点只有一个条目，并通过预先索引条目来加速高效的连接操作。两个具有相同索引的`VertexRDD`可以高效地进行连接。'
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`VertexRDD` also implements many functions, which provide important functionality
    related to graph operations. Each function typically accepts inputs of vertices
    represented by `VertexRDD`.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`VertexRDD`也实现了许多函数，这些函数提供了与图操作相关的重要功能。每个函数通常接受由`VertexRDD`表示的顶点作为输入。'
- en: 'Let''s load vertices into a `VertexRDD` of users. For this, we shall first
    declare a case class `User` as shown here:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将顶点加载到`VertexRDD`中。为此，我们首先声明一个案例类`User`，如下面所示：
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, using the file `users.txt`, create the `VertexRDD`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用`users.txt`文件创建`VertexRDD`：
- en: '| **VertexID** | **Name** | **Occupation** |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| **VertexID** | **姓名** | **职业** |'
- en: '| 1 | John | Accountant |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| 1 | John | 会计 |'
- en: '| 2 | Mark | Doctor |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| 2 | Mark | 医生 |'
- en: '| 3 | Sam | Lawyer |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| 3 | Sam | 律师 |'
- en: '| 4 | Liz | Doctor |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| 4 | Liz | 医生 |'
- en: '| 5 | Eric | Accountant |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| 5 | Eric | 会计 |'
- en: '| 6 | Beth | Accountant |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| 6 | Beth | 会计 |'
- en: '| 7 | Larry | Engineer |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| 7 | Larry | 工程师 |'
- en: '| 8 | Marry | Cashier |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| 8 | Marry | 收银员 |'
- en: '| 9 | Dan | Doctor |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| 9 | Dan | 医生 |'
- en: '| 10 | Ken | Librarian |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| 10 | Ken | 图书管理员 |'
- en: 'Each line of the file `users.txt` contains **VertexId** , the **Name**, and
    the **Occupation**, so we can use the `String` split function here:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`users.txt`文件的每一行包含**VertexId**、**姓名**和**职业**，所以我们可以在这里使用`String`的分割函数：'
- en: '[PRE8]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: EdgeRDD
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`EdgeRDD`'
- en: The `EdgeRDD` represents the set of Edges between the vertices and is a member
    of the Graph class as seen earlier. `EdgeRDD`, just like `VertexRDD`, extends
    from RDD and takes both Edge attributes and Vertex attributes.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`EdgeRDD`表示顶点之间的边集合，是Graph类的成员，如前所述。`EdgeRDD`与`VertexRDD`一样，都是从RDD扩展而来的，并且可以同时包含边属性和顶点属性。'
- en: '`EdgeRDD[ED, VD]` extends `RDD[Edge[ED]]` by storing the edges in columnar
    format on each partition for performance. It may additionally store the vertex
    attributes associated with each edge to provide the triplet view:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`EdgeRDD[ED, VD]`通过将边存储在每个分区的列格式中来扩展`RDD[Edge[ED]]`，以提高性能。它还可以存储与每条边相关联的顶点属性，从而提供三元组视图：'
- en: '[PRE9]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: EdgeRDD also implements many functions, which provide important functionality
    related to graph operations. Each function typically accepts inputs of edges represented
    by EdgeRDD. Each Edge consists of a source vertexId, destination vertexId and
    edge attributes such as a `String`, `Integer`, or any case class. In the following
    example, we use a `String` friend as the attribute. Later in this chapter, we
    use the distance in miles (`Integer`) as the attribute.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`EdgeRDD`还实现了许多函数，这些函数提供了与图操作相关的重要功能。每个函数通常接受由`EdgeRDD`表示的边作为输入。每条边由源顶点Id、目标顶点Id和边属性（如`String`、`Integer`或任何案例类）组成。在下面的例子中，我们使用`String`类型的朋友作为属性。稍后在本章中，我们将使用以英里为单位的距离（`Integer`）作为属性。'
- en: 'We can create EdgeRDD by reading a file of pairs of vertexIds:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过读取一对顶点Id的文件来创建`EdgeRDD`：
- en: '| **Source Vertex ID** | **Target/Destination Vertex ID** | **Distance in Miles**
    |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| **源顶点ID** | **目标/目的地顶点ID** | **距离（英里）** |'
- en: '| 1 | 3 | 5 |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 3 | 5 |'
- en: '| 3 | 1 | 5 |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 1 | 5 |'
- en: '| 1 | 2 | 1 |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 2 | 1 |'
- en: '| 2 | 1 | 1 |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 1 | 1 |'
- en: '| 4 | 10 | 5 |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 10 | 5 |'
- en: '| 10 | 4 | 5 |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| 10 | 4 | 5 |'
- en: '| 1 | 10 | 5 |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 10 | 5 |'
- en: '| 10 | 1 | 5 |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| 10 | 1 | 5 |'
- en: '| 2 | 7 | 6 |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 7 | 6 |'
- en: '| 7 | 2 | 6 |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 2 | 6 |'
- en: '| 7 | 4 | 3 |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 4 | 3 |'
- en: '| 4 | 7 | 3 |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 7 | 3 |'
- en: '| 2 | 3 | 2 |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 3 | 2 |'
- en: 'Each line of the `friends.txt` file contains the source `vertexId` and destination
    `vertexId`, so we can use the `String` split function here:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`friends.txt`文件的每一行都包含源`vertexId`和目标`vertexId`，因此我们可以在这里使用`String`的分割函数：'
- en: '[PRE10]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We now have vertices and edges, so it is time to put everything together and
    explore how we can build a `Graph` from the lists of vertices and edges:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了顶点和边，接下来是将一切整合在一起，探索如何从顶点和边的列表构建一个`Graph`：
- en: '[PRE11]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Using the `Graph` object, we can look at the vertices and edges using the `collect()`
    function, which will show all vertices and edges. Each vertex is of the form (`VertexId`,
    `User`) and each edge is of the form (`srcVertexId`, `dstVertexId`, `edgeAttribute`).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Graph`对象，我们可以通过`collect()`函数查看顶点和边，`collect()`会显示所有的顶点和边。每个顶点的形式是（`VertexId`，`User`），每条边的形式是（`srcVertexId`，`dstVertexId`，`edgeAttribute`）。
- en: '[PRE12]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now that we have a graph created, we will look at various operations in the
    next section.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了一个图，接下来我们将在下一部分查看各种操作。
- en: Graph operators
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图操作符
- en: Let's start with the operations we can directly perform using `Graph` object,
    such as filtering the vertices and edges of the graph to filter out based on some
    attribute of the object. We will also see an example of `mapValues()`, which can
    transform the graph to yield a custom RDD.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从直接使用`Graph`对象进行的操作开始，例如基于对象的某些属性过滤图中的顶点和边。我们还将看到`mapValues()`的示例，它可以将图转换为自定义的RDD。
- en: First, let's examine the vertices and the edges using the `Graph` object we
    created in the previous section and then look at some graph operators.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们使用我们在前一节创建的`Graph`对象来检查顶点和边，然后看一些图操作符。
- en: '[PRE13]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Filter
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Filter
- en: 'A function call to `filter()` restricts the vertex set to the set of vertices
    satisfying the given predicate. This operation preserves the index for efficient
    joins with the original RDD, and it sets bits in the bitmask rather than allocating
    new memory:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 对`filter()`的函数调用将顶点集限制为满足给定谓词的顶点集。此操作保留索引以便与原始RDD进行高效连接，并且设置位于位掩码中，而不是分配新内存。
- en: '[PRE14]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Using `filter`, we can filter out everything but the vertex for user `Mark`,
    which can be done either using the vertexId or the `User.name` attribute. We can
    also filter for the `User.occupation` attribute.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`filter`，我们可以过滤出除用户`Mark`的顶点之外的所有内容，可以使用顶点ID或`User.name`属性进行过滤。我们还可以过滤`User.occupation`属性。
- en: 'The following is the code to accomplish the same:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是完成相同任务的代码：
- en: '[PRE15]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We can also perform `filter` on the edges too, using either the source vertexId
    or the destination vertexId. So we can filter out the edges to show only the edges,
    which originate from `John` (vertexId = 1):'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以对边执行`filter`操作，使用源顶点ID或目标顶点ID。因此，我们可以过滤出仅显示从`John`（顶点ID = 1）发出的边：
- en: '[PRE16]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: MapValues
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MapValues
- en: '`mapValues()` maps each vertex attribute, preserving the index so as not to
    change the vertexId. Changing the vertexId would have changed the index so much
    that subsequent operations would fail and the vertices will not be reachable anymore.
    Hence, it is important to not change the vertexIds.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`mapValues()`映射每个顶点属性，保留索引以避免改变顶点ID。改变顶点ID会导致索引变化，从而使后续操作失败，并且顶点将不再可达。因此，重要的是不要改变顶点ID。'
- en: 'The declaration of this function is shown here:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数的声明如下所示：
- en: '[PRE17]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`mapValues()` can also operate on the edges and maps the values in an edge
    partitioning preserving the structure but changing the values:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`mapValues()`也可以操作边，对边进行值映射，保留结构但改变值：'
- en: '[PRE18]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The following is the example code invoking `mapValues()` in the vertices and
    edges. MapValues on vertices transforms the vertices to list of pairs of (`vertexId`
    , `User.name`). MapValues on edges transforms the edges to triplets of (`srcId`,
    `dstId`, `string`):'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在顶点和边上调用`mapValues()`的示例代码。在顶点上，MapValues将顶点转换为(`vertexId`, `User.name`)对的列表。在边上，MapValues将边转换为(`srcId`,
    `dstId`, `string`)的三元组：
- en: '[PRE19]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: aggregateMessages
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: aggregateMessages
- en: The core aggregation operation in GraphX is `aggregateMessages`, which applies
    a user-defined `sendMsg` function to each edge triplet in the graph and then uses
    the `mergeMsg` function to aggregate these messages at their destination vertex.
    `aggregateMessages` is used in many graph algorithms, where we have to exchange
    information between vertices.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: GraphX中的核心聚合操作是`aggregateMessages`，它将用户定义的`sendMsg`函数应用于图中每个边三元组，然后使用`mergeMsg`函数在目标顶点处聚合这些消息。`aggregateMessages`在许多图算法中使用，其中我们需要在顶点之间交换信息。
- en: 'The following is the signature for this API:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是此API的签名：
- en: '[PRE20]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The key functions are the `sendMsg` and `mergeMsg`, which determine what gets
    sent either to source vertex or destination vertex of an edge. Then, `mergeMsg`
    processes the messages received from all the Edges and performs a computation
    or aggregation.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 关键函数是`sendMsg`和`mergeMsg`，它们确定发送到边的源顶点或目标顶点的内容。然后，`mergeMsg`处理从所有边接收到的消息，并执行计算或聚合。
- en: 'The following is a simple example of calling `aggregateMessages` on the `Graph`
    graph, where we send a message to all destination vertices. The merge strategy
    at each vertex is to just add all the messages being received:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在`Graph`图上调用`aggregateMessages`的简单示例代码，其中我们向所有目标顶点发送消息。每个顶点的合并策略只是将接收到的所有消息相加：
- en: '[PRE21]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: TriangleCounting
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TriangleCounting
- en: A triangle is created if two neighbors of a vertex are connected by an edge.
    In other words, a user will create a triangle with the two friends who are friends
    with each other.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个顶点的两个邻居通过一条边相连，就会创建一个三角形。换句话说，用户将与那两个互为朋友的朋友创建一个三角形。
- en: Graph has a function `triangleCount()`, which computes the triangles in the
    graph.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Graph有一个函数`triangleCount()`，用于计算图中的三角形。
- en: 'The following is the code used to count the triangles in the graph by first
    invoking the `triangleCount` function and then by joining the triangles with the
    vertices (users) to generate the output of each user and the triangle the user
    belongs to:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是用于通过首先调用 `triangleCount` 函数并将三角形与顶点（用户）连接，以生成每个用户及其所属三角形输出的代码：
- en: '[PRE22]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The diagram of the two triangles we just computed in the preceding code shows
    the two triangles, (**John**, **Mark**, **Sam**) and (**Ken**, **Mary**, **Beth**):'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '我们刚才在前面的代码中计算出的两个三角形的图示显示了两个三角形，(**John**, **Mark**, **Sam**) 和 (**Ken**, **Mary**,
    **Beth**):'
- en: '![](img/00023.jpeg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00023.jpeg)'
- en: Pregel API
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Pregel API
- en: Graphs are inherently recursive data structures as properties of vertices depend
    on properties of their neighbors, which in turn depend on properties of their
    own neighbors. As a consequence, many important graph algorithms iteratively recompute
    the properties of each vertex until a fixed-point condition is reached. A range
    of graph-parallel abstractions have been proposed to express these iterative algorithms.
    GraphX exposes a variant of the Pregel API.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图本质上是递归的数据结构，因为顶点的属性依赖于其邻居的属性，而邻居的属性又依赖于它们自己的邻居的属性。因此，许多重要的图算法需要迭代地重新计算每个顶点的属性，直到达到固定点条件。为了表达这些迭代算法，提出了多种图并行抽象。GraphX
    提供了 Pregel API 的变体。
- en: At a high level, the Pregel operator in GraphX is a bulk-synchronous parallel
    messaging abstraction constrained to the topology of the graph. The Pregel operator
    executes in a series of steps in which vertices receive the sum of their inbound
    messages from the previous super step, compute a new value for the vertex property,
    and then send messages to neighboring vertices in the next super step. Using Pregel,
    messages are computed in parallel as a function of the edge triplet and the message
    computation has access to both the source and destination vertex attributes. Vertices
    that do not receive a message are skipped within a super step. The Pregel operators
    terminate iteration and return the final graph when there are no messages remaining.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 从高层次来看，GraphX 中的 Pregel 运算符是一个批量同步的并行消息抽象，受图的拓扑结构限制。Pregel 运算符在一系列步骤中执行，在这些步骤中，顶点接收来自上一超步的传入消息的总和，计算顶点属性的新值，然后在下一超步中向相邻顶点发送消息。使用
    Pregel 时，消息是并行计算的，作为边三元组的函数，消息计算可以访问源和目标顶点的属性。没有接收到消息的顶点会在超步中跳过。Pregel 运算符在没有剩余消息时终止迭代并返回最终图。
- en: 'Some algorithms which come built-in using Pregel API are as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 一些内置的 Pregel API 算法如下所示：
- en: ConnectedComponents
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连通分量
- en: ShortestPaths
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最短路径
- en: Traveling salesman
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 旅行商问题
- en: PageRank (covered in the next section)
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PageRank（将在下一节介绍）
- en: 'The Pregel API signature is shown in the following code, which shows the various
    arguments needed. The exact usage will be shown in the subsequent sections, so
    you can refer to this signature for clarification:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Pregel API 的签名如下所示，显示了所需的各种参数。确切的用法将在后续章节中展示，您可以参考此签名以获得更多信息：
- en: '[PRE23]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: ConnectedComponents
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连通分量
- en: Connected components are essentially subgraphs within a graph, where the vertices
    are connected to each other in some way. This means that every vertex in the same
    component has an edge to/from some other vertex in the component. Whenever no
    other edge exists to connect a vertex to a component, a new component is created
    with that specific vertex. This continues until all vertices are in some component.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 连通分量本质上是图中的子图，其中顶点通过某种方式相互连接。这意味着同一组件中的每个顶点都与组件中的其他顶点有一条边。当没有其他边将顶点连接到某个组件时，就会创建一个新的组件，该组件包含该特定顶点。这个过程会一直持续，直到所有顶点都属于某个组件。
- en: 'The graph object provides a `connectComponents()` function to compute the connected
    components. This uses the Pregel API underneath to calculate the component a vertex
    belongs to. The following is the code to calculate connected components in the
    graph. Obviously, in this example, we had only one connected component, so it
    shows one as the component number for all users:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图对象提供了一个 `connectComponents()` 函数来计算连通分量。该函数在底层使用 Pregel API 来计算顶点所属的组件。以下是用于计算图中连通分量的代码。显然，在此示例中，我们只有一个连通分量，因此所有用户的组件编号都显示为
    1：
- en: '[PRE24]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Traveling salesman problem
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 旅行商问题
- en: Traveling salesman problem tried to find the shortest path through an undirected
    graph traversing every vertex, for example, user, John, wants to drive to every
    other user minimizing the total distance driven. As the number of vertices and
    edges increase, the number of permutations also increases polynomially to cover
    all the possible paths from vertex to vertex. The time complexity increases polynomially
    to a point that the problem can take a very long time to solve. Rather than solve
    it completely and accurately, an approach known as a **greedy** algorithm is used
    to solve the problem as optimally as possible.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 旅行商问题试图在无向图中找到一条最短路径，遍历每个顶点。例如，用户约翰想要开车到每个其他用户的地方，最小化总驾驶距离。随着顶点和边的数量增加，排列组合的数量也会呈多项式增长，覆盖从顶点到顶点的所有可能路径。时间复杂度也会多项式增长，问题的解决可能需要很长时间。与其完全准确地解决它，更常用的方法是采用**贪心**算法，以尽可能最优的方式解决该问题。
- en: To solve the traveling salesman problem, the greedy approach is to quickly choose
    the shortest edge, knowing that this could be a nonoptimal selection if we traverse
    further depth-wise.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决旅行商问题，贪心算法会快速选择最短的边，尽管我们知道如果继续进一步深度遍历，这可能是一个非最优选择。
- en: 'A diagram of the greedy algorithm on the graph of users and friends is as follows,
    where we see the traversal picking the shortest weighted edge at each vertex.
    Also note that the vertices **Larry** (**7**) and **Liz** (**4**) are never visited:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 贪心算法在用户和朋友图中的示意图如下所示，其中我们看到在每个顶点处选择最短的加权边进行遍历。同时请注意，顶点**拉里**（**7**）和**莉兹**（**4**）从未被访问过：
- en: '![](img/00025.jpeg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00025.jpeg)'
- en: ShortestPaths
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ShortestPaths
- en: 'Shortest paths algorithm finds the path between two vertices by starting at
    the source Vertex and then traversing the edges connecting the vertices to other
    vertices until it reaches the target vertex. The shortest paths algorithm works
    by exchanging messages between various vertices. Also this shortest paths algorithm
    is not directly a part of the `Graph` or `GraphOps` objects, rather must be invoked
    using `lib.ShortestPaths()`:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 最短路径算法通过从源顶点开始，然后遍历连接各顶点的边，直到到达目标顶点，从而找到两顶点之间的路径。该算法通过各顶点之间交换消息来实现。此外，这个最短路径算法并不是`Graph`或`GraphOps`对象的一部分，而必须通过`lib.ShortestPaths()`来调用：
- en: '[PRE25]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '`ShortestPaths` picks the shortest paths in terms of number of hops between
    the two vertices. The following diagram shows three ways **John** can reach **Larry**
    and two of the paths are of length 2 and one of length 3\. From the results of
    the preceding code, it clearly shows that the path chosen from **Larry** to John
    is of length 2.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`ShortestPaths`选择两个顶点之间跳跃次数最少的最短路径。以下图示展示了**约翰**到**拉里**的三种路径，其中两条路径长度为2，一条路径长度为3。从前面代码的结果可以清楚地看到，从**拉里**到约翰选择的路径长度为2。'
- en: 'The same is shown in the output in above code block as a vector containing
    the length of the path and the nodes `(7,(Map(1 -> 2),User(Larry,Engineer)))`:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码块的输出显示了一个包含路径长度和节点的向量`(7,(Map(1 -> 2),User(Larry,Engineer)))`：
- en: '![](img/00031.jpeg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00031.jpeg)'
- en: 'We can also compute the shortest path using weighted edges, which means every
    edge connecting users is not the same. For example, if we can consider the edge
    value/weight/attribute as the distance between where each user lives, we get a
    weighted graph. In this case, the shortest path is calculated by the distance
    between two users in miles:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用加权边计算最短路径，这意味着连接用户的每条边的权重不同。例如，如果我们可以将边的值/权重/属性视为每个用户居住地之间的距离，我们就得到一个加权图。在这种情况下，最短路径是通过计算两个用户之间的距离（以英里为单位）来求得的：
- en: '[PRE26]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The following is a diagram that uses Pregel API to compute the **Single Source
    Shortest Path** from **John** to **Larry** starting from initialization and iteration
    by iteration until we reach the best paths.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个使用Pregel API计算从**约翰**到**拉里**的**单源最短路径**的示意图，计算过程从初始化开始，逐步迭代直到我们到达最佳路径。
- en: 'Initialization of the graph is done by setting the value of vertex representing
    **John** to zero and all other vertices to positive infinity:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图的初始化是通过将代表**约翰**的顶点的值设置为零，所有其他顶点的值设置为正无穷大来完成的：
- en: '![](img/00010.jpeg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00010.jpeg)'
- en: Once the initialization is complete, we will use Pregel for four iterations
    of recomputing the vertex values. In each iteration, we go through all the vertices
    and, at each vertex, check whether there is a better path from a source vertex
    to a destination vertex. If there is such an edge/path, then the vertex value
    is updated.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化完成后，我们将使用 Pregel 进行四次迭代来重新计算顶点值。在每次迭代中，我们遍历所有顶点，并在每个顶点处检查是否存在更好的从源顶点到目标顶点的路径。如果存在这样的边/路径，则更新顶点值。
- en: Let's define two functions *distance(v)* and *distance(s, t)*, where *distance(v)*
    gives the value of a vertex and *distance(s,t)* gives the value of the edge connecting
    *s* to *t*.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义两个函数 *distance(v)* 和 *distance(s, t)*，其中 *distance(v)* 返回一个顶点的值，*distance(s,t)*
    返回连接 *s* 到 *t* 的边的值。
- en: In Iteration 1, every user except John is set to infinity and John is at 0,
    since he is the source vertex. Now, we use Pregel to loop through the vertices
    and check whether there is anything better than infinity. Using Ken as an example,
    we will check if *distance("John") + distance("John", "Ken") < distance("Ken")*.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在迭代 1 中，除约翰外的每个用户都被设置为无限大，约翰的距离为 0，因为他是源顶点。现在，我们使用 Pregel 遍历各个顶点，检查是否有比无限大更好的值。以
    Ken 为例，我们将检查 *distance("John") + distance("John", "Ken") < distance("Ken")*。
- en: This is equivalent to checking whether *0 + 5 < Infinity*, which is `true`;
    so we update Ken's distance to *5*.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当于检查 *0 + 5 < Infinity*，结果是 `true`；所以我们将 Ken 的距离更新为 *5*。
- en: Similarly, we check for Mary, *distance("Ken") + distance("Ken", "Mary") < distance("Mary")*,
    which turns out to be `false`, since at that time Ken is still at infinity. Hence,
    in iteration 1, we could only update the users who are connected to John.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们检查 Mary，*distance("Ken") + distance("Ken", "Mary") < distance("Mary")*，结果是`false`，因为那时
    Ken 仍然是无限远。因此，在迭代 1 中，我们只能更新与约翰连接的用户。
- en: In the next iteration, Mary, Liz, Eric and so on, are all updated since now
    we have updated values for Ken, Mark, and Sam from iteration 1\. This continues
    for a number of iterations specified in the Pregel API call.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一次迭代中，Mary、Liz、Eric 等人都会被更新，因为现在我们已经有了来自迭代 1 中的 Ken、Mark 和 Sam 的更新值。这将继续进行，直到达到
    Pregel API 调用中指定的迭代次数。
- en: 'Shown below are the illustrations of the various iterations when computing
    single source shortest path on the graph:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是计算图中单源最短路径时，各个迭代步骤的示意图：
- en: '![](img/00038.jpeg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00038.jpeg)'
- en: 'The shortest paths from **John** to **Larry** after four iterations shows that
    the shortest path is five miles. The path from **John** to **Larry** can be seen
    if you follow the path **John** | **Mark** | **Sam** | **Larry**:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在经过四次迭代后，从**约翰**到**拉里**的最短路径显示，最短路径为五英里。从**约翰**到**拉里**的路径可以通过以下路径查看：**约翰** |
    **马克** | **萨姆** | **拉里**：
- en: '![](img/00275.jpeg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00275.jpeg)'
- en: PageRank
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PageRank
- en: '**PageRank** is one of the most important algorithms in the graph processing
    space. Originating at Google, the algorithm named after Larry page, the founder
    of Google, has evolved into many types of use cases based on the concept of ranking
    vertices or nodes based on relationships or edges.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '**PageRank** 是图处理领域最重要的算法之一。该算法源于 Google，以 Google 创始人 Larry Page 的名字命名，并且基于通过关系或边缘对顶点或节点进行排名的概念，已经发展出许多不同的应用场景。'
- en: Google PageRank works by counting the number and quality of links to a page
    to determine a rough estimate of how important the website is. The underlying
    assumption is that more important websites are likely to receive more links from
    other websites. For more information, you can read the description at [https://en.wikipedia.org/wiki/PageRank](https://en.wikipedia.org/wiki/PageRank)
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: Google PageRank 通过计算指向页面的链接数量和质量，来大致估算一个网站的重要性。其基本假设是，越重要的网站更可能收到来自其他网站的更多链接。如需了解更多信息，您可以阅读
    [https://en.wikipedia.org/wiki/PageRank](https://en.wikipedia.org/wiki/PageRank)
    上的描述。
- en: Using Google PageRank as an example, you can improve the relative importance
    of a web page on your company website or maybe your blog by promoting the web
    page among other popular websites and technical blogs. Using this approach, your
    blog website may appear in Google search results about some article higher than
    other similar web pages, if there are a lot of third-party websites, which show
    your blog website and the content.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 以 Google PageRank 为例，通过在其他流行网站和技术博客中推广您的网页，您可以提高您公司网站或博客中某个网页的相对重要性。使用这种方法，您的博客网站可能会在
    Google 搜索结果中排名高于其他类似网页，尤其是当有许多第三方网站显示您的博客网站及其内容时。
- en: '**Search Engine Optimization** (**SEO**) is one of the biggest industries in
    the marketing world, where pretty much every website out there is investing into
    this technology. SEO involves various techniques and strategies essentially to
    improve how far up your website appears in any search engine results when anyone
    searches for some relevant words. This is based on Google PageRank-like concept.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '**搜索引擎优化**（**SEO**）是营销领域中最大的行业之一，几乎每个网站都在投资这一技术。SEO 涉及各种技术和策略，主要目的是提高网站在搜索引擎结果中排名的高度，当用户搜索相关词汇时，网站能够排在前面。这基于类似
    Google PageRank 的概念。'
- en: If you consider web pages as nodes/vertices and the hyperlinks between the web
    pages as edges, we essentially created a graph. Now, if you can count the rank
    of a web page as the number of hyperlinks/edges pointed into such as your `myblog.com`
    site having links on `cnn.com` or `msnbc.com` so that a user can click on the
    link and come to your `myblog.com` page. This can be a factor representing the
    importance of the `myblog.com` vertex. If we apply this simple logic recursively,
    we eventually end up with a rank assigned to each vertex calculated using the
    number of incoming edges and PageRank based on the ranks of the source vertices.
    A page that is linked to by many pages with high PageRank receives a high rank
    itself. Let's look at how to solve the PageRank problem at a big data scale using
    Spark GraphX. As we have seen, PageRank measures the importance of each vertex
    in a graph, assuming an edge from **a** to **b** represents the value of **b**
    boosted by **a**. For example, if a Twitter user is followed by many others, the
    user will be ranked highly.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将网页视为节点/顶点，将网页之间的超链接视为边缘，那么我们基本上就创建了一个图。现在，如果你能计算网页的排名，作为指向该网页的超链接/边缘的数量，例如你的
    `myblog.com` 网站上有指向 `cnn.com` 或 `msnbc.com` 的链接，用户可以点击这些链接访问你的 `myblog.com` 页面。这可以作为一个表示
    `myblog.com` 顶点重要性的因子。如果我们递归地应用这个简单的逻辑，最终我们会为每个顶点分配一个排名，该排名是通过计算传入边的数量和基于源顶点排名的
    PageRank 来得到的。一个被许多高 PageRank 网页链接的页面，自己也会获得较高的排名。让我们看看如何使用 Spark GraphX 在大数据规模上解决
    PageRank 问题。正如我们所看到的，PageRank 衡量了图中每个顶点的重要性，假设从 **a** 到 **b** 的边表示 **a** 提升了 **b**
    的值。例如，如果一个 Twitter 用户被许多其他用户关注，那么该用户将被排名较高。
- en: 'GraphX comes with static and dynamic implementations of PageRank as methods
    on the `pageRank` object. Static PageRank runs for a fixed number of iterations,
    while dynamic PageRank runs until the ranks converge. `GraphOps` allows calling
    these algorithms directly as methods on the graph:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: GraphX 提供了静态和动态实现的 PageRank，作为 `pageRank` 对象上的方法。静态 PageRank 运行固定次数的迭代，而动态 PageRank
    会一直运行直到排名收敛。`GraphOps` 允许直接在图上调用这些算法方法：
- en: '[PRE27]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The diagram of the PageRank algorithm on the graph is as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图上的 PageRank 算法示意图如下：
- en: '![](img/00309.jpeg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00309.jpeg)'
- en: Summary
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have introduced graph theory using Facebook as an example;
    Apache Spark's graph processing library GraphX, `VertexRDD`, and EdgeRDDs; graph
    operators, `aggregateMessages`, `TriangleCounting`, and the Pregel API; and use
    cases such as the PageRank algorithm. We have also seen the traveling salesman
    problem and connected components and so on. We have seen how the GraphX API can
    be used to develop graph processing algorithms at scale.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过使用 Facebook 作为示例介绍了图论；Apache Spark 的图处理库 GraphX、`VertexRDD` 和 EdgeRDDs；图操作符
    `aggregateMessages`、`TriangleCounting` 和 Pregel API；以及像 PageRank 算法这样的应用案例。我们还了解了旅行推销员问题和连通分量等内容。我们看到了如何使用
    GraphX API 开发大规模图处理算法。
- en: In [Chapter 11](part0343.html#A73GU1-21aec46d8593429cacea59dbdcd64e1c), *Learning
    Machine Learning - Spark MLlib and ML*, we will explore the exciting world of
    Apache Spark's Machine Learning library.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 11 章](part0343.html#A73GU1-21aec46d8593429cacea59dbdcd64e1c)，*学习机器学习 - Spark
    MLlib 和 ML*，我们将探索 Apache Spark 的机器学习库的精彩世界。
