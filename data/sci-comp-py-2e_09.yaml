- en: Iterating
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代
- en: In this chapter, we will present iterations using loops and iterators. We will
    show examples of how this can be used with lists and generators. Iteration is
    one of the fundamental operations a computer is useful for. Traditionally, iteration
    is achieved with a `for` loop. A `for` loop is a repetition of a block of instructions
    a certain number of times. Inside the loop, you have access to a loop variable,
    in which the iteration number is stored.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将展示使用循环和迭代器进行迭代的示例。我们将展示如何在列表和生成器中使用它们。迭代是计算机的基本操作之一。传统上，通过 `for` 循环实现迭代。`for`
    循环是对一组指令块的重复执行。在循环内部，你可以访问一个循环变量，其中存储了迭代的次数。
- en: A `for` loop in Python is primarily designed to exhaust a list, that is, to
    repeat the same sequence of commands for each element of that list. The effect
    is similar to the repetition effect just described if you use a list containing
    the first [![](img/884f8125-1635-4209-8092-168269add126.png)] integers.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Python 中的 `for` 循环主要设计用于枚举一个列表，也就是对该列表的每个元素重复相同的命令序列。如果你使用包含前 [![](img/884f8125-1635-4209-8092-168269add126.png)]
    个整数的列表，效果类似于刚刚描述的重复效果。
- en: A `for` loop only needs one element of the list at a time. It is therefore desirable
    to use a `for` loop with objects that are able to create those elements on demand,
    one at a time, instead of providing a complete list. This is what iterators achieve
    in Python.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '`for` 循环一次只需要列表的一个元素。因此，最好使用能够按需生成这些元素的对象，而不是提供一个完整列表。这就是Python中迭代器的作用。'
- en: 'The following topics are covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖以下主题：
- en: The for statement
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`for` 语句'
- en: Controlling the flow inside the loop
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制循环内部的流程
- en: Iterable objects
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可迭代对象
- en: List-filling patterns
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 填充列表的模式
- en: When iterators behave as lists
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当迭代器像列表一样工作时
- en: Iterator objects
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代器对象
- en: Infinite iterations
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无限迭代
- en: 9.1 The for statement
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.1 `for` 语句
- en: 'The primary aim of the `for` statement is to traverse a list, that is, to apply
    the same sequence of commands to each element of a given list:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`for` 语句的主要目的是遍历一个列表，也就是对给定列表的每个元素应用相同的一系列命令：'
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this example, the loop variable, `s`, is successively assigned to one element
    of the list. Notice that the loop variable is available after the loop has terminated.
    This may sometimes be useful; see, for instance, the example in [Section 9.2](66c25bba-72d2-46a9-929a-1f57fa7a1684.xhtml):* Controlling
    the flow inside the loop**.*
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，循环变量 `s` 依次赋值为列表的每个元素。请注意，循环结束后仍然可以访问循环变量。有时这可能很有用；例如，参见[第 9.2 节](66c25bba-72d2-46a9-929a-1f57fa7a1684.xhtml)：*控制循环内部的流程*。
- en: 'One of the most frequent uses of a `for` loop is to repeat, that is, to apply
    the same sequence of commands to each element of a given list: a given task a
    defined number of times, using the function `range`, see [Section 1.3.1](cbb0e54a-9e37-4356-8553-6f051956f80e.xhtml): *Lists*.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`for` 循环最常见的用途之一是重复，也就是对给定列表的每个元素应用相同的一系列命令：使用函数 `range`，详见[第 1.3.1 节](cbb0e54a-9e37-4356-8553-6f051956f80e.xhtml)：*列表*。'
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If the purpose of a loop is to go through a list, many languages (including
    Python) offer the following pattern:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果循环的目的是遍历一个列表，许多语言（包括Python）提供了以下模式：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If the purpose of that code were to go through the list `my_list`, the preceding
    code would not make it very clear. For this reason, a better way to express this
    is as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果该代码的目的是遍历列表 `my_list`，那么前面的代码就不是很清晰。因此，更好的表达方式如下：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'It is now clear at first glance that the preceding piece of code goes through
    the list `my_list`. Note that if you really need the index variable [![](img/63a53532-5287-44f2-8eda-69d97e13fc06.png)],
    you may replace the preceding code with this (see also [Section 9.3.3](66c25bba-72d2-46a9-929a-1f57fa7a1684.xhtml):
    *Iterator tools*):'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一眼就能看出前面的代码是在遍历列表 `my_list`。请注意，如果确实需要索引变量 [![](img/63a53532-5287-44f2-8eda-69d97e13fc06.png)]，你可以用这段代码替换前面的代码（另见[第
    9.3.3 节](66c25bba-72d2-46a9-929a-1f57fa7a1684.xhtml)：*迭代器工具*）：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The intent of this piece of code is to go through `my_list` while keeping the
    index variable `k` available. A similar construction for arrays is the command `ndenumerate`:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 此段代码的意图是在遍历 `my_list` 的同时保持索引变量 `k` 可用。对数组而言，类似的构造是使用命令 `ndenumerate`：
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 9.2 Controlling the flow inside the loop
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.2 在循环内部控制流程
- en: Sometimes it is necessary to jump out of the loop or to go directly to the next
    loop iteration. These two operations are performed by the commands `break` and `continue`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 有时需要跳出循环或直接进入下一个循环迭代。这两个操作通过 `break` 和 `continue` 命令来执行。
- en: The keyword `break` is used to terminate the loop before it is completely executed—it
    breaks the loop.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`break` 关键字用于在循环完全执行之前终止循环——它打破了循环。'
- en: 'Two situations can occur in loops with a **`break`** statement:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在包含 **`break`** 语句的循环中可能会发生两种情况：
- en: The loop is completely executed.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 循环被完全执行。
- en: The loop is left when reaching `break` before it was completely executed.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当到达 `break` 时，循环在没有完全执行之前被跳出。
- en: For the first case, special actions can be defined in an `else` block, which
    is executed if the whole list is traversed. This is useful in general if the purpose
    of the `for` loop is to find something and stop. Examples might be searching for
    one element satisfying a certain property inside a list. If such an element is not
    found, the `else` block is executed.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一种情况，可以在 `else` 块中定义特殊操作，当整个列表遍历完毕时执行。如果 `for` 循环的目的是找到某个元素并停止，这在一般情况下很有用。例如，搜索一个满足特定属性的元素。如果没有找到这样的元素，则执行
    `else` 块。
- en: 'Here is a common usage in scientific computing: Quite often, we use an iterating
    algorithm that is not guaranteed to succeed. In that case, it is preferable to
    use a (big) finite loop so that the program does not get caught in an infinite
    loop. The `for`/`else` construct allows such an implementation:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是科学计算中的常见用法：我们经常使用一个不保证成功的迭代算法。在这种情况下，最好使用一个（大）有限循环，以防程序陷入无限循环。`for`/`else`
    结构可以实现这种方式：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 9.3 Iterable objects
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.3 可迭代对象
- en: A `for` loop is primarily used to traverse a list, but it picks the elements
    of the list one at a time. In particular, there is no need to store the whole
    list in memory for the loop to work properly. The mechanism that allows `for` loops
    to work without lists is that of iterators.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`for` 循环主要用于遍历一个列表，但它一次处理列表中的一个元素。特别是，循环正常工作时并不需要将整个列表存储在内存中。使 `for` 循环在没有列表的情况下仍能工作的机制就是迭代器。'
- en: 'An iterable object produces objects to be passed to a loop. Such an object
    may be used inside a loop as if it were a list:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可迭代对象会生成要传递给循环的对象。这样的对象可以像列表一样在循环中使用：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The notion of iterable objects thus generalizes the idea of lists.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 可迭代对象的概念从而扩展了列表的思想。
- en: 'The simplest example of an iterable object is given by lists. The produced
    objects are simply the objects stored in the list:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的可迭代对象示例是列表。产生的对象就是存储在列表中的对象：
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: An iterable object need not produce existing objects. The objects may, instead,
    be produced on the fly.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可迭代对象不一定要产生已存在的对象。相反，对象可以在需要时即时产生。
- en: 'A typical iterable is the object returned by the function `range`. This function
    works as if it would generate a list of integers, but instead, the successive
    integers are produced on the fly when they are needed:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的可迭代对象是 `range` 函数返回的对象。这个函数看起来好像会生成一个整数列表，但实际上是按需即时生成连续的整数：
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If you really need a list with all integers between 0 and 100,000,000, then
    it has to be formed explicitly:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你真的需要一个包含从 0 到 100,000,000 之间所有整数的列表，那么必须显式地构造它：
- en: '[PRE10]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Iterable objects have a method called `__iter__`. That's how you can check whether
    a given object in Python is iterable.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 可迭代对象有一个名为 `__iter__` 的方法。这就是你可以检查某个对象是否是可迭代对象的方法。
- en: 'So far, we have met the following datatypes, which are iterable objects:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经遇到以下数据类型，它们是可迭代对象：
- en: '`lists`'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lists`'
- en: '`tuples`'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tuples`'
- en: '`strings`'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`strings`'
- en: '`range` objects'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`range` 对象'
- en: '`dictionaries`'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dictionaries`'
- en: '`arrays`'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`arrays`'
- en: '`enumerate` and `ndenumerate` objects'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`enumerate` 和 `ndenumerate` 对象'
- en: 'By executing the method `__iter__` on an iterable object, an iterator is created.
    This is tacitly done when a `for` loop is invoked. An iterator has a `__next__`
    method, which returns the next element of a sequence:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在可迭代对象上执行 `__iter__` 方法，可以创建一个迭代器。当调用 `for` 循环时，这一操作是默认执行的。迭代器有一个 `__next__`
    方法，用来返回序列中的下一个元素：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 9.3.1 Generators
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.3.1 生成器
- en: 'You can create your own iterator by using the keyword `yield`. For example,
    a generator for odd numbers smaller than ![](img/4348dffe-7c52-4c93-b2ed-4ebcba289e27.png)
    can be defined by:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用 `yield` 关键字创建自己的迭代器。例如，定义一个生成小于 ![](img/4348dffe-7c52-4c93-b2ed-4ebcba289e27.png)
    的奇数的生成器：
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then you can use it as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你可以像这样使用它：
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Or even like this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 甚至像这样：
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 9.3.2 Iterators are disposable
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.3.2 迭代器是一次性的
- en: 'One salient feature of iterators is that they may be used only once. In order
    to use the iterator again, you will have to create a new iterator object. Note
    that an iterable object is able to create new iterators as many times as necessary.
    Let''s examine the case of a list:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器的一个显著特点是它们只能使用一次。为了再次使用迭代器，你必须创建一个新的迭代器对象。请注意，可迭代对象可以根据需要创建新的迭代器。让我们来看一个列表的例子：
- en: '[PRE15]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Each time a generator object is called, it creates a new iterator. Hence, when
    that iterator is exhausted, you have to call the generator again to obtain a new
    iterator:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用生成器对象时，它会创建一个新的迭代器。因此，当该迭代器耗尽时，你必须再次调用生成器以获得新的迭代器：
- en: '[PRE16]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 9.3.3 Iterator tools
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.3.3 迭代器工具
- en: 'Now, we will introduce a couple of iterator tools that often come in very handy:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将介绍几个常用的迭代器工具：
- en: '`enumerate` is used to enumerate another iterator. It produces a new iterator
    that yields pairs (`iteration`, element), where `iteration` stores the index of
    the iteration:'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`enumerate` 用于枚举另一个迭代器。它生成一个新的迭代器，返回一个（`迭代`，元素）对，其中 `迭代` 存储迭代的索引：'
- en: '[PRE17]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`reversed` creates an iterator from a list by going through that list backward.
    Notice that this is different from creating a reversed list:'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reversed` 通过倒序遍历列表来创建迭代器。注意，这与创建一个反转的列表不同：'
- en: '[PRE18]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`itertools.count` is a possibly infinite iterator of integers:'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`itertools.count` 是一个可能无限的整数迭代器：'
- en: '[PRE19]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`intertools.islice` truncates an iterator using the familiar `slicing` syntax;
    see [Section 3.1.1](c4f97b8b-36c4-4db4-9e58-02aac275b257.xhtml): *Slicing*. One
    application is creating a finite iterator from an infinite one:'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`intertools.islice` 使用熟悉的 `slicing` 语法截断迭代器；请参见 [第3.1.1节](c4f97b8b-36c4-4db4-9e58-02aac275b257.xhtml)：*切片*。一个应用是从无限迭代器创建有限迭代器：'
- en: '[PRE20]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'For example, let''s find some odd numbers by combining `islice` with an infinite
    generator. First, we modify the generator for odd numbers so that it becomes an
    infinite generator:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，结合 `islice` 与无限生成器，我们可以找出一些奇数。首先，我们修改奇数生成器，使其成为无限生成器：
- en: '[PRE21]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Then, we use it with `islice` to get a list of some odd numbers:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用 `islice` 获取一些奇数的列表：
- en: '[PRE22]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This command takes from an assumed list of all odd numbers, the one with index
    10 to index 29 in steps of 8.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令从假设的所有奇数列表中提取，从索引 10 到索引 29，以步长 8 递增的数值。
- en: 9.3.4 Generators of recursive sequences
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.3.4 递归序列的生成器
- en: 'Assume that a sequence is given by an induction formula. For instance, consider
    the Fibonacci sequence, defined by the recurrence formula:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 假设某个序列是由归纳公式给定的。例如，考虑斐波那契数列，它由递归公式定义：
- en: '![](img/a432e87d-4a3b-481f-9e74-d3d47460e116.png).'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/a432e87d-4a3b-481f-9e74-d3d47460e116.png)。'
- en: 'This sequence depends on two initial values, namely [![](img/51fb6836-fce2-4b89-9a06-a75e2c6bad68.png)]
    and [![](img/bb815d4b-45f2-4d4a-a045-61875a23df13.png)], although for the standard
    Fibonacci sequence those numbers are taken as 0 and 1 respectively. A nifty way
    of programming the generation of such a sequence is by using generators, as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 该序列依赖于两个初始值，即 [![](img/51fb6836-fce2-4b89-9a06-a75e2c6bad68.png)] 和 [![](img/bb815d4b-45f2-4d4a-a045-61875a23df13.png)]，尽管对于标准斐波那契数列，这两个数分别取值为
    0 和 1。生成这样一个序列的巧妙方法是使用生成器，如下所示：
- en: '[PRE23]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This may then be used, for instance, like this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，可以像这样使用它：
- en: '[PRE24]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 9.3.5 Examples for iterators in mathematics
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.3.5 数学中迭代器的示例
- en: Arithmetic geometric mean
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 算术几何平均数
- en: 'A more elaborate example for a generator is its use for an iteration based
    on iteratively computing arithmetic and geometric means – the so-called **AGM
    iteration,** see [[1]](12bddbb5-edd0-46c6-8f7a-9475aaf01a9d.xhtml):'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更复杂的生成器示例是它在迭代计算算术和几何平均数时的使用——即所谓的 **AGM 迭代法**，参见 [[1]](12bddbb5-edd0-46c6-8f7a-9475aaf01a9d.xhtml)：
- en: '![](img/4a450656-718a-4c79-b8b8-038fd2a7dabf.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4a450656-718a-4c79-b8b8-038fd2a7dabf.png)'
- en: We demonstrate this iteration here in the context of computing elliptic integrals
    for determining the period of a mathematical pendulum.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在计算椭圆积分以确定数学摆的周期时，在这里演示了这个迭代过程。
- en: 'When started with the values ![](img/3f4b7ed9-ab08-4774-8cce-cb9ff9ac209b.png),
    the AGM iteration generates a sequence of numbers with the following (astonishing)
    property:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当开始时使用值 ![](img/3f4b7ed9-ab08-4774-8cce-cb9ff9ac209b.png)，AGM 迭代生成具有以下（惊人）特性的数字序列：
- en: '![](img/33038d29-70ff-42b2-96ed-d194ec4800c7.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](img/33038d29-70ff-42b2-96ed-d194ec4800c7.png)'
- en: 'The integral on the right-hand side is called a complete elliptic integral
    of the first kind. We''ll now proceed to compute this elliptic integral. We use
    a generator to describe the iteration:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 右侧的积分被称为第一类完全椭圆积分。我们现在将继续计算这个椭圆积分。我们使用一个生成器来描述迭代：
- en: '[PRE25]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'As the sequences [![](img/307dffaf-3613-428b-bbaf-de773830e787.png)] converge
    to the same value, the sequence [![](img/f595ec23-48f9-4f3c-9269-6c7e1ad570c2.png)]
    defined by [![](img/0b22114b-d670-41ce-999b-dc4c47cef153.png)] converges to zero—a
    fact that will be used to terminate the iteration in the program to compute the
    elliptic integral:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当序列 [![](img/307dffaf-3613-428b-bbaf-de773830e787.png)] 收敛到相同的值时，序列 [![](img/f595ec23-48f9-4f3c-9269-6c7e1ad570c2.png)]
    由 [![](img/0b22114b-d670-41ce-999b-dc4c47cef153.png)] 定义，并且收敛到零——这一事实将在程序中用于终止迭代以计算椭圆积分：
- en: '[PRE26]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We have to make sure that the algorithm stops. Note that this code fully relies
    on the mathematical statement that the arithmetic-geometric mean iteration converges
    (fast). In practical computing, we have to be careful while applying theoretical
    results, as they might no longer be valid in limited-precision arithmetic. The
    right way to make the preceding code safe is to use `itertools.islice`. The safe
    code is as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须确保算法停止。请注意，这段代码完全依赖于算术几何平均迭代收敛（快速）的数学声明。在实际计算中，我们在应用理论结果时必须小心，因为在有限精度算术中，它们可能不再有效。确保前述代码安全的正确方法是使用
    `itertools.islice`。安全代码如下：
- en: '[PRE27]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'As an application, elliptic integrals may be used to compute the period [![](img/2305b79a-4aba-47f8-9a9f-5a6b6b1f9df4.png)]
    of a pendulum of length [![](img/0f853c58-6445-4d8e-a411-e073c213f108.png)] starting
    at an angle [![](img/1de0db74-1210-4943-896d-5de9701da0bc.png)] using:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 作为应用，椭圆积分可以用来计算长度为 [![](img/0f853c58-6445-4d8e-a411-e073c213f108.png)] 的摆钟的周期
    [![](img/2305b79a-4aba-47f8-9a9f-5a6b6b1f9df4.png)]，该摆钟从角度 [![](img/1de0db74-1210-4943-896d-5de9701da0bc.png)]
    开始，使用以下公式：
- en: '![](img/09a6b1af-cedc-48c1-be1e-093174af6636.png).'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/09a6b1af-cedc-48c1-be1e-093174af6636.png)。'
- en: 'Using this formula, the period of the pendulum is easily obtained, see [[18]](12bddbb5-edd0-46c6-8f7a-9475aaf01a9d.xhtml):'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此公式，摆钟的周期可以轻松得到，见 [[18]](12bddbb5-edd0-46c6-8f7a-9475aaf01a9d.xhtml)：
- en: '[PRE28]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Convergence acceleration
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 收敛加速
- en: We'll give an example of the application of generators for convergence acceleration.
    This presentation closely follows the example given in [[9]](12bddbb5-edd0-46c6-8f7a-9475aaf01a9d.xhtml).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将给出一个生成器加速收敛的应用示例。此演示紧密跟随 [[9]](12bddbb5-edd0-46c6-8f7a-9475aaf01a9d.xhtml)
    中给出的例子。
- en: Note that a generator may take another generator as an input parameter. For
    instance, suppose that we have defined a generator that generates the elements
    of a converging sequence. It is then possible to improve the convergence by an
    acceleration technique due to *Euler* and *Aitken*, often called Aitken's Δ²-method,
    see [[33]](12bddbb5-edd0-46c6-8f7a-9475aaf01a9d.xhtml)*.* It transforms a sequence [![](img/7a713aba-765a-4631-9538-03b54ca291c3.png)]
    into another by defining
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，生成器可以将另一个生成器作为输入参数。例如，假设我们定义了一个生成器来生成一个收敛序列的元素。然后，可以通过加速技术来改善收敛，该技术源于 *欧拉*
    和 *艾特金*，通常称为艾特金的 Δ² 方法，见 [[33]](12bddbb5-edd0-46c6-8f7a-9475aaf01a9d.xhtml)*。*
    它通过定义将序列 [![](img/7a713aba-765a-4631-9538-03b54ca291c3.png)] 转换为另一个序列。
- en: '![](img/d3bc7362-d7f9-48b9-99c7-f8e1e0dd100f.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d3bc7362-d7f9-48b9-99c7-f8e1e0dd100f.png)'
- en: 'Both sequences have the same limit, but the sequence [![](img/f14f54e1-ea9a-485e-bbe3-f139d46526d7.png)] converges
    significantly faster. One possible implementation is as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 两个序列有相同的极限，但序列 [![](img/f14f54e1-ea9a-485e-bbe3-f139d46526d7.png)] 收敛得更快。一种可能的实现如下：
- en: '[PRE29]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As an example, we use the series *![](img/1b9d4037-f4c4-4c8c-a638-aa4362709ad7.png), *which
    converges to ![](img/131e9ae0-b279-4681-8a12-69d0eb6ca6e1.png).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个例子，我们使用序列 *![](img/1b9d4037-f4c4-4c8c-a638-aa4362709ad7.png)*，它收敛于 *![](img/131e9ae0-b279-4681-8a12-69d0eb6ca6e1.png)*。
- en: 'We implement this series as a generator in the following code:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在以下代码中实现这个序列作为生成器：
- en: '[PRE30]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We may now use the accelerated version of that sequence using this:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用加速版本的该序列：
- en: '[PRE31]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Accordingly, the first *N* elements of that accelerated sequence are obtained
    with:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，加速序列的前*N*个元素可以通过以下公式得到：
- en: '[PRE32]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Note, here we stacked three generators: `pi_series`, `Euler_accelerate`, and
    `itertools.islice`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这里我们堆叠了三个生成器：`pi_series`、`Euler_accelerate` 和 `itertools.islice`。
- en: '*Figure 9.1* shows the convergence rate of the log of the error for the standard
    version of the sequence defined by the preceding formula and its accelerated version:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9.1* 显示了使用前述公式定义的标准版本序列及其加速版本的误差对数收敛速度：'
- en: '![](img/f3d3fdf4-b5ce-4e86-9657-ae04d17361f2.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f3d3fdf4-b5ce-4e86-9657-ae04d17361f2.png)'
- en: 'Figure 9.1: Comparison between the sequence and its accelerated version'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.1：序列与其加速版本的比较
- en: 9.4 List-filling patterns
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.4 列表填充模式
- en: In this section, we will compare different ways to fill lists. They are different
    in computational efficiency and also in code readability.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我们将比较不同的列表填充方法。它们在计算效率和代码可读性上有所不同。
- en: 9.4.1 List filling with the append method
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.4.1 使用append方法填充列表
- en: 'A ubiquitous programming pattern is to compute elements and store them in a
    list:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 一个普遍的编程模式是计算元素并将其存储在列表中：
- en: '[PRE33]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This approach has a number of disadvantages:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法有一些缺点：
- en: The number of iterations is decided in advance. If there is a `break` instruction,
    then the preceding code takes care of both generating values and deciding when
    to stop. This is not desirable and lacks flexibility.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代次数是预先决定的。如果有`break`指令，前面的代码会处理生成值和决定何时停止的问题。这是不可取的，并且缺乏灵活性。
- en: It makes the assumption that the user wants the whole history of the computation,
    for all the iterations. Suppose we are only interested in the sum of all the computed
    values. If there are many computed values, it does not make sense to store them,
    as it is much more efficient to add them one at a time.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它假设用户想要计算的整个历史记录，涵盖所有迭代。假设我们只对所有计算值的总和感兴趣。如果有很多计算值，存储它们没有意义，因为逐个相加效率更高。
- en: 9.4.2 List from iterators
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.4.2 来自迭代器的列表
- en: 'Iterators provide us with an elegant solution to problems discussed previously:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器为我们提供了一个优雅的解决方案来解决之前讨论的问题：
- en: '[PRE34]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: With iterators, we separate the task of generating the computed values without
    bothering about the stopping condition or about the storage.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 使用迭代器时，我们将生成计算值的任务与停止条件和存储分开处理。
- en: 'If the user of that code wants to store the [![](img/c8b7f35d-215d-4049-8d4d-564c7bfa755a.png)] first
    values, it is easily done using the `list` constructor:'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果该代码的用户想要存储[![](img/c8b7f35d-215d-4049-8d4d-564c7bfa755a.png)]的第一个值，可以使用`list`构造器轻松完成：
- en: '[PRE35]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'If the user wants the sum of the first *n* generated values, this construction
    is recommended:'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果用户想要前*n*个生成值的总和，推荐使用这种构造：
- en: '[PRE36]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'If the user wants to generate all elements until a certain condition is fulfilled,
    the function `itertools.takewhile` comes in handy:'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果用户希望生成所有元素直到满足某个条件，可以使用函数`itertools.takewhile`：
- en: '[PRE37]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The function `takewhile` takes as a first argument a function that returns a
    Boolean. Its second argument is a generator. The generator is iterated as long
    as the function evaluates to `True`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`takewhile`的第一个参数是一个返回布尔值的函数。第二个参数是一个生成器。只要该函数的返回值为`True`，生成器就会继续迭代。
- en: What we did here was separate the generation of elements on one hand, and store
    those elements on the other.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里做的事情是将元素的生成与元素的存储分开处理。
- en: 'If the purpose is really to build a list, and when the result at each step
    does not depend on previously computed elements, you may use the list comprehension
    syntax (see [Section 3.1.6](c4f97b8b-36c4-4db4-9e58-02aac275b257.xhtml): *List
    Comprehension*):'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果目标确实是构建一个列表，并且每一步的结果不依赖于先前计算的元素，可以使用列表推导语法（参见[第3.1.6节](c4f97b8b-36c4-4db4-9e58-02aac275b257.xhtml)：*列表推导*）：
- en: '[PRE38]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: When iteratively computing values that depend on the previously computed values,
    list comprehensions cannot help.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当迭代计算依赖于先前计算的值时，列表推导无法提供帮助。
- en: 9.4.3 Storing generated values
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.4.3 存储生成的值
- en: Using iterators to fill out lists will work nicely most of the time, but there
    are complications to this pattern when the algorithm computing the new values
    is liable to throw an exception; if the iterator raises an exception along the
    way, the list will not be available! The following example illustrates this problem.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 使用迭代器来填充列表通常能很好地工作，但当计算新值的算法可能抛出异常时，这种模式会有一些复杂性；如果迭代器在过程中抛出异常，列表将无法使用！下面的示例展示了这个问题。
- en: 'Suppose we generate the sequence defined recursively by [![](img/dc077bef-8013-4d4a-ba02-89f971e6ea90.png)].
    This sequence quickly diverges to infinity if the initial data [![](img/f660ed0a-4dcc-4c12-beb2-af8ae2327ab3.png)] is
    greater than one. Let''s generate it with a generator:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们生成了由[![](img/dc077bef-8013-4d4a-ba02-89f971e6ea90.png)]定义的递归序列。如果初始数据[![](img/f660ed0a-4dcc-4c12-beb2-af8ae2327ab3.png)]大于1，这个序列会迅速发散到无穷大。让我们用生成器来生成它：
- en: '[PRE39]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'If you try to obtain the first *20* elements of the sequence (initialized by
    [![](img/83467fe6-ed62-4c7a-82f5-b2866a8021c2.png)]) by executing:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试通过执行以下操作来获取序列的前*20*个元素（由[![](img/83467fe6-ed62-4c7a-82f5-b2866a8021c2.png)]初始化）：
- en: '[PRE40]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'An `OverflowError` exception will be raised and no list will be available,
    not even the list of elements before the exception was raised. There is currently
    no way to obtain a partially filled list from a possibly faulty generator. The
    only way around this is to use the method `append` wrapped in an exception-catching
    block (see [Section 12.1](9bd2d3f3-b846-4421-931c-7ebfbdc8fbea.xhtml): *What are
    exceptions?*, for more details):'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发生`OverflowError`异常，将会抛出异常，并且无法获取任何列表，甚至不能获取异常抛出之前的元素列表。目前没有方法从可能有问题的生成器中获取部分填充的列表。唯一的解决办法是使用`append`方法，并将其包装在一个捕获异常的代码块中（参见[第12.1节](9bd2d3f3-b846-4421-931c-7ebfbdc8fbea.xhtml)：*什么是异常？*，获取更多细节）：
- en: '[PRE41]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 9.5 When iterators behave as lists
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.5 当迭代器表现得像列表一样
- en: 'Some list operations also work on iterators. We will now examine the equivalents
    of *list comprehensions* and *list zipping* (see [Section 3.1.6](c4f97b8b-36c4-4db4-9e58-02aac275b257.xhtml):
    *List Comprehension*, and [Section 3.1.5](c4f97b8b-36c4-4db4-9e58-02aac275b257.xhtml):
    *Merging Lists*).'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 一些列表操作也可以在迭代器上使用。我们现在将探讨*列表推导*和*列表合并*的等效操作（参见[第3.1.6节](c4f97b8b-36c4-4db4-9e58-02aac275b257.xhtml)：*列表推导*，以及[第3.1.5节](c4f97b8b-36c4-4db4-9e58-02aac275b257.xhtml)：*合并列表*）。
- en: 9.5.1 Generator expressions
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.5.1 生成器表达式
- en: 'There is an equivalent of list comprehension for generators. Such a construction
    is called a generator expression:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器有一个等效于列表推导的方式。这样的构造被称为生成器表达式：
- en: '[PRE42]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This is useful in particular for computing sums or products because those operations
    are incremental; they only need one element at a time:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于计算和积累求和或求积特别有用，因为这些操作是递增的；它们每次只需要一个元素：
- en: '[PRE43]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In that code, you notice that the `sum` function is given one argument, which
    is a generator expression. Note that Python syntax allows us to omit the enclosing
    parentheses of generators when a generator is used as the *only* argument of a
    function.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，你会注意到`sum`函数只接收了一个参数，这个参数是一个生成器表达式。请注意，Python语法允许我们省略生成器外部的圆括号，当生成器作为函数的*唯一*参数时。
- en: Let's compute the Riemann zeta function [![](img/e733c4da-13fa-4f7d-9d9f-a04d2b99d8b6.png)],
    whose expression is
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们计算黎曼zeta函数[![](img/e733c4da-13fa-4f7d-9d9f-a04d2b99d8b6.png)]，其表达式为
- en: '![](img/bbfb420f-4add-41a5-b7d7-2aaac00e3234.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bbfb420f-4add-41a5-b7d7-2aaac00e3234.png)'
- en: 'With a generator expression, we may compute a partial sum of this series in
    one line:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 使用生成器表达式，我们可以在一行中计算该序列的部分和：
- en: '[PRE44]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Note that we could also have defined a generator of the sequence [![](img/49cf6b79-a417-44e4-8edf-604afaef358d.png)] as
    follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们也可以像下面这样定义序列[![](img/49cf6b79-a417-44e4-8edf-604afaef358d.png)]的生成器：
- en: '[PRE45]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Then we simply obtain the sum of the first *N* terms using:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们简单地通过以下方法获得前*N*项的和：
- en: '[PRE46]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: We point out that we used this way of computing the zeta (![](img/4e60ab18-0e48-49d9-9e83-1d599478085e.png))
    function as a demonstration of the use of generators in an elegant way. It is
    certainly not the most accurate and computationally efficient way to evaluate
    this function.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们指出，我们使用这种方式计算zeta函数（![](img/4e60ab18-0e48-49d9-9e83-1d599478085e.png)）是为了演示生成器的优雅使用方式。它肯定不是评估该函数最准确和计算效率最高的方式。
- en: 9.5.2 Zipping iterators
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.5.2 迭代器合并
- en: 'We saw in [Section 3.1.5](c4f97b8b-36c4-4db4-9e58-02aac275b257.xhtml): *Merging
    Lists* that it is possible to create a list out of two or more lists by zipping
    them together. The same operation exists for iterators:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第3.1.5节](c4f97b8b-36c4-4db4-9e58-02aac275b257.xhtml)：*合并列表*中看到，确实可以通过将两个或更多列表合并来创建一个新的列表。对迭代器来说，也有类似的操作：
- en: '[PRE47]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The zipped iterator stops as soon as one of the iterators is exhausted. This
    is the same behavior as the operation zip on lists.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦其中一个迭代器耗尽，合并的迭代器就会停止。这与列表上的zip操作行为相同。
- en: 9.6 Iterator objects
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.6 迭代器对象
- en: 'As we mentioned earlier, a `for` loop only needs an iterable object. Lists,
    in particular, are iterable objects. This means that a list is able to create
    an iterator from its contents. In fact, this is true for any object (not only
    lists): any object may be made iterable.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，`for`循环只需要一个可迭代对象。特别地，列表是可迭代对象。这意味着列表能够从其内容创建一个迭代器。事实上，这对任何对象（不仅仅是列表）都成立：任何对象都可以是可迭代的。
- en: 'This is achieved via the method `__iter__`, which should return an iterator.
    Here we give an example where the method `__iter__` is a generator:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过`__iter__`方法实现的，该方法应该返回一个迭代器。这里我们给出一个例子，其中`__iter__`方法是一个生成器：
- en: '[PRE48]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'If you try to use the features of an iterator with an object that is not iterable,
    an exception will be raised:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试使用迭代器的功能处理一个不可迭代的对象，将会引发异常：
- en: '[PRE49]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'In this example, the function list tries to iterate through object *3* by calling
    the method `__iter__`. But this method is not implemented for integers and thus
    the exception is raised. The same would happen if we tried to cycle through a
    non-iterable object:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，函数 list 尝试通过调用方法 `__iter__` 遍历对象 *3*。但是这个方法并没有为整数实现，因此引发了异常。如果我们尝试遍历一个不可迭代的对象，也会发生相同的情况：
- en: '[PRE50]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 9.7 Infinite iterations
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.7 无限迭代
- en: Infinite iterations are obtained either with an infinite iterator, with a `while` loop,
    or by recursion. Obviously, in practical cases, some condition stops the iteration.
    The difference with finite iterations is that it is impossible to say from a cursory
    examination of the code whether the iteration will stop or not.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 无限迭代通过无限迭代器、`while` 循环或递归得到。显然，在实际情况下，某些条件会停止迭代。与有限迭代的不同之处在于，无法通过粗略查看代码判断迭代是否会停止。
- en: 9.7.1 The while loop
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.7.1 while 循环
- en: 'The `while` loop may be used to repeat a code block until a condition is fulfilled:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`while` 循环可用于重复执行代码块，直到满足某个条件：'
- en: '[PRE51]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'A `while` loop is equivalent to the following code:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`while` 循环等价于以下代码：'
- en: '[PRE52]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'So a `while` loop used to repeat a code block until a condition is fulfilled
    is equivalent to an infinite iterator, which might be stopped if a condition is
    fulfilled. The danger of such a construction is obvious: the code may be trapped
    in an infinite loop if the condition is never fulfilled.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，`while` 循环用于重复执行代码块，直到满足某个条件时，它等价于一个无限迭代器，可能会在条件满足时停止。此类结构的危险显而易见：如果条件永远不会满足，代码可能会陷入无限循环。
- en: The problem in scientific computing is that you are not always sure that an
    algorithm will converge. Newton iteration, for instance, might not converge at
    all. If that algorithm were implemented inside a `while` loop, the corresponding
    code would be trapped in an infinite loop for some choices of initial conditions.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 科学计算中的问题是，你不能总是确定一个算法是否会收敛。例如，牛顿迭代法可能根本不收敛。如果该算法被实现为 `while` 循环，那么对于某些初始条件的选择，相应的代码可能会陷入无限循环。
- en: 'We, therefore, advise that finite iterators are often better suited for such
    a task. The following construction replaces, often advantageously, the use of
    a `while` loop:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们建议在这种任务中，有限迭代器通常更为合适。以下结构通常可以更好地替代 `while` 循环的使用：
- en: '[PRE53]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The first advantage is that the code is guaranteed to execute in a finite time
    no matter what happens. The second advantage is that the variable `nb_iterations` contains
    the number of iterations that were necessary for the algorithm to converge.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个优点是，无论发生什么，代码都能保证在有限的时间内执行完毕。第二个优点是，变量 `nb_iterations` 存储了算法收敛所需的迭代次数。
- en: 9.7.2 Recursion
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.7.2 递归
- en: 'Recursion occurs when a function calls itself (see [Section 7.4](35749482-dbc7-41b2-aa19-dc63b242f18f.xhtml):
    *Recursive functions*).'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 递归发生在一个函数调用自身时（参见[第 7.4 节](35749482-dbc7-41b2-aa19-dc63b242f18f.xhtml)：*递归函数*）。
- en: 'When doing recursions, it is the recursion depth, which is the number of iterations,
    that brings your computer to its limits. We demonstrate this here by considering
    a simple recursion, which actually contains no computations at all. It assigns
    to the iterates only the value zero:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行递归时，限制计算机的因素是递归深度，也就是迭代的次数。我们通过考虑一个简单的递归来展示这一点，实际上这个递归没有任何计算操作。它仅仅将零赋值给迭代变量：
- en: '[PRE54]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Depending on your system, this program may choke for [![](img/aa5d7601-eb3e-462c-998a-82481eb1cb19.png)] (too
    much memory is used). The result is that the Python interpreter crashes without
    further exception. Python provides a mechanism to raise an exception when a too
    high recursion depth is detected. This maximum recursion depth may be changed
    by executing:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的系统，程序可能会因为 [![](img/aa5d7601-eb3e-462c-998a-82481eb1cb19.png)](使用了过多的内存)
    而卡住。结果是 Python 解释器崩溃，而不会抛出进一步的异常。Python 提供了一种机制，当检测到过高的递归深度时，能够引发异常。这个最大递归深度可以通过执行以下命令来改变：
- en: '[PRE55]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Be aware though, that choosing too high a number may imperil the stability of
    your code since Python might crash before that maximum depth is reached. It is
    therefore often wise to leave the recursion limit as it is. The actual value of
    the recursion limit can be obtained with `sys.getrecursionlimit()`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 但请注意，选择过高的数值可能会危及代码的稳定性，因为 Python 可能会在达到最大深度之前崩溃。因此，通常明智的做法是保持递归限制不变。实际的递归限制值可以通过
    `sys.getrecursionlimit()` 获得。
- en: 'By comparison, the following, non-recursive, program runs ten of millions of
    iterations without any problem:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，以下非递归程序可以无问题地运行数千万次迭代：
- en: '[PRE56]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: We advocate that, if possible, recursion should be avoided in Python. This applies
    obviously only if there is an appropriate alternative iterative algorithm available.
    The first reason is that a recursion of depth ***N*** involves ***N*** function
    calls at the same time, which might result in significant overhead. The second
    reason is that it is an infinite iteration, that is, it is difficult to give an
    upper bound to the number of steps necessary before the recursion is over.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们主张在 Python 中，如果可能的话，避免使用递归。当然，这仅适用于有合适替代的迭代算法。第一个原因是深度为 ***N*** 的递归涉及同时进行
    ***N*** 次函数调用，这可能会导致显著的开销。第二个原因是递归是一个无限迭代，即很难给出完成递归所需步骤数的上限。
- en: Note that in some very special cases (tree traversal) recursion is unavoidable.
    Besides, in some cases (with small recursion depths), recursive programs might
    be preferred due to readability.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在某些特殊情况下（树遍历），递归是不可避免的。此外，在某些情况下（递归深度较小），由于可读性，可能更倾向于使用递归程序。
- en: 9.8 Summary
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.8 小结
- en: In this chapter, we studied iterators, a programming construct very near to
    a mathematical description of iterative methods. You saw the keyword `yield` and
    met finite and infinite iterators.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们研究了迭代器，这是一种与迭代方法的数学描述非常接近的编程构造。你看到了关键字 `yield`，并接触了有限和无限迭代器。
- en: We showed that an iterator can be exhausted. More special aspects such as iterator
    comprehension and recursive iterators were introduced and demonstrated with the
    help of examples.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们展示了迭代器可以被耗尽。更多特殊的方面，如迭代器推导和递归迭代器，也通过示例进行了介绍和演示。
- en: 9.9 Exercises
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.9 练习
- en: '**Ex. 1:** Compute the value of the sum:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '**例 1：** 计算求和的值：'
- en: '![](img/0b05ec3f-b024-4e2b-a7eb-f19551a2a39f.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0b05ec3f-b024-4e2b-a7eb-f19551a2a39f.png)'
- en: '**Ex. 2:** Create a generator that computes the sequence defined by the relation:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '**例 2：** 创建一个生成器，计算由关系定义的序列：'
- en: '![](img/22f0a02e-8752-4d58-834b-0b735ce239ee.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![](img/22f0a02e-8752-4d58-834b-0b735ce239ee.png)'
- en: '**Ex. 3:** Generate all the even numbers.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '**例 3：** 生成所有偶数。'
- en: '**Ex. 4:** Let [![](img/537c8f39-479d-4a88-aa87-8baf6d233dc6.png)]. In calculus,
    it is shown that [![](img/88618432-dea1-4b8a-90ee-8d86ec945649.png)] . Determine
    experimentally the smallest number ![](img/c07910ea-e646-4704-b8cf-570ab0119311.png) such
    that [![](img/6c5d2fa8-5a02-4ec7-804a-5eaacc778498.png)]. Use a generator for
    this task.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '**例 4：** 设 [![](img/537c8f39-479d-4a88-aa87-8baf6d233dc6.png)]。在微积分中，已证明 [![](img/88618432-dea1-4b8a-90ee-8d86ec945649.png)]。实验确定最小的数字
    ![](img/c07910ea-e646-4704-b8cf-570ab0119311.png)，使得 [![](img/6c5d2fa8-5a02-4ec7-804a-5eaacc778498.png)]。使用生成器来完成此任务。'
- en: '**Ex. 5:** Generate all prime numbers less than a given integer. Use the algorithm called
    *Sieve of Eratosthenes*.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '**例 5：** 生成小于给定整数的所有质数。使用称为 *厄拉多塞筛法* 的算法。'
- en: '**Ex. 6:** Solving the differential equation [![](img/58410877-2e15-408b-837f-556aafbd0813.png)] by
    applying the explicit Euler method results in the recursion:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '**例 6：** 通过应用显式欧拉法解微分方程 [![](img/58410877-2e15-408b-837f-556aafbd0813.png)]
    结果得到递归：'
- en: '![](img/18d7bbb3-ac62-4a96-b4e0-f7f158ae0e14.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![](img/18d7bbb3-ac62-4a96-b4e0-f7f158ae0e14.png)'
- en: Write a generator that computes the solution values ![](img/ba1d483f-8eeb-4757-b16a-41b8eebb06f3.png) for
    a given initial value ![](img/2c063d73-e6ca-4631-b913-13da8ed5304f.png) and for
    a given value of the time step ![](img/0968c1ee-c6bc-4419-971d-41367ac5c23e.png).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个生成器，计算给定初始值 ![](img/2c063d73-e6ca-4631-b913-13da8ed5304f.png) 和给定时间步长值 ![](img/0968c1ee-c6bc-4419-971d-41367ac5c23e.png)
    的解值 ![](img/ba1d483f-8eeb-4757-b16a-41b8eebb06f3.png)。
- en: '**Ex. 7:** Compute π using the formula:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '**例 7：** 使用以下公式计算 π：'
- en: '![](img/1a41172d-85e9-497c-874c-b4136baa9345.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1a41172d-85e9-497c-874c-b4136baa9345.png)'
- en: 'The integral can be approximated using the composite trapezoidal rule, that
    is, with this formula:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 该积分可以使用复合梯形法则进行近似，即使用以下公式：
- en: '![](img/716db66e-5e6b-4b0b-b857-3c23f53d434d.png)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![](img/716db66e-5e6b-4b0b-b857-3c23f53d434d.png)'
- en: where ![](img/016f2ebf-9dc1-4d3a-aea3-a79cf4d62594.png).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 ![](img/016f2ebf-9dc1-4d3a-aea3-a79cf4d62594.png)。
- en: Program a *generator* for the values [![](img/5b6bfda4-c20d-4d09-9ae9-de27d85f262a.png)]and
    evaluate the formula by summing one term after the other. Compare your results
    with the `quad` function of SciPy.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个 *生成器* 用于计算值 [![](img/5b6bfda4-c20d-4d09-9ae9-de27d85f262a.png)]，并通过逐项相加来评估公式。将结果与
    SciPy 的 `quad` 函数进行比较。
- en: '**Ex. 8:** Let `x = [1, 2, 3]` and `y = [-1, -2, -3]`. What is the effect of
    the code `zip(*zip(x, y))`? Explain how it works.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '**习题 8：** 设 `x = [1, 2, 3]` 和 `y = [-1, -2, -3]`。代码 `zip(*zip(x, y))` 有什么作用？请解释其原理。'
- en: '**Ex. 9:** Complete elliptic integrals can be computed by the function `scipy.special.ellipk`.
    Write a function that counts the number of iterations needed with the AGM iteration
    until the result coincides up to a given tolerance (note that the input parameter *m* in `ellipk` corresponds
    to ![](img/133737ff-4444-4eea-be8a-fd8203c3c069.png)in the definition in [Section
    9.3.5](66c25bba-72d2-46a9-929a-1f57fa7a1684.xhtml): *Examples for iterators in
    mathematics**)*.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '**习题 9：** 完全椭圆积分可以通过 `scipy.special.ellipk` 函数计算。编写一个函数，通过 AGM 迭代来计算所需的迭代次数，直到结果在给定的容差内与实际结果一致（注意，在
    `ellipk` 中输入参数 *m* 对应于 [第 9.3.5 节](66c25bba-72d2-46a9-929a-1f57fa7a1684.xhtml)中的
    ![](img/133737ff-4444-4eea-be8a-fd8203c3c069.png)：*数学中迭代器的例子*）。'
- en: '**Ex. 10:** Consider the sequence ![](img/75a5ddd1-5690-43e0-b573-1cefd1970ee0.png) defined
    by:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '**习题 10：** 考虑由以下式子定义的序列 ![](img/75a5ddd1-5690-43e0-b573-1cefd1970ee0.png)：'
- en: '![](img/71ce32bd-58ef-4de2-a1fa-2f20fa5758f0.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![](img/71ce32bd-58ef-4de2-a1fa-2f20fa5758f0.png)'
- en: 'It converges monotonically to zero: ![](img/afb2bccf-36b3-4806-9e84-8584f4e91519.png).
    By integration by parts, we can show that the sequence ![](img/2c8e757e-4b77-48b0-bab8-042394496e33.png) fulfills
    the following recursion:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 它单调收敛到零：![](img/afb2bccf-36b3-4806-9e84-8584f4e91519.png)。通过分部积分，我们可以证明序列 ![](img/2c8e757e-4b77-48b0-bab8-042394496e33.png)
    满足以下递推关系：
- en: '![](img/f0047906-eee8-4a58-84ad-dd88feabca58.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f0047906-eee8-4a58-84ad-dd88feabca58.png)'
- en: 'Compute the first 20 terms of the recursion by using an appropriate generator
    and compare the results with those obtained by numerical integration with `scipy.integrate.quad`.
    Do the same by reversing the recursion:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 使用合适的生成器计算递推的前20项，并将结果与通过 `scipy.integrate.quad` 进行的数值积分结果进行比较。反转递推关系后进行相同的操作：
- en: '![](img/cd183bb8-3c5a-40c3-9e70-21cf9c912900.png)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cd183bb8-3c5a-40c3-9e70-21cf9c912900.png)'
- en: Use the function `exp` to evaluate the exponential function. What do you observe?
    Do you have an explanation? See also [[29]](12bddbb5-edd0-46c6-8f7a-9475aaf01a9d.xhtml).
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 使用函数 `exp` 来计算指数函数。你观察到了什么？你有什么解释吗？请参见 [[29]](12bddbb5-edd0-46c6-8f7a-9475aaf01a9d.xhtml)。
- en: '![](img/885ef052-42d3-4c73-8d41-d022a0029e9c.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![](img/885ef052-42d3-4c73-8d41-d022a0029e9c.png)'
- en: 'Figure 9.2: A convergence study of functions approximating [![](img/4ecef828-561f-47fa-a43d-b48302a5c823.png)]'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.2：一个关于逼近函数的收敛性研究 [![](img/4ecef828-561f-47fa-a43d-b48302a5c823.png)]
- en: '**Ex. 11:** The sine-function can be expressed due to Euler as:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '**习题 11：** 由于欧拉公式，正弦函数可以表示为：'
- en: '![](img/0d5b517e-f89b-47f2-9ba0-429b35442493.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0d5b517e-f89b-47f2-9ba0-429b35442493.png)'
- en: Write a generator that generates the function values ***P[k](x)***. Set `x=linspace(-1,3.5*pi,200)` and
    demonstrate graphically how well ***P[k](x)*** approximates **sin** for increasing *k*.
    In *Figure 9.2*, the possible result is shown. Consult also Theorem 5.2, p. 65
    in [[11]](12bddbb5-edd0-46c6-8f7a-9475aaf01a9d.xhtml).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个生成器，生成函数值 ***P[k](x)***。设定 `x=linspace(-1,3.5*pi,200)`，并通过图示展示在 *图 9.2*
    中，如何随着 *k* 增大，***P[k](x)*** 如何逼近 **sin**。可以参考 [[11]](12bddbb5-edd0-46c6-8f7a-9475aaf01a9d.xhtml)
    中的定理 5.2，第 65 页。
