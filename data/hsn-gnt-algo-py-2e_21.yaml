- en: '16'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '16'
- en: Other Evolutionary and Bio-Inspired Computation Techniques
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他进化和生物启发式计算技术
- en: In this chapter, you will broaden your horizons and discover several new problem-solving
    and optimization techniques related to genetic algorithms. Three different techniques
    of this extended family – **genetic programming**, **NeuroEvolution of Augmenting
    Topologies** (**NEAT**), and **particle swarm optimization** – will be then demonstrated
    through the implementation of problem-solving Python programs. Finally, we will
    provide a brief overview of several other related computation paradigms.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将拓宽视野，发现与遗传算法相关的几种新的问题解决和优化技术。通过实现问题解决的Python程序，我们将展示这一扩展家族的三种不同技术——**遗传编程**、**神经进化拓扑增强**（**NEAT**）和**粒子群优化**。最后，我们还将简要概述几种其他相关的计算范式。
- en: 'This chapter will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涉及以下主题：
- en: The evolutionary computation family of algorithms
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进化计算家族算法
- en: Understanding the concepts of **genetic programming** and how they differ from
    genetic algorithms
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解**遗传编程**的概念及其与遗传算法的区别
- en: Using genetic programming to solve the **even parity** **check** problem
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用遗传编程解决**偶校验** **检查**问题
- en: Understanding the concepts of **NEAT** and how they differ from genetic algorithms
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解**NEAT**的概念及其与遗传算法的区别
- en: Using NEAT to solve the even parity check problem
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用NEAT解决偶校验检查问题
- en: Understanding the concepts of particle swarm optimization
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解粒子群优化的概念
- en: Using particle swarm optimization to optimize **Himmelblau’s function**
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用粒子群优化算法优化**Himmelblau函数**
- en: Understanding the principles behind several other evolutionary and **biologically**
    **inspired techniques**
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解其他几种进化和**生物学启发式**技术的原理
- en: We will start this chapter by unveiling the extended family of **evolutionary
    computation** and discussing the main characteristics shared by its members.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从本章开始，揭示**进化计算**的扩展家族，并讨论其成员共享的主要特点。
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In this chapter, we will be using Python 3 alongside the following supporting
    libraries:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用Python 3，并搭配以下支持库：
- en: '**deap**'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**deap**'
- en: '**numpy**'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**numpy**'
- en: '**networkx**'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**networkx**'
- en: '**neatpy** – introduced in this chapter'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**neatpy**——在本章中介绍'
- en: '**pygame**'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**pygame**'
- en: Important note
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: If you’re using the **requirements.txt** file we’ve provided (see [*Chapter
    3*](B20851_03.xhtml#_idTextAnchor091)), these libraries will already be in your
    environment.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是我们提供的**requirements.txt**文件（见[*第3章*](B20851_03.xhtml#_idTextAnchor091)），这些库会已经存在于你的环境中。
- en: The programs that will be used in this chapter can be found in this book’s GitHub
    repository at [https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/tree/main/chapter_16](https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/tree/main/chapter_16).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的程序可以在本书的GitHub库中找到：[https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/tree/main/chapter_16](https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/tree/main/chapter_16)。
- en: 'Check out the following video to see the Code in Action:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频，看看代码的实际应用：
- en: '[https://packt.link/OEBOd](https://packt.link/OEBOd).'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/OEBOd](https://packt.link/OEBOd)。'
- en: Evolutionary computation and bio-inspired computing
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进化计算与生物启发式计算
- en: Throughout this book, we have covered the problem-solving technique known as
    *genetic algorithms* and applied it to numerous types of problems, including **combinatorial
    optimization**, **constraint satisfaction,** and **continuous function optimization**,
    as well as to **machine learning** and **artificial intelligence**. However, as
    we mentioned in [*Chapter 1*](B20851_01.xhtml#_idTextAnchor015), *An Introduction
    to Genetic Algorithms*, genetic algorithms are just one branch within a larger
    family of algorithms called **evolutionary computation**. This family consists
    of various related problem-solving and optimization techniques, all of which draw
    inspiration from Charles Darwin’s theory of natural evolution.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中，我们已经介绍了名为*遗传算法*的求解技术，并将其应用于多种类型的问题，包括**组合优化**、**约束满足**、**连续函数优化**，以及**机器学习**和**人工智能**。然而，正如我们在[*第1章*](B20851_01.xhtml#_idTextAnchor015)《遗传算法简介》中提到的那样，遗传算法只是一个更大算法家族——**进化计算**中的一支。这个家族包括各种相关的问题解决和优化技术，所有这些技术都从查尔斯·达尔文的自然进化理论中汲取灵感。
- en: 'The main characteristics that are shared by these techniques are as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这些技术共享的主要特征如下：
- en: The starting point is an initial set (**population**) of candidate solutions.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 起点是一个初始集（**种群**）的候选解。
- en: The candidate solutions (**individuals**) are updated iteratively to create
    new generations.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 候选解（**个体**）会通过迭代更新，生成新的代。
- en: Creating a new generation involves removing less successful individuals (**selection**),
    as well as introducing small random changes (**mutations**) to some individuals.
    Other operators, such as interaction with other individuals (**crossover**), may
    also be applied.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建新一代涉及淘汰不太成功的个体（**选择**），并对一些个体引入小的随机变化（**突变**）。也可以应用其他操作，如与其他个体的交互（**交叉**）。
- en: As a result, as generations go by, the **fitness** of the population increases;
    in other words, the candidate solutions become better at solving the problem at
    hand.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结果是，随着代数的增加，种群的**适应度**提高；换句话说，候选解在解决当前问题上变得更加有效。
- en: More broadly, since evolutionary computation techniques are based on various
    biological systems or behaviors, they generally overlap with the algorithm family
    known as **bio-inspired computing**.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 更广泛地说，由于进化计算技术基于各种生物系统或行为，它们通常与被称为**生物启发计算**的算法家族有所重叠。
- en: 'In the following sections, we will cover some of the most frequently used members
    of evolutionary computation and bio-inspired computing – some will be covered
    in greater detail, while the others will only be mentioned briefly. We will start
    by providing a detailed account of a fascinating technique that allows us to evolve
    actual computer programs: **genetic programming**.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将介绍一些进化计算和生物启发计算中最常用的成员——有些会详细介绍，而其他则仅简要提及。我们将从详细介绍一个有趣的技术开始，它使我们能够进化实际的计算机程序：**遗传编程**。
- en: Genetic programming
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 遗传编程
- en: Genetic programming is a special form of genetic algorithm – that is, the technique
    we have been applying throughout this book. In this special case, the candidate
    solutions – or individuals – that we are evolving to find the best one for our
    purpose are computer programs, hence the name. In other words, when we apply genetic
    programming, we evolve *computer programs* to find a program that will excel at
    performing a particular task.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 遗传编程是遗传算法的一种特殊形式——也就是我们在本书中应用的技术。在这种特殊情况下，我们正在进化的候选解——或者说个体——是计算机程序，因此得名。换句话说，当我们应用遗传编程时，我们在进化*计算机程序*，以找到能够出色完成特定任务的程序。
- en: 'As you may recall, genetic algorithms use a representation of the candidate
    solutions, often referred to as a *chromosome*. This representation is subject
    to genetic operators, namely *selection*, *crossover*, and *mutation*. Applying
    these operators to the current generation results in a new generation of solutions
    that is expected to produce better results than its predecessor. In most of the
    problems we have looked at so far, this representation was a list (or an array)
    of values of a certain type, such as integers, Booleans, or floats. To represent
    a *program*, however, we typically use a *tree structure*, as shown in the following
    diagram:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所记得，遗传算法使用候选解的表示，通常称为*染色体*。这个表示受基因操作符的作用，即*选择*、*交叉*和*突变*。将这些操作符应用于当前代时，结果是产生一个新的解代，预计比前代产生更好的结果。在我们到目前为止所研究的大多数问题中，这种表示通常是某种类型值的列表（或数组），如整数、布尔值或浮点数。然而，为了表示*程序*，我们通常使用*树结构*，如以下图示所示：
- en: '![Figure 16.1: Tree structure representation of a simple program](img/B20851_16_1.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图16.1：简单程序的树结构表示](img/B20851_16_1.jpg)'
- en: 'Figure 16.1: Tree structure representation of a simple program'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.1：简单程序的树结构表示
- en: 'Source: [https://commons.wikimedia.org/wiki/File:Genetic_Program_Tree.png](https://commons.wikimedia.org/wiki/File:Genetic_Program_Tree.png)'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 来源：[https://commons.wikimedia.org/wiki/File:Genetic_Program_Tree.png](https://commons.wikimedia.org/wiki/File:Genetic_Program_Tree.png)
- en: Image by Baxelrod.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图片来自Baxelrod。
- en: 'The tree structure depicted in the preceding diagram represents the calculation
    shown underneath the tree. This calculation is equivalent to a short program (or
    a function) that accepts two arguments, *X* and *Y*, and returns a certain output
    based on their values. To create and evolve such tree structures, we need to define
    two different sets:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的树形结构表示了树下方展示的计算过程。这个计算等同于一个接受两个参数 *X* 和 *Y* 的短程序（或函数），并根据它们的值返回一个特定的输出。为了创建和进化这样的树结构，我们需要定义两个不同的集合：
- en: '**Terminals**, or the *leaves* of the tree. These are arguments and the constant
    values that can be used in the tree. In our example, **X** and **Y** are arguments,
    while **2.2**, **11**, and **7** are constants. Constants can also be generated
    randomly, within a certain range, when a tree is created.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**终端**，或者是树的*叶节点*。这些是可以在树中使用的参数和常量值。在我们的示例中，**X** 和 **Y** 是参数，而 **2.2**、**11**
    和 **7** 是常量。在树创建时，常量也可以在某个范围内随机生成。'
- en: '**Primitives**, or the *internal nodes* of the tree. These are functions (or
    operators) that accept one or more arguments and generate a single output value.
    In our example, **+**, **-**, *****, and **÷** are primitives that accept two
    arguments, while **cos** is a primitive that accepts a single argument.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基本操作符**，或者是树的*内部节点*。这些是接受一个或多个参数并生成单一输出值的函数（或运算符）。在我们的示例中，**+**、**-**、****、**÷**
    是接受两个参数的基本操作符，而 **cos** 是接受一个参数的基本操作符。'
- en: 'In [*Chapter 2*](B20851_02.xhtml#_idTextAnchor053), *Understanding the Key
    Components of Genetic Algorithms*, we demonstrated how the genetic operator of
    *single-point crossover* operates on binary-valued lists. The crossover operation
    created two offspring from two parents by cutting out a part of each parent and
    swapping the detached parts between the parents. Similarly, a crossover operator
    for the tree representation may detach a *subtree* (a branch or a group of branches)
    from each parent and swap the detached branches between the parents to create
    offspring trees, as demonstrated in the following diagram:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第 2 章*](B20851_02.xhtml#_idTextAnchor053)，《理解遗传算法的关键组件》中，我们展示了遗传操作符*单点交叉*如何作用于二进制值列表。交叉操作通过切割每个父节点的一部分并交换父节点之间的切割部分，创建了两个后代。类似地，树形表示的交叉操作符可以从每个父节点中分离出一个*子树*（一个分支或一组分支），并交换这些被分离的分支来创建后代树，示例如下图所示：
- en: '![Figure 16.2: Crossover operation between two tree structures representing
    programs](img/B20851_16_2.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.2：表示程序的两个树结构之间的交叉操作](img/B20851_16_2.jpg)'
- en: 'Figure 16.2: Crossover operation between two tree structures representing programs'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.2：表示程序的两个树结构之间的交叉操作
- en: 'Source: [https://commons.wikimedia.org/wiki/File:GP_crossover.png](https://commons.wikimedia.org/wiki/File:GP_crossover.png)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 来源：[https://commons.wikimedia.org/wiki/File:GP_crossover.png](https://commons.wikimedia.org/wiki/File:GP_crossover.png)
- en: Image by U-ichi
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图片由 U-ichi 提供
- en: In this example, the two parents on the top row have subtrees that have been
    swapped between them to create the two offspring in the second row. The swapped
    subtrees are marked by the rectangles surrounding them.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，顶行的两个父节点有交换了子树，形成了第二行的两个后代。交换的子树用矩形框标出。
- en: Along the same lines, the *mutation* operator, which intends to introduce random
    changes to a single individual, can be implemented by picking a subtree within
    the candidate solution and replacing it with a randomly generated one.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，*变异*操作符旨在对单个个体引入随机变化，它的实现方式是从候选解中选择一个子树，并将其替换为一个随机生成的子树。
- en: The **deap** library, which we have been using throughout this book, provides
    inherent support for genetic programming. In the next section, we will implement
    a simple genetic programming example using this library.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本书中一直使用的 **deap** 库原生支持遗传编程。在下一节中，我们将使用该库实现一个简单的遗传编程示例。
- en: Genetic programming example – even parity check
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 遗传编程示例——偶校验检查
- en: 'For our example, we will use genetic programming to create a program that implements
    an even parity check. In this task, the possible values of the inputs are 0 or
    1\. The output value should be 1 if the number of the inputs with the value 1
    is odd, thereby producing a total even number of 1 values; otherwise, the output
    value should be 0\. The following table lists the various possible combinations
    of input values for the case of three inputs, along with the matching even parity
    output values:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的示例，我们将使用遗传编程创建一个实现偶校验检查的程序。在此任务中，输入的可能值为0或1。若输入中值为1的数量为奇数，则输出值应为1，从而得到一个偶数个1的总数；否则，输出值应为0。下表列出了三输入情况下，输入值的各种可能组合及其对应的偶校验输出值：
- en: '| **in_0** | **in_1** | **in_2** | **Even Parity** |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| **in_0** | **in_1** | **in_2** | **偶校验** |'
- en: '| 0 | 0 | 0 | 0 |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 0 | 0 |'
- en: '| 0 | 0 | 1 | 1 |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 1 | 1 |'
- en: '| 0 | 1 | 0 | 1 |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 | 0 | 1 |'
- en: '| 0 | 1 | 1 | 0 |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 | 1 | 0 |'
- en: '| 1 | 0 | 0 | 1 |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 | 0 | 1 |'
- en: '| 1 | 0 | 1 | 0 |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 | 1 | 0 |'
- en: '| 1 | 1 | 0 | 0 |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 0 | 0 |'
- en: '| 1 | 1 | 1 | 1 |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 1 | 1 |'
- en: 'Table 16.1: Truth table of even parity as a function of three inputs'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 表16.1：三输入偶校验的真值表
- en: This kind of table is often referred to as the *truth table* of the operation
    at hand. As evident from this truth table, one reason that the parity check is
    often used as a benchmark is that any single change in the input values will result
    in a change to the output value.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这种表格通常被称为*真值表*。从这个真值表可以看出，偶校验经常作为基准使用的原因之一是，输入值的任何单一变化都会导致输出值发生变化。
- en: 'The parity check can also be represented using logic gates, such as `AND`,
    `OR`, `NOT`, and exclusive `OR` (`XOR`). While the `NOT` gate accepts a single
    input and inverts it, each of the three other gate types accepts two inputs. For
    the respective output to be 1, the `AND` gate requires both inputs to be 1, the
    `OR` gate requires at least one of them to be 1, and the `XOR` gate requires that
    exactly one of them is 1, as shown in the following table:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 偶校验还可以通过逻辑门来表示，例如`AND`、`OR`、`NOT`和异或（`XOR`）。`NOT`门接受一个输入并将其反转，而其他三种门类型每种都接受两个输入。为了使输出为1，`AND`门要求两个输入都为1，`OR`门要求至少一个输入为1，而`XOR`门要求恰好一个输入为1，如下表所示：
- en: '| **in_0** | **in_1** | **AND** | **OR** | **XOR** |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| **in_0** | **in_1** | **AND** | **OR** | **XOR** |'
- en: '| 0 | 0 | 0 | 0 | 0 |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 0 | 0 | 0 |'
- en: '| 0 | 1 | 0 | 1 | 1 |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 | 0 | 1 | 1 |'
- en: '| 1 | 0 | 0 | 1 | 1 |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 | 0 | 1 | 1 |'
- en: '| 1 | 1 | 1 | 1 | 0 |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 1 | 1 | 0 |'
- en: 'Table 16.2: Truth tables of AND, OR and XOR operations of two inputs'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 表16.2：两输入的AND、OR和XOR操作的真值表
- en: 'There are many possible ways to implement the three-input parity check using
    logic gates. The simplest way to do this is by using two `XOR` gates, as shown
    in the following diagram:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 实现三输入偶校验有多种可能的方法。最简单的方法是使用两个`XOR`门，如下图所示：
- en: '![Figure 16.3: A three-input even parity check implemented using two XOR gates](img/B20851_16_3.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图16.3：使用两个XOR门实现的三输入偶校验](img/B20851_16_3.jpg)'
- en: 'Figure 16.3: A three-input even parity check implemented using two XOR gates'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.3：使用两个XOR门实现的三输入偶校验
- en: In the next subsection, we will use genetic programming to create a small program
    that implements an even parity check using the `AND`, `OR`, `NOT`, and `XOR` logic
    operations.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的小节中，我们将使用遗传编程创建一个小程序，该程序通过使用`AND`、`OR`、`NOT`和`XOR`逻辑运算实现偶校验。
- en: Genetic programming implementation
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 遗传编程实现
- en: To evolve a program that implements the even parity check logic, we’ve created
    a genetic programming-based Python program called `01_gp_even_parity.py` at [https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_16/01_gp_even_parity.py](https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_16/01_gp_even_parity.py).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进化出实现偶校验逻辑的程序，我们创建了一个基于遗传编程的Python程序，名为`01_gp_even_parity.py`，可以在[https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_16/01_gp_even_parity.py](https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_16/01_gp_even_parity.py)找到。
- en: Since genetic programming is a special case of genetic algorithms, much of this
    program will look familiar to you if you have gone over the programs we presented
    in earlier chapters of this book.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 由于遗传编程是遗传算法的一种特例，如果你已经浏览过本书前几章中展示的程序，那么这个程序的很多部分应该会对你来说非常熟悉。
- en: 'The following steps describe the main parts of this program:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤描述了该程序的主要部分：
- en: 'We start by setting the problem-related constant values. Here, **NUM_INPUTS**
    determines the number of inputs for the even parity checker. We will use a value
    of **3** for simplicity; however, larger values can be set as well. The **NUM_COMBINATIONS**
    constant represents the number of possible combinations of values for the inputs,
    which is analogous to the number of rows in the truth table we saw earlier:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先设置与问题相关的常量值。这里，**NUM_INPUTS**决定了偶校验检查器的输入数量。为了简化，我们使用**3**作为值；但也可以设置更大的值。**NUM_COMBINATIONS**常量表示输入值的可能组合数，它类似于我们之前看到的真值表中的行数：
- en: '[PRE0]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This is followed by the familiar genetic algorithm constants we have seen numerous
    times before:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是我们之前多次见过的熟悉的遗传算法常量：
- en: '[PRE1]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'However, genetic programming requires several additional constants that refer
    to the tree representation of the candidate solutions. These are defined in the
    following code. We will see how they are used as we examine the rest of this program:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，遗传编程需要一些额外的常量，这些常量指的是候选解的树表示形式。它们在以下代码中定义。我们将在检查本程序的其余部分时看到它们是如何使用的：
- en: '[PRE2]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, we calculate the *truth table* of the even parity check so that we can
    use it as a reference when we need to check the accuracy of a given candidate
    solution. The **parityIn** matrix represents the input columns of the truth table,
    while the **parityOut** vector represents the output column. The Python **itertools.product()**
    function is an elegant replacement for nested **for** loops that would be otherwise
    required to iterate over all the combinations of input values:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们计算*真值表*的偶校验，以便在需要检查给定候选解的准确性时可以作为参考。**parityIn**矩阵表示真值表的输入列，而**parityOut**向量表示输出列。Python的**itertools.product()**函数是嵌套**for**循环的优雅替代，它可以遍历所有输入值的组合：
- en: '[PRE3]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, it is time to create the set of *primitives* – that is, the operators
    that will be used in our evolved programs. The first declaration creates a set
    using the following three arguments:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，是时候创建*原始元素*集合了——也就是将用于我们进化程序的运算符。第一个声明使用以下三个参数创建一个集合：
- en: The name of the program to be generated using the primitives from the set (here,
    we called it **main**)
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用集合中的原始元素生成的程序名称（在这里，我们称之为**main**）
- en: The number of inputs to the program
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序的输入数量
- en: The prefix to be used when naming the inputs (optional)
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于命名输入的前缀（可选）
- en: 'These three arguments are used to create the following primitive set:'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这三个参数用于创建以下原始元素集合：
- en: '[PRE4]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, we fill the primitive set with the various functions (or operators) that
    will be used as the building blocks of the program. For each operator, we will
    use a reference to the function that implements it and the number of arguments
    it expects. Although we could define our own functions for this purpose, in this
    case, we’re making use of the existing Python **operator** module, which contains
    numerous useful functions, including the logical operators we need:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们用将作为程序构建块的各种函数（或运算符）填充原始集合。对于每个运算符，我们将引用实现它的函数以及它期望的参数个数。尽管我们可以为此定义自己的函数，但在本例中，我们利用了现有的Python
    **operator**模块，它包含了许多有用的函数，包括我们所需的逻辑运算符：
- en: '[PRE5]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The following definitions set the *terminal* values to be used. As we mentioned
    earlier, these are constants that can be used as input values for the tree. In
    our case, it makes sense to use **0** and **1** as values:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下定义设置了要使用的*终止*值。如前所述，这些是可以作为树的输入值的常量。在我们的例子中，使用**0**和**1**作为值是合适的：
- en: '[PRE6]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Since our goal is to create a program that implements the truth table of the
    *even parity check*, we will attempt to minimize the difference between the program’s
    output and the known output values. For this purpose, we will define a single
    objective – that is, minimizing the fitness strategy:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们的目标是创建一个实现*偶校验真值表*的程序，我们将尽量减少程序输出与已知输出值之间的差异。为此，我们将定义一个单一的目标——即最小化适应度策略：
- en: '[PRE7]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, we will create the **Individual** class, based on the **PrimitiveTree**
    class provided by the **deap** library:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将创建**Individual**类，基于**deap**库提供的**PrimitiveTree**类：
- en: '[PRE8]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To help us construct an individual in the population, we will create a helper
    function that will generate random trees using the primitive set we defined earlier.
    Here, we’re making use of the **genFull()** function offered by **deap** and providing
    it with the primitive set, as well as with the values for defining the minimum
    and maximum height of the generated trees:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了帮助我们构建种群中的个体，我们将创建一个辅助函数，使用之前定义的原始集合生成随机树。在这里，我们利用了**deap**提供的**genFull()**函数，并为其提供了原始集合，以及定义生成树的最小和最大高度的值：
- en: '[PRE9]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This is followed by defining two operators, the first of which creates an individual
    instance using the preceding helper operator. The other generates a list of such
    individuals:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来定义了两个操作符，第一个通过前面的辅助操作符创建个体实例。另一个生成这样个体的列表：
- en: '[PRE10]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, we create an operator to *compile* a given primitive tree into Python
    code using the **compile()** function offered by **deap**. Consequently, we’ll
    use this compile operator in a function we’ll create, called **parityError()**.
    For a given individual – a tree representing an expression – this function counts
    the number of rows in the truth table for which the result of the calculation
    differs from the expected one:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个操作符，用于*编译*给定的原始树为Python代码，使用**compile()**函数，这个函数是由**deap**提供的。因此，我们将在我们创建的一个函数中使用这个编译操作符，叫做**parityError()**。对于给定的个体——表示一个表达式的树——这个函数会统计在真值表中，计算结果与预期结果不同的行数：
- en: '[PRE11]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then, we must instruct the genetic programming algorithm to use the **getCost()**
    function for fitness evaluation. This function returns the parity error we just
    saw in tuple form that’s required by the underlying evolutionary algorithm:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们必须指示遗传编程算法使用**getCost()**函数进行适应度评估。该函数返回我们刚才看到的奇偶错误，作为元组形式，这是底层进化算法所需的：
- en: '[PRE12]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'It’s time to choose our genetic operators, starting with the *selection* operator
    (aliased with **select**). For genetic programming, this operator is typically
    the same *tournament selection* we have been using throughout this book. Here,
    we’re using it with a tournament size of **2**:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是选择我们的遗传操作符的时候了，从*选择*操作符（别名为**select**）开始。对于遗传编程，这个操作符通常是我们在本书中一直使用的*锦标赛选择*。在这里，我们使用的锦标赛大小为**2**：
- en: '[PRE13]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'As for the *crossover* operator (aliased with **mate**), we will use the specialized
    genetic programming **cxOnePoint()** operator that’s provided by **deap**. Since
    the evolving programs are represented by trees, this operator takes two parent
    trees and exchanges sections of them to create two valid offspring trees:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 至于*交叉*操作符（别名为**mate**），我们将使用DEAP提供的专用遗传编程**cxOnePoint()**操作符。由于进化程序由树表示，这个操作符接受两个父树，并交换它们的部分内容，从而创建两个有效的后代树：
- en: '[PRE14]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next is the *mutation* operator, which introduces random changes to an existing
    tree. The mutation is defined in two stages. First, we specify a helper operator
    that utilizes the specialized genetic programming **genGrow()** function, provided
    by **deap**. This operator creates a subtree within the limits defined by the
    two constants. Then, we define the mutation operator itself (aliased with **mutate**).
    This operator utilizes DEAP’s **mutUniform()** function, which randomly replaces
    a subtree in a given tree with a random one that was generated using the helper
    operator:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是*变异*操作符，它引入对现有树的随机变化。变异定义为两个阶段。首先，我们指定一个辅助操作符，利用由**deap**提供的专用遗传编程**genGrow()**函数。这个操作符在由两个常量定义的限制内创建一个子树。然后，我们定义变异操作符本身（别名为**mutate**）。该操作符利用DEAP的**mutUniform()**函数，随机替换给定树中的一个子树，替换成通过辅助操作符生成的随机子树：
- en: '[PRE15]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To prevent individuals in the population from growing into overly large trees,
    potentially containing an excessive number of primitives, we need to introduce
    *bloat control* measures. We can do this using DEAP’s **staticLimit()** function,
    which imposes a tree height restriction on the results of the *crossover* and
    *mutation* operations:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了防止种群中的个体树木过度增长，可能包含过多的原始元素，我们需要引入*膨胀控制*措施。我们可以通过使用DEAP的**staticLimit()**函数来实现，它对*交叉*和*变异*操作的结果施加树的高度限制：
- en: '[PRE16]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The program’s main loop is very similar to the ones we saw in earlier chapters.
    After creating the initial population, defining the statistics measurements, and
    creating the HOF object, we call the evolutionary algorithm. Like we’ve done multiple
    times before, we must apply the *elitist approach*, where the HOF members – the
    current best individuals – are always passed untouched to the next generation:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 程序的主循环与我们在前几章中看到的非常相似。在创建初始种群、定义统计度量和创建HOF对象之后，我们调用进化算法。像之前做过的多次一样，我们必须采用*精英方法*，即将HOF成员——当前最优个体——始终传递给下一代，保持不变：
- en: '[PRE17]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'At the end of the run, we print the best solution, as well as the height of
    the tree that’s being used to represent it, and its length – that is, the total
    number of operators contained in the tree:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在运行结束时，我们打印出最佳解决方案，以及用于表示它的树的高度和长度——即树中包含的运算符总数：
- en: '[PRE18]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The last thing we need to do is plot a graphic illustration of the tree representing
    the best solution. To that end, we must utilize the graph and networks library
    known as *NetworkX* (**nx**), which we introduced in [*Chapter 5*](B20851_05.xhtml#_idTextAnchor177),
    *Constraint Satisfaction*. We start by calling the **graph()** function provided
    by **deap**, which breaks down the individual tree into the nodes, edges, and
    labels that are required for the graph, and then create the graph using the appropriate
    **networkx** functions:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后我们需要做的事情是绘制表示最佳解决方案的树的图形插图。为此，我们必须使用图形和网络库*NetworkX*（**nx**），它在[*第五章*](B20851_05.xhtml#_idTextAnchor177)《约束满足》中有所介绍。我们首先调用**deap**提供的**graph()**函数，它将单个树分解为构建图所需的节点、边和标签，然后使用适当的**networkx**函数创建图：
- en: '[PRE19]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, we draw the nodes, edges, and labels. Since the layout of this graph
    is not a classic hierarchical tree, we must distinguish the top node by coloring
    it red and enlarging it:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们绘制节点、边和标签。由于该图的布局不是经典的层次树结构，我们必须通过将顶部节点着色为红色并放大它来区分它：
- en: '[PRE20]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'When running this program, we get the following output:'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行此程序时，我们得到以下输出：
- en: '[PRE21]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Since this is a simple problem, the fitness has quickly reached the minimum
    value of 0, which means we were able to find a solution that correctly reproduces
    the *even parity check* truth table. However, the resulting expression, which
    consists of 19 elements and four levels in the hierarchy, seems overly complex.
    This is illustrated by the following plot that was produced by the program:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个简单的问题，适应度很快达到了最小值0，这意味着我们成功找到了一个正确地重现*偶校验检查*真值表的解决方案。然而，结果表达式由19个元素和四个层次组成，看起来过于复杂。下面的图表显示了程序生成的结果：
- en: '![Figure 16.4: A plot representing the parity check solution that was found
    by the initial program](img/B20851_16_04.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图16.4：表示初始程序找到的奇偶校验解决方案的图表](img/B20851_16_04.jpg)'
- en: 'Figure 16.4: A plot representing the parity check solution that was found by
    the initial program'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.4：表示初始程序找到的奇偶校验解决方案的图表
- en: As we mentioned previously, the red node in the graph represents the top of
    the program’s tree, which maps to the first `XOR` operation in the expression.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，图中的红色节点表示程序树的顶部，它映射到表达式中的第一个`XOR`操作。
- en: The reason for this relatively complex graph is that there is no advantage to
    using simpler expressions. So long as they fall within the imposed limitation
    of tree height, the expressions that are evaluated incur no penalty for complexity.
    In the next subsection, we will attempt to change this situation by making a small
    modification to the program in the hope of achieving the same outcome – the implementation
    of the even parity check – but with a simpler solution.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这个相对复杂的图表的原因是使用更简单的表达式没有优势。只要它们符合树高度的限制，被评估的表达式不会因复杂性而受到惩罚。在下一个子章节中，我们将通过对程序进行小的修改来尝试改变这种情况，期望以更简洁的解决方案实现相同的结果——偶校验检查的实现。
- en: Simplifying the solution
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 简化解决方案
- en: In the implementation we have just seen, there were measures in place to restrict
    the size of the trees that represent the candidate solutions. However, the best
    solution we found seems overly complex. One way to pressure the algorithm into
    producing simpler results is to impose a small cost penalty for complexity. This
    penalty should be small enough that it refrains from favoring simpler solutions
    that fail to solve the problem. Rather, it should serve as a tie-breaker between
    two good solutions, so the simpler of the two will be preferred. This approach
    has been implemented in the `02_gp_even_parity_reduced.py` Python program, which
    is located at [https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_16/02_gp_even_parity_reduced.py](https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_16/02_gp_even_parity_reduced.py).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们刚刚看到的实现中，已经采取了措施来限制表示候选解的树的大小。然而，我们找到的最佳解似乎过于复杂。强制算法生成更简单结果的一种方法是对复杂性施加小的成本惩罚。这种惩罚应该足够小，以避免偏好于未能解决问题的更简单解决方案。相反，它应该作为两个良好解决方案之间的决胜局，从而优先选择更简单的解决方案。这种方法已经在位于[https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_16/02_gp_even_parity_reduced.py](https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_16/02_gp_even_parity_reduced.py)的`02_gp_even_parity_reduced.py`
    Python程序中实施。
- en: 'This program is nearly identical to the previous one, except for a couple of
    small changes:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序几乎与之前的程序相同，除了几个小的变化：
- en: 'The main change was introduced to the *cost function*, which the algorithm
    seeks to minimize. To the original calculated error, a small penalty measure was
    added that depends on the height of the tree:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 主要的变化是引入到*成本函数*中，该算法试图最小化。在原始计算的错误之上，增加了依赖于树高度的小惩罚措施：
- en: '[PRE22]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The only other change was at the end of the run, after printing the best solution
    that was found. Here, in addition to printing the fitness value, we print the
    actual *parity error* that was obtained, without the penalty that’s present in
    the fitness:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 唯一的其他变化发生在运行结束后，在打印找到的最佳解决方案之后。在这里，除了打印健身价值外，我们还打印了实际的*奇偶错误*，而没有出现在健身中的惩罚：
- en: '[PRE23]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'By running this modified version, we get the following output:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这个修改版本，我们得到以下输出：
- en: '[PRE24]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'From the preceding output, we can tell that, after five generations, the algorithm
    was able to find a solution that correctly reproduces the even parity check truth
    table since the fitness value at that point was nearly 0\. However, as the algorithm
    kept running, the tree height was reduced from four (a penalty of `0.04`) to two
    (a penalty of `0.02`). As a result, the best solution is very simple and consists
    of only five elements – the three inputs and two `XOR` operators. The solution
    we found represents the simplest known solution that we saw earlier, which consists
    of two `XOR` gates. This is illustrated by the following plot, which was produced
    by the program:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的输出中，我们可以看出，经过五代的迭代后，该算法能够找到一个正确重现偶校验检查真值表的解决方案，因为此时的健身价值几乎为0。然而，随着算法的继续运行，树的高度从四（0.04的惩罚）降低到了二（0.02的惩罚）。因此，最佳解决方案非常简单，仅包含五个元素
    - 三个输入和两个`XOR`运算符。我们找到的解决方案代表了我们之前看到的最简单已知解决方案，其中包含两个`XOR`门。这由程序生成的以下绘图所示：
- en: '![Figure 16.5: A plot representing the parity check solution that was found
    by the modified program](img/B20851_16_05.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.5：代表由修改后程序找到的奇偶校验解的绘图](img/B20851_16_05.jpg)'
- en: 'Figure 16.5: A plot representing the parity check solution that was found by
    the modified program'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.5：代表由修改后程序找到的奇偶校验解的绘图
- en: While genetic programming is considered a subset of genetic algorithms, the
    next section describes a more specialized form of evolutionary computation – one
    that is dedicated to creating neural network architectures.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管遗传编程被认为是遗传算法的一个子集，但下一节描述了一种更专门的进化计算形式 - 专门用于创建神经网络架构。
- en: NEAT
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NEAT
- en: In [*Chapter 9*](B20851_09.xhtml#_idTextAnchor257), *Architecture Optimization
    of Deep Learning Networks*, we demonstrated how a simple genetic algorithm can
    be used to find the best architecture of a feed-forward neural network (also known
    as **multilayer perceptron** or **MLP**) for a particular task. To do that, we
    limited ourselves to three hidden layers and coded each network using a fixed-size
    chromosome that had placeholders for each of the layers, where a 0 or a negative
    value meant that the layer did not exist.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第9章*](B20851_09.xhtml#_idTextAnchor257)，*深度学习网络的架构优化*，我们展示了如何使用简单的遗传算法来找到适合特定任务的前馈神经网络（也称为**多层感知器**或**MLP**）的最佳架构。为此，我们限制了三个隐藏层，并使用了一个具有每个层占位符的固定大小染色体来编码每个网络，其中0或负值表示该层不存在。
- en: Taking this idea further, **NEAT** is an evolutionary technique dedicated to
    creating neural networks more flexibly and incrementally and was created in 2002
    by *Kenneth Stanley* and *Risto Miikkulainen*.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 将这个想法进一步发展，**NEAT**是一种专门用于更灵活和渐进创建神经网络的进化技术，由*Kenneth Stanley*和*Risto Miikkulainen*于2002年创建。
- en: NEAT starts with small, simple neural networks and allows them to evolve by
    adding and modifying neurons and connections over generations. Rather than using
    a fixed-size chromosome, NEAT represents solutions as *directed graphs* that directly
    map into artificial neural networks, where nodes represent neurons, and connections
    between nodes represent synapses. This allows NEAT to evolve not only the weights
    of the connections but also the network’s structure itself, including adding and
    removing neurons and connections.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: NEAT从小而简单的神经网络开始，并允许它们通过在几代中添加和修改神经元和连接来进化。与使用固定大小的染色体不同，NEAT将解决方案表示为直接映射到人工神经网络的*有向图*，其中节点表示神经元，节点之间的连接表示突触。这使得NEAT不仅可以进化连接的权重，还可以进化网络的结构本身，包括添加和删除神经元和连接。
- en: NEAT’s *crossover* operator is designed specifically for neural networks. It
    aligns and combines matching neurons and connections from parent networks while
    maintaining unique ‘innovation’ identifiers. To enable this kind of matching,
    the history of genes is tracked by the use of a **global innovation number**,
    which increases as new genes are added.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: NEAT的*交叉*运算符专门设计用于神经网络。它对齐并结合来自父网络的匹配神经元和连接，同时保持独特的‘创新’标识符。为了实现这种匹配，通过使用**全局创新编号**跟踪基因的历史，随着新基因的添加，此编号会增加。
- en: In addition, NEAT employs a **speciation** mechanism that groups individuals
    (neural networks) into species based on their structural similarity. This grouping
    encourages competition *within* species rather than *between* species. This mechanism
    helps ensure that innovations have a chance to thrive within their respective
    niches before being subjected to intense competition.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，NEAT采用一种**物种化**机制，根据它们的结构相似性将个体（神经网络）分组为物种。这种分组鼓励物种内的竞争，而不是物种之间的竞争。该机制有助于确保创新在其各自的生态位中有机会繁荣，然后再受到激烈竞争的影响。
- en: NEAT (along with other related neuroevolutionary techniques) has been applied
    in many areas, including financial forecasting, drug discovery, evolving art,
    electronic circuit design, and robotics; however, it is most commonly found in
    *reinforcement learning* applications, such as game playing.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: NEAT（以及其他相关的神经进化技术）已被应用于许多领域，包括财务预测、药物发现、进化艺术、电子电路设计和机器人技术；然而，它最常见的应用是在*强化学习*应用中，如游戏玩法。
- en: NEAT example – even parity check
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NEAT示例 - 偶数奇偶校验
- en: We will illustrate using the NEAT technique by solving the same three-input
    *even parity check* problem we used in the previous section to demonstrate genetic
    programming. Here, we’ll employ NEAT to create a feed-forward neural network implementation
    of the same parity check function.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过解决与前一节中使用的相同的三输入*偶数奇偶校验*问题，使用NEAT技术进行说明，来创建同一奇偶校验函数的前馈神经网络实现。
- en: In regards to neural networks, the even parity check, also known as **the XOR
    problem**, is known to be impossible for a single perceptron to implement as it
    forms a pattern that cannot be separated by a single line or a simple linear function.
    To capture this non-linearity, the minimal required network consists of, in addition
    to the input and output layers, a hidden layer of two neurons. In the next subsection,
    we will set out to see if NEAT can find this minimal solution.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 关于神经网络，偶校验检查，也称为**XOR问题**，已知单个感知器无法实现它，因为它形成的模式无法用一条直线或简单的线性函数分开。为了捕捉这种非线性，所需的最小网络包括输入层和输出层，外加一个包含两个神经元的隐藏层。在下一小节中，我们将设置并查看NEAT是否能找到这个最小解决方案。
- en: NEAT implementation
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NEAT实现
- en: To evolve a neural network that implements the even parity check logic using
    the NEAT technique, we’ve created a Python program called `03_neat_even_parity.py`
    at [https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_16/03_neat_even_parity.py](https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_16/03_neat_even_parity.py).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 为了利用NEAT技术演化一个实现偶校验逻辑的神经网络，我们创建了一个名为`03_neat_even_parity.py`的Python程序，存放在[https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_16/03_neat_even_parity.py](https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_16/03_neat_even_parity.py)。
- en: Python NEAT library
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Python NEAT库
- en: 'There are several capable Python libraries available that implement the NEAT
    technique, most notably the **NEAT-Python** library. However, for our example,
    we will be using the lightweight **neatpy** library, owing to its conciseness
    and ease of use. This library can be installed (if not already present) using
    the following command:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个强大的Python库实现了NEAT技术，其中最著名的是**NEAT-Python**库。然而，在我们的示例中，我们将使用轻量级的**neatpy**库，因为它简洁且易于使用。如果该库尚未安装，可以使用以下命令进行安装：
- en: '[PRE25]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In addition, the **PyGame** library is required for visualizing the progress
    of the solution. If it’s not been installed yet, it can be added using the following
    command:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，**PyGame**库是可视化解决方案进展所必需的。如果尚未安装，可以使用以下命令进行安装：
- en: '[PRE26]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Program
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 程序
- en: 'The following steps describe the main parts of this program:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤描述了该程序的主要部分：
- en: Similar to the genetic programming example, we’ll start by setting the problem-related
    constant values. **NUM_INPUTS** determines the number of inputs for the even parity
    checker.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与遗传编程示例类似，我们将首先设置与问题相关的常量值。**NUM_INPUTS**决定了偶校验检查器的输入数量。
- en: 'Since we would like to save an image with the best solution’s network structure
    at the end of the program, let’s make sure a folder for it has been created:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们希望在程序结束时保存一个包含最佳解决方案的网络结构的图像，因此需要确保已创建一个用于存放图像的文件夹：
- en: '[PRE27]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, we must set up the graphical display for the real-time “animation” of
    the algorithm’s progress by using the functionality of the *PyGame* library:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们必须使用*PyGame*库的功能设置图形显示，以实时“动画”方式展示算法的进度：
- en: '[PRE28]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Next, we must set several options for the NEAT algorithm that will be used:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们必须为NEAT算法设置几个选项：
- en: The number of inputs for our network (which would be identical to **NUM_INPUTS**).
  id: totrans-171
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们网络的输入数量（这将与**NUM_INPUTS**相同）。
- en: The number of outputs (1, in our case).
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出的数量（在我们的例子中为1）。
- en: Population size (150, in our example).
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 种群大小（在我们的例子中为150）。
- en: 'A fitness threshold. If the best solution surpasses this value, the algorithm
    considers the problem as solved and stops. As the best fitness possible is equal
    to the number of rows in the truth table (indicating we got the correct results
    for all rows), we must set the threshold to a value just under that:'
  id: totrans-174
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适应度阈值。如果最佳解决方案超过此值，算法就认为问题已解决并停止。由于最佳适应度等于真值表中的行数（表示我们对所有行得出了正确的结果），因此我们必须将阈值设置为一个略低于该值的数字：
- en: '[PRE29]'
  id: totrans-175
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Next, we must calculate **parityIn** and **parityOut** while implementing the
    inputs and outputs of the desired parity check, similar to what we did in the
    genetic programming example:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们必须在实现所需偶校验的输入和输出时计算**parityIn**和**parityOut**，这与我们在遗传编程示例中所做的类似：
- en: '[PRE30]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, it’s time to define **parityScore()**, the function that evaluates a given
    neural network (represented by the **nn** parameter). Since the score needs to
    be positive, we’ll start from the maximum score, and then subtract the square
    of the difference between each expected network output and the actual (float)
    value produced by the network:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，是时候定义**parityScore()**函数了，该函数用于评估给定的神经网络（由**nn**参数表示）。由于得分需要为正数，我们从最大得分开始，然后减去每个期望网络输出与网络实际（浮动）输出值之间差的平方：
- en: '[PRE31]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In addition, the score includes a small penalty term for each node in the network,
    giving smaller architectures an advantage:'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此外，评分还包括每个网络节点的小额惩罚项，使得较小的架构占据优势：
- en: '[PRE32]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Coming up next is another utility function, **draw_current()**. It draws the
    architecture (nodes and connections) of the current best solution by calling the
    **neatpy** library’s **draw_brain_pygame()**; in addition, it illustrates the
    *speciation* mechanism by drawing the current status of species using the **draw_species_bar_pygame()**
    function.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是另一个工具函数，**draw_current()**。它通过调用**neatpy**库的**draw_brain_pygame()**绘制当前最佳解的架构（节点和连接）；此外，它还通过使用**draw_species_bar_pygame()**函数绘制当前物种的状态，展示了*物种分化*机制。
- en: 'After creating the initial **population**, we get to the main loop of the NEAT
    algorithm. Thanks to the simplicity of the **neatpy** library, this loop is very
    concise. It starts by scoring the current population, as is the usual case for
    evolutionary algorithms:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建初始**种群**后，我们进入了NEAT算法的主循环。得益于**neatpy**库的简洁性，这个循环非常简明。它从对当前种群进行评分开始，这也是进化算法中的常见步骤：
- en: '[PRE33]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The main loop continues by calling the library’s **epoch()** function, which
    performs a single NEAT evolutionary step, resulting in a new population. Then,
    it prints out the current population and draws the current best individual, as
    well as the speciation status, by calling **draw_current()**.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 主循环通过调用库中的**epoch()**函数继续进行，这个函数执行一次NEAT进化步骤，产生新的种群。然后，它会打印当前种群，并通过调用**draw_current()**绘制当前最佳个体及物种状态。
- en: Once the loop exits, the results are printed, the truth table is checked, and
    the latest drawing is saved to an image file.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦循环退出，结果会被打印出来，真值表会被检查，最新的图形也会保存为图片文件。
- en: 'When running the program, the drawing containing the visualizations of the
    network and the speciation appears and updates itself at each generation, thereby
    creating an “animated” view of the status. The following figure contains four
    “snapshots” of the drawing that were captured during the run:'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在运行程序时，包含网络可视化和物种演化的图形会出现，并在每一代更新自身，从而创建出一个“动画”视图来显示状态。下图包含了在运行过程中捕捉的四个“快照”：
- en: '![Figure 16.6: Stages in the evolution of the NEAT solution for the three-input
    even parity check problem](img/B20851_16_6.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![图16.6：三输入偶数奇偶校验问题的NEAT解的演化阶段](img/B20851_16_6.jpg)'
- en: 'Figure 16.6: Stages in the evolution of the NEAT solution for the three-input
    even parity check problem'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.6：三输入偶数奇偶校验问题的NEAT解的演化阶段
- en: These snapshots demonstrate how the network starts with only the input and output
    layer nodes and a single species, then develops numerous species, followed by
    the addition of a single hidden layer node, and then a second one.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这些快照展示了网络如何从仅有输入层和输出层节点及一个物种开始，然后发展出多个物种，接着增加了一个隐藏层节点，再增加第二个隐藏层节点。
- en: 'At the end of the run, the program saves one last snapshot as an image under
    the `images` folder. This looks as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行结束时，程序会将最后一个快照保存为图片，保存在`images`文件夹中。如下所示：
- en: '![Figure 16.7: The final stage in the evolution of the NEAT solution for the
    three-input even parity check problem](img/B20851_16_7.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![图16.7：三输入偶数奇偶校验问题的NEAT解的最终演化阶段](img/B20851_16_7.jpg)'
- en: 'Figure 16.7: The final stage in the evolution of the NEAT solution for the
    three-input even parity check problem'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.7：三输入偶数奇偶校验问题的NEAT解的最终演化阶段
- en: In the drawings, the white circles represent the nodes of the network, except
    for the top left circle, which is used to represent the *bias* values of the hidden
    and output layer nodes. The blue edges represent connections of positive weight
    (or a positive bias value), while the orange edges represent negative weights
    (or bias values). Unlike traditional MLPs, the networks created by the NEAT algorithm
    can have connections that “skip” a layer, such as the orange edge connecting the
    bottom input node directly to the output node, as well as intra-layer connections.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在图示中，白色圆圈代表网络的节点，左上角的圆圈表示隐藏层和输出层节点的*偏置*值。蓝色边代表正权重（或正偏置值）连接，而橙色边代表负权重（或负偏置值）连接。与传统的MLP不同，NEAT算法创建的网络可以有“跳跃”某一层的连接，例如橙色边直接将底部输入节点连接到输出节点，以及层内连接。
- en: 'The printed output of the program indicates that the best network that was
    found was able to solve the problem:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的打印输出显示，找到的最佳网络能够解决问题：
- en: '[PRE34]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As we can see, the best architecture that was found included a single hidden
    layer of two nodes.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，找到的最佳架构包括一个包含两个节点的单一隐藏层。
- en: In the next section, we will examine another biologically inspired, population-based
    algorithm. However, this algorithm deviates from using the familiar genetic operators
    of selection, crossover, and mutation, and instead utilizes a different set of
    rules to modify the population at each generation – welcome to the world of swarm
    behavior!
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将研究另一个受生物启发的基于群体的算法。然而，这个算法偏离了使用传统的选择、交叉和变异基因操作符，而是采用了一套不同的规则，在每一代中修改种群——欢迎来到群体行为的世界！
- en: Particle swarm optimization
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 粒子群优化
- en: '**Particle swarm optimization** (**PSO**) draws its inspiration from natural
    groupings of individual organisms, such as flocks of birds or schools of fish,
    generally referred to as *swarms*. The organisms interact within the swarm without
    central supervision, working together toward a common goal. This observed behavior
    gave rise to a computational method that can solve or optimize a given problem
    by using a group of candidate solutions, represented by *particles* analogous
    to organisms in a swarm. The particles move in the search space, looking for the
    best solution, and their movement is governed by simple rules that involve their
    position and *velocity* (directional speed).'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '**粒子群优化**（**PSO**）的灵感来源于自然界中个体有机体的群体，例如鸟群或鱼群，通常称为*群体*。这些有机体在没有中央监督的情况下在群体中相互作用，共同朝着一个共同的目标努力。这种观察到的行为催生了一种计算方法，可以通过使用一组候选解来解决或优化给定问题，这些候选解由类似于群体中有机体的*粒子*表示。粒子在搜索空间中移动，寻找最佳解，它们的移动遵循简单的规则，这些规则涉及它们的位置和*速度*（方向速度）。'
- en: 'The PSO algorithm is iterative, and in each iteration, every particle’s position
    gets evaluated, and its best location so far, as well as the best location within
    the entire group of particles, are updated if necessary. Then, each particle’s
    velocity is updated according to the following information:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: PSO算法是迭代的，每次迭代中，都会评估每个粒子的位置，并在必要时更新其迄今为止的最佳位置，以及整个粒子群体中的最佳位置。然后，按照以下信息更新每个粒子的速度：
- en: The particle’s current speed and direction of movement – representing *inertia*
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 粒子当前的速度和运动方向——代表*惯性*
- en: The particle’s best position found so far (local best) – representing *cognitive
    force*
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 粒子迄今为止找到的最佳位置（局部最佳）——代表*认知力*
- en: The entire group’s best position found so far (global best) – representing *social
    force*
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整个群体迄今为止找到的最佳位置（全局最佳）——代表*社会力*
- en: This is followed by an update to the particle’s position, based on the newly
    calculated velocity.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，根据新计算的速度更新粒子的位置。
- en: This iterative process continues until some stopping condition, such as the
    *iterations limit*, is met. At this point, the group’s current best position is
    taken as the solution by the algorithm.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这个迭代过程持续进行，直到满足某个停止条件，例如*迭代次数限制*。此时，算法将当前群体的最佳位置作为解。
- en: This simple yet efficient process will be illustrated in detail in the next
    section, where we will go over a program that optimizes a function using the PSO
    algorithm.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单但高效的过程将在下一节中详细说明，我们将讨论一个使用PSO算法优化函数的程序。
- en: PSO example – function optimization
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PSO示例——函数优化
- en: 'For demonstration purposes, we will use the PSO algorithm to find the minimum
    location(s) of *Himmelblau’s function*, a commonly used benchmark that we previously
    optimized using genetic algorithms in [*Chapter 6*](B20851_06.xhtml#_idTextAnchor197),
    *Optimizing Continuous Functions*. This function can be depicted as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示，我们将使用粒子群优化算法来寻找*Himmelblau函数*的最小位置，这个函数是一个常用的基准，之前我们在[*第6章*](B20851_06.xhtml#_idTextAnchor197)中使用遗传算法进行了优化，标题为*优化连续函数*。这个函数可以表示如下：
- en: '![Figure 16.8: Himmelblau’s function](img/B20851_16_08.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![图16.8：Himmelblau函数](img/B20851_16_08.jpg)'
- en: 'Figure 16.8: Himmelblau’s function'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.8：Himmelblau函数
- en: 'Source: [https://commons.wikimedia.org/wiki/File:Himmelblau_function.svg](https://commons.wikimedia.org/wiki/File:Himmelblau_function.svg)'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 来源：[https://commons.wikimedia.org/wiki/File:Himmelblau_function.svg](https://commons.wikimedia.org/wiki/File:Himmelblau_function.svg)
- en: Image by Morn the Gorn.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 图片由Morn the Gorn提供。
- en: 'As a reminder, the function can be mathematically expressed as follows:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 提醒一下，这个函数可以通过数学公式表达如下：
- en: f(x, y) = (x 2 + y − 11) 2 + (x + y 2 − 7) 2
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: f(x, y) = (x 2 + y − 11) 2 + (x + y 2 − 7) 2
- en: 'It has four global minima, evaluating to 0, indicated by the blue areas in
    the plot. These are located at the following coordinates:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 它有四个全局最小值，评估结果为0，图中用蓝色区域表示。这些最小值位于以下坐标：
- en: '*x=3.0, y=2.0*'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*x=3.0, y=2.0*'
- en: '*x=−2.805118, y=3.131312*'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*x=−2.805118, y=3.131312*'
- en: '*x=−3.779310, y=−3.283186*'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*x=−3.779310, y=−3.283186*'
- en: '*x=3.584458, y=−1.848126*'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*x=3.584458, y=−1.848126*'
- en: For our example, we will attempt to find any one of these minima.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们将尝试找到这些最小值中的任何一个。
- en: Particle swarm optimization implementation
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 粒子群优化实现
- en: To locate a minimum of *Himmelblau’s function* using particle swarm optimization,
    we’ve created a Python program called `04_pso_himmelblau.py` at [https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_16/04_pso_himmelblau.py](https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_16/04_pso_himmelblau.py).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用粒子群优化算法定位*Himmelblau函数*的最小值，我们创建了一个名为`04_pso_himmelblau.py`的Python程序，地址：[https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_16/04_pso_himmelblau.py](https://github.com/PacktPublishing/Hands-On-Genetic-Algorithms-with-Python-Second-Edition/blob/main/chapter_16/04_pso_himmelblau.py)。
- en: 'The following steps describe the main parts of this program:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤描述了程序的主要部分：
- en: 'We start by setting various constants that will be used throughout the program.
    First, we have the *dimensionality* of the problem at hand – **2**, in our case
    – which, in turn, determines the dimensionality of the *location* and *velocity*
    of each particle. Next comes the population size – the total number of particles
    in the swarm – and the number of generations, or iterations, of running the algorithm:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先设置程序中将使用的各种常量。首先，我们有当前问题的*维度*—在我们这里是**2**—它决定了每个粒子的*位置*和*速度*的维度。接下来是种群大小——即群体中粒子的总数——以及运行算法的代数或迭代次数：
- en: '[PRE35]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This is followed by several additional constants that affect how the particles
    are created and updated. We will see how they play their roles as we examine the
    rest of the program:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后是一些额外的常量，它们影响粒子的创建和更新。我们将在分析程序的其余部分时看到它们的作用：
- en: '[PRE36]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Since our goal is to locate a minimum in *Himmelblau’s function*, we need to
    define a single objective – that is, minimizing the fitness strategy:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们的目标是定位*Himmelblau函数*的最小值，我们需要定义一个单一目标——即，最小化适应度策略：
- en: '[PRE37]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: creator.create("Particle",
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: creator.create("Particle",
- en: np.ndarray,
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: np.ndarray,
- en: fitness=creator.FitnessMin,
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: fitness=creator.FitnessMin,
- en: speed=None,
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: speed=None,
- en: best=None)
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: best=None)
- en: '[PRE38]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'To help us construct an individual particle in the population, we need to define
    a helper function that will create and initialize a random particle. We will use
    the **numpy** library’s **random.uniform()** function to randomly generate the
    location and speed arrays of the new particle, within the given boundaries:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了帮助我们构建种群中的单个粒子，我们需要定义一个辅助函数，用于创建并初始化一个随机粒子。我们将使用**numpy**库的**random.uniform()**函数，随机生成新粒子的位置信息和速度数组，在给定的边界范围内：
- en: '[PRE39]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This function is used in the definition of the operator that creates a particle
    instance. This, in turn, is used by the population creation operator:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该函数用于定义创建粒子实例的操作符。这反过来被种群创建操作符使用：
- en: '[PRE40]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Next comes the method that serves as the heart of the algorithm, `ndarray` type
    are *two- dimensional* in our case, and the calculations are performed element-wise,
    one per dimension.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是作为算法核心的方法，在我们这里，`ndarray`类型是*二维*的，计算是逐元素进行的，每次处理一个维度。
- en: 'The updated particle speed is effectively a combination of the particle’s original
    speed (representing *inertia*), the particle’s best-known location (*cognitive
    force*), and the best-known location of the entire population (*social force*):'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新后的粒子速度实际上是粒子原始速度（代表*惯性*）、粒子已知的最佳位置（*认知力*）和整个群体的最佳已知位置（*社交力*）的结合：
- en: '[PRE41]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The **updateParticle()** method continues by making sure that the new speed
    does not exceed the preset limits and updates the location of the particles using
    the updated speed. As we mentioned previously, both **location** and **speed**
    are of the **ndarray** type and have separate components for each dimension:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**updateParticle()**方法继续执行，确保新的速度不超过预设的限制，并使用更新后的速度更新粒子的位置。如前所述，**位置**和**速度**都是**ndarray**类型，并且每个维度都有单独的组件：'
- en: '[PRE42]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Then, we must register the **updateParticle()** method as a toolbox operator
    that will be in the main loop later:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们必须将**updateParticle()**方法注册为工具箱操作符，该操作符将在后续的主循环中使用：
- en: '[PRE43]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We still need to define the function to be optimized – *Himmelblau’s function*,
    in our case – and register it as the fitness evaluation operator:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们仍然需要定义要优化的函数——在我们的例子中是*Himmelblau函数*——并将其注册为适应度评估操作符：
- en: '[PRE44]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now that we’re finally at the **main()** method, we can start it by creating
    the population of particles:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们终于到达了**main()**方法，可以通过创建粒子群体来开始它：
- en: '[PRE45]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Before starting the algorithm’s main loop, we need to create the **stats**
    object, to calculate the population’s statistics, and the **logbook** object,
    to record the statistics at every iteration:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在开始算法的主循环之前，我们需要创建**stats**对象，用于计算群体的统计数据，以及**logbook**对象，用于记录每次迭代的统计数据：
- en: '[PRE46]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The program’s main loop contains an external loop that iterates over the generations/update
    cycles. Within each iteration, there are two secondary loops, each iterating over
    all the particles in the population. The first loop, which can be seen in the
    following code, evaluates each particle against the function to be optimized and
    updates the *local best* and the *global best* if necessary:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 程序的主循环包含一个外部循环，用于迭代生成/更新周期。在每次迭代中，有两个内部循环，每个循环遍历群体中的所有粒子。第一个循环，如下代码所示，评估每个粒子与要优化的函数的关系，并在必要时更新*局部最佳*和*全局最佳*：
- en: '[PRE47]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The second inner loop calls the **update** operator. As we saw previously,
    this operator updates the speed and the location of the particle using a combination
    of *inertia*, *cognitive force*, and *social force*:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个内部循环调用**update**操作符。如前所述，该操作符使用*惯性*、*认知力*和*社交力*的结合来更新粒子的速度和位置：
- en: '[PRE48]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'At the end of the outer loop, we record the statistics for the current generation
    and print them:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在外部循环结束时，我们记录当前代的统计数据并将其打印出来：
- en: '[PRE49]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Once the outer loop is done, we print the information for the best location
    that was recorded during the run. This is considered the solution that the algorithm
    has found for the problem at hand:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦外部循环完成，我们会打印出在运行过程中记录的最佳位置的信息。这被认为是算法为当前问题找到的解决方案：
- en: '[PRE50]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'By running this program, we get the following output:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此程序后，我们得到如下输出：
- en: '[PRE51]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: These results indicate that the algorithm was able to locate one of the minima,
    around x=−3.77 and y=−3.28\. Looking at the stats we recorded along the way, we
    can see that the best result was achieved at generation 480\. It is also evident
    that the particles move around quite a bit and, during the run, oscillate about
    the best result.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这些结果表明，算法能够定位到一个最小值，大约位于x=−3.77和y=−3.28。通过查看我们在过程中记录的统计数据，我们可以看到最佳结果是在第480代时获得的。还可以明显看出，粒子在过程中有较大的移动，并在运行期间围绕最佳结果进行振荡。
- en: To find the other minimum locations, you can rerun the algorithm with a different
    random seed. You can also penalize the solutions in the areas around the previously
    found minima, just like we did with *Simionescu’s function* in [*Chapter 6*](B20851_06.xhtml#_idTextAnchor197),
    *Optimizing Continuous Functions*. Another approach could be using multiple simultaneous
    swarms to locate several minima in the same run – you are encouraged to try this
    on your own (see the *Further reading* section for more information).
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找到其他最小值位置，您可以使用不同的随机种子重新运行算法。您还可以像我们在[第*6章*](B20851_06.xhtml#_idTextAnchor197)中对*Simionescu函数*所做的那样，对已找到的最小值周围的区域进行惩罚，*优化连续函数*。另一种方法是使用多个同时进行的群体来在同一次运行中找到多个最小值——我们鼓励您自己尝试一下（有关更多信息，请参阅*进一步阅读*部分）。
- en: In the next section, we will briefly review several more members of the extended
    evolutionary computation family.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将简要回顾扩展进化计算家族中的其他几种成员。
- en: Other related techniques
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他相关技术
- en: Besides the techniques we have covered so far, numerous other problem-solving
    and optimization techniques draw their inspiration from the Darwinian evolution
    theory, as well as from various biological systems and behaviors. The following
    subsections briefly describe several more of these techniques.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们目前所讨论的技术外，还有许多其他的求解和优化技术，其灵感来源于达尔文进化理论，以及各种生物系统和行为。以下小节将简要介绍其中几种技术。
- en: Evolution strategies
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进化策略
- en: '**Evolution strategies** (**ES**) are a kind of genetic algorithm that emphasizes
    *mutation* rather than *crossover* as the evolutionary facilitator. The mutation
    is adaptive, and its strength is learned over the generations. The selection operator
    in ES is always based on *rank* rather than on actual fitness values. A simple
    version of this technique is called *(1 + 1)*. It includes only two individuals
    – a parent and its mutated offspring. The best of them continue to be the parent
    of the next mutated offspring. In the more general case, called *(1 + λ)*, there
    is one parent and λ mutated offspring, and the best of the offspring continues
    to be the parent of the next λ offspring. Some newer variations of the algorithm
    include more than one parent, as well as a *crossover* operator.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '**进化策略**（**ES**）是一种强调*变异*而非*交叉*作为进化驱动因素的遗传算法。变异是自适应的，其强度会随着世代的推移进行学习。ES中的选择操作符始终是基于*排名*而非实际的适应度值。该技术的一个简单版本叫做*(1
    + 1)*，它仅包括两个个体——一个父代和其变异后的后代。最优秀的个体将继续作为下一个变异后代的父代。在更一般的情况下，称为*(1 + λ)*，它包括一个父代和λ个变异后的后代，最优秀的后代将继续作为下一个λ个后代的父代。一些新的算法变种包括多个父代，并且有一个*交叉*操作符。'
- en: Differential evolution
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 差分进化
- en: '**Differential evolution** (**DE**) is a specialized variant of genetic algorithms
    that’s used to optimize real-valued functions. DE differs from genetic algorithms
    in the following aspects:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '**差分进化**（**DE**）是遗传算法的一个专门变种，用于优化实数值函数。DE与遗传算法的区别在于以下几个方面：'
- en: The DE population is always represented as a collection of real-valued vectors.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DE种群始终表示为实值向量的集合。
- en: Instead of replacing the entire current generation with a new generation, DE
    keeps iterating over the population, modifying one individual at a time, or keeping
    the original individual if it’s better than its modified version.
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与其用新一代完全替换当前的整代，DE更倾向于在种群中不断迭代，每次修改一个个体，或者如果修改后的个体不如原个体，则保留原个体。
- en: The traditional *crossover* and *mutation* operators are replaced by specialized
    ones, thereby modifying the value of the current individual using the values of
    three other individuals that are chosen at random.
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传统的*交叉*和*变异*操作符被专门的操作符所替代，从而通过随机选择的三只个体的值来修改当前个体的值。
- en: Ant colony optimization
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 蚁群优化
- en: '**Ant colony optimization** (**ACO**) algorithms are inspired by the way certain
    species of ants locate food. The ants start by wandering randomly, and when any
    of them locates food, they go back to their colony while depositing pheromones
    along the way, marking the path for other ants. Other ants finding food at the
    same location will reinforce the trail by depositing their own pheromones. The
    pheromone marks fade away over time, giving the shorter paths and the paths that
    are traveled more often an advantage.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '**蚁群优化**（**ACO**）算法的灵感来源于某些蚂蚁寻找食物的方式。蚂蚁们首先随机游走，当其中一只找到食物时，它们会回到巢穴并在路上留下信息素，标记出路径供其他蚂蚁参考。其他蚂蚁如果在相同位置找到食物，就会通过留下自己的信息素来加强这条路径。信息素标记随着时间的推移逐渐消失，因此较短的路径和经过频繁使用的路径更具优势。'
- en: ACO algorithms use artificial ants that move about in the search space looking
    for the location of the best solutions. The “ants” keep track of their locations
    and the candidate solutions they have found along the way. This information is
    used by the ants of the subsequent iterations so that they can find better solutions.
    These algorithms are often combined with the *local search* method, which is activated
    after locating an area of interest.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: ACO算法使用人工蚂蚁在搜索空间中寻找最佳解的位置。这些“蚂蚁”会跟踪它们的当前位置以及它们在过程中找到的候选解。这些信息被后续迭代中的蚂蚁利用，从而帮助它们找到更好的解。通常，这些算法会与*局部搜索*方法结合使用，在找到感兴趣区域后激活局部搜索。
- en: Artificial immune systems
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 人工免疫系统
- en: '**Artificial immune systems** (**AIS**) draw their inspiration from the characteristics
    of adaptive immune systems found in mammals. These systems are capable of identifying
    and learning new threats, as well as applying the acquired knowledge and responding
    faster the next time a similar threat is detected.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '**人工免疫系统**（**AIS**）的灵感来源于哺乳动物适应性免疫系统的特性。这些系统能够识别和学习新威胁，并且应用所学知识，下一次类似威胁出现时能更快作出反应。'
- en: 'Recent AIS can be used in various machine learning and optimization tasks,
    and generally belong to one of the following three subfields:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 最近的AIS可以用于各种机器学习和优化任务，通常属于以下三大子领域之一：
- en: '**Clonal selection**: This involves imitating the process by which the immune
    system selects the best cell to recognize and eliminate an antigen that enters
    the body. The cell is chosen out of a pool of pre-existing cells with varying
    specificities, and once chosen, it is cloned to create a population of cells that
    eliminates the invading antigen. This paradigm is typically applied to optimization
    and pattern recognition tasks.'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**克隆选择**：这模仿了免疫系统选择最佳细胞来识别并消除入侵抗原的过程。细胞是从一池具有不同特异性的预存细胞中选出的，选中后被克隆以创建一个能够消除入侵抗原的细胞群体。这一范式通常应用于优化和模式识别任务。'
- en: '**Negative selection**: This follows a process that identifies and deletes
    cells that may attack self-tissues. These algorithms are typically used in anomaly
    detection tasks, where normal patterns are used to “negatively” train filters
    that will then be able to detect anomalous patterns.'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**负选择**：这一过程旨在识别并删除可能攻击自体组织的细胞。这些算法通常用于异常检测任务，其中通过正常模式“负向”训练过滤器，从而能够检测异常模式。'
- en: '**Immune network algorithms**: This is inspired by the theory that suggests
    that the immune system is regulated using special types of antibodies that bind
    to other antibodies. In this type of algorithm, antibodies represent nodes in
    a network and the learning process involves creating or removing edges between
    the nodes, resulting in an evolving network graph structure. These algorithms
    are typically used in non-supervised machine learning tasks, as well as in the
    fields of control and optimization.'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**免疫网络算法**：这受到免疫系统使用特定类型抗体与其他抗体结合来调节的理论启发。在这种算法中，抗体代表网络中的节点，学习过程涉及在节点之间创建或删除边，从而形成一个不断演化的网络图结构。这些算法通常用于无监督机器学习任务，以及控制和优化领域。'
- en: Artificial life
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 人工生命
- en: Rather than being a branch of evolutionary computation, **artificial life**
    (**ALife**) is a broader field that involves systems and processes that imitate
    natural life in different ways, such as computer simulations and robotic systems.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '**人工生命**（**ALife**）不是进化计算的一个分支，而是一个更广泛的领域，涉及以不同方式模拟自然生命的系统和过程，如计算机仿真和机器人系统。'
- en: Evolutionary computation can be viewed as an application of ALife, where the
    population seeking to optimize a certain fitness function is a metaphor for organisms
    searching for food. The niching and sharing mechanisms, which we described in
    [*Chapter 2*](B20851_02.xhtml#_idTextAnchor053), *Understanding the Key Components
    of Genetic Algorithms*, draw directly from the food metaphor.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 进化计算可以被视为人工生命（ALife）的应用，其中寻求优化某一适应度函数的种群可以看作是寻找食物的生物体。这些在[*第二章*](B20851_02.xhtml#_idTextAnchor053)中描述的“共享和分配机制”，*理解遗传算法的关键组件*，直接源自于食物隐喻。
- en: 'The main branches of ALife are as follows:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 人工生命的主要分支如下：
- en: '**Soft**: Represents software-based (digital) simulation'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**软**：代表基于软件的（数字）仿真'
- en: '**Hard**: Represents hardware-based (physical) robotics'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**硬**：代表基于硬件的（物理）机器人技术'
- en: '**Wet**: Represents biochemical-based manipulation or synthetic biology'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**湿**：代表基于生化操作或合成生物学的技术'
- en: ALife can also be viewed as the bottom-up counterpart to artificial intelligence
    since ALife typically builds on the biological environment, mechanisms, and structures
    rather than high-level cognition.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 人工生命也可以被看作是人工智能的自下而上的对应物，因为人工生命通常基于生物环境、机制和结构，而不是高层次的认知。
- en: Summary
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you were introduced to the extended family of *evolutionary
    computation* and some of the common characteristics of its members. Then, we used
    *genetic programming* – a special case of genetic algorithms – to implement the
    *even parity check* task using Boolean logic building blocks.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你了解了*进化计算*的扩展家族以及其成员的一些常见特征。然后，我们使用*遗传编程*——遗传算法的一个特例——通过布尔逻辑构建块实现了*偶校验检查*任务。
- en: Next, we created a neural network implementation of the same even parity check
    task by utilizing the NEAT technique.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过使用NEAT技术，创建了一个神经网络实现，用于相同的偶校验任务。
- en: This was followed by creating a program that utilized the *particle swarm optimization*
    technique to optimize *Himmelblau’s function*.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建了一个程序，利用*粒子群优化*技术来优化*Himmelblau函数*。
- en: We concluded this chapter with a brief overview of several other related problem-solving
    techniques.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以简要概述其他几种相关的解决问题技巧结束了这一章。
- en: Now that this book has come to its end, I wanted to thank you for taking this
    journey with me while going through the various aspects and use cases of genetic
    algorithms and evolutionary computation. I hope that you found this book interesting
    as well as thought-provoking. As this book demonstrated, genetic algorithms and
    their related techniques can be applied to a plethora of tasks in virtually any
    computation and engineering field, including – very likely – the ones you are
    currently involved with. Remember, all that is required for the genetic algorithm
    to start crunching a problem is a way to represent a solution and a way to evaluate
    a solution – or compare two solutions. Since this is the age of artificial intelligence
    and cloud computing, you will find that genetic algorithms lend themselves well
    to both and can be a powerful tool in your arsenal when you’re approaching a new
    challenge.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这本书已经结束，我想感谢你在我带领下共同探索遗传算法和进化计算的各个方面和应用案例。我希望你发现这本书既有趣又发人深省。正如本书所示，遗传算法及其相关技术可以应用于几乎任何计算和工程领域的众多任务，包括——很可能——你当前涉及的领域。记住，遗传算法开始处理问题所需要的只是表示解决方案的方式和评估解决方案的方式——或者比较两个解决方案的方式。既然这是人工智能和云计算的时代，你会发现遗传算法在这两者方面都有很好的应用，可以成为你解决新挑战时的强大工具。
- en: Further reading
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For more information, please refer to the following resources:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 欲了解更多信息，请参考以下资源：
- en: '*Genetic Programming: bio-inspired machine* *learning*: [http://geneticprogramming.com/tutorial/](http://geneticprogramming.com/tutorial/)'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*遗传编程：生物启发的机器* *学习*：[http://geneticprogramming.com/tutorial/](http://geneticprogramming.com/tutorial/)'
- en: '*Artificial Intelligence for Big Data*, by Manish Kumar and Anand Deshpande,
    May 21, 2018'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*大数据中的人工智能*，作者：Manish Kumar 和 Anand Deshpande，2018年5月21日'
- en: '*Hands-On Neuroevolution with Python*, by Iaroslav Omelianenko, December 24,
    2019'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Python神经进化实践*，作者：Iaroslav Omelianenko，2019年12月24日'
- en: '*Multimodal optimization using particle swarm optimization algorithms*: CEC
    2015 competition on single objective multi-niche optimization: [https://ieeexplore.ieee.org/document/7257009](https://ieeexplore.ieee.org/document/7257009)'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用粒子群优化算法的多模态优化*：CEC 2015 单目标多小 niche 优化竞赛：[https://ieeexplore.ieee.org/document/7257009](https://ieeexplore.ieee.org/document/7257009)'
