- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Testing an API Asynchronously with pytest and HTTPX
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 pytest 和 HTTPX 异步测试 API
- en: In software development, a significant part of the developer’s work should be
    dedicated to writing tests. At first, you may be tempted to manually test your
    application by running it, making a few requests, and arbitrarily deciding that
    “everything works.” However, this approach is flawed and can’t guarantee that
    your program works in every circumstance and that you didn’t break things along
    the way.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件开发中，开发者的工作中很大一部分应当专注于编写测试。一开始，你可能会倾向于通过手动运行应用程序，发起一些请求，并随意决定“所有功能都正常”，来测试你的应用程序。然而，这种做法是有缺陷的，无法保证程序在各种情况下都能正常工作，并且无法确保你在开发过程中没有引入新问题。
- en: 'That’s why several disciplines have emerged regarding software testing: unit
    tests, integration tests, end-to-end tests, acceptance tests, and others. These
    techniques aim to validate the functionality of software from a micro level, where
    we test single functions (unit tests), to a macro level, where we test a global
    feature that delivers value to the user (acceptance tests). In this chapter, we’ll
    focus on the first level: unit testing.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 正因如此，软件测试领域出现了多个分支：单元测试、集成测试、端到端测试、验收测试等。这些技术旨在从微观层面验证软件的功能，在单元测试中我们验证单个函数的正确性；而在宏观层面，我们验证能够为用户提供价值的整体功能（如验收测试）。在本章中，我们将聚焦于第一个层次：单元测试。
- en: 'Unit tests are short programs designed to verify that our code behaves the
    way it should in every circumstance. You may think that tests are time-consuming
    to write and that they don’t add value to your software, but this will save you
    time in the long run: first of all, tests can be run automatically in a few seconds,
    ensuring that all your software works, without you needing to manually go over
    every feature. Secondly, when you introduce new features or refactor the code,
    you’re ensuring that you don’t introduce bugs to existing parts of the software.
    In conclusion, tests are just as important as the program itself, and they help
    you deliver reliable and high-quality software.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试是用于验证我们编写的代码在每种情况下都能按预期行为运行的简短程序。你可能会认为编写测试非常耗时，并且它们对软件没有附加价值，但从长远来看，它将节省你的时间：首先，测试可以自动在几秒钟内运行，确保你的所有软件功能正常，而不需要你手动逐个检查每个功能。其次，当你引入新功能或重构代码时，确保不会向现有功能中引入错误。总之，测试和程序本身一样重要，它们帮助你交付可靠且高质量的软件。
- en: In this chapter, you’ll learn how to write tests for your FastAPI application,
    both for HTTP endpoints and WebSockets. To help with this, you’ll learn how to
    configure pytest, a well-known Python test framework, and HTTPX, an asynchronous
    HTTP client for Python.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何为你的 FastAPI 应用程序编写测试，包括 HTTP 端点和 WebSockets。为此，你将学习如何配置 pytest，一个知名的
    Python 测试框架，以及 HTTPX，一个用于 Python 的异步 HTTP 客户端。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: An introduction to unit testing with pytest
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 pytest 进行单元测试简介
- en: Setting up the testing tools for FastAPI with HTTPX
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 FastAPI 设置 HTTPX 测试工具
- en: Writing tests for REST API endpoints
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 REST API 端点编写测试
- en: Writing tests for WebSocket endpoints
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 WebSocket 端点编写测试
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, you’ll require a Python virtual environment, just as we set
    up in [*Chapter 1*](B19528_01.xhtml#_idTextAnchor024), *Python Development* *Environment
    Setup*.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章内容，你需要一个 Python 虚拟环境，正如我们在[*第 1 章*](B19528_01.xhtml#_idTextAnchor024)中设置的那样，*Python
    开发环境设置*。
- en: 'For the *Communicating with a MongoDB database using Motor* section, you’ll
    need a running MongoDB server on your local computer. The easiest way to do this
    is to run it as a Docker container. If you’ve never used Docker before, we recommend
    that you refer to the *Getting started* tutorial in the official documentation
    at [https://docs.docker.com/get-started/](https://docs.docker.com/get-started/).
    Once you have done this, you’ll be able to run a MongoDB server using this simple
    command:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 对于*使用 Motor 与 MongoDB 数据库通信*部分，你需要在本地计算机上运行一个 MongoDB 服务器。最简单的方式是通过 Docker 容器来运行。如果你从未使用过
    Docker，建议参考官方文档中的*入门教程*，网址为[https://docs.docker.com/get-started/](https://docs.docker.com/get-started/)。完成这一步后，你可以使用以下简单命令来运行
    MongoDB 服务器：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The MongoDB server instance will then be available on your local computer at
    port `27017`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB 服务器实例将通过本地计算机上的端口`27017`提供服务。
- en: You’ll find all the code examples of this chapter in the dedicated GitHub repository
    at [https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在本章节专用的 GitHub 仓库中找到所有代码示例，地址为 [https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09)。
- en: An introduction to unit testing with pytest
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 pytest 进行单元测试简介
- en: As we mentioned in the introduction, writing unit tests is an essential task
    in software development to deliver high-quality software. To help us be productive
    and efficient, a lot of libraries exist that provide tools and shortcuts dedicated
    to testing. In the Python standard library, a module exists for unit testing called
    `unittest`. Even though it’s quite common in Python code bases, many Python developers
    tend to prefer pytest, which provides a more lightweight syntax and powerful tools
    for advanced use cases.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在介绍中提到的，编写单元测试是软件开发中的一项重要任务，旨在交付高质量的软件。为了提高我们的工作效率，许多库提供了专门用于测试的工具和快捷方式。在
    Python 标准库中，有一个用于单元测试的模块，叫做`unittest`。尽管它在 Python 代码库中非常常见，但许多 Python 开发者倾向于使用
    pytest，因为它提供了更轻量的语法和强大的高级工具。
- en: 'In the following examples, we’ll write a unit test for a function called `add`,
    both with `unittest` and pytest, so that you can see how they compare on a basic
    use case. First, we’ll install pytest:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的示例中，我们将为一个名为`add`的函数编写单元测试，分别使用`unittest`和pytest，以便你能比较它们在基本用例中的表现。首先，我们来安装
    pytest：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, let’s see our simple `add` function, which simply performs an addition:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下我们的简单`add`函数，它只是执行加法操作：
- en: chapter09_introduction.py
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: chapter09_introduction.py
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_introduction.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_introduction.py)'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_introduction.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_introduction.py)'
- en: 'Now, let’s implement a test that checks that *2 + 3* is indeed equal to *5*
    with `unittest`:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们用`unittest`实现一个测试，检查*2 + 3*是否确实等于*5*：
- en: chapter09_introduction_unittest.py
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: chapter09_introduction_unittest.py
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_introduction_unittest.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_introduction_unittest.py)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_introduction_unittest.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_introduction_unittest.py)'
- en: As you can see, `unittest` expects us to define a class inheriting from `TestCase`.
    Then, each test lives in its own method. To assert that two values are equal,
    we must use the `assertEqual` method.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`unittest`要求我们定义一个继承自`TestCase`的类。然后，每个测试都在自己的方法中。要断言两个值是否相等，我们必须使用`assertEqual`方法。
- en: 'To run this test, we can call the `unittest` module from the command line and
    pass it through the dotted path to our test module:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行这个测试，我们可以从命令行调用`unittest`模块，并通过点路径传递给我们的测试模块：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the output, each successful test is represented by a dot. If one or several
    tests are not successful, you will get a detailed error report for each, highlighting
    the failing assertion. You can try it by changing the assertion in the test.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出中，每个成功的测试由一个点表示。如果一个或多个测试没有成功，你将收到每个测试的详细错误报告，突出显示失败的断言。你可以通过更改测试中的断言来尝试修复问题。
- en: 'Now, let’s write the same test with pytest:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们用 pytest 来编写相同的测试：
- en: chapter09_introduction_pytest.py
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: chapter09_introduction_pytest.py
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_introduction_pytest.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_introduction_pytest.py)'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_introduction_pytest.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_introduction_pytest.py)'
- en: 'As you can see, it’s much shorter! Indeed, with pytest, you don’t necessarily
    have to define a class: a simple function is enough. The only constraint to making
    it work is that the function name has to start with `test_`. This way, pytest
    can automatically discover the test functions. Secondly, it relies on the built-in
    `assert` statement instead of specific methods, allowing you to write comparisons
    more naturally.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这样简短多了！事实上，在 pytest 中，你不一定需要定义一个类：一个简单的函数就足够了。唯一的约束是函数名称必须以 `test_`
    开头。这样，pytest 就可以自动发现测试函数。其次，它依赖于内置的 `assert` 语句，而不是特定的方法，这让你能够更自然地编写比较。
- en: 'To run this test, we must simply call the `pytest` executable with the path
    to our test file:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行这个测试，我们只需调用 `pytest` 可执行文件并指定测试文件的路径：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Once again, the output represents each successful test with a dot. Of course,
    if you change the test to make it fail, you’ll get a detailed error for the failing
    assertion.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，输出使用一个点表示每个成功的测试。当然，如果你修改了测试使其失败，你将获得失败断言的详细错误信息。
- en: It’s worth noting that if you run pytest without any arguments, it’ll automatically
    discover all the tests living in your project, as long as their name starts with
    `test_`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，如果你在没有任何参数的情况下运行 pytest，它将自动发现你项目中所有的测试，只要它们的名称以 `test_` 开头。
- en: Here, we made a small comparison between `unittest` and pytest. For the rest
    of this chapter, we’ll stick with pytest, which should give you a more productive
    experience while writing tests.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们对 `unittest` 和 pytest 做了一个小的比较。在本章的剩余部分，我们将继续使用 pytest，它应该能为你提供更高效的测试体验。
- en: 'Before focusing on FastAPI testing, let’s review two of the most powerful features
    of pytest: `parametrize` and fixtures.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在专注于 FastAPI 测试之前，让我们复习一下 pytest 的两个最强大的功能：`parametrize` 和 fixtures。
- en: Generating tests with parametrize
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 parametrize 生成测试
- en: 'In our previous example, with the `add` function, we only tested one addition
    test, *2 + 3*. Most of the time, we’ll want to check for more cases to ensure
    our function works in every circumstance. Our first approach could be to add more
    assertions to our test, like so:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的例子中，使用 `add` 函数时，我们只测试了一个加法测试，*2 + 3*。大多数时候，我们会希望检查更多的情况，以确保我们的函数在各种情况下都能正常工作。我们第一步的做法可能是向测试中添加更多断言，例如：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'While working, this method has two drawbacks: first, it may be a bit cumbersome
    to write the same assertion several times with only some parameters changing.
    In this example, it’s not too bad, but tests can be way more complex, as we’ll
    see with FastAPI. Second, we still only have one test: the first failing assertion
    will stop the test and the following ones won’t be executed. Thus, we’ll only
    know the result if we fix the failing assertion first and run the test again.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际工作中，这种方法有两个缺点：首先，写下多次相同的断言可能有些繁琐，尤其是只有一些参数发生变化的情况下。在这个例子中不算太糟，但测试可能会变得更复杂，正如我们在
    FastAPI 中将看到的那样。其次，我们仍然只有一个测试：第一个失败的断言会停止测试，之后的断言将不会被执行。因此，只有在我们先修复失败的断言并重新运行测试后，我们才会知道结果。
- en: To help with this specific task, pytest provides the `parametrize` marker. In
    pytest, a **marker** is a special decorator that’s used to easily pass metadata
    to the test. Special behaviors can then be implemented, depending on the markers
    used by the test.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助完成这一特定任务，pytest 提供了 `parametrize` 标记。在 pytest 中，**标记** 是一种特殊的装饰器，用来轻松地将元数据传递给测试。然后，根据测试所使用的标记，可以实现特殊的行为。
- en: 'Here, `parametrize` allows us to define several sets of variables that will
    be passed as arguments to the test function. At runtime, each set will generate
    a new and independent test. To understand this better, let’s look at how to use
    this marker to generate several tests for our `add` function:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`parametrize` 允许我们定义多个变量集，这些变量将作为参数传递给测试函数。在运行时，每个变量集都会生成一个新的独立测试。为了更好地理解这一点，我们来看看如何使用这个标记为我们的
    `add` 函数生成多个测试：
- en: chapter09_introduction_pytest_parametrize.py
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: chapter09_introduction_pytest_parametrize.py
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_introduction_pytest_parametrize.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_introduction_pytest_parametrize.py)'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_introduction_pytest_parametrize.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_introduction_pytest_parametrize.py)'
- en: 'Here, you can see that we simply decorated our test function with the `parametrize`
    marker. The basic usage is as follows: the first argument is a string with the
    name of each parameter separated by a comma. Then, the second argument is a list
    of tuples. Each tuple contains the values of the parameters in order.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以看到我们只是简单地用`parametrize`标记装饰了我们的测试函数。基本用法如下：第一个参数是一个字符串，其中包含每个参数的名称，用逗号分隔。然后，第二个参数是一个元组列表。每个元组按顺序包含参数的值。
- en: 'Our test function receives those parameters in arguments, each one named the
    way you specified previously. Thus, you can use them at will in the test logic.
    As you can see, the great benefit here is that we only have to write the `assert`
    statement once. Besides, it’s very quick to add a new test case: we just have
    to add another tuple to the `parametrize` marker.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试函数以参数的形式接收这些参数，每个参数的名称与您之前指定的方式相同。因此，您可以在测试逻辑中随意使用它们。正如您所见，这里的巨大好处在于我们只需要一次编写`assert`语句。此外，添加新的测试用例非常快速：我们只需在`parametrize`标记中添加另一个元组。
- en: 'Now, let’s run this test to see what happens by using the following command:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们运行这个测试，看看使用以下命令会发生什么：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As you can see, pytest executed *four tests instead of one*! This means that
    it generated four independent tests, along with their own sets of parameters.
    If several tests fail, we’ll be informed, and the output will tell us which set
    of parameters caused the error.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，pytest 执行了*四个测试而不是一个*！这意味着它生成了四个独立的测试，以及它们自己的参数集。如果有几个测试失败，我们将得到通知，并且输出将告诉我们哪组参数导致了错误。
- en: To conclude, `parametrize` is a very convenient way to test different outcomes
    when it’s given a different set of parameters.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，`parametrize` 是一种非常便捷的方式，当给定不同的参数集时，测试不同的结果。
- en: 'While writing unit tests, you’ll often need variables and objects several times
    across your tests, such as app instances, fake data, and so on. To avoid having
    to repeat the same things over and over across your tests, pytest proposes an
    interesting feature: fixtures.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写单元测试时，通常需要在测试中多次使用变量和对象，比如应用程序实例、虚假数据等等。为了避免在测试中反复重复相同的事物，pytest 提出了一个有趣的特性：夹具。
- en: Reusing test logic by creating fixtures
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过创建夹具来重用测试逻辑
- en: 'When testing a large application, tests tend to become quite repetitive: lots
    of them will share the same boilerplate code before their actual assertion. Consider
    the following Pydantic models representing a person and their postal address:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试大型应用程序时，测试往往会变得非常重复：在实际断言之前，许多测试将共享相同的样板代码。考虑以下代表人物及其邮政地址的 Pydantic 模型：
- en: chapter09_introduction_fixtures.py
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: chapter09_introduction_fixtures.py
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_introduction_fixtures.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_introduction_fixtures.py)'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_introduction_fixtures.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_introduction_fixtures.py)'
- en: 'This example may look familiar: it was taken from [*Chapter 4*](B19528_04.xhtml#_idTextAnchor176),
    *Managing Pydantic Data Models in FastAPI*. Now, let’s say that we want to write
    tests with some instances of those models. Obviously, it would be a bit annoying
    to instantiate them in each test, filling them with fake data.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子可能看起来很熟悉：它来自[*第4章*](B19528_04.xhtml#_idTextAnchor176)，*在 FastAPI 中管理 Pydantic
    数据模型*。现在，假设我们希望使用这些模型的一些实例编写测试。显然，在每个测试中实例化它们并填充虚假数据会有点烦人。
- en: 'Fortunately, fixtures allow us to write them once and for all. The following
    example shows how to use them:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，夹具使我们能够一劳永逸地编写它们。以下示例展示了如何使用它们：
- en: chapter09_introduction_fixtures_test.py
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: chapter09_introduction_fixtures_test.py
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_introduction_fixtures_test.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_introduction_fixtures_test.py)'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_introduction_fixtures_test.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_introduction_fixtures_test.py)'
- en: 'Once again, pytest makes it very straightforward: fixtures are *simple functions*
    decorated *with the fixture decorator*. Inside, you can write any logic and return
    the object you’ll need in your tests. Here, in `address`, we instantiate an `Address`
    object with fake data and return it.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 再次感谢pytest的简便性：夹具是*简单的函数*，并且*使用夹具装饰器*进行装饰。在这些函数内部，你可以编写任何逻辑，并返回你在测试中需要的对象。在`address`中，我们用虚拟数据实例化了一个`Address`对象并返回它。
- en: 'Now, how can we use this fixture? If you look at the `test_address_country`
    test, you’ll see some magic happening: by setting an `address` argument on the
    test function, pytest automatically detects that it corresponds to the `address`
    fixture, executes it, and passes its return value. Inside the test, we have our
    `Address` object ready to use. pytest calls this *requesting* *a fixture*.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们如何使用这个夹具呢？如果你查看`test_address_country`测试，你会看到一些魔法：通过在测试函数中设置`address`参数，pytest会自动检测到它对应于`address`夹具，执行它并传递其返回值。在测试中，我们的`Address`对象已经准备好使用了。pytest称之为*请求*
    *一个夹具*。
- en: 'You may have noticed that we also defined another fixture, `person`. Once again,
    we instantiate a `Person` model with dummy data. The interesting thing to note,
    however, is that we actually requested the `address` fixture to use it inside!
    That’s what makes this system so powerful: fixtures can depend on other fixtures,
    which can also depend on others, and so on. In some way, it’s quite similar to
    dependency injection, as we discussed in [*Chapter 5*](B19528_05.xhtml#_idTextAnchor285),
    *Dependency Injection* *in FastAPI*.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，我们还定义了另一个夹具`person`。再一次，我们用虚拟数据实例化了一个`Person`模型。然而，值得注意的是，我们实际上请求了`address`夹具并在其中使用了它！这就是这个系统如此强大的原因：夹具可以依赖于其他夹具，而这些夹具也可以依赖于其他夹具，依此类推。从某种意义上来说，它与我们在[*第5章*](B19528_05.xhtml#_idTextAnchor285)中讨论的*依赖注入*非常相似，*FastAPI中的依赖注入*。
- en: 'With that, our quick introduction to pytest has come to an end. Of course,
    there are so many more things to say, but this will be enough for you to get started.
    If you want to explore this topic further, you can read the official pytest documentation,
    which includes tons of examples showing you how you can benefit from all its features:
    [https://docs.pytest.org/en/latest/](https://docs.pytest.org/en/latest/).'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 至此，我们对pytest的简短介绍已经结束。当然，还有很多内容可以讨论，但这些内容足以让你开始。如果你想深入了解这个话题，可以阅读官方的pytest文档，其中包含大量示例，展示了你如何从其所有功能中受益：[https://docs.pytest.org/en/latest/](https://docs.pytest.org/en/latest/)。
- en: Now, let’s focus on FastAPI. We’ll start by setting up the tools for testing
    our applications.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们把重点放在FastAPI上。我们将从设置测试工具开始。
- en: Setting up testing tools for FastAPI with HTTPX
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用HTTPX为FastAPI设置测试工具
- en: If you look at the FastAPI documentation regarding testing, you’ll see that
    it recommends that you use `TestClient` provided by Starlette. In this book, we’ll
    show you a different approach involving an HTTP client called HTTPX.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看FastAPI文档中关于测试的部分，你会看到它推荐使用Starlette提供的`TestClient`。在本书中，我们将向你展示一种不同的方法，它涉及一个名为HTTPX的HTTP客户端。
- en: 'Why? The default `TestClient` is implemented in a way that makes it completely
    synchronous, meaning you can write tests without worrying about `async` and `await`.
    This might sound nice, but we found that it causes some problems in practice:
    since your FastAPI app is designed to work asynchronously, you’ll likely have
    lots of services working asynchronously, such as the database drivers we saw in
    [*Chapter 6*](B19528_06.xhtml#_idTextAnchor346), *Databases and Asynchronous ORMs*.
    Thus, in your tests, you’ll probably need to perform some actions on those asynchronous
    services, such as filling a database with dummy data, which will make your tests
    asynchronous anyway. Melding the two approaches often leads to strange errors
    that are hard to debug.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么？默认的`TestClient`实现方式使其完全同步，这意味着你可以在测试中写代码而不必担心`async`和`await`。这听起来可能不错，但我们发现它在实际中会引发一些问题：由于你的FastAPI应用是设计为异步工作的，因此你很可能会有许多异步工作的服务，比如我们在[*第6章*](B19528_06.xhtml#_idTextAnchor346)中讨论的*数据库和异步ORM*。因此，在你的测试中，你很可能需要对这些异步服务执行一些操作，比如用虚拟数据填充数据库，这样即使测试本身是异步的。将两种方法混合往往会导致一些难以调试的奇怪错误。
- en: 'Fortunately, HTTPX, an HTTP client created by the same team as Starlette, allows
    us to have a pure asynchronous HTTP client able to make requests to our FastAPI
    app. To make this approach work, we’ll need three libraries:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，HTTPX是由与Starlette同一团队创建的一个HTTP客户端，它使我们能够拥有一个纯异步的HTTP客户端，可以向我们的FastAPI应用发送请求。为了使这种方法奏效，我们需要三个库：
- en: '`HTTPX`, the client that will perform HTTP requests'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HTTPX`，执行HTTP请求的客户端'
- en: '`asgi-lifespan`, a library for managing the lifespan events of your FastAPI
    app programmatically'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`asgi-lifespan`，一个用于以编程方式管理FastAPI应用程序生命周期事件的库'
- en: '`pytest-asyncio`, an extension for pytest that allows us to write asynchronous
    tests'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pytest-asyncio`，一个为pytest扩展的库，允许我们编写异步测试'
- en: 'Let’s install those libraries using the following command:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用以下命令安装这些库：
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Great! Now, let’s write some fixtures so that we can easily get an HTTP test
    client for a FastAPI application. This way, when writing a test, we’ll only have
    to request the fixture and we’ll be able to make a request right away.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！现在，让我们编写一些夹具，以便我们可以轻松地为FastAPI应用程序获取HTTP测试客户端。这样，在编写测试时，我们只需请求该夹具，就能立即进行请求。
- en: 'In the following example, we are considering a simple FastAPI application that
    we want to test:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们考虑了一个简单的FastAPI应用程序，我们希望对其进行测试：
- en: chapter09_app.py
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: chapter09_app.py
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_app.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_app.py)'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_app.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_app.py)'
- en: In a separate test file, we’ll implement two fixtures.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个单独的测试文件中，我们将实现两个夹具（fixtures）。
- en: 'The first one, `event_loop`, will ensure that we always work with the same
    event loop instance. It’s automatically requested by `pytest-asyncio` before executing
    asynchronous tests. You can see its implementation in the following example:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个，`event_loop`，将确保我们始终使用相同的事件循环实例。它会在执行异步测试之前由`pytest-asyncio`自动请求。你可以在以下示例中看到它的实现：
- en: chapter09_app_test.py
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: chapter09_app_test.py
- en: '[PRE14]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_app_test.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_app_test.py)'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_app_test.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_app_test.py)'
- en: Here, you can see that we simply create a new event loop before *yielding* it.
    As we discussed in [*Chapter 2*](B19528_02.xhtml#_idTextAnchor032), *Python Programming
    Specificities*, using a generator allows us to “pause” the function’s execution
    and get back to the execution of its caller. This way, when the caller is done,
    we can execute cleanup operations, such as closing the loop. pytest is smart enough
    to handle this correctly in fixtures, so this is a very common pattern for setting
    up test data, using it, and destroying it after. We also use the same approach
    for lifespan functions in FastAPI.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到我们仅仅在*生成*它之前创建了一个新的事件循环。正如我们在[*第二章*](B19528_02.xhtml#_idTextAnchor032)中讨论的那样，*Python编程的特殊性*，使用生成器允许我们“暂停”函数的执行并返回到调用者的执行。当调用者完成时，我们可以执行清理操作，比如关闭循环。pytest足够聪明，能够正确地处理夹具中的这一点，所以这是设置测试数据、使用它并在之后销毁它的一个非常常见的模式。我们在FastAPI的生命周期函数中也使用相同的方法。
- en: 'Of course, this function is decorated with the `fixture` decorator to make
    it a fixture for pytest. You may have noticed that we set an argument called `scope`
    with the `session` value. This argument controls at which level the fixture should
    be instantiated. By default, it’s recreated *at the beginning of each single test
    function*. The `session` value is the highest level, meaning that the fixture
    is only created once at the beginning of the whole test run, which is relevant
    for our event loop. You can find out more about this more advanced feature in
    the official documentation: [https://docs.pytest.org/en/latest/how-to/fixtures.html#scope-sharing-fixtures-across-classes-modules-packages-or-session](https://docs.pytest.org/en/latest/how-to/fixtures.html#scope-sharing-fixtures-across-classes-modules-packages-or-session).'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这个函数被`fixture`装饰器修饰，使其成为pytest的夹具。你可能已经注意到我们设置了一个名为`scope`的参数，值为`session`。这个参数控制夹具应该在哪个层级进行实例化。默认情况下，它会在*每个单独的测试函数开始时*重新创建。`session`值是最高的层级，意味着该夹具只会在整个测试运行开始时创建一次，这对于我们的事件循环是很重要的。你可以在官方文档中了解更多关于这个更高级功能的信息：[https://docs.pytest.org/en/latest/how-to/fixtures.html#scope-sharing-fixtures-across-classes-modules-packages-or-session](https://docs.pytest.org/en/latest/how-to/fixtures.html#scope-sharing-fixtures-across-classes-modules-packages-or-session)。
- en: 'Next, we’ll implement our `test_client` fixture, which will create an instance
    of HTTPX for our FastAPI application. We must also remember to trigger the app
    events with `asgi-lifespan`. You can see what it looks like in the following example:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将实现我们的`test_client`固定装置，它将为我们的FastAPI应用程序创建一个HTTPX实例。我们还必须记住使用`asgi-lifespan`触发应用程序事件。您可以在以下示例中看到它的外观：
- en: chapter09_app_test.py
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: chapter09_app_test.py
- en: '[PRE15]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_app_test.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_app_test.py)'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_app_test.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_app_test.py)'
- en: Only three lines are needed. The first difference with fixtures we’ve seen so
    far is that this is an async function. In this case, notice that we used the `@pytest_asyncio.fixture`
    decorator instead of `@pytest.fixture`. It’s the async counterpart of this decorator
    provided by `pytest-asyncio` so async fixtures are correctly handled. In previous
    versions, using the standard decorator used to work but it’s now discouraged.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 只需要三行。到目前为止，与我们所见过的固定装置的第一个不同之处在于这是一个异步函数。在这种情况下，请注意，我们使用了`@pytest_asyncio.fixture`装饰器，而不是`@pytest.fixture`。这是由`pytest-asyncio`提供的此装饰器的异步对应项，因此可以正确处理异步固定装置。在以前的版本中，使用标准装饰器曾经有效，但现在不鼓励使用。
- en: 'Then, we have two context managers: `LifespanManager` and `httpx.AsyncClient`.
    The first one ensures startup and shutdown events are executed, while the second
    one ensures that an HTTP session is ready. On both of them, we set the `app` variable:
    this is our FastAPI application instance we imported from its module, `chapter09.chapter09_app`
    `import app`.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有两个上下文管理器：`LifespanManager`和`httpx.AsyncClient`。第一个确保启动和关闭事件被执行，而第二个确保HTTP会话已准备就绪。在这两者上，我们设置了`app`变量：这是我们从其模块`chapter09.chapter09_app`中导入的FastAPI应用程序实例。
- en: Notice that we once again used a generator here, with `yield`. This is important
    because, even if we don’t have any more code after, *we need to close the context
    managers after we use our client*. If we used `return`, Python would have immediately
    closed them and we would end up with an unusable client.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在这里我们再次使用了一个生成器，使用了`yield`。这很重要，因为即使我们在其后没有更多的代码，*我们需要在使用客户端后关闭上下文管理器*。如果我们使用`return`，Python会立即关闭它们，我们最终会得到一个无法使用的客户端。
- en: Organizing tests and global fixtures in projects
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目中组织测试和全局固定装置
- en: In larger projects, you’ll likely have several test files to keep your tests
    organized. Usually, those files are placed in a `tests` folder at the root of
    your project. If your test files are prefixed with `test_`, they will be automatically
    discovered by pytest. *Figure 9**.1* shows an example of this.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在更大的项目中，您可能会有几个测试文件来组织您的测试。通常，这些文件放置在项目根目录的`tests`文件夹中。如果您的测试文件以`test_`前缀，它们将被pytest自动发现。*图9**.1*显示了一个示例。
- en: Besides this, you’ll need the fixtures we defined in this section for all your
    tests. Rather than repeating them again and again in all your test files, pytest
    allows you to write global fixtures in a file named `conftest.py`. After putting
    it in your `tests` folder, it will automatically be imported, allowing you to
    request all the fixtures you define inside it. You can read more about this in
    the official documentation at https://docs.pytest.org/en/latest/reference/fixtures.html#conftest-py-sharing-fixtures-across-multiple-files.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您将需要在所有测试中使用我们在本节中定义的固定装置。与其在所有测试文件中一遍又一遍地重复定义它们，pytest允许您在名为`conftest.py`的文件中编写全局固定装置。将其放置在您的`tests`文件夹中后，它将自动被导入，允许您请求您在其中定义的所有固定装置。您可以在官方文档的https://docs.pytest.org/en/latest/reference/fixtures.html#conftest-py-sharing-fixtures-across-multiple-files中了解更多信息。
- en: 'As mentioned previously, *Figure 9**.1* shows the test files in the `tests`
    folder:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，*图9**.1*显示了位于`tests`文件夹中的测试文件：
- en: '![Figure 9.1 – Structure of a project with tests](img/Figure_9.1_B19528.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图9**.1 – 项目带有测试的结构](img/Figure_9.1_B19528.jpg)'
- en: Figure 9.1 – Structure of a project with tests
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图9**.1 – 项目带有测试的结构
- en: That’s it! We now have all the fixtures ready to write tests for our REST API
    endpoints. That’s what we’ll do in the next section.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！现在我们已经准备好为我们的REST API端点编写测试所需的所有固定装置。这将是我们在下一节要做的事情。
- en: Writing tests for REST API endpoints
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为REST API端点编写测试
- en: All the tools we need to test our FastAPI application are now ready. All these
    tests boil down to performing an HTTP request and checking the response to see
    whether it corresponds to what we expect.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 测试 FastAPI 应用程序所需的所有工具现在都已准备好。所有这些测试都归结为执行一个 HTTP 请求并检查响应，看看它是否符合我们的预期。
- en: 'Let’s start simply with a test for our `hello_world` path operation function.
    You can see it in the following code:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从对 `hello_world` 路径操作函数进行简单的测试开始。你可以在以下代码中看到它：
- en: chapter09_app_test.py
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: chapter09_app_test.py
- en: '[PRE16]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_app_test.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_app_test.py)'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_app_test.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_app_test.py)'
- en: 'First of all, notice that the test function is defined as async. As we mentioned
    previously, to make it work with pytest, we had to install `pytest-asyncio`. This
    extension provides the `asyncio` marker: each asynchronous test should be decorated
    with this marker to make it work properly.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，注意测试函数被定义为异步函数。如前所述，为了让它与 pytest 一起工作，我们需要安装 `pytest-asyncio`。这个扩展提供了 `asyncio`
    标记：每个异步测试都应使用此标记进行装饰，以确保它能正常工作。
- en: Next, we request our `test_client` fixture, which we defined earlier. It gives
    us an HTTPX client instance ready to make requests to our FastAPI app. Note that
    we manually type hinted the fixture. While not strictly required, it’ll greatly
    help you if you use an IDE such as Visual Studio Code, which uses type hints to
    provide you with convenient auto-completion features.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们请求我们之前定义的 `test_client` 固件。它为我们提供了一个准备好向 FastAPI 应用程序发起请求的 HTTPX 客户端实例。注意，我们手动给这个固件加上了类型提示。虽然这不是严格要求的，但如果你使用像
    Visual Studio Code 这样的 IDE，类型提示会大大帮助你，提供方便的自动完成功能。
- en: 'Then, in the body of our test, we perform the request. Here, it’s a simple
    GET request to the `/` path. It returns an HTTPX `Response` object (which is *different*
    from the `Response` class of FastAPI) containing all the data of the HTTP response:
    the status code, the headers, and the body.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在我们测试的主体中，我们执行请求。在这里，它是一个简单的对 `/` 路径的 GET 请求。它返回一个 HTTPX `Response` 对象（*与
    FastAPI 的 `Response` 类不同*），包含 HTTP 响应的所有数据：状态码、头信息和正文。
- en: Finally, we make assertions based on this data. As you can see, we verify that
    the status code is indeed `200`. We also check the content of the body, which
    is a simple JSON object. Notice that the `Response` object has a convenient method
    called `json` for automatically parsing JSON content.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们基于这些数据做出断言。如你所见，我们验证了状态码确实是 `200`。我们还检查了正文的内容，它是一个简单的 JSON 对象。注意，`Response`
    对象有一个方便的方法 `json`，可以自动解析 JSON 内容。
- en: Great! We wrote our first FastAPI test! Of course, you’ll likely have more complex
    tests, typically ones for POST endpoints.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们写出了第一个 FastAPI 测试！当然，你可能会有更复杂的测试，通常是针对 POST 端点的测试。
- en: Writing tests for POST endpoints
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写 POST 端点的测试
- en: 'Testing a POST endpoint is not very different from what we’ve seen earlier.
    The difference is that we’ll likely have more cases to check whether data validation
    is working. In the following example, we are implementing a POST endpoint that
    accepts a `Person` model in the body:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 测试 POST 端点与我们之前看到的并没有太大不同。不同之处在于，我们可能会有更多的用例来检查数据验证是否有效。在下面的例子中，我们实现了一个 POST
    端点，该端点接受请求体中的 `Person` 模型：
- en: chapter09_app_post.py
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: chapter09_app_post.py
- en: '[PRE17]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_app_post.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_app_post.py)'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_app_post.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_app_post.py)'
- en: 'An interesting test could be to ensure that an error is raised if some fields
    are missing in the request payload. In the following extract, we wrote two tests
    – one with an invalid payload and another with a valid one:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有趣的测试可能是确保如果请求负载中缺少某些字段，系统会引发错误。在以下提取中，我们编写了两个测试—一个使用无效负载，另一个使用有效负载：
- en: chapter09_app_post_test.py
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: chapter09_app_post_test.py
- en: '[PRE18]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_app_post_test.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_app_post_test.py)'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_app_post_test.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_app_post_test.py)'
- en: 'The first thing you may have noticed is that we wrapped our two tests inside
    a class. While not required in pytest, it could help you organize your tests –
    for example, to regroup tests that concern a single endpoint. Notice that, in
    this case, we only have to decorate the class with the `asyncio` marker; it will
    be automatically applied on single tests. Also, ensure that you add the `self`
    argument to each test: since we are now inside a class, they become methods.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能首先注意到的是，我们将两个测试包装在了一个类里面。虽然在pytest中这不是必须的，但它可以帮助你组织测试——例如，重新组合与单个端点相关的测试。请注意，在这种情况下，我们只需要用`asyncio`标记装饰类，它会自动应用到单个测试上。另外，确保为每个测试添加`self`参数：因为我们现在在一个类中，它们变成了方法。
- en: 'These tests are not very different from our first example. As you can see,
    the HTTPX client makes it very easy to perform POST requests with a JSON payload:
    you just have to pass a dictionary to the `json` argument.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这些测试与我们的第一个例子没有太大不同。正如你所看到的，HTTPX客户端使得执行带有JSON负载的POST请求变得非常简单：你只需将字典传递给`json`参数。
- en: 'Of course, HTTPX helps you build all kinds of HTTP requests with headers, query
    parameters, and so on. Be sure to check its official documentation to learn more
    about its usage: [https://www.python-httpx.org/quickstart/](https://www.python-httpx.org/quickstart/).'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，HTTPX帮助你构建各种各样的HTTP请求，包括带有头部、查询参数等等。务必查看它的官方文档，以了解更多使用方法：[https://www.python-httpx.org/quickstart/](https://www.python-httpx.org/quickstart/)。
- en: Testing with a database
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用数据库进行测试
- en: Your application will likely have a database connection to read and store data.
    In this context, you’ll need to work with a fresh test database in each run to
    have a clean and predictable set of data to write your tests.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你的应用程序可能会有一个数据库连接，用来读取和存储数据。在这种情况下，你需要在每次运行时都使用一个新的测试数据库，以便拥有一组干净且可预测的数据来编写测试。
- en: For this, we’ll use two things. The first one, `dependency_overrides`, is a
    FastAPI feature that allows us to replace some dependencies at runtime. For example,
    we can replace the dependency that returns the database instance with another
    one that returns a test database instance. The second one is, once again, fixtures,
    which will help us create fake data in the test database before we run the tests.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们将使用两样东西。第一个是`dependency_overrides`，它是FastAPI的一个特性，允许我们在运行时替换一些依赖项。例如，我们可以用返回测试数据库实例的依赖项替换返回数据库实例的依赖项。第二个是再次使用fixtures，它将帮助我们在运行测试之前向测试数据库添加假数据。
- en: 'To show you a working example, we’ll consider the same example we built in
    the *Communicating with a MongoDB database with Motor* section of [*Chapter 6*](B19528_06.xhtml#_idTextAnchor346),
    *Databases and Asynchronous ORMs*. In that example, we built REST endpoints to
    manage blog posts. As you may recall, we had a `get_database` dependency that
    returned the database instance. As a reminder, we show it again here:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给你展示一个工作示例，我们将考虑我们在[《第6章》](B19528_06.xhtml#_idTextAnchor346)中构建的*与MongoDB数据库进行通信*部分中的相同示例，*数据库和异步ORM*。在那个示例中，我们构建了用于管理博客文章的REST端点。你可能还记得，我们有一个返回数据库实例的`get_database`依赖项。为了提醒，你可以在这里再次看到它：
- en: database.py
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: database.py
- en: '[PRE19]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter6/mongodb/database.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter6/mongodb/database.py)'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter6/mongodb/database.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter6/mongodb/database.py)'
- en: Path operation functions and other dependencies would then use this dependency
    to retrieve the database instance.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 路径操作函数和其他依赖项将使用这个依赖项来获取数据库实例。
- en: 'For our tests, we’ll create a new instance of `AsyncIOMotorDatabase` that points
    to another database. Then, we’ll create a new dependency, directly in our test
    file, that returns this instance. You can see this in the following example:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的测试，我们将创建一个新的`AsyncIOMotorDatabase`实例，它指向另一个数据库。然后，我们将在测试文件中直接创建一个新依赖项，返回这个实例。你可以在以下示例中看到这一点：
- en: chapter09_db_test.py
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: chapter09_db_test.py
- en: '[PRE20]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_db_test.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_db_test.py)'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_db_test.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_db_test.py)'
- en: 'Then, in our `test_client` fixture, we’ll override the default `get_database`
    dependency by using our current `get_test_database` dependency. The following
    example shows how this is done:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在我们的 `test_client` fixture 中，我们将通过使用当前的 `get_test_database` 依赖项来覆盖默认的 `get_database`
    依赖项。以下示例展示了如何实现这一点：
- en: chapter09_db_test.py
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: chapter09_db_test.py
- en: '[PRE21]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_db_test.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_db_test.py)'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_db_test.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_db_test.py)'
- en: FastAPI provides a property called `dependency_overrides`, which is a dictionary
    that maps original dependency functions with substitutes. Here, we directly used
    the `get_database` function as a key. The rest of the fixture doesn’t have to
    change. Now, whenever the `get_database` dependency is injected into the application
    code, FastAPI will automatically replace it with `get_test_database`. As a result,
    our endpoints will now work with the test database instance.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI 提供了一个名为 `dependency_overrides` 的属性，这是一个字典，用于将原始依赖函数与替代函数进行映射。在这里，我们直接使用
    `get_database` 函数作为键。其余的 fixture 不需要改变。现在，每当 `get_database` 依赖项被注入到应用程序代码中时，FastAPI
    会自动将其替换为 `get_test_database`。因此，我们的端点现在将使用测试数据库实例。
- en: app and dependency_overrides are global
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: app 和 dependency_overrides 是全局的
- en: 'Since we are directly importing `app` from its module, it’s instantiated only
    once for the whole test run. It means that `dependency_overrides` is common for
    every test. Keep this in mind if someday you want to override a dependency for
    a single test: once you’ve set it, it’ll be set for the rest of the execution.
    In this case, you can reset `dependency_overrides` by using `app.dependency_overrides
    = {}`.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们是直接从模块中导入 `app`，因此它只会在整个测试运行中实例化一次。这意味着 `dependency_overrides` 对每个测试都是通用的。如果有一天你想为单个测试覆盖某个依赖项，记住一旦设置，它将应用于剩余的执行过程。在这种情况下，你可以通过使用
    `app.dependency_overrides = {}` 来重置 `dependency_overrides`。
- en: 'To test some behaviors, such as retrieving a single post, it’s usually convenient
    to have some base data in our test database. To allow this, we’ll create a new
    fixture that will instantiate dummy `PostDB` objects and insert them into the
    test database. You can see this in the following example:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试一些行为，例如获取单个帖子，通常需要在我们的测试数据库中准备一些基础数据。为此，我们将创建一个新的 fixture，它将实例化虚拟的 `PostDB`
    对象并将其插入到测试数据库中。你可以在以下示例中看到这一点：
- en: chapter09_db_test.py
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: chapter09_db_test.py
- en: '[PRE22]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_db_test.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_db_test.py)'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_db_test.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_db_test.py)'
- en: Here, you can see that we just had to make an `insert_many` request to the MongoDB
    database to create the posts.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到我们只需要向 MongoDB 数据库发出一个 `insert_many` 请求来创建帖子。
- en: Notice that we used the `autouse` and `scope` arguments of the `fixture` decorator.
    The first one tells pytest to automatically call this fixture *even if it’s not
    requested in any test*. In this case, it’s convenient because we’ll always ensure
    that the data has been created in the database, without the risk of forgetting
    to request it in the tests. The other one, `scope`, allows us, as we mentioned
    previously, to not run this fixture at the beginning of each test. With the `module`
    value, the fixture will create the objects only once, at the beginning of this
    particular test file. It helps make the test fast because, in this case, it doesn’t
    make sense to recreate the posts before each test.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们使用了`fixture`装饰器的`autouse`和`scope`参数。第一个参数告诉pytest自动调用此测试夹具，*即使在任何测试中都没有请求它*。在这种情况下，它很方便，因为我们将始终确保数据已在数据库中创建，而不会有忘记在测试中请求它的风险。另一个参数`scope`，如前所述，允许我们在每个测试开始时不运行此测试夹具。使用`module`值时，测试夹具只会在此特定测试文件的开始时创建对象一次。它有助于提高测试速度，因为在这种情况下，重新创建帖子在每个测试之前是没有意义的。
- en: Once again, we *yield* the posts instead of returning them. This pattern allows
    us to delete the test database after the tests run. By doing this, we’re making
    sure that we always start with a fresh database when we’ve run the tests.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们*使用生成器*来生成帖子，而不是直接返回它们。这个模式使得我们在测试运行后能够删除测试数据库。通过这样做，我们确保每次运行测试时，数据库都是全新的。
- en: 'And we are done! We can now write tests while knowing exactly what we have
    in the database. In the following example, you can see tests that are used to
    verify the behavior of the endpoint retrieving a single post:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 完成了！现在我们可以在完全了解数据库中的内容的情况下编写测试。在下面的示例中，您可以看到用于验证获取单个帖子端点行为的测试：
- en: chapter09_db_test.py
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: chapter09_db_test.py
- en: '[PRE23]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_db_test.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_db_test.py)'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_db_test.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_db_test.py)'
- en: Notice that we requested the `initial_posts` fixture in the second test to retrieve
    the identifier of the post that truly exists in our database.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在第二个测试中，我们请求了`initial_posts`测试夹具，以获取数据库中真实存在的帖子的标识符。
- en: 'Of course, we can also test our endpoints by creating data and checking whether
    it was correctly inserted into the database. You can see this in the following
    example:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们也可以通过创建数据并检查它是否正确插入到数据库中来测试我们的端点。您可以在以下示例中看到这一点：
- en: chapter09_db_test.py
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: chapter09_db_test.py
- en: '[PRE24]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_db_test.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_db_test.py)'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_db_test.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_db_test.py)'
- en: 'In the second test, we used the `database_test` instance to perform a request
    and check that the object was inserted correctly. This shows the benefit of using
    asynchronous tests: we can use the same libraries and tools inside our tests.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个测试中，我们使用了`database_test`实例来执行请求，并检查对象是否正确插入。这展示了使用异步测试的好处：我们可以在测试中使用相同的库和工具。
- en: 'That’s all you need to know about `dependency_overrides`. This feature is also
    very helpful when you need to write tests for logic involving external services,
    such as external APIs. Instead of making real requests to those external services
    during your tests, which could cause issues or incur costs, you’ll be able to
    replace them with another dependency that fakes the requests. To understand this,
    we’ve built another example application with an endpoint for retrieving data from
    an external API:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是关于`dependency_overrides`的所有内容。这个功能在你需要为涉及外部服务的逻辑编写测试时非常有用，例如外部API。与其在测试期间向这些外部服务发送真实请求（可能会导致问题或产生费用），你可以将它们替换为另一个伪造请求的依赖项。为了理解这一点，我们构建了另一个示例应用程序，其中有一个端点用于从外部API获取数据：
- en: chapter09_app_external_api.py
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: chapter09_app_external_api.py
- en: '[PRE25]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_app_external_api.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_app_external_api.py)'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_app_external_api.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_app_external_api.py)'
- en: 'To call our external API, we’ve built a class dependency, as we saw in the
    *Creating and using a parameterized dependency with a class* section of [*Chapter
    5*](B19528_05.xhtml#_idTextAnchor285), *Dependency Injection in FastAPI*. We use
    HTTPX as an HTTP client to make a request to the external API and retrieve the
    data. This external API is a dummy API containing fake data – very useful for
    experiments like this: [https://dummyjson.com](https://dummyjson.com).'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 为了调用我们的外部 API，我们构建了一个类依赖，就像我们在 [*第 5 章*](B19528_05.xhtml#_idTextAnchor285)的
    *在 FastAPI 中创建并使用带参数化的依赖类* 一节中所看到的那样。我们使用 HTTPX 作为 HTTP 客户端向外部 API 发出请求并获取数据。这个外部
    API 是一个虚拟 API，包含假的数据——非常适合像这样的实验：[https://dummyjson.com](https://dummyjson.com)。
- en: The `/products` endpoint is simply injected with this dependency and directly
    returns the data provided by the external API.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`/products` 端点只是通过依赖注入来获取依赖并直接返回外部 API 提供的数据。'
- en: 'Of course, to test this endpoint, we don’t want to make real requests to the
    external API: it may take time and could be subject to rate limiting. Besides,
    you may want to test behavior that is not easy to reproduce in the real API, such
    as errors.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，为了测试这个端点，我们不希望向外部 API 发出真实请求：这样可能会耗费时间，而且可能会受到速率限制。此外，你可能希望测试一些在真实 API 中不容易复现的行为，比如错误。
- en: 'Thanks to `dependency_overrides`, it’s very easy to replace our `ExternalAPI`
    dependency class with another one that returns static data. In the following example,
    you can see how we implemented such a test:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 由于有了 `dependency_overrides`，我们可以很容易地用返回静态数据的另一个类替换我们的 `ExternalAPI` 依赖类。在以下示例中，你可以看到我们是如何实现这种测试的：
- en: chapter09_app_external_api_test.py
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: chapter09_app_external_api_test.py
- en: '[PRE26]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_app_external_api_test.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_app_external_api_test.py)'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_app_external_api_test.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_app_external_api_test.py)'
- en: Here, you can see that we wrote a simple class called `MockExternalAPI` that
    returns hardcoded data. All we have to do then is override the original dependency
    with this one. During the tests, the external API won’t be called; we’ll only
    work with the static data.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到我们编写了一个简单的名为 `MockExternalAPI` 的类，它返回硬编码的数据。接下来我们只需要用这个类覆盖原有的依赖。在测试过程中，外部
    API 将不会被调用；我们只会使用静态数据。
- en: 'With the guidelines we’ve seen so far, you can now write tests for any HTTP
    endpoints in your FastAPI app. However, there is another kind of endpoint that
    behaves differently: WebSockets. As we’ll see in the next section, unit testing
    WebSockets is also quite different from what we described for REST endpoints.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们目前所看到的指南，你现在可以为 FastAPI 应用中的任何 HTTP 端点编写测试。然而，还有另一种行为不同的端点：WebSocket。正如我们将在下一节中看到的，WebSocket
    的单元测试与我们为 REST 端点描述的方式非常不同。
- en: Writing tests for WebSocket endpoints
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为 WebSocket 端点编写测试
- en: In [*Chapter 8*](B19528_08.xhtml#_idTextAnchor551), *Defining WebSockets for
    Two-Way Interactive Communication in FastAPI*, we explained how WebSockets work
    and how you can implement such endpoints in FastAPI. As you may have guessed,
    writing unit tests for WebSockets endpoints is quite different from what we’ve
    seen so far.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 8 章*](B19528_08.xhtml#_idTextAnchor551) *在 FastAPI 中定义双向交互通信的 WebSocket*
    一节中，我们解释了 WebSocket 是如何工作的以及如何在 FastAPI 中实现这样的端点。正如你可能已经猜到的那样，为 WebSocket 端点编写单元测试与我们之前所看到的方式有很大不同。
- en: 'For this task, we’ll need to tweak our `test_client` fixture a little bit.
    Indeed, HTTPX doesn’t have built-in support to communicate with WebSockets. Hence,
    we’ll need to use a plugin, HTTPX WS. Let’s install it with the following command:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个任务，我们需要稍微调整一下 `test_client` 固件。实际上，HTTPX 并没有内置支持与 WebSocket 通信。因此，我们需要使用一个插件：HTTPX
    WS。我们可以通过以下命令来安装它：
- en: '[PRE27]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'To enable support for WebSockets on our test client, we’ll change it like this:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在测试客户端启用对 WebSocket 的支持，我们将这样修改它：
- en: chapter09_websocket_test.py
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: chapter09_websocket_test.py
- en: '[PRE28]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_websocket_test.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_websocket_test.py)'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_websocket_test.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_websocket_test.py)'
- en: You can see that, instead of directly setting the `app` argument, we set `transport`
    with a class provided by HTTPX WS. This class provides support to test apps with
    WebSockets endpoints. Other than that, nothing changes. It’s worth noting that
    testing standard HTTP endpoints will still work correctly, so you can use this
    test client for all your tests.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，我们没有直接设置 `app` 参数，而是使用 HTTPX WS 提供的类设置了 `transport`。这个类提供了对带 WebSocket
    端点的应用程序进行测试的支持。除此之外，其他没有变化。值得注意的是，测试标准的 HTTP 端点仍然能够正常工作，因此你可以使用这个测试客户端进行所有的测试。
- en: 'Now, let’s consider a simple WebSocket endpoint example:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们考虑一个简单的 WebSocket 端点示例：
- en: chapter09_websocket.py
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: chapter09_websocket.py
- en: '[PRE29]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_websocket.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_websocket.py)'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_websocket.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_websocket.py)'
- en: You may have recognized the “echo” example from [*Chapter 8*](B19528_08.xhtml#_idTextAnchor551),
    *Defining WebSockets for Two-Way Interactive Communication* *in FastAPI*.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经认出“回声”示例来自 [*第 8 章*](B19528_08.xhtml#_idTextAnchor551)，*在 FastAPI 中定义 WebSockets
    进行双向交互通信*。
- en: 'Now, let’s write a test for our WebSocket using our test client:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用测试客户端为我们的 WebSocket 编写一个测试：
- en: Chapter09_websocket_test.py
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: Chapter09_websocket_test.py
- en: '[PRE30]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_websocket_test.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_websocket_test.py)'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_websocket_test.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter09/chapter09_websocket_test.py)'
- en: As you can see, HTTPX WS provides the `aconnect_ws` function to open a connection
    to a WebSocket endpoint. It expects the path of your WebSocket endpoint and a
    valid HTTPX client in an argument. By using `test_client`, we’ll make requests
    directly against our FastAPI application.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，HTTPX WS 提供了 `aconnect_ws` 函数来打开到 WebSocket 端点的连接。它需要 WebSocket 端点的路径以及有效的
    HTTPX 客户端作为参数。通过使用 `test_client`，我们可以直接向 FastAPI 应用程序发起请求。
- en: It opens a context manager, giving you the `websocket` variable. It’s an object
    that exposes several methods to either send or receive data. Each of those methods
    will block until a message has been sent or received.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 它打开了一个上下文管理器，给你一个 `websocket` 变量。它是一个对象，暴露了多个方法，用于发送或接收数据。每个方法都会阻塞，直到发送或接收到消息为止。
- en: 'Here, to test our “echo” server, we send a message thanks to the `send_text`
    method. Then, we retrieve a message with `receive_text` and assert that it corresponds
    to what we expect. Equivalent methods also exist for sending and receiving JSON
    data directly: `send_json` and `receive_json`.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，为了测试我们的“回声”服务器，我们通过 `send_text` 方法发送一条消息。然后，我们使用 `receive_text` 获取消息，并断言它符合我们的预期。也有等效的方法可以直接发送和接收
    JSON 数据：`send_json` 和 `receive_json`。
- en: 'This is what makes WebSocket testing a bit special: you have to think about
    the sequence of sent and received messages and implement them programmatically
    to test the behavior of your WebSocket.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 WebSocket 测试有点特别的地方：你需要考虑发送和接收消息的顺序，并以编程方式实现这些顺序，以测试 WebSocket 的行为。
- en: Other than that, all the things we’ve seen so far regarding testing are applicable,
    especially `dependency_overrides`, when you need to use a test database.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，我们迄今为止看到的所有关于测试的内容都适用，尤其是当你需要使用测试数据库时的`dependency_overrides`。
- en: Summary
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Congratulations! You are now ready to build high-quality FastAPI applications
    that have been well tested. In this chapter, you learned how to use pytest, a
    powerful and efficient testing framework for Python. Thanks to pytest fixtures,
    you saw how to create a reusable test client for your FastAPI application that
    can work asynchronously. Using this client, you learned how to make HTTP requests
    to assert the behavior of your REST API. Finally, we reviewed how to test WebSocket
    endpoints, which involves a fairly different way of thinking.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你！你现在已经准备好构建高质量的、经过充分测试的 FastAPI 应用程序。在这一章中，你学习了如何使用 pytest，这是一款强大且高效的 Python
    测试框架。得益于 pytest 固件，你了解了如何为 FastAPI 应用程序创建一个可以异步工作的可重用测试客户端。使用这个客户端，你学习了如何发出 HTTP
    请求，以断言你的 REST API 的行为。最后，我们回顾了如何测试 WebSocket 端点，这涉及到一种完全不同的思维方式。
- en: Now that you can build a reliable and efficient FastAPI application, it’s time
    to bring it to the whole world! In the next chapter, we’ll review the best practices
    and patterns for preparing a FastAPI application for the world before studying
    several deployment methods.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经能够构建一个可靠且高效的 FastAPI 应用程序，是时候将它带给全世界了！在下一章中，我们将回顾一些最佳实践和模式，以准备 FastAPI
    应用程序让它面向全球，然后再研究几种部署方法。
