- en: '15'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '15'
- en: Enhancing Web Apps with Forms, Session State, and Customizable Subdomains
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用表单、会话状态和可自定义子域名增强 Web 应用
- en: In Streamlit, *forms*, *Session State*, and *customizable subdomains* are all
    features that allow for more advanced customization and functionality in web applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Streamlit 中，*表单*、*会话状态*和*可自定义子域名*都是可以提供更多高级定制和功能的特性，适用于 Web 应用程序。
- en: '*Forms* allow users to create interactive forms within their Streamlit web
    app that can be used to collect user input and perform actions based on a specific
    group of inputs. Forms can contain a variety of input elements, such as text fields,
    drop-down menus, and checkboxes.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*表单*允许用户在 Streamlit 网页应用中创建交互式表单，可以用来收集用户输入并根据特定的一组输入执行操作。表单可以包含多种输入元素，如文本字段、下拉菜单和复选框。'
- en: '*Session State* is a feature that allows users to store and persist data across
    different sessions of their web app. This can be useful for storing user preferences
    or app settings.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '*会话状态*是一个功能，允许用户在他们的 Web 应用的不同会话之间存储和持久化数据。这对于存储用户偏好或应用设置非常有用。'
- en: Finally, *customizable subdomains* allow users to create a custom subdomain
    for their Streamlit app that can be useful for branding or creating a more memorable
    URL (instead of using the standard anonymous URL proposed automatically).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，*可自定义子域名*允许用户为他们的 Streamlit 应用创建一个自定义子域名，这对于品牌化或创建更易记的 URL（而不是使用自动生成的标准匿名
    URL）非常有用。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将涵盖以下主要内容：
- en: What are forms and when and why do we use them?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是表单，我们在什么情况下以及为什么使用它们？
- en: What is Session State and when do we use it?
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是会话状态（Session State），我们在什么情况下使用它？
- en: What are customizable subdomains and what possibilities do they offer?
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是可自定义子域名，它们提供了什么可能性？
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In this chapter, we’ll be using the following libraries, packages, and tools:'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这一章中，我们将使用以下库、包和工具：
- en: Sublime Text
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Sublime Text
- en: Python 3
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 3
- en: '`pipenv`'
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pipenv`'
- en: Streamlit
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Streamlit
- en: 'The code in this chapter can be accessed through the following GitHub link:
    [https://github.com/PacktPublishing/Web-App-Development-Made-Simple-with-Streamlit/tree/217479d2112ded99cfdd820a85709296ba5356b2/Chapter15](https://github.com/PacktPublishing/Web-App-Development-Made-Simple-with-Streamlit/tree/217479d2112ded99cfdd820a85709296ba5356b2/Chapter15)'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这章中的代码可以通过以下 GitHub 链接访问：[https://github.com/PacktPublishing/Web-App-Development-Made-Simple-with-Streamlit/tree/217479d2112ded99cfdd820a85709296ba5356b2/Chapter15](https://github.com/PacktPublishing/Web-App-Development-Made-Simple-with-Streamlit/tree/217479d2112ded99cfdd820a85709296ba5356b2/Chapter15)
- en: What are forms and when and why do we use them?
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是表单，我们在什么情况下以及为什么使用它们？
- en: '**Streamlit forms** is a feature that allows you to create interactive web
    forms in your Streamlit apps. These forms enable you to collect user input through
    different widgets such as textboxes, selects, checkboxes, and more. When a user
    submits a form, Streamlit automatically captures the input values and makes them
    available to your Python code.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**Streamlit 表单**是一个功能，允许你在 Streamlit 应用中创建交互式网页表单。这些表单可以通过各种小部件（如文本框、选择框、复选框等）收集用户输入。当用户提交表单时，Streamlit
    会自动捕获输入值，并使其可用于你的 Python 代码。'
- en: Using Streamlit forms is simple. You can define the form boundaries with `st.form()`
    and add widgets within it. Streamlit provides a variety of input components that
    make it easy for users to enter information such as text input, number input,
    and so on. This integration with Python eliminates the need for manual form handling.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Streamlit 表单非常简单。你可以通过 `st.form()` 定义表单的边界，并在其中添加小部件。Streamlit 提供了多种输入组件，使得用户可以轻松输入信息，如文本输入、数字输入等。这种与
    Python 的集成消除了手动处理表单的需求。
- en: Streamlit forms offer customization options to improve the user experience.
    You can add labels, default values, and tooltips to guide users. Additionally,
    you can control a form’s layout and style to match your app’s design.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Streamlit 表单提供了定制选项，以改善用户体验。你可以添加标签、默认值和提示信息来引导用户。此外，你还可以控制表单的布局和样式，以匹配你的应用设计。
- en: Form submission is always triggered by a submit button, allowing you to capture
    user input and perform actions based on it.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 表单提交总是通过提交按钮触发，这样你就可以捕获用户输入并根据它执行操作。
- en: 'To summarize, forms are groups of widgets, and we can run different groups
    of forms independently of one another. Let’s write some simple code to show this
    feature:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，表单是小部件的组合，我们可以独立运行不同组合的表单。让我们写一些简单的代码来展示这一特性：
- en: '![Figure 15.1: Starting point for forms](img/B21147_15_01.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图 15.1：表单的起始点](img/B21147_15_01.jpg)'
- en: 'Figure 15.1: Starting point for forms'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.1：表单的起始点
- en: 'The preceding code is extremely simple: after importing `streamlit`, we just
    print a title on the screen. Here is the result:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码非常简单：在导入`streamlit`后，我们仅仅在屏幕上打印了一个标题。结果如下：
- en: '![Figure 15.2: Starting point from the browser perspective](img/B21147_15_02.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图15.2：从浏览器角度的起始点](img/B21147_15_02.jpg)'
- en: 'Figure 15.2: Starting point from the browser perspective'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.2：从浏览器角度的起始点
- en: To introduce forms in our code, we essentially have two approaches. Let’s take
    a look at them one by one.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代码中引入表单时，基本上有两种方法。让我们一一看看它们。
- en: The context manager approach
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 上下文管理器方法
- en: 'The first way to introduce forms in our code is the *context manager approach*,
    an elegant approach that uses the `with` instruction. The `with` instruction makes
    it possible to *declare* the form just at the beginning of the code block (on
    *line 8* in *Figure 15**.3*) and then just use instructions in the usual way,
    typing `st.` with the name of the widget. So, write this code:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 引入表单的第一种方式是*上下文管理器方法*，这是一种优雅的方法，使用`with`语句。`with`语句使得我们可以在代码块的开头（*第8行*，见*图15.3*）声明表单，然后以常规方式使用指令，输入`st.`并加上小部件的名称。所以，写下这个代码：
- en: '![Figure 15.3: The context manager approach](img/B21147_15_03.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图15.3：上下文管理器方法](img/B21147_15_03.jpg)'
- en: 'Figure 15.3: The context manager approach'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.3：上下文管理器方法
- en: 'Here’s a breakdown of the code shown in *Figure 15**.3*:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是*图15.3*中展示的代码解析：
- en: On *line 8*, we created a form leveraging the `with` instruction. Please note
    that the only argument of the form is its key, and it can be any kind of text.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*第8行*，我们使用`with`语句创建了一个表单。请注意，表单的唯一参数是它的键，可以是任何类型的文本。
- en: After that, on *lines 9* and *10*, we inserted a couple of widgets in our new
    form, specifically a couple of `text_input` instances used to save the first name
    and last name of a hypothetical user.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 之后，在*第9行*和*第10行*，我们在新表单中插入了几个小部件，具体来说是两个`text_input`实例，用于保存假设用户的名字和姓氏。
- en: On *line 11*, we just merged the first and last names.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*第11行*，我们将名字和姓氏合并在一起。
- en: '*Line 13* is very important because each form needs to be activated by a submit
    button, which must be created using the `form_submit_button` method. In this case,
    as an argument, we use the label to be visualized in the form.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第13行*非常重要，因为每个表单都需要通过提交按钮激活，该按钮必须使用`form_submit_button`方法创建。在这种情况下，作为参数，我们使用要在表单中显示的标签。'
- en: Finally, on *line 15*, we used an `if` clause to double-check whether the button
    has been pushed; if it has, we print a success message.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，在*第15行*，我们使用了一个`if`语句来重新检查按钮是否已被按下；如果是的话，我们会打印一个成功信息。
- en: 'This is the result in the browser:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这是浏览器中的结果：
- en: '![Figure 15.4: Result using the context manager approach in the browser](img/B21147_15_04.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图15.4：使用上下文管理器方法在浏览器中的结果](img/B21147_15_04.jpg)'
- en: 'Figure 15.4: Result using the context manager approach in the browser'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.4：使用上下文管理器方法在浏览器中的结果
- en: When we click on the `text_input` instances and the button.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们点击`text_input`实例和按钮时。
- en: 'To keep the message out of the form, we can slightly change the code, as shown
    in the following figure:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将信息从表单中移除，我们可以稍微修改代码，如下图所示：
- en: '![Figure 15.5: Keeping the success message outside the form](img/B21147_15_05.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图15.5：将成功信息保持在表单外](img/B21147_15_05.jpg)'
- en: 'Figure 15.5: Keeping the success message outside the form'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.5：将成功信息保持在表单外
- en: 'Now, the `if` clause indentation has been changed to be exactly below the `with`
    instruction, which means below the form – that is, outside its code block. This
    is the result:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`if`语句的缩进已更改为准确地位于`with`语句下方，也就是说，位于表单外部——也就是它的代码块之外。结果是：
- en: '![Figure 15.6: A different position for the greeting message](img/B21147_15_06.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图15.6：问候信息的不同位置](img/B21147_15_06.jpg)'
- en: 'Figure 15.6: A different position for the greeting message'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.6：问候信息的不同位置
- en: Let’s now see the second approach, a classic one, used to introduce forms.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看第二种方法，一种经典的方法，用来引入表单。
- en: The classic approach
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 经典方法
- en: 'The classic approach is quite straightforward, since it doesn’t require the
    `with` instruction:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 经典方法相当直接，因为它不需要`with`语句：
- en: '![Figure 15.7: The classic approach to introduce forms in our code](img/B21147_15_07.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图15.7：在我们的代码中引入表单的经典方法](img/B21147_15_07.jpg)'
- en: 'Figure 15.7: The classic approach to introduce forms in our code'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.7：在我们的代码中引入表单的经典方法
- en: 'Here’s what we are doing this time:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们做的事情是：
- en: On *line 19*, we directly introduce the form.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*第19行*，我们直接引入了表单。
- en: After that, on *lines 20* and *21*, we create two new widgets, `text_input`
    and `selectbox`, respectively.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 之后，在*第20行*和*第21行*，我们分别创建了两个新小部件，`text_input`和`selectbox`。
- en: On *line 22*, we create a submit button. As usual, an `if` clause oversees whether
    or not the submit button has been pushed. It’s important to understand that, in
    this case, the indentation of the `if` clause will always be at the same level
    as that of the form, so the success message will always be outside the form box.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*第22行*，我们创建了一个提交按钮。和往常一样，一个`if`语句检查提交按钮是否被点击。需要理解的是，在这种情况下，`if`语句的缩进始终与表单的缩进保持在同一层级，因此成功消息将始终位于表单框之外。
- en: 'Here’s how the two forms created using the two approaches look in the browser:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是使用这两种方法创建的两个表单在浏览器中的展示效果：
- en: '![Figure 15.8: Two forms created with the context manager and classic approaches](img/B21147_15_08.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图 15.8：使用上下文管理器和经典方法创建的两个表单](img/B21147_15_08.jpg)'
- en: 'Figure 15.8: Two forms created with the context manager and classic approaches'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.8：使用上下文管理器和经典方法创建的两个表单
- en: Please note that we can insert data (this means using widgets) independently
    into the two forms. In fact, the two submit buttons are completely unrelated.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们可以独立地将数据（这意味着使用小部件）插入到这两个表单中。实际上，这两个提交按钮是完全不相关的。
- en: Forms are a very powerful way of keeping widgets and components segregated in
    a specific area of our web app. Let’s now see how to deal with so-called *sessions*.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 表单是将小部件和组件分隔在我们 web 应用的特定区域中的一种非常强大的方式。现在让我们看看如何处理所谓的*会话*。
- en: What is Session State and when do we use it?
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是会话状态，我们何时使用它？
- en: 'Streamlit was launched in 2019, and *statefulness* was a little problem for
    quite a long time since states weren’t managed natively. However, starting from
    version 0.8.4, things changed, and the official claim ([https://blog.streamlit.io/session-state-for-streamlit/](https://blog.streamlit.io/session-state-for-streamlit/))
    was as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Streamlit 于2019年发布，而*有状态性*在相当长的一段时间里是一个小问题，因为状态没有本地管理。然而，从0.8.4版本开始，情况发生了变化，官方声明（[https://blog.streamlit.io/session-state-for-streamlit/](https://blog.streamlit.io/session-state-for-streamlit/)）如下：
- en: '*You can now store information across app interactions* *and rerun!*'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*现在你可以跨应用交互存储信息* *并重新运行！*'
- en: To be honest, that claim is really perfect because it conveys everything about
    sessions. Streamlit’s **Session State** feature offers an efficient and sophisticated
    approach to session management. This feature enables the storage of variables
    across multiple reruns, facilitates the creation of interactive events on input
    widgets, and allows the use of callback functions to manage these events effectively.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 老实说，这个声明真的很完美，因为它传达了关于会话的一切。Streamlit 的**会话状态**功能提供了一种高效而复杂的会话管理方法。此功能支持在多次重新运行之间存储变量，促进在输入小部件上创建交互事件，并允许使用回调函数有效地管理这些事件。
- en: 'The robust capabilities of Session State enhance the development of various
    applications. These capabilities include the following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 会话状态的强大功能增强了各种应用程序的开发。这些功能包括以下几点：
- en: Integrating widgets that are interdependent
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成相互依赖的小部件
- en: Developing engaging stateful games, such as Battleship and Tic-Tac-Toe
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发引人入胜的有状态游戏，如战舰和井字棋
- en: Conducting data and image annotation tasks
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进行数据和图像标注任务
- en: Extending functionalities for diverse and complex uses, such as persistence
    of user data across multiple requests and efficient management of resources and
    data
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展功能以应对多样化和复杂的需求，如在多个请求之间持久化用户数据以及高效管理资源和数据
- en: Typically, using Streamlit without Session State means that interacting with
    a widget initiates a rerun, causing the variables defined in the script to reset
    with each execution. In contrast, employing Session State enables the preservation
    of variable values across reruns, which is particularly beneficial when there
    is a need to maintain variable states without reinitialization.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，使用没有会话状态的 Streamlit 意味着与小部件交互时会触发重新运行，导致脚本中定义的变量在每次执行时都会重置。相反，使用会话状态可以跨重新运行保留变量值，这在需要保持变量状态而无需重新初始化时特别有用。
- en: 'Let’s use the following code to see a little example in action and understand
    more. Start by writing the following code:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用以下代码来看一个小示例并进一步理解。首先编写以下代码：
- en: '![Figure 15.9: Session State in code](img/B21147_15_09.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图 15.9：代码中的会话状态](img/B21147_15_09.jpg)'
- en: 'Figure 15.9: Session State in code'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.9：代码中的会话状态
- en: 'The idea behind Session State is simple and genial: Streamlit always runs from
    top to bottom on every iteration, so we check whether a variable of our interest
    (`count` in the example) has already been initialized in `st.session_state`. If
    it is not initialized yet, we initialize it to a specific value (`0` in our case);
    otherwise, we don’t do anything.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Session State 的核心思想既简单又巧妙：Streamlit 每次迭代时都会从上到下执行，因此我们检查我们关注的变量（示例中的 `count`）是否已经在
    `st.session_state` 中初始化。如果尚未初始化，我们将其初始化为一个特定的值（在我们的例子中是 `0`）；否则，我们什么都不做。
- en: So, `st.session_state` is just a kind of *collection* that saves variables we
    don’t want to initialize every time.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`st.session_state` 就是一种 *集合*，用于保存我们不希望每次都初始化的变量。
- en: 'The preceding code is very easy. Here’s a breakdown:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码非常简单。下面是详细的解析：
- en: On *line 13*, we check whether the `count` variable is not in `session_state`;
    in this case, we initialize it to `0`
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 *第 13 行*，我们检查 `count` 变量是否不在 `session_state` 中；如果不在，我们将其初始化为 `0`。
- en: On *line 19*, we create a button to increment the count variable and we perform
    this operation using `st.session_state.count`; in this way, we remember the `count`
    variable’s value
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 *第 19 行*，我们创建了一个按钮来递增 `count` 变量，并通过 `st.session_state.count` 执行此操作；这样，我们就能记住
    `count` 变量的值。
- en: On *line 24*, we do the same, but decrementing the `count` variable
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 *第 24 行*，我们做了相同的操作，但是是对 `count` 变量进行递减。
- en: Finally, on *line 28*, we visualize a little message on the screen showing the
    `count` variable value
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，在 *第 28 行*，我们在屏幕上可视化显示 `count` 变量的值。
- en: 'This is the result in the browser:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这是浏览器中的结果：
- en: '![Figure 15.10: Session State in action](img/B21147_15_10.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图 15.10：Session State 的应用](img/B21147_15_10.jpg)'
- en: 'Figure 15.10: Session State in action'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.10：Session State 的应用
- en: Please verify that every time you click on the **Increment** or **Decrement**
    button, the value of **Count** is automatically updated.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 请验证每次点击 **递增** 或 **递减** 按钮时，**Count** 的值是否会自动更新。
- en: The code in *Figure 15**.9* demonstrates the persistence of values across reruns.
    However, let’s explore a more intricate scenario. In Streamlit, it is feasible
    to assign *callbacks* to various widgets, such as `st.button` or `st.slider`.
    This is achieved by utilizing the `on_change` argument, allowing for more advanced
    interactivity and functionality.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15.9* 中的代码展示了值在重新运行时的持久性。然而，让我们探讨一个更复杂的场景。在 Streamlit 中，可以将 *回调* 分配给不同的小部件，如
    `st.button` 或 `st.slider`。这通过使用 `on_change` 参数实现，允许更高级的互动和功能。'
- en: A callback, often referred to as a *call-after* function, is a segment of executable
    code that is provided as an argument to another piece of code. This arrangement
    anticipates that the receiving code will execute the callback at a specified moment.
    Typical scenarios for such execution include user interactions such as clicking
    a button or adjusting a slider – essentially, whenever a change is detected.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 回调函数，通常称为 *回调后* 函数，是一段可执行的代码，作为参数传递给另一段代码。这个安排预期接收代码会在指定的时刻执行回调函数。此类执行的典型场景包括用户交互，如点击按钮或调整滑块
    —— 本质上是每当检测到变化时。
- en: 'Utilizing Session State enables the management of events linked to modifications
    in a widget or button clicks through callback functions. This implies that when
    a callback function is associated with a widget, any alteration in the widget
    initiates a specific sequence: the callback function is executed first, followed
    by a top-to-bottom execution of the application.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Session State 可以通过回调函数管理与小部件修改或按钮点击相关的事件。这意味着，当一个回调函数与小部件关联时，小部件的任何变化都会启动一个特定的序列：首先执行回调函数，然后应用程序会从上到下地执行。
- en: 'Let’s see callbacks in action:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看回调函数的实际应用：
- en: '![Figure 15.11: Callbacks in code](img/B21147_15_11.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图 15.11：代码中的回调函数](img/B21147_15_11.jpg)'
- en: 'Figure 15.11: Callbacks in code'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.11：代码中的回调函数
- en: 'Here’s a breakdown of the code in *Figure 15**.11*:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 *图 15.11* 中代码的详细解析：
- en: On *line 32*, we define a callback function named `update_first`. This function
    updates the value of the *second* variable contained in the `session_state` widget
    to the value of the *first* variable always stored in the `session_state` widget.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 *第 32 行*，我们定义了一个名为 `update_first` 的回调函数。这个函数将 `session_state` 小部件中 *第二个* 变量的值更新为始终存储在
    `session_state` 小部件中的 *第一个* 变量的值。
- en: On *line 35*, we define a second callback function that is exactly the same
    as the first one, but updates the value of the *first* variable according to the
    value of the *second* one.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 *第 35 行*，我们定义了第二个回调函数，它与第一个完全相同，但会根据 *第二个* 变量的值更新 *第一个* 变量的值。
- en: 'On *lines 39 and 40*, we introduce two `text_input` widgets. Among their arguments,
    as usual, we can find a label and a key, but this time there is something new:
    `on_change`.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*第39行和40行*，我们引入了两个`text_input`小部件。在它们的参数中，像往常一样，我们可以找到标签和键，但这次有一个新内容：`on_change`。
- en: Here, the callbacks enter action when a change happens in the widgets (so, when
    some text is inserted) when the `update_first` function is executed at *line 39*
    and the `update_second` function is executed on *line 40*.
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，当小部件中发生变化（比如插入文本）时，回调函数开始起作用，`update_first`函数在*第39行*执行，而`update_second`函数在*第40行*执行。
- en: 'In this way, we create two widgets with mirrored values. This is the result
    in the browser:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们创建了两个具有镜像值的小部件。浏览器中的结果如下：
- en: '![Figure 15.12: Result of the callback action](img/B21147_15_12.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图 15.12：回调操作的结果](img/B21147_15_12.jpg)'
- en: 'Figure 15.12: Result of the callback action'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.12：回调操作的结果
- en: As we can see, every time we insert text into the first input box, the second
    one is updated, and vice versa.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，每次在第一个输入框中插入文本时，第二个输入框也会被更新，反之亦然。
- en: Session State is perhaps one of the most powerful features of Streamlit. Please
    learn carefully how to leverage it.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 会话状态可能是Streamlit最强大的功能之一。请仔细学习如何利用它。
- en: Let’s now see the advantages offered by *customizable subdomains*.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下*自定义子域名*所带来的优势。
- en: What are customizable subdomains and what possibilities do they offer?
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是自定义子域名，它们提供了哪些可能性？
- en: 'We have already deployed two applications on Streamlit Cloud: the *NLP App*
    and the *COVID-19 Detection Tool*. So, we are quite familiar with the process,
    and even how to solve problems arising due to big files or a need for unconventional
    libraries.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在Streamlit Cloud上部署了两个应用程序：*NLP应用*和*COVID-19检测工具*。因此，我们对这个过程非常熟悉，甚至知道如何解决因大文件或需要非常规库而出现的问题。
- en: 'Upon deploying our application on Community Cloud, it is assigned an automatically
    generated subdomain, which is structured based on our GitHub repository. This
    subdomain, unique to our application, serves as a means to share the app with
    others. Nevertheless, the default subdomain can often be cumbersome and not particularly
    user-friendly. For instance, a subdomain such as the following may not be easily
    memorable:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将应用程序部署到Community Cloud后，它会分配一个自动生成的子域名，结构基于我们的GitHub仓库。这个子域名是应用程序独有的，用于与他人分享该应用。然而，默认的子域名往往很笨重，并且不太友好。例如，下面这样的子域名可能并不容易记住：
- en: '[PRE0]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To enhance shareability and recognition, we have the option to establish a
    custom subdomain. This customization allows the subdomain to better represent
    the content of our app, our personal brand, or any other preferred aspect. The
    custom URL would then be formatted as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了增强共享性和识别度，我们可以选择建立一个自定义子域名。这一自定义使得子域名能够更好地代表我们应用的内容、个人品牌或其他任何偏好方面。自定义URL的格式如下：
- en: '[PRE1]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To tailor the subdomain of your application within Streamlit’s Cloud workspace,
    follow these straightforward steps:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要定制你应用在Streamlit Cloud工作区内的子域名，请按照以下简单步骤操作：
- en: 'Navigate to the right of your app, click on the **︙** overflow menu, and then
    select **Settings**:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航至你应用的右侧，点击**︙**溢出菜单，然后选择**设置**：
- en: '![Figure 15.13: Deployed app settings on Streamlit Cloud](img/B21147_15_13.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图 15.13：在Streamlit Cloud上的部署应用设置](img/B21147_15_13.jpg)'
- en: 'Figure 15.13: Deployed app settings on Streamlit Cloud'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.13：在Streamlit Cloud上的部署应用设置
- en: In the app settings modal, access the **General** tab. Here, you’ll find your
    app’s current unique subdomain.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用设置模态框中，访问**常规**标签。这里，你会看到你应用的当前唯一子域名。
- en: Choose a custom subdomain that is between `6` and `63` characters long for your
    app’s URL.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为你的应用URL选择一个长度在`6`到`63`个字符之间的自定义子域名。
- en: 'Click **Save** to confirm:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**保存**以确认：
- en: '![Figure 15.14: A new subdomain for our app](img/B21147_15_14.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图 15.14：我们应用的新子域名](img/B21147_15_14.jpg)'
- en: 'Figure 15.14: A new subdomain for our app'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.14：我们应用的新子域名
- en: 'This process is quick and efficient. Once completed, your app will be accessible
    via the newly set custom subdomain URL. In cases where the chosen custom subdomain
    is unavailable (for instance, if it is already in use), an error message will
    be displayed, prompting you to select a different subdomain, as shown in the following
    screenshot:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程既快速又高效。完成后，你的应用将通过新设置的自定义子域名URL进行访问。如果所选的自定义子域名不可用（例如已经被使用），系统会显示错误消息，提示你选择其他子域名，下面的截图演示了这一点：
- en: '![Figure 15.15: “This subdomain is already taken” error message](img/B21147_15_15.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图 15.15：“该子域名已被占用”错误信息](img/B21147_15_15.jpg)'
- en: 'Figure 15.15: “This subdomain is already taken” error message'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.15：“该子域名已被占用”错误信息
- en: Being able to select a subdomain name that perfectly suits the aim of our web
    application is a very powerful customization.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 能够选择一个完美符合我们网页应用目标的子域名是一个非常强大的自定义功能。
- en: Summary
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we covered some topics that can really increase the level of
    our web applications.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了一些能够真正提升我们网页应用水平的主题。
- en: First of all, we saw what forms are and how to use them, discovering that having
    independent groups of widgets inside our web apps can make a big difference. All
    we need to do is define these forms and include some widgets inside them, using
    a button to trigger the widgets. Even the button is customizable since it can
    be included in the form or placed outside it.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们了解了什么是表单以及如何使用它们，发现将独立的小部件组放入我们的网页应用中会带来很大不同。我们需要做的就是定义这些表单，并在其中包含一些小部件，使用按钮来触发这些小部件。甚至按钮也是可以自定义的，因为它可以放在表单内，也可以放在表单外。
- en: Further, we learned that Session State is an incredibly powerful weapon in our
    hands. At last, we can persist the values of our variables, and this opens up
    an incredible scenario of use cases to us. Moreover, thanks to callbacks, we can
    decide what to do when a user interacts with our widgets, calling back fully customized
    functions that completely match our needs.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还学到了 Session State 是我们手中的一个极其强大的工具。最终，我们可以保存变量的值，这为我们打开了一个令人难以置信的使用场景。而且，借助回调，我们可以决定在用户与小部件交互时该做什么，调用完全自定义的函数，完美契合我们的需求。
- en: 'Finally, by customizing the subdomains of our deployed web applications, we
    achieved two targets: we made them much easier to remember and we gave them a
    very professional touch!'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通过自定义我们部署的网页应用的子域名，我们实现了两个目标：让它们更容易记住，并为它们增添了一丝专业感！
- en: In the next and final chapter, we are going to sum up the long journey we’ve
    made together, highlighting considerations about the Streamlit framework, discussing
    what the very important takeaways are, and giving some suggestions for the next
    steps.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的最后一章中，我们将总结我们共同经历的这段长旅程，重点讨论 Streamlit 框架的相关考虑事项，分析重要的收获，并提出一些下一步的建议。
