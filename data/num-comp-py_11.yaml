- en: Boolean Indexing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 布尔索引
- en: Filtering data from a dataset is one of the most common and basic operations.
    There are numerous ways to filter (or subset) data in pandas with **b****oolean
    indexing**. Boolean indexing (also known as **boolean selection**) can be a confusing
    term, but for the purposes of pandas, it refers to selecting rows by providing
    a boolean value (`True` or `False`) for each row. These boolean values are usually
    stored in a Series or NumPy `ndarray` and are usually created by applying a boolean
    condition to one or more columns in a DataFrame. We begin by creating boolean
    Series and calculating statistics on them and then move on to creating more complex
    conditionals before using boolean indexing in a wide variety of ways to filter
    data.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 从数据集中筛选数据是最常见和基本的操作之一。使用**布尔索引**，有多种方式可以在 pandas 中筛选（或子集化）数据。布尔索引（也称为**布尔选择**）可能是一个让人困惑的术语，但在
    pandas 中，它指的是通过为每一行提供布尔值（`True` 或 `False`）来选择行。这些布尔值通常存储在 Series 或 NumPy 的`ndarray`中，并通常通过对
    DataFrame 中一个或多个列应用布尔条件来创建。我们首先创建布尔 Series，并对其计算统计数据，然后再通过创建更复杂的条件来使用布尔索引，以多种方式筛选数据。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: Calculating boolean statistics
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算布尔统计数据
- en: Constructing multiple boolean conditions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造多个布尔条件
- en: Filtering with boolean indexing
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用布尔索引筛选
- en: Replicating boolean indexing with index selection
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用索引选择复制布尔索引
- en: Selecting with unique and sorted indexes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用唯一且排序的索引进行选择
- en: Gaining perspective on stock prices
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取股价的视角
- en: Translating SQL WHERE clauses
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转换 SQL WHERE 子句
- en: Determining the normality of stock market returns
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定股市回报的正态性
- en: Improving readability of boolean indexing with the query method
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 query 方法提高布尔索引的可读性
- en: Preserving Series with the `where` method
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `where` 方法保留 Series
- en: Masking DataFrame rows
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 屏蔽 DataFrame 行
- en: Selecting with booleans, integer location, and labels
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用布尔值、整数位置和标签进行选择
- en: Calculating boolean statistics
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算布尔统计数据
- en: When first getting introduced to boolean Series, it can be informative to calculate
    basic summary statistics on them. Each value of a boolean series evaluates to
    0 or 1 so all the Series methods that work with numerical values also work with
    booleans.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在首次接触布尔 Series 时，计算其基本汇总统计信息可能会很有帮助。布尔 Series 中的每个值都被评估为 0 或 1，因此所有适用于数值的 Series
    方法也适用于布尔值。
- en: Getting ready
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we create a boolean Series by applying a condition to a column
    of data and then calculate summary statistics from it.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们通过对数据列应用条件来创建布尔 Series，然后从中计算汇总统计信息。
- en: How to do it...
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Read in the `movie` dataset, set the index to the movie title, and inspect
    the first few rows:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取 `movie` 数据集，将索引设置为电影标题，并查看前几行：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '![](img/db52f01e-a8cc-453c-8c12-16c0634faaba.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](img/db52f01e-a8cc-453c-8c12-16c0634faaba.png)'
- en: 'Determine whether the duration of each movie is longer than two hours by using
    the greater than comparison operator with the `duration` Series:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用大于比较运算符与 `duration` Series，判断每部电影的时长是否超过两小时：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can now use this Series to determine the number of movies that are longer
    than two hours:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以使用这个 Series 来确定时长超过两小时的电影数量：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To find the percentage of movies in the dataset longer than two hours, use
    the `mean` method:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要找出数据集中时长超过两小时的电影百分比，可以使用 `mean` 方法：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Unfortunately, the output from step 4 is misleading. The `duration` column
    has a few missing values. If you look back at the DataFrame output from step 1,
    you will see that the last row is missing a value for `duration`. The boolean
    condition in step 2 returns `False` for this. We need to drop the missing values
    first, then evaluate the condition and take the mean:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不幸的是，第 4 步的输出是误导性的。`duration` 列有一些缺失值。如果你回顾第 1 步的 DataFrame 输出，你会看到最后一行缺少 `duration`
    的值。第 2 步的布尔条件对此返回了 `False`。我们需要先删除缺失值，然后再评估条件并计算均值：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Use the `describe` method to output a few summary statistics on the boolean
    Series:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `describe` 方法输出布尔 Series 的一些汇总统计信息：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How it works...
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Most DataFrames will not have columns of booleans like our movie dataset. The
    most straightforward method to produce a boolean Series is to apply a condition
    to one of the columns using one of the comparison operators. In step 2, we use
    the greater than operator to test whether or not the duration of each movie was
    more than two hours (120 minutes). Steps 3 and 4 calculate two important quantities
    from a boolean Series, its sum and mean. These methods are possible as Python
    evaluates `False`/`True` as 0/1.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数DataFrame不会像我们的电影数据集那样拥有布尔列。生成布尔系列的最直接方法是将条件应用于其中一列，使用比较运算符。在步骤2中，我们使用大于运算符来测试每部电影的时长是否超过两小时（120分钟）。步骤3和4计算了布尔系列的两个重要量——其总和和均值。这些方法之所以可行，是因为Python将`False`/`True`分别视为0/1。
- en: 'You can prove to yourself that the mean of a boolean Series represents the
    percentage of `True` values. To do this, use the `value_counts` method to count
    with the `normalize` parameter set to `True` to get its distribution:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过计算布尔系列的均值来证明其表示`True`值的百分比。为此，可以使用`value_counts`方法，并将`normalize`参数设置为`True`来获取其分布情况：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Step 5 alerts us to the incorrect result from step 4\. Even though the `duration`
    column had missing values, the boolean condition evaluated all these comparisons
    against missing values as `False`. Dropping these missing values allows us to
    calculate the correct statistic. This is done in one step through method chaining.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤5提醒我们注意步骤4的错误结果。尽管`duration`列有缺失值，但布尔条件仍然将所有针对缺失值的比较结果评估为`False`。删除这些缺失值使我们能够计算出正确的统计量。这可以通过方法链式调用一步完成。
- en: Step 6 shows that pandas treats boolean columns similarly to how it treats object
    data types by displaying frequency information. This is a natural way to think
    about boolean Series, rather than display quantiles like it does with numeric
    data.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤6展示了pandas如何将布尔列与其处理对象数据类型的方式相似，显示频率信息。这是思考布尔系列的一种自然方式，而不是像处理数值数据时那样显示分位数。
- en: There's more...
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: 'It is possible to compare two columns from the same DataFrame to produce a
    boolean Series. For instance, we could determine the percentage of movies that
    have actor 1 with more Facebook likes than actor 2\. To do this, we would select
    both of these columns and then drop any of the rows that had missing values for
    either movie. Then we would make the comparison and calculate the mean:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 可以比较来自同一DataFrame的两列，生成布尔系列。例如，我们可以确定电影中演员1是否比演员2拥有更多的Facebook点赞数。为此，我们需要选择这两列，并删除任何包含缺失值的行。然后，我们进行比较并计算均值：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Constructing multiple boolean conditions
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建多个布尔条件
- en: In Python, boolean expressions use the built-in logical operators `and`, `or`,
    and `not`. These keywords do not work with boolean indexing in pandas and are
    respectively replaced with `&`, `|`, and `~`. Additionally, each expression must
    be wrapped in parentheses or an error will be raised.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，布尔表达式使用内建的逻辑运算符`and`、`or`和`not`。这些关键字不能与pandas中的布尔索引一起使用，分别被替换为`&`、`|`和`~`。此外，每个表达式必须用括号括起来，否则会抛出错误。
- en: Getting ready
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Constructing a precise filter for your dataset might have you combining multiple
    boolean expressions together to extract an exact subset. In this recipe, we construct
    multiple boolean expressions before combining them together to find all the movies
    that have an `imdb_score` greater than 8, a `content_rating` of PG-13, and a `title_year`
    either before 2000 or after 2009.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 构建一个精确的筛选器来处理你的数据集，可能需要将多个布尔表达式结合起来，提取出一个精确的子集。在这个步骤中，我们构建了多个布尔表达式，并将它们结合起来，找出所有`imdb_score`大于8、`content_rating`为PG-13且`title_year`早于2000年或晚于2009年的电影。
- en: How to do it...
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Load in the movie dataset and set the index as the title:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载电影数据集并将标题设置为索引：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Create a variable to hold each set of criteria independently as a boolean Series:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个变量来独立地存储每组标准，作为一个布尔系列：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Combine all the criteria together into a single boolean Series:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有标准结合成一个布尔系列：
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: How it works...
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: All values in a Series can be compared against a scalar value using the standard
    comparison operators( `<`, `>`, `==`, `!=`, `<=`, `>=`). The expression `movie.imdb_score
    > 8` yields a Series of booleans where all `imdb_score` values prices exceeding
    8 are `True` and those less than or equal to 8 are `False`. The index of this
    boolean Series retains the same index as the original and in this case, is the
    title of the movie.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Series中的所有值都可以使用标准的比较运算符（`<`、`>`、`==`、`!=`、`<=`、`>=`）与标量值进行比较。表达式`movie.imdb_score
    > 8`将产生一个布尔值Series，其中所有`imdb_score`大于8的值为`True`，小于或等于8的为`False`。这个布尔Series的索引保持与原始Series相同，在这个例子中，是电影的标题。
- en: The `criteria3` variable is created by two independent boolean expressions.
    Each expression must be enclosed in parentheses to function properly. The pipe
    character, `|`, is used to create a logical `or` condition between each of the
    values in both Series.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`criteria3`变量由两个独立的布尔表达式组成。每个表达式必须用括号括起来才能正常工作。管道字符`|`用于在两个Series的每个值之间创建逻辑`or`条件。'
- en: All three criteria need to be `True` to match the requirements of the recipe.
    They are each combined together with the ampersand character, `&`, which creates
    a logical `and` condition between each Series value.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 所有三个条件都需要为`True`，才能符合食谱的要求。它们通过与符号`&`结合，形成一个逻辑`and`条件，适用于每个Series值。
- en: There's more...
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'A consequence of pandas using different syntax for the logical operators is
    that operator precedence is no longer the same. The comparison operators have
    a higher precedence than `and`, `or`, and `not`. However, the new operators for
    pandas (the bitwise operators `&`, `|`, and `~`) have a higher precedence than
    the comparison operators, thus the need for parentheses. An example can help clear
    this up. Take the following expression:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: pandas使用不同语法进行逻辑运算符的结果是，运算符的优先级不再相同。比较运算符的优先级高于`and`、`or`和`not`。然而，pandas的新运算符（按位运算符`&`、`|`和`~`）的优先级高于比较运算符，因此需要使用括号。以下是一个示例，帮助更清楚地理解：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the preceding expression, `5 < 10` evaluates first, followed by `3 < 4`,
    and finally, the `and` evaluates. Python progresses through the expression as
    follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的表达式中，`5 < 10`首先求值，然后是`3 < 4`，最后求值`and`。Python按如下顺序推进表达式：
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let''s take a look at what would happen if the expression in `criteria3` was
    written as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如果`criteria3`中的表达式写成如下会发生什么：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As the bitwise operators have higher precedence than the comparison operators,
    `2000 | movie.title_year` is evaluated first, which is nonsensical and raises
    an error. Therefore, parentheses are needed to have the operations evaluated in
    the correct order.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 由于按位运算符的优先级高于比较运算符，首先会求值`2000 | movie.title_year`，这是没有意义的并且会抛出错误。因此，需要使用括号来确保运算以正确的顺序进行。
- en: Why can't pandas use `and`, `or`, and `not`? When these keywords are evaluated,
    Python attempts to find the **truthiness** of the objects as a whole. As it does
    not make sense for a Series as a whole to be either True or False--only each element--pandas
    raises an error.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么pandas不能使用`and`、`or`和`not`？当这些关键字被求值时，Python试图找到对象整体的**真值**。由于将整个Series视为True或False没有意义——只有每个元素才有意义——因此pandas会抛出错误。
- en: Many objects in Python have boolean representation. For instance, all integers
    except 0 are considered `True`. All strings except the empty string are `True`.
    All non-empty sets, tuples, dictionaries, and lists are `True`. An empty DataFrame
    or Series does not evaluate as True or False and instead an error is raised. In
    general, to retrieve the truthiness of a Python object, pass it to the `bool`
    function.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的许多对象都有布尔表示。例如，除0以外的所有整数都被视为`True`。除空字符串外的所有字符串都为`True`。所有非空的集合、元组、字典和列表都为`True`。一个空的DataFrame或Series不会被评估为True或False，而是抛出错误。通常，要获取Python对象的真值，可以将其传递给`bool`函数。
- en: See also
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另见
- en: Python operator precedence ([http://bit.ly/2vxuqSn](https://docs.python.org/3/reference/expressions.html#operator-precedence))
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python运算符优先级（[http://bit.ly/2vxuqSn](https://docs.python.org/3/reference/expressions.html#operator-precedence)）
- en: Filtering with boolean indexing
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用布尔索引进行筛选
- en: Boolean selection for Series and DataFrame objects is virtually identical. Both
    work by passing a Series of booleans indexed identically to the object being filtered
    to the indexing operator.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Series和DataFrame对象的布尔选择几乎是相同的。两者都是通过将一个布尔值Series（其索引与被过滤对象相同）传递给索引运算符来实现的。
- en: Getting ready
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe constructs two complex and independent boolean criteria for different
    sets of movies. The first set of movies comes from the previous recipe and consists
    of those with an `imdb_score` greater than 8, a `content_rating` of PG-13, and
    a `title_year` either before 2000 or after 2009\. The second set of movies consists
    of those with `imdb_score` less than 5, a `content_rating` of R, and a `title_year`
    between 2000 and 2010.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例构建了两个复杂且独立的布尔标准，用于选择不同的电影集。第一组电影来自前一个示例，包含 `imdb_score` 大于 8，`content_rating`
    为 PG-13，以及 `title_year` 在 2000 年之前或 2009 年之后的电影。第二组电影包含 `imdb_score` 小于 5，`content_rating`
    为 R，并且 `title_year` 在 2000 年到 2010 年之间的电影。
- en: How to do it...
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Read in the `movie` dataset, set the index to the `movie_title`, and create
    the first set of criteria:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取 `movie` 数据集，将索引设置为 `movie_title`，并创建第一组标准：
- en: '[PRE14]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Create criteria for the second set of movies:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为第二组电影创建标准：
- en: '[PRE15]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Combine the two sets of criteria using the pandas `or` operator. This yields
    a boolean Series of all movies that are members of either set:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 pandas `or` 操作符将两个标准结合起来。这将生成一个布尔序列，包含属于任一标准的所有电影：
- en: '[PRE16]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Once you have your boolean Series, you simply pass it to the indexing operator
    to filter the data:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你有了布尔序列，只需将其传递给索引操作符来过滤数据：
- en: '[PRE17]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '![](img/20f2408c-8036-4718-b24d-414396bf1b93.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](img/20f2408c-8036-4718-b24d-414396bf1b93.png)'
- en: 'We have successfully filtered the data and all the columns of the DataFrame.
    We can''t easily perform a manual check to determine whether the filter worked
    correctly. Let''s filter both rows and columns with the `.loc` indexer:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经成功地过滤了数据和数据框的所有列。我们无法轻松地手动检查过滤是否正确。让我们通过 `.loc` 索引器同时过滤行和列：
- en: '[PRE18]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '![](img/45dd3c6c-983d-48ac-a195-cf04a3d34701.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/45dd3c6c-983d-48ac-a195-cf04a3d34701.png)'
- en: How it works...
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In step 1 and step 2, each set of criteria is built from simpler boolean expressions.
    It is not necessary to create a different variable for each boolean expression
    as done here, but it does make it far easier to read and debug any logic mistakes.
    As we desire both sets of movies, step 3 uses the pandas logical `or` operator
    to combine them.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 1 步和第 2 步中，每组标准都由更简单的布尔表达式构建。并不需要像这里那样为每个布尔表达式创建不同的变量，但这确实使得读取和调试逻辑错误更容易。由于我们需要两组电影，第
    3 步使用 pandas 逻辑 `or` 操作符将它们结合起来。
- en: Step 4 shows the exact syntax of how boolean indexing works. You simply pass
    the Series of booleans created from step 3 directly to the indexing operator.
    Only the movies with `True` values from `final_crit_all` are selected.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 第 4 步展示了布尔索引的准确语法。你只需将第 3 步中创建的布尔序列直接传递给索引操作符。只有 `final_crit_all` 中值为 `True`
    的电影会被选择。
- en: Boolean indexing also works with the `.loc` indexer as seen in step 5 by simultaneously
    doing boolean indexing and individual column selection. This slimmed DataFrame
    is far easier to check manually whether the logic was implemented correctly.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔索引也可以与 `.loc` 索引器一起使用，如第 5 步所示，通过同时进行布尔索引和单独列选择。这种精简的数据框更容易手动检查逻辑是否正确实现。
- en: Boolean indexing does not quite work with the `.iloc` indexing operator. If
    you pass in a boolean series to it, an exception will get raised. However, if
    you pass in a boolean ndarray it will the same as it does in this recipe with
    the other indexers.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔索引不能与 `.iloc` 索引操作符一起正常工作。如果将布尔序列传递给它，会引发异常。但是，如果传递布尔 ndarray，它将与其他索引器中的行为相同。
- en: There's more...
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'As was stated earlier, it is possible to use one long boolean expression in
    place of several other shorter ones. To replicate the `final_crit_a` variable
    from step 1 with one long line of code, we can do the following:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，可以使用一个长的布尔表达式代替多个较短的表达式。为了用一行长代码复制第 1 步中的 `final_crit_a` 变量，我们可以这样做：
- en: '[PRE19]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: See also
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另见
- en: Pandas official documentation on *boolean indexing* ([http://bit.ly/2v1xK77](http://pandas.pydata.org/pandas-docs/stable/indexing.html#boolean-indexing))
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pandas 官方文档中的 *布尔索引* ([http://bit.ly/2v1xK77](http://pandas.pydata.org/pandas-docs/stable/indexing.html#boolean-indexing))
- en: Checking the truth of a Python object ([http://bit.ly/2vn8WXX](https://docs.python.org/3/library/stdtypes.html#truth))
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查 Python 对象的真实性 ([http://bit.ly/2vn8WXX](https://docs.python.org/3/library/stdtypes.html#truth))
- en: Replicating boolean indexing with index selection
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用索引选择复制布尔索引
- en: It is possible to replicate specific cases of boolean selection by taking advantage
    of the index. Selection through the index is more intuitive and makes for greater
    readability.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 通过利用索引，复制特定的布尔选择情况是可能的。通过索引进行选择更加直观，也提高了可读性。
- en: Getting ready
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we use the `college` dataset to select all institutions from
    a particular state with both boolean indexing and index selection and then compare
    each of their performance against one another.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们使用`college`数据集通过布尔索引和索引选择分别选择来自特定州的所有机构，并将它们的性能进行比较。
- en: How to do it...
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Read in the `college` dataset and use boolean indexing to select all institutions
    from the state of Texas (TX):'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取`college`数据集并使用布尔索引选择德克萨斯州（TX）的所有机构：
- en: '[PRE20]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Pandas official documentation on
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Pandas官方文档
- en: '![](img/d5e22aa2-e86e-4927-afeb-4f898a718bdf.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d5e22aa2-e86e-4927-afeb-4f898a718bdf.png)'
- en: 'To replicate this using index selection, we need to move the `STABBR` column
    into the index. We can then use label-based selection with the `.loc` indexer:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了通过索引选择来复制此操作，我们需要将`STABBR`列移到索引中。然后我们可以使用基于标签的选择，通过`.loc`索引器来选择：
- en: '[PRE21]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '![](img/7500adf0-77c4-4a09-84bd-047e03cb3a84.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7500adf0-77c4-4a09-84bd-047e03cb3a84.png)'
- en: 'Let''s compare the speed of both methods:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们比较两种方法的速度：
- en: '[PRE22]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Boolean indexing takes three times as long as index selection. As setting the
    index does not come for free, let''s time that operation as well:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 布尔索引的时间是索引选择的三倍。由于设置索引并非免费的，因此我们也需要计时这个操作：
- en: '[PRE23]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: How it works...
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Step 1 creates a boolean Series by determining which rows of data have `STABBR`
    equal to `TX`. This Series is passed to the indexing operator, which subsets the
    data. This process may be replicated by moving that same column to the index and
    simply using basic label-based index selection with `.loc`. Selection via the
    index is much faster than boolean selection.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步通过判断哪些数据行的`STABBR`等于`TX`来创建布尔Series。这个Series被传递给索引操作符，进而对数据进行子集化。可以通过将相同的列移动到索引中，并使用基于标签的索引选择`.loc`来复制此过程。通过索引选择的数据比通过布尔选择的数据要快得多。
- en: There's more...
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: 'This recipe only selects a single state. It is possible to select multiple
    states with both boolean and index selection. Let''s select **Texas** (**TX**),
    **California** (**CA**), and **New York** (**NY**). With boolean selection, you
    can use the `isin` method but with indexing, just pass a list to `.loc`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 本例只选择一个州。也可以使用布尔索引和索引选择同时选择多个州。让我们选择**德克萨斯**（**TX**）、**加利福尼亚**（**CA**）和**纽约**（**NY**）。对于布尔选择，可以使用`isin`方法；而对于索引选择，只需将列表传递给`.loc`：
- en: '[PRE24]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: There is quite a bit more to the story than what this recipe explains. Pandas
    implements the index differently based on whether the index is unique or sorted.
    See the following recipe for more details.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这篇食谱解释的内容远不止这些。Pandas根据索引是否唯一或已排序来实现索引。有关更多详细信息，请参阅以下食谱。
- en: Selecting with unique and sorted indexes
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用唯一和已排序索引进行选择
- en: Index selection performance drastically improves when the index is unique or
    sorted. The prior recipe used an unsorted index that contained duplicates, which
    makes for relatively slow selections.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当索引唯一或已排序时，索引选择性能会大幅提高。之前的例子使用了一个未排序的索引，该索引包含重复项，这导致选择过程相对较慢。
- en: Getting ready
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we use the `college` dataset to form unique or sorted indexes
    to increase the performance of index selection. We will continue to compare the
    performance to boolean indexing as well.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们使用`college`数据集来形成唯一或排序的索引，以提高索引选择的性能。我们将继续将其与布尔索引进行性能比较。
- en: How to do it...
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Read in the college dataset, create a separate DataFrame with `STABBR` as the
    index, and check whether the index is sorted:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取college数据集，创建一个以`STABBR`为索引的单独DataFrame，并检查索引是否已排序：
- en: '[PRE25]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Sort the index from `college2` and store it as another object:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对`college2`的索引进行排序，并将其存储为另一个对象：
- en: '[PRE26]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Time the selection of the state of Texas (TX) from all three DataFrames:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对来自三个数据框架的德克萨斯州（TX）选择进行计时：
- en: '[PRE27]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The sorted index performs nearly an order of magnitude faster than boolean
    selection. Let''s now turn towards unique indexes. For this, we use the institution
    name as the index:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 排序后的索引比布尔选择快近一个数量级。现在我们来看看唯一索引。为此，我们使用机构名称作为索引：
- en: '[PRE28]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Let''s select Stanford University with boolean indexing:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用布尔索引选择斯坦福大学：
- en: '[PRE29]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '![](img/54c9850e-c00d-43fb-887c-ccbfdc6b81f1.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](img/54c9850e-c00d-43fb-887c-ccbfdc6b81f1.png)'
- en: 'Let''s select Stanford University with index selection:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用索引选择来选择斯坦福大学：
- en: '[PRE30]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'They both produce the same data, just with different objects. Let''s time each
    approach:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它们都产生相同的数据，只是对象不同。让我们对每种方法进行计时：
- en: '[PRE31]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: How it works...
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: When the index is not sorted and contains duplicates, as with `college2`, pandas
    will need to check every single value in the index in order to make the correct
    selection. When the index is sorted, as with `college3`, pandas takes advantage
    of an algorithm called **binary search** to greatly improve performance.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当索引未排序且包含重复项时，例如`college2`，Pandas需要检查索引中的每个值，以确保做出正确选择。当索引已排序时，如`college3`，Pandas利用一种叫做**二分查找**的算法，极大地提高了性能。
- en: In the second half of the recipe, we use a unique column as the index. Pandas
    implements unique indexes with a hash table, which makes for even faster selection.
    Each index location can be looked up in nearly the same time regardless of its
    length.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这部分的食谱中，我们使用一个独特的列作为索引。Pandas通过哈希表实现唯一索引，这使得选择操作更加高效。无论索引的长度如何，每个索引位置几乎可以在相同的时间内被查找。
- en: There's more...
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: 'Boolean selection gives much more flexibility than index selection as it is
    possible to condition on any number of columns. In this recipe, we used a single
    column as the index. It is possible to concatenate multiple columns together to
    form an index. For instance, in the following code, we set the index equal to
    the concatenation of the city and state columns:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 与索引选择相比，布尔选择提供了更多的灵活性，因为它可以基于任意多个列进行条件筛选。在这个食谱中，我们使用了一个单一的列作为索引。实际上，也可以将多个列连接起来作为索引。例如，在下面的代码中，我们将索引设置为城市和州列的连接：
- en: '[PRE32]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '![](img/7cbcb510-cb15-4633-9a23-6f3c6f53aa59.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7cbcb510-cb15-4633-9a23-6f3c6f53aa59.png)'
- en: 'From here, we can select all colleges from a particular city and state combination
    without boolean indexing. Let''s select all colleges from `Miami, FL`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里开始，我们可以选择来自特定城市和州组合的所有大学，而不使用布尔索引。让我们选择来自`Miami, FL`的所有大学：
- en: '[PRE33]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '![](img/ee559ed9-bef7-426a-9337-2dc405de57c8.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ee559ed9-bef7-426a-9337-2dc405de57c8.png)'
- en: 'We can compare the speed of this compound index selection with boolean indexing.
    There is more than an order of magnitude difference:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这个复合索引选择的速度与布尔索引进行比较。差异的数量级超过一个：
- en: '[PRE34]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: See also
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The *Binary search algorithm* ([http://bit.ly/2wbMq20](https://en.wikipedia.org/wiki/Binary_search_algorithm))
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*二分查找算法* ([http://bit.ly/2wbMq20](https://en.wikipedia.org/wiki/Binary_search_algorithm))'
- en: Gaining perspective on stock prices
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取股票价格的视角
- en: Investors who have purchased long stock positions would obviously like to sell
    stocks at or near their all-time highs. This, of course, is very difficult to
    do in practice, especially if a stock price has only spent a small portion of
    its history above a certain threshold. We can use boolean indexing to find all
    points in time that a stock has spent above or below a certain value. This exercise
    may help us gain perspective as to what a common range for some stock to be trading
    within.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些购买了长期股票头寸的投资者，显然希望在股票价格接近或达到历史最高点时卖出股票。当然，实际上这非常困难，尤其是当股票价格在其历史中只有一小部分时间位于某个阈值之上时。我们可以使用布尔索引找到股票价格超过或低于某个值的所有时间点。这个练习可能帮助我们理解某只股票的常见交易区间。
- en: Getting ready
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we examine Schlumberger stock from the start of 2010 until mid-2017\.
    We use boolean indexing to extract a Series of the lowest and highest ten percent
    of closing prices during this time period. We then plot all points and highlight
    those that are in the upper and lower ten percent.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们研究了2010年初至2017年中期的施耐德（Schlumberger）股票。我们使用布尔索引提取了这段时间内最低和最高10%的收盘价序列。然后，我们绘制了所有数据点，并突出显示那些属于上下10%的数据点。
- en: How to do it...
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Read in the Schlumberger stock data, put the `Date` column into the index,
    and convert it to a `DatetimeIndex`:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取施耐德股票数据，将`Date`列设置为索引，并将其转换为`DatetimeIndex`：
- en: '[PRE35]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '![](img/9c889d58-52eb-4eec-8b73-39db375c7b89.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9c889d58-52eb-4eec-8b73-39db375c7b89.png)'
- en: 'Select the closing price as a Series and use the `describe` method to return
    summary statistics as a Series:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择收盘价作为一个序列，并使用`describe`方法返回总结统计信息：
- en: '[PRE36]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Using boolean selection, select all closing prices in the upper or lower tenth
    percentile:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用布尔选择，选择所有位于上下第十百分位数的收盘价：
- en: '[PRE37]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Plot the resulting filtered Series in light gray on top of all closing prices
    in black. Use the `matplotlib` library to draw horizontal lines at the tenth and
    ninetieth percentiles:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将筛选后的结果序列以浅灰色绘制在所有收盘价（黑色）之上。使用`matplotlib`库在第十和第九十百分位数位置绘制水平线：
- en: '[PRE38]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '![](img/787b6fa6-65a8-4550-a293-05ed4e625cdc.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](img/787b6fa6-65a8-4550-a293-05ed4e625cdc.png)'
- en: How it works...
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The result of the `describe` method in step 2 is itself a Series with the identifying
    summary statistic as its index labels. This summary Series is used to store the
    tenth and ninetieth percentiles as their own variables. Step 3 uses boolean indexing
    to select only those values in the upper and lower tenth of the distribution.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 第 2 步中 `describe` 方法的结果本身是一个 Series，标识性总结统计量作为其索引标签。这个总结 Series 用于存储第十百分位数和第九十百分位数作为独立变量。第
    3 步使用布尔索引选择分布的上下第十百分位数中的值。
- en: Both Series and DataFrames have direct plotting capabilities through the `plot`
    method. This first call to the `plot` method comes from the `slb_close` Series,
    which contains all the SLB closing prices. This is the black line in the plot.
    The points from `slb_filtered` are plotted as gray markers directly on top of
    the closing prices. The `style` parameter is set to a single blank space so that
    no line is drawn. The `ms` parameter sets the marker size.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`Series` 和 `DataFrame` 都通过 `plot` 方法提供直接的绘图功能。第一次调用 `plot` 方法来自 `slb_close`
    Series，它包含了所有的 SLB 收盘价。这是图表中的黑线。来自 `slb_filtered` 的数据点作为灰色标记直接绘制在收盘价上。`style`
    参数设置为一个空格，这样就不会绘制任何线条。`ms` 参数设置标记的大小。'
- en: Matplotlib comes with a convenience function, `hlines`, that plots horizontal
    lines. It takes a list of `y` values and plots them from `xmin` to `xmax`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Matplotlib 提供了一个方便的函数 `hlines`，用于绘制水平线。它接受一组 `y` 值，并从 `xmin` 到 `xmax` 绘制这些线。
- en: Judging from our new perspective from the plots that we created, it's clear
    to see that although SLB's all-time high is close to $120 per share, only 10%
    of the trading days in the last seven years have been above $93 per share.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们创建的图表的新视角来看，可以清楚地看到，尽管 SLB 的历史最高股价接近每股 $120，但过去七年中仅有 10% 的交易日股价超过每股 $93。
- en: There's more...
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Instead of plotting red points (black points) over the closing prices to indicate
    the upper and lower tenth percentiles, we can use matplotlib''s `fill_between`
    function. This function fills in all the areas between two lines. It takes an
    optional `where` parameter that accepts a boolean Series, alerting it to exactly
    which locations to fill in:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以不再通过在收盘价上绘制红色（或黑色）点来表示上下第十百分位数，而是使用 matplotlib 的 `fill_between` 函数。这个函数填充两条线之间的所有区域。它接受一个可选的
    `where` 参数，该参数接受一个布尔 Series，告知它确切的填充位置：
- en: '[PRE39]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '![](img/1b04de13-e7d7-4d60-ab2d-38b1afc0daef.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1b04de13-e7d7-4d60-ab2d-38b1afc0daef.png)'
- en: Translating SQL WHERE clauses
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 翻译 SQL WHERE 子句
- en: Many pandas users will have a background processing data directly from databases
    using the ubiquitous **Structured Query Language** (**SQL**). SQL is a standardized
    language to define, manipulate, and control data stored in a database. The `SELECT`
    statement is the most common way to use SQL to select, filter, aggregate, and
    order data. Pandas has the ability to connect to databases and send SQL statements
    to them.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 pandas 用户有直接从数据库处理数据的背景，使用的是无处不在的 **结构化查询语言** (**SQL**) 。SQL 是一种标准化的语言，用于定义、操作和控制存储在数据库中的数据。`SELECT`
    语句是使用 SQL 选择、过滤、聚合和排序数据的最常用方式。Pandas 可以连接到数据库并向其发送 SQL 语句。
- en: SQL is a very important language to know for data scientists. Much of the world's
    data is stored in databases that necessitate SQL to retrieve, manipulate, and
    perform analyses on. SQL syntax is fairly simple and easy to learn. There are
    many different SQL implementations from companies such as Oracle, Microsoft, IBM,
    and more. Although the syntax is not compatible between the different implementations,
    the core of it will look very much the same.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: SQL 是数据科学家必须掌握的一种非常重要的语言。世界上大部分的数据存储在需要 SQL 来检索、操作和进行分析的数据库中。SQL 语法相对简单且容易学习。许多公司如
    Oracle、Microsoft、IBM 等提供了不同的 SQL 实现。尽管不同的实现之间的语法不兼容，但其核心语法非常相似。
- en: Getting ready
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Within a SQL SELECT statement, the WHERE clause is very common and filters data.
    This recipe will write pandas code that is equivalent to a SQL query that selects
    a certain subset of the employee dataset.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SQL SELECT 语句中，WHERE 子句是非常常见的，用于过滤数据。这个方法将编写与 SQL 查询等效的 pandas 代码，用于选择员工数据集中的某个子集。
- en: It is not necessary to understand any SQL syntax to make use of this recipe.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此方法并不需要理解任何 SQL 语法。
- en: 'Suppose we are given a task to find all the female employees that work in the
    police or fire departments that have a base salary between 80 and 120 thousand
    dollars. The following SQL statement would answer this query for us:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们被要求找到所有在警察或消防部门工作的女性员工，她们的基础薪资在8万到12万美元之间。以下SQL语句将为我们解答这个查询：
- en: '[PRE40]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: How to do it...
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Read in the `employee` dataset as a DataFrame:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`employee`数据集读入为DataFrame：
- en: '[PRE41]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Before filtering out the data, it is helpful to do some manual inspection of
    each of the filtered columns to know the exact values that will be used in the
    filter:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在筛选数据之前，最好先对每个被筛选的列进行一些手动检查，以了解筛选中将使用的确切值：
- en: '[PRE42]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Write a single statement for each of the criteria. Use the `isin` method to
    test equality to one of many values:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为每个标准写一个语句。使用`isin`方法来测试是否等于多个值中的一个：
- en: '[PRE43]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Combine all the boolean Series together:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有布尔Series组合在一起：
- en: '[PRE44]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Use boolean indexing to select only the rows that meet the final criteria:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用布尔索引仅选择符合最终标准的行：
- en: '[PRE45]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '![](img/5cf310ad-c04c-4212-b5c5-03e9459468cf.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5cf310ad-c04c-4212-b5c5-03e9459468cf.png)'
- en: How it works...
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Before any filtering is actually done, you will obviously need to know the exact
    string names that will be used. The Series `value_counts` method is an excellent
    way to get both the exact string name and number of occurrences of that value.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际进行筛选之前，你显然需要知道将使用的确切字符串名称。Series的`value_counts`方法是获取确切字符串名称和该值出现次数的绝佳方式。
- en: The `isin` Series method is equivalent to the SQL `IN` operator and accepts
    a list of all possible values that you would like to keep. It is possible to use
    a series of `OR` conditions to replicate this expression but it would not be as
    efficient or idiomatic.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`isin`方法等同于SQL中的`IN`操作符，接受一个包含所有可能保留值的列表。虽然可以使用一系列`OR`条件来模拟这个表达式，但效率较低且不够规范。'
- en: The criteria for salary, `criteria_sal`, is formed by combining two simple inequality
    expressions. All the criteria are finally combined together with the pandas `and`
    operator, `&`, to yield a single boolean Series as the filter.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 薪资标准`criteria_sal`是通过结合两个简单的不等式表达式形成的。所有标准最终通过pandas的`and`运算符`&`组合在一起，产生一个单一的布尔Series作为筛选条件。
- en: There's more...
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'For many operations, pandas has multiple ways to do the same thing. In the
    preceding recipe, the criteria for salary uses two separate boolean expressions.
    Similarly to SQL, Series have a `between` method, with the salary criteria equivalently
    written as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多操作，pandas提供了多种方法来做同一件事。在前面的示例中，薪资标准使用了两个独立的布尔表达式。与SQL类似，Series也有`between`方法，薪资标准可以等价地写成如下形式：
- en: '[PRE46]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Another useful application of `isin` is to provide a sequence of values automatically
    generated by some other pandas statements. This would avoid any manual investigating
    to find the exact string names to store in a list. Conversely, let''s try to exclude
    the rows from the top five most frequently occurring departments:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`isin`的另一个有用应用是提供由其他pandas语句自动生成的值序列。这可以避免手动调查以查找需要存储在列表中的确切字符串名称。相反，假设我们要排除出现频率最高的前五个部门的行：'
- en: '[PRE47]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The SQL equivalent of this would be as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: SQL的等效查询如下：
- en: '[PRE48]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Notice the use of the pandas not operator, `~`, which negates all boolean values
    of a Series.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 注意使用pandas的非操作符`~`，它对Series的所有布尔值取反。
- en: See also
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另见
- en: Pandas official documentation of the `isin` ([http://bit.ly/2v1GPfQ](http://pandas.pydata.org/pandas-docs/stable/generated/pandas.Series.isin.html))
    and `between` ([http://bit.ly/2wq9YPF](http://pandas.pydata.org/pandas-docs/stable/generated/pandas.Series.between.html))
    Series methods
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pandas官方文档中的`isin`方法([http://bit.ly/2v1GPfQ](http://pandas.pydata.org/pandas-docs/stable/generated/pandas.Series.isin.html))和`between`方法([http://bit.ly/2wq9YPF](http://pandas.pydata.org/pandas-docs/stable/generated/pandas.Series.between.html))
- en: Refer to the *Connecting to SQL databases recipe* in [Chapter 15](40ba859e-6517-458e-8fd5-f3bcaf55a4fc.xhtml),
    *Combining Pandas Objects*
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参考[第15章](40ba859e-6517-458e-8fd5-f3bcaf55a4fc.xhtml)中的*连接到SQL数据库的食谱*，*合并Pandas对象*
- en: A basic introduction to SQL from W3 schools ([http://bit.ly/2hsq8Wp](https://www.w3schools.com/sql/DEfaULT.asP))
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: W3Schools中的SQL基础介绍([http://bit.ly/2hsq8Wp](https://www.w3schools.com/sql/DEfaULT.asP))
- en: The SQL IN operator ([http://bit.ly/2v3H7Bg](https://www.w3schools.com/sql/sql_in.asp))
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQL中的IN操作符([http://bit.ly/2v3H7Bg](https://www.w3schools.com/sql/sql_in.asp))
- en: The SQL BETWEEN operator ([http://bit.ly/2vn5UTP](https://www.w3schools.com/sql/sql_between.asp))
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQL中的BETWEEN操作符([http://bit.ly/2vn5UTP](https://www.w3schools.com/sql/sql_between.asp))
- en: Determining the normality of stock market returns
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确定股市回报的正态性
- en: In elementary statistics textbooks, the normal distribution is heavily relied
    upon to describe many different populations of data.  Although many random processes
    do appear to look like normal distributions most of the time, real-life tends
    to be more complex. Stock market returns are a prime example of a distribution
    that can look fairly normal but in actuality be quite far off.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在基础统计学教材中，正态分布被广泛用于描述许多不同的数据群体。虽然大多数时间，许多随机过程确实看起来像正态分布，但现实生活往往更加复杂。股市回报是一个典型的例子，它的分布看起来可能相当正常，但实际上却可能相差甚远。
- en: Getting ready
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe describes how to find daily stock market returns of the internet
    retail giant Amazon and informally test whether they follow a normal distribution.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这份食谱描述了如何获取互联网零售巨头亚马逊的每日股市回报，并非正式地测试它们是否符合正态分布。
- en: How to do it...
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Load Amazon stock data and set the date as the index:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载亚马逊股票数据并将日期设为索引：
- en: '[PRE49]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '![](img/32cbff6f-8e7f-45ec-b066-abff676c389b.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![](img/32cbff6f-8e7f-45ec-b066-abff676c389b.png)'
- en: 'Create a Series by selecting only the closing price and then using the `pct_change`
    method to get the daily rate of return:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过仅选择收盘价并使用`pct_change`方法来计算每日回报率，创建一个Series：
- en: '[PRE50]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Drop the missing value and plot a histogram of the returns to visually inspect
    the distribution:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除缺失值并绘制回报的直方图，以视觉检查分布：
- en: '[PRE51]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '![](img/d34eaba2-c6be-4b31-9f20-a1517c225a1e.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d34eaba2-c6be-4b31-9f20-a1517c225a1e.png)'
- en: 'Normal distributions approximately follow the 68-95-99.7 rule--meaning that
    68% of the data falls between 1 standard deviation of the mean, 95% between 2,
    and 99.7% between 3\. We will now calculate the percentage of daily returns that
    fall between 1, 2, and 3 standard deviations from the mean. For this, we will
    need the mean and standard deviation:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正态分布大致遵循68-95-99.7法则——意味着68%的数据位于均值1个标准差范围内，95%位于2个标准差内，99.7%位于3个标准差内。我们现在将计算每日回报中有多少百分比落在均值的1、2和3个标准差范围内。为此，我们需要均值和标准差：
- en: '[PRE52]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Calculate the absolute value of the `z-score` for each observation. The `z-score`
    is the number of standard deviations away from the mean:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算每个观察值的`z-score`的绝对值。`z-score`是离均值的标准差个数：
- en: '[PRE53]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Find the percentage of returns that are within 1, 2, and 3 standard deviations:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找出位于1、2和3个标准差范围内的回报百分比：
- en: '[PRE54]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: How it works...
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: By default, the `pct_change` Series method calculates the percentage change
    between the current element and the previous element. This transforms the raw
    stock closing prices into daily percentage returns. The first element of the returned
    Series is a missing value as there is no previous price.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`pct_change` Series方法计算当前元素与前一个元素之间的百分比变化。这将原始的股票收盘价转化为每日百分比回报。返回Series的第一个元素是缺失值，因为没有前一个价格。
- en: Histograms are fantastic plots to summarize and visualize one-dimensional numeric
    data. It is clear from the plot that the distribution is symmetrical but it remains
    difficult to determine whether it is normal or not. There are formal statistical
    procedures to determine the normality of a distribution but we will simply find
    how close the data matches the 68-95-99.7 rule.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 直方图是总结和可视化一维数值数据的极佳图形。从图中可以明显看出，分布是对称的，但仍然很难判断它是否符合正态分布。有一些正式的统计方法可以用来确定分布的正态性，但我们将简单地找到数据与68-95-99.7法则的匹配程度。
- en: Step 5 calculates the number of standard deviations away from the mean for each
    observation which is referred to as the `z-score`. This step uses the methods
    and not the symbols (`-` and `/`) to do subtraction and division. The method for
    less than is also used in favor of the symbols in step 6.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 第5步计算每个观察值离均值的标准差个数，这被称为`z-score`。这一步使用方法而非符号（`-`和`/`）来进行减法和除法。步骤6中也使用了小于的方法，而不是符号。
- en: It may seem odd that the mean is being taken in step 6\. The result of the `abs_z_score.lt(1)`
    expression is a Series of booleans. As booleans evaluate to 0 or 1, taking the
    mean of this Series returns the percentage of elements that are `True`, which
    is what we desired.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤6中取均值可能看起来有些奇怪。`abs_z_score.lt(1)`表达式的结果是一个布尔值的Series。由于布尔值会被计算为0或1，取该Series的均值返回的是`True`元素所占的百分比，这正是我们所需要的。
- en: We can now more easily determine the normality of the returns by comparing the
    resulting numbers (78.7-95.7-98.5) to the 68-95-99.7 rule. The percentages deviate
    greatly from the rule for 1 and 3 standard deviations, and we can conclude that
    Amazon daily stock returns do not follow a normal distribution.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过将结果数字（78.7-95.7-98.5）与 68-95-99.7 规则进行比较，更容易判断回报的正态性。对于 1 和 3 个标准差，百分比与规则的偏差很大，我们可以得出结论：亚马逊的日股回报不遵循正态分布。
- en: There's more...
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多……
- en: 'To automate this process, we can write a function that accepts stock data in
    the and outputs the histogram of daily returns along with the percentages that
    fall within 1, 2, and 3 standard deviations from the mean. The following function
    does this and replaces the methods with their symbol counterparts:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 为了自动化此过程，我们可以编写一个函数，接受股票数据并输出日回报的直方图，以及落在均值的 1、2 和 3 个标准差范围内的百分比。以下函数完成了这一功能，并用符号对应的替代方法替换了原有方法：
- en: '[PRE55]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '![](img/9401919f-736c-480a-ba3a-d67a05852b7e.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9401919f-736c-480a-ba3a-d67a05852b7e.png)'
- en: See also
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另见
- en: Pandas official documentation of the `pct_change` Series method ([http://bit.ly/2wcjmqT](http://pandas.pydata.org/pandas-docs/stable/generated/pandas.Series.pct_change.html))
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pandas 官方文档中的 `pct_change` Series 方法 ([http://bit.ly/2wcjmqT](http://pandas.pydata.org/pandas-docs/stable/generated/pandas.Series.pct_change.html))
- en: Improving readability of boolean indexing with the query method
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 query 方法改进布尔索引的可读性
- en: Boolean indexing is not necessarily the most pleasant syntax to read or write,
    especially when using a single line to write a complex filter. Pandas has an alternative
    string-based syntax through the DataFrame `query` method that can provide more
    clarity.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔索引不一定是最容易阅读或编写的语法，尤其是当使用一行代码写复杂过滤器时。Pandas 提供了一种替代的基于字符串的语法，通过 DataFrame `query`
    方法，可以提供更清晰的表达方式。
- en: The `query` DataFrame method is experimental and not as capable as boolean indexing
    and should not be used for production code.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`query` DataFrame 方法是实验性的，功能不如布尔索引强大，不应在生产代码中使用。'
- en: Getting ready
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备开始
- en: This recipe replicates the earlier recipe in this chapter, *Translating SQL
    WHERE clauses,* but instead takes advantage of the `query` DataFrame method. The
    goal here is to filter the employee data for female employees from the police
    or fire departments that earn a salary between 80 and 120 thousand dollars.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱复制了本章之前的食谱，*翻译 SQL WHERE 子句*，但它改用了 `query` DataFrame 方法。目标是筛选出来自警察或消防部门的女性员工数据，这些员工的年薪在
    8 万到 12 万美元之间。
- en: How to do it...
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作……
- en: 'Read in the employee data, assign the chosen departments, and import columns
    to variables:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取员工数据，分配所选部门，并将列导入变量：
- en: '[PRE57]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Build the query string and execute the method:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建查询字符串并执行该方法：
- en: '[PRE58]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '![](img/594a1364-103c-4ce5-be63-1f12a5cc7b17.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![](img/594a1364-103c-4ce5-be63-1f12a5cc7b17.png)'
- en: How it works...
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理……
- en: Strings passed to the `query` method are going to look more like plain English
    than normal pandas code. It is possible to reference Python variables using the
    at symbol (`@`) as with `depts`. All DataFrame column names are available in the
    query namespace by simply referencing their name without inner quotes. If a string
    is needed, such as `Female`, inner quotes will need to wrap it.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给 `query` 方法的字符串看起来更像是普通英语，而不是普通的 pandas 代码。可以使用 @ 符号引用 Python 变量，就像 `depts`
    一样。所有的 DataFrame 列名都可以通过直接引用它们的名称来访问，无需内层引号。如果需要字符串，例如 `Female`，则需要使用内层引号。
- en: Another nice feature of the `query` syntax is the ability to write a double
    inequality in a single expression and its ability to understand the verbose logical
    operators `and`, `or`, and `not` instead of their bitwise equivalents as with
    boolean indexing.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`query` 语法的另一个优点是能够在单个表达式中编写双重不等式，并且它能够理解冗长的逻辑运算符 `and`、`or` 和 `not`，而不是像布尔索引那样使用按位运算符。'
- en: There's more...
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多……
- en: 'Instead of manually typing in a list of department names, we could have programmatically
    created it. For instance, if we wanted to find all the female employees that were
    not a member of the top 10 departments by frequency, we can run the following
    code:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要手动输入部门名称列表，而是可以通过编程的方式创建它。例如，如果我们想找到所有不是前 10 个部门中频率最高的女性员工，可以运行以下代码：
- en: '[PRE59]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '![](img/04c5bb6f-52a6-44d6-9cc7-862e08c0bc15.png)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![](img/04c5bb6f-52a6-44d6-9cc7-862e08c0bc15.png)'
- en: See also
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另见
- en: Pandas official documentation on the `query` method ([http://bit.ly/2vnlwXk](http://pandas.pydata.org/pandas-docs/stable/indexing.html#indexing-query))
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pandas 官方文档中的 `query` 方法 ([http://bit.ly/2vnlwXk](http://pandas.pydata.org/pandas-docs/stable/indexing.html#indexing-query))
- en: Preserving Series with the where method
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`where`方法保留Series
- en: Boolean indexing necessarily filters your dataset by removing all the rows that
    don't match the criteria. Instead of dropping all these values, it is possible
    to keep them using the `where` method. The `where` method preserves the size of
    your Series or DataFrame and either sets the values that don't meet the criteria
    for missing or replaces them with something else.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔索引必然会通过删除所有不符合标准的行来过滤数据集。与删除所有这些值不同，使用`where`方法可以保留它们。`where`方法保留Series或DataFrame的大小，并将不满足标准的值设为缺失值，或者用其他值替代。
- en: Getting ready
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: In this recipe, we pass the `where` method boolean conditions to put a floor
    and ceiling on the minimum and maximum number of Facebook likes for actor 1 in
    the `movie` dataset.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们传递`where`方法的布尔条件，用于在`movie`数据集中设置演员1的Facebook点赞数的上下限。
- en: How to do it...
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Read the `movie` dataset, set the movie title as the index, and select all
    the values in the `actor_1_facebook_likes` column that are not missing:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取`movie`数据集，将电影标题设置为索引，并选择`actor_1_facebook_likes`列中所有非缺失的值：
- en: '[PRE60]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Let''s use the `describe` method to get a sense of the distribution:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用`describe`方法来大致了解分布情况：
- en: '[PRE61]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Additionally, we may plot a histogram of this Series to visually inspect the
    distribution:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，我们还可以绘制该Series的直方图来直观检查分布情况：
- en: '[PRE62]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '![](img/18859e7b-eebe-49f7-aed5-c7511b01f94f.png)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![](img/18859e7b-eebe-49f7-aed5-c7511b01f94f.png)'
- en: 'This is quite a bad visualization and very difficult to get a sense of the
    distribution. On the other hand, the summary statistics from step 2 appear to
    be telling us that it is highly skewed to the right with many observations more
    than an order of magnitude greater than the median. Let''s create criteria to
    test whether the number of likes is less than 20,000:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是一个相当糟糕的可视化图形，很难看出分布情况。另一方面，步骤2中的摘要统计量似乎告诉我们数据高度偏向右侧，且许多观测值比中位数大一个数量级。让我们创建标准来测试点赞数是否少于20,000：
- en: '[PRE63]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'About 91% of the movies have an actor 1 with fewer than 20,000 likes. We will
    now use the `where` method, which accepts a boolean condition. The default behavior
    is to return a Series the same size as the original but which has all the `False`
    locations replaced with a missing value:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 大约91%的电影的演员1点赞数少于20,000。现在我们将使用`where`方法，它接受布尔条件。默认行为是返回一个与原始Series大小相同的Series，但将所有`False`位置替换为缺失值：
- en: '[PRE64]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The second parameter to the `where` method, `other`, allows you to control
    the replacement value. Let''s change all the missing values to 20,000:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`where`方法的第二个参数`other`允许你控制替换的值。让我们将所有缺失的值改为20,000：'
- en: '[PRE65]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Similarly, we can create criteria to put a floor on the minimum number of likes.
    Here, we chain another `where` method and replace the values not meeting with
    the condition to `300`:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，我们可以创建标准来设定最小点赞数的下限。在这里，我们链式调用另一个`where`方法，并将不满足条件的值替换为`300`：
- en: '[PRE66]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The length of the original Series and modified Series is the same:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 原始Series和修改后的Series的长度相同：
- en: '[PRE67]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Let''s make a histogram with the modified Series. With the data in a much tighter
    range, it should produce a better plot:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们用修改后的Series制作一个直方图。由于数据的范围更加紧凑，它应该能生成一个更好的图形：
- en: '[PRE68]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '![](img/7322581b-6241-4bb8-a3b4-b24ea9bf7644.png)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7322581b-6241-4bb8-a3b4-b24ea9bf7644.png)'
- en: How it works...
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `where` method again preserves the size and shape of the calling object
    and does not modify the values where the passed boolean is `True`. It was important
    to drop the missing values in step 1 as the `where` method would have eventually
    replaced them with a valid number in future steps.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '`where`方法再次保留调用对象的大小和形状，并且在传入的布尔值为`True`时不会修改值。在步骤1中删除缺失值是很重要的，因为`where`方法最终会在后续步骤中用有效数字替换它们。'
- en: The summary statistics in step 2 give us some intuition where it would make
    sense to cap our data. The histogram from step 3, on the other hand, appears to
    clump all the data into one bin. The data has too many outliers for a plain histogram
    to make a good plot. The `where` method allows us to place a ceiling and floor
    on our data, which results in a histogram with many more visible bars.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤2中的摘要统计给了我们一些直觉，表明在哪些情况下设置数据上限是有意义的。另一方面，步骤3中的直方图似乎将所有数据集中到一个箱子里。数据中有太多离群值，单纯的直方图很难生成好的图形。`where`方法允许我们为数据设置上限和下限，从而生成一个具有更多可见条形的直方图。
- en: There's more...
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Pandas actually has built-in methods `clip`, `clip_lower`, and `clip_upper`
    that replicate this operation. The `clip` method can set a floor and ceiling at
    the same time. We also check whether this alternate method produces the exact
    same Series, which it does:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: Pandas 实际上有内建的方法 `clip`、`clip_lower` 和 `clip_upper`，可以实现这一操作。`clip` 方法可以同时设置下限和上限。我们还检查了这个替代方法是否产生完全相同的
    Series，结果是一样的：
- en: '[PRE69]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: See also
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另见
- en: Pandas official documentation on the `where` method ([http://bit.ly/2vmW2cv](http://bit.ly/2vmW2cv))
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pandas 官方文档关于 `where` 方法的介绍 ([http://bit.ly/2vmW2cv](http://bit.ly/2vmW2cv))
- en: Masking DataFrame rows
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 遮罩 DataFrame 行
- en: The `mask` method performs the exact opposite operation that the `where` method
    does. By default, it creates missing values wherever the boolean condition is
    `True`. In essence, it is literally masking, or covering up, values in your dataset.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '`mask` 方法执行的操作正好是 `where` 方法的相反操作。默认情况下，它会在布尔条件为 `True` 的地方创建缺失值。本质上，它就是在你的数据集中遮罩或覆盖掉某些值。'
- en: Getting ready
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we will mask all rows of the movie dataset that were made after
    2010 and then filter all the rows with missing values.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个案例中，我们将遮罩所有 2010 年之后制作的电影数据行，然后筛选出所有包含缺失值的行。
- en: How to do it...
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作……
- en: 'Read the `movie` dataset, set the movie title as the index, and create the
    criteria:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取 `movie` 数据集，将电影标题设为索引，并创建筛选条件：
- en: '[PRE70]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Use the `mask` method on a DataFrame to make all the values in rows with movies
    that were made from 2010 onward missing. Any movie that originally had a missing
    value for `title_year` is also masked:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `mask` 方法在 DataFrame 中将所有 2010 年以后制作的电影行中的值设为缺失值。任何原本 `title_year` 列为缺失值的电影也会被遮罩：
- en: '[PRE71]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '![](img/d7b0fdac-c4b2-4d31-9594-7c8d776fb964.png)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d7b0fdac-c4b2-4d31-9594-7c8d776fb964.png)'
- en: 'Notice how all the values in the third, fourth, and fifth rows from the preceding
    DataFrame are missing. Chain the `dropna` method to remove rows that have all
    values missing:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意到前面 DataFrame 中第三、第四和第五行的所有值都缺失了。链式调用 `dropna` 方法删除所有值都缺失的行：
- en: '[PRE72]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '![](img/d9027ba6-fe62-4ba4-971f-70bfc54f599b.png)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d9027ba6-fe62-4ba4-971f-70bfc54f599b.png)'
- en: 'The operation in step 3 is just a complex way of doing basic boolean indexing.
    We can check whether the two methods produce the same DataFrame:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第 3 步的操作其实就是做一个复杂的布尔索引。我们可以检查这两种方法是否产生相同的 DataFrame：
- en: '[PRE73]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The `equals` method is telling us that they aren''t equal. Something is wrong.
    Let''s do some sanity checking and see if they are the same shape:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`equals` 方法告诉我们它们不相等。有些地方出错了。让我们做一些合理性检查，看看它们的形状是否相同：'
- en: '[PRE74]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'When we used the preceding `mask` method, it created many missing values. Missing
    values are `float` data types so any previous integer column is now a float. The
    `equals` method returns `False` if the data types of the columns are different,
    even if the values are the same. Let''s check the equality of the data types to
    see whether this scenario happened:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们使用前面的 `mask` 方法时，它创建了很多缺失值。缺失值的类型是 `float`，因此任何原本是整数的列现在变成了浮动类型。`equals`
    方法会返回 `False`，如果列的数据类型不同，即使它们的值是相同的。让我们检查数据类型的相等性，看看这种情况是否发生：
- en: '[PRE75]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'It turns out that a couple of columns don''t have the same data type. Pandas
    has an alternative for these situations. In its testing module, which is primarily
    used by developers, there is a function, `assert_frame_equal`, that allows you
    to check the equality of Series and DataFrames without also checking the equality
    of the data types:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结果发现有几列的类型不相同。Pandas 为这些情况提供了一个替代方案。在其测试模块中，主要供开发者使用，有一个函数 `assert_frame_equal`，允许你在不检查数据类型是否相等的情况下，检查
    Series 和 DataFrame 的内容是否相等：
- en: '[PRE76]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: How it works...
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: By default, the `mask` method covers up data with missing values. The first
    parameter to the `mask` method is the condition which is often a boolean Series
    such as `criteria`. Because the `mask` method is called from a DataFrame, all
    the values in each row where the condition is `False` change to missing. Step
    3 uses this masked DataFrame to drop the rows that contain all missing values.
    Step 4 shows how to do this same procedure with boolean indexing.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`mask` 方法会将缺失值覆盖掉。`mask` 方法的第一个参数是条件，通常是布尔类型的 Series，例如 `criteria`。由于
    `mask` 方法是从 DataFrame 调用的，所以在条件为 `False` 的行中，所有的值都会变为缺失值。第 3 步使用这个被遮罩的 DataFrame
    来删除包含所有缺失值的行。第 4 步演示了如何使用布尔索引执行相同的操作。
- en: During a data analysis, it is very important to continually validate results.
    Checking the equality of Series and DataFrames is an extremely common approach
    to validation. Our first attempt, in step 4, yielded an unexpected result. Some
    basic sanity checking, such as ensuring that the number of rows and columns are
    the same or that the row and column names are the same, are good checks before
    going deeper.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据分析过程中，不断验证结果非常重要。检查 Series 和 DataFrame 是否相等是非常常见的验证方法。我们在第4步中的第一次尝试得到了意外的结果。在深入分析之前，一些基本的合理性检查，比如确保行和列的数量相同，或者行列名称相同，是很好的检查方式。
- en: Step 6 compares the two Series of data types together. It is here where we uncover
    the reason why the DataFrames were not equivalent. The `equals` method checks
    that both the values and data types are the same. The `assert_frame_equal` function
    from step 7 has many available parameters to test equality in a variety of ways.
    Notice that there is no output after calling `assert_frame_equal`. This method
    returns None when the two passed DataFrames are equal and raises an error when
    they are not.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 第6步比较了两组数据类型的 Series。正是在这里，我们揭示了 DataFrames 不相等的原因。`equals` 方法检查值和数据类型是否相同。第7步中的
    `assert_frame_equal` 函数有许多可用的参数，用于以多种方式测试相等性。请注意，调用 `assert_frame_equal` 后没有输出。如果两个传递的
    DataFrames 相等，该方法返回 None；如果不相等，则抛出错误。
- en: There's more...
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Let''s compare the speed difference between masking and dropping missing rows
    and boolean indexing. Boolean indexing is about an order of magnitude faster in
    this case:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们比较掩码和删除缺失行与布尔索引之间的速度差异。在这种情况下，布尔索引速度快了一个数量级：
- en: '[PRE77]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: See also
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另见
- en: Pandas official documentation on `assert_frame_equal` ([http://bit.ly/2u5H5Yl](https://pandas.pydata.org/pandas-docs/stable/generated/pandas.testing.assert_frame_equal.html))
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pandas 官方文档关于 `assert_frame_equal` 的说明 ([http://bit.ly/2u5H5Yl](https://pandas.pydata.org/pandas-docs/stable/generated/pandas.testing.assert_frame_equal.html))
- en: Python official documentation of the `assert` statement ([http://bit.ly/2v1YKmY](https://docs.python.org/3/reference/simple_stmts.html#the-assert-statement))
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 官方文档关于 `assert` 语句的说明 ([http://bit.ly/2v1YKmY](https://docs.python.org/3/reference/simple_stmts.html#the-assert-statement))
- en: Selecting with booleans, integer location, and labels
  id: totrans-331
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用布尔值、整数位置和标签进行选择
- en: '[Chapter 10](3b938362-1f65-406c-ba9d-3bf735543ca8.xhtml), *Selecting Subsets
    of Data*, covered a wide range of recipes on selecting different subsets of data
    through the `.iloc` and `.loc` indexers. Both these indexers select rows and columns
    simultaneously by either integer location or label. Both these indexers can also
    do data selection through boolean indexing, even though booleans are not integers
    and not labels.'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '[第10章](3b938362-1f65-406c-ba9d-3bf735543ca8.xhtml)，*选择数据的子集*，涵盖了通过 `.iloc`
    和 `.loc` 索引器选择不同数据子集的多种方法。这两种索引器可以通过整数位置或标签同时选择行和列。这两种索引器还可以通过布尔索引进行数据选择，尽管布尔值既不是整数，也不是标签。'
- en: Getting ready
  id: totrans-333
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we will filter both rows and columns with boolean indexing for
    both the `.iloc` and `.loc` indexers.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们将通过布尔索引同时过滤 `.iloc` 和 `.loc` 索引器的行和列。
- en: How to do it...
  id: totrans-335
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Read in the movie dataset, set the index as the title, and then create a boolean
    Series matching all movies with a content rating of `G` and an IMDB score less
    than `4`:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取电影数据集，设置标题为索引，然后创建一个布尔 Series，匹配所有内容评级为 `G` 且 IMDB 评分小于 `4` 的电影：
- en: '[PRE78]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Let''s first pass these criteria to the `.loc` indexer to filter the rows:'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先将这些标准传递给 `.loc` 索引器以过滤行：
- en: '[PRE79]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '![](img/c1f67118-c501-4567-898e-2955ae52f71b.png)'
  id: totrans-340
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c1f67118-c501-4567-898e-2955ae52f71b.png)'
- en: 'Let''s check whether this DataFrame is exactly equal to the one generated directly
    from the indexing operator:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们检查一下这个 DataFrame 是否与直接通过索引操作符生成的 DataFrame 完全相等：
- en: '[PRE80]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Now let''s attempt the same boolean indexing with the `.iloc` indexer:'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们尝试使用 `.iloc` 索引器进行相同的布尔索引：
- en: '[PRE81]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'It turns out that we cannot directly use a Series of booleans because of the
    index. We can, however, use ndarray of booleans. To extract the array, use the
    `values` attribute:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 事实证明，我们不能直接使用布尔值的 Series，因为存在索引问题。然而，我们可以使用布尔值的 ndarray。要提取该数组，可以使用 `values`
    属性：
- en: '[PRE82]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Although not very common, it is possible to do boolean indexing to select particular
    columns. Here, we select all the columns that have a data type of 64-bit integers:'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 虽然不太常见，但可以使用布尔索引选择特定的列。在这里，我们选择所有数据类型为64位整数的列：
- en: '[PRE83]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '![](img/3d5a5522-27c6-4a1f-8c09-ea6f01ac522f.png)'
  id: totrans-349
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3d5a5522-27c6-4a1f-8c09-ea6f01ac522f.png)'
- en: As `criteria_col` is a Series, which always has an index, you must use the underlying
    ndarray to make it work with `.iloc`. The following produces the same result as
    step 6.
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于`criteria_col`是一个Series，它总是有一个索引，因此你必须使用底层的ndarray才能与`.iloc`一起使用。以下操作产生与第6步相同的结果。
- en: '[PRE84]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'A boolean Series may be used to select rows and then simultaneously select
    columns with either integers or labels. Remember, you need to put a comma between
    the row and column selections. Let''s keep the row criteria and select `content_rating`,
    `imdb_score`, `title_year`, and `gross`:'
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以使用布尔序列来选择行，并同时使用整数或标签选择列。记住，行和列选择之间需要用逗号隔开。让我们保持行标准，选择`content_rating`、`imdb_score`、`title_year`和`gross`：
- en: '[PRE85]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '![](img/dadc8ffc-c00e-4c21-9dbe-756c1ca4294b.png)'
  id: totrans-354
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dadc8ffc-c00e-4c21-9dbe-756c1ca4294b.png)'
- en: 'This same operation may be replicated with `.iloc`, but you need to get the
    integer location of all the columns:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以通过`.iloc`重复相同的操作，但你需要获取所有列的整数位置：
- en: '[PRE86]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: How it works...
  id: totrans-357
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'Boolean indexing may be accomplished with both the `.iloc` and `.loc` indexers
    with the caveat that `.iloc` cannot be passed a Series but the underlying ndarray.
    Let''s take a look at the one-dimensional ndarray underlying the criteria Series:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔索引可以通过`.iloc`和`.loc`索引器实现，但有一个注意点：`.iloc`不能传递Series，而必须传递底层的ndarray。让我们来看一下`criteria`序列的底层一维ndarray：
- en: '[PRE87]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: The array is the same length as the Series, which is the same length as the
    movie DataFrame. The integer location for the boolean array aligns with the integer
    location of the DataFrame and the filter happens as expected. These arrays also
    work with the `.loc` operator as well but they are a necessity for `.iloc`.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的长度与Series的长度相同，而Series的长度与电影DataFrame的长度相同。布尔数组的整数位置与DataFrame的整数位置对齐，过滤过程按预期发生。这些数组也可以与`.loc`操作符一起使用，但它们对于`.iloc`是必需的。
- en: Steps 6 and 7 show how to filter by columns instead of by rows. The colon, `:`,
    is needed to indicate the selection of all the rows. The comma following the colon
    separates the row and column selections. There is actually a much easier way to
    select columns with integer data types and that is through the `select_dtypes`
    method.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 第6步和第7步展示了如何按列过滤，而不是按行过滤。冒号`:`表示选择所有行，冒号后的逗号分隔了行和列的选择。其实，还有一种更简单的方法可以选择具有整数数据类型的列，那就是通过`select_dtypes`方法。
- en: Steps 8 and 9 show a very common and useful way to do boolean indexing on the
    row and column selections simultaneously. You simply place a comma between the
    row and column selections. Step 9 uses a list comprehension to loop through all
    the desired column names to find their integer location with the index method `get_loc`.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 第8步和第9步展示了一种非常常见且有用的方法，可以同时对行和列进行布尔索引。你只需在行和列选择之间放置一个逗号。第9步使用列表推导式遍历所有所需的列名，通过`get_loc`方法找到它们的整数位置。
- en: There's more...
  id: totrans-363
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'It is actually possible to pass arrays and lists of booleans to Series objects
    that are not the same length as the DataFrame you are doing the indexing on. Let''s
    look at an example of this by selecting the first and third rows, and the first
    and fourth columns:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，可以将布尔数组和列表传递给Series对象，这些数组和列表的长度与正在进行索引操作的DataFrame不相等。我们通过选择第一行和第三行，以及第一列和第四列来看看这个例子：
- en: '[PRE88]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '![](img/07c9bc12-0cc4-4402-bc01-fda1e8ee7958.png)'
  id: totrans-366
  prefs: []
  type: TYPE_IMG
  zh: '![](img/07c9bc12-0cc4-4402-bc01-fda1e8ee7958.png)'
- en: Both of the boolean lists are not the same length as the axis they are indexing.
    The rest of the rows and columns not explicitly given a boolean value in the lists
    are dropped.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 两个布尔列表的长度与它们索引的轴的长度不同。列表中没有明确给出布尔值的其余行和列会被丢弃。
- en: See also
  id: totrans-368
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另见
- en: Refer to the *Selecting data with both integers and labels* recipe from [Chapter
    10](3b938362-1f65-406c-ba9d-3bf735543ca8.xhtml), *Selecting Subsets of Data*
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参考[第10章](3b938362-1f65-406c-ba9d-3bf735543ca8.xhtml)的*选择具有整数和标签的数据*方法，*选择数据的子集*
