- en: '*Chapter 8*: Rule-Based Anomaly Detection'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第八章*：基于规则的异常检测'
- en: It's time to catch some hackers trying to gain access to a website using a **brute-force
    attack**—trying to log in with a bunch of username-password combinations until
    they gain access. This type of attack is very noisy, so it gives us plenty of
    data points for **anomaly detection**, which is the process of looking for data
    generated from a process other than the one we deem to be typical activity. The
    hackers will be simulated and won't be as crafty as they can be in real life,
    but it will give us great exposure to anomaly detection.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候抓住一些试图通过**暴力破解攻击**访问网站的黑客了——他们通过尝试一堆用户名和密码组合，直到成功登录为止。这种攻击非常嘈杂，因此为我们提供了大量的数据点用于**异常检测**，即寻找由与我们认为典型活动不同的过程产生的数据。黑客将被模拟，并不会像现实中那样狡猾，但这将为我们提供良好的异常检测实践机会。
- en: We will be creating a package that will handle the simulation of the login attempts
    in order to generate the data for this chapter. Knowing how to simulate is an
    essential skill to have in our toolbox. Sometimes, it's difficult to solve a problem
    with an exact mathematical solution; however, it might be easy to define how small
    components of the system work. In these cases, we can model the small components
    and simulate the behavior of the system as a whole. The result of the simulation
    gives us an approximation of the solution that may be sufficient for our purposes.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个包，处理登录尝试的模拟，以便生成本章的数据。知道如何进行模拟是我们工具箱中一个至关重要的技能。有时，用精确的数学解法解决问题很困难；然而，定义系统中小组件如何工作可能比较容易。在这种情况下，我们可以模拟小组件并模拟整个系统的行为。模拟结果为我们提供了一个近似解，这可能足以满足我们的目的。
- en: We will utilize rule-based anomaly detection to identify suspicious activity
    in the simulated data. By the end of this chapter, we will have an understanding
    of how to simulate data using random numbers generated from various probability
    distributions, get more exposure to the Python standard library, gain additional
    experience building Python packages, practice performing exploratory data analysis,
    and get an introduction to anomaly detection.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将利用基于规则的异常检测来识别模拟数据中的可疑活动。在本章结束时，我们将了解如何使用从各种概率分布生成的随机数来模拟数据，进一步了解 Python
    标准库，积累更多构建 Python 包的经验，练习进行探索性数据分析，并初步接触异常检测。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Simulating login attempts to create our dataset for the chapter
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟登录尝试以创建本章的数据集
- en: Performing exploratory data analysis to understand the simulated data
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行探索性数据分析以理解模拟数据
- en: Using rules and baselines for anomaly detection
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用规则和基准线进行异常检测
- en: Chapter materials
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本章材料
- en: We will be building a simulation package to generate the data for this chapter;
    it is on GitHub at [https://github.com/stefmolin/login-attempt-simulator/tree/2nd_edition](https://github.com/stefmolin/login-attempt-simulator/tree/2nd_edition).
    This package was installed from GitHub when we set up our environment back in
    [*Chapter 1*](B16834_01_Final_SK_ePub.xhtml#_idTextAnchor015), *Introduction to
    Data Analysis*; however, you can follow the instructions in [*Chapter 7*](B16834_07_Final_SK_ePub.xhtml#_idTextAnchor146),
    *Financial Analysis – Bitcoin and the Stock Market*, to install a version of the
    package that you can edit.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建一个模拟包来生成本章的数据；该包在 GitHub 上的地址是 [https://github.com/stefmolin/login-attempt-simulator/tree/2nd_edition](https://github.com/stefmolin/login-attempt-simulator/tree/2nd_edition)。在我们设置环境时，这个包已从
    GitHub 安装，相关内容在[*第一章*](B16834_01_Final_SK_ePub.xhtml#_idTextAnchor015)，*数据分析导论*中有提及；然而，你也可以按照[*第七章*](B16834_07_Final_SK_ePub.xhtml#_idTextAnchor146)，*金融分析——比特币与股市*中的说明，安装一个可以编辑的版本。
- en: The repository for this chapter, which can be found at [https://github.com/stefmolin/Hands-On-Data-Analysis-with-Pandas-2nd-edition/tree/master/ch_08](https://github.com/stefmolin/Hands-On-Data-Analysis-with-Pandas-2nd-edition/tree/master/ch_08),
    has the notebook we will use for our actual analysis (`anomaly_detection.ipynb`),
    the data files we will be working with in the `logs/` folder, the data used for
    the simulation in the `user_data/` folder, and the `simulate.py` file, which contains
    a Python script that we can run on the command line to simulate the data for the
    chapter.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节的代码库可以在[https://github.com/stefmolin/Hands-On-Data-Analysis-with-Pandas-2nd-edition/tree/master/ch_08](https://github.com/stefmolin/Hands-On-Data-Analysis-with-Pandas-2nd-edition/tree/master/ch_08)找到，包含了我们实际分析中使用的笔记本（`anomaly_detection.ipynb`）、我们将在`logs/`文件夹中处理的数据文件、用于模拟的数据（位于`user_data/`文件夹），以及包含Python脚本的`simulate.py`文件，我们可以在命令行运行该脚本来模拟本章节的数据。
- en: Simulating login attempts
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟登录尝试
- en: Since we can't easily find login attempt data from a breach (it's not typically
    shared due to its sensitive nature), we will be simulating it. Simulation requires
    a strong understanding of statistical modeling, estimating probabilities of certain
    events, and identifying appropriate assumptions to simplify where necessary. In
    order to run the simulation, we will build a Python package (`login_attempt_simulator`)
    to simulate a login process requiring a correct username and password (without
    any extra authentication measures, such as two-factor authentication) and a script
    (`simulate.py`) that can be run on the command line, both of which we will discuss
    in this section.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们很难从泄露数据中找到登录尝试数据（通常因为其敏感性不予共享），我们将进行模拟。模拟需要对统计建模有深入的理解，能够估计某些事件的概率，并根据需要识别适当的假设进行简化。为了运行模拟，我们将构建一个Python包（`login_attempt_simulator`）来模拟登录过程，要求正确的用户名和密码（没有任何额外的身份验证措施，如双重身份验证），以及一个可以在命令行运行的脚本（`simulate.py`），我们将在本节中讨论这两个内容。
- en: Assumptions
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 假设
- en: Before we jump into the code that handles the simulation, we need to understand
    the assumptions. It is impossible to control for every possible variable when
    we make a simulation, so we must identify some simplifying assumptions to get
    started.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进入处理模拟的代码之前，需要理解一些假设。进行模拟时不可能控制所有可能的变量，因此我们必须确定一些简化假设以便开始。
- en: 'The simulator makes the following assumptions regarding valid users of the
    website:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟器对网站有效用户做出以下假设：
- en: Valid users come according to a **Poisson process** at an hourly rate that depends
    on the day of the week and the time of day. A Poisson process models arrivals
    per unit of time (our simulation will use an hour) as a Poisson distribution with
    mean λ (lambda). The interarrival times are exponentially distributed with mean
    1/λ.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有效用户按照**泊松过程**到达，小时的到达率取决于星期几和一天中的时间。泊松过程将每单位时间内的到达（我们的模拟将使用小时）建模为一个均值为λ（lambda）的泊松分布。到达时间服从指数分布，均值为1/λ。
- en: Valid users connect from 1-3 IP addresses (a unique identifier for each device
    using the Internet), which comprise 4 random integers in the range [0, 255] separated
    by periods. It is possible, although highly unlikely, that two valid users share
    an IP address.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有效用户从1到3个IP地址（每个连接到互联网的设备的唯一标识符）连接，这些IP地址由4个随机整数组成，范围为[0, 255]，并由句点分隔。尽管极为不可能，但两个有效用户可能会共享一个IP地址。
- en: Valid users are unlikely to make many mistakes while entering their credentials.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有效用户在输入凭证时不太可能犯很多错误。
- en: Important note
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 重要提示
- en: The interarrival times have the **memoryless** property, meaning that the time
    between two consecutive arrivals has no bearing on when the subsequent arrival
    will happen.
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 到达时间具有**无记忆性**特性，这意味着两个连续到达之间的时间不会影响随后的到达时间。
- en: 'The simulator makes the following assumptions about the hackers:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟器对黑客做出以下假设：
- en: The hackers try to avoid an account lockout by only testing a few username-password
    combinations, rather than a full-blown **dictionary attack** (for every user,
    trying every password the hacker has in a dictionary of possible passwords that
    they maintain). However, they don't add delays between their attempts.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 黑客试图避免账户锁定，只测试少量的用户名和密码组合，而不是进行全面的**字典攻击**（对于每个用户，尝试黑客在字典中所有可能的密码）。然而，他们在尝试之间不会添加延迟。
- en: Since the hackers don't want to cause a denial of service, they limit the volume
    of their attacks and only make one attempt at a time.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于黑客不想造成拒绝服务攻击，他们限制攻击的频率，每次只进行一次尝试。
- en: The hackers know the number of accounts that exist in the system and have a
    good idea of the format the usernames are in, but are guessing the exact usernames.
    They will choose to try to guess all 133 usernames, or some subset of them.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 黑客知道系统中存在的账户数量，并且对用户名的格式有一定了解，但他们只能猜测具体的用户名。他们会选择尝试猜测所有133个用户名，或者其中的某些子集。
- en: Each attack is standalone, meaning there is a single hacker acting for each
    attack, and a hacker never attacks more than once.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次攻击都是独立的，也就是说每次攻击都是由单个黑客执行的，而且一个黑客从不进行多次攻击。
- en: The hackers don't share information about which username-password combinations
    are correct.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 黑客不会共享哪些用户名-密码组合是正确的。
- en: The attacks come at random times.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 攻击是随机发生的。
- en: Each hacker will use a single IP address, which is generated in the same way
    the valid user ones are. However, our simulator is capable of varying this IP
    address, a feature that we will look at in [*Chapter 11*](B16834_11_Final_SK_ePub.xhtml#_idTextAnchor237),
    *Machine Learning Anomaly Detection*, to make this scenario more challenging.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个黑客将使用一个唯一的IP地址，该地址与有效用户的IP地址生成方式相同。然而，我们的模拟器能够改变这个IP地址，这是我们将在[*第11章*](B16834_11_Final_SK_ePub.xhtml#_idTextAnchor237)《机器学习异常检测》中探讨的功能，目的是让这个场景变得更具挑战性。
- en: Although highly unlikely, it is possible the hacker has the same IP address
    as a valid user. The hacker may even be a valid user.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然可能性极小，但黑客的IP地址可能与有效用户相同，甚至黑客可能是有效用户。
- en: We are abstracting away some of the complexity of password-guessing as well;
    instead, we are using random numbers to determine whether or not the password
    is guessed correctly—this means we aren't considering how the website stores passwords,
    perhaps as plaintext (hopefully not), hashes (the irreversible transformation
    of the plaintext password that allows verification without storing the actual
    password), or salted hashes (refer to the *Further reading* section for an article
    on this). In practice, a hacker could gain access to the stored passwords and
    figure out what they are offline (see the article on rainbow tables in the *Further
    reading* section at the end of this chapter), in which case the techniques discussed
    in this chapter wouldn't be as helpful, since the logs wouldn't have a record
    of their attempts. Keep in mind that the hackers in this simulation are very conspicuous.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也在抽象化密码猜测的一些复杂性；相反，我们使用随机数字来决定密码是否被猜测正确——这意味着我们没有考虑网站如何存储密码，可能是明文（希望不是）、哈希值（对明文密码进行不可逆转换，使得无需存储实际密码即可进行验证）或加盐哈希值（有关这方面的文章请参见*进一步阅读*部分）。实际上，黑客可能会获取存储的密码并离线破解它们（请参阅*进一步阅读*部分结尾处关于彩虹表的文章），在这种情况下，本章讨论的技术可能不会很有帮助，因为日志中不会记录他们的尝试。请记住，本次模拟中的黑客非常显眼。
- en: The login_attempt_simulator package
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`login_attempt_simulator` 包'
- en: 'This package is much more lightweight than the `stock_analysis` package from
    the previous chapter; we only have three files:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这个包比上一章中的`stock_analysis`包要轻量得多；我们只有三个文件：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We will walk through each of these files in the following sections. Note that
    parts of the docstrings have been removed for brevity; check the files themselves
    for the full documentation.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在以下章节中逐一讲解这些文件。请注意，部分文档字符串已被删除以简洁起见；请查看文件本身以获取完整的文档。
- en: Helper functions
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 辅助函数
- en: 'Let''s start our discussion with the `utils.py` functions, which are helpers
    for our simulator class. First, we create our docstring for the module and handle
    our imports:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`utils.py`函数开始讨论，它们是我们模拟器类的辅助工具。首先，我们为模块创建文档字符串，并处理导入：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, we define the `make_user_base()` function, which makes the user base
    for our web application. It creates a file of usernames by combining one lowercase
    letter from the English alphabet with each last name in the list inside the function,
    and adds a few administrative accounts as well; this results in a user base of
    133 accounts. By writing to a file, we ensure we don''t have to generate this
    every time we run our simulation and can simply read from it to simulate in the
    future:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义`make_user_base()`函数，它为我们的Web应用程序创建用户库。该函数通过将英语字母表中的一个小写字母与函数内列表中的每个姓氏结合，来创建一个包含用户名的文件，并添加一些管理员账户；这样就形成了一个包含133个账户的用户库。通过写入文件，我们确保每次运行模拟时不需要重新生成，而是可以简单地从中读取数据以便将来进行模拟：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Since we will need to use this user base in our simulator, we also write a
    function to read the user base file into a list. The `get_valid_users()` function
    reads the file written by the `make_user_base()` function back into a Python list:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们需要在模拟器中使用这个用户库，我们还写了一个函数来读取用户库文件并将其转化为列表。`get_valid_users()` 函数将由 `make_user_base()`
    函数写入的文件重新读取到 Python 列表中：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `random_ip_generator()` function creates IP addresses from random numbers
    of the form `xxx.xxx.xxx.xxx`, where `x` is an integer in the range [0, 255].
    We are using the `ipaddress` module from the Python standard library ([https://docs.python.org/3/library/ipaddress.html](https://docs.python.org/3/library/ipaddress.html))
    to avoid assigning private IP addresses:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`random_ip_generator()` 函数生成随机的 IP 地址，格式为 `xxx.xxx.xxx.xxx`，其中 `x` 是 [0, 255]
    范围内的整数。我们使用 Python 标准库中的 `ipaddress` 模块（[https://docs.python.org/3/library/ipaddress.html](https://docs.python.org/3/library/ipaddress.html)）来避免分配私有
    IP 地址：'
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Each of our users will have a few IP addresses from which they attempt to log
    in. The `assign_ip_addresses()` function maps 1-3 random IP addresses to each
    user, creating a dictionary:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 每个用户将有几个尝试登录的 IP 地址。`assign_ip_addresses()` 函数为每个用户映射 1 到 3 个随机 IP 地址，创建一个字典：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `save_user_ips()` and `read_user_ips()` functions save the user-IP address
    mapping to a JSON file and read it back into the dictionary file, respectively:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`save_user_ips()` 和 `read_user_ips()` 函数分别将用户-IP 地址映射保存到 JSON 文件中，并将其重新读取到字典文件中：'
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Tip
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: The Python standard library has lots of helpful modules that we might not find
    many occasions to use but are definitely worth knowing about. Here, we use the
    `json` module to save dictionaries to JSON files and read them back later. We
    are using the `ipaddress` module to work with IP addresses, and the `string` module
    to get the characters in the alphabet without having to type them all out.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Python 标准库有许多有用的模块，尽管我们可能不常用，但它们绝对值得了解。在这里，我们使用 `json` 模块将字典保存到 JSON 文件，并稍后读取它们。我们使用
    `ipaddress` 模块处理 IP 地址，使用 `string` 模块获取字母表中的字符，而不需要一一输入。
- en: The LoginAttemptSimulator class
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: LoginAttemptSimulator 类
- en: 'The `LoginAttemptSimulator` class in the `login_attempt_simulator.py` file
    handles the heavy lifting of carrying out the simulation with all the random number
    generation logic. As usual, we start with our module docstring and imports:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`login_attempt_simulator.py` 文件中的 `LoginAttemptSimulator` 类负责执行模拟的重负荷工作，包含所有随机数生成逻辑。像往常一样，我们从模块的文档字符串和导入语句开始：'
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Next, we begin defining the `LoginAttemptSimulator` class with its docstring,
    along with some class variables for storing constants. We do this to avoid magic
    numbers (numbers in the code that don''t seem to have meaning) and spelling errors
    with strings we will use in multiple spots. Note that these messages are only
    for our logs; the web application doesn''t show the end users why the authentication
    attempt failed (nor should it):'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们开始定义 `LoginAttemptSimulator` 类及其文档字符串，同时为存储常量定义一些类变量。我们这样做是为了避免使用魔法数字（即代码中看似没有意义的数字）以及避免在多个地方使用字符串时出现拼写错误。请注意，这些信息仅用于我们的日志；Web
    应用程序不会向最终用户显示认证尝试失败的原因（也不应该显示）：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Important note
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Take note of how we used class variables to store constants, such as error messages,
    so that we don't risk typos in the code. This means that every time we use these
    error messages, the text will be identical, which will keep the data clean. In
    Python, constants are typically written in all caps ([https://www.python.org/dev/peps/pep-0008/#constants](https://www.python.org/dev/peps/pep-0008/#constants)).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意我们如何使用类变量来存储常量，例如错误信息，这样就不会在代码中犯拼写错误。这样，每次使用这些错误信息时，文本都会保持一致，从而保持数据的整洁。在
    Python 中，常量通常采用全大写字母形式（[https://www.python.org/dev/peps/pep-0008/#constants](https://www.python.org/dev/peps/pep-0008/#constants)）。
- en: 'The `__init__()` method will handle the setup for the simulator, such as reading
    in the user base from the file indicated, initializing the logs, storing success
    probabilities, and determining the start and end dates for the simulation, as
    needed:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`__init__()` 方法将处理模拟器的设置，例如从指定的文件读取用户库、初始化日志、存储成功概率，并根据需要确定模拟的开始和结束日期：'
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `_record()` method appends the result of each attempt to the log, noting
    the IP address it came from, which username, at what time, whether it succeeded,
    and the reason for failure, if there was one:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`_record()` 方法将每次尝试的结果追加到日志中，记录其来源的 IP 地址、用户名、时间、是否成功以及失败的原因（如果有的话）：'
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `_attempt_login()` method handles the logic of determining whether the
    login attempt succeeds:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`_attempt_login()` 方法处理判断登录尝试是否成功的逻辑：'
- en: '![Figure 8.1 – Simulation logic'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.1 – 模拟逻辑'
- en: '](img/Figure_8.1_B16834.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.1_B16834.jpg)'
- en: Figure 8.1 – Simulation logic
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1 – 模拟逻辑
- en: 'We provide the probability of entering a correct username (`username_accuracy`)
    and the probabilities of successfully entering the password for each attempt (`success_likelihoods`).
    The number of attempts is the minimum of the number of attempts allowed before
    an account lockout and the length of the list of success probabilities (`success_likelihoods`).
    The outcome of each attempt is passed to `_record()` using `functools`), which
    allow us to create functions that fix certain parameters to a specific value (so
    we don''t have to pass the same value continuously):'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供输入正确用户名的概率（`username_accuracy`）以及每次尝试成功输入密码的概率（`success_likelihoods`）。尝试次数是允许的最大尝试次数与成功概率列表长度（`success_likelihoods`）中的最小值。每次尝试的结果会通过
    `functools` 传递给 `_record()`，它允许我们创建函数，将某些参数固定为特定值（这样就不必不断传递相同的值）：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `_valid_user_attempts_login()` and `_hacker_attempts_login()` methods are
    wrappers around the `_attempt_login()` method that handle the adjustment in probabilities
    for valid users and hackers, respectively. Notice that while both use a Gaussian
    (normal) distribution to determine how accurate the username will be, the valid
    user''s distribution has a higher mean and lower standard deviation, meaning they
    are more likely to provide the correct username when trying to log in. This is
    because, while valid users may make typos (infrequently), the hackers are guessing:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`_valid_user_attempts_login()` 和 `_hacker_attempts_login()` 方法是围绕 `_attempt_login()`
    方法的封装，分别处理有效用户和黑客的概率调整。注意，尽管两者都使用高斯（正态）分布来确定用户名的准确性，但有效用户的分布具有更高的均值和更低的标准差，这意味着他们在尝试登录时更有可能提供正确的用户名。这是因为，虽然有效用户可能会打错字（偶尔发生），但黑客则是在猜测：'
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'When the simulator determines that the username will not be provided correctly,
    it calls the `_distort_username()` method, which randomly decides to omit a letter
    from the valid username or to replace one of the letters with another one. While
    hackers enter incorrect usernames because they are guessing (not due to typos),
    we abstract away this detail in order to use a single function for introducing
    username errors for both valid users and hackers:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当模拟器判断用户名无法正确提供时，它会调用 `_distort_username()` 方法，该方法会随机决定从有效用户名中省略一个字母或将一个字母替换为另一个字母。虽然黑客因猜测而输入错误的用户名（而不是由于打字错误），我们在这里抽象化处理这一细节，以便使用一个统一的函数来为有效用户和黑客引入用户名错误：
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We use the `_valid_user_arrivals()` method to generate the number of users
    that will arrive in a given hour and the interarrival times using Poisson and
    exponential distributions, respectively:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `_valid_user_arrivals()` 方法来生成给定小时内到达的用户数量和使用泊松分布和指数分布生成的到达间隔时间：
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Important note
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: We are using `numpy` instead of `random` to generate random numbers from the
    exponential distribution because we can ask for multiple values at once (one for
    each of the hourly arrivals determined by the Poisson process). Also, note that
    `random` doesn't provide a Poisson distribution, so we need `numpy`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `numpy` 而不是 `random` 来从指数分布中生成随机数，因为我们可以一次请求多个值（每个值对应泊松过程确定的每小时到达数）。此外，`random`
    不提供泊松分布，因此我们需要 `numpy`。
- en: 'Our simulation uses many different distributions, so it can be helpful to see
    what they look like. The following subplots show examples for each of the distributions
    we are using. Notice that the Poisson distribution is drawn differently. This
    is because the Poisson distribution is discrete. For this reason, we often use
    it to model arrivals—here, we use it for modeling the arrivals of users attempting
    to log in. Discrete distributions have a **probability mass function** (**PMF**)
    instead of a **probability density function** (**PDF**):'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的模拟使用了多种不同的分布，因此查看它们的样子可能会有所帮助。以下子图展示了我们使用的每种分布的示例。注意，泊松分布的绘制方式不同。这是因为泊松分布是离散的。因此，我们通常用它来模拟到达情况——在这里，我们用它来模拟尝试登录的用户到达情况。离散分布有一个**概率质量函数**（**PMF**），而不是**概率密度函数**（**PDF**）：
- en: '![Figure 8.2 – Distributions used in the simulation'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.2 – 模拟中使用的分布'
- en: '](img/Figure_8.2_B16834.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.2_B16834.jpg)'
- en: Figure 8.2 – Distributions used in the simulation
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.2 – 模拟中使用的分布
- en: 'The `_hack()` method generates a random IP address for the hacker and carries
    out a brute-force attack on a given user list:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`_hack()` 方法为黑客生成一个随机的 IP 地址，并对给定的用户列表进行暴力攻击：'
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now that we have the functionality to carry out the main parts of the simulation,
    we write the `simulate()` method to put it all together:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经具备了执行仿真主要部分的功能，我们编写 `simulate()` 方法将所有内容整合在一起：
- en: '[PRE16]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We want to save the logs to CSV files, so we add the `_save()` method as a
    static method to allow for less repetition in the code for the two save methods.
    The `save_log()` method will save the login attempts and the `save_hack_log()`
    method will save the record of the attacks:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望将日志保存为 CSV 文件，因此我们将 `_save()` 方法作为静态方法添加，以减少两个保存方法中的代码重复。`save_log()` 方法将保存登录尝试，而
    `save_hack_log()` 方法将保存攻击记录：
- en: '[PRE17]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Notice that there were many private methods in this class; this is because users
    of this class only need to be able to create an instance of this class (`__init__()`),
    simulate by hour (`simulate()`), and save the output (`save_log()` and `save_hack_log()`)—all
    other methods are for internal use by objects of this class. The methods behind
    the scenes will handle the bulk of the work.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到这个类中有很多私有方法，这是因为该类的用户只需要能够创建该类的实例（`__init__()`），按小时进行仿真（`simulate()`），并保存输出（`save_log()`
    和 `save_hack_log()`）——所有其他方法仅供该类的对象内部使用。后台的这些方法将处理大部分工作。
- en: 'Lastly, we have the `__init__.py` file, which makes this a package, but also
    provides us with an easier way to import the main class:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有 `__init__.py` 文件，这使得这个目录变成一个包，同时也为我们提供了一种更容易的方式来导入主类：
- en: '[PRE18]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now that we understand how the simulator works, we will discuss how to run the
    simulation to collect the login attempts data.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了仿真器是如何工作的，接下来我们将讨论如何运行仿真以收集登录尝试的数据。
- en: Simulating from the command line
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从命令行进行仿真
- en: Rather than writing the code to simulate the login attempts every time, we can
    package this up in a script that we can easily run from the command line. The
    Python standard library has the `argparse` module ([https://docs.python.org/3/library/argparse.html](https://docs.python.org/3/library/argparse.html)),
    which allows us to specify arguments to our script that can be supplied from the
    command line.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将模拟登录尝试的代码包装成一个可以轻松通过命令行运行的脚本，而不是每次都写代码。Python 标准库中有 `argparse` 模块（[https://docs.python.org/3/library/argparse.html](https://docs.python.org/3/library/argparse.html)），允许我们为脚本指定可以从命令行提供的参数。
- en: 'Let''s take a look at the `simulate.py` file to see how to do this. We start
    with our imports:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看 `simulate.py` 文件，看看如何做到这一点。我们从导入开始：
- en: '[PRE19]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In order to provide status updates when using this from the command line, we
    are going to set up logging messages using the standard library''s `logging` module
    ([https://docs.python.org/3/library/logging.html](https://docs.python.org/3/library/logging.html)):'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在命令行中使用时提供状态更新，我们将使用标准库中的 `logging` 模块设置日志消息（[https://docs.python.org/3/library/logging.html](https://docs.python.org/3/library/logging.html)）：
- en: '[PRE20]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Next, we define some utility functions for generating file paths that we will
    need for reading and writing data during the simulation:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义了一些实用函数，用于生成我们在仿真过程中读取和写入数据时需要的文件路径：
- en: '[PRE21]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The largest part of this script defines which command-line parameters can be
    passed—we will allow the user to specify whether they want to create a new user
    base, set a seed, when to start the simulation, how long to simulate, and where
    to save all the files. The actual simulation is taken care of in a few lines thanks
    to the package we built. This section will only run when this module is run, rather
    than imported:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本的最大部分定义了可以传递的命令行参数——我们将允许用户指定是否要创建一个新的用户基础，设置种子，仿真开始时间，仿真时长，以及保存所有文件的位置。实际的仿真通过我们构建的包在几行代码内完成。这个部分只有在运行该模块时才会执行，而不是在导入时：
- en: '[PRE22]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Tip
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: The code placed in the `if __name__ == '__main__'` block will only be run when
    this module is run as a script. This makes it possible for us to import the functions
    defined in the module without running the simulation.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`if __name__ == ''__main__''` 块中放置的代码只有在该模块作为脚本运行时才会被执行。这样，我们就可以在不运行仿真的情况下导入模块中定义的函数。'
- en: 'After defining the arguments, we need to parse them in order to use them:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 定义好参数后，我们需要解析它们才能使用：
- en: '[PRE23]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Once we have the command-line arguments parsed, we check to see whether we
    need to generate the user base or read it in:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们解析了命令行参数，就检查是否需要生成用户基础数据或读取它：
- en: '[PRE24]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Afterward, we parse the start date from the command-line arguments, and determine
    the end date by adding the duration from the command-line arguments to the start
    date:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们从命令行参数中解析起始日期，并通过将持续时间添加到起始日期来确定结束日期：
- en: '[PRE25]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Tip
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: '[PRE26]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Finally, we run the actual simulation and write our results to the files specified
    (or the default paths). We set the probability of attack in a given hour to 10%
    (`attack_prob`), the probability the hacker will attempt to guess all usernames
    at 20% (`try_all_users_prob`), and have the hackers use the same IP address for
    all of their attempts (`vary_ips`):'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们运行实际的模拟并将结果写入指定的文件（或默认路径）。我们将某一小时内发生攻击的概率设置为10%（`attack_prob`），黑客尝试猜测所有用户名的概率设置为20%（`try_all_users_prob`），并让黑客在所有尝试中使用相同的IP地址（`vary_ips`）：
- en: '[PRE27]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Tip
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Notice that we used the `logger` object to print helpful messages to the screen
    throughout the script; this will help the users of this script know how far along
    in the process it is. These messages come in different levels of severity (we
    are using `INFO`, `WARNING`, and `ERROR` here), allowing them to be placed for
    debugging (the `DEBUG` level), and left there once the code goes into production,
    since the minimum level for printing can be raised to `INFO`, so that no `DEBUG`
    messages are printed. This is leaps and bounds above simple `print()` statements,
    since we don't have to worry about removing them as we move to production or adding
    back these messages as development continues.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们使用了`logger`对象在脚本中打印有用的信息到屏幕；这将帮助脚本用户了解进程进行到什么阶段。这些信息有不同的严重级别（我们在这里使用的是`INFO`、`WARNING`和`ERROR`），允许它们用于调试（`DEBUG`级别），并且在代码进入生产阶段后，打印的最小级别可以提高到`INFO`，这样就不会再打印`DEBUG`信息。这比简单的`print()`语句要强大得多，因为我们不需要担心在进入生产环境时删除它们，或者在开发继续进行时再将这些信息加回去。
- en: 'Let''s now take a look at how we can run this script. We know that `simulate.py`
    can be run on the command line, but how can we see what arguments we need to pass?
    Simple—we add the help flag (`-h` or `--help`) to the call:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看如何运行这个脚本。我们知道`simulate.py`可以在命令行上运行，但我们如何查看需要传递哪些参数呢？很简单——我们只需在调用时添加帮助标志（`-h`或`--help`）：
- en: '[PRE28]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Important note
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Note that we didn't specify the `help` argument when we added the other arguments
    with `argparse`; it was automatically created by `argparse`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当我们使用`argparse`添加其他参数时，并没有指定`help`参数；它是由`argparse`自动创建的。
- en: 'Once we know which arguments we can pass and have decided which of these we
    want to provide, we can run the simulation. Let''s simulate 30 days, starting
    from 12 AM on November 1, 2018, while having the script create the user base and
    IP address mappings needed:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们知道可以传递哪些参数，并决定了我们想要提供哪些参数，我们就可以运行模拟了。让我们模拟从2018年11月1日12点开始的30天，并让脚本创建所需的用户基础和IP地址映射：
- en: '[PRE29]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Tip
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Since we set a seed (`-s 0`), the output of this simulation is reproducible.
    Simply remove the seed or change it to get a different result.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们设置了种子（`-s 0`），因此此模拟的输出是可重现的。只需移除种子或更改它，就可以得到不同的结果。
- en: 'Python modules can also be run as scripts. As opposed to importing a module,
    when we run one as a script, any code underneath `if __name__ == ''__main__''`
    will also be run, meaning we don''t always need to write a separate script. Most
    of the modules we have built only defined functions and classes, so running them
    as scripts wouldn''t do anything; however, the way we created our virtual environment
    with `venv` back in [*Chapter 1*](B16834_01_Final_SK_ePub.xhtml#_idTextAnchor015),
    *Introduction to Data Analysis*, was an example of this. The previous code block
    is therefore equivalent to the following command:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Python模块也可以作为脚本运行。与导入模块不同，当我们将模块作为脚本运行时，`if __name__ == '__main__'`下方的任何代码也会被执行，这意味着我们不总是需要编写单独的脚本。我们构建的大多数模块只定义了函数和类，因此作为脚本运行并不会有任何效果；然而，我们在[*第1章*](B16834_01_Final_SK_ePub.xhtml#_idTextAnchor015)《数据分析简介》中创建虚拟环境时，正是这种方式。前面的代码块因此等同于以下命令：
- en: '[PRE30]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Now that we have our simulated data, let's begin our analysis.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了模拟数据，开始进行分析吧。
- en: Exploratory data analysis
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索性数据分析
- en: 'In this scenario, we have the benefit of access to labeled data (`logs/attacks.csv`)
    and will use it to investigate how to distinguish between valid users and attackers.
    However, this is a luxury that we often don''t have, especially once we leave
    the research phase and enter the application phase. In [*Chapter 11*](B16834_11_Final_SK_ePub.xhtml#_idTextAnchor237),
    *Machine Learning Anomaly Detection*, we will revisit this scenario, but begin
    without the labeled data for more of a challenge. As usual, we start with our
    imports and reading in the data:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们有幸可以访问标记数据（`logs/attacks.csv`），并将其用于研究如何区分合法用户和攻击者。然而，这种情况在我们离开研究阶段并进入应用阶段时往往无法实现。在[*第
    11 章*](B16834_11_Final_SK_ePub.xhtml#_idTextAnchor237)《机器学习异常检测》中，我们将重新审视这一场景，但从没有标记数据开始，以增加挑战。像往常一样，我们先进行导入并读取数据：
- en: '[PRE31]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The login attempts dataframe (`log`) contains the date and time of each attempt
    in the `datetime` column, the IP address it came from (`source_ip`), the username
    that was used (`username`), whether the attempt was successful (`success`), and
    the reason for failure if it wasn''t (`failure_reason`):'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 登录尝试数据框（`log`）包含了每次尝试的日期和时间（`datetime`列）、来源的 IP 地址（`source_ip`）、使用的用户名（`username`）、是否成功（`success`）以及如果失败的话失败原因（`failure_reason`）：
- en: '![Figure 8.3 – Sample of the login attempt data'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.3 – 登录尝试数据示例'
- en: '](img/Figure_8.3_B16834.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.3_B16834.jpg)'
- en: Figure 8.3 – Sample of the login attempt data
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.3 – 登录尝试数据示例
- en: 'When approaching this data, we need to think about what normal activity and
    hacker activity would look like. Any big differences between the groups could
    potentially be leveraged to identify the hackers. We would expect valid users
    to have high success rates, with the most common reason for failure being an incorrect
    password. We would expect users to log in from a few different IP addresses (phone,
    home computer, work computer, and any other device they may have), and it is possible
    that people share devices. Without knowing the nature of this web application,
    we can''t say anything about whether it is normal to log in many times throughout
    the day. We also don''t know what time zone this data is in, so we can''t make
    any inferences about the login times. Potentially, we could look at which countries
    these IP addresses are from, but there are ways of masking IP addresses, so we
    won''t go down that path. This leaves us with a few viable options, given our
    available data:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理这些数据时，我们需要思考什么是正常活动，什么是黑客活动。两者之间的任何显著差异都可能被用来识别黑客。我们预计合法用户的成功率较高，最常见的失败原因是密码错误。我们预计用户会从不同的
    IP 地址登录（手机、家用电脑、工作电脑以及其他可能的设备），并且有可能人们共享设备。由于我们不了解该网络应用程序的性质，我们不能说多次登录是否正常。我们也不知道这些数据的时区，因此不能对登录时间做出任何推断。理论上，我们可以查看这些
    IP 地址来自哪些国家，但由于有方法可以隐藏 IP 地址，因此我们不会走这条路。基于现有数据，我们可以选择以下几种可行的方式：
- en: Investigate any spikes in attempts and failures (both overall and per IP address).
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调查登录尝试和失败的任何异常波动（无论是总体还是按 IP 地址统计）。
- en: Examine cases where the failure reason was an incorrect username.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查失败原因是用户名错误的情况。
- en: Look at the failure rate per IP address.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看每个 IP 地址的失败率。
- en: Find IP addresses trying to log in with many distinct usernames.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找尝试使用多个不同用户名登录的 IP 地址。
- en: 'One other thing to note is that we would want to flag anomalous behavior sooner
    rather than later. Waiting a month to flag something is less valuable (the value
    drops quickly over time), so we need to find a way to flag much sooner; say, using
    an hourly frequency. Since we are in the research phase, we have some labeled
    data to work with:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的点是，我们希望尽早标记异常行为，而不是等到最后。等待一个月才标记某个行为的价值较低（随着时间推移，价值迅速下降），因此我们需要找到更早标记异常的方式；例如，使用每小时的频率。由于我们处于研究阶段，可以使用一些标记数据：
- en: '[PRE32]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This data is the record of attacks on the web application (`attacks`). It contains
    the date and time of the start of the attack (`start`), the date and time of the
    end of the attack (`end`), and the IP address associated with the attack (`source_ip`):'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数据是针对网络应用程序（`attacks`）的攻击记录。它包含了攻击开始的日期和时间（`start`）、攻击结束的日期和时间（`end`）以及与攻击相关的
    IP 地址（`source_ip`）：
- en: '![Figure 8.4 – Sample of the labeled data'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.4 – 标记数据示例'
- en: '](img/Figure_8.4_B16834.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.4_B16834.jpg)'
- en: Figure 8.4 – Sample of the labeled data
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.4 – 标记数据示例
- en: 'Using the `shape` property, we can see that we had 72 attacks and 12,836 login
    attempts from valid and nefarious users, and with `nunique()`, we see that 22%
    of the IP addresses were associated with attacks:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`shape`属性，我们可以看到72次攻击和12,836次来自有效用户和恶意用户的登录尝试，使用`nunique()`，我们看到22%的IP地址与攻击相关：
- en: '[PRE33]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Important note
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Normally, it wouldn't be this trivial to know when the attacks occurred—they
    can go a long time without detection, and, even then, it's not so simple to isolate
    the attacker's actions from those of normal users.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，仅凭这些数据很难知道攻击发生的具体时间——攻击可以在不被发现的情况下持续很长时间，即使是这样，也并不容易将攻击者的行为与正常用户的行为区分开来。
- en: 'Our data is pretty clean (we designed it just for this purpose, after all),
    so let''s see whether we can find anything interesting by performing some **exploratory
    data analysis** (**EDA**). First, let''s look to see how many attempts are coming
    through on an hourly basis:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数据相当干净（毕竟我们就是为这个目的设计的），所以让我们看看通过执行一些**探索性数据分析**（**EDA**）是否能发现有趣的东西。首先，让我们看看每小时的登录尝试数量：
- en: '[PRE34]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Several hours had very large peaks, which could possibly be when attacks occurred.
    Using this plot, we could report on hours that had a high level of login attempt
    activity, but nothing beyond that:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 几个小时的登录尝试出现了非常大的峰值，这可能是攻击发生的时间。使用这张图，我们可以报告登录尝试活动较高的小时数，但仅此而已：
- en: '![Figure 8.5 – Hourly login attempts'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.5 – 每小时登录尝试'
- en: '](img/Figure_8.5_B16834.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.5_B16834.jpg)'
- en: Figure 8.5 – Hourly login attempts
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.5 – 每小时登录尝试
- en: 'Another interesting avenue of exploration would be to see how many attempts
    came from each IP address. We can achieve this by running the following command:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的探索方向是查看每个IP地址的尝试次数。我们可以通过运行以下命令来实现这一点：
- en: '[PRE35]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This data definitely appears to have some outliers, which pull the number of
    attempts per IP address up quite high. Let''s create some plots to better assess
    this:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数据显然有一些异常值，它们将每个IP地址的尝试次数拉得很高。让我们创建一些图表来更好地评估这一点：
- en: '[PRE36]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The distribution of attempts per IP address is the sum of the distributions
    for both valid users and attackers. The histogram indicates that this distribution
    is bimodal, but we are unable to determine whether all of those IP addresses with
    high attempts are actually hackers by just looking at the plot:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 每个IP地址的尝试分布是有效用户和攻击者分布的总和。直方图显示这个分布是双峰的，但仅凭这张图我们无法确定所有高尝试次数的IP地址是否都是黑客：
- en: '![Figure 8.6 – Distribution of login attempts per IP address'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.6 – 每个IP地址的登录尝试分布'
- en: '](img/Figure_8.6_B16834.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.6_B16834.jpg)'
- en: Figure 8.6 – Distribution of login attempts per IP address
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.6 – 每个IP地址的登录尝试分布
- en: 'Since we have access to the details of each attack, we can check whether the
    right part of the histogram is the distribution for the hackers. Their IP addresses
    make up 88.9% of the top IP addresses ranked by number of attempts:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们可以访问每次攻击的详细信息，我们可以检查直方图的右侧部分是否是黑客的分布。根据尝试次数，黑客的IP地址占前列IP地址的88.9%：
- en: '[PRE37]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We could simply stop here and flag any IP address that shows up in a list of
    IP addresses with the most attempts per month, but we most likely want a more
    robust solution, since the hackers could simply change their IP address each time
    and avoid detection. Ideally, we would also be able to detect the attacks without
    waiting for a full month''s worth of data. Looking at the hourly attempts made
    by each IP address unfortunately doesn''t give us much information, though:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在此停止，并标记出每个月尝试次数最多的IP地址列表，但我们更可能需要一个更具鲁棒性的解决方案，因为黑客每次都可能更改IP地址来避免检测。理想情况下，我们还希望在不等待完整一个月的数据的情况下就能检测到攻击。然而，通过查看每个IP地址的每小时尝试次数，遗憾的是，似乎并没有提供太多信息：
- en: '[PRE38]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Remember from [*Chapter 1*](B16834_01_Final_SK_ePub.xhtml#_idTextAnchor015),
    *Introduction to Data Analysis*, that the mean is not robust to outliers. If the
    attackers make many attempts, they will bring the average hourly attempts per
    IP address higher. We can see several large peaks in this line plot, but notice
    that many of them only go up to two or three. Can we really expect only one user
    to access the web application from a given IP address? This is probably not a
    realistic assumption:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 请回想一下来自[*第一章*](B16834_01_Final_SK_ePub.xhtml#_idTextAnchor015)的内容，*数据分析简介*，其中提到均值对异常值不具鲁棒性。如果攻击者进行了多次尝试，异常值会将每个IP地址的平均每小时登录尝试次数拉高。我们可以在这条线图中看到几个大的峰值，但注意到它们中的许多只有两到三次。我们真的能期望一个用户只通过一个IP地址访问Web应用程序吗？这很可能不是一个现实的假设：
- en: '![Figure 8.7 – Average hourly login attempts per IP address'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.7 – 每个IP地址的平均每小时登录尝试次数'
- en: '](img/Figure_8.7_B16834.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.7_B16834.jpg)'
- en: Figure 8.7 – Average hourly login attempts per IP address
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.7 – 每个IP地址的平均每小时登录尝试次数
- en: 'So, if we can''t rely on the IP address (after all, the hacker could be smart
    enough to spread the attack over many different addresses), what else can we try?
    Perhaps the hackers have more trouble logging in successfully:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，如果我们不能仅依赖IP地址（毕竟，黑客可能足够聪明，能够将攻击分布到多个不同的地址上），我们还能尝试什么呢？或许黑客在成功登录方面遇到了更多困难：
- en: '[PRE39]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The hackers are only successful 17% of the time, but how often are the valid
    users successful? This information is important for determining a baseline of
    what normal behavior looks like for the website. As we would expect, valid users
    have much higher success rates:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 黑客成功的概率只有17%，但合法用户的成功率有多高呢？这些信息对于确定网站正常行为的基准值非常重要。正如我们所预期的，合法用户的成功率要高得多：
- en: '[PRE40]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Since the logs come with the reason that a login attempt failed, we can use
    a crosstab to see why hackers and valid users fail to log in successfully. Any
    differences here may help us separate the two groups:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 由于日志中包含了登录失败的原因，我们可以使用交叉表来查看黑客和合法用户未能成功登录的原因。这里的任何差异都可能帮助我们区分这两组用户：
- en: '[PRE41]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Valid users sometimes enter their passwords or usernames incorrectly, but the
    hacker has way more issues getting both the username and password correct:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 合法用户有时会输入错误的密码或用户名，但黑客在同时输入正确的用户名和密码时会遇到更多问题：
- en: '![Figure 8.8 – Reason for failed login attempts'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.8 – 登录失败尝试的原因'
- en: '](img/Figure_8.8_B16834.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.8_B16834.jpg)'
- en: Figure 8.8 – Reason for failed login attempts
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.8 – 登录失败尝试的原因
- en: 'Valid users don''t make many mistakes with their credentials, so if the hackers
    make many attempts with many users, we can flag it. To confirm, we can look at
    average hourly attempts per user:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 合法用户在输入凭证时不会犯太多错误，因此如果黑客尝试登录的次数很多，并且涉及多个用户，我们可以标记这种行为。为了确认这一点，我们可以查看每个用户的平均每小时尝试次数：
- en: '[PRE42]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'For the most part, less than one attempt per hour is made per username. There''s
    also no guarantee that spikes in this metric are indications of an attack. Perhaps
    the website is having a flash sale; in that case, we would likely see a spike
    in this metric caused by valid users:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，每个用户名每小时的尝试次数不到一次。这个指标的波动也不能保证就是攻击的迹象。或许是网站正在进行闪购活动；在这种情况下，我们很可能会看到由合法用户引起的这个指标的激增：
- en: '![Figure 8.9 – Average hourly login attempts per username'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.9 – 每个用户名的平均每小时登录尝试次数'
- en: '](img/Figure_8.9_B16834.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.9_B16834.jpg)'
- en: Figure 8.9 – Average hourly login attempts per username
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.9 – 每个用户名的平均每小时登录尝试次数
- en: 'Based on our findings, error rates seem to be the most fruitful metric for
    detecting attacks, so we will look into IP addresses that have high error rates.
    To do so, we can create a pivot table to calculate some helpful metrics:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们的发现，错误率似乎是检测攻击的最有用指标，因此我们将研究错误率高的IP地址。为此，我们可以创建一个透视表来计算一些有用的指标：
- en: '[PRE43]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Tip
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: The `insert()` method allows us to insert the newly created `attempts` column
    at a specific position in the current dataframe in place. We created the `attempts`
    column as the sum of errors and successes (we fill in the `NaN` values in the
    `failure_reason` column with `success` to count it here) by summing with `axis=1`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`insert()`方法允许我们将新创建的`attempts`列插入到当前数据框的特定位置，并且是就地操作。我们创建了`attempts`列，它是错误和成功的总和（我们将`failure_reason`列中的`NaN`值用`success`填充，以便在此处进行计数），通过在`axis=1`方向上进行求和。'
- en: 'This yields the following pivot table sorted by attempts (from most to fewest):'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这生成了以下按尝试次数排序的透视表（从最多到最少）：
- en: '![Figure 8.10 – Metrics per IP address'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.10 – 每个IP地址的度量'
- en: '](img/Figure_8.10_B16834.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.10_B16834.jpg)'
- en: Figure 8.10 – Metrics per IP address
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.10 – 每个IP地址的度量
- en: 'We know that certain IP addresses are making many attempts, so it''s worth
    looking into how many usernames are attempting to log in per IP address; we would
    expect valid users to only log in from a few IP addresses and not to share their
    IP address with many others. This can be determined with a group by and an aggregation:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道某些IP地址正在进行多次尝试，因此值得调查每个IP地址尝试登录的用户名数量；我们预计合法用户只会从少数几个IP地址登录，并且不会与许多其他用户共享他们的IP地址。这可以通过分组和聚合来确定：
- en: '[PRE44]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This definitely appears to be a good strategy for isolating nefarious users.
    The majority of the IP addresses are used by two or fewer users, but the maximum
    stands at 253\. While this criterion could help us identify some of the attackers,
    it won't help if the hackers are clever enough to vary their IP addresses throughout
    their attack.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来确实是隔离恶意用户的好策略。大多数IP地址由两名或更少的用户使用，但最大值为253个。虽然这个标准可能有助于我们识别一些攻击者，但如果黑客足够聪明，可以在攻击过程中不断更换IP地址，这个标准就无法起到作用了。
- en: 'Before we move on to anomaly detection methods, let''s see whether we can visually
    identify the hackers. Let''s create a scatter plot for the successes and attempts
    for each IP address:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续讨论异常检测方法之前，先看看我们是否能通过视觉识别出黑客。让我们为每个IP地址的成功次数和尝试次数绘制散点图：
- en: '[PRE45]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'There appear to be a few distinct clusters. In the bottom-left corner of the
    plot, we see points forming a line with a one-to-one relationship of successes
    to attempts. The upper-right portion of the plot contains a less dense cluster
    with a high number of attempts and moderate successes. Since we used the `alpha`
    parameter to control transparency, we can see that the trail of points that seem
    to connect the two clusters is not densely populated. Even without the axis scales,
    we would predict the bottom-left cluster to be regular users and the top-right
    to be hackers (since we imagine there are more regular users than hackers, and
    regular users have higher success rates). The points in the middle are more difficult
    to judge, however:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 似乎有几个明显的聚类。在图的左下角，我们看到一些点形成了一条成功与尝试呈一对一关系的线。右上部分则包含一个较为稀疏的聚类，尝试次数较高，成功次数适中。由于我们使用了`alpha`参数来控制透明度，我们可以看到，似乎连接这两个聚类的点迹并不密集。即便没有坐标轴的比例尺，我们也能预测左下角的聚类是普通用户，右上角的聚类是黑客（因为我们假设普通用户比黑客多，而且普通用户的成功率较高）。然而，中间的点则更难判断：
- en: '![Figure 8.11 – Scatter plot of successes versus attempts by IP address'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.11 – 每个IP地址的成功与尝试的散点图'
- en: '](img/Figure_8.11_B16834.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.11_B16834.jpg)'
- en: Figure 8.11 – Scatter plot of successes versus attempts by IP address
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.11 – 每个IP地址的成功与尝试的散点图
- en: 'Without making any assumptions, we can draw a boundary line grouping the middle
    points with their nearest cluster:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在不做任何假设的情况下，我们可以绘制一条边界线，将中间的点与其最近的聚类分组：
- en: '[PRE46]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Of course, when lacking labeled data, it is difficult to evaluate the effectiveness
    of this decision boundary:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在缺乏标注数据的情况下，评估这个决策边界的有效性是困难的：
- en: '![Figure 8.12 – Visualizing a decision boundary'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.12 – 可视化决策边界'
- en: '](img/Figure_8.12_B16834.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.12_B16834.jpg)'
- en: Figure 8.12 – Visualizing a decision boundary
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.12 – 可视化决策边界
- en: 'Luckily for us, we have data on which IP addresses the hackers used because
    we have been given labeled data to conduct our research, so we can use `seaborn`
    to actually see the separation:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们有黑客使用的IP地址数据，因为我们已经获得了标注数据来进行研究，所以我们可以使用`seaborn`来实际看到这种分离：
- en: '[PRE47]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Our intuition about there being two distinct clusters was dead-on. The middle
    area, however, was much trickier to determine. The blue (darker) points on the
    left do appear to be following a line upward, while the orange (lighter) points
    on the left are following a line to the orange cluster. By plotting the log of
    the attempts instead, we get a little more separation between our orange middle
    points and the blue points:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们关于存在两个明显聚类的直觉完全正确。然而，中间区域的判断则要复杂得多。左侧的蓝色（较深）点似乎呈向上排列，而左侧的橙色（较浅）点则跟随一条通向橙色聚类的线条。通过绘制尝试次数的对数，我们能更好地将橙色中间点和蓝色点分开：
- en: '![Figure 8.13 – Using labeled data to check our intuition'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.13 – 使用标注数据来验证我们的直觉'
- en: '](img/Figure_8.13_B16834.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.13_B16834.jpg)'
- en: Figure 8.13 – Using labeled data to check our intuition
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.13 – 使用标注数据来验证我们的直觉
- en: 'Remember, we can also use a box plot to check for possible outliers, which
    will be shown as points. Let''s see what successes and attempts look like per
    IP address:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们还可以使用箱型图来检查是否存在异常值，异常值会显示为点。让我们看看每个IP地址的成功与尝试分布情况：
- en: '[PRE48]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The points marked as outliers coincide with the points in the upper-right corner
    of the scatter plots we made:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 被标记为离群值的点与我们之前绘制的散点图右上角的点重合：
- en: '![Figure 8.14 – Checking for outliers'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.14 – 检查异常值'
- en: '](img/Figure_8.14_B16834.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.14_B16834.jpg)'
- en: Figure 8.14 – Checking for outliers
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.14 – 检查异常值
- en: Now that we have a good understanding of our data, we are ready to learn how
    to implement a few simple anomaly detection strategies.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对数据有了充分的了解，我们准备学习如何实现一些简单的异常检测策略。
- en: Implementing rule-based anomaly detection
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现基于规则的异常检测
- en: It's time to catch those hackers. After the EDA in the previous section, we
    have an idea of how we might go about this. In practice, this is much more difficult
    to do, as it involves many more dimensions, but we have simplified it here. **We
    want to find the IP addresses with excessive amounts of attempts accompanied by
    low success rates, and those attempting to log in with more unique usernames than
    we would deem normal (anomalies)**. To do this, we will employ threshold-based
    rules as our first foray into anomaly detection; then, in [*Chapter 11*](B16834_11_Final_SK_ePub.xhtml#_idTextAnchor237),
    *Machine Learning Anomaly Detection*, we will explore a few machine learning techniques
    as we revisit this scenario.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候抓住那些黑客了。在前一节的EDA（探索性数据分析）之后，我们已经对如何进行此操作有了一定的了解。实际上，这要困难得多，因为它涉及更多的维度，但我们在这里简化了处理过程。**我们希望找到那些尝试次数过多但成功率较低的IP地址，以及那些使用比我们认为正常的更多独特用户名进行登录尝试的IP地址（异常行为）**。为了实现这一点，我们将采用基于阈值的规则作为我们进行异常检测的第一步；接下来，在[*第11章*](B16834_11_Final_SK_ePub.xhtml#_idTextAnchor237)《机器学习异常检测》中，我们将探讨一些机器学习技术，并重新审视这一场景。
- en: 'Since we are interested in flagging IP addresses that are suspicious, we are
    going to arrange the data so that we have hourly aggregated data per IP address
    (if there was activity for that hour):'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们有兴趣标记可疑的IP地址，我们将安排数据，以便每个IP地址有每小时的聚合数据（如果该小时内有活动）：
- en: '[PRE49]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Tip
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: The `np.invert()` function is an easy way to flip Boolean values. It turns `True`
    to `False` and `False` to `True` along a NumPy array-like structure.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`np.invert()`函数是一个轻松翻转布尔值的方法。它将`True`转换为`False`，将`False`转换为`True`，适用于NumPy数组结构。'
- en: 'The aggregated data looks like this:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合后的数据如下所示：
- en: '![Figure 8.15 – Hourly aggregated data per IP address'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.15 – 每个IP地址的每小时聚合数据'
- en: '](img/Figure_8.15_B16834.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.15_B16834.jpg)'
- en: Figure 8.15 – Hourly aggregated data per IP address
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.15 – 每个IP地址的每小时聚合数据
- en: The simplest form of rule-based anomaly detection involves calculating a threshold
    value and checking to see whether the data is beyond the threshold. This could
    mean values falling below some lower bound threshold, or values exceeding some
    upper bound threshold. Since we are looking at login attempts, we are interested
    in values that are greater than normal. Therefore, we will be calculating the
    threshold for our upper bounds and comparing that to our data.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的基于规则的异常检测方法是计算阈值，并检查数据是否超出该阈值。这可能意味着值低于某个下限阈值，或超过某个上限阈值。由于我们关注的是登录尝试，我们对高于正常水平的值感兴趣。因此，我们将计算上限阈值，并将其与我们的数据进行比较。
- en: Percent difference
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 百分比差异
- en: Provided that we have an idea of what normal login attempt activity (minus the
    hackers) looks like on the site, we can flag values that deviate from this by
    a certain percentage. In order to calculate this baseline, we could take a few
    IP addresses at random with replacement for each hour, and average the number
    of login attempts they made. We are bootstrapping since we don't have much data
    (about 50 unique IP addresses to pick from for each of the 24 hours).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们对网站上正常的登录尝试活动（排除黑客的影响）有一定了解，我们可以通过某个百分比的偏差来标记那些与此偏离的值。为了计算这个基准，我们可以随机抽取一些IP地址（每小时重复抽取），并计算它们的平均登录尝试次数。由于数据量较少（每个小时大约有50个独特的IP地址可供选择），我们采用自助法（bootstrap）。
- en: 'To do this, we could write a function that takes in the aggregated dataframe
    we just made, along with the name of a statistic to calculate per column of the
    data to use as the starting point for the threshold:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们可以编写一个函数，该函数接受我们刚刚创建的聚合数据框，并传入每一列的数据统计名称作为计算阈值的起始点：
- en: '[PRE50]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Important note
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: '[PRE51]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Notice that we can get equally sized samples for all groups (hours, here) if
    we use `sample()` inside `apply()` after grouping by the column we want to sample
    with. This means that we are selecting 10 rows with replacement per hour for each
    column. We have to sample by hour here because, if we do simple random sampling,
    there is a good chance we won''t have a statistic for every hour. Let''s use `get_baselines()`
    to calculate the column baselines using the mean:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果我们在`apply()`内使用`sample()`，在按我们想要抽样的列分组后，我们可以为所有组（这里是小时）获得大小相等的样本。这意味着我们在每小时对每列进行有放回的抽样，选择10行。我们必须按小时进行抽样，因为如果进行简单的随机抽样，可能会没有每小时的统计数据。让我们使用`get_baselines()`通过均值计算列基准：
- en: '[PRE52]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Tip
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: If, instead, we wanted to perform stratified random sampling, we could replace
    `10` in the `get_baselines()` function with `x.shape[0] * pct`, where `pct` is
    the percentage we want to sample from each group.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想进行分层随机抽样，可以将`get_baselines()`函数中的`10`替换为`x.shape[0] * pct`，其中`pct`是我们希望从每个组中抽取的百分比。
- en: 'Each column has the mean per hour for the 10 IP addresses chosen randomly to
    estimate normal behavior. This technique, however, doesn''t guarantee that we
    won''t mix any of the hacker activity into our baseline calculations. For example,
    let''s take a look at the six hours with the highest baseline values for failure
    rate:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 每列都包含通过随机选择的10个IP地址估算正常行为的每小时均值。然而，这种方法并不能保证我们不会将黑客活动混入基准计算中。例如，我们来看一下故障率基准值最高的六个小时：
- en: '[PRE53]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We might find it difficult to flag any activity at hours **19**, **23**, or
    **14** with this baseline because the failure rate and unique usernames tried
    are both high:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会发现很难在**19**、**23**或**14**点钟时标记任何活动为异常，因为这些小时的故障率和尝试过的独特用户名都很高：
- en: '![Figure 8.16 – Hourly baselines using the mean'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.16 – 使用均值计算的每小时基准'
- en: '](img/Figure_8.16_B16834.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.16_B16834.jpg)'
- en: Figure 8.16 – Hourly baselines using the mean
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.16 – 使用均值计算的每小时基准
- en: 'To combat this issue, we could trim our summary statistics by making the top
    *x*% ineligible for use in our baseline calculation. Let''s remove values greater
    than the 95th percentile of data from each hour. First, we will write a function
    to trim rows from a given hour that have data above a given quantile:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 为了应对这个问题，我们可以通过让排名前* x *%的值在基准计算中无效来修剪我们的摘要统计信息。我们将从每个小时的数据中移除超过第95百分位的数据。首先，我们编写一个函数，用于修剪某个小时内超出给定分位数的行：
- en: '[PRE54]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Next, we will group the IP address data by hour and apply our trimming function.
    Since we will be using our bootstrapping function, we need to clean up some of
    the extra columns that will result from this operation, so we drop the `hour`
    column, reset the index, and then remove the grouping column and the old index:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将按小时对IP地址数据进行分组，并应用我们的修剪函数。由于我们将使用自举函数，因此需要清理一些由此操作产生的多余列，所以我们删除`hour`列，重置索引，然后移除分组列和旧的索引：
- en: '[PRE55]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Now, we can use the `get_baselines()` function to grab our baseline using the
    average with the trimmed data:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用`get_baselines()`函数，通过平均值和修剪后的数据来获取我们的基准：
- en: '[PRE56]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The trimmed baseline is now quite different from *Figure 8.16* at hours **19**,
    **23**, and **14**:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 经过修剪后的基准在**19**、**23**和**14**小时与*图 8.16*相比有了显著变化：
- en: '![Figure 8.17 – Trimmed hourly baselines using the mean'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.17 – 使用均值修剪后的每小时基准'
- en: '](img/Figure_8.17_B16834.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.17_B16834.jpg)'
- en: Figure 8.17 – Trimmed hourly baselines using the mean
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.17 – 使用均值修剪后的每小时基准
- en: 'Now that we have our baseline, let''s write a function that will do the heavy
    lifting of calculating the threshold from our baseline and the percentage difference
    per column, returning the IP addresses that have been flagged as hackers:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了基准，接下来我们来写一个函数，负责从基准和每列的百分比差异中计算阈值，并返回被标记为黑客的IP地址：
- en: '[PRE57]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The `pct_change_threshold()` function uses a series of chained operations to
    give us the flagged IP addresses:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`pct_change_threshold()`函数使用一系列链式操作来返回被标记的IP地址：'
- en: First, it joins the baselines to the hourly IP address logs on the `hour` column.
    Since all the baseline columns have the same names as the hourly IP address logs,
    and we don't want to join on them, we suffix their names with `'_baseline'`.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，它将基准与`hour`列上的每小时IP地址日志连接。由于所有基准列的名称与每小时IP地址日志相同，并且我们不希望根据这些名称进行连接，因此我们在列名后添加`'_baseline'`后缀。
- en: After that, all the data we need to check whether the thresholds were exceeded
    is in the same dataframe. We use `assign()` to make three new Boolean columns,
    indicating whether each of our conditions (too many users, too many attempts,
    and high failure rate) has been violated.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，所有需要检查是否超出阈值的数据都在同一个数据框中。我们使用`assign()`方法创建三个新的布尔列，表示我们每个条件（过多用户、过多尝试和高失败率）是否被违反。
- en: Then, we chain a call to the `query()` method, which lets us easily select rows
    where all of these Boolean columns are `True` (notice we don't need to explicitly
    say `<column> == True`).
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们链式调用`query()`方法，这样我们就可以轻松选择所有布尔列值为`True`的行（注意我们无需显式地写出`<column> == True`）。
- en: Lastly, we make sure to return just the IP addresses and to drop any duplicates
    in case the same IP address was flagged for multiple hours.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们确保只返回IP地址，并删除任何重复项，以防相同的IP地址在多个小时内被标记。
- en: 'In order to use this function, we need to pick a percentage difference from
    each of our baselines. By default, that will be 100% of the baseline, which, since
    it is the average, will flag way too many IP addresses. Instead, let''s get the
    IP addresses this flags with values 25% higher than the baseline for each criterion:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用这个函数，我们需要选择每个基线的百分比差异。默认情况下，这将是基线的100%，而基线作为平均值，可能会标记出过多的IP地址。因此，让我们选择将每个标准的IP地址提高25%的阈值：
- en: '[PRE58]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Tip
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: The percentages we use are in a dictionary, with the key being the column they
    are for and the value being the percentage itself. If the caller of the function
    doesn't provide these, we have default values of 100%, since we are using `get()`
    to select from the dictionary.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的百分比存储在字典中，字典的键是对应列名，值是百分比。如果函数调用者没有提供这些值，我们会使用默认的100%，因为我们使用`get()`方法从字典中选择。
- en: 'These rules flagged 73 IP addresses:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这些规则标记了73个IP地址：
- en: '[PRE59]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Important note
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: In practice, we probably wouldn't run this rule on the entries used to calculate
    the baselines because they influence the definition of the baseline with their
    behavior.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际操作中，我们可能不会对用于计算基线的条目运行此规则，因为它们的行为会影响基线的定义。
- en: Tukey fence
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Tukey fence
- en: 'As we discussed in [*Chapter 1*](B16834_01_Final_SK_ePub.xhtml#_idTextAnchor015),
    *Introduction to Data Analysis*, the mean is not robust to outliers. If we feel
    there are many outliers influencing our baselines, we could go back to the percent
    difference and try out the median or look into using a **Tukey fence**. Remember
    from previous chapters that the Tukey fence gets its bounds from the first and
    third quartiles and the **interquartile range** (**IQR**). Since we only care
    about exceeding the upper bound, this solves the issue with the mean, provided
    that outliers make up less than 25% of our data. We can use the following to calculate
    the upper bound:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[*第1章*](B16834_01_Final_SK_ePub.xhtml#_idTextAnchor015)《数据分析简介》中讨论的那样，均值对离群值并不稳健。如果我们觉得有很多离群值影响了我们的基线，我们可以返回到百分比差异，尝试使用中位数，或考虑使用**Tukey
    fence**。记住，在之前的章节中，我们提到Tukey fence的边界来自第一四分位数和第三四分位数，以及**四分位间距**（**IQR**）。因为我们只关心超出上限的值，这就解决了均值的问题，前提是离群值占数据量的比例小于25%。我们可以使用以下公式来计算上限：
- en: '![](img/Formula_08_005.jpg)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_08_005.jpg)'
- en: 'Our `get_baselines()` function will still help us, but we need to do some additional
    processing. We will write a function that will calculate the upper bound of the
    Tukey fence and let us test out various values for the multiplier (`k`). Notice
    that we also have the option to use percentages with the Tukey fence here:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`get_baselines()`函数仍然会帮助我们，但我们需要做一些额外的处理。我们将编写一个函数来计算Tukey fence的上限，并让我们测试不同的乘数（`k`）值。注意，我们在这里也可以选择使用Tukey
    fence的百分比：
- en: '[PRE60]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Let''s use the `tukey_fence_test()` function to grab the IP addresses that
    exceed the upper bound of the Tukey fence using an IQR multiplier of `3`:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`tukey_fence_test()`函数，利用`3`的IQR乘数，抓取超出Tukey fence上限的IP地址：
- en: '[PRE61]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'With this method, we flag 83 IP addresses:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，我们标记了83个IP地址：
- en: '[PRE62]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Important note
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: We used a multiplier of 3 here. However, depending on the application, we may
    see 1.5 used in order to be less restrictive. In reality, we can use any number;
    finding the best one may require some trial and error.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用了3的乘数。然而，根据应用场景，我们可能会看到使用1.5，以便更加宽松。实际上，我们可以使用任何数字；找到最佳值可能需要一些试错过程。
- en: Z-score
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Z得分
- en: Remember, from [*Chapter 1*](B16834_01_Final_SK_ePub.xhtml#_idTextAnchor015),
    *Introduction to Data Analysis*, that we can also calculate Z-scores and flag
    IP addresses a given number of standard deviations from the mean. The `pct_change_threshold()`
    function we wrote earlier won't help us as is, since we aren't just comparing
    with the baseline. Instead, we need to subtract the baseline for the mean from
    all the values and divide by the baseline for the standard deviation, so we must
    rework our approach.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在[*第1章*](B16834_01_Final_SK_ePub.xhtml#_idTextAnchor015)《数据分析导论》中，我们还可以计算Z分数，并标记距离均值一定标准差的IP地址。我们之前写的`pct_change_threshold()`函数在这种情况下不适用，因为我们不仅仅是在与基线进行比较。相反，我们需要从所有值中减去基线的均值，并除以基线的标准差，因此我们必须重新设计我们的方法。
- en: 'Let''s write a new function, `z_score_test()`, to perform our Z-score tests
    using any number of standard deviations above the mean as a cutoff. First, we
    will use the `get_baselines()` function to calculate the baseline standard deviations
    by hour with the trimmed data. Then, we join the standard deviations and means
    together, adding the suffixes. This allows us to adapt the logic of `pct_change_threshold()`
    for this task:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个新函数`z_score_test()`，通过任何标准差数量的均值上方作为截断值来执行Z分数测试。首先，我们将使用`get_baselines()`函数，通过修剪后的数据计算每小时的基线标准差。然后，我们将标准差和均值合并，添加后缀。这样，我们就可以将`pct_change_threshold()`的逻辑应用于这个任务：
- en: '[PRE63]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Let''s call our function with a cutoff of three or more standard deviations
    from the mean:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用一个截断值为距离均值三倍标准差或更多的函数：
- en: '[PRE64]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'With this method, we flag 62 IP addresses:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此方法，我们标记了62个IP地址：
- en: '[PRE65]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Important note
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: In practice, the cutoff value for the Z-score is also a parameter we will want
    to tune.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际应用中，Z分数的截断值也是我们需要调整的一个参数。
- en: Evaluating performance
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能评估
- en: So, we now have a series of IP addresses for each set of rules, but we would
    like to know how well each method did (assuming we can actually check). In this
    case, we have the attacker IP addresses for our research, so we can see how many
    each method got right—this is not so trivial in practice; instead, we could mark
    things that we have discovered to be malicious in the past and look out for similar
    behavior in the future.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在有一系列的IP地址，分别对应于每组规则，但我们希望了解每种方法的效果如何（假设我们可以实际检查）。在这种情况下，我们拥有用于研究的攻击者IP地址，因此可以查看每种方法标记了多少个正确的地址——这在实践中并不简单；相反，我们可以标记过去发现的恶意地址，并在未来关注类似的行为。
- en: 'This is a classification problem with two classes; we want to classify each
    IP address as either a valid user or a nefarious one. This leaves us with four
    possible outcomes that we can visualize using a **confusion matrix**:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个包含两类的分类问题；我们希望将每个IP地址分类为有效用户或恶意用户。这使得我们有四种可能的结果，可以通过**混淆矩阵**来可视化：
- en: '![Figure 8.18 – The confusion matrix'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.18 – 混淆矩阵'
- en: '](img/Figure_8.18_B16834.jpg)'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.18_B16834.jpg)'
- en: Figure 8.18 – The confusion matrix
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.18 – 混淆矩阵
- en: 'In this application, these outcomes mean the following:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在此应用中，这些结果的含义如下：
- en: '**True Positive (TP)**: Our method flagged it as malicious, and it was.'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**真正例 (TP)**：我们的方法标记它为恶意的，且它确实是恶意的。'
- en: '**True Negative (TN)**: Our method didn''t flag it, and it wasn''t malicious.'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**真负例 (TN)**：我们的方法没有标记它，而且它不是恶意的。'
- en: '**False Positive (FP)**: Our method flagged it, but it wasn''t malicious.'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**假正例 (FP)**：我们的方法标记它为恶意的，但它其实不是恶意的。'
- en: '**False Negative (FN)**: Our method didn''t flag it, but it was malicious.'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**假负例 (FN)**：我们的方法没有标记它，但它实际上是恶意的。'
- en: 'True positives and true negatives mean our method did well, but false positives
    and false negatives are possible areas for improvement (bear in mind that this
    will never be perfect). Let''s now write a function that will help determine where
    each method stands:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 真正例和真负例表明我们的方法效果不错，但假正例和假负例是可能需要改进的地方（请记住，这永远不会是完美的）。现在让我们编写一个函数，帮助我们确定每种方法的表现：
- en: '[PRE66]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Before we begin calculating metrics, let''s make a partial function so we don''t
    have to keep passing in the series of attacker IP addresses (`attacks.source_ip`)
    and IP addresses in the logs (`pivot.index`). Remember, a partial function allows
    us to fix the values for certain arguments and call the function later:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始计算指标之前，先写一个部分函数，这样我们就不需要不断传递攻击者IP地址（`attacks.source_ip`）和日志中的IP地址（`pivot.index`）。记住，部分函数允许我们固定某些参数的值，然后稍后调用该函数：
- en: '[PRE67]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Now, let''s use this to calculate some metrics to measure our performance.
    One common metric is the **false positive rate** (**FPR**), which tells us the
    **false alarm rate**. It is calculated by taking the ratio of false positives
    to everything that was actually negative:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用这个来计算一些指标以衡量我们的表现。一个常见的指标是**假阳性率**（**FPR**），它告诉我们**假警报率**。它是通过将假阳性与实际为负的所有情况的比例计算得出的：
- en: '![](img/Formula_08_001.jpg)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_08_001.jpg)'
- en: 'The **false discovery rate** (**FDR**), which tells us the percentage of positives
    that are incorrect, is another way of looking at false alarms:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '**假发现率**（**FDR**）是另一种看待假警报的方式，它告诉我们不正确的正例的百分比：'
- en: '![](img/Formula_08_002.jpg)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_08_002.jpg)'
- en: 'Let''s see what the FPR and FDR are for our percent difference from the mean
    approach:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看我们使用与均值差异百分比的方法计算的假阳性率（FPR）和假发现率（FDR）：
- en: '[PRE68]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Another metric of interest is the **false negative rate** (**FNR**), which
    tells us what we fail to detect (the **miss rate**). It is calculated by taking
    the ratio of false negatives to everything that was actually positive:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个感兴趣的指标是**假阴性率**（**FNR**），它告诉我们我们未能检测到的内容（**漏检率**）。它通过将假阴性与实际为正的所有情况的比例计算得出：
- en: '![](img/Formula_08_003.jpg)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_08_003.jpg)'
- en: 'An alternative way of looking at false negatives is the **false omission rate**
    (**FOR**), which tells us the percentage of cases we incorrectly mark as negatives:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 观察假阴性的一种替代方式是**假遗漏率**（**FOR**），它告诉我们错误标记为负例的案例百分比：
- en: '![](img/Formula_08_004.jpg)'
  id: totrans-317
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_08_004.jpg)'
- en: 'Our percent difference from the mean method has no false negatives, so both
    FNR and FOR are zero:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的均值差异百分比方法没有假阴性，因此FNR和FOR都是零：
- en: '[PRE69]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: There is typically a trade-off here—do we want to catch as many hackers as possible,
    and risk flagging valid users (by focusing on FNR/FOR), or do we want to keep
    from inconveniencing our valid users and risk missing hacker activity (by minimizing
    FPR/FDR)? These questions are tough to answer and will depend on the domain, as
    the cost of false positives is not necessarily equal to (or even close in scale
    to) the cost of false negatives.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 这里通常存在一个权衡——我们是否想尽可能捕捉到更多的黑客活动，并冒着标记有效用户的风险（通过关注FNR/FOR），还是我们希望避免给有效用户带来不便，冒着错过黑客活动的风险（通过最小化FPR/FDR）？这些问题很难回答，将取决于具体领域，因为假阳性的代价不一定等于（甚至远低于）假阴性的代价。
- en: Tip
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: We will discuss additional metrics that can be used to evaluate our performance
    in [*Chapter 9*](B16834_09_Final_SK_ePub.xhtml#_idTextAnchor188), *Getting Started
    with Machine Learning in Python*.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[*第9章*](B16834_09_Final_SK_ePub.xhtml#_idTextAnchor188)中讨论更多可以用于评估我们性能的指标，*《Python中的机器学习入门》*。
- en: 'Let''s now write a function to handle all these calculations for us:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们编写一个函数来处理所有这些计算：
- en: '[PRE70]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'We can now use the results from the `evaluate()` function to calculate our
    metrics. For the percentage difference from the mean, we get the following output:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用`evaluate()`函数的结果来计算我们的指标。对于均值差异百分比的方法，我们得到以下输出：
- en: '[PRE71]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'It looks like our trio of criteria did quite well. If we were concerned with
    the hacker IP addresses being chosen when we calculated the baselines, but didn''t
    want to trim, we could have run this with the median instead of the mean:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来我们的三个标准表现得相当不错。如果我们担心在计算基准时会选择黑客IP地址，但又不想修剪数据，我们本可以使用中位数代替均值来运行：
- en: '[PRE72]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Using the median, we achieve similar performance to the mean. In this case,
    however, we didn''t need to trim the data beforehand. This is because the median
    is robust to outliers, meaning that picking a single hacker IP address in a given
    hour doesn''t affect that hour''s baseline as it would the mean:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 使用中位数时，我们达到了与均值相似的表现。然而，在这种情况下，我们不需要提前修剪数据。这是因为中位数对离群值具有鲁棒性，意味着选择某个小时内的单个黑客IP地址并不会像均值那样影响该小时的基准：
- en: '[PRE73]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'To compare each of the methods discussed, we can use dictionary comprehensions
    to populate a `DataFrame` object with the performance metrics:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 为了比较讨论过的每种方法，我们可以使用字典推导式来填充一个`DataFrame`对象，包含性能指标：
- en: '[PRE74]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Tip
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: The `scores()` function returns a tuple of `(tp, fp, tn, fn)`, but the `classification_stats()`
    function expects four arguments. However, since `scores()` returns them in the
    same order that `classification_stats()` expects them, we can use `*` to unpack
    the tuple and send the values as four positional arguments.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '`scores()`函数返回一个元组`(tp, fp, tn, fn)`，但`classification_stats()`函数期望四个参数。然而，由于`score()`以`classification_stats()`期望的顺序返回这些值，我们可以使用`*`来解包元组并将这些值作为四个位置参数传递。'
- en: 'The mean is affected by outliers, but once we trimmed the data, it became a
    viable method. We didn''t need to trim the data to work with the median; the usefulness
    of the median hinges on the data containing fewer than 50% outliers. The Tukey
    fence takes this a step further by using the third quartile and assuming that
    fewer than 25% of the data points are outliers. The Z-score method is also affected
    by outliers because it uses the mean; however, with the trimmed data, we were
    able to achieve good performance with a modest cutoff of three:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 均值受异常值的影响，但一旦我们对数据进行修剪，它就成了一个可行的方法。我们不需要修剪数据就能处理中位数；中位数的有效性取决于数据中异常值的比例低于50%。Tukey围栏法进一步通过使用第三四分位数，并假设数据中异常值的比例低于25%，将此方法做得更为严格。Z-score方法也会受到异常值的影响，因为它使用均值；然而，经过修剪的数据使我们能够通过适当的三倍标准差阈值实现良好的性能：
- en: '![Figure 8.19 – Comparing performance'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.19 – 性能比较'
- en: '](img/Figure_8.19_B16834.jpg)'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.19_B16834.jpg)'
- en: Figure 8.19 – Comparing performance
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.19 – 性能比较
- en: Ultimately, which method we use in practice will depend on how costly it is
    to have a false positive versus a false negative—is it worse to raise the alarm
    when nothing is wrong, or to be silent when something is? In this case, we would
    err on the side of minimizing false negatives since we don't want to miss anything.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，我们在实际应用中使用哪种方法将取决于假阳性与假阴性带来的成本——是当什么都没有问题时发出警报更糟，还是当有问题时保持沉默更糟？在这种情况下，我们倾向于尽量减少假阴性，因为我们不想错过任何重要信息。
- en: Important note
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Another common use case for anomaly detection is in quality or process control
    in industrial settings, such as monitoring factory equipment performance and output.
    Process control uses threshold-based and pattern-based rules to determine whether
    systems are out of control. These can be used for things such as determining when
    the distribution of the underlying data has changed, which could be a precursor
    for later problems. **Western Electric rules** and **Nelson rules** are common
    ones. References for both can be found in the *Further reading* section at the
    end of this chapter.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 异常检测的另一个常见应用是工业环境中的质量或过程控制，例如监控工厂设备的性能和产量。过程控制使用基于阈值和基于模式的规则来判断系统是否失控。这些方法可以用于判断基础数据的分布是否发生了变化，这可能是后续问题的前兆。**西电规则**和**纳尔逊规则**是常见的规则。两者的参考资料可以在本章末的*进一步阅读*部分找到。
- en: Summary
  id: totrans-342
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In our second application chapter, we learned how to simulate events in Python
    and got additional exposure to writing packages. We also saw how to write Python
    scripts that can be run from the command line, which we used to run our simulation
    of the login attempt data. Then, we performed some EDA on the simulated data to
    see whether we could figure out what would make hacker activity easy to spot.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第二个应用章节中，我们学习了如何在Python中模拟事件，并额外接触了编写包的技巧。我们还学习了如何编写可以从命令行运行的Python脚本，这些脚本被用来运行我们的登录尝试数据模拟。接着，我们对模拟数据进行了探索性数据分析（EDA），以查看是否能够找出哪些因素使得黑客活动容易被识别。
- en: This led us to zero in on the number of distinct usernames attempting to authenticate
    per IP address per hour, as well as the number of attempts and failure rates.
    Using these metrics, we were able to create a scatter plot, which appeared to
    show two distinct groups of points, along with some other points connecting the
    two groups; naturally, these represented the groups of valid users and the nefarious
    ones, with some of the hackers not being as obvious as others.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 这让我们聚焦于每小时每个IP地址尝试验证的不同用户名数量，以及尝试次数和失败率。利用这些指标，我们能够绘制出一个散点图，图中显示了两个不同的点群，另外还有一些连接两个点群的点；显然，这些点代表了有效用户和恶意用户群体，其中一些黑客并不像其他人那样显眼。
- en: 'Finally, we set about creating rules that would flag the hacker IP addresses
    for their suspicious activity. First, we used `pandas` to reshape our data into
    hourly aggregates per IP address. Then, we wrote functions to trim values greater
    than the 95th percentile and calculate baselines for a given statistic per hour,
    which we used to create our rules based on percentage difference from the mean
    and median, exceeding the upper bound of a Tukey fence, and using Z-scores. We
    saw that building good rules depended on carefully tuning our parameters: the
    percentage for the differences from the mean and median, the multiplier for the
    Tukey fence, and the threshold for the Z-score. To determine which of the rules
    was performing the best, we used the miss rate, false omission rate, false discovery
    rate, and the false alarm rate.'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们开始制定规则，以标记出因可疑活动而被怀疑为黑客的IP地址。首先，我们使用`pandas`将数据按小时汇总成每个IP地址的数据。然后，我们编写函数，修剪出大于95百分位的数据，并计算每小时给定统计数据的基线，基于与均值和中位数的百分比差异、超出Tukey围栏上限以及使用Z分数来创建规则。我们发现，制定有效规则取决于仔细调整参数：均值和中位数差异的百分比、Tukey围栏的乘数以及Z分数的阈值。为了确定哪个规则表现最好，我们使用了漏报率、假漏报率、假发现率和误报率。
- en: In the next two chapters, we will introduce machine learning in Python using
    `scikit-learn`, and in [*Chapter 11*](B16834_11_Final_SK_ePub.xhtml#_idTextAnchor237),
    *Machine Learning Anomaly Detection*, we will revisit this scenario for anomaly
    detection using machine learning.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的两章中，我们将介绍使用`scikit-learn`进行Python中的机器学习，并在[*第11章*](B16834_11_Final_SK_ePub.xhtml#_idTextAnchor237)《机器学习异常检测》中，我们将回顾这个场景，通过机器学习进行异常检测。
- en: Exercises
  id: totrans-347
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'Complete the following exercises to practice the concepts covered in this chapter:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 完成以下练习以巩固本章所涵盖的概念：
- en: Run the simulation for December 2018 into new log files without making the user
    base again. Be sure to run `python3 simulate.py -h` to review the command-line
    arguments. Set the seed to `27`. This data will be used for the remaining exercises.
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对2018年12月的数据进行模拟，并将结果保存到新的日志文件中，而无需重新创建用户基础。确保运行`python3 simulate.py -h`来查看命令行参数。将种子值设置为`27`。这些数据将用于剩余的练习。
- en: Find the number of unique usernames, attempts, successes, and failures, as well
    as the success/failure rates per IP address, using the data simulated from exercise
    *1*.
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找出每个IP地址的唯一用户名数、尝试次数、成功次数、失败次数，以及成功/失败率，使用的是从练习*1*中模拟的数据。
- en: Create two subplots with failures versus attempts on the left, and failure rate
    versus distinct usernames on the right. Draw decision boundaries for the resulting
    plots. Be sure to color each data point by whether or not it is a hacker IP address.
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两个子图，左侧是失败次数与尝试次数的关系，右侧是失败率与唯一用户名数的关系。为结果图绘制决策边界。确保按是否为黑客IP地址为每个数据点着色。
- en: Build a rule-based criteria using the percentage difference from the median
    that flags an IP address if the failures and attempts are both five times their
    respective medians, or if the distinct usernames count is five times its median.
    Be sure to use a one-hour window. Remember to use the `get_baselines()` function
    to calculate the metrics needed for the baselines.
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建一个基于中位数百分比差异的规则，标记一个IP地址，如果其失败次数和尝试次数都为各自中位数的五倍，或者唯一用户名数为中位数的五倍。确保使用一个小时的时间窗口。记得使用`get_baselines()`函数计算基线所需的指标。
- en: Calculate metrics to evaluate how well these rules performed using the `evaluate()`
    and `classification_stats()` functions from this chapter.
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用本章中的`evaluate()`和`classification_stats()`函数计算指标，以评估这些规则的执行效果。
- en: Further reading
  id: totrans-354
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Check out the following resources for more information on the topics covered
    in this chapter:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下资源，获取更多关于本章所讨论主题的信息：
- en: '*A Gentle Introduction to the Bootstrap Method*: [https://machinelearningmastery.com/a-gentle-introduction-to-the-bootstrap-method/](https://machinelearningmastery.com/a-gentle-introduction-to-the-bootstrap-method/)'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*引导法温和入门*: [https://machinelearningmastery.com/a-gentle-introduction-to-the-bootstrap-method/](https://machinelearningmastery.com/a-gentle-introduction-to-the-bootstrap-method/)'
- en: '*An Introduction to the Bootstrap Method*: [https://towardsdatascience.com/an-introduction-to-the-bootstrap-method-58bcb51b4d60](https://towardsdatascience.com/an-introduction-to-the-bootstrap-method-58bcb51b4d60)'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*引导法简介*: [https://towardsdatascience.com/an-introduction-to-the-bootstrap-method-58bcb51b4d60](https://towardsdatascience.com/an-introduction-to-the-bootstrap-method-58bcb51b4d60)'
- en: '*Adding Salt to Hashing: A Better Way to Store Passwords*: [https://auth0.com/blog/adding-salt-to-hashing-a-better-way-to-store-passwords/](https://auth0.com/blog/adding-salt-to-hashing-a-better-way-to-store-passwords/)'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*向哈希算法中添加盐：存储密码的更好方式*：[https://auth0.com/blog/adding-salt-to-hashing-a-better-way-to-store-passwords/](https://auth0.com/blog/adding-salt-to-hashing-a-better-way-to-store-passwords/)'
- en: '*Brute-Force Attack*: [https://en.wikipedia.org/wiki/Brute-force_attack](https://en.wikipedia.org/wiki/Brute-force_attack)'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*暴力破解攻击*：[https://en.wikipedia.org/wiki/Brute-force_attack](https://en.wikipedia.org/wiki/Brute-force_attack)'
- en: '*Classification Accuracy Is Not Enough: More Performance Measures You Can Use*:
    [https://machinelearningmastery.com/classification-accuracy-is-not-enough-more-performance-measures-you-can-use/](https://machinelearningmastery.com/classification-accuracy-is-not-enough-more-performance-measures-you-can-use/)'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*分类准确率不足：更多可以使用的性能衡量标准*：[https://machinelearningmastery.com/classification-accuracy-is-not-enough-more-performance-measures-you-can-use/](https://machinelearningmastery.com/classification-accuracy-is-not-enough-more-performance-measures-you-can-use/)'
- en: '*Dictionary Attack*: [https://en.wikipedia.org/wiki/Dictionary_attack](https://en.wikipedia.org/wiki/Dictionary_attack)'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*字典攻击*：[https://en.wikipedia.org/wiki/Dictionary_attack](https://en.wikipedia.org/wiki/Dictionary_attack)'
- en: '*Nelson Rules*: [https://en.wikipedia.org/wiki/Nelson_rules](https://en.wikipedia.org/wiki/Nelson_rules)'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*尼尔森规则*：[https://en.wikipedia.org/wiki/Nelson_rules](https://en.wikipedia.org/wiki/Nelson_rules)'
- en: '*Offline Password Cracking: The Attack and the Best Defense*: [https://www.alpinesecurity.com/blog/offline-password-cracking-the-attack-and-the-best-defense-against-it](https://www.alpinesecurity.com/blog/offline-password-cracking-the-attack-and-the-best-defense-against-it)'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*离线密码破解：攻击与最佳防御*：[https://www.alpinesecurity.com/blog/offline-password-cracking-the-attack-and-the-best-defense-against-it](https://www.alpinesecurity.com/blog/offline-password-cracking-the-attack-and-the-best-defense-against-it)'
- en: '*Poisson Point Process*: [https://en.wikipedia.org/wiki/Poisson_point_process](https://en.wikipedia.org/wiki/Poisson_point_process)'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*泊松点过程*：[https://en.wikipedia.org/wiki/Poisson_point_process](https://en.wikipedia.org/wiki/Poisson_point_process)'
- en: '*Precision and Recall*: [https://en.wikipedia.org/wiki/Precision_and_recall](https://en.wikipedia.org/wiki/Precision_and_recall)'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*精准度与召回率*：[https://en.wikipedia.org/wiki/Precision_and_recall](https://en.wikipedia.org/wiki/Precision_and_recall)'
- en: '*Probability Distributions in Python*: [https://www.datacamp.com/community/tutorials/probability-distributions-python](https://www.datacamp.com/community/tutorials/probability-distributions-python)'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Python中的概率分布*：[https://www.datacamp.com/community/tutorials/probability-distributions-python](https://www.datacamp.com/community/tutorials/probability-distributions-python)'
- en: '*Rainbow Tables: Your Password''s Worst Nightmare*: [https://www.lifewire.com/rainbow-tables-your-passwords-worst-nightmare-2487288](https://www.lifewire.com/rainbow-tables-your-passwords-worst-nightmare-2487288)'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*彩虹表：你密码的噩梦*：[https://www.lifewire.com/rainbow-tables-your-passwords-worst-nightmare-2487288](https://www.lifewire.com/rainbow-tables-your-passwords-worst-nightmare-2487288)'
- en: '*RFC 1597 (Address Allocation for Private Internets)*: [http://www.faqs.org/rfcs/rfc1597.html](http://www.faqs.org/rfcs/rfc1597.html)'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*RFC 1597（私有互联网的地址分配）*：[http://www.faqs.org/rfcs/rfc1597.html](http://www.faqs.org/rfcs/rfc1597.html)'
- en: '*Sampling Techniques*: [https://towardsdatascience.com/sampling-techniques-a4e34111d808](https://towardsdatascience.com/sampling-techniques-a4e34111d808)'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*抽样技术*：[https://towardsdatascience.com/sampling-techniques-a4e34111d808](https://towardsdatascience.com/sampling-techniques-a4e34111d808)'
- en: '*Trimmed Estimator*: [https://en.wikipedia.org/wiki/Trimmed_estimator](https://en.wikipedia.org/wiki/Trimmed_estimator)'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*修剪估计量*：[https://en.wikipedia.org/wiki/Trimmed_estimator](https://en.wikipedia.org/wiki/Trimmed_estimator)'
- en: '*Western Electric rules*: [https://en.wikipedia.org/wiki/Western_Electric_rules](https://en.wikipedia.org/wiki/Western_Electric_rules)'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*西电规则*：[https://en.wikipedia.org/wiki/Western_Electric_rules](https://en.wikipedia.org/wiki/Western_Electric_rules)'
