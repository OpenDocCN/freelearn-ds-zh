- en: 'def display_map(self):'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 'def display_map(self):'
- en: '"""Opens and displays a map image file.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '"""打开并显示地图图像文件。'
- en: ':param image_file: Path to the image.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: ':param image_file: 图像的路径。'
- en: '"""'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: image = cv2.imread(self.output_image)
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: image = cv2.imread(self.output_image)
- en: cv2.imshow('image', image)
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: cv2.imshow('image', image)
- en: cv2.waitKey(0)
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: cv2.waitKey(0)
- en: cv2.destroyAllWindows()
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: cv2.destroyAllWindows()
- en: This function now uses the output_image property to display the map and takes
    no arguments apart from the class instance (self) when called.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数现在使用 output_image 属性来显示地图，调用时除了类实例（self）外不接受任何参数。
- en: Next, let’s work on the create_map function.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们来处理 create_map 函数。
- en: '8\. Copy the create_map function from the map_functions.py file and make the
    following changes to the class:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 8. 从 map_functions.py 文件中复制 create_map 函数，并对类进行以下修改：
- en: coding=utf-8
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: coding=utf-8
- en: import cv2
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: import cv2
- en: import mapnik
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: import mapnik
- en: 'class MapMakerApp(object):'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 'class MapMakerApp(object):'
- en: def __init__(self, output_image="map.png",
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: def __init__(self, output_image="map.png",
- en: style_file="map_maker/styles.xml",
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: style_file="map_maker/styles.xml",
- en: 'map_size=(800, 600)):'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 'map_size=(800, 600)):'
- en: '"""Application class.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '"""应用程序类。'
- en: ':param output_image: Path to the image output of the map.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: ':param output_image: 地图图像输出的路径。'
- en: ':param style_file: Mapnik XML file containing only the style for the map.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: ':param style_file: 仅包含地图样式的 Mapnik XML 文件。'
- en: ':param map_size: Size of the map in pixels.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: ':param map_size: 地图像素大小。'
- en: '"""'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: self.output_image = output_image
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: self.output_image = output_image
- en: self.style_file = style_file
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: self.style_file = style_file
- en: self.map_size = map_size
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: self.map_size = map_size
- en: 'def display_map(self):'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 'def display_map(self):'
- en: '"""Opens and displays a map image file."""'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '"""打开并显示地图图像文件。”'
- en: image = cv2.imread(self.output_image)
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: image = cv2.imread(self.output_image)
- en: cv2.imshow('image', image)
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: cv2.imshow('image', image)
- en: cv2.waitKey(0)
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: cv2.waitKey(0)
- en: cv2.destroyAllWindows()
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: cv2.destroyAllWindows()
- en: 'def create_map(self):'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 'def create_map(self):'
- en: '"""Creates a map and writes it to a file."""'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '"""创建地图并将其写入文件。”'
- en: map = mapnik.Map(*self.map_size)
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: map = mapnik.Map(*self.map_size)
- en: mapnik.load_map(map, self.style_file)
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: mapnik.load_map(map, self.style_file)
- en: layers = map.layers
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: layers = map.layers
- en: map.zoom_all()
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: map.zoom_all()
- en: mapnik.render_to_file(map, self.output_image)
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: mapnik.render_to_file(map, self.output_image)
- en: As we did with display_map, now the create_map function takes no arguments (except
    for self) and all parameters come from the instance attributes, the ones that
    were added to the __init__ method. We also improved the default values for those
    arguments.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在 display_map 中所做的那样，现在 create_map 函数不接受任何参数（除了 self），所有参数都来自实例属性，这些属性被添加到
    __init__ 方法中。我们还改进了这些参数的默认值。
- en: All the layer and data source definitions were removed from create_map because
    in the next steps we will plug in the PythonDatasource that we created earlier.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 从 create_map 中移除了所有层和数据源的定义，因为在接下来的步骤中我们将插入我们之前创建的 PythonDatasource。
- en: '**Using PythonDatasource**'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用 PythonDatasource**'
- en: 'To use this type of data source and implement the ability to display any number
    of data sources on the map, we will make our app class take control of the organization
    of the layers and the data that they use, always following the premise that the
    application should have a high level of abstraction:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用此类数据源并实现能够在地图上显示任意数量的数据源的能力，我们将使我们的应用程序类控制层和数据组织的结构，始终遵循应用程序应具有高度抽象的原则：
- en: '1\. Include this import at the beginning of the file:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 在文件开头包含此导入：
- en: from map_maker.my_datasource import MapDatasource
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: from map_maker.my_datasource import MapDatasource
- en: '2\. Modify the class __init__ method and create an add_layer method, as follows:
    class MapMakerApp(object):'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '2. 修改类 __init__ 方法并创建一个 add_layer 方法，如下所示：class MapMakerApp(object):'
- en: def __init__(self, output_image="map.png",
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: def __init__(self, output_image="map.png",
- en: style_file="map_maker/styles.xml",
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: style_file="map_maker/styles.xml",
- en: 'map_size=(800, 600)):'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 'map_size=(800, 600)):'
- en: '"""Application class.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '"""应用程序类。'
- en: ':param output_image: Path to the image output of the map.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: ':param output_image: 地图图像输出的路径。'
- en: ':param style_file: Mapnik XML file containing only the style for the map.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: ':param style_file: 仅包含地图样式的 Mapnik XML 文件。'
- en: ':param map_size: Size of the map in pixels.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: ':param map_size: 地图像素大小。'
- en: '"""'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: self.output_image = output_image
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: self.output_image = output_image
- en: self.style_file = style_file
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: self.style_file = style_file
- en: self.map_size = map_size
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: self.map_size = map_size
- en: self._layers = {}
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: self._layers = {}
- en: def display_map(self):...
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: def display_map(self):...
- en: def create_map(self):...
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: def create_map(self):...
- en: 'def add_layer(self, geo_data, name, style=''style1''):'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 'def add_layer(self, geo_data, name, style=''style1''):'
- en: '"""Add data to the map to be displayed in a layer with a given style.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '"""向地图添加数据，以便在具有给定样式的层中显示。'
- en: ':param geo_data: a BaseGeoCollection subclass instance.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: ':param geo_data: 一个 BaseGeoCollection 子类实例。'
- en: '"""'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: data source = mapnik.Python(factory='MapDatasource',
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: data source = mapnik.Python(factory='MapDatasource',
- en: data=geo_data)
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: data=geo_data)
- en: 'layer = {"data source": data source,'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 'layer = {"data source": data source,'
- en: '"data": geo_data,'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '"data": geo_data,'
- en: '"style": style}'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '"style": style}'
- en: self._layers[name] = layer
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: self._layers[name] = layer
- en: What we did here is use a private attribute (_layers) to keep track of the layers
    that we will use by their names. The add_layer method is responsible for instantiating
    the MapDatasource class and passing to it the data.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的是使用一个私有属性 (_layers) 来跟踪我们将使用的层，通过它们的名称。add_layer 方法负责实例化 MapDatasource
    类，并将数据传递给它。
- en: The data that we will use here is a subclass of BaseGeoCollection that we used
    in the previous chapters. With this, we will manipulate the map using only high-level
    objects, and also get all their functionality for free.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用的数据是 BaseGeoCollection 的子类，我们在前面的章节中使用过。有了这个，我们将仅使用高级对象来操作地图，并且还可以免费获得它们的所有功能。
- en: As we said before, *Python Datasource does not work on Windows*, so we need
    to
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所说，*Python Datasource 在 Windows 上不工作*，因此我们需要
- en: create a workaround to make things work despite the operating system. What we
    are going to do is save the data to a temporary file and then use Mapnik’s GeoJSON
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个解决方案来使事情在操作系统不同的情况下也能工作。我们将要做的是将数据保存到临时文件中，然后使用 Mapnik 的 GeoJSON
- en: plugin to create a data source.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: plugin to create a data source.
- en: '3\. Add these imports to the beginning of the file:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 3\. 在文件开头添加以下导入：
- en: coding=utf-8
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: coding=utf-8
- en: '**import platform**'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**导入 platform**'
- en: '**import tempfile**'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**导入 tempfile**'
- en: '**from models import BoundaryCollection, PointCollection**'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**从 models 导入 BoundaryCollection, PointCollection**'
- en: import cv2
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: import cv2
- en: import mapnik
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: import mapnik
- en: 4\. Now let’s create a folder to hold our temporary files. Create a new folder
    named temp inside your Chapter5 folder.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 4\. 现在让我们创建一个文件夹来存放我们的临时文件。在您的 Chapter5 文件夹内创建一个名为 temp 的新文件夹。
- en: '5\. Modify the add_layer method to include the workaround:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 5\. 修改 add_layer 方法以包含解决方案：
- en: '#...'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '#...'
- en: 'def add_layer(self, geo_data, name, style=''style1''):'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 'def add_layer(self, geo_data, name, style=''style1''):'
- en: '"""Add data to the map to be displayed in a layer with a given style.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '"""向地图添加数据，以给定样式在图层中显示。'
- en: ':param geo_data: a BaseGeoCollection subclass instance.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: ':param geo_data: 一个 BaseGeoCollection 子类实例。'
- en: '"""'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: 'if platform.system() == "Windows":'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 'if platform.system() == "Windows":'
- en: print("Windows system")
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: print("Windows system")
- en: temp_file, filename = tempfile.mkstemp(dir="temp") print temp_file, filename
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: temp_file, filename = tempfile.mkstemp(dir="temp") print temp_file, filename
- en: geo_data.export_geojson(filename)
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: geo_data.export_geojson(filename)
- en: data source = mapnik.GeoJSON(file=filename)
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: data source = mapnik.GeoJSON(file=filename)
- en: 'else:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: data source = mapnik.Python(factory='MapDatasource',
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: data source = mapnik.Python(factory='MapDatasource',
- en: data=geo_data)
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: data=geo_data)
- en: 'layer = {"data source": data source,'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 'layer = {"data source": data source,'
- en: '"data": geo_data,'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '"data": geo_data,'
- en: '"style": style}'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '"style": style}'
- en: self._layers[name] = layer
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: self._layers[name] = layer
- en: Here, we used platform.system() to detect whether the operating system is Windows.
    If so, instead of creating a Python DataSource, it creates a temporary file and
    exports geo_data to it. Then we use the GeoJSON plugin to open that file, creating
    a DataSource.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用 platform.system() 来检测操作系统是否为 Windows。如果是，则不是创建 Python DataSource，而是创建一个临时文件，并将
    geo_data 导出至其中。然后我们使用 GeoJSON 插件打开该文件，创建 DataSource。
- en: Now that the workaround is complete, we need to go back to the MapDatasource
    definition and make it accept the data that we are passing to it.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在解决方案完成，我们需要回到 MapDatasource 的定义，并使其能够接受我们传递给它的数据。
- en: '6\. In the my_datasource.py file, include the following __init__ method in
    the MapDatasource class:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 6\. 在 my_datasource.py 文件中，在 MapDatasource 类中包含以下 __init__ 方法：
- en: 'class MapDatasource(mapnik.PythonDatasource):'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 'class MapDatasource(mapnik.PythonDatasource):'
- en: '"""Implementation of Mapinik''s PythonDatasource."""'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '"""Mapnik 的 PythonDatasource 实现。”'
- en: 'def __init__(self, data):'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, data):'
- en: super(MapDatasource, self).__init__(envelope, geometry_type, data_type)
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: super(MapDatasource, self).__init__(envelope, geometry_type, data_type)
- en: self.data = data
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: self.data = data
- en: 'def features(self, query=None):'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 'def features(self, query=None):'
- en: raise NotImplementedError
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: raise NotImplementedError
- en: Our subclass of PythonDatasource now takes one obligatory data argument. Since
    we are increasing the level of abstraction, we will make the MapDatasource class
    define all the other arguments automatically by inspecting the data it receives;
    with this change, we won’t need to worry about the geometry type or data type.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对 PythonDatasource 的子类现在接受一个必选的数据参数。由于我们正在提高抽象级别，我们将使 MapDatasource 类通过检查它接收到的数据来自动定义所有其他参数；通过这个更改，我们不需要担心几何类型或数据类型。
- en: '7\. Make another change to the __init__ method:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 7\. 对 __init__ 方法进行另一个修改：
- en: 'class MapDatasource(mapnik.PythonDatasource):'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 'class MapDatasource(mapnik.PythonDatasource):'
- en: '"""Implementation of Mapinik''s PythonDatasource."""'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '"""Mapinik 的 PythonDatasource 的实现。”'
- en: 'def __init__(self, data):'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, data):'
- en: data_type = mapnik.DataType.vector
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: data_type = mapnik.DataType.vector
- en: 'if isinstance(data, PointCollection):'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 'if isinstance(data, PointCollection):'
- en: geometry_type = mapnik.GeometryType.Point
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: geometry_type = mapnik.GeometryType.Point
- en: 'elif isinstance(data, BoundaryCollection):'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif isinstance(data, BoundaryCollection):'
- en: geometry_type = mapnik.GeometryType.Polygon
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: geometry_type = mapnik.GeometryType.Polygon
- en: 'else:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: raise TypeError
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: raise TypeError
- en: super(MapDatasource, self).__init__(
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: super(MapDatasource, self).__init__(
- en: envelope=None, geometry_type=geometry_type,
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: envelope=None, geometry_type=geometry_type,
- en: data_type=data_type)
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: data_type=data_type)
- en: self.data = data
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: self.data = data
- en: 'def features(self, query=None):'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 'def features(self, query=None):'
- en: raise NotImplementedError
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: raise NotImplementedError
- en: Here, isinstance() checks which type is data, and for each of the possible types
    it defines the corresponding geometry_type to be passed to the parent __init__
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，isinstance() 检查数据类型，并为每种可能的类型定义了相应的 geometry_type，以便传递给父 __init__
- en: method.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: method.
- en: 'For now, we only have one data type: the vector. Anyway, we will make this
    definition explicit (data_type = mapnik.DataType.vector) because in the next chapter,
    the raster type will be introduced.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们只有一个数据类型：矢量。无论如何，我们将明确此定义（data_type = mapnik.DataType.vector），因为在下一章中，将介绍栅格类型。
- en: Before we go any further, let’s test the app as it is.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，让我们测试一下当前的应用程序。
- en: '8\. Now edit the if __name__ == ''__main__'': block at the end of the file:
    if __name__ == ''__main__'':'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '8. 现在编辑文件末尾的 if __name__ == ''__main__'' 块：if __name__ == ''__main__'':'
- en: world_borders = BoundaryCollection(
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: world_borders = BoundaryCollection(
- en: '"../data/world_borders_simple.shp")'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '"../data/world_borders_simple.shp")'
- en: map_app = MapMakerApp()
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: map_app = MapMakerApp()
- en: map_app.add_layer(world_borders, 'world')
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: map_app.add_layer(world_borders, 'world')
- en: map_app.create_map()
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: map_app.create_map()
- en: map_app.display_map()
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: map_app.display_map()
- en: '**Note**'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: Note how Mapnik is completely abstracted; we now only deal with the high-level
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 Mapnik 是如何完全抽象的；我们现在只处理由我们的模型和应用程序提供的高级功能。
- en: functionality provided by our models and the app.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 功能性，以及我们的模型和应用程序。
- en: '9\. Run the code; you should see an empty map and an output like this in the
    console: File imported: ../data/world_borders_simple.shp'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '9. 运行代码；您应该看到一个空地图和在控制台中的输出：File imported: ../data/world_borders_simple.shp'
- en: Windows system
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 系统
- en: 'File exported: \geopy\Chapter5\temp\tmpfqv9ch'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 'File exported: \geopy\Chapter5\temp\tmpfqv9ch'
- en: 'The map is empty because two points are still missing: the features method,
    which is the glue between our geo data and the Mapnik data source, and making
    the create_map function use the layers that we have defined.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 地图是空的，因为还缺少两个点：features 方法，它是我们地理数据和 Mapnik 数据源之间的粘合剂，以及使 create_map 函数使用我们已定义的图层。
- en: '10\. Let’s start with the create_map method. Change its code so it can iterate
    over our layers and add them to the map:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 10. 让我们从 create_map 方法开始。修改其代码，使其能够遍历我们的图层并将它们添加到地图中：
- en: '#...'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '#...'
- en: 'def create_map(self):'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 'def create_map(self):'
- en: '"""Creates a map and writes it to a file."""'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '"""创建地图并将其写入文件。”'
- en: map = mapnik.Map(*self.map_size)
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: map = mapnik.Map(*self.map_size)
- en: mapnik.load_map(map, self.style_file)
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: mapnik.load_map(map, self.style_file)
- en: layers = map.layers
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: layers = map.layers
- en: 'for name, layer in self._layers.iteritems():'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 'for name, layer in self._layers.iteritems():'
- en: new_layer = mapnik.Layer(name)
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: new_layer = mapnik.Layer(name)
- en: new_layer.datasource = layer["data source"]
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: new_layer.datasource = layer["data source"]
- en: new_layer.stylers.append(layer['style'])
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: new_layer.stylers.append(layer['style'])
- en: layers.append(new_layer)
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: layers.append(new_layer)
- en: map.zoom_all()
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: map.zoom_all()
- en: mapnik.render_to_file(map, self.output_image)
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: mapnik.render_to_file(map, self.output_image)
- en: '11\. Now edit styles.xml in order to remove the extent restriction from it:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 11. 现在编辑 styles.xml，以从中移除范围限制：
- en: <Map background-color="white">
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: <Map background-color="white">
- en: <Style name="style1">
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: <Style name="style1">
- en: <Rule>
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: <Rule>
- en: <PolygonSymbolizer fill="#f2eff9" />
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: <PolygonSymbolizer fill="#f2eff9" />
- en: <LineSymbolizer stroke="red" stroke-width="1.0" smooth="0.5" />
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: <LineSymbolizer stroke="red" stroke-width="1.0" smooth="0.5" />
- en: <TextSymbolizer face-name="DejaVu Sans Book" size="10"
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: <TextSymbolizer face-name="DejaVu Sans Book" size="10"
- en: fill="black" halo-fill= "white"
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: fill="black" halo-fill= "white"
- en: halo-radius="1" placement="interior"
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: halo-radius="1" placement="interior"
- en: allow-overlap="false">[NAME]
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: allow-overlap="false">[NAME]
- en: </TextSymbolizer>
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: </TextSymbolizer>
- en: </Rule>
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: </Rule>
- en: </Style>
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: </Style>
- en: <Style name="style2">
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: <Style name="style2">
- en: <Rule>
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: <Rule>
- en: <PointSymbolizer file="marker.svg" transform="scale(0.3)"/>
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: <PointSymbolizer file="marker.svg" transform="scale(0.3)"/>
- en: </Rule>
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: </Rule>
- en: </Style>
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: </Style>
- en: </Map>
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: </Map>
- en: '12\. Now run the code again and look at the output. If you are using Windows,
    you should see a rendered map. If you are using Linux you should get an exception:
    Traceback (most recent call last):'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '12. 现在再次运行代码并查看输出。如果您使用的是 Windows，您应该看到一个渲染的地图。如果您使用的是 Linux，您应该得到一个异常：Traceback
    (most recent call last):'
- en: File … in <module>
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 … 在 <module>
- en: raise NotImplementedError
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: raise NotImplementedError
- en: NotImplementedError
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: NotImplementedError
- en: Process finished with exit code 1
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 进程以退出代码1结束
- en: If you got this exception (in Linux), it is because everything went fine and
    Mapnik called our unimplemented features method.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您遇到这个异常（在Linux上），那么是因为一切正常，Mapnik调用了我们的未实现的功能方法。
- en: So now let’s implement this method.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在让我们实现这个方法。
- en: '13\. Go to the my_datasource.py file and edit our class:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 13. 打开my_datasource.py文件并编辑我们的类：
- en: 'class MapDatasource(mapnik.PythonDatasource):'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 'class MapDatasource(mapnik.PythonDatasource):'
- en: '"""Implementation of Mapinik''s PythonDatasource."""'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '"""Mapinik的PythonDatasource实现。”'
- en: 'def __init__(self, data):'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, data):'
- en: data_type = mapnik.DataType.Vector
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: data_type = mapnik.DataType.Vector
- en: 'if isinstance(data, PointCollection):'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 'if isinstance(data, PointCollection):'
- en: geometry_type = mapnik.GeometryType.Point
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: geometry_type = mapnik.GeometryType.Point
- en: 'elif isinstance(data, BoundaryCollection):'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif isinstance(data, BoundaryCollection):'
- en: geometry_type = mapnik.GeometryType.Polygon
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: geometry_type = mapnik.GeometryType.Polygon
- en: 'else:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: raise TypeError
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: raise TypeError
- en: super(MapDatasource, self).__init__(
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: super(MapDatasource, self).__init__(
- en: envelope=None, geometry_type=geometry_type,
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: envelope=None, geometry_type=geometry_type,
- en: data_type=data_type)
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: data_type=data_type)
- en: self.data = data
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: self.data = data
- en: 'def features(self, query=None):'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 'def features(self, query=None):'
- en: keys = ['name',]
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: keys = ['name',]
- en: features = []
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: features = []
- en: 'for item in self.data.data:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 'for item in self.data.data:'
- en: 'features.append([item.geom.wkb, {''name'': item.name}])'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 'features.append([item.geom.wkb, {''name'': item.name}])'
- en: 'return mapnik.PythonDatasource.wkb_features(keys, features) 14\. Run the code
    again; now you should see the rendered map in the output:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: return mapnik.PythonDatasource.wkb_features(keys, features) 14. 再次运行代码；现在您应该会在输出中看到渲染的地图：
- en: '![Image 38](img/index-272_1.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![Image 38](img/index-272_1.jpg)'
- en: '![Image 39](img/index-273_1.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![Image 39](img/index-273_1.jpg)'
- en: '**Using the app with filtering**'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用带有过滤器的应用程序**'
- en: Since the BaseGeoCollection class has filtering capabilities that were implemented
    before, it’s possible to filter the data before passing it to the map.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 由于BaseGeoCollection类具有之前实现的过滤功能，因此可以在将其传递给地图之前过滤数据。
- en: 'Let’s try some examples:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一些示例：
- en: '1\. In the map_maker_app.py file, edit the if __name__ == ''__main__'': block:
    if __name__ == ''__main__'':'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '1. 在map_maker_app.py文件中，编辑if __name__ == ''__main__''块：if __name__ == ''__main__'':'
- en: world_borders = BoundaryCollection(
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: world_borders = BoundaryCollection(
- en: '"../data/world_borders_simple.shp")'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '"../data/world_borders_simple.shp")'
- en: my_country = world_borders.filter('name', 'Brazil')
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: my_country = world_borders.filter('name', 'Brazil')
- en: map_app = MapMakerApp()
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: map_app = MapMakerApp()
- en: map_app.add_layer(my_country, 'countries')
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: map_app.add_layer(my_country, 'countries')
- en: map_app.create_map()
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: map_app.create_map()
- en: map_app.display_map()
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: map_app.display_map()
- en: Here, we are using the filter function of the BaseGeoCollection class to filter
    the countries by name; feel free to try to filter by your country.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用BaseGeoCollection类的过滤器功能按名称过滤国家；您可以自由尝试按您的国家进行过滤。
- en: '2\. Run the code and you should see a map containing only one country (zoom
    should be active), as in the following screenshot:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 运行代码，您应该会看到一个只包含一个国家的地图（应该激活缩放），如下面的截图所示：
- en: '3\. Now try combining filters to show more than one country:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 现在尝试组合过滤器以显示多个国家：
- en: '![Image 40](img/index-274_1.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![Image 40](img/index-274_1.jpg)'
- en: 'if __name__ == ''__main__'':'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == ''__main__'':'
- en: world_borders = BoundaryCollection(
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: world_borders = BoundaryCollection(
- en: '"../data/world_borders_simple.shp")'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '"../data/world_borders_simple.shp")'
- en: countries = world_borders.filter('name', 'China') +\
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: countries = world_borders.filter('name', 'China') +\
- en: world_borders.filter('name', 'India') +\
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: world_borders.filter('name', 'India') +\
- en: world_borders.filter('name', 'Japan')
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: world_borders.filter('name', 'Japan')
- en: map_app = MapMakerApp()
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: map_app = MapMakerApp()
- en: map_app.add_layer(countries, 'countries')
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: map_app.add_layer(countries, 'countries')
- en: map_app.create_map()
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: map_app.create_map()
- en: map_app.display_map()
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: map_app.display_map()
- en: 4\. Run the code again and see the results.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 4. 再次运行代码并查看结果。
- en: '**Summary**'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '**总结**'
- en: In this chapter we saw how Mapnik works and how maps are defined and styled
    using both Python and XML. Using Mapnik’s Python API, it was possible to define
    the map in XML and then alter it in Python, showing great flexibility for all
    kinds of needs.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了Mapnik是如何工作的，以及如何使用Python和XML定义和样式化地图。使用Mapnik的Python API，我们可以在XML中定义地图，然后在Python中修改它，这显示了对于各种需求的高度灵活性。
- en: As the app was structured, Mapnik was hidden behind high-level functionalities
    that enabled us to use the geographic data objects that we created before, allowing
    the application to filter the data to be displayed in the map.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 由于应用程序的结构，Mapnik隐藏在高级功能之后，这些功能使我们能够使用之前创建的地理数据对象，允许应用程序过滤地图中要显示的数据。
- en: In the next chapter, we will meet raster data for the first time; we will see
    how it works and display it in our maps.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将首次遇到栅格数据；我们将看到它是如何工作的，并在我们的地图中显示它。
- en: '**Chapter 6\. Working with Remote Sensing**'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '**第6章\. 使用遥感**'
- en: '**Images**'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '**图像**'
- en: In this chapter, we will start working with images—images that may come from
    a variety of sensors carried by satellites, drones, airplanes, and so on. These
    types of images, the ones collected from remote sensing devices, are images that
    contain pixels representing a spectral response from a given geographic region.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将开始处理图像——这些图像可能来自卫星、无人机、飞机等携带的各种传感器。这些类型的图像，即从遥感设备收集的图像，是包含像素的图像，这些像素代表了一个给定地理区域的光谱响应。
- en: Besides just adding images to a map, it is important to prepare the images to
    be presented on the map. You may need to combine, cut, change the resolution,
    change values, and perform many other transformations in order to produce a visually
    appealing map or valuable information.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 除了将图像添加到地图上之外，准备图像在地图上展示也很重要。你可能需要合并、裁剪、改变分辨率、改变值以及执行许多其他转换，以便制作出视觉上吸引人的地图或有价值的信息。
- en: To perform these transformations on the images, we will go through a process
    of deduction that will result in a versatile and powerful software structure.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 为了对图像执行这些转换，我们将通过一个演绎过程，最终得到一个灵活且强大的软件结构。
- en: 'The topics covered here are:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这里涉及的主题包括：
- en: Understanding how the images are represented
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 理解图像是如何表示的
- en: The relation of the images with the real world
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 图像与真实世界的关系
- en: Combining, cropping, and adjusting the values of the images Creating shaded
    relief maps from the elevation data
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 合并、裁剪和调整图像的值 从高程数据创建阴影高程图
- en: How to execute a sequence of processing steps
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如何执行一系列处理步骤
- en: '![Image 41](img/index-279_1.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![图像41](img/index-279_1.jpg)'
- en: '**Understanding how images are**'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '**理解图像是如何表示的**'
- en: '**represented**'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '**表示**'
- en: 'In order to understand what images are in terms of computer representation
    and the data they contain, we are going to start with some examples. The first
    thing to do is to organize your project to follow this chapter’s code as follows:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解图像在计算机表示及其包含的数据方面的含义，我们将从一些示例开始。首先要做的事情是组织你的项目，按照本章的代码如下：
- en: 1\. As before, inside your geopy project, make a copy of your Chapter5 folder
    and rename it to Chapter6\.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. 如前所述，在你的geopy项目中，复制你的Chapter5文件夹并将其重命名为Chapter6。
- en: 2\. Inside Chapter6, navigate to the experiments folder and create a new file
    inside it named image_experiments.py. Open it for editing.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. 在第6章中，导航到实验文件夹，并在其中创建一个名为image_experiments.py的新文件。打开它进行编辑。
- en: We will start by inspecting a small sample image that has a structure similar
    to a large satellite image.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先检查一个小样本图像，其结构类似于大型卫星图像。
- en: Nothing fancy, you will see four squares of different colors. But if we take
    a step further and add a grid to it, we can see a little bit more information.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 没有什么花哨的，你会看到四个不同颜色的正方形。但如果我们再进一步，给它加上网格，我们就能看到更多一点的信息。
- en: '![Image 42](img/index-280_1.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![图像42](img/index-280_1.jpg)'
- en: The image was divided into 16 squares of equal size. Each one of these squares
    is a so-called **pixel**. A pixel is the smallest portion of information that
    an image (that is, raster data) contains. While talking about geoprocessing, the
    image as a whole comprehends a space in the real world and each pixel is a fraction
    of that space.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 该图像被分成16个大小相等的正方形。这些正方形中的每一个都是一个所谓的**像素**。像素是图像（即，栅格数据）包含的最小信息部分。在谈论地理处理时，整个图像在真实世界中代表一个空间，而每个像素是那个空间的一部分。
- en: When we added the sample image to the map in the beginning of the chapter, we
    manually defined the extent of this image (that is, its bounding box). This information
    told Mapnik how the coordinates in the image relates to the real world coordinates.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章开头将样本图像添加到地图时，我们手动定义了该图像的范围（即其边界框）。这些信息告诉Mapnik图像中的坐标如何与真实世界的坐标相关联。
- en: So far, we have seen that our sample image has 16 pixels with a shape of 4 x
    4\. But how this image or any other raster data relates to a real world space
    depends on the information that may or may not be stored in the data itself.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到我们的样本图像有16个像素，形状为4 x 4。但是，这幅图像或任何其他栅格数据如何与真实世界空间相关联，取决于数据中可能或可能不存储的信息。
- en: The first information that states the relation is where the image is in the
    world. Images and raster data normally have their point of origin in the top left
    corner. If we assign a coordinate to the point of origin, we will be able to place
    the image on the world.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个表示关系的信息是图像在世界中的位置。图像和栅格数据通常以左上角为原点。如果我们给原点分配一个坐标，我们就能将图像放置在世界中。
- en: 'Secondly, we need information on the area that this image covers. And there
    are three ways this information can appear:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们需要有关此图像覆盖区域的信息。这种信息可以通过以下三种方式出现：
- en: The size of the pixels of the image
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 图像像素的大小
- en: The size of the image
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 图像的大小
- en: The coordinates of the bounding box of the image
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 图像边界框的坐标
- en: '![Image 43](img/index-281_1.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![Image 43](img/index-281_1.jpg)'
- en: 'This information is related by the following equations:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 此信息与以下方程相关：
- en: x_pixel_size = width / columns
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: x_pixel_size = width / columns
- en: y_pixel_size = height / lines
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: y_pixel_size = height / lines
- en: width = xmax – xmin
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: width = xmax – xmin
- en: height = ymax – ymin
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: height = ymax – ymin
- en: '**Opening images with OpenCV**'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用 OpenCV 打开图像**'
- en: 'For a better understanding, we will open the sample image with OpenCV and inspect
    its contents as follows:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解，我们将使用 OpenCV 打开示例图像并检查其内容如下：
- en: '1\. In your image_expriments.py file, type the following code: def open_raster_file(image):'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '1\. 在你的 image_expriments.py 文件中，输入以下代码：def open_raster_file(image):'
- en: '"""Opens a raster file.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '"""打开栅格文件。'
- en: ':param image: Path of the raster file or np array.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: ':param image: 栅格文件的路径或 np 数组。'
- en: '"""'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: image = cv2.imread(image)
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: image = cv2.imread(image)
- en: return image
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: return image
- en: 'if __name__ == ''__main__'':'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == ''__main__'':'
- en: image = open_raster_file('../../data/sample_image.tiff')
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: image = open_raster_file('../../data/sample_image.tiff')
- en: print(image)
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: print(image)
- en: print(type(image))
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: print(type(image))
- en: print(image.shape)
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: print(image.shape)
- en: 2\. Run the code. Since it’s the first time you have run this file, press *Alt*
    + *Shift* + *F10*
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. 运行代码。由于这是你第一次运行此文件，请按 *Alt* + *Shift* + *F10*
- en: 'and choose image_experiments from the list. You should see the following output:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 并从列表中选择 image_experiments。你应该看到以下输出：
- en: '[[[ 0 0 255]'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '[[[ 0 0 255]'
- en: '[ 0 0 255]'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '[ 0 0 255]'
- en: '[ 0 255 0]'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '[ 0 255 0]'
- en: '[ 0 255 0]]'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '[ 0 255 0]]'
- en: '[[ 0 0 255]'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '[[ 0 0 255]'
- en: '[ 0 0 255]'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '[ 0 0 255]'
- en: '[ 0 255 0]'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '[ 0 255 0]'
- en: '[ 0 255 0]]'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '[ 0 255 0]]'
- en: '[[255 0 0]'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '[[255 0 0]'
- en: '[255 0 0]'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '[255 0 0]'
- en: '[100 100 100]'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '[100 100 100]'
- en: '[100 100 100]]'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '[100 100 100]]'
- en: '[[255 0 0]'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '[[255 0 0]'
- en: '[255 0 0]'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '[255 0 0]'
- en: '[100 100 100]'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '[100 100 100]'
- en: '[100 100 100]]]'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '[100 100 100]]]'
- en: <type 'numpy.ndarray'>
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: <type 'numpy.ndarray'>
- en: (4, 4, 3)
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: (4, 4, 3)
- en: Process finished with exit code 0
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: Process finished with exit code 0
- en: The expression print(type(image)) prints the type of the object that is stored
    in the image variable. As you can see, it’s a NumPy array with a shape of 4 x
    4 x 3\. OpenCV
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式 print(type(image)) 打印存储在 image 变量中的对象的类型。如你所见，它是一个形状为 4 x 4 x 3 的 NumPy
    数组。OpenCV
- en: opens the image and put its data inside an array, although for now, it is a
    little bit hard to visualize how the data is organized. The array contains the
    color information for each
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 打开图像并将其数据放入数组中，尽管现在还很难可视化数据的组织方式。该数组包含每个
- en: pixel on the image.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 图像上的像素。
- en: 'For better visualization, I’m going to reorganize the print output for you:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好的可视化，我将为你重新组织打印输出：
- en: '[[[ 0 0 255] [ 0 0 255] [ 0 255 0] [ 0 255 0]]'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '[[[ 0 0 255] [ 0 0 255] [ 0 255 0] [ 0 255 0]]'
- en: '[[ 0 0 255] [ 0 0 255] [ 0 255 0] [ 0 255 0]]'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '[[ 0 0 255] [ 0 0 255] [ 0 255 0] [ 0 255 0]]'
- en: '[[255 0 0] [255 0 0] [100 100 100] [100 100 100]]'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '[[255 0 0] [255 0 0] [100 100 100] [100 100 100]]'
- en: '[[255 0 0] [255 0 0] [100 100 100] [100 100 100]]]'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '[[255 0 0] [255 0 0] [100 100 100] [100 100 100]]]'
- en: Now the shape of the array makes more sense. Notice that we have four *lines*
    and each line has four *columns* exactly as it is seen in the image. By its turn,
    each item has a set of three numbers that represents the values for the blue,
    green, and red channels.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 现在数组的形状更有意义了。注意，我们有四条*行*，每行正好有四个*列*，正如我们在图像中看到的那样。每个项目都有一组三个数字，代表蓝色、绿色和红色通道的值。
- en: '**Tip**'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**'
- en: Remember that when you import a colored image with OpenCV, the order of the
    channels will be BGR (blue, green, and red).
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，当你使用 OpenCV 导入彩色图像时，通道的顺序将是 BGR（蓝色、绿色和红色）。
- en: 'For example, take the first pixel in the top left corner. It’s all red as we
    see in the image: Blue Green Red'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以左上角的第一像素为例。它全部是红色，正如我们在图像中看到的那样：蓝 绿 红
- en: '[ 0 0 255]'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '[ 0 0 255]'
- en: So, the first and the most important implication of the images being imported
    as NumPy arrays is that they behave like arrays and have all the functions and
    methods that any NumPy array has, opening the possibility of using the full power
    of NumPy while working with raster data.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，将图像作为NumPy数组导入的第一个且最重要的含义是，它们的行为类似于数组，并具有任何NumPy数组都有的所有函数和方法，这为在处理栅格数据时使用NumPy的全部功能打开了可能性。
- en: '![Image 44](img/index-284_1.jpg)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
  zh: '![Image 44](img/index-284_1.jpg)'
- en: '**Knowing numerical types**'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '**了解数值类型**'
- en: 'Each pixel in the previous topic has three channels: blue, green, and red.
    Each one has a value ranging from 0 to 255 (256 possible values). The combination
    of these channels result in a visible color. This range of values is not random;
    256 is the number of combinations that is possible to achieve with a single **byte**.'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个主题中，每个像素都有三个通道：蓝色、绿色和红色。每个通道的值范围从0到255（256个可能的值）。这些通道的组合产生一个可见的颜色。这个值范围不是随机的；256是使用单个**字节**可以实现的组合数量。
- en: A byte is the smallest portion of data that a computer can store and retrieve
    from the memory. It’s composed of 8 bits of zeros or ones.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 字节是计算机可以存储和从内存中检索的最小数据部分。它由8位零或一组成。
- en: This is important to us because the computer uses its memory to store the image
    and it will reserve a given space to store the value for each channel for each
    pixel. We must be sure that the space reserved is adequate for the data we want
    to store.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 这对我们来说很重要，因为计算机使用其内存来存储图像，并且将为每个像素的每个通道保留一定空间来存储值。我们必须确保保留的空间足以存储我们想要存储的数据。
- en: Let’s make an abstraction. Think that you have 1 liter (1,000 ml) of water and
    you want to store it. If you choose a 250 ml cup to store this water, the excess
    will spill out. If you choose a water truck with 10,000 liter capacity, you can
    store the water, but it will be a huge waste of space. So, you may choose a 3
    liter bucket that would be sufficient to store the water. It’s not big as a truck
    and you will have some extra space if you want to store a little bit more water.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进行一个抽象。假设你有1升（1000毫升）的水，你想存储它。如果你选择一个250毫升的杯子来存储这水，多余的部分会溢出来。如果你选择一个容量为10000升的水罐车，你可以存储水，但会浪费很多空间。所以，你可能选择一个3升的桶，这样就可以足够存储水了。它不像卡车那么大，如果你想存储一点更多的水，你还会有些多余的空间。
- en: In computing, things work similarly. You need to choose the size of the container
    before you put things in it. In the previous example, OpenCV made this choice
    for us. You will see a number of instances in the future where the programs we
    use will help us in these choices. But a clear understanding on how this works
    is very important because if the water spills out (that is, overflows), you will
    end up with unexpected behavior in your program. Or, if you choose a too large
    recipient, you may run out of computer memory.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机中，事情的工作方式类似。在将东西放入容器之前，你需要选择容器的大小。在之前的例子中，OpenCV为我们做出了这个选择。你将在未来的许多实例中看到，我们使用的程序将帮助我们做出这些选择。但是，对如何工作的清晰理解非常重要，因为如果水溢出来（即溢出），你的程序将出现意外的行为。或者，如果你选择一个太大的容器，你可能会耗尽计算机内存。
- en: 'The needs for value storage may vary in the aspects of:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 值存储的需求可能在以下方面有所不同：
- en: Only positive or positive and negative numbers
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 只能是正数或正负数
- en: Integers or fractions
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 整数或分数
- en: Small or large numbers
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 小数或大数
- en: Complex numbers
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 复数
- en: 'The available options and their sizes may vary with the computer architecture
    and software. For a common 64-bit desktop, NumPy will give you these possible
    numerical types:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的选项及其大小可能因计算机架构和软件而异。对于常见的64位桌面，NumPy将为你提供这些可能的数值类型：
- en: 'bool: Boolean (True or False) stored as a byte'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: bool：布尔值（True或False），以字节形式存储
- en: 'int8: Byte (-128 to 127)'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: int8：字节（-128到127）
- en: 'int16: Integer (-32768 to 32767)'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: int16：整数（-32768到32767）
- en: 'int32: Integer (-2147483648 to 2147483647) int64: Integer (-9223372036854775808
    to 9223372036854775807) uint8: Unsigned integer (0 to 255)'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: int32：整数（-2147483648到2147483647）int64：整数（-9223372036854775808到9223372036854775807）uint8：无符号整数（0到255）
- en: 'uint16: Unsigned integer (0 to 65535)'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: uint16：无符号整数（0到65535）
- en: 'uint32: Unsigned integer (0 to 4294967295)'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: uint32：无符号整数（0到4294967295）
- en: 'uint64: Unsigned integer (0 to 18446744073709551615)'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: uint64：无符号整数（0到18446744073709551615）
- en: 'float16: Half precision float: sign bit, 5 bits exponent, 10 bits mantissa
    float32: Single precision float: sign bit, 8 bits exponent, 23 bits mantissa float64:
    Double precision float: sign bit, 11 bits exponent, 52 bits mantissa complex64:
    Complex number represented by two 32-bit floats (real and imaginary components)'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 'float16: 半精度浮点数：符号位，5位指数，10位尾数'
- en: 'complex128: Complex number represented by two 64-bit floats (real and imaginary
    components)'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 'complex128: 由两个64位浮点数（实部和虚部）表示的复数'
- en: 'So, we may expect that our sample image has the type uint8\. Let’s check whether
    it’s true:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可能预期我们的样本图像的类型是uint8。让我们检查它是否正确：
- en: '1\. Edit the if __name__ == ''__main__'': block:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 编辑if __name__ == '__main__':块：
- en: 'if __name__ == ''__main__'':'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == ''__main__'':'
- en: image = open_raster_file('../../data/sample_image.tiff')
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: image = open_raster_file('../../data/sample_image.tiff')
- en: print(type(image))
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: print(type(image))
- en: print(image.dtype)
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: print(image.dtype)
- en: '2\. Run the code again. You should see an output matching our expectations:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 再次运行代码。你应该看到符合我们预期的输出：
- en: <type 'numpy.ndarray'>
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: <type 'numpy.ndarray'>
- en: uint8
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: uint8
- en: Process finished with exit code 0
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 处理完成，退出代码为0
- en: '**Processing remote sensing images and**'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '**处理遥感图像和**'
- en: '**data**'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据**'
- en: Satellite images come in a different format and serve different purposes. These
    images can be used to visualize features on Earth using real colors or they may
    be used to identify a variety of characteristics using parts of the spectrum invisible
    to the human eye.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 卫星图像以不同的格式出现，服务于不同的目的。这些图像可以用来使用真实颜色可视化地球上的特征，或者用来通过人眼不可见的频谱部分来识别各种特征。
- en: As we saw, our sample image had three channels (blue, green, and red) that were
    combined in a single file to compose a real color image. Different from the sample
    image, most satellite data comes with each channel separated into a file for each
    one of them.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，我们的样本图像有三个通道（蓝色、绿色和红色），它们组合在一个文件中，以组成一个真实色彩图像。与样本图像不同，大多数卫星数据将每个通道分别存储在一个文件中。
- en: These channels are called **bands** and comprise of a range of the electromagnetic
    spectrum visible or not to the human eye.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 这些通道被称为 **波段**，并包含可见或不可见于人眼的电磁频谱范围。
- en: In the following examples, we are going to use the **digital elevation models**
    (**DEM**) generated with the data obtained by the **Advanced Spaceborne Thermal
    Emission and** **Reflection Radiometer** (**ASTER**).
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将使用由 **Advanced Spaceborne Thermal Emission and Reflection Radiometer**
    (**ASTER**) 获取的数据生成的 **数字高程模型** (**DEM**)。
- en: These DEM have a resolution of approximately 90 m and the values are stored
    in the 16
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 这些DEM的分辨率大约为90米，值存储在16位
- en: bits signed integers representing the elevation in meters.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 表示以米为单位的高的有符号整数。
- en: 'The dataset we are going to use is included in the data folder and is from
    a Brazilian city called *Poços de Caldas*. This city is inside a giant extinct
    volcano crater, a feature we hope to see during data processing. For didactic
    reasons and in order to cover a big region, four images will be used:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要使用的数据集包含在数据文件夹中，并来自一个名为 *Poços de Caldas* 的巴西城市。这座城市位于一个巨大的已灭绝火山口内，这是我们希望在数据处理过程中看到的一个特征。出于教学目的和为了覆盖一个大区域，我们将使用四张图片：
- en: '**Note**'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: You can obtain more digital elevation models at [http://earthexplorer.usgs.gov/.](http://earthexplorer.usgs.gov/)
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [http://earthexplorer.usgs.gov/](http://earthexplorer.usgs.gov/) 获取更多数字高程模型。
- en: 1\. If want to download and use your own DEM, you need to extract the downloaded
    ZIP
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 如果想下载并使用自己的DEM，需要提取下载的ZIP文件
- en: file. Notice that each ZIP archive has two images. The one ending with _dem
    is the actual elevation data. The one ending with _num contains the quality assessment
    information. Take a look at the included README.pdf file for more information.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 文件。注意，每个ZIP存档包含两张图片。以_dem结尾的是实际的高程数据。以_num结尾的包含质量评估信息。查看包含的README.pdf文件获取更多信息。
- en: 2\. Move or copy all the images to the data folder of your Chapter 6 code.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 将所有图片移动或复制到第6章代码的数据文件夹中。
- en: 'Each image represents a tile of 1 degree. The information on which tile the
    image covers is encoded in the name of the file, as seen in the following image:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 每张图片代表一个1度的瓦片。图片覆盖的瓦片信息编码在文件名中，如下面的图片所示：
- en: '![Image 45](img/index-288_1.jpg)'
  id: totrans-368
  prefs: []
  type: TYPE_IMG
  zh: '![Image 45](img/index-288_1.jpg)'
- en: '**Mosaicking images**'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '**图像镶嵌**'
- en: Mapnik has the ability to read tiled data from the disk using the raster data
    source. But we are not going to use it, because the process of patching images
    together is very important and is worth learning.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: Mapnik具有从磁盘读取瓦片数据的栅格数据源的能力。但我们不会使用它，因为将图像拼接在一起的过程非常重要，值得学习。
- en: 'The next code will open the images, combine them, and save a single combined
    image in the disk. This process (with varying levels of complexity) is called
    **mosaicking**: 1\. Still in the image_experiments.py file, add a new function
    after the open_raster_file function:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码将打开图像，将它们组合，并将单个组合图像保存到磁盘。这个过程（具有不同复杂程度）称为**拼贴**：1. 仍然在image_experiments.py文件中，在open_raster_file函数之后添加一个新函数：
- en: 'def combine_images(input_images):'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 'def combine_images(input_images):'
- en: '"""Combine images in a mosaic.'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '"""将图像组合成拼贴。'
- en: ':param input_images: Path to the input images.'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: ':param input_images: 输入图像的路径。'
- en: '"""'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: images = []
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: images = []
- en: 'for item in input_images:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 'for item in input_images:'
- en: images.append(open_raster_file(item))
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: images.append(open_raster_file(item))
- en: print images
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: print images
- en: '2\. Now, edit the if __name__ == ''__main__'': block so we can test the code:
    if __name__ == ''__main__'':'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '2. 现在，编辑if __name__ == ''__main__'':块，以便我们可以测试代码：if __name__ == ''__main__'':'
- en: elevation_data = [
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: elevation_data = [
- en: '''../../data/ASTGTM2_S22W048_dem.tif'','
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '''../../data/ASTGTM2_S22W048_dem.tif'','
- en: '''../../data/ASTGTM2_S22W047_dem.tif'','
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '''../../data/ASTGTM2_S22W047_dem.tif'','
- en: '''../../data/ASTGTM2_S23W048_dem.tif'','
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '''../../data/ASTGTM2_S23W048_dem.tif'','
- en: '''../../data/ASTGTM2_S23W047_dem.tif'']'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '''../../data/ASTGTM2_S23W047_dem.tif'']'
- en: combine_images(elevation_data)
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: combine_images(elevation_data)
- en: '3\. Run the code and look at the output:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 运行代码并查看输出：
- en: '[array([[[1, 1, 1],'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '[array([[[1, 1, 1],'
- en: '[1, 1, 1],'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '[1, 1, 1],'
- en: '[2, 2, 2],'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '[2, 2, 2],'
- en: '...,'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '...,'
- en: '[4, 4, 4],'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '[4, 4, 4],'
- en: '[4, 4, 4],'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '[4, 4, 4],'
- en: '[4, 4, 4]],'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '[4, 4, 4]],'
- en: . . .
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: . . .
- en: Process finished with exit code 0
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: Process finished with exit code 0
- en: You should see a list of four arrays. PyCharm will hide some values so it can
    fit in the console.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到四个数组的列表。PyCharm将隐藏一些值，以便它可以在控制台中适应。
- en: The first thing we should notice is that the order of the images in the input
    images argument is the same as the order of the arrays in the output list. This
    will be very important later.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先应该注意到，输入图像参数中图像的顺序与输出列表中数组的顺序相同。这将在以后非常重要。
- en: Secondly, although the elevation data is a 16-bit signed integer (int16), the
    arrays representing the images still have three bands of an 8-bit unsigned integer.
    This is an error.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，尽管高程数据是16位有符号整数（int16），但表示图像的数组仍然有三个8位无符号整数的波段。这是一个错误。
- en: '![Image 46](img/index-290_1.jpg)'
  id: totrans-400
  prefs: []
  type: TYPE_IMG
  zh: '![Image 46](img/index-290_1.jpg)'
- en: 'OpenCV is converting the grayscale image to a color image. We are going to
    fix it as follows:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV正在将灰度图像转换为彩色图像。我们将按照以下方式修复它：
- en: '1\. Change the open_raster_file function to accept a new argument. It will
    allow us to open the images without changing them:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 将open_raster_file函数修改为接受一个新参数。这将允许我们打开图像而不更改它们：
- en: 'def open_raster_file(image, unchanged=True):'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 'def open_raster_file(image, unchanged=True):'
- en: '"""Opens a raster file.'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '"""打开栅格文件。'
- en: ':param image: Path of the raster file or np array.'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: ':param image: 栅格文件的路径或np数组。'
- en: ':param unchanged: Set to true to keep the original format.'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: ':param unchanged: 设置为true以保留原始格式。'
- en: '"""'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: flags = cv2.CV_LOAD_IMAGE_UNCHANGED if unchanged else -1
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: flags = cv2.CV_LOAD_IMAGE_UNCHANGED if unchanged else -1
- en: image = cv2.imread(image, flags=flags)
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: image = cv2.imread(image, flags=flags)
- en: return image
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: return image
- en: The flags argument in cv2.imread allows us to tune how the images are opened
    and converted into arrays. If the flags are set to cv2.CV_LOAD_IMAGE_UNCHANGED,
    the image will open as it is without any conversion.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: cv2.imread中的flags参数允许我们调整图像的打开和转换为数组的方式。如果flags设置为cv2.CV_LOAD_IMAGE_UNCHANGED，则图像将以原始形式打开，不进行任何转换。
- en: '2\. Since we set the default of unchanged to true, we will just run the code
    again and see the results:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 由于我们设置了默认的不变为true，我们只需再次运行代码并查看结果：
- en: '[array([[ 508, 511, 514, ..., 1144, 1148, 1152],'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '[array([[ 508, 511, 514, ..., 1144, 1148, 1152],'
- en: '[ 507, 510, 510, ..., 1141, 1144, 1150],'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '[ 507, 510, 510, ..., 1141, 1144, 1150],'
- en: '[ 510, 508, 506, ..., 1141, 1145, 1154],'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '[ 510, 508, 506, ..., 1141, 1145, 1154],'
- en: '...,'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '...,'
- en: '[ 805, 805, 803, ..., 599, 596, 593],'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '[ 805, 805, 803, ..., 599, 596, 593],'
- en: '[ 802, 797, 803, ..., 598, 594, 590],'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '[ 802, 797, 803, ..., 598, 594, 590],'
- en: '[ 797, 797, 800, ..., 603, 596, 593]], dtype=uint16)'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '[ 797, 797, 800, ..., 603, 596, 593]], dtype=uint16)'
- en: . . .
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: . . .
- en: Process finished with exit code 0
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: Process finished with exit code 0
- en: The values now are correct and they are the measured elevation in meters for
    each pixel.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的值是正确的，并且它们是每个像素的测量高程（米）。
- en: 'So far, we have a list of arrays in the order that the input files are listed.
    To figure out the next step, we can imagine this list as if the images were mosaicked
    as a strip: Now, we must reorganize this, so the images are placed in their correct
    position.'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们有一个按输入文件顺序排列的数组列表。为了确定下一步，我们可以想象这个列表就像图像被作为条带马赛克一样：现在，我们必须重新组织这个列表，以便图像放置在正确的位置。
- en: Remember that NumPy arrays have a shape property. In a 2D array, it’s a tuple
    containing
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，NumPy 数组有一个形状属性。在二维数组中，它是一个包含
- en: the shape in columns and rows. NumPy arrays also have the reshape() method that
    performs a shape transformation.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: the shape in columns and rows. NumPy 数组还有一个 reshape() 方法，它执行形状转换。
- en: '**Note**'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: Take a look at the NumPy documentation on the reshape method and function. Changing
    the shape of an array is a very powerful tool at
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 查看NumPy文档中关于reshape方法和函数的说明。改变数组的形状是一个非常强大的工具，
- en: '[http://docs.scipy.org/doc/numpy/reference/generated/numpy.reshape.html.](http://docs.scipy.org/doc/numpy/reference/generated/numpy.reshape.html)'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://docs.scipy.org/doc/numpy/reference/generated/numpy.reshape.html.](http://docs.scipy.org/doc/numpy/reference/generated/numpy.reshape.html)'
- en: The reshape works by filling a row with the input values in order. When the
    row is full, the method jumps to the next row and continues until the end. So,
    if we pass the expected shape of the mosaic to the combine_images function, we
    can use this information to combine the images with respect to the proper positions.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: reshape 通过按顺序填充行中的输入值来工作。当行填满时，该方法跳到下一行并继续，直到结束。因此，如果我们将马赛克的预期形状传递给 combine_images
    函数，我们就可以使用这些信息根据正确的位置组合图像。
- en: 'But we need something else. We need to know the shape of the output image through
    the number of pixels, and this will be the product of the shape of each image
    by the shape of the mosaic. Let’s try a few changes in the code as follows: 1\.
    Edit the combine images function:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们需要其他东西。我们需要通过像素数量知道输出图像的形状，这将是通过每个图像的形状与马赛克形状的乘积得到的。让我们在代码中尝试一些更改，如下所示：1.
    编辑 combine_images 函数：
- en: 'def combine_images(input_images, shape, output_image):'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 'def combine_images(input_images, shape, output_image):'
- en: '"""Combine images in a mosaic.'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: '"""将图像组合成马赛克。'
- en: ':param input_images: Path to the input images.'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: ':param input_images: 输入图像的路径。'
- en: ':param shape: Shape of the mosaic in columns and rows.'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: ':param shape: 图像马赛克在列和行中的形状。'
- en: ':param output_image: Path to the output image mosaic.'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: ':param output_image: 输出图像马赛克的路径。'
- en: '"""'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: 'if len(input_images) != shape[0] * shape[1]:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 'if len(input_images) != shape[0] * shape[1]:'
- en: raise ValueError(
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: raise ValueError(
- en: '"Number of images doesn''t match the mosaic shape.") images = []'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '"图像数量与马赛克形状不匹配。") images = []'
- en: 'for item in input_images:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 'for item in input_images:'
- en: images.append(open_raster_file(item))
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: images.append(open_raster_file(item))
- en: rows = []
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: rows = []
- en: 'for row in range(shape[0]):'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 'for row in range(shape[0]):'
- en: start = (row * shape[1])
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: start = (row * shape[1])
- en: end = start + shape[1]
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: end = start + shape[1]
- en: rows.append(np.concatenate(images[start:end], axis=1))
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: rows.append(np.concatenate(images[start:end], axis=1))
- en: mosaic = np.concatenate(rows, axis=0)
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: mosaic = np.concatenate(rows, axis=0)
- en: print(mosaic)
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: print(mosaic)
- en: print(mosaic.shape)
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: print(mosaic.shape)
- en: Now the function accepts two more arguments, the shape of the mosaic (the number
    of images in the row and columns and not the number of pixels) and the path of
    the output image for later use.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 现在函数接受两个额外的参数，马赛克的形状（行和列中的图像数量，而不是像素数量）以及输出图像的路径，供以后使用。
- en: With this code, the list of images is separated into rows. Then, the rows are
    combined to form the complete mosaic.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此代码，图像列表被分离成行。然后，这些行被组合成完整的马赛克。
- en: '2\. Before you run the code, don’t forget to import NumPy at the beginning
    of the file:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 在运行代码之前，别忘了在文件开头导入 NumPy：
- en: coding=utf-8
  id: totrans-453
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: coding=utf-8
- en: import cv2
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: import cv2
- en: import numpy as np
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: import numpy as np
- en: 'And edit the if __name__ == ''__main__'': block: if __name__ == ''__main__'':'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: '并编辑 if __name__ == ''__main__'': 块：if __name__ == ''__main__'':'
- en: elevation_data = [
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: elevation_data = [
- en: '''../../data/ASTGTM2_S22W048_dem.tif'','
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: '''../../data/ASTGTM2_S22W048_dem.tif'','
- en: '''../../data/ASTGTM2_S22W047_dem.tif'','
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: '''../../data/ASTGTM2_S22W047_dem.tif'','
- en: '''../../data/ASTGTM2_S23W048_dem.tif'','
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: '''../../data/ASTGTM2_S23W048_dem.tif'','
- en: '''../../data/ASTGTM2_S23W047_dem.tif'']'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: '''../../data/ASTGTM2_S23W047_dem.tif'']'
- en: combine_images(elevation_data, shape=(2, 2))
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: combine_images(elevation_data, shape=(2, 2))
- en: '3\. Now run the code and see the results:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 现在运行代码并查看结果：
- en: '[[508 511 514…, 761 761 761]'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: '[[508 511 514…, 761 761 761]'
- en: '[507 510 510…, 761 761 761]'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: '[507 510 510…, 761 761 761]'
- en: '[510 508 506…, 761 761 761]'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: '[510 508 506…, 761 761 761]'
- en: '...,'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: '...,'
- en: '[514 520 517…, 751 745 739]'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: '[514 520 517…, 751 745 739]'
- en: '[517 524 517…, 758 756 753]'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: '[517 524 517…, 758 756 753]'
- en: '[509 509 510…, 757 759 760]]'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: '[509 509 510…, 757 759 760]]'
- en: (7202, 7202)
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: (7202, 7202)
- en: Process finished with exit code 0
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 进程以退出代码 0 完成
- en: It’s now a single array with 7202 x 7202 pixels. The remaining task is to save
    this array to the disk as an image.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 现在它是一个包含7202 x 7202像素的单个数组。剩余的任务是将此数组保存到磁盘上的图像。
- en: '4\. Just add two lines to the function and edit the if __name__ == ''__main__'':
    block: def combine_images(input_images, shape, output_image):'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: '4\. 只需在函数中添加两行并编辑if __name__ == ''__main__'':块：def combine_images(input_images,
    shape, output_image):'
- en: '"""Combine images in a mosaic.'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: '"""将图像组合成拼贴图。'
- en: ':param input_images: Path to the input images.'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: ':param input_images: 输入图像的路径。'
- en: ':param shape: Shape of the mosaic in columns and rows.'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: ':param shape: 拼贴图的列数和行数形状。'
- en: ':param output_image: Path to the output image mosaic.'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: ':param output_image: 输出图像拼贴图的路径。'
- en: '"""'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: 'if len(input_images) != shape[0] * shape[1]:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 'if len(input_images) != shape[0] * shape[1]:'
- en: raise ValueError(
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: raise ValueError(
- en: '"Number of images doesn''t match the mosaic shape.") images = []'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: '"图像数量与拼贴图形状不匹配。") images = []'
- en: 'for item in input_images:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 'for item in input_images:'
- en: images.append(open_raster_file(item))
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: images.append(open_raster_file(item))
- en: rows = []
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: rows = []
- en: 'for row in range(shape[0]):'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 'for row in range(shape[0]):'
- en: start = (row * shape[1])
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: start = (row * shape[1])
- en: end = start + shape[1]
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: end = start + shape[1]
- en: rows.append(np.concatenate(images[start:end], axis=1))
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: rows.append(np.concatenate(images[start:end], axis=1))
- en: mosaic = np.concatenate(rows, axis=0)
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: mosaic = np.concatenate(rows, axis=0)
- en: print(mosaic)
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: print(mosaic)
- en: print(mosaic.shape)
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: print(mosaic.shape)
- en: cv2.imwrite(output_image, mosaic)
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: cv2.imwrite(output_image, mosaic)
- en: 'if __name__ == ''__main__'':'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == ''__main__'':'
- en: elevation_data = [
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: elevation_data = [
- en: '''../../data/ASTGTM2_S22W048_dem.tif'','
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: '''../../data/ASTGTM2_S22W048_dem.tif'','
- en: '''../../data/ASTGTM2_S22W047_dem.tif'','
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: '''../../data/ASTGTM2_S22W047_dem.tif'','
- en: '''../../data/ASTGTM2_S23W048_dem.tif'','
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: '''../../data/ASTGTM2_S23W048_dem.tif'','
- en: '''../../data/ASTGTM2_S23W047_dem.tif'']'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: '''../../data/ASTGTM2_S23W047_dem.tif'']'
- en: combine_images(elevation_data, shape=(2, 2),
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: combine_images(elevation_data, shape=(2, 2),
- en: output_image="../output/mosaic.png")
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: output_image="../output/mosaic.png")
- en: '**Adjusting the values of the images**'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: '**调整图像的值**'
- en: 'If you run the previous code, you will see a black image as an output. This
    happens because the value range that represents the actual data of this region
    is so narrow in comparison to the possible range of the 16-bit integer image that
    we can’t distinguish the shades of gray. For better understanding, let’s make
    a simple test as follows: 1\. Still in the image_experiments.py file, comment
    the if __name__ == ''__main__'': block and add this new one:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行前面的代码，你会看到一个黑色图像作为输出。这是因为表示该区域实际数据的值范围与16位整数图像的可能范围相比非常窄，我们无法区分灰度色调。为了更好地理解，让我们进行以下简单测试：1\.
    仍然在image_experiments.py文件中，注释掉if __name__ == '__main__':块并添加以下新块：
- en: 'if __name__ == ''__main__'':'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == ''__main__'':'
- en: image = open_raster_file("../output/mosaic.png")
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: image = open_raster_file("../output/mosaic.png")
- en: print(image.min(), image.max())
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: print(image.min(), image.max())
- en: 2\. Run the code and look at the console output.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. 运行代码并查看控制台输出。
- en: (423, 2026)
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: (423, 2026)
- en: Process finished with exit code 0
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: Process finished with exit code 0
- en: Precisely, the image ranges from -32768 to 32767 and the elevation of the region
    in it ranges from 423 to 2026\. So what we need to do to make the image visible
    is to scale the altitude range to the range of the data type.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 精确地说，图像的范围从-32768到32767，该区域的高度从423到2026。因此，我们需要将高度范围缩放到数据类型的范围。
- en: Since we are making a data representation intended for human visualization,
    we don’t need to use a big range of gray values. The researches vary, but some
    say that we can detect only 30 shades, so an 8-bit unsigned integer with 256 possible
    values should be more than enough for data visualization.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在制作旨在供人类可视化的数据表示，我们不需要使用大范围的灰度值。研究各不相同，但有些人说我们只能检测到30种色调，因此256个可能值的8位无符号整数应该足够用于数据可视化。
- en: '3\. Add this new function:'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 3\. 添加此新函数：
- en: 'def adjust_values(input_image, output_image, img_range=None):'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 'def adjust_values(input_image, output_image, img_range=None):'
- en: '"""Create a visualization of the data in the input_image by projecting a range
    of values into a grayscale image.'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: '"""通过将一系列值投影到灰度图像中来在input_image中创建数据的可视化。'
- en: ':param input_image: Array containing the data'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: ':param input_image: 包含数据的数组'
- en: or path to an image.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 或图像的路径。
- en: ':param output_image: The image path to write the output.'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: ':param output_image: 写入输出的图像路径。'
- en: ':param img_range: specified range of values or None to use the range of the
    image (minimum and maximum).'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: ':param img_range: 指定的值范围或None以使用图像的范围（最小值和最大值）。'
- en: '"""'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: image = open_raster_file(input_image)
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: image = open_raster_file(input_image)
- en: 'if img_range:'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 'if img_range:'
- en: min = img_range[0]
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: min = img_range[0]
- en: max = img_range[1]
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: max = img_range[1]
- en: 'else:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: min = image.min()
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: min = image.min()
- en: max = image.max()
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: max = image.max()
- en: interval = max - min
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: interval = max - min
- en: factor = 256.0 / interval
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: factor = 256.0 / interval
- en: output = image * factor
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: output = image * factor
- en: cv2.imwrite(output_image, output)
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: cv2.imwrite(output_image, output)
- en: This function accepts either an array or the path to an image file. With this
    feature,
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数接受数组或图像文件的路径。利用此功能，
- en: '![Image 47](img/index-295_1.jpg)'
  id: totrans-532
  prefs: []
  type: TYPE_IMG
  zh: '![Image 47](img/index-295_1.jpg)'
- en: we can later use this function as a sub-step in other processing procedures.
    The range of values that you want to use is also optional. It can be set manually
    or can be extracted from the images minimum and maximum value.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以稍后使用此函数作为其他处理步骤的子步骤。您想要使用的值范围也是可选的。它可以手动设置，也可以从图像的最小值和最大值中提取。
- en: '4\. To test the code, edit the if __name__ == ''__main__'': block: if __name__
    == ''__main__'':'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: '4. 要测试代码，编辑 if __name__ == ''__main__'': 块：if __name__ == ''__main__'':'
- en: Adjust.
  id: totrans-535
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调整。
- en: adjust_values('../output/mosaic.png',
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: adjust_values('../output/mosaic.png',
- en: '''../output/mosaic_grey.png'')'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: '''../output/mosaic_grey.png'')'
- en: Note that the output image is now a png file. Since we are preparing the image
    for visualization, we can afford to lose information in data compression in exchange
    for a smaller file.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，输出图像现在是一个png文件。由于我们正在为可视化准备图像，我们可以承受在数据压缩中丢失信息，以换取更小的文件。
- en: '5\. Run the code and open the mosaic_grey.png file to see the results. You
    should see the following beautiful grayscale image now:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 5. 运行代码并打开 mosaic_grey.png 文件以查看结果。现在你应该看到以下美丽的灰度图像：
- en: '**Cropping an image**'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: '**裁剪图像**'
- en: We made a big mosaic of images in order to cover the region of interest, and
    in the process, we ended up with an image much bigger than the one we needed.
    Now, it’s time to crop the image, so we end up with a smaller one comprising only
    of what we want to see, thus saving disk space and processing time.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 我们制作了一个大型的图像拼贴，以覆盖感兴趣的区域，在这个过程中，我们得到了一个比所需的图像大得多的图像。现在，是时候裁剪图像了，这样我们就能得到一个更小的图像，只包含我们想要看到的部分，从而节省磁盘空间和处理时间。
- en: 'In our example, we are interested in the volcano crater. It’s the round object
    located on the right-hand side of the image. In order to obtain only that region
    of interest, we will write a function that can crop the image using a bounding
    box set of coordinates, as follows: 1\. Add the new function to the image_experiments.py
    file:'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们感兴趣的是火山口。它是图像右侧的圆形物体。为了只获取该感兴趣区域，我们将编写一个函数，该函数可以使用一组坐标的边界框来裁剪图像，如下所示：1.
    将新函数添加到 image_experiments.py 文件中：
- en: 'def crop_image(input_image, image_extent, bbox, output_image):'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 'def crop_image(input_image, image_extent, bbox, output_image):'
- en: '"""Crops an image by a bounding box.'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: '"""通过边界框裁剪图像。'
- en: 'bbox and image_extent format: (xmin, ymin, xmax, ymax).'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: bbox 和 image_extent 格式：(xmin, ymin, xmax, ymax)。
- en: ':param input_image: Array containing the data'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: ':param input_image: 包含数据的数组'
- en: or path to an image.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 或图像的路径。
- en: ':param image_extent: The geographic extent of the image.'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: ':param image_extent: 图像的地理范围。'
- en: ':param output_image: The image path to write the output.'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: ':param output_image: 输出图像的路径。'
- en: ':param bbox: The bounding box of the region of interest.'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: ':param bbox: 感兴趣区域的边界框。'
- en: '"""'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: input_image = open_raster_file(input_image)
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: input_image = open_raster_file(input_image)
- en: img_shape = input_image.shape
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: img_shape = input_image.shape
- en: img_geo_width = abs(image_extent[2] - image_extent[0])
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: img_geo_width = abs(image_extent[2] - image_extent[0])
- en: img_geo_height = abs(image_extent[3] - image_extent[1])
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: img_geo_height = abs(image_extent[3] - image_extent[1])
- en: How much pixels are contained in one geographic unit.
  id: totrans-556
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个地理单位包含多少像素。
- en: pixel_width = img_shape[1] / img_geo_width
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: pixel_width = img_shape[1] / img_geo_width
- en: pixel_height = img_shape[0] / img_geo_height
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: pixel_height = img_shape[0] / img_geo_height
- en: Index of the pixel to cut.
  id: totrans-559
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 要切割的像素索引。
- en: x_min = abs(bbox[0] - image_extent[0]) * pixel_width
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: x_min = abs(bbox[0] - image_extent[0]) * pixel_width
- en: x_max = abs(bbox[2] - image_extent[0]) * pixel_width
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: x_max = abs(bbox[2] - image_extent[0]) * pixel_width
- en: y_min = abs(bbox[1] - image_extent[1]) * pixel_height
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: y_min = abs(bbox[1] - image_extent[1]) * pixel_height
- en: y_max = abs(bbox[3] - image_extent[1]) * pixel_height
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: y_max = abs(bbox[3] - image_extent[1]) * pixel_height
- en: output = input_image[y_min:y_max, x_min:x_max]
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: output = input_image[y_min:y_max, x_min:x_max]
- en: cv2.imwrite(output_image, output)
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: cv2.imwrite(output_image, output)
- en: Since we are dealing with NumPy arrays, the cropping itself is a simple array
    slicing.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们处理的是NumPy数组，裁剪本身就是一个简单的数组切片。
- en: The slicing of arrays is very similar to the Python lists’ slicing, but with
    additional dimensions. The statement input_image[y_min:y_max, x_min:x_max] tells
    that we want only the portion of the array contained within the specified cells
    (that is, pixels).
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的切片与Python列表的切片非常相似，但具有额外的维度。语句 input_image[y_min:y_max, x_min:x_max] 表示我们只想获取数组中指定单元格（即像素）的部分。
- en: So, all the math involved is to convert geographic units into array indices.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，所有涉及的数学运算都是将地理单位转换为数组索引。
- en: '2\. Edit the if __name__ == ''__main__'': block to test the code: if __name__
    == ''__main__'':'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: '2\. 修改 if __name__ == ''__main__'': 块以测试代码：if __name__ == ''__main__'':'
- en: Crop.
  id: totrans-570
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Crop.
- en: 'roi = (-46.8, -21.7, -46.3, -22.1) # Region of interest.'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 'roi = (-46.8, -21.7, -46.3, -22.1) # 利益区域。'
- en: crop_image('../output/mosaic_grey.png',
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: crop_image('../output/mosaic_grey.png',
- en: (-48, -21, -46, -23), roi, "../output/cropped.png")
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: (-48, -21, -46, -23), roi, "../output/cropped.png")
- en: '![Image 48](img/index-297_1.jpg)'
  id: totrans-574
  prefs: []
  type: TYPE_IMG
  zh: '![Image 48](img/index-297_1.jpg)'
- en: 3\. Run the code and open the output image to see the results.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 3\. 运行代码并打开输出图像以查看结果。
- en: '4\. If you have missed any of the steps, you can run the whole process all
    at once. Just edit the if __name__ == ''__main__'' block:'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 4\. 如果您错过了任何步骤，可以一次性运行整个流程。只需编辑 if __name__ == '__main__' 块：
- en: 'if __name__ == ''__main__'':'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == ''__main__'':'
- en: Combine.
  id: totrans-578
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Combine.
- en: elevation_data = [
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: elevation_data = [
- en: '''../../data/ASTGTM2_S22W048_dem.tif'','
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: '''../../data/ASTGTM2_S22W048_dem.tif'','
- en: '''../../data/ASTGTM2_S22W047_dem.tif'','
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: '''../../data/ASTGTM2_S22W047_dem.tif'','
- en: '''../../data/ASTGTM2_S23W048_dem.tif'','
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: '''../../data/ASTGTM2_S23W048_dem.tif'','
- en: '''../../data/ASTGTM2_S23W047_dem.tif'']'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: '''../../data/ASTGTM2_S23W047_dem.tif'']'
- en: combine_images(elevation_data, shape=(2, 2),
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: combine_images(elevation_data, shape=(2, 2),
- en: output_image="../output/mosaic.png")
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: output_image="../output/mosaic.png")
- en: Adjust.
  id: totrans-586
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Adjust.
- en: adjust_values('../output/mosaic.png',
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: adjust_values('../output/mosaic.png',
- en: '''../output/mosaic_grey.png'')'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: '''../output/mosaic_grey.png'')'
- en: Crop.
  id: totrans-589
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Crop.
- en: 'roi = (-46.8, -21.7, -46.3, -22.1) # Region of interest.'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 'roi = (-46.8, -21.7, -46.3, -22.1) # 利益区域。'
- en: crop_image('../output/mosaic_grey.png',
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: crop_image('../output/mosaic_grey.png',
- en: (-48, -21, -46, -23), roi, "../output/cropped.png")
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: (-48, -21, -46, -23), roi, "../output/cropped.png")
- en: '![Image 49](img/index-298_1.jpg)'
  id: totrans-593
  prefs: []
  type: TYPE_IMG
  zh: '![Image 49](img/index-298_1.jpg)'
- en: '**Creating a shaded relief image**'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: '**创建阴影立体图像**'
- en: Our digital elevation model image has improved a lot after we processed it,
    but it is still not suitable for a map. Untrained eyes may find it difficult to
    understand the relief only by looking at the different shades of gray.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们处理之后，我们的数字高程模型图像有了很大的改进，但它仍然不适合地图。未经训练的眼睛可能很难仅通过观察不同灰度的阴影来理解地形。
- en: 'Fortunately, there is a technique, called **hill shading** or **relief shading**,
    that transforms the elevation data into a simulated sun shading over the terrain.
    Look at the beautiful map in the following picture and note how much easier it
    is to understand the relief when it is presented as a shaded relief:'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有一种技术，称为**阴影渲染**或**立体渲染**，可以将高程数据转换为地形上的模拟阳光阴影。看看下面图片中的美丽地图，并注意当它以阴影立体图的形式呈现时，理解地形要容易得多：
- en: 'The process is simple and involves passing our image through a well-known algorithm
    as follows:'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 该过程很简单，涉及将我们的图像通过以下知名算法：
- en: '1\. Add the create_hillshade function to your image_experiments.py file: def
    create_hillshade(input_image, output_image,'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. 将 create_hillshade 函数添加到您的 image_experiments.py 文件中：def create_hillshade(input_image,
    output_image,
- en: 'azimuth=90, angle_altitude=60):'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 'azimuth=90, angle_altitude=60):'
- en: '"""Creates a shaded relief image from a digital elevation model.'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: '"""从数字高程模型创建阴影立体图像。'
- en: ':param input_image: Array containing the data'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: ':param input_image: 包含数据的数组'
- en: or path to an image.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 或图像的路径。
- en: ':param azimuth: Simulated sun azimuth.'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: ':param azimuth: 模拟太阳方位角。'
- en: ':param angle_altitude: Sun altitude angle.'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: ':param angle_altitude: 太阳高度角。'
- en: '"""'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: input_image = open_raster_file(input_image)
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: input_image = open_raster_file(input_image)
- en: x, y = np.gradient(input_image)
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: x, y = np.gradient(input_image)
- en: slope = np.pi / 2 - np.arctan(np.sqrt(x * x + y * y))
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: slope = np.pi / 2 - np.arctan(np.sqrt(x * x + y * y))
- en: aspect = np.arctan2(-x, y)
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: aspect = np.arctan2(-x, y)
- en: az_rad = azimuth * np.pi / 180
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: az_rad = azimuth * np.pi / 180
- en: alt_rad = angle_altitude * np.pi / 180
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: alt_rad = angle_altitude * np.pi / 180
- en: '![Image 50](img/index-299_1.jpg)'
  id: totrans-612
  prefs: []
  type: TYPE_IMG
  zh: '![Image 50](img/index-299_1.jpg)'
- en: a = np.sin(alt_rad) * np.sin(slope)
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: a = np.sin(alt_rad) * np.sin(slope)
- en: b = np.cos(alt_rad) * np.cos(slope) * np.cos(az_rad - aspect) output = 255 *
    (a + b + 1) / 2
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: b = np.cos(alt_rad) * np.cos(slope) * np.cos(az_rad - aspect) output = 255 *
    (a + b + 1) / 2
- en: cv2.imwrite(output_image, output)
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: cv2.imwrite(output_image, output)
- en: '2\. Now, alter the if __name__ == ''__main__'': block to test the code: if
    __name__ == ''__main__'':'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: '2\. 现在，修改 if __name__ == ''__main__'': 块以测试代码：if __name__ == ''__main__'':'
- en: create_hillshade("../output/cropped.png",
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: create_hillshade("../output/cropped.png",
- en: '"../output/hillshade.png")'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: '"../output/hillshade.png")'
- en: 3\. Run the code and open the output image to see the results. If everything
    goes fine, you should see a shaded relief representation of your data.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 3\. 运行代码并打开输出图像以查看结果。如果一切顺利，您应该看到您数据的阴影立体图表示。
- en: '![Image 51](img/index-301_1.jpg)'
  id: totrans-620
  prefs: []
  type: TYPE_IMG
  zh: '![Image 51](img/index-301_1.jpg)'
- en: '**Building an image processing pipeline**'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: '**构建图像处理管道**'
- en: Image processing, be it for geographic applications or not, generally requires
    the execution of a sequence of transformations (that is, steps) in order to obtain
    the desired final result. In these sequences, the output of one step is the input
    of the next one. In computing, this is called **processing pipeline**.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 图像处理，无论是用于地理应用还是其他应用，通常需要执行一系列变换（即步骤）以获得所需的最终结果。在这些序列中，一个步骤的输出是下一个步骤的输入。在计算机科学中，这被称为**处理管道**。
- en: This type of data manipulation is very versatile, because you have a range of
    functions or steps than can be arranged into numerous combinations to produce
    a wide range of results.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的数据操作非常灵活，因为您有一系列可以排列成多种组合以产生广泛结果的函数或步骤。
- en: What we did so far, in this chapter’s examples, was we opened an image from
    the disk, performed a given operation, and saved the results to another image
    on the disk. Then, in the next step, we opened the result from the previous one
    and so on.
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本章的示例中，我们所做的是从磁盘打开一个图像，执行一个给定的操作，并将结果保存到磁盘上的另一个图像。然后，在下一步中，我们打开前一步的结果，依此类推。
- en: 'Despite the steps are not yet connected, we can imagine the following image
    processing pipeline:'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管步骤尚未连接，我们可以想象以下图像处理管道：
- en: Saving intermediary steps to the disk is useful when we want to use the images
    from them, or in other situations, when the pipeline uses parallel processing
    or other more complex methods.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 将中间步骤保存到磁盘在需要使用这些图像或在其他情况下，当管道使用并行处理或其他更复杂的方法时是有用的。
- en: For some cases, it would be more interesting just to pass data along the pipeline
    without touching the hard drive, only using the computer memory. With this, one
    should expect a noticeable gain in speed and a lesser production of residual files.
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些情况，仅仅在管道中传递数据而不接触硬盘，只使用计算机内存可能更有趣。这样，我们应期望速度有显著提升，并且残余文件的产生会减少。
- en: In order to conciliate these two situations, we can use type checks for our
    functions’
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 为了调和这两种情况，我们可以使用函数的类型检查来处理参数，使它们可以接受数组或文件路径。
- en: 'arguments, making them accept either arrays or file paths. Navigate to your
    open_raster_file function and alter its code:'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 参数，使它们可以接受数组或文件路径。导航到您的 open_raster_file 函数并修改其代码：
- en: 'def open_raster_file(file_path, unchanged=True):'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 'def open_raster_file(file_path, unchanged=True):'
- en: '"""Opens a raster file.'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: '"""打开栅格文件。'
- en: '**:param file_path: Path of the raster file or np array.**'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: '**:param file_path: 栅格文件的路径或 np 数组。**'
- en: ':param unchanged: Set to true to keep the original format.'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: ':param unchanged: 设置为 true 以保持原始格式。'
- en: '"""'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: '**if isinstance(file_path, np.ndarray):**'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: '**if isinstance(file_path, np.ndarray):**'
- en: '**return file_path**'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: '**return file_path**'
- en: flags = cv2.CV_LOAD_IMAGE_UNCHANGED if unchanged else -1
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: flags = cv2.CV_LOAD_IMAGE_UNCHANGED if unchanged else -1
- en: image = cv2.imread(file_path, flags=flags)
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: image = cv2.imread(file_path, flags=flags)
- en: return image
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: return image
- en: This function will now check the type of file_path. If it is already a NumPy
    array, it will be returned. This changes the behavior of all of our functions
    because they can now receive arrays as input.
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数现在将检查 file_path 的类型。如果它已经是一个 NumPy 数组，它将被返回。这改变了我们所有函数的行为，因为它们现在可以接收数组作为输入。
- en: If we add a return statement to all the functions and make them return the output
    arrays,
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在所有函数中添加返回语句并使它们返回输出数组，
- en: 'we would be able to combine the function as follows: create_hillshade('
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将能够如下组合函数：create_hillshade(
- en: crop_image(
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: crop_image(
- en: adjust_values('mosaic.png'),
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: adjust_values('mosaic.png'),
- en: (-48, -21, -46, -23), roi), 'shaded.png')
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: (-48, -21, -46, -23), roi), 'shaded.png')
- en: You don’t need to type this code. This notation is hard to understand. The order
    in which the functions are called is unintuitive and it’s difficult to figure
    out of which function is each argument.
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 您不需要输入此代码。这种表示法难以理解。函数调用的顺序不直观，难以确定每个参数属于哪个函数。
- en: It would be much nicer if we could execute the pipeline by chaining the functions,
    like we did in the *Chaining filters* section in [Chapter 4,](index_split_001.html#p174)
    *Improving the App Search Capabilities*.
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能够像在第四章的“链式过滤器”部分中做的那样通过链式调用函数来执行管道，那会更好。[第4章](index_split_001.html#p174)，*改进应用搜索能力*。
- en: 'Actually, it would be great to use something with a notation as follows: adjust_values().crop_image().create_hillshade()'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，如果能使用如下表示法那就太好了：adjust_values().crop_image().create_hillshade()
- en: As in [Chapter 4](index_split_001.html#p174), *Improving the App Search Capabilities*,
    the only thing we need is to have a class and the methods that return the same
    type of class. With these two things, there are no limits on how the steps can
    be combined. So, let’s do it.
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 如同 [第 4 章](index_split_001.html#p174)，*改进应用搜索功能*，我们需要的只是一个类和返回相同类型类的那些方法。有了这两样东西，步骤如何组合就没有限制了。所以，让我们开始吧。
- en: '**Creating a RasterData class**'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: '**创建 RasterData 类**'
- en: Our RasterData class will follow the pattern used before with our vectors. When
    instantiated, the class will receive a file path or an array. As said before,
    in order to use method chaining to perform a processing pipeline, each processing
    method must return another instance of the RasterData class.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 RasterData 类将遵循之前与我们的向量所使用的模式。实例化时，该类将接收一个文件路径或一个数组。正如之前所说，为了使用方法链来执行处理管道，每个处理方法必须返回
    RasterData 类的另一个实例。
- en: 'We will start with class declaration and then fill it with the methods. To
    make it easier to cut and paste the work we have already done, we will do the
    following steps inside the image_experiments.py file:'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从类声明开始，然后填充它的方法。为了使剪切和粘贴我们已完成的工作更容易，我们将在 image_experiments.py 文件中进行以下步骤：
- en: '1\. At the top of the image_experiments.py file, after the imports, create
    the class:'
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 在 image_experiments.py 文件顶部，导入之后，创建一个类：
- en: coding=utf-8
  id: totrans-654
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: coding=utf-8
- en: import cv2
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: import cv2
- en: import numpy as np
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: import numpy as np
- en: 'class RasterData(object):'
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 'class RasterData(object):'
- en: 'def __init__(self, input_data, unchanged=True, shape=None):'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, input_data, unchanged=True, shape=None):'
- en: '"""Represents a raster data in the form of an array.'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: '"""表示以数组形式存在的栅格数据。'
- en: ':param input_data: Raster files or Numpy array.'
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: ':param input_data: 栅格文件或 Numpy 数组。'
- en: ':param unchanged: True to keep the original format.'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: ':param unchanged: 如果为 True，则保持原始格式。'
- en: ':param shape: When using multiple input data, this param'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: ':param shape: 当使用多个输入数据时，此参数'
- en: determines the shape of the composition.
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 确定组合的形状。
- en: '"""'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: self.data = None
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: self.data = None
- en: if isinstance(input_data, list) \
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: if isinstance(input_data, list) \
- en: 'or isinstance(input_data, tuple):'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 'or isinstance(input_data, tuple):'
- en: self.combine_images(input_data, shape)
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: self.combine_images(input_data, shape)
- en: 'else:'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: self.import_data(input_data, unchanged)
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: self.import_data(input_data, unchanged)
- en: The array will be stored in the data property, so we will initially set it to
    None.
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 该数组将被存储在 data 属性中，因此我们最初将其设置为 None。
- en: There are a few other changes to make this class consistent with the others
    and avoid redundancy in the names. The first one is to use an import_data method
    like before.
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个类与其他类保持一致并避免名称上的冗余，我们需要进行一些其他更改。第一个更改是使用与之前相同的 import_data 方法。
- en: '2\. Cut and paste the open_raster_file function into the class, rename it to
    import_data, and change it to behave like a method:'
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 将 open_raster_file 函数剪切并粘贴到类中，将其重命名为 import_data，并修改其行为以像方法一样：
- en: 'class RasterData(object):'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 'class RasterData(object):'
- en: 'def __init__(self, input_data, unchanged=True, shape=None):'
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, input_data, unchanged=True, shape=None):'
- en: '...'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: 'def import_data(self, image, unchanged=True):'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 'def import_data(self, image, unchanged=True):'
- en: '"""Opens a raster file.'
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: '"""打开栅格文件。'
- en: ':param image: Path of the raster file or np array.'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: ':param image: 栅格文件路径或 np 数组。'
- en: ':param unchanged: True to keep the original format.'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: ':param unchanged: 如果为 True，则保持原始格式。'
- en: '"""'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: 'if isinstance(image, np.ndarray):'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 'if isinstance(image, np.ndarray):'
- en: self.data = image
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: self.data = image
- en: return image
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: return image
- en: flags = cv2.CV_LOAD_IMAGE_UNCHANGED if unchanged else -1
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: flags = cv2.CV_LOAD_IMAGE_UNCHANGED if unchanged else -1
- en: self.data = cv2.imread(image, flags=flags)
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: self.data = cv2.imread(image, flags=flags)
- en: Instead of returning an array, it will now put the array in the data property.
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是返回一个数组，现在它将数组放入 data 属性中。
- en: Next, since we will be removing the obligation of writing the image to the disk
    from the steps, we will need a method to perform this action.
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，由于我们将从步骤中移除将图像写入磁盘的义务，我们需要一个方法来执行此操作。
- en: '3\. Add the write_image method:'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 添加 write_image 方法：
- en: 'class RasterData(object):'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 'class RasterData(object):'
- en: 'def __init__(self, input_data, unchanged=True, shape=None):'
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, input_data, unchanged=True, shape=None):'
- en: '...'
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: 'def import_data(self, input_image, unchanged=True):'
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 'def import_data(self, input_image, unchanged=True):'
- en: '...'
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: 'def write_image(self, output_image):'
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 'def write_image(self, output_image):'
- en: '"""Write the data to the disk as an image.'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: '"""将数据写入磁盘作为图像。'
- en: ':param output_image: Path and name of the output image.'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: ':param output_image: 输出图像的路径和名称。'
- en: '"""'
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: cv2.imwrite(output_image, self.data)
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: cv2.imwrite(output_image, self.data)
- en: return self
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: return self
- en: '4\. Following the examples’ order, cut and paste the combine_images function
    as a method to the class:'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 4. 按照示例的顺序，将 combine_images 函数剪切并粘贴到类中作为方法：
- en: 'class RasterData(object):'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 'class RasterData(object):'
- en: 'def __init__(self, input_data, unchanged=True, shape=None):'
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, input_data, unchanged=True, shape=None):'
- en: '...'
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: 'def import_data(self, input_image, unchanged=True):'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 'def import_data(self, input_image, unchanged=True):'
- en: '...'
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: 'def write_image(self, output_image):'
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 'def write_image(self, output_image):'
- en: '...'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: 'def combine_images(self, input_images, shape):'
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 'def combine_images(self, input_images, shape):'
- en: '"""Combine images in a mosaic.'
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: '"""组合图像形成镶嵌。'
- en: ':param input_images: Path to the input images.'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: ':param input_images: 输入图像的路径。'
- en: ':param shape: Shape of the mosaic in columns and rows.'
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: ':param shape: 镶嵌的列数和行数形状。'
- en: '"""'
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: 'if len(input_images) != shape[0] * shape[1]:'
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 'if len(input_images) != shape[0] * shape[1]:'
- en: raise ValueError("Number of images doesn't match the"
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: raise ValueError("图像数量与形状不匹配"
- en: '" mosaic shape.")'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: '"镶嵌形状。")'
- en: images = []
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: images = []
- en: 'for item in input_images:'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 'for item in input_images:'
- en: 'if isinstance(item, RasterData):'
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 'if isinstance(item, RasterData):'
- en: images.append(item.data)
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: images.append(item.data)
- en: 'else:'
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: images.append(RasterData(item).data)
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: images.append(RasterData(item).data)
- en: rows = []
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: rows = []
- en: 'for row in range(shape[0]):'
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 'for row in range(shape[0]):'
- en: start = (row * shape[1])
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: start = (row * shape[1])
- en: end = start + shape[1]
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: end = start + shape[1]
- en: rows.append(np.concatenate(images[start:end], axis=1))
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: rows.append(np.concatenate(images[start:end], axis=1))
- en: mosaic = np.concatenate(rows, axis=0)
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: mosaic = np.concatenate(rows, axis=0)
- en: self.data = mosaic
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: self.data = mosaic
- en: return self
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: return self
- en: Now, it’s possible to create an empty RasterData instance and then populate
    it with a mosaic using this method. Or, you can create the instance with a list
    containing any combination of image paths, arrays, or even other RasterData instances
    as an argument. It will automatically combine them, put the result in the data
    property, and return itself.
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以创建一个空的 RasterData 实例，然后使用此方法用镶嵌填充它。或者，你可以使用包含任何组合的图像路径、数组或甚至其他 RasterData
    实例作为参数创建实例。它将自动将它们组合起来，将结果放入数据属性中，并返回自身。
- en: Now that you got the hang of it, let’s do the same transformation with the last
    three functions.
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经掌握了这个技巧，让我们用最后三个函数进行相同的转换。
- en: '5\. Cut and paste the adjust_values, crop_image and create_hillshade functions
    as methods into the class. Your complete class should be as follows: class RasterData(object):'
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: '5. 将 adjust_values、crop_image 和 create_hillshade 函数作为方法添加到类中。你的完整类应该如下所示：class
    RasterData(object):'
- en: 'def __init__(self, input_data, unchanged=True, shape=None):'
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, input_data, unchanged=True, shape=None):'
- en: '"""Represents a raster data in the form of an array.'
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: '"""表示以数组形式存在的栅格数据。'
- en: ':param input_data: Raster files or Numpy array.'
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: ':param input_data: 栅格文件或 Numpy 数组。'
- en: ':param unchanged: True to keep the original format.'
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: ':param unchanged: True 以保持原始格式。'
- en: ':param shape: When using multiple input data, this param'
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: ':param shape: 当使用多个输入数据时，此参数'
- en: determines the shape of the composition.
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 确定组合的形状。
- en: '"""'
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: self.data = None
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: self.data = None
- en: if isinstance(input_data, list) \
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: if isinstance(input_data, list) \
- en: 'or isinstance(input_data, tuple):'
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 'or isinstance(input_data, tuple):'
- en: self.combine_images(input_data, shape)
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: self.combine_images(input_data, shape)
- en: 'else:'
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: self.import_data(input_data, unchanged)
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: self.import_data(input_data, unchanged)
- en: 'def import_data(self, image, unchanged=True):'
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 'def import_data(self, image, unchanged=True):'
- en: '"""Opens a raster file.'
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: '"""打开栅格文件。'
- en: ':param image: Path of the raster file or np array.'
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: ':param image: 栅格文件的路径或 np 数组。'
- en: ':param unchanged: True to keep the original format.'
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: ':param unchanged: True 以保持原始格式。'
- en: '"""'
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: 'if isinstance(image, np.ndarray):'
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 'if isinstance(image, np.ndarray):'
- en: self.data = image
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: self.data = image
- en: return image
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: return image
- en: flags = cv2.CV_LOAD_IMAGE_UNCHANGED if unchanged else -1
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: flags = cv2.CV_LOAD_IMAGE_UNCHANGED if unchanged else -1
- en: self.data = cv2.imread(image, flags=flags)
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: self.data = cv2.imread(image, flags=flags)
- en: 'def write_image(self, output_image):'
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 'def write_image(self, output_image):'
- en: '"""Write the data to the disk as an image.'
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: '"""将数据写入磁盘作为图像。'
- en: ':param output_image: Path and name of the output image.'
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: ':param output_image: 输出图像的路径和名称。'
- en: '"""'
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: cv2.imwrite(output_image, self.data)
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: cv2.imwrite(output_image, self.data)
- en: return self
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: return self
- en: 'def combine_images(self, input_images, shape):'
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 'def combine_images(self, input_images, shape):'
- en: '"""Combine images in a mosaic.'
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: '"""组合图像形成镶嵌。'
- en: ':param input_images: Path to the input images.'
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: ':param input_images: 输入图像的路径。'
- en: ':param shape: Shape of the mosaic in columns and rows.'
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: ':param shape: 镶嵌的列数和行数形状。'
- en: '"""'
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: 'if len(input_images) != shape[0] * shape[1]:'
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 'if len(input_images) != shape[0] * shape[1]:'
- en: raise ValueError("Number of images doesn't match the"
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: raise ValueError("图像数量与形状不匹配"
- en: '" mosaic shape.")'
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: '"镶嵌形状。")'
- en: images = []
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: images = []
- en: 'for item in input_images:'
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 'for item in input_images:'
- en: 'if isinstance(item, RasterData):'
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: 'if isinstance(item, RasterData):'
- en: images.append(item.data)
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: images.append(item.data)
- en: 'else:'
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: images.append(RasterData(item).data)
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: images.append(RasterData(item).data)
- en: rows = []
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: rows = []
- en: 'for row in range(shape[0]):'
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: 'for row in range(shape[0]):'
- en: start = (row * shape[1])
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: start = (row * shape[1])
- en: end = start + shape[1]
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: end = start + shape[1]
- en: rows.append(np.concatenate(images[start:end], axis=1))
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: rows.append(np.concatenate(images[start:end], axis=1))
- en: mosaic = np.concatenate(rows, axis=0)
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: mosaic = np.concatenate(rows, axis=0)
- en: self.data = mosaic
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: self.data = mosaic
- en: return self
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: return self
- en: 'def adjust_values(self, img_range=None):'
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 'def adjust_values(self, img_range=None):'
- en: '"""Create a visualization of the data in the input_image by projecting a range
    of values into a grayscale image.'
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: '"""通过将一系列值投影到灰度图像中来在输入图像中创建数据的可视化。'
- en: ':param img_range: specified range of values'
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: ':param img_range: 指定的值范围'
- en: or None to use the range of the image
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: 或None以使用图像的范围
- en: (minimum and maximum).
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: (最小值和最大值)。
- en: '"""'
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: image = self.data
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: image = self.data
- en: 'if img_range:'
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: 'if img_range:'
- en: min = img_range[0]
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: min = img_range[0]
- en: max = img_range[1]
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: max = img_range[1]
- en: 'else:'
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: min = image.min()
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: min = image.min()
- en: max = image.max()
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: max = image.max()
- en: interval = max - min
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: interval = max - min
- en: factor = 256.0 / interval
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: factor = 256.0 / interval
- en: output = image * factor
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: output = image * factor
- en: self.data = output
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: self.data = output
- en: return self
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: return self
- en: 'def crop_image(self, image_extent, bbox):'
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: 'def crop_image(self, image_extent, bbox):'
- en: '"""Crops an image by a bounding box.'
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: '"""通过边界框裁剪图像。'
- en: 'bbox and image_extent format: (xmin, ymin, xmax, ymax).'
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: 'bbox和image_extent格式: (xmin, ymin, xmax, ymax)。'
- en: ':param input_image: Array containing the data'
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: ':param input_image: 包含数据的数组'
- en: or path to an image.
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: 或图像的路径。
- en: ':param image_extent: The geographic extent of the image.'
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: ':param image_extent: 图像的地理范围。'
- en: ':param output_image: The image path to write the output.'
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: ':param output_image: 写入输出的图像路径。'
- en: ':param bbox: The bounding box of the region of interest.'
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: ':param bbox: 兴趣区域的边界框。'
- en: '"""'
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: input_image = self.data
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: input_image = self.data
- en: img_shape = input_image.shape
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: img_shape = input_image.shape
- en: img_geo_width = abs(image_extent[2] - image_extent[0])
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: img_geo_width = abs(image_extent[2] - image_extent[0])
- en: img_geo_height = abs(image_extent[3] - image_extent[1])
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: img_geo_height = abs(image_extent[3] - image_extent[1])
- en: How much pixels are contained in one geographic unit.
  id: totrans-816
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个地理单位包含多少像素。
- en: pixel_width = img_shape[1] / img_geo_width
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: pixel_width = img_shape[1] / img_geo_width
- en: pixel_height = img_shape[0] / img_geo_height
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: pixel_height = img_shape[0] / img_geo_height
- en: Index of the pixel to cut.
  id: totrans-819
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 要切割的像素索引。
- en: x_min = abs(bbox[0] - image_extent[0]) * pixel_width
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: x_min = abs(bbox[0] - image_extent[0]) * pixel_width
- en: x_max = abs(bbox[2] - image_extent[0]) * pixel_width
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: x_max = abs(bbox[2] - image_extent[0]) * pixel_width
- en: y_min = abs(bbox[1] - image_extent[1]) * pixel_height
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: y_min = abs(bbox[1] - image_extent[1]) * pixel_height
- en: y_max = abs(bbox[3] - image_extent[1]) * pixel_height
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: y_max = abs(bbox[3] - image_extent[1]) * pixel_height
- en: output = input_image[y_min:y_max, x_min:x_max]
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: output = input_image[y_min:y_max, x_min:x_max]
- en: self.data = output
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: self.data = output
- en: return self
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: return self
- en: 'def create_hillshade(self, azimuth=90, angle_altitude=60):'
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: 'def create_hillshade(self, azimuth=90, angle_altitude=60):'
- en: '"""Creates a shaded relief image from a digital elevation model.'
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: '"""从数字高程模型创建阴影图。'
- en: ':param input_image: Array containing the data'
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: ':param input_image: 包含数据的数组'
- en: or path to an image.
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: 或图像的路径。
- en: ':param azimuth: Simulated sun azimuth.'
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: ':param azimuth: 模拟的太阳方位角。'
- en: ':param angle_altitude: Sun altitude angle.'
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: ':param angle_altitude: 太阳高度角。'
- en: '"""'
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: input_image = self.data
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: input_image = self.data
- en: x, y = np.gradient(input_image)
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: x, y = np.gradient(input_image)
- en: slope = np.pi / 2 - np.arctan(np.sqrt(x * x + y * y))
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: slope = np.pi / 2 - np.arctan(np.sqrt(x * x + y * y))
- en: aspect = np.arctan2(-x, y)
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: aspect = np.arctan2(-x, y)
- en: az_rad = azimuth * np.pi / 180
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: az_rad = azimuth * np.pi / 180
- en: alt_rad = angle_altitude * np.pi / 180
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: alt_rad = angle_altitude * np.pi / 180
- en: a = np.sin(alt_rad) * np.sin(slope)
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: a = np.sin(alt_rad) * np.sin(slope)
- en: b = np.cos(alt_rad) * np.cos(slope)\
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: b = np.cos(alt_rad) * np.cos(slope)\
- en: '* np.cos(az_rad - aspect)'
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: '* np.cos(az_rad - aspect)'
- en: output = 255 * (a + b + 1) / 2
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: output = 255 * (a + b + 1) / 2
- en: self.data = output
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: self.data = output
- en: return self
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: return self
- en: The class is complete and we can make a pipeline to test it.
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: 类已完整，我们可以创建一个流程来测试它。
- en: '6\. Edit and organize the if __name__ == ''__main__'': block to test the image
    processing pipeline:'
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: 6\. 编辑并组织if __name__ == '__main__':块以测试图像处理流程：
- en: 'if __name__ == ''__main__'':'
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == ''__main__'':'
- en: elevation_data = [
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: 高程数据 = [
- en: '''../../data/ASTGTM2_S22W048_dem.tif'','
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
  zh: '''../../data/ASTGTM2_S22W048_dem.tif'','
- en: '''../../data/ASTGTM2_S22W047_dem.tif'','
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: '''../../data/ASTGTM2_S22W047_dem.tif'','
- en: '''../../data/ASTGTM2_S23W048_dem.tif'','
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: '''../../data/ASTGTM2_S23W048_dem.tif'','
- en: '''../../data/ASTGTM2_S23W047_dem.tif'']'
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: '''../../data/ASTGTM2_S23W047_dem.tif'']'
- en: 'roi = (-46.8, -21.7, -46.3, -22.1) # Region of interest.'
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
  zh: 'roi = (-46.8, -21.7, -46.3, -22.1) # 兴趣区域。'
- en: 'iex = (-48, -21, -46, -23) # Image extent.'
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: 'iex = (-48, -21, -46, -23) # 图像范围。'
- en: RasterData(elevation_data, shape=(2, 2)).adjust_values().\
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: RasterData(elevation_data, shape=(2, 2)).adjust_values().\
- en: crop_image(iex, roi).create_hillshade().\
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: crop_image(iex, roi).create_hillshade().\
- en: write_image('../output/pipeline_output.png')
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: write_image('../output/pipeline_output.png')
- en: '![Image 52](img/index-308_1.jpg)'
  id: totrans-859
  prefs: []
  type: TYPE_IMG
  zh: '![Image 52](img/index-308_1.jpg)'
- en: Due to the width limitation of the book, the pipeline is broken into three lines,
    but you can type it in a single line in PyCharm if you wish.
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本书的宽度限制，管道被拆分为三行，但如果你愿意，可以在PyCharm中将其输入为单行。
- en: 7\. Run the code and admire the result.
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: 7. 运行代码并欣赏结果。
- en: At this point, you have a fantastic accomplishment. I’m not talking about the
    shaded relief image, I’m talking about the ability to consistently develop processing
    steps and combine them into a processing pipeline in order to achieve the final
    result. The structure that we developed here can be used to do almost anything
    in terms of geoprocessing.
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经取得了了不起的成就。我说的不是阴影高程图，我说的是能够持续开发处理步骤并将它们组合成一个处理管道以实现最终结果的能力。我们在这里开发的结构可以用于几乎任何地理处理。
- en: Also, note that the image generated by the pipeline is of a much superior quality
    than the one created before. This happened because the data was in the memory
    the whole time.
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，由管道生成的图像的质量远优于之前的图像。这是因为数据一直存储在内存中。
- en: This avoided data loss due to compression when the data was saved to a file
    multiple times.
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: 这避免了在将数据多次保存到文件时由于压缩导致的数据丢失。
- en: 'A few remarks about the functionality of the structure as we implemented it
    are as follows: All the processing methods do two things in the end: they change
    the instance data and return the instance itself. The implication of this is that
    the class instance will mutate along the pipeline and the old data will be replaced
    by new ones as the process goes on. With this, Python’s garbage collector will
    eliminate old results from the memory and save space.'
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: 关于我们实现的结构功能的一些评论如下：所有的处理方法最终都做两件事：改变实例数据并返回实例本身。这意味着类实例将在管道中发生变异，随着过程的进行，旧数据将被新数据替换。因此，Python的垃圾回收器将消除内存中的旧结果以节省空间。
- en: If, at any step, you want to save the current state of processing, just insert
    a call to the write_image method (it will also return self and it can be piped).
    This is a powerful
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在任何步骤中你想保存当前的处理状态，只需插入对write_image方法的调用（它也会返回self，并且可以被管道化）。这是一个强大的功能。
- en: tool for debugging and also can save time when you only want to repeat the steps
    later in a long pipeline.
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: 调试工具，同时也可以在稍后需要重复长管道中的步骤时节省时间。
- en: You can fork the pipeline. You can create a bifurcation where more than one
    result can be produced by following different paths. To do this, you can use the
    copy() function or you can write the result to the disk before the bifurcation.
    Later in the book we will see that, sometimes, while performing parallel processing,
    we will need these techniques too.
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以分叉管道。你可以在不同的路径上创建一个分支，从而可以产生多个结果。为此，你可以使用copy()函数，或者你可以在分叉之前将结果写入磁盘。在本书的后面部分，我们将看到，在进行并行处理时，有时我们也会需要这些技术。
- en: '**Summary**'
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: '**总结**'
- en: In this chapter, we understood how remote sensing images are represented inside
    the computer as arrays and how we can use this characteristic to process them.
    We saw that, in order to use images on a map, it is common that we need to transform
    them to achieve better results. Then, we wrote processing functions to process
    the digital elevation model images, ending with a beautiful shaded relief map.
    Finally, we created a RasterData class and transformed our functions into the
    methods of this class. With a few additional changes, we made it possible to chain
    these methods into a processing pipeline.
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了遥感图像如何在计算机内部表示为数组，以及我们如何利用这一特性来处理它们。我们看到了，为了在地图上使用图像，通常需要将它们转换以获得更好的结果。然后，我们编写了处理函数来处理数字高程模型图像，最终得到一幅美丽的阴影高程图。最后，我们创建了一个RasterData类，并将我们的函数转换成了这个类的成员方法。通过一些额外的修改，我们使这些方法能够链入处理管道。
- en: In the next chapter, we will explore the data in the images and obtain valuable
    information.
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探索图像中的数据并获取有价值的信息。
- en: '**Chapter 7\. Extract Information from**'
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: '**第7章：提取信息**'
- en: '**Raster Data**'
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
  zh: '**栅格数据**'
- en: More than just a resource for visual information, raster data are samples of
    a given spatial attribute, whose values can be analyzed in order to produce valuable
    information.
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
  zh: 栅格数据不仅仅是视觉信息的资源，它们是给定空间属性的样本，其值可以进行分析以产生有价值的信息。
- en: Is this chapter, we will extract information from raster data with special emphasis
    on statistical information. Following the previous examples, we will use the digital
    elevation model to obtain values such as the maximum and minimum altitude of a
    given region, separate altitude ranges into classes, and produce histograms and
    other statistical information. Going beyond simple numerical values, we will display
    all the information on beautifully colored maps.
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将从栅格数据中提取信息，特别强调统计信息。遵循之前的示例，我们将使用数字高程模型来获取给定区域的最高和最低海拔值，将海拔范围分为类别，并生成直方图和其他统计信息。超越简单的数值，我们将在漂亮的彩色地图上显示所有信息。
- en: 'The topics covered by this chapter are:'
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的主题包括：
- en: How to obtain statistics from raster data
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: 如何从栅格数据中获取统计信息
- en: The use of programming techniques, such as lazy evaluation and memorization,
    to avoid unnecessary calculation
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: 使用编程技术，如延迟评估和记忆化，以避免不必要的计算
- en: How to format tabular data output
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: 如何格式化表格数据输出
- en: How to colorize maps and choose suitable colors for them
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: 如何着色地图并选择合适的颜色
- en: How to blend color maps in order to produce colorized and shaded maps
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: 如何混合颜色图以生成彩色和阴影图
- en: '**Getting the basic statistics**'
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: '**获取基本统计信息**'
- en: As we have previously seen, images or raster data are arrays containing numerical
    values representing a given real world space. So, they are by consequence statistical
    samples and they can be used in statistical analysis.
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前看到的，图像或栅格数据是包含表示给定现实世界空间的数值的数组。因此，它们是统计样本，并且可以用于统计分析。
- en: When we import the data, it is converted into NumPy arrays. These arrays are
    packed with methods for basic statistical calculations. In this topic, we are
    going to obtain the results from these calculations and save them in a file.
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们导入数据时，它被转换为 NumPy 数组。这些数组包含基本统计计算的方法。在本主题中，我们将从这些计算中获得结果并将它们保存到文件中。
- en: At the end of the previous chapter, we made an image processing pipeline by
    combining steps that can be saved on the disk. Here, we will follow the same pattern.
    The statistical computation will be added as another step. Maintaining the same
    kind of organization allows the user to generate statistics at any point on the
    processing pipeline. It will be possible to save statistics from all the substeps
    if needed.
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章的末尾，我们通过组合可以保存到磁盘上的步骤创建了一个图像处理流程。在这里，我们将遵循相同的模式。统计计算将被添加为另一个步骤。保持相同的组织结构允许用户在任何处理流程点上生成统计信息。如果需要，可以保存所有子步骤的统计信息。
- en: 'Let’s start by organizing our code:'
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先组织我们的代码：
- en: 1\. As we do at the beginning of every chapter, we will copy the code from the
    previous chapter. In your geopy project folder, copy the Chapter 6 folder ( *Ctrl*
    + *C*) and paste it ( *Ctrl* + *V*). Name the copied folder as Chapter7\.
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 正如我们在每一章的开始所做的那样，我们将从上一章复制代码。在你的 geopy 项目文件夹中，复制 Chapter 6 文件夹（*Ctrl* + *C*）并将其粘贴（*Ctrl*
    + *V*）。将复制的文件夹命名为 Chapter7\。
- en: In the last chapter, we finished the RasterData class inside the image_experiments.py
    file. Since our experiments are over, let’s move this class to a permanent and
    meaningful location.
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一章中，我们在 image_experiments.py 文件中完成了 RasterData 类。由于我们的实验已经结束，让我们将这个类移动到一个永久且有意义的位置。
- en: 2\. Copy the file Chapter7/experiments/image_experiments.py ( *Ctrl* + *C*).
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 复制文件 Chapter7/experiments/image_experiments.py（*Ctrl* + *C*）。
- en: 3\. Select the Chapter7 folder and paste the file there ( *Ctrl* + *V*).
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 选择 Chapter7 文件夹并将文件粘贴到那里（*Ctrl* + *V*）。
- en: 4\. Rename the file to raster_data.py. To do this, right-click on the file and
    select **Refactor** | **Rename…** or select the file and press *Ctrl* + *F6*.
    The refactor dialog will appear. Change the name in the dialog and click on the
    **Refactor** button. There are two checkboxes in the dialog asking whether you
    want to search for this file’s references. If they are checked (on), PyCharm will
    search and automatically change these references, so the code will continue to
    work.
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: 4. 将文件重命名为 raster_data.py。为此，右键单击文件并选择 **重构** | **重命名…** 或者选择文件并按 *Ctrl* + *F6*。将出现重构对话框。在对话框中更改名称，然后单击
    **重构** 按钮。对话框中有两个复选框询问您是否想要搜索此文件的引用。如果它们被勾选（开启），PyCharm 将搜索并自动更改这些引用，因此代码将继续工作。
- en: 5\. Remove the image_experiments.py file, as it won’t be of use anymore.
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: 5. 删除 image_experiments.py 文件，因为它将不再有用。
- en: Now that our code is organized, we are going to analyze a few aspects and review
    some points in order to plan our next step.
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经组织好了代码，我们将分析一些方面并回顾一些点，以便规划我们的下一步。
- en: 'Let’s take an instance of your RasterData class that has a base working pattern,
    as it is now:'
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以一个具有基础工作模式的 RasterData 类实例为例：
- en: At the instancing moment, you can pass the data or you can import the data later.
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: 在实例化时刻，你可以传递数据，或者你可以稍后导入数据。
- en: After this, the data will be stored as a NumPy array in the data property.
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，数据将存储为 NumPy 数组在 data 属性中。
- en: When you run any method in the class, the operation is performed and the data
    is transformed if it’s the case and the instance itself is returned along with
    the new data.
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在类中运行任何方法时，操作将被执行，如果需要，数据将被转换，并且实例本身将连同新数据一起返回。
- en: No information is stored in the class, other than the data. And by consequence,
    some methods need to take manually defined parameters.
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: 类中除了数据外没有存储任何信息。因此，一些方法需要手动定义参数。
- en: The data property is a NumPy array, so it has all the NumPy array methods.
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: 数据属性是一个 NumPy 数组，所以它具有所有 NumPy 数组方法。
- en: '**Preparing the data**'
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: '**准备数据**'
- en: The sample data that we will be using is composed of four images containing
    elevation data. The processing pipeline combines these images, adjusts the values
    to display on a map, cuts the image, and then generates the shaded relief image.
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要使用的是由包含高程数据的四幅图像组成的样本数据。处理流程将这些图像合并，调整值以在地图上显示，裁剪图像，然后生成阴影地形图。
- en: This pipeline is good for visualization, but data is lost in the moment we adjust
    the values.
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
  zh: 这个流程适合可视化，但在调整值的时候会丢失数据。
- en: 'For this work, we don’t want that to happen. We want the original values in
    meters. So, the first thing we need to do is build a pipeline adequate for our
    needs, and in the end, save the results, so we don’t need to repeat all the steps
    in the following tests: 1\. Open the raster_data.py file for editing, and at the
    end of it, add the if __name__'
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这项工作，我们不希望发生这种情况。我们希望保留原始的米值。所以，我们首先需要做的是构建一个适合我们需求的流程，并在最后保存结果，这样我们就不需要在接下来的测试中重复所有步骤：1.
    打开 raster_data.py 文件进行编辑，并在其末尾添加 if __name__
- en: '== ''__main__'': block with the following code:'
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
  zh: '== ''__main__'': 包含以下代码的块:'
- en: 'if __name__ == ''__main__'':'
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == ''__main__'':'
- en: elevation_data = [
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: 高程数据 = [
- en: '''../data/ASTGTM2_S22W048_dem.tif'','
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
  zh: '''../data/ASTGTM2_S22W048_dem.tif'','
- en: '''../data/ASTGTM2_S22W047_dem.tif'','
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: '''../data/ASTGTM2_S22W047_dem.tif'','
- en: '''../data/ASTGTM2_S23W048_dem.tif'','
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
  zh: '''../data/ASTGTM2_S23W048_dem.tif'','
- en: '''../data/ASTGTM2_S23W047_dem.tif'']'
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: '''../data/ASTGTM2_S23W047_dem.tif'']'
- en: 'roi = (-46.8, -21.7, -46.3, -22.1) # Region of interest.'
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
  zh: 'roi = (-46.8, -21.7, -46.3, -22.1) # 利益区域.'
- en: 'iex = (-48, -21, -46, -23) # Image extent.'
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
  zh: 'iex = (-48, -21, -46, -23) # 图像范围.'
- en: data = RasterData(elevation_data, shape=(2, 2))
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
  zh: data = RasterData(elevation_data, shape=(2, 2))
- en: data.crop_image(iex, roi).write_image(
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: data.crop_image(iex, roi).write_image(
- en: '''output/dem.tif'')'
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
  zh: '''output/dem.tif'')'
- en: This is very similar to what we did before, but the pipeline was simplified
    to combining the images and cropping and writing the results in the dem.tif file.
    It was chosen as a TIFF file, so the information isn’t lost due to data compression.
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们之前所做的是非常相似的，但是流程被简化为合并图像、裁剪并将结果写入 dem.tif 文件。它被选为 TIFF 文件，所以信息不会因为数据压缩而丢失。
- en: '2\. Run the code. Remember that because it’s a new file, you need to click
    on **Run** or press *Alt* + *Shift* + *F10* and choose raster_data. You should
    see an output telling you that everything went fine:'
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 运行代码。记住，因为它是一个新文件，你需要点击**运行**或按*Alt* + *Shift* + *F10*并选择 raster_data。你应该看到一个输出告诉你一切顺利：
- en: Process finished with exit code 0
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
  zh: 处理完成，退出代码 0
- en: From now on, we can use the prepared image in output/dem.tif for our tests.
    This is simply a matter of speeding up the process. What we are going to do could
    be done in any RasterData instance.
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在起，我们可以使用准备好的图像 output/dem.tif 进行测试。这仅仅是一个加快过程的问题。我们即将要做的事情可以在任何 RasterData
    实例中完成。
- en: If, by any reason, you couldn’t generate dem.tif, copy the one provided with
    the sample data to your output folder.
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
  zh: 如果由于任何原因，你无法生成 dem.tif，请将样本数据中提供的 dem.tif 复制到你的输出文件夹。
- en: '**Printing simple information**'
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
  zh: '**打印简单信息**'
- en: The first step for us to get some statistical output is to explore what NumPy
    has to offer.
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要获取一些统计输出的第一步是探索 NumPy 能提供什么。
- en: 'As we know, the data property of a RasterData instance is a NumPy array, so
    let’s see what we can get from it:'
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，RasterData 实例的数据属性是一个 NumPy 数组，那么让我们看看我们能从中得到什么：
- en: 1\. First, check whether everything is working so far. Clean the if __name__
    ==
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 首先，检查到目前为止是否一切正常。清理 if __name__ ==
- en: '''__main__'': block and add this new code:'
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: '''__main__'': 块并添加以下新代码：'
- en: 'if __name__ == ''__main__'':'
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == ''__main__'':'
- en: raster_data = RasterData('output/dem.tif')
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
  zh: raster_data = RasterData('output/dem.tif')
- en: print raster_data.data
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
  zh: 打印raster_data.data
- en: '2\. Run the code with *Shift* + *F10*. You should see this output:'
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 使用 *Shift* + *F10* 运行代码。你应该看到以下输出：
- en: '[[ 933 935 942…, 1077 1076 1078]'
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: '[[ 933 935 942…, 1077 1076 1078]'
- en: '[ 936 939 945…, 1075 1079 1076]'
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
  zh: '[ 936 939 945…, 1075 1079 1076]'
- en: '[ 935 939 946…, 1064 1072 1075]'
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: '[ 935 939 946…, 1064 1072 1075]'
- en: '...,'
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
  zh: '...,'
- en: '[ 780 781 781…, 1195 1193 1193]'
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
  zh: '[ 780 781 781…, 1195 1193 1193]'
- en: '[ 781 784 782…, 1191 1189 1188]'
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
  zh: '[ 781 784 782…, 1191 1189 1188]'
- en: '[ 781 784 785…, 1187 1185 1184]]'
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
  zh: '[ 781 784 785…, 1187 1185 1184]]'
- en: Process finished with exit code 0
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
  zh: 处理完成，退出代码为0
- en: This is the array containing the data in meters. NumPy automatically suppressed
    some rows and columns to make the output smaller. You see this output because
    a NumPy array has a __repr__ method that tells what is to be shown when the print
    function is called.
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
  zh: 这是包含数据的数组，单位为米。NumPy 自动抑制了一些行和列以减小输出大小。你看到这个输出是因为 NumPy 数组有一个 __repr__ 方法，它在调用
    print 函数时告诉应该显示什么。
- en: As we did before with the vector data, we will customize the __repr__ method
    of our class, so it outputs some information from the data in it.
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前对矢量数据所做的那样，我们将自定义类的 __repr__ 方法，以便输出其中数据的一些信息。
- en: 3\. Edit the RasterData class and insert the __repr__ method right after the
    __init__
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 编辑 RasterData 类并在 __init__ 方法之后插入 __repr__ 方法：
- en: 'method:'
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
  zh: 方法：
- en: 'class RasterData(object):'
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
  zh: 'class RasterData(object):'
- en: 'def __init__(self, input_data, unchanged=True, shape=None):'
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, input_data, unchanged=True, shape=None):'
- en: '...'
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: 'def __repr__(self):'
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __repr__(self):'
- en: return "Hi, I'm a raster data!"
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
  zh: return "Hi, 我是一个栅格数据！"
- en: '4\. Now, edit the if __name__ == ''__main__'': block and make it print the
    RasterData instance directly:'
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
  zh: '4. 现在，编辑 if __name__ == ''__main__'': 块并直接打印 RasterData 实例：'
- en: 'if __name__ == ''__main__'':'
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == ''__main__'':'
- en: raster_data = RasterData('output/dem.tif')
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
  zh: raster_data = RasterData('output/dem.tif')
- en: print raster_data
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
  zh: print raster_data
- en: '5\. Run the code and see whether you get this output:'
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
  zh: 5. 运行代码并查看是否得到以下输出：
- en: Hi, I'm a raster data!
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
  zh: Hi, 我是一个栅格数据！
- en: Process finished with exit code 0
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
  zh: 处理完成，退出代码为0
- en: OK, nothing fancy here. It’s just to remember that __repr__ takes no arguments
    except the instance (self) and should return only a string. Also, the method’s
    position in the class makes no difference. We are placing it after the __init__
    method for organization.
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这里没有特别之处。这只是提醒大家，__repr__ 方法不接受任何参数（除了实例 self）并且应该只返回一个字符串。此外，该方法在类中的位置没有影响。我们将其放置在
    __init__ 方法之后是为了组织上的考虑。
- en: All the *magic* methods go together at the beginning of the class.
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 *魔法* 方法都在类的开头一起。
- en: Now that we have everything set, let’s explore the NumPy array in the data property.
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了一切，让我们探索数据属性中的 NumPy 数组。
- en: 'In order to avoid repetition, I’ll suppress the class’ declaration and the
    __init__ method in the code and replace it by #....'
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
  zh: '为了避免重复，我将抑制代码中的类声明和 __init__ 方法，并用 # 替换。'
- en: '1\. Edit the __repr__ method to look as follows:'
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 编辑 __repr__ 方法，使其看起来如下：
- en: '...'
  id: totrans-959
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '...'
- en: 'def __repr__(self):'
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __repr__(self):'
- en: 'if self.data is None:'
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
  zh: 'if self.data is None:'
- en: return "No data to display!"
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
  zh: return "没有数据可显示！"
- en: data = self.data
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
  zh: data = self.data
- en: 'min = "Min: {}".format(data.min())'
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
  zh: 'min = "最小值: {}".format(data.min())'
- en: 'mean = "Mean: {}".format(data.mean())'
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
  zh: 'mean = "平均值: {}".format(data.mean())'
- en: 'max = "Max: {}".format(data.max())'
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
  zh: 'max = "最大值: {}".format(data.max())'
- en: return "Hi, I'm a raster data!\n {} {} {}".format(
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
  zh: return "Hi, 我是一个栅格数据!\n {} {} {}".format(
- en: min, mean, max)
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
  zh: min, mean, max)
- en: The first thing is to avoid an exception if the data is empty (None). In this
    case, the method prints a nice message telling that the instance has no data.
    If the instance has data, then it prepares three strings with the minimum, mean,
    and maximum values by calling the respective methods. In the end, a string is
    formatted to contain all the information.
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，要避免数据为空（None）时抛出异常。在这种情况下，该方法打印一条友好的消息，说明实例没有数据。如果实例有数据，则通过调用相应的方法准备包含最小值、平均值和最大值的三个字符串。最后，一个字符串被格式化以包含所有信息。
- en: '2\. Run the code with *Shift* + *F10*. You should see this output: Hi, I''m
    a raster data!'
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 使用 *Shift* + *F10* 运行代码。你应该看到以下输出：Hi, 我是一个栅格数据！
- en: 'Min: 671 Mean: 1139.06559874 Max: 1798'
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
  zh: '最小值: 671 平均值: 1139.06559874 最大值: 1798'
- en: Process finished with exit code 0
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
  zh: 处理完成，退出代码为0
- en: That’s great! Now, we have some statistical information on our data.
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
  zh: 那太好了！现在，我们有一些关于我们数据的统计信息。
- en: But this code is clumsy and if we want to add or remove information returned
    from __repr__, we need to do a lot of editing. So, before we proceed on to obtaining
    more statistics, we will make a few changes and automate the process of formatting
    the information that we want to display.
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
  zh: 但此代码笨拙，如果我们想添加或删除从__repr__返回的信息，我们需要进行大量的编辑。因此，在我们继续获取更多统计数据之前，我们将进行一些更改并自动化我们想要显示的信息的格式化过程。
- en: '**Formatting the output information**'
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
  zh: '**格式化输出信息**'
- en: At this point, we are displaying three parameters in a simple string output.
    We want to improve this code, so we can easily add or remove parameters from the
    output.
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们正在以简单的字符串输出显示三个参数。我们想要改进这个代码，以便我们可以轻松地添加或删除输出中的参数。
- en: 'Before we modify the code, let’s think ahead and foresee that we may also need
    to output these statistics in other formats, for example:'
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们修改代码之前，让我们提前考虑我们可能还需要以其他格式输出这些统计数据，例如：
- en: To a file on the disk in a human-friendly format
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据以人类友好的格式保存到磁盘上的文件中
- en: To a file on the disk in a computer-friendly format, such as CSV or JSON
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
  zh: 以计算机友好的格式（如CSV或JSON）保存到磁盘上的文件中
- en: As parameters to be passed to the other function or method
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
  zh: 作为传递给其他函数或方法的参数
- en: 'So, a good way we can prepare the code to fulfill these requirements is to
    separate the statistic generation from the output as follows:'
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一种好的方法来准备代码以满足这些要求是将统计生成与输出分离，如下所示：
- en: '1\. First, separate the data verification from the __repr__ method. Create
    a new method to handle this task:'
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 首先，将数据验证从__repr__方法中分离出来。创建一个新的方法来处理这个任务：
- en: '...'
  id: totrans-983
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '...'
- en: 'def _check_data(self):'
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
  zh: 'def _check_data(self):'
- en: '"""Check if has data and if it''s a Numpy array."""'
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
  zh: '"""检查是否有数据以及它是否是Numpy数组。"""'
- en: 'if self.data is None:'
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
  zh: 'if self.data is None:'
- en: raise ValueError("No data defined.")
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
  zh: raise ValueError("未定义数据。")
- en: 'elif not isinstance(self.data, np.ndarray):'
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif not isinstance(self.data, np.ndarray):'
- en: raise TypeError("Wrong type of data.")
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
  zh: raise TypeError("数据类型错误。")
- en: The verification is more rigorous and it raises different types of exceptions
    for each possible failure. This makes the code mode useful and safe, because it
    allows error-handling to be done in the other functions and because it stops the
    program’s execution if the exception is not properly caught.
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
  zh: 验证更加严格，并且为每种可能的失败类型引发不同的异常。这使得代码模式既有用又安全，因为它允许在其他函数中执行错误处理，并且如果异常没有被正确捕获，它将停止程序的执行。
- en: '2\. Now, create a new method to calculate and collect the statistics that we
    have so far:'
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 现在，创建一个新的方法来计算和收集我们迄今为止所拥有的统计数据：
- en: '...'
  id: totrans-992
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '...'
- en: 'def _calculate_stats(self):'
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
  zh: 'def _calculate_stats(self):'
- en: '"""Calculate and return basic statistical information from the data.'
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
  zh: '"""从数据中计算并返回基本的统计信息。'
- en: '"""'
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: self._check_data()
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
  zh: self._check_data()
- en: data = self.data
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
  zh: data = self.data
- en: stats = {
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
  zh: stats = {
- en: '"Minimum": data.min(),'
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
  zh: '"最小值": data.min(),'
- en: '"Mean": data.mean(),'
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
  zh: '"平均值": data.mean(),'
- en: '"Maximum": data.max()}'
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
  zh: '"最大值": data.max()}'
- en: return stats
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
  zh: 返回stats
- en: 'Here, the statistics are stored in a dictionary for two reasons: it allows
    the items to have readable names (including accents and spaces if you wish) and
    it avoids name collisions.'
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，统计数据存储在字典中有两个原因：它允许项目具有可读的名称（包括如果您希望的话，重音符号和空格）并且它避免了名称冲突。
- en: Finally, it lets us prepare a human-readable output with the statistics calculated.
    For this, we will use the tabulate module.
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，它让我们准备一个包含计算出的统计信息的可读输出。为此，我们将使用tabulate模块。
- en: '3\. Insert this import at the beginning of the file:'
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 在文件开头插入此导入：
- en: coding=utf-8
  id: totrans-1006
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: coding=utf-8
- en: import cv2
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
  zh: 导入cv2库
- en: import numpy as np
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
  zh: import numpy as np
- en: from tabulate import tabulate
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
  zh: from tabulate import tabulate
- en: '4\. Add this new method:'
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
  zh: 4. 添加这个新方法：
- en: '...'
  id: totrans-1011
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '...'
- en: 'def _format_stats(self, stats, out_format=''human''):'
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
  zh: 'def _format_stats(self, stats, out_format=''human''):'
- en: '"""Format the statistical data in a given output format.'
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
  zh: '"""以给定的输出格式格式化统计数据。'
- en: ':param out_format: ''human'' or ''csv'''
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
  zh: ':param out_format: ''human'' 或 ''csv'''
- en: '"""'
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: table = []
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
  zh: table = []
- en: 'for key, value in stats.iteritems():'
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
  zh: 'for key, value in stats.iteritems():'
- en: table.append([key, value])
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
  zh: table.append([key, value])
- en: return tabulate(table)
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
  zh: 返回tabulate(table)
- en: The tabulate function takes a list of lists representing a table. It then prepares
    a string containing a well-formatted table with this data.
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
  zh: tabulate函数接受一个列表的列表，表示一个表格。然后它准备一个包含格式良好的表格字符串，其中包含这些数据。
- en: '5\. Finally, edit the __repr__ method:'
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
  zh: 5. 最后，编辑__repr__方法：
- en: '...'
  id: totrans-1022
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '...'
- en: 'def __repr__(self):'
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __repr__(self):'
- en: stats = self._calculate_stats()
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
  zh: stats = self._calculate_stats()
- en: stats = self._format_stats(stats)
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
  zh: stats = self._format_stats(stats)
- en: 'return "Raster data - basic statistics.\n {}".format(stats) 6\. Now, run the
    code again with *Shift* + *F10*. You should see this output: Raster data - basic
    statistics.'
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
  zh: return "栅格数据 - 基本统计。\n {}".format(stats) 6. 现在，再次使用 *Shift* + *F10* 运行代码。你应该看到以下输出：栅格数据
    - 基本统计。
- en: '------- -------'
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
  zh: '------- -------'
- en: Minimum 671
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
  zh: 最小值 671
- en: Maximum 1798
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
  zh: 最大值 1798
- en: Mean 1139.07
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
  zh: 平均值 1139.07
- en: '------- -------'
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
  zh: '------- -------'
- en: Process finished with exit code 0
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
  zh: 进程已退出，退出代码为 0
- en: The presentation is much better now. If we want to add or remove elements, we
    just need to edit the dictionary in the _calculate_stats method.
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
  zh: 现在演示效果更好了。如果我们想添加或删除元素，我们只需编辑 _calculate_stats 方法中的字典。
- en: '**Calculating quartiles, histograms, and other** **statistics**'
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
  zh: '**计算四分位数、直方图和其他统计信息**'
- en: 'We have the minimum, maximum, and mean values for our data. In our case, it
    is the minimum, maximum, and mean elevation of the given region. In the next few
    steps, we will obtain more information from our data:'
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有了数据的最小值、最大值和平均值。在我们的案例中，这是给定区域的最小值、最大值和平均值。在接下来的几个步骤中，我们将从数据中获得更多信息：
- en: '1\. Edit the _calculate_stats method, adding more items to the dictionary:'
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 编辑 _calculate_stats 方法，向字典中添加更多项：
- en: '...'
  id: totrans-1037
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '...'
- en: 'def _calculate_stats(self):'
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
  zh: 'def _calculate_stats(self):'
- en: '"""Calculate and return basic statistical information from the data.'
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
  zh: '"""从数据中计算并返回基本统计信息。'
- en: '"""'
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: self._check_data()
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
  zh: self._check_data()
- en: data = self.data
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
  zh: data = self.data
- en: stats = {
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
  zh: stats = {
- en: '"Minimum": data.min(),'
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
  zh: '"最小值": data.min(),'
- en: '"Mean": data.mean(),'
  id: totrans-1045
  prefs: []
  type: TYPE_NORMAL
  zh: '"平均值": data.mean(),'
- en: '"Maximum": data.max(),'
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
  zh: '"最大值": data.max(),'
- en: '"Q1": np.percentile(data, 25),'
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
  zh: '"Q1": np.percentile(data, 25),'
- en: '"Median": np.median(data),'
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
  zh: '"中位数": np.median(data),'
- en: '"Q3": np.percentile(data, 75),'
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
  zh: '"Q3": np.percentile(data, 75),'
- en: '"Variance": data.var(),'
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
  zh: '"方差": data.var(),'
- en: '"Histogram": np.histogram(data)'
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
  zh: '"直方图": np.histogram(data)'
- en: '}'
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: return stats
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
  zh: return stats
- en: You can add any value to the dictionary. Maybe, you can obtain it from a NumPy
    function or method or from a function developed by you.
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以向字典中添加任何值。也许，你可以从 NumPy 函数或方法或从你自己开发的功能中获取它。
- en: '**Note**'
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: You can find more information on NumPy statistics in
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [NumPy 统计](http://docs.scipy.org/doc/numpy/reference/routines.statistics.html)
    中找到更多信息。
- en: '[http://docs.scipy.org/doc/numpy/reference/routines.statistics.html](http://docs.scipy.org/doc/numpy/reference/routines.statistics.html)
    and'
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
  zh: '[NumPy 数组方法](http://docs.scipy.org/doc/numpy/reference/arrays.ndarray.html#array-methods)
    和'
- en: '[http://docs.scipy.org/doc/numpy/reference/arrays.ndarray.html#array-methods](http://docs.scipy.org/doc/numpy/reference/arrays.ndarray.html#array-methods).'
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
  zh: '[NumPy 数组方法](http://docs.scipy.org/doc/numpy/reference/arrays.ndarray.html#array-methods)。'
- en: '2\. Run the code with *Shift* + *F10*. You should get more values as the output:
    Raster data - basic statistics.'
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 使用 *Shift* + *F10* 运行代码。你应该得到更多值作为输出：栅格数据 - 基本统计。
- en: '---------'
  id: totrans-1060
  prefs: []
  type: TYPE_NORMAL
  zh: '---------'
- en: Q1 992.0
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
  zh: Q1 992.0
- en: Q3 1303.0
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
  zh: Q3 1303.0
- en: Minimum 671
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
  zh: 最小值 671
- en: Variance 37075.0925323
  id: totrans-1064
  prefs: []
  type: TYPE_NORMAL
  zh: 方差 37075.0925323
- en: Histogram (array([ 83917, 254729, ..., 44225, 8279, 2068]), array([ 671\. ,
    783.7, ..., 1685.3, 1798.]))
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
  zh: 直方图 (array([ 83917, 254729, ..., 44225, 8279, 2068]), array([ 671. , 783.7,
    ..., 1685.3, 1798.]))
- en: Median 1140.0
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
  zh: 中位数 1140.0
- en: Maximum 1798
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
  zh: 最大值 1798
- en: Mean 1139.06559874
  id: totrans-1068
  prefs: []
  type: TYPE_NORMAL
  zh: 平均值 1139.06559874
- en: '--------- ---------------'
  id: totrans-1069
  prefs: []
  type: TYPE_NORMAL
  zh: '--------- ---------------'
- en: Process finished with exit code 0
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
  zh: 进程已退出，退出代码为 0
- en: 'Note in the output that the histogram is composed of two arrays: one containing
    the number of occurrences and the other containing the top limit for each bin.
    Since we are dealing with geographic data, it would be better if this information
    came translated into the amount of area for each interval.'
  id: totrans-1071
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到输出中的直方图由两个数组组成：一个包含每个桶中发生的次数，另一个包含每个桶的上限。由于我们处理的是地理数据，如果这些信息被转换成每个区间的面积，会更好。
- en: To do this, we just need to multiply the number of currencies (the number of
    pixels within a given range) by the area represented by each pixel. We will get
    to this after we prepare a few things in the next topics.
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们只需将货币数量（给定范围内的像素数量）乘以每个像素表示的区域。我们将在下一节准备一些事情之后做到这一点。
- en: '**Making statistics a lazy property**'
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
  zh: '**将统计信息做成延迟属性**'
- en: Our statistics is working fine and we will make an improvement now. Instead
    of calculating the statistics that we need all the time, we will calculate it
    only once and only when it’s needed for the first time.
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的统计功能现在运行良好，我们将对其进行改进。我们不再需要每次都计算所需的统计信息，而是一次性计算，并且仅在第一次需要时计算。
- en: 'We will use two very useful programming techniques: **lazy evaluation** and
    **memoization**.'
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用两种非常有用的编程技术：**延迟评估**和**记忆化**。
- en: Lazy evaluation is when a process or calculation is delayed and only performed
    when needed. Memoization is when the results of an expensive process are stored
    for later use to avoid them being recalculated every time we may need them.
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
  zh: 懒加载是在过程或计算被延迟，并且仅在需要时才执行。记忆化是在昂贵过程的结果被存储以供以后使用，以避免每次可能需要时都重新计算。
- en: 'Let’s see how it works:'
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它是如何工作的：
- en: '1\. Add a new _stats property to the __init__ method:'
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. 在 __init__ 方法中添加一个新的 _stats 属性：
- en: 'class RasterData(object):'
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
  zh: 'class RasterData(object):'
- en: 'def __init__(self, input_data, unchanged=True, shape=None):'
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, input_data, unchanged=True, shape=None):'
- en: '"""Represents a raster data in the form of an array.'
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
  zh: '"""表示为数组的栅格数据。'
- en: ':param input_data: Raster files or Numpy array.'
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
  zh: ':param input_data: 栅格文件或NumPy数组。'
- en: ':param unchanged: True to keep the original format.'
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
  zh: ':param unchanged: 如果为True，则保持原始格式。'
- en: ':param shape: When using multiple input data, this param'
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
  zh: ':param shape: 当使用多个输入数据时，此参数'
- en: determines the shape of the composition.
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
  zh: 确定组合的形状。
- en: '"""'
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: self.data = None
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
  zh: self.data = None
- en: self._stats = None
  id: totrans-1088
  prefs: []
  type: TYPE_NORMAL
  zh: self._stats = None
- en: if isinstance(input_data, list) \
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
  zh: if isinstance(input_data, list) \
- en: 'or isinstance(input_data, tuple):'
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
  zh: '或 isinstance(input_data, tuple):'
- en: self.combine_images(input_data, shape)
  id: totrans-1091
  prefs: []
  type: TYPE_NORMAL
  zh: self.combine_images(input_data, shape)
- en: 'else:'
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: self.import_data(input_data, unchanged)
  id: totrans-1093
  prefs: []
  type: TYPE_NORMAL
  zh: self.import_data(input_data, unchanged)
- en: The property name starts with an underscore. Remember that this notation shows
    that the property should only be accessed from the instance itself. This property
    will work as a cache to store the statistics.
  id: totrans-1094
  prefs: []
  type: TYPE_NORMAL
  zh: 属性名以下划线开头。请记住，这种表示法表明该属性只能从实例本身访问。此属性将作为缓存来存储统计数据。
- en: '2\. Now add a property method that will return the statistics:'
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. 现在添加一个返回统计信息的属性方法：
- en: '#...'
  id: totrans-1096
  prefs: []
  type: TYPE_NORMAL
  zh: '#...'
- en: '@property'
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
  zh: '@property'
- en: 'def stats(self):'
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
  zh: 'def stats(self):'
- en: 'if self._stats is None:'
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
  zh: 'if self._stats is None:'
- en: self._stats = self._calculate_stats()
  id: totrans-1100
  prefs: []
  type: TYPE_NORMAL
  zh: self._stats = self._calculate_stats()
- en: return self._stats
  id: totrans-1101
  prefs: []
  type: TYPE_NORMAL
  zh: return self._stats
- en: When this property is accessed, it verifies that if _stats is None. If so, it
    calculates the statistics and stores the results into _stats. The next time we
    need it, it only returns what’s stored.
  id: totrans-1102
  prefs: []
  type: TYPE_NORMAL
  zh: 当访问此属性时，它将验证如果 _stats 为None。如果是，则计算统计数据并将结果存储到 _stats 中。下次需要时，它只返回存储的内容。
- en: Making a property lazy and adding memoization to it is important when the process
    to obtain this information is costly. The processing power and time is used only
    once when the given property is needed.
  id: totrans-1103
  prefs: []
  type: TYPE_NORMAL
  zh: 当获取此信息的过程成本较高时，使属性延迟评估并添加记忆化非常重要。只有在需要给定属性时，才会使用处理能力和时间。
- en: '3\. Now, change the __repr__ method to use this new functionality:'
  id: totrans-1104
  prefs: []
  type: TYPE_NORMAL
  zh: 3\. 现在，将 __repr__ 方法更改为使用此新功能：
- en: '...'
  id: totrans-1105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '...'
- en: 'def __repr__(self):'
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __repr__(self):'
- en: stats = self._format_stats(self.stats)
  id: totrans-1107
  prefs: []
  type: TYPE_NORMAL
  zh: stats = self._format_stats(self.stats)
- en: return "Raster data basic statistics.\n {}".format(stats)
  id: totrans-1108
  prefs: []
  type: TYPE_NORMAL
  zh: return "Raster data basic statistics.\n {}".format(stats)
- en: '**Creating color classified images**'
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
  zh: '**创建颜色分类图像**'
- en: 'If we want to display image information on a map, we must prepare a visual
    output of what we got. A common and efficient form of visual representation is
    to separate values into classes and give each class a different color. In our
    case, we can split the data into altitude classes. NumPy makes it easy for us.
    Let’s write a method that can be called in the pipeline to get started:'
  id: totrans-1110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在地图上显示图像信息，我们必须准备我们得到的结果的视觉输出。一种常见且高效的视觉表示形式是将值分为类别，并为每个类别分配不同的颜色。在我们的情况下，我们可以将数据分为高度类别。NumPy使我们很容易做到这一点。让我们编写一个可以在管道中调用的方法来开始：
- en: '1\. Add a new method to the RasterData class:'
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. 在 RasterData 类中添加一个新的方法：
- en: '#...'
  id: totrans-1112
  prefs: []
  type: TYPE_NORMAL
  zh: '#...'
- en: 'def colorize(self, style):'
  id: totrans-1113
  prefs: []
  type: TYPE_NORMAL
  zh: 'def colorize(self, style):'
- en: '"""Produces an BGR image based on a style containing limits and colors.'
  id: totrans-1114
  prefs: []
  type: TYPE_NORMAL
  zh: '"""基于包含限制和颜色的样式生成BGR图像。'
- en: ':param style: A list of limits and colors.'
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
  zh: ':param style: 包含限制和颜色的列表。'
- en: '"""'
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: shape = self.data.shape
  id: totrans-1117
  prefs: []
  type: TYPE_NORMAL
  zh: shape = self.data.shape
- en: limits = []
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
  zh: limits = []
- en: colors = []
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
  zh: colors = []
- en: Separate the limits and colors.
  id: totrans-1120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分离限制和颜色。
- en: 'for item in style:'
  id: totrans-1121
  prefs: []
  type: TYPE_NORMAL
  zh: 'for item in style:'
- en: limits.append(item[0])
  id: totrans-1122
  prefs: []
  type: TYPE_NORMAL
  zh: limits.append(item[0])
- en: colors.append(self._convert_color(item[1]))
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
  zh: colors.append(self._convert_color(item[1]))
- en: colors = np.array(colors)
  id: totrans-1124
  prefs: []
  type: TYPE_NORMAL
  zh: colors = np.array(colors)
- en: Put each color in its limits.
  id: totrans-1125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将每种颜色放入其限制中。
- en: flat_array = self.data.flatten()
  id: totrans-1126
  prefs: []
  type: TYPE_NORMAL
  zh: flat_array = self.data.flatten()
- en: di_array = np.digitize(flat_array, limits)
  id: totrans-1127
  prefs: []
  type: TYPE_NORMAL
  zh: di_array = np.digitize(flat_array, limits)
- en: di_array = di_array.reshape((shape[0], shape[1], 1))
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
  zh: di_array = di_array.reshape((shape[0], shape[1], 1))
- en: results = np.choose(di_array, colors)
  id: totrans-1129
  prefs: []
  type: TYPE_NORMAL
  zh: results = np.choose(di_array, colors)
- en: Convert from RGB to BGR.
  id: totrans-1130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将RGB转换为BGR。
- en: results = np.asarray(results, dtype=np.uint8)
  id: totrans-1131
  prefs: []
  type: TYPE_NORMAL
  zh: results = np.asarray(results, dtype=np.uint8)
- en: results = cv2.cvtColor(results, cv2.COLOR_RGB2BGR)
  id: totrans-1132
  prefs: []
  type: TYPE_NORMAL
  zh: results = cv2.cvtColor(results, cv2.COLOR_RGB2BGR)
- en: self.data = results
  id: totrans-1133
  prefs: []
  type: TYPE_NORMAL
  zh: self.data = results
- en: return self
  id: totrans-1134
  prefs: []
  type: TYPE_NORMAL
  zh: return self
- en: In order to achieve what we want, two important things happen here. First, the
    data is indexed into classes by NumPy’s digitize function. Then, each class receives
    an RGB value with the defined color. This is done using the choose function.
  id: totrans-1135
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现我们的目标，这里发生了两个重要的事情。首先，数据通过NumPy的digitize函数索引到类别中。然后，每个类别都接收一个具有定义颜色的RGB值。这是使用choose函数完成的。
- en: 'This method takes a style as an argument. This style is a list of limits and
    colors, like a map legend. For example, the style can be defined as: style = [[700,
    "#f6eff7"],'
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法接受一个样式作为参数。这个样式是一个限制和颜色的列表，就像地图图例一样。例如，样式可以定义为：style = [[700, "#f6eff7"],
- en: '[900, "#bdc9e1"],'
  id: totrans-1137
  prefs: []
  type: TYPE_NORMAL
  zh: '[900, "#bdc9e1"],'
- en: '[1100, "#67a9cf"],'
  id: totrans-1138
  prefs: []
  type: TYPE_NORMAL
  zh: '[1100, "#67a9cf"],'
- en: '[1300, "#1c9099"],'
  id: totrans-1139
  prefs: []
  type: TYPE_NORMAL
  zh: '[1300, "#1c9099"],'
- en: '[1800, "#016c59"]]'
  id: totrans-1140
  prefs: []
  type: TYPE_NORMAL
  zh: '[1800, "#016c59"]]'
- en: This means that all the values below 700 will have the color "#f6eff7" and so
    on. The colors are expressed in hex notations. This notation is popular with web
    applications and is chosen here because it’s short and easy to type or copy.
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着所有低于700的值都将具有颜色 "#f6eff7"，等等。颜色以十六进制表示。这种表示法在Web应用中很受欢迎，在这里选择它是因为它简短且易于输入或复制。
- en: 'At this point, note that inside this method, we called the _convert_color method
    that will perform the conversion of the color notation. Let’s add this method
    to the class: 1\. Add the _convert_color method to the class:'
  id: totrans-1142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，请注意，在这个方法内部，我们调用了 _convert_color 方法，该方法将执行颜色表示法的转换。让我们将此方法添加到类中：1. 将 _convert_color
    方法添加到类中：
- en: '#...'
  id: totrans-1143
  prefs: []
  type: TYPE_NORMAL
  zh: '#...'
- en: 'def _convert_color(self, color_code):'
  id: totrans-1144
  prefs: []
  type: TYPE_NORMAL
  zh: 'def _convert_color(self, color_code):'
- en: '"""Converts the color notation.'
  id: totrans-1145
  prefs: []
  type: TYPE_NORMAL
  zh: '"""将颜色表示法进行转换。'
- en: ':param color_code: A string containing the color in hex'
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
  zh: ':param color_code: 包含十六进制颜色的字符串'
- en: or JavaScript notation.
  id: totrans-1147
  prefs: []
  type: TYPE_NORMAL
  zh: 或者JavaScript表示法。
- en: '"""'
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: 'if color_code[0] == "#":'
  id: totrans-1149
  prefs: []
  type: TYPE_NORMAL
  zh: 'if color_code[0] == "#":'
- en: result = (int(color_code[1:3], 16),
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
  zh: result = (int(color_code[1:3], 16),
- en: int(color_code[3:5], 16),
  id: totrans-1151
  prefs: []
  type: TYPE_NORMAL
  zh: int(color_code[3:5], 16),
- en: int(color_code[5:7], 16))
  id: totrans-1152
  prefs: []
  type: TYPE_NORMAL
  zh: int(color_code[5:7], 16))
- en: 'elif color_code[:3] == "rgb":'
  id: totrans-1153
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif color_code[:3] == "rgb":'
- en: result = map(int, color_code[4:-1].split(','))
  id: totrans-1154
  prefs: []
  type: TYPE_NORMAL
  zh: result = map(int, color_code[4:-1].split(','))
- en: 'else:'
  id: totrans-1155
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: raise ValueError("Invalid color code.")
  id: totrans-1156
  prefs: []
  type: TYPE_NORMAL
  zh: raise ValueError("Invalid color code.")
- en: return result
  id: totrans-1157
  prefs: []
  type: TYPE_NORMAL
  zh: return result
- en: '2\. Finally, edit the if __name__ == ''__main__'': block to test our code:
    if __name__ == ''__main__'':'
  id: totrans-1158
  prefs: []
  type: TYPE_NORMAL
  zh: '2. 最后，编辑 if __name__ == ''__main__'': 块以测试我们的代码：if __name__ == ''__main__'':'
- en: raster_data = RasterData('output/dem.tif')
  id: totrans-1159
  prefs: []
  type: TYPE_NORMAL
  zh: raster_data = RasterData('output/dem.tif')
- en: style = [[700, "#f6eff7"],
  id: totrans-1160
  prefs: []
  type: TYPE_NORMAL
  zh: style = [[700, "#f6eff7"],
- en: '[900, "#bdc9e1"],'
  id: totrans-1161
  prefs: []
  type: TYPE_NORMAL
  zh: '[900, "#bdc9e1"],'
- en: '[1100, "#67a9cf"],'
  id: totrans-1162
  prefs: []
  type: TYPE_NORMAL
  zh: '[1100, "#67a9cf"],'
- en: '[1300, "#1c9099"],'
  id: totrans-1163
  prefs: []
  type: TYPE_NORMAL
  zh: '[1300, "#1c9099"],'
- en: '[1800, "#016c59"]]'
  id: totrans-1164
  prefs: []
  type: TYPE_NORMAL
  zh: '[1800, "#016c59"]]'
- en: raster_data.colorize(style).write_image(
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
  zh: raster_data.colorize(style).write_image(
- en: '''output/classified.png'')'
  id: totrans-1166
  prefs: []
  type: TYPE_NORMAL
  zh: '''output/classified.png'')'
- en: '3\. Run the code and then open the output image to see the results:'
  id: totrans-1167
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 运行代码，然后打开输出图像以查看结果：
- en: '![Image 53](img/index-328_1.jpg)'
  id: totrans-1168
  prefs: []
  type: TYPE_IMG
  zh: '![Image 53](img/index-328_1.jpg)'
- en: '![Image 54](img/index-329_1.jpg)'
  id: totrans-1169
  prefs: []
  type: TYPE_IMG
  zh: '![Image 54](img/index-329_1.jpg)'
- en: '**Choosing the right colors for a map**'
  id: totrans-1170
  prefs: []
  type: TYPE_NORMAL
  zh: '**选择地图的正确颜色**'
- en: 'The choice of what colors to use in a map is one determining factor as to whether
    the map would be capable of correctly passing the desired information. In order
    to choose a good set of colors, some factors should be considered:'
  id: totrans-1171
  prefs: []
  type: TYPE_NORMAL
  zh: 在地图中使用什么颜色是决定地图能否正确传递所需信息的一个决定性因素。为了选择一组好的颜色，应考虑以下因素：
- en: The ability of the human eye to distinguish hues—the classes need to be visually
    distinguishable, otherwise the map may contain colors that may look the same to
    some people
  id: totrans-1172
  prefs: []
  type: TYPE_NORMAL
  zh: 人眼区分色调的能力——类别需要视觉上可区分，否则地图可能包含对某些人看起来相同颜色的颜色
- en: The media that the map will be presented on (for example, paper or screen)—
  id: totrans-1173
  prefs: []
  type: TYPE_NORMAL
  zh: 地图将展示的媒体（例如，纸张或屏幕）——
- en: depending on the media, the colors may suffer small changes that may compromise
    the readability of the map
  id: totrans-1174
  prefs: []
  type: TYPE_NORMAL
  zh: 根据媒体，颜色可能会发生轻微变化，这可能会损害地图的可读性
- en: Colorblind safety—this is an inclusion measure and it allows the information
    to be interpreted by a wider audience
  id: totrans-1175
  prefs: []
  type: TYPE_NORMAL
  zh: 色盲安全性——这是一个包含度量，它允许更广泛的受众解释信息
- en: The type of data (for example, sequential or qualitative)—use colors that match
    what you want to show
  id: totrans-1176
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类型（例如，顺序或定性）——使用与您想要展示的内容相匹配的颜色
- en: There are a number of studies on this subject and the ones made by Cynthia Brewer
    are very practical and popular among modern map makers. She produced an extensive
    set of colors to be used in maps and made this information available for use under
    the name of ColorBrewer.
  id: totrans-1177
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个主题有许多研究，Cynthia Brewer的研究非常实用且在现代地图制作者中很受欢迎。她制作了一套广泛用于地图的颜色，并以ColorBrewer的名义提供这些信息供使用。
- en: 'Let’s change the colors of our map with the help of ColorBrewer: 1\. Access
    the [http://colorbrewer2.org/](http://colorbrewer2.org/) website. You should see
    this interface:'
  id: totrans-1178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们借助ColorBrewer更改地图的颜色：1\. 访问[http://colorbrewer2.org/](http://colorbrewer2.org/)网站。您应该看到此界面：
- en: '![Image 55](img/index-330_1.jpg)'
  id: totrans-1179
  prefs: []
  type: TYPE_IMG
  zh: '![Image 55](img/index-330_1.jpg)'
- en: 2\. The left-hand side panel allows you to set the parameters to choose the
    color. At the top, change **Number of data classes** to **5** as in our data.
  id: totrans-1180
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. 左侧面板允许您设置选择颜色的参数。在顶部，将**数据类别数量**更改为**5**，如我们的数据所示。
- en: 3\. About the nature of our data, two options would go well, sequential or diverging.
    I will choose diverging for this example.
  id: totrans-1181
  prefs: []
  type: TYPE_NORMAL
  zh: 3\. 关于我们数据的特点，两种选项都很好，顺序或发散。我将为此示例选择发散。
- en: 4\. Before choosing a color scheme, if you wish, you can filter the schemes
    by **colorblind safe**, **print friendly** and **photocopy safe**.
  id: totrans-1182
  prefs: []
  type: TYPE_NORMAL
  zh: 4\. 在选择颜色方案之前，如果您愿意，可以通过**色盲安全**、**打印友好**和**复印安全**来过滤方案。
- en: 5\. Now, pick a color scheme that pleases you and note that the bottom right
    section of the panel and the map will change to show the colors of this scheme.
  id: totrans-1183
  prefs: []
  type: TYPE_NORMAL
  zh: 5\. 现在，选择一个您喜欢的颜色方案，并注意面板和地图的右下角将更改以显示此方案的颜色。
- en: '6\. Let’s export this scheme in a practical way to it use in our code. Click
    on the **EXPORT** tab just to the right of the colors. A new panel will open as
    follows: 7\. Note that the **JavaScript** box contains a list of RGB values. We
    can easily parse this information in our code. So, we will select its contents
    and copy it.'
  id: totrans-1184
  prefs: []
  type: TYPE_NORMAL
  zh: 6\. 让我们将此方案以实用方式导出，以便在代码中使用。单击颜色右侧的**导出**选项卡。将打开一个新面板，如下所示：7\. 注意**JavaScript**框中包含RGB值列表。我们可以在代码中轻松解析此信息。因此，我们将选择其内容并将其复制。
- en: '8\. Go back to our code and paste the colors to a variable named colorbrewer
    in the if __name__ == ''__main__'': block:'
  id: totrans-1185
  prefs: []
  type: TYPE_NORMAL
  zh: 8\. 返回我们的代码，并将颜色粘贴到名为colorbrewer的变量中，在if __name__ == '__main__':块中：
- en: 'if __name__ == ''__main__'':'
  id: totrans-1186
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == ''__main__'':'
- en: colorbrewer = ['rgb(202,0,32)','rgb(244,165,130)',
  id: totrans-1187
  prefs: []
  type: TYPE_NORMAL
  zh: colorbrewer = ['rgb(202,0,32)','rgb(244,165,130)',
- en: '''rgb(247,247,247)'',''rgb(146,197,222)'','
  id: totrans-1188
  prefs: []
  type: TYPE_NORMAL
  zh: '''rgb(247,247,247)'',''rgb(146,197,222)'','
- en: '''rgb(5,113,176)'']'
  id: totrans-1189
  prefs: []
  type: TYPE_NORMAL
  zh: '''rgb(5,113,176)'']'
- en: raster_data = RasterData('data/dem.tif')
  id: totrans-1190
  prefs: []
  type: TYPE_NORMAL
  zh: raster_data = RasterData('data/dem.tif')
- en: style = [[700, "#f6eff7"],
  id: totrans-1191
  prefs: []
  type: TYPE_NORMAL
  zh: style = [[700, "#f6eff7"],
- en: '[900, "#bdc9e1"],'
  id: totrans-1192
  prefs: []
  type: TYPE_NORMAL
  zh: '[900, "#bdc9e1"],'
- en: '[1100, "#67a9cf"],'
  id: totrans-1193
  prefs: []
  type: TYPE_NORMAL
  zh: '[1100, "#67a9cf"],'
- en: '[1300, "#1c9099"],'
  id: totrans-1194
  prefs: []
  type: TYPE_NORMAL
  zh: '[1300, "#1c9099"],'
- en: '[1800, "#016c59"]]'
  id: totrans-1195
  prefs: []
  type: TYPE_NORMAL
  zh: '[1800, "#016c59"]]'
- en: raster_data.colorize(style).write_image(
  id: totrans-1196
  prefs: []
  type: TYPE_NORMAL
  zh: raster_data.colorize(style).write_image(
- en: '''output/classified.png'')'
  id: totrans-1197
  prefs: []
  type: TYPE_NORMAL
  zh: '''output/classified.png'')'
- en: 'At this point, the style is not yet complete. There are two problems: the colors
    are in a format different from what we need and we don’t have the limits associated
    with them. Since we want the process to be as practical as possible, we will write
    the code to solve these two issues instead of manually converting the colors and
    associating them with the limits.'
  id: totrans-1198
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，样式尚未完成。存在两个问题：颜色格式与我们所需的不同，并且我们没有与它们相关的限制。由于我们希望过程尽可能实用，我们将编写代码来解决这两个问题，而不是手动转换颜色并将它们与限制相关联。
- en: First, let’s implement the capability of our program to accept colors and limits
    separately.
  id: totrans-1199
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们实现程序接受颜色和限制分开的能力。
- en: '9\. Put the limits that were in the style definition into a different list:
    if __name__ == ''__main__'':'
  id: totrans-1200
  prefs: []
  type: TYPE_NORMAL
  zh: '9\. 将样式定义中存在的限制放入不同的列表中：if __name__ == ''__main__'':'
- en: colorbrewer = ['rgb(202,0,32)','rgb(244,165,130)',
  id: totrans-1201
  prefs: []
  type: TYPE_NORMAL
  zh: colorbrewer = ['rgb(202,0,32)','rgb(244,165,130)',
- en: '''rgb(247,247,247)'',''rgb(146,197,222)'','
  id: totrans-1202
  prefs: []
  type: TYPE_NORMAL
  zh: '''rgb(247,247,247)'',''rgb(146,197,222)'','
- en: '''rgb(5,113,176)'']'
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
  zh: '''rgb(5,113,176)'']'
- en: limits = [700, 900, 1100, 1300, 1800]
  id: totrans-1204
  prefs: []
  type: TYPE_NORMAL
  zh: limits = [700, 900, 1100, 1300, 1800]
- en: raster_data = RasterData('data/dem.tif')
  id: totrans-1205
  prefs: []
  type: TYPE_NORMAL
  zh: raster_data = RasterData('data/dem.tif')
- en: 'raster_data.colorize(style).write_image(''output/classified.png'') 10\. Now
    edit the colorize method:'
  id: totrans-1206
  prefs: []
  type: TYPE_NORMAL
  zh: raster_data.colorize(style).write_image('output/classified.png') 10\. 现在编辑colorize方法：
- en: '#..'
  id: totrans-1207
  prefs: []
  type: TYPE_NORMAL
  zh: '#..'
- en: 'def colorize(self, limits, raw_colors):'
  id: totrans-1208
  prefs: []
  type: TYPE_NORMAL
  zh: 'def colorize(self, limits, raw_colors):'
- en: '"""Produces an BGR image based on a style containing limits and colors.'
  id: totrans-1209
  prefs: []
  type: TYPE_NORMAL
  zh: '"""基于包含限制和颜色的样式生成BGR图像。'
- en: ':param limits: A list of limits.'
  id: totrans-1210
  prefs: []
  type: TYPE_NORMAL
  zh: ':param limits: 一系列限制。'
- en: ':param raw_colors: A list of color codes. """'
  id: totrans-1211
  prefs: []
  type: TYPE_NORMAL
  zh: ':param raw_colors: 一系列颜色代码。"""'
- en: shape = self.data.shape
  id: totrans-1212
  prefs: []
  type: TYPE_NORMAL
  zh: shape = self.data.shape
- en: colors = []
  id: totrans-1213
  prefs: []
  type: TYPE_NORMAL
  zh: colors = []
- en: 'for item in raw_colors:'
  id: totrans-1214
  prefs: []
  type: TYPE_NORMAL
  zh: 'for item in raw_colors:'
- en: colors.append(self._convert_color(item))
  id: totrans-1215
  prefs: []
  type: TYPE_NORMAL
  zh: colors.append(self._convert_color(item))
- en: colors = np.array(colors)
  id: totrans-1216
  prefs: []
  type: TYPE_NORMAL
  zh: colors = np.array(colors)
- en: Put each color in its limits.
  id: totrans-1217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将每个颜色放入其限制中。
- en: flat_array = self.data.flatten()
  id: totrans-1218
  prefs: []
  type: TYPE_NORMAL
  zh: flat_array = self.data.flatten()
- en: di_array = np.digitize(flat_array, limits, right=True)
  id: totrans-1219
  prefs: []
  type: TYPE_NORMAL
  zh: di_array = np.digitize(flat_array, limits, right=True)
- en: di_array = di_array.reshape((shape[0], shape[1], 1))
  id: totrans-1220
  prefs: []
  type: TYPE_NORMAL
  zh: di_array = di_array.reshape((shape[0], shape[1], 1))
- en: results = np.choose(di_array, colors)
  id: totrans-1221
  prefs: []
  type: TYPE_NORMAL
  zh: results = np.choose(di_array, colors)
- en: Convert from RGB to BGR.
  id: totrans-1222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将RGB转换为BGR。
- en: results = np.asarray(results, dtype=np.uint8)
  id: totrans-1223
  prefs: []
  type: TYPE_NORMAL
  zh: results = np.asarray(results, dtype=np.uint8)
- en: results = cv2.cvtColor(results, cv2.COLOR_RGB2BGR)
  id: totrans-1224
  prefs: []
  type: TYPE_NORMAL
  zh: results = cv2.cvtColor(results, cv2.COLOR_RGB2BGR)
- en: self.data = results
  id: totrans-1225
  prefs: []
  type: TYPE_NORMAL
  zh: self.data = results
- en: return self
  id: totrans-1226
  prefs: []
  type: TYPE_NORMAL
  zh: return self
- en: This method now takes two arguments instead of just the style. The only task
    that remains is to convert this new color format.
  id: totrans-1227
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法现在接受两个参数而不是只有一个样式。唯一剩下的任务是将这种新的颜色格式转换过来。
- en: '11\. Edit the _convert_color method:'
  id: totrans-1228
  prefs: []
  type: TYPE_NORMAL
  zh: 11. 编辑 _convert_color 方法：
- en: '#...'
  id: totrans-1229
  prefs: []
  type: TYPE_NORMAL
  zh: '#...'
- en: 'def _convert_color(self, color_code):'
  id: totrans-1230
  prefs: []
  type: TYPE_NORMAL
  zh: 'def _convert_color(self, color_code):'
- en: '"""Converts the color notation.'
  id: totrans-1231
  prefs: []
  type: TYPE_NORMAL
  zh: '"""转换颜色表示法。'
- en: ':param color_code: A string containing the color in hex'
  id: totrans-1232
  prefs: []
  type: TYPE_NORMAL
  zh: ':param color_code: 包含十六进制颜色的字符串'
- en: or JavaScript notation.
  id: totrans-1233
  prefs: []
  type: TYPE_NORMAL
  zh: 或者使用 JavaScript 语法。
- en: '"""'
  id: totrans-1234
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: 'if color_code[0] == "#": result = (int(color_code[1:3], 16),'
  id: totrans-1235
  prefs: []
  type: TYPE_NORMAL
  zh: 'if color_code[0] == "#": result = (int(color_code[1:3], 16),'
- en: int(color_code[3:5], 16),
  id: totrans-1236
  prefs: []
  type: TYPE_NORMAL
  zh: int(color_code[3:5], 16),
- en: int(color_code[5:7], 16))
  id: totrans-1237
  prefs: []
  type: TYPE_NORMAL
  zh: int(color_code[5:7], 16))
- en: 'elif color_code[:3] == "rgb":'
  id: totrans-1238
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif color_code[:3] == "rgb":'
- en: result = map(int, color_code[4:-1].split(','))
  id: totrans-1239
  prefs: []
  type: TYPE_NORMAL
  zh: result = map(int, color_code[4:-1].split(','))
- en: 'else:'
  id: totrans-1240
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: raise ValueError("Invalid color code.")
  id: totrans-1241
  prefs: []
  type: TYPE_NORMAL
  zh: raise ValueError("Invalid color code.")
- en: return result
  id: totrans-1242
  prefs: []
  type: TYPE_NORMAL
  zh: return result
- en: This method is now able to detect and convert the two color codes that we use.
    It can also raise an exception in case the color code is not recognized.
  id: totrans-1243
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法现在能够检测和转换我们使用的两种颜色代码。如果颜色代码未被识别，它还可以引发异常。
- en: '12\. To test the code, edit the if __name__ == ''__main__'': block to be compliant
    with the new format:'
  id: totrans-1244
  prefs: []
  type: TYPE_NORMAL
  zh: '12. 为了测试代码，编辑 if __name__ == ''__main__'': 块以符合新的格式：'
- en: 'if __name__ == ''__main__'':'
  id: totrans-1245
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == ''__main__'':'
- en: raster_data = RasterData('output/dem.tif')
  id: totrans-1246
  prefs: []
  type: TYPE_NORMAL
  zh: raster_data = RasterData('output/dem.tif')
- en: colors = ['rgb(202,0,32)', 'rgb(244,165,130)',
  id: totrans-1247
  prefs: []
  type: TYPE_NORMAL
  zh: colors = ['rgb(202,0,32)', 'rgb(244,165,130)',
- en: '''rgb(247,247,247)'', ''rgb(146,197,222)'','
  id: totrans-1248
  prefs: []
  type: TYPE_NORMAL
  zh: '''rgb(247,247,247)'', ''rgb(146,197,222)'','
- en: '''rgb(5,113,176)'']'
  id: totrans-1249
  prefs: []
  type: TYPE_NORMAL
  zh: '''rgb(5,113,176)'']'
- en: limits = [700, 900, 1100, 1300, 1800]
  id: totrans-1250
  prefs: []
  type: TYPE_NORMAL
  zh: limits = [700, 900, 1100, 1300, 1800]
- en: raster_data.colorize(limits, colors).write_image(
  id: totrans-1251
  prefs: []
  type: TYPE_NORMAL
  zh: raster_data.colorize(limits, colors).write_image(
- en: '''output/classified.png'')'
  id: totrans-1252
  prefs: []
  type: TYPE_NORMAL
  zh: '''output/classified.png'')'
- en: '13\. Finally, run the code with *Shift* + *F10* and check the output. The schema
    I chose produced the following result:'
  id: totrans-1253
  prefs: []
  type: TYPE_NORMAL
  zh: 13. 最后，使用 *Shift* + *F10* 运行代码并检查输出。我选择的模式产生了以下结果：
- en: '![Image 56](img/index-333_1.jpg)'
  id: totrans-1254
  prefs: []
  type: TYPE_IMG
  zh: '![Image 56](img/index-333_1.jpg)'
- en: Despite the fact that this is a beautiful image, there is a mistake in the choice
    of colors. The warm colors are representing lower altitudes. This could lead to
    confusions, since on most maps, the rule is warmer the color, higher is the value.
  id: totrans-1255
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这是一张美丽的图片，但在颜色选择上存在错误。暖色调代表的是较低的海拔。这可能会导致混淆，因为在大多数地图上，规则是颜色越暖，数值越高。
- en: It’s only a mater of inverting the colors. Let’s add an option to our colorize
    method to do this.
  id: totrans-1256
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个反转颜色的问题。让我们在我们的 colorize 方法中添加一个选项来做这个。
- en: '14\. Edit the colorize method:'
  id: totrans-1257
  prefs: []
  type: TYPE_NORMAL
  zh: 14. 编辑 colorize 方法：
- en: '#...'
  id: totrans-1258
  prefs: []
  type: TYPE_NORMAL
  zh: '#...'
- en: 'def colorize(self, limits, raw_colors, invert_colors=False):'
  id: totrans-1259
  prefs: []
  type: TYPE_NORMAL
  zh: 'def colorize(self, limits, raw_colors, invert_colors=False):'
- en: '"""Produces an BGR image based on a style containing limits and colors.'
  id: totrans-1260
  prefs: []
  type: TYPE_NORMAL
  zh: '"""根据包含限制和颜色的样式生成 BGR 图像。'
- en: ':param limits: A list of limits.'
  id: totrans-1261
  prefs: []
  type: TYPE_NORMAL
  zh: ':param limits: 一个限制列表。'
- en: ':param raw_colors: A list of color codes.'
  id: totrans-1262
  prefs: []
  type: TYPE_NORMAL
  zh: ':param raw_colors: 一个颜色代码列表。'
- en: ':param invert_colors: Invert the order of the colors.'
  id: totrans-1263
  prefs: []
  type: TYPE_NORMAL
  zh: ':param invert_colors: 反转颜色顺序。'
- en: '"""'
  id: totrans-1264
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: shape = self.data.shape
  id: totrans-1265
  prefs: []
  type: TYPE_NORMAL
  zh: shape = self.data.shape
- en: colors = []
  id: totrans-1266
  prefs: []
  type: TYPE_NORMAL
  zh: colors = []
- en: 'if invert_colors:'
  id: totrans-1267
  prefs: []
  type: TYPE_NORMAL
  zh: 'if invert_colors:'
- en: raw_colors = list(reversed(raw_colors))
  id: totrans-1268
  prefs: []
  type: TYPE_NORMAL
  zh: raw_colors = list(reversed(raw_colors))
- en: Convert the colors.
  id: totrans-1269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转换颜色。
- en: '![Image 57](img/index-334_1.jpg)'
  id: totrans-1270
  prefs: []
  type: TYPE_IMG
  zh: '![Image 57](img/index-334_1.jpg)'
- en: 'for item in raw_colors:'
  id: totrans-1271
  prefs: []
  type: TYPE_NORMAL
  zh: 'for item in raw_colors:'
- en: colors.append(self._convert_color(item))
  id: totrans-1272
  prefs: []
  type: TYPE_NORMAL
  zh: colors.append(self._convert_color(item))
- en: colors = np.array(colors)
  id: totrans-1273
  prefs: []
  type: TYPE_NORMAL
  zh: colors = np.array(colors)
- en: Put each color in its limits.
  id: totrans-1274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将每种颜色放入其限制范围内。
- en: flat_array = self.data.flatten()
  id: totrans-1275
  prefs: []
  type: TYPE_NORMAL
  zh: flat_array = self.data.flatten()
- en: di_array = np.digitize(flat_array, limits, right=True)
  id: totrans-1276
  prefs: []
  type: TYPE_NORMAL
  zh: di_array = np.digitize(flat_array, limits, right=True)
- en: di_array = di_array.reshape((shape[0], shape[1], 1))
  id: totrans-1277
  prefs: []
  type: TYPE_NORMAL
  zh: di_array = di_array.reshape((shape[0], shape[1], 1))
- en: results = np.choose(di_array, colors)
  id: totrans-1278
  prefs: []
  type: TYPE_NORMAL
  zh: results = np.choose(di_array, colors)
- en: Convert from RGB to BGR.
  id: totrans-1279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 RGB 转换为 BGR。
- en: results = np.asarray(results, dtype=np.uint8)
  id: totrans-1280
  prefs: []
  type: TYPE_NORMAL
  zh: results = np.asarray(results, dtype=np.uint8)
- en: results = cv2.cvtColor(results, cv2.COLOR_RGB2BGR)
  id: totrans-1281
  prefs: []
  type: TYPE_NORMAL
  zh: results = cv2.cvtColor(results, cv2.COLOR_RGB2BGR)
- en: self.data = results
  id: totrans-1282
  prefs: []
  type: TYPE_NORMAL
  zh: self.data = results
- en: return self
  id: totrans-1283
  prefs: []
  type: TYPE_NORMAL
  zh: return self
- en: '15\. Now, edit the if __name__ == ''__main__'': block again:'
  id: totrans-1284
  prefs: []
  type: TYPE_NORMAL
  zh: '15. 现在，再次编辑 if __name__ == ''__main__'': 块：'
- en: 'if __name__ == ''__main__'':'
  id: totrans-1285
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == ''__main__'':'
- en: raster_data = RasterData('output/dem.tif')
  id: totrans-1286
  prefs: []
  type: TYPE_NORMAL
  zh: raster_data = RasterData('output/dem.tif')
- en: colors = ['rgb(202,0,32)', 'rgb(244,165,130)',
  id: totrans-1287
  prefs: []
  type: TYPE_NORMAL
  zh: colors = ['rgb(202,0,32)', 'rgb(244,165,130)',
- en: '''rgb(247,247,247)'', ''rgb(146,197,222)'','
  id: totrans-1288
  prefs: []
  type: TYPE_NORMAL
  zh: '''rgb(247,247,247)'', ''rgb(146,197,222)'','
- en: '''rgb(5,113,176)'']'
  id: totrans-1289
  prefs: []
  type: TYPE_NORMAL
  zh: '''rgb(5,113,176)'']'
- en: limits = [700, 900, 1100, 1300, 1800]
  id: totrans-1290
  prefs: []
  type: TYPE_NORMAL
  zh: limits = [700, 900, 1100, 1300, 1800]
- en: raster_data.colorize(limits, colors, True).write_image(
  id: totrans-1291
  prefs: []
  type: TYPE_NORMAL
  zh: raster_data.colorize(limits, colors, True).write_image(
- en: '''output/classified.png'')'
  id: totrans-1292
  prefs: []
  type: TYPE_NORMAL
  zh: '''output/classified.png'')'
- en: '16\. Run the code and look at the new output:'
  id: totrans-1293
  prefs: []
  type: TYPE_NORMAL
  zh: 16. 运行代码并查看新的输出：
- en: '**Blending images**'
  id: totrans-1294
  prefs: []
  type: TYPE_NORMAL
  zh: '**图像混合**'
- en: We can make our results even more visually appealing and informative if we can
    combine the colorized image with the shaded relief image. Again, since we are
    dealing with arrays, we may deduce that this kind of composition can be achieved
    by performing an arithmetic operation between the two arrays.
  id: totrans-1295
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能够将着色图像与阴影高程图像结合起来，我们的结果将更加具有视觉吸引力和信息量。同样，由于我们处理的是数组，我们可以推断出这种组合可以通过在两个数组之间执行算术运算来实现。
- en: 'In image processing, this is called **alpha blending**. Basically, a *transparency*
    is applied to both of the images and then they are blended into a new one. In
    the next steps, we are going to create a function that performs this operation:'
  id: totrans-1296
  prefs: []
  type: TYPE_NORMAL
  zh: 在图像处理中，这被称为**alpha混合**。基本上，对两个图像都应用了透明度，然后它们被混合成一个新的图像。在接下来的步骤中，我们将创建一个执行此操作的功能：
- en: '1\. First, to avoid generating the shaded relief multiple times, let’s save
    it on the disk and edit the if __name__ == ''__main__'': block of the raster_data.py
    file: if __name__ == ''__main__'':'
  id: totrans-1297
  prefs: []
  type: TYPE_NORMAL
  zh: '1. 首先，为了避免多次生成阴影高程，让我们将其保存在磁盘上，并编辑raster_data.py文件的if __name__ == ''__main__'':块：if
    __name__ == ''__main__'':'
- en: raster_data = RasterData('output/dem.tif')
  id: totrans-1298
  prefs: []
  type: TYPE_NORMAL
  zh: raster_data = RasterData('output/dem.tif')
- en: raster_data.adjust_values().create_hillshade(
  id: totrans-1299
  prefs: []
  type: TYPE_NORMAL
  zh: raster_data.adjust_values().create_hillshade(
- en: 10, 60).write_image('output/shaded.png')
  id: totrans-1300
  prefs: []
  type: TYPE_NORMAL
  zh: 10, 60).write_image('output/shaded.png')
- en: 2\. Run the code and check whether the image was correctly written on the disk.
  id: totrans-1301
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 运行代码并检查图像是否正确写入磁盘。
- en: '3\. Now, add the alpha_blend method to the RasterData class:'
  id: totrans-1302
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 现在，将alpha_blend方法添加到RasterData类中：
- en: '#...'
  id: totrans-1303
  prefs: []
  type: TYPE_NORMAL
  zh: '#...'
- en: 'def alpha_blend(self, raster_data, alpha=0.5):'
  id: totrans-1304
  prefs: []
  type: TYPE_NORMAL
  zh: 'def alpha_blend(self, raster_data, alpha=0.5):'
- en: '"""Blend this raster data with another one.'
  id: totrans-1305
  prefs: []
  type: TYPE_NORMAL
  zh: '"""将此栅格数据与另一个数据合并。'
- en: ':param raster_data: RasterData instance.'
  id: totrans-1306
  prefs: []
  type: TYPE_NORMAL
  zh: ':param raster_data: RasterData实例。'
- en: ':param alpha: Amount of transparency to apply.'
  id: totrans-1307
  prefs: []
  type: TYPE_NORMAL
  zh: ':param alpha: 应用透明度的量。'
- en: '"""'
  id: totrans-1308
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: shade = cv2.cvtColor(raster_data.data, cv2.COLOR_GRAY2BGR)
  id: totrans-1309
  prefs: []
  type: TYPE_NORMAL
  zh: shade = cv2.cvtColor(raster_data.data, cv2.COLOR_GRAY2BGR)
- en: result = (1-alpha) * self.data + alpha * shade
  id: totrans-1310
  prefs: []
  type: TYPE_NORMAL
  zh: result = (1-alpha) * self.data + alpha * shade
- en: self.data = result
  id: totrans-1311
  prefs: []
  type: TYPE_NORMAL
  zh: self.data = result
- en: return self
  id: totrans-1312
  prefs: []
  type: TYPE_NORMAL
  zh: return self
- en: '4\. Finally, edit the if __name__ == ''__main__'': block again to test the
    code: if __name__ == ''__main__'':'
  id: totrans-1313
  prefs: []
  type: TYPE_NORMAL
  zh: '4. 最后，再次编辑if __name__ == ''__main__'':块以测试代码：if __name__ == ''__main__'':'
- en: shaded = RasterData('output/shaded.png')
  id: totrans-1314
  prefs: []
  type: TYPE_NORMAL
  zh: shaded = RasterData('output/shaded.png')
- en: classified = RasterData('output/classified.png')
  id: totrans-1315
  prefs: []
  type: TYPE_NORMAL
  zh: classified = RasterData('output/classified.png')
- en: classified.alpha_blend(shaded).write_image(
  id: totrans-1316
  prefs: []
  type: TYPE_NORMAL
  zh: classified.alpha_blend(shaded).write_image(
- en: '''output/color_shade.png'')'
  id: totrans-1317
  prefs: []
  type: TYPE_NORMAL
  zh: '''output/color_shade.png'')'
- en: '5\. Run the code and check the image in the output folder:'
  id: totrans-1318
  prefs: []
  type: TYPE_NORMAL
  zh: 5. 运行代码并检查输出文件夹中的图像：
- en: '![Image 58](img/index-338_1.jpg)'
  id: totrans-1319
  prefs: []
  type: TYPE_IMG
  zh: '![图像 58](img/index-338_1.jpg)'
- en: You should see this beautiful output. Note how the combination of the shaded
    relief with the colorized image produces a map that transmits a lot of information
    even for untrained eyes.
  id: totrans-1320
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到这个美丽的输出。注意阴影高程与着色图像的结合如何产生一个即使对于未经训练的眼睛也能传达大量信息的地图。
- en: '![Image 59](img/index-340_1.jpg)'
  id: totrans-1321
  prefs: []
  type: TYPE_IMG
  zh: '![图像 59](img/index-340_1.jpg)'
- en: '**Showing statistics with colors**'
  id: totrans-1322
  prefs: []
  type: TYPE_NORMAL
  zh: '**用颜色显示统计数据**'
- en: How the map is colorized is only a matter of defining the limits and colors
    in the style. So, if we want to translate statistical information into colors,
    we just need to associate the values that we want with a sequence of colors.
  id: totrans-1323
  prefs: []
  type: TYPE_NORMAL
  zh: 地图着色仅是定义样式中的限制和颜色的问题。因此，如果我们想将统计信息转换为颜色，我们只需将我们想要的值与一系列颜色关联起来。
- en: 'First, let’s try it with the quartiles:'
  id: totrans-1324
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们用四分位数来尝试：
- en: '1\. Since everything is prepared in our class, we just need to change the code
    in the if __name__ == ''__main__'': block:'
  id: totrans-1325
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 由于所有准备工作都在我们的课程中完成，我们只需要更改if __name__ == '__main__':块中的代码：
- en: 'if __name__ == ''__main__'':'
  id: totrans-1326
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == ''__main__'':'
- en: dem = RasterData('output/dem.tif')
  id: totrans-1327
  prefs: []
  type: TYPE_NORMAL
  zh: dem = RasterData('output/dem.tif')
- en: shaded = RasterData('output/shaded.png')
  id: totrans-1328
  prefs: []
  type: TYPE_NORMAL
  zh: shaded = RasterData('output/shaded.png')
- en: limits = [dem.stats['Q1'],
  id: totrans-1329
  prefs: []
  type: TYPE_NORMAL
  zh: limits = [dem.stats['Q1'],
- en: dem.stats['Q3'],
  id: totrans-1330
  prefs: []
  type: TYPE_NORMAL
  zh: dem.stats['Q3'],
- en: dem.stats['Maximum']]
  id: totrans-1331
  prefs: []
  type: TYPE_NORMAL
  zh: dem.stats['Maximum']]
- en: colors = ["#fc8d59", "#ffffbf", "#91cf60"]
  id: totrans-1332
  prefs: []
  type: TYPE_NORMAL
  zh: colors = ["#fc8d59", "#ffffbf", "#91cf60"]
- en: 'dem.colorize(limits, colors).write_image(''output/stats.png'') dem.alpha_blend(shaded).write_image(''output/shaded_stats.png'')
    The following image illustrates the colored output for the analyzed parameters:'
  id: totrans-1333
  prefs: []
  type: TYPE_NORMAL
  zh: dem.colorize(limits, colors).write_image('output/stats.png') dem.alpha_blend(shaded).write_image('output/shaded_stats.png')
    以下图像展示了分析参数的彩色输出：
- en: '![Image 60](img/index-341_1.jpg)'
  id: totrans-1334
  prefs: []
  type: TYPE_IMG
  zh: '![图像 60](img/index-341_1.jpg)'
- en: 'For this image you can start the lead-in this way:'
  id: totrans-1335
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这张图像，你可以这样开始引导：
- en: '**Using the histogram to colorize the image** We can also use the histogram
    to colorize the maps. The histogram generated by NumPy is composed of two one-dimensional
    arrays. The first contains the number of occurrences in a given interval (that
    is, the number of pixels). The second one contains the *bins* or the limits. By
    default, the histogram is produced with 11 bins, so we also need 11 different
    colors to produce a map. Let’s change our tests to see how this works: 1\. Edit
    the if __name__ == ''__main__'': block:'
  id: totrans-1336
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用直方图对图像进行着色** 我们还可以使用直方图对地图进行着色。NumPy生成的直方图由两个一维数组组成。第一个包含给定区间内的发生次数（即像素数量）。第二个包含*桶*或限制。默认情况下，直方图使用11个桶，因此我们还需要11种不同的颜色来生成地图。让我们改变我们的测试来看看这是如何工作的：1.
    编辑if __name__ == ''__main__'':块：'
- en: 'if __name__ == ''__main__'':'
  id: totrans-1337
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == ''__main__'':'
- en: dem = RasterData('data/dem.tif')
  id: totrans-1338
  prefs: []
  type: TYPE_NORMAL
  zh: dem = RasterData('data/dem.tif')
- en: shaded = RasterData('output/shaded.png')
  id: totrans-1339
  prefs: []
  type: TYPE_NORMAL
  zh: shaded = RasterData('output/shaded.png')
- en: colors = ['rgb(103,0,31)','rgb(178,24,43)','rgb(214,96,77)',
  id: totrans-1340
  prefs: []
  type: TYPE_NORMAL
  zh: colors = ['rgb(103,0,31)','rgb(178,24,43)','rgb(214,96,77)',
- en: '''rgb(244,165,130)'',''rgb(253,219,199)'','
  id: totrans-1341
  prefs: []
  type: TYPE_NORMAL
  zh: '''rgb(244,165,130)'',''rgb(253,219,199)'','
- en: '''rgb(247,247,247)'',''rgb(209,229,240)'','
  id: totrans-1342
  prefs: []
  type: TYPE_NORMAL
  zh: '''rgb(247,247,247)'',''rgb(209,229,240)'','
- en: '''rgb(146,197,222)'',''rgb(67,147,195)'','
  id: totrans-1343
  prefs: []
  type: TYPE_NORMAL
  zh: '''rgb(146,197,222)'',''rgb(67,147,195)'','
- en: '''rgb(33,102,172)'',''rgb(5,48,97)'']'
  id: totrans-1344
  prefs: []
  type: TYPE_NORMAL
  zh: '''rgb(33,102,172)'',''rgb(5,48,97)'']'
- en: limits = dem.stats['Histogram'][1]
  id: totrans-1345
  prefs: []
  type: TYPE_NORMAL
  zh: limits = dem.stats['Histogram'][1]
- en: dem.colorize(limits, colors, True).write_image('output/hist.png') dem.alpha_blend(shaded).write_image('output/shaded_hist.png')
    The colors here are also obtained from ColorBrewer. They are of a diverging nature
    from red to blue. The limits were taken from the histogram by simply using the
    stats property and the second array, which contains the bins.
  id: totrans-1346
  prefs: []
  type: TYPE_NORMAL
  zh: dem.colorize(limits, colors, True).write_image('output/hist.png') dem.alpha_blend(shaded).write_image('output/shaded_hist.png')
    这里使用的颜色也来自ColorBrewer。它们从红色到蓝色具有发散性质。限制是通过简单地使用stats属性和包含桶的第二个数组从直方图中获得的。
- en: 2\. Run the code and look at the output.
  id: totrans-1347
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 运行代码并查看输出。
- en: '![Image 61](img/index-343_1.jpg)'
  id: totrans-1348
  prefs: []
  type: TYPE_IMG
  zh: '![Image 61](img/index-343_1.jpg)'
- en: 'And the shaded result should look as the following image:'
  id: totrans-1349
  prefs: []
  type: TYPE_NORMAL
  zh: 阴影结果应该看起来像以下图像：
- en: '![Image 62](img/index-344_1.jpg)'
  id: totrans-1350
  prefs: []
  type: TYPE_IMG
  zh: '![Image 62](img/index-344_1.jpg)'
- en: Using more classes resulted in a better representation of the altitude variation
    and it allowed us to clearly see the peaks with high altitudes.
  id: totrans-1351
  prefs: []
  type: TYPE_NORMAL
  zh: 使用更多的类别可以更好地表示高度变化，并使我们能够清楚地看到高海拔的峰值。
- en: '**Summary**'
  id: totrans-1352
  prefs: []
  type: TYPE_NORMAL
  zh: '**总结**'
- en: In this chapter, we took raw raster data, and with a series of techniques, we
    were able to extract statistical information from it and display it on high quality
    maps. These procedures took us to a high level of communication in terms of geospatial
    information because the material produced is easy to interpret, even for untrained
    eyes.
  id: totrans-1353
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们处理了原始栅格数据，并使用一系列技术从中提取统计信息，并将其显示在高质量地图上。这些程序使我们能够在地理空间信息方面达到高水平的沟通，因为产生的材料易于解释，即使是未经训练的眼睛也能看懂。
- en: In the next chapter, we will enter a new field and start taking care of the
    efficiency of our code in order to process massive geospatial datasets in a timely
    manner.
  id: totrans-1354
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将进入一个新的领域，并开始关注我们代码的效率，以便及时处理大量地理空间数据集。
- en: '**Chapter 8\. Data Miner App**'
  id: totrans-1355
  prefs: []
  type: TYPE_NORMAL
  zh: '**第8章 数据挖掘应用**'
- en: New challenges appear, to the extent that data size increases. Large sets of
    data bring problems related to excessive processing time and great memory consumption.
    These problems may turn data analysis into a painful process or may even make
    it completely impossible.
  id: totrans-1356
  prefs: []
  type: TYPE_NORMAL
  zh: 随着数据量的增加，新的挑战也随之而来。大量数据带来与过度处理时间和大量内存消耗相关的问题。这些问题可能会使数据分析变得痛苦，甚至可能使其完全不可能进行。
- en: In this chapter, we will create an application capable of processing huge datasets
    in an efficient way. We will review our code, implementing new tools and techniques
    that will make our analysis not only run faster, but also make better use of computer
    hardware, allowing virtually any amount of data to be processed.
  id: totrans-1357
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将创建一个能够以高效方式处理大量数据集的应用程序。我们将审查我们的代码，实现新的工具和技术，这将使我们的分析不仅运行得更快，而且还能更好地利用计算机硬件，使几乎任何数量的数据都能被处理。
- en: In order to achieve those goals, we will learn how to use databases and how
    to stream the data into them, making the use of computing power constant and stable
    regardless of the amount of data.
  id: totrans-1358
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这些目标，我们将学习如何使用数据库以及如何将数据流式传输到它们中，使计算能力的使用保持恒定和稳定，无论数据量的大小。
- en: These tools will also enable us to perform more advanced searches, calculations,
    and cross information from different sources, allowing you to mine the data for
    precious information.
  id: totrans-1359
  prefs: []
  type: TYPE_NORMAL
  zh: 这些工具还将使我们能够执行更高级的搜索、计算，并从不同来源获取交叉信息，让您能够挖掘宝贵的信息。
- en: 'This chapter will cover the following topics:'
  id: totrans-1360
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: What code efficiency is and how to measure it
  id: totrans-1361
  prefs: []
  type: TYPE_NORMAL
  zh: 代码效率是什么以及如何衡量它
- en: How to import data into a spatial database
  id: totrans-1362
  prefs: []
  type: TYPE_NORMAL
  zh: 如何将数据导入到空间数据库中
- en: How to abstract database data into Python objects
  id: totrans-1363
  prefs: []
  type: TYPE_NORMAL
  zh: 如何将数据库数据抽象为Python对象
- en: Making queries and getting information from a spatial database Understanding
    code efficiency
  id: totrans-1364
  prefs: []
  type: TYPE_NORMAL
  zh: 查询和从空间数据库中获取信息 理解代码效率
- en: 'What constitutes efficient code depends on the points that are being analyzed.
    When we talk about computational efficiency, there are four points that may be
    taken into consideration:'
  id: totrans-1365
  prefs: []
  type: TYPE_NORMAL
  zh: 效率代码的构成取决于正在分析的点。当我们谈论计算效率时，有四个点可能需要考虑：
- en: The time the code takes to execute
  id: totrans-1366
  prefs: []
  type: TYPE_NORMAL
  zh: 代码执行所需的时间
- en: How much memory it uses to run
  id: totrans-1367
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时使用的内存量
- en: How much disk space it uses
  id: totrans-1368
  prefs: []
  type: TYPE_NORMAL
  zh: 占用的磁盘空间量
- en: Whether the code uses all the available computing power
  id: totrans-1369
  prefs: []
  type: TYPE_NORMAL
  zh: 代码是否使用了所有可用的计算能力
- en: 'Good and efficient code is not only about computational efficiency; it’s also
    about writing code that brings these favorable qualities to the development process
    (to cite just a few of them):'
  id: totrans-1370
  prefs: []
  type: TYPE_NORMAL
  zh: 优秀的、高效的代码不仅关乎计算效率；它还关乎编写能够为开发过程带来这些有利品质的代码（仅举几个例子）：
- en: Clean and organized code
  id: totrans-1371
  prefs: []
  type: TYPE_NORMAL
  zh: 清洁且有序的代码
- en: Readable code
  id: totrans-1372
  prefs: []
  type: TYPE_NORMAL
  zh: 易读的代码
- en: Easy to maintain and debug
  id: totrans-1373
  prefs: []
  type: TYPE_NORMAL
  zh: 易于维护和调试
- en: Generalized
  id: totrans-1374
  prefs: []
  type: TYPE_NORMAL
  zh: 广泛的
- en: Shielded against misuse
  id: totrans-1375
  prefs: []
  type: TYPE_NORMAL
  zh: 防止误用
- en: It’s obvious that some points are contradictory. Here are just a few examples.
    To speed up a process, you may need to use more memory. To use less memory, you
    may need more disk space. Alternatively, for faster code, you may need to give
    up on generalization and
  id: totrans-1376
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，有些点是相互矛盾的。这里只举几个例子。为了加快一个过程，您可能需要使用更多的内存。为了使用更少的内存，您可能需要更多的磁盘空间。或者，为了获得更快的代码，您可能需要放弃泛化，
- en: write very specific functions.
  id: totrans-1377
  prefs: []
  type: TYPE_NORMAL
  zh: 编写非常具体的函数。
- en: It is the developer who determines the balance between antagonistic characteristics,
    based on the software requirements and the gains obtained by investing in one
    point or another.
  id: totrans-1378
  prefs: []
  type: TYPE_NORMAL
  zh: 是开发者根据软件需求和投资于某一点或另一点所获得的收益来决定对抗性特征之间的平衡。
- en: For example, if much cleaner code can be written with very little penalty in
    terms of execution time, the developer may opt for clean and maintainable code
    that will be easier for him and his team to understand.
  id: totrans-1379
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果可以编写出非常干净的代码，同时执行时间上的损失很小，开发者可能会选择编写干净且易于维护的代码，这将使他和他的团队能够更容易地理解。
- en: The second block of good characteristics is prone to human evaluation, whereas
    the items in the first block can be measured and compared by the computer.
  id: totrans-1380
  prefs: []
  type: TYPE_NORMAL
  zh: 第二组好的特性容易受到人类评估的影响，而第一组中的项目可以通过计算机进行测量和比较。
- en: '**Measuring execution time**'
  id: totrans-1381
  prefs: []
  type: TYPE_NORMAL
  zh: '**测量执行时间**'
- en: 'In order to measure how fast a piece of code is executed, we need to measure
    its execution time. The time measured is relative and varies, depending on a number
    of factors: the operating system, whether there are other programs running, the
    hardware, and so on.'
  id: totrans-1382
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测量一段代码的执行速度，我们需要测量其执行时间。所测量的时间是相对的，并受多种因素的影响：操作系统、是否有其他程序正在运行、硬件等。
- en: For our efficiency tests, we will measure the execution time, make changes in
    the code, and measure it again. In this way, we will see if the changes improve
    the code efficiency or not.
  id: totrans-1383
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的效率测试中，我们将测量执行时间，对代码进行修改，然后再次测量。这样，我们将看到这些修改是否提高了代码效率。
- en: Let’s start with a simple example and measure how long it takes to run.
  id: totrans-1384
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从简单的例子开始，并测量其运行所需的时间。
- en: '1\. As before, make a copy of the previous chapter folder in your geopy project
    and rename it as Chapter8\. Your project structure should look like this:'
  id: totrans-1385
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 如前所述，在您的geopy项目中复制上一章的文件夹，并将其重命名为Chapter8。您的项目结构应如下所示：
- en: ├───Chapter1
  id: totrans-1386
  prefs: []
  type: TYPE_NORMAL
  zh: ├───Chapter1
- en: ├───Chapter2
  id: totrans-1387
  prefs: []
  type: TYPE_NORMAL
  zh: ├───Chapter2
- en: ├───Chapter3
  id: totrans-1388
  prefs: []
  type: TYPE_NORMAL
  zh: ├───Chapter3
- en: ├───Chapter4
  id: totrans-1389
  prefs: []
  type: TYPE_NORMAL
  zh: ├───Chapter4
- en: ├───Chapter5
  id: totrans-1390
  prefs: []
  type: TYPE_NORMAL
  zh: ├───Chapter5
- en: ├───Chapter6
  id: totrans-1391
  prefs: []
  type: TYPE_NORMAL
  zh: ├───Chapter6
- en: ├───Chapter7
  id: totrans-1392
  prefs: []
  type: TYPE_NORMAL
  zh: ├───Chapter7
- en: ├───Chapter8
  id: totrans-1393
  prefs: []
  type: TYPE_NORMAL
  zh: ├───Chapter8
- en: │ ├───experiments
  id: totrans-1394
  prefs: []
  type: TYPE_NORMAL
  zh: │ ├───experiments
- en: │ ├───map_maker
  id: totrans-1395
  prefs: []
  type: TYPE_NORMAL
  zh: │ ├───map_maker
- en: │ ├───output
  id: totrans-1396
  prefs: []
  type: TYPE_NORMAL
  zh: │ ├───output
- en: │ └───utils
  id: totrans-1397
  prefs: []
  type: TYPE_NORMAL
  zh: │ └───utils
- en: └───data
  id: totrans-1398
  prefs: []
  type: TYPE_NORMAL
  zh: └───data
- en: 2\. Click on your experiments folder and create a new Python file inside it.
    Name that file timing.py.
  id: totrans-1399
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 点击您的实验文件夹，并在其中创建一个新的Python文件。将该文件命名为timing.py。
- en: '3\. Now add the following code to that file:'
  id: totrans-1400
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 现在将以下代码添加到该文件中：
- en: coding=utf-8
  id: totrans-1401
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: coding=utf-8
- en: 'def make_list1(items_list):'
  id: totrans-1402
  prefs: []
  type: TYPE_NORMAL
  zh: 'def make_list1(items_list):'
- en: result = ""
  id: totrans-1403
  prefs: []
  type: TYPE_NORMAL
  zh: result = ""
- en: 'for item in items_list:'
  id: totrans-1404
  prefs: []
  type: TYPE_NORMAL
  zh: 'for item in items_list:'
- en: template = "I like {}. \n"
  id: totrans-1405
  prefs: []
  type: TYPE_NORMAL
  zh: template = "我喜欢{}。 \n"
- en: text = template.format(item)
  id: totrans-1406
  prefs: []
  type: TYPE_NORMAL
  zh: text = template.format(item)
- en: result = result + text
  id: totrans-1407
  prefs: []
  type: TYPE_NORMAL
  zh: result = result + text
- en: return result
  id: totrans-1408
  prefs: []
  type: TYPE_NORMAL
  zh: return result
- en: 'if __name__ == ''__main__'':'
  id: totrans-1409
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == ''__main__'':'
- en: my_list = ['bacon', 'lasagna', 'salad', 'eggs', 'apples']
  id: totrans-1410
  prefs: []
  type: TYPE_NORMAL
  zh: my_list = ['培根', '千层面', '沙拉', '鸡蛋', '苹果']
- en: print(make_list1(my_list))
  id: totrans-1411
  prefs: []
  type: TYPE_NORMAL
  zh: print(make_list1(my_list))
- en: '4\. Run the code. Press *Alt* + *Shift* + *F10* and select a timing from the
    list. You should get this output:'
  id: totrans-1412
  prefs: []
  type: TYPE_NORMAL
  zh: 4. 再次运行代码。按 *Alt* + *Shift* + *F10* 并从列表中选择一个计时。你应该得到这个输出：
- en: I like bacon.
  id: totrans-1413
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢培根。
- en: I like lasagna.
  id: totrans-1414
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢千层面。
- en: I like salad.
  id: totrans-1415
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢沙拉。
- en: I like eggs.
  id: totrans-1416
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢鸡蛋。
- en: I like apples.
  id: totrans-1417
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢苹果。
- en: Nothing fancy, it’s a simple inefficient function to format texts and produce
    a printable list of things.
  id: totrans-1418
  prefs: []
  type: TYPE_NORMAL
  zh: 没有什么花哨的，这是一个简单的低效函数，用于格式化文本并生成可打印的事物列表。
- en: '5\. Now we are going to measure how long it takes to execute. Modify your code:'
  id: totrans-1419
  prefs: []
  type: TYPE_NORMAL
  zh: 5. 现在我们将测量执行所需的时间。修改你的代码：
- en: coding=utf-8
  id: totrans-1420
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: coding=utf-8
- en: from timeit import timeit
  id: totrans-1421
  prefs: []
  type: TYPE_NORMAL
  zh: from timeit import timeit
- en: 'def make_list1(items_list):'
  id: totrans-1422
  prefs: []
  type: TYPE_NORMAL
  zh: 'def make_list1(items_list):'
- en: result = ""
  id: totrans-1423
  prefs: []
  type: TYPE_NORMAL
  zh: result = ""
- en: 'for item in items_list:'
  id: totrans-1424
  prefs: []
  type: TYPE_NORMAL
  zh: 'for item in items_list:'
- en: template = "I like {}. \n"
  id: totrans-1425
  prefs: []
  type: TYPE_NORMAL
  zh: template = "我喜欢{}。 \n"
- en: text = template.format(item)
  id: totrans-1426
  prefs: []
  type: TYPE_NORMAL
  zh: text = template.format(item)
- en: result = result + text
  id: totrans-1427
  prefs: []
  type: TYPE_NORMAL
  zh: result = result + text
- en: return result
  id: totrans-1428
  prefs: []
  type: TYPE_NORMAL
  zh: return result
- en: 'if __name__ == ''__main__'':'
  id: totrans-1429
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == ''__main__'':'
- en: my_list = ['bacon', 'lasagna', 'salad', 'eggs', 'apples']
  id: totrans-1430
  prefs: []
  type: TYPE_NORMAL
  zh: my_list = ['培根', '千层面', '沙拉', '鸡蛋', '苹果']
- en: number = 100
  id: totrans-1431
  prefs: []
  type: TYPE_NORMAL
  zh: number = 100
- en: execution_time = timeit('make_list1(my_list)',
  id: totrans-1432
  prefs: []
  type: TYPE_NORMAL
  zh: execution_time = timeit('make_list1(my_list)',
- en: setup='from __main__ import make_list1, my_list',
  id: totrans-1433
  prefs: []
  type: TYPE_NORMAL
  zh: setup='from __main__ import make_list1, my_list',
- en: number=number)
  id: totrans-1434
  prefs: []
  type: TYPE_NORMAL
  zh: number=number)
- en: print("It took {}s to execute the code {} times".format(
  id: totrans-1435
  prefs: []
  type: TYPE_NORMAL
  zh: print("执行代码{}次花费了{}秒"。format(
- en: execution_time, number))
  id: totrans-1436
  prefs: []
  type: TYPE_NORMAL
  zh: execution_time, number))
- en: '6\. Run your code again with *Shift* + *F10* and look at the results: It took
    0.000379365835017s to execute the code 100 times'
  id: totrans-1437
  prefs: []
  type: TYPE_NORMAL
  zh: 6. 再次使用 *Shift* + *F10* 运行代码并查看结果：执行代码100次花费了0.000379365835017秒
- en: Process finished with exit code 0
  id: totrans-1438
  prefs: []
  type: TYPE_NORMAL
  zh: Process finished with exit code 0
- en: Here we are using the timeit module to measure the execution time of our function.
  id: totrans-1439
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们使用 timeit 模块来测量我们函数的执行时间。
- en: Since some pieces of code run vary fast, we need to repeat the execution many
    times to get a more precise measurement and a more meaningful number. The number
    of times that the statement is repeated is given by the number parameter.
  id: totrans-1440
  prefs: []
  type: TYPE_NORMAL
  zh: 由于一些代码运行速度很快，我们需要多次重复执行以获得更精确的测量和更有意义的数字。重复执行语句的次数由数字参数给出。
- en: '7\. Increase your number parameter to 1000000 and run the code again: It took
    3.66938576408s to execute the code 1000000 times'
  id: totrans-1441
  prefs: []
  type: TYPE_NORMAL
  zh: 7. 将你的数字参数增加到1000000并再次运行代码：执行代码1000000次花费了3.66938576408秒
- en: Process finished with exit code 0
  id: totrans-1442
  prefs: []
  type: TYPE_NORMAL
  zh: Process finished with exit code 0
- en: Now we have a more consistent number to work with. If your computer is much
    faster than mine you can increase the number. If it’s slower, decrease it.
  id: totrans-1443
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个更一致的数字可以工作。如果你的电脑比我的快得多，你可以增加这个数字。如果它更慢，就减少它。
- en: Grab a piece of paper and take note of that result. We are going to change the
    function and see if we make the code more efficient.
  id: totrans-1444
  prefs: []
  type: TYPE_NORMAL
  zh: 拿一张纸并记下那个结果。我们将更改函数，看看我们是否使代码更高效。
- en: '8\. Add another version of our function; name it make_list2: def make_list2(items_list):'
  id: totrans-1445
  prefs: []
  type: TYPE_NORMAL
  zh: '8. 添加我们函数的另一个版本；命名为 make_list2: def make_list2(items_list):'
- en: result = ""
  id: totrans-1446
  prefs: []
  type: TYPE_NORMAL
  zh: result = ""
- en: template = "I like {}. \n"
  id: totrans-1447
  prefs: []
  type: TYPE_NORMAL
  zh: template = "我喜欢{}。 \n"
- en: 'for item in items_list:'
  id: totrans-1448
  prefs: []
  type: TYPE_NORMAL
  zh: 'for item in items_list:'
- en: text = template.format(item)
  id: totrans-1449
  prefs: []
  type: TYPE_NORMAL
  zh: text = template.format(item)
- en: result = result + text
  id: totrans-1450
  prefs: []
  type: TYPE_NORMAL
  zh: result = result + text
- en: return result
  id: totrans-1451
  prefs: []
  type: TYPE_NORMAL
  zh: return result
- en: '9\. Also change your if __name__ == ''__main__'': block. We will make it clear
    which version of the function we are executing:'
  id: totrans-1452
  prefs: []
  type: TYPE_NORMAL
  zh: '9. 还要更改你的 if __name__ == ''__main__'': 块。我们将清楚地说明正在执行函数的哪个版本：'
- en: 'if __name__ == ''__main__'':'
  id: totrans-1453
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == ''__main__'':'
- en: my_list = ['bacon', 'lasagna', 'salad', 'eggs', 'apples']
  id: totrans-1454
  prefs: []
  type: TYPE_NORMAL
  zh: my_list = ['培根', '千层面', '沙拉', '鸡蛋', '苹果']
- en: number = 1000000
  id: totrans-1455
  prefs: []
  type: TYPE_NORMAL
  zh: number = 1000000
- en: function_version = 2
  id: totrans-1456
  prefs: []
  type: TYPE_NORMAL
  zh: function_version = 2
- en: statement = 'make_list{}(my_list)'.format(function_version) setup = 'from __main__
    import make_list{}, my_list'.format(
  id: totrans-1457
  prefs: []
  type: TYPE_NORMAL
  zh: statement = 'make_list{}(my_list)'.format(function_version) setup = 'from __main__
    import make_list{}, my_list'.format(
- en: function_version)
  id: totrans-1458
  prefs: []
  type: TYPE_NORMAL
  zh: function_version)
- en: execution_time = timeit(statement, setup=setup, number=number) print("Version
    {}.".format(function_version))
  id: totrans-1459
  prefs: []
  type: TYPE_NORMAL
  zh: execution_time = timeit(statement, setup=setup, number=number) print("版本{}。".format(function_version))
- en: print("It took {}s to execute the code {} times".format(
  id: totrans-1460
  prefs: []
  type: TYPE_NORMAL
  zh: print("执行代码{}次花费了{}秒"。format(
- en: execution_time, number))
  id: totrans-1461
  prefs: []
  type: TYPE_NORMAL
  zh: execution_time, number))
- en: '10\. Run the code again and see your results. On my computer, I got this: Version
    2\.'
  id: totrans-1462
  prefs: []
  type: TYPE_NORMAL
  zh: 10. 再次运行代码并查看结果。在我的电脑上，我得到了这个：版本2。
- en: It took 3.5384931206s to execute the code 1000000 times
  id: totrans-1463
  prefs: []
  type: TYPE_NORMAL
  zh: It took 3.5384931206s to execute the code 1000000 times
- en: Process finished with exit code 0
  id: totrans-1464
  prefs: []
  type: TYPE_NORMAL
  zh: Process finished with exit code 0
- en: That was a slight improvement in execution time. The only change that was made
    in version 2 was that we moved the template out of the for loop.
  id: totrans-1465
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对执行时间的一点点改进。在版本2中，我们唯一做出的改变是将模板移出了for循环。
- en: '11\. Make a third version of the function:'
  id: totrans-1466
  prefs: []
  type: TYPE_NORMAL
  zh: 11. 创建函数的第三个版本：
- en: 'def make_list3(items_list):'
  id: totrans-1467
  prefs: []
  type: TYPE_NORMAL
  zh: 'def make_list3(items_list):'
- en: result = ""
  id: totrans-1468
  prefs: []
  type: TYPE_NORMAL
  zh: result = ""
- en: template = "I like "
  id: totrans-1469
  prefs: []
  type: TYPE_NORMAL
  zh: template = "I like "
- en: 'for item in items_list:'
  id: totrans-1470
  prefs: []
  type: TYPE_NORMAL
  zh: 'for item in items_list:'
- en: text = template + item + ". \n"
  id: totrans-1471
  prefs: []
  type: TYPE_NORMAL
  zh: text = template + item + ". \n"
- en: result = result + text
  id: totrans-1472
  prefs: []
  type: TYPE_NORMAL
  zh: result = result + text
- en: return result
  id: totrans-1473
  prefs: []
  type: TYPE_NORMAL
  zh: 返回结果
- en: '12\. Change your function_version variable to 3 and run the code again: Version
    3\.'
  id: totrans-1474
  prefs: []
  type: TYPE_NORMAL
  zh: 12. 将你的function_version变量更改为3并再次运行代码：版本3。
- en: It took 1.88675713574s to execute the code 1000000 times
  id: totrans-1475
  prefs: []
  type: TYPE_NORMAL
  zh: 执行1000000次代码耗时1.88675713574秒
- en: Process finished with exit code 0
  id: totrans-1476
  prefs: []
  type: TYPE_NORMAL
  zh: 进程以退出代码0结束
- en: Now we changed how the string "I like " is formed. Instead of using string formatting,
    we added parts of the string and got code that ran almost twice as fast as the
    previous version.
  id: totrans-1477
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们改变了字符串"I like "的构成方式。我们不是使用字符串格式化，而是添加了字符串的部分，得到的代码比上一个版本快了近两倍。
- en: You can find out which small changes will reduce the execution time by trial
    and error, by consulting articles on the Internet, or by experience. But there
    is a more assertive and powerful way to find out where your code spends more time;
    this is called **profiling**.
  id: totrans-1478
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过试验、查阅互联网上的文章或通过经验来找出哪些小的改动可以减少执行时间。但有一种更肯定、更强大的方法来找出代码中花费更多时间的地方；这被称为**分析**。
- en: '**Code profiling**'
  id: totrans-1479
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码分析**'
- en: By trial, we found that the most expensive part of our code was the string formatting.
  id: totrans-1480
  prefs: []
  type: TYPE_NORMAL
  zh: 通过试验，我们发现代码中最昂贵的部分是字符串格式化。
- en: When your code gets more complex, finding bottlenecks by this method gets harder
    and at some point becomes impractical.
  id: totrans-1481
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的代码变得更加复杂时，通过这种方法找到瓶颈变得更加困难，在某个时候变得不切实际。
- en: The solution is to break and analyze small pieces of code. To see how long they
    take to execute, make a profile of the code.
  id: totrans-1482
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是分解并分析小块代码。为了查看它们执行所需的时间，对代码进行剖析。
- en: Python comes with a good profiling tool that automates this process to a certain
    level.
  id: totrans-1483
  prefs: []
  type: TYPE_NORMAL
  zh: Python自带了一个很好的分析工具，它可以在一定程度上自动化这个过程。
- en: 'Let’s use it on our code to see what it tells us:'
  id: totrans-1484
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在我们的代码上使用它，看看它告诉我们什么：
- en: '1\. Add this import at the beginning of the file:'
  id: totrans-1485
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 在文件开头添加此导入：
- en: from timeit import timeit
  id: totrans-1486
  prefs: []
  type: TYPE_NORMAL
  zh: from timeit import timeit
- en: '**import cProfile**'
  id: totrans-1487
  prefs: []
  type: TYPE_NORMAL
  zh: '**导入cProfile**'
- en: '2\. Edit your if __name__ == ''__main__'': block to use the profiler: if __name__
    == ''__main__'':'
  id: totrans-1488
  prefs: []
  type: TYPE_NORMAL
  zh: '2. 编辑你的if __name__ == ''__main__'':块以使用分析器：if __name__ == ''__main__'':'
- en: my_list = ['bacon', 'lasagna', 'salad', 'eggs', 'apples']
  id: totrans-1489
  prefs: []
  type: TYPE_NORMAL
  zh: my_list = ['bacon', 'lasagna', 'salad', 'eggs', 'apples']
- en: number = 1000000
  id: totrans-1490
  prefs: []
  type: TYPE_NORMAL
  zh: number = 1000000
- en: profile = cProfile.Profile()
  id: totrans-1491
  prefs: []
  type: TYPE_NORMAL
  zh: profile = cProfile.Profile()
- en: profile.enable()
  id: totrans-1492
  prefs: []
  type: TYPE_NORMAL
  zh: profile.enable()
- en: 'for i in range(number):'
  id: totrans-1493
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(number):'
- en: make_list1(my_list)
  id: totrans-1494
  prefs: []
  type: TYPE_NORMAL
  zh: make_list1(my_list)
- en: profile.disable()
  id: totrans-1495
  prefs: []
  type: TYPE_NORMAL
  zh: profile.disable()
- en: profile.print_stats(sort='cumulative')
  id: totrans-1496
  prefs: []
  type: TYPE_NORMAL
  zh: profile.print_stats(sort='cumulative')
- en: '3\. Run the code. You should see the profiler statistics on the console. (I
    suppressed some information for reasons of space):'
  id: totrans-1497
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 运行代码。你应该能在控制台上看到分析器统计信息。（由于空间原因，我抑制了一些信息）：
- en: 6000002 function calls in 4.755 seconds
  id: totrans-1498
  prefs: []
  type: TYPE_NORMAL
  zh: 6000002次函数调用在4.755秒内
- en: 'Ordered by: cumulative time'
  id: totrans-1499
  prefs: []
  type: TYPE_NORMAL
  zh: 按照累积时间排序
- en: ncalls tottime percall cumtime percall
  id: totrans-1500
  prefs: []
  type: TYPE_NORMAL
  zh: ncalls tottime percall cumtime percall
- en: 1000000 2.718 0.000 4.738 0.000 timing.py
  id: totrans-1501
  prefs: []
  type: TYPE_NORMAL
  zh: 1000000 2.718 0.000 4.738 0.000 timing.py
- en: 5000000 2.019 0.000 2.019 0.000 {'format' ...}
  id: totrans-1502
  prefs: []
  type: TYPE_NORMAL
  zh: 5000000 2.019 0.000 2.019 0.000 {'format' ...}
- en: 1 0.017 0.017 0.017 0.017 {range}
  id: totrans-1503
  prefs: []
  type: TYPE_NORMAL
  zh: 1 0.017 0.017 0.017 0.017 {range}
- en: 1 0.000 0.000 0.000 0.000 {'disable' ...}
  id: totrans-1504
  prefs: []
  type: TYPE_NORMAL
  zh: 1 0.000 0.000 0.000 0.000 {'disable' ...}
- en: There are many ways to execute the profiler. In our case, we instantiated the
    Profile class and used the enable and disable methods to tell the profiler where
    to start and stop collecting data. Again, the call to make_list1 was repeated
    1000000 times to generate bigger numbers.
  id: totrans-1505
  prefs: []
  type: TYPE_NORMAL
  zh: 执行分析器有多种方式。在我们的例子中，我们实例化了Profile类，并使用enable和disable方法来告诉分析器从哪里开始和停止收集数据。再次强调，调用make_list1的次数被重复了1000000次，以生成更大的数字。
- en: In the output, we can see that make_list1 was called 1000000 times and the format
    method was called five million times, taking 2.019 seconds. Note that the profiler
    only gave information regarding methods and functions.
  id: totrans-1506
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出中，我们可以看到make_list1被调用了1000000次，format方法被调用了五百万次，耗时2.019秒。请注意，分析器只提供了有关方法和函数的信息。
- en: '**Storing information on a database**'
  id: totrans-1507
  prefs: []
  type: TYPE_NORMAL
  zh: '**在数据库上存储信息**'
- en: In the previous chapters, the basic workflow was to import all the data into
    memory as Python objects every time we ran the code. That’s perfectly fine and
    efficient when we work with small pieces of data.
  id: totrans-1508
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，基本的流程是在每次运行代码时将所有数据导入内存作为Python对象。当我们处理小块数据时，这完全可行且效率很高。
- en: At some point, you may have noticed that the performance of our code was debilitated,
    especially when we started importing country boundaries along with all the attributes.
    This happened because importing attributes is slow.
  id: totrans-1509
  prefs: []
  type: TYPE_NORMAL
  zh: 在某个时候，你可能已经注意到我们代码的性能受到了削弱，尤其是在我们开始导入国家边界以及所有属性时。这是因为导入属性很慢。
- en: Secondly, although our filtering mechanisms worked pretty well, we may have
    problems when dealing with huge datasets.
  id: totrans-1510
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，尽管我们的过滤机制工作得相当好，但我们处理大型数据集时可能会遇到问题。
- en: 'The formula to solve these problems is very simple and consists of only two
    basic ingredients:'
  id: totrans-1511
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这些问题的公式非常简单，只包含两个基本成分：
- en: Get only what you need
  id: totrans-1512
  prefs: []
  type: TYPE_NORMAL
  zh: 只获取你需要的内容
- en: Use indexed searches
  id: totrans-1513
  prefs: []
  type: TYPE_NORMAL
  zh: 使用索引搜索
- en: The first point is about getting only the records you need, as well as getting
    only the attributes that are desired for a given analysis.
  id: totrans-1514
  prefs: []
  type: TYPE_NORMAL
  zh: 第一点是只获取你需要的记录，以及获取给定分析所需的属性。
- en: The second point is about how things are found. In our method, a loop tests
    every record for a condition until the desired one is found (that is, the test
    returns True). Alternatively, if the computer somehow had an idea of where the
    item was, the search would be much faster; this is indexing.
  id: totrans-1515
  prefs: []
  type: TYPE_NORMAL
  zh: 第二点关于如何找到事物。在我们的方法中，一个循环会测试每条记录的条件，直到找到所需的记录（即测试返回True）。或者，如果计算机有关于项目位置的某种想法，搜索将会更快；这就是索引。
- en: Instead of trying to implement these features by ourselves, we can use a database
    to handle these mechanisms for us; they are state-of-the-art for this kind of
    job.
  id: totrans-1516
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是试图自己实现这些功能，我们可以使用数据库来为我们处理这些机制；它们是这个类型工作的最先进技术。
- en: 'Here we have two options:'
  id: totrans-1517
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们有两个选择：
- en: Use a **SQLite** database with the **Spatialite** extension, which is an open
    source, simple, and very efficient SQL database. It doesn’t require a server or
    installation, and Python comes bundled with a connector to it.
  id: totrans-1518
  prefs: []
  type: TYPE_NORMAL
  zh: 使用带有**Spatialite**扩展的**SQLite**数据库，这是一个开源、简单且非常高效的SQL数据库。它不需要服务器或安装，Python自带了连接到它的连接器。
- en: Use a **PostgreSQL** database with the **Postgis** extension. Also open source
    and powerful, this is a full-featured database server.
  id: totrans-1519
  prefs: []
  type: TYPE_NORMAL
  zh: 使用带有**Postgis**扩展的**PostgreSQL**数据库。这也是一个开源且强大的数据库服务器。
- en: The choice is up to you and will have no influence on the code except for a
    small change in the settings.
  id: totrans-1520
  prefs: []
  type: TYPE_NORMAL
  zh: 选择权在你，除了在设置中有一小点变化外，它不会对代码产生影响。
- en: '**Tip**'
  id: totrans-1521
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**'
- en: 'PostgreSQL can be download from: [http://www.postgresql.org/.](http://www.postgresql.org/)
    In order to enable Postgis, you just need to select it in the stack builder during
    the installation.'
  id: totrans-1522
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从以下链接下载PostgreSQL：[http://www.postgresql.org/.](http://www.postgresql.org/)
    为了启用Postgis，你只需要在安装过程中在堆栈构建器中选择它。
- en: 'If you are using Ubuntu, you can find more details at:'
  id: totrans-1523
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用Ubuntu，你可以在以下链接中找到更多详细信息：
- en: '[https://wiki.ubuntu.com/UbuntuGIS.](https://wiki.ubuntu.com/UbuntuGIS)'
  id: totrans-1524
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://wiki.ubuntu.com/UbuntuGIS.](https://wiki.ubuntu.com/UbuntuGIS)'
- en: '**Creating an Object Relational Mapping**'
  id: totrans-1525
  prefs: []
  type: TYPE_NORMAL
  zh: '**创建对象关系映射**'
- en: '**Object Relational Mapping** (**ORM**) is a method that we will use to convert
    the data stored in a database into Python objects. This no different from what
    we did before in our models.py file, where we made code that transformed data
    stored in geographic files (for example, a GPX shapefile) into Python objects.'
  id: totrans-1526
  prefs: []
  type: TYPE_NORMAL
  zh: '**对象关系映射**（**ORM**）是我们将使用的方法，将存储在数据库中的数据转换为Python对象。这与我们在models.py文件中做的没有区别，我们在那里编写了将存储在地理文件（例如，GPX形状文件）中的数据转换为Python对象的代码。'
- en: This time, we will close the circle by importing the data into the database,
    and then later retrieve data or information from it in the same elegant and intuitive
    manner as before.
  id: totrans-1527
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们将通过将数据导入数据库来闭合这个循环，然后稍后以前那种优雅直观的方式从其中检索数据或信息。
- en: 'SQL databases, such as SQLite, store the data in tables with row and columns.
    The following table illustrates how the geocaching data that we previously used
    would be represented in this format:'
  id: totrans-1528
  prefs: []
  type: TYPE_NORMAL
  zh: SQL数据库，如SQLite，将数据存储在具有行和列的表中。以下表格说明了我们之前使用的地理缓存数据将如何以这种格式表示：
- en: '**ID Geom Name**'
  id: totrans-1529
  prefs: []
  type: TYPE_NORMAL
  zh: '**ID Geom Name**'
- en: '**Status**'
  id: totrans-1530
  prefs: []
  type: TYPE_NORMAL
  zh: '**状态**'
- en: '**Owner Hints**'
  id: totrans-1531
  prefs: []
  type: TYPE_NORMAL
  zh: '**所有者提示**'
- en: '1'
  id: totrans-1532
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: (wkb) LaSalle Park Available John
  id: totrans-1533
  prefs: []
  type: TYPE_NORMAL
  zh: （wkb）LaSalle Park 可用 John
- en: Under sign
  id: totrans-1534
  prefs: []
  type: TYPE_NORMAL
  zh: 在签名下
- en: '2'
  id: totrans-1535
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: (wkb) Parking
  id: totrans-1536
  prefs: []
  type: TYPE_NORMAL
  zh: （wkb）停车场
- en: Available Nina
  id: totrans-1537
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的Nina
- en: Big tree
  id: totrans-1538
  prefs: []
  type: TYPE_NORMAL
  zh: 大树
- en: We can guess that this is incompatible with the premise of being able to import
    any type of data, because the type of column is fixed. If we have data with different
    attributes or more attributes, we need different tables or to add more columns
    to match every possibility.
  id: totrans-1539
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以猜测这与能够导入任何类型数据的假设不相符，因为列的类型是固定的。如果我们有具有不同属性或更多属性的数据，我们需要不同的表或添加更多列以匹配所有可能性。
- en: To overcome the limitation of this schema, we will use the relational capabilities
    of SQL
  id: totrans-1540
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服此架构的限制，我们将使用 SQL 的关系功能
- en: 'databases. We will store items and attributes in different tables and relate
    them: **Points**'
  id: totrans-1541
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库。我们将存储项目和属性在不同的表中，并将它们关联起来：**点**
- en: '**ID Geom**'
  id: totrans-1542
  prefs: []
  type: TYPE_NORMAL
  zh: '**ID 几何**'
- en: '1'
  id: totrans-1543
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: 42.89 - 78.90
  id: totrans-1544
  prefs: []
  type: TYPE_NORMAL
  zh: 42.89 - 78.90
- en: '2'
  id: totrans-1545
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: 43.00 - 78.0
  id: totrans-1546
  prefs: []
  type: TYPE_NORMAL
  zh: 43.00 - 78.0
- en: '**Attributes**'
  id: totrans-1547
  prefs: []
  type: TYPE_NORMAL
  zh: '**属性**'
- en: '**ID Key**'
  id: totrans-1548
  prefs: []
  type: TYPE_NORMAL
  zh: '**ID 键**'
- en: '**Value**'
  id: totrans-1549
  prefs: []
  type: TYPE_NORMAL
  zh: '**值**'
- en: '**point_id**'
  id: totrans-1550
  prefs: []
  type: TYPE_NORMAL
  zh: '**point_id**'
- en: '1'
  id: totrans-1551
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: name LaSalle Park 1
  id: totrans-1552
  prefs: []
  type: TYPE_NORMAL
  zh: 名称 LaSalle Park 1
- en: '2'
  id: totrans-1553
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: status Available
  id: totrans-1554
  prefs: []
  type: TYPE_NORMAL
  zh: 状态 可用
- en: '1'
  id: totrans-1555
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '3'
  id: totrans-1556
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: owner John
  id: totrans-1557
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有者 John
- en: '1'
  id: totrans-1558
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '4'
  id: totrans-1559
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: hints
  id: totrans-1560
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: under sign
  id: totrans-1561
  prefs: []
  type: TYPE_NORMAL
  zh: 签名下
- en: '1'
  id: totrans-1562
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '5'
  id: totrans-1563
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: name Parking
  id: totrans-1564
  prefs: []
  type: TYPE_NORMAL
  zh: 名称 停车场
- en: '2'
  id: totrans-1565
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: '6'
  id: totrans-1566
  prefs: []
  type: TYPE_NORMAL
  zh: '6'
- en: status Available
  id: totrans-1567
  prefs: []
  type: TYPE_NORMAL
  zh: 状态 可用
- en: '2'
  id: totrans-1568
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: '7'
  id: totrans-1569
  prefs: []
  type: TYPE_NORMAL
  zh: '7'
- en: owner Nina
  id: totrans-1570
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有者 Nina
- en: '2'
  id: totrans-1571
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: '8'
  id: totrans-1572
  prefs: []
  type: TYPE_NORMAL
  zh: '8'
- en: hints
  id: totrans-1573
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: big tree
  id: totrans-1574
  prefs: []
  type: TYPE_NORMAL
  zh: 大树
- en: '2'
  id: totrans-1575
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: This key/value data model allows each point (or other objects) to have arbitrary
    numbers and types of attributes. Each attribute is attached to its owner by an
    ID.
  id: totrans-1576
  prefs: []
  type: TYPE_NORMAL
  zh: 这种键/值数据模型允许每个点（或其他对象）具有任意数量和类型的属性。每个属性通过一个 ID 与其所有者关联。
- en: You may have heard of Django, *batteries-included* Python web framework. It
    happens that Django has a fantastic ORM included in it, and it has very developed
    support for geospatial databases and geospatial operations (this part of Django
    is called **GeoDjango** and is included by default). You will also notice that
    the transition from our models to Django will be smooth and they will remain easy
    to use, as before.
  id: totrans-1577
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能听说过 Django，这是一个包含所有功能的 Python 网络框架。事实上，Django 内置了一个出色的 ORM，并且它对地理空间数据库和地理空间操作有非常成熟的支持（Django
    的这部分称为 **GeoDjango**，默认包含）。你也会注意到，从我们的模型到 Django 的过渡将非常平滑，它们将像以前一样易于使用。
- en: '**Preparing the environment**'
  id: totrans-1578
  prefs: []
  type: TYPE_NORMAL
  zh: '**准备环境**'
- en: In order to use Django’s ORM we need to setup a Django project. To do that we
    will prepare the minimum required structure, which consists of a few files and
    settings.
  id: totrans-1579
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用 Django 的 ORM，我们需要设置一个 Django 项目。为此，我们将准备所需的最小结构，这包括几个文件和设置。
- en: First, let’s set up our application to use Django.
  id: totrans-1580
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们设置我们的应用程序以使用 Django。
- en: '1\. Inside your Chapter8 folder, create a new Python file named settings.py.
    If you are using PostgreSQL/Postgis, add the following code to the file: DATABASES
    = {'
  id: totrans-1581
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 在你的 Chapter8 文件夹中，创建一个名为 settings.py 的新 Python 文件。如果你使用 PostgreSQL/Postgis，请将以下代码添加到文件中：DATABASES
    = {
- en: '''default'': {'
  id: totrans-1582
  prefs: []
  type: TYPE_NORMAL
  zh: '''default'': {'
- en: '''ENGINE'': ''django.contrib.gis.db.backends.postgis'','
  id: totrans-1583
  prefs: []
  type: TYPE_NORMAL
  zh: '''ENGINE'': ''django.contrib.gis.db.backends.postgis'','
- en: '''NAME'': ''postgres'','
  id: totrans-1584
  prefs: []
  type: TYPE_NORMAL
  zh: '''NAME'': ''postgres'','
- en: '''USER'': ''postgres'','
  id: totrans-1585
  prefs: []
  type: TYPE_NORMAL
  zh: '''USER'': ''postgres'','
- en: '''PASSWORD'': ''mypassword'','
  id: totrans-1586
  prefs: []
  type: TYPE_NORMAL
  zh: '''PASSWORD'': ''mypassword'','
- en: '''PORT'': 5432'
  id: totrans-1587
  prefs: []
  type: TYPE_NORMAL
  zh: '''PORT'': 5432'
- en: '}}'
  id: totrans-1588
  prefs: []
  type: TYPE_NORMAL
  zh: '}}'
- en: The first item (DATABASES) is the database settings. If you have a default PostgreSQL/Postgis
    installation, this will work. Just change your password for the one you set during
    the installation.
  id: totrans-1589
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个项目（DATABASES）是数据库设置。如果你有默认的 PostgreSQL/Postgis 安装，这将有效。只需更改你在安装过程中设置的密码。
- en: '2\. If you are using SQLite/Spatialite, use this configuration: DATABASES =
    {'
  id: totrans-1590
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 如果你使用 SQLite/Spatialite，请使用以下配置：DATABASES = {
- en: '''default'': {'
  id: totrans-1591
  prefs: []
  type: TYPE_NORMAL
  zh: '''default'': {'
- en: '''ENGINE'': ''django.contrib.gis.db.backends.spatialite'','
  id: totrans-1592
  prefs: []
  type: TYPE_NORMAL
  zh: '''ENGINE'': ''django.contrib.gis.db.backends.spatialite'','
- en: '''NAME'': ''mydatabase.db'''
  id: totrans-1593
  prefs: []
  type: TYPE_NORMAL
  zh: '''NAME'': ''mydatabase.db'''
- en: '}}'
  id: totrans-1594
  prefs: []
  type: TYPE_NORMAL
  zh: '}}'
- en: '3\. After the database configuration, add these items:'
  id: totrans-1595
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 在数据库配置后，添加以下项：
- en: INSTALLED_APPS = ('django.contrib.gis', 'geodata')
  id: totrans-1596
  prefs: []
  type: TYPE_NORMAL
  zh: INSTALLED_APPS = ('django.contrib.gis', 'geodata')
- en: SECRET_KEY = 'abc'
  id: totrans-1597
  prefs: []
  type: TYPE_NORMAL
  zh: SECRET_KEY = 'abc'
- en: The INSTALLED_APPS item tells Django where to look for models. SECRET_KEY is
    used for Django’s user management. Although we won’t use it, this needs to be
    set (you can use any value as the secret key).
  id: totrans-1598
  prefs: []
  type: TYPE_NORMAL
  zh: INSTALLED_APPS 项告诉 Django 在哪里查找模型。SECRET_KEY 用于 Django 的用户管理。尽管我们不会使用它，但需要设置（可以使用任何值作为密钥）。
- en: 4\. Now create a Python package that will be our Django app. Right-click the
    Chapter8
  id: totrans-1599
  prefs: []
  type: TYPE_NORMAL
  zh: 4. 现在创建一个 Python 包，它将成为我们的 Django 应用。在 Chapter8 文件夹下右键单击并选择 **新建** | **Python
    包**。将其命名为 geodata。
- en: folder and select **New** | **Python Package**. Name it geodata.
  id: totrans-1600
  prefs: []
  type: TYPE_NORMAL
  zh: 文件夹下右键单击并选择 **新建** | **Python 包**。将其命名为 geodata。
- en: 5\. Create a new Python file inside Chapter8 and name it geodata_app.py.
  id: totrans-1601
  prefs: []
  type: TYPE_NORMAL
  zh: 5. 在 Chapter8 内创建一个新的 Python 文件，并将其命名为 geodata_app.py。
- en: '**Changing our models**'
  id: totrans-1602
  prefs: []
  type: TYPE_NORMAL
  zh: '**修改我们的模型**'
- en: We have the basic structure ready, now we need to adapt our models so they can
    use the database instead of storing all the information in memory. Django’s model
    definition is very similar to ours.
  id: totrans-1603
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有了基本结构，现在我们需要调整我们的模型，以便它们可以使用数据库而不是将所有信息存储在内存中。Django 的模型定义与我们非常相似。
- en: 'Using the new capabilities provided by Django, we will make one change in the
    choice of design: instead of one class for each type of object (geocaching, roads,
    boundaries, and so on) we will have only one class that can store data for all
    of them and any others that we can think of.'
  id: totrans-1604
  prefs: []
  type: TYPE_NORMAL
  zh: 利用Django提供的新功能，我们将对设计选择进行一个更改：而不是为每种类型的对象（地理藏宝、道路、边界等）创建一个类，我们将只有一个可以存储所有这些数据以及我们可以想到的其他数据的类。
- en: '1\. Create a file models.py inside the geodata folder and add this code:'
  id: totrans-1605
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 在geodata文件夹内创建一个名为models.py的文件，并添加以下代码：
- en: coding=utf-8
  id: totrans-1606
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: coding=utf-8
- en: from django.contrib.gis.db import models
  id: totrans-1607
  prefs: []
  type: TYPE_NORMAL
  zh: from django.contrib.gis.db import models
- en: 'class GeoObject(models.Model):'
  id: totrans-1608
  prefs: []
  type: TYPE_NORMAL
  zh: 'class GeoObject(models.Model):'
- en: geom = models.GeometryField()
  id: totrans-1609
  prefs: []
  type: TYPE_NORMAL
  zh: geom = models.GeometryField()
- en: atype = models.CharField(max_length=20)
  id: totrans-1610
  prefs: []
  type: TYPE_NORMAL
  zh: atype = models.CharField(max_length=20)
- en: objects = models.GeoManager()
  id: totrans-1611
  prefs: []
  type: TYPE_NORMAL
  zh: objects = models.GeoManager()
- en: The GeoObject class represents a single object (a single row in a table). It
    can accept any kind of geometry (a point, polygon, and so on) in the geom field.
    The atype property represents the high-level type of the object. This property
    will tell us if it’s a geocaching point or something else (we are using atype
    and not type to avoid conflicts with the internal type() function).
  id: totrans-1612
  prefs: []
  type: TYPE_NORMAL
  zh: GeoObject类代表一个单独的对象（表中的一行）。它可以在geom字段中接受任何类型的几何形状（一个点、多边形等）。atype属性代表对象的高级类型。这个属性将告诉我们它是一个地理藏宝点还是其他东西（我们使用atype而不是type是为了避免与内部type()函数冲突）。
- en: Finally, the objects property represents the collection of GeoObject (the table
    in the database). In Django this is called a **manager**; don’t worry, we will
    see more about this later.
  id: totrans-1613
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，objects属性代表GeoObject集合（数据库中的表）。在Django中，这被称为**管理器**；不要担心，我们稍后会看到更多关于这个的内容。
- en: 2\. Now we need the tags for our GeoObject; the tags will contain every attribute.
    Add another class after the GeoObject class.
  id: totrans-1614
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 现在我们需要为GeoObject添加标签；标签将包含每个属性。在GeoObject类之后添加另一个类。
- en: 'class Tag(models.Model):'
  id: totrans-1615
  prefs: []
  type: TYPE_NORMAL
  zh: 'class Tag(models.Model):'
- en: key = models.CharField(max_length=250)
  id: totrans-1616
  prefs: []
  type: TYPE_NORMAL
  zh: key = models.CharField(max_length=250)
- en: value = models.CharField(max_length=250)
  id: totrans-1617
  prefs: []
  type: TYPE_NORMAL
  zh: value = models.CharField(max_length=250)
- en: geo_object = models.ForeignKey(GeoObject, related_name='tags') Again, this class
    represents a single object, a single tag with a key and a value that is connected
    with a GeoObject by a foreign key. The result is that a Tag class has a GeoObject
    and a GeoObject has many tags.
  id: totrans-1618
  prefs: []
  type: TYPE_NORMAL
  zh: geo_object = models.ForeignKey(GeoObject, related_name='tags') 再次，这个类代表一个单独的对象，一个带有键和值的单独标签，通过外键与GeoObject连接。结果是，Tag类有一个GeoObject，而GeoObject有多个标签。
- en: '**Customizing a manager**'
  id: totrans-1619
  prefs: []
  type: TYPE_NORMAL
  zh: '**自定义管理器**'
- en: As said before, a manager can be considered as something that represents a table
    in a database. It contains methods to retrieve records, add, delete, and many
    other operations.
  id: totrans-1620
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，经理可以被视为数据库中表的一种表示。它包含检索记录、添加、删除以及许多其他操作的方法。
- en: Django comes with the GeoManager class that is used for tables that contain
    spatial objects. If we want to add more functionalities to our GeoData manager,
    we just need to inherit from GeoManager and then add a class property with an
    instance of it in the GeoObject class. Actually, we will just replace the instance
    in the objects property.
  id: totrans-1621
  prefs: []
  type: TYPE_NORMAL
  zh: Django附带了一个GeoManager类，用于包含空间对象的表。如果我们想为我们的GeoData管理器添加更多功能，我们只需要从GeoManager继承，然后在GeoObject类中添加一个具有其实例的类属性。实际上，我们只是替换了objects属性中的实例。
- en: 'Let’s adapt our BaseGeoCollection class to be a manager for the GeoObject class:
    1\. Navigate to your Chapter8/models.py file (the one that we wrote in previous
    chapters) and rename it to Chapter8/old_models.py. With this, we avoid confusion
    about which model we are talking about.'
  id: totrans-1622
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将我们的BaseGeoCollection类调整为GeoObject类的管理器：1. 导航到你的Chapter8/models.py文件（我们在前面的章节中编写的那个文件）并将其重命名为Chapter8/old_models.py。通过这样做，我们可以避免混淆，不清楚我们在谈论哪个模型。
- en: '2\. Create a file named managers.py inside the geodata folder. Add this code
    to the file:'
  id: totrans-1623
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 在geodata文件夹内创建一个名为managers.py的文件。将以下代码添加到该文件中：
- en: coding=utf-8
  id: totrans-1624
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: coding=utf-8
- en: from django.contrib.gis.db.models import GeoManager
  id: totrans-1625
  prefs: []
  type: TYPE_NORMAL
  zh: from django.contrib.gis.db.models import GeoManager
- en: from utils.geo_functions import open_vector_file
  id: totrans-1626
  prefs: []
  type: TYPE_NORMAL
  zh: from utils.geo_functions import open_vector_file
- en: 'class GeoCollection(GeoManager):'
  id: totrans-1627
  prefs: []
  type: TYPE_NORMAL
  zh: 'class GeoCollection(GeoManager):'
- en: '"""This class represents a collection of spatial data."""'
  id: totrans-1628
  prefs: []
  type: TYPE_NORMAL
  zh: '"""这个类代表空间数据集合。"""'
- en: Pass
  id: totrans-1629
  prefs: []
  type: TYPE_NORMAL
  zh: Pass
- en: 'This is the first step in migrating our BaseGeoCollection class. Note that
    we named it GeoCollection because it won’t be a base class anymore. We will simplify
    our code so this class will manage all types of geo objects. To do that, we will
    add the import_data method from the BaseGeoCollection class and combine it with
    the _parse_data method from the PointCollection class. Before we continue, let’s
    take a look at these methods as they are (you don’t need to type this code):'
  id: totrans-1630
  prefs: []
  type: TYPE_NORMAL
  zh: 这是迁移我们的 BaseGeoCollection 类的第一步。请注意，我们将其命名为 GeoCollection，因为它将不再是基类。我们将简化我们的代码，这样这个类将管理所有类型的地理对象。为此，我们将从
    BaseGeoCollection 类中添加 import_data 方法，并将其与 PointCollection 类中的 _parse_data 方法结合。在我们继续之前，让我们看看这些方法现在的样子（你不需要输入此代码）：
- en: '#...'
  id: totrans-1631
  prefs: []
  type: TYPE_NORMAL
  zh: '#...'
- en: 'def import_data(self, file_path):'
  id: totrans-1632
  prefs: []
  type: TYPE_NORMAL
  zh: 'def import_data(self, file_path):'
- en: '"""Opens an vector file compatible with OGR and parses the data.'
  id: totrans-1633
  prefs: []
  type: TYPE_NORMAL
  zh: '"""打开与 OGR 兼容的矢量文件并解析数据。'
- en: ':param str file_path: The full path to the file.'
  id: totrans-1634
  prefs: []
  type: TYPE_NORMAL
  zh: ':param str file_path: 文件的完整路径。'
- en: '"""'
  id: totrans-1635
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: features, metadata = open_vector_file(file_path)
  id: totrans-1636
  prefs: []
  type: TYPE_NORMAL
  zh: features, metadata = open_vector_file(file_path)
- en: self._parse_data(features)
  id: totrans-1637
  prefs: []
  type: TYPE_NORMAL
  zh: self._parse_data(features)
- en: self.epsg = metadata['epsg']
  id: totrans-1638
  prefs: []
  type: TYPE_NORMAL
  zh: self.epsg = metadata['epsg']
- en: 'print("File imported: {}".format(file_path))'
  id: totrans-1639
  prefs: []
  type: TYPE_NORMAL
  zh: 'print("文件导入成功: {}".format(file_path))'
- en: '#...'
  id: totrans-1640
  prefs: []
  type: TYPE_NORMAL
  zh: '#...'
- en: 'def _parse_data(self, features):'
  id: totrans-1641
  prefs: []
  type: TYPE_NORMAL
  zh: 'def _parse_data(self, features):'
- en: '"""Transforms the data into Geocache objects.'
  id: totrans-1642
  prefs: []
  type: TYPE_NORMAL
  zh: '"""将数据转换为 Geocache 对象。'
- en: ':param features: A list of features.'
  id: totrans-1643
  prefs: []
  type: TYPE_NORMAL
  zh: ':param features: 特征列表。'
- en: '"""'
  id: totrans-1644
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: 'for feature in features:'
  id: totrans-1645
  prefs: []
  type: TYPE_NORMAL
  zh: 'for feature in features:'
- en: coords = feature['geometry']['coordinates']
  id: totrans-1646
  prefs: []
  type: TYPE_NORMAL
  zh: coords = feature['geometry']['coordinates']
- en: point = Point(float(coords[1]), float(coords[0]))
  id: totrans-1647
  prefs: []
  type: TYPE_NORMAL
  zh: point = Point(float(coords[1]), float(coords[0]))
- en: attributes = feature['properties']
  id: totrans-1648
  prefs: []
  type: TYPE_NORMAL
  zh: attributes = feature['properties']
- en: cache_point = Geocache(point, attributes=attributes)
  id: totrans-1649
  prefs: []
  type: TYPE_NORMAL
  zh: cache_point = Geocache(point, attributes=attributes)
- en: self.data.append(cache_point)
  id: totrans-1650
  prefs: []
  type: TYPE_NORMAL
  zh: self.data.append(cache_point)
- en: Note that import_data opens the vector file and then sends the features to _parse_data,
    which iterates over the data, creating points and putting the feature properties
    into a dictionary. If we manage to import any kind of geometry and pass the feature
    properties to the tag model, we end with a piece of code that will serve any kind
    of geospatial object.
  id: totrans-1651
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，import_data 函数首先打开矢量文件，然后将特征发送到 _parse_data 函数，该函数遍历数据，创建点并将特征属性放入字典中。如果我们成功导入任何类型的几何形状并将特征属性传递给标签模型，我们最终将得到一段代码，它可以服务于任何类型的地理空间对象。
- en: 3\. Edit the code in geodata/managers.py again. Whether you want to copy and
    edit the mentioned methods or type the new import_data method from scratch is
    up to you.
  id: totrans-1652
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 再次编辑 geodata/managers.py 中的代码。无论你是想复制并编辑提到的函数还是从头开始输入新的 import_data 方法，都取决于你。
- en: 'The resulting code should be the following:'
  id: totrans-1653
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的代码应该是以下内容：
- en: coding=utf-8
  id: totrans-1654
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: coding=utf-8
- en: from django.contrib.gis.db.models import GeoManager
  id: totrans-1655
  prefs: []
  type: TYPE_NORMAL
  zh: from django.contrib.gis.db.models import GeoManager
- en: from django.db import IntegrityError, DataError
  id: totrans-1656
  prefs: []
  type: TYPE_NORMAL
  zh: from django.db import IntegrityError, DataError
- en: from utils.geo_functions import open_vector_file
  id: totrans-1657
  prefs: []
  type: TYPE_NORMAL
  zh: from utils.geo_functions import open_vector_file
- en: from shapely.geometry import shape
  id: totrans-1658
  prefs: []
  type: TYPE_NORMAL
  zh: from shapely.geometry import shape
- en: 'class GeoCollection(GeoManager):'
  id: totrans-1659
  prefs: []
  type: TYPE_NORMAL
  zh: 'class GeoCollection(GeoManager):'
- en: '"""This class represents a collection of spatial data."""'
  id: totrans-1660
  prefs: []
  type: TYPE_NORMAL
  zh: '"""这个类代表一组空间数据。”'
- en: 'def import_data(self, file_path, atype):'
  id: totrans-1661
  prefs: []
  type: TYPE_NORMAL
  zh: 'def import_data(self, file_path, atype):'
- en: '"""Opens an vector file compatible with OGR and parses the data.'
  id: totrans-1662
  prefs: []
  type: TYPE_NORMAL
  zh: '"""打开与 OGR 兼容的矢量文件并解析数据。'
- en: ':param str file_path: The full path to the file.'
  id: totrans-1663
  prefs: []
  type: TYPE_NORMAL
  zh: ':param str file_path: 文件的完整路径。'
- en: '"""'
  id: totrans-1664
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: features = open_vector_file(file_path)
  id: totrans-1665
  prefs: []
  type: TYPE_NORMAL
  zh: features, metadata = open_vector_file(file_path)
- en: 'for feature in features:'
  id: totrans-1666
  prefs: []
  type: TYPE_NORMAL
  zh: 'for feature in features:'
- en: geom = shape(feature['geometry'])
  id: totrans-1667
  prefs: []
  type: TYPE_NORMAL
  zh: geom = shape(feature['geometry'])
- en: geo_object = self.model(geom=geom.wkt, atype=atype)
  id: totrans-1668
  prefs: []
  type: TYPE_NORMAL
  zh: geo_object = self.model(geom=geom.wkt, atype=atype)
- en: geo_object.save()
  id: totrans-1669
  prefs: []
  type: TYPE_NORMAL
  zh: geo_object.save()
- en: 'for key, value in feature[''properties''].iteritems():'
  id: totrans-1670
  prefs: []
  type: TYPE_NORMAL
  zh: 'for key, value in feature[''properties''].iteritems():'
- en: 'try:'
  id: totrans-1671
  prefs: []
  type: TYPE_NORMAL
  zh: 'try:'
- en: geo_object.tags.create(key=key, value=value)
  id: totrans-1672
  prefs: []
  type: TYPE_NORMAL
  zh: geo_object.tags.create(key=key, value=value)
- en: 'except (IntegrityError, DataError):'
  id: totrans-1673
  prefs: []
  type: TYPE_NORMAL
  zh: 'except (IntegrityError, DataError):'
- en: pass
  id: totrans-1674
  prefs: []
  type: TYPE_NORMAL
  zh: pass
- en: 'print("File imported: {}".format(file_path))'
  id: totrans-1675
  prefs: []
  type: TYPE_NORMAL
  zh: 'print("文件导入成功: {}".format(file_path))'
- en: We used Shapley’s shape function to directly convert feature['geometry'], which
    is a GeoJSON geometry-like dictionary, into a shapely geometry of the correct
    type.
  id: totrans-1676
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了 Shapley 的 shape 函数，直接将 feature['geometry']（一个类似于 GeoJSON 几何的字典）转换为正确的
    shapely 几何类型。
- en: Then we used that geometry to get a WKT representation of it.
  id: totrans-1677
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用该几何形状来获取其 WKT 表示形式。
- en: The atype argument was included on the method, so we can use it to define the
    type of the GeoObject. Remember that atype is not a type of geometry; it represents
    the high-level type of the object (geocaching, boundary, road, river, waypoint,
    and so on).
  id: totrans-1678
  prefs: []
  type: TYPE_NORMAL
  zh: 方法中包含了 atype 参数，我们可以用它来定义 GeoObject 的类型。请记住，atype 不是一个几何类型；它代表对象的较高层次类型（地理缓存、边界、道路、河流、航点等）。
- en: 'In the statement geo_object = self.model(geom=geom.wkt, atype=atype), we see
    a great feature of Django managers: the same manager can be used by many models,
    and self.model contains a reference to the class that this manager was called
    from.'
  id: totrans-1679
  prefs: []
  type: TYPE_NORMAL
  zh: 在语句geo_object = self.model(geom=geom.wkt, atype=atype)中，我们看到了Django管理器的伟大特性：相同的管理器可以被多个模型使用，self.model包含了对从该管理器被调用的类的引用。
- en: If we had decided on another design pattern and used one class for each object
    type, we would still be able to use the same manager for all of them.
  id: totrans-1680
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们决定采用另一种设计模式，并为每种对象类型使用一个类，我们仍然可以使用相同的管理器来管理所有这些。
- en: 'In the sequence, the model is saved and then the properties dictionary is iterated
    and for every item a tag is created. We are catching exceptions here because we
    have two special conditions that may happen: if the value of a property is None
    it will raise an IntegrityError; if the length of the value is larger than 250,
    it will raise a DataError. If you are interested in long fields, such as the logs
    from the geocaching data, you can increase the field max_length or try a different
    field type.'
  id: totrans-1681
  prefs: []
  type: TYPE_NORMAL
  zh: 按顺序，模型被保存，然后遍历属性字典，并为每个项目创建一个标签。我们在这里捕获异常，因为我们有两个可能发生的特殊条件：如果属性的值为None，它将引发IntegrityError；如果值的长度大于250，它将引发DataError。如果你对长字段感兴趣，例如来自地理藏宝数据的日志，你可以增加字段max_length或尝试不同的字段类型。
- en: '4\. We are not using the metadata here, and reading it can cause an incompatibility
    error between libraries for Windows users. So we will remove it from the open_vector_file
    function. Edit your utils/geo_functions.py file to change this function. As a
    plus, let’s print the number of features read: def open_vector_file(file_path):'
  id: totrans-1682
  prefs: []
  type: TYPE_NORMAL
  zh: '4. 我们在这里不使用元数据，读取它可能会在Windows用户之间引起库不兼容错误。因此，我们将从open_vector_file函数中删除它。编辑你的utils/geo_functions.py文件以更改此函数。此外，让我们打印读取到的要素数量：def
    open_vector_file(file_path):'
- en: '"""Opens an vector file compatible with OGR or a GPX file.'
  id: totrans-1683
  prefs: []
  type: TYPE_NORMAL
  zh: '"""打开与OGR兼容的矢量文件或GPX文件。'
- en: Returns a list of features and informations about the file.
  id: totrans-1684
  prefs: []
  type: TYPE_NORMAL
  zh: 返回要素列表和有关文件的信息。
- en: ':param str file_path: The full path to the file.'
  id: totrans-1685
  prefs: []
  type: TYPE_NORMAL
  zh: ':param str file_path: 文件的完整路径。'
- en: '"""'
  id: totrans-1686
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: datasource = ogr.Open(file_path)
  id: totrans-1687
  prefs: []
  type: TYPE_NORMAL
  zh: datasource = ogr.Open(file_path)
- en: Check if the file was opened.
  id: totrans-1688
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查文件是否已打开。
- en: 'if not datasource:'
  id: totrans-1689
  prefs: []
  type: TYPE_NORMAL
  zh: 'if not datasource:'
- en: 'if not os.path.isfile(file_path):'
  id: totrans-1690
  prefs: []
  type: TYPE_NORMAL
  zh: 'if not os.path.isfile(file_path):'
- en: message = "Wrong path."
  id: totrans-1691
  prefs: []
  type: TYPE_NORMAL
  zh: message = "Wrong path."
- en: 'else:'
  id: totrans-1692
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: message = "File format is invalid."
  id: totrans-1693
  prefs: []
  type: TYPE_NORMAL
  zh: message = "File format is invalid."
- en: raise IOError('Error opening the file {}\n{}'.format(
  id: totrans-1694
  prefs: []
  type: TYPE_NORMAL
  zh: raise IOError('Error opening the file {}\n{}'.format(
- en: file_path, message))
  id: totrans-1695
  prefs: []
  type: TYPE_NORMAL
  zh: file_path, message))
- en: file_name, file_extension = os.path.splitext(file_path)
  id: totrans-1696
  prefs: []
  type: TYPE_NORMAL
  zh: file_name, file_extension = os.path.splitext(file_path)
- en: Check if it's a GPX and read it if so.
  id: totrans-1697
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查它是否是GPX，如果是，则读取它。
- en: 'if file_extension in [''.gpx'', ''.GPX'']:'
  id: totrans-1698
  prefs: []
  type: TYPE_NORMAL
  zh: 'if file_extension in [''.gpx'', ''.GPX'']:'
- en: features = read_gpx_file(file_path)
  id: totrans-1699
  prefs: []
  type: TYPE_NORMAL
  zh: features = read_gpx_file(file_path)
- en: If not, use OGR to get the features.
  id: totrans-1700
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如果不是，请使用OGR获取要素。
- en: 'else:'
  id: totrans-1701
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: features = read_ogr_features(datasource.GetLayerByIndex(0)) print("{} features.".format(len(features)))
  id: totrans-1702
  prefs: []
  type: TYPE_NORMAL
  zh: features = read_ogr_features(datasource.GetLayerByIndex(0)) print("{} features.".format(len(features)))
- en: return features
  id: totrans-1703
  prefs: []
  type: TYPE_NORMAL
  zh: return features
- en: '5\. Finally, edit geodata/models.py to import and use the new manager:'
  id: totrans-1704
  prefs: []
  type: TYPE_NORMAL
  zh: 5. 最后，编辑geodata/models.py以导入和使用新的管理器：
- en: coding=utf-8
  id: totrans-1705
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: coding=utf-8
- en: from django.contrib.gis.db import models
  id: totrans-1706
  prefs: []
  type: TYPE_NORMAL
  zh: from django.contrib.gis.db import models
- en: from managers import GeoCollection
  id: totrans-1707
  prefs: []
  type: TYPE_NORMAL
  zh: from managers import GeoCollection
- en: 'class GeoObject(models.Model):'
  id: totrans-1708
  prefs: []
  type: TYPE_NORMAL
  zh: 'class GeoObject(models.Model):'
- en: geom = models.GeometryField()
  id: totrans-1709
  prefs: []
  type: TYPE_NORMAL
  zh: geom = models.GeometryField()
- en: atype = models.CharField(max_length=20)
  id: totrans-1710
  prefs: []
  type: TYPE_NORMAL
  zh: atype = models.CharField(max_length=20)
- en: objects = GeoCollection()
  id: totrans-1711
  prefs: []
  type: TYPE_NORMAL
  zh: objects = GeoCollection()
- en: 'class Tag(models.Model):'
  id: totrans-1712
  prefs: []
  type: TYPE_NORMAL
  zh: 'class Tag(models.Model):'
- en: key = models.CharField(max_length=250)
  id: totrans-1713
  prefs: []
  type: TYPE_NORMAL
  zh: key = models.CharField(max_length=250)
- en: value = models.CharField(max_length=250)
  id: totrans-1714
  prefs: []
  type: TYPE_NORMAL
  zh: value = models.CharField(max_length=250)
- en: 'geo_object = models.ForeignKey(GeoObject, related_name=''tags'') We are almost
    ready to begin testing. At this point, your Chapter 8 structure should be like
    this:'
  id: totrans-1715
  prefs: []
  type: TYPE_NORMAL
  zh: geo_object = models.ForeignKey(GeoObject, related_name='tags') 我们几乎准备好开始测试了。此时，你的第8章结构应该是这样的：
- en: +---Chapter8
  id: totrans-1716
  prefs: []
  type: TYPE_NORMAL
  zh: +---Chapter8
- en: '| geocaching_app.py'
  id: totrans-1717
  prefs: []
  type: TYPE_NORMAL
  zh: '| geocaching_app.py'
- en: '| geodata_app.py'
  id: totrans-1718
  prefs: []
  type: TYPE_NORMAL
  zh: '| geodata_app.py'
- en: '| map_maker_app.py'
  id: totrans-1719
  prefs: []
  type: TYPE_NORMAL
  zh: '| map_maker_app.py'
- en: '| models_old.py'
  id: totrans-1720
  prefs: []
  type: TYPE_NORMAL
  zh: '| models_old.py'
- en: '| raster_data.py'
  id: totrans-1721
  prefs: []
  type: TYPE_NORMAL
  zh: '| raster_data.py'
- en: '| settings.py'
  id: totrans-1722
  prefs: []
  type: TYPE_NORMAL
  zh: '| settings.py'
- en: '| settings.pyc'
  id: totrans-1723
  prefs: []
  type: TYPE_NORMAL
  zh: '| settings.pyc'
- en: '| __init__.py'
  id: totrans-1724
  prefs: []
  type: TYPE_NORMAL
  zh: '| __init__.py'
- en: '|'
  id: totrans-1725
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: +---experiments
  id: totrans-1726
  prefs: []
  type: TYPE_NORMAL
  zh: +---experiments
- en: '|'
  id: totrans-1727
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: +---geodata
  id: totrans-1728
  prefs: []
  type: TYPE_NORMAL
  zh: +---geodata
- en: '| | managers.py'
  id: totrans-1729
  prefs: []
  type: TYPE_NORMAL
  zh: '| | managers.py'
- en: '| | models.py'
  id: totrans-1730
  prefs: []
  type: TYPE_NORMAL
  zh: '| | models.py'
- en: '| | __init__.py'
  id: totrans-1731
  prefs: []
  type: TYPE_NORMAL
  zh: '| | __init__.py'
- en: '|'
  id: totrans-1732
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: +---map_maker
  id: totrans-1733
  prefs: []
  type: TYPE_NORMAL
  zh: +---map_maker
- en: '|'
  id: totrans-1734
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: +---output
  id: totrans-1735
  prefs: []
  type: TYPE_NORMAL
  zh: +---output
- en: '|'
  id: totrans-1736
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: \---utils
  id: totrans-1737
  prefs: []
  type: TYPE_NORMAL
  zh: \---utils
- en: check_plugins.py
  id: totrans-1738
  prefs: []
  type: TYPE_NORMAL
  zh: check_plugins.py
- en: data_transfer.py
  id: totrans-1739
  prefs: []
  type: TYPE_NORMAL
  zh: data_transfer.py
- en: geo_functions.py
  id: totrans-1740
  prefs: []
  type: TYPE_NORMAL
  zh: geo_functions.py
- en: '**Generating the tables and importing data** Now it’s time to make Django generate
    the database tables for us. Since our models are defined, we just need to call
    a pair of commands and Django will perform its magic.'
  id: totrans-1741
  prefs: []
  type: TYPE_NORMAL
  zh: '**生成表和导入数据** 现在是时候让 Django 为我们生成数据库表了。由于我们的模型已经定义，我们只需要调用一对命令，Django 就会施展其魔法。'
- en: '1\. Go back to the geodata_app.py file and add some content to it:'
  id: totrans-1742
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 返回 geodata_app.py 文件并添加一些内容：
- en: coding=utf-8
  id: totrans-1743
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: coding=utf-8
- en: import os
  id: totrans-1744
  prefs: []
  type: TYPE_NORMAL
  zh: import os
- en: import django
  id: totrans-1745
  prefs: []
  type: TYPE_NORMAL
  zh: import django
- en: os.environ.setdefault("DJANGO_SETTINGS_MODULE", "settings") django.setup()
  id: totrans-1746
  prefs: []
  type: TYPE_NORMAL
  zh: os.environ.setdefault("DJANGO_SETTINGS_MODULE", "settings") django.setup()
- en: from django.core.management import call_command
  id: totrans-1747
  prefs: []
  type: TYPE_NORMAL
  zh: from django.core.management import call_command
- en: from geodata.models import *
  id: totrans-1748
  prefs: []
  type: TYPE_NORMAL
  zh: from geodata.models import *
- en: 'def prepare_database():'
  id: totrans-1749
  prefs: []
  type: TYPE_NORMAL
  zh: 'def prepare_database():'
- en: '"""Call this to setup the database or any time you change your models.'
  id: totrans-1750
  prefs: []
  type: TYPE_NORMAL
  zh: '"""在设置数据库或更改模型时调用此命令。”'
- en: '"""'
  id: totrans-1751
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: call_command('makemigrations', 'geodata')
  id: totrans-1752
  prefs: []
  type: TYPE_NORMAL
  zh: call_command('makemigrations', 'geodata')
- en: call_command('migrate', 'geodata')
  id: totrans-1753
  prefs: []
  type: TYPE_NORMAL
  zh: call_command('migrate', 'geodata')
- en: 'if __name__ == ''__main__'':'
  id: totrans-1754
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == ''__main__'':'
- en: prepare_database()
  id: totrans-1755
  prefs: []
  type: TYPE_NORMAL
  zh: prepare_database()
- en: After we import os and django we need to specify which settings file it should
    look for. After that, django.setup() initializes Django.
  id: totrans-1756
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们导入 os 和 django 之后，我们需要指定它应该查找哪个设置文件。之后，django.setup() 初始化 Django。
- en: The prepare_database function calls two Django management commands responsible
    for database creation. We will need to call it every time we change our models.
    Internally, Django keeps a record of the changes made and automatically generates
    SQL queries that perform the modifications on the database.
  id: totrans-1757
  prefs: []
  type: TYPE_NORMAL
  zh: The prepare_database 函数调用两个负责数据库创建的 Django 管理命令。每次我们更改我们的模型时，都需要调用它。内部，Django
    会记录所做的更改并自动生成执行数据库修改的 SQL 查询。
- en: '2\. Run your code now. If everything goes fine, you should see the database
    migration results in the output:'
  id: totrans-1758
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 现在运行你的代码。如果一切顺利，你应该会在输出中看到数据库迁移的结果：
- en: 'Migrations for ''geodata'':'
  id: totrans-1759
  prefs: []
  type: TYPE_NORMAL
  zh: 'Migrations for ''geodata'':'
- en: '0001_initial.py:'
  id: totrans-1760
  prefs: []
  type: TYPE_NORMAL
  zh: '0001_initial.py:'
- en: '- Create model GeoObject'
  id: totrans-1761
  prefs: []
  type: TYPE_NORMAL
  zh: '- 创建模型 GeoObject'
- en: '- Create model Tag'
  id: totrans-1762
  prefs: []
  type: TYPE_NORMAL
  zh: '- 创建模型 Tag'
- en: 'Operations to perform:'
  id: totrans-1763
  prefs: []
  type: TYPE_NORMAL
  zh: 需要执行的操作：
- en: 'Apply all migrations: geodata'
  id: totrans-1764
  prefs: []
  type: TYPE_NORMAL
  zh: 'Apply all migrations: geodata'
- en: 'Running migrations:'
  id: totrans-1765
  prefs: []
  type: TYPE_NORMAL
  zh: 'Running migrations:'
- en: Rendering model states… DONE
  id: totrans-1766
  prefs: []
  type: TYPE_NORMAL
  zh: Rendering model states… DONE
- en: Applying geodata.0001_initial… OK
  id: totrans-1767
  prefs: []
  type: TYPE_NORMAL
  zh: Applying geodata.0001_initial… OK
- en: Process finished with exit code 0
  id: totrans-1768
  prefs: []
  type: TYPE_NORMAL
  zh: Process finished with exit code 0
- en: 3\. Now, edit geodata_app.py again to add a convenience function to import some
    data.
  id: totrans-1769
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 现在，再次编辑 geodata_app.py 以添加一个导入一些数据的方便函数。
- en: 'We will begin with the geocaching data as a test:'
  id: totrans-1770
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用地理藏宝数据作为测试：
- en: coding=utf-8
  id: totrans-1771
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: coding=utf-8
- en: import os
  id: totrans-1772
  prefs: []
  type: TYPE_NORMAL
  zh: import os
- en: import django
  id: totrans-1773
  prefs: []
  type: TYPE_NORMAL
  zh: import django
- en: os.environ.setdefault("DJANGO_SETTINGS_MODULE", "settings") django.setup()
  id: totrans-1774
  prefs: []
  type: TYPE_NORMAL
  zh: os.environ.setdefault("DJANGO_SETTINGS_MODULE", "settings") django.setup()
- en: from django.core.management import call_command
  id: totrans-1775
  prefs: []
  type: TYPE_NORMAL
  zh: from django.core.management import call_command
- en: from geodata.models import *
  id: totrans-1776
  prefs: []
  type: TYPE_NORMAL
  zh: from geodata.models import *
- en: 'def prepare_database():'
  id: totrans-1777
  prefs: []
  type: TYPE_NORMAL
  zh: 'def prepare_database():'
- en: '"""Call this to setup the database or any time you change your models.'
  id: totrans-1778
  prefs: []
  type: TYPE_NORMAL
  zh: '"""在设置数据库或更改模型时调用此命令。'
- en: '"""'
  id: totrans-1779
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: call_command('makemigrations', 'geodata')
  id: totrans-1780
  prefs: []
  type: TYPE_NORMAL
  zh: call_command('makemigrations', 'geodata')
- en: call_command('migrate', 'geodata')
  id: totrans-1781
  prefs: []
  type: TYPE_NORMAL
  zh: call_command('migrate', 'geodata')
- en: 'def import_initial_data(input_file, atype):'
  id: totrans-1782
  prefs: []
  type: TYPE_NORMAL
  zh: 'def import_initial_data(input_file, atype):'
- en: '"""Import new data into the database."""'
  id: totrans-1783
  prefs: []
  type: TYPE_NORMAL
  zh: '"""将新数据导入数据库。”'
- en: print("Importing {}...".format(atype))
  id: totrans-1784
  prefs: []
  type: TYPE_NORMAL
  zh: print("Importing {}...".format(atype))
- en: GeoObject.objects.import_data(input_file, atype)
  id: totrans-1785
  prefs: []
  type: TYPE_NORMAL
  zh: GeoObject.objects.import_data(input_file, atype)
- en: print("Done!")
  id: totrans-1786
  prefs: []
  type: TYPE_NORMAL
  zh: print("Done!")
- en: 'if __name__ == ''__main__'':'
  id: totrans-1787
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == ''__main__'':'
- en: prepare_database()
  id: totrans-1788
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: prepare_database()
- en: import_initial_data("../data/geocaching.gpx", 'geocaching') This new function
    is only a convenience function to reduce typing since we will import a lot of
    data very soon. We are commenting the prepare_database() statement because we
    will use it later.
  id: totrans-1789
  prefs: []
  type: TYPE_NORMAL
  zh: import_initial_data("../data/geocaching.gpx", 'geocaching') 这个新函数仅是一个方便函数，以减少输入，因为我们很快就会导入大量数据。我们正在注释掉
    prepare_database() 语句，因为我们稍后会使用它。
- en: '4\. Run your code (make sure you run it only once to avoid duplicated entries).
    In your output you should see this:'
  id: totrans-1790
  prefs: []
  type: TYPE_NORMAL
  zh: 4. 现在运行你的代码（确保只运行一次以避免重复条目）。在你的输出中你应该看到以下内容：
- en: Importing geocaching…
  id: totrans-1791
  prefs: []
  type: TYPE_NORMAL
  zh: Importing geocaching…
- en: 112 features.
  id: totrans-1792
  prefs: []
  type: TYPE_NORMAL
  zh: 112 个特征。
- en: Done!
  id: totrans-1793
  prefs: []
  type: TYPE_NORMAL
  zh: Done!
- en: Process finished with exit code 0
  id: totrans-1794
  prefs: []
  type: TYPE_NORMAL
  zh: Process finished with exit code 0
- en: '**Filtering the data**'
  id: totrans-1795
  prefs: []
  type: TYPE_NORMAL
  zh: '**过滤数据**'
- en: Now that we have some data in the database, it’s time to test it and see if
    we can filter some points as we did before.
  id: totrans-1796
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们数据库中有了一些数据，是时候测试它并看看我们是否能像之前那样过滤一些点。
- en: '1\. Edit your if __name__ == ''__main__'': block (remember to comment the previous
    commands):'
  id: totrans-1797
  prefs: []
  type: TYPE_NORMAL
  zh: '1. 编辑你的 if __name__ == ''__main__'': 块（记得注释掉之前的命令）：'
- en: 'if __name__ == ''__main__'':'
  id: totrans-1798
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == ''__main__'':'
- en: prepare_database()
  id: totrans-1799
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: prepare_database()
- en: import_initial_data("../data/geocaching.gpx", 'geocaching') points = GeoObject.objects.filter(atype='geocaching',
  id: totrans-1800
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从'../data/geocaching.gpx'导入初始数据('geocaching') points = GeoObject.objects.filter(atype='geocaching',
- en: tags__key='status',
  id: totrans-1801
  prefs: []
  type: TYPE_NORMAL
  zh: tags__key='状态',
- en: tags__value='Available')
  id: totrans-1802
  prefs: []
  type: TYPE_NORMAL
  zh: tags__value='可用')
- en: print(len(points))
  id: totrans-1803
  prefs: []
  type: TYPE_NORMAL
  zh: 打印(points的长度)
- en: 'for tag in points[0].tags.all():'
  id: totrans-1804
  prefs: []
  type: TYPE_NORMAL
  zh: 对于points[0].tags.all()中的每个tag：
- en: print(tag.key, tag.value)
  id: totrans-1805
  prefs: []
  type: TYPE_NORMAL
  zh: 打印(tag.key, tag.value)
- en: Here we are using the filter method inherited by our manager to filter the records
    of geocaching type. Plus we are accessing the related tags to filter only the
    available geocaches. This is done by using a double underscore after the property
    name. In the end, we print all the tags for the first of the points returned.
  id: totrans-1806
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用我们的管理器继承的过滤方法来过滤地理藏宝类型的相关记录。此外，我们通过在属性名后使用双下划线来访问相关的标签，以过滤仅可用的地理藏宝。这是通过打印返回的第一个点的所有标签来完成的。
- en: '2\. Run your code and you should see a list of tags like this: 224'
  id: totrans-1807
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 运行你的代码，你应该会看到一个类似这样的标签列表：224
- en: (u'type', u'Other')
  id: totrans-1808
  prefs: []
  type: TYPE_NORMAL
  zh: (u'类型', u'其他')
- en: (u'hints', u'under sign')
  id: totrans-1809
  prefs: []
  type: TYPE_NORMAL
  zh: (u'提示', u'在签名下')
- en: (u'time', u'2013-09-29T00:00:00Z')
  id: totrans-1810
  prefs: []
  type: TYPE_NORMAL
  zh: (u'时间', u'2013-09-29T00:00:00Z')
- en: (u'state', u'New York')
  id: totrans-1811
  prefs: []
  type: TYPE_NORMAL
  zh: (u'州', u'纽约')
- en: (u'country', u'United States')
  id: totrans-1812
  prefs: []
  type: TYPE_NORMAL
  zh: (u'国家', u'美国')
- en: (u'url', u'http://www.opencaching.us/viewcache.php?cacheid=1728') (u'name',
    u'LaSalle Park No 1')
  id: totrans-1813
  prefs: []
  type: TYPE_NORMAL
  zh: (u'URL', u'http://www.opencaching.us/viewcache.php?cacheid=1728') (u'名称', u'LaSalle
    Park No 1')
- en: (u'container', u'Virtual')
  id: totrans-1814
  prefs: []
  type: TYPE_NORMAL
  zh: (u'容器', u'虚拟')
- en: (u'src', u'www.opencaching.us')
  id: totrans-1815
  prefs: []
  type: TYPE_NORMAL
  zh: (u'来源', u'www.opencaching.us')
