- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Mathematical Plotting with Matplotlib
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Matplotlib 进行数学绘图
- en: Plotting is a fundamental tool in all of mathematics. A good plot can reveal
    hidden details, suggest future directions, verify results, or reinforce an argument.
    It is no surprise, then, that the scientific Python stack features a powerful
    and flexible plotting library called Matplotlib.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 绘图是数学中一项基础工具。一张好的图表能够揭示隐藏的细节，提示未来的方向，验证结果，或增强论点。因此，科学 Python 堆栈中自然有一个功能强大且灵活的绘图库——Matplotlib。
- en: In this chapter, we will plot functions and data in a variety of styles and
    create figures that are fully labeled and annotated. We will create three-dimensional
    plots, customize the appearance of figures, create figures that contain multiple
    plots using subplots, and save figures directly to files for applications that
    are not running in an interactive environment.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用多种样式绘制函数和数据，并创建完全标注和注释的图形。我们将创建三维图形，自定义图形的外观，使用子图创建包含多个绘图的图形，并将图形直接保存到文件中，适用于没有交互式环境的应用程序。
- en: Plotting is one of the most important aspects covered in this book. Plotting
    data, functions, or solutions can often help you gain an understanding of a problem
    that can really help to reason about your methods. We will see plotting again
    in every chapter of this book.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 绘图是本书中最重要的内容之一。绘制数据、函数或解通常可以帮助你更好地理解问题，这对于推理方法非常有帮助。在本书的每一章中，我们都会看到绘图的应用。
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Basic plotting with Matplotlib
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Matplotlib 进行基本绘图
- en: Adding subplots
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加子图
- en: Plotting with error bars
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绘制带误差条的图形
- en: Saving Matplotlib figures
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存 Matplotlib 图形
- en: Surface and contour plots
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 曲面图和等高线图
- en: Customizing three-dimensional plots
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义三维图形
- en: Plotting vector fields with quiver plots
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绘制带箭头的向量场
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The main plotting package for Python is Matplotlib, which can be installed
    using your favorite package manager, such as `pip`:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的主要绘图库是 Matplotlib，可以通过你喜欢的包管理工具（如 `pip`）进行安装：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This will install the most recent version of Matplotlib, which, at the time
    of writing this book, is version 3.5.2.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这将安装 Matplotlib 的最新版本，在编写本书时，版本为 3.5.2。
- en: 'Matplotlib contains numerous sub-packages, but the main `matplotlib.pyplot`
    package, which, by convention, is imported under the `plt` alias. This is achieved
    using the following `import` statement:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Matplotlib 包含了许多子包，但主要的 `matplotlib.pyplot` 包通常会被导入为 `plt` 别名。可以通过以下 `import`
    语句实现：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Many of the recipes in this chapter also require NumPy, which, as usual, is
    imported under the `np` alias.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的许多教程也需要使用 NumPy，通常通过 `np` 别名进行导入。
- en: The code for this chapter can be found in the `Chapter 02` folder of the GitHub
    repository at [https://github.com/PacktPublishing/Applying-Math-with-Python-2nd-Edition/tree/main/Chapter%2002](https://github.com/PacktPublishing/Applying-Math-with-Python-2nd-Edition/tree/main/Chapter%2002).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在 GitHub 仓库的 `Chapter 02` 文件夹中找到，地址为 [https://github.com/PacktPublishing/Applying-Math-with-Python-2nd-Edition/tree/main/Chapter%2002](https://github.com/PacktPublishing/Applying-Math-with-Python-2nd-Edition/tree/main/Chapter%2002)。
- en: Basic plotting with Matplotlib
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Matplotlib 进行基本绘图
- en: Plotting is an important part of understanding behavior. So much can be learned
    by simply plotting a function or data that would otherwise be hidden. In this
    recipe, we will walk through how to plot simple functions or data using Matplotlib,
    set the plotting style, and add labels to a plot.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 绘图是理解行为的一个重要部分。仅通过绘制一个函数或数据，可以学习到许多原本隐藏的信息。在本教程中，我们将演示如何使用 Matplotlib 绘制简单的函数或数据，设置绘图风格，并为绘图添加标签。
- en: Matplotlib is a very powerful plotting library, which means it can be rather
    intimidating to perform simple tasks with it. For users who are used to working
    with MATLAB and other mathematical software packages, there is a state-based interface
    called `pyplot`. There is also an `pyplot` interface is a convenient way to create
    basic objects.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Matplotlib 是一个非常强大的绘图库，这意味着它在执行简单任务时可能会让人感到有些复杂。对于习惯使用 MATLAB 和其他数学软件的用户，Matplotlib
    提供了一个基于状态的接口，称为 `pyplot`。`pyplot` 接口是创建基本对象的便捷方式。
- en: Getting ready
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Most commonly, the data that you wish to plot will be stored in two separate
    NumPy arrays, which we will label `x` and `y` for clarity (although this naming
    does not matter in practice). We will demonstrate plotting the graph of a function,
    so we will generate an array of `x` values and use the function to generate the
    corresponding `y` values. We’re going to plot three different functions over the
    range ![](img/Formula_02_001.png) on the same axes:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的情况是，您希望绘制的数据将存储在两个独立的 NumPy 数组中，我们为了清晰起见将其标记为 `x` 和 `y`（尽管在实际操作中这个命名并不重要）。我们将演示如何绘制一个函数的图形，因此我们将生成一组
    `x` 值，并使用该函数生成相应的 `y` 值。我们将绘制三个不同的函数，并在相同的坐标系上覆盖它们，范围为 ![](img/Formula_02_001.png)：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Let’s plot these three functions in Python using Matplotlib.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 Matplotlib 在 Python 中绘制这三种函数。
- en: How to do it...
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Before we can plot the function, we must generate `x` and `y` data to be plotted.
    If you are plotting existing data, you can skip these commands. We need to create
    a set of `x` values that cover the desired range, and then use the function to
    create `y` values:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在绘制函数之前，我们必须先生成要绘制的 `x` 和 `y` 数据。如果你正在绘制现有数据，可以跳过这些命令。我们需要创建一组覆盖所需范围的 `x` 值，然后使用函数生成相应的
    `y` 值：
- en: 'The `linspace` routine from NumPy is ideal for creating arrays of numbers for
    plotting. By default, it will create 50 equally spaced points between the specified
    arguments. The number of points can be customized by providing an additional argument,
    but 50 is sufficient for most cases:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: NumPy 中的 `linspace` 函数非常适合用于创建用于绘图的数值数组。默认情况下，它会在指定的参数之间创建 50 个等间距的点。可以通过提供额外的参数来自定义点的数量，但
    50 个点对于大多数情况来说已经足够：
- en: '[PRE3]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Once we have created `x` values, we can generate `y` values:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们创建了 `x` 值，我们就可以生成 `y` 值：
- en: '[PRE4]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To plot the data, we first need to create a new figure and attach axes objects,
    which can be achieved by calling the `plt.subplots` routine without any arguments:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了绘制数据，我们首先需要创建一个新图形并附加坐标轴对象，这可以通过调用没有任何参数的 `plt.subplots` 函数来实现：
- en: '[PRE7]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, we use the `plot` method on the `ax` object to plot the first function.
    The first two arguments are ![](img/Formula_02_002.png) and ![](img/Formula_02_003.png)
    coordinates to be plotted, and the third (optional) argument specifies that the
    line color should be black:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们在 `ax` 对象上使用 `plot` 方法绘制第一个函数。前两个参数是 ![](img/Formula_02_002.png) 和 ![](img/Formula_02_003.png)
    要绘制的坐标，第三个（可选）参数指定线条颜色为黑色：
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To help distinguish the plots for the other functions, we plot those with a
    dashed line and a dot-dash line:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助区分其他函数的绘图，我们使用虚线和点划线绘制它们：
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Every plot should have a title and axis labels. In this case, there isn’t anything
    interesting to label the axes with, so we just label them `"x"` and `"y"`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 每个绘图应该有一个标题和坐标轴标签。在这种情况下，没有什么特别的内容可以用来标注坐标轴，所以我们只是将它们标记为 `"x"` 和 `"y"`：
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let’s also add a legend to help you distinguish between the different function
    plots without having to look elsewhere to see which line is which:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再加上一个图例，帮助你区分不同函数的图形，而不必到处寻找哪条线代表哪个函数：
- en: '[PRE11]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Finally, let’s annotate the plot to mark the intersection between the functions
    ![](img/Formula_02_004.png) and ![](img/Formula_02_005.png) with text:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们在图形上加上注释，标出函数 ![](img/Formula_02_004.png) 和 ![](img/Formula_02_005.png)
    的交点，并添加文字说明：
- en: '[PRE12]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This will plot the `y` values against the `x` values on a new figure. If you
    are working within IPython or with a Jupyter notebook, then the plot should automatically
    appear at this point; otherwise, you might need to call the `plt.show` function
    to make the plot appear:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把 `y` 值与 `x` 值绘制在一个新的图形中。如果你在 IPython 或 Jupyter notebook 中工作，那么绘图应该会在这一点自动出现；否则，你可能需要调用
    `plt.show` 函数才能让图形显示出来：
- en: '[PRE13]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If you use `plt.show`, the figure should appear in a new window. We won’t add
    this command to any further recipes in this chapter, but you should be aware that
    you will need to use it if you are not working in an environment where plots will
    be rendered automatically, such as an IPython console or a Jupyter Notebook. The
    resulting plot should look something like the plot in *Figure 2**.1*:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用 `plt.show`，图形应该会出现在一个新窗口中。我们在本章中将不会在进一步的示例中加入此命令，但你应该知道，如果你不在自动渲染图形的环境中工作（如
    IPython 控制台或 Jupyter Notebook），你将需要使用此命令。生成的图形应该类似于 *图 2.1*：
- en: '![Figure 2.1 – Three functions on a single set of axes, each with a different
    style, with labels, legend, and an annotation](img/B19085_02_01.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.1 – 在同一坐标系中绘制三个不同风格的函数，带有标签、图例和注释](img/B19085_02_01.jpg)'
- en: Figure 2.1 – Three functions on a single set of axes, each with a different
    style, with labels, legend, and an annotation
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1 – 在一组坐标轴上绘制三个不同风格的函数，并添加标签、图例和注释
- en: Note
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you are using a Jupyter notebook and the `subplots` command, you must include
    the call to `subplots` within the same cell as the plotting commands or the figure
    will not be produced.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用 Jupyter Notebook 和 `subplots` 命令，必须将 `subplots` 的调用放在同一个单元格中，否则图形将无法生成。
- en: How it works…
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Here, we’re using the OOI because it allows us to keep track of exactly which
    figure and axes object we’re plotting on. This isn’t so important here where we
    have only a single `figure` and `axes`, but one can easily envisage situations
    where you might have two or more figures and axes concurrently. Another reason
    to follow this pattern is to be consistent when you add multiple subplots—see
    the *Adding* *subplots* recipe.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用 OOI（对象导向接口），因为它允许我们准确跟踪当前正在绘制的图形和坐标轴对象。在这里我们只有一个 `figure` 和一个 `axes`，这一点并不那么重要，但你可以很容易地设想出在同时有两个或多个图形和坐标轴的情况下，使用
    OOI 的好处。遵循这个模式的另一个原因是当你添加多个子图时保持一致性——参见*添加子图*配方。
- en: 'You can produce the same plot as in the recipe via the state-based interface
    by using the following sequence of commands:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过以下一系列命令，在基于状态的接口中生成与配方中相同的图：
- en: '[PRE14]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If there are currently no `Figure` or `Axes` objects, the `plt.plot` routine
    creates a new `Figure` object, adds a new `Axes` object to the figure, and populates
    this `Axes` object with the plotted data. A list of handles to the plotted lines
    is returned. Each of these handles is a `Lines2D` object. In this case, this list
    will contain a single `Lines2D` object. We could use this `Lines2D` object to
    further customize the appearance of the line later.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果当前没有 `Figure` 或 `Axes` 对象，`plt.plot` 例程将创建一个新的 `Figure` 对象，向该图形添加一个新的 `Axes`
    对象，并用绘制的数据填充这个 `Axes` 对象。此函数将返回一个包含已绘制线条的句柄列表。这些句柄是 `Lines2D` 对象。在这种情况下，列表将包含一个
    `Lines2D` 对象。我们可以使用这个 `Lines2D` 对象来进一步自定义线条的外观。
- en: Notice that in the preceding code, we combined all the calls to the `plot` routine
    together. This is also possible if you use the OOI; the state-based interface
    is passing the arguments to the axes method on the set of axes that it either
    retrieves or creates.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在上面的代码中，我们将所有 `plot` 例程的调用都结合在一起。如果你使用 OOI，这也是可能的；基于状态的接口将参数传递给它检索或创建的坐标轴方法。
- en: The object layer of Matplotlib interacts with a lower-level *backend*, which
    does the heavy lifting of producing the graphical plot. The `plt.show` function
    issues an instruction to the backend to render the current figure. There are a
    number of backends that can be used with Matplotlib, which can be customized by
    setting the `MPLBACKEND` environment variable, modifying the `matplotlibrc` file,
    or by calling `matplotlib.use` from within Python with the name of an alternative
    backend. By default, Matplotlib picks a backend that is appropriate for the platform
    (Windows, macOS, Linux) and purpose (interactive or non-interactive), based on
    which backends are available. For example, on the author’s system, the `QtAgg`
    backend is the default. This is an interactive backend based on the `QtCairo`
    backend, which uses the Cairo library for rendering.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Matplotlib 的对象层与一个较低级别的*后端*交互，后端负责执行绘制图形的繁重任务。`plt.show`函数向后端发出指令，要求其渲染当前的图形。Matplotlib
    可以使用多种后端，可以通过设置 `MPLBACKEND` 环境变量、修改 `matplotlibrc` 文件，或者通过在 Python 中调用 `matplotlib.use`
    并指定替代后端的名称来进行自定义。默认情况下，Matplotlib 会根据可用的后端和平台（Windows、macOS、Linux）以及用途（交互式或非交互式）选择一个合适的后端。例如，在作者的系统中，默认后端是
    `QtAgg`，这是一个基于 `QtCairo` 后端的交互式后端，后者使用 Cairo 库进行渲染。
- en: Note
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `plt.show` function does more than simply call the `show` method on a figure.
    It also hooks into an event loop to correctly display the figure. The `plt.show`
    routine should be used to display a figure, rather than the `show` method on a
    `Figure` object.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`plt.show` 函数不仅仅是调用图形上的 `show` 方法。它还连接到事件循环，以正确显示图形。应该使用 `plt.show` 例程来显示图形，而不是直接调用
    `Figure` 对象上的 `show` 方法。'
- en: The **format string** used to quickly specify the line style has three optional
    parts, each consisting of one or more characters. The first part controls the
    marker style, which is the symbol that is printed at each data point; the second
    controls the style of the line that connects the data points; the third controls
    the color of the plot. In this recipe, we only specified the line style. However,
    one could specify both line style and marker style or just marker style. If you
    only provide the marker style, no connecting lines are drawn between the points.
    This is useful for plotting discrete data where no interpolation between points
    is necessary.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 用于快速指定线条样式的**格式字符串**有三个可选部分，每个部分由一个或多个字符组成。第一部分控制标记样式，即在每个数据点上打印的符号；第二部分控制连接数据点的线条样式；第三部分控制图形的颜色。在本示例中，我们只指定了线条样式。然而，也可以同时指定线条样式和标记样式，或者只指定标记样式。如果只提供标记样式，则不会在点之间绘制连接线。这对于绘制离散数据非常有用，因为不需要在点之间进行插值。
- en: 'Four line-style parameters are available: a solid line (`-`), a dashed line
    (`--`), a dash-dot line (`-.`), or a dotted line (`:`). Only a limited number
    of colors can be specified in the format string; they are red, green, blue, cyan,
    yellow, magenta, black, and white. The character used in the format string is
    the first letter of each color (with the exception of black), so the corresponding
    characters are `r`, `g`, `b`, `c`, `y`, `m`, `k`, and `w`, respectively.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 提供了四种线条样式参数：实线（`-`）、虚线（`--`）、点划线（`-.`）和点线（`:`）。格式字符串中只能指定有限的颜色；它们分别是红色、绿色、蓝色、青色、黄色、品红色、黑色和白色。格式字符串中使用的字符是每种颜色的首字母（黑色除外），因此相应的字符是`r`、`g`、`b`、`c`、`y`、`m`、`k`和`w`。
- en: 'In the recipe, we saw three examples of these format strings: the single `k`
    format string only changed the color of the line and kept the other settings at
    default (small point markers and unbroken blue line); the `k--` and `k.-` format
    strings both changed the color and the line style. For an example of changing
    the point style, see the *There’s more...* section and *Figure 2**.2*:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们看到了三个格式字符串的例子：单一的`k`格式字符串只改变了线条的颜色，其他设置保持默认（小点标记和未断开的蓝线）；`k--`和`k.-`格式字符串都改变了颜色和线条样式。关于更改点样式的示例，请参见*更多内容...*部分和*图
    2.2*：
- en: '![Figure 2.2 - Plot of three sets of data, each plotted using a different marker
    style'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.2 - 绘制三组数据，每组数据使用不同的标记样式'
- en: '](img/B19085_02_02.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B19085_02_02.jpg)'
- en: Figure 2.2 - Plot of three sets of data, each plotted using a different marker
    style
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2 - 绘制三组数据，每组数据使用不同的标记样式
- en: The `set_title`, `set_xlabel`, and `set_ylabel` methods simply add the text
    argument to the corresponding position of the `Axes` object. The `legend` method,
    as called in the preceding code, adds the labels to the datasets in the order
    that they were added to the plot—in this case, `y1`, `y2`, and then `y3`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`set_title`、`set_xlabel`和`set_ylabel`方法仅仅是将文本参数添加到`Axes`对象的相应位置。`legend`方法，如前述代码所示，将标签按添加顺序添加到数据集——在这个例子中是`y1`、`y2`，然后是`y3`。'
- en: There are a number of keyword arguments that can be supplied to the `set_title`,
    `set_xlabel`, and `set_ylabel` routines to control the style of the text. For
    example, the `fontsize` keyword can be used to specify the size of the label font
    in the usual `pt` point measure.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 可以向`set_title`、`set_xlabel`和`set_ylabel`函数提供多个关键字参数，以控制文本的样式。例如，`fontsize`关键字可以用来指定标签字体的大小，通常以`pt`为单位。
- en: The `annotate` method on the `Axes` object adds arbitrary text to a specific
    position on the plot. This routine takes two arguments—the text to display as
    a string and the coordinates of the point at which the annotation should be placed.
    This routine also accepts keyword arguments that can be used to customize the
    style of the annotation.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`annotate`方法在`Axes`对象上将任意文本添加到图形中的指定位置。该函数接受两个参数——要显示的文本字符串和注释应放置的点的坐标。此函数还接受可以自定义注释样式的关键字参数。'
- en: There’s more…
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: The `plt.plot` routine accepts a variable number of positional inputs. In the
    preceding code, we supplied two positional arguments that were interpreted as
    `x` values and `y` values (in that order). If we had instead provided only a single
    array, the `plot` routine would have plotted the values against their position
    in the array; that is, the `x` values are taken to be `0`, `1`, `2`, and so on.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`plt.plot`例程接受可变数量的位置输入。在前面的代码中，我们提供了两个位置参数，分别被解释为`x`值和`y`值（顺序如此）。如果我们只提供了一个数组，`plot`例程会将值绘制在数组中的位置；也就是说，`x`值被视为`0`、`1`、`2`等。'
- en: The `plot` method also accepts a number of keyword arguments that can also be
    used to control the style of a plot. Keyword arguments take precedence over format
    string parameters if both are present, and they apply to all sets of data plotted
    by the call. The keyword to control the marker style is `marker`, the keyword
    for the line style is `linestyle`, and the keyword for color is `color`. The `color`
    keyword argument accepts a number of different formats to specify a color, which
    includes RGB values as a `(r, g, b)` tuple, where each character is a float between
    `0` and `1` or is a hex string. The width of the line plotted can be controlled
    using the `linewidth` keyword, which should be provided with a `float` value.
    Many other keyword arguments can be passed to `plot`; a list is given in the Matplotlib
    documentation. Many of these keyword arguments have a shorter version, such as
    `c` for `color` and `lw` for `linewidth`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`plot`方法还接受许多关键字参数，这些参数也可以用于控制绘图的样式。如果同时存在关键字参数和格式字符串参数，则关键字参数优先。这些关键字参数适用于调用时绘制的所有数据集。控制标记样式的关键字是`marker`，控制线条样式的关键字是`linestyle`，颜色的关键字是`color`。`color`关键字参数接受许多不同的格式来指定颜色，包括RGB值作为`(r,
    g, b)`元组，其中每个字符是介于`0`和`1`之间的浮点数，或者是十六进制字符串。可以使用`linewidth`关键字来控制绘制的线条宽度，该关键字应提供一个`float`值。许多其他关键字参数可以传递给`plot`；在Matplotlib文档中列出了一个列表。许多这些关键字参数都有一个更短的版本，例如`c`代表`color`，`lw`代表`linewidth`。'
- en: 'In the this recipe, we plotted a large number of coordinates generated by evaluating
    functions on a selection of ![](img/Formula_02_017.png) values. In other applications,
    one might have data sampled from the real world (as opposed to generated). In
    these situations, it might be better to leave out the connecting lines and simply
    plot the markers at the points. Here is an example of how this might be done:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们绘制了通过在一些![](img/Formula_02_017.png)值上评估函数生成的大量坐标。在其他应用中，可能会有来自真实世界的数据（而不是生成的）。在这些情况下，最好不要连接线条，而只是在点上绘制标记。以下是如何实现的示例：
- en: '[PRE15]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The result of these commands is shown in *Figure 2**.2*. Matplotlib has a specialized
    method for producing scatter plots such as this, called `scatter`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令的结果显示在*图2**.2*中。Matplotlib有一个专门用于生成散点图的方法，称为`scatter`。
- en: Other aspects of the plot can be customized by using methods on the `Axes` object.
    The axes ticks can be modified using the `set_xticks` and `set_yticks` methods
    on the `Axes` object, and the grid appearance can be configured using the `grid`
    method. There are also convenient methods in the `pyplot` interface that apply
    these modifications to the current axes (if they exist).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过在`Axes`对象上使用方法来自定义绘图的其他方面。可以使用`Axes`对象上的`set_xticks`和`set_yticks`方法修改轴刻度，使用`grid`方法配置网格外观。在`pyplot`接口中还有方便的方法，将这些修改应用于当前轴（如果存在）。
- en: 'For example, we modify the axis limits, set the ticks at every multiple of
    `0.5` in both the ![](img/Formula_02_006.png) and ![](img/Formula_02_008.png)
    direction, and add a grid to the plot by using the following commands:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们修改轴限制，在`0.5`的倍数处设置刻度，同时在![](img/Formula_02_006.png)和![](img/Formula_02_008.png)方向上添加网格到图中，使用以下命令：
- en: '[PRE16]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Notice how we set the limits slightly larger than the extent of the plot. This
    is to avoid markers being placed on the boundary of the plot window.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们将限制设置得比图的范围稍大。这是为了避免标记放在图窗口的边界上。
- en: Matplotlib has many other plotting routines besides the `plot` routine described
    here. For example, there are plotting methods that use a different scale for the
    axes, including the logarithmic ![](img/Formula_02_009.png) or ![](img/Formula_02_010.png)
    axes separately (`semilogx` or `semilogy`, respectively) or together (`loglog`).
    These are explained in the Matplotlib documentation. The `scatter` plotting routine
    may be useful if you wish to plot discrete data on axes without connecting the
    points with a line. This allows more control over the style of the marker. For
    example, you can scale the marker according to some additional information.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这里描述的`plot`函数，Matplotlib还有许多其他绘图函数。例如，有一些绘图方法使用不同的坐标轴尺度，包括对数坐标轴![](img/Formula_02_009.png)或![](img/Formula_02_010.png)，分别是`semilogx`或`semilogy`，或者将它们一起使用（`loglog`）。这些内容在Matplotlib文档中有详细说明。如果你希望绘制离散数据，而不通过连线连接这些点，`scatter`绘图函数可能会很有用。它允许你对标记样式进行更多控制，例如，你可以根据某些附加信息来调整标记的大小。
- en: We can use a different font by using the `fontfamily` keyword, the value of
    which can be the name of a font or `serif`, `sans-serif`, or `monospace`, which
    will choose the appropriate built-in font. A complete list of modifiers can be
    found in the Matplotlib documentation for the `matplotlib.text.Text` class.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用`fontfamily`关键字来使用不同的字体，其值可以是字体名称，或者是`serif`、`sans-serif`或`monospace`，这些将选择适当的内置字体。完整的修改器列表可以在Matplotlib的`matplotlib.text.Text`类文档中找到。
- en: Text arguments can also be rendered using TeX for additional formatting by supplying
    `usetex=True` to the routine. We’ll demonstrate the use of TeX formatting of labels
    in *Figure 2**.3* in the following recipe. This is especially useful if the title
    or axis label contains a mathematical formula. Unfortunately, the `usetex` keyword
    argument cannot be used if TeX is not installed on the system—it will cause an
    error in this case. However, it is still possible to use the TeX syntax for formatting
    mathematical text within labels, but this will be typeset by Matplotlib, rather
    than by TeX.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 通过向函数提供`usetex=True`，文本参数还可以使用TeX进行额外的格式化。我们将在下面的示例中演示如何在*图2.3*中使用TeX格式化标签。如果标题或坐标轴标签包含数学公式，这尤其有用。不幸的是，如果系统上没有安装TeX，`usetex`关键字参数无法使用——这会导致错误。然而，仍然可以使用TeX语法在标签中格式化数学文本，但这将由Matplotlib进行排版，而不是由TeX排版。
- en: Adding subplots
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加子图
- en: Occasionally, it is useful to place multiple related plots within the same figure
    side by side but not on the same axes. Subplots allow us to produce a grid of
    individual plots within a single figure. In this recipe, we will see how to create
    two plots side by side on a single figure using subplots.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，将多个相关的图表放置在同一图形中并排显示，但不在同一坐标轴上是很有用的。子图可以让我们在一个图形中生成一个由多个独立图表组成的网格。在这个实例中，我们将看到如何使用子图在单个图形中并排显示两个图表。
- en: Getting ready
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'You will need the data to be plotted on each subplot. As an example, we will
    plot the first five iterates of Newton’s method applied to the ![](img/Formula_02_011.png)
    function with an initial value of ![](img/Formula_02_012.png) on the first subplot,
    and for the second, we will plot the error of the iterate. We first define a generator
    function to get the iterates:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要为每个子图准备要绘制的数据。作为示例，我们将在第一个子图中绘制应用于![](img/Formula_02_011.png)函数的牛顿法的前五次迭代，初始值为![](img/Formula_02_012.png)，而在第二个子图中，我们将绘制迭代的误差。我们首先定义一个生成器函数来获取这些迭代：
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This routine generates two lists. The first list contains iterates of Newton’s
    method applied to the function, and the second contains the error in the approximation:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数生成两个列表。第一个列表包含应用于该函数的牛顿法的迭代，第二个列表包含近似值的误差：
- en: '[PRE18]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: How to do it...
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The following steps show how to create a figure that contains multiple subplots:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤展示了如何创建包含多个子图的图形：
- en: 'We use the `subplots` routine to create a new figure and references to all
    of the `Axes` objects in each subplot, arranged in a grid with one row and two
    columns. We also set the `tight_layout` keyword argument to `True` to fix the
    layout of the resulting plots. This isn’t strictly necessary, but it is in this
    case as it produces a better result than the default:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`subplots`函数来创建一个新的图形，并获取每个子图中`Axes`对象的引用，这些对象按一行两列的网格排列。我们还将`tight_layout`关键字参数设置为`True`，以修正结果图表的布局。这在严格意义上并不是必须的，但在这种情况下，它能比默认设置产生更好的效果：
- en: '[PRE19]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Once `Figure` and `Axes` objects are created, we can populate the figure by
    calling the relevant plotting method on each `Axes` object. For the first plot
    (displayed on the left), we use the `plot` method on the `ax1` object, which has
    the same signature as the standard `plt.plot` routine. We can then call the `set_title`,
    `set_xlabel`, and `set_ylabel` methods on `ax1` to set the title and the `x` and
    `y` labels. We also use TeX formatting for the axes labels by providing the `usetex`
    keyword argument; you can ignore this if you don’t have TeX installed on your
    system:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦创建了 `Figure` 和 `Axes` 对象，我们就可以通过在每个 `Axes` 对象上调用相关的绘图方法来填充图形。对于第一个图（显示在左侧），我们在
    `ax1` 对象上使用 `plot` 方法，其签名与标准的 `plt.plot` 函数相同。然后，我们可以在 `ax1` 上调用 `set_title`、`set_xlabel`
    和 `set_ylabel` 方法来设置标题以及 `x` 和 `y` 标签。我们还通过提供 `usetex` 关键字参数使用 TeX 格式化轴标签；如果系统没有安装
    TeX，可以忽略此部分。
- en: '[PRE22]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, we can plot the error values on the second plot (displayed on the right)
    using the `ax2` object. We use an alternative plotting method that uses a logarithmic
    scale on the ![](img/Formula_02_014.png) axis, called `semilogy`. The signature
    for this method is the same as the standard `plot` method. Again, we set the axes
    labels and the title. Again, the use of `usetex` can be left out if you don’t
    have TeX installed:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以使用 `ax2` 对象在第二个图（显示在右侧）上绘制误差值。我们使用一种替代的绘图方法，该方法在 ![](img/Formula_02_014.png)
    轴上使用对数刻度，称为 `semilogy`。该方法的签名与标准的 `plot` 方法相同。再次，我们设置轴标签和标题。如果你的系统没有安装 TeX，也可以省略使用
    `usetex`：
- en: '[PRE26]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The result of this sequence of commands is shown here:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这组命令的结果如图所示：
- en: '![Figure 2.3 - Multiple subplots on the same Matplotlib figure'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.3 - 在同一个 Matplotlib 图形上显示多个子图'
- en: '](img/B19085_02_03.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B19085_02_03.jpg)'
- en: Figure 2.3 - Multiple subplots on the same Matplotlib figure
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.3 - 在同一个 Matplotlib 图形上显示多个子图
- en: The left-hand side plots the first five iterates of Newton’s method, and the
    right-hand side is the approximation error plotted on a logarithmic scale.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧绘制了牛顿法的前五次迭代，右侧是以对数刻度绘制的近似误差。
- en: How it works...
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: A `Figure` object in Matplotlib is simply a container for plot elements, such
    as `Axes`, of a certain size. A `Figure` object will usually only hold a single
    `Axes` object, which occupies the entire figure area, but it can contain any number
    of `Axes` objects in the same area. The `subplots` routine does several things.
    It first creates a new figure and then creates a grid with the specified shape
    in the figure area. Then, a new `Axes` object is added to each position of the
    grid. The new `Figure` object and one or more `Axes` objects are then returned
    to the user. If a single subplot is requested (one row and one column, with no
    arguments) then a plain `Axes` object is returned. If a single row or column is
    requested (with more than one column or row, respectively), then a list of `Axes`
    objects is returned. If more than one row and column are requested, a list of
    lists, with rows represented by inner lists filled with `Axes` objects, will be
    returned. We can then use the plotting methods on each of the `Axes` objects to
    populate the figure with the desired plots.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Matplotlib 中，`Figure` 对象只是一个容器，用于存放诸如 `Axes` 等绘图元素，并具有一定的大小。`Figure` 对象通常只会包含一个
    `Axes` 对象，该对象占据整个图形区域，但它也可以在同一区域内包含任意数量的 `Axes` 对象。`subplots` 函数做了几件事。它首先创建一个新的图形，然后在图形区域内创建一个指定形状的网格。接着，一个新的
    `Axes` 对象会被添加到网格的每个位置。最后，新的 `Figure` 对象和一个或多个 `Axes` 对象会返回给用户。如果只请求一个子图（没有参数，即一行一列），则返回一个普通的
    `Axes` 对象。如果请求一个单行或单列（分别有多个列或行），则返回一个 `Axes` 对象的列表。如果请求多个行和列，则返回一个列表的列表，其中行由内部列表表示，内部列表填充有
    `Axes` 对象。然后，我们可以在每个 `Axes` 对象上使用绘图方法，以在图形中填充所需的图表。
- en: In this recipe, we used the standard `plot` method for the left-hand side plot,
    as we have seen in previous recipes. However, for the right-hand side plot, we
    used a plot where the ![](img/Formula_02_015.png) axis had been changed to a logarithmic
    scale. This means that each unit on the ![](img/Formula_02_015.png) axis represents
    a change of a power of 10 rather than a change of one unit so that `0` represents
    ![](img/Formula_02_016.png), `1` represents 10, `2` represents 100, and so on.
    The axes labels are automatically changed to reflect this change in scale. This
    type of scaling is useful when the values change by an order of magnitude, such
    as the error in an approximation, as we use more and more iterations. We can also
    plot with a logarithmic scale for ![](img/Formula_02_017.png) only by using the
    `semilogx` method, or both axes on a logarithmic scale by using the `loglog` method.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们在左侧图中使用了标准的`plot`方法，就像我们在之前的示例中看到的那样。然而，在右侧图中，我们使用了一个将![](img/Formula_02_015.png)轴更改为对数刻度的绘图。这意味着![](img/Formula_02_015.png)轴上的每个单位代表一个数量级的变化，而不是一个单位的变化，因此`0`代表![](img/Formula_02_016.png)，`1`代表10，`2`代表100，依此类推。轴标签会自动更改以反映这种比例变化。当值按数量级变化时，例如在逼近中的误差随着迭代次数的增加而变化时，这种缩放方式非常有用。我们还可以通过使用`semilogx`方法仅对![](img/Formula_02_017.png)使用对数刻度绘图，或者通过使用`loglog`方法使两个轴都使用对数刻度绘图。
- en: There’s more...
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There are several ways to create subplots in Matplotlib. If you have already
    created a `Figure` object, then subplots can be added using the `add_subplot`
    method of the `Figure` object. Alternatively, you can use the `subplot` routine
    from `matplotlib.pyplot` to add subplots to the current figure. If one does not
    yet exist, it will be created when this routine is called. The `subplot` routine
    is a convenience wrapper of the `add_subplot` method on the `Figure` object.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在Matplotlib中创建子图有几种方法。如果您已经创建了一个`Figure`对象，则可以使用`Figure`对象的`add_subplot`方法添加子图。或者，您可以使用`matplotlib.pyplot`中的`subplot`例程将子图添加到当前图中。如果尚不存在，则在调用此例程时将创建一个。`subplot`例程是`Figure`对象上`add_subplot`方法的便利包装器。
- en: In the preceding example, we created two plots with differently scaled ![](img/Formula_02_018.png)
    axes. This demonstrates one of the many possible uses of subplots. Another common
    use is for plotting data in a matrix where columns have a common `x` label and
    rows have a common `y` label, which is especially common in multivariate statistics
    when investigating the correlation between various sets of data. The `plt.subplots`
    routine for creating subplots accepts the `sharex` and `sharey` keyword parameters,
    which allows the axes to be shared among all subplots or among a row or column.
    This setting affects the scale and ticks of the axes.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们创建了两个具有不同比例的![](img/Formula_02_018.png)轴的图。这展示了子图的许多可能用途之一。另一个常见用途是在矩阵中绘制数据，其中列具有共同的`x`标签，行具有共同的`y`标签，这在多元统计中特别常见，用于研究各组数据之间的相关性。用于创建子图的`plt.subplots`例程接受`sharex`和`sharey`关键参数，允许轴在所有子图之间或在行或列之间共享。此设置会影响轴的比例和刻度。
- en: See also
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Matplotlib supports more advanced layouts by providing the `gridspec_kw` keyword
    arguments to the `subplots` routine. See the documentation for `matplotlib.gridspec`
    for more information.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Matplotlib通过为`subplots`例程提供`gridspec_kw`关键字参数来支持更高级的布局。有关更多信息，请参阅`matplotlib.gridspec`的文档。
- en: Plotting with error bars
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用误差条绘图
- en: It is quite common that the values that we gather from the real world carry
    some uncertainty; no measurement of a real-world quantity is perfectly accurate.
    For example, if we measure a distance with a tape measure, there is a certain
    amount of accuracy that we can assume in our results, but beyond this accuracy,
    we cannot be sure that our measurement is valid. For such a situation, we can
    probably be confident of our accuracy up to about 1 millimeter or a little less
    than 1/16 inch. (This is, of course, assuming that we are measuring perfectly.)
    These values are the smallest subdivisions on typical tape measures. Let’s assume
    that we have collected such a set of 10 measurements (in centimeters) and we wish
    to plot these values along with the accuracy that we are confident about. (The
    range of values that lie above or below the measurement by the accuracy amount
    is called the *error*.) This is what we address in this recipe.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 从现实世界中收集的数据通常会带有一些不确定性；没有任何现实世界的量度是完全准确的。例如，如果我们使用卷尺测量距离，那么我们可以假设我们的结果在一定范围内是准确的，但超过这个范围后，我们就无法确保测量结果的有效性。在这种情况下，我们可能对精度有信心的范围大约是1毫米或稍小于1/16英寸。（当然，这是假设我们在完美的条件下进行测量。）这些值通常是典型卷尺上最小的分度线。假设我们收集了这样一组10个测量值（单位为厘米），并且我们希望将这些值与我们有信心的精度一起绘制出来。（误差范围是指实际测量值上下偏离的范围，通常称为
    *误差*。）我们将在本节中处理这一问题。
- en: Getting ready
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'As usual, we have the Matplotlib `pyplot` interface imported under the alias
    `plt`. We first need to generate our hypothetical data and the assumed accuracy
    in NumPy arrays:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，我们导入了 Matplotlib 的 `pyplot` 接口，别名为 `plt`。首先，我们需要在 NumPy 数组中生成我们的假设数据和假定的精度：
- en: '[PRE30]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Let’s see how to use plotting routines in Matplotlib to plot these measurements
    with error bars to indicate the uncertainty in each measurement.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用 Matplotlib 中的绘图函数，将这些带有误差条的测量值绘制出来，以表示每个测量值的不确定性。
- en: How to do it…
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: The following steps show how to plot measurements along with accuracy information
    on a figure.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤展示了如何在图形上绘制带有精度信息的测量值。
- en: 'First, we need to generate a new `figure` and `axis` object as usual:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要像往常一样生成一个新的 `figure` 和 `axis` 对象：
- en: '[PRE31]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Next, we use the `errorbar` method on the axis object to plot the data along
    with the error bars. The accuracy information (the error) is passed as the `yerr`
    argument:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用 `errorbar` 方法在轴对象上绘制数据，并附上误差条。精度信息（即误差）通过 `yerr` 参数传递：
- en: '[PRE32]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'As usual, we should always add meaningful labels to the axes and a title to
    the plot:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，我们应该始终为坐标轴添加有意义的标签，并为图形添加标题：
- en: '[PRE33]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Since Matplotlib will not produce `xlabel` ticks at every value by default,
    we set the x-tick values to the measurement IDs so that they are all displayed
    on the plot:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Matplotlib 默认不会在每个值处绘制 `xlabel` 刻度，因此我们将 x 刻度值设置为测量 ID，以确保它们都能显示在图形上：
- en: '[PRE34]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The resulting plot is shown in *Figure 2**.4*. The recorded value is shown
    at the `x` markers, and the error bar extends above and below that value by an
    accuracy of 0.1 cm (1 mm):'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 结果图形显示在 *图 2.4* 中。记录值显示在 `x` 标记处，误差条则在该值的上下延伸，精度为 0.1 厘米（即 1 毫米）：
- en: '![Figure 2.4 - Plot of a set of 10 sample measurements (in centimeters) with
    their measurement error shown'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.4 - 显示10个样本测量值（单位为厘米）及其测量误差的图形'
- en: '](img/B19085_02_04.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B19085_02_04.jpg)'
- en: Figure 2.4 - Plot of a set of 10 sample measurements (in centimeters) with their
    measurement error shown
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.4 - 显示10个样本测量值（单位为厘米）及其测量误差的图形
- en: We can see here that each of the markers has a vertical bar that indicates the
    range in which we expect the true measurement (![](img/Formula_02_019.png)-value)
    to lie.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，每个标记都有一个垂直条，表示我们期望真实测量值(![](img/Formula_02_019.png)-值)所在的范围。
- en: How it works…
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The `errorbar` method works in a similar way to other plotting methods. The
    first two arguments are the ![](img/Formula_02_020.png) and ![](img/Formula_02_021.png)
    coordinates of the points to be plotted. (Note that both must be provided, which
    is not the case for other plotting methods.) The `yerr` argument indicates the
    size of the error bars to be added to the plot and should all be positive values.
    The form of the value(s) passed to this argument determines the nature of the
    error bars. In the recipe, we provided a flat NumPy array with 10 entries—one
    for each measurement—which leads to error bars above and below each point with
    the same size (the corresponding value from the argument). Alternatively, we could
    have specified a 2-by-10 array, where the first row contains the lower error and
    the second row contains the upper error. (Since all our errors are the same, we
    could also have provided a single float containing the common error for all measurements.)
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`errorbar`方法的工作方式与其他绘图方法相似。前两个参数是要绘制的点的![](img/Formula_02_020.png)和![](img/Formula_02_021.png)坐标。（请注意，两个坐标都必须提供，而其他绘图方法则不要求这样。）`yerr`参数表示要添加到图中的误差条的大小，并且所有的值应该是正值。传递给此参数的值的形式决定了误差条的性质。在该示例中，我们提供了一个包含10个条目的平坦NumPy数组——每个条目对应一个测量值——这导致每个点上方和下方都有大小相同的误差条（即来自该参数的相应值）。另外，我们还可以指定一个2×10的数组，其中第一行包含下误差，第二行包含上误差。（由于我们的误差值相同，我们也可以提供一个包含所有测量共同误差的浮动值。）'
- en: In addition to the data arguments, there are the usual format arguments, including
    the `fmt` format string. (We used this here as a keyword argument because we named
    the `yerr` argument that precedes it.) In addition to the formatting of lines
    and points found in other plotting methods, there are special arguments for customizing
    the look of error bars. In the recipe, we used the `capsize` argument to add “caps”
    to either end of the error bars so that we could easily identify the ends of those
    bars; the default style is a simple line.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 除了数据参数，还有通常的格式化参数，包括`fmt`格式化字符串。（我们在这里使用了它作为关键字参数，因为我们命名了之前的`yerr`参数。）除了其他绘图方法中的线条和点的格式化外，还有一些特殊参数可以用来定制误差条的外观。在该示例中，我们使用了`capsize`参数为误差条的两端添加“帽子”，以便我们可以轻松地识别这些条的端点；默认的样式是简单的线条。
- en: There’s more...
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In the recipe, we only plotted errors in the ![](img/Formula_02_022.png) axis
    because the ![](img/Formula_02_023.png) values were simply ID values. If both
    sets of values have uncertainty, you can also specify the ![](img/Formula_02_024.png)
    error values using the `xerr` argument. This argument functions in the same way
    as the `yerr` argument used previously.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在该示例中，我们只在![](img/Formula_02_022.png)轴上绘制了误差，因为![](img/Formula_02_023.png)值仅仅是ID值。如果两个值集都有不确定性，你也可以使用`xerr`参数来指定![](img/Formula_02_024.png)误差值。该参数的功能与之前使用的`yerr`参数相同。
- en: If you are plotting a very large number of points that follow some kind of trend,
    you might wish to plot error bars more selectively. For this, you can use the
    `errorevery` keyword argument to instruct Matplotlib to add error bars at every
    `n`th data point rather than at all of them. This can be either a positive integer—indicating
    the “stride” to use to select points that will have errors—or a tuple containing
    an offset from the first value and a stride. For example, `errorevery=(2, 5)`
    would place error bars every five data points, starting from the second entry.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在绘制大量符合某种趋势的数据点，可能希望更有选择性地绘制误差条。为此，你可以使用`errorevery`关键字参数，指示Matplotlib每隔第`n`个数据点添加误差条，而不是对所有数据点都添加误差条。这可以是一个正整数——表示选择有误差的数据点的“步长”——或者一个包含从第一个值起的偏移量和步长的元组。例如，`errorevery=(2,
    5)`会在每五个数据点处添加误差条，且从第二个数据点开始。
- en: 'You can also add error bars to bar charts in the same way (except here, the
    `xerr` and `yerr` arguments are keywords only). We could have plotted the data
    from the recipe as a bar chart using the following commands:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以用相同的方式在条形图中添加误差条（除了这里，`xerr`和`yerr`参数只是关键字）。我们可以用以下命令将示例中的数据绘制成条形图：
- en: '[PRE35]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'If this line is used instead of the call to `errorbar` in the recipe, then
    we would get a bar chart, as shown in *Figure 2**.5*:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在示例中使用这行代码代替调用`errorbar`，则我们将得到一个条形图，如*图2**.5*所示：
- en: '![Figure 2.5 - Bar chart of measurements with error bars'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.5 - 带有误差条的测量值条形图'
- en: '](img/B19085_02_05.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B19085_02_05.jpg)'
- en: Figure 2.5 - Bar chart of measurements with error bars
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5 - 带有误差条的测量值条形图
- en: As before, the measurement bar is capped with an indicator of the ![](img/Formula_02_025.png)
    range in which we expect the true measurement to lie.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如之前所述，测量条的顶部有一个指示器，表示我们期望真实测量值所在的范围 ![](img/Formula_02_025.png)。
- en: Saving Matplotlib figures
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保存 Matplotlib 图形
- en: When you work in an interactive environment, such as an IPython console or a
    Jupyter notebook, displaying a figure at runtime is perfectly normal. However,
    there are plenty of situations where it would be more appropriate to store a figure
    directly to a file, rather than rendering it on screen. In this recipe, we will
    see how to save a figure directly to a file, rather than displaying it on screen.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在交互式环境中工作时，例如 IPython 控制台或 Jupyter 笔记本，运行时显示图形是完全正常的。然而，有很多情况下直接将图形保存到文件中比在屏幕上渲染它更为合适。在这个教程中，我们将学习如何直接将图形保存到文件，而不是在屏幕上显示它。
- en: Getting ready
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'You will need the data to be plotted and the path or file object in which you
    wish to store the output. We store the result in `savingfigs.png` in the current
    directory. In this example, we will plot the following data:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要有待绘制的数据和希望存储输出的路径或文件对象。我们将结果保存在当前目录下的 `savingfigs.png` 文件中。在这个示例中，我们将绘制以下数据：
- en: '[PRE36]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Let’s see how to plot this curve using Matplotlib and save the resulting plot
    to a file (without needing to interact with the plot GUI).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用 Matplotlib 绘制这条曲线，并将生成的图形保存到文件中（无需与图形界面交互）。
- en: How to do it...
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The following steps show how to save a Matplotlib plot directly to a file:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤展示了如何将 Matplotlib 图形直接保存到文件：
- en: 'The first step is to create a figure, as usual, and add any labels, titles,
    and annotations that are necessary. The figure will be written to the file in
    its current state, so any changes to the figure should be made before saving:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是像往常一样创建一个图形，并添加任何必要的标签、标题和注释。图形将以当前状态写入文件，因此任何更改应在保存之前进行：
- en: '[PRE37]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Then, we use the `savefig` method on `fig` to save this figure to a file. The
    only required argument is the path to output to or a file-like object that the
    figure can be written to. We can adjust various settings for the output format,
    such as the resolution, by providing the appropriate keyword arguments. We’ll
    set the `300`, which is a reasonable resolution for most applications:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用 `savefig` 方法将 `fig` 保存到文件中。唯一需要的参数是输出路径或一个文件类对象，图形可以写入该对象。我们可以通过提供适当的关键字参数来调整输出格式的各种设置，例如分辨率。我们将设置
    `300`，这是大多数应用程序的合理分辨率：
- en: '[PRE42]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Matplotlib will infer that we wish to save the image in the `format` keyword),
    or it will fall back to the default from the configuration file.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: Matplotlib 将推断我们希望以 `format` 关键字指定的格式保存图像，或者如果未指定，它将回退到配置文件中的默认格式。
- en: How it works...
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `savefig` method chooses the appropriate backend for the output format and
    then renders the current figure in that format. The resulting image data is written
    to the specified path or file-like object. If you have manually created a `Figure`
    instance, the same effect can be achieved by calling the `savefig` method on that
    instance.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`savefig` 方法选择适当的后端输出格式，然后以该格式渲染当前图形。生成的图像数据会写入指定的路径或类文件对象。如果你手动创建了一个 `Figure`
    实例，也可以通过在该实例上调用 `savefig` 方法来实现相同的效果。'
- en: There’s more...
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `savefig` routine takes a number of additional optional keyword arguments
    to customize the output image. For example, the resolution of the image can be
    specified using the `dpi` keyword. The plots in this chapter have been produced
    by saving the Matplotlib figures to the file.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`savefig` 例程接受许多额外的可选关键字参数，以自定义输出图像。例如，可以使用 `dpi` 关键字指定图像的分辨率。本章中的图形是通过将 Matplotlib
    图形保存到文件中生成的。'
- en: The output formats available include PNG, `quality` and `optimize`. A dictionary
    of image metadata can be passed to the `metadata` keyword, which will be written
    as image metadata when saving.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的输出格式包括 PNG、`quality` 和 `optimize`。可以通过 `metadata` 关键字传递一个图像元数据字典，该字典将在保存时作为图像元数据写入。
- en: See also
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: The examples gallery on the Matplotlib website includes examples of embedding
    Matplotlib figures into a GUI application using several common Python GUI frameworks.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Matplotlib 网站上的示例画廊包括了如何使用几种常见的 Python GUI 框架将 Matplotlib 图形嵌入到 GUI 应用程序中的示例。
- en: Surface and contour plots
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表面图和轮廓图
- en: Matplotlib can also plot three-dimensional data in a variety of ways. Two common
    choices for displaying data such as this are using **surface plots** or **contour
    plots** (think of contour lines on a map). In this recipe, we will see a method
    for plotting surfaces from three-dimensional data and how to plot contours of
    three-dimensional data.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Matplotlib 还可以以多种方式绘制三维数据。显示这类数据的两种常见选择是使用 **表面图** 或 **等高线图**（可以类比为地图上的等高线）。在本食谱中，我们将看到一种从三维数据绘制表面图的方法，以及如何绘制三维数据的等高线。
- en: Getting ready
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To plot three-dimensional data, it needs to be arranged into two-dimensional
    arrays for the ![](img/Formula_02_026.png), ![](img/Formula_02_027.png), and ![](img/Formula_02_028.png)
    components, where both the ![](img/Formula_02_029.png) and ![](img/Formula_02_030.png)
    components must be of the same shape as the ![](img/Formula_02_031.png) component.
    For the sake of this demonstration, we will plot the surface corresponding to
    the following function:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 为了绘制三维数据，它需要被整理成二维数组，分别对应 ![](img/Formula_02_026.png)、![](img/Formula_02_027.png)
    和 ![](img/Formula_02_028.png) 组件，其中 ![](img/Formula_02_029.png) 和 ![](img/Formula_02_030.png)
    组件必须与 ![](img/Formula_02_031.png) 组件形状相同。为了演示，我们将绘制以下函数对应的表面：
- en: '![](img/Formula_02_032.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_02_032.jpg)'
- en: For 3D data, we can’t just use the routines from the `pyplot` interface. We
    need to import some extra functionality from another part of Matplotlib. We’ll
    see how to do this next.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 对于三维数据，我们不能仅仅使用 `pyplot` 接口中的例程。我们需要从 Matplotlib 的其他部分导入一些额外的功能。接下来我们将展示如何操作。
- en: How to do it...
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We want to plot the function ![](img/Formula_02_033.png) on the ![](img/Formula_02_034.png)
    and ![](img/Formula_02_035.png) range. The first task is to create a suitable
    grid of ![](img/Formula_02_036.png) pairs on which to evaluate this function:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望在 ![](img/Formula_02_034.png) 和 ![](img/Formula_02_035.png) 范围内绘制函数 ![](img/Formula_02_033.png)。第一步是创建一个适合的
    ![](img/Formula_02_036.png) 对网格，用于评估该函数：
- en: 'We first use `np.linspace` to generate a reasonable number of points in these
    ranges:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先使用 `np.linspace` 在这些范围内生成一个合理数量的点：
- en: '[PRE43]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now, we need to create a grid on which to create our ![](img/Formula_02_037.png)
    values. For this, we use the `np.meshgrid` routine:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要创建一个网格，用于生成我们的 ![](img/Formula_02_037.png) 值。为此，我们使用 `np.meshgrid` 例程：
- en: '[PRE45]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now, we can create ![](img/Formula_02_038.png) values to plot, which hold the
    value of the function at each of the grid points:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以创建 ![](img/Formula_02_038.png) 值来绘制，这些值表示函数在每个网格点的值：
- en: '[PRE46]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'To plot three-dimensional surfaces, we need to load a Matplotlib toolbox, `mplot3d`,
    which comes with the Matplotlib package. This won’t be used explicitly in the
    code, but behind the scenes, it makes the three-dimensional plotting utilities
    available to Matplotlib:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要绘制三维表面图，我们需要加载一个 Matplotlib 工具箱，`mplot3d`，它随 Matplotlib 包一起提供。虽然在代码中不会显式使用它，但在幕后，它使得三维绘图工具能够在
    Matplotlib 中使用：
- en: '[PRE49]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Next, we create a new figure and a set of three-dimensional axes for the figure:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们为图形创建一个新的图形和一组三维坐标轴：
- en: '[PRE50]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Now, we can call the `plot_surface` method on these axes to plot the data (we
    set the colormap to gray for better visibility in print; see the next recipe for
    a more detailed discussion):'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以在这些坐标轴上调用 `plot_surface` 方法来绘制数据（我们将颜色图设置为灰色，以便在打印时更清晰；有关更详细的讨论，请参见下一个食谱）：
- en: '[PRE53]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'It is extra important to add axis labels to three-dimensional plots because
    it might not be clear which axis is which on the displayed plot. We also set the
    title at this point:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为三维图添加坐标轴标签非常重要，因为在显示的图表中可能不清楚每个坐标轴代表的是哪个。此时我们还设置了标题：
- en: '[PRE54]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'You can use the `plt.show` routine to display the figure in a new window (if
    you are using Python interactively and not in a Jupyter notebook or on an IPython
    console) or `plt.savefig` to save the figure to a file. The result of the preceding
    sequence is shown here:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `plt.show` 例程在新窗口中显示图形（如果你在 Python 中交互式使用，而不是在 Jupyter notebook 或 IPython
    控制台中），或者使用 `plt.savefig` 将图形保存到文件。前面的代码序列结果如下所示：
- en: '![Figure 2.6 - A three-dimensional surface plot produced with Matplotlib'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.6 - 使用 Matplotlib 绘制的三维表面图'
- en: '](img/B19085_02_06.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B19085_02_06.jpg)'
- en: Figure 2.6 - A three-dimensional surface plot produced with Matplotlib
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.6 - 使用 Matplotlib 绘制的三维表面图
- en: 'Contour plots do not require the `mplot3d` toolkit, and there is a `contour`
    routine in the `pyplot` interface that produces contour plots. However, unlike
    the usual (two-dimensional) plotting routines, the `contour` routine requires
    the same arguments as the `plot_surface` method. We use the following sequence
    to produce a plot:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等高线图不需要 `mplot3d` 工具包，`pyplot` 接口中有一个 `contour` 函数可以生成等高线图。然而，与通常的（二维）绘图函数不同，`contour`
    函数需要与 `plot_surface` 方法相同的参数。我们使用以下步骤来生成图表：
- en: '[PRE58]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The result is shown in the following plot:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 结果显示在下面的图表中：
- en: '![Figure 2.7 - Contour plot produced using Matplotlib with the default settings'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.7 - 使用 Matplotlib 和默认设置生成的等高线图'
- en: '](img/B19085_02_07.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B19085_02_07.jpg)'
- en: Figure 2.7 - Contour plot produced using Matplotlib with the default settings
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.7 - 使用 Matplotlib 和默认设置生成的等高线图
- en: The peak and basin of the function are shown clearly here by the rings of concentric
    circles. In the top right, the shading is lighter, indicating that the function
    is increasing, and in the bottom left, the shade is darker, indicating that the
    function is decreasing. The curve that separates the regions in which the function
    is increasing and decreasing is shown between them.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的峰值和盆地通过同心圆的环形清晰展示。在右上方，阴影较浅，表示函数在增加，而在左下方，阴影较深，表示函数在减少。区分函数增加和减少区域的曲线显示在它们之间。
- en: How it works...
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `mplot3d` toolkit provides an `Axes3D` object, which is a three-dimensional
    version of the `Axes` object in the core Matplotlib package. This is made available
    to the `axes` method on a `Figure` object when the `projection="3d"` keyword argument
    is given. A surface plot is obtained by drawing quadrilaterals in the three-dimensional
    projection between nearby points in the same way that a two-dimensional curve
    is approximated by straight lines joining adjacent points.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`mplot3d` 工具包提供了一个 `Axes3D` 对象，它是核心 Matplotlib 包中 `Axes` 对象的三维版本。当给定 `projection="3d"`
    关键字参数时，可以通过 `Figure` 对象的 `axes` 方法访问它。通过在三维投影中绘制相邻点之间的四边形，可以获得表面图，就像通过连接相邻点的直线来近似二维曲线一样。'
- en: The `plot_surface` method needs the ![](img/Formula_02_039.png) values to be
    provided as a two-dimensional array that encodes the ![](img/Formula_02_040.png)
    values on a grid of ![](img/Formula_02_041.png) pairs. We created a range of ![](img/Formula_02_042.png)
    and ![](img/Formula_02_043.png) values that we are interested in, but if we simply
    evaluate our function on the pairs of corresponding values from these arrays,
    we will get the ![](img/Formula_02_044.png) values along a line and not over a
    grid. Instead, we use the `meshgrid` routine, which takes the two `X` and `Y`
    arrays and creates from them a grid consisting of all the possible combinations
    of values in `X` and `Y`. The output is a pair of two-dimensional arrays on which
    we can evaluate our function. We can then provide all three of these two-dimensional
    arrays to the `plot_surface` method.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`plot_surface` 方法需要提供 ![](img/Formula_02_039.png) 数值作为二维数组，这些数值在 ![](img/Formula_02_040.png)
    网格的 ![](img/Formula_02_041.png) 对应点上编码。我们创建了感兴趣的 ![](img/Formula_02_042.png) 和
    ![](img/Formula_02_043.png) 数值范围，但如果我们仅在这些数组的对应点上计算我们的函数，我们将得到沿着一条线的 ![](img/Formula_02_044.png)
    数值，而不是在网格上。相反，我们使用 `meshgrid` 函数，它接受两个 `X` 和 `Y` 数组，并从中创建一个包含 `X` 和 `Y` 中所有可能组合的网格。输出是两个二维数组，我们可以在上面计算我们的函数。然后，我们将这三个二维数组提供给
    `plot_surface` 方法。'
- en: There’s more...
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The routines described in the preceding section, `contour` and `plot_surface`,
    only work with highly structured data where the ![](img/Formula_02_045.png), ![](img/Formula_02_046.png),
    and ![](img/Formula_02_047.png) components are arranged into grids. Unfortunately,
    real-life data is rarely so structured. In this case, you need to perform some
    kind of interpolation between known points to approximate the value on a uniform
    grid, which can then be plotted. A common method for performing this interpolation
    is by triangulating the collection of ![](img/Formula_02_048.png) pairs and then
    using the values of the function on the vertices of each triangle to estimate
    the value on the grid points. Fortunately, Matplotlib has a method that does all
    of these steps and then plots the result, which is the `plot_trisurf` routine.
    We briefly explain how this can be used here:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 前面章节中描述的例程`contour`和`plot_surface`仅适用于高度结构化的数据，其中！[](img/Formula_02_045.png)、！[](img/Formula_02_046.png)和！[](img/Formula_02_047.png)组件被排列成网格。不幸的是，现实生活中的数据很少是这样结构化的。在这种情况下，你需要在已知点之间进行某种插值，以近似在均匀网格上的值，然后绘制出来。执行这种插值的常见方法是通过三角剖分！[](img/Formula_02_048.png)对，然后利用每个三角形顶点上的函数值来估计网格点上的值。幸运的是，Matplotlib提供了一种方法，能够完成这些步骤并绘制结果，这就是`plot_trisurf`例程。我们在这里简要解释如何使用它：
- en: 'To illustrate the use of `plot_trisurf`, we will plot a surface and contours
    from the following data:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了说明如何使用`plot_trisurf`，我们将根据以下数据绘制一个曲面和轮廓：
- en: '[PRE63]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'This time, we will plot both the surface and contour (approximations) on the
    same figure as two separate subplots. For this, we supply the `projection="3d"`
    keyword argument to the subplot that will contain the surface. We use the `plot_trisurf`
    method on the three-dimensional axes to plot the approximated surface, and the
    `tricontour` method on the two-dimensional axes to plot the approximated contours:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这一次，我们将在同一图形上将曲面和轮廓（近似）作为两个单独的子图绘制。为此，我们向将包含曲面的子图提供`projection="3d"`关键字参数。我们在三维坐标轴上使用`plot_trisurf`方法绘制近似曲面，在二维坐标轴上使用`tricontour`方法绘制近似轮廓：
- en: '[PRE73]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'We can now plot the contours for the triangulated surface using the following
    command:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以使用以下命令绘制三角化曲面的轮廓：
- en: '[PRE80]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'We include the `tight_layout=True` keyword argument with the figure to save
    a call to the `plt.tight_layout` routine later. The result is shown here:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在图形中加入了`tight_layout=True`关键字参数，以避免之后再调用`plt.tight_layout`函数。结果如下所示：
- en: '![Figure 2.8 - Approximate surface and contour plots generated from unstructured
    data using triangulation'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.8 - 使用三角剖分从非结构化数据生成的近似曲面和轮廓图'
- en: '](img/B19085_02_08.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B19085_02_08.jpg)'
- en: Figure 2.8 - Approximate surface and contour plots generated from unstructured
    data using triangulation
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.8 - 使用三角剖分从非结构化数据生成的近似曲面和轮廓图
- en: In addition to surface plotting routines, the `Axes3D` object has a `plot` (or
    `plot3D`) routine for simple three-dimensional plotting, which works exactly as
    the usual `plot` routine but on three-dimensional axes. This method can also be
    used to plot two-dimensional data on one of the axes.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 除了曲面绘制例程，`Axes3D`对象还有一个`plot`（或`plot3D`）例程用于简单的三维绘图，工作原理与通常的`plot`例程相同，但是在三维坐标轴上。此方法也可用于在一个坐标轴上绘制二维数据。
- en: See also
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: Matplotlib is the go-to plotting library for Python, but other options do exist.
    We’ll see the Bokeh library in [*Chapter 6*](B19085_06.xhtml#_idTextAnchor226).
    There are other libraries, such as Plotly (https://plotly.com/python/), that simplify
    the process of creating certain types of plots and adding more features, such
    as interactive plots.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: Matplotlib是Python中首选的绘图库，但也存在其他选项。我们将在[*第6章*](B19085_06.xhtml#_idTextAnchor226)中看到Bokeh库。还有其他库，如Plotly（https://plotly.com/python/），它简化了创建某些类型的图形并添加更多功能（如交互式图表）的过程。
- en: Customizing three-dimensional plots
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义三维图形
- en: Contour plots can hide some detail of the surface that they represent since
    they only show where the “height” is similar and not what the value is, even in
    relation to the surrounding values. On a map, this is remedied by printing the
    height onto certain contours. Surface plots are more revealing, but the problem
    of projecting three-dimensional objects into 2D to be displayed on a screen can
    itself obscure some details. To address these issues, we can customize the appearance
    of a three-dimensional plot (or contour plot) to enhance the plot and make sure
    the detail that we wish to highlight is clear. The easiest way to do this is by
    changing the colormap of the plot, as we saw in the previous recipe. (By default,
    Matplotlib will produce surface plots with a single color, which makes details
    difficult to see in printed media.) In this recipe, we look at some other ways
    we can customize 3D surface plots, including changing the initial angle of the
    display and changing the normalization applied for the colormap.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 等高线图可能会隐藏它所表示的表面的一些细节，因为它们仅显示“高度”相似的地方，而不显示具体的值，即使是相对于周围的值也是如此。在地图上，通常会通过将高度打印到特定的等高线来解决这个问题。表面图则更加直观，但将三维物体投影到二维以便在屏幕上显示的过程中，某些细节可能会被掩盖。为了解决这些问题，我们可以自定义三维图（或等高线图）的外观，以增强图表并确保我们希望突出的细节清晰可见。最简单的方法是通过更改图表的颜色映射，如前一个方法中所示。（默认情况下，Matplotlib会生成单色的表面图，这使得细节在印刷媒体中难以观察。）在这个方法中，我们将探讨一些可以自定义3D表面图的其他方法，包括更改显示的初始角度和更改应用于颜色映射的归一化处理。
- en: Getting ready
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In this recipe, we will further customize the function we plotted in the previous
    recipe:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，我们将进一步自定义我们在前一个方法中绘制的函数：
- en: '![](img/Formula_02_049.jpg)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_02_049.jpg)'
- en: 'We generate points at which this should be plotted, as in the previous recipe:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们生成应绘制的点，就像前一个方法中一样：
- en: '[PRE85]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Let’s see how to customize a three-dimensional plot of these values.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何自定义这些值的三维图表。
- en: How to do it...
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The following steps show how to customize the appearance of a 3D plot:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤展示了如何自定义3D图表的外观：
- en: 'As usual, our first task is to create a new figure and axes on which we will
    plot. Since we’re going to customize the properties of the `Axes3D` object, we’ll
    just create a new figure first:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，我们的第一步是创建一个新的图形和坐标轴，在上面进行绘制。由于我们要自定义`Axes3D`对象的属性，因此我们将首先创建一个新的图形：
- en: '[PRE86]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Now, we need to add a new `Axes3D` object to this figure and change the initial
    viewing angle by setting the `azim` and `elev` keyword arguments along with the
    `projection=``"3d"` keyword argument that we have seen before:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要向这个图形中添加一个新的`Axes3D`对象，并通过设置`azim`和`elev`关键字参数，以及之前看到的`projection="3d"`关键字参数来改变初始视角：
- en: '[PRE87]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'With this done, we can now plot the surface. We’re going to change the bounds
    of the normalization so that the maximum value and minimum value are not at the
    extreme ends of our colormap. We do this by changing the `vmin` and `vmax` arguments:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，我们现在可以绘制表面图了。我们将通过改变归一化的范围，使最大值和最小值不再位于颜色映射的极端位置。我们通过更改`vmin`和`vmax`参数来实现：
- en: '[PRE88]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Finally, we can set up the axes labels and the title as usual:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以像往常一样设置坐标轴标签和标题：
- en: '[PRE89]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'The resulting plot is shown in *Figure 2**.9*:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 结果图如*图 2.9*所示：
- en: '![Figure 2.9 - Customized 3D surface plot with modified normalization and an
    initial viewing angle'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.9 - 自定义的3D表面图，修改了归一化处理和初始视角'
- en: '](img/B19085_02_09.jpg)'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B19085_02_09.jpg)'
- en: Figure 2.9 - Customized 3D surface plot with modified normalization and an initial
    viewing angle
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.9 - 自定义的3D表面图，修改了归一化处理和初始视角
- en: Comparing *Figure 2**.6* with *Figure 2**.9*, we can see that the latter generally
    contains darker shades compared to the former, and the viewing angle offers a
    better view of the basin where the function is minimized. The darker shade is
    due to the normalization applied to the values for the colormap, which we altered
    using the `vmin` and `vmax` keyword arguments.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 比较*图 2.6*与*图 2.9*，我们可以看到后者相比前者通常包含了更深的阴影，并且视角提供了一个更好的视图，能够更好地看到该函数最小化的盆地。较暗的阴影是由于我们使用`vmin`和`vmax`关键字参数修改了颜色映射的归一化处理所导致的。
- en: How it works...
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Color mapping works by assigning an RGB value according to a scale—the `0` and
    `1`, which is typically done by a linear transformation that takes the minimum
    value to `0` and the maximum value to `1`. The appropriate color is then applied
    to each face of the surface plot (or line, in another kind of plot).
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 色彩映射通过根据一个尺度分配RGB值来实现——`0` 和 `1`，这通常是通过线性变换完成的，最低值映射到`0`，最高值映射到`1`。然后将适当的颜色应用到表面图的每个面（或者在另一种类型的图中应用于线条）。
- en: In the recipe, we used the `vmin` and `vmax` keyword arguments to artificially
    change the value that is mapped to `0` and `1`, respectively, for the purposes
    of fitting the colormap. In effect, we changed the ends of the color range applied
    to the plot.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，我们使用了`vmin`和`vmax`关键字参数，人工改变了分别映射到`0`和`1`的值，以便拟合色彩图。实际上，我们改变了应用到图表上的颜色范围的端点。
- en: Matplotlib comes with a number of built-in colormaps that can be applied by
    simply passing the name to the `cmap` keyword argument. A list of these colormaps
    is given in the documentation ([https://matplotlib.org/tutorials/colors/colormaps.html](https://matplotlib.org/tutorials/colors/colormaps.html))
    and also comes with a reversed variant, which is obtained by adding the `_r` suffix
    to the name of the chosen colormap.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: Matplotlib附带了多个内置的色彩图，可以通过简单地将名称传递给`cmap`关键字参数来应用。色彩图的列表可以在文档中找到（[https://matplotlib.org/tutorials/colors/colormaps.html](https://matplotlib.org/tutorials/colors/colormaps.html)），并且每个色彩图都有一个反向变体，可以通过在所选色彩图名称后添加`_r`后缀来获取。
- en: 'The viewing angle for a 3D plot is described by two angles: the `Axes3D` is
    -60 Azimuthal and 30 elevation. In the recipe, we used the `azim` keyword argument
    of `plot_surface` to change the initial Azimuthal angle to -80 degrees (almost
    from the direction of the negative ![](img/Formula_02_052.png) axis) and the `elev`
    argument to change the initial elevation to 22 degrees.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 3D图的视角由两个角度描述：`Axes3D`的方位角是-60，仰角是30。在本示例中，我们使用了`plot_surface`的`azim`关键字参数将初始方位角改为-80度（几乎是从负方向的![](img/Formula_02_052.png)轴来看），并使用`elev`参数将初始仰角改为22度。
- en: There’s more...
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The normalization step in applying a colormap is performed by an object derived
    from the `Normalize` class. Matplotlib provides a number of standard normalization
    routines, including `LogNorm` and `PowerNorm`. Of course, you can also create
    your own subclass of `Normalize` to perform the normalization. An alternative
    `Normalize` subclass can be added using the `norm` keyword of `plot_surface` or
    other plotting functions.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用色彩图时，归一化步骤是由一个从`Normalize`类派生的对象执行的。Matplotlib提供了多个标准的归一化方法，包括`LogNorm`和`PowerNorm`。当然，你也可以创建自己的`Normalize`子类来执行归一化。通过`plot_surface`或其他绘图函数的`norm`关键字参数，可以添加一个替代的`Normalize`子类。
- en: 'For more advanced uses, Matplotlib provides an interface for creating custom
    shading using light sources. This is done by importing the `LightSource` class
    from the `matplotlib.colors` package, and then using an instance of this class
    to shade the surface elements according to the ![](img/Formula_02_053.png) value.
    This is done using the `shade` method on the `LightSource` object:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更高级的使用，Matplotlib提供了一个接口，通过光源创建自定义的阴影效果。这是通过从`matplotlib.colors`包中导入`LightSource`类来实现的，然后使用该类的实例根据![](img/Formula_02_053.png)值对表面元素进行阴影处理。这是通过`LightSource`对象的`shade`方法实现的：
- en: '[PRE90]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Complete examples are shown in the Matplotlib gallery should you wish to learn
    more about how this.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多，Matplotlib画廊中有完整的示例。
- en: In addition to the viewing angle, we can also change the type of projection
    used to represent 3D data as a 2D image. The default is a perspective projection,
    but we can also use an orthogonal projection by setting the `proj_type` keyword
    argument to `"ortho"`.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 除了视角，我们还可以改变用于表示3D数据为2D图像的投影类型。默认情况下是透视投影，但我们也可以通过将`proj_type`关键字参数设置为`"ortho"`来使用正交投影。
- en: Plotting vector fields with quiver plots
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用箭头图绘制矢量场
- en: A vector field is a function that assigns to each point in a region a vector—it
    is a vector-valued function defined on a space. These are especially common in
    the study of (systems of) differential equations, where a vector field typically
    appears as the right-hand side of the equation. (See the *Solving systems of differential
    equations* recipe from [*Chapter 3*](B19085_03.xhtml#_idTextAnchor078) for more
    details.) For this reason, it is often useful to visualize a vector field and
    understand how the function will evolve over space. For now, we’re simply going
    to produce a plot of a vector field using a quiver plot, which takes a set of
    ![](img/Formula_02_054.png) and ![](img/Formula_02_055.png) coordinates and a
    set of ![](img/Formula_02_056.png) and ![](img/Formula_02_057.png) vectors, and
    produces a plot on which each point has an arrow in the direction ![](img/Formula_02_058.png)
    and whose length is the length of this vector. (Hopefully, this will become more
    clear when we actually create the said plot.)
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 向量场是一个函数，它为区域中的每个点分配一个向量——它是一个在空间上定义的向量值函数。这在研究（系统）微分方程时特别常见，其中向量场通常作为方程的右侧出现。（有关更多详细信息，请参见[*第3章*](B19085_03.xhtml#_idTextAnchor078)中的*解微分方程组*食谱。）因此，通常需要可视化一个向量场，并理解该函数在空间中的演变方式。目前，我们只打算通过箭头图来绘制向量场，箭头图接受一组![](img/Formula_02_054.png)和![](img/Formula_02_055.png)坐标以及一组![](img/Formula_02_056.png)和![](img/Formula_02_057.png)向量，并生成一个图形，其中每个点都有一个指向![](img/Formula_02_058.png)方向的箭头，箭头的长度等于该向量的长度。（希望当我们实际创建该图形时，这将变得更加清晰。）
- en: Getting ready
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: As usual, we import the Matplotlib `pyplot` interface under the alias `plt`.
    Before we start, we need to define a function that takes a point and produces
    a vector; we’ll use this later to generate ![](img/Formula_02_059.png) and ![](img/Formula_02_060.png)
    data that will be passed to the plotting function.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，我们导入Matplotlib的`pyplot`接口，别名为`plt`。在开始之前，我们需要定义一个函数，该函数接受一个点并生成一个向量；我们稍后将使用这个函数来生成![](img/Formula_02_059.png)和![](img/Formula_02_060.png)数据，这些数据将传递给绘图函数。
- en: 'For this example, we’re going to plot the following vector field:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们将绘制以下向量场：
- en: '![](img/Formula_02_061.jpg)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_02_061.jpg)'
- en: For this example, we’ll plot the vector field over the region where ![](img/Formula_02_062.png)
    and ![](img/Formula_02_063.png).
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们将在区域内绘制向量场，其中包含![](img/Formula_02_062.png)和![](img/Formula_02_063.png)。
- en: How to do it…
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: The following steps show how to visualize the aforementioned vector field over
    the specified region.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤展示了如何在指定区域内可视化上述向量场。
- en: 'First, we need to define a Python function that evaluates our vector field
    at points:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要定义一个Python函数，该函数在各点评估我们的向量场：
- en: '[PRE91]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Next, we need to create our grid of points covering the region. For this, we
    first create a temporary `linspace` routine with values between `-1` and `1`.
    Then, we use `meshgrid` to generate a grid of points:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建一个覆盖区域的点网格。为此，我们首先创建一个临时的`linspace`函数，其值介于`-1`和`1`之间。然后，使用`meshgrid`生成一个点网格：
- en: '[PRE92]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Next, we use our function to generate `dx` and `dy` values that describe the
    vectors at each grid point:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用我们的函数生成`dx`和`dy`值，描述每个网格点的向量：
- en: '[PRE93]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Now, we can create a new figure and axis and use the `quiver` method to generate
    a plot:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以创建一个新的图形和坐标轴，并使用`quiver`方法生成图形：
- en: '[PRE94]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'The resulting plot is shown in *Figure 2**.10*:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 结果图如*图2.10*所示：
- en: '![Figure 2.10 - Visualization of a vector field using a quiver plot'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.10 - 使用箭头图可视化向量场'
- en: '](img/B19085_02_10.jpg)'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B19085_02_10.jpg)'
- en: Figure 2.10 - Visualization of a vector field using a quiver plot
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.10 - 使用箭头图可视化向量场
- en: In *Figure 2**.10*, we can see the ![](img/Formula_02_064.png) value represented
    as an arrow based at each ![](img/Formula_02_065.png) coordinate. The size of
    the arrow is determined by the magnitude of the vector field. At the origin, the
    vector field has ![](img/Formula_02_066.png), so the arrows nearby are very small.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图2.10*中，我们可以看到![](img/Formula_02_064.png)值以箭头的形式表示，基于每个![](img/Formula_02_065.png)坐标。箭头的大小由向量场的大小决定。在原点，向量场的值为![](img/Formula_02_066.png)，因此附近的箭头非常小。
- en: How it works…
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: Our example from the recipe is a mathematical construction rather than something
    that might arise from real data. For this particular case, the arrows describe
    how some quantity might evolve if it flows according to the vector field we specified.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从食谱中的例子是一个数学构造，而不是来自真实数据的内容。在这个特定的例子中，箭头描述了某个量如何在按照我们指定的向量场流动时可能演变。
- en: Each point in the grid is the base of an arrow. The direction of the arrow is
    given by the corresponding ![](img/Formula_02_067.png) value, and the length of
    the arrow is normalized by length (so, a vector ![](img/Formula_02_068.png) with
    smaller components produces a shorter arrow). This can be customized by changing
    the `scale` keyword argument. Many other aspects of the plot can be customized
    too.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 网格中的每个点都是一个箭头的起点。箭头的方向由对应的 ![](img/Formula_02_067.png) 值确定，箭头的长度根据长度进行归一化（因此，具有较小分量的向量
    ![](img/Formula_02_068.png) 会产生较短的箭头）。可以通过更改 `scale` 关键字参数来进行自定义。图表的许多其他方面也可以自定义。
- en: There’s more…
  id: totrans-321
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'If you want to plot a set of trajectories that follow a vector field, you can
    use the `streamplot` method. This will plot trajectories starting at various points
    to indicate the general flow in different parts of the domain. Each streamline
    has an arrow to indicate the direction of flow. For example, *Figure 2**.11* shows
    the result of using the `streamplot` method with the vector field in the recipe:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想绘制一组遵循向量场的轨迹，可以使用 `streamplot` 方法。这个方法会绘制从不同点出发的轨迹，以指示在领域的不同部分的总体流动情况。每条流线都有一个箭头来表示流动的方向。例如，*图
    2.11* 显示了使用食谱中的向量场和 `streamplot` 方法得到的结果：
- en: '![Figure 2.11 – Plot of the trajectories described by the vector field from
    the recipe'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.11 – 由食谱中的向量场描述的轨迹图'
- en: '](img/B19085_02_11.jpg)'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B19085_02_11.jpg)'
- en: Figure 2.11 – Plot of the trajectories described by the vector field from the
    recipe
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.11 – 由食谱中的向量场描述的轨迹图
- en: In a different scenario, you might have data about wind speed (or similar quantities)
    at a number of coordinates—on a map, say—and you want to plot these quantities
    in the standard style for weather charts. Then, we can use the `barbs` plotting
    method. The arguments are similar to the `quiver` method.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在不同的场景中，你可能拥有一些关于风速（或类似量）在多个坐标上的数据——比如在地图上——你希望以标准的气象图表风格来绘制这些数据。然后，我们可以使用 `barbs`
    绘图方法。参数与 `quiver` 方法类似。
- en: Further reading
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: The Matplotlib package is extensive, and we can scarcely do it justice in such
    a short space. The documentation contains far more detail than is provided here.
    Moreover, there is a large gallery of examples ([https://matplotlib.org/gallery/index.html#](https://matplotlib.org/gallery/index.html#))
    covering many more of the capabilities of the package than in this book.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: Matplotlib 包非常庞大，我们几乎无法在这么短的篇幅中充分讲解它。文档包含了比这里提供的更多的细节。此外，还有一个包含大量示例的图库 ([https://matplotlib.org/gallery/index.html#](https://matplotlib.org/gallery/index.html#))，展示了该包比本书中更多的功能。
- en: Other packages build on top of Matplotlib to offer high-level plotting methods
    for specific applications. For example, the Seaborn libraries provide routines
    for visualizing data ([https://seaborn.pydata.org/](https://seaborn.pydata.org/)).
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 其他包是在 Matplotlib 的基础上构建的，提供了特定应用的高级绘图方法。例如，Seaborn 库提供了用于可视化数据的例程 ([https://seaborn.pydata.org/](https://seaborn.pydata.org/))。
