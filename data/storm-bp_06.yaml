- en: Chapter 6. Artificial Intelligence
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章 人工智能
- en: In earlier chapters, we saw a pattern that combined real-time analytics using
    Storm with batch processing using Hadoop. In this chapter, we will go in the other
    direction. We will incorporate Storm into an operational system that must respond
    in real time to end user queries.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们看到了一种模式，它将使用Storm进行实时分析与使用Hadoop进行批处理相结合。在本章中，我们将朝着另一个方向前进。我们将把Storm纳入一个操作系统中，这个系统必须实时响应最终用户的查询。
- en: Typical applications of Storm focus on a never-ending stream of data. The data
    is often queued and processed as fast as possible by persistent topologies. The
    system includes a queue to accommodate varying amounts of load. At times of light
    load, the queue is empty. During heavy load, the queue will persist the data for
    eventual processing.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Storm的典型应用集中在永无止境的数据流上。数据通常被排队，并由持久拓扑尽可能快地处理。系统包括一个队列，以容纳不同数量的负载。在轻负载时，队列为空。在重负载时，队列将保留数据以供以后处理。
- en: Even the untrained eye will recognize that such a system does not provide true
    real-time data processing. Storm monitors tuple timeouts, but it is focused on
    the processing time of tuple(s) after the spout emits the data.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是未经训练的眼睛也会认识到这样的系统并不能提供真正的实时数据处理。Storm监视元组超时，但它专注于spout发出数据后元组的处理时间。
- en: To support real-time scenarios more completely, timeouts and **Service Level
    Agreements** (**SLA**) must be monitored from the reception of the data to the
    delivery of the response. These days, requests are often received via an HTTP-based
    API and response time SLAs must be subsecond.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更完全地支持实时场景，必须从接收数据到响应交付的时间监控超时和服务级别协议（SLA）。如今，请求通常通过基于HTTP的API接收，并且响应时间SLA必须在亚秒级别。
- en: HTTP is a synchronous protocol. It often introduces an asynchronous mechanism
    like a queue, complicates the system, and introduces added latency. For this reason,
    when exposing features and functions via HTTP, we typically prefer synchronous
    integrations with components involved.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP是一种同步协议。它经常引入一个像队列这样的异步机制，使系统变得复杂，并引入额外的延迟。因此，当通过HTTP公开功能和函数时，我们通常更喜欢与涉及的组件进行同步集成。
- en: In this chapter, we will explore Storm's place in an architecture that exposes
    a web services API. Specifically, we will construct the world's best tic-tac-toe
    **Artificial Intelligence** (**AI**) system. Our system will include both synchronous
    and asynchronous subsystems. The asynchronous portion of the system will work
    continually, exploring the best options for game states. The synchronous component
    exposes a web services interface that, given a game state, returns the best move
    possible.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨Storm在暴露Web服务API的架构中的位置。具体来说，我们将构建世界上最好的井字游戏人工智能（AI）系统。我们的系统将包括同步和异步子系统。系统的异步部分将不断工作，探索游戏状态的最佳选项。同步组件公开了一个Web服务接口，根据游戏状态返回可能的最佳移动。
- en: 'This chapter covers the following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖以下主题：
- en: Recursion in Storm
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Storm中的递归
- en: Distributed Remote Procedure Call (DRPC)
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分布式远程过程调用（DRPC）
- en: Distributed Read-before-write paradigm
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分布式读写前范式
- en: Designing for our use case
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为我们的用例设计
- en: The "hello world" of the artificial intelligence world is tic-tac-toe. Sticking
    to the tradition, we will also use this as our subject game, although the architecture
    and approach extend well beyond this simple example (for example, Global Thermonuclear
    War; for other use cases, refer to John Badham's *War Games*).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 人工智能世界的“hello world”是井字游戏。遵循传统，我们也将以此作为我们的主题游戏，尽管架构和方法远远超出了这个简单的例子（例如，全球热核战争；对于其他用例，请参考约翰·巴德姆的《战争游戏》）。
- en: Tic-tac-toe is a two-player game of Xes and Os. The board is a 3 x 3 grid. One
    player has the symbol O and the other has the symbol X, and the play alternates.
    On a turn, a player places their symbol in any open cell in the grid. If by placing
    their symbol, it completes a horizontal, vertical, or diagonal line of three contiguous
    symbols, that player wins. If all cells are filled without forming a line of three,
    then the game is a tie.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 井字游戏是一个X和O的两人游戏。棋盘是一个3 x 3的网格。一个玩家有符号O，另一个有符号X，并且轮流进行。在一个回合中，玩家将他们的符号放在网格中的任何空单元格中。如果通过放置他们的符号，完成了三个连续符号的水平、垂直或对角线，那个玩家就赢了。如果所有单元格都填满了而没有形成三个连线，那么游戏就是平局。
- en: A common approach to developing Artificial Intelligence programs for games with
    alternating turns is to explore the game tree recursively searching for the game
    state that evaluates best for the current player (or worse for the opposition).
    A game tree is a tree structure whose nodes are game states. A node's immediate
    children are game states that can be achieved by making a legal move from that
    node's game state.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为交替轮次的游戏开发人工智能程序的常见方法是递归地探索游戏树，寻找对当前玩家评估最佳的游戏状态（或对对手更糟糕的状态）。游戏树是一个节点为游戏状态的树结构。节点的直接子节点是通过从该节点的游戏状态进行合法移动而可以达到的游戏状态。
- en: 'A sample game tree for tic-tac-toe is shown in the following diagram:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 井字游戏的一个示例游戏树如下图所示：
- en: '![Designing for our use case](img/8294OS_06_01.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![为我们的用例设计](img/8294OS_06_01.jpg)'
- en: 'The simplest of algorithms that traverses a game tree searching for the best
    move is the **Minimax** algorithm. The algorithm scores each board recursively
    and returns the best score found. For this algorithm, we assume that a good score
    for the opposition is a bad score for the current player. Thus, the algorithm
    actually alternates between maximizing and minimizing the score of the current
    board. The Minimax algorithm can be summarized with the following pseudocode:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历游戏树寻找最佳移动的最简单算法是极小化极大化（Minimax）算法。该算法对每个棋盘进行递归评分，并返回找到的最佳分数。对于这个算法，我们假设对手的好分数对于当前玩家来说是坏分数。因此，该算法实际上在最大化和最小化当前棋盘的分数之间交替。极小化极大化算法可以用以下伪代码总结：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: A client invokes the algorithm with a game state, a depth, and a Boolean variable
    that indicates whether or not the algorithm should seek to maximize or minimize
    the score. In our use case, the game state is fully encapsulated by the board,
    which is a 3 x 3 grid partially filled with Xes and Os.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端使用游戏状态、深度和布尔变量调用算法，该变量指示算法是否应该寻求最大化或最小化得分。在我们的用例中，游戏状态由棋盘完全封装，棋盘是一个部分填充有X和O的3
    x 3网格。
- en: The algorithm is recursive. The first few lines of the code are the base case.
    This ensures that the algorithm does not recurse endlessly. This conditions on
    the depth variable. In a game of alternating turns, the depth indicates how many
    turns the algorithm should explore.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法是递归的。代码的前几行是基本情况。这确保了算法不会无休止地递归。这取决于深度变量。在交替轮次的游戏中，深度表示算法应该探索多少轮。
- en: In our use case, the Storm topology need not track the depth. We will let the
    Storm topology explore endlessly (or until there are no new boards returned from
    the `move` method).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的用例中，风暴拓扑结构不需要跟踪深度。我们将让风暴拓扑结构无休止地探索（或直到从“移动”方法返回没有新棋盘为止）。
- en: Typically, each player is given a set amount of time and must make his or her
    move within the allotted time. Since we will more likely have antsy human players
    competing against the AI, let's assume the system needs to respond in fewer than
    200 milliseconds.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，每个玩家都会被分配一定的时间，并且必须在规定的时间内进行移动。由于我们更可能有焦躁不安的人类玩家与人工智能竞争，让我们假设系统需要在200毫秒内做出响应。
- en: After the algorithm checks for the base case, it calls the `move()` method,
    which returns boards for all possible moves. The algorithm then cycles through
    all possible child boards. If maximizing, the algorithm finds the child board
    that leads to the highest score. If minimizing, the algorithm finds the board
    that leads to the least score.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在算法检查基本情况之后，它调用“move（）”方法，该方法返回所有可能移动的棋盘。然后算法循环遍历所有可能的子棋盘。如果最大化，算法找到导致最高得分的子棋盘。如果最小化，算法找到导致最低得分的棋盘。
- en: Tip
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The **Negamax** algorithm accomplishes the same more succinctly by alternating
    the sign of the score. Additionally, in a real-world scenario, we might apply
    Alpha-Beta pruning, which attempts to trim the branches of the tree that are explored.
    The algorithm only considers branches that fall within a threshold. In our use
    case, this is not necessary because the search space is small enough to explore
    in its entirety.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Negamax算法通过交替得分的符号更简洁地实现了相同的目标。此外，在现实场景中，我们可能会应用Alpha-Beta剪枝，该剪枝试图修剪探索的树的分支。算法只考虑落在阈值内的分支。在我们的用例中，这是不必要的，因为搜索空间小到足以完全探索。
- en: In our simple use case, it is possible to enumerate the entire game tree. In
    more complicated games such as Chess, the game tree is impossible to enumerate.
    In an extreme case such as Go, experts have calculated the number of legal boards
    to be in excess of 2 x 10170.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们简单的用例中，可以枚举整个游戏树。在更复杂的游戏中，比如国际象棋，游戏树是无法枚举的。在极端情况下，比如围棋，专家们已经计算出合法棋盘的数量超过2
    x 10170。
- en: 'The goal of the Minimax algorithm is to traverse the game tree and assign a
    score to each node. In our Storm topology, which is not beholden to any SLA, the
    score of any non-leaf node is simply the maximum (or minimum) of its descendants.
    For a leaf node, we must interpret the game state into a corresponding score.
    In our simple use case, there are three possible outcomes: we win, our opponent
    wins, or the game is a tie.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Minimax算法的目标是遍历游戏树并为每个节点分配得分。在我们的风暴拓扑结构中，对于任何非叶节点的得分只是其后代的最大值（或最小值）。对于叶节点，我们必须将游戏状态解释为相应的得分。在我们简单的用例中，有三种可能的结果：我们赢了，对手赢了，或者游戏是平局。
- en: In our synchronous system, however, we might very well run out of time before
    we reach a leaf node. In this case, we need to calculate the score from the current
    state of the board. Scoring heuristics are often the most difficult aspect of
    developing an AI application.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们的同步系统中，我们很可能在到达叶节点之前就用完了时间。在这种情况下，我们需要根据当前棋盘状态计算得分。评分启发式通常是开发AI应用程序最困难的部分。
- en: 'For our simple use case, we will compute the score for any board by considering
    the lines in the grid. There are eight lines to consider: three horizontal, three
    vertical, and two diagonals. Each line contributes to the score according to the
    following table:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们简单的用例，我们将通过考虑网格中的线来计算任何棋盘的得分。有八条线需要考虑：三条水平线，三条垂直线和两条对角线。每条线根据以下表格对得分有贡献：
- en: '| Status | Score |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: 状态| 得分|
- en: '| --- | --- |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '--- | --- |'
- en: '| Three in a row for the current player | +1000 |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: 当前玩家三排一个| +1000 |
- en: '| Two in a row for the current player | +10 |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: 当前玩家两排一个| +10 |
- en: '| One in a row for current player | +1 |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: 当前玩家一排一个| +1 |
- en: '| Three in a row for an opponent | -1000 |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: 对手三排一个| -1000 |
- en: '| Two in a row for an opponent | -10 |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: 对手两排一个| -10 |
- en: '| One in a row for an opponent | -1 |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: 对手一排一个| -1 |
- en: The preceding table applies only if the remaining cells in the line are empty.
    Although there are improvements to the preceding heuristic, it suffices for this
    example. And, since we expect Storm to work continually on our game tree, we hope
    not to rely on the heuristic all that much. Instead, we would rely directly on
    the minimum (or maximum) of the leaf scores, which will always be a win (+1000),
    loss (-1000), or draw (0).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的表格仅在线中剩余的单元格为空时适用。虽然有改进前面的启发式，但对于这个例子来说已经足够了。而且，由于我们希望风暴能够持续处理我们的游戏树，我们希望不要太依赖启发式。相反，我们将直接依赖叶子得分的最小值（或最大值），这将始终是赢（+1000），输（-1000）或平局（0）。
- en: Finally, armed with an approach, our algorithm and a scoring function, we are
    able to move on to the architecture and design.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，有了方法、算法和评分函数，我们就能继续进行架构和设计了。
- en: Establishing the architecture
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 建立架构
- en: Examining the preceding algorithm, there are a number of interesting design
    and architectural considerations, especially given the current state of Storm.
    The algorithm requires recursion. We also need a means of synchronously processing
    requests. Recursion within Storm is an evolving topic, and while Storm provides
    a means of interacting with topologies synchronously, when combined with a demand
    for recursion, this presents some unique and interesting challenges.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 审查前面的算法，有许多有趣的设计和架构考虑，特别是考虑到Storm当前的状态。该算法需要递归。我们还需要一种同步处理请求的方法。Storm中的递归是一个不断发展的话题，虽然Storm提供了一种与拓扑同步交互的方法，但结合对递归的需求，这带来了一些独特和有趣的挑战。
- en: Examining the design challenges
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 审查设计挑战
- en: Originally, native Storm provided a mechanism to service asynchronous procedure
    calls. The feature is **Distributed Remote Procedure Call** (**DRPC**). DRPC allowed
    a client to make requests of a topology by submitting data directly to the topology.
    With DRPC, a simple RPC client acts as a spout.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，原生Storm提供了一种服务异步过程调用的机制。这个功能就是**分布式远程过程调用**（**DRPC**）。DRPC允许客户端通过直接向拓扑提交数据来向拓扑发出请求。使用DRPC，一个简单的RPC客户端充当spout。
- en: With the advent of Trident, DRPC was deprecated in native Storm and is now officially
    supported only in Trident.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 随着Trident的出现，DRPC在原生Storm中已经被弃用，现在只在Trident中得到官方支持。
- en: Although there has been some exploratory work into recursive/nonlinear DRPC,
    which is what we would require here, it is not a mainstream functionality ([https://groups.google.com/forum/#!topic/storm-user/hk3opTiv3Kc](https://groups.google.com/forum/#!topic/storm-user/hk3opTiv3Kc)).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管已经进行了一些探索性工作，探讨了递归/非线性DRPC，这正是我们在这里需要的，但这并不是一个主流功能（[https://groups.google.com/forum/#!topic/storm-user/hk3opTiv3Kc](https://groups.google.com/forum/#!topic/storm-user/hk3opTiv3Kc)）。
- en: Additionally, that work would rely on the deprecated classes within the native
    Storm. Thus, we need to find alternative means to create a recursive structure
    without relying on Storm.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这项工作将依赖于Storm中已弃用的类。因此，我们需要找到替代手段来创建一个递归结构，而不依赖于Storm。
- en: Once we find a construct to implement the recursion, we need to be able to invoke
    the same functionality synchronously. Seeking to leverage what Storm provides
    means incorporating DRPC calls into our architecture.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们找到一种构造来实现递归，我们需要能够同步调用相同的功能。寻求利用Storm提供的功能意味着将DRPC调用纳入我们的架构中。
- en: Implementing the recursion
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现递归
- en: 'If we map our algorithm directly to Storm constructs, we would expect a means
    of allowing a stream to feed back data into itself. We can imagine a topology
    similar to the following logical data flow:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将我们的算法直接映射到Storm构造中，我们会期望一种允许流将数据反馈到自身的方法。我们可以想象一个类似以下逻辑数据流的拓扑：
- en: '![Implementing the recursion](img/8294OS_06_02.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![实现递归](img/8294OS_06_02.jpg)'
- en: The `BoardSpout` function emits a board (for example, the 3 x 3 array) in the
    `currentBoard` field with a second field named `parents` that will be used to
    store all parent nodes. The `parents` field will be empty initially.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`BoardSpout`函数在`currentBoard`字段中发出一个棋盘（例如，3 x 3数组），并使用名为`parents`的第二个字段来存储所有父节点。`parents`字段最初将为空。'
- en: The `isLeaf` filter decides whether this is an end state (for example, win,
    loss, or draw). If the `currentBoard` field is not an end state, the `GenerateBoards`
    function emits all the new boards, replacing the value of the `currentBoard` field
    with the child board and adding the `currentBoard` field to the list of nodes
    in the `parents` field. The `GenerateBoards` function could emit the tuple back
    through the spout or directly into the `isLeaf` filter, bypassing the spout.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`isLeaf`过滤器决定这是否是一个结束状态（例如，胜利、失败或平局）。如果`currentBoard`字段不是一个结束状态，`GenerateBoards`函数会发出所有新的棋盘，用子棋盘替换`currentBoard`字段的值，并将`currentBoard`字段添加到`parents`字段中的节点列表中。`GenerateBoards`函数可以通过spout将元组发回，也可以直接进入`isLeaf`过滤器，绕过spout。'
- en: If the `isLeaf` filter determines that this is an end state, we need to score
    the `currentBoard` field and then update all the parents to reflect that new score.
    The `ScoreFunction` computes the score of the board and persists that to the `GameTree
    State`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`isLeaf`过滤器确定这是一个结束状态，我们需要对`currentBoard`字段进行评分，然后更新所有父节点以反映新的分数。`ScoreFunction`计算棋盘的得分，并将其持久化到`GameTree
    State`中。
- en: To update the parents, we iterate over each of the parents and query the current
    maximum (or minimum) for that node. If the child's score is a new maximum (or
    minimum), then we would persist the new values.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更新父节点，我们遍历每个父节点，并查询该节点的当前最大值（或最小值）。如果子节点的得分是新的最大值（或最小值），那么我们将持久化新值。
- en: Tip
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: This is only a logical data flow. Constructing such a topology is not only impossible,
    but also not recommended for reasons described in the following sections.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个逻辑数据流。构建这样的拓扑不仅是不可能的，而且基于以下部分描述的原因也不建议这样做。
- en: You can already see that this data flow is not as straightforward as our pseudocode.
    There are a few constraints within Trident and Storm that force us to introduce
    additional complexities, and furthermore, not all the operations articulated in
    the data flow are available in Storm/Trident. Let's examine this data flow more
    closely.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经可以看到，这个数据流并不像我们的伪代码那样直接。在Trident和Storm中有一些约束，这些约束迫使我们引入额外的复杂性，而且并非所有在数据流中表达的操作都在Storm/Trident中可用。让我们更仔细地检查这个数据流。
- en: Accessing the function's return values
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 访问函数的返回值
- en: Firstly, notice that we are forced to maintain our own call stack in the form
    of a list of parents because Storm and Trident do not have any mechanisms to access
    the results of functions downstream in the topology. In classic recursion, the
    results of the recursive method call are immediately available within the function
    and can be incorporated into the results of that method. Thus, the preceding data
    flow resembles a more iterative approach to the problem.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，注意到我们被迫维护自己的调用堆栈，以父节点列表的形式，因为Storm和Trident没有任何机制可以访问拓扑中下游函数的结果。在经典递归中，递归方法调用的结果立即在函数内部可用，并且可以并入该方法的结果。因此，前面的数据流类似于对问题的更迭方法。
- en: Immutable tuple field values
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不可变元组字段值
- en: Secondly, in the preceding data flow, we invoke a magical ability to replace
    the value of a field. We do that in the recursive emit from the `GenerateBoards`
    function. Replacing the `currentBoard` field with the new board is not possible.
    Additionally, adding the `currentBoard` field to the parents list would require
    updating the value of the `parents` field. In Trident, tuples are immutable.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，在前面的数据流中，我们调用了一个神奇的能力来替换字段的值。我们在`GenerateBoards`函数中进行了递归发出。用新的棋盘替换`currentBoard`字段是不可能的。此外，将`currentBoard`字段添加到父节点列表中将需要更新`parents`字段的值。在Trident中，元组是不可变的。
- en: Upfront field declaration
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 前期字段声明
- en: To get around tuple immutability, we could always add additional fields to the
    tuple—one for each layer of the recursion—but Trident requires that all fields
    be declared prior to deployment.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决元组的不可变性，我们可以始终向元组添加额外的字段——每个递归层都要添加一个字段——但Trident要求在部署之前声明所有字段。
- en: Tuple acknowledgement in recursion
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 递归中的元组确认
- en: We have additional problems when we consider tuple acknowledgement in this data
    flow. At what point do we acknowledge the initial tuple that triggered the processing?
    From a logical data flow perspective, that initial tuple shouldn't be acknowledged
    until all the children for that node have been considered and the game tree state
    reflects those scores. Surely, however, the processing time to compute large subsections
    of the game tree for any non-trivial game would most likely exceed any tuple timeouts.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑这个数据流中的元组确认时，我们还有其他问题。在什么时候确认触发处理的初始元组？从逻辑数据流的角度来看，直到该节点的所有子节点都被考虑并且游戏树状态反映了这些分数之前，初始元组都不应该被确认。然而，计算任何非平凡游戏的大部分游戏树子部分的处理时间很可能会超过任何元组超时。
- en: Output to multiple streams
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 输出到多个流
- en: Another issue with topology is the multiple paths that emit from the `isLeaf`
    filter. Presently, there is no way to output to multiple streams within Trident.
    The enhancement can be found at [https://issues.apache.org/jira/browse/STORM-68](https://issues.apache.org/jira/browse/STORM-68).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 拓扑的另一个问题是从`isLeaf`过滤器发出的多条路径。目前，在Trident中没有办法在多个流中输出。增强功能可以在[https://issues.apache.org/jira/browse/STORM-68](https://issues.apache.org/jira/browse/STORM-68)找到。
- en: As we will see, you can work around this by forking the stream and affecting
    the decision as filters on both streams.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将看到的，您可以通过在两个流上分叉并将决策作为过滤器影响这一点。
- en: Read-before-write
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 写入前读取
- en: 'Lastly, because we do not have access to the return values, updating the parent
    scores requires a read-before-write paradigm. This is an anti-pattern in any distributed
    system. The following sequence diagram demonstrates the issues that arise in read-before-write
    constructs in the absence of locking mechanisms:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，因为我们无法访问返回值，更新父节点分数需要一个读取前写入的范式。这在任何分布式系统中都是一种反模式。以下序列图演示了在缺乏锁定机制的情况下读取前写入构造中出现的问题：
- en: '![Read-before-write](img/8294OS_06_03.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![写入前读取](img/8294OS_06_03.jpg)'
- en: In the preceding diagram, there are two threads operating independently. In
    our use case, this occurs when multiple children complete simultaneously and attempt
    to resolve the maximum score of a parent node at the same time.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在上图中，有两个独立操作的线程。在我们的用例中，当多个子节点同时完成并尝试同时解析父节点的最大分数时，就会发生这种情况。
- en: The first thread is resolving a child score of **7**. The second thread is resolving
    a child score of **15**. They are both resolving the same node. At the end of
    the process, the new maximum should be **15**, but because there was no coordination
    between the threads, the maximum score becomes **7**.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个线程正在解析子节点的分数为**7**。第二个线程正在解析子节点的分数为**15**。它们都在解析同一个节点。在过程结束时，新的最大值应该是**15**，但由于线程之间没有协调，最大分数变成了**7**。
- en: The first thread reads the current maximum score for the node, which returns
    **5**. Then, the second thread reads from the state and also receives **5**. Both
    threads compare the current maximum to their respective child scores and update
    the maximum with new values. Since the second thread's update takes place after
    the first, the result is an incorrect maximum value for the parent node.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个线程读取节点的当前最大分数，返回**5**。然后，第二个线程从状态中读取，也收到**5**。两个线程将当前最大值与它们各自的子节点分数进行比较，并用新值更新最大值。由于第二个线程的更新发生在第一个之后，结果是父节点的最大值不正确。
- en: In the next section, we will see how to properly address the preceding constraints
    to produce a functional system.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看到如何正确解决前面的约束，以产生一个功能性的系统。
- en: Solving the challenges
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决挑战
- en: 'To accommodate the constraints outlined in the preceding section, we will break
    the topology into two parts. The first topology will perform the actual recursion.
    The second topology will resolve the scores. This is shown in the following diagram:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 为了适应前面部分概述的约束，我们将拓扑分成两部分。第一个拓扑将执行实际的递归。第二个拓扑将解析分数。这在下图中显示：
- en: '![Solving the challenges](img/8294OS_06_04.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![解决挑战](img/8294OS_06_04.jpg)'
- en: 'The system is broken down into two topologies: the **Recursion Topology** and
    the **Scoring Topology** . The **Recursion Topology** attempts to enumerate all
    the boards in the system. The Scoring Topology attempts to score all of the boards
    enumerated by the Recursion Topology.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 系统分为两个拓扑：“递归拓扑”和“评分拓扑”。递归拓扑尝试枚举系统中的所有棋盘。评分拓扑尝试对递归拓扑枚举的所有棋盘进行评分。
- en: 'To affect the recursion, we introduce two queues in the system. The first queue,
    **Work Queue**, contains a list of nodes that we need to visit. The Recursion
    Topology consumes from that queue via the **Work Spout**. If the node is not a
    leaf, the topology queues the child boards. The format of the messages on the
    Work Queue is as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 为了影响递归，我们在系统中引入了两个队列。第一个队列，“工作队列”，包含我们需要访问的节点列表。递归拓扑通过“工作喷口”从该队列中获取。如果节点不是叶子节点，拓扑将排队子节点的棋盘。工作队列上的消息格式如下：
- en: '[PRE1]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Each `board` is a 3 x 3 array. The `parents` array contains all of the parent
    boards.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 每个“board”都是一个3x3的数组。“parents”数组包含所有父棋盘。
- en: If the node is a leaf node, the board is queued on the **Scoring Queue** using
    the same message format. The Scoring Topology reads from the Scoring Queue via
    the **Scoring Spout**. The **Scoring Function** scores the node. The board is
    necessarily a leaf node because that is the only type of node queued for scoring.
    Then, the Scoring Function emits a tuple for the current node and each parent.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果节点是叶子节点，棋盘将使用相同的消息格式排队到“评分队列”上。评分拓扑通过“评分喷口”从评分队列中读取。评分函数对节点进行评分。棋盘必然是叶子节点，因为这是排队进行评分的唯一类型的节点。然后，评分函数对当前节点和每个父节点发出一个元组。
- en: We then need to update the state. The query-and-write paradigms are encapsulated
    in a single function because of the race condition we outlined previously. In
    the following design, we will demonstrate how we accommodate the race condition
    introduced by read-before-write.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们需要更新状态。由于我们之前概述的竞争条件，查询和写入范式被封装在一个函数中。在接下来的设计中，我们将演示如何适应读写之前引入的竞争条件。
- en: 'However, before we move on to the design, notice that because we introduced
    queues, we clearly delineated lines along which we can acknowledge tuples. In
    the first topology, a tuple is acknowledged when either of the cases is true:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们继续设计之前，请注意，因为我们引入了队列，我们清楚地划定了可以确认元组的线路。在第一个拓扑中，当以下情况之一为真时，元组被确认：
- en: The topology has enumerated and queued the descendants of a node
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拓扑已经枚举并排队了节点的后代
- en: The topology has queued the node for scoring
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拓扑已经将节点排队进行评分
- en: In the second topology, a tuple is acknowledged when the current board and all
    of its parents have been updated to reflect the value in the leaf node.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个拓扑中，当当前棋盘及其所有父节点都已更新以反映叶子节点中的值时，元组被确认。
- en: Also notice that we do not need to introduce new fields or mutate existing fields
    during processing. The only fields used in the first topology are `board` and
    `parents`. The second topology is the same but adds a single additional field
    to capture the score.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意的是，在处理过程中我们不需要引入新的字段或改变现有字段。第一个拓扑中使用的唯一字段是“board”和“parents”。第二个拓扑相同，但添加了一个额外的字段来捕获分数。
- en: Notice also that we forked the stream coming out of the Work Spout. This was
    done to accommodate the fact that we cannot emit to multiple streams from a single
    function. Instead, both `GenerateBoards` and `IsEndGame` must determine whether
    the game has ended and react accordingly. In `GenerateBoards`, the tuple is filtered
    to avoid an infinite recursion. In `IsEndGame`, the tuple is passed along for
    scoring. When functions are able to emit to different streams, we will be able
    to collapse this function into a single "decision" filter that choses which stream
    a tuple should proceed with.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，我们分叉了从工作喷口出来的流。这是为了适应我们不能从单个函数中发出多个流的事实。相反，“GenerateBoards”和“IsEndGame”都必须确定游戏是否已经结束并做出相应反应。在“GenerateBoards”中，元组被过滤以避免无限递归。在“IsEndGame”中，元组被传递以进行评分。当函数能够发出到不同的流时，我们将能够将此函数合并为一个单一的“决策”过滤器，选择元组应该继续的流。
- en: Implementing the architecture
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施架构
- en: Let's now delve into the details of the implementation. For example purposes,
    the following code assumes the topology is running locally. We use an in-memory
    queue instead of a persistent queue, and a hash map as our storage mechanism.
    In a real production implementation, we would most likely use a durable queuing
    system such as Kafka and a distributed storage mechanism such as Cassandra.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们深入了解实现的细节。为了举例说明，以下代码假设拓扑在本地运行。我们使用内存队列而不是持久队列，并使用哈希映射作为我们的存储机制。在真正的生产实现中，我们很可能会使用诸如Kafka之类的持久队列系统和诸如Cassandra之类的分布式存储机制。
- en: The data model
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据模型
- en: 'We will look at each of the topologies in depth, but first, let''s have a look
    at the data model. To simplify things, we''ve encapsulated the game logic and
    the data model into two classes: `Board` and `GameState`.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将深入研究每个拓扑，但首先，让我们看看数据模型。为了简化，我们将游戏逻辑和数据模型封装到两个类中：“Board”和“GameState”。
- en: 'The following is a listing of the `Board` class:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是“Board”类的列表：
- en: '[PRE2]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `Board` class provides three main functions. The `Board` class encapsulates
    the board itself in a multidimensional string array as a member variable. It then
    provides functions that will generate the child boards (for example, `nextBoards()`),
    determines whether the game has ended (for example, `isEndState()`), and finally,
    provides a method to compute the score of the board when a player is provided
    (for example, `nextBoards(player)`, and its supporting methods).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: “Board”类提供了三个主要函数。“Board”类封装了棋盘本身，作为成员变量以多维字符串数组的形式存在。然后它提供将生成子棋盘的函数（例如，“nextBoards()”），确定游戏是否已经结束（例如，“isEndState()”），最后，提供一个计算棋盘得分的方法，当提供了一个玩家时（例如，“nextBoards(player)”及其支持方法）。
- en: Notice also that the `Board` class provides a `toKey()` method. This key uniquely
    represents the board and is what we will use as a unique identifier when accessing
    our persistence mechanism. In this case, the unique identifier is just a concatenation
    of the values from the board grid.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意`Board`类提供了一个`toKey()`方法。这个键唯一地表示了棋盘，这是我们在访问我们的持久性机制时将使用的唯一标识符。在这种情况下，唯一标识符只是棋盘网格中的值的串联。
- en: 'To completely represent the game state, we also need to know which player is
    currently taking their turn. Thus, we have one higher-level object that encapsulates
    the board and the current player. This is the `GameState` object whose listing
    is shown in the following code snippet:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完全表示游戏状态，我们还需要知道当前轮到哪个玩家。因此，我们有一个封装了棋盘和当前玩家的高级对象。这是`GameState`对象，其清单如下所示：
- en: '[PRE3]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: There is nothing terribly surprising in this class except for the `history`
    variable. This member variable tracks all the previous board states for this path
    through the game tree. This is the breadcrumb trail required to update the game
    tree with the score from the leaf node.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类中没有什么特别令人惊讶的，除了`history`变量。这个成员变量跟踪了这条游戏树路径上的所有先前的棋盘状态。这是更新游戏树以获得叶节点得分所需的面包屑路径。
- en: 'Finally, we represent the player in the game with the `Player` class, which
    is shown in the following code snippet:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们用`Player`类表示游戏中的玩家，如下所示：
- en: '[PRE4]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Examining the recursive topology
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查递归拓扑
- en: 'With the data model outlined previously, we can create a topology that recurses
    down the game tree. In our implementation, this is the `RecursiveTopology` class.
    The code for the topology is shown in the following code snippet:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 有了之前概述的数据模型，我们可以创建一个递归下棋树的拓扑结构。在我们的实现中，这是`RecursiveTopology`类。拓扑的代码如下所示：
- en: '[PRE5]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The first section configures the in-memory queues for work and scoring. The
    input stream is configured from a single spout working off of the Work Queue.
    This queue is seeded with the initial game state.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分配置了工作和评分的内存队列。输入流是从一个单个spout配置的，该spout从工作队列中工作。这个队列被初始化为初始游戏状态。
- en: The stream is then forked. The first prong of the fork is filtered for only
    endgame boards, which are then passed along to the Scoring Queue. The second prong
    of the fork generates new boards and queues the descendants.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将流分叉。叉的第一个叉齿仅用于终局棋盘，然后将其传递到评分队列。叉的第二个叉齿生成新的棋盘并将后代排队。
- en: The queue interaction
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 队列交互
- en: 'For this example implementation, we used an in-memory queue. In a real production
    system, we would rely on the Kafka spout. The listing for the `LocalQueueEmitter`
    class is shown in the following code snippet. Note that queues are instances of
    a `BlockingQueue` instance within a map, which links a queue name to the `BlockingQueue`
    instance. This is a handy class when testing topologies that use a single queue
    as the input and output (that is, recursive topologies):'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例实现，我们使用了内存队列。在真实的生产系统中，我们会依赖Kafka spout。`LocalQueueEmitter`类的清单如下所示。请注意，队列是`BlockingQueue`实例的实例，位于一个映射内，将队列名称链接到`BlockingQueue`实例。这是一个方便的类，用于测试使用单个队列作为输入和输出的拓扑（即递归拓扑）：
- en: '[PRE6]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The main method in this class is the `emitBatch` implementation for the `Emitter`
    interface. This simply reads from the queue while it has data and while the maximum
    batch size has not been reached.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 该类中的主要方法是`Emitter`接口的`emitBatch`实现。这只是在队列中有数据且未达到最大批量大小时读取。
- en: 'Also, note that the class provides an `enqueue()` method. The `enqueue()` method
    is used by our `LocalQueueFunction` class to complete the recursion. The listing
    for the `LocalQueueFunction` class is shown in the following code snippet:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，该类提供了一个`enqueue()`方法。`enqueue()`方法由我们的`LocalQueueFunction`类用于完成递归。`LocalQueueFunction`类的清单如下所示：
- en: '[PRE7]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note that the function is actually instantiated with the `emitter` function
    used by the spout. This allows the function to enqueue data directly into the
    spout. Again, this construct is useful when developing recursive topologies, but
    real production topologies would most likely use durable storage. Without durable
    storage, there is a chance for data loss since tuples are acknowledged before
    the processing (recursion) is complete.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，函数实际上是使用spout使用的`emitter`函数实例化的。这允许函数直接将数据排入spout。同样，这种构造在开发递归拓扑时很有用，但是真实的生产拓扑很可能会使用持久存储。没有持久存储，存在数据丢失的可能性，因为元组在处理（递归）完成之前就被确认。
- en: Functions and filters
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数和过滤器
- en: 'Now, we turn our attention to the functions and filters specific to this topology.
    The first is a simple filter used to filter out the endgame boards. The code for
    the `IsEndGame` filter is shown in the following code snippet:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将注意力转向与此拓扑特定的函数和过滤器。首先是一个简单的过滤器，用于过滤出终局棋盘。`IsEndGame`过滤器的代码如下所示：
- en: '[PRE8]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Note that this class is not necessary if Trident had support for emitting tuples
    to different streams from a single function. In the following listing for the
    `IsEndGame` function, it performs the same check/filter function:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果Trident支持从单个函数向不同流发出元组，则此类是不必要的。在以下`IsEndGame`函数的清单中，它执行相同的检查/过滤功能：
- en: '[PRE9]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The function adds the current board to the history list, and then queues a new
    `GameState` object, with the child board position.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数将当前棋盘添加到历史列表中，然后排队一个新的`GameState`对象，带有子棋盘位置。
- en: Tip
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Alternatively, we could have implemented `IsEndGame` as a function, adding another
    field to capture the results; however, it was more constructive to use this as
    an example to motivate having multiple stream capabilities within functions.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以将`IsEndGame`实现为一个函数，添加另一个字段来捕获结果；然而，使用这个作为一个例子来激励函数内部具有多个流能力更有建设性。
- en: 'The following is a sample output from the Recursive Topology:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是递归拓扑的示例输出：
- en: '[PRE10]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Examining the Scoring Topology
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查评分拓扑
- en: The Scoring Topology is more straightforward in that it is linear. The complicated
    aspect is the state's update to avoid the read-before-write race condition.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 评分拓扑结构更直接，因为它是线性的。复杂的方面是状态的更新，以避免读写竞争条件。
- en: 'The code for the topology is as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 拓扑结构的代码如下：
- en: '[PRE11]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'There are only two functions: `ScoreFunction` and `ScoreUpdater`. The `ScoreFunction`
    scores the current board and emits that score for each board in the history.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 只有两个函数：`ScoreFunction` 和 `ScoreUpdater`。`ScoreFunction` 为历史上的每个棋盘评分并发出该得分。
- en: 'The listing for `ScoreFunction` is shown in the following code snippet:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`ScoreFunction` 的列表如下代码片段所示：'
- en: '[PRE12]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The function simply scores the current board and emits a tuple for the current
    board. Then, the function loops through the player emitting tuples for each board,
    swapping the player with each turn.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数简单地为当前棋盘评分并为当前棋盘发出一个元组。然后，该函数循环遍历玩家，为每个棋盘发出元组，并在每轮中交换玩家。
- en: 'Lastly, we have the `ScoreUpdater` function. Again, we kept it simple for the
    example. The following is the code for this class:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有`ScoreUpdater` 函数。同样，我们为示例保持简单。以下是该类的代码：
- en: '[PRE13]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Addressing read-before-write
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决读写问题
- en: Notice in the preceding code that we used a mutex to sequence the updates to
    scores, thereby eliminating the race condition mentioned earlier. This only works
    because we are operating in a single/local JVM. When this topology is deployed
    to a real cluster, this will not work; however, we do have a few options to address
    the issue.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在前面的代码中，我们使用互斥锁来对得分的更新进行排序，从而消除了之前提到的竞争条件。这仅在我们在单个/本地JVM中运行时才有效。当此拓扑结构部署到真实集群时，这将不起作用；但是，我们有一些选项来解决这个问题。
- en: Distributed locking
  id: totrans-138
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 分布式锁定
- en: As we see in other chapters, it is possible to leverage a distributed locking
    mechanism such as ZooKeeper. In this approach, ZooKeeper provides a mechanism
    for maintaining a mutex across multiple hosts. This is certainly a viable approach,
    but distributed locks come at a cost to performance. Every operation incurs overhead
    to accommodate what in reality might be an infrequent occurrence.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在其他章节中看到的，可以利用分布式锁定机制，例如 ZooKeeper。在这种方法中，ZooKeeper提供了一种在多个主机之间维护互斥锁的机制。这当然是一种可行的方法，但分布式锁定会带来性能成本。每个操作都会产生开销，以适应现实中可能是不经常发生的情况。
- en: Retry when stale
  id: totrans-140
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 过时时重试
- en: Another pattern that might be useful is the *retry when stale* approach. In
    this scenario, along with the data, we also pull back a version number, timestamp,
    or checksum. Then, we perform a conditional update, including the version/timestamp/checksum
    information in a clause that will fail the update if that metadata has changed
    (for example, adding the `WHERE` clause to the `UPDATE` statement in the SQL/CQL
    paradigm). If the metadata has changed, it indicates that the value on which we
    based our decision is now stale and we should reselect the data.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 可能有用的另一种模式是*过时时重试*方法。在这种情况下，除了数据之外，我们还会拉回一个版本号、时间戳或校验和。然后，我们执行条件更新，包括版本/时间戳/校验和信息在一个子句中，如果元数据发生了变化（例如，在SQL/CQL范式中将`WHERE`子句添加到`UPDATE`语句中），则更新将失败。如果元数据发生了变化，表示我们基于的值现在已经过时，我们应该重新选择数据。
- en: Obviously, there are trade-offs between these approaches. With retries, in the
    extreme case where there is a tremendous amount of contention, a thread may have
    to be retried a number of times in order to commit an update. However, with distributed
    locking, you may run into timeout issues if a single thread gets stuck, loses
    communication with the server, or fails entirely.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这些方法之间存在权衡。在重试中，如果存在大量争用，一个线程可能需要重试多次才能提交更新。然而，使用分布式锁定时，如果单个线程被卡住、与服务器失去通信或完全失败，可能会遇到超时问题。
- en: Tip
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'Recently, there have been advances in this area. I suggest that you should
    look at Paxos and Cassandra''s use of that algorithm to affect conditional updates
    at the following URLs:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 最近，在这个领域已经有了一些进展。我建议您查看 Paxos 和 Cassandra 在以下URL中使用该算法来影响条件更新：
- en: '[http://research.microsoft.com/en-us/um/people/lamport/pubs/paxos-simple.pdf](http://research.microsoft.com/en-us/um/people/lamport/pubs/paxos-simple.pdf)'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://research.microsoft.com/en-us/um/people/lamport/pubs/paxos-simple.pdf](http://research.microsoft.com/en-us/um/people/lamport/pubs/paxos-simple.pdf)'
- en: '[http://www.datastax.com/dev/blog/lightweight-transactions-in-cassandra-2-0](http://www.datastax.com/dev/blog/lightweight-transactions-in-cassandra-2-0)'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://www.datastax.com/dev/blog/lightweight-transactions-in-cassandra-2-0](http://www.datastax.com/dev/blog/lightweight-transactions-in-cassandra-2-0)'
- en: 'In our simple case, we are extremely lucky, and we can actually incorporate
    the logic into the update directly. Consider the following SQL statement:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的简单情况中，我们非常幸运，实际上可以直接将逻辑合并到更新中。考虑以下SQL语句：
- en: '[PRE14]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As we have resolved our read-before-write issues, the topology is suitable to
    score all of the boards queued by the Recursive Topology. The topology assigns
    a value to the endgame state and propagates that value up the game tree, persisting
    the proper score with the respective game state. In a real production system,
    we would access that state from our DRPC topology to be able to look ahead multiple
    turns.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经解决了读写问题，拓扑结构适合对递归拓扑结构排队的所有棋盘进行评分。该拓扑结构为终局状态分配一个值，并将该值传播到游戏树上，将适当的得分与相应的游戏状态持久化。在真实的生产系统中，我们将从DRPC拓扑结构访问该状态，以便能够提前多回合。
- en: Executing the topology
  id: totrans-150
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 执行拓扑结构
- en: 'The following is sample output for the Scoring Topology:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是评分拓扑结构的示例输出：
- en: '[PRE15]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: It is resolving a tie-game leaf node, shown at the beginning of the listing.
    You can see that the value propagates through the parents after that, updating
    the current score for those nodes.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 它正在解决列表开头显示的平局叶节点。之后，您可以看到该值在那之后通过父节点传播，更新这些节点的当前得分。
- en: Enumerating the game tree
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 枚举游戏树
- en: The final result of combining the Recursive Topology with the Scoring Topology
    is a set of topologies working together continually to enumerate as much of the
    problem space as possible. Most likely, this process would be combined with heuristics
    that would only store key nodes. Also, we would prune the search space using heuristics
    to reduce the number of boards we need to evaluate. Regardless, however, we will
    need to interact with the system through an interface in order to determine the
    best move, given a current game state. This is what we will tackle in the next
    section.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 将递归拓扑与评分拓扑相结合的最终结果是一组拓扑不断协作，以尽可能多地枚举问题空间。很可能，这个过程将与启发式算法相结合，只存储关键节点。此外，我们将使用启发式算法修剪搜索空间，以减少我们需要评估的板的数量。然而，无论如何，我们都需要通过接口与系统进行交互，以确定在当前游戏状态下的最佳移动。这将是我们下一节要解决的问题。
- en: Distributed Remote Procedure Call (DRPC)
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分布式远程过程调用（DRPC）
- en: Now that we have a functioning Recursive Topology that will continually seek
    to compute the entire game tree, let's take a look at a synchronous invocation.
    The DRPC capabilities that Storm provided were ported to Trident and deprecated
    in Storm. This was the major motivation for using Trident in this example.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个功能正常的递归拓扑，它将不断寻求计算整个游戏树，让我们来看看同步调用。Storm提供的DRPC功能已被移植到Trident，并在Storm中已被弃用。这是在本例中使用Trident的主要动机。
- en: 'With DRPC, you construct a topology much like you would in the asynchronous
    case. The following diagram show our DRPC topology:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 使用DRPC，您构建拓扑的方式与异步情况下的方式非常相似。以下图表显示了我们的DRPC拓扑：
- en: '![Distributed Remote Procedure Call (DRPC)](img/8294OS_06_05.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![分布式远程过程调用（DRPC）](img/8294OS_06_05.jpg)'
- en: 'The DRPC client acts as a spout. The output of the client passes through the
    `ArgsFunction`, which normalizes the input so we can reuse the existing functions:
    `GenerateBoards` and `ScoreFunction`. Then, we use `.groupBy(state)` and aggregate
    the results using an `Aggregator` class''s `FindBestMove`. We then perform a simple
    projection to return only the best move to the client.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: DRPC客户端充当一个喷口。客户端的输出经过`ArgsFunction`，它规范化输入，以便我们可以重用现有的函数：`GenerateBoards`和`ScoreFunction`。然后，我们使用`.groupBy(state)`并使用`Aggregator`类的`FindBestMove`来聚合结果。然后，我们执行一个简单的投影，只将最佳移动返回给客户端。
- en: Tip
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You might also want to take a look at Spring Breeze, which allows you to wire
    POJOs together into a Storm topology. This is another approach to gain reuse,
    because those same POJOs could be exposed via web services without introducing
    DRPC.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还想看一下Spring Breeze，它允许您将POJO连接到Storm拓扑中。这是另一种获得重用的方法，因为这些相同的POJO可以通过Web服务公开而不引入DRPC。
- en: '[https://github.com/internet-research-network/breeze](https://github.com/internet-research-network/breeze)'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/internet-research-network/breeze](https://github.com/internet-research-network/breeze)'
- en: 'First, we will have a look at the code for the topology:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将看一下拓扑的代码：
- en: '[PRE16]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: For this example, we use a `LocalDRPC` client. This is passed in as an argument
    to the `newDRPCStream` call, which is the crux of a DRPC topology. From there
    on, the topology functions as a normal topology.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们使用了一个`LocalDRPC`客户端。这作为`newDRPCStream`调用的参数传入，这是DRPC拓扑的关键。从那里开始，拓扑函数就像一个普通的拓扑一样运行。
- en: You can see the actual remote procedure call takes place via the `client.execute()`
    method. Presently, the signature for that method takes and returns only strings.
    There is an outstanding enhancement request to change this signature. You can
    find that enhancement at [https://issues.apache.org/jira/browse/STORM-42](https://issues.apache.org/jira/browse/STORM-42).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`client.execute()`方法，您可以看到实际的远程过程调用发生。目前，该方法的签名仅接受和返回字符串。有一个未解决的增强请求来更改这个签名。您可以在[https://issues.apache.org/jira/browse/STORM-42](https://issues.apache.org/jira/browse/STORM-42)找到该增强请求。
- en: 'Since the current signature only accepts strings, we need to marshal the input.
    This takes place in the `ArgsFunction` as shown in the following code snippet:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 由于当前签名只接受字符串，我们需要对输入进行编组。这发生在`ArgsFunction`中，如下面的代码片段所示：
- en: '[PRE17]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The second parameter to the call we made to `client.execute()` was a string
    that contained our input. In this case, you can see it in the topology code that
    we passed in the key for the board. This was the 3 x 3 grid, with the cells concatenated
    as a string. In order to marshal that string into a board, we added a constructor
    to the `Board` class that parses the string into a board as shown in the following
    code snippet:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对`client.execute()`的调用的第二个参数是一个包含我们输入的字符串。在这种情况下，您可以在拓扑代码中看到我们传入了板的键。这是一个3x3的网格，其中单元格被串联为一个字符串。为了将该字符串编组为一个板，我们向`Board`类添加了一个解析字符串为板的构造函数，如下面的代码片段所示：
- en: '[PRE18]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The next two functions applied in the DRPC topology demonstrate the reuse that
    you can achieve by leveraging DRPC as a synchronous interface. In this case, we
    are leveraging the functions in isolation, but you can imagine that you could
    reuse more complicated data flows as well.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在DRPC拓扑中应用的下两个函数演示了通过利用DRPC作为同步接口可以实现的重用。在这种情况下，我们是独立利用这些函数，但您可以想象您也可以重用更复杂的数据流。
- en: Using the `GenerateBoard` function, we emit all the children for the current
    board. Then, the `ScoreFunction` scores each of those boards.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`GenerateBoard`函数，我们发出当前板的所有子板。然后，`ScoreFunction`对每个板进行评分。
- en: 'As it was in the Scoring Topology, the output of the `ScoreFunction` is a triple
    of `board`, `score`, and `player`. These are the scores for each of the children
    boards. To determine our next best move, we simply need to maximize (or minimize)
    the value. This can be done using a simple `Aggregator`. We created an aggregating
    function named `FindBestMove` as shown in the following code snippet:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 与评分拓扑一样，`ScoreFunction`的输出是`board`、`score`和`player`的三元组。这些是每个子板的分数。为了确定我们的下一个最佳移动，我们只需要最大化（或最小化）这个值。这可以通过一个简单的`Aggregator`来实现。我们创建了一个名为`FindBestMove`的聚合函数，如下面的代码片段所示：
- en: '[PRE19]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This aggregation extends `BaseAggregator`, which is a Java generic. In this
    case, we want to emit the best possible move, combined with its score. Thus, we
    parameterize the `BaseAggregator` class with a `BestMove` class, which is simply
    as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这个聚合扩展了`BaseAggregator`，它是一个Java泛型。在这种情况下，我们希望发出最佳的移动，结合它的得分。因此，我们使用`BestMove`类参数化`BaseAggregator`类，它的简单定义如下：
- en: '[PRE20]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: If you recall, for aggregation, Trident initially calls the `init()` method,
    which returns the initial aggregate value. In our case, we simply seed the `BestMove`
    class with the worst move. Note that the score variable of the `BestMove` class
    is seeded with the absolute minimum value. Then, Trident makes subsequent calls
    to the `aggregate()` method, which allows the function to incorporate the tuple
    into the aggregate value. An aggregation can also emit values here, but since
    we are only concerned with the final best move, we do not emit anything form the
    `aggregate()` method. Finally, Trident calls the `complete()` method when all
    values of tuples have been aggregated. It is in this method that we emit the final
    best move.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你回忆一下，对于聚合，Trident最初调用`init()`方法，该方法返回初始的聚合值。在我们的情况下，我们只是用最差的移动来初始化`BestMove`类。注意`BestMove`类的得分变量被初始化为绝对最小值。然后，Trident调用`aggregate()`方法，允许函数将元组合并到聚合值中。聚合也可以在这里发出值，但由于我们只关心最终的最佳移动，所以我们不从`aggregate()`方法中发出任何东西。最后，Trident在所有元组的值都被聚合后调用`complete()`方法。在这个方法中，我们发出最终的最佳移动。
- en: 'The following is the output from the topology:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是拓扑结构的输出：
- en: '[PRE21]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In this example, it is O's turn, and he or she has a scoring opportunity. You
    can see that the topology correctly identifies the scoring opportunity and returns
    it as the best possible move (with the appropriate score value).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，轮到O方了，他或她有一个得分机会。你可以看到拓扑正确地识别了得分机会，并将其作为最佳移动返回（带有适当的得分值）。
- en: Remote deployment
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 远程部署
- en: 'What we showed is local invocation of a DRPC topology. To invoke a remote topology,
    you need to launch the DRPC server. You do this, just like any other Storm service,
    by executing the Storm script with `drpc` as the parameter as shown in the following
    code snippet:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们展示的是DRPC拓扑的本地调用。要调用远程拓扑，你需要启动DRPC服务器。你可以通过执行带有`drpc`参数的Storm脚本来实现这一点，如下面的代码片段所示：
- en: '[PRE22]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The Storm cluster will connect to the DRPC server to receive invocations. In
    order for it to do that, it needs to know the location(s) of the DRPC servers.
    These are specified in the `storm.yaml` file as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: Storm集群将连接到DRPC服务器接收调用。为了做到这一点，它需要知道DRPC服务器的位置。这些位置在`storm.yaml`文件中指定如下：
- en: '[PRE23]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'With the servers configured and the DRPC server started, the topology is submitted
    like any other topology, and the DRPC client can be used from any Java application
    that requires large-scale synchronous distributed processing. To switch from a
    local DRPC client to a remote, the only line that needs to change is the instantiation
    of the DRPC client. Instead of instantiating a local DRPC client, you need to
    use the following line:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 配置好服务器并启动DRPC服务器后，拓扑就像任何其他拓扑一样被提交，DRPC客户端可以从任何需要大规模同步分布式处理的Java应用程序中使用。要从本地DRPC客户端切换到远程客户端，唯一需要更改的是DRPC客户端的实例化。你需要使用以下行：
- en: '[PRE24]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The parameters specify the host and port of the DRPC server and should match
    the configuration in the YAML file.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这些参数指定了DRPC服务器的主机和端口，并应与YAML文件中的配置匹配。
- en: Summary
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we took on an AI use case. There are many problems within that
    domain that leverage tree and graph data structures, and the algorithms most appropriate
    for those data structures are often recursive. To demonstrate how those algorithms
    translate to Storm, we took the Minimax algorithm and implemented it using Storm's
    constructs.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们处理了一个人工智能用例。在这个领域中有许多问题利用了树和图数据结构，而对于这些数据结构最合适的算法通常是递归的。为了演示这些算法如何转化为Storm，我们使用了Minimax算法，并使用Storm的构造实现了它。
- en: Along the way, we noted a few constraints within Storm that make it more complicated
    than expected, and we saw patterns and approaches that work around those constraints
    to produce a working/scalable system.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程中，我们注意到了Storm中的一些约束条件，使得它比预期的更加复杂，我们也看到了能够绕过这些约束条件并产生可工作/可扩展系统的模式和方法。
- en: Additionally, we introduced DRPC. DRPC can be used to expose a synchronous interface
    to clients. DRPC also allows the design to reuse code and data flows between synchronous
    and asynchronous interfaces.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们介绍了DRPC。DRPC可以用于向客户端公开同步接口。DRPC还允许设计在同步和异步接口之间重用代码和数据流。
- en: Combining synchronous and asynchronous topologies, with shared state, is a powerful
    pattern not only for AI applications, but also for analytics. Often, new data
    arrives in the background continuously, but users interrogate that data through
    synchronous interfaces. When you combine DRPC with the Trident state capabilities
    covered in other chapters, you should be able to build a system that can accommodate
    the real-time analytics' use cases.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 将同步和异步拓扑与共享状态结合起来，不仅对于人工智能应用而言是一个强大的模式，对于分析也是如此。通常，新数据持续在后台到达，但用户通过同步接口查询这些数据。当你将DRPC与其他章节介绍的Trident状态能力结合起来时，你应该能够构建一个能够满足实时分析用例的系统。
- en: In the next chapter, we integrate Storm with a non-transactional real-time analytics
    system, Druid. We will also look deeper into distributed state management with
    Trident and ZooKeeper.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将Storm与非事务实时分析系统Druid集成。我们还将更深入地研究Trident和ZooKeeper的分布式状态管理。
