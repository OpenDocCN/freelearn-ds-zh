- en: Chapter 4. Working with PostGIS
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 4 章. 使用 PostGIS
- en: 'In this chapter we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Executing a PostGIS ST_Buffer analysis query and exporting it to GeoJSON
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行 PostGIS ST_Buffer 分析查询并将其导出为 GeoJSON
- en: Finding out whether a point is inside a polygon
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找点是否在多边形内部
- en: Splitting LineStrings at intersections using ST_Node
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 ST_Node 在交点处分割 LineStrings
- en: Checking the validity of LineStrings
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查 LineStrings 的有效性
- en: Executing a spatial join and assigning point attributes to a polygon
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行空间连接并将点属性分配给多边形
- en: Conducting a complex spatial analysis query using ST_Distance()
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 ST_Distance() 进行复杂的空间分析查询
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: A spatial database is nothing but a standard database that can store geometry
    and execute spatial queries in their simplest forms. We will explore how to run
    spatial analysis queries, handle connections, and more, all from our Python code.
    Your ability to answer spatial questions such as "I want to locate all the hotels
    that are within 2 km of a golf course and less than 5 km from a park" is where
    PostGIS comes into play. This chaining of requests into a model is where the powers
    of spatial analysis shine.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 空间数据库不过是一个可以存储几何数据并在其最简单形式下执行空间查询的标准数据库。我们将探讨如何从我们的 Python 代码中运行空间分析查询、处理连接等，以及更多内容。你回答诸如“我想定位所有距离高尔夫球场
    2 公里以内且距离公园不到 5 公里的酒店”这样的空间问题的能力，正是 PostGIS 发挥作用的地方。这种将请求链入模型的过程正是空间分析力量的体现。
- en: We will work with the most popular and powerful open source spatial database
    called **PostgreSQL**, along with the **PostGIS** extension, including over 150
    functions. Basically, we'll get a full-blown GIS with complex spatial analysis
    functions for both vectors and rasters, spatial data types, and diverse methods
    to move spatial data around.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用最受欢迎和功能强大的开源空间数据库 **PostgreSQL**，以及 **PostGIS** 扩展，包括超过 150 个函数。基本上，我们将获得一个功能齐全的
    GIS，具有复杂的空间分析功能，适用于矢量和栅格数据，以及多种移动空间数据的方法。
- en: If you are looking for more information on PostGIS and a good read, please check
    out *PostGIS Cookbook* by *Paolo Corti* (available at [https://www.packtpub.com/big-data-and-business-intelligence/postgis-cookbook](https://www.packtpub.com/big-data-and-business-intelligence/postgis-cookbook)).
    This book explores the wider use of PostGIS and includes a full chapter on PostGIS
    Programming using Python.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要更多关于 PostGIS 的信息以及一本好书，请查看由 *Paolo Corti* 编著的 *PostGIS Cookbook*（可在 [https://www.packtpub.com/big-data-and-business-intelligence/postgis-cookbook](https://www.packtpub.com/big-data-and-business-intelligence/postgis-cookbook)
    购买）。这本书探讨了 PostGIS 的更广泛用途，并包括一个关于使用 Python 进行 PostGIS 编程的完整章节。
- en: Executing a PostGIS ST_Buffer analysis query and exporting it to GeoJSON
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行 PostGIS ST_Buffer 分析查询并将其导出为 GeoJSON
- en: Let's start by executing our first spatial analysis query from Python against
    our already running PostgreSQL and PostGIS database. The goal is to generate a
    100 m buffer around all schools and export the new buffer polygon to GeoJSON,
    including the name of a school. The end result will be shown on this map, available
    ([https://github.com/mdiener21/python-geospatial-analysis-cookbook/blob/master/ch04/geodata/out_buff_100m.geojson](https://github.com/mdiener21/python-geospatial-analysis-cookbook/blob/master/ch04/geodata/out_buff_100m.geojson))
    on GitHub.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从执行我们的第一个空间分析查询开始，该查询针对我们已运行的 PostgreSQL 和 PostGIS 数据库。目标是生成所有学校的 100 米缓冲区，并将新的缓冲多边形导出为
    GeoJSON，包括学校的名称。最终结果将显示在这张地图上，可在 GitHub 上找到（[https://github.com/mdiener21/python-geospatial-analysis-cookbook/blob/master/ch04/geodata/out_buff_100m.geojson](https://github.com/mdiener21/python-geospatial-analysis-cookbook/blob/master/ch04/geodata/out_buff_100m.geojson)）。
- en: Tip
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Quick visualizations of GeoJSON data using GitHub is a fast and simple way to
    create a web map without coding a single line. Note that the data is then free
    for everyone else to download if you are using a public and free GitHub account.
    Private GitHub accounts mean the data, that is, GeoJSON, will also remain private
    if data privacy or sensitivity is an issue.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 GitHub 快速可视化 GeoJSON 数据是一种快速简单的方法，无需编写任何代码即可创建网络地图。请注意，如果你使用的是公共免费的 GitHub
    账户，那么数据将免费供其他人下载。私有 GitHub 账户意味着如果数据隐私或敏感性是一个问题，那么 GeoJSON 数据也将保持私有。
- en: '![Executing a PostGIS ST_Buffer analysis query and exporting it to GeoJSON](img/50790OS_04_01.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![执行 PostGIS ST_Buffer 分析查询并将其导出为 GeoJSON](img/50790OS_04_01.jpg)'
- en: Getting ready
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To get started, we'll use our data in the PostGIS database. We will begin by
    accessing our `schools` table that we uploaded to PostGIS in the Batch importing
    a folder of Shapefiles into PostGIS using ogr2ogr recipe of [Chapter 3](ch03.html
    "Chapter 3. Moving Spatial Data from One Format to Another"), *Moving Spatial
    Data from One Format to Another*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，我们将使用 PostGIS 数据库中的数据。我们将从访问我们上传到 PostGIS 的 `schools` 表开始，这是在 [第 3 章](ch03.html
    "第 3 章。将空间数据从一个格式转换为另一个格式")，*将空间数据从一个格式转换为另一个格式* 中的 ogr2ogr 脚本中完成的批量导入文件夹。
- en: Connecting to a PostgreSQL and PostGIS database is accomplished with **Psycopg**,
    which is a Python DB API ([http://initd.org/psycopg/](http://initd.org/psycopg/))
    implementation. We've already installed this in [Chapter 1](ch01.html "Chapter 1. Setting
    Up Your Geospatial Python Environment"), *Setting Up Your Geospatial Python Environment*
    along with PostgreSQL, Django, and PostGIS.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 连接到 PostgreSQL 和 PostGIS 数据库是通过 **Psycopg** 实现的，这是一个 Python DB API ([http://initd.org/psycopg/](http://initd.org/psycopg/))。我们已经在
    [第 1 章](ch01.html "第 1 章。设置你的地理空间 Python 环境")，*设置你的地理空间 Python 环境* 中安装了它，包括 PostgreSQL、Django
    和 PostGIS。
- en: 'For all the following recipes, enter your virtual environment, `pygeoan_cb`,
    so that you have access to your libraries using this command:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有后续的食谱，请进入你的虚拟环境 `pygeoan_cb`，这样你就可以使用此命令访问你的库：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How to do it...
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'The long road is not so long after all, so follow along:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 长路并不那么长，所以请跟随：
- en: '[PRE1]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How it works...
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The database connection is using the `pyscopg2` module, so we import the libraries
    at the start alongside `geojson` and the standard `json` modules to handle our
    GeoJSON export.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库连接正在使用 `pyscopg2` 模块，因此我们在开始时与 `geojson` 和标准的 `json` 模块一起导入库，以处理我们的 GeoJSON
    导出。
- en: 'Our connection is created and then followed immediately with our SQL Buffer
    query string. The query uses three PostGIS functions. Working your way from the
    inside out, you will see the `ST_Buffer` function taking in the geometry of the
    school points followed by the 100 m buffer distance and the number of circle segments
    that we would like to generate. `ST_Transform` then takes the newly created buffer
    geometry and transforms it into the WGS84 coordinate system (EPSG: 4326) so that
    we can display it on GitHub, which only displays WGS84 and the projected GeoJSON.
    Lastly, we''ll use the `ST_asGeoJSON` function to export our geometry as the GeoJSON
    geometry.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '我们创建连接后立即使用我们的 SQL 缓冲查询字符串。该查询使用了三个 PostGIS 函数。从内到外逐步工作，你会看到 `ST_Buffer` 函数接收学校点的几何形状，然后是
    100 米的缓冲距离以及我们想要生成的圆段数量。然后 `ST_Transform` 函数将新创建的缓冲几何形状转换成 WGS84 坐标系统（EPSG: 4326），这样我们就可以在
    GitHub 上显示它，GitHub 只显示 WGS84 和投影的 GeoJSON。最后，我们将使用 `ST_asGeoJSON` 函数将我们的几何形状导出为
    GeoJSON 几何形状。'
- en: Note
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: PostGIS does not export the complete GeoJSON syntax, only the geometry in the
    form of the GeoJSON geometry. This is the reason that we need to complete our
    GeoJSON using the Python `geojson` module.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: PostGIS 不导出完整的 GeoJSON 语法，只以 GeoJSON 几何形状的形式导出几何形状。这就是为什么我们需要使用 Python `geojson`
    模块来完成我们的 GeoJSON 的原因。
- en: All of this means that we not only perform analysis on the query, but we also
    specify the output format and coordinate system all in one go.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都意味着我们不仅对查询进行操作，而且我们还一次性指定了输出格式和坐标系。
- en: Next, we will execute the query and fetch all the returned objects using `cur.fetchall()`
    so that we can later loop through each returned buffer polygon. Our `new_geom_collection`
    list will store each of the new geometries and the feature names. Next, in the
    `for` loop function, we'll use the `geojson` module function, `loads(geom)`, to
    input our geometry into a GeoJSON geometry object. This is followed by the `Feature()`function
    that actually creates our GeoJSON feature. This is then used as the input for
    the `FeatureCollection` function where the final, completed GeoJSON is created.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将执行查询并使用 `cur.fetchall()` 获取所有返回的对象，这样我们就可以稍后遍历每个返回的缓冲多边形。我们的 `new_geom_collection`
    列表将存储每个新的几何形状和特征名称。接下来，在 `for` 循环函数中，我们将使用 `geojson` 模块函数 `loads(geom)` 将我们的几何形状输入到一个
    GeoJSON 几何对象中。这随后由 `Feature()` 函数创建我们的 GeoJSON 特征。然后它被用作 `FeatureCollection` 函数的输入，最终创建完成的
    GeoJSON。
- en: Lastly, we'll need to write this new GeoJSON file to disk and save it. Hence,
    we'll use the new file object where we use the standard Python `json.dumps` module
    to export our `FeatureCollection`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要将这个新的 GeoJSON 文件写入磁盘并保存。因此，我们将使用新的文件对象，在那里我们使用标准的 Python `json.dumps`
    模块导出我们的 `FeatureCollection`。
- en: We'll do a little clean up to close the cursor object and connection. Bingo!
    We are now done and can visualize our final results.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将进行一些清理工作，以关闭游标对象和连接。Bingo！我们现在完成了，可以可视化我们的最终结果。
- en: Finding out whether a point is inside a polygon
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找点是否在多边形内
- en: A point inside a polygon analysis query is a very common spatial operation.
    This query can identify objects located within an area such as a polygon. The
    area of interest in this example is a 100 m buffer polygon around bike paths and
    we would like to locate all schools that are inside this polygon.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 多边形内点分析查询是一个非常常见的空间操作。此查询可以识别位于区域内的对象，例如多边形。在这个例子中，感兴趣的区域是围绕自行车道的100米缓冲多边形，我们希望定位所有位于这个多边形内的学校。
- en: Getting ready
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In the previous section, we used the `schools` table to create a buffer. This
    time around, we will use this table as our input points table. The `bikeways`
    table that we imported in [Chapter 3](ch03.html "Chapter 3. Moving Spatial Data
    from One Format to Another"), *Moving Spatial Data from One Format to Another*,
    will be used as our input lines to generate a new 100 m buffer polygon. Be sure,
    however, that you have the two datasets in your local PostgreSQL database.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们使用了`schools`表来创建缓冲区。这次，我们将使用这个表作为我们的输入点表。我们在[第3章](ch03.html "第3章。将空间数据从一种格式转换为另一种格式")中导入的`bikeways`表，即*将空间数据从一种格式转换为另一种格式*，将用作我们的输入线以生成一个新的100米缓冲多边形。但是，请确保您在本地PostgreSQL数据库中有这两个数据集。
- en: How to do it...
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Now, let''s dive into some more code to find schools located within 100 m of
    the bikeways in order to find points inside a polygon:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们深入研究一些代码，以找到位于自行车道100米范围内的学校，以便找到多边形内的点：
- en: '[PRE2]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You can now view your newly created GeoJSON file on a great little site created
    by Mapbox at [http://www.geojson.io](http://www.geojson.io). Simply drag and drop
    your GeoJSON file from Windows Explorer in Windows or Nautilus in Ubuntu onto
    the [http://www.geojson.io](http://www.geojson.io) web page and, Bob's your uncle,
    you should see 50 or so schools that are located within 100 m of a bikeway in
    Vancouver.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以在Mapbox创建的一个很棒的网站上查看您新创建的GeoJSON文件，网址是[http://www.geojson.io](http://www.geojson.io)。只需将您的GeoJSON文件从Windows的Windows
    Explorer或Ubuntu的Nautilus拖放到[http://www.geojson.io](http://www.geojson.io)网页上，Bob's
    your uncle，您应该能看到大约50所学校，这些学校位于温哥华的自行车道100米范围内。
- en: '![How to do it...](img/50790OS_04_02.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/50790OS_04_02.jpg)'
- en: How it works...
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We will reuse code to make our database connection, so this should be familiar
    to you at this point. The `new_bike_buff_100m` query string contains our query
    to generate a new 100 m buffer polygon around all the bikeways. We need to execute
    this query and commit it to the database so that we can access this new set of
    polygons as input to our actual query that will find schools (points) located
    inside this new buffer polygon.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重用代码来建立数据库连接，所以这一点现在应该对您来说很熟悉。`new_bike_buff_100m`查询字符串包含我们生成围绕所有自行车道的100米缓冲多边形的查询。我们需要执行此查询并将其提交到数据库，以便我们可以访问这个新的多边形集作为我们实际查询的输入，该查询将找到位于这个新缓冲多边形内的学校（点）。
- en: The `is_inside_query` string actually does the hard work for us by selecting
    selecting the values from the field `name` and the geometry from the `geom` field.
    The geometry is wrapped up in two other PostGIS functions to allow us to export
    our data as GeoJSON in the WGS 84 coordinate system. This will be the input geometry
    needed to generate our final new GeoJSON file.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`is_inside_query`字符串实际上为我们做了艰苦的工作，通过从`name`字段选择值和从`geom`字段选择几何形状。几何形状被封装在另外两个PostGIS函数中，以便我们可以将数据作为GeoJSON在WGS
    84坐标系中导出。这将是我们生成最终新的GeoJSON文件所需的输入几何形状。'
- en: The `WHERE` clause uses the `ST_Within` function to see whether a point is inside
    the polygon and returns `True` if the point is within the buffer polygon.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`WHERE`子句使用`ST_Within`函数来查看一个点是否在多边形内，如果点在缓冲多边形内，则返回`True`。'
- en: Now, we've created a new function that simply wraps up our export to the GeoJSON
    code that was used in the previous, *Executing a PostGIS ST_Buffer analysis query
    and exporting it to GeoJSON*, recipe. This new `export2geojson` function simply
    takes one input of our PostGIS query and outputs a GeoJSON file. To set the name
    and location of the new output file, simply replace the path and name within the
    function.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经创建了一个新的函数，它只是封装了之前在*执行PostGIS ST_Buffer分析查询并将其导出为GeoJSON*的配方中使用的导出GeoJSON代码。这个新的`export2geojson`函数只需一个PostGIS查询的输入，并输出一个GeoJSON文件。要设置新输出文件的名字和位置，只需在函数内替换路径和名称。
- en: Finally, all we need to do is call the new function to export the GeoJSON file
    using the `db_rows` variable that contains our list of schools as points located
    within the 100 m buffer polygon.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们只需要调用新的函数，使用包含我们学校列表的`db_rows`变量来导出GeoJSON文件，这些学校位于100米缓冲多边形内。
- en: There's more...
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: This example to find all schools located within 100 m of the bike paths could
    be completed using another PostGIS function called `ST_Dwithin`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例，找到所有位于自行车道100米范围内的学校，可以使用另一个名为`ST_Dwithin`的PostGIS函数来完成。
- en: 'The SQL to select all the schools located within 100 m of the bikepaths would
    look like this:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 选择所有位于自行车道100米范围内的学校的SQL语句看起来像这样：
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Splitting LineStrings at intersections using ST_Node
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ST_Node在交叉口分割LineStrings
- en: Working with road data is usually a tricky business because the validity of
    the data and data structure plays a very important role. If you want to do anything
    useful with your road data, such as building a routing network, you will need
    to prepare the data first. The first task is usually to segmentize your lines,
    which means splitting all lines at intersections where LineStrings cross each
    other, creating a base network road dataset.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 处理道路数据通常是一件棘手的事情，因为数据的有效性和数据结构起着非常重要的作用。如果你想对你的道路数据做些有用的事情，比如构建一个路由网络，你首先需要准备数据。第一个任务通常是分割你的线条，这意味着在线条交叉的交叉口处分割所有线条，创建一个基础网络道路数据集。
- en: Note
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Be aware that this recipe will split all lines on all intersections regardless
    of whether, for example, there is a road-bridge overpass where no intersection
    should be created.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个菜谱将分割所有交叉口上的所有线条，无论是否例如，有一个道路-桥梁立交桥，不应该创建交叉口。
- en: Getting ready
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before we get into the details of how to do this, we will use a small section
    of the **OpenStreetMap** (**OSM**) road data for our example. The OSM data is
    available in your `/ch04/geodata/`folder called `vancouver-osm-data.osm`. This
    data was simply downloaded from the [www.openstreetmap.org](http://www.openstreetmap.org)
    home page using the **Export** button located at the top of the page:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们详细介绍如何做之前，我们将使用OpenStreetMap（**OSM**）道路数据的一个小部分作为我们的示例。OSM数据位于你的`/ch04/geodata/`文件夹中，名为`vancouver-osm-data.osm`。这些数据是从[www.openstreetmap.org](http://www.openstreetmap.org)主页上使用位于页面顶部的**导出**按钮简单下载的：
- en: '![Getting ready](img/50790OS_04_03.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作](img/50790OS_04_03.jpg)'
- en: The OSM data contains not only roads but all the other points and polygons located
    within the extent that I have chosen. The region of interest is again the Burrard
    Street bridge in Vancouver.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: OSM数据不仅包含道路，还包含我选择的范围内所有其他点和多边形。感兴趣的区域再次是温哥华的Burrard Street桥。
- en: 'We are going to need to extract all the roads and import them into our PostGIS
    table. This time, let''s try using the `ogr2ogr` command line directly from the
    console to upload the OSM streets to our PostGIS database:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要提取所有道路并将它们导入我们的PostGIS表中。这次，让我们尝试直接从控制台使用`ogr2ogr`命令行上传OSM街道到我们的PostGIS数据库：
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This assumes that your OSM data is in the `/ch04/geodata` folder and the command
    is run while you are located in the `/ch04/code` folder.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这假设你的OSM数据位于`/ch04/geodata`文件夹中，并且命令是在你位于`/ch04/code`文件夹时运行的。
- en: Now this really long thing means that we connect to our PostGIS database as
    our output and input the `vancouver-osm-data.osm` file. Create a new table called
    `lines` and transform the input OSM projection to EPSG:3857\. All data exported
    from OSM is in EPSG:4326\. You can, of course, leave it in this system and simply
    remove the `-t_srs EPSG:3857` part of the command line option.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这个非常长的东西意味着我们将连接到我们的PostGIS数据库作为输出，并将`vancouver-osm-data.osm`文件作为输入。创建一个名为`lines`的新表，并将输入的OSM投影转换为EPSG:3857。所有从OSM导出的数据都在EPSG:4326中。当然，你可以保持在这个系统中，只需简单地删除命令行选项中的`-t_srs
    EPSG:3857`部分。
- en: 'We are now ready to rock and roll with the splitting at intersections. If you
    like, go ahead and open the data in **QGIS** (**Quantum GIS**). In QGIS, you will
    see that the road data is not split at all road intersections as shown in this
    screenshot:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好在交叉口进行分割操作了。如果你愿意，可以打开数据在**QGIS**（**量子GIS**）中。在QGIS中，你会看到道路数据并没有在所有交叉口处分割，就像这个截图所示：
- en: '![Getting ready](img/50790OS_04_04.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作](img/50790OS_04_04.jpg)'
- en: Here, you can see that **McNicoll Avenue** is a single LineString crossing over
    **Cypress Street**. After we've completed the recipe, we will see that **McNicoll
    Avenue** will be split at this intersection.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，你可以看到**McNicoll Avenue**是一条单独的LineString，横跨**Cypress Street**。完成我们的操作后，我们会看到**McNicoll
    Avenue**将在这个交叉口处被分割。
- en: How to do it...
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Running through the Python code is quite straightforward since the hard work
    is done in one SQL query. So follow along:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于所有的工作都在一个 SQL 查询中完成，运行 Python 代码相当直接。所以请继续：
- en: '[PRE5]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '![How to do it...](img/50790OS_04_05.jpg)'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/50790OS_04_05.jpg)'
- en: Well, this was quite simple and we can now see that **McNicoll Avenue** is split
    at the intersection with **Cypress Street**.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这相当简单，我们现在可以看到 **McNicoll Avenue** 在与 **Cypress Street** 的交点处被分割。
- en: How it works...
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Looking at the code, we can see that the database connection remains the same
    and the only new thing is the query itself that creates the intersection. Here
    three separate PostGIS functions are used to obtain our results:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 从代码中我们可以看到，数据库连接保持不变，唯一的新事物就是创建交点的查询本身。在这里，使用了三个独立的 PostGIS 函数来获取我们的结果：
- en: The first function, when working our way inside-out in the query, starts with
    `ST_Collect(wkb_geometry)`. This simply takes our original geometry column as
    input. The simple combining of the geometries is all that is going on here.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个函数，在查询中从内到外工作时，从 `ST_Collect(wkb_geometry)` 开始。这仅仅是将我们的原始几何形状列作为输入。这里只是简单地将几何形状组合在一起。
- en: Next up is the actual splitting of the lines using the `ST_Node(geometry)`,
    inputting the new geometry collection and nodding, which splits our LineStrings
    at intersections.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来是使用 `ST_Node(geometry)` 实际分割线段，输入新的几何形状集合并进行节点操作，这将在交点处分割我们的 LineStrings。
- en: Finally, we'll use `ST_Dump()` as a set returning function. This means that
    it basically explodes all the LineString geometry collections into individual
    LineStrings. The end of the query with `.geom` specifies that we only want to
    export the geometry and not the returned array numbers of the split geometry.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们将使用 `ST_Dump()` 作为返回集合的函数。这意味着它基本上将所有的 LineString 几何形状集合爆炸成单个 LineStrings。查询末尾的
    `.geom` 指定我们只想导出几何形状，而不是分割几何形状返回的数组数字。
- en: Now, we'll execute and commit the query to the database. The commit is an important
    part because, otherwise, the query will be run but it will not actually create
    the new table that we are looking to generate. Last but not least, we can close
    down our cursor and connection. That is that; we now have split LineStrings.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将执行并提交查询到数据库。提交是一个重要的部分，因为否则查询将会运行，但它实际上不会创建我们想要生成的新的表。最后但同样重要的是，我们可以关闭游标和连接。就是这样；我们现在有了分割的
    LineStrings。
- en: Note
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Be aware that the new split LineStrings do NOT contain the street names and
    other attributes. To export the names, we would need to do a join on our data.
    Such a query to include the attributes on the newly created LineStrings could
    look like this:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，新的分割 LineStrings 不包含街道名称和其他属性。要导出名称，我们需要在数据上执行连接操作。这样的查询，包括在新建的 LineStrings
    上的属性，可能看起来像这样：
- en: '[PRE6]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Checking the validity of LineStrings
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查 LineStrings 的有效性
- en: Working with road data has many areas to watch out for and one of these is invalid
    geometry. Our source data is OSM and is, therefore, collected by a community of
    users that are not trained by GIS professionals, resulting in errors. To execute
    spatial queries, the data must be valid or we will have results with errors or
    no results at all.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 处理道路数据有许多需要注意的区域，其中之一就是无效的几何形状。我们的源数据是 OSM，因此是由一群未经 GIS 专业人员培训的用户收集的，这导致了错误。为了执行空间查询，数据必须是有效的，否则我们将得到有错误或根本没有结果的结果。
- en: PostGIS includes the `ST_isValid()` function that returns True/False on the
    basis of whether a geometry is valid or not. There is also the `ST_isValidReason()`
    function that will output a text description of the geometry error. Finally, the
    `ST_isValidDetail()` function will return if the geometry is valid along with
    the reason and location of the geometry error. These three functions all accomplish
    similar tasks and selecting one depends on what you want to accomplish.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: PostGIS 包含了 `ST_isValid()` 函数，该函数根据几何形状是否有效返回 True/False。还有一个 `ST_isValidReason()`
    函数，它会输出几何形状错误的文本描述。最后，`ST_isValidDetail()` 函数将返回几何形状是否有效，以及几何形状错误的理由和位置。这三个函数都完成类似的任务，选择哪一个取决于你想要完成什么。
- en: How to do it...
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Now, to determine if `geodata.lines` are valid, we will run another query that
    will list all invalid geometries if there are any:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，为了确定 `geodata.lines` 是否有效，我们将运行另一个查询，如果存在无效的几何形状，它将列出所有这些几何形状：
- en: '[PRE7]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This query should return an empty Python list, which means that we have no invalid
    geometries. If there are objects in your list, then you'll know that you have
    some manual work to do to correct those geometries. Your best bet is to fire up
    QGIS and get started with digitizing tools to clean things up.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 此查询应返回一个空Python列表，这意味着我们没有无效的几何形状。如果您的列表中有对象，那么您就会知道您需要做一些手动工作来纠正这些几何形状。您最好的选择是启动QGIS并使用数字化工具开始清理。
- en: Executing a spatial join and assigning point attributes to a polygon
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行空间连接并将点属性分配给多边形
- en: We'll now get back to some more golf action where we would like to execute a
    spatial attribute join. We're given a situation where we have a set of polygons,
    in this case, these are in the form of golf greens without any hole number. Our
    hole number is stored in a point dataset that is located spatially within the
    green of each hole. We would like to assign each green its appropriate hole number
    based on its location within the polygon.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将回到一些更多的高尔夫动作，我们想要执行一个空间属性连接。我们面临的情况是有一些多边形，在这种情况下，这些是以高尔夫球道的形式出现的，没有任何洞号。我们的洞号存储在一个点数据集中，该数据集位于每个洞的球道内。我们希望根据多边形内的位置为每个球道分配适当的洞号。
- en: The OSM data from the Pebble Beach Golf Course located in Monterey California
    is our source data. This golf course is one the great golf courses on the PGA
    tour and is well mapped in OSM.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 位于加利福尼亚州莫尼卡市的佩布尔海滩高尔夫球场的OSM数据是我们的源数据。这个高尔夫球场是PGA巡回赛上的顶级高尔夫球场之一，在OSM中得到了很好的映射。
- en: Tip
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you are interested in getting golf course data yourself from OSM, it is recommended
    that you use the great Overpass API at [http://overpass-turbo.eu/](http://overpass-turbo.eu/).
    This site enables you to export the OSM data as GeoJSON or KML, for example.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对从OSM获取高尔夫球场数据感兴趣，建议您使用优秀的Overpass API，网址为[http://overpass-turbo.eu/](http://overpass-turbo.eu/)。此网站允许您将OSM数据导出为GeoJSON或KML等格式。
- en: 'To download all the golf-specific OSM data, you will need to correct tags.
    To do this, simply copy and paste the following Overpass API query into the query
    window located on the left hand side, then click on `Download`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 要下载所有特定于高尔夫的OSM数据，您需要纠正标签。为此，只需将以下Overpass API查询复制并粘贴到左侧的查询窗口中，然后点击`下载`：
- en: '[PRE8]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Getting ready
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Importing our data into PostGIS will be the first step to execute our spatial
    query. This time around, we will use the `shp2pgsql` tool to import our data to
    change things a little since there are so many ways to get data into PostGIS.
    The `shp2pgsql` tool is definitely the most well-tested and common way to import
    Shapefiles into PostGIS. Let's get going and perform this import once again, executing
    this tool directly from the command line.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们的数据导入PostGIS将是执行空间查询的第一步。这次，我们将使用`shp2pgsql`工具将我们的数据导入，以改变一下方式，因为将数据导入PostGIS的方法有很多。`shp2pgsql`工具无疑是导入Shapefiles到PostGIS最经过测试和最常用的方法。让我们开始，再次执行此导入操作，直接从命令行运行此工具。
- en: For Windows users, this should work, but check that the paths are correct or
    that `shp2pgsql.exe` is in your system path variable. By doing this, you save
    having to type the full path to execute.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Windows用户，这应该可以工作，但请检查路径是否正确，或者`shp2pgsql.exe`是否已添加到您的系统路径变量中。这样做可以节省输入完整路径来执行操作。
- en: Note
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'I assume that you are running the following command when you are in the `/ch04/code`
    folder:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我假设您在`/ch04/code`文件夹中运行以下命令：
- en: '[PRE9]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: On a Linux machine your command is basically the same without the long path,
    assuming that your system links were all set up when you installed PostGIS in
    [Chapter 1](ch01.html "Chapter 1. Setting Up Your Geospatial Python Environment"),
    *Setting Up Your Geospatial Python Environment*.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux机器上，您的命令基本上与Windows相同，没有长路径，前提是您在[第1章](ch01.html "第1章。设置您的地理空间Python环境")
    *设置您的地理空间Python环境* 中安装PostGIS时已设置好系统链接。
- en: 'Next up, we need to import our points with the attributes, so let''s get to
    it as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要导入带有属性的点，让我们按照以下步骤进行：
- en: '[PRE10]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: That's that! We now have our points and polygons available in the PostGIS Schema
    `geodata` setting, which sets the stage for our spatial join.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是了！我们现在在我们的PostGIS模式`geodata`设置中有了点和多边形，这为我们的空间连接做好了准备。
- en: How to do it...
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The core work is done once again inside our PostGIS query string, assigning
    the attributes to the polygons, so follow along:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 核心工作再次在我们的PostGIS查询字符串内部完成，将属性分配给多边形，所以请跟随：
- en: '[PRE11]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: How it works...
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The query is straightforward enough; we'll use the `UPDATE` standard SQL command
    to update the values in the name field of our table, `geodata.pebble_beach_greens`,
    with the hole numbers located in the `pebble_beach_hole_num` table.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 查询非常直接；我们将使用`UPDATE`标准SQL命令来更新我们表`geodata.pebble_beach_greens`中名称字段中的值，这些值位于`pebble_beach_hole_num`表中。
- en: We follow up by setting the name value from our `geodata.pebble_beach_hole_num`
    table, where the field name also exists and holds our needed attribute values.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接着设置`geodata.pebble_beach_hole_num`表中的名称值，其中字段名称也存在并包含我们需要的属性值。
- en: Our `WHERE` clause uses the PostGIS query, `ST_Contains`, to return `True` if
    the point lies inside our greens, and if so, it will update our values.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`WHERE`子句使用PostGIS查询`ST_Contains`，如果点位于我们的绿色区域内部，则返回`True`，如果是这样，它将更新我们的值。
- en: This was easy and demonstrates the great power of spatial relationships.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单，展示了空间关系强大的功能。
- en: Conducting a complex spatial analysis query using ST_Distance()
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ST_Distance()执行复杂的空间分析查询
- en: Now let's check for a more complex query in PostGIS to get our spatial juices
    flowing. We want to locate all the golf courses that are either inside or within
    5 km of a national park or protected area. Plus, the golf course must be within
    2 km of a city. The city data is derived from the tags in OSM where the *tag place
    = city*.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们检查一个更复杂的PostGIS查询，以激发我们的空间分析热情。我们想要定位所有位于国家公园或保护区内部或5公里范围内的高尔夫球场。此外，高尔夫球场必须在2公里范围内有城市。城市数据来自OSM中的标签，其中*标签place
    = city*。
- en: The national parks and protected areas for this query belong to the Government
    of Canada. Our golf courses and datasets of cities are derived from an OSM located
    in British Columbia and Alberta.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 此查询的国家公园和保护区属于加拿大政府。我们的高尔夫球场和城市数据集来源于位于不列颠哥伦比亚省和艾伯塔省的OSM。
- en: Getting ready
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We need the data of all the national parks and protected areas in Canada, so
    go and make sure they're located in the `/ch04/geodata/` folder.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要加拿大所有国家公园和保护区的数据，所以请确保它们位于`/ch04/geodata/`文件夹中。
- en: The original data is located at [http://ftp2.cits.rncan.gc.ca/pub/geott/frameworkdata/protected_areas/1M_PROTECTED_AREAS.shp.zip](http://ftp2.cits.rncan.gc.ca/pub/geott/frameworkdata/protected_areas/1M_PROTECTED_AREAS.shp.zip)
    for download if you do not already have the `/geodata` folder downloaded from
    GitHub.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 原始数据位于[http://ftp2.cits.rncan.gc.ca/pub/geott/frameworkdata/protected_areas/1M_PROTECTED_AREAS.shp.zip](http://ftp2.cits.rncan.gc.ca/pub/geott/frameworkdata/protected_areas/1M_PROTECTED_AREAS.shp.zip)，如果您还没有从GitHub下载`/geodata`文件夹。
- en: The other datasets needed are the cities and golf courses that can be obtained
    from OSM. These two files are the GeoJSON files located in the /ch04/geodata/
    folder and are called `osm-golf-courses-bc-alberta.geojson` and `osm-place-city-bc-alberta.geojson`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 需要的其他数据集包括可以从OSM获取的城市和高尔夫球场。这两个文件是位于/ch04/geodata/文件夹中的GeoJSON文件，分别命名为`osm-golf-courses-bc-alberta.geojson`和`osm-place-city-bc-alberta.geojson`。
- en: 'We will now import the downloaded data into our database:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将导入下载的数据到我们的数据库中：
- en: Note
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Ensure that you are currently in the `/ch04/code` folder when you run the following
    commands; otherwise, adjust the paths as necessary.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你在运行以下命令时当前位于`/ch04/code`文件夹中；否则，根据需要调整路径。
- en: 'Starting with the OSM golf courses from British Columbia and Alberta, run this
    command-line call to ogr2ogr. Windows users need to note that they can either
    switch the slashes to backslashes or include the full path to GeoJSON:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从不列颠哥伦比亚省和艾伯塔省的OSM高尔夫球场开始，运行这个命令行调用ogr2ogr。Windows用户需要注意，他们可以将反斜杠切换为正斜杠，或者包含完整的路径到GeoJSON：
- en: '[PRE12]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, we''ll run the same command again to import the cities:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将再次运行相同的命令来导入城市：
- en: '[PRE13]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Last but not least, we''ll need to import the protected areas and national
    parks of Canada using the `shp2pgsql` command line. Here, note that we need to
    use the `-W latin1` option to specify the required encoding. The data you acquire
    is for all of Canada and not just BC and Alberta:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，我们需要使用`shp2pgsql`命令行导入加拿大的保护区和国家公园。在此，请注意，我们需要使用`-W latin1`选项来指定所需的编码。您获得的数据是整个加拿大，而不仅仅是BC和艾伯塔省：
- en: '[PRE14]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now we have all three tables in our database and we can execute our analysis
    script.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们数据库中有所有三个表，我们可以执行我们的分析脚本。
- en: How to do it...
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s see what the code looks like:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看代码的样子：
- en: '[PRE15]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: How it works...
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Let''s go step by step through the SQL query:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步一步地通过SQL查询：
- en: We'll start with defining what columns we want our query to return and from
    which tables. Here, we'll define that we want the golf club geometry as a point,
    city name, golf club name, park name, distance between a city and golf club, and
    finally, distance between a park and golf club. The geometry that we return is
    of the golf course as a point, hence `ST_Centroid`, which returns the middle point
    of the golf course and then outputs this as the GeoJSON geometry.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将从定义查询需要返回的列以及从哪些表中获取开始。在这里，我们将定义我们想要高尔夫球场的几何形状作为一个点、城市名称、高尔夫球场名称、公园名称、城市与高尔夫球场之间的距离，以及最终，公园与高尔夫球场之间的距离。我们返回的几何形状是高尔夫球场作为一个点，因此使用`ST_Centroid`，它返回高尔夫球场的中心点，然后将其作为GeoJSON几何形状输出。
- en: The `FROM` clause sets our parks and tables of cities and assigns them an alias
    name with `SQL AS`. We then `JOIN` the golf courses based on the distance using
    `ST_DWithin()` so that we can locate distances that are less than 4 km between
    a city and golf course.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FROM`子句设置了我们的公园和城市表，并使用`SQL AS`为它们分配一个别名。然后我们根据距离使用`ST_DWithin()`来`JOIN`高尔夫球场，以便我们可以定位城市与高尔夫球场之间小于4公里的距离。'
- en: The `WHERE` clause, `ST_DWithin()`, enforces the last requirement that the distance
    between a park and golf course cannot be more than 5 km.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WHERE`子句中的`ST_DWithin()`强制执行最后一个要求，即公园与高尔夫球场之间的距离不能超过5公里。'
- en: The SQL does all of our heavy lifting to return the correct spatial analysis
    results. The next step is to use Python to output our results as valid GeoJSON
    in order to view our newly found golf courses. Each attribute property is then
    identified by its array location in the query and assigned a name for the GeoJSON
    output. In the end, we'll output a .geojson file that you can visualize directly
    in GitHub at [https://github.com/mdiener21/python-geospatial-analysis-cookbook/blob/master/ch04/geodata/golfcourses_analysis.geojson](https://github.com/mdiener21/python-geospatial-analysis-cookbook/blob/master/ch04/geodata/golfcourses_analysis.geojson).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: SQL完成了所有繁重的工作，以返回正确的空间分析结果。下一步是使用Python将我们的结果输出为有效的GeoJSON，以便我们可以查看我们新发现的高尔夫球场。每个属性属性随后通过其在查询中的数组位置被识别，并为GeoJSON输出分配一个名称。最后，我们将输出一个`.geojson`文件，您可以直接在GitHub上可视化它，链接为[https://github.com/mdiener21/python-geospatial-analysis-cookbook/blob/master/ch04/geodata/golfcourses_analysis.geojson](https://github.com/mdiener21/python-geospatial-analysis-cookbook/blob/master/ch04/geodata/golfcourses_analysis.geojson)。
- en: '![How it works...](img/50790OS_04_06.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/50790OS_04_06.jpg)'
