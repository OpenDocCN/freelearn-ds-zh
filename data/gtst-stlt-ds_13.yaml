- en: '*Chapter 10*: The Data Project – Prototyping Projects in Streamlit'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第10章*：数据项目——在 Streamlit 中进行项目原型设计'
- en: In the previous chapter, we discussed how to create Streamlit applications that
    are specific to job applications. Another fun application of Streamlit is to try
    out new and interesting data science ideas and create interactive apps for others.
    Some examples of this include applying a new machine learning model to an existing
    dataset, carrying out an analysis on some data uploaded by users, or creating
    an interactive analysis on a private dataset. There are numerous reasons for making
    a project like this, such as personal education or community contribution.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了如何创建针对职位申请的 Streamlit 应用。Streamlit 的另一个有趣应用是尝试新的、令人兴奋的数据科学创意，并为他人创建互动式应用。例如，将一个新的机器学习模型应用于现有数据集，进行用户上传的数据分析，或创建基于私人数据集的互动分析。做这个项目的理由有很多，比如个人教育或社区贡献。
- en: In terms of personal education, often, the best way to learn a new topic is
    to observe how it actually works by applying it to the world around you or a dataset
    that you know closely. For instance, if you are trying to learn how *Principal
    Component Analysis* works, you can always learn about it in a textbook or watch
    someone else apply it to a dataset. However, I have found that my comprehension
    of a topic goes through the roof when I actually apply it myself in practice.
    Streamlit is perfect for this. It allows you to give new ideas a shot in a responsive,
    fun environment that can be easily shared with others. Learning data science can
    be collaborative, which leads me to the next reason for creating data projects
    in Streamlit.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在个人教育方面，通常，学习一个新主题的最佳方式是通过将其应用到你周围的世界或你熟悉的数据集中，观察它如何真正运作。例如，如果你想了解 *主成分分析* 是如何工作的，你可以在教科书中学习它，或看别人将它应用到数据集中。然而，我发现，当我自己亲自实践时，对一个主题的理解会飞跃性提高。Streamlit
    正是为了这种情况而设计的。它让你可以在一个互动、轻松的环境中尝试新创意，而且这些创意可以轻松与他人共享。学习数据科学可以是一个合作的过程，这也是我选择在 Streamlit
    中创建数据项目的另一个原因。
- en: In terms of community contribution, one of the best parts of Streamlit – and,
    frankly, data science – is the growing community around the tools and toys we
    routinely play with. By learning with others and sharing Streamlit apps on Twitter
    ([https://twitter.com/tylerjrichards](https://twitter.com/tylerjrichards)), LinkedIn,
    and the Streamlit forums ([https://discuss.streamlit.io/](https://discuss.streamlit.io/)),
    we can turn away from the zero-sum experience that is taught in most schools and
    universities (where if your classmate gets a good grade, that usually comparatively
    hurts you) and toward a positive-sum experience, where you directly benefit from
    the lessons learned by others. To use the previous example, if you create an app
    that helped you understand the statistics behind principal component analysis,
    sharing that with others will probably teach them something, too.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 就社区贡献而言，Streamlit 的一个亮点——老实说，数据科学的亮点——就是围绕我们日常使用的工具和玩具所形成的日益壮大的社区。通过与他人一起学习，并在
    Twitter 上分享 Streamlit 应用（[https://twitter.com/tylerjrichards](https://twitter.com/tylerjrichards)）、LinkedIn
    和 Streamlit 论坛（[https://discuss.streamlit.io/](https://discuss.streamlit.io/)）上分享应用，我们可以摆脱大多数学校和大学中所教的零和博弈经验（即如果你的同学得了高分，通常会相对地影响你），转而朝向一个正和博弈的体验，在这种体验中，你能直接从他人学到的经验中受益。举个例子，如果你创建了一个帮助你理解主成分分析背后统计学的应用，分享给他人也许会让他们学到一些东西。
- en: 'In this chapter, we will run through one thorough data project from end to
    end, starting with an idea and ending with the final product. Specifically, we
    will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将从头到尾完整地进行一个数据项目，从一个创意开始，到最终产品结束。具体来说，我们将涵盖以下主题：
- en: Data science ideation
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据科学创意
- en: Collecting and cleaning data
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据收集与清洗
- en: Making a **Minimum Viable Product** (**MVP**)
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 制作 **最小可行产品**（**MVP**）
- en: Iterative improvement
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代改进
- en: Hosting and promotion
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 托管与推广
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In this section, we will utilize the website *Goodreads.com*, which is a popular
    website owned by Amazon, that is used to track everything about a user's reading
    habits, from when they started and finished books to what they would like to read
    next. It is recommended that you first head over to [https://www.goodreads.com/](https://www.goodreads.com/),
    sign up for an account, and explore around a little (perhaps you can even add
    your own book lists!).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用网站*Goodreads.com*，这是一个由亚马逊拥有的流行网站，用于跟踪用户的阅读习惯，从开始和完成书籍的时间到他们想要阅读的下一本书。建议你首先访问[https://www.goodreads.com/](https://www.goodreads.com/)，注册一个账户，并稍微浏览一下（也许你还可以添加自己的书单！）。
- en: Data science ideation
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据科学创意
- en: Often, coming up with a new idea for a data science project is the most daunting
    part. You might have numerous doubts. What if I start a project that no one likes?
    What if my data actually doesn't work out well? What if I can't think of anything?
    The good news is that if you are creating projects that you actually do care about
    and would use, then the worst-case scenario is that you have an audience of one!
    And if you send me (*tylerjrichards@gmail.com*)your project, I promise to read
    it. So that makes it an audience of two at the very least.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，构思一个新的数据科学项目是最具挑战性的部分。你可能会有许多疑虑。如果我开始一个没人喜欢的项目怎么办？如果我的数据实际效果不好怎么办？如果我想不出任何点子怎么办？好消息是，如果你创建的是你真正关心并且会使用的项目，那么最坏的情况就是你只有一个观众！如果你把项目发给我（*tylerjrichards@gmail.com*），我保证会读的。至少那样的话，你的观众就有两个了。
- en: 'Some examples I have either created or observed in the wild include the following:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我自己创造或观察到的一些例子包括以下内容：
- en: Recording ping-pong games for a semester to determine the best player with an
    Elo model ([http://www.tylerjrichards.com/Ping_pong.html](http://www.tylerjrichards.com/Ping_pong.html))
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 录制一个学期的乒乓球比赛以使用 Elo 模型确定最佳玩家（[http://www.tylerjrichards.com/Ping_pong.html](http://www.tylerjrichards.com/Ping_pong.html)）
- en: Using natural language processing to determine the quality of Wi-Fi in hostels
    ([https://www.racketracer.com/2015/11/18/practical-natural-language-processing-for-determing-wifi-quality-in-hostels/](https://www.racketracer.com/2015/11/18/practical-natural-language-processing-for-determing-wifi-quality-in-hostels/))
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用自然语言处理来判断旅馆中 Wi-Fi 的质量（[https://www.racketracer.com/2015/11/18/practical-natural-language-processing-for-determing-wifi-quality-in-hostels/](https://www.racketracer.com/2015/11/18/practical-natural-language-processing-for-determing-wifi-quality-in-hostels/)）
- en: Analyzing thousands of pizza reviews to find the best NYC pizza near you ([https://towardsdatascience.com/adventures-in-barstools-pizza-data-9b8ae6bb6cd1](https://towardsdatascience.com/adventures-in-barstools-pizza-data-9b8ae6bb6cd1))
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析成千上万条披萨评论，找出你附近的最佳纽约披萨（[https://towardsdatascience.com/adventures-in-barstools-pizza-data-9b8ae6bb6cd1](https://towardsdatascience.com/adventures-in-barstools-pizza-data-9b8ae6bb6cd1)）
- en: Analyzing your reading habits with Goodreads data ([http://www.tylerjrichards.com/books_reco.html](http://www.tylerjrichards.com/books_reco.html))
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Goodreads 数据分析你的阅读习惯（[http://www.tylerjrichards.com/books_reco.html](http://www.tylerjrichards.com/books_reco.html)）
- en: 'Only one of these data projects uses Streamlit, as the rest came out before
    the library was released. However, all of these could have been improved by deploying
    them on Streamlit rather than just uploading them to a Jupyter Notebook (*project
    #1*) or a Word document/HTML file (*projects #2 and #3*).'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '这些数据项目中只有一个使用了 Streamlit，其余的在库发布之前就已经完成。然而，如果将这些项目部署到 Streamlit 上，而不是仅仅上传到
    Jupyter Notebook（*项目 #1*）或 Word 文档/HTML 文件（*项目 #2 和 #3*），它们都可以得到改进。'
- en: 'There are many different methods that you can use to come up with your own
    idea for a data project, but the most popular methods generally fall into three
    categories:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用多种不同的方法来构思自己的数据项目创意，但最常见的方法通常分为三类：
- en: Finding data that only you could gather (for example, your friend's ping-pong
    games)
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找只有你能收集到的数据（例如，你朋友的乒乓球比赛）
- en: Finding data that you care about (for example, Goodreads' reading data)
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找你关心的数据（例如，Goodreads 的阅读数据）
- en: Thinking of an analysis/app you wish existed to solve a problem you have and
    executing it (for example, hostel Wi-Fi analysis or finding the best pizza near
    you in NYC).
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 想出一个你希望存在的分析/应用程序来解决你的问题并实施它（例如，旅馆 Wi-Fi 分析或找到你附近的最佳披萨店）。
- en: You can try one of these or start with another idea that you have already. The
    best method is the one that works best for you! For this chapter, we will walk
    through and recreate the Goodreads Streamlit app, in depth, as an example of a
    data project. You can access it again at [http://www.tylerjrichards.com/books_reco.html](http://www.tylerjrichards.com/books_reco.html).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以尝试其中之一，或者从你已有的其他想法开始。最好的方法是最适合你的方法！在本章中，我们将深入走一遍并重建Goodreads的Streamlit应用，作为数据项目的示例。你可以通过以下链接再次访问：[http://www.tylerjrichards.com/books_reco.html](http://www.tylerjrichards.com/books_reco.html)。
- en: 'This app is designed to scrape a user''s Goodreads history and create a set
    of graphs to inform them about their reading habits since they started using Goodreads.
    The sets of graphs should be similar to the following screenshot:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应用旨在抓取用户的Goodreads历史，并生成一组图表，帮助用户了解自从使用Goodreads以来的阅读习惯。图表的样式应该类似于以下截图：
- en: '![ Figure 10.1 – Examples of Goodreads'' graphs'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.1 – Goodreads图表示例'
- en: '](img/B16864_10_1.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16864_10_1.jpg)'
- en: Figure 10.1 – Examples of Goodreads' graphs
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.1 – Goodreads图表示例
- en: I came up with this idea by doing a personal analysis of my book history, and
    then thinking to myself that others might also be interested in this analysis!
    There really was no better reason than that, and often, the most fun projects
    start out that way. To begin, we will work on collecting and cleaning the user
    data that exists on Goodreads.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我通过对我的书籍历史进行个人分析得出了这个想法，然后我想，也许其他人也会对这个分析感兴趣！其实没有比这个更好的理由了，很多最有趣的项目往往都是这么开始的。首先，我们将着手收集和清洗Goodreads上现有的用户数据。
- en: Collecting and cleaning data
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 收集和清洗数据
- en: 'There are two ways in which to get data from Goodreads: through their **Application
    Programming Interface** (**API**), which allows developers to programmatically
    access data about books, and through their manual exporting function. Sadly, Goodreads
    is deprecating their API in the near future and, as of December 2020, are not
    giving access to more developers.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方式可以从Goodreads获取数据：通过**应用程序编程接口**（**API**），允许开发者以编程方式访问书籍数据；以及通过其手动导出功能。遗憾的是，Goodreads将在不久的将来停用API，并且从2020年12月开始不再向更多开发者提供访问权限。
- en: 'The original Goodreads app uses the API, but our version will rely on the manual
    exporting function that the Goodreads website has instead. To get your data, head
    over to [https://www.goodreads.com/review/import](https://www.goodreads.com/review/import)
    and download your own data. If you do not have a Goodreads account, feel free
    to use my personal data for this, which can be found at [https://github.com/tylerjrichards/goodreads_book_demo](https://github.com/tylerjrichards/goodreads_book_demo).
    I have saved my Goodreads data in a file, called `goodreads_history.csv`, in a
    new folder, called `streamlit_goodreads_book`. To make your own folder with the
    appropriate setup, run the following in your Terminal:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 原始的Goodreads应用使用API，但我们的版本将依赖于Goodreads网站提供的手动导出功能。要获取你的数据，请访问[https://www.goodreads.com/review/import](https://www.goodreads.com/review/import)并下载你的数据。如果你没有Goodreads账号，可以使用我的个人数据，数据可以在[https://github.com/tylerjrichards/goodreads_book_demo](https://github.com/tylerjrichards/goodreads_book_demo)找到。我已经将我的Goodreads数据保存在一个名为`goodreads_history.csv`的文件中，文件位于一个名为`streamlit_goodreads_book`的新文件夹里。要创建你自己的文件夹并设置适当的环境，请在终端中运行以下命令：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now we are ready to get started. We really have no idea what this data looks
    like or what is in this dataset, so our first steps are to do the following:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备开始了。我们其实并不知道这些数据是什么样的，也不知道数据集里有什么，所以我们的第一步是做以下几件事：
- en: Put titles and an explanation at the top of our app.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在应用顶部放置标题和说明。
- en: Allow the user to upload their own data with ours as the default if they have
    no data of their own.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许用户上传自己的数据，如果没有数据，默认使用我们的数据。
- en: Write the first few rows of data to the app so that we can take a look at it.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将前几行数据写入应用中，以便我们查看。
- en: 'The following code block does all of this. Feel free to change the text so
    that your app has your name, and also add links to a profile of you that people
    can view! As of now, around 10 percent of the traffic to my personal website comes
    from the Streamlit apps I have produced:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块完成了所有这些操作。你可以随意更改文本，使你的应用显示你的名字，并添加链接到个人资料，供他人查看！目前，大约10%的访问量来自我制作的Streamlit应用：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, when we run this Streamlit app, we should get an app that looks similar
    to the following screenshot:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们运行这个Streamlit应用时，应该能看到一个类似于以下截图的界面：
- en: '![Figure 10.2 – The first five rows'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.2 – 前五行'
- en: '](img/B16864_10_2.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16864_10_2.jpg)'
- en: Figure 10.2 – The first five rows
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.2 – 前五行
- en: As you can see, we get a dataset where each book is a unique row. Additionally,
    we get a ton of data about each book, including the title and author, the average
    rating of the book, your rating of the book, the number of pages, and even if
    you have read the book, are planning to read the book, or are in the middle of
    reading the book. The data looks mostly clean but with some weirdness; for instance,
    the data having both a publication year and an original publication year, and
    the fact that the ISBN (International Standard Book Number) comes in the format
    of *="1400067820"*, which is just odd. Now that we know more about the data at
    hand, we can switch over to try to build some interesting graphs for users.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们得到一个数据集，其中每本书都是唯一的一行。此外，我们还获得了关于每本书的大量数据，包括书名和作者、书籍的平均评分、你对书籍的评分、书籍的页数，甚至是你是否已经读过、计划阅读或正在阅读该书。数据看起来大部分是干净的，但也有些奇怪的地方；例如，数据中既有出版年份又有原始出版年份，ISBN（国际标准书号）以
    *="1400067820"* 的格式出现，这非常奇怪。现在我们对手头的数据有了更多了解，可以切换到尝试为用户构建一些有趣的图表。
- en: Making an MVP
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个 MVP
- en: 'Looking at our data, we can start by asking a basic question: what are the
    most interesting questions I can answer with this data? After looking at the data
    and thinking about what information I would want from my Goodreads reading history,
    here are a few questions that I have thought of:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看我们的数据，我们可以从一个基本问题开始：我可以用这些数据回答哪些最有趣的问题？在查看数据并思考我希望从 Goodreads 阅读历史中获得什么信息后，我想到了以下几个问题：
- en: How many books do I read each year?
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我每年读多少本书？
- en: How long does it take for me to finish a book that I have started?
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我需要多久才能完成一本已开始的书？
- en: How long are the books that I have read?
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我读过的书籍有多长？
- en: How old are the books that I have read?
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我读过的书籍有多旧？
- en: How do I rate books compared to other Goodreads users?
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我如何将书籍的评分与其他 Goodreads 用户进行比较？
- en: We can take these questions, figure out how to modify our data to visualize
    them well, and then make the first go at our product by printing out all of the
    graphs.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以根据这些问题，弄清楚如何修改数据以便很好地可视化它们，然后通过打印出所有图表来完成我们的第一个版本。
- en: How many books do I read each year?
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我每年读多少本书？
- en: 'For the first question about books read per year, we have the `Date Read` column
    with the data presented in the format of *yyyy/mm/dd*. The following code block
    will do the following:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一个关于每年读书数量的问题，我们有 `Date Read` 列，数据呈现为 *yyyy/mm/dd* 格式。以下代码块将执行以下操作：
- en: Convert our column into datetime format.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将我们的列转换为日期时间格式。
- en: Extract the year from the `Date Read` column.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 `Date Read` 列中提取年份。
- en: Group the books by this column and make a count for books per year.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据此列对书籍进行分组，并计算每年读书的数量。
- en: Graph this using Plotly.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Plotly 绘制图表。
- en: 'The following code block does this, starting with the datetime conversion.
    It is important to note here that as with all things, I didn''t get this right
    on the very first try. In fact, it took me some time to figure out exactly how
    I needed to manage and convert this data. When you are creating projects of your
    own, do not feel bad if you find that data cleaning and converting are taking
    a long time! Very often, it is the hardest step:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块执行此操作，从日期时间转换开始。这里需要特别注意的是，和所有事情一样，我第一次尝试时并没有做到完全正确。事实上，我花了一些时间才弄清楚如何管理和转换这些数据。当你自己创建项目时，不要觉得清理和转换数据花费了很长时间就不好！通常来说，这一步是最困难的：
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The preceding code block will create the following graph:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码块将生成以下图表：
- en: '![Figure 10.3 – Year Finished bar plot'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.3 – 完成年份条形图'
- en: '](img/B16864_10_3.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16864_10_3.jpg)'
- en: Figure 10.3 – Year Finished bar plot
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.3 – 完成年份条形图
- en: We actually made an assumption here, that is, we assumed the year in the `Date
    Read` column represents when we read the book. But what if we start a book in
    the middle of December and finish it on January 2? Or, what if we start a book
    in 2019 but only get a few pages into it, and then pick it back up during 2021?
    We know this will not be a perfect approximation of the number of books read per
    year, but it will be better to express this as the number of books finished per
    year.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们实际上做了一个假设，即我们假设 `Date Read` 列中的年份表示我们阅读该书的时间。但如果我们在 12 月中旬开始读一本书，并在 1 月
    2 日完成呢？或者，如果我们在 2019 年开始一本书，但只读了几页，然后在 2021 年才继续读呢？我们知道这并不是每年读书数量的完美近似，但将其表达为每年完成的书籍数量会更好。
- en: How long does it take for me to finish a book that I have started?
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我开始读一本书后，需要多长时间才能读完？
- en: 'Our next question is about the time it takes for us to finish a book once we
    have started it. To answer this, we need to find the difference between two columns:
    the `Date Read` column and the `Date Added` column. Again, this is going to be
    an approximation, as we do not have the date of when the user started reading
    the book but only when they added the book to Goodreads. Given this, our next
    steps include the following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下一个问题是关于完成一本书所需的时间，一旦我们开始阅读它。为了回答这个问题，我们需要计算两列之间的差异：`Date Read`列和`Date Added`列。同样，这将是一个近似值，因为我们没有用户开始阅读书籍的日期，只有他们将书籍添加到Goodreads的日期。基于此，接下来的步骤包括以下内容：
- en: Convert the two columns into datetime format.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将这两列转换为datetime格式。
- en: Find the difference between the two columns in days.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算两列之间的天数差异。
- en: Plot this difference in a histogram.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将这个差异绘制为直方图。
- en: 'The following code block starts with the conversion, as we have done previously,
    and then moves through our list of tasks:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块从转换开始，和之前一样，然后执行我们的任务列表：
- en: '[PRE3]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The previous code block can be added to the bottom of your current Streamlit
    app, which, when run, should show a new graph:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码块可以添加到当前Streamlit应用的底部，运行时应该会显示一个新的图表：
- en: '![Figure 10.4 – The days to finish graph'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.4 – 完成所需天数图'
- en: '](img/B16864_10_4.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16864_10_4.jpg)'
- en: Figure 10.4 – The days to finish graph
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.4 – 完成所需天数图
- en: 'This is not the most helpful graph for my data. It looks as though, at some
    point, I added books that I had read in the past to Goodreads, which show up in
    this chart. We also have a set of books that have not been finished yet or are
    on the to-read bookshelf, which exist as null values in this dataset. We can do
    a few things here, such as filtering the dataset to just include books where the
    number of days is positive and filtering the data to only finished books, which
    the following code block does:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于我的数据来说不是最有用的图表。看起来，在某个时刻，我将曾经读过的书籍添加到了Goodreads，这些书籍出现在了这个图表中。我们还有一组未完成的书籍，或者是在待阅读书架上的书籍，它们在这个数据集中是空值。我们可以做一些事情，比如过滤数据集，只保留天数为正的书籍，并且只保留已完成的书籍，以下代码块实现了这一点：
- en: '[PRE4]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This change in our code makes the graph significantly better. It makes some
    assumptions, but it also provides a more accurate analysis. The finished graph
    can be viewed in the following screenshot:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们代码中的这个改动使得图表有了显著改进。它做了一些假设，但也提供了更准确的分析。完成后的图表可以在以下截图中查看：
- en: '![Figure 10.5 – The improved days to finish graph'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.5 – 改进后的完成所需天数图'
- en: '](img/B16864_10_5.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16864_10_5.jpg)'
- en: Figure 10.5 – The improved days to finish graph
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.5 – 改进后的完成所需天数图
- en: This looks much better! Now, let's move on to the next question.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来好多了！现在，让我们继续下一个问题。
- en: How long are the books that I have read?
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我读过的书籍有多长？
- en: 'The data for this question is already in a fairly good state. We have a single
    column called `Number of Pages`, which, you guessed it, has the number of pages
    in each book. We just need to pass that column to another histogram, and we will
    be good to go:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的数据已经处于相当好的状态。我们有一列名为`Number of Pages`，顾名思义，它包含了每本书的页数。我们只需要将这一列传递给另一个直方图，之后我们就可以开始了：
- en: '[PRE5]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This code will produce something similar to the following screenshot, showing
    a histogram of book length as measured in pages:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将生成类似于以下截图的内容，显示书籍页数的直方图：
- en: '![Figure 10.6 – The Number of Pages histogram'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.6 – 页数直方图'
- en: '](img/B16864_10_6.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16864_10_6.jpg)'
- en: Figure 10.6 – The Number of Pages histogram
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.6 – 页数直方图
- en: This makes sense to me; a ton of books are in the 300–400 page range, with a
    few giant books that have 1,000+ pages. Now, let's move on to the age of these
    books!
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这对我来说有意义；大多数书籍的页数在300到400页之间，也有一些超大书籍，页数超过1000页。接下来，让我们继续看这些书籍的年龄！
- en: How old are the books that I have read?
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我读过的书籍有多旧？
- en: 'Our next graph should be straightforward. How do we figure out how old the
    books that we read are? Are our tendencies to go for the newest set of books that
    are published or to shoot toward reading classics? There are two columns that
    we can get this information from, the publication year and the original publication
    year. There is very little documentation on this dataset, but I think we can safely
    assume that the original publication year is what we are looking for, and the
    publication year exists for when a publisher republishes a book. The following
    code block checks this assumption by printing out all the books where the original
    publication year is later than the publication year:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下一个图表应该是直观的。我们如何找出我们读过的书籍的年龄？我们倾向于选择最新出版的书籍，还是更喜欢阅读经典作品？我们可以从两个列中获取这个信息：出版年份和原出版年份。这个数据集的文档非常少，但我认为我们可以安全地假设原出版年份是我们要找的内容，而出版年份则是出版社重新出版书籍时使用的年份。以下代码块通过打印出所有原出版年份晚于出版年份的书籍来验证这一假设：
- en: '[PRE6]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'When we run this, the app should return zero books with the original publication
    year as greater than the year published. Now that we have checked this assumption,
    we can do the following:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这个时，应用应该返回没有原出版年份晚于出版年份的书籍。现在我们已经验证了这一假设，接下来我们可以做以下操作：
- en: Group the books by the original publication year.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按原出版年份对书籍进行分组。
- en: Plot this on a bar chart.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在条形图上绘制此图。
- en: 'The following code block takes two steps:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块分为两个步骤：
- en: '[PRE7]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'When we run this app, we should get the following graph:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这个应用时，应该会得到以下图表：
- en: '![Figure 10.7 – Book Age Plot'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.7 – 书籍年龄图'
- en: '](img/B16864_10_7.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16864_10_7.jpg)'
- en: Figure 10.7 – Book Age Plot
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.7 – 书籍年龄图
- en: 'At first glance, this graph does not appear to be incredibly useful, as there
    are quite a few books written so far back in history (for example, Plato''s writings
    in -375 BCE) that the entire graph is hard to read. However, Plotly is interactive
    by default, and it allows us to zoom into sections of history that we care about
    more than others. For example, the following screenshot shows us what happens
    when we zoom into the period of 1850 to the present, where most of the books that
    I''ve read happen to be in:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，这个图表似乎并不是特别有用，因为有很多书籍的写作年代非常久远（例如，柏拉图的著作约公元前375年），整个图表很难阅读。然而，Plotly 默认是交互式的，它允许我们缩放到我们更关心的历史时期。例如，以下截图展示了当我们将范围缩放到1850年至今时发生的情况，这段时间内大多数我读过的书籍恰好都在此范围内：
- en: '![Figure 10.8 – Zooming in on Year Published'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.8 – 缩放出版年份'
- en: '](img/B16864_10_8.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16864_10_8.jpg)'
- en: Figure 10.8 – Zooming in on Year Published
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.8 – 缩放出版年份
- en: 'This is a much better graph! There are a couple of options going forward. We
    can start with the graph that is not as useful and tell users to zoom in, we can
    filter our dataset for only younger books (which would defeat the main purpose
    of the graph), or we can set a default zoom state for the graph and also alert
    users at the bottom that they can zoom in as they''d like. I think the third option
    is the best one. The following code implements this option:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个更好的图表！接下来有几种选择。我们可以从一个不太有用的图表开始，并告诉用户放大，或者我们可以筛选数据集只显示较新的书籍（这会违背图表的主要目的），或者我们可以为图表设置默认的缩放状态，并在底部提醒用户可以根据需要进行缩放。我认为第三种选择是最好的。以下代码实现了这个选项：
- en: '[PRE8]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'When we run this code, we should get our final plot:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这段代码时，应该会得到最终的图表：
- en: '![Figure 10.9 – A default zoom with helpful text'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.9 – 带有提示文本的默认缩放'
- en: '](img/B16864_10_9.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16864_10_9.jpg)'
- en: Figure 10.9 – A default zoom with helpful text
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.9 – 带有提示文本的默认缩放
- en: Four questions down, we have one to go!
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 再答四个问题，剩下一个！
- en: How do I rate books compared to other Goodreads users?
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我如何与其他Goodreads用户比较我对书籍的评分？
- en: 'For this final question, we really need two separate graphs. First, we need
    to plot how we have rated the books. Then, second, we need to plot how other users
    have rated the books that we also rated. This isn''t a perfect analysis, because
    Goodreads just shows us the average rating of the books – we have not read the
    distribution. For example, if we had read *The Snowball*, a biography of Warren
    Buffett, and rated it 3 stars, and half of Goodreads'' readers rated it a 1 star
    while the other half rated it 5 stars, we would have rated it exactly the same
    as the average rating, but we would not have rated it the same as any individual
    rater! However, we do what we can with the data we have. So, we can do the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个最后的问题，我们实际上需要两个独立的图表。首先，我们需要绘制我们如何对书籍进行评分。其次，我们需要绘制其他用户对我们也评分过的书籍的评分情况。这并不是一个完美的分析，因为
    Goodreads 只显示书籍的平均评分——我们并没有查看评分分布。例如，如果我们读过《雪球》这本沃伦·巴菲特的传记，并且给了它3星评分，而 Goodreads
    上一半的读者评分为1星，另一半评分为5星，我们的评分就会和平均评分完全一样，但和任何个别读者的评分都不相同！不过，我们只能尽力利用我们拥有的数据。因此，我们可以做以下事情：
- en: Filter the books according to the ones we have rated (and, therefore, read).
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据我们已评分（即已阅读）的书籍来筛选图书。
- en: Create a histogram of the average rating per book for our first graph.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为我们的第一个图表创建每本书的平均评分直方图。
- en: Create another histogram for your own ratings.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个关于你自己评分的直方图。
- en: 'This next code block does exactly that:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块正是实现了这一功能：
- en: '[PRE9]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As you can see in the following screenshot, the first graph with the user rating
    distribution looks great. It looks as though I mainly rate books either 4 or 5
    stars, which are, overall, pretty lenient ratings:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如下图所示，第一个图表展示了用户评分分布，看起来很不错。图表显示我主要给书籍评分为4星或5星，这总体来说是相当宽松的评分：
- en: '![Figure 10.10 – The User Rating distribution'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.10 – 用户评分分布'
- en: '](img/B16864_10_10.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16864_10_10.jpg)'
- en: Figure 10.10 – The User Rating distribution
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.10 – 用户评分分布
- en: 'When we also look at the second graph, we see a fairly clean distribution.
    However, we run into the problem that we have addressed before – all the rating
    averages are more tightly bundled than the user ratings:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看第二个图表时，我们会看到一个相当干净的分布。然而，我们遇到了之前已经提到的问题——所有评分的平均值比用户评分更加紧密地集中在一起：
- en: '![Figure 10.11 – Average Goodreads Ratings'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.11 – 平均 Goodreads 评分'
- en: '](img/B16864_10_11.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16864_10_11.jpg)'
- en: Figure 10.11 – Average Goodreads Ratings
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.11 – Goodreads 平均评分
- en: 'We can always set the *x*-axis range to 1–5 for both graphs, but this will
    not help our actual problem. Instead, we can leave both of the graphs but also
    calculate whether, on average, we rate books higher or lower than the Goodreads
    average. The following code block will calculate this and add it underneath the
    average Goodreads rating graph:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们始终可以将两个图表的 *x* 轴范围设置为1–5，但这并不能解决我们实际的问题。相反，我们可以保留两个图表，同时计算我们是否普遍给书籍打高于或低于
    Goodreads 平均评分的分数。以下代码块将计算这一点，并将其添加到平均 Goodreads 评分图表下方：
- en: '[PRE10]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This code block makes our average and creates a dynamic string that will either
    say that the Goodreads user rates books higher or lower than the average Goodreads
    user. The result for my data is as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码块计算我们的平均值，并生成一个动态字符串，显示 Goodreads 用户的评分是高于还是低于 Goodreads 平均用户评分。我数据的结果如下：
- en: '![Figure 10.12 – Adding an average difference'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.12 – 添加平均差异'
- en: '](img/B16864_10_12.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16864_10_12.jpg)'
- en: Figure 10.12 – Adding an average difference
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.12 – 添加平均差异
- en: 'This is better and completes our MVP. Our app is in a decent state, and the
    difficult manipulation and visualization steps are pretty much complete. However,
    our app certainly doesn''t look great and is just a bunch of graphs that appear
    in a row. This might be good for an MVP, but we need to add some styling to really
    improve our state. That leads us to our next section: iterating on this idea to
    make it even better.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这更好，并且完成了我们的最小可行产品（MVP）。我们的应用程序已经处于一个不错的状态，复杂的数据处理和可视化步骤几乎完成了。然而，我们的应用程序看起来并不好，只是一些排成一行的图表。这对于
    MVP 来说可能不错，但我们需要添加一些样式，真正提升我们的状态。这引出了我们的下一部分内容：对这个想法进行迭代，使其变得更好。
- en: Iterative improvement
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迭代改进
- en: 'So far, we have been almost purely in production mode with this app. Iterative
    improvement is all about editing the work we have already done and organizing
    it in a way that makes the app more usable and, frankly, nicer to look at. There
    are a few improvements that we can shoot for here:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的应用几乎处于生产模式。迭代改进就是对我们已完成的工作进行编辑，并以一种使应用更加易用、更加美观的方式进行组织。我们可以尝试做出以下一些改进：
- en: Beautification via animation
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过动画进行美化
- en: Organization using columns and width
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用列和宽度进行组织
- en: Narrative building through text and additional statistics
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过文本和附加统计信息构建叙述
- en: Let's start by using animations to make our apps a bit prettier!
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过动画来让我们的应用更美观吧！
- en: Beautification via animation
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过动画进行美化
- en: 'In [*Chapter 7*](B16864_07_Final_VK_ePub.xhtml#_idTextAnchor074), *Exploring*
    *Streamlit Components*, we explored the use of various Streamlit components: one
    of these was a component called `streamlit-lottie`, which gives us the ability
    to add animation to our Streamlit applications. We can improve our current app
    by adding an animation to the top of our current Streamlit app using the following
    code. If you want to learn more about Streamlit components, please head back over
    to [*Chapter 7*](B16864_07_Final_VK_ePub.xhtml#_idTextAnchor074)*, Exploring Streamlit
    Components*:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第七章*](B16864_07_Final_VK_ePub.xhtml#_idTextAnchor074)，*探索* *Streamlit 组件*
    中，我们探讨了如何使用各种 Streamlit 组件：其中之一是 `streamlit-lottie` 组件，它使我们能够为 Streamlit 应用添加动画。我们可以通过以下代码向当前
    Streamlit 应用的顶部添加动画，从而改善我们的应用。如果你想了解更多关于 Streamlit 组件的内容，请返回 [*第七章*](B16864_07_Final_VK_ePub.xhtml#_idTextAnchor074)*，探索
    Streamlit 组件*：
- en: '[PRE11]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This Lottie file is an animation of a book flipping its pages, as shown in
    the following screenshot. These animations are always a nice touch for longer
    Streamlit apps:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 Lottie 文件是一本书翻动页面的动画，正如以下截图所示。这些动画总是为较长的 Streamlit 应用增添了一些亮点：
- en: '![Figure 12.13 – Goodreads animation'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.13 – Goodreads 动画'
- en: '](img/B16864_10_13.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16864_10_13.jpg)'
- en: Figure 12.13 – Goodreads animation
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.13 – Goodreads 动画
- en: Now that we have added our animation, we can move on to how to organize our
    app a bit better.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经添加了动画，接下来可以继续改进我们应用的组织方式。
- en: Organization using columns and width
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用列和宽度进行组织
- en: As we discussed earlier, our app does not look very good with each graph appearing
    one after the other. Another improvement we can make is to allow our app to be
    in wide, rather than narrow, format, and then put our apps side by side in each
    column.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论的那样，我们的应用看起来并不十分美观，因为每个图表都一个接一个地显示。我们可以做出的另一个改进是让我们的应用设置为宽格式，而不是窄格式，然后将应用中的图表并排放在每一列中。
- en: 'To begin, at the top of our app, we need the first Streamlit call to be the
    one that sets the configuration of our Streamlit app to wide rather than narrow,
    as shown in the following code block:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在我们的应用顶部，我们需要设置第一个 Streamlit 调用，将 Streamlit 应用的配置设置为宽格式，而不是窄格式，代码如下所示：
- en: '[PRE12]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This will set our Streamlit to our wide format. So far, in our app, we have
    called each graph a unique name (such as `fig_year_finished`) to make this next
    step easier. We can now remove all of our `st.plotly_chart()` calls, and create
    a set of two columns and three rows where we can place our six graphs. The following
    code creates each of these. We name each space first, and then fill them with
    one of our graphs:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把我们的 Streamlit 设置为宽格式。到目前为止，在我们的应用中，我们已经为每个图表指定了一个独特的名称（如`fig_year_finished`），以便简化下一步操作。我们现在可以删除所有的`st.plotly_chart()`调用，并创建一组两列三行的布局，在这里我们可以放置我们的六个图表。以下代码创建了每个图表。我们首先命名每个位置，然后将其中一个图表填充进去：
- en: '[PRE13]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This code will create the app that appears in the following screenshot, which
    has been cropped to the top two graphs for brevity:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将创建如下截图所示的应用，截图已被裁剪为仅显示前两个图表以便简洁：
- en: '![Figure 12.14 – The wide format example'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.14 – 宽格式示例'
- en: '](img/B16864_10_14.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16864_10_14.jpg)'
- en: Figure 12.14 – The wide format example
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.14 – 宽格式示例
- en: This makes our graphs much easier to read and easily allows us to compare them.
    We have intentionally paired our two graphs according to ratings, and the rest
    also appear to fit quite well next to each other. Our final step is to add a bit
    more text to make the entire app easier to read.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这样可以使我们的图表更易于阅读，并且能够轻松地进行比较。我们故意按照评分将两个图表配对，其他图表也看起来很适合并排显示。我们的最后一步是增加一些文字，使整个应用更加易读。
- en: Narrative building through text and additional statistics
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过文本和附加统计信息构建叙述
- en: These graphs are already quite helpful for understanding how the user reads,
    but we can bolster the readability of this app by adding some useful statistics
    and text underneath each graph and at the beginning of the app.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这些图表对于理解用户如何阅读已经非常有帮助，但我们可以通过在每个图表下方和应用程序开头添加一些有用的统计信息和文本来增强应用的可读性。
- en: 'Right above where we start to define our columns, we can add an initial section
    that shows the unique number of books that we have read, the unique authors, and
    our favorite author, all in one. We can use these basic statistics to kick off
    the app and tell the user that each graph is also interactive:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始定义列的地方，我们可以添加一个初步部分，显示我们读过的独特书籍数量、独特作者数量以及我们最喜欢的作者，一目了然。我们可以利用这些基本统计数据来启动应用程序，并告诉用户每个图表也是互动的：
- en: '[PRE14]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now we need to add four new text sections below the four graphs that do not
    have any annotated text as of yet. For the first three graphs, the following code
    will add some statistics and text to each:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要在四个尚未添加任何注释文本的图表下方添加四个新的文本部分。对于前三个图表，以下代码会为每个图表添加一些统计数据和文本：
- en: '[PRE15]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'One example graph here is the histogram on book length. The preceding code
    adds an average length and some text below the graph, as shown in the following
    screenshot:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的一个示例图表是关于书籍长度的直方图。前面的代码添加了一个平均长度以及一些图表下方的文本，如下图所示：
- en: '![Figure 10.15 – The average number of pages text'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.15 – 平均页数文本'
- en: '](img/B16864_10_15.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16864_10_15.jpg)'
- en: Figure 10.15 – The average number of pages text
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.15 – 平均页数文本
- en: 'For the final set of graphs, we can add text to the ones without context:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 对于最后一组图表，我们可以为没有上下文的图表添加文本：
- en: '[PRE16]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This completes our section on adding text and additional statistics! Now, our
    final step is to deploy this on Streamlit Sharing.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们关于添加文本和附加统计信息的部分！现在，我们的最后一步是将其部署到 Streamlit Sharing 上。
- en: Hosting and promotion
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 托管和推广
- en: 'Our final step is to host this app on Streamlit Sharing. To do this, we need
    to perform the following steps:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的最后一步是将这个应用程序托管到 Streamlit Sharing 上。为了做到这一点，我们需要执行以下步骤：
- en: Create a GitHub repository for this work.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为此工作创建一个 GitHub 仓库。
- en: Add a `requirements.txt` file.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个 `requirements.txt` 文件。
- en: Use 1-click deployment on Streamlit Sharing to deploy.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Streamlit Sharing 上的一键部署进行部署。
- en: We already covered this extensively in [*Chapter 5*](B16864_05_Final_VK_ePub.xhtml#_idTextAnchor056),
    *Deploying Streamlit with Streamlit Sharing*, so give it a shot now without instruction.
    If you get stuck, head over to [*Chapter 5*](B16864_05_Final_VK_ePub.xhtml#_idTextAnchor056),
    *Deploying Streamlit with Streamlit Sharing*, to find the exact instructions.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[*第 5 章*](B16864_05_Final_VK_ePub.xhtml#_idTextAnchor056)中已经详细介绍了这一点，*通过
    Streamlit Sharing 部署 Streamlit*，所以现在就按照没有说明的方式尝试一下吧。如果遇到问题，可以返回到[*第 5 章*](B16864_05_Final_VK_ePub.xhtml#_idTextAnchor056)，*通过
    Streamlit Sharing 部署 Streamlit*，查找具体的指导。
- en: Summary
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: What a fun chapter! We have learned so much here – from how to come up with
    data science projects of our own to how to create initial MVPs, to the iterative
    improvement of our apps. We have done this all through the lens of our Goodreads
    dataset, and we have taken this app from just an idea to a fully functioning app
    hosted on Streamlit Sharing. I look forward to seeing all the different types
    of Streamlit apps that you create. Please create something fun and send it to
    me on Twitter at *@tylerjrichards*. In the next chapter, we will focus on learning
    how to use Streamlit at work with the new Streamlit product, *Streamlit for Teams*.
    See you there!
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 多么有趣的一章！我们在这里学到了很多东西——从如何提出自己的数据科学项目到如何创建初始 MVP，再到如何迭代改进我们的应用程序。我们通过 Goodreads
    数据集的视角完成了这一切，并将这个应用程序从一个想法发展到一个完全功能的应用程序，并托管在 Streamlit Sharing 上。我期待看到你们创造的各种
    Streamlit 应用。请创造一些有趣的内容，并在 Twitter 上 @*tylerjrichards* 发给我。下一章，我们将专注于学习如何在工作中使用
    Streamlit，使用 Streamlit 新产品 *Streamlit for Teams*。到时候见！
