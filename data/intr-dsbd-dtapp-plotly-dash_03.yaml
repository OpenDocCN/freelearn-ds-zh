- en: '*Chapter 2*: Exploring the Structure of a Dash App'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第二章*：探索 Dash 应用的结构'
- en: 'We are now ready to tackle the mechanism through which Dash creates interactivity
    – the heart of Dash, if you will. Once you are comfortable with creating **callback
    functions** that link different elements of the layout, combined with what you
    learned in [*Chapter 1*](B16780_01_Final_NM_ePub.xhtml#_idTextAnchor015), *Overview
    of the Dash Ecosystem*, you should be well equipped to be able to convert datasets
    into interactive apps in a very short period of time. The remainder of this book
    will go into much more detail and offer many more options of how to do this. However,
    these two chapters should be sufficient for creating visual layouts, as well as
    connecting them and making them interactive. We will mainly explore callback functions
    in this chapter; the following topics will be covered:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备好讨论 Dash 创建交互性的机制——可以说这是 Dash 的核心。一旦你熟悉了创建将布局中不同元素连接起来的**回调函数**，并结合你在[*第一章*](B16780_01_Final_NM_ePub.xhtml#_idTextAnchor015)《Dash
    生态系统概述》中学到的内容，你应该能够在非常短的时间内将数据集转化为交互式应用。接下来的部分将深入探讨更多细节，并提供多种方法来实现这一目标。然而，这两章足以帮助你创建视觉布局，并将其连接起来并实现交互性。本章将主要探讨回调函数，以下主题将被涵盖：
- en: Using Jupyter Notebooks to run Dash apps
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Jupyter Notebooks 运行 Dash 应用
- en: Creating a standalone pure Python function
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个独立的纯 Python 函数
- en: Understanding the ID parameter of Dash components
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Dash 组件的 ID 参数
- en: Using Dash inputs and outputs
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Dash 输入和输出
- en: Incorporating the function into the app – creating your first reactive program
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将函数整合到应用中——创建你的第一个响应式程序
- en: Running your first interactive app
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行你的第一个交互式应用
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In addition to the packages that we used in [*Chapter 1*](B16780_01_Final_NM_ePub.xhtml#_idTextAnchor015),
    *Overview of the Dash Ecosystem* (for example, Dash, Dash HTML Components, and
    Dash Bootstrap Components), we will be, most importantly, working with `jupyter_dash`
    package along with `pandas` for data manipulation.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们在[*第一章*](B16780_01_Final_NM_ePub.xhtml#_idTextAnchor015)《Dash 生态系统概述》中使用的包（例如
    Dash、Dash HTML 组件和 Dash Bootstrap 组件）外，我们最重要的是将与 `jupyter_dash` 包一起使用，并结合 `pandas`
    进行数据处理。
- en: The code files of this chapter can be found on GitHub at [https://github.com/PacktPublishing/Interactive-Dashboards-and-Data-Apps-with-Plotly-and-Dash/tree/master/chapter_02](https://github.com/PacktPublishing/Interactive-Dashboards-and-Data-Apps-with-Plotly-and-Dash/tree/master/chapter_02).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在 GitHub 上找到，地址为 [https://github.com/PacktPublishing/Interactive-Dashboards-and-Data-Apps-with-Plotly-and-Dash/tree/master/chapter_02](https://github.com/PacktPublishing/Interactive-Dashboards-and-Data-Apps-with-Plotly-and-Dash/tree/master/chapter_02)。
- en: Check out the following video to see the Code in Action at [https://bit.ly/3tC0ZsW](https://bit.ly/3tC0ZsW).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频，了解代码的实际应用：[https://bit.ly/3tC0ZsW](https://bit.ly/3tC0ZsW)。
- en: Using Jupyter Notebooks to run Dash apps
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Jupyter Notebooks 运行 Dash 应用
- en: 'With a change to imports and a minor change to app instantiation, we can easily
    start to run our apps within Jupyter Notebook environments. The package that makes
    this possible is `jupyter_dash`. Essentially, the difference is that we import
    the **JupyterDash** object (instead of importing Dash), and app instantiation
    occurs by calling this object, as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 通过更改导入并对应用实例化做一些小修改，我们可以轻松地在 Jupyter Notebook 环境中运行我们的应用。使这一切成为可能的包是 `jupyter_dash`。本质上，区别在于我们导入
    **JupyterDash** 对象（而不是导入 Dash），并通过调用该对象来进行应用实例化，如下所示：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: One of the advantages of running apps in a notebook environment is that it is
    less tedious to make small changes, iterate them, and see results. Working with
    an IDE, the command line, and the browser, you need to constantly shift between
    them, while in a notebook environment, everything is in one place. This makes
    introducing simple changes and testing them easier. It can make your notebooks
    far more powerful and interesting as well.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在笔记本环境中运行应用的一个优势是，进行小的修改、迭代并查看结果不会那么繁琐。在使用 IDE、命令行和浏览器时，你需要不断地在它们之间切换，而在笔记本环境中，一切都集中在一个地方。这使得引入简单的修改并进行测试变得更加容易，也让你的笔记本变得更强大和有趣。
- en: 'The `jupyter_dash` package also provides an additional option while running
    the app, where you can determine whether you want to run the app in one of three
    modes:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`jupyter_dash` 包在运行应用时还提供了一个额外的选项，你可以决定是否希望在以下三种模式之一中运行应用：'
- en: '`external`: In a separate browser window, exactly as we have done so far'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`external`：在一个单独的浏览器窗口中，正如我们目前所做的那样'
- en: '`inline`: In the code output area of the notebook, right underneath the code
    cell'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`inline`：在笔记本的代码输出区，位于代码单元下方'
- en: '`jupyterlab`: In a separate tab while/if running in JupyterLab'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jupyterlab`：在 JupyterLab 中运行时，在一个独立的标签页中'
- en: 'You can also set your desired width and height if you wish to. Running the
    app takes additional optional parameters, as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意，也可以设置所需的宽度和高度。运行应用程序时需要额外的可选参数，如下所示：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see, setting the height and width can be done either by specifying
    an integer, that is, the number of pixels, or, for `width`, a percentage of the
    screen size as a string.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，设置高度和宽度可以通过指定整数来完成，即像素数量，或者对于 `width`，通过字符串形式的屏幕大小百分比来设置。
- en: Still, there is another important benefit of running apps in a Jupyter Notebook
    environment, other than keeping the code and narrative in one place.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在 Jupyter Notebook 环境中运行应用程序还有另一个重要的好处，除了将代码和叙述放在一个地方。
- en: Isolating functionality for better management and debugging
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 隔离功能以便更好地管理和调试
- en: When running and developing apps, you inevitably come across bugs and issues.
    In order to handle them, you need to isolate the cause and create the simplest
    reproducible example that causes the bug to happen. Only then can you properly
    troubleshoot the problem. And only then can you ask others for help. We won't
    wait for bugs to happen to isolate issues and figure them out. We will preemptively
    isolate all new features before incorporating them, so we can better handle and
    manage them.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行和开发应用程序时，你不可避免地会遇到 bugs 和问题。为了处理它们，你需要隔离原因，并创建最简单的可重现示例，使 bug 发生。只有这样，你才能正确地进行故障排除，只有这样，你才能向别人寻求帮助。我们不会等到
    bugs 发生才去隔离问题并找出原因。我们会在融入新功能之前预先隔离所有新功能，这样我们就能更好地处理和管理它们。
- en: From now on, introducing new features will be done by, first, creating them
    in an isolated environment, where we create a minimal app containing only this
    functionality. Once we are comfortable that we understand how it works, and that
    it functions as expected, we will keep a copy for reference, and see how to incorporate
    it into the existing app. This will also help us if we want to make changes to
    that specific functionality in the future, in which case we go through the same
    process again.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，介绍新功能将通过以下步骤进行：首先，在一个独立的环境中创建它们，我们将创建一个只包含该功能的最小应用程序。一旦我们确定它的工作原理并且它按预期运行，我们将保留一个副本以供参考，然后看看如何将其融入现有应用中。这也有助于我们在未来需要对特定功能进行更改时，重复同样的过程。
- en: 'Let''s start with our first example, which will be a drop-down menu with three
    values. The user selects one, and right underneath it, they see a message showing
    the value they chose. *Figure 2.1* shows an example of what this might look like
    in its simplest form:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从第一个示例开始，它将是一个包含三个值的下拉菜单。用户选择其中一个，紧接着会看到一条消息，显示他们选择的值。*图 2.1* 展示了最简单形式的示例：
- en: '![Figure 2.1 – The user''s selection is displayed based on the value selected](img/B16780_02_001.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.1 – 根据用户选择的值显示用户的选择](img/B16780_02_001.jpg)'
- en: Figure 2.1 – The user's selection is displayed based on the value selected
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1 – 根据用户选择的值显示用户的选择
- en: 'The following code will create this, except for the function that shows the
    user''s selection:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将创建这个，除了显示用户选择的功能：
- en: 'Import the required packages with their aliases:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用别名导入所需的包：
- en: '[PRE2]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Instantiate the app:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例化应用：
- en: '[PRE3]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Create the layout of the app. We will now introduce a new component, the Dash
    Core Components `options` attribute to set the options that the user can select
    from. This parameter is set by using a list of dictionaries, one for each option,
    where `label` is what the user will see, and `value` is the actual value that
    we will be dealing with:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建应用的布局。我们现在将介绍一个新组件，即 Dash Core Components 的 `options` 属性，用来设置用户可以选择的选项。这个参数通过使用字典列表来设置，每个选项一个字典，其中
    `label` 是用户将看到的内容，而 `value` 是我们将要处理的实际值：
- en: '[PRE4]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Run the app as usual, with the minor change of running this in the `inline`
    mode for easier interactive work in JupyterLab:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 像往常一样运行应用程序，唯一的不同是以 `inline` 模式运行，以便在 JupyterLab 中更方便地进行交互工作：
- en: '[PRE5]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Figure 2.2* shows an example of what this would look like in a notebook environment:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2.2* 展示了在笔记本环境中运行时的示例：'
- en: '![Figure 2.2 – The Dash app running in JupyterLab](img/B16780_02_002.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.2 – Dash 应用在 JupyterLab 中运行](img/B16780_02_002.jpg)'
- en: Figure 2.2 – The Dash app running in JupyterLab
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2 – Dash 应用在 JupyterLab 中运行
- en: I'm sure you have noticed the empty `html.Div` file that was added right underneath
    the drop-down list. Let's examine how that fits into the structure of the app
    and how to implement the remaining functionality. We will now look at how to create
    the function that will link the dropdown to the empty div tag.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信你已经注意到在下拉列表正下方添加的空`html.Div`文件。让我们来看看它如何融入到应用程序的结构中，并且如何实现剩余的功能。现在我们将探讨如何创建将下拉列表与空的div标签关联的函数。
- en: Creating a standalone pure Python function
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个独立的纯Python函数
- en: This function is what we will be using to take the selected value from the dropdown,
    process it somehow, and use its return value to do something that is visible to
    the user.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将用来获取从下拉列表中选定的值，以某种方式处理它，并使用其返回值做一些用户可见的操作。
- en: 'The function is so simple that it doesn''t require much explanation:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数非常简单，不需要太多解释：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If the user doesn't input anything (or deselects the current option), then the
    `color` variable is set to `'nothing'`, and the function returns `'You selected
    ' + <color>`, with whatever value `color` takes. Later in the chapter, we will
    create a more involved function to get some information on countries.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户没有输入任何内容（或取消选择当前选项），那么`color`变量会被设置为`'nothing'`，函数将返回`'You selected ' +
    <color>`，并显示`color`变量所取的任何值。稍后的章节中，我们将创建一个更复杂的函数来获取一些关于国家的信息。
- en: A function is essentially a procedure. It takes in one or more arguments (inputs),
    does something to them, and returns one or more outputs. So, for this function,
    what will `Input` be, and what happens to its `Output`? You decide by selecting
    from the available components from the layout.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 函数本质上是一个过程。它接收一个或多个参数（输入），对它们进行处理，然后返回一个或多个输出。因此，对于这个函数，`Input`是什么，`Output`会发生什么呢？你可以通过从布局中选择可用的组件来决定。
- en: 'For this function, the dropdown will provide `Input`. Then, after processing
    it, the return value of the function, that is, its `Output`, will influence what
    to display in the currently empty `html.Div` right underneath the dropdown. Building
    on the diagram in *Figure 2.1*, *Figure 2.3* shows what we are trying to achieve.
    We will build a way to connect the dropdown (`Input`) to the div that shows the
    text (`Output`) by using the function we just defined as an intermediary:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个函数，下拉列表将提供`Input`。然后，经过处理后，函数的返回值，也就是其`Output`，将影响在下拉列表下方当前空的`html.Div`中显示的内容。基于*图
    2.1*，*图 2.3*展示了我们尝试实现的目标。我们将通过使用我们刚定义的函数作为中介，来构建一种方法将下拉列表（`Input`）与显示文本的div（`Output`）连接起来：
- en: '![Figure 2.3 – Input, Output, and a standalone function](img/B16780_02_003.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.3 – 输入、输出和独立函数](img/B16780_02_003.jpg)'
- en: Figure 2.3 – Input, Output, and a standalone function
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.3 – 输入、输出和独立函数
- en: In order for it to work in the context of this app, the function needs to know
    what its inputs and outputs are.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使它在此应用程序的上下文中工作，函数需要知道其输入和输出是什么。
- en: Let's now look at how to identify components by setting their `id` values. After
    that, we will learn how to declare a component as `Input` or `Output`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下如何通过设置组件的`id`值来识别组件。之后，我们将学习如何声明一个组件为`Input`或`Output`。
- en: The id parameter of Dash components
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Dash组件的id参数
- en: As briefly mentioned in [*Chapter 1*](B16780_01_Final_NM_ePub.xhtml#_idTextAnchor015),
    *Overview of the Dash Ecosystem*, every Dash component has an `id` parameter that
    you can easily set in order to uniquely identify it. There is actually nothing
    more to this parameter than making sure that your components have unique and descriptive
    names.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如在[*第一章*](B16780_01_Final_NM_ePub.xhtml#_idTextAnchor015)中简要提到的，*Dash生态系统概述*，每个Dash组件都有一个`id`参数，你可以轻松地设置它以唯一标识该组件。实际上，这个参数没有其他复杂的内容，只需要确保你的组件具有唯一且描述性的名称。
- en: Note
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: There are more advanced ways of using the **id** parameter, and they will be
    tackled in a later, more advanced chapter. However, for now, we will just focus
    on it being a unique identifier.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**id**参数有更高级的方式，稍后会在更高级的章节中讨论。然而，目前我们将仅关注它作为一个唯一标识符的作用。
- en: 'Using descriptive and explicit names for the `id` parameter becomes more important
    as the app grows in complexity. This parameter is optional when there is no interactivity,
    but it becomes mandatory when there is. The following example snippet shows how
    easy it is to set the `id` parameter for a basic use case:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 随着应用程序复杂度的增长，为`id`参数使用描述性和明确的名称变得更加重要。当没有交互性时，这个参数是可选的，但当有交互性时，它是必需的。以下示例代码展示了如何为基本用例轻松设置`id`参数：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Applying this to our current isolated app, we set a descriptive name to each
    `id` parameter:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 将此应用到我们当前的独立应用中，我们为每个 `id` 参数设置了描述性的名称：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Our app is now complete from a layout perspective, exactly as we did in [*Chapter
    1*](B16780_01_Final_NM_ePub.xhtml#_idTextAnchor015), *Overview of the Dash Ecosystem*.
    The difference here is that we set values for the `id` parameter, and we are running
    it in a Jupyter Notebook environment. Once we can identify components using their
    `id` parameter, we can determine which become `Input` and which become `Output`.
    By updating our conceptual diagram with the ID values that we set, we can view
    the labels, as shown in *Figure 2.4*:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 从布局角度来看，我们的应用现在已经完成，正如我们在 [*第 1 章*](B16780_01_Final_NM_ePub.xhtml#_idTextAnchor015)
    中所做的那样，*Dash 生态系统概述*。这里的不同之处在于，我们为 `id` 参数设置了值，并且我们正在 Jupyter Notebook 环境中运行它。一旦我们能够使用
    `id` 参数识别组件，就可以确定哪些是 `Input`，哪些是 `Output`。通过更新我们概念图中的 ID 值，我们可以查看标签，如 *图 2.4*
    所示：
- en: '![Figure 2.4 – Visible app elements are given names (IDs)](img/B16780_02_004.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.4 – 可见的应用元素被赋予了名称（ID）](img/B16780_02_004.jpg)'
- en: Figure 2.4 – Visible app elements are given names (IDs)
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.4 – 可见的应用元素被赋予了名称（ID）
- en: Having given our components descriptive names, we are now ready to use them
    beyond simply displaying them.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在为我们的组件命名后，我们现在准备将它们用于展示之外的其他用途。
- en: Dash inputs and outputs
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Dash 输入和输出
- en: The next step is to determine which component is going to become an input (to
    our pure Python function) and which component will get the return value of the
    function (as an output) to be displayed to the user.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是确定哪个组件将成为输入（传递给我们的纯 Python 函数），哪个组件将接收函数的返回值（作为输出）并展示给用户。
- en: Determining your inputs and outputs
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 确定你的输入和输出
- en: 'The `dash.dependencies` module has several classes, two of which we will be
    using here: `Output` and `Input`.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`dash.dependencies` 模块有几个类，其中两个我们将在这里使用：`Output` 和 `Input`。'
- en: 'These classes can be imported by adding the following line to the `imports`
    section of our app:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类可以通过将以下行添加到我们应用的 `imports` 部分来导入：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let''s quickly recap what we did earlier before adding the final element that
    will make this functionality work:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加使功能正常运行的最终元素之前，先快速回顾一下我们之前所做的工作：
- en: We instantiated an app in the Jupyter Notebook environment.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在 Jupyter Notebook 环境中实例化了一个应用。
- en: We created a dropdown containing three colors.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个包含三种颜色的下拉框。
- en: 'We created a regular function that returns a string, together with the value
    provided to it: `''Your selected'' + <color>`.'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个常规函数，它返回一个字符串，并附上提供给它的值：`'Your selected' + <color>`。
- en: The components were identified with descriptive names through their `id` parameters.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过它们的 `id` 参数，我们为组件指定了描述性的名称。
- en: '`Input` and `Output` were imported from `dash.dependencies`.'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Input` 和 `Output` 从 `dash.dependencies` 导入。'
- en: We will now define our callback function.
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们现在将定义我们的回调函数。
- en: 'Callback functions are decorators, and in the most basic use case, they require
    three things:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 回调函数是装饰器，在最基本的用法中，它们需要三个内容：
- en: '`children` property of the empty div. In this case, it can be specified like
    this:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 空 div 的 `children` 属性。在这种情况下，它可以像这样指定：
- en: '[PRE10]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`value` property:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`value` 属性：'
- en: '[PRE11]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`Input` and `Output` that we have chosen.'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们选择了 `Input` 和 `Output`。
- en: '*Figure 2.5* shows an updated view of how things are coming together:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2.5* 显示了事物如何汇聚在一起的更新视图：'
- en: '![Figure 2.5 – Visible app elements connected through certain properties](img/B16780_02_005.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.5 – 可见的应用元素通过某些属性连接](img/B16780_02_005.jpg)'
- en: Figure 2.5 – Visible app elements connected through certain properties
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.5 – 可见的应用元素通过某些属性连接
- en: Tip
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: The distinction between the frontend and the backend in Dash is massively simplified
    for us. They both exist in the same module, and we don't need to worry about many
    of the conventional details. For now, anything in `app.layout` can be considered
    the frontend, and any callback functions that we define outside it can be collectively
    thought of as the backend.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Dash 中前端和后端的区别对我们来说极大地简化了。它们都存在于同一个模块中，我们无需担心许多传统的细节。现在，`app.layout` 中的任何内容都可以视为前端，而我们在其外定义的任何回调函数都可以统称为后端。
- en: Specifying your callback function
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指定你的回调函数
- en: 'The general format to specify a callback function is to define it as an attribute
    of the `app` variable, using the Python classes'' dot notation, and then set the
    output and input, as shown here:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 指定回调函数的一般格式是将其定义为 `app` 变量的一个属性，使用 Python 类的点符号表示法，然后设置输出和输入，如下所示：
- en: '[PRE12]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now that we have created a callback as an attribute of our app and determined
    which components'' IDs and properties we want to influence each other, we bring
    our Python function and simply place it underneath the callback:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经将回调作为应用程序的一个属性创建，并确定了哪些组件的 ID 和属性相互影响，我们将 Python 函数带入，并简单地将其放在回调下方：
- en: '[PRE13]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now our callback is complete and ready to be incorporated into our app.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的回调函数已完成，可以集成到我们的应用中。
- en: Implementing the callback
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现回调
- en: 'Let''s take this abstract structure and implement it using the details of our
    standalone app:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们利用这些抽象结构，通过我们独立应用的细节来实现：
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Please keep in mind that the order is important. `Output` has to be provided
    before `Input`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，顺序很重要。`Output`必须在`Input`之前提供。
- en: Now we have a complete callback function that belongs to our `app`. It knows
    which property of which `Output` it will modify, as well as which property of
    which `Input` it will be using for this. It then uses the `display_selected_color`
    function for processing, taking the output value and sending it to the component
    where `id='color_output'`. This will, in turn, modify the specified property (`children`).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个完整的回调函数，它属于我们的`app`。它知道将修改哪个`Output`的属性，以及将使用哪个`Input`的属性。然后，它使用`display_selected_color`函数进行处理，获取输出值并将其发送到`id='color_output'`的组件。这将反过来修改指定的属性（`children`）。
- en: 'For running it in JupyterLab, you can see the full code in *Figure 2.6*, as
    well as several possible outputs based on the selected value:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 JupyterLab 中运行它，您可以在*图 2.6*中看到完整的代码，并查看根据所选值生成的几种可能输出：
- en: '![Figure 2.6 – An interactive Dash app in a Jupyter Notebook](img/B16780_02_006.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.6 – 在 Jupyter Notebook 中的交互式 Dash 应用](img/B16780_02_006.jpg)'
- en: Figure 2.6 – An interactive Dash app in a Jupyter Notebook
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.6 – 在 Jupyter Notebook 中的交互式 Dash 应用
- en: I also introduced a simple new component, `html.Br`, which simply provides a
    regular HTML `<br>` element, for better readability of the output.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我还引入了一个简单的新组件，`html.Br`，它仅提供一个常规的 HTML `<br>` 元素，以提高输出的可读性。
- en: With this, we have completed our first isolated and interactive app. We ran
    it in JupyterLab, and we did so step by step, analyzing every tiny detail. The
    app that we have just built uses a toy dataset and implements extremely simple
    functionality. We did this so that we could focus on the mechanism that creates
    interactivity. There's not much practical value in telling the user what color
    they know they just selected.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 到此，我们已经完成了第一个独立且互动的应用。我们在 JupyterLab 中运行它，并一步步地进行分析每一个细节。我们刚刚构建的应用使用的是一个玩具数据集，并实现了非常简单的功能。我们这么做是为了聚焦于创建交互性的机制。告诉用户他们刚刚选择的颜色并没有太多实际意义。
- en: With this knowledge, we will now add functionality to answer a real question
    for the user – a question that might be tedious to answer if they were to skim
    through the whole dataset.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些知识后，我们将为用户回答一个实际问题——一个如果用户浏览整个数据集可能会觉得很繁琐的问题。
- en: We will also incorporate this new feature into our app and examine how it fits
    with the other content and functionality that we created already.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将这个新功能整合到我们的应用中，查看它如何与我们已经创建的其他内容和功能契合。
- en: Incorporating the function into the app
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将该功能集成到应用中
- en: 'Here is the plan for the functionality that we are going to introduce:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将要引入的功能计划：
- en: Create a drop-down list using the countries and regions available in our dataset.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用我们数据集中可用的国家和地区创建一个下拉列表。
- en: Create a callback function that takes the selected country, filters the dataset,
    and finds the population of that country in the year 2010.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个回调函数，获取所选国家，过滤数据集，并找到该国家在 2010 年的人口数据。
- en: Return a small report about the found data. *Figure 2.7* shows the desired end
    result:![Figure 2.7 – A drop-down list used to display the selected country's
    population](img/B16780_02_007.jpg)
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回一个关于找到的数据的小报告。*图 2.7* 显示了期望的最终结果：![图 2.7 – 用于显示所选国家人口的下拉列表](img/B16780_02_007.jpg)
- en: Figure 2.7 – A drop-down list used to display the selected country's population
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.7 – 用于显示所选国家人口的下拉列表
- en: Important note
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Now that we are beginning to use our dataset, we will start opening files from
    the `data` folder. This assumes that the app you are running is in the same folder.
    The code for each chapter in the GitHub repository is placed in its own folder
    for easy access; however, the code only works if the `data` folder and `app.py`
    are both in the same folder.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们开始使用数据集，我们将从 `data` 文件夹中打开文件。这假设你正在运行的应用程序与该文件夹位于同一目录下。每一章的代码在 GitHub 仓库中都有单独的文件夹，便于访问；然而，代码只有在
    `data` 文件夹和 `app.py` 文件在同一目录下时才有效。
- en: '*Figure 2.8* shows what this folder structure might look like:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2.8* 显示了该文件夹结构可能的样子：'
- en: '![Figure 2.8 – The assumed folder structure for the app](img/B16780_02_008.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.8 – 假定的应用文件夹结构](img/B16780_02_008.jpg)'
- en: Figure 2.8 – The assumed folder structure for the app
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.8 – 假定的应用文件夹结构
- en: As agreed, we will run a minimal app in JupyterLab, make sure it is running
    properly, keep a copy, and then add it to the app.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 按照约定，我们将在 JupyterLab 中运行一个简化版的应用程序，确保其正常运行，保存副本，然后将其添加到应用程序中。
- en: We first need to take a look at the dataset, explore it a little bit, and learn
    how to implement the new functionality.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要查看数据集，稍微探究一下，并学习如何实现新功能。
- en: 'To view what files we have in the dataset, we can run the following code:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看数据集中包含哪些文件，我们可以运行以下代码：
- en: '[PRE15]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Feel free to check out the files and their contents if you wish to. For now,
    we will be working with the `PovStatsData.csv` file. For a quick overview of its
    structure, we can run the following:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意，可以查看文件及其内容。现在，我们将使用 `PovStatsData.csv` 文件。为了快速了解其结构，我们可以运行以下代码：
- en: '[PRE16]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Running this code snippet in JupyterLab displays the first three rows of the
    dataset, as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JupyterLab 中运行这段代码会显示数据集的前三行，如下所示：
- en: '![Figure 2.9 – The first few rows and columns of the poverty dataset](img/B16780_02_009.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.9 – 贫困数据集的前几行和列](img/B16780_02_009.jpg)'
- en: Figure 2.9 – The first few rows and columns of the poverty dataset
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.9 – 贫困数据集的前几行和列
- en: It seems that we have two fixed variable columns (`NaN`) values are available
    under their respective year column. Here, the years span from 1974 to 2019 (note
    that not all of the years are shown for better readability). The countries and
    indicators also have codes, which can be useful later when we want to merge different
    DataFrames.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来我们有两列固定变量（`NaN`）值，这些值位于各自的年份列下。这里，年份从 1974 到 2019（请注意，并不是所有年份都显示，以便更好地阅读）。国家和指标也有代码，这些代码在我们需要合并不同
    DataFrame 时会派上用场。
- en: Tip
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Fixed variables refers to variables that are known in advance and don't change;
    in this case, they are the countries and the indicators. The measured variables
    are the values that we are interested in knowing, for example, the population
    of country A in year B. Fixed variables are also known as "dimensions." Technically,
    they are all columns in the dataset, and this is a conceptual distinction that
    is useful for analysis.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 固定变量指的是那些预先已知且不变化的变量；在这种情况下，它们是国家和指标。被测量的变量是我们希望了解的数值，例如某国 A 在某年 B 的人口。固定变量也被称为“维度”。从技术上讲，它们是数据集中所有的列，这是一个有助于分析的概念性区分。
- en: In [*Chapter 4*](B16780_04_Final_NM_ePub.xhtml#_idTextAnchor060), *Data Manipulation
    and Preparation - Paving the Way to Plotly Express*, we will explore data formats
    and how they might affect our analysis and visualization. The current structure
    can be improved by having a column for "year," and another column for "values,"
    which makes it standardized and more intuitive for analysis. For now, since we
    are focusing on callback functions, we will keep the data format as it is so that
    we don't get distracted.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 4 章*](B16780_04_Final_NM_ePub.xhtml#_idTextAnchor060)，*数据处理与准备 - 为 Plotly
    Express 铺路*，我们将探讨数据格式及其如何影响我们的分析与可视化。目前的结构可以通过新增“年份”列和“数值”列来改进，这样可以使其更加标准化并且便于分析。现在，由于我们专注于回调函数，我们将保持数据格式不变，以免分心。
- en: 'Let''s now implement the plan with code:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们用代码实现计划：
- en: 'First, let''s create a drop-down list. Here, we use the pandas `Series.unique`
    method to deduplicate countries and regions. Right underneath that, we create
    an empty div with `id=''report''`:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个下拉列表。在这里，我们使用 pandas 的 `Series.unique` 方法来去重国家和地区。就在下方，我们创建一个空的 div，`id='report'`：
- en: '[PRE17]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Next, we create a callback function that takes the selected country, filters
    the dataset, and finds the population of that country in the year 2010\. The filtering
    will take two steps.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个回调函数，该函数接收选定的国家，过滤数据集，并查找该国家在2010年的人口。过滤将分为两个步骤。
- en: 'Check whether no country has been provided to the function, which happens when
    the user first accesses the page or when the user deselects values from the dropdown.
    Here, we simply return the empty string:'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 检查是否未向函数提供任何国家（这是用户首次访问页面或用户从下拉框中取消选择时发生的情况）。在这里，我们简单地返回空字符串：
- en: '[PRE18]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, let''s focus on the filtering part. First, we take the selected country
    and filter the `poverty_data` DataFrame to get the population value. We then define
    the `filtered_df` variable. This takes the selected country and gives the rows
    where the `population` variable. We do this by using the pandas `loc` method,
    where we take all of the `:` rows and the column name `values` attribute and get
    the number at index zero:'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，让我们集中处理过滤部分。首先，我们获取选定的国家并过滤`poverty_data`数据框以获取人口值。然后我们定义`filtered_df`变量。这个变量获取选定的国家，并返回`population`变量所在的行。我们通过使用pandas的`loc`方法来实现，在该方法中我们选择所有的`:`行和列名`values`属性，并获取索引零的数值：
- en: '[PRE19]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Finally, let''s return a small report about the data that has been found. Now
    that we have the population number that we are interested in, we return a list
    that contains two elements. The first is an <h3> element, showing the `country`
    variable using a large font. The second is a sentence that takes two dynamic values,
    which are inserted where they belong, as you can see in the following code snippet:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们返回一个关于已找到数据的小报告。现在我们已经获得了感兴趣的*人口*数字，我们返回一个包含两个元素的列表。第一个是一个<h3>元素，使用大字体显示`country`变量。第二个是一个句子，其中包含两个动态值，这些值会被插入到相应的位置，您可以在以下代码片段中看到：
- en: '[PRE20]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note that since we already have a div element in the layout, and we have indicated
    that we are modifying its `children` property (which takes a single value or a
    list), the return value of the function can simply be a list (or a single value).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，由于我们已经在布局中有一个div元素，并且我们已指示要修改其`children`属性（该属性可以是单个值或列表），所以该函数的返回值可以简单地是一个列表（或单个值）。
- en: I have formatted the `population` value in the report to make it easier to read.
    The colon indicates that the following string is how we want to format it. The
    comma indicates that we want thousands to be separated by a comma. The dot indicates
    how to format decimal places. A zero after the dot indicates the number of decimal
    places, and the `f` indicates that we are dealing with floats.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我已将报告中的`population`值进行了格式化，以便更易读。冒号表示后面的字符串是我们希望的格式。逗号表示我们希望千位数用逗号分隔。点号表示如何格式化小数位数。点号后的零表示小数位数的数量，而`f`表示我们正在处理浮动数值。
- en: Now, we are ready to refactor our code to include the new visual elements, as
    well as the new functionality.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备重构代码，以包含新的视觉元素和新功能。
- en: 'Picking up where we left off in the last version of our app in [*Chapter 1*](B16780_01_Final_NM_ePub.xhtml#_idTextAnchor015),
    *Overview of the Dash Ecosystem*, the dropdown and report div should go between
    the `H2` and `Tabs` components:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，我们从上个版本的应用程序中继续，回顾[*第一章*](B16780_01_Final_NM_ePub.xhtml#_idTextAnchor015)，*Dash生态系统概述*，下拉框和报告div应位于`H2`和`Tabs`组件之间：
- en: '[PRE21]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The callback function should come after the closing parentheses of the top-level
    `html.Div` of the app. Here is the full code of the function:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 回调函数应位于应用程序的顶层`html.Div`的闭合括号之后。以下是该函数的完整代码：
- en: '[PRE22]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'By running the app again, you should get this updated view:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 重新运行应用后，您应该能看到更新后的视图：
- en: '![Figure 2.10 – The updated app with the dropdown and simple population report](img/B16780_02_010.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图2.10 – 更新后的应用程序，包含下拉框和简单的人口报告](img/B16780_02_010.jpg)'
- en: Figure 2.10 – The updated app with the dropdown and simple population report
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.10 – 更新后的应用程序，包含下拉框和简单的人口报告
- en: Tip
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: The `app.run_server` method takes an optional `port` argument, which defaults
    to `app.run_server(port=1234)`. This also applies to `jupyter_dash`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`app.run_server`方法接受一个可选的`port`参数，默认为`app.run_server(port=1234)`。这同样适用于`jupyter_dash`。'
- en: 'Now that we have our callbacks enabled and working, we can finally start using
    that blue button in the bottom-right corner! Clicking on it and then selecting
    **Callbacks** shows an interactive diagram displaying the components exactly as
    we specified them. The **country** and its **value**, and the **report** and its
    **children**. *Figure 2.11* shows this:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经启用了回调函数并使其正常工作，我们终于可以开始使用右下角的蓝色按钮了！点击它，然后选择**回调函数**，会显示一个互动式图表，精确展示我们所指定的组件。**国家**及其**值**，以及**报告**及其**子元素**。*图2.11*展示了这一点：
- en: '![Figure 2.11 – The Dash visual debugger in action](img/B16780_02_011.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![图2.11 – Dash可视化调试器的实际操作](img/B16780_02_011.jpg)'
- en: Figure 2.11 – The Dash visual debugger in action
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.11 – Dash可视化调试器的实际操作
- en: The **Server** button is green, which means it's running fine. We also see that
    we have "0 Errors." When you have this debugger opened in a running app, and while
    modifying the components, you can also see the path of the callbacks and what
    is triggering what. The components that are involved in triggering a callback
    light up, so you can "see" what is going on. This becomes much more useful in
    complex situations. The nodes of the graph are also interactive, and you can move
    them around by increasing/decreasing the size of the overall graph so that you
    can zoom in and out wherever you want. And yes, this graph is a Dash app, using
    another one of Dash's packages.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '**服务器**按钮是绿色的，这意味着它运行正常。我们还可以看到“0 错误”提示。当你在一个运行中的应用中打开这个调试器，并修改组件时，你还可以看到回调的路径以及触发了什么。参与触发回调的组件会被高亮显示，这样你就可以“看到”发生了什么。在复杂情况下，这个功能会变得更加有用。图表中的节点也是互动式的，你可以通过放大/缩小整体图表来移动它们，这样就可以在任何你想要的地方进行缩放。而且，是的，这个图表是一个Dash应用，使用了Dash的另一个包。'
- en: The green rectangle in the middle shows two interesting numbers. The one on
    top, showing **1**, tells us how many times this callback has been fired so far.
    The one at the bottom shows how long it took to run this callback function. This
    is very helpful in tracking and analyzing performance.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 中间的绿色矩形显示了两个有趣的数字。顶部显示的**1**告诉我们到目前为止该回调函数被触发了多少次。底部的数字显示运行该回调函数所花费的时间。这对于跟踪和分析性能非常有帮助。
- en: So far, we have used a single-value input (not a list, for example) to modify
    an output. But what if we wanted to get multiple values and do something with
    them? What if we wanted to process values from multiple sources, for example,
    drop-down values and a date? All this and more is possible with Dash's callback
    functions. Did I mention that they were the heart of Dash?
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只使用了单一值的输入（例如，不是列表）来修改输出。但如果我们想获取多个值并对其进行处理呢？如果我们想处理来自多个来源的值，例如，来自下拉框的值和日期呢？这些都可以通过Dash的回调函数实现。对了，我是不是提到过回调函数是Dash的核心？
- en: I believe we've done enough coding in this chapter, and I think it's a good
    idea to have an overview of what lies ahead in terms of the power of callback
    functions, what they can do, and some of their interesting attributes. These are
    just things to keep in mind and know for now; we will be exploring how each feature
    works as we progress through the later chapters.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信我们在这一章的编码已经足够了，我觉得现在回顾一下回调函数的强大功能、它们能做什么，以及它们的一些有趣属性是个不错的主意。这些只是目前需要牢记和了解的内容；我们将在后续章节中逐步探索每个功能是如何工作的。
- en: Properties of Dash's callback functions
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Dash回调函数的属性
- en: 'Let''s recap the properties of Dash''s callback function and introduce a few
    others that will be explored in more detail later on:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下Dash回调函数的属性，并介绍一些后面将更详细探讨的其他属性：
- en: '**Multiple inputs**: As I just mentioned, we can give callbacks to more than
    one input, and create more complex functionality. Using our dataset as an example,
    we can easily imagine a dropdown to select countries, another to select dates,
    and yet another to specify the economic indicator that you want to analyze. Those
    inputs could be used to filter a subset of the DataFrame and return the values
    that you want, based on multiple criteria.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多个输入**：正如我刚才提到的，我们可以为回调函数提供多个输入，并创建更复杂的功能。以我们的数据集为例，我们可以轻松想象一个下拉框用来选择国家，另一个用来选择日期，再一个用来指定你想要分析的经济指标。这些输入可以用来过滤DataFrame的子集，并根据多个条件返回你需要的值。'
- en: '`Input`): The country selector can be made to accept multiple values, so we
    can loop over them and visualize the same trend for the same indicator for multiple
    countries in one chart (or a chart per country).'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Input`）：国家选择器可以设置为接受多个值，这样我们就可以循环遍历它们，并在一张图表中（或每个国家一张图表）展示多个国家在相同指标上的趋势。'
- en: '**Multiple outputs**: As with multiple inputs, multiple outputs can be modified
    using one callback function. In our example, we might imagine producing two outputs
    – one that is a chart visualizing the filtered data and another that is a table
    – providing the user with the raw data if they want to export and further analyze
    this particular subset.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多个输出**：与多个输入一样，多个输出也可以通过一个回调函数进行修改。在我们的示例中，我们可以设想产生两个输出——一个是可视化过滤后数据的图表，另一个是表格——为用户提供原始数据，如果他们想导出并进一步分析这个特定的子集。'
- en: '**They can do other things before returning**: We have mainly focused on callbacks
    being simple processors of data, but they can really do anything before returning.
    For example, you can imagine a function sending an email under certain conditions.
    Logging is another interesting thing to explore. All you have to do is simply
    log the arguments given to each function. This can give you insights into what
    people are interested in, which functionality is being used, and more. You can
    even parse those logs and develop your own separate analytics app based on that!'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**它们可以在返回之前做其他事情**：我们主要关注回调函数作为简单的数据处理器，但它们实际上可以在返回之前做任何事情。例如，你可以想象一个函数在特定条件下发送电子邮件。日志记录是另一个有趣的探索方向。你只需要简单地记录传递给每个函数的参数。这可以让你洞察人们感兴趣的内容，哪些功能被使用等等。你甚至可以解析这些日志，并基于此开发你自己的独立分析应用程序！'
- en: '`Input` in the decorator should correspond to the first parameter of `my_function`.
    I used the same names in the preceding snippet to make it explicit and clear (`dropdown`
    and `date`). The same applies to outputs.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 装饰器中的`Input`应对应`my_function`的第一个参数。我在前面的代码片段中使用了相同的名称，以使其明确且清晰（`dropdown`和`date`）。输出也适用相同的规则。
- en: '`State`. In the examples we have discussed so far, the callbacks immediately
    fire when the values change. Sometimes, you don''t want that. For example, if
    you have multiple inputs, it might be annoying for the user to have the outputs
    change while they are configuring their options. Imagine having a textbox that
    modifies another element on the page. Every letter the user enters would modify
    it, which is not the best user experience. The typical scenario for using `State`
    is to have buttons. The user selects or enters values, and once they are ready,
    they can click on a button, which only then triggers the callback function.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`State`。在我们迄今讨论的示例中，回调函数在值变化时会立即触发。有时，你可能并不希望这样。例如，如果你有多个输入，用户在配置选项时，如果每次变化都触发输出变化，可能会让用户感到烦恼。想象一下，用户输入的每一个字母都在修改页面上的另一个元素，这并不是最佳的用户体验。使用`State`的典型场景是按钮。用户选择或输入值后，一旦准备好，他们可以点击按钮，只有在此时才会触发回调函数。'
- en: '*Figure 2.12* presents a conceptual diagram of a more complex callback function
    and what it might look like:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2.12* 展示了一个更复杂的回调函数的概念图及其可能的样子：'
- en: '![Figure 2.12 – A callback function handling multiple inputs and outputs, as
    well as running other tasks](img/B16780_02_012.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.12 – 处理多个输入和输出的回调函数，同时执行其他任务](img/B16780_02_012.jpg)'
- en: Figure 2.12 – A callback function handling multiple inputs and outputs, as well
    as running other tasks
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.12 – 处理多个输入和输出的回调函数，同时执行其他任务
- en: We have now created and run two callback functions in two different contexts.
    We also incorporated one of them and built on the work we did in [*Chapter 1*](B16780_01_Final_NM_ePub.xhtml#_idTextAnchor015),
    *Overview of the Dash Ecosystem*. With a few more examples, you will have mastered
    callback functions. The next skills you need to conquer are managing complexity
    and being comfortable with refactoring code while keeping things organized and
    under control.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经在两个不同的上下文中创建并运行了两个回调函数。我们还将其中一个回调函数融入其中，并基于我们在[*第1章*](B16780_01_Final_NM_ePub.xhtml#_idTextAnchor015)中所做的工作进行扩展，*Dash生态系统概述*。通过几个额外的示例，你将掌握回调函数。接下来，你需要攻克的技能是管理复杂性，并在重构代码时保持代码的组织性和可控性。
- en: Let's quickly recap what we learned in this chapter.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速回顾一下本章所学的内容。
- en: Summary
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: First, we introduced a new way to run Dash apps, which is by running them in
    a Jupyter Notebook environment. We saw how familiar the process is, and we created
    our first interactive app in a notebook. We went through every detail in the process
    from creating layout components, giving them IDs, and selecting which of their
    properties will be used, to connecting all of this with the callback function.
    We ran another example and familiarized ourselves with our dataset. Most importantly,
    we learned how to incorporate the new work into the app, and we ran an updated
    version that produced simple population reports. Congratulations!
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们介绍了一种新的运行 Dash 应用程序的方式，即在 Jupyter Notebook 环境中运行它们。我们看到了这个过程的熟悉感，并在笔记本中创建了我们的第一个互动应用。我们详细讲解了整个过程，从创建布局组件、为它们赋予
    ID、选择将使用哪些属性，到将所有这些与回调函数连接起来。我们又运行了一个示例，并熟悉了我们的数据集。最重要的是，我们学会了如何将新的工作整合到应用中，并运行了一个更新版，生成了简单的人口报告。恭喜！
- en: In the next chapter, we will take a deep dive into Plotly's data visualization
    capabilities. We will mainly focus on the **Figure** object, its components, how
    to query them, and how to modify them. This will give us fine-grained control
    over the visualizations that we will make.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入探讨 Plotly 的数据可视化功能。我们将主要关注**Figure**对象及其组件，如何查询它们，以及如何修改它们。这将使我们能够对所创建的可视化进行精细的控制。
