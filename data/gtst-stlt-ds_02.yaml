- en: '*Chapter 1*: An Introduction to Streamlit'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 1 章*：Streamlit 入门'
- en: Streamlit is a web application framework that helps you build and develop Python-based
    web applications that can be used to share analytics results, build complex interactive
    experiences, and illustrate new machine learning models. On top of that, developing
    and deploying Streamlit apps is incredibly fast and flexible, often turning application
    development time from days into hours.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Streamlit 是一个 Web 应用框架，帮助你构建和开发基于 Python 的 Web 应用，这些应用可以用来共享分析结果、构建复杂的交互体验并展示新的机器学习模型。更重要的是，开发和部署
    Streamlit 应用非常快速且灵活，通常将应用开发的时间从几天缩短为几个小时。
- en: In this chapter, we start out with the Streamlit basics. We will learn how to
    download and run demo Streamlit apps, how to edit demo apps using our own text
    editor, how to organize our Streamlit apps, and finally, how to make our very
    own. Then, we will explore the basics of data visualization in Streamlit. We will
    learn how to accept some initial user input, and then add some finishing touches
    to our own apps with text. At the end of this chapter, you should be comfortable
    starting to make your own Streamlit applications!
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将从 Streamlit 的基础知识开始。我们将学习如何下载和运行示例 Streamlit 应用，如何使用自己的文本编辑器编辑示例应用，如何组织我们的
    Streamlit 应用，最后，如何制作我们自己的应用。然后，我们将探索 Streamlit 中的数据可视化基础。我们将学习如何接受一些初始用户输入，并通过文本为我们的应用添加一些修饰。在本章结束时，你应该能够轻松地开始制作自己的
    Streamlit 应用！
- en: 'In particular, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们将涵盖以下主题：
- en: Why Streamlit?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么选择 Streamlit？
- en: Installing Streamlit
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 Streamlit
- en: Organizing Streamlit apps
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组织 Streamlit 应用
- en: Streamlit plotting demo
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Streamlit 绘图示例
- en: Making an app from scratch
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从零开始制作应用程序
- en: Before we begin, we will start with the technical requirements to make sure
    we have everything we need to get started.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，我们将先了解技术要求，确保我们拥有开始所需的一切。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Here are the installations and setup required for this chapter:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章所需的安装和设置：
- en: The requirements for this book are to have Python 3.7 (or later) downloaded
    ([https://www.python.org/downloads/](https://www.python.org/downloads/)), and
    have a text editor to edit Python files in. Any text editor will do. I use Sublime
    ([https://www.sublimetext.com/3](https://www.sublimetext.com/3)).
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本书的要求是下载 Python 3.7（或更高版本）（[https://www.python.org/downloads/](https://www.python.org/downloads/)），并且需要一个文本编辑器来编辑
    Python 文件。任何文本编辑器都可以。我使用 Sublime（[https://www.sublimetext.com/3](https://www.sublimetext.com/3)）。
- en: 'Some sections of this book use GitHub, and a GitHub account is recommended
    ([https://github.com/join](https://github.com/join)). Understanding how to use
    Git is not necessary for this book but is always useful. If you want to get started,
    this link has a useful tutorial: [https://guides.github.com/activities/hello-world/](https://guides.github.com/activities/hello-world/).'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本书的某些部分使用了 GitHub，建议拥有一个 GitHub 账号（[https://github.com/join](https://github.com/join)）。了解如何使用
    Git 对于本书不是必须的，但始终有帮助。如果你想入门，这个链接有一个有用的教程：[https://guides.github.com/activities/hello-world/](https://guides.github.com/activities/hello-world/)。
- en: A basic understanding of Python is also very useful for this book. If you are
    not there yet, feel free to spend some time getting to know Python better using
    this tutorial ([https://docs.python.org/3/tutorial/](https://docs.python.org/3/tutorial/))
    or any other of the freely and readily available tutorials out there, and come
    back here when you are ready. We also need to have the Streamlit library installed,
    which we will do and test in a later section called *Installing Streamlit*.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对 Python 的基本理解对本书也非常有用。如果你还没有达到这个水平，欢迎通过这个教程（[https://docs.python.org/3/tutorial/](https://docs.python.org/3/tutorial/)）或其他任何免费的教程来更好地了解
    Python，准备好后再回来这里。我们还需要安装 Streamlit 库，我们将在后面的*安装 Streamlit*部分进行安装和测试。
- en: Why Streamlit?
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么选择 Streamlit？
- en: Data scientists have become an increasingly valuable resource for companies
    and nonprofits over the course of the past decade. They help make data-driven
    decisions, make processes more efficient, and implement machine learning models
    to improve these decisions at a repeatable scale. One pain point for data scientists
    is in the process just after they have found a new insight or made a new model.
    What is the best way to show a dynamic result, a new model, or a complicated piece
    of analytics to a data scientist's colleagues? They can send a static visualization,
    which works in some cases but fails for complicated analyses that build on each
    other or on anything that requires user input. They can create a Word document
    (or export their Jupyter notebook as a document) that combines text and visualizations,
    which also doesn't work for user input and is harder to reproduce. Another option
    is to build out an entire web application from scratch using a framework such
    as Flask or Django, and then figure out how to deploy the entire app in AWS or
    another cloud provider. None of these options really work that well. Many are
    slow, don't take user input, or are suboptimal for informing the decision-making
    process so fundamental to data science.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去十年里，数据科学家已成为公司和非营利组织日益重要的资源。他们帮助做出数据驱动的决策，使流程更加高效，并通过实施机器学习模型来在可重复的规模上改进这些决策。数据科学家面临的一个痛点是在发现新见解或创建新模型后，如何向同事展示动态结果、新模型或复杂的分析内容？他们可以发送静态的可视化图表，这在某些情况下有效，但对于需要构建多个步骤的复杂分析，或任何需要用户输入的情况就不适用了。另一种方法是创建一个结合文本和可视化的
    Word 文档（或将 Jupyter notebook 导出为文档），但这同样无法处理用户输入，而且也更难以重复。还有一种选择是使用 Flask 或 Django
    等框架从头开始构建一个完整的 Web 应用程序，然后再弄清楚如何将整个应用部署到 AWS 或其他云服务提供商上。但这些方法都不算理想。许多方法都比较慢，不能接收用户输入，或者对数据科学中至关重要的决策过程的支持不足。
- en: Enter Streamlit. Streamlit is all about speed and interaction. It is a web application
    framework that helps you build and develop Python web applications. It has built-in
    and convenient methods for taking in user input, graphing using the most popular
    and powerful Python graphing libraries, and quickly deploying graphs to a web
    application.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 介绍 Streamlit。Streamlit 旨在提供速度和互动性。它是一个帮助你构建和开发 Python Web 应用程序的框架。它内置了便捷的用户输入方法、使用最流行和强大的
    Python 图形库进行绘图的方法，并能迅速将图表部署到 Web 应用程序中。
- en: I have spent the past year building Streamlit apps of all different flavors,
    from data projects for my personal portfolio to building quick applications for
    data science take-home problems, to even building mini-apps for repeatable analysis
    at work. I truly believe that Streamlit could be as valuable to you and your work
    as it has been to mine and wrote this to bring you quickly up to speed so you
    can accelerate your learning curve and get to building web applications in minutes
    and hours instead of days. If this is for you, read on! We will work in three
    sections, starting with an introduction to Streamlit, and ramp you up to building
    your own basic Streamlit applications. In part two, we'll extend this knowledge
    to more advanced topics such as production deployment methods and using components
    created by the Streamlit community for increasingly beautiful and usable Streamlit
    apps. And in the last part, we'll focus heavily on interviews with power users
    who use Streamlit at work, in academia, and for learning data science techniques.
    Before we begin, we need to get Streamlit set up and discuss how the rest of this
    book's examples will be structured.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我在过去的一年里构建了各种不同类型的 Streamlit 应用，从个人作品集的数据项目，到为数据科学带回家的问题构建快速应用，甚至还为工作中的可重复分析构建了迷你应用。我真心相信，Streamlit
    对你和你的工作将和对我一样有价值，所以我写了这篇文章，帮助你快速上手，以便你能够加速学习曲线，在几分钟或几个小时内构建 Web 应用，而不是花费几天的时间。如果这对你有帮助，接着往下看！我们将分为三个部分进行学习，从介绍
    Streamlit 开始，逐步让你掌握如何构建自己的基础 Streamlit 应用。在第二部分，我们将扩展这一知识，探讨更高级的话题，例如生产环境部署方法，以及如何使用
    Streamlit 社区创建的组件，打造更美观且实用的 Streamlit 应用。最后，在第三部分，我们将重点采访那些在工作、学术界以及学习数据科学技术中使用
    Streamlit 的高级用户。在我们开始之前，我们需要先设置 Streamlit，并讨论本书其余部分示例的结构。
- en: Installing Streamlit
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Streamlit
- en: In order to run any Streamlit apps, you must first install Streamlit. I've used
    a package manager called pip to do this, but you can install it using any package
    manager you choose (for example, **brew**). This book uses Streamlit version 0.81,
    and Python 3.7, but it should work on newer versions as well.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行任何Streamlit应用，你必须先安装Streamlit。我使用了一种名为pip的包管理器来安装它，但你也可以使用任何你选择的包管理器（例如，**brew**）。本书使用的Streamlit版本是0.81，Python版本是3.7，但它也应该适用于更新的版本。
- en: 'Throughout this book, we''ll be using a mix of both terminal commands and code
    written in Python scripts. We will signpost in which location to run the code
    to make this as clear as possible. To install Streamlit, run the following code
    in a terminal:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将混合使用终端命令和Python脚本中的代码。我们会在每个代码位置标明运行的环境，以便尽可能清晰。要安装Streamlit，请在终端中运行以下代码：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now that we have Streamlit downloaded, we can call it directly from our command
    line using the preceding code to kick off Streamlit's `demo.streamlit hello`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经下载了Streamlit，我们可以直接在命令行中使用上述代码来启动Streamlit的`demo.streamlit hello`。
- en: Take some time to explore Streamlit's demo and take a glance at any code that
    you find interesting! We're going to borrow and edit the code behind the plotting
    demo, which *illustrates a combination of plotting and animation with Streamlit*.
    Before we dive in, let's take a second and talk about how to organize Streamlit
    apps.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 花些时间浏览Streamlit的演示，看看你觉得有趣的任何代码！我们将借用并编辑绘图演示背后的代码，*它展示了Streamlit结合绘图和动画的应用*。在我们深入之前，让我们先讨论一下如何组织Streamlit应用。
- en: Organizing Streamlit apps
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组织Streamlit应用
- en: Each Streamlit app we create in this book should be contained in its own folder.
    It is tempting to create new files for each Streamlit app, but this promotes a
    bad habit that will bite us later when we talk about deploying Streamlit apps
    and deal with permissions and data for Streamlit.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中我们创建的每个Streamlit应用都应该包含在各自的文件夹中。虽然很容易为每个Streamlit应用创建新的文件，但这会养成一个坏习惯，等我们讨论如何部署Streamlit应用时，会遇到权限和数据方面的问题。
- en: 'For this book, I would recommend that you have a dedicated individual folder
    that will house all the apps you''ll create throughout this book. I have named
    mine `streamlit_apps`. The following command will make a new folder called `streamlit_apps`
    and make it our current working directory:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本书，我建议你创建一个专用的文件夹来存放你在本书中创建的所有应用。我把它命名为`streamlit_apps`。以下命令会创建一个名为`streamlit_apps`的新文件夹，并将其设置为当前工作目录：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: All the code for this book is housed at [https://github.com/tylerjrichards/Getting-Started-with-Streamlit-for-Data-Science](https://github.com/tylerjrichards/Getting-Started-with-Streamlit-for-Data-Science),
    but I would highly recommend coding these by hand for practice.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的所有代码都可以在[https://github.com/tylerjrichards/Getting-Started-with-Streamlit-for-Data-Science](https://github.com/tylerjrichards/Getting-Started-with-Streamlit-for-Data-Science)找到，但我强烈推荐你亲自动手编写代码来练习。
- en: Streamlit plotting demo
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Streamlit绘图演示
- en: 'First, we''re going to start to learn how to make Streamlit apps by reproducing
    the plotting demo we saw before in the Streamlit demo, with a Python file that
    we''ve made ourselves. In order to do that, we will do the following:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将开始学习如何制作Streamlit应用，通过重新制作我们之前在Streamlit演示中看到的绘图示例，并使用我们自己编写的Python文件。为此，我们将执行以下操作：
- en: Make a Python file where we will house all our Streamlit code.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个Python文件来存放我们所有的Streamlit代码。
- en: Use the plotting code given in the demo.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用演示中提供的绘图代码。
- en: Make small edits for practice.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进行小幅修改以进行练习。
- en: Run our file locally.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本地运行我们的文件。
- en: 'Our first step is to create a folder called `plotting_app`, which will house
    our first example. The following code makes this folder when run in the terminal,
    changes our working directory to `plotting_app`, and creates an empty Python file
    we''ll call `plot_demo.py`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一步是创建一个名为`plotting_app`的文件夹，用来存放我们的第一个示例。以下代码将在终端运行时创建这个文件夹，将我们的工作目录切换到`plotting_app`，并创建一个空的Python文件，我们将其命名为`plot_demo.py`：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now that we''ve made a file called `plot_demo.py`, open it with any text editor
    (if you don''t have one already, I''m partial to Sublime ([https://www.sublimetext.com/](https://www.sublimetext.com/)).
    When you open it up, copy and paste the following code to your `plot_demo.py`
    file:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了一个名为`plot_demo.py`的文件，使用任何文本编辑器打开它（如果你还没有选择编辑器，我个人推荐Sublime ([https://www.sublimetext.com/](https://www.sublimetext.com/))）。打开后，将以下代码复制粘贴到`plot_demo.py`文件中：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This code does a few things. First, it imports all the libraries needed and
    creates a line chart in Streamlit's native graphing framework that starts at a
    random number sampled from a normal distribution with mean 0 and variance 1\.
    And then it runs a `for` loop that keeps sampling new random numbers in bunches
    of 5 and adding that to the sum we had before while waiting for a twentieth of
    a second so we can see the graph change, simulating an animation.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码做了几件事。首先，它导入了所有需要的库，并在 Streamlit 的原生图形框架中创建了一个折线图，起始点是从正态分布中随机抽取的一个数字，均值为
    0，方差为 1。接着，它运行一个`for`循环，持续以每次 5 个数字的批次抽取新随机数，并将其加到之前的总和中，同时等待二十分之一秒，以便让我们看到图表的变化，模拟动画效果。
- en: 'By the end of this book, you will be able to make apps like this extremely
    quickly. But for now, let''s run this locally by typing the following code in
    our terminal:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 到本书结束时，你将能够非常快速地制作像这样的应用。但现在，我们可以在本地运行它，在终端输入以下代码：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This should open a new tab with your app in your default web browser. We should
    see our app run as shown in the following figure:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会在默认的网页浏览器中打开一个新标签页，显示你的应用。我们应该能看到我们的应用运行，效果如下图所示：
- en: '![Figure 1.1 – Plotting demo output'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.1 – 绘图演示输出'
- en: '](img/B16864_01_01.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16864_01_01.jpg)'
- en: Figure 1.1 – Plotting demo output
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1 – 绘图演示输出
- en: 'This is how we will run every Streamlit app, by first calling `streamlit run`
    and then pointing Streamlit toward the Python script that houses our app''s code.
    Now let''s change something small within the app so we better understand how Streamlit
    works. The following code changes how many random numbers we plot on our graph,
    but feel free to make any changes you''d like. Make your changes using the following
    code, save your changes in your text editor of choice, and run the file again:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过先调用`streamlit run`并指向包含我们应用代码的 Python 脚本来运行每个 Streamlit 应用。现在让我们在应用中做些小改动，更好地理解
    Streamlit 的工作原理。以下代码更改了我们在图表上绘制随机数的数量，但你也可以自由做任何你想要的修改。使用以下代码进行更改，在你选择的文本编辑器中保存这些更改，并再次运行文件：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You should notice that Streamlit detected a change to the source file and is
    prompting you to rerun the file if you'd like. Click **Rerun** (or **Always rerun**
    if you want this behavior to be the default, which I almost always do), and watch
    your app change.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会注意到 Streamlit 检测到源文件发生了更改，并会提示你是否希望重新运行该文件。如果你愿意，点击**重新运行**（或者点击**总是重新运行**，如果你想让这种行为成为默认设置，我几乎总是这么做），然后观察你的应用发生变化。
- en: Feel free to try making some other changes to the plotting app to get the hang
    of it! Once you are ready, let's move on to making our own apps.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 随意尝试对绘图应用进行其他更改，熟悉它！当你准备好后，我们可以继续制作自己的应用。
- en: Making an app from scratch
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从零开始制作应用
- en: Now that we've tried out the apps others have made, let's make our own! This
    app is going to focus on using the central limit theorem, which is a fundamental
    theorem of statistics that says that if we randomly sample with replacement enough
    from any distribution, then the distribution of the mean of our samples will approximate
    the normal distribution.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经试过了别人做的应用，接下来让我们自己动手做一个！这个应用将重点使用中心极限定理，这是一个统计学的基本定理，指的是如果我们从任何分布中进行带放回的随机抽样足够多次，那么我们的样本均值的分布将近似正态分布。
- en: We are not going to prove this with our app, but instead, let's try to generate
    a few graphs that help explain the power of the central limit theorem. First,
    let's make sure that we're in the correct directory (we called it `streamlit_apps`
    earlier), make a new folder called `clt_app`, and toss in a new file.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会通过应用来证明这一点，而是尝试生成几个图表，帮助解释中心极限定理的强大之处。首先，确保我们在正确的目录下（我们之前叫它`streamlit_apps`），然后创建一个名为`clt_app`的新文件夹，并放入一个新文件。
- en: 'The following code makes a new folder called `clt_app`, and again creates an
    empty Python file, this time called `clt_demo.py`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码会创建一个名为`clt_app`的新文件夹，并再次创建一个空的 Python 文件，这次叫做`clt_demo.py`：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Whenever we start a new Streamlit app, we want to make sure to import Streamlit
    (often aliased in this book and elsewhere as `st`). Streamlit has unique functions
    for each type of content (text, graphs, pictures, and other media) that we can
    use as building blocks for all of our apps. The first one we'll use is `st.write()`,
    which is a function that takes a string (and as we'll see later, almost any Pythonic
    objects, such as dictionaries) and writes it directly into our web app in the
    order that it is called. As we are calling a Python script, Streamlit sequentially
    looks through the file and, every time it sees one of the functions, designates
    a sequential slot for that piece of content. This makes it very easy to use, as
    you can write all the Python you'd like, and when you want something to appear
    on the app you've made, you can simply use `st.write()` and you're all set.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们启动一个新的 Streamlit 应用时，我们需要确保导入 Streamlit（在本书和其他地方通常使用别名`st`）。Streamlit 为每种内容类型（文本、图表、图片和其他媒体）提供了独特的函数，我们可以将它们作为构建所有应用的基础模块。我们将使用的第一个函数是`st.write()`，它是一个接受字符串（如后面所示，几乎可以接受任何
    Python 对象，例如字典）的函数，并将其按调用顺序直接写入我们的 Web 应用。由于我们正在调用一个 Python 脚本，Streamlit 会顺序查看文件，每次看到一个函数时，就为该内容分配一个顺序位置。这使得使用起来非常简单，因为你可以写任何
    Python 代码，当你希望某些内容出现在你创建的应用中时，只需使用`st.write()`，一切都准备好了。
- en: 'In our `clt_demo.py` file, we can start with the basic `''Hello World''` output
    using `st.write()`, using the following code:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`clt_demo.py`文件中，我们可以通过使用`st.write()`并编写以下代码，来实现基本的`'Hello World'`输出：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now we can test this by running the following code in the terminal:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过在终端中运行以下代码来进行测试：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We should see the string `''Hello World''` printed on our app, so all is good
    so far. The following figure is a screenshot of our app in Safari:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该能看到字符串`'Hello World'`出现在我们的应用中，到目前为止一切正常。下图是我们在 Safari 中看到的应用截图：
- en: '![Figure 1.2 – Hello World app'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.2 – Hello World 应用'
- en: '](img/B16864_01_02.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16864_01_02.jpg)'
- en: Figure 1.2 – Hello World app
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.2 – Hello World 应用
- en: 'There are three items to note in this screenshot. First, we see the string
    as we wrote it, which is great. Next, we see that the URL points to `8501`. We
    don''t need to understand almost anything about the port system on computers,
    or the **Transmission Control Protocol** (**TCP**). The important thing here is
    that this app is local to your computer. The third important item to note is the
    hamburger icon at the top right. The following screenshot shows us what happens
    when we click the icon:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这张截图中有三点需要注意。首先，我们看到了我们所写的字符串，这很好。接下来，我们看到 URL 指向`8501`。我们不需要了解计算机上的端口系统或**传输控制协议**（**TCP**）的任何内容。这里需要注意的关键是这个应用是本地的，运行在你的计算机上。第三点需要注意的是右上角的汉堡图标。下图展示了我们点击该图标后发生的事情：
- en: '![Figure 1.3 – Icon options'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.3 – 图标选项'
- en: '](img/B16864_01_03.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16864_01_03.jpg)'
- en: Figure 1.3 – Icon options
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.3 – 图标选项
- en: This is the default options panel for Streamlit apps. Throughout this book,
    we'll discuss each of these options in depth, especially the non-self-explanatory
    ones such as **Clear cache**. All we have to know for now is that if we want to
    rerun the app or find settings or the documentation, we can use this icon to find
    almost whatever we need.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 Streamlit 应用的默认选项面板。在本书中，我们将深入讨论每个选项，特别是那些不那么显而易见的选项，例如**清除缓存**。目前我们只需知道的是，如果我们希望重新运行应用或查找设置或文档，我们可以使用这个图标来找到几乎所有需要的内容。
- en: When we host applications so that others can use them, they'll see this same
    icon but have some different options (for example, they will not be able to clear
    the cache). We'll discuss this in greater detail later as well. Now back to our
    central limit theorem app!
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们托管应用程序供他人使用时，他们会看到相同的图标，但有一些不同的选项（例如，他们将无法清除缓存）。我们稍后将更详细地讨论这一点。现在回到我们的中心极限定理应用！
- en: 'The next step is going to be generating a distribution that we want to sample
    from with replacement. I''m choosing the binomial here. We can read the following
    code as simulating 1,000 coin flips using the Python package `numpy`, and printing
    out the mean number of heads from those 1,000 coin flips:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是生成一个我们希望从中进行有放回抽样的分布。我这里选择了二项分布。我们可以把以下代码理解为使用 Python 包`numpy`模拟 1,000 次掷硬币，并打印出这
    1,000 次掷硬币的平均正面朝上的次数：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now, given what we know about the central limit theorem, we would expect that
    if we sampled from `binom_dist` enough times, the mean of those samples would
    approximate the normal distribution.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，基于我们对中心极限定理的理解，我们可以预期，如果我们从`binom_dist`中进行足够多次抽样，那么这些样本的均值将近似于正态分布。
- en: We've already discussed the `st.write()` function. Our next foray into writing
    content to the Streamlit app is through graphs. `st.pyplot()` is a function that
    lets us use all the power of the popular `matplotlib` library and push our `matplotlib`
    graph to Streamlit. Once we create a figure in `matplotlib`, we can explicitly
    tell Streamlit to write that to our app with the `st.pyplot()` function.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论过`st.write()`函数。我们下一步要探索的是将内容写入Streamlit应用程序，这次是通过图形。`st.pyplot()`是一个让我们可以使用流行的`matplotlib`库的所有功能，并将我们的`matplotlib`图形推送到Streamlit的函数。一旦我们在`matplotlib`中创建了一个图形，就可以明确告诉Streamlit通过`st.pyplot()`函数将其写入我们的应用程序。
- en: 'So, all together now! This app simulates 1,000 coin flips and stores those
    values in a list we call `binom_dist`. We then sample (with replacement) 100 from
    that list, take the mean, and store that mean in the cleverly named variable `list_of_means`.
    We do that 1,000 times (it''s overkill – we could do this even with dozens of
    samples), and then plot the histogram. After we do this, the result of the following
    code should show a bell-shaped distribution:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，现在全部放在一起！这个应用模拟了1000次掷硬币，并将这些值存储在一个我们称之为`binom_dist`的列表中。然后我们从这个列表中随机抽取（带替换）100个，计算均值，并将该均值存储在巧妙命名的变量`list_of_means`中。我们重复这一过程1000次（虽然有些过头了，我们也可以只用几十次抽样），然后绘制直方图。完成后，以下代码的结果应该显示一个钟形分布：
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Each run of this app will create a new bell curve. When I ran it, my bell curve
    looked like the following figure. If your graph isn''t exactly what you see in
    the next figure, that''s totally fine because of the random sampling used in our
    code:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 每次运行这个应用都会生成一个新的正态分布曲线。当我运行它时，我的正态分布曲线看起来像下面的图形。如果你的图形和接下来看到的图形不完全相同，没关系，因为我们的代码中使用了随机抽样：
- en: '![Figure 1.4 – Bell curve'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.4 – 正态分布曲线'
- en: '](img/B16864_01_04.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16864_01_04.jpg)'
- en: Figure 1.4 – Bell curve
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.4 – 正态分布曲线
- en: As you probably noticed, we first created an empty figure and empty axes for
    that figure by calling `plt.subplots()`, and then assigned the histogram we created
    to the `ax` variable. Because of this, we were able to explicitly tell Streamlit
    to show the figure on our Streamlit app.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能注意到的，我们首先通过调用`plt.subplots()`创建了一个空图形和空的坐标轴，然后将我们创建的直方图分配给`ax`变量。正因如此，我们能够明确告诉Streamlit在我们的Streamlit应用中展示这个图形。
- en: 'This is an important step, as in Streamlit versions, we can also skip this
    step, and not assign our histogram to any variable, and then call `st.pyplot()`
    directly afterward. The following code takes this approach:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个重要的步骤，因为在Streamlit的某些版本中，我们也可以跳过这一步，不将我们的直方图分配给任何变量，而是在之后直接调用`st.pyplot()`。以下代码采用了这种方法：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: I don't recommend this method, as it can give you some unexpected results. Take
    this example, where we want to first make our histogram of means, and then make
    another histogram of a new list filled only with the number 1.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我不推荐这种方法，因为它可能会给你一些意想不到的结果。举个例子，我们想先制作一个均值的直方图，然后制作一个仅包含数字1的新列表的直方图。
- en: Take a second and guess what the following code would do. How many graphs would
    we get? What would the output be?
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 请稍等片刻，猜猜以下代码会做什么。我们会得到多少个图形？输出会是什么？
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'I would expect this to show two histograms, the first one of `list_of_means`,
    and the second one of the lists of `1`s:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我预计这将显示两个直方图，第一个是`list_of_means`的直方图，第二个是包含`1`的列表的直方图：
- en: '![Figure 1.5 – A tale of two histograms'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.5 – 两个直方图的故事'
- en: '](img/B16864_01_05.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16864_01_05.jpg)'
- en: Figure 1.5 – A tale of two histograms
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.5 – 两个直方图的故事
- en: What we actually get is different! The second histogram has data from the first
    and the second list! When we call `plt.hist()` without assigning the output to
    anything, `matplotlib` tacks the new histogram onto the old graph that is stored
    globally, and Streamlit pushes that new one to our app.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上我们得到的结果是不同的！第二个直方图包含了来自第一个和第二个列表的数据！当我们调用`plt.hist()`而没有将输出分配给任何变量时，`matplotlib`会将新的直方图附加到全局存储的旧图形上，Streamlit会将新的图形推送到我们的应用中。
- en: 'Here''s a solution to this issue. If we instead explicitly created two graphs,
    we could call the `st.pyplot()` function wherever we liked after the graph was
    generated, and have greater control over where exactly our graphs were placed.
    The following code separates the two graphs explicitly:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这是解决这个问题的一种方法。如果我们显式创建了两个图形，我们可以在图形生成后，随时调用`st.pyplot()`函数，并更好地控制图形的位置。以下代码显式分离了这两个图形：
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The preceding code plots both histograms separately by first defining separate
    variables for each figure and axis using `plt.subplots()` and then assigning the
    histogram to the appropriate axis. After this, we can call `st.pyplot()` using
    the created figure, which produces the following app:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码通过先为每个图形和轴定义单独的变量（使用 `plt.subplots()`），然后将直方图赋值给相应的轴，来分别绘制两个直方图。之后，我们可以使用创建的图形调用
    `st.pyplot()`，生成如下应用：
- en: '![Figure 1.6 – Fixed histograms'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.6 – 固定的直方图'
- en: '](img/B16864_01_06.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16864_01_06.jpg)'
- en: Figure 1.6 – Fixed histograms
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.6 – 固定的直方图
- en: We can clearly see in the preceding figure that the two histograms are now separated,
    which is the desired behavior. We will very often plot multiple visualizations
    in Streamlit and will use this method for the rest of the book. Now, on to accepting
    user input!
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以清晰地看到，前面的图形中两个直方图现在已经分开，这是我们希望的行为。在 Streamlit 中，我们通常会绘制多个可视化，并将在本书的其余部分使用这种方法。接下来，开始接受用户输入！
- en: Using user input in Streamlit apps
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Streamlit 应用中使用用户输入
- en: As of now, our app is just a fancy way to show our visualizations. But most
    web apps take some user input or are dynamic, not static visualizations. Luckily
    for us, Streamlit has many functions to accept inputs from users, all differentiated
    by the object that we want to input. There are freeform text inputs with `st.text_input()`;
    radio buttons, `st.radio()`; numeric inputs with `st.number_input()`; and a dozen
    more that are extremely helpful for making Streamlit apps. We will explore most
    of them in detail throughout this book, but we'll start with the numeric input.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的应用程序只是以一种花哨的方式展示我们的可视化内容。但大多数 web 应用都会接受某些用户输入，或者是动态的，而非静态的可视化。幸运的是，Streamlit
    提供了许多函数来接受用户输入，这些函数根据我们想要输入的对象有所不同。比如有自由格式的文本输入 `st.text_input()`；单选按钮 `st.radio()`；数字输入
    `st.number_input()`；还有许多其他非常有用的函数可以帮助我们制作 Streamlit 应用。我们将在本书中详细探讨它们的大多数内容，但我们将从数字输入开始。
- en: 'From the previous example, we assumed that the coins we were flipping were
    fair coins and had a 50/50 chance of being heads or tails. Let''s let the user
    decide what the percentage chance of heads is, assign that to a variable, and
    use that as an input in our binomial distribution. The number input function takes
    a label, a minimum and maximum value, and a default value, which I have filled
    in the following code:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的示例中，我们假设我们掷的是公平的硬币，硬币正反面出现的概率各是 50/50。现在让用户决定硬币正面朝上的百分比，将其赋值给一个变量，并将该变量作为输入用于二项分布。数字输入函数需要一个标签、最小值和最大值，以及默认值，我在以下代码中填写了这些内容：
- en: '[PRE14]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The preceding code uses the `st.number_input()` function to collect our percentage,
    assigns the user input to a variable (`perc_heads`), then uses that variable to
    change the inputs to our binomial distribution function that we used before. It
    also sets our histogram''s *x* axis to always be between 0 and 1, so we can better
    notice changes as our input changes. Try and play around with this app for a bit;
    change the number input and notice how the app responds whenever a user input
    is changed. For example, here is a result from when we set the numeric input to
    `.25`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码使用 `st.number_input()` 函数收集我们的百分比，并将用户输入赋值给变量（`perc_heads`），然后利用该变量来更改之前使用的二项分布函数的输入。它还将我们的直方图的
    *x* 轴始终设置为在 0 和 1 之间，这样我们可以更清楚地看到输入变化时的差异。试着玩一玩这个应用；更改数字输入，注意当用户输入更改时应用如何响应。例如，下面是当我们将数字输入设置为
    `.25` 时的结果：
- en: '![Figure 1.7 - An example of a result from when we set the numeric input to
    .25'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.7 - 当我们将数字输入设置为 0.25 时的结果示例'
- en: '](img/B16864_01_07.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16864_01_07.jpg)'
- en: Figure 1.7 - An example of a result from when we set the numeric input to .25
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.7 - 当我们将数字输入设置为 0.25 时的结果示例
- en: 'As you probably noticed, every time that we changed the input of our script,
    Streamlit re-ran the entire application. This is the default behavior and is very
    important to understanding Streamlit performance; we will explore a few ways that
    allow us to change this default later in the book, such as adding caching or forms!
    We can also accept text input in Streamlit using the `st.text_input()` function,
    just as we did with the numeric input. The next bit of code takes a text input
    and assigns it to the title of our graph:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经注意到的，每次我们更改脚本的输入时，Streamlit 都会重新运行整个应用程序。这是默认行为，对于理解 Streamlit 性能非常重要；在本书后面，我们将探索一些可以更改此默认行为的方法，比如添加缓存或表单！我们还可以通过
    `st.text_input()` 函数在 Streamlit 中接受文本输入，就像我们之前处理数字输入一样。以下代码将文本输入赋值给图表的标题：
- en: '[PRE15]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This creates a Streamlit app with two inputs, both a numeric input and a text
    input, and uses them both to change our Streamlit app. Finally, this results in
    a Streamlit app that looks like the next figure, with dynamic titles and probabilities:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码创建了一个Streamlit应用，包含两个输入框，一个是数字输入，另一个是文本输入，并利用这两个输入改变我们的Streamlit应用。最后，结果是一个看起来像下一张图的Streamlit应用，拥有动态标题和概率：
- en: '![Figure 1.8 – A Streamlit app with dynamic titles and probabilities'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.8 – 带有动态标题和概率的Streamlit应用'
- en: '](img/B16864_01_08.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16864_01_08.jpg)'
- en: Figure 1.8 – A Streamlit app with dynamic titles and probabilities
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.8 – 带有动态标题和概率的Streamlit应用
- en: Now that we have worked a bit with user input, let's talk about text and Streamlit
    apps more deeply.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经处理了一些用户输入，让我们深入探讨Streamlit应用中的文本部分。
- en: Finishing touches – adding text to Streamlit
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 完成的细节 – 向Streamlit添加文本
- en: Our app is functional, but it is missing a lot of nice touches. We talked earlier
    about the `st.write()` function, which the Streamlit docs call the Swiss Army
    knife of Streamlit commands. Almost whatever we wrap `st.write()` around will
    work by default and it should be our go-to function if we're not sure of the best
    path forward.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用已经能正常运行，但还缺少一些精美的细节。我们之前提到过`st.write()`函数，Streamlit文档称它为Streamlit命令的瑞士军刀。几乎任何我们用`st.write()`包裹的内容都可以默认工作，如果不确定最佳方案，它应该是我们的首选函数。
- en: Other than `st.write()`, we also can utilize other built-in functions that format
    our text for us, such as `st.title()`, `st.header()`, `st.markdown()`, and `st.subheader()`.
    Using these five functions helps to format text in our Streamlit apps easily and
    keeps sizing consistent for bigger apps.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`st.write()`，我们还可以使用其他内置函数来格式化文本，如`st.title()`、`st.header()`、`st.markdown()`和`st.subheader()`。使用这五个函数可以轻松地格式化我们的Streamlit应用中的文本，并确保在更大的应用中保持一致的字号。
- en: 'More specifically, `st.title()` will place a large block of text in our app,
    `st.header()` uses a slightly smaller font than `st.title()`, and `st.subheader()`
    uses an even smaller one. Other than those three, `st.markdown()` will allow anyone
    already familiar with Markdown to use the popular markup language in our Streamlit
    apps. Let''s try a couple of them in the following code:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说，`st.title()`会在应用中显示一个大块文本，`st.header()`使用的字体稍小于`st.title()`，而`st.subheader()`则使用更小的字体。除此之外，`st.markdown()`允许任何熟悉Markdown的人在Streamlit应用中使用这个流行的标记语言。接下来我们可以在以下代码中尝试使用几个函数：
- en: '[PRE16]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This preceding code adds a large title (`st.title()`), adds a smaller subheader
    below (`st.subheader()`), and then adds some even smaller text below the subheader
    (`st.write()`). We also separated the long string of text in the preceding code
    block into three smaller strings for readability and to make it easier to edit
    in our text editor. It should look like the following screenshot. Note that because
    we are using randomly generated data for this histogram, it is OK (and expected!)
    if your histogram looks slightly different:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 以上代码首先添加了一个大标题（`st.title()`），接着在其下方添加了一个较小的子标题（`st.subheader()`），然后在子标题下方添加了更小的文本（`st.write()`）。我们还将前面代码块中的长文本字符串分割成了三个更小的字符串，以提高可读性并使其在文本编辑器中更易编辑。最终效果应该像以下截图。请注意，由于我们使用的是随机生成的数据来绘制这个直方图，如果你的直方图与示例有所不同，这是可以接受的（也是预期的！）：
- en: '![Figure 1.9 – Central Limit Theorem application'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.9 – 中央极限定理应用'
- en: '](img/B16864_01_09.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16864_01_09.jpg)'
- en: Figure 1.9 – Central Limit Theorem application
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.9 – 中央极限定理应用
- en: One other option Streamlit has for writing out text is `st.markdown()`, which
    interprets and writes Markdown-style text into your Streamlit app. If you already
    have familiarity with Markdown, this is a great option to test out instead of
    `st.write()`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Streamlit还提供了一个写文本的选项——`st.markdown()`，它可以将Markdown风格的文本解析并显示在你的Streamlit应用中。如果你已经熟悉Markdown，那么这个选项比`st.write()`更适合测试。
- en: Summary
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we started by learning how to organize our files and folders
    for the remainder of this book and quickly moved on to instructions for downloading
    Streamlit. We then built our first Streamlit application, Hello World, and learned
    how to run our Streamlit applications locally. Then we started building out a
    more complicated application to show the implications of the central limit theorem
    from the ground up, going from a simple histogram to accepting user input and
    formatting different types of text around our app for clarity and beautification.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先学习了如何组织文件和文件夹，以便在本书的后续部分中使用，并迅速进入了下载 Streamlit 的指令。接着我们构建了第一个 Streamlit
    应用程序——Hello World，并学习了如何在本地运行 Streamlit 应用程序。然后，我们开始构建一个更复杂的应用程序，从零开始展示中心极限定理的影响，从一个简单的直方图开始，到接受用户输入，并格式化不同类型的文本以提升应用程序的清晰度和美观度。
- en: By now, you should be comfortable with subjects such as basic data visualization,
    editing Streamlit apps in a text editor, and locally running Streamlit apps. We're
    going to dive more deeply into data manipulation in our next chapter.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你应该已经熟悉了基本的数据可视化、在文本编辑器中编辑 Streamlit 应用程序以及在本地运行 Streamlit 应用程序等内容。在下一章，我们将更深入地探讨数据处理。
