- en: Object-Oriented Scala
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向对象的Scala
- en: '*"The object-oriented model makes it easy to build up programs by accretion.
    What this often means, in practice, is that it provides a structured way to write
    spaghetti code."*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*"面向对象的模型使通过增加程序变得容易。实际上，这经常意味着它提供了一种结构化的方式来编写意大利面代码。"*'
- en: '- Paul Graham'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '- Paul Graham'
- en: In the previous chapter, we looked at how to get programming started with Scala.
    Well, if you're writing the procedural program that we followed in the previous
    chapter, you can enforce the code reusability by creating procedures or functions.
    However, if you continue working, consequently, your program gets longer, bigger,
    and more complex. At a certain point, you will not even have any other more simple
    way to organize the entire code before production.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看了如何开始使用Scala进行编程。如果您正在编写我们在上一章中遵循的过程式程序，可以通过创建过程或函数来强制实现代码的可重用性。但是，如果您继续工作，因此，您的程序会变得更长、更大和更复杂。在某一点上，您甚至可能没有其他更简单的方法来在生产之前组织整个代码。
- en: On the contrary, the **object-oriented programming** (**OOP**) paradigm provides
    a whole new layer of abstraction. You can then modularize your code through defining
    OOP entities such as classes with related properties and methods. You can even
    define the relationship between those entities by utilizing inheritance or an
    interface. You can also group similar classes holding similar functionality together,
    as a helper class maybe; therefore, making your project suddenly feels more spacious
    and extensible. In short, the greatest strengths of OOP languages are discoverability,
    modularity, and extensibility.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，**面向对象编程**（**OOP**）范式提供了一个全新的抽象层。您可以通过定义具有相关属性和方法的OOP实体（如类）来模块化代码。您甚至可以通过使用继承或接口定义这些实体之间的关系。您还可以将具有类似功能的类分组在一起，例如辅助类；因此，使您的项目突然感觉更宽敞和可扩展。简而言之，面向对象编程语言的最大优势在于可发现性、模块化和可扩展性。
- en: 'Considering the preceding features of OOP languages, in this chapter, we will
    discuss the basic object-oriented features in Scala. In a nutshell, the following
    topics will be covered in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到前面介绍的面向对象编程语言的特性，在本章中，我们将讨论Scala中的基本面向对象特性。简而言之，本章将涵盖以下主题：
- en: Variables in Scala
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Scala中的变量
- en: Methods, classes, and objects in Scala
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Scala中的方法、类和对象
- en: Packages and package objects
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包和包对象
- en: Traits and trait linearization
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特征和特征线性化
- en: Java Interoperability
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java互操作性
- en: Then, we will discuss pattern matching, which is a feature that comes from functional
    programming concepts. Moreover, we will discuss some built-in concepts in Scala,
    such as implicit and generics. Finally, we will discuss some widely used build
    tools that are needed for building our Scala applications into jars.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将讨论模式匹配，这是来自函数式编程概念的一个特性。此外，我们将讨论Scala中的一些内置概念，如隐式和泛型。最后，我们将讨论一些广泛使用的构建工具，这些工具对于将我们的Scala应用程序构建成jar文件是必需的。
- en: Variables in Scala
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scala中的变量
- en: 'Before entering into the depth of OOP features, first, we need to know details
    about the different types of variables and data types in Scala. To declare a variable
    in Scala, you need to use `var` or `val` keywords. The formal syntax of declaring
    a variable in Scala is as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入了解面向对象编程特性之前，首先需要了解Scala中不同类型的变量和数据类型的详细信息。要在Scala中声明变量，您需要使用`var`或`val`关键字。在Scala中声明变量的正式语法如下：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'For example, let''s see how can we declare two variables whose data types are
    explicitly specified as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们看看如何声明两个数据类型明确指定的变量：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You can even just declare a variable without specifying the `DataType`. For
    example, let''s see how to declare a variable using `val` or `var`, as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 您甚至可以只声明一个变量而不指定`DataType`。例如，让我们看看如何使用`val`或`var`声明变量，如下所示：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'There are two types of variables in Scala: mutable and immutable that can be
    defined as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Scala中有两种类型的变量：可变和不可变，可以定义如下：
- en: '**Mutable:** The ones whose values you can change later'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可变：**其值可以在以后更改的变量'
- en: '**Immutable:** The ones whose values you cannot change once they have been
    set'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不可变：**一旦设置，其值就无法更改的变量'
- en: 'In general, for declaring a mutable variable, a `var` keyword is used. On the
    other hand, for specifying an immutable variable, a `val` keyword is used. To
    show an example of using the mutable and immutable variables, let''s consider
    the following code segment:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，用`var`关键字声明可变变量。另一方面，为了指定不可变变量，使用`val`关键字。为了展示使用可变和不可变变量的示例，让我们考虑以下代码段：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The preceding code works fine until `myVar = 90`, since **`myVar`** is a mutable
    variable. However, if you try to change the value of the immutable variable (that
    is, `myVal`), as shown earlier, your IDE will show a compilation error saying
    reassignment to `val`, as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码在`myVar = 90`之前都可以正常工作，因为**`myVar`**是一个可变变量。但是，如果您尝试更改不可变变量（即`myVal`）的值，如前所示，您的IDE将显示编译错误，指出重新分配给`val`，如下所示：
- en: '![](img/00202.jpeg)**Figure 1:** Reassignment of immutable variables is not
    allowed in Scala variable scope'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/00202.jpeg)**图1：**在Scala变量范围内不允许重新分配不可变变量'
- en: Don't worry looking at the preceding code with the object and method! We will
    discuss classes, methods, and objects later in this chapter, then things will
    become more clear.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 不要担心看前面的带有对象和方法的代码！我们将在本章后面讨论类、方法和对象，然后事情会变得更清晰。
- en: 'In Scala variables, we can have three different scopes, depending on the place
    where you have declared them:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在Scala变量中，我们可以有三种不同的范围，取决于您声明它们的位置：
- en: '**Fields:** These are variables that belong to an instance of a class of your
    Scala code. The fields are, therefore, accessible from inside every method in
    the object. However, depending on the access modifiers, fields can be accessible
    to instances of the other classes.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**字段：**这些是属于您Scala代码实例的变量。因此，这些字段可以从对象中的每个方法中访问。但是，根据访问修饰符的不同，字段可以被其他类的实例访问。'
- en: As discussed earlier, object fields can be mutable or they can be immutable
    (based on the declaration types using either `var` or `val`). But, they can't
    be both at the same time.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，对象字段可以是可变的，也可以是不可变的（根据使用`var`或`val`声明类型）。但是，它们不能同时是两者。
- en: '**Method arguments:** These are variables, and when the method is called, these
    can be used to pass the value inside a method. Method parameters are accessible
    only from inside the method. However, the objects being passed in may be accessible
    from the outside.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方法参数：**这些是变量，当调用方法时，可以用它们来传递方法内部的值。方法参数只能从方法内部访问。但是，传递的对象可能可以从外部访问。'
- en: It is to be noted that method parameters/arguments are always immutable, no
    matter what is/are the keyword(s) specified.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，方法参数/参数始终是不可变的，无论指定了什么关键字。
- en: '**Local variables:** These variables are declared inside a method and are accessible
    from the inside the method itself. However, the calling code can access the returned
    value.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**局部变量：**这些变量在方法内部声明，并且可以从方法内部访问。但是，调用代码可以访问返回的值。'
- en: Reference versus value immutability
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引用与值的不可变性
- en: 'According to the section earlier, `val` is used to declare immutable variables,
    so can we change the values of these variables? Will it be similar to the final
    keyword in Java? To help us understand more about this, we will use the following
    code snippet:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前面的部分，`val`用于声明不可变变量，那么我们可以更改这些变量的值吗？这是否类似于Java中的final关键字？为了帮助我们更多地了解这一点，我们将使用以下代码片段：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If you run the preceding code, an error at compilation time will be noticed,
    which will tell you that you are trying to reassign to a `val` variable. In general,
    mutable variables bring a performance advantage. The reason is that this is closer
    to how the computer behaves and because introducing immutable values forces the
    computer to create a whole new instance of an object whenever a change (no matter
    how small) to a particular instance is required
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果运行上述代码，将会在编译时注意到一个错误，它会告诉您正在尝试重新分配给`val`变量。一般来说，可变变量带来了性能优势。原因是这更接近计算机的行为，因为引入不可变值会迫使计算机在需要对特定实例进行任何更改（无论多么小）时创建一个全新的对象实例
- en: Data types in Scala
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scala中的数据类型
- en: 'As mentioned, Scala is a JVM language, so it shares lots in common with Java.
    One of these commonalities is the data types; Scala shares the same data types
    with Java. In short, Scala has all the same data types as Java, with the same
    memory footprint and precision. As mentioned in [Chapter 1](part0022.html#KVCC1-21aec46d8593429cacea59dbdcd64e1c),
    *Introduction to Scala*, objects are almost everywhere in Scala. and all data
    types are objects and you can call methods in them as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Scala是一种JVM语言，因此它与Java有很多共同之处。其中一个共同点就是数据类型；Scala与Java共享相同的数据类型。简而言之，Scala具有与Java相同的所有数据类型，具有相同的内存占用和精度。如[第1章](part0022.html#KVCC1-21aec46d8593429cacea59dbdcd64e1c)中所述，*介绍Scala*，在Scala中几乎到处都是对象。所有数据类型都是对象，您可以按如下方式在其中调用方法：
- en: '| **Sr.No** | **Data Type and Description** |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| **Sr.No** | **数据类型和描述** |'
- en: '| 1 | **Byte**: 8 bit signed value. Ranges from -128 to 127 |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| 1 | **Byte**：8位有符号值。范围从-128到127 |'
- en: '| 2 | **Short**: 16 bit signed value. Ranges -32768 to 32767 |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| 2 | **Short**：16位有符号值。范围为-32768至32767 |'
- en: '| 3 | **Int**: 32 bit signed value. Ranges -2147483648 to 2147483647 |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| 3 | **Int**：32位有符号值。范围为-2147483648至2147483647 |'
- en: '| 4 | **Long**: 64 bit signed value. -9223372036854775808 to 9223372036854775807
    |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| 4 | **Long**：64位有符号值。-9223372036854775808至9223372036854775807 |'
- en: '| 5 | **Float**: 32 bit IEEE 754 single-precision float |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 5 | **Float**：32位IEEE 754单精度浮点数 |'
- en: '| 6 | **Double**: 64 bit IEEE 754 double-precision float |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| 6 | **Double**：64位IEEE 754双精度浮点数 |'
- en: '| 7 | **Char**: 16 bit unsigned Unicode character. Range from U+0000 to U+FFFF
    |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 7 | **Char**：16位无符号Unicode字符。范围从U+0000到U+FFFF |'
- en: '| 8 | **String**: A sequence of Chars |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| 8 | **String**：一系列字符 |'
- en: '| 9 | **Boolean**: Either the literal `true` or the literal `false` |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 9 | **Boolean**：要么是文字`true`，要么是文字`false` |'
- en: '| 10 | **Unit**: Corresponds to no value |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| 10 | **Unit**：对应于无值 |'
- en: '| 11 | **Null**: Null or empty reference |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| 11 | **Null**：空值或空引用 |'
- en: '| 12 | **Nothing**: The subtype of every other type; includes no values |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 12 | **Nothing**：每种其他类型的子类型；不包括任何值 |'
- en: '| 13 | **Any**: The supertype of any type; any object is of type *Any* |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| 13 | **Any**：任何类型的超类型；任何对象都是*Any*类型 |'
- en: '| 14 | **AnyRef**: The supertype of any reference type |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| 14 | **AnyRef**：任何引用类型的超类型 |'
- en: '**Table 1:** Scala data types, description, and range'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**表1：**Scala数据类型、描述和范围'
- en: All the data types listed in the preceding table are objects. However, note
    that there are no primitive types, as in Java. This means that you can call methods
    on an `Int`, `Long`, and so on.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的表中列出的所有数据类型都是对象。但是，请注意，没有原始类型，就像在Java中一样。这意味着您可以在`Int`、`Long`等上调用方法。
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now, you can start playing around with these variables. Let's get some ideas
    on how to initialize a variable and work on the type annotations.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以开始玩弄这些变量。让我们对如何初始化变量和处理类型注释有一些想法。
- en: Variable initialization
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量初始化
- en: 'In Scala, it''s a good practice to initialize the variables once declared.
    However, it is to be noted that uninitialized variables aren''t necessarily nulls
    (consider types like `Int`, `Long`, `Double`, `Char`, and so on), and initialized
    variables aren''t necessarily non-null (for example, `val s: String = null`).
    The actual reasons are that:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '在Scala中，初始化变量一旦声明就是一个好习惯。但是，需要注意的是，未初始化的变量不一定是空值（考虑`Int`、`Long`、`Double`、`Char`等类型），而初始化的变量也不一定是非空值（例如`val
    s: String = null`）。实际原因是：'
- en: 'In Scala, types are inferred from the assigned value. This means that a value
    must be assigned for the compiler to infer the type (how should the compiler consider
    this code: `val a`? Since a value isn''t given, the compiler can''t infer the
    type; since it can''t infer the type, it wouldn''t know how to initialize it).'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Scala中，类型是从分配的值中推断出来的。这意味着必须为编译器分配一个值才能推断出类型（编译器应该如何考虑这段代码：`val a`？由于没有给出值，编译器无法推断出类型；由于它无法推断出类型，它将不知道如何初始化它）。
- en: In Scala, most of the time, you'll use `val`. Since these are immutable, you
    wouldn't be able to declare them and then initialize them afterward.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Scala中，大多数时候，你会使用`val`。由于这些是不可变的，你将无法先声明它们，然后再初始化它们。
- en: 'Although, Scala language requires you to initialize your instance variable
    before using it, Scala does not provide a default value for your variable. Instead,
    you have to set up its value manually using the wildcard underscore, which acts
    like a default value, as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Scala语言要求你在使用实例变量之前初始化它，但Scala不为你的变量提供默认值。相反，你必须手动设置它的值，使用通配符下划线，它就像一个默认值一样，如下所示：
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Instead of using the names, such as `val1`, `val2` and so on, you can define
    your own names:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以定义自己的名称，而不是使用`val1`、`val2`等名称：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You can use these names in subsequent expressions, as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在后续的表达式中使用这些名称，如下所示：
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Type annotations
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型标注
- en: If you use a `val` or `var` keyword to declare a variable, its data type will
    be inferred automatically according to the value that you assigned to this variable.
    You also have the luxury of explicitly stating the data type of the variable at
    declaration time.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用`val`或`var`关键字来声明一个变量，它的数据类型将根据你为这个变量分配的值自动推断。你还可以在声明时明确指定变量的数据类型。
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now, let's look at some other aspects that will be needed while working with
    variables and data types in Scala. We will see how to work with type ascription
    and `lazy` variables.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一些在使用Scala中的变量和数据类型时需要的其他方面。我们将看到如何使用类型标注和`lazy`变量。
- en: Type ascription
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型标注
- en: 'Type ascription is used to tell the compiler what types you expect out of an
    expression, from all possible valid types. Consequently, a type is valid if it
    respects existing constraints, such as variance and type declarations, and it
    is either one of the types the expression it applies to "is a," or there''s a
    conversion that applies in scope. So, technically, `java.lang.String` extends
    `java.lang.Object`, therefore any `String` is also an `Object`. For example:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 类型标注用于告诉编译器你期望从表达式中得到的类型，从所有可能的有效类型中。因此，如果一个类型符合现有的约束，比如变异和类型声明，并且它是表达式所适用的类型之一，或者在范围内有一个适用的转换，那么这个类型就是有效的。因此，从技术上讲，`java.lang.String`扩展了`java.lang.Object`，因此任何`String`也是`Object`。例如：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Lazy val
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 延迟值
- en: 'The main characteristic of a `lazy val` is that the bound expression is not
    evaluated immediately, but once on the first access. Here''s where the main difference
    between `val` and `lazy val` lies. When the initial access happens, the expression
    is evaluated and the result is bound to the identifier, the `lazy val`. On subsequent
    access, no further evaluation occurs, instead, the stored result is returned immediately.
    Let''s see an interesting example:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`lazy val`的主要特点是绑定的表达式不会立即被评估，而是在第一次访问时。这就是`val`和`lazy val`之间的主要区别所在。当初始访问发生时，表达式被评估，并且结果被绑定到标识符，即`lazy
    val`。在后续访问中，不会发生进一步的评估，而是立即返回存储的结果。让我们看一个有趣的例子：'
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If you look at the preceding code in Scala REPL, you will notice that the code
    runs very well without throwing any errors, even though you divided an integer
    with 0! Let''s see a better example:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在Scala REPL中查看前面的代码，你会注意到代码运行得很好，即使你将一个整数除以0也不会抛出任何错误！让我们看一个更好的例子：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This works and, later on, you can access the value of variable `x` when required.
    These are just a few examples of using lazy `val` concepts. Interested readers
    should access this page for more details: [https://blog.codecentric.de/en/2016/02/lazy-vals-scala-look-hood/.](https://blog.codecentric.de/en/2016/02/lazy-vals-scala-look-hood/)'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做后，以后可以在需要时访问变量`x`的值。这些只是使用延迟`val`概念的一些例子。感兴趣的读者应该访问此页面以获取更多详细信息：[https://blog.codecentric.de/en/2016/02/lazy-vals-scala-look-hood/.](https://blog.codecentric.de/en/2016/02/lazy-vals-scala-look-hood/)
- en: Methods, classes, and objects in Scala
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scala中的方法、类和对象
- en: In the previous section, we saw how to work with Scala variables, different
    data types and their mutability and immutability, along with their usages scopes.
    However, in this section, to get the real flavor of the OOP concept, we are going
    to deal with methods, objects, and classes. These three features of Scala will
    help us understand the object-oriented nature of Scala and its features.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们看到了如何使用Scala变量、不同的数据类型以及它们的可变性和不可变性，以及它们的使用范围。然而，在本节中，为了真正理解面向对象编程的概念，我们将处理方法、对象和类。Scala的这三个特性将帮助我们理解Scala的面向对象的特性和其特点。
- en: Methods in Scala
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scala中的方法
- en: 'In this part, we are going to talk about methods in Scala. As you dive into
    Scala, you''ll find that there are lots of ways to define methods in Scala. We
    will demonstrate them in some of these ways:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这部分中，我们将讨论Scala中的方法。当你深入学习Scala时，你会发现有很多种方法来定义Scala中的方法。我们将以一些方式来演示它们：
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The preceding declaration of the method takes two variables and returns the
    smallest among them. In Scala, all the methods must start with the def keyword,
    which is then followed by a name for this method. Optionally, you can decide not
    to pass any parameters to the method or even decide not to return anything. You''re
    probably wondering how the smallest value is returned, but we will get to this
    later. Also, in Scala, you can define methods without curly braces:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的方法声明接受两个变量并返回它们中的最小值。在Scala中，所有方法都必须以def关键字开头，然后是这个方法的名称。可选地，你可以决定不向方法传递任何参数，甚至决定不返回任何东西。你可能想知道最小值是如何返回的，但我们稍后会讨论这个问题。此外，在Scala中，你可以定义不带大括号的方法：
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If your method has a small body, you can declare your method like this. Otherwise,
    it''s preferred to use the curly braces in order to avoid confusion. As mentioned
    earlier, you can pass no parameters to the method if needed:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的方法体很小，你可以像这样声明你的方法。否则，最好使用大括号以避免混淆。如前所述，如果需要，你可以不传递任何参数给方法：
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'A method with or without parentheses signals the absence or presence of a side
    effect. Moreover, it has a deep connection with the uniform access principle.
    Thus, you can also avoid the braces as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 带有或不带有括号的方法表示副作用的存在或不存在。此外，它与统一访问原则有着深刻的联系。因此，您也可以避免使用大括号，如下所示：
- en: '[PRE16]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'There are also some methods which return the value by explicitly mentioning
    the return types. For example:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些方法通过显式指定返回类型来返回值。例如：
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: It should be mentioned that the preceding code works due to the Scala compiler,
    which is able to infer the return type, just as with values and variables.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 应该提到的是，前面的代码之所以能够工作，是因为Scala编译器能够推断返回类型，就像值和变量一样。
- en: 'This will return `Hello` concatenated with the passed person name. For example:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回`Hello`与传递的人名连接在一起。例如：
- en: '[PRE18]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The return in Scala
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scala中的返回
- en: 'Before learning how a Scala method returns a value, let''s recap the structure
    of a method in Scala:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习Scala方法如何返回值之前，让我们回顾一下Scala方法的结构：
- en: '[PRE19]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'For the preceding syntax, the return type could be any valid Scala data type
    and a list of parameters will be a list of variables separated by a comma and
    a list of parameters and return type is optional. Now, let''s define a method
    that adds two positive integers and returns the result, which is also an integer
    value:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 对于前面的语法，返回类型可以是任何有效的Scala数据类型，参数列表将是用逗号分隔的变量列表，参数列表和返回类型是可选的。现在，让我们定义一个方法，它将两个正整数相加并返回结果，这也是一个整数值：
- en: '[PRE20]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If you now call the preceding method from the `main()` method with the real
    values, such as `addInt(10, 30)`, the method will return an integer value sum,
    which is equal to `40`. As using the keyword `return` is optional, the Scala compiler
    is designed such that the last assignment will be returned with the absence of
    the `return` keyword. As in this situation, the greater value will be returned:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在从`main()`方法中使用真实值调用前面的方法，比如`addInt(10, 30)`，该方法将返回一个整数值和，等于`40`。由于使用关键字`return`是可选的，Scala编译器设计成在没有`return`关键字的情况下，最后的赋值将被返回。在这种情况下，将返回较大的值：
- en: '[PRE21]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Well done! We have seen how to use variables and how to declare a method in
    Scala REPL. Now, its time to see how to encapsulate them inside Scala methods
    and classes. The next section discusses Scala objects.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！我们已经看到了如何在Scala REPL中使用变量以及如何声明方法。现在，是时候看看如何将它们封装在Scala方法和类中了。下一节将讨论Scala对象。
- en: Classes in Scala
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scala中的类
- en: 'Classes are considered as a blueprint and then you instantiate this class in
    order to create something that will actually be represented in memory. They can
    contain methods, values, variables, types, objects, traits, and classes which
    are collectively called **members**. Let''s demonstrate this with the following
    example:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 类被认为是一个蓝图，然后你实例化这个类以创建实际上将在内存中表示的东西。它们可以包含方法、值、变量、类型、对象、特征和类，这些统称为**成员**。让我们通过以下示例来演示：
- en: '[PRE22]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We have two variables `animalName` and `animalAge` with their setters and getters.
    Now, how do we use them to solve our purpose? Here come the usages of Scala objects.
    Now, we will discuss Scala objects, then we will trace back to our next discussion.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两个变量`animalName`和`animalAge`以及它们的设置器和获取器。现在，我们如何使用它们来解决我们的目的呢？这就是Scala对象的用法。现在，我们将讨论Scala对象，然后我们将追溯到我们的下一个讨论。
- en: Objects in Scala
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scala中的对象
- en: 'An **object** in Scala has a slightly different meaning than the traditional
    OOP one, and this difference should be explained. In particular, in OOP, an object
    is an instance of a class, while in Scala, anything that is declared as an object
    cannot be instantiated! The `object` is a keyword in Scala. The basic syntax for
    declaring an object in Scala is as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Scala中的**object**的含义与传统的OOP有些不同，这种差异应该得到解释。特别是在OOP中，对象是类的一个实例，而在Scala中，任何声明为对象的东西都不能被实例化！`object`是Scala中的一个关键字。在Scala中声明对象的基本语法如下：
- en: '[PRE23]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'To understand the preceding syntax, let''s revisit the hello world program:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解前面的语法，让我们重新看一下hello world程序：
- en: '[PRE24]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This hello world example is pretty similar to the Java ones. The only big difference
    is that the main method is not inside a class, but instead it''s inside an object.
    In Scala, the keyword object can mean two different things:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这个hello world示例与Java的示例非常相似。唯一的区别是main方法不在一个类中，而是在一个对象中。在Scala中，关键字object可以表示两种不同的东西：
- en: As in OOP, an object can represent an instance of a class
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 就像在OOP中，一个对象可以表示一个类的实例
- en: A keyword for depicting a very different type of instance object called **Singleton**
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于描述一种非常不同的实例对象，称为**Singleton**
- en: Singleton and companion objects
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单例和伴生对象
- en: 'In this subsection, we will see a comparative analysis between the singleton
    object in Scala and Java. The idea beneath the singleton pattern is to have an
    implementation that makes sure that only a single instance of a class can exist.
    Here''s an example of the Singleton pattern in Java:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一小节中，我们将看到Scala和Java中的单例对象之间的比较分析。单例模式的理念是确保一个类的实例只能存在一个。以下是Java中单例模式的示例：
- en: '[PRE25]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The Scala object does a similar thing, and it''s well taken care of by the
    compiler. Since there will be only one instance, there is no way for object creation
    here:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Scala对象也做了类似的事情，并且它由编译器很好地处理。由于只会有一个实例，因此在这里没有对象创建的方式：
- en: '![](img/00215.jpeg)**Figure 3:** Object creation in Scala'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/00215.jpeg)**图3：**Scala中的对象创建'
- en: Companion objects
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 伴生对象
- en: 'When a `singleton object` is named the same as a class, it is called a `companion
    object`. A companion object must be defined inside the same source file as the
    class. Let''s demonstrate this with the example here:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个`singleton object`与一个类同名时，它被称为`companion object`。伴生对象必须在与类相同的源文件中定义。让我们通过这个例子来演示：
- en: '[PRE26]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The following is the way that you will call methods through the companion object
    (preferably with the same name - that is, `Animal`):'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是通过伴生对象调用方法的方式（最好与相同的名称 - 也就是`Animal`）：
- en: '[PRE27]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'A Java equivalent would be very similar, as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Java的等价物将非常相似，如下所示：
- en: '[PRE28]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Well done! So far, we have seen how to work with Scala objects and classes.
    However, working with the method for implementing and solving your data analytics
    problem is even more important. Thus, we will now see how to work with Scala methods
    in brief.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！到目前为止，我们已经看到了如何使用Scala对象和类。然而，使用方法来实现和解决数据分析问题的方法更加重要。因此，我们现在将简要介绍如何使用Scala方法。
- en: '[PRE29]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The output is as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE30]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Now, let's have a brief overview on the accessibility and the visibility of
    the Scala classes in the next section.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在下一节中简要概述Scala类的可访问性和可见性。
- en: 'Comparing and contrasting: val and final'
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较和对比：val和final
- en: 'Just like Java, the final keyword also exists in Scala, which works somehow
    similar to the val keyword. In order to differentiate between the `val` and `final`
    keywords in Scala, let''s declare a simple animal class, as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 与Java一样，Scala中也存在final关键字，它的工作方式与val关键字类似。为了区分Scala中的`val`和`final`关键字，让我们声明一个简单的动物类，如下所示：
- en: '[PRE31]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'As mentioned in [Chapter 1](part0022.html#KVCC1-21aec46d8593429cacea59dbdcd64e1c),
    *Introduction to Scala*, while listing Scala features, Scala can override variables
    which don''t exist in Java:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第1章](part0022.html#KVCC1-21aec46d8593429cacea59dbdcd64e1c)中所述，*Scala简介*，在列出Scala特性时，Scala可以覆盖Java中不存在的变量：
- en: '[PRE32]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now, before going deeper, a quick discussion on the keyword `extends` is a mandate.
    Refer to the following information box for details.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在深入讨论之前，关键字`extends`的快速讨论是必需的。有关详细信息，请参阅以下信息框。
- en: 'Using Scala, classes can be extensible. A subclass mechanism using the extends
    keyword makes it possible to *specialize* a class by inheriting all members of
    a given *superclass* and defining additional class members. Let''s look at an
    example, as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Scala，类可以是可扩展的。使用extends关键字的子类机制使得可以通过继承给定*超类*的所有成员并定义额外的类成员来*专门化*类。让我们看一个例子，如下所示：
- en: '`class Coordinate(xc: Int, yc: Int) {`'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`class Coordinate(xc: Int, yc: Int) {`'
- en: '`val x: Int = xc`'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`val x: Int = xc`'
- en: '`val y: Int = yc`'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`val y: Int = yc`'
- en: '`def move(dx: Int, dy: Int): Coordinate = new Coordinate(x + dx, y + dy)`'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`def move(dx: Int, dy: Int): Coordinate = new Coordinate(x + dx, y + dy)`'
- en: '`}`'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`}`'
- en: '`class ColorCoordinate(u: Int, v: Int, c: String) extends Coordinate(u, v)
    {`'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`class ColorCoordinate(u: Int, v: Int, c: String) extends Coordinate(u, v)
    {`'
- en: '`val color: String = c`'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`val color: String = c`'
- en: '`def compareWith(pt: ColorCoordinate): Boolean = (pt.x == x) && (pt.y == y)
    && (pt.color == color)`'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`def compareWith(pt: ColorCoordinate): Boolean = (pt.x == x) && (pt.y == y)
    && (pt.color == color)`'
- en: '`override def move(dx: Int, dy: Int): ColorCoordinate = new ColorCoordinate(x
    + dy, y + dy, color)`'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`override def move(dx: Int, dy: Int): ColorCoordinate = new ColorCoordinate(x
    + dy, y + dy, color)`'
- en: '`}`'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`}`'
- en: 'However, if we declared the age variable as final in the `Animal` class, then
    the `Cat` class will not be able to override it, and it will give the following
    error. For this `Animal` example, you should have learned when to use the `final`
    keyword. Let''s see an example of this:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我们在`Animal`类中将年龄变量声明为final，那么`Cat`类将无法覆盖它，并且将会出现以下错误。对于这个`Animal`示例，您应该学会何时使用`final`关键字。让我们看一个例子：
- en: '[PRE33]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Well done! To achieve the best encapsulation - also called information hiding
    - you should always declare methods with the least visibility that works. In the
    next subsection, we will learn how the access and visibility of classes, companion
    objects, packages, subclasses, and projects work.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！为了实现最佳封装-也称为信息隐藏-您应该始终使用最少可见性声明方法。在下一小节中，我们将学习类、伴生对象、包、子类和项目的访问和可见性如何工作。
- en: Access and visibility
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问和可见性
- en: 'In this subsection, we will try to understand the access and visibility of
    Scala variables and different data types in the OOP paradigm. Let''s have a look
    at access modifiers in Scala. A similar one for Scala:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节中，我们将尝试理解OOP范式中Scala变量和不同数据类型的访问和可见性。让我们看看Scala中的访问修饰符。Scala的类似之一：
- en: '| **Modifier** | **Class** | **Companion Object** | **Package** | **Subclass**
    | **Project** |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| **修饰符** | **类** | **伴生对象** | **包** | **子类** | **项目** |'
- en: '| Default/No modifier | Yes | Yes | Yes | Yes | Yes |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| 默认/无修饰符 | 是 | 是 | 是 | 是 | 是 |'
- en: '| Protected | Yes | Yes | Yes | No | No |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| 受保护 | 是 | 是 | 是 | 否 | 否 |'
- en: '| Private | Yes | Yes | No | No | No |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| 私有 | 是 | 是 | 否 | 否 | 否 |'
- en: '**Public members**: Unlike a private and protected member, it is not required
    to specify the public keyword for public members. There is no explicit modifier
    for public members. Such members can be accessed from anywhere. For example:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**公共成员**：与私有和受保护成员不同，对于公共成员，不需要为公共成员指定public关键字。公共成员没有显式的修饰符。这些成员可以从任何地方访问。例如：'
- en: '[PRE34]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '**Private members**: A private member is visible only inside the class or object
    that contains the member definition. Let''s see an example, as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '**私有成员**：私有成员仅在包含成员定义的类或对象内部可见。让我们看一个例子，如下所示：'
- en: '[PRE35]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '**Protected members**: A protected member is only accessible from subclasses
    of the class in which the member is defined. Let''s see an example, as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '**受保护成员**：受保护成员只能从定义成员的类的子类中访问。让我们看一个例子，如下所示：'
- en: '[PRE36]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Access modifiers in Scala can be augmented with qualifiers. A modifier of the
    form `private[X]` or `protected[X]` means that access is private or protected
    up to `X`, where `X` designates an enclosing package, class, or singleton object.
    Let''s see an example:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Scala中的访问修饰符可以通过限定符进行增强。形式为`private[X]`或`protected[X]`的修饰符意味着访问是私有的或受保护的，直到`X`，其中`X`指定封闭的包、类或单例对象。让我们看一个例子：
- en: '[PRE37]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Here''s a short note on the preceding code segment:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码段中有一个简短的说明：
- en: Variable `jboTitle` will be accessible to any class within the enclosing package
    `Professional`
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量`jboTitle`将对封闭包`Professional`中的任何类可访问
- en: Variable `friend` will be accessible to any class within the enclosing package
    `Country`
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量`friend`将对封闭包`Country`中的任何类可访问
- en: Variable `secret` will be accessible only to the implicit object within instance
    methods (this) only
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量`secret`只能在实例方法（this）中被隐式对象访问
- en: If you look at the preceding examples, we used the keyword `package`. However,
    we have not discussed this so far. But don't worry; there will be a dedicated
    section later in this chapter. The constructor is a strong feature for any objected-oriented
    programming language. Scala is not an exception. Now, let's have a short overview
    of the constructor.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您看一下前面的例子，我们使用了关键字`package`。然而，我们到目前为止还没有讨论这个问题。但不要担心；本章后面将有一个专门的部分。构造函数是任何面向对象编程语言的一个强大特性。Scala也不例外。现在，让我们简要概述一下构造函数。
- en: Constructors
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构造函数
- en: The concept and the usage of constructors in Scala are a little different than
    what they are in C# or Java. There are two types of constructors in Scala - primary
    and auxiliary constructors. The primary constructor is the class's body, and it's
    parameter list appears right after the class name.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在Scala中，构造函数的概念和用法与C#或Java中的有些不同。Scala中有两种类型的构造函数 - 主构造函数和辅助构造函数。主构造函数是类的主体，其参数列表紧跟在类名后面。
- en: 'For example, the following code segment describes the way to use the primary
    constructor in Scala:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下代码段描述了在Scala中使用主构造函数的方法：
- en: '[PRE38]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, to use the preceding constructor, this implementation is similar to the
    previous one, except there are no setters and getters. Instead, we can get the
    animal name and age, as here:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要使用前面的构造函数，这个实现与之前的实现类似，只是没有设置器和获取器。相反，我们可以在这里获取动物的名称和年龄：
- en: '[PRE39]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Parameters are given in the class definition time to represent constructors.
    If we declare a constructor, then we cannot create a class without providing the
    default values of the parameters that are specified in the constructor. Moreover,
    Scala allows the instantiation of an object without providing the necessary parameters
    to its constructor: this happens when all constructor arguments have a default
    value defined.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在类定义时给出参数以表示构造函数。如果我们声明了一个构造函数，那么就不能在不提供构造函数中指定的参数的默认值的情况下创建类。此外，Scala允许在不提供必要参数给其构造函数的情况下实例化对象：当所有构造函数参数都有默认值定义时会发生这种情况。
- en: Although there is a constraint for using the auxiliary constructors, we are
    free to add as many additional auxiliary constructors as we want. An auxiliary
    constructor must, on the first line of its body, call either another auxiliary
    constructor that has been declared before it, or the primary constructor. To obey
    this rule, each auxiliary constructor will, either directly or indirectly, end
    up invoking the primary constructor.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管使用辅助构造函数有一些限制，但我们可以自由地添加任意数量的额外辅助构造函数。辅助构造函数必须在其主体的第一行调用在其之前声明的另一个辅助构造函数或主构造函数。为了遵守这个规则，每个辅助构造函数最终都会直接或间接地调用主构造函数。
- en: 'For example, the following code segment demonstrates the use of the auxiliary
    constructor in Scala:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下代码段演示了在Scala中使用辅助构造函数：
- en: '[PRE40]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In the earlier setting, we included a secondary (that is, 2^(nd)) message in
    the primary constructor. The primary constructor will instantiate a new `Hello`
    object. Method `sayHello()` will print the concatenated message.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的设置中，我们在主构造函数中包含了一个次要（即第二个）消息。主构造函数将实例化一个新的`Hello`对象。方法`sayHello()`将打印连接的消息。
- en: '**Auxiliary constructors**: In Scala, defining one or more auxiliary constructors
    for a Scala class gives the consumers of the class different ways to create object
    instances. Define the auxiliary constructors as methods in the class with the
    name this. You can define multiple auxiliary constructors, but they must have
    different signatures (parameter lists). Also, each constructor must call one of
    the previously defined constructors.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '**辅助构造函数**：在Scala中，为Scala类定义一个或多个辅助构造函数可以让类的消费者以不同的方式创建对象实例。在类中将辅助构造函数定义为this的方法。您可以定义多个辅助构造函数，但它们必须具有不同的签名（参数列表）。此外，每个构造函数必须调用先前定义的构造函数之一。'
- en: Now let's peep into another important but relatively new concept in Scala, called
    **traits**. We will discuss this in the next section.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下Scala中另一个重要但相对较新的概念，称为**特征**。我们将在下一节中讨论这个问题。
- en: Traits in Scala
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scala中的特征
- en: One of the new features in Scala is a trait, which is very similar to the notion
    of an interface in Java, except that it can also contain concrete methods. Although,
    Java 8 already has support for this. On the other hand, traits are one of the
    new concepts in Scala. But the feature already exists in OOP. So, they look like
    abstract classes, except that they don't have constructors.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Scala中的一个新特性是特征，它与Java中接口的概念非常相似，只是它还可以包含具体方法。尽管Java 8已经支持这一点。另一方面，特征是Scala中的一个新概念。但这个特性已经存在于面向对象编程中。因此，它们看起来像抽象类，只是它们没有构造函数。
- en: A trait syntax
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特征语法
- en: 'You need to use the `trait` keyword in order to declare a trait and it should
    be followed by the trait name and body:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要使用`trait`关键字来声明一个特征，后面应该跟着特征名称和主体：
- en: '[PRE41]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Extending traits
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展特征
- en: 'In order to extend traits or classes, you need to use the `extend` keyword.
    Traits cannot be instantiated because it may contain unimplemented methods. So,
    it''s necessary to implement the abstract members in the trait:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 为了扩展特征或类，您需要使用`extend`关键字。特征不能被实例化，因为它可能包含未实现的方法。因此，必须实现特征中的抽象成员：
- en: '[PRE42]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'A value class is not allowed to extend traits. To permit value classes to extend
    traits, universal traits are introduced, which extends for `Any`. For example,
    suppose that we have the following trait defined:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 不允许值类扩展特征。为了允许值类扩展特征，引入了通用特征，它扩展了`Any`。例如，假设我们已经定义了以下特征：
- en: '[PRE43]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now, to extend the preceding trait in Scala using the universal trait, we follow
    the following code segment:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要使用通用特征在Scala中扩展前面的特征，我们遵循以下代码段：
- en: '[PRE44]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: So, what is the difference between an abstract class and the traits in Scala?
    As you have seen, an abstract class can have constructor parameters, type parameters,
    and multiple parameters. However, a trait in Scala can have only type parameters.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，在Scala中抽象类和特征之间有什么区别呢？正如您所见，Scala中的抽象类可以具有构造参数、类型参数和多个参数。但是，Scala中的特征只能具有类型参数。
- en: A trait is fully interoperable if, and only if, it does not contain any implementation
    code. Furthermore, Scala traits are fully interoperable with Java interfaces in
    Scala 2.12\. Because Java 8 allows method implementations in its interfaces, too.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个特征不包含任何实现代码，那么它才是完全可互操作的。此外，Scala特征在Scala 2.12中与Java接口完全可互操作。因为Java 8也允许在其接口中进行方法实现。
- en: 'There might be other cases for traits as well, for example, an abstract class
    can extend a trait or, if needed, any normal class (including the case classes)
    can extend an existing trait. For example, an abstract class can also extend traits:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 可能还有其他情况适用于特征，例如，抽象类可以扩展特征，或者如果需要，任何普通类（包括case类）都可以扩展现有的特征。例如，抽象类也可以扩展特征：
- en: '[PRE45]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Lastly, a normal Scala class also can extend a Scala trait. Since classes are
    concrete, (that is, instances can be created), the abstract members of the trait
    should be implemented. In the next section, we will discuss the Java interoperability
    of Scala codes. Now let's peep into another important concept in every OOP, called
    **abstract classes**. We will discuss this in the next section.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，普通的Scala类也可以扩展Scala特征。由于类是具体的（即可以创建实例），特征的抽象成员应该被实现。在下一节中，我们将讨论Scala代码的Java互操作性。现在让我们来了解OOP中的另一个重要概念，称为**抽象类**。我们将在下一节中讨论这个问题。
- en: Abstract classes
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象类
- en: An abstract class in Scala can have constructor parameters as well as type parameters.
    An abstract class in Scala is fully interoperable with Java. In other words, it
    is possible to call them from Java code without any intermediate wrappers.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在Scala中，抽象类可以具有构造参数以及类型参数。Scala中的抽象类与Java完全可互操作。换句话说，可以在Java代码中调用它们，而无需任何中间包装器。
- en: 'So, what is the difference between an abstract class and the traits in Scala?
    As you have seen, an abstract class can have constructor parameters, type parameters,
    and multiple parameters. However, a trait in Scala can have only type parameters.
    The following is a simple example of an abstract class:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，在Scala中抽象类和特征之间有什么区别呢？正如您所见，Scala中的抽象类可以具有构造参数、类型参数和多个参数。但是，Scala中的特征只能具有类型参数。以下是抽象类的一个简单示例：
- en: '[PRE46]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In order to extend this class by another one, we need to implement the unimplemented
    methods earlier `getAnimalAge`, `getAnimalGender`, and `getAnimalOrigin`. For
    `getAnimalName`, we can override it or not, since its implementation is already
    there.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 为了通过另一个类扩展这个类，我们需要实现之前未实现的方法`getAnimalAge`，`getAnimalGender`和`getAnimalOrigin`。对于`getAnimalName`，我们可以覆盖它，也可以不覆盖，因为它的实现已经存在。
- en: Abstract classes and the override keyword
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象类和override关键字
- en: 'If you want to override a concrete method from the superclass, the override
    modifier is necessary. However, if you are implementing an abstract method, it
    is not strictly necessary to add the override modifier. Scala uses the `override`
    keyword to override a method from a parent class. For example, suppose you have
    the following abstract class and a method `printContents()` to print your message
    on the console:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要覆盖父类的具体方法，则需要override修饰符。但是，如果要实现抽象方法，则不一定需要添加override修饰符。Scala使用`override`关键字来覆盖父类的方法。例如，假设您有以下抽象类和一个`printContents()`方法来在控制台上打印您的消息：
- en: '[PRE47]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now, add a concrete implementation of the preceding abstract class to print
    the contents on the console as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，添加前面的抽象类的具体实现以在控制台上打印内容，如下所示：
- en: '[PRE48]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Secondly, if you want to create a trait to modify the behavior of the preceding
    concrete class, as follows:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，如果您想创建一个特征来修改前面的具体类的行为，如下所示：
- en: '[PRE49]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'If you look at the preceding code segment carefully, you will find two modifiers
    (that is, abstract and override). Now, with the preceding setting, you can do
    the following to use the preceding class:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您仔细查看前面的代码段，您会发现两个修饰符（即abstract和override）。现在，在前面的设置下，您可以执行以下操作来使用前面的类：
- en: '[PRE50]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In summary, we can add an `override` keyword in front of the method to work
    as expected.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，我们可以在方法前面添加`override`关键字以使其按预期工作。
- en: Case classes in Scala
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scala中的Case类
- en: 'A **case** class is an instantiable class that includes several automatically
    generated methods. It also includes an automatically generated companion object
    with its own automatically generated methods. The basic syntax of a case class
    in Scala is as follows:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '**case**类是一个可实例化的类，其中包括几个自动生成的方法。它还包括一个自动生成的伴生对象，其中包括自己的自动生成的方法。Scala中case类的基本语法如下：'
- en: '[PRE51]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: A case class can be pattern matched, and comes with the following methods already
    implemented the method `hashCode` (location/scope is a class), `apply` (location/scope
    is an object), `copy` (location/scope is a class), `equals` (location/scope is
    a class), `toString` (location/scope is a class), and `unapply` (location/scope
    is an object).
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Case类可以进行模式匹配，并且已经实现了以下方法：`hashCode`方法（位置/范围是类），`apply`方法（位置/范围是对象），`copy`方法（位置/范围是类），`equals`方法（位置/范围是类），`toString`方法（位置/范围是类），和`unapply`方法（位置/范围是对象）。
- en: 'Like a plain class, a case class automatically define, getter methods for the
    constructor arguments. To get a practical insight about the preceding features
    or a case class, let''s see the following code segment:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 与普通类一样，case类自动为构造参数定义getter方法。为了对前面的特性或case类有实际的了解，让我们看下面的代码段：
- en: '[PRE52]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The preceding code produces the following output:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码产生以下输出：
- en: '[PRE53]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'For the REPL and the output of the regular expression matching, if you execute
    the preceding code (except the `Object` and `main` method), you should be able
    to see the more interactive output as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 对于REPL和正则表达式匹配的输出，如果您执行前面的代码（除了`Object`和`main`方法），您应该能够看到更多的交互式输出，如下所示：
- en: '![](img/00373.jpeg)**Figure 2:** Scala REPL for case class'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/00373.jpeg)**图2：** 用于case类的Scala REPL'
- en: Packages and package objects
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包和包对象
- en: 'Just like Java, a package is a special container or object which contains/defines
    a set of objects, classes, and even packages. Every Scala file has the following
    automatically imported:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 就像Java一样，包是一个特殊的容器或对象，其中包含/定义一组对象、类甚至包。每个Scala文件都自动导入以下内容：
- en: '`java.lang._`'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.lang._`'
- en: '`scala._`'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scala._`'
- en: '`scala.Predef._`'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scala.Predef._`'
- en: 'The following is an example for basic imports:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是基本导入的示例：
- en: '[PRE54]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'You can even rename a member while importing, and that''s to avoid a collision
    between packages that have the same member name. This method is also called class
    `alias`:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 您甚至可以在导入时重命名成员，这是为了避免具有相同成员名称的包之间的冲突。这种方法也被称为类`别名`：
- en: '[PRE55]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'As mentioned in [Chapter 1](part0022.html#KVCC1-21aec46d8593429cacea59dbdcd64e1c),
    *Introduction to Scala*, you can also import all the members of a package, but
    some members are also called **member hiding**:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在[第1章](part0022.html#KVCC1-21aec46d8593429cacea59dbdcd64e1c)中所述，《Scala简介》，您还可以导入包的所有成员，但有些成员也被称为**成员隐藏**：
- en: '[PRE56]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'If you tried this in the REPL, it just tells the compiler the full, canonical
    name of the defined class or object:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在REPL中尝试了这个，它只是告诉编译器定义的类或对象的完整规范名称：
- en: '[PRE57]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: You can even use the style of defining packages in curly braces. You can have
    a single package and nested package means package within a package. For example,
    the following code segment defines a single package named `singlePackage` consisting
    of a single class named `Test`. The `Test` class, on the other hand, consists
    of a single method named `toString()`.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 您甚至可以使用大括号定义包的样式。您可以有一个单一的包和嵌套包，即包中的包。例如，以下代码段定义了一个名为`singlePackage`的单一包，其中包含一个名为`Test`的单一类。另一方面，`Test`类包含一个名为`toString()`的单一方法。
- en: '[PRE58]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Now, you can make the packaging nested. In other words, you can have more than
    one package in a nested way. For example, for the below case, we have two packages,
    namely `NestParentPack` and the `NestChildPack`, each containing their own classes.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以将包进行嵌套。换句话说，您可以以嵌套的方式拥有多个包。例如，对于下面的情况，我们有两个包，分别是`NestParentPack`和`NestChildPack`，每个包都包含自己的类。
- en: '[PRE59]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Let''s create a new object (let''s name it `MainProgram`), in which we''ll
    invoke the methods and classes we just defined:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新对象（我们将其命名为`MainProgram`），在其中我们将调用刚刚定义的方法和类：
- en: '[PRE60]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: You will find more examples on the internet that describe sophisticated use
    cases of packages and package objects. In the next section, we will discuss the
    Java interoperability of Scala codes.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在互联网上找到更多的例子，描述了包和包对象的复杂用例。在下一节中，我们将讨论Scala代码的Java互操作性。
- en: Java interoperability
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java互操作性
- en: Java is one of the most popular languages, and many programmers learn Java programming
    as their first entrance to the programming world. The popularity of Java has increased
    since its initial release back in 1995\. Java has gained in popularity for many
    reasons. One of them is the design of its platform, such that any Java code will
    be compiled to bytecode, which in turn runs on the JVM. With this magnificent
    feature, Java language to be being written once and run anywhere. So, Java is
    a cross-platform language.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: Java是最流行的语言之一，许多程序员将Java编程作为他们进入编程世界的第一步。自1995年首次发布以来，Java的受欢迎程度一直在增加。Java之所以受欢迎有很多原因。其中之一是其平台的设计，使得任何Java代码都将被编译为字节码，然后在JVM上运行。有了这一绝妙的特性，Java语言可以编写一次，然后在任何地方运行。因此，Java是一种跨平台语言。
- en: Also, Java has lots of support from its community and lots of packages that
    will help you get your idea up and running with the help of these packages. Then
    comes Scala, which has lots of features that Java lacks, such as type inference
    and optional semicolon, immutable collections built right into Scala core, and
    lots more features (addressed in [Chapter 1](part0022.html#KVCC1-21aec46d8593429cacea59dbdcd64e1c),
    *Introduction to Scala*). Scala also runs on the JVM, just like Java.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Java得到了来自其社区的大量支持和许多包的支持，这些包将帮助您借助这些包实现您的想法。然后是Scala，它具有许多Java所缺乏的特性，例如类型推断和可选的分号，不可变集合直接内置到Scala核心中，以及更多功能（在[第1章](part0022.html#KVCC1-21aec46d8593429cacea59dbdcd64e1c)中介绍，《Scala简介》）。Scala也像Java一样在JVM上运行。
- en: '**Semicolon in Scala:** Semicolons are exactly optional, and they are required
    when more lines of code should be written on a single line. That''s probably the
    reason why the compiler doesn''t complain if a semicolon is put at the end of
    a line: it is considered a piece of code followed by an empty piece of code that,
    coincidentally, lives on the same line.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '**Scala中的分号：** 分号是完全可选的，当需要在一行上编写多行代码时才需要。这可能是为什么编译器不会抱怨如果在行尾放上一个分号的原因：它被认为是一个代码片段，后面跟着一个空的代码片段，巧合的是，它们都在同一行上。'
- en: 'As you can see that both Scala and Java run on the JVM, it makes sense to use
    them simultaneously in the same program without complaints from the compiler.
    Let''s demonstrate this with an example. Consider the following Java code:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，Scala和Java都在JVM上运行，因此在同一个程序中同时使用它们是有意义的，而且编译器也不会有任何投诉。让我们通过一个示例来演示这一点。考虑以下Java代码：
- en: '[PRE61]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'In order to write the same code in Scala, you can make use of Java packages.
    Let''s translate the previous example into Scala with the help of using Java collections
    such as `ArrayList`:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在Scala中编写相同的代码，您可以利用Java包。让我们借助使用Java集合（如`ArrayList`）将前面的示例翻译成Scala：
- en: '[PRE62]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The previous mix applies for the standard packages of Java, but you want to
    use libraries that aren't packaged with the standard libraries of Java, or even
    want to use your own classes. Then, you need to make sure that they lie in the
    classpath.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的混合适用于Java的标准包，但是如果您想使用未打包在Java标准库中的库，甚至想使用自己的类。那么，您需要确保它们位于类路径中。
- en: Pattern matching
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式匹配
- en: 'One of the widely used features of Scala is pattern matching. Each pattern
    match has a set of alternatives, each of them starting with the case keyword.
    Each alternative has a pattern and expression(s), which will be evaluated if the
    pattern matches and the arrow symbol `=>` separates pattern(s) from expression(s).
    The following is an example which demonstrates how to match against an integer:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: Scala的一个广泛使用的特性是模式匹配。每个模式匹配都有一组备选项，每个备选项都以关键字`case`开头。每个备选项都有一个模式和表达式，如果模式匹配成功，箭头符号`=>`将模式与表达式分开。以下是一个示例，演示如何匹配整数：
- en: '[PRE63]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'You can run the preceding program by saving this file in `PatternMatchingDemo1.scala`
    and then using the following commands to run it. Just use the following command:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过将此文件保存为`PatternMatchingDemo1.scala`并使用以下命令来运行前面的程序。只需使用以下命令：
- en: '[PRE64]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'You will get the following output:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 您将获得以下输出：
- en: '[PRE65]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The cases statements are used as a function that maps integers to strings.
    The following is another example which matches against different types:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: case语句用作将整数映射到字符串的函数。以下是另一个示例，用于匹配不同类型：
- en: '[PRE66]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'You can run this example by doing the same for the example earlier and will
    get the following output:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过对之前的示例执行相同的操作来运行此示例，并将获得以下输出：
- en: '[PRE67]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Pattern matching is a mechanism for checking a value against a pattern. A successful
    match can also deconstruct a value into its constituent parts. It is a more powerful
    version of the switch statement in Java, and it can likewise be used in place
    of a series of `if...else` statements. You can find more on pattern matching by
    referring to the official docs of Scala (URL: [http://www.scala-lang.org/files/archive/spec/2.11/08-pattern-matching.html](http://www.scala-lang.org/files/archive/spec/2.11/08-pattern-matching.html)).'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 模式匹配是一种检查值与模式匹配的机制。成功的匹配还可以将值解构为其组成部分。它是Java中switch语句的更强大版本，也可以用来代替一系列的`if...else`语句。您可以通过参考Scala的官方文档（URL：[http://www.scala-lang.org/files/archive/spec/2.11/08-pattern-matching.html](http://www.scala-lang.org/files/archive/spec/2.11/08-pattern-matching.html)）了解更多关于模式匹配的内容。
- en: In the next section, we will discuss an important feature in Scala that enables
    us a value that can be passed automatically, so to speak, or a conversion from
    one type to another that is made automatically.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论Scala中的一个重要特性，它使我们能够自动传递一个值，或者说自动进行一种类型到另一种类型的转换。
- en: Implicit in Scala
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scala中的隐式
- en: 'Implicit is another exciting and powerful feature introduced by Scala, and
    it can refer to two different things:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 隐式是Scala引入的另一个令人兴奋和强大的特性，它可以指两种不同的东西：
- en: A value that can be automatically passed
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以自动传递的值
- en: Automatic conversion from one type to another
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从一种类型自动转换为另一种类型
- en: They can be used for extending the capabilities of a class
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以用于扩展类的功能
- en: 'Actual automatic conversion can be accomplished with implicit def, as seen
    in the following example (supposing you are using the Scala REPL):'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的自动转换可以通过隐式def完成，如下面的示例所示（假设您正在使用Scala REPL）：
- en: '[PRE68]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Now, having the preceding code in my scope, it''s possible for me to do something
    like this:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我的范围内有了前面的代码，我可以做类似这样的事情：
- en: '[PRE69]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Even if one of the parameters passed to `add()` is a `String` (and `add()` would
    require you to provide two integers), having the implicit conversion in scope
    allows the compiler to automatically convert from `String` to `Int`. Obviously
    enough, this feature could be quite dangerous, because it makes the code less
    readable; moreover, once an implicit conversion is defined, it's not easy to tell
    the compiler when to use it and when to avoid using it.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 即使传递给`add()`的参数之一是`String`（并且`add()`需要您提供两个整数），在范围内具有隐式转换允许编译器自动从`String`转换为`Int`。显然，这个特性可能非常危险，因为它使代码变得不太可读；而且，一旦定义了隐式转换，就不容易告诉编译器何时使用它，何时避免使用它。
- en: 'The first type of implicit is a value that can automatically pass an implicit
    parameter. These parameters are passed while calling a method like any normal
    parameter, but Scala''s compiler tries to fill them automatically. If Scala''s
    compiler fails to automatically fill these parameters, it will complain. The following
    is an example to demonstrate the first type of implicit:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种隐式是可以自动传递隐式参数的值。这些参数在调用方法时像任何普通参数一样传递，但Scala的编译器会尝试自动填充它们。如果Scala的编译器无法自动填充这些参数，它会报错。以下是演示第一种隐式的示例：
- en: '[PRE70]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'By this, you are asking the compiler to look for an implicit value for `num`,
    if not provided during calling the method. You can define implicit value to the
    compiler like this:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，您要求编译器查找`num`的隐式值，如果在调用方法时未提供。您可以像这样向编译器定义隐式值：
- en: '[PRE71]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Then, we can simply call the function like this:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以简单地这样调用函数：
- en: '[PRE72]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Here, no parameter is passed, so Scala''s compiler will look for implicit value,
    which is `2`, and then return `4` as the output of the method calling. However,
    a lot of other options have evolved a questions such as:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，没有传递参数，因此Scala的编译器将寻找隐式值，即`2`，然后返回方法调用的输出`4`。然而，还有很多其他选项，引发了一些问题，比如：
- en: 'Can a method contain both an explicit and an implicit parameter? The answer
    is YES. Let''s see an example on Scala REPL:'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个方法可以同时包含显式参数和隐式参数吗？答案是可以。让我们在Scala REPL上看一个例子：
- en: '[PRE73]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Can a method contain more than one implicit parameter? The answer is YES. Let''s
    see an example on Scala REPL:'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个方法可以包含多个隐式参数吗？答案是可以。让我们在Scala REPL上看一个例子：
- en: '[PRE74]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Can an implicit parameter be explicitly provided? The answer is YES. Let''s
    see an example on Scala REPL:'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐式参数可以显式提供吗？答案是可以。让我们在Scala REPL上看一个例子：
- en: '[PRE75]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: What happens if more implicits are contained in the same scope and how are implicits
    resolved? Is there any order to how implicits are resolved? To get to know the
    answer to these two questions, refer to this URL at [http://stackoverflow.com/questions/9530893/good-example-of-implicit-parameter-in-scala](http://stackoverflow.com/questions/9530893/good-example-of-implicit-parameter-in-scala).
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 如果同一作用域中包含更多的隐式参数，会发生什么，隐式参数是如何解析的？隐式参数的解析顺序是否有任何顺序？要了解这两个问题的答案，请参考此URL：[http://stackoverflow.com/questions/9530893/good-example-of-implicit-parameter-in-scala](http://stackoverflow.com/questions/9530893/good-example-of-implicit-parameter-in-scala)。
- en: In the next section, we will discuss generics in Scala with some examples.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论Scala中的泛型，并提供一些示例。
- en: Generic in Scala
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scala中的泛型
- en: Generic classes are classes which take a type as a parameter. They are particularly
    useful for collection classes. Generic classes can be used in everyday data structure
    implementation, such as stack, queue, linked list, and so on. We will see some
    examples.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型类是以类型作为参数的类。它们对于集合类特别有用。泛型类可以用于日常数据结构实现，如栈、队列、链表等。我们将看到一些示例。
- en: Defining a generic class
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义一个泛型类
- en: 'Generic classes take a type as a parameter within square brackets `[]`. One
    convention is to use the letter `A` as a type parameter identifier, though any
    parameter name may be used. Let''s see a minimal example on Scala REPL, as follows:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 通用类在方括号`[]`内以类型作为参数。一个惯例是使用字母`A`作为类型参数标识符，尽管可以使用任何参数名称。让我们看一个Scala REPL的最小示例，如下所示：
- en: '[PRE76]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The preceding implementation of a `Stack` class takes any type A as a parameter.
    This means the underlying list, `var elements: List[A] = Nil` can only store elements
    of type `A`. The procedure def push only accepts objects of type `A` (note: `elements
    = x :: elements` reassigns elements to a new list created by prepending `x` to
    the current elements). Let''s see an example of how to use the preceding class
    to implement a stack:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '前面的`Stack`类的实现将任何类型A作为参数。这意味着底层列表`var elements: List[A] = Nil`只能存储类型为`A`的元素。过程def
    push只接受类型为`A`的对象（注意：`elements = x :: elements`重新分配元素到一个新列表，该列表由将`x`前置到当前元素创建）。让我们看一个如何使用前面的类来实现一个栈的示例：'
- en: '[PRE77]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The output is as follows:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE78]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The second use case could be implementing a linked list too. For instance,
    if Scala didn''t have a linked-list class and you wanted to write your own, you
    could write the basic functionality like this:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个用例可能也是实现一个链表。例如，如果Scala没有一个链表类，而您想要编写自己的链表，您可以像这样编写基本功能：
- en: '[PRE79]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Now, let''s see how could we use the preceding linked list implementation:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何使用前面的链表实现：
- en: '[PRE80]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The output is as follows:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE81]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: In summary, at the basic level, creating a generic class in Scala is just like
    creating a generic class in Java, with the exception of the brackets. Well! So
    far we have gotten to know some essential features to get started with an object-oriented
    programming language, Scala.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，在Scala的基本级别上，创建一个泛型类就像在Java中创建一个泛型类一样，只是方括号的例外。好了！到目前为止，我们已经了解了一些基本功能，以便开始使用面向对象的编程语言Scala。
- en: Although, we have not covered some other aspects, however, we still think that
    you can continue working. In [Chapter 1](part0022.html#KVCC1-21aec46d8593429cacea59dbdcd64e1c),
    *Introduction to Scala*, we discussed what the available editors for Scala are.
    In the next section, we will see how to set up your build environment. More specifically,
    three build systems, like Maven, SBT, and Gradle will be covered.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们还没有涵盖一些其他方面，但我们仍然认为你可以继续工作。在[第1章](part0022.html#KVCC1-21aec46d8593429cacea59dbdcd64e1c)
    *Scala简介*中，我们讨论了Scala的可用编辑器。在接下来的部分，我们将看到如何设置构建环境。具体来说，我们将涵盖三种构建系统，如Maven、SBT和Gradle。
- en: SBT and other build systems
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SBT和其他构建系统
- en: It's necessary to use a build tool for any enterprise software project. There
    are lots of build tools that you can choose from, such as Maven, Gradle, Ant,
    and SBT. A good choice of build tool is the one which will let you focus on coding
    rather than compilation complexities.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何企业软件项目，使用构建工具是必要的。有许多构建工具可供选择，例如Maven、Gradle、Ant和SBT。一个好的构建工具选择是让您专注于编码而不是编译复杂性的工具。
- en: Build with SBT
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SBT构建
- en: 'Here, we are going to give a brief introduction to SBT. Before going any further,
    you need to install SBT using the installation method that fits your system from
    their official installations methods (URL: [http://www.scala-sbt.org/release/docs/Setup.html](http://www.scala-sbt.org/release/docs/Setup.html)).'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将简要介绍SBT。在继续之前，您需要使用官方安装方法（URL：[http://www.scala-sbt.org/release/docs/Setup.html](http://www.scala-sbt.org/release/docs/Setup.html)）安装SBT。
- en: 'So, let''s begin with SBT to demonstrate the use of SBT in a terminal. For
    this build tool tutorial, we assume that your source code files are in a directory.
    You need to do the following:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们从SBT开始，在终端中演示SBT的使用。对于这个构建工具教程，我们假设您的源代码文件在一个目录中。您需要执行以下操作：
- en: Open the terminal and change path to that directory by using `cd`,
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并使用`cd`命令将路径更改为该目录，
- en: Create a build file called `build.sbt`.
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`build.sbt`的构建文件。
- en: 'Then, populate that build file with the following lines:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用以下行填充该构建文件：
- en: '[PRE82]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Let''s see the meaning of these lines:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这些行的含义：
- en: The `name` defines a name for your project. This name will be used in the generated
    jar files.
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`定义了项目的名称。这个名称将在生成的jar文件中使用。'
- en: The `organization` is a namespace that's used to prevent collisions between
    projects that have similar names.
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`organization`是一个命名空间，用于防止具有相似名称的项目之间的冲突。'
- en: '`scalaVersion` sets the version of Scala that you want to build against.'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scalaVersion`设置您要构建的Scala版本。'
- en: '`Version` specifies the current build version of your project and you can use
    `-SNAPSHOT` for versions that have not been released yet.'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Version`指定了项目的当前构建版本，您可以使用`-SNAPSHOT`来表示尚未发布的版本。'
- en: After creating this build file, you need to `run` the `sbt` command in your
    terminal and then a prompt starting with `>` will be opened for you. In this prompt,
    you can type `compile` in order to compile your Scala or Java source files in
    your code. Also, you can enter the command in the SBT prompt in order to run the
    program if it's runnable. Or you can use the package command in SBT prompt in
    order to generate a `.jar` file, which will exist in a subdirectory called `target`.
    To read more about SBT and more sophisticated examples, you can refer to the official
    site of SBT.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 创建此构建文件后，您需要在终端中运行`sbt`命令，然后会为您打开一个以`>`开头的提示符。在此提示符中，您可以输入`compile`以编译您的Scala或Java源文件。此外，您还可以在SBT提示符中输入命令以运行可运行的程序。或者您可以使用SBT提示符中的package命令生成一个`.jar`文件，该文件将存在一个名为`target`的子目录中。要了解有关SBT和更复杂示例的更多信息，您可以参考SBT的官方网站。
- en: Maven with Eclipse
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Eclipse中的Maven
- en: Using Eclipse as Scala IDE with Maven as a build tool is very easy and straightforward.
    In this section, we will demonstrate with screenshots how to use Scala with Eclipse
    and Maven. To be able to use Maven in Eclipse, you need to install its plugin,
    which will be different across different versions of Eclipse. After installing
    the Maven plugin, you will find that it doesn't support Scala directly. What we
    need to do in order to get this Maven plugin to support Scala projects is to install
    a connector called **m2eclipse-scala**.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在Eclipse中使用Maven作为构建工具作为Scala IDE非常容易和直接。在本节中，我们将通过截图演示如何在Eclipse和Maven中使用Scala。要在Eclipse中使用Maven，您需要安装其插件，这将在不同版本的Eclipse中有所不同。安装Maven插件后，您会发现它不直接支持Scala。为了使Maven插件支持Scala项目，我们需要安装一个名为m2eclipse-scala的连接器。
- en: 'If you paste this URL ([http://alchim31.free.fr/m2e-scala/update-site](http://alchim31.free.fr/m2e-scala/update-site)
    ) while trying to add new software to Eclipse, you will find that Eclipse understands
    the URL and suggests some plugins for you to add:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在尝试向Eclipse添加新软件时粘贴此URL（[http://alchim31.free.fr/m2e-scala/update-site](http://alchim31.free.fr/m2e-scala/update-site)），您会发现Eclipse理解该URL并建议您添加一些插件：
- en: '![](img/00184.jpeg)**Figure 4:** Installing Maven plugins on Eclipse to enable
    Maven build'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/00184.jpeg)**图4：**在Eclipse上安装Maven插件以启用Maven构建'
- en: 'After installing Maven and the connector for Scala support, we are going to
    create a new Scala Maven project. To create a new Scala Maven project, you need
    to navigate to New | Project | Other and then choose Maven Project. After this,
    select the option that has net.alchim31.maven as Group Id:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Maven和Scala支持连接器后，我们将创建一个新的Scala Maven项目。要创建一个新的Scala Maven项目，您需要导航到新建 | 项目
    | 其他，然后选择Maven项目。之后，选择net.alchim31.maven作为Group Id的选项：
- en: '![](img/00186.jpeg)**Figure 5:** Creating a Scala Maven project on Eclipse'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/00186.jpeg)**图5：**在Eclipse上创建一个Scala Maven项目'
- en: After this selection, you need to follow the wizard and enter the required values,
    such as Group Id, and so on. Then, hit Finish and, with this, you have created
    your first Scala project with Maven support in the workspace. In the project structure,
    you will find something called `pom.xml` where you can add all your dependencies
    and other things.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 选择后，您需要按照向导输入所需的值，如Group Id等。然后，点击完成，这样就在工作区中创建了具有Maven支持的第一个Scala项目。在项目结构中，您会发现一个名为`pom.xml`的文件，您可以在其中添加所有依赖项和其他内容。
- en: For more information about how to add dependencies to your project, you can
    refer to this link at [http://docs.scala-lang.org/tutorials/scala-with-maven.html](http://docs.scala-lang.org/tutorials/scala-with-maven.html).
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 有关如何向项目添加依赖项的更多信息，请参考此链接：[http://docs.scala-lang.org/tutorials/scala-with-maven.html](http://docs.scala-lang.org/tutorials/scala-with-maven.html)。
- en: As a continuation of this section, we will show you how to build your Spark
    application written in Scala in the upcoming chapter.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 作为本节的延续，我们将在接下来的章节中展示如何构建用Scala编写的Spark应用程序。
- en: Gradle with Eclipse
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Eclipse中的Gradle
- en: Gradle Inc. provides the Gradle tools and plugins for the Eclipse IDE. This
    tool allows you to create and import Gradle enabled projects into the Eclipse
    IDE. In addition, it allows you to run Gradle tasks and monitor the execution
    of the tasks.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle Inc.为Eclipse IDE提供了Gradle工具和插件。该工具允许您在Eclipse IDE中创建和导入启用Gradle的项目。此外，它允许您运行Gradle任务并监视任务的执行。
- en: The Eclipse project itself is called **Buildship**. The source code of this
    project is available on GitHub at [https://github.com/eclipse/Buildship](https://github.com/eclipse/Buildship).
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: Eclipse项目本身称为**Buildship**。该项目的源代码可在GitHub上找到：[https://github.com/eclipse/Buildship](https://github.com/eclipse/Buildship)。
- en: 'There are two options for installing Gradle plugins on Eclipse. These are as
    follows:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在Eclipse上安装Gradle插件有两个选项。如下所示：
- en: Via the Eclipse Marketplace
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过Eclipse Marketplace
- en: Via the Eclipse Update Manager
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过Eclipse更新管理器
- en: 'First, let''s see how to install Buildship plugins for Grade build on Eclipse
    using Marketplace: Eclipse | Help | Eclipse Marketplace:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看如何在Eclipse上使用Marketplace安装Grade构建的Buildship插件：Eclipse | 帮助 | Eclipse
    Marketplace：
- en: '![](img/00190.jpeg)**Figure 6:** Installing Buildship plugins for Grade build
    on Eclipse using Marketplace'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/00190.jpeg)**图6：**在Eclipse上使用Marketplace安装Grade构建的Buildship插件'
- en: 'The second option for installing the Gradle plugins on Eclipse is from the
    Help | Install New Software... menu path to install the Gradle tooling as shown
    in the following figure:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在Eclipse上安装Gradle插件的第二个选项是从帮助 | 安装新软件...菜单路径安装Gradle工具，如下图所示：
- en: '![](img/00192.jpeg)**Figure 7:** Installing Buildship plugins for Grade build
    on Eclipse using install new software'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/00192.jpeg)**图7：**在Eclipse上使用安装新软件安装Grade构建的Buildship插件'
- en: 'For example, the following URL can be used for Eclipse 4.6 (Neon) release:
    [http://download.eclipse.org/releases/neon](http://download.eclipse.org/releases/neon).'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，可以使用以下URL来下载Eclipse 4.6（Neon）版本：[http://download.eclipse.org/releases/neon](http://download.eclipse.org/releases/neon)。
- en: 'Once you have installed the Gradle plugins by following any one of the methods
    described earlier, Eclipse Gradle helps you to set up Scala based Gradle projects:
    File | New | Project | Select a wizard | Gradle | Gradle Project.'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您按照之前描述的任一方法安装了Gradle插件，Eclipse Gradle将帮助您设置基于Scala的Gradle项目：文件|新建|项目|选择向导|Gradle|Gradle项目。
- en: '**![](img/00196.jpeg)****Figure 8:** Creating a Gradle project on Eclipse'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '**![](img/00196.jpeg)****图8：**在Eclipse上创建Gradle项目'
- en: 'Now, if you press Next>, you will get the following wizard to specify the name
    of the project for your purpose:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您按下Next>，您将获得以下向导，以指定项目名称以满足您的目的：
- en: '**![](img/00198.jpeg)****Figure 9:** Creating a Gradle project on Eclipse specifying
    the project name'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '**![](img/00198.jpeg)****图9：**在Eclipse上创建Gradle项目并指定项目名称'
- en: 'Finally, press the Finish button to create the project. Pressing the Finish
    button essentially triggers the Gradle `init --type java-library` command and
    imports the project. However, if you would like to get a preview of the configuration
    before the it is created, press Next > to get the following wizard:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，按下Finish按钮创建项目。按下Finish按钮实质上触发了Gradle `init --type java-library`命令并导入了项目。然而，如果您想在创建之前预览配置，请按Next>以获得以下向导：
- en: '![](img/00050.jpeg)**Figure 10:** Preview of the configuration before it is
    created'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/00050.jpeg)**图10：**在创建之前预览配置'
- en: Finally, you will see the following project structure on Eclipse. However, we
    will see how to build Spark applications using Maven, SBT, and Gradle in a later
    chapter. The reason is that, before starting your project, it is more important
    to learn Scala and Spark together.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您将在Eclipse上看到以下项目结构。然而，我们将在后面的章节中看到如何使用Maven、SBT和Gradle构建Spark应用程序。原因是，在开始项目之前，更重要的是学习Scala和Spark。
- en: '![](img/00058.jpeg)**Figure 11:** The project structure on Eclipse using Gradle'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/00058.jpeg)**图11：**在Eclipse上使用Gradle的项目结构'
- en: In this section, we have seen three build systems, including SBT, Maven, and
    Gradle. However, throughout the chapters, I will try to mainly use Maven because
    of its simplicity and better code compatibility. However, in later chapters, we
    will use SBT to create JARS from your Spark application.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们已经看到了三种构建系统，包括SBT、Maven和Gradle。然而，在接下来的章节中，我将尽量主要使用Maven，因为它简单且代码兼容性更好。然而，在后面的章节中，我们将使用SBT来创建您的Spark应用程序的JARS。
- en: Summary
  id: totrans-356
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Structuring code in a sane way, with classes and traits, enhances the reusability
    of your code with generics, and creates a project with standard and widespread
    tools. Improve on the basics to know how Scala implements the OO paradigm to allow
    the building of modular software systems. In this chapter, we discussed the basic
    object-oriented features in Scala, such as classes and objects, packages and package
    objects, traits, and trait linearization, Java interoperability, pattern matching,
    implicit, and generics. Finally, we discussed SBT and other build systems that
    will be needed to build our Spark application on Eclipse or any other IDEs.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 以合理的方式构建代码，使用类和特征增强了您的代码的可重用性，使用泛型创建了一个具有标准和广泛工具的项目。改进基础知识，了解Scala如何实现面向对象范式，以允许构建模块化软件系统。在本章中，我们讨论了Scala中的基本面向对象特性，如类和对象、包和包对象、特征和特征线性化、Java互操作性、模式匹配、隐式和泛型。最后，我们讨论了SBT和其他构建系统，这些系统将需要在Eclipse或其他IDE上构建我们的Spark应用程序。
- en: In the next chapter, we will discuss what functional programming is and how
    Scala supports it. We will get to know why it matters and what the advantages
    of using functional concepts are. Continuing, you will learn pure functions, higher-order
    functions, Scala collections basics (map, flatMap, filter), for - comprehensions,
    monadic processing, and for extending higher-order functions outside of collections
    using the standard library of Scala.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论函数式编程是什么，以及Scala如何支持它。我们将了解为什么它很重要以及使用函数式概念的优势是什么。接下来，您将学习纯函数、高阶函数、Scala集合基础（map、flatMap、filter）、for
    - comprehensions、单子处理，以及使用Scala标准库在集合之外扩展高阶函数。
