- en: Phylogenetic Analysis and Visualization
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 系统发育分析与可视化
- en: The comparison of sequences in order to infer evolutionary relationships is
    a fundamental technique of bioinformatics. It has a long history in R, too. There
    are many packages outside of Bioconductor for evolutionary analysis. In the recipes
    in this chapter, we will take a good look at how to work with tree formats from
    a variety of sources. A key focus will be how to manipulate trees to focus on
    particular parts and work with visualizations based on the new `ggplot`-based
    tree visualization packages, and the latter's usefulness in terms of viewing and
    annotating large trees.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 比较序列以推断进化关系是生物信息学中的一项基本技术。这项技术在R中也有着悠久的历史。除了Bioconductor之外，还有许多用于进化分析的包。在本章的食谱中，我们将详细研究如何处理来自不同来源的树形格式。重点将放在如何操作树形结构，聚焦于特定部分，并使用基于新的`ggplot`的树形可视化包进行可视化，这对于查看和注释大型树形结构特别有用。
- en: 'The following recipes will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下食谱：
- en: Reading and writing varied tree formats with ape and treeio
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用ape和treeio读取和写入各种树形格式
- en: Visualizing trees of many genes quickly with ggtree
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用ggtree快速可视化多基因树
- en: Quantifying distances between trees with treespace
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用treespace量化树之间的距离
- en: Extracting and working with subtrees using ape
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用ape提取和处理子树
- en: Creating dot plots for alignment visualization
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为对齐可视化创建点图
- en: Reconstructing trees from alignments using phangorn
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用phangorn从比对中重建树形
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The sample data you'll need is available from this book's GitHub repository
    at [https://github.com/danmaclean/R_Bioinformatics_Cookbook](https://github.com/danmaclean/R_Bioinformatics_Cookbook)[.](https://github.com/danmaclean/R_Bioinformatics_Cookbook) If
    you want to use the code examples as they are written, then you will need to make
    sure that this data is located in a subdirectory of whatever your working directory
    is.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要的示例数据可以从本书的GitHub仓库获得，链接是[https://github.com/danmaclean/R_Bioinformatics_Cookbook](https://github.com/danmaclean/R_Bioinformatics_Cookbook)。如果你想按照代码示例直接使用这些数据，请确保这些数据位于你工作目录的一个子目录中。
- en: 'Here are the R packages that you''ll need. The majority of these will install
    with `install.packages()`; others are a little more complicated:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是你需要的R包。大多数包可以通过`install.packages()`进行安装；其他的则稍微复杂一些：
- en: '`ape`'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ape`'
- en: '`adegraphics`'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`adegraphics`'
- en: '`Bioconductor:`'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Bioconductor:`'
- en: '`Biostrings`'
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Biostrings`'
- en: '`ggtree`'
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ggtree`'
- en: '`treeio`'
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`treeio`'
- en: '`msa`'
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`msa`'
- en: '`devtools`'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`devtools`'
- en: '`dotplot`'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dotplot`'
- en: '`ggplot2`'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ggplot2`'
- en: '`phangorn`'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`phangorn`'
- en: '`treespace`'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`treespace`'
- en: '`Bioconductor` is huge and has its own installation manager. You can install
    it with the following code:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`Bioconductor` 非常庞大，并且有自己的安装管理器。你可以使用以下代码进行安装：'
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Further information is available at [https://www.bioconductor.org/install/](https://www.bioconductor.org/install/).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息请参见[https://www.bioconductor.org/install/](https://www.bioconductor.org/install/)。
- en: Normally, in R, a user will load a library and use the functions directly by
    name. This is great in interactive sessions, but it can cause confusion when many
    packages are loaded. To clarify which package and function I'm using at a given
    moment, I will occasionally use the `packageName::functionName()` convention.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在R中，用户会加载一个库并直接按名称使用其中的函数。这在交互式会话中非常方便，但当加载了许多包时，可能会造成混淆。为了明确在某个时刻我正在使用哪个包和函数，我会偶尔使用`packageName::functionName()`的约定。
- en: 'Sometimes, in the middle of a recipe, I''ll interrupt the code so that you
    can see some intermediate output or the structure of an object that''s important
    to understand. Whenever that happens, you''ll see a code block where each line
    begins with `##` (double hash) symbols. Consider the following command:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，在食谱的中途，我会中断代码，这样你就能看到一些中间输出或一个重要的对象结构，帮助理解。每当这种情况发生时，你会看到一个代码块，每行都以`##`（双哈希）符号开头。请看以下命令：
- en: '`letters[1:5]`'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`letters[1:5]`'
- en: 'This will give us the following output:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给我们带来以下输出：
- en: '`## a b c d e`'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`## a b c d e`'
- en: Note that the output lines are prefixed with `##`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，输出行的前面会有`##`作为前缀。
- en: Reading and writing varied tree formats with ape and treeio
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ape和treeio读取和写入各种树形格式
- en: Phylogenetic analysis is a cornerstone of biology and bioinformatics. The programs
    are diverse and complex, the computations are long-running, and the datasets are
    often large. Many programs are standalone and many have proprietary input and
    output formats. This has created a very complex ecosystem that we must navigate
    when dealing with phylogenetic data, meaning that, often, the simplest strategy
    is to use combinations of tools to load, convert, and save the results of analyses
    in order to be able to use them in different packages. In this recipe, we'll look
    at dealing with phylogenetic tree data in R. To date, R support for the wide range
    of tree formats is restricted, but a few core packages have sufficient standardized
    objects such that workflows can focus on a few types and conversion to those types
    is streamlined. We'll look at using the `ape` and `treeio` packages to get tree
    data into and out of R.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 系统发育分析是生物学和生物信息学的基石。相关程序种类繁多且复杂，计算耗时，数据集通常庞大。许多程序是独立运行的，且拥有专有的输入和输出格式。这形成了一个复杂的生态系统，我们在处理系统发育数据时必须应对，意味着通常最简单的策略是使用多种工具组合来加载、转换并保存分析结果，以便能够在不同的软件包中使用它们。在这个操作中，我们将探讨如何在R中处理系统发育树数据。迄今为止，R对各种树格式的支持较为有限，但一些核心包具有足够标准化的对象，工作流可以集中在少数几种类型上，且转换为这些类型的过程已经简化。我们将使用`ape`和`treeio`包来导入和导出树数据。
- en: Getting ready
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this section, we'll need the tree and phylogenetic information in `datasets/ch4/` from
    the book's data repository, specifically the `mammal_tree.nwk` and `mammal_tree.nexus` files,
    which are Newick and Nexus format trees of a mammal phylogeny (you can see brief
    descriptions of these file types in this book's Appendix). We'll need `beast_mcc.tree`, which
    is a tree file from a run of BEAST, and `RAxML_bipartitionsBranchLabels.H3`, which
    is an RAxML output file. Both of these files are taken from the extensive data
    provided with the `treeio` package. We'll require the Bioconductor package, `treeio`,
    and the `ape` package.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本节内容，我们需要从本书数据仓库中的`datasets/ch4/`文件夹获取树和系统发育信息，特别是`mammal_tree.nwk`和`mammal_tree.nexus`文件，它们分别是哺乳动物系统发育树的Newick格式和Nexus格式（你可以在本书的附录中查看这些文件格式的简要描述）。我们还需要`beast_mcc.tree`，这是BEAST运行的树文件，和`RAxML_bipartitionsBranchLabels.H3`，它是RAxML的输出文件。这两个文件来自`treeio`包提供的大量数据。我们还需要Bioconductor包`treeio`和`ape`包。
- en: How to do it...
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'Reading and writing tree formats with `ape` and `treeio` can be executed using
    the following steps:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ape`和`treeio`读取和写入树格式的步骤如下：
- en: 'Load the `ape` library and load in trees:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载`ape`库并加载树数据：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Load the `treeio` library and load in BEAST/RAxML output:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载`treeio`库并加载BEAST/RAxML输出：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Check the object types that the different functions return:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查不同函数返回的对象类型：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Convert `tidytree` to `phylo`, and vice versa:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`tidytree`转换为`phylo`，反之亦然：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Write output files using the following code:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码编写输出文件：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How it works...
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In *Step 1*, we make use of very straightforward loading functions from `ape`—we
    use the `read.tree()` and `read.nexus()` functions, which can read the generic
    format trees. In *Step 2*, we repeat this using the specific format functions
    from `treeio` for BEAST and RaXML output. *Step 3* simply confirms the object
    types that the function returns; note that `ape` gives `phylo` objects, while `treeio` gives
    `treedata` objects. The two are interconverted using `as.phylo()` and `as.treedata()`from
    `treeio` in *Step 4*. By converting in this way, we can get input in many formats
    into downstream analysis in R. Finally, we write the files in *Step 5*.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤1*中，我们使用了`ape`包中非常简单的加载函数——我们使用`read.tree()`和`read.nexus()`函数，它们能够读取通用格式的树。在*步骤2*中，我们使用`treeio`包的特定格式函数来加载BEAST和RaXML的输出。*步骤3*只是确认这些函数返回的对象类型；注意，`ape`返回`phylo`对象，而`treeio`返回`treedata`对象。通过`treeio`中的`as.phylo()`和`as.treedata()`，我们可以相互转换这两种对象类型。在*步骤4*中，通过这种转换，我们可以将多种格式的输入导入到R中进行后续分析。最后，在*步骤5*中，我们将文件写出。
- en: See also
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The loading functions we used in *Step 2* are just a couple of those available.
    Refer to the `treeio` package vignettes for a comprehensive list.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在*步骤2*中使用的加载函数只是其中的几个。请参阅`treeio`包的说明文档，了解完整的函数列表。
- en: Visualizing trees of many genes quickly with ggtree
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ggtree快速可视化多个基因的树
- en: Once you have computed a tree, the first thing you will want to do with it is
    take a look. That's possible in many programs, but R has an extremely powerful,
    flexible, and fast system in the form of the `ggtree` package. In this recipe,
    we'll learn how to get data into ggtree and re-layout, highlight, and annotate
    tree images in just a few commands.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你计算出了树，首先要做的就是查看它。虽然许多程序都能做到这一点，但R具有一种极其强大、灵活且快速的系统，形式为`ggtree`包。在这个配方中，我们将学习如何将数据导入`ggtree`，并仅用几条命令重新布局、突出显示和注释树图。
- en: Getting ready
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: You'll need the `ggplot2`, `ggtree`**, **and `ape` packages. You'll also require
    the `itol.nwk` file from the `datasets/ch4` folder of this book's repository,
    which is a Newick tree of 191 species from the *Interactive Tree of Life* online
    tool's public dataset.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要`ggplot2`、`ggtree`和`ape`包。此外，还需要从本书的仓库中的`datasets/ch4`文件夹中获取`itol.nwk`文件，它是来自*Interactive
    Tree of Life*在线工具的公共数据集的Newick格式树，包含191个物种。
- en: How to do it...
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Visualizing trees of many genes quickly with `ggtree` can be executed using
    the following steps:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ggtree`快速可视化多基因的树，可以按照以下步骤执行：
- en: 'Load the libraries and get a `phylo` object of the Newick tree:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载库并获取Newick树的`phylo`对象：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Make a basic tree plot:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 制作基础的树形图：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Make a circular plot:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 制作圆形图：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Rotate and invert the tree:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 旋转并反转树：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Add labels to the tree tips:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向树的末端添加标签：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Make a strip of color to annotate a particular clade:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 制作颜色条来注释特定的谱系：
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Make a blob of color to highlight a particular clade:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 制作颜色块来突出显示特定的谱系：
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: How it works...
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'This code achieves a lot very quickly. It can do this by virtue of its `ggplot`-like
    layer syntax. Here''s what each step does and its output:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码能够非常快速地实现很多功能。它通过类似于`ggplot`的层语法来实现这一点。以下是每个步骤的作用及其输出：
- en: Load in a tree from a file. The tree here has 191 tips, so it's quite large.
    It happens to be in Newick format, so we use the `ape` `read.tree()` function.
    Note that we don't need to have a `treedata` object for `ggtree` in subsequent
    steps; the `phylo` object returned from `read.tree()` is perfectly acceptable
    to `ggtree()`.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从文件加载一棵树。这里的树有191个叶子节点，所以非常大。恰好它是Newick格式的，因此我们使用`ape`的`read.tree()`函数。请注意，在后续步骤中，我们不需要为`ggtree`创建`treedata`对象；从`read.tree()`返回的`phylo`对象完全可以传递给`ggtree()`。
- en: 'Create a basic tree with `ggtree()`. This function is a wrapper for a longer
    `ggplot`-style syntax, specifically, `ggplot(itol) + aes(x,y) + geom_tree() +
    theme_tree()`. Hence, all the usual `ggplot` functions can be used as extra layers
    in the plot. The code in this step gives us the following plot:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`ggtree()`创建一棵基本的树。这是一个封装了较长`ggplot`样式语法的函数，具体来说是`ggplot(itol) + aes(x,y)
    + geom_tree() + theme_tree()`。因此，可以将所有常见的`ggplot`函数作为额外层叠加到图表中。此步骤中的代码将生成以下图：
- en: '![](img/c524bc24-5636-45da-be9e-51680a5a4897.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c524bc24-5636-45da-be9e-51680a5a4897.png)'
- en: 'Change the layout of the plot. Setting the layout argument to circular gives
    us a round tree. There are many other tree types available through this argument:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改图表的布局。将布局参数设置为圆形将得到一个圆形的树。通过此参数，还可以选择其他多种树形：
- en: '![](img/93e048c2-c9fe-4549-b707-0a97cdf0df0d.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/93e048c2-c9fe-4549-b707-0a97cdf0df0d.png)'
- en: 'We can change the left-right direction of the tree to a top-bottom one using
    the standard `ggplot` functions, `coord_flip()` and `scale_x_reverse()`, to make
    the plot look like this:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用标准的`ggplot`函数`coord_flip()`和`scale_x_reverse()`将树的左右方向改为上下方向，图表将呈现如下效果：
- en: '![](img/53da2023-c4e1-496c-a52b-72a3b0a210d9.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/53da2023-c4e1-496c-a52b-72a3b0a210d9.png)'
- en: 'We can add names to the end of the tips with `geom_tiplab()`. The size argument
    sets the text size. This code generates the following output:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用`geom_tiplab()`在树的末端添加名称。`size`参数设置文本的大小。以下代码将生成如下输出：
- en: '![](img/6da4e55f-8f77-41ed-a213-a6e0191e5ca6.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6da4e55f-8f77-41ed-a213-a6e0191e5ca6.png)'
- en: 'By adding a `geom_strip()` layer, we can annotate clades in the tree with a
    block of color. The first argument (`13` in this instance) is the start node in
    the tree, while the second argument is the end node in the tree for the strip
    of color. The `barsize` argument sets the width of the color block. The result
    looks like this:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过添加`geom_strip()`层，我们可以用一块颜色条注释树中的谱系。第一个参数（在本例中为`13`）是树中的起始节点，第二个参数是树中颜色条的结束节点。`barsize`参数设置颜色块的宽度。结果如下所示：
- en: '![](img/4d934492-a6da-4a18-97c4-e0a8fa840ebe.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4d934492-a6da-4a18-97c4-e0a8fa840ebe.png)'
- en: 'We can highlight clades in unrooted trees with blobs of color using the `geom_hilight_encircle()`
    geom. We need to pick a value for the `node` argument, which tells `ggtree()` which
    node to center the color over. The code here provides the following output:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用`geom_hilight_encircle()`几何图形在无根树中突出显示某些分支。我们需要为`node`参数选择一个值，这告诉`ggtree()`哪个节点是颜色的中心。这里的代码输出以下结果：
- en: '![](img/c6da3037-3ccc-40ac-8cbd-a8adbc0201d5.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c6da3037-3ccc-40ac-8cbd-a8adbc0201d5.png)'
- en: There's more...
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: '*Steps 6* and *7* here relied on us knowing which nodes in the tree to manipulate.
    This isn''t always obvious as the nodes are identified by number and not name.
    We can get at the node number we want if we use the `MRCA()` (**Most Recent Common
    Ancestor**) function. Simply pass it a vector of node names and it returns the
    ID of the node that represents the MRCA:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤 6*和*步骤 7*依赖于我们知道要操作树中的哪些节点。因为节点是通过数字而非名称来标识的，这并不总是显而易见的。如果我们使用`MRCA()`（**最近共同祖先**）函数，就可以找到我们想要的节点编号。只需传递一个节点名称的向量，它就会返回代表MRCA的节点ID：'
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This will give the following output:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出以下结果：
- en: '[PRE14]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Quantifying differences between trees with treespace
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用treespace量化树之间的差异
- en: Comparing trees to differentiate or group them can help researchers to see patterns
    of evolution. Multiple trees of a single gene tracked across species or strains
    can reveal differences in how that gene is changing across species. At the core
    of these approaches are metrics of distances between trees. In this recipe, we'll
    calculate one such metric to find pairwise differences between 20 different gene
    trees in 15 different species—hence, 15 different tips with identical names in
    each tree. Such similarity in trees is usually needed to compare and get distances,
    and we can't do an analysis like this unless these conditions are met.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 比较树以区分或将它们分组，可以帮助研究人员观察进化模式。通过跨物种或菌株跟踪单一基因的多棵树，可以揭示该基因在不同物种中变化的差异。这些方法的核心是树之间距离的度量。在这个食谱中，我们将计算一个这样的度量，找到15个不同物种中20棵不同基因树的成对差异——因此，每棵树中有15个相同名称的树枝。树之间的这种相似性通常是进行比较和获取距离所必需的，只有满足这些条件，我们才能进行这样的分析。
- en: Getting ready
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: For this recipe, we'll use the `treespace` package to compute distances and
    clusters. We'll use `ape` and `adegraphics` for accessory loading and visualization
    functions. The input data here will be all 20 files in `datasets/ch4/gene_trees`,
    each of which is a Newick-format tree for a single gene in each of 15 species.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个食谱，我们将使用`treespace`包来计算距离和聚类。我们将使用`ape`和`adegraphics`来加载附加功能和可视化函数。这里的输入数据将是`datasets/ch4/gene_trees`中的所有20个文件，每个文件都是一个Newick格式的树，代表15个物种中每个物种的单个基因。
- en: How to do it...
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何进行...
- en: 'Quantifying differences between trees with `treespace` can be executed using
    the following steps:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`treespace`量化树之间的差异可以通过以下步骤执行：
- en: 'Load the libraries:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载库：
- en: '[PRE15]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Load all the tree files into a `multiPhylo` object:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有树文件加载到一个`multiPhylo`对象中：
- en: '[PRE16]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Compute the Kendall-Colijn distances:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算Kendall-Colijn距离：
- en: '[PRE17]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Plot pairwise distances:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制成对距离：
- en: '[PRE18]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Plot **principal component analysis** (**PCA**) and clusters:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制**主成分分析**（**PCA**）和聚类：
- en: '[PRE19]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: How it works...
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The short and sweet code here is really powerful—and gives us a lot of analysis
    in a few commands.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这里简短而强大的代码非常有效——在少数几条命令中就能提供大量的分析。
- en: In *Step 1*, initially, we load the libraries we require.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤 1*中，首先加载我们需要的库。
- en: In *Step 2*, after loading the necessary libraries, we make a character vector, `treefiles`,
    which holds paths to the 20 trees we wish to use. The `list.files()` function that we
    use takes a filesystem path as its argument and returns the names of files it
    finds in that path. As `treefiles` is a vector, we can use it as the first argument
    to `lapply()`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤 2*中，加载必要的库后，我们创建一个字符向量`treefiles`，它保存我们希望使用的20棵树的路径。我们使用的`list.files()`函数接受一个文件系统路径作为参数，并返回该路径下找到的文件名。由于`treefiles`是一个向量，我们可以将其作为`lapply()`的第一个参数。
- en: In case you're not familiar with it, `lapply()` is an iterator function that
    returns an R list (hence, `lapply()`).Simply put, `lapply()` runs the function
    named in the second argument over the list of things in the first. The current
    thing is passed as the target function's first argument. So, in *Step 2*, we run
    the **ape** `read.tree()` function on each file named in `treefiles` and receive
    a list of `phylo` tree objects in return. The final step is to ensure that the
    `tree_list` object has the class, `multiPhylo`, so that we satisfy the requirements
    of the downstream functions. Helpfully, a `multiPhylo` object is a list-like object
    anyway, so we can get away with adding the `multiPhylo` string to the class attribute
    with the `class()` function.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不熟悉，`lapply()`是一个迭代函数，它返回一个R列表（因此是`lapply()`）。简单来说，`lapply()`会将第二个参数中指定的函数应用于第一个参数中的列表。当前元素作为目标函数的第一个参数传递。因此，在*第2步*中，我们在`treefiles`中列出的每个文件上运行**ape**的`read.tree()`函数，返回一个`phylo`树对象的列表。最后一步是确保`tree_list`对象具有类`multiPhylo`，这样我们就满足了后续函数的要求。值得一提的是，`multiPhylo`对象本身就是一个类似列表的对象，因此我们只需要通过`class()`函数将`multiPhylo`字符串添加到类属性中即可。
- en: In *Step 3*, the `treespace()` function from the package of the same name does
    an awful lot of analysis. First, it runs pairwise comparisons of all trees in
    the input, and then it carries out clustering using PCA. These are returned in
    a list object, with a member *D* containing the pairwise distances for the trees,
    and `pco` containing the PCA. The default distance metric, the Kendall-Colijn
    distance, is particularly suitable for rooted gene trees as we have here, though
    the metric can be changed. The argument `nf` simply tells us how many of the principal
    components to retain. As our aim is plotting, we won't need more than three.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第3步*中，来自同名包的`treespace()`函数做了大量的分析。首先，它对输入中的所有树进行成对比较，然后使用PCA进行聚类。结果以列表对象返回，成员*D*包含树的成对距离，`pco`包含PCA。默认的距离度量，Kendall-Colijn距离，特别适用于我们这里的有根基因树，尽管该度量可以更改。`nf`参数仅告诉我们保留多少个主成分。由于我们的目标是绘图，我们不需要超过三个主成分。
- en: 'In *Step 4*, we plot the distance matrix in `comparisons$D` using the `table.image()`
    function in `adegraphics`—a convenient heatmap-style function. The `nclass` argument tells
    us how many levels of color to use. We get a plot as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第4步*中，我们使用`adegraphics`中的`table.image()`函数绘制`comparisons$D`中的距离矩阵—这是一个方便的热图风格函数。`nclass`参数告诉我们要使用多少个颜色层级。我们得到的图如下所示：
- en: '![](img/5d616d00-9d11-4851-95b7-458c94ed1d72.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5d616d00-9d11-4851-95b7-458c94ed1d72.png)'
- en: 'In *Step 5*, the `plotGroves()` functionplots a `treespace` object directly,
    so we can see the plot of the PCA:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第5步*中，`plotGroves()`函数直接绘制`treespace`对象，因此我们可以看到PCA的绘图：
- en: '![](img/2fca568c-2421-475d-9025-70ce3394583a.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2fca568c-2421-475d-9025-70ce3394583a.png)'
- en: 'We can use the `findGroves()` function to group the trees into the number of
    groups given by the `nclust` argument and re-plot to view that:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`findGroves()`函数将树分组为由`nclust`参数给定的组数，并重新绘制以查看结果：
- en: '![](img/cb693e11-7f01-419f-b7ad-0b6d5073334c.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cb693e11-7f01-419f-b7ad-0b6d5073334c.png)'
- en: There's more...
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'If you have many trees and the plot is crowded, you can create an interactive
    plot that can be zoomed and panned using the following code:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有很多树，并且图表看起来拥挤，你可以使用以下代码创建一个可以缩放和平移的交互式图：
- en: '[PRE20]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Extracting and working with subtrees using ape
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ape提取和操作子树
- en: In this short recipe, we'll look at how easy it can be to manipulate trees;
    specifically, how to pull out a subtree as a new object and how to combine trees
    into other trees.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简短的教程中，我们将看看操作树是多么简单；具体来说，如何将子树提取为一个新对象，以及如何将树组合成其他树。
- en: Getting ready
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We'll need a single example tree; the `mammal_tree.nwk` file in the `datasets/ch4` folder
    will be fine. All the functions we require can be found in the `ape` package.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一棵示例树；`datasets/ch4`文件夹中的`mammal_tree.nwk`文件就可以。我们需要的所有函数都可以在`ape`包中找到。
- en: How to do it...
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Extracting and working with subtrees using `ape` can be executed using the
    following steps:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ape`提取和操作子树可以通过以下步骤执行：
- en: 'Load the `ape` library and then load the tree:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载`ape`库，然后加载树：
- en: '[PRE21]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Get a list of all of the subtrees:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取所有子树的列表：
- en: '[PRE22]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Extract a specific subtree:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提取特定的子树：
- en: '[PRE23]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Combine two trees:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 合并两棵树：
- en: '[PRE24]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: How it works...
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The functions in this recipe are really straightforward, but extremely useful.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱中的函数非常简单，但非常有用。
- en: '*Step 1* is a familiar tree-loading step. We need a phylo object tree to progress.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '*第一步*是一个常见的树加载步骤。我们需要一个phylo对象的树来进行后续操作。'
- en: '*Step 2* uses the `subtrees()` function, which extracts all non-trivial (greater
    than one node) subtrees and puts them in a list. The members of the list are numbered
    according to the node number in the original tree, and each object in the list
    is a `phylo` object, like the parent. We can inspect the original tree and the
    subtree at node 4 using the `plot()` function, which generates the following diagram:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '*第二步*使用`subtrees()`函数，它提取所有非平凡的（超过一个节点的）子树，并将它们放入一个列表中。列表中的成员根据原始树中的节点编号进行编号，每个列表中的对象都是一个`phylo`对象，像父树一样。我们可以使用`plot()`函数查看原始树和节点4的子树，并生成以下图示：'
- en: '![](img/87afa2f7-6e77-427a-a027-224ee38952cc.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87afa2f7-6e77-427a-a027-224ee38952cc.png)'
- en: In *Step 3*, we get a single specific subtree using the `extract.clade()` function.
    The first argument to this function is the tree, while the second is the node
    that will be extracted. In fact, all nodes downstream of this node are taken and
    a new `phylo` object is returned.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第三步*中，我们使用`extract.clade()`函数获取一个特定的子树。该函数的第一个参数是树，第二个参数是将被提取的节点。实际上，所有该节点下游的节点都会被提取，返回一个新的`phylo`对象。
- en: 'The last example shows how to use the `bind.tree()` function to combine two
    `phylo` objects. The first argument is the major tree, which will receive the
    tree of the second argument. Here, we''ll be stitching `small_tree` onto Newick.
    The third argument is the node in the major tree to which the second tree will
    be joined. Again, a new `phylo` object is returned. When we plot the new tree,
    we can see the repeated segment relative to our original tree:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的示例展示了如何使用`bind.tree()`函数将两个`phylo`对象结合起来。第一个参数是主树，它将接收第二个参数中的树。在这里，我们将把`small_tree`接到Newick树上。第三个参数是主树中要加入第二棵树的节点。同样，返回的是一个新的`phylo`对象。当我们绘制新的树时，可以看到相对于原始树的重复部分：
- en: '![](img/fe646dab-df22-4c39-9200-2a1a3acbd0c1.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fe646dab-df22-4c39-9200-2a1a3acbd0c1.png)'
- en: There's more...
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'A minor problem with the preceding functions is that they expect us to know
    the node number we want to work with. A simple way to access this is by using
    the interactive `subtreeplot()` command. The `subtreeplot(newick)` code generates
    an interactive plot for the tree provided, like the one here. By clicking on particular
    nodes in the tree, we can get the viewer to render the subtree and print the node
    ID. We can then use the node ID in the functions:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 上述函数的一个小问题是它们要求我们知道要操作的节点编号。一种简单的访问方式是使用交互式的`subtreeplot()`命令。`subtreeplot(newick)`代码会生成一个交互式的树图，如这里的例子。通过点击树中的特定节点，我们可以让查看器渲染该子树并打印节点ID。然后我们可以在函数中使用这个节点ID：
- en: '![](img/77fd4bed-d815-4939-85c0-146c10beaaf5.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](img/77fd4bed-d815-4939-85c0-146c10beaaf5.png)'
- en: Creating dot plots for alignment visualization
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建对齐可视化的点图
- en: Dot plots of pairs of aligned sequences are probably the oldest alignment visualization.
    In these plots, the positions of two sequences are plotted on the *x* axis and
    *y* axis, and for every coordinate in that space, a point is drawn if the letters
    (nucleotides or amino acids) correspond at that `(x,y)` coordinate. Since the
    plot can show regions that match that aren't generally in the same region of the
    two sequences, this is a good way to visually spot insertions and deletions and
    structural rearrangements in the two sequences. In this recipe, we'll look at
    a speedy method for constructing a dot plot using the `dotplot` package and a
    bit of code for getting a grid plot of all pairwise dot plots for sequences in
    a file.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 对齐序列对的点图可能是最古老的对齐可视化方法。在这些图中，两个序列的位置分别绘制在*x*轴和*y*轴上，对于该坐标系中的每个坐标点，如果该点处的字母（核苷酸或氨基酸）相对应，就会画出一个点。由于该图能够展示出两个序列中不一定在同一区域匹配的区域，这是一种视觉上快速发现插入、删除以及结构重排的好方法。在这个例子中，我们将展示如何使用`dotplot`包和一些代码，快速构建一个点图，并获取文件中所有序列对的点图网格。
- en: Getting ready
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We''ll need the `datasets/ch4/bhlh.fa` file, which contains three **basic helix-loop-helix**
    (**bHLH**) transcription factor sequences from pea, soy, and lotus. We''ll also
    need the `dotplot` package, which isn''t on CRAN or Bioconductor, so you''ll need
    to install it from GitHub using the `devtools` package. The following code should
    work:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要`datasets/ch4/bhlh.fa`文件，其中包含豌豆、大豆和莲花的三种**基本螺旋-环-螺旋**（**bHLH**）转录因子序列。我们还需要`dotplot`包，它不在CRAN或Bioconductor上，因此你需要使用`devtools`包从GitHub安装它。以下代码应该可行：
- en: '[PRE25]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: How to do it...
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Creating dot plots for alignment visualization can be executed using the following
    steps:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 创建用于对齐可视化的点图可以通过以下步骤完成：
- en: 'Load the libraries and sequences:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载库和序列：
- en: '[PRE26]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Make a basic dot plot:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个基本的点图：
- en: '[PRE27]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Change the dot plot and apply the `ggplot2` themes and labels:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改点图并应用 `ggplot2` 主题和标签：
- en: '[PRE28]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Make a function that will create a dot plot from sequences provided and the
    sequence index:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数，从提供的序列和序列索引中生成点图：
- en: '[PRE29]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Set up data structures to run the function:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置数据结构以运行函数：
- en: '[PRE30]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Run the function on all the possible combinations of pairs of sequences:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对所有可能的序列对组合运行该函数：
- en: '[PRE31]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Plot the grid of plots:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制点图网格：
- en: '[PRE32]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: How it works...
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The first part of this recipe is pretty familiar. We load in the libraries and
    use `Biostrings` to load in our protein sequences. Note that our sequences in
    the `seqs` variable are an instance of the `XStringSet` class.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的第一部分非常熟悉。我们加载库，并使用 `Biostrings` 加载我们的蛋白质序列。请注意，`seqs` 变量中的序列是 `XStringSet`
    类的一个实例。
- en: 'In *Step 2*, we can create a basic dot plot using the `dotplotg()` function.
    The arguments are the sequences we want to plot. Note that we can''t pass the
    `XStringSet` objects directly; we need to pass character vectors, so we coerce
    our sequences into that format with the `as.character()` function. Running this
    code gives us the following dot plot:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *步骤 2* 中，我们可以使用 `dotplotg()` 函数创建一个基本的点图。参数是我们希望绘制的序列。注意，我们不能直接传递 `XStringSet`
    对象；我们需要传递字符向量，因此我们使用 `as.character()` 函数将序列转换为该格式。运行此代码会生成以下点图：
- en: '![](img/7d3856f1-de5c-4fe1-ad63-781cf25c3445.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7d3856f1-de5c-4fe1-ad63-781cf25c3445.png)'
- en: 'In *Step 3*, we elaborate on the basic dot plot by first changing the way a
    match is considered. With the `wsize=7` option, we state that we are looking at
    seven residues at a time (instead of the default of one), the `wstep=5` option
    tells the plotter to jump five residues each step (instead of one, again), and
    the `nmatch=4` option tells the plotter to mark a window as matching if four of
    the residues are identical. We then customize the plot by adding a `ggplot2` theme
    to it in the usual `ggplot` manner and add axis names with the label function.
    From this, we get the following dot plot. Note how it is different to the first
    one:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *步骤 3* 中，我们通过首先改变匹配的考虑方式来详细说明基本点图。通过 `wsize=7` 选项，我们表示一次查看七个残基（而不是默认的一个），`wstep=5`
    选项告诉绘图程序每次跳过五个残基（而不是默认的一个），`nmatch=4` 选项告诉绘图程序当四个残基相同时，标记该窗口为匹配。然后，我们通过添加 `ggplot2`
    主题并以通常的 `ggplot` 方式进行自定义，最后使用标签函数添加轴名称。由此，我们得到了与第一个不同的点图：
- en: '![](img/05cbd1a9-77a9-4c60-a456-5463b1e45d44.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](img/05cbd1a9-77a9-4c60-a456-5463b1e45d44.png)'
- en: The custom function, `make_dot_plot()`, defined in *Step 4* takes two numbers
    in variables, `i` and `j`, and an `XStringSet` object in the `seqs` argument.
    It then converts the i-th and j-th sequence in the `seqs` object to characters
    and stores those in `seqi` and `seqj` variables. It also extracts the names of
    those sequences to `namei` and `namej`. Finally, it creates and returns a dot
    plot using the variables created
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义函数 `make_dot_plot()`，在 *步骤 4* 中定义，接收两个数字变量 `i` 和 `j` 以及 `seqs` 参数中的 `XStringSet`
    对象。然后，它将 `seqs` 对象中的第 i 个和第 j 个序列转换为字符，并将其存储在 `seqi` 和 `seqj` 变量中。同时，它提取这些序列的名称并分别存储在
    `namei` 和 `namej` 中。最后，它创建并返回一个使用这些变量生成的点图。
- en: To use the function, we need two things; the combinations of sequences to be
    plotted and a list to hold the results in. In *Step 4*, the `expand.grid()` function
    is used to create a data frame of all possible combinations of sequences by number,
    which we store in the `combinations` variable. The `plots` variable, created with
    the `vector()` function, contains a `list` object with the right number of slots
    to hold the resultant dot plots.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用该函数，我们需要两个条件：要绘制的序列组合和一个用于存储结果的列表。在 *步骤 4* 中，使用 `expand.grid()` 函数创建所有可能的序列组合的数据框，并将其存储在
    `combinations` 变量中。使用 `vector()` 函数创建的 `plots` 变量包含一个 `list` 对象，该对象有足够的槽位来存储结果的点图。
- en: '*Step 6* is a loop that iterates over each row of the combination''s data frame,
    extracting the sequence numbers we wish to work with and storing them in the `i`
    and `j` variables. The `make_dot_plot()` function is then called with `i`, `j`,
    and `seqs`, and its results stored in the `plots` list we created.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤 6* 是一个循环，遍历组合数据框中的每一行，提取我们希望处理的序列编号，并将其存储在 `i` 和 `j` 变量中。然后，调用 `make_dot_plot()`
    函数，传入 `i`、`j` 和 `seqs`，并将其结果存储在我们创建的 `plots` 列表中。'
- en: 'Finally, in *Step 7*, we use the `cowplot` library function, `plot_grid()`,
    with our list of plots to make a master plot of all possible combinations that
    looks like this:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在*步骤7*中，我们使用`cowplot`库的`plot_grid()`函数，结合我们的图形列表，生成所有可能组合的主图，如下所示：
- en: '![](img/bec8bae0-5740-4178-bd18-9f17a5f6de59.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bec8bae0-5740-4178-bd18-9f17a5f6de59.png)'
- en: Reconstructing trees from alignments using phangorn
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用phangorn从对齐中重建树
- en: So far in this chapter, we've assumed that trees are already available and ready
    to use. Of course, there are many ways to make a phylogenetic tree and, in this
    recipe, we'll take a look at some of the different methods available.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本章节中，我们假设树已经可用并准备好使用。当然，构建系统树有很多方法，在本食谱中，我们将看看一些可用的不同方法。
- en: Getting ready
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this chapter, we'll use the `datasets/ch4/` file, the `abc.fa` file of yeast
    ABC transporter sequences, the `Bioconductor Biostrings` package, and the `msa`
    and `phangorn` packages from CRAN.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章节中，我们将使用`datasets/ch4/`文件、酵母ABC转运蛋白序列的`abc.fa`文件、`Bioconductor Biostrings`包以及来自CRAN的`msa`和`phangorn`包。
- en: How to do it...
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'Constructing trees using `phangorn` can be executed using the following steps:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`phangorn`构建树可以通过以下步骤执行：
- en: 'Load in the libraries and sequences, and make an alignment:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载库和序列，并进行对齐：
- en: '[PRE33]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Convert the alignment to the `phyDat` object:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将对齐转换为`phyDat`对象：
- en: '[PRE34]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Make UPGMA and neighbor-joining trees from a distance matrix:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从距离矩阵生成UPGMA和邻接法树：
- en: '[PRE35]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Calculate the bootstraps and plot:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算自助法并绘制：
- en: '[PRE36]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: How it works...
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The first step carries out a loading and amino acid sequence alignment, as we've
    seen in an earlier recipe with the `msa` package, returning an `MsaAAMultipleAlignment` object.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步执行加载和氨基酸序列对齐，就像我们在之前的食谱中使用`msa`包时看到的那样，返回一个`MsaAAMultipleAlignment`对象。
- en: The second step uses the `as.phyDat()` function to convert the alignment to
    a `phyDat` object that can be used by the `phangorn` functions.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 第二步使用`as.phyDat()`函数将对齐转换为可以由`phangorn`函数使用的`phyDat`对象。
- en: 'In *Step 3*, we actually make trees. Trees are made from a distance matrix,
    which we can compute with `dist.ml()` and our alignment (this is a maximum-likelihood
    distance measure; other functions can be used here if needed). The `dist_mat`
    is passed to the `upgma()` and `NJ()` functions to make UPGMA and neighbor-joining
    trees, respectively. These return standard `phylo` objects that can be worked
    with in many other functions. Here, we plot directly:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤3*中，我们实际上生成树。树是由距离矩阵构建的，我们可以使用`dist.ml()`和我们的对齐来计算距离矩阵（这是一个最大似然距离度量；如果需要，也可以使用其他函数）。然后将`dist_mat`传递给`upgma()`和`NJ()`函数，分别生成UPGMA和邻接法树。这些函数返回标准的`phylo`对象，可以在许多其他函数中使用。这里，我们直接绘制：
- en: '![](img/807b4486-43e0-4838-b9e6-a3147134c115.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![](img/807b4486-43e0-4838-b9e6-a3147134c115.png)'
- en: In the final step, we use the `bootstraps.phyDat()` function to compute bootstrap
    support for the branches in the tree. The first argument is the `phyDat` object, `aln`,
    while the second argument, `FUN`, requires a function to calculate trees. Here,
    we use an anonymous function wrapping the `NJ()` method we used to generate `nj_tree`
    in the first place. The `bs` argument tells the functions how many bootstraps
    to compute. Finally, we can plot the resultant bootstraps onto the tree using
    the `plotBS()` function.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一步，我们使用`bootstraps.phyDat()`函数来计算树中各个分支的自助法支持。第一个参数是`phyDat`对象`aln`，而第二个参数`FUN`需要一个函数来计算树。这里，我们使用一个匿名函数，包装了我们最初用于生成`nj_tree`的`NJ()`方法。`bs`参数告诉函数计算多少次自助法。最后，我们可以使用`plotBS()`函数将结果图绘制到树上。
