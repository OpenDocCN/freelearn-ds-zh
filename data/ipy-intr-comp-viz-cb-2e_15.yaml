- en: Chapter 15. Symbolic and Numerical Mathematics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第15章 符号和数值数学
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Diving into symbolic computing with SymPy
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用SymPy进行符号计算
- en: Solving equations and inequalities
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解方程和不等式
- en: Analyzing real-valued functions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析实值函数
- en: Computing exact probabilities and manipulating random variables
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算精确概率和操作随机变量
- en: A bit of number theory with SymPy
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用SymPy进行一点数论
- en: Finding a Boolean propositional formula from a truth table
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从真值表中找到布尔命题公式
- en: Analyzing a nonlinear differential system – Lotka-Volterra (predator-prey) equations
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析非线性微分系统 - Lotka-Volterra（捕食者-猎物）方程
- en: Getting started with Sage
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始使用Sage
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In this chapter, we will introduce **SymPy**, a Python library for symbolic
    mathematics. Whereas most of the book deals with numerical methods, we will see
    examples here where symbolic computations are more suitable.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍**SymPy**，这是一个用于符号数学的Python库。虽然本书大部分内容涉及数值方法，但在这里我们将看到符号计算更适合的示例。
- en: SymPy is to symbolic computing what NumPy is to numerical computing. For example,
    SymPy can help us analyze a mathematical model before we run a simulation.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: SymPy对符号计算就像NumPy对数值计算一样重要。例如，SymPy可以帮助我们在运行模拟之前分析数学模型。
- en: Although quite powerful, SymPy is a bit slow compared to other computer algebra
    systems. The main reason is that SymPy is written in pure Python. A faster and
    more powerful mathematics system is **Sage** (see also the *Getting started with
    Sage* recipe in this chapter). Sage is a heavy standalone program that has many
    big dependencies (including SymPy!), and it uses only Python 2 at the time of
    writing. It is essentially meant for interactive use. Sage includes an IPython-like
    notebook.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管SymPy相当强大，但与其他计算机代数系统相比有点慢。主要原因是SymPy是用纯Python编写的。一个更快更强大的数学系统是**Sage**（也请参阅本章中的*Getting
    started with Sage*示例）。Sage是一个庞大的独立程序，有许多大型依赖项（包括SymPy！），并且在撰写本文时仅使用Python 2。它主要用于交互式使用。Sage包括类似IPython的笔记本。
- en: LaTeX
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: LaTeX
- en: '**LaTeX** is a document markup language widely used to write publication-quality
    mathematical equations. Equations written in LaTeX can be displayed in the browser
    with the **MathJax** JavaScript library. SymPy uses this system to display equations
    in the IPython notebook.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**LaTeX**是一种广泛用于编写出版质量数学方程式的文档标记语言。使用LaTeX编写的方程式可以在浏览器中使用**MathJax** JavaScript库显示。SymPy使用此系统在IPython笔记本中显示方程式。'
- en: LaTeX equations can also be used in matplotlib. In this case, it is recommended
    to have a LaTeX installation on your local computer.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: LaTeX方程式也可以在matplotlib中使用。在这种情况下，建议在本地计算机上安装LaTeX。
- en: 'Here are a few references:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些参考资料：
- en: LaTeX on Wikipedia, at [http://en.wikipedia.org/wiki/LaTeX](http://en.wikipedia.org/wiki/LaTeX)
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Wikipedia上的LaTeX，网址为[http://en.wikipedia.org/wiki/LaTeX](http://en.wikipedia.org/wiki/LaTeX)
- en: MathJax, available at [www.mathjax.org](http://www.mathjax.org)
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MathJax，可在[www.mathjax.org](http://www.mathjax.org)找到
- en: LaTeX in matplotlib, described at [http://matplotlib.org/users/usetex.html](http://matplotlib.org/users/usetex.html)
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: matplotlib中的LaTeX，描述在[http://matplotlib.org/users/usetex.html](http://matplotlib.org/users/usetex.html)
- en: Documentation for displaying equations with SymPy, available at [http://docs.sympy.org/latest/tutorial/printing.html](http://docs.sympy.org/latest/tutorial/printing.html)
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于显示SymPy方程式的文档，网址为[http://docs.sympy.org/latest/tutorial/printing.html](http://docs.sympy.org/latest/tutorial/printing.html)
- en: To install LaTeX on your computer, refer to [http://latex-project.org/ftp.html](http://latex-project.org/ftp.html)
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要在计算机上安装LaTeX，请参考[http://latex-project.org/ftp.html](http://latex-project.org/ftp.html)
- en: Diving into symbolic computing with SymPy
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SymPy进行符号计算
- en: In this recipe, we will give a brief introduction to symbolic computing with
    SymPy. We will see more advanced features of SymPy in the next recipes.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将简要介绍使用SymPy进行符号计算。我们将在接下来的示例中看到SymPy的更高级功能。
- en: Getting ready
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: SymPy is a pure Python package with no other dependencies, and as such, it is
    very easy to install. With Anaconda, you can type `conda install sympy` in a terminal.
    On Windows, you can use Chris Gohlke's package ([www.lfd.uci.edu/~gohlke/pythonlibs/#sympy](http://www.lfd.uci.edu/~gohlke/pythonlibs/#sympy)).
    Finally, you can use the `pip install sympy` command.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: SymPy是一个纯Python包，没有其他依赖项，因此非常容易安装。使用Anaconda，您可以在终端中键入`conda install sympy`。在Windows上，您可以使用Chris
    Gohlke的软件包([www.lfd.uci.edu/~gohlke/pythonlibs/#sympy](http://www.lfd.uci.edu/~gohlke/pythonlibs/#sympy))。最后，您可以使用`pip
    install sympy`命令。
- en: How to do it...
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: SymPy can be used from a Python module, or interactively in IPython. In the
    notebook, all mathematical expressions are displayed with LaTeX, thanks to the
    MathJax JavaScript library.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: SymPy可以在Python模块中使用，或者在IPython中交互式使用。在笔记本中，所有数学表达式都通过LaTeX显示，得益于MathJax JavaScript库。
- en: 'Here is an introduction to SymPy:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是SymPy的介绍：
- en: 'First, we import SymPy and enable LaTeX printing in the IPython notebook:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们导入SymPy并在IPython笔记本中启用LaTeX打印：
- en: '[PRE0]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To deal with symbolic variables, we first need to declare them:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要处理符号变量，我们首先需要声明它们：
- en: '[PRE1]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `var()` function creates symbols and injects them into the namespace. This
    function should only be used in the interactive mode. In a Python module, it is
    better to use the `symbols()` function that returns the symbols:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`var()`函数用于创建符号并将其注入到命名空间中。这个函数仅应在交互模式下使用。在Python模块中，最好使用`symbols()`函数来返回符号：'
- en: '[PRE2]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We can create mathematical expressions with these symbols:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以用这些符号创建数学表达式：
- en: '[PRE3]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Are these expressions equal?
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些表达式相等吗？
- en: '[PRE4]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'These expressions are mathematically equal, but not syntactically identical.
    To test whether they are mathematically equal, we can ask SymPy to simplify the
    difference algebraically:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些表达式在数学上相等，但在语法上并不相同。为了测试它们是否在数学上相等，我们可以让SymPy代数化地简化差异：
- en: '[PRE5]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: A very common operation with symbolic expressions is the substitution of a symbol
    by another symbol, expression, or a number, using the `subs()` method of a symbolic
    expression:![How to do it...](img/4818OS_15_01.jpg)
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理符号表达式时，一个非常常见的操作是通过符号表达式的`subs()`方法将一个符号替换为另一个符号、表达式或数字：![如何操作...](img/4818OS_15_01.jpg)
- en: Substitution in a SymPy expression
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在SymPy表达式中的替代
- en: 'A rational number cannot be written simply as `1/2` as this Python expression
    evaluates to 0\. A possibility is to convert the number `1` into a SymPy integer
    object, for example by using the `S()` function:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个有理数不能简单地写作`1/2`，因为这个Python表达式会计算出0。一个解决方法是将数字`1`转换为SymPy整数对象，例如使用`S()`函数：
- en: '[PRE6]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Exactly represented numbers can be evaluated numerically with `evalf`:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 精确表示的数字可以通过`evalf`进行数值求值：
- en: '[PRE7]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We can easily create a Python function from a SymPy symbolic expression using
    the `lambdify()` function. The resulting function can notably be evaluated on
    NumPy arrays. This is quite convenient when we need to go from the symbolic world
    to the numerical world:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过`lambdify()`函数轻松地从SymPy符号表达式创建Python函数。生成的函数可以特别地在NumPy数组上进行求值。这在我们需要从符号世界转到数值世界时非常方便：
- en: '[PRE8]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: How it works...
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: A core idea in SymPy is to use the standard Python syntax to manipulate exact
    expressions. Although this is very convenient and natural, there are a few caveats.
    Symbols such as `x`, which represent mathematical variables, cannot be used in
    Python before being instantiated (otherwise, a `NameError` exception is thrown
    by the interpreter). This is in contrast to most other computer algebra systems.
    For this reason, SymPy offers ways to declare symbolic variables beforehand.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: SymPy的一个核心思想是使用标准的Python语法来操作精确的表达式。虽然这非常方便和自然，但也有一些注意事项。像`x`这样的符号，代表数学变量，在被实例化之前不能在Python中使用（否则，解释器会抛出`NameError`异常）。这与大多数其他计算机代数系统不同。因此，SymPy提供了提前声明符号变量的方法。
- en: Another example is integer division; as `1/2` evaluates to `0` (in Python 2),
    SymPy has no way to know that the user intended to write a fraction instead. We
    need to convert the numerical integer `1` to the symbolic integer `1` before dividing
    it by `2`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是整数除法；由于`1/2`会计算为`0`（在Python 2中），SymPy无法知道用户原本打算写一个分数。我们需要先将数值整数`1`转换为符号整数`1`，然后再除以`2`。
- en: Also, the Python equality refers to the equality between syntax trees rather
    than between mathematical expressions.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Python的等式指的是语法树之间的相等，而不是数学表达式之间的相等。
- en: See also
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: The *Solving equations and inequalities* recipe
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*求解方程和不等式*食谱'
- en: The *Getting started with Sage* recipe
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Sage入门*食谱'
- en: Solving equations and inequalities
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 求解方程和不等式
- en: SymPy offers several ways to solve linear and nonlinear equations and systems
    of equations. Of course, these functions do not always succeed in finding closed-form
    exact solutions. In this case, we can fall back to numerical solvers and obtain
    approximate solutions.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: SymPy提供了多种方法来求解线性和非线性方程及方程组。当然，这些函数并不总能成功找到封闭形式的精确解。在这种情况下，我们可以退回到数值求解器并得到近似解。
- en: Getting ready
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: We first need to import SymPy. We also initialize pretty printing in the notebook
    (see the first recipe of this chapter).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要导入 SymPy。我们还需要在笔记本中初始化美观打印（参见本章的第一个示例）。
- en: How to do it...
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Let''s define a few symbols:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一些符号：
- en: '[PRE9]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We use the `solve()` function to solve equations (the right-hand side is `0`
    by default):'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`solve()`函数来解方程（右侧默认是`0`）：
- en: '[PRE10]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can also solve inequalities. Here, we need to use the `solve_univariate_inequality()`
    function to solve this univariate inequality in the real domain:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以解不等式。在这里，我们需要使用`solve_univariate_inequality()`函数来解这个实数域中的单变量不等式：
- en: '[PRE11]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `solve()` function also accepts systems of equations (here, a linear system):'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`solve()`函数也接受方程组（这里是一个线性系统）：'
- en: '[PRE12]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Nonlinear systems are also handled:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 非线性系统也可以处理：
- en: '[PRE13]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Singular linear systems can also be solved (here, there is an infinite number
    of solutions because the two equations are collinear):'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 奇异线性系统也可以求解（这里有无限多个解，因为两个方程是共线的）：
- en: '[PRE14]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, let''s solve a linear system using matrices containing symbolic variables:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们使用包含符号变量的矩阵来求解线性系统：
- en: '[PRE15]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We create the **augmented matrix**, which is the horizontal concatenation of
    the system''s matrix with the linear coefficients and the right-hand side vector.
    This matrix corresponds to the following system in *x,y: ax+by=u, cx+dy=v*:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '我们创建了**增广矩阵**，这是系统矩阵与线性系数和右侧向量的水平拼接。这个矩阵对应于以下系统 *x,y: ax+by=u, cx+dy=v*：'
- en: '[PRE16]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This system needs to be nonsingular in order to have a unique solution, which
    is equivalent to saying that the determinant of the system''s matrix needs to
    be nonzero (otherwise the denominators in the preceding fractions are equal to
    zero):'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个系统需要是非奇异的，才能有唯一解，这等同于说系统矩阵的行列式需要非零（否则前述分数的分母将为零）：
- en: '[PRE17]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: There's more...
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: Matrix support in SymPy is quite rich; we can perform a large number of operations
    and decompositions (see the reference guide at [http://docs.sympy.org/latest/modules/matrices/matrices.html](http://docs.sympy.org/latest/modules/matrices/matrices.html)).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: SymPy 中的矩阵支持非常丰富；我们可以执行大量的操作和分解（请参阅[http://docs.sympy.org/latest/modules/matrices/matrices.html](http://docs.sympy.org/latest/modules/matrices/matrices.html)的参考指南）。
- en: 'Here are more references about linear algebra:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有更多关于线性代数的参考资料：
- en: Linear algebra on Wikipedia, at [http://en.wikipedia.org/wiki/Linear_algebra#Further_reading](http://en.wikipedia.org/wiki/Linear_algebra#Further_reading)
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维基百科上的线性代数，[http://en.wikipedia.org/wiki/Linear_algebra#Further_reading](http://en.wikipedia.org/wiki/Linear_algebra#Further_reading)
- en: Linear algebra on Wikibooks, at [http://en.wikibooks.org/wiki/Linear_Algebra](http://en.wikibooks.org/wiki/Linear_Algebra)
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维基教科书上的线性代数，[http://en.wikibooks.org/wiki/Linear_Algebra](http://en.wikibooks.org/wiki/Linear_Algebra)
- en: Analyzing real-valued functions
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析实值函数
- en: 'SymPy contains a rich **calculus** toolbox to analyze real-valued functions:
    limits, power series, derivatives, integrals, Fourier transforms, and so on. In
    this recipe, we will show the very basics of these capabilities.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: SymPy 包含了丰富的**微积分**工具箱，用于分析实值函数：极限、幂级数、导数、积分、傅里叶变换等等。在这个示例中，我们将展示这些功能的基本用法。
- en: Getting ready
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 做好准备
- en: We first need to import SymPy. We also initialize pretty printing in the notebook
    (see the first recipe of this chapter).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要导入 SymPy。我们还需要在笔记本中初始化美观打印（参见本章的第一个示例）。
- en: How to do it...
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Let''s define a few symbols and a function (which is just an expression depending
    on `x`):'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一些符号和一个函数（它只是一个依赖于 `x` 的表达式）：
- en: '[PRE18]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let''s evaluate this function at `1`:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在 `1` 处评估这个函数：
- en: '[PRE19]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We can compute the derivative of this function:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以计算这个函数的导数：
- en: '[PRE20]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'What is `f`''s limit to infinity? (Note the double o (`oo`) for the infinity
    symbol):'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`f` 的极限是无限大吗？（注意符号的双 `oo`（无穷大）表示）：'
- en: '[PRE21]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here's how to compute a Taylor series (here, around `0`, of order `9`). The
    **Big O** can be removed with the `removeO()` method.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下面是如何计算泰勒级数（这里是围绕`0`，阶数为`9`）。**大 O** 可以通过 `removeO()` 方法去除。
- en: '[PRE22]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We can compute definite integrals (here, over the entire real line):'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以计算定积分（这里是对整个实数轴的积分）：
- en: '[PRE23]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'SymPy can also compute indefinite integrals:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SymPy 还可以计算不定积分：
- en: '[PRE24]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Finally, let''s compute `f`''s Fourier transforms:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们计算`f`的傅里叶变换：
- en: '[PRE25]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: There's more...
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: SymPy includes a large number of other integral transforms besides the Fourier
    transform ([http://docs.sympy.org/dev/modules/integrals/integrals.html](http://docs.sympy.org/dev/modules/integrals/integrals.html)).
    However, SymPy will not always be able to find closed-form solutions.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: SymPy还包括许多其他的积分变换，除了傅里叶变换（[http://docs.sympy.org/dev/modules/integrals/integrals.html](http://docs.sympy.org/dev/modules/integrals/integrals.html)）。然而，SymPy并不总是能够找到闭式解。
- en: 'Here are a few general references about real analysis and calculus:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些关于实分析和微积分的参考书目：
- en: Real analysis on Wikipedia, at [http://en.wikipedia.org/wiki/Real_analysis#Bibliography](http://en.wikipedia.org/wiki/Real_analysis#Bibliography)
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维基百科上的实分析内容，访问 [http://en.wikipedia.org/wiki/Real_analysis#Bibliography](http://en.wikipedia.org/wiki/Real_analysis#Bibliography)
- en: Calculus on Wikibooks, at [http://en.wikibooks.org/wiki/Calculus](http://en.wikibooks.org/wiki/Calculus)
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维基书上的微积分内容，访问 [http://en.wikibooks.org/wiki/Calculus](http://en.wikibooks.org/wiki/Calculus)
- en: Computing exact probabilities and manipulating random variables
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算精确概率并操作随机变量
- en: SymPy includes a module named `stats` that lets us create and manipulate random
    variables. This is useful when we work with probabilistic or statistical models;
    we can compute symbolic expectancies, variances probabilities, and densities of
    random variables.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: SymPy包括一个名为`stats`的模块，允许我们创建和操作随机变量。当我们处理概率或统计模型时，这非常有用；我们可以计算符号期望值、方差、概率和随机变量的密度。
- en: How to do it...
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let''s import SymPy and the stats module:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们来导入SymPy和stats模块：
- en: '[PRE26]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Let''s roll two dice, `X` and `Y`, with six faces each:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们掷两个骰子，`X`和`Y`，每个都有六个面：
- en: '[PRE27]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We can compute probabilities defined by equalities (with the `Eq` operator)
    or inequalities:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以计算由等式（使用`Eq`运算符）或不等式定义的概率：
- en: '[PRE28]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Conditions can also involve multiple random variables:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 条件也可以涉及多个随机变量：
- en: '[PRE29]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We can compute conditional probabilities:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以计算条件概率：
- en: '[PRE30]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We can also work with arbitrary discrete or continuous random variables:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们也可以处理任意的离散或连续随机变量：
- en: '[PRE31]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We can compute expectancies and variances:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以计算期望值和方差：
- en: '[PRE32]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We can also compute densities:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们也可以计算密度：
- en: '[PRE33]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We can plot these densities:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以绘制这些密度：
- en: '[PRE34]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '![How to do it...](img/4818OS_15_02.jpg)'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/4818OS_15_02.jpg)'
- en: The Gaussian density
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 高斯密度
- en: How it works...
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'SymPy''s `stats` module contains many functions to define random variables
    with classical laws (binomial, exponential, and so on), discrete or continuous.
    It works by leveraging SymPy''s powerful integration algorithms to compute exact
    probabilistic quantities as integrals of probability distributions. For example,
    ![How it works...](img/4818OS_15_10.jpg) is:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: SymPy的`stats`模块包含许多函数，用于定义具有经典分布（如二项分布、指数分布等）的随机变量，无论是离散的还是连续的。它通过利用SymPy强大的积分算法来计算概率分布的积分，从而精确计算概率量。例如，![它是如何工作的...](img/4818OS_15_10.jpg)就是：
- en: '![How it works...](img/4818OS_15_03.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/4818OS_15_03.jpg)'
- en: Note that the equality condition is written using the `Eq` operator rather than
    the more standard `==` Python syntax. This is a general feature in SymPy; `==`
    means equality between Python variables, whereas `Eq` is the mathematical operation
    between symbolic expressions.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，等式条件是使用`Eq`运算符而非更常见的Python语法`==`来表示的。这是SymPy的一个通用特性；`==`表示Python变量之间的相等，而`Eq`表示符号表达式之间的数学运算。
- en: A bit of number theory with SymPy
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一点关于数论的内容与SymPy
- en: 'SymPy contains many number-theory-related routines: obtaining prime numbers,
    integer decompositions, and much more. We will show a few examples here.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: SymPy包含许多与数论相关的例程：获取质数、整数分解等等。我们将在这里展示几个例子。
- en: Getting ready
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: To display legends using LaTeX in matplotlib, you will need an installation
    of LaTeX on your computer (see this chapter's *Introduction*).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 要在matplotlib中使用LaTeX显示图例，你需要在计算机上安装LaTeX（请参见本章的*简介*）。
- en: How to do it...
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let''s import SymPy and the number theory package:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们来导入SymPy和数论包：
- en: '[PRE35]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We can test whether a number is prime:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以测试一个数字是否是质数：
- en: '[PRE36]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We can find the next prime after a given number:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以找出给定数字后的下一个质数：
- en: '[PRE37]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: What is the 1000th prime number?
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第1000个质数是什么？
- en: '[PRE38]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: How many primes less than 2011 are there?
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 小于2011的质数有多少个？
- en: '[PRE39]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We can plot ![How to do it...](img/4818OS_15_11.jpg), the **prime-counting
    function** (the number of prime numbers less than or equal to some number *x*).
    The famous **prime number theorem** states that this function is asymptotically
    equivalent to *x/*log*(x)*. This expression approximately quantifies the distribution
    of prime numbers among all integers:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以绘制![如何操作...](img/4818OS_15_11.jpg)，**素数计数函数**（小于或等于某个数字 *x* 的素数的数量）。著名的**素数定理**指出，这个函数在渐近意义上等价于
    *x/*log*(x)*。这个表达式大致量化了素数在所有整数中的分布情况：
- en: '[PRE40]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '![How to do it...](img/4818OS_15_04.jpg)'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/4818OS_15_04.jpg)'
- en: Distribution of prime numbers
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 素数分布
- en: 'Let''s compute the integer factorization of a number:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们计算一个数字的整数因式分解：
- en: '[PRE41]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Finally, a small problem. A lazy mathematician is counting his marbles. When
    they are arranged in three rows, the last column contains one marble. When they
    form four rows, there are two marbles in the last column, and there are three
    with five rows. How many marbles are there? (Hint: The lazy mathematician has
    fewer than 100 marbles.)![How to do it...](img/4818OS_15_05.jpg)'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，一个小问题。一个懒惰的数学家在数他的珠子。当它们排列成三行时，最后一列有一颗珠子。当它们排列成四行时，最后一列有两颗珠子，排列成五行时有三颗珠子。那么珠子总共有多少颗？（提示：懒惰的数学家少于100颗珠子。）![如何操作...](img/4818OS_15_05.jpg)
- en: Counting marbles with the Chinese Remainder Theorem
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用中国剩余定理计数珠子
- en: 'The Chinese Remainder Theorem gives us the answer:'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 中国剩余定理给我们提供了答案：
- en: '[PRE42]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'There are infinitely many solutions: 58 plus any multiple of 60\. Since there
    are less than 100 marbles, 58 is the right answer.'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有无限多的解：58加上任何60的倍数。由于珠子总数少于100颗，58就是正确答案。
- en: How it works...
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'SymPy contains many number-theory-related functions. Here, we used the **Chinese
    Remainder Theorem** to find the solutions of the following system of arithmetic
    equations:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: SymPy包含许多与数论相关的函数。在这里，我们使用**中国剩余定理**来求解以下算术方程组的解：
- en: '![How it works...](img/4818OS_15_06.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/4818OS_15_06.jpg)'
- en: The Chinese Remainder Theorem
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 中国剩余定理
- en: The triple bar is the symbol for modular congruence. Here, it means that *m[i]*
    divides *a[i]-n*. In other words, *n* and *a[i]* are equal up to a multiple of
    *m[i]*. Reasoning with congruences is very convenient when periodic scales are
    involved. For example, operations involving 12-hour clocks are done modulo 12\.
    The numbers 11 and 23 are equivalent modulo 12 (they represent the same hour on
    the clock) because their difference is a multiple of 12.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 三重条是模同余的符号。这里，它表示 *m[i]* 整除 *a[i]-n*。换句话说，*n* 和 *a[i]* 相等，直到 *m[i]* 的倍数。处理同余时，当涉及周期性尺度时非常方便。例如，12小时制的时钟操作是按模12运算的。数字11和23在模12下是等价的（它们在时钟上表示相同的时刻），因为它们的差是12的倍数。
- en: 'In this recipe''s example, three congruences have to be satisfied: the remainder
    of the number of marbles in the division with 3 is 1 (there''s one extra marble
    in that arrangement), it is 2 in the division with 4, and 3 in the division with
    5\. With SymPy, we simply specify these values in the `solve_congruence()` function
    to get the solutions.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，必须满足三个同余：珠子数在除以3时的余数是1（表示这种排列中多了一颗珠子），除以4时余数是2，除以5时余数是3。使用SymPy，我们只需在`solve_congruence()`函数中指定这些值，就能得到解。
- en: The theorem states that solutions exist as soon as the *m[i]* are pairwise co-prime
    (any two distinct numbers among them are co-prime). All solutions are congruent
    modulo the product of the *m[i]*. This fundamental theorem in number theory has
    several applications, notably in cryptography.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 该定理指出，当 *m[i]* 彼此互质时（它们之间的任意两个数都是互质的），解是存在的。所有解在 *m[i]* 的乘积下是同余的。这个数论中的基本定理有许多应用，特别是在密码学中。
- en: There's more...
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'Here are a few textbooks about number theory:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些关于数论的教材：
- en: 'Undergraduate level: *Elementary Number Theory*, *Gareth A. Jones*, *Josephine
    M. Jones*, *Springer*, *(1998)*'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本科水平：《*初等数论*》，*Gareth A. Jones*，*Josephine M. Jones*，*Springer*，*(1998)*
- en: 'Graduate level: *A Classical Introduction to Modern Number Theory*, *Kenneth
    Ireland*, *Michael Rosen*, *Springer*, *(1982)*'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 研究生水平：《*现代数论的经典介绍*》，*Kenneth Ireland*，*Michael Rosen*，*Springer*，*(1982)*
- en: 'Here are a few references:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些参考资料：
- en: Documentation on SymPy's number-theory module, available at [http://docs.sympy.org/dev/modules/ntheory.html](http://docs.sympy.org/dev/modules/ntheory.html)
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SymPy的数论模块文档，访问地址：[http://docs.sympy.org/dev/modules/ntheory.html](http://docs.sympy.org/dev/modules/ntheory.html)
- en: The Chinese Remainder Theorem on Wikipedia, at [http://en.wikipedia.org/wiki/Chinese_remainder_theorem](http://en.wikipedia.org/wiki/Chinese_remainder_theorem)
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[维基百科上的中国剩余定理](http://en.wikipedia.org/wiki/Chinese_remainder_theorem)'
- en: Applications of the Chinese Remainder Theorem, given at [http://mathoverflow.net/questions/10014/applications-of-the-chinese-remainder-theorem](http://mathoverflow.net/questions/10014/applications-of-the-chinese-remainder-theorem)
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中国剩余定理的应用，见于[http://mathoverflow.net/questions/10014/applications-of-the-chinese-remainder-theorem](http://mathoverflow.net/questions/10014/applications-of-the-chinese-remainder-theorem)
- en: Finding a Boolean propositional formula from a truth table
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从真值表中找到一个布尔命题公式
- en: The logic module in SymPy lets us manipulate complex Boolean expressions, also
    known as **propositional formulas**.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: SymPy中的逻辑模块让我们操作复杂的布尔表达式，也就是**命题公式**。
- en: This recipe will show an example where this module can be useful. Let's suppose
    that, in a program, we need to write a complex `if` statement depending on three
    Boolean variables. We can think about each of the eight possible cases (true,
    true and false, and so on) and evaluate what the outcome should be. SymPy offers
    a function to generate a compact logic expression that satisfies our truth table.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子将展示这个模块的一个实际应用。假设在一个程序中，我们需要根据三个布尔变量写一个复杂的`if`语句。我们可以考虑八种可能的情况（真、真与假、依此类推），并评估每种情况下应该得到什么结果。SymPy提供了一个函数，可以生成一个满足我们真值表的紧凑逻辑表达式。
- en: How to do it...
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let''s import SymPy:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们导入SymPy：
- en: '[PRE43]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Let''s define a few symbols:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们定义一些符号：
- en: '[PRE44]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We can define propositional formulas with symbols and a few operators:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用符号和几个运算符来定义命题公式：
- en: '[PRE45]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We can use `subs()` to evaluate a formula on actual Boolean values:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用`subs()`来对实际的布尔值进行公式求值：
- en: '[PRE46]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Now, we want to find a propositional formula depending on `x`, `y`, and `z`,
    with the following truth table:![How to do it...](img/4818OS_15_07.jpg)
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们希望根据`x`、`y`和`z`找到一个命题公式，以下是其真值表：![如何操作...](img/4818OS_15_07.jpg)
- en: A truth table
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一张真值表
- en: 'Let''s write down all combinations that we want to evaluate to `True`, and
    those for which the outcome does not matter:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们列出所有我们希望求值为`True`的组合，以及那些结果无关紧要的组合：
- en: '[PRE47]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now, we use the `SOPform()` function to derive an adequate formula:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们使用`SOPform()`函数来推导出一个合适的公式：
- en: '[PRE48]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Let''s test that this proposition works:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们测试一下这个命题是否有效：
- en: '[PRE49]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: How it works...
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `SOPform()` function generates a full expression corresponding to a truth
    table and simplifies it using the **Quine-McCluskey algorithm**. It returns the
    smallest *Sum of Products* form (or disjunction of conjunctions). Similarly, the
    `POSform()` function returns a Product of Sums.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`SOPform()`函数生成一个与真值表对应的完整表达式，并使用**Quine-McCluskey算法**简化它。它返回最小的*积和*形式（或合取的析取）。类似地，`POSform()`函数返回一个和的积。'
- en: 'The given truth table can occur in this case: suppose that we want to write
    a file if it doesn''t already exist (`z`), or if the user wants to force the writing
    (`x`). In addition, the user can prevent the writing (`y`). The expression evaluates
    to `True` if the file is to be written. The resulting SOP formula works if we
    explicitly forbid `x` and `y` in the first place (forcing and preventing the writing
    at the same time is forbidden).'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 给定的真值表可能出现在这种情况下：假设我们希望在文件不存在时写入文件（`z`），或者用户希望强制写入（`x`）。此外，用户可以阻止写入（`y`）。当文件需要被写入时，表达式的值为`True`。得到的SOP公式在我们首先显式禁止`x`和`y`时有效（强制和禁止写入同时发生是禁止的）。
- en: There's more...
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: 'Here are a few references:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些参考资料：
- en: The propositional formula on Wikipedia, at [http://en.wikipedia.org/wiki/Propositional_formula](http://en.wikipedia.org/wiki/Propositional_formula)
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[维基百科上的命题公式](http://en.wikipedia.org/wiki/Propositional_formula)'
- en: Sum of Products on Wikipedia, at [http://en.wikipedia.org/wiki/Canonical_normal_form](http://en.wikipedia.org/wiki/Canonical_normal_form)
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[维基百科上的积和形式](http://en.wikipedia.org/wiki/Canonical_normal_form)'
- en: The Quine–McCluskey algorithm on Wikipedia, at [http://en.wikipedia.org/wiki/Quine%E2%80%93McCluskey_algorithm](http://en.wikipedia.org/wiki/Quine%E2%80%93McCluskey_algorithm)
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[维基百科上的Quine–McCluskey算法](http://en.wikipedia.org/wiki/Quine%E2%80%93McCluskey_algorithm)'
- en: Analyzing a nonlinear differential system – Lotka-Volterra (predator-prey) equations
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析非线性微分系统 – Lotka-Volterra（捕食-被捕食）方程
- en: 'Here, we will conduct a brief analytical study of a famous nonlinear differential
    system: the **Lotka-Volterra equations**, also known as predator-prey equations.
    These equations are first-order differential equations that describe the evolution
    of two interacting populations (for example, sharks and sardines), where the predators
    eat the prey. This example illustrates how to obtain exact expressions and results
    about fixed points and their stability with SymPy.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将对著名的非线性微分方程系统——**洛特卡-沃尔特拉方程**进行简要的分析，这也被称为捕食者-猎物方程。这些方程是描述两种相互作用的种群（例如鲨鱼和沙丁鱼）演化的一级微分方程，其中捕食者捕食猎物。这个例子展示了如何使用SymPy获得关于固定点及其稳定性的精确表达式和结果。
- en: Getting ready
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备好
- en: For this recipe, knowing the basics of linear and nonlinear systems of differential
    equations is recommended.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个公式，建议了解线性和非线性微分方程的基础知识。
- en: How to do it...
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Let''s create some symbols:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一些符号：
- en: '[PRE50]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The variables `x` and `y` represent the populations of the prey and predators,
    respectively. The parameters `a`, `b`, `c`, and `d` are strictly positive parameters
    (described more precisely in the *How it works...* section of this recipe). The
    equations are:![How to do it...](img/4818OS_15_08.jpg)
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 变量`x`和`y`分别代表猎物和捕食者的种群。参数`a`、`b`、`c`和`d`是严格为正的参数（在这个公式的*如何实现...*部分中更精确地描述）。方程为：![如何实现...](img/4818OS_15_08.jpg)
- en: Lotka-Volterra equations
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 洛特卡-沃尔特拉方程
- en: '[PRE51]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Let''s find the fixed points of the system (solving *f(x,y) = g(x,y) = 0*).
    We call them *(x[0], y[0])* and *(x[1], y[1])*:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们找到系统的固定点（解*f(x,y) = g(x,y) = 0*）。我们将它们称为*(x[0], y[0])*和*(x[1], y[1])*：
- en: '[PRE52]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Let''s write the 2D vector with the two equations:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们用两个方程来写出二维向量：
- en: '[PRE53]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now, we can compute the **Jacobian** of the system, as a function of `(x, y)`:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以计算系统的**雅可比矩阵**，作为`(x, y)`的函数：
- en: '[PRE54]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Let''s study the stability of the first fixed point by looking at the eigenvalues
    of the Jacobian at this point. The first fixed point corresponds to extinct populations:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过观察雅可比矩阵在这个点的特征值来研究第一个固定点的稳定性。第一个固定点对应的是种群灭绝：
- en: '[PRE55]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The parameters `a` and `c` are strictly positive, so the eigenvalues are real
    and of opposite signs, and this fixed point is a **saddle point**. As this point
    is unstable, the extinction of both populations is unlikely in this model.
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 参数`a`和`c`是严格为正的，因此特征值是实数且符号相反，这个固定点是**鞍点**。由于这个点不稳定，因此在这个模型中两种种群都灭绝的可能性很小。
- en: 'Let''s consider the second fixed point now:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们考虑第二个固定点：
- en: '[PRE56]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The eigenvalues are purely imaginary; thus, this fixed point is not hyperbolic.
    Therefore, we cannot draw conclusions from this linear analysis about the qualitative
    behavior of the system around this fixed point. However, we could show with other
    methods that oscillations occur around this point.
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 特征值是纯虚数；因此，这个固定点不是双曲的。因此，我们不能从这个线性分析中得出关于该固定点周围系统定性行为的结论。然而，我们可以通过其他方法证明，在这个点附近会发生振荡。
- en: How it works...
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: The Lotka-Volterra equations model the growth of the predator and prey populations,
    taking into account their interactions. In the first equation, the *ax* term represents
    the exponential growth of the prey, and *-bxy* represents death by predators.
    Similarly, in the second equation, *-yc* represents the natural death of the predators,
    and *dxy* represents their growth as they eat more and more prey.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 洛特卡-沃尔特拉方程模拟了捕食者和猎物种群的增长，考虑了它们的相互作用。在第一个方程中，*ax*项表示猎物的指数增长，*-bxy*表示捕食者导致的死亡。同样，在第二个方程中，*-yc*表示捕食者的自然死亡，*dxy*表示捕食者因捕食更多猎物而增长。
- en: To find the **equilibrium points** of the system, we need to find the values
    *x, y* such that *dx/dt = dy/dt = 0*, that is, *f(x, y) = g(x, y) = 0*, so that
    the variables do not evolve anymore. Here, we were able to obtain analytical values
    for these equilibrium points with the `solve()` function.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到系统的**平衡点**，我们需要找到* x, y *的值，使得* dx/dt = dy/dt = 0*，即*f(x, y) = g(x, y) =
    0*，这样变量就不再变化了。在这里，我们能够通过`solve()`函数获得这些平衡点的解析值。
- en: To analyze their stability, we need to perform a linear analysis of the nonlinear
    equations, by taking the **Jacobian matrix** at these equilibrium points. This
    matrix represents the linearized system, and its eigenvalues tell us about the
    stability of the system near the equilibrium point. The **Hartman–Grobman theorem**
    states that the behavior of the original system qualitatively matches the behavior
    of the linearized system around an equilibrium point if this point is **hyperbolic**
    (meaning that no eigenvalues of the matrix have a real part equal to 0). Here,
    the first equilibrium point is hyperbolic as *a, c > 0*, but the second is not.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 为了分析它们的稳定性，我们需要对非线性方程进行线性分析，通过在这些平衡点计算**雅可比矩阵**。这个矩阵代表了线性化系统，它的特征值告诉我们关于平衡点附近系统的稳定性。**哈特曼–格罗曼定理**指出，如果平衡点是**双曲的**（意味着矩阵的特征值没有实部为零的情况），那么原始系统的行为在定性上与线性化系统在平衡点附近的行为是匹配的。在这里，第一个平衡点是双曲的，因为*a,
    c > 0*，而第二个则不是。
- en: Here, we were able to compute symbolic expressions for the Jacobian matrix and
    its eigenvalues at the equilibrium points.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们能够计算出平衡点处雅可比矩阵及其特征值的符号表达式。
- en: There's more...
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Even when a differential system is not solvable analytically (as is the case
    here), a mathematical analysis can still give us qualitative information about
    the behavior of the system's solutions. A purely numerical analysis is not always
    relevant when we are interested in qualitative results, as numerical errors and
    approximations can lead to wrong conclusions about the system's behavior.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 即使一个差分系统无法解析求解（如这里所示），数学分析仍然可以为我们提供关于系统解的行为的定性信息。当我们关心定性结果时，纯粹的数值分析并不总是相关的，因为数值误差和近似可能导致关于系统行为的错误结论。
- en: 'Here are a few references:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些参考资料：
- en: Matrix documentation in SymPy, available at [http://docs.sympy.org/dev/modules/matrices/matrices.html](http://docs.sympy.org/dev/modules/matrices/matrices.html)
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SymPy 中的矩阵文档，网址：[http://docs.sympy.org/dev/modules/matrices/matrices.html](http://docs.sympy.org/dev/modules/matrices/matrices.html)
- en: Dynamical systems on Wikipedia, at [http://en.wikipedia.org/wiki/Dynamical_system](http://en.wikipedia.org/wiki/Dynamical_system)
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维基百科上的动态系统，[http://en.wikipedia.org/wiki/Dynamical_system](http://en.wikipedia.org/wiki/Dynamical_system)
- en: Equilibrium points on Scholarpedia, at [www.scholarpedia.org/article/Equilibrium](http://www.scholarpedia.org/article/Equilibrium)
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Scholarpedia 上的平衡点，[www.scholarpedia.org/article/Equilibrium](http://www.scholarpedia.org/article/Equilibrium)
- en: Bifurcation theory on Wikipedia, at [http://en.wikipedia.org/wiki/Bifurcation_theory](http://en.wikipedia.org/wiki/Bifurcation_theory)
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维基百科上的分岔理论，[http://en.wikipedia.org/wiki/Bifurcation_theory](http://en.wikipedia.org/wiki/Bifurcation_theory)
- en: Chaos theory on Wikipedia, at [http://en.wikipedia.org/wiki/Chaos_theory](http://en.wikipedia.org/wiki/Chaos_theory)
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维基百科上的混沌理论，[http://en.wikipedia.org/wiki/Chaos_theory](http://en.wikipedia.org/wiki/Chaos_theory)
- en: Further reading on dynamical systems, at [http://en.wikipedia.org/wiki/Dynamical_system#Further_reading](http://en.wikipedia.org/wiki/Dynamical_system#Further_reading)
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于动态系统的进一步阅读，网址：[http://en.wikipedia.org/wiki/Dynamical_system#Further_reading](http://en.wikipedia.org/wiki/Dynamical_system#Further_reading)
- en: Getting started with Sage
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用 Sage
- en: Sage ([www.sagemath.org](http://www.sagemath.org)) is a standalone mathematics
    software based on Python. It is an open source alternative to commercial products
    such as Mathematica, Maple, or MATLAB. Sage provides a unified interface to many
    open source mathematical libraries. These libraries include SciPy, SymPy, NetworkX,
    and other Python scientific packages, but also non-Python libraries such as ATLAS,
    BLAS, GSL, LAPACK, Singular, and many others.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: Sage ([www.sagemath.org](http://www.sagemath.org)) 是一个基于 Python 的独立数学软件。它是商业产品如
    Mathematica、Maple 或 MATLAB 的开源替代品。Sage 提供了一个统一的接口，连接了许多开源数学库。这些库包括 SciPy、SymPy、NetworkX
    和其他 Python 科学包，也包括非 Python 库，如 ATLAS、BLAS、GSL、LAPACK、Singular 等。
- en: In this recipe, we will give a brief introduction to Sage.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将简要介绍 Sage。
- en: Getting ready
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'You can either:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以选择：
- en: Install Sage on your local computer ([www.sagemath.org/doc/installation/](http://www.sagemath.org/doc/installation/))
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本地计算机上安装 Sage ([www.sagemath.org/doc/installation/](http://www.sagemath.org/doc/installation/))
- en: Create Sage notebooks remotely in the cloud ([https://cloud.sagemath.com/](https://cloud.sagemath.com/))
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在云端远程创建 Sage 笔记本 ([https://cloud.sagemath.com/](https://cloud.sagemath.com/))
- en: 'Being based on so many libraries, Sage is heavy and hard to compile from source.
    Binaries exist for most systems except Windows, where you generally have to use
    VirtualBox (a virtualization solution: [www.virtualbox.org](http://www.virtualbox.org)).'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 由于依赖于如此多的库，Sage 很庞大且难以从源代码编译。除了 Windows 系统外，其他大多数系统都有现成的二进制文件，而在 Windows 上通常需要使用
    VirtualBox（一种虚拟化解决方案：[www.virtualbox.org](http://www.virtualbox.org)）。
- en: Alternatively, you can use Sage in a browser with an IPython notebook running
    on the cloud.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，你也可以通过在云端运行 IPython 笔记本，在浏览器中使用 Sage。
- en: Note that Sage is not compatible with Python 3 at the time of this writing.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Sage 在写作时与 Python 3 不兼容。
- en: Typically, Sage is used interactively with the built-in notebook (which resembles
    the IPython notebook). If you want to use Sage in a Python program (that is, importing
    Sage from Python), you need to run Sage's built-in Python interpreter ([www.sagemath.org/doc/faq/faq-usage.html#how-do-i-import-sage-into-a-python-script](http://www.sagemath.org/doc/faq/faq-usage.html#how-do-i-import-sage-into-a-python-script)).
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，Sage 是通过内置的笔记本进行交互式使用（它类似于 IPython 笔记本）。如果你想在 Python 程序中使用 Sage（也就是从 Python
    导入 Sage），你需要运行 Sage 的内置 Python 解释器（[www.sagemath.org/doc/faq/faq-usage.html#how-do-i-import-sage-into-a-python-script](http://www.sagemath.org/doc/faq/faq-usage.html#how-do-i-import-sage-into-a-python-script)）。
- en: How to do it...
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Here, we will create a new Sage notebook and introduce the most basic features:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将创建一个新的 Sage 笔记本，并介绍最基本的功能：
- en: 'Sage accepts mathematical expressions as we would expect:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Sage 接受数学表达式，就像我们预期的那样：
- en: '[PRE57]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Being based on Python, Sage''s syntax is almost Python, but there are a few
    differences. For example, the power exponent is the more classical `^` symbol:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于基于 Python，Sage 的语法几乎与 Python 相同，但也有一些差异。例如，幂指数使用的是更经典的 `^` 符号：
- en: '[PRE58]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Like in SymPy, symbolic variables need to be declared beforehand with the `var()`
    function. However, the `x` variable is always predefined. Here, we define a new
    mathematical function:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像在 SymPy 中一样，符号变量需要事先使用 `var()` 函数声明。然而，`x` 变量总是预定义的。在这里，我们定义一个新的数学函数：
- en: '[PRE59]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Let''s simplify the expression of `f`:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们简化 `f` 的表达式：
- en: '[PRE60]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Let''s evaluate `f` on a given point:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在给定的点上评估 `f`：
- en: '[PRE61]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Functions can be differentiated and integrated:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数可以进行微分和积分：
- en: '[PRE62]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Sage also supports numerical computations in addition to symbolic computations:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除了符号计算，Sage 还支持数值计算：
- en: '[PRE63]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Sage also comes with rich plotting capabilities (including interactive plotting
    widgets):'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Sage 还具有丰富的绘图功能（包括交互式绘图控件）：
- en: '[PRE64]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '![How to do it...](img/4818OS_15_09.jpg)'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何做...](img/4818OS_15_09.jpg)'
- en: There's more...
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: 'This (too) short recipe cannot do justice to the huge list of possibilities
    offered by Sage. Many aspects of mathematics are covered: algebra, combinatorics,
    numerical mathematics, number theory, calculus, geometry, graph theory, and many
    others. Here are a few references:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这个（也）简短的教程无法充分展示 Sage 提供的广泛功能。Sage 涉及数学的许多方面：代数、组合数学、数值数学、数论、微积分、几何、图论等。以下是一些参考资料：
- en: An in-depth tutorial on Sage, available at [www.sagemath.org/doc/tutorial/](http://www.sagemath.org/doc/tutorial/)
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于 Sage 的深入教程可以在 [www.sagemath.org/doc/tutorial/](http://www.sagemath.org/doc/tutorial/)
    查阅
- en: The Sage reference manual, available at [www.sagemath.org/doc/reference/](http://www.sagemath.org/doc/reference/)
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Sage 的参考手册可以在 [www.sagemath.org/doc/reference/](http://www.sagemath.org/doc/reference/)
    查阅
- en: Videos on Sage, available at [www.sagemath.org/help-video.html](http://www.sagemath.org/help-video.html)
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于 Sage 的视频，可以在 [www.sagemath.org/help-video.html](http://www.sagemath.org/help-video.html)
    查阅
- en: See also
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: The *Diving into symbolic computing with SymPy* recipe
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*深入学习符号计算与 SymPy* 课程'
