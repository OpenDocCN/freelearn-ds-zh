- en: Producing Publication and Web-Ready Visualizations
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成出版物和Web-ready可视化图形
- en: Designing and producing publication-quality visualizations is a key task and
    one of the most rewarding things bioinformaticians gets to do with data. R is
    not short of excellent packages for creating graphics, that is, beyond the powerful
    base graphics system and `ggplot2`. In the recipes in this chapter, we'll look
    at how to create plots for many different data types that aren't of the typical
    bar/scatter plot type. We'll also look at networks, interactive and 3D graphics,
    and circular genome plots.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 设计和制作出版质量的可视化图形是生物信息学家的核心任务之一，也是他们在数据处理过程中最具成就感的部分。R提供了许多优秀的图形制作包，超越了强大的基础图形系统和`ggplot2`。在本章的配方中，我们将探讨如何为许多不同类型的数据制作图表，这些数据通常不是典型的条形图/散点图类型。我们还将讨论网络、交互式图形、3D图形和圆形基因组图。
- en: 'The following recipes will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍以下配方：
- en: Visualizing multiple distributions with ridgeplots
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用ridgeplots可视化多个分布
- en: Creating colormaps for two-variable data
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为双变量数据创建色图
- en: Representing relational data as networks
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将关系数据表示为网络
- en: Creating interactive web graphics with plotly
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用plotly创建交互式Web图形
- en: Constructing three-dimensional plots with plotly
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用plotly构建三维图形
- en: Constructing circular genome plots of polyomic data
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建多组学数据的圆形基因组图
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The sample data you'll need for this chapter is available in this book's GitHub
    repository: [https://github.com/danmaclean/R_Bioinformatics_Cookbook](https://github.com/danmaclean/R_Bioinformatics_Cookbook)[.](https://github.com/danmaclean/R_Bioinformatics_Cookbook) If
    you want to use the code examples as they are written, then you will need to make
    sure that the data is in a subdirectory of your working directory.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章所需的示例数据可以在本书的GitHub仓库中找到：[https://github.com/danmaclean/R_Bioinformatics_Cookbook](https://github.com/danmaclean/R_Bioinformatics_Cookbook)[.](https://github.com/danmaclean/R_Bioinformatics_Cookbook)
    如果你想按照书中的代码示例运行，你需要确保数据位于工作目录的子目录中。
- en: 'Here are the R packages that you''ll need. You can install them with `install.packages("package_name")`.
    The packages listed under `Bioconductor` need to be installed with a dedicated
    installer, which is also described in this section. If you need to do anything
    else, the installation steps will be described in the recipes in which the packages
    are used:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是你需要的R包。你可以使用`install.packages("package_name")`来安装它们。列在`Bioconductor`下的包需要使用专用的安装器进行安装，安装步骤也在本节中描述。如果你需要做其他操作，安装步骤将在包使用的配方中描述：
- en: '`circlize`'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`circlize`'
- en: '`dplyr`'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dplyr`'
- en: '`ggplot2`'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ggplot2`'
- en: '`ggridges`'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ggridges`'
- en: '`gplots`'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gplots`'
- en: '`plotly`'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`plotly`'
- en: '`RColorBrewer`'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RColorBrewer`'
- en: '`readr`'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`readr`'
- en: '`magrittr`'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`magrittr`'
- en: '`tidyr`'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tidyr`'
- en: '`viridis`'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`viridis`'
- en: '`Bioconductor` is huge and has its own installation manager. You can install
    the manager with the following code:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`Bioconductor`非常庞大，且有自己的安装管理器。你可以使用以下代码安装该管理器：'
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, you can install the packages with the following code:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以使用以下代码安装这些包：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Further information is available at [https://www.bioconductor.org/install/](https://www.bioconductor.org/install/).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息可以在[https://www.bioconductor.org/install/](https://www.bioconductor.org/install/)中找到。
- en: Normally, in R, a user will load a library and use the functions directly by
    name. This is great in interactive sessions, but it can cause confusion when many
    packages are loaded. To clarify which package and function I'm using at a given
    moment, I will occasionally use the `packageName::functionName()` convention.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在R中，用户会加载一个库并直接通过名称使用其中的函数。这在交互式会话中非常有效，但当加载多个包时，可能会导致混淆。为了明确在某一时刻我使用的是哪个包和函数，我会偶尔使用`packageName::functionName()`的约定。
- en: 'Sometimes, in the middle of a recipe, I''ll interrupt the flow of code so that
    you can see some intermediate output or the structure of an object that''s important
    to understand. Whenever that happens, you''ll see a code block where each line
    begins with ## double hash symbols. Consider the following command:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，在配方的中间，我会打断代码流程，让你看到一些中间输出或对理解非常重要的对象结构。每当发生这种情况，你会看到一个代码块，其中每行以##双哈希符号开头。请考虑以下命令：
- en: '`letters[1:5]`'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`letters[1:5]`'
- en: 'This will give us the following output:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '`## a b c d e`'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`## a b c d e`'
- en: Note that the output lines are prefixed with `##`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，输出行以`##`为前缀。
- en: Visualizing multiple distributions with ridgeplots
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ridgeplots可视化多个分布
- en: Visualizing distributions of some measured quantity is an extremely common task
    in bioinformatics, and one that base R handles admirably with its `hist()` and
    `density()` functions and the generic `plot()` methods, which can create plots
    of the objects. The `ggplot` graphics system has a neat way of plotting many density
    graphs in a per factor level manner, resulting in a compact and very readable
    graphic—a so-called ridgeplot. In this recipe, we'll look at how to create a ridgeplot.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 可视化某些测量数量的分布是生物信息学中的一项常见任务，R的基础功能通过`hist()`和`density()`函数以及通用的`plot()`方法，能很好地处理这种任务，后者可以创建对象的图形。`ggplot`图形系统以一种整洁的方式绘制多个密度图，每个因子水平对应一个图形，从而生成一个紧凑且非常易读的图形——即所谓的山脊图。在这个示例中，我们将看看如何创建一个山脊图。
- en: Getting ready
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we'll use the `ggplot` and `ggridges` packages. For the dataset,
    we'll use one from the `datasets` package that usually comes preinstalled with
    R. We're going to use the `airquality` data. You can see this if you type `airquality`
    straight into the R console.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将使用`ggplot`和`ggridges`包。数据集方面，我们将使用`datasets`包中的一个数据集，该包通常是R的预安装包之一。我们将使用`airquality`数据集。你可以直接在R控制台中输入`airquality`来查看它。
- en: How to do it...
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Visualizing multiple distributions with ridgeplots can be done using the following
    steps:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 使用山脊图可视化多个分布可以通过以下步骤完成：
- en: 'Load the libraries:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载库：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Build a `ggplot` description:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建一个`ggplot`描述：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Explicitly make `Month` a factor:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显式将`Month`转换为因子：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Color the ridges:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给山脊上色：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Reshape the dataframe and add facets:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重塑数据框并添加面板：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: How it works...
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: After loading the libraries we needed in *Step 1*, in *Step 2*, we created a
    standard `ggplot` description using the `geom_ridges()` function from the `ggridges`
    package. If you haven't seen a ggplot plot before, they're very straightforward.
    A ggplot plot has three layers, built up using at least three functions—the `ggplot()` function
    is always the first and allows us to specify the dataset. The next, which is added
    on top with the `+` operator, is the `aes()` function or aesthetic function, which
    we can think of as being the things we want to see in the plot. The first argument
    represents the thing on the *x* axis, while the second argument represents the
    thing on the *y *axis. The `group = Month` argument is specific to the ridgeplot
    and tells the plotting function how to group data points. It is needed here since
    the `Month` data is numeric, not a factor. Finally, we add `geom_density_ridges()`
    to create the right sort of plot.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤1*中加载所需的库后，*步骤2*中我们使用`ggridges`包的`geom_ridges()`函数创建了一个标准的`ggplot`描述。如果你以前没见过`ggplot`图，它们非常简单。一个`ggplot`图有三个层次，至少需要通过三个函数构建——`ggplot()`函数始终是第一个，它允许我们指定数据集。接下来，使用`+`运算符添加的函数是`aes()`函数或美学函数，我们可以将其视为我们希望在图表中看到的内容。第一个参数表示*X*轴上的元素，而第二个参数表示*Y*轴上的元素。`group
    = Month`参数是特定于山脊图的，它告诉绘图函数如何对数据点进行分组。由于`Month`数据是数字型，而不是因子型，因此这里需要此参数。最后，我们添加`geom_density_ridges()`来创建正确类型的图。
- en: 'In *Step 3*, we followed the same sort of procedure as *Step 2*, but this time,
    as an alternative, we use `as.factor(Month)`, which explicitly converts the `Month`
    data into a factor before processing and rendering the group. This deems the `Month`
    step unnecessary. The plots from these steps look as follows, with *Step 2* on
    the left and *Step 3* on the right:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤3*中，我们遵循了与*步骤2*类似的程序，但这次，我们作为替代方法使用了`as.factor(Month)`，它在处理和渲染分组之前显式地将`Month`数据转换为因子类型。因此，`Month`的步骤变得不再必要。这些步骤生成的图形如下，*步骤2*在左，*步骤3*在右：
- en: '![](img/386fb9ba-2bec-45cf-bb1f-3203c30ae6c8.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/386fb9ba-2bec-45cf-bb1f-3203c30ae6c8.png)'
- en: 'In *Step 4*, we added color to the ridges. Essentially, the `ggplot` construction
    is the same, except it has the addition of `fill = ..x..` in the `aes()` function,
    which tells the plot that color should be filled in the *x* axis direction. We
    then use a slightly different `geom` function, `geom_density_ridges_gradient()`,
    which is capable of coloring its ridges. In the last new layer, with `scale_fill_viridis()`,
    we chose a color scale from the viridis color scale library (loaded at the top).
    The `"C"` option specifies the particular color scale, while `name` specifies
    the name for the scale. The resulting plot looks like this:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第4步*中，我们为山脊添加了颜色。基本上，`ggplot` 构建过程没有变化，只是在 `aes()` 函数中增加了 `fill = ..x..`，它告诉绘图填充
    *x* 轴方向的颜色。然后我们使用了一个稍微不同的 `geom` 函数，`geom_density_ridges_gradient()`，它能够为山脊着色。在最后一层，我们使用
    `scale_fill_viridis()`，选择了来自 viridis 颜色库的颜色尺度（该库在顶部加载）。`"C"` 选项指定了特定的颜色尺度，而 `name`
    用来指定尺度的名称。结果图像如下所示：
- en: '![](img/3cf10b88-19e3-4d92-bcf4-f03969c0e5f7.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3cf10b88-19e3-4d92-bcf4-f03969c0e5f7.png)'
- en: 'Finally, in *Step 5*, we split the data by a further dimension and added facets
    containing different aspects of the same dataset in the same style of plot. The
    `airquality` data needs to be preprocessed a little for this to be possible. We
    load the `tidyr` package and use the `gather()` function to take the values named
    columns (specifically Ozone, Solar.R, Wind, and Temp) into a single column called
    value and add a new column called Measurement that records the original column
    that the observation came from. Then, we pipe the result into `ggplot()`. The
    construction is nearly identical to before (note that our *x* axis is now value,
    not Temp, as this is where the temperatures are stored in the reshaped dataframe),
    with the addition of the `facet_wrap()` function at the end, which uses formula
    notation to select the subsets of the data to display in individual facets. The
    option scales are `"free"` and allow each of the resulting facets to have their
    own scales. The result is as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在*第5步*中，我们通过进一步的维度对数据进行了拆分，并在相同样式的图中添加了包含同一数据集不同方面的面板。为了实现这一点，`airquality`
    数据需要进行一些预处理。我们加载了 `tidyr` 包，并使用 `gather()` 函数将命名列的值（具体是 Ozone、Solar.R、Wind 和 Temp）合并到一个名为
    value 的列中，并添加一个名为 Measurement 的新列，记录原始列中观察值的来源。然后，我们将结果传递到 `ggplot()`。构建过程几乎与之前相同（请注意，我们的
    *x* 轴现在是 value，而不是 Temp，因为温度数据已经存储在重塑后的数据框中），最后添加了 `facet_wrap()` 函数，它使用公式符号选择数据的子集并显示在各个面板中。选项
    scales 为 `"free"`，允许每个结果面板有独立的坐标轴刻度。结果如下所示：
- en: '![](img/4ddd1065-e5d0-4614-acf0-91f5f9d3c55b.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4ddd1065-e5d0-4614-acf0-91f5f9d3c55b.png)'
- en: Creating colormaps for two-variable data
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为双变量数据创建颜色映射
- en: Colormaps, also known as heatmaps, are plots of two-dimensional matrices in
    which the numeric values are converted into a color at a particular scale. There
    are numerous various ways in which we can plot these in R; most graphics packages
    have some way of doing this. In this recipe, we'll use the base package's `heatmap()` function
    to visualize some matrices.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 颜色映射，也称为热图，是二维矩阵的绘图，其中数值在特定尺度上转换为颜色。我们可以通过多种方式在 R 中绘制这些图表；大多数图形包都提供了这类功能。在本教程中，我们将使用基础包的
    `heatmap()` 函数来可视化一些矩阵。
- en: Getting ready
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We'll need just the `ggplot` packages, as well as the built-in `WorldPhones` dataset.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要 `ggplot` 包和内置的 `WorldPhones` 数据集。
- en: How to do it...
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'Creating colormaps for two-variable data can be done using the following steps:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为双变量数据创建颜色映射可以通过以下步骤完成：
- en: 'Create a basic heatmap:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建基本的热图：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Remove the dendrogram:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移除树状图：
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Add a color scale to the groups:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为分组添加颜色尺度：
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Change the palette:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改调色板：
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Rescale the data:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新缩放数据：
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: How it works...
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In *Step 1*, we passed the base `heatmap()` function a matrix, which returns
    a plot that looks like this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第1步*中，我们将基础的 `heatmap()` 函数应用于一个矩阵，返回一个如下所示的图：
- en: '![](img/e6e8d896-0aa1-4eba-991f-c749b2933354.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e6e8d896-0aa1-4eba-991f-c749b2933354.png)'
- en: 'In *Step 2*, we used the `Rowv` and `Colv` arguments to remove the dendrogram.
    Note that, in the resulting plot, the columns are in the same order as in the
    matrix. By using the dendrograms, we can rearrange the columns and rows. The treeless
    plot looks like this:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第2步*中，我们使用了 `Rowv` 和 `Colv` 参数来去除树状图。请注意，在结果图中，列的顺序与矩阵中的顺序一致。通过使用树状图，我们可以重新排列列和行。没有树状图的图表如下所示：
- en: '![](img/984dd795-1719-45b8-b22e-de1f7b48d9ee.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/984dd795-1719-45b8-b22e-de1f7b48d9ee.png)'
- en: 'In *Step 3*, we created a palette object using the `rainbow()` function, which
    returns the colors for a plot. The first argument to `rainbow()` is the number
    of colors. Here, we are using `ncol(WorldPhones)` to get one color per column
    for the dataset. The start and end arguments specify where to start and end the
    color selection in the rainbow. We can then use the **CC** palette object in the
    `ColSideColors` argument to get a color key for the columns. We can use more similar
    columns to get more similar colors, as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第3步*中，我们使用`rainbow()`函数创建了一个调色板对象，该函数返回绘图所需的颜色。`rainbow()`的第一个参数是颜色的数量。这里，我们使用`ncol(WorldPhones)`来为数据集的每一列获取一种颜色。`start`和`end`参数指定了彩虹中颜色选择的起始和结束位置。然后，我们可以在`ColSideColors`参数中使用**CC**调色板对象，以获取列的颜色键。我们可以使用更多相似的列来获得更多相似的颜色，具体如下：
- en: '![](img/171a8ed7-dbd4-4093-88a9-de35fa1e9abb.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/171a8ed7-dbd4-4093-88a9-de35fa1e9abb.png)'
- en: 'In *Step 4*, we provided a palette object to the `col` argument to change the
    overall palette of the heatmap. We used the `colorRampPalette()` function to make
    a sequential palette from a smaller list of specific colors. This will interpolate
    the colors to make a full palette. We passed `colorRampPalette()` the `RColorBrewer`
    package function known as `brewer.pal()`, which, with the provided options, will
    return eight colors from the **pink-yellow-green** (**PiYG**) pallete. The resulting
    heatmap is colored like so:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第4步*中，我们为`col`参数提供了一个调色板对象，以更改热图的整体调色板。我们使用了`colorRampPalette()`函数，从一小部分特定颜色列表中生成顺序调色板。这个函数会插值生成完整的调色板。我们将`RColorBrewer`包中的`brewer.pal()`函数作为参数传给`colorRampPalette()`，该函数根据提供的选项返回**粉色-黄色-绿色**（**PiYG**）调色板中的八种颜色。生成的热图颜色如下所示：
- en: '![](img/62b784e1-0480-40db-a5c6-6bf8c09948d9.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](img/62b784e1-0480-40db-a5c6-6bf8c09948d9.png)'
- en: 'Finally, in *Step 5*, we applied a numeric transformation to the data within
    the visualization step. We use the `scale` option of `heatmap()` to normalize
    the data in the plot. Note that setting the value to **column** does this column-wise
    while setting it to `row` does this row-wise. The default base package `scale()` function
    is used for this. Rescaling the numbers in the plot is what is responsible for
    the color change, and is not the result of a direct selection from a palette.
    The plot is as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在*第5步*中，我们在可视化步骤中对数据进行了数值转换。我们使用`heatmap()`的`scale`选项来规范化图表中的数据。请注意，设置为**column**时按列进行规范化，而设置为`row`时按行进行规范化。默认的基础包`scale()`函数用于此操作。图表中的数字重新缩放是颜色变化的原因，而不是直接从调色板中选择的结果。图表如下所示：
- en: '![](img/cb43c3e2-11a7-49d8-9b0b-c6b7bc0d6725.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cb43c3e2-11a7-49d8-9b0b-c6b7bc0d6725.png)'
- en: See also
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另见
- en: 'The `heatmap()` function has been followed up by other packages that follow
    a similar syntax but extend its capabilities. Try `heatmap.2()` and `heatmap.3()`
    in the `gplots` package. A `heatmap.2()` plot can be seen in the following histogram.
    It''s very similar to `heatmap()`, but has an added color key and histogram plot
    by default:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`heatmap()`函数随后有了其他包，这些包遵循类似的语法，但扩展了其功能。尝试使用`gplots`包中的`heatmap.2()`和`heatmap.3()`。以下直方图展示了`heatmap.2()`的绘图效果。它与`heatmap()`非常相似，但默认添加了颜色键和直方图：'
- en: '![](img/fe5afabd-d1d9-45ab-b0e9-089e40921f89.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fe5afabd-d1d9-45ab-b0e9-089e40921f89.png)'
- en: Representing relational data as networks
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表示关系数据为网络
- en: Networks, or graphs, are extremely powerful data representations for relationships
    between entities that are central to a large number of biological studies. Network
    analysis can reveal a lot about community structures in ecological studies, reveal
    potential drug targets in protein-protein interactions, and help us understand
    the interactions involved in complex metabolic reactions. The underlying data
    structures that represent networks can be complex. Thankfully, R has got some
    very powerful packages, in particular, `igraph` and `ggraph`, that we can use
    to access information about our networks and make plots. In this recipe, we'll
    look at some ways of generating plots for a reasonably sized network.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 网络，或图形，是表示实体之间关系的强大数据表示方式，对于许多生物学研究至关重要。网络分析可以揭示生态学研究中的社区结构，揭示蛋白质-蛋白质相互作用中的潜在药物靶点，并帮助我们理解复杂代谢反应中的相互作用。表示网络的基础数据结构可能是复杂的。幸运的是，R有一些非常强大的包，特别是`igraph`和`ggraph`，我们可以使用它们来访问网络信息并进行绘图。在本教程中，我们将探索一些生成适当大小网络图的方式。
- en: Getting ready
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we'll need the `ggraph` and `igraph` packages and dependencies,
    including `magrittr`, `readr`, and `dplyr`. We'll need the `bio-DM-LC.edges` file
    from the `datasets/ch7` folder of this book repository. This is a file that contains
    some gene functional associations from WormNet. The network contains ~1,100 edges
    and ~650 nodes. You can read more about the data here: [http://networkrepository.com/bio-DM-LC.php](http://networkrepository.com/bio-DM-LC.php).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们需要`ggraph`和`igraph`包及其依赖项，包括`magrittr`、`readr`和`dplyr`。我们还需要来自本书代码库中`datasets/ch7`文件夹的`bio-DM-LC.edges`文件。这个文件包含来自WormNet的一些基因功能关联数据。网络包含大约1,100条边和650个节点。你可以在这里阅读更多关于数据的信息：[http://networkrepository.com/bio-DM-LC.php](http://networkrepository.com/bio-DM-LC.php)。
- en: How to do it...
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Representing relational data as networks can be done using the following steps:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 将关系数据表示为网络可以通过以下步骤完成：
- en: 'Load the packages and prepare the dataframe:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载包并准备数据框：
- en: '[PRE12]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Create an `igraph` object and use it in a basic plot:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`igraph`对象并在基础图形中使用它：
- en: '[PRE13]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Color the edges according to their value or type:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据边的值或类型给边着色：
- en: '[PRE14]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Add the node attributes and color nodes accordingly:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加节点属性并相应地为节点着色：
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: How it works...
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In *Step 1*, we loaded the libraries we needed and then prepared the dataframe
    from the file of edges. The input file is basically an edge list. Each row describes
    a connection with one of the target nodes in the first column and one in the second.
    The third column contains a value representing the strength of the interaction
    between those two nodes, which we'll think of as an edge weight. The fields are
    separated by a single space and the file has no header with column names. As such,
    we set the values of the `delim` and `col_names` arguments appropriately. We pipe
    the dataframe to the `dplyr::mutate()` function to add an extra column called
    `edge_type`. In this column, we randomly assign either `"A"` or `"B"` to each
    row using the `sample()` function. The resulting object is saved in the `df` variable.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第 1 步*中，我们加载了所需的库，并从边列表文件中准备了数据框。输入文件基本上是一个边列表。每一行描述了一个连接，第一列是目标节点之一，第二列是另一个目标节点。第三列包含一个值，表示这两个节点之间交互的强度，我们可以将其视为边的权重。字段由空格分隔，文件没有列名标题。因此，我们适当地设置了`delim`和`col_names`参数的值。然后，我们将数据框传递给`dplyr::mutate()`函数，添加一个名为`edge_type`的额外列。在该列中，我们使用`sample()`函数随机为每一行分配`"A"`或`"B"`。最终的对象保存在`df`变量中。
- en: 'In *Step 2*, we created the igraph object from `df` using the `igraph::graph_from_data_frame()`
    function and saved it to the `graph` variable. We passed the `igraph` graph object
    as the first object to the `ggraph()` function, which works analogously to `ggplot()`*.*
    It takes the `graph` object and a layout argument. (Here, we use `"kk"`, but the
    exact one to use will be heavily dependent on the data itself.) Then, we added
    layers with the `+` operator. First, we added the `geom_edge_link()` layer, which
    draws the edges, then `geom_node_point()`, which draws the nodes, and finally,
    we add `theme_void()`, which removes the background gray panel and white lines
    and leaves a clear background for the network. The initial plot looks like this:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第 2 步*中，我们使用`igraph::graph_from_data_frame()`函数从`df`创建了`igraph`对象，并将其保存在`graph`变量中。我们将`igraph`图形对象作为第一个对象传递给`ggraph()`函数，后者与`ggplot()`类似。它接收`graph`对象和一个布局参数。（在这里，我们使用`"kk"`，但具体使用哪个布局将高度依赖于数据本身。）然后，我们使用`+`运算符添加层。首先，我们添加了`geom_edge_link()`层，它绘制了边，然后是`geom_node_point()`，它绘制了节点，最后，我们添加了`theme_void()`，它去除了背景的灰色面板和白色线条，为网络留下了一个清晰的背景。初始图形如下所示：
- en: '![](img/2cc1a139-5b20-4d55-88fc-754f5213eb3b.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2cc1a139-5b20-4d55-88fc-754f5213eb3b.png)'
- en: 'In *Step 3*, we added some data-based customizations. We started by changing
    the layout algorithm to `"fr"`, which gives a nicer and more spread out view.
    Then, we used the `aes()` function in `geom_edge_link()` to set the edge color
    to be mapped to the `edge_type` value. The remaining layers were added like they
    were previously. By doing this, we get the following plot:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第 3 步*中，我们添加了一些基于数据的自定义设置。我们首先将布局算法更改为`"fr"`，这种算法提供了更美观且更分散的视图。然后，我们在`geom_edge_link()`中使用`aes()`函数将边的颜色映射到`edge_type`值。剩下的层像之前一样添加。通过这样做，我们得到了以下图形：
- en: '![](img/772fcbe4-3dab-4b75-8f60-0a43e50b9507.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/772fcbe4-3dab-4b75-8f60-0a43e50b9507.png)'
- en: 'In *Step 4*, we set up some attributes for the nodes. This is simpler than
    it looks. The `V()` function from `igraph` returns a simple vector of the node
    IDs in the `graph` object (nodes are called vertices in igraph jargon), so we
    calculate the length of the vector and use it to make a random vector of the `Nucleus`,
    `Mitochondrion`, and `Cytoplasm` values. We can then assign these new values to
    the nodes by using the `V()` function with `$` indexing. We can create any attribute
    we like, so `igraph::V(graph)$category` creates a new attribute called **category**.
    We can assign the new values straight to the attribute using the standard `*<-*` assignment
    operator. The next step is similar; `igraph::V(graph)$degree` creates an attribute
    called **degree**. In our case, we assign the result of the `igraph::degree()`
    function. Degree is the graph jargon term for the number of edges that meet at
    a node. We now have new attributes and can color our graph accordingly. The `ggraph()`
    construction proceeds as it did previously, but in the `geom_node_point()` layer,
    we use `aes()` to map color to our new category attribute and size to our new
    `degree` attribute. The resulting plot looks like this:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第4步* 中，我们为节点设置了一些属性。这比看起来要简单。`igraph` 中的 `V()` 函数返回一个简单的节点 ID 向量（在 igraph
    行话中，节点被称为顶点），因此我们计算该向量的长度，并用它生成一个包含 `Nucleus`、`Mitochondrion` 和 `Cytoplasm` 值的随机向量。然后我们可以通过使用带有
    `$` 索引的 `V()` 函数将这些新值分配给节点。我们可以创建任何我们喜欢的属性，因此 `igraph::V(graph)$category` 创建了一个名为
    **category** 的新属性。我们可以使用标准的 `*<-*` 赋值运算符将新值直接分配给该属性。接下来的步骤类似；`igraph::V(graph)$degree`
    创建了一个名为 **degree** 的属性。在我们的案例中，我们将 `igraph::degree()` 函数的结果分配给它。Degree 是图论中的术语，表示与一个节点相连的边的数量。现在我们拥有了新的属性，可以根据这些属性对图形进行上色。`ggraph()`
    构建过程与之前相同，但在 `geom_node_point()` 层中，我们使用 `aes()` 将颜色映射到我们新的 category 属性，并将大小映射到我们新的
    degree 属性。最终的图形如下所示：
- en: '![](img/29ba5b4d-1884-41ee-bdbe-c1758200658b.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](img/29ba5b4d-1884-41ee-bdbe-c1758200658b.png)'
- en: There's more...
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: 'Hive plots are a nice way of plotting networks, especially when you have three
    node types or some sort of directional structure. You can create a hive plot out
    of the same sort of data we already have, like so:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 蜂窝图是绘制网络的好方法，尤其是在你有三种节点类型或某种方向性结构时。你可以使用我们已经拥有的相同类型的数据创建一个蜂窝图，如下所示：
- en: '[PRE16]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here, we set up the layout type to be `hive` and specify the attribute on which
    to make the axis `category`. The edge description in `geom_edge_hive()` is pretty
    much like it was previously, with an `alpha` argument called `..index..` that
    adds a transparency element to the edges based on how early they are plotted.
    The `geom` node is replaced with `geom_axis_hive()`, in which we use `aes()` to
    map a color to the category. The resultant plot looks like this:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们设置布局类型为 `hive`，并指定用于制作轴的属性为 `category`。在 `geom_edge_hive()` 中的边描述与之前差不多，`alpha`
    参数为 `..index..`，它根据边的绘制顺序为边缘添加透明度元素。`geom` 节点被替换为 `geom_axis_hive()`，我们在其中使用 `aes()`
    将颜色映射到 category 属性。生成的图形如下所示：
- en: '![](img/c88697a7-7aab-4240-8c29-eb4b1abc601a.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c88697a7-7aab-4240-8c29-eb4b1abc601a.png)'
- en: Creating interactive web graphics with plotly
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 plotly 创建交互式网页图形
- en: Exploring a dataset interactively through a graphical user interface can be
    a rewarding and enlightening way to analyze and interrogate data. Dynamically
    adding and removing data from a plot, zooming in and out of specific parts, or
    allowing the plot to change with time-dependent on underlying data can allow us
    to see trends and features we could not see with static plots. In this recipe,
    we'll look at using the `plotly` library to create interactive graphics in R,
    building up from a basic plot to a more involved one.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 通过图形用户界面交互式地探索数据集是一种有益且启发性的方式，能够分析和审视数据。动态地在图形中添加和删除数据、放大或缩小特定部分，或让图形随着时间变化（依赖于底层数据）可以让我们看到一些在静态图形中看不见的趋势和特征。在这个实例中，我们将使用
    `plotly` 库在 R 中创建交互式图形，从一个基本图形开始，逐步构建一个更复杂的图形。
- en: Getting ready
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we'll use the built-in Orange data, which describes changes
    in the circumference of orange trees' trunks over time. This is part of the (usually)
    preinstalled `datasets` package, so you should be able to access it straight away.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实例中，我们将使用内置的 Orange 数据集，它描述了橙树树干围长随时间的变化。该数据集是 `datasets` 包的一部分（通常已经预装），因此你应该能够立即访问它。
- en: How to do it...
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Creating interactive web graphics with `plotly` can be done using the following
    steps:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `plotly` 创建交互式网页图形可以通过以下步骤完成：
- en: 'Load the library and make a basic plot:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载库并创建一个基本图形：
- en: '[PRE17]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Map the color and size of markers and hover over text to data:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 映射标记的颜色和大小以及悬停文本到数据：
- en: '[PRE18]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Add a second series/trace:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加第二个系列/迹线：
- en: '[PRE19]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Add a drop-down menu so that you can select the plot type:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个下拉菜单，以便您可以选择图表类型：
- en: '[PRE20]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: How it works...
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'After loading the library in *Step 1*, we used the core `plot_ly()` function
    to create the simplest plot possible. We passed `plot_ly()` the name of the dataframe,
    and the columns for the *x* and *y* axes as formulae—hence the `~` sign. At this
    point, we haven''t explicitly specified the trace type, what `plotly` calls its
    series or data tracks, so it guesses and makes a scatter plot, as shown in the
    following graph:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第1步*加载库后，我们使用核心的`plot_ly()`函数创建了可能最简单的图。我们向`plot_ly()`传递了数据框的名称，以及作为公式的*x*和*y*轴的列，因此使用了`~`符号。在这一点上，我们还没有明确指定迹线类型，即`plotly`称其为系列或数据轨道，所以它猜测并创建了一个散点图，如下图所示：
- en: '![](img/6861dbc2-2587-4488-8c0d-0d405cd4e12d.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6861dbc2-2587-4488-8c0d-0d405cd4e12d.png)'
- en: Note the menu icons at the top of the plot and the hover text that appears when
    you mouse over a data point. These figures can be interacted with perfectly well
    within an interactive R session but are better suited to HTML-based documents
    such as compiled R markdown.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 注意图表顶部的菜单图标以及当鼠标悬停在数据点上时显示的悬停文本。这些图形在交互式R会话中可以很好地进行交互，但更适合于HTML-based文档，例如编译的R
    markdown。
- en: 'In *Step 2*, we mapped the features in the plot to aspects of the data. We
    set the size and color to map to the Tree ID and age columns, again as a formula
    with the `~` syntax. We also set the hover text for each point and used `paste()` to
    compile the exact format. Note that the hover text is HTML-based and that we can
    use tags such as `<br>` to format the hover as we choose. Our plot is now improved
    to look like the following:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第2步*中，我们将图中的特征映射到数据的各个方面。我们将大小和颜色设置为与树木ID和年龄列相对应的公式，再次使用`~`语法。我们还为每个数据点设置了悬停文本，并使用`paste()`函数编译了确切的格式。请注意，悬停文本是基于HTML的，我们可以使用诸如`<br>`这样的标签来按照选择的方式格式化悬停效果。我们的图现在改进为如下所示：
- en: '![](img/b17950f4-e633-40ba-a6ad-339251331123.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b17950f4-e633-40ba-a6ad-339251331123.png)'
- en: 'In *Step 3*, our major change is to explicitly specify the trace data. To highlight
    that traces can carry data outside of the original dataframe, we created a new
    data vector called `trace_1` using `rnorm()`, which contains 35 random numbers
    with a mean of 120 and a standard deviation of 1\. We created our plot in the
    same way as we created the plot in *Step 2*, but this time we used the `magrittr` pipe
    to send the plot object to the `add_trace()` function. Here, we pass the new `trace_1`
    object as our `y` value and set `mode` to `"lines"` to get a line graph. Again,
    we piped that to another `add_trace()` function (we can build up a plot from multiple
    trace series in this way), but this time used the original dataframe column circumference
    and set `mode` to `"markers"`. The resulting plot looks like this:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第3步*中，我们的主要变化是明确指定了迹线数据。为了突出显示迹线可以携带超出原始数据框之外的数据，我们使用`rnorm()`创建了一个名为`trace_1`的新数据向量，其中包含35个均值为120，标准差为1的随机数。我们与在*第2步*创建图表的方式相同，但这次我们使用了`magrittr`管道将图形对象发送到`add_trace()`函数。在这里，我们将新的`trace_1`对象作为我们的`y`值传递，并将`mode`设置为`"lines"`以获得折线图。再次，我们将其传递到另一个`add_trace()`函数（我们可以通过多个迹线系列构建一个图），但这次使用原始数据框列周长，并将`mode`设置为`"markers"`。生成的图表看起来像这样：
- en: '![](img/65b6953c-b853-42f4-a768-d1a6741e6542.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](img/65b6953c-b853-42f4-a768-d1a6741e6542.png)'
- en: 'In *Step 4*, we introduced menus into our plot. The menu we implemented will
    allow us to switch between trace types—from lines to markers and back. The step
    started with the same basic call to `plot_ly()` and then piping to just one trace
    this time. Next, we piped to the `layout` function, which takes a plot title in
    the `title` argument and a complicated list of options for the `updatemenus` argument.
    You must pass a list of lists to `updatemenus` that has three members – `type`,
    `y`, and `buttons`. `type` sets the type of menu—in this case, we want a dropdown; `y`
    sets the position of the menu on the *y* axis as a value between 0 and 1, and
    `buttons` requires another list of lists in which each sublist describes a menu
    option. Each sublist has the `members` method, as well as `args` and `labels`.
    The `setting` method is used to `"restyle"`, which means the plot will update
    on menu selection. The `args` member requires another list specifying the `"mode"`
    and `"type"` for the current menu option. Finally, `label` specifies the text
    that will appear in the menu itself for this menu option. The plot looks as follows
    when we select **Marker** in the dropdown, which renders on the left:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第4步*中，我们将菜单引入了我们的图表。我们实现的菜单将允许我们在不同的追踪类型之间切换——从线条到标记，再到线条。此步骤以相同的基本`plot_ly()`调用开始，然后这次只传入一个追踪。接下来，我们传入了`layout`函数，该函数接受一个图表标题作为`title`参数，并为`updatemenus`参数提供一个复杂的选项列表。你必须将一个包含三个成员的列表传递给`updatemenus`——`type`、`y`和`buttons`。`type`设置菜单类型——在这种情况下，我们想要一个下拉菜单；`y`设置菜单在*y*轴上的位置，值范围为0到1，而`buttons`需要另一个列表，其中每个子列表描述一个菜单选项。每个子列表都有`members`方法，以及`args`和`labels`。`setting`方法用于`"restyle"`，意味着图表将在选择菜单时更新。`args`成员需要另一个列表，指定当前菜单选项的`"mode"`和`"type"`。最后，`label`指定此菜单选项在菜单中显示的文本。当我们在下拉菜单中选择**Marker**时，图表如下所示，渲染在左侧：
- en: '![](img/3ae09760-4a47-4a46-9a18-1c78a8a9e5ef.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3ae09760-4a47-4a46-9a18-1c78a8a9e5ef.png)'
- en: Constructing three-dimensional plots with plotly
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用plotly构建三维图表
- en: Most plots we generate in bioinformatics are static and stuck in a two-dimensional
    plane, but modern web technologies allow us to interact with three-dimensional
    objects with dynamic rendering. The `plotly` library has tools for rendering different
    kinds of 3D plots and in this recipe, we'll look at how to construct a 3D surface
    plot and a scatter plot with *x*, *y*, and *z* axes.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在生物信息学中生成的大多数图表都是静态的，并且局限于二维平面，但现代网络技术使我们能够与三维对象进行互动并动态渲染。`plotly`库提供了渲染不同类型3D图表的工具，在这个教程中，我们将展示如何构建一个3D表面图和一个带有*x*、*y*、*z*轴的散点图。
- en: Getting ready
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: In this recipe, we'll use the `plotly` library again and the built-in `longley`
    dataset of economic data.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将再次使用`plotly`库，并且使用内置的`longley`经济数据集。
- en: How to do it...
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Constructing three-dimensional plots with `plotly` can be done using the following
    steps:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`plotly`构建三维图表可以通过以下步骤完成：
- en: 'Set up the data objects:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置数据对象：
- en: '[PRE21]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Create the basic surface plot:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建基本的表面图：
- en: '[PRE22]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Add a reactive contour plot layer:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个响应式等高线图层：
- en: '[PRE23]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: How it works...
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In *Step 1*, we begin by building a dataset that''s appropriate for the type
    of plot. For the surface 3D plot, we need a dataframe of *x* and *y* coordinates,
    which we create directly using `data.frame()` and save in a variable called `d`.
    The dataframe, `d`, contains a sequence of 20 values between 0 and 10 in the x
    and y columns (10 values each). You should think of this dataframe as specifying
    the width and length of the 3D field, and not the actual data values. The data
    values come in a distinct matrix object with the dimensions specified by the dataframe.
    We created a matrix of appropriate dimension using the `matrix()` function with
    random normal values from the `rnorm()` function. Once we have these two structures,
    we can use them in `plot_ly()` while specifying `d`, `x`, and `y`, like we did
    for two-dimensional plots, and with the new *z *axis, which gets our matrix. The
    result is piped to the `add_surface()` function, which renders the data as a three-dimensional
    surface. The plot will look something like the following:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第1步*中，我们首先构建一个适合图表类型的数据集。对于表面三维图，我们需要一个包含*x*和*y*坐标的数据框，我们直接使用`data.frame()`函数创建，并将其保存在一个名为`d`的变量中。数据框`d`包含了x和y列之间从0到10的20个值（每列10个值）。你可以将这个数据框视为指定三维场的宽度和长度，而不是实际的数据值。数据值是通过与数据框指定的维度相对应的矩阵对象获得的。我们使用`matrix()`函数创建了一个适当维度的矩阵，矩阵中的值是通过`rnorm()`函数生成的随机正态值。一旦我们有了这两个结构，就可以像之前为二维图表做的那样，使用它们在`plot_ly()`函数中指定`d`、`x`和`y`，并添加新的*z*轴来获取我们的矩阵。结果被传递给`add_surface()`函数，将数据渲染为三维表面。该图表的效果类似如下：
- en: '![](img/937a3979-ea5e-45ba-9899-98ff241c9740.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](img/937a3979-ea5e-45ba-9899-98ff241c9740.png)'
- en: Note that by clicking and dragging within the plot area, you can adjust the
    camera view.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，点击并拖动图表区域，你可以调整相机视角。
- en: 'In *Step 2*, we elaborate on the plot by adding a reactive contour plot under
    (or over) the 3D surface. We used the contours option in the `add_surface()` function.
    This takes a list of options. The first `z` specifies what to do with the contour.
    It takes a further list with members to control the appearance of the contour
    map, the most important being `highlightcolor`, which specifies the color to draw onto
    the contour plot to show the current level of the 3D plot the mouse is hovering
    over. The rendered image looks something like this:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第2步*中，我们通过在三维表面下方（或上方）添加一个反应式等高线图来进一步完善图表。我们在`add_surface()`函数中使用了contours选项。它接受一个选项列表。第一个`z`指定如何处理等高线。它还接受一个包含多个成员的列表，用于控制等高线图的外观，最重要的选项是`highlightcolor`，它指定了在等高线图上绘制的颜色，用于显示鼠标悬停的当前三维图层。渲染后的图像类似于以下效果：
- en: '![](img/2e83eb40-202c-4423-be61-9b5b2f8558cf.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2e83eb40-202c-4423-be61-9b5b2f8558cf.png)'
- en: 'In *Step 3*, we changed tack and drew a scatter plot in three dimensions. This
    is more straightforward. We passed the Longley data to the `plot_ly()` function,
    along with the dimensions and the data columns to map to. We also added a marker
    option to map color to the GNP column. Finally, we piped the basic plot object
    to the `add_markers()` function to get the final plot, which renders like this:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第3步*中，我们改变了方向，绘制了一个三维散点图。这更加直接。我们将Longley数据传递给`plot_ly()`函数，并指定了维度和数据列进行映射。我们还添加了一个标记选项，将颜色映射到GNP列。最后，我们将基本图对象传递给`add_markers()`函数，得到最终图表，效果如下所示：
- en: '![](img/eccfaa8a-99e6-482b-b01c-87726e45f6a8.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eccfaa8a-99e6-482b-b01c-87726e45f6a8.png)'
- en: Constructing circular genome plots of polyomic data
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建多组学数据的圆形基因组图
- en: A whole genome analysis of multiple data series is often presented in a circular
    manner with concentric circles, each showing different kinds of data with a different
    representation in each. These plots, called Circos plots, are extremely powerful
    and can show a lot of dense information in a compact form. In this recipe, we'll
    look at constructing such plots in R from common genomics data files.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 对多条数据序列的整体基因组分析通常以圆形方式呈现，采用同心圆，每个圆显示不同种类的数据，每个数据在圆中的表示方式不同。这些图表被称为Circos图，具有极大的表现力，可以在紧凑的形式中显示大量的密集信息。在本教程中，我们将学习如何在R中构建这样的图表，使用常见的基因组数据文件。
- en: Getting ready
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: To make Circos plots, we'll use the `circlize` package and the four files prefixed
    with `arabidopsis` in the `datasets/ch7/` folder of this book's repository.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 为了制作Circos图，我们将使用`circlize`包以及本书仓库中`datasets/ch7/`文件夹下的四个以`arabidopsis`为前缀的文件。
- en: How to do it...
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Constructing circular genome plots of polyomic data can be done using the following
    steps:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 构建多组学数据的圆形基因组图可以通过以下步骤完成：
- en: 'Load the library and read the chromosome length information:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载库并读取染色体长度信息：
- en: '[PRE24]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Initialize the plot and chromosome track, and then add links:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化图表和染色体轨迹，然后添加链接：
- en: '[PRE25]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Load in link information from the file and draw it:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从文件加载链接信息并绘制：
- en: '[PRE26]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Load in the gene positions and add a density track:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载基因位置并添加密度轨迹：
- en: '[PRE27]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Load in the heatmap data. Then, add a heatmap track:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载热图数据。然后，添加一个热图轨迹：
- en: '[PRE28]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Combine the tracks:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 合并这些轨迹：
- en: '[PRE29]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: How it works...
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In *Step 1*, we begin by reading in the `arabidopsis.gff` file, a file that
    describes the lengths of the chromosomes we'd like to use in our plot. We only
    needed the name, start, and end columns, so we piped the data to the `dplyr::select()`
    function to keep the appropriate columns, that is, `X1`, `X4`, and `X5`. As a
    `.gff` file has no column headings, the `read_tsv()` functions give the column
    names X1 ... Xn. We saved the result in the `df` object.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤 1*中，我们开始通过读取`arabidopsis.gff`文件来构建图表，该文件描述了我们希望在图表中使用的染色体长度。我们只需要名称、开始和结束列，因此我们将数据传递给`dplyr::select()`函数，保留适当的列，即`X1`、`X4`和`X5`。由于`.gff`文件没有列标题，`read_tsv()`函数会给出列名X1
    ... Xn。我们将结果保存在`df`对象中。
- en: 'In *Step 2*, we started building the plot. We used the `circos.genomicInitialize()`
    function with `df` to create the plot''s backbone and coordinate system and then
    manually added a single link. The `circos.link()` function allows us to create
    a single origin and destination using the chromosome''s name, c(start, end) format,
    thereby coloring the link in the requested color. The plot currently looks like
    this:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤 2*中，我们开始构建图表。我们使用`circos.genomicInitialize()`函数和`df`来创建图表的骨架和坐标系统，然后手动添加了一个单独的链接。`circos.link()`函数允许我们使用染色体名称和c(start,
    end)格式创建单个来源和目标，从而将链接着色为请求的颜色。当前图表如下所示：
- en: '![](img/ce859647-57e4-40da-887e-055c9c9ff227.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ce859647-57e4-40da-887e-055c9c9ff227.png)'
- en: 'At the start of *Step 3*, we used `circos.clear()` to completely reset the
    plot. Resetting is only necessary for the purposes of this tutorial as we want
    to build things step-wise; you can likely ignore it in your own coding. The next
    stage is to load in a file of genomic regions that represent the source of some
    links and a separate file of genomic regions that represent the target of some
    links. These two files should be in BED format and row N in the source file must
    correspond to row N in the target file. Then, we reinitialized the plot with `circos.genomicInitialize()` and
    used `circos.genomicLink()` to add many links in one command, passing it the objects
    of the source link data and the target data before coloring them all blue. The
    plot looks like this:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤 3*的开始，我们使用了`circos.clear()`来完全重置图表。重置仅在本教程中需要，因为我们想逐步构建内容；在你自己的编码中，你可能可以忽略它。下一步是加载一个基因组区域文件，代表一些链接的来源，以及一个独立的基因组区域文件，代表一些链接的目标。这两个文件应该是BED格式，并且源文件中的第N行必须与目标文件中的第N行对应。然后，我们使用`circos.genomicInitialize()`重新初始化图表，并使用`circos.genomicLink()`在一个命令中添加多个链接，传入源链接数据和目标数据的对象，然后将它们全部着色为蓝色。图表如下所示：
- en: '![](img/678fa268-b228-4375-883b-f933cf5b2d0d.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](img/678fa268-b228-4375-883b-f933cf5b2d0d.png)'
- en: 'In *Step 4*, after clearing the plot, we read in another BED file of gene positions
    from `arabidopsis_genes.bed`. We want to add this information as a density track
    that counts the number of features in the windows of user-specified length and
    plots them as a density curve. To do this, we use the `circos.genomicDensity()` function,
    passing it the dataframe of `gene_positions`, selecting a window size of 1 million,
    a color (note the color is in the eight-digit HEX format that allows us to add
    transparency to the color), and `track.height`, which specifies the proportion
    of the plot to use for this track. The track looks like this:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤 4*中，在清除图表后，我们从`arabidopsis_genes.bed`文件中读取另一个基因位置的BED文件。我们希望将这些信息添加为一个密度轨迹，计算用户指定长度的窗口中功能的数量，并将其绘制为密度曲线。为此，我们使用`circos.genomicDensity()`函数，传入`gene_positions`数据框，选择一个1百万的窗口大小，一种颜色（注意颜色使用八位十六进制格式，允许我们为颜色添加透明度），以及`track.height`，它指定了图表中此轨迹所占的比例。轨迹如下所示：
- en: '![](img/7a08f401-61ce-4069-9ec2-1cd1b20bbe70.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7a08f401-61ce-4069-9ec2-1cd1b20bbe70.png)'
- en: 'In *Step 5*, we added a more complex track—a heatmap that can represent many
    columns of quantitative data. The file format here is extended BED format, with
    a chromosome name, start, and end with data in any further columns. We have three
    extra columns of data in our sample `arabidopsis_quant_data.bed` file. We load
    the bed file into `heatmap_data` with `read.delim()`. Next, we created a color
    function and saved it as `col_fun` to help draw the heatmap. The `colorRamp2()` function
    takes a vector of the minimum, middle, and maximum values of the data as its argument,
    for which the colors specified in the second argument should be used. So, with
    `10`, `12`, and `15` and `green`, `red`, and `black`, we drew 10 in green, 12
    in black, and 15 in red, respectively. The colors for the values in-between those
    points are calculated automatically by `colorRamp2()`. To draw the heatmap, we
    used the `circos.genomicHeatmap()` function, passing `col_fun` to the `col` argument.
    The `side` argument specifies whether to draw inside or outside the circle, while
    the `border` argument specifies the color of the lines between heatmap elements.
    The plot looks like this:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第5步*中，我们添加了一个更复杂的轨迹——一个热图，可以表示许多列的定量数据。这里的文件格式是扩展的BED格式，包含染色体名称、起始位置和结束位置，以及后续列中的数据。在我们的示例文件`arabidopsis_quant_data.bed`中有三个额外的数据列。我们通过`read.delim()`将BED文件加载到`heatmap_data`中。接下来，我们创建了一个颜色函数，并将其保存为`col_fun`，用于绘制热图。`colorRamp2()`函数接受数据的最小值、中值和最大值的向量作为其参数，然后使用第二个参数中指定的颜色。因此，使用`10`、`12`和`15`以及`绿色`、`红色`和`黑色`，我们分别将10绘制为绿色，12绘制为黑色，15绘制为红色。介于这些值之间的颜色会由`colorRamp2()`自动计算。为了绘制热图，我们使用了`circos.genomicHeatmap()`函数，并将`col_fun`传递给`col`参数。`side`参数指定是否在圆内或圆外绘制，而`border`参数指定热图元素之间线条的颜色。绘图效果如下：
- en: '![](img/9cd724a1-0585-4cd5-95f6-80b48894a4c7.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9cd724a1-0585-4cd5-95f6-80b48894a4c7.png)'
- en: 'Finally, in *Step 6*, we put all of this together. By clearing and reinitializing
    the plot, we specified the order of the tracks from outside to in by calling the
    relevant functions in outside first to inside last order:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在*第6步*中，我们将所有内容结合在一起。通过清除并重新初始化绘图，我们通过按从外到内的顺序调用相关函数来指定轨迹的顺序：
- en: '![](img/45d052d2-678b-4bee-9ba8-30f3f2adca7e.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![](img/45d052d2-678b-4bee-9ba8-30f3f2adca7e.png)'
- en: The final plot, as seen in the preceding image, gets `circos.genomicHeatmap()`,
    then `circos.genomicDensity()`, and then `circos.genomicLink()`to give us the
    circular genome plot.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的图形，如前面所见，先是`circos.genomicHeatmap()`，然后是`circos.genomicDensity()`，最后是`circos.genomicLink()`，以得到圆形基因组图。
