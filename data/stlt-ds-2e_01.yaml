- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: An Introduction to Streamlit
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Streamlit 简介
- en: Streamlit is the fastest way to make data apps. It is an open-source Python
    library that helps you build web applications to be used for sharing analytical
    results, building complex interactive experiences, and iterating on top of new
    machine learning models. On top of that, developing and deploying Streamlit apps
    is incredibly fast and flexible, often reducing the application development time
    from days to hours.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Streamlit 是创建数据应用的最快方式。它是一个开源的 Python 库，帮助你构建用于共享分析结果、构建复杂的互动体验，并在新的机器学习模型上进行迭代的
    Web 应用。此外，开发和部署 Streamlit 应用非常快速且灵活，通常将应用开发时间从几天缩短到几小时。
- en: In this chapter, we will start out with the Streamlit basics. We will learn
    how to download and run demo Streamlit apps, how to edit demo apps using our own
    text editor, how to organize our Streamlit apps, and finally, how to make our
    very own apps. Then, we will explore the basics of data visualization in Streamlit.
    We will learn how to accept some initial user input, and then add some finishing
    touches to our own apps with text. By the end of this chapter, you should be comfortable
    with starting to make your own Streamlit apps!
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将从 Streamlit 基础知识开始。我们将学习如何下载和运行示例 Streamlit 应用，如何使用我们自己的文本编辑器编辑示例应用，如何组织我们的
    Streamlit 应用，最后，如何制作我们自己的应用。然后，我们将探索 Streamlit 中的数据可视化基础。我们将学习如何接受一些初始用户输入，然后通过文本为我们的应用添加一些修饰。到本章结束时，你应该能够熟练地开始制作自己的
    Streamlit 应用！
- en: 'In particular, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 特别地，我们将涵盖以下主题：
- en: Why Streamlit?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么选择 Streamlit？
- en: Installing Streamlit
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 Streamlit
- en: Organizing Streamlit apps
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组织 Streamlit 应用
- en: Streamlit plotting demo
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Streamlit 绘图示例
- en: Making an app from scratch
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从零开始制作一个应用
- en: Before we begin, we will start with the technical requirements to make sure
    we have everything we need to get started.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，我们将首先了解技术要求，确保我们具备了开始所需的一切。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Here are the installations and setup required for this chapter:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章所需的安装和设置：
- en: The requirements for this book are to have Python 3.9 (or later) downloaded
    ([https://www.python.org/downloads/](https://www.python.org/downloads/)) and have
    a text editor to edit Python files in. Any text editor will do. I use VS Code
    ([https://code.visualstudio.com/download](https://code.visualstudio.com/download)).
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本书的要求是下载 Python 3.9（或更高版本）（[https://www.python.org/downloads/](https://www.python.org/downloads/)）并拥有一个文本编辑器来编辑
    Python 文件。任何文本编辑器都可以。我使用的是 VS Code（[https://code.visualstudio.com/download](https://code.visualstudio.com/download)）。
- en: 'Some sections of this book use GitHub, and a GitHub account is recommended
    ([https://github.com/join](https://github.com/join)). Understanding how to use
    Git is not necessary for this book but is always useful. If you want to get started,
    this link has a useful tutorial: [https://guides.github.com/activities/hello-world/](https://guides.github.com/activities/hello-world/).'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本书的某些部分使用 GitHub，推荐拥有一个 GitHub 账户（[https://github.com/join](https://github.com/join)）。理解如何使用
    Git 对于本书并非必要，但总是很有用。如果你想入门，这个链接有一个实用的教程：[https://guides.github.com/activities/hello-world/](https://guides.github.com/activities/hello-world/)。
- en: A basic understanding of Python is also very useful for this book. If you are
    not there yet, feel free to spend some time getting to know Python better using
    this tutorial ([https://docs.python.org/3/tutorial/](https://docs.python.org/3/tutorial/))
    or any other of the freely and readily available tutorials out there, and come
    back here when you are ready. We also need to have the Streamlit library installed,
    which we will do in a later section called *Installing Streamlit*.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本书还需要一定的 Python 基础。如果你还不熟悉，可以通过这个教程（[https://docs.python.org/3/tutorial/](https://docs.python.org/3/tutorial/)）或其他免费、随手可得的教程花些时间深入了解
    Python，准备好后再回来继续。我们还需要安装 Streamlit 库，我们将在后面的章节中进行安装，章节名为 *安装 Streamlit*。
- en: Why Streamlit?
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么选择 Streamlit？
- en: Data scientists have become an increasingly valuable resource for companies
    and nonprofits over the course of the past decade. They help make data-driven
    decisions, make processes more efficient, and implement machine learning models
    to improve these decisions at scale. One pain point for data scientists is the
    process just after they have found a new insight or made a new model. What is
    the best way to show a dynamic result, a new model, or a complicated piece of
    analytics to a data scientist’s colleagues? They can send a static visualization,
    which works in some cases but fails for complicated analyses that build on each
    other or on anything that requires user input. They can create a Word document
    (or export their Jupyter notebook as a document) that combines text and visualizations,
    which also doesn’t incorporate user input and makes reproducible results much
    harder. Another option still is to build out an entire web application from scratch
    using a framework such as Flask or Django, and then figure out how to deploy the
    entire app in AWS or another cloud provider.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去十年中，数据科学家已成为公司和非营利组织越来越宝贵的资源。他们帮助做出数据驱动的决策，提升流程效率，并实现机器学习模型以大规模改善这些决策。数据科学家的一个痛点是，在他们发现新的见解或建立新的模型后，如何展示这些结果。如何展示动态结果、新模型或复杂的分析给同事看呢？他们可以发送一个静态的可视化，这在某些情况下有效，但对于那些依赖相互关联或需要用户输入的复杂分析就行不通了。他们还可以创建一个Word文档（或者将Jupyter笔记本导出为文档），该文档将文本和可视化结合起来，但它依然无法整合用户输入，并且使得结果难以复现。另一种选择是，使用Flask或Django等框架从头开始构建整个网页应用，然后再想办法将整个应用部署到AWS或其他云服务商上。
- en: None of these options really work that well. Many are slow, don’t take user
    input, or are suboptimal for informing the decision-making process so fundamental
    to data science.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这些选项没有一个真正有效。许多方法都很慢，不能接受用户输入，或者在数据科学中非常关键的决策过程方面不够理想。
- en: Enter Streamlit. Streamlit is all about speed and interaction. It is a web application
    framework that helps you build and develop Python web applications. It has built-in
    and convenient methods for everything from taking in user inputs like text and
    dates to showing interactive graphs using the most popular and powerful Python
    graphing libraries.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是Streamlit的魅力所在。Streamlit注重速度和互动性。它是一个帮助你构建和开发Python网页应用的框架。它内置了方便的方法，可以处理从用户输入（如文本和日期）到显示使用最流行和强大的Python图形库绘制的互动图表的所有需求。
- en: I have spent the past two years building Streamlit apps of all different flavors,
    from data projects for my personal portfolio to building quick applications for
    data science take-home problems to even building mini-apps for repeatable analysis
    at work. When I started this journey, I worked at Meta (then Facebook), but after
    the first edition of this book was published, I loved working on Streamlit apps
    so much that I went to work for the Streamlit team. Soon after I moved over, the
    Data Cloud company Snowflake purchased Streamlit. None of this is book is sponsored
    by Snowflake, and I certainly do not speak for Snowflake, but I truly believe
    that Streamlit could be as valuable to you and your work as it has been to mine.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 过去两年，我一直在构建各种类型的Streamlit应用，从个人作品集中的数据项目，到为数据科学的家庭作业任务快速构建的应用，再到为工作中可重复分析构建的迷你应用。当我开始这段旅程时，我在Meta（当时是Facebook）工作，但在本书的第一版发布后，我如此热爱Streamlit应用的开发，以至于我加入了Streamlit团队。不久后，数据云公司Snowflake收购了Streamlit。这本书并没有得到Snowflake的赞助，我当然不代表Snowflake发言，但我真心相信，Streamlit对你和你的工作来说，可能和对我一样有价值。
- en: I wrote this book to bring you quickly up to speed so you can accelerate your
    learning curve and get to building web applications in minutes and hours instead
    of days. If this is for you, read on!
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我写这本书是为了帮助你迅速掌握知识，以便你能够加快学习进程，在几分钟到几个小时内构建网页应用，而不是几天。如果这正是你所需要的，继续阅读吧！
- en: We will work in three sections, starting with an introduction to Streamlit,
    and ramping you up to building your own basic Streamlit applications. In *Part
    2*, we’ll extend this knowledge to more advanced topics such as production deployment
    methods and using Components created by the Streamlit community for increasingly
    beautiful and usable Streamlit apps. And in the last part, we’ll focus heavily
    on interviews with power users who use Streamlit at work, in academia, and for
    learning data science techniques. Before we begin, we need to get Streamlit set
    up and discuss how this book’s examples will be structured.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将分三个部分进行学习，首先介绍 Streamlit，然后带你逐步构建自己的基础 Streamlit 应用程序。在*第二部分*，我们将扩展这些知识，涵盖更高级的主题，例如生产环境部署方法以及使用
    Streamlit 社区创建的组件来构建越来越美观和可用的 Streamlit 应用程序。最后一部分，我们将重点采访那些在工作、学术界和数据科学学习中使用
    Streamlit 的高级用户。在我们开始之前，我们需要先设置好 Streamlit，并讨论本书示例的结构。
- en: Installing Streamlit
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Streamlit
- en: In order to run any Streamlit apps, you must first install Streamlit. I’ve used
    a package manager called `pip` to do this, but you can install it using any package
    manager you choose (for example, `brew`). This book uses Streamlit version 1.13.0
    and Python 3.9, but it should work on newer versions as well.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行任何 Streamlit 应用程序，必须先安装 Streamlit。我使用了名为 `pip` 的包管理器来安装它，但你也可以使用任何你选择的包管理器进行安装（例如，`brew`）。本书使用的是
    Streamlit 版本 1.13.0 和 Python 3.9，但它也应该适用于更新的版本。
- en: 'Throughout this book, we’ll be using a mix of both terminal commands and code
    written in Python scripts. We will signpost in which location to run the code
    to make this as clear as possible. To install Streamlit, run the following code
    in a terminal:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将结合使用终端命令和 Python 脚本中的代码。我们会明确指示在哪个位置运行代码，以便尽可能清晰。要安装 Streamlit，请在终端中运行以下代码：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now that we have Streamlit downloaded, we can call it directly from our command
    line using the preceding code to kick off Streamlit’s demo using the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经下载了 Streamlit，我们可以通过命令行直接调用它，使用以下代码启动 Streamlit 的演示：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Take some time to explore Streamlit’s demo and take a glance at any code that
    you find interesting! We’re going to borrow and edit the code behind the plotting
    demo, which illustrates a combination of plotting and animation with Streamlit.
    Before we dive in, let’s take a second and talk about how to organize Streamlit
    apps.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 花些时间浏览 Streamlit 的演示，并快速浏览任何你觉得有趣的代码！我们将借用并编辑绘图示例背后的代码，该示例展示了 Streamlit 中绘图和动画的结合。在深入之前，我们先花点时间讨论一下如何组织
    Streamlit 应用程序。
- en: Organizing Streamlit apps
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组织 Streamlit 应用程序
- en: Each Streamlit app we create in this book should be contained in its own folder.
    It is tempting to create new files for each Streamlit app, but this promotes a
    bad habit that will bite us later when we talk about deploying Streamlit apps
    and deal with permissions and data for Streamlit.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中我们创建的每个 Streamlit 应用程序都应包含在它自己的文件夹中。虽然我们可能会想为每个 Streamlit 应用程序创建新的文件，但这种做法会养成不好的习惯，等到我们讨论如何部署
    Streamlit 应用并处理权限和数据时，这个问题会影响我们。
- en: 'I would recommend that you have a dedicated individual folder that will house
    all the apps you’ll create throughout this book. I have named mine `streamlit_apps`.
    The following command will make a new folder called `streamlit_apps` and make
    it our current working directory:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议你为将要在本书中创建的所有应用程序准备一个独立的文件夹。我把它命名为 `streamlit_apps`。以下命令将创建一个名为 `streamlit_apps`
    的新文件夹，并将其设置为当前工作目录：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: All the code for this book is housed at [https://github.com/tylerjrichards/Getting-Started-with-Streamlit-for-Data-Science](https://github.com/tylerjrichards/Getting-Started-with-Streamlit-for-Data-Science),
    but I would highly recommend coding by hand for practice. Later in this book,
    we’ll talk about how to create multi-page apps, which essentially allow us to
    have many mini-data apps within our central monoapp. Ensuring that our Streamlit
    apps are well organized will help us with that!
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的所有代码都可以在 [https://github.com/tylerjrichards/Getting-Started-with-Streamlit-for-Data-Science](https://github.com/tylerjrichards/Getting-Started-with-Streamlit-for-Data-Science)
    上找到，但我强烈建议你通过手动编码进行练习。本书后面将介绍如何创建多页面应用程序，这实际上让我们可以在一个中央单一应用中拥有许多小型数据应用。确保我们的 Streamlit
    应用程序组织良好，这将有助于我们实现这一目标！
- en: Streamlit plotting demo
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Streamlit 绘图示例
- en: 'First, we’re going to start to learn how to make Streamlit apps by reproducing
    the plotting demo we saw before in the Streamlit demo with a Python file that
    we’ve made ourselves. In order to do that, we will do the following:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将通过再现之前在 Streamlit 演示中看到的绘图演示，来开始学习如何制作 Streamlit 应用，所用的 Python 文件是我们自己创建的。为了做到这一点，我们将执行以下操作：
- en: Make a Python file where we will house all our Streamlit code.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 Python 文件，用来容纳所有的 Streamlit 代码。
- en: Use the plotting code given in the demo.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用演示中给出的绘图代码。
- en: Make small edits for practice.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进行一些小的编辑来练习。
- en: Run our file locally.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本地运行我们的文件。
- en: 'Our first step is to create a folder called `plotting_app`, which will house
    our first example. The following code makes this folder when run in the terminal,
    changes our working directory to `plotting_app`, and creates an empty Python file
    we’ll call `plot_demo.py`:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一步是创建一个名为 `plotting_app` 的文件夹，来容纳我们的第一个示例。以下代码会在终端中运行时创建此文件夹，将工作目录切换到 `plotting_app`，并创建一个空的
    Python 文件，我们将其命名为 `plot_demo.py`：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now that we’ve made a file called `plot_demo.py`, open it with any text editor
    (if you don’t have one already, I’m partial to VS Code ([https://code.visualstudio.com/download](https://code.visualstudio.com/download))).
    When you open it up, copy and paste the following code in to your `plot_demo.py`
    file:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经创建了一个名为 `plot_demo.py` 的文件，使用任何文本编辑器打开它（如果你还没有编辑器，我个人推荐 VS Code（[https://code.visualstudio.com/download](https://code.visualstudio.com/download)））。当你打开它时，将以下代码复制粘贴到你的
    `plot_demo.py` 文件中：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This code does a few things. First, it imports all the libraries needed and
    creates a line chart in Streamlit’s native graphing framework that starts at a
    random number sampled from a normal distribution with mean 0 and variance 1\.
    And then it runs a `for` loop that keeps sampling new random numbers in bunches
    of 5 and adding that to the sum we had before while waiting for a twentieth of
    a second so we can see the graph change, simulating an animation.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码完成了几件事。首先，它导入了所需的所有库，并在 Streamlit 的原生图形框架中创建了一个线性图表，起点为从均值为 0、方差为 1 的正态分布中随机抽取的一个数。然后，它运行一个
    `for` 循环，不断从正态分布中抽取 5 个新的随机数，并将其加到之前的和中，同时等待 1/20 秒，以便我们能看到图表的变化，模拟动画效果。
- en: 'By the end of this book, you will be able to make apps like this extremely
    quickly. But for now, let’s run this locally by typing the following code in our
    terminal:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 到本书结束时，你将能够非常快速地制作类似的应用。但现在，让我们在本地运行它，在终端中输入以下代码：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This should open a new tab with your app in your default web browser. We should
    see our app run as shown in the following figure. Your app will not show this
    exact line, as random numbers are being generated during each run, but other than
    that, the app should look the same!
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会在默认的 Web 浏览器中打开一个新标签页，显示你的应用。我们应该看到应用运行，正如下图所示。你的应用不会显示完全相同的内容，因为每次运行时都会生成随机数，但除此之外，应用应该看起来是一样的！
- en: '![](img/B18444_01_01.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18444_01_01.png)'
- en: 'Figure 1.1: Plotting demo output'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1：绘图演示输出
- en: 'This is how we will run every Streamlit app, by first calling `streamlit` `run`
    and then pointing Streamlit toward the Python script that houses our app’s code.
    Now let’s change something small within the app so we better understand how Streamlit
    works. The following code changes how many random numbers we plot on our graph,
    but feel free to make any changes you’d like. Make your changes using the following
    code, save your changes in your text editor of choice, and run the file again:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们运行每个 Streamlit 应用的方法：首先调用 `streamlit` `run`，然后将 Streamlit 指向包含应用代码的 Python
    脚本。现在，让我们在应用中做一些小的修改，以便更好地理解 Streamlit 的工作原理。以下代码将改变我们在图表上绘制的随机数数量，但你可以根据自己的需求做任何修改。使用以下代码进行修改，在你选择的文本编辑器中保存更改，并再次运行文件：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You should notice that Streamlit detected a change to the source file and is
    prompting you to rerun the file if you’d like. Click **Rerun** (or **Always rerun**
    if you want this behavior to be the default, which I almost always do), and watch
    your app change.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该注意到 Streamlit 检测到源文件发生了变化，并提示你是否希望重新运行文件。如果需要，可以点击 **Rerun**（或者选择 **Always
    rerun**，如果你希望此行为为默认设置，我几乎总是这么做），然后观察应用的变化。
- en: Feel free to try making some other changes to the plotting app to get the hang
    of it! Once you are ready, let’s move on to making our own apps.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 随意尝试对绘图应用进行一些修改，以熟悉它！一旦准备好，我们就可以继续创建自己的应用了。
- en: Making an app from scratch
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从零开始制作一个应用
- en: Now that we’ve tried out the apps others have made, let’s make our own! This
    app is going to focus on using the central limit theorem, which is a fundamental
    theorem of statistics that says that if we randomly sample with replacement enough
    from any distribution, then the distribution of the mean of our samples will approximate
    the normal distribution.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经尝试过别人制作的应用，让我们来制作自己的应用吧！这个应用将专注于使用中心极限定理，它是统计学的一个基本定理，说明如果我们从任何分布中进行足够多的有放回的随机抽样，那么我们样本的均值分布将近似正态分布。
- en: We are not going to prove this with our app, but instead, let’s try to generate
    a few graphs that help explain the power of the central limit theorem. First,
    let’s make sure that we’re in the correct directory (in this case, the `streamlit_apps`
    folder that we created earlier), make a new folder called `clt_app`, and toss
    in a new file.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会通过应用来证明这个定理，而是尝试生成一些图表，帮助解释中心极限定理的威力。首先，让我们确保我们在正确的目录中（此时是我们之前创建的 `streamlit_apps`
    文件夹），新建一个名为 `clt_app` 的文件夹，并放入一个新文件。
- en: 'The following code makes a new folder called `clt_app`, and again creates an
    empty Python file, this time called `clt_demo.py`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码会创建一个名为 `clt_app` 的新文件夹，并再次创建一个空的 Python 文件，这次命名为 `clt_demo.py`：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Whenever we start a new Streamlit app, we want to make sure to import Streamlit
    (often aliased in this book and elsewhere as `st`). Streamlit has unique functions
    for each type of content (text, graphs, pictures, and other media) that we can
    use as building blocks for all of our apps. The first one we’ll use is `st.write()`,
    which is a function that takes a string (and as we’ll see later, almost any Pythonic
    object, such as a dictionary) and writes it directly into our web app in the order
    that it is called. As we are calling a Python script, Streamlit sequentially looks
    through the file and, every time it sees one of the functions, designates a sequential
    slot for that piece of content. This makes it very easy to use, as you can write
    all the Python you’d like, and when you want something to appear on the app you’ve
    made, you can simply use `st.write()` and you’re all set.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们启动一个新的 Streamlit 应用时，我们都需要确保导入 Streamlit（在本书中和其他地方通常别名为 `st`）。Streamlit
    为每种类型的内容（文本、图表、图片以及其他媒体）提供了独特的函数，我们可以将它们作为构建所有应用的基础模块。我们首先使用的函数是 `st.write()`，它是一个接受字符串（正如我们稍后将看到的，它几乎可以接受任何
    Python 对象，例如字典）的函数，并将其按调用顺序直接写入我们的网页应用中。当我们调用一个 Python 脚本时，Streamlit 会按顺序浏览文件，每当遇到某个函数时，就为该部分内容分配一个顺序插槽。这使得使用起来非常简单，因为你可以编写所有需要的
    Python 代码，当你想让某个内容出现在你创建的应用上时，只需使用 `st.write()`，一切就绪。
- en: 'In our `clt_demo.py` file, we can start with the basic `''Hello World''` output
    using `st.write()`, using the following code:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `clt_demo.py` 文件中，我们可以从基本的 `'Hello World'` 输出开始，使用 `st.write()`，并用以下代码：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now we can test this by running the following code in the terminal:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过在终端中运行以下代码来进行测试：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We should see the string `''``Hello World''` printed on our app, so all is
    good so far. The following figure is a screenshot of our app in Safari:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该能在应用中看到字符串 `'Hello World'` 的输出，至此一切正常。以下截图展示了我们的应用在 Safari 中的样子：
- en: '![](img/B18444_01_02.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18444_01_02.png)'
- en: 'Figure 1.2: Hello World app'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.2：Hello World 应用
- en: 'There are three items to note in this screenshot. First, we see the string
    as we wrote it, which is great. Next, we see that the URL points to **localhost:8501**,
    which is just telling us that we’re hosting this locally (that is, it’s not on
    the internet anywhere) through port **8501**. We don’t need to understand almost
    anything about the port system on computers, or the **Transmission Control Protocol**
    (**TCP**). The important thing here is that this app is local to your computer.
    Later in this book, we’ll learn how to take the local apps we create and share
    them with anyone via a link! The third important item to note is the hamburger
    icon at the top right. The following screenshot shows us what happens when we
    click the icon:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个截图中有三点需要注意。首先，我们看到的是我们写的字符串，这很好。接下来，我们看到 URL 指向 **localhost:8501**，这只是告诉我们我们正在本地托管此应用（即，它不在互联网上），通过
    **8501** 端口。我们不需要了解计算机上关于端口系统或 **传输控制协议**（**TCP**）的任何内容。这里需要注意的重点是，这个应用是本地的，运行在你的计算机上。在本书后面，我们将学习如何将本地创建的应用通过链接与任何人分享！第三个重要点是右上角的汉堡菜单图标。以下截图展示了点击该图标后的效果：
- en: '![](img/B18444_01_03.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18444_01_03.png)'
- en: 'Figure 1.3: Icon options'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.3：图标选项
- en: This is the default options panel for Streamlit apps. Throughout this book,
    we’ll discuss each of these options in depth, especially the non-self-explanatory
    ones such as **Clear cache**. All we have to know for now is that if we want to
    rerun the app or find settings or the documentation, we can use this icon to find
    almost whatever we need.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Streamlit应用的默认选项面板。在本书中，我们将详细讨论这些选项，特别是一些不太直观的选项，比如**清除缓存**。现在我们只需要知道的是，如果我们想重新运行应用或查找设置或文档，我们可以使用这个图标找到几乎所有需要的内容。
- en: When we host applications so that others can use them, they’ll see this same
    icon but have some different options (for example, users will not be able to clear
    the cache). We’ll discuss this in greater detail later as well. Now back to our
    central limit theorem app!
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们托管应用以便其他人使用时，他们会看到相同的图标，但会有一些不同的选项（例如，用户将无法清除缓存）。我们稍后会更详细地讨论这个问题。现在回到我们的中心极限定理应用！
- en: 'The next step is going to be generating a distribution that we want to sample
    from with replacement. I’m choosing the binomial here. We can read the following
    code as simulating 1,000 coin flips using the Python package `NumPy`, and printing
    out the mean number of heads from those 1,000 coin flips:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步将是生成一个我们想要从中带放回抽样的分布。我在这里选择了二项分布。我们可以将以下代码解读为使用Python包`NumPy`模拟1,000次抛硬币，并打印出这1,000次抛硬币中的正面朝上的平均次数：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now, given what we know about the central limit theorem, we would expect that
    if we sampled from `binom_dist` enough times, the mean of those samples would
    approximate the normal distribution.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，鉴于我们对中心极限定理的了解，我们可以预期，如果我们从`binom_dist`中多次抽样，那么这些样本的均值将近似于正态分布。
- en: 'We’ve already discussed the `st.write()` function. Our next foray into writing
    content to the Streamlit app is through graphs. `st.pyplot()` is a function that
    lets us use all the power of the popular `matplotlib` library and push our `matplotlib`
    graph to Streamlit. Once we create a figure in `matplotlib`, we can explicitly
    tell Streamlit to write that to our app with the `st.pyplot()` function. So, all
    together now! This app simulates 1,000 coin flips and stores those values in a
    list we call `binom_dist`. We then sample (with replacement) 100 from that list,
    take the mean, and store that mean in the cleverly named variable `list_of_means`.
    We do that 1,000 times (which is overkill – we could do this even with dozens
    of samples), and then plot the histogram. After we do this, the result of the
    following code should show a bell-shaped distribution:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论过`st.write()`函数。我们接下来要向Streamlit应用写入内容的方式是通过图形。`st.pyplot()`是一个函数，它让我们能够使用流行的`matplotlib`库的所有功能，并将我们的`matplotlib`图形推送到Streamlit。一旦我们在`matplotlib`中创建了一个图形，我们就可以明确地告诉Streamlit将其写入到我们的应用中，方法是使用`st.pyplot()`函数。所以，现在我们来总结一下！这个应用模拟了1,000次抛硬币，并将这些值存储在我们称之为`binom_dist`的列表中。然后，我们从这个列表中随机抽取（带放回）100个样本，计算均值，并将这个均值存储在巧妙命名的变量`list_of_means`中。我们重复这个过程1,000次（这其实有些过头——我们可以只用几十个样本），然后绘制直方图。完成之后，以下代码的结果应该显示一个钟形分布：
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Each run of this app will create a new bell curve. When I ran it, my bell curve
    looked like the following figure. If your graph isn’t exactly what you see in
    the next figure (but is still a bell!), that’s totally fine because of the random
    sampling used in our code:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 每次运行这个应用时都会生成一个新的钟形曲线。当我运行它时，我的钟形曲线如下图所示。如果你的图形不完全是接下来图中的样子（但仍然是钟形曲线！），那也没问题，因为我们的代码使用了随机抽样：
- en: '![](img/B18444_01_04.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18444_01_04.png)'
- en: 'Figure 1.4: Bell curve'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.4：钟形曲线
- en: As you probably noticed, we first created an empty figure and empty axes for
    that figure by calling `plt.subplots()`, and then assigned the histogram we created
    to the `ax` variable. Because of this, we were able to explicitly tell Streamlit
    to show the figure in our Streamlit app.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经注意到的，我们首先通过调用`plt.subplots()`创建了一个空的图形和空的坐标轴，然后将我们创建的直方图赋值给`ax`变量。正因如此，我们能够明确地告诉Streamlit在我们的Streamlit应用中显示这个图形。
- en: 'This is an important step, as in Streamlit versions, we can also skip this
    step, not assign our histogram to any variable, and then call `st.pyplot()` directly
    afterward. The following code takes this approach:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个重要的步骤，因为在Streamlit的版本中，我们也可以跳过这个步骤，不将直方图赋值给任何变量，然后直接调用`st.pyplot()`。以下代码采用了这种方法：
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: I don’t recommend this method, as it can give you some unexpected results. Take
    this example, where we want to first make our histogram of means, and then make
    another histogram of a new list filled only with the number 1.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我不推荐这种方法，因为它可能会给你一些意想不到的结果。举个例子，我们首先想制作一个均值的直方图，然后再制作一个只包含数字1的新列表的直方图。
- en: Take a second and guess what the following code would do. How many graphs would
    we get? What would the output be?
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 请花点时间猜测以下代码会做什么。我们会得到几个图形？输出是什么？
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'I would expect this to show two histograms, the first one of `list_of_means`,
    and the second one of the lists of `1s`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我预计这会显示两个直方图，第一个是 `list_of_means` 的直方图，第二个是 `1s` 列表的直方图：
- en: '![](img/B18444_01_05.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18444_01_05.png)'
- en: 'Figure 1.5: A tale of two histograms'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.5：两张直方图的故事
- en: What we actually get is different! The second histogram has data from the first
    and the second list! When we call `plt.hist()` without assigning the output to
    anything, `matplotlib` tacks the new histogram onto the old graph, which is stored
    globally, and Streamlit pushes that new one to our app. You may also get a `PyplotGlobalUseWarning`
    when you run the preceding code, depending on your matplotlib version. Don’t worry,
    we will fix this in the next section!
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，实际结果有所不同！第二个直方图的数据包含了第一个和第二个列表的数据！当我们调用 `plt.hist()` 而不将输出赋值给任何变量时，`matplotlib`
    会将新的直方图追加到旧的图形上，而这个图形是全局存储的，Streamlit 会将这个新的图形推送到我们的应用中。如果你的 matplotlib 版本较新，你也可能会收到
    `PyplotGlobalUseWarning` 警告。别担心，我们将在下一节解决这个问题！
- en: 'Here’s a solution to this issue. If we instead explicitly created two graphs,
    we could call the `st.pyplot()` function wherever we liked after the graph was
    generated, and have greater control over where exactly our graphs were placed.
    The following code separates the two graphs explicitly:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这是解决此问题的一种方法。如果我们显式创建两个图形，我们可以在生成图形后随时调用 `st.pyplot()` 函数，这样可以更好地控制图形的放置位置。以下代码显式地分开了两个图形：
- en: '[PRE14]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The preceding code plots both histograms separately by first defining separate
    variables for each figure and axis using `plt.subplots()` and then assigning the
    histogram to the appropriate axis. After this, we can call `st.pyplot()` using
    the created figure, which produces the following app:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码通过首先使用 `plt.subplots()` 定义每个图形和坐标轴的单独变量，然后将直方图分配给相应的坐标轴，分别绘制两个直方图。之后，我们可以使用创建的图形调用
    `st.pyplot()`，它会生成以下应用：
- en: '![](img/B18444_01_06.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18444_01_06.png)'
- en: 'Figure 1.6: Fixed histograms'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.6：固定的直方图
- en: We can clearly see in the preceding figure that the two histograms are now separated,
    which is the desired behavior. We will very often plot multiple visualizations
    in Streamlit and will use this method for the rest of the book.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 从上面的图中我们可以清楚地看到，两个直方图现在已经分开了，这是我们期望的行为。在 Streamlit 中，我们经常会绘制多个可视化图表，并且在本书剩余部分我们将使用这种方法。
- en: Matplotlib is an extremely popular library for data visualization but has some
    serious flaws when used within data apps. It is not interactive by default, it
    is not particularly pretty, and it also can slow down very large apps. Later in
    this book, we’ll switch over to more performant and interactive libraries.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Matplotlib 是一个非常流行的数据可视化库，但在数据应用中使用时存在一些严重缺陷。它默认不支持交互，外观也不算特别漂亮，并且在非常大的应用中可能会导致性能下降。稍后在本书中，我们将切换到性能更高且支持交互的库。
- en: Now, on to accepting user input!
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，开始接收用户输入吧！
- en: Using user input in Streamlit apps
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Streamlit 应用中使用用户输入
- en: As of now, our app is just a fancy way to show our visualizations. But most
    web apps take some user input or are dynamic, not static visualizations. Luckily
    for us, Streamlit has many functions for accepting inputs from users, all differentiated
    by the object that we want to input. There are freeform text inputs with `st.text_input()`;
    radio buttons, `st.radio()`; numeric inputs with `st.number_input()`; and a dozen
    more that are extremely helpful for making Streamlit apps. We will explore most
    of them in detail throughout this book, but we’ll start with numeric input.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的应用只是展示可视化的一种花哨方式。但大多数网页应用都需要接收用户输入或是动态的，而不是静态的可视化。幸运的是，Streamlit 提供了许多用于接收用户输入的函数，它们根据我们希望输入的对象而有所不同。有自由文本输入
    `st.text_input()`；单选按钮 `st.radio()`；数字输入 `st.number_input()`；以及更多对构建 Streamlit
    应用非常有帮助的函数。本书中我们将详细探索其中的大多数，但我们从数字输入开始。
- en: 'From the previous example, we assumed that the coins we were flipping were
    fair coins and had a 50/50 chance of being heads or tails. Let’s let the user
    decide what the percentage chance of heads is, assign that to a variable, and
    use that as an input in our binomial distribution. The number input function takes
    a label, a minimum and maximum value, and a default value, which I have filled
    in the following code:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们假设我们抛的硬币是公平的，正反面各有 50/50 的机会。现在让我们让用户决定正面朝上的概率，将其赋值给一个变量，并将这个值作为输入用于我们的二项分布。数字输入函数需要一个标签、最小值、最大值和默认值，我已经在以下代码中填写了这些内容：
- en: '[PRE15]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The preceding code uses the `st.number_input()` function to collect our percentage,
    assigns the user input to a variable (`perc_heads`), then uses that variable to
    change the inputs to the binomial distribution function that we used before. It
    also sets our histogram’s *x* axis to always be between 0 and 1, so we can better
    notice changes as our input changes. Try and play around with this app for a bit;
    change the number input and notice how the app responds whenever a user input
    is changed. For example, here is a result from when we set the numeric input to
    `.25`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码使用`st.number_input()`函数来收集我们的百分比，将用户输入赋值给一个变量（`perc_heads`），然后使用该变量更改我们之前使用的二项分布函数的输入。它还将我们的直方图的*X*轴设置为始终在0到1之间，以便我们更好地观察到随着输入变化而产生的变化。试着稍微玩一下这个应用；改变数字输入，注意每次用户输入变化时，应用是如何响应的。例如，当我们将数字输入设置为`.25`时，这里是一个结果：
- en: '![](img/B18444_01_07.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18444_01_07.png)'
- en: 'Figure 1.7: An example of a result from when we set the numeric input to .25'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.7：当我们将数字输入设置为.25时的结果示例
- en: 'As you probably noticed, every time that we changed the input of our script,
    Streamlit re-ran the entire application. This is the default behavior and is very
    important to understanding Streamlit performance; we will explore a few ways that
    allow us to change this default later in the book, such as adding caching or forms!
    We can also accept text input in Streamlit using the `st.text_input()` function,
    just as we did with the numeric input. The next bit of code takes a text input
    and assigns it to the title of our graph:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能注意到的，每次我们改变脚本的输入时，Streamlit都会重新运行整个应用程序。这是默认行为，并且对于理解Streamlit的性能非常重要；在本书后面的部分，我们将探讨几种方法，允许我们更改这个默认行为，比如添加缓存或表单！我们还可以使用`st.text_input()`函数接受文本输入，就像我们之前处理数字输入一样。接下来的代码段接收文本输入并将其赋值给我们图表的标题：
- en: '[PRE16]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This creates a Streamlit app with two inputs, both a numeric input and a text
    input, and uses them both to change our Streamlit app. Finally, this results in
    a Streamlit app that looks like the next figure, with dynamic titles and probabilities:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码创建了一个Streamlit应用，包含两个输入框，一个是数字输入框，另一个是文本输入框，并使用这两个输入框来改变我们的Streamlit应用。最后，这会生成一个Streamlit应用，呈现出下图所示，带有动态标题和概率：
- en: '![](img/B18444_01_08.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18444_01_08.png)'
- en: 'Figure 1.8: A Streamlit app with dynamic titles and probabilities'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.8：一个带有动态标题和概率的Streamlit应用
- en: Now that we have worked a bit with user input, let’s talk about text and Streamlit
    apps more deeply.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经稍微处理了一些用户输入，接下来让我们更深入地讨论文本和Streamlit应用。
- en: Finishing touches – adding text to Streamlit
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 精致的修饰 – 向Streamlit添加文本
- en: Our app is functional, but it is missing a lot of nice touches. We talked earlier
    about the `st.write()` function, which the Streamlit docs call the Swiss Army
    knife of Streamlit commands. Almost whatever we wrap `st.write()` around will
    work by default and it should be our go-to function if we’re not sure of the best
    path forward.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序是功能齐全的，但缺少一些精致的细节。我们之前讨论过`st.write()`函数，Streamlit文档称它是Streamlit命令的瑞士军刀。几乎我们将`st.write()`包裹的任何内容默认都会起作用，它应该是我们在不确定最佳路径时的首选函数。
- en: Other than `st.write()`, we also can utilize other built-in functions that format
    our text for us, such as `st.title()`, `st.header()`, `st.markdown()`, and `st.subheader()`.
    Using these five functions helps to format text in our Streamlit apps easily and
    keeps sizing consistent for bigger apps.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`st.write()`，我们还可以利用其他内置函数来格式化文本，如`st.title()`、`st.header()`、`st.markdown()`和`st.subheader()`。使用这五个函数可以轻松地在我们的Streamlit应用中格式化文本，并保持较大应用的一致性。
- en: 'More specifically, `st.title()` will place a large block of text in our app,
    `st.header()` uses a slightly smaller font than `st.title()`, and `st.subheader()`
    uses an even smaller one. Other than those three, `st.markdown()` will allow anyone
    already familiar with Markdown to use the popular markup language in our Streamlit
    apps. Let’s try a couple of them in the following code:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说，`st.title()`会在我们的应用中放置一大块文本，`st.header()`使用比`st.title()`稍小的字体，`st.subheader()`使用更小的字体。除此之外，`st.markdown()`允许任何熟悉Markdown的人在我们的Streamlit应用中使用这种流行的标记语言。让我们在接下来的代码中尝试其中的一些：
- en: '[PRE17]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The preceding code adds a large title (`st.title()`), adds a smaller subheader
    below (`st.subheader()`), and then adds some even smaller text below the subheader
    (`st.write()`). We also separated the long string of text in the preceding code
    block into three smaller strings for readability and to make it easier to edit
    in our text editor. It should look like the following screenshot. Note that because
    we are using randomly generated data for this histogram, it is OK (and expected!)
    if your histogram looks slightly different:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码添加了一个大标题（`st.title()`），并在其下方添加了一个较小的副标题（`st.subheader()`），接着在副标题下方添加了更小的文本（`st.write()`）。我们还将前面的长文本字符串拆分成了三个更小的字符串，以提高可读性，并便于在文本编辑器中进行编辑。它应当呈现如下截图。请注意，由于我们使用的是随机生成的数据，因此，如果你的直方图看起来略有不同，这是完全可以接受的（并且是预期中的）！
- en: '![](img/B18444_01_09.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18444_01_09.png)'
- en: 'Figure 1.9: The central limit theorem application'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.9：中心极限定理应用
- en: And that concludes our illustration of the central limit theorem. Go ahead and
    try out the other options that Streamlit has for writing text (like `st.markdown()`,
    which interprets and writes Markdown-style text in your Streamlit app) to further
    explore app creation.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们关于中心极限定理的说明。你可以尝试 Streamlit 提供的其他文本书写选项（比如 `st.markdown()`，它可以解释并书写 Markdown
    样式的文本）来进一步探索应用程序的创建。
- en: Summary
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we started by learning how to organize our files and folders
    for the remainder of this book and quickly moved on to instructions for downloading
    Streamlit. We then built our first Streamlit application, Hello World, and learned
    how to run our Streamlit applications locally. Then, we started building out a
    more complicated application to show the implications of the central limit theorem
    from the ground up, going from a simple histogram to accepting user input and
    formatting different types of text within our app for clarity and beautification.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先学习了如何组织文件和文件夹，为本书的剩余部分做准备，并快速介绍了如何下载 Streamlit。接着，我们构建了第一个 Streamlit
    应用程序 "Hello World"，并学习了如何在本地运行 Streamlit 应用程序。然后，我们开始构建一个更复杂的应用程序，从零开始展示中心极限定理的含义，从一个简单的直方图开始，到接受用户输入，再到在应用程序中格式化不同类型的文本，以增强可读性和美观性。
- en: By now, you should be comfortable with subjects such as basic data visualization,
    editing Streamlit apps in a text editor, and locally running Streamlit apps. We’re
    going to dive more deeply into data manipulation in our next chapter.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你应该已经对一些基本的内容感到熟悉，比如数据可视化、在文本编辑器中编辑 Streamlit 应用程序以及本地运行 Streamlit 应用程序。在下一章中，我们将深入探讨数据处理。
- en: Learn more on Discord
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Discord 上了解更多
- en: 'To join the Discord community for this book – where you can share feedback,
    ask questions to the author, and learn about new releases – follow the QR code
    below:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 要加入本书的 Discord 社区——你可以在这里分享反馈、向作者提问、了解新版本的发布——请扫描以下二维码：
- en: '[https://packt.link/sl](https://packt.link/sl)'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/sl](https://packt.link/sl)'
- en: '![](img/QR_Code13440134443835796.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code13440134443835796.png)'
