- en: Chapter 3. Designing the Visual Look of Our Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章 设计应用程序的视觉外观
- en: We have now come to the part where we want to design how our application will
    look and feel. For this **graphical user interface** (**GUI**), we take the path
    of least resistance and go with the **Tkinter** library since this is a standard
    built-in library in the official Python installations, at least for Windows and
    Mac. Other reasons for choosing Tkinter is that it is fairly easy to use and is
    slightly more Pythonic than some of the newer third-party GUI libraries.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经到了设计我们的应用程序外观和感觉的部分。对于这个**图形用户界面**（**GUI**），我们选择了阻力最小的路径，选择了**Tkinter**库，因为这是官方Python安装中的标准内置库，至少在Windows和Mac上是这样。选择Tkinter的其他原因还包括它相对容易使用，并且比一些较新的第三方GUI库更符合Python风格。
- en: If you have not used Tkinter before, you should still be able to follow along.
    The basic idea of Tkinter is that you create widget classes for each graphical
    element of your GUI, defining their look and placement. Complex elements can be
    created by nesting widgets within widgets. You can also bind functions to user
    interaction events.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 即使您之前没有使用过Tkinter，也应该能够跟上。Tkinter的基本思想是，您为GUI中的每个图形元素创建小部件类，定义它们的样式和位置。可以通过在小部件内部嵌套小部件来创建复杂元素。您还可以将函数绑定到用户交互事件。
- en: Note
  id: totrans-3
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To learn more about Tkinter, I highly recommend using John W. Shipman's reference
    guide, available from [http://infohost.nmt.edu/tcc/help/pubs/tkinter/tkinter.pdf](http://infohost.nmt.edu/tcc/help/pubs/tkinter/tkinter.pdf).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于Tkinter的信息，我强烈推荐使用John W. Shipman的参考指南，可在[http://infohost.nmt.edu/tcc/help/pubs/tkinter/tkinter.pdf](http://infohost.nmt.edu/tcc/help/pubs/tkinter/tkinter.pdf)找到。
- en: 'In this chapter you will:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将：
- en: Set up the general code structure to make a themed and highly customizable GIS
    application
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置通用代码结构，以创建一个主题化和高度可定制的GIS应用程序
- en: Create a toolbox of specialized user interface widgets that can connect to our
    underlying GIS functionality
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个工具箱，包含专门的用户界面小部件，这些小部件可以连接到我们底层的GIS功能
- en: Use this toolbox of widgets to glue together the visual design and layout of
    our application
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用这个小部件工具箱将应用程序的视觉设计和布局粘合在一起
- en: Learn how to test run our application
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何测试运行我们的应用程序
- en: Setting up the GUI package
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置GUI包
- en: 'We begin the chapter by setting up the structural skeleton for our application
    GUI. This should be logically separate from the rest of our code so we give it
    a subpackage of its own. Inside the top level `pythongis` folder, create a package
    folder called `app` with an `__init__.py` file inside it. Have it import the rest
    of the modules we will be creating:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从设置应用程序GUI的结构骨架开始本章。这应该与我们的其余代码逻辑上分开，所以我们给它一个自己的子包。在顶级`pythongis`文件夹内部，创建一个名为`app`的包文件夹，并在其中包含一个`__init__.py`文件。让它导入我们将要创建的其余模块：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To make our `app` package accessible from our top level `pythongis` package,
    we similarly need to import it in `pythongis/__init__.py` as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的`app`包可以从我们的顶级`pythongis`包中访问，我们同样需要在`pythongis/__init__.py`中导入它，如下所示：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The purpose of the `app` package is that we should be able to define how our
    GUI looks and behaves, and with a single line of code, `pythongis.app.run()`,
    we should be able to invoke it. The actual definition and layout of our GUI should
    be contained in a module we call `app/builder.py` (which we return to at the end
    of the chapter). The builder in turn relies on a set of predefined GUI building
    blocks, which we define in a subpackage folder called `app/toolkit`. This toolkit''s
    `__init__.py` file imports the building block modules that we are going to create
    throughout the chapter:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`app`包的目的是我们应该能够定义我们的GUI的外观和行为，并且通过一行代码`pythongis.app.run()`，我们应该能够调用它。我们GUI的实际定义和布局应该包含在一个我们称为`app/builder.py`的模块中（我们将在本章末尾回到这个模块）。构建器反过来又依赖于一组预定义的GUI构建块，我们在一个名为`app/toolkit`的子包文件夹中定义这些构建块。这个工具包的`__init__.py`文件导入了我们将在本章中创建的构建块模块：'
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In addition to our builder and toolkit, we also need an `app/dialogues.py` module
    that defines application-specific dialogue windows.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们的构建器和工具包之外，我们还需要一个`app/dialogues.py`模块，该模块定义了应用程序特定的对话框窗口。
- en: 'Last but not least, an important part of an application structure is how to
    access icons and images. To make our icons readily available to any widget that
    may need them, we create an `app/icons` package. This `package` folder is where
    we will save all our icons. When an application widget needs an icon, it simply
    asks the `icons` package for the icon name and size via `get()` and in return
    receives a Tkinter compatible `PhotoImage` object. Create its `__init__.py` file
    now:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，应用程序结构的一个重要部分是如何访问图标和图像。为了使我们的图标能够迅速提供给任何可能需要它们的控件，我们创建了一个`app/icons`包。这个`包`文件夹是我们将保存所有图标的地方。当应用程序小部件需要图标时，它只需通过`get()`请求图标名称和大小，然后返回一个Tkinter兼容的`PhotoImage`对象。现在创建它的`__init__.py`文件：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Once you created all of these, we should be ready to go. Your `app` folder
    structure should look like this:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了所有这些，我们就应该准备就绪了。你的`app`文件夹结构应该看起来像这样：
- en: '![Setting up the GUI package](img/5407OS_03_01.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![设置GUI包](img/5407OS_03_01.jpg)'
- en: Creating the toolkit building blocks
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建工具包构建块
- en: Before we can start designing our GUI layout, we have to create the `toolkit`
    package containing the underlying building blocks or design elements that we will
    be using. Tkinter already provides a set of basic GUI element or **widget** classes,
    such as `Buttons`, `Labels`, or `CheckBoxes`, with methods for placing them in
    the application window or nested within each other. To stay consistent with this
    logic, we subclass these Tkinter widgets and expand on them to make our own specialized
    building block widgets. This way our GUI code becomes consistent, stable, and
    reusable.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始设计我们的GUI布局之前，我们必须创建包含我们将使用的底层构建块或设计元素的`toolkit`包。Tkinter已经提供了一套基本的GUI元素或**小部件**类，例如`按钮`、`标签`或`复选框`，它们提供了将它们放置在应用程序窗口中或嵌套在彼此内部的方法。为了保持这种逻辑的一致性，我们子类化这些Tkinter小部件并在此基础上扩展，以创建我们自己的专用构建块小部件。这样，我们的GUI代码就变得一致、稳定且可重用。
- en: 'In our `toolkit` package, we want to have a few widgets readily available:
    icon buttons, toolbars, a ribbon tab system, a status bar, a panel overview to
    contain data layers, a map widget, and pop-up window templates. We also need a
    way for our buttons to connect with and execute geospatial work tasks from our
    GIS code library, so we make a command dispatch tool. However, before we start
    making widgets, let''s set up an easy way to style them.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`toolkit`包中，我们希望有一些小部件可以随时使用：图标按钮、工具栏、标签页系统、状态栏、包含数据层的面板概览、地图小部件和弹出窗口模板。我们还需要一种方法让我们的按钮能够与我们的GIS代码库中的地理空间工作任务连接并执行，因此我们创建了一个命令调度工具。然而，在我们开始制作小部件之前，让我们设置一种简单的方式来风格化它们。
- en: Themed styling
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主题风格
- en: To give our application a sense of style, we have to define things like background
    color or text font in each and every one of our toolkit widgets. To make this
    styling more flexible, we centralize the styling instructions into a separate
    module which we call `app/toolkit/theme.py`. The various widgets can then import
    the styling instructions from this theme module, which can be easily changed and
    modified as we develop our application, or perhaps even as a customizable feature
    by the end user.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给我们的应用程序一种风格感，我们必须在每一个工具包小部件中定义诸如背景颜色或文本字体等元素。为了使这种风格更加灵活，我们将风格说明集中到一个单独的模块中，我们称之为`app/toolkit/theme.py`。各种小部件可以从中导入风格说明，这些说明可以很容易地在我们开发应用程序时进行更改和修改，或者甚至作为最终用户可定制的功能。
- en: 'When specifying colors in Tkinter, you can either specify hex color strings
    or names of colors predefined by Tkinter. Let''s make the main background color
    of our application a light grey, with five different shades all the way up until
    pure white. We also want some more unique colors for highlighting purposes, one
    with two shades of orange, and an alternative one with two shades of blue:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在Tkinter中指定颜色时，你可以指定十六进制颜色字符串或Tkinter预定义的颜色名称。让我们将应用程序的主要背景颜色设为浅灰色，从浅灰色一直到纯白色共有五种不同的色调。我们还想为突出显示目的添加一些更独特的颜色，一种是两种橙色的色调，另一种是两种蓝色的色调：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For the full list of valid Tkinter color names and their appearance, see [http://wiki.tcl.tk/37701](http://wiki.tcl.tk/37701).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看有效的Tkinter颜色名称及其外观的完整列表，请参阅[http://wiki.tcl.tk/37701](http://wiki.tcl.tk/37701)。
- en: 'The type and size of font one uses is also a crucial part of application design,
    so we decide to use the trendy Segoe font used in Windows 8\. Tkinter fonts can
    be specified with a tuple containing the font name, size, and optionally the type
    of emphasis. We create two main shades of text fonts, one normal and one weaker
    one for less important background text. We also create two types of title/header
    text fonts for extra emphasis, one normal and one white, in case we need to display
    text on darker backgrounds:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 一个人使用的字体类型和大小也是应用程序设计的关键部分，因此我们决定使用Windows 8中使用的时尚的Segoe字体。Tkinter字体可以用包含字体名称、大小和可选的强调类型的元组来指定。我们创建了两种主要的文本字体色调，一种是正常的，一种是较弱的，用于不太重要的背景文本。我们还创建了两种标题/标题文本字体类型，一种是正常的，一种是白色的，以防我们需要在较暗的背景上显示文本：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Basic buttons
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本按钮
- en: 'Now, we can begin making widgets. Although Tkinter already comes with **Button**
    widgets, we will create some of our own so that each button we create is already
    styled in the way that we want, and we can simplify the process of giving them
    icons. Therefore, we create our first module which we call `app/toolkit/buttons.py`
    in the `toolkit` package. At the top, we import some necessary things:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以开始制作小部件了。尽管Tkinter已经自带**Button**小部件，但我们将创建一些自己的，以便每个创建的按钮都按照我们想要的样式进行设计，并且我们可以简化为它们添加图标的过程。因此，我们在`toolkit`包中创建我们的第一个模块，我们将其命名为`app/toolkit/buttons.py`。在顶部，我们导入一些必要的东西：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, we import our theme module and define the style we will use for buttons
    as dictionary entries. Under normal circumstances we want buttons to have a light
    background color with a flat relief. Once the mouse pointer hovers over the button,
    it *lights up* with a highlight color that turns into an even stronger color if
    clicked on:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们导入我们的主题模块，并将用于按钮的样式定义为字典条目。在正常情况下，我们希望按钮具有浅色背景色和平滑的立体感。一旦鼠标指针悬停在按钮上，它就会**点亮**，并显示高亮颜色，如果点击，颜色会变得更鲜艳：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To implement a Button widget that follows this style, we make a Button widget
    that subclasses the standard Tkinter button and takes our readily formatted style
    dictionary as keyword arguments. We also define that it should light up as defined
    in our hover-dictionary every time the mouse passes over the button:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现遵循这种样式的按钮小部件，我们创建了一个继承自标准Tkinter按钮的按钮小部件，并使用我们的格式化样式字典作为关键字参数。我们还定义了当鼠标经过按钮时，它应该按照我们定义的悬停字典中的方式**点亮**：
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We also add some commonly needed buttons, such as an **Ok** button with an
    *Enter*/*Return* keyboard shortcut that runs a specified function when activated:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了一些常用的按钮，例如带有*Enter*/*Return*键盘快捷键的**确定**按钮，当激活时运行指定的函数：
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Buttons with icons
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 带有图标的按钮
- en: In our application, we want to illustrate what our buttons do by using small
    icon images, but as you will soon see, giving icons to buttons in Tkinter requires
    several custom steps that can quickly become a dull task. Therefore, we create
    a specialized icon button that does these steps for us.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，我们希望通过使用小图标图像来展示按钮的功能，但正如你很快就会看到的，在Tkinter中为按钮添加图标需要几个自定义步骤，这些步骤很快就会变得乏味。因此，我们创建了一个专门的图标按钮，它会为我们完成这些步骤。
- en: To create the `IconButton` class, we take our styled button class as the starting
    point, and all we have to do is add a `set_icon` method. This method retrieves
    the image via the `icons` package with a size that fits the button, styles the
    way the image is placed inside the button, assigns it, and stores it as one of
    the button's attributes so it doesn't get garbage collected.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建`IconButton`类，我们将我们的样式按钮类作为起点，我们只需要添加一个`set_icon`方法。该方法通过`icons`包检索图像，大小适合按钮，以样式化图像在按钮内的放置方式，分配它，并将其存储为按钮的一个属性，以便它不会被垃圾回收：
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Toolbars
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工具栏
- en: 'Buttons should not just be placed randomly around. Instead, we want to group
    together sets of logically related buttons into areas known as **toolbars**. We
    create the `app/toolkit/toolbars.py` module and start it off with the necessary
    imports and style setting:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮不应随意放置。相反，我们希望将逻辑上相关的按钮组合成称为**工具栏**的区域。我们创建`app/toolkit/toolbars.py`模块，并从必要的导入和样式设置开始：
- en: '[PRE11]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The toolbar area is itself a subclass of the Tkinter frame and will consist
    of a frame area into which buttons will be packed side by side, and a text area
    on the bottom specifying the purpose of the toolbar. For now, we just create the
    generic `Toolbar` class with a convenient `add_button` method so we can later
    build and populate specialized toolbars by subclassing this one:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 工具栏区域本身是Tkinter框架的子类，它将包括一个框架区域，按钮将并排打包，底部有一个文本区域，指定工具栏的用途。目前，我们只创建了一个方便的`Toolbar`类，它有一个`add_button`方法，这样我们就可以通过子类化这个类来后来构建和填充专门的工具栏：
- en: '[PRE12]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The Ribbon tab system
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 功能区标签系统
- en: 'Next up is the **Ribbon** widget, which, inspired by newer versions of Microsoft
    Office, will give our application not only a sleek modern look, but also the level
    of organization and simplicity that we need, to avoid scaring off the not-so-technical
    users of our application. Just like related buttons were grouped together into
    toolbars in the previous section, toolbars can here be grouped into the Ribbon
    tab areas at the top of the window that can be switched and flipped-between, like
    a notebook, as shown in the following screenshot:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是**功能区**小部件，它受到微软办公软件新版本的启发，不仅将为我们的应用程序带来时尚现代的外观，还将提供我们所需要的组织水平和简洁性，以避免吓跑我们应用程序的非技术用户。就像上一节中相关的按钮被分组到工具栏中一样，这里工具栏可以被分组到窗口顶部的功能区区域，可以切换和翻页，就像笔记本一样，如下面的截图所示：
- en: '![The Ribbon tab system](img/5407OS_03_02.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![功能区标签系统](img/5407OS_03_02.jpg)'
- en: 'After creating the `app/toolkit/ribbon.py` module in the `toolkit` package,
    we begin with importing and styling, using a subtle grey highlight effect for
    the tab selectors:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在`toolkit`包中创建`app/toolkit/ribbon.py`模块后，我们开始导入和样式设置，使用微妙的灰色高亮效果为标签选择器着色：
- en: '[PRE13]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `Ribbon` class itself is a frame, with a top area for tab selectors, and
    the bottom area for displaying the currently selected tab area for related toolbars.
    Tabs are created as separate instances and added with the `add_tab` method, which
    will create a tab selector for that tab, which also lights up when the mouse hovers
    over it. A `switch` method will be called when a tab selector is pushed, which
    raises its tab area into view over all other tabs:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`Ribbon`类本身是一个框架，顶部区域用于标签选择器，底部区域用于显示当前选中的标签区域，用于相关工具栏。标签作为单独的实例创建，并通过`add_tab`方法添加，当鼠标悬停在其上时，它也会亮起。当标签选择器被按下时，将调用一个`switch`方法，它将将其标签区域提升到所有其他标签之上：'
- en: '[PRE14]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'When we use the Ribbon''s `add_tab` method it returns to us a `Tab` class,
    which it is up to us to populate with buttons and other content. For convenience,
    we give the `Tab` class an `add_toolbar` method:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用功能区的`add_tab`方法时，它返回给我们一个`Tab`类，我们负责用按钮和其他内容填充它。为了方便，我们给`Tab`类提供了一个`add_toolbar`方法：
- en: '[PRE15]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The bottom status bar
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 底部状态栏
- en: 'Another important GUI element is the status bar, which can contain one or more
    pieces of information or statuses and tends to be placed at the bottom of the
    application window meshed into the background. We create the `app/toolkit/statusbar.py`
    module and do the usual imports and styling in the beginning:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的GUI元素是状态栏，它可以包含一个或多个信息或状态，并且通常放置在应用程序窗口的底部，与背景交织在一起。我们在`app/toolkit/statusbar.py`模块中创建状态栏，并在开始时进行常规导入和样式设置：
- en: '[PRE16]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The StatusBar widget itself is simply a frame that contains one or more status
    widgets. Here is the code for the `StatusBar` class:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 状态栏小部件本身只是一个包含一个或多个状态小部件的框架。以下是`StatusBar`类的代码：
- en: '[PRE17]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We then make a base class for all status widgets called `Status` and some subclasses
    of it for displaying projection name, zoom level, and mouse pointer coordinates,
    without any event bindings or behavior since this will be controlled by a parent
    widget. A special TaskStatus widget can be set to `start()` and will turn orange
    along with a task description provided by the caller. It will return to normal
    once the `stop` method is called, as shown in the following code:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们然后为所有状态小部件创建一个基类，称为`Status`，以及一些它的子类来显示投影名称、缩放级别和鼠标指针坐标，由于这些将由父小部件控制，因此不需要任何事件绑定或行为。一个特殊的`TaskStatus`小部件可以被设置为`start()`，并将随着调用者提供的任务描述变为橙色。一旦调用`stop`方法，它将恢复正常，如下面的代码所示：
- en: '[PRE18]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The layers pane
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 层级面板
- en: 'A crucial element in most GIS applications is the layers pane, which displays
    and allows access to the loaded data and shows their symbols and in which order
    they are rendered to the map. After initiating our new `app/toolkit/layers.py`
    module, we start it with some imports and styling. Note that we also import our
    top-level `pythongis` package and our `dispatch` module because this layer''s
    pane needs to be able to load and render data:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数GIS应用中的一个关键元素是图层面板，它显示并允许访问加载的数据，并显示它们的符号以及它们在地图上的渲染顺序。在启动我们新的`app/toolkit/layers.py`模块后，我们通过一些导入和样式来启动它。请注意，我们还导入了我们的顶级`pythongis`包和我们的`dispatch`模块，因为这一层面板需要能够加载和渲染数据：
- en: '[PRE19]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'For now we only create the styled `LayersPane` class, with a title header text
    saying **Layers** and a main list area where individual loaded layers will show
    up. More about these layer items, how to load them, and their appearance and behavior
    will be dealt with more naturally in [Chapter 4](ch04.html "Chapter 4. Rendering
    Our Geodata"), *Rendering Our Geodata*:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 目前我们只创建了一个带样式的`LayersPane`类，标题文本为**图层**，以及一个主列表区域，其中将显示单个加载的图层。关于这些图层项、如何加载它们以及它们的显示和行为将在[第4章](ch04.html
    "第4章。渲染我们的地理数据")*渲染我们的地理数据*中更自然地处理：
- en: '[PRE20]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The Map widget
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 地图小部件
- en: 'Last but not least, we cannot have a GIS without a Map widget for interactively
    viewing geographic data. Create the `app/toolkit/map.py` module and start it off
    as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，没有用于交互式查看地理数据的地图小部件，我们就无法拥有GIS。创建`app/toolkit/map.py`模块，并按照以下方式启动它：
- en: '[PRE21]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'As with the layers pane, we begin developing the Map widget more fully in [Chapter
    4](ch04.html "Chapter 4. Rendering Our Geodata"), *Rendering Our Geodata*, so
    for now we only make the initial `MapView` class. Eventually, we want our Map
    widget to be able to hold a rendered map image and let the user pan around and
    zoom in and out of it, so we make it a subclass of the Tkinter **Canvas** widget.
    Since the `MapView` class will be calling some potentially heavy rendering operations
    later on, we also need a way to link it to a status bar in order to report its
    progress:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 与图层面板一样，我们在[第4章](ch04.html "第4章。渲染我们的地理数据")*渲染我们的地理数据*中更全面地开发地图小部件，因此现在我们只创建初始的`MapView`类。最终，我们希望我们的地图小部件能够包含渲染的地图图像，并允许用户在地图上平移和缩放，因此我们将其作为Tkinter
    **Canvas**小部件的子类。由于`MapView`类将在以后调用一些可能很重的渲染操作，我们还需要一种方法将其链接到状态栏，以便报告其进度：
- en: '[PRE22]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Pop-up windows
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 弹出窗口
- en: Later in the book, there are several times we will need to open additional windows
    on top of our main GUI window, whether it be an error message or an options or
    tool menu. In our `toolkit` package, we therefore want to define some window templates.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的后面部分，我们将在主GUI窗口之上打开几个额外的窗口，无论是错误消息还是选项或工具菜单。因此，在我们的`toolkit`包中，我们想要定义一些窗口模板。
- en: Note
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: These window templates are not the same as the actual windows specific to our
    application, which are defined throughout the book as part of the `app/dialogues.py`
    module we created earlier in this chapter.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这些窗口模板与我们的应用程序中特定的实际窗口不同，这些窗口在本章中作为我们之前创建的`app/dialogues.py`模块的一部分定义。
- en: 'Create a module for window templating as `app/toolkit/popups.py` and begin
    with some imports:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个用于窗口模板的模块`app/toolkit/popups.py`，并开始导入：
- en: '[PRE23]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'First, we create some basic pop-up windows and templates. This includes a simple
    warning `popup_message` function that can be used to raise errors in the GUI,
    as well as a basic `Window` class template with ideal positioning and size, used
    as the starting point for any other window:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建了一些基本的弹出窗口和模板。这包括一个简单的警告`popup_message`函数，可以用于在GUI中引发错误，以及一个基本的`Window`类模板，具有理想的定位和大小，用作任何其他窗口的起点：
- en: '[PRE24]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We also create another template, this time specifically for building tool options
    input frames. This will not be a window, but a Tkinter frame that can be placed
    inside any other widget, representing some tool or functionality where the user
    can customize settings or parameters and decide to run the tool or cancel. Let''s
    create this generic `RunToolFrame` class, which consists of an input area where
    all the options will be built to the left, a help area on the right, and a button
    for running the tool on the bottom:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还创建了一个模板，这次专门用于构建工具选项输入框架。这不会是一个窗口，而是一个Tkinter框架，可以放置在任何其他小部件内部，代表一些工具或功能，用户可以自定义设置或参数，并决定运行工具或取消。让我们创建这个通用的`RunToolFrame`类，它由一个输入区域组成，所有选项都将构建在左侧，一个帮助区域在右侧，以及一个在底部运行工具的按钮：
- en: '![Pop-up windows](img/5407OS_03_03.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![弹出窗口](img/5407OS_03_03.jpg)'
- en: 'Here is the code to create the `RunToolFrame` class:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是创建`RunToolFrame`类的代码：
- en: '[PRE25]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To make things easier for us later, we also give it simple methods for defining
    which options to pass to the target operation, which it uses to automatically
    create the appropriate input widgets. The most powerful feature here is `add_option_input()`
    which adds a customizable option widget and has several arguments that can be
    tweaked and combined to produce widgets for many different value types. This requires
    two arguments: `label`—the text to display next to the input widget, and `valuetype`—a
    function to convert input values as retrieved from the widget (which is always
    text) into the type that the target operation expects.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们以后更容易操作，我们还提供了简单的方法来定义要传递给目标操作哪些选项，它使用这些选项自动创建适当的输入小部件。这里最强大的功能是`add_option_input()`，它添加一个可定制的选项小部件，并具有几个可以调整和组合的参数，以生成适用于许多不同值类型的小部件。这需要两个参数：`label`——显示在输入小部件旁边的文本，和`valuetype`——一个函数，用于将从小部件（总是文本）检索到的输入值转换为目标操作期望的类型。
- en: 'If no other arguments are specified, this method adds an unnamed list argument
    to the target function, or by specifying `argname` you can make it a keyword argument.
    When the `multi` argument is true, the user is given an entry widget for freely
    typing in values and adding it to a list of option values, and if the `choices`
    argument is also true then the user is limited to choose one or more items from
    a list of choices. Setting the `choices` argument without the `multi` argument
    lets the user choose only a single value from a drop-down list of choices. The
    `default` argument defines the starting value of the widget, and `minval` and
    `maxval` tries to ensure that the final argument is greater than, less than, or
    between certain limits. Finally, there is also an `add_hidden_option` method that
    sets an option without having it show up as customizable widget. Take a look at
    the following code:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有指定其他参数，此方法将向目标函数添加一个未命名的列表参数，或者通过指定`argname`，可以将其作为关键字参数。当`multi`参数为真时，用户将获得一个输入小部件，可以自由输入值并将其添加到选项值的列表中，如果`choices`参数也为真，则用户被限制只能从选择列表中选择一个或多个项目。设置`choices`参数而不设置`multi`参数允许用户只能从下拉列表中选择单个值。`default`参数定义了小部件的起始值，而`minval`和`maxval`试图确保最终参数大于、小于或介于某些限制之间。最后，还有一个`add_hidden_option`方法，它设置一个选项，而不会将其显示为可定制的控件。请看以下代码：
- en: '[PRE26]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We now have ways to build a series of customizable parameter widgets in the
    window, but we still do not know what action or target operation should be run
    once the user is ready to run the tool window. This action must be given as a
    function able to receive the input widget parameters to `set_target_method()`.
    Doing so remembers the target function for later and retrieves the `doc` string
    from the given function and displays it to the user in the help area of the window.
    Also, we don''t want to lock the GUI while the function is running, so the target
    function is dispatched in a new thread (more on this shortly). Using `assign_statusbar()`
    lets it inform a linked status bar while awaiting the results. We must also set
    a function to be run once processing the results is finished, using `set_finished_method()`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有方法在窗口中构建一系列可定制的参数小部件，但我们仍然不知道当用户准备好运行工具窗口时应该运行什么操作或目标操作。这个操作必须作为一个能够接收输入小部件参数并传递给`set_target_method()`的函数。这样做可以记住目标函数以供以后使用，并从给定的函数中检索`doc`字符串，然后在窗口的帮助区域显示给用户。此外，我们不希望在函数运行时锁定GUI，因此目标函数将在新线程中调度（稍后将有更多介绍）。使用`assign_statusbar()`可以让它在等待结果时通知链接的状态栏。我们还需要设置一个在处理结果完成后要运行的函数，使用`set_finished_method()`：
- en: '[PRE27]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Dispatching heavy tasks to thread workers
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将重任务调度到线程工作者
- en: In later chapters, we will begin adding a specific GIS code to be run whenever
    we click on different buttons. Many GIS tasks can be quite heavy duty and take
    some time to finish. If we just run this lengthy code from within our Tkinter
    main event handling loop, then we will end up freezing our application while waiting
    for it to finish. To avoid such freezing, the long-running thread must be run
    in a thread other than our GUI, while our GUI checks at regular intervals to see
    if the results are in.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在后面的章节中，我们将开始添加在点击不同按钮时运行的特定GIS代码。许多GIS任务可能非常复杂，需要一些时间才能完成。如果我们只是在我们Tkinter主事件处理循环中运行这段冗长的代码，那么我们的应用程序在等待它完成时会冻结。为了避免这种情况，长时间运行的线程必须在除了我们的GUI之外的其他线程中运行，同时我们的GUI会定期检查结果是否已经准备好。
- en: Since we expect to call on such heavy tasks quite frequently via button clicks,
    we simplify the threading procedure by creating an `app/toolkit/dispatch.py` module
    to do the work for us. Whenever a GUI tool or button needs to run any type of
    geospatial task or workload, we simply send the function and arguments over to
    the dispatch's `request_results` method. That method will immediately return a
    **Queue communications object**, which we must then send to `after_completion()`
    to check for the results at regular intervals without blocking any new GUI events
    or interaction, and run the specified function for processing the results once
    completed. If an exception is raised during the threaded processing, it will be
    returned to the application for proper handling.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们预计将通过按钮点击频繁地调用这些重任务，我们通过创建一个`app/toolkit/dispatch.py`模块来简化线程处理过程，该模块为我们完成工作。每当一个GUI工具或按钮需要运行任何类型的地理空间任务或工作负载时，我们只需将函数和参数发送到调度程序的`request_results`方法。该方法将立即返回一个**队列通信对象**，然后我们必须将其发送到`after_completion()`以定期检查结果，而不会阻塞任何新的GUI事件或交互，并在完成后运行指定的函数来处理结果。如果在线程处理过程中抛出异常，它将被返回到应用程序以进行适当的处理。
- en: 'Here is the code:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是代码：
- en: '[PRE28]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Using the toolkit to build the GUI
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用工具包构建GUI
- en: 'Now that we have created the fundamental GUI building blocks, we just need
    to put them all together to create our first application:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了基本的GUI构建块，我们只需要将它们全部组合起来，以创建我们的第一个应用程序：
- en: '![Using the toolkit to build the GUI](img/5407OS_03_04.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![使用工具包构建GUI](img/5407OS_03_04.jpg)'
- en: 'To do so, reopen the empty `app/builder.py` module we created at the beginning
    of this chapter. Let''s create a basic GUI widget that represents the entirety
    of our application, populated with our widgets in a traditional layout:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，请重新打开我们在本章开头创建的空`app/builder.py`模块。让我们创建一个基本的GUI小部件，它代表我们应用程序的全部内容，并使用传统的布局填充我们的小部件：
- en: Our Ribbon widget at the top
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 顶部的Ribbon小部件
- en: Our LayersPane on the left
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 左侧的LayersPane
- en: The MapView on the right
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 右侧的MapView
- en: The StatusBar container at the bottom
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 底部的StatusBar容器
- en: 'Here is the code:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是代码：
- en: '[PRE29]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Finally, we create a `run` function, which is separate from the GUI class,
    that simply creates the main Tkinter root window, packs our GUI widget inside
    it, and runs the application:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们创建一个`run`函数，它独立于GUI类，简单地创建主Tkinter根窗口，将我们的GUI小部件打包到其中，并运行应用程序：
- en: '[PRE30]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Make this function directly available from the `app` package, by adding the
    following to `app/__init__.py`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在`app/__init__.py`中添加以下内容，使此函数直接从`app`包中可用：
- en: '[PRE31]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Testing our application
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试我们的应用程序
- en: 'Provided you followed all of the instructions correctly, you should now be
    able to use the previous `run` function to begin exploring the application we
    have built so far. As we add more features throughout the book, you will likely
    want to call on this function repeatedly for testing purposes. Therefore, we add
    a ready-made script that does this for us called `guitester.py`, saving it in
    the same directory where our `pythongis` package is located to make the latter
    directly importable. The script only needs the following code:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正确地遵循了所有指示，你现在应该能够使用之前的`run`函数开始探索我们迄今为止构建的应用程序。随着我们在整本书中添加更多功能，你可能会多次调用此函数进行测试。因此，我们添加了一个现成的脚本，名为`guitester.py`，将其保存在我们的`pythongis`包所在的同一目录中，以便后者可以直接导入。该脚本只需要以下代码：
- en: '[PRE32]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If you run `guitester.py` now, it should open an application that looks like
    this on Windows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在运行`guitester.py`，它应该在Windows上打开一个看起来像这样的应用程序：
- en: '![Testing our application](img/5407OS_03_05.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![测试我们的应用程序](img/5407OS_03_05.jpg)'
- en: Tip
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You will also likely want to start collecting a few vector and raster files
    that you can use to test with the application later on. A good place to get them
    is [http://www.naturalearthdata.com/](http://www.naturalearthdata.com/), and they
    are all in the same WGS84 coordinate system.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还希望开始收集一些矢量文件和栅格文件，以便稍后使用应用程序进行测试。一个获取这些文件的好地方是[http://www.naturalearthdata.com/](http://www.naturalearthdata.com/)，它们都在相同的WGS84坐标系中。
- en: Summary
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: At this point, we have made the basics of our application, one which doesn't
    do much right now but that is ready to be extended further as we continue to add
    new geospatial functionality. You learned to create a solid toolkit foundation
    of tools and widgets that we can use to build our GUI in a separate and flexible
    builder module, some of which will be extended in later chapters. The main missing
    piece, before we can say we have a functional GIS application, is to visualize
    data in our map widget. This is what we turn to in the next chapter.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经完成了应用程序的基础部分，目前它功能有限，但已经准备好随着我们继续添加新的地理空间功能而进一步扩展。你学会了创建一个坚实的工具包基础，包括工具和控件，我们可以使用这些工具和控件在一个独立且灵活的构建模块中构建我们的GUI，其中一些将在后面的章节中扩展。在我们可以说我们有一个功能齐全的GIS应用程序之前，主要缺少的部分是在我们的地图控件中可视化数据。这就是我们在下一章要解决的问题。
