- en: Container Types
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 容器类型
- en: 'Container types are used to group objects together. The main difference between
    the different container types is the way individual elements are accessed and
    how operations are defined. In this chapter, we discuss container types such as lists,
    tuples, dictionaries, and sets and related concepts such as indexing techniques.
    More specialized containers such as pandas DataFrames will be presented in [Chapter
    4](b9f628e9-f682-41be-b5a6-94359f8629fc.xhtml): *L**inear Algebra – Arrays*, [Chapter
    5](e60692b7-f6d2-42df-a59f-bfaf357ea932.xhtml): *Advanced Array Concepts*, and [Chapter
    10](6db12ffa-0569-4e1e-9059-2f7ada99c3e3.xhtml): *Series and DataFrames.*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 容器类型用于将对象组合在一起。不同容器类型之间的主要区别在于如何访问单个元素以及如何定义操作。在本章中，我们讨论了诸如列表、元组、字典和集合等容器类型以及相关的概念，如索引技巧。更专业的容器，如pandas
    DataFrame，将在[第4章](b9f628e9-f682-41be-b5a6-94359f8629fc.xhtml)：*线性代数–数组*、[第5章](e60692b7-f6d2-42df-a59f-bfaf357ea932.xhtml)：*高级数组概念*，以及[第10章](6db12ffa-0569-4e1e-9059-2f7ada99c3e3.xhtml)：*序列和数据框*中介绍。
- en: 'In particular, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 特别地，我们将涵盖以下主题：
- en: Lists
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表
- en: Arrays
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组
- en: Tuples
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元组
- en: Dictionaries
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字典
- en: Sets
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合
- en: 3.1 Lists
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.1 列表
- en: In this section, we introduce lists – the most frequently used container datatype
    in Python. With lists, we can refer to several, even totally different, Python
    objects together.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍列表——Python中最常用的容器数据类型。使用列表，我们可以将多个甚至完全不同的Python对象放在一起。
- en: 'A list is, as the name hints, a list of objects of any kind:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 列表，顾名思义，是由任何类型的对象组成的列表：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first list in this example contains a string, a float, and an integer object.
    The second list in this example, `M`, contains another list as its second item.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本例中的第一个列表包含一个字符串、一个浮动数和一个整数对象。第二个列表`M`包含另一个列表作为它的第二个元素。
- en: The individual objects are enumerated by assigning each element an index. The
    first element in the list gets index ![](img/24755493-7391-4f8c-ae55-d7059940bc62.png).
    This *zero-based indexing* is frequently used in mathematical notation. Consider
    as an example for zero-based indexing the usual indexing of coefficients of a
    polynomial.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 每个对象通过分配给每个元素一个索引来进行枚举。列表中的第一个元素获得索引0。这种*零基础索引*在数学表示法中经常使用。以零基础索引为例，考虑多项式系数的常规索引。
- en: 'The index allows us to access the following objects from the two lists defined
    in the preceding example:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 索引使我们可以访问在前面示例中定义的两个列表中的以下对象：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The bracket notation here corresponds to the use of subscripts in mathematical
    formulas. `L` is a simple list, while `M` itself contains a list so that you need
    two indexes to access an element of the inner list.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的括号表示法对应于数学公式中使用下标的方式。`L`是一个简单的列表，而`M`本身包含一个列表，因此你需要两个索引才能访问内列表的一个元素。
- en: 'A list containing subsequent integers can easily be generated by the command `range`:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 一个包含连续整数的列表可以通过命令`range`轻松生成：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'A more general use is to provide this command with start, stop, and step parameters:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 更一般的用法是为该命令提供起始、停止和步长参数：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The command `len` returns the length of the list:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 命令`len`返回列表的长度：
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 3.1.1 Slicing
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1.1 切片
- en: Like cutting a slice from a loaf of bread, lists can be cut into slices. Slicing
    a list between `i` and `j` creates a new list containing the elements starting
    at index `i` and ending just before `j`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 就像从一条面包中切下一片，列表也可以被切分成切片。将列表在`i`和`j`之间切割会创建一个新列表，其中包含从索引`i`开始、在`j`之前结束的元素。
- en: For slicing, a range of indexes has to be given. `L[i:j]` means create a list
    by taking all elements from `L` starting at `L[i]` until `L[j-1]`. In other words,
    the new list is obtained by removing the first `i` elements from `L` and taking
    the next `j-i` elements ![](img/8c30c1ca-2375-4303-ae1a-4ce9475c5eba.png).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 对于切片，必须给出一个索引范围。`L[i:j]`意味着通过从`L[i]`开始到`L[j-1]`为止，创建一个新列表。换句话说，新列表是通过从`L`中删除前`i`个元素并取下一个`j-i`个元素来得到的。
- en: 'Here, `L[i:]` means remove the ![](img/21174276-5eae-46d9-a4fd-c9a015c1b95e.png) first
    elements and `L[:i]` means take only the first ![](img/097a8bc0-54d3-4cd5-a899-9b12859a5e0e.png)elements:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`L[i:]`表示移除第一个元素，`L[:i]`表示仅取前`i`个元素：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You may omit the first or last bound of the slicing:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以省略切片的第一个或最后一个界限：
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Python allows the use of negative indexes for counting from the right. In particular,
    the element `L[-1]` is the last element in the list `L`. Similarly, `L[:-i]` means
    remove the last ***i*** elements, and `L[-i:]` means take only the last ***i*** elements.
    This may be combined in `L[i:-j]` to remove the first ***i*** and the last ***j*** elements.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Python允许使用负数索引从右侧计数。特别地，元素`L[-1]`是列表`L`中的最后一个元素。类似地，`L[:-i]`表示移除最后***i***个元素，`L[-i:]`表示只取最后***i***个元素。这可以结合使用，如`L[i:-j]`表示移除前***i***个元素和最后***j***个元素。
- en: 'Here is an example:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个例子：
- en: '[PRE7]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Omitting one index in the range corresponds to half-open intervals in ℝ. The
    half-open interval (∞, *a*) means take all numbers strictly lower than *a*; this
    is similar to the syntax `L[:j] `; see *Figure 3.1* for more examples:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在范围中省略一个索引对应于ℝ中的半开区间。半开区间(∞, *a*)表示取所有严格小于*a*的数；这类似于语法`L[:j]`；更多示例请参见*图 3.1*：
- en: '![](img/7a6c8df0-b30b-4234-bcfb-034a2469b627.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7a6c8df0-b30b-4234-bcfb-034a2469b627.png)'
- en: 'Figure 3.1: Some typical slicing situations'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1：一些典型的切片情况
- en: 'Notice that you never get index errors with *out-of-bound slices*. Possibly,
    you may obtain empty lists:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，*越界切片*时，你永远不会遇到索引错误。可能你会得到空列表：
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Be careful when using variables in indexing that may become negative, since
    it changes the slice completely. This might lead to unexpected results:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用可能变成负数的变量进行索引时要小心，因为这会完全改变切片。这可能导致意外的结果：
- en: '[PRE9]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The result is `3`, `0`, `1`, `3` while you expect `0`, `0`, `1`, `3`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是`3`，`0`，`1`，`3`，而你期望的结果是`0`，`0`，`1`，`3`。
- en: 'Let''s sum up the use of slices:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结一下切片的使用：
- en: '`L[i:]` amounts to taking all elements except the first *i* ones.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`L[i:]`表示取所有元素，除了前*i*个。'
- en: '`L[:i]` amounts to taking the first *i* elements.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`L[:i]`表示取前*i*个元素。'
- en: '`L[-i:]` amounts to taking the last *i* elements.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`L[-i:]`表示取列表的最后*i*个元素。'
- en: '`L[:-i]` amounts to taking all elements except the last *i* ones.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`L[:-i]`表示取所有元素，除了最后*i*个。'
- en: Strides
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步长
- en: When computing slices, you may also specify a stride, which is the length of
    the step from one index to the other. The default stride is `1`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算切片时，你也可以指定步长，即从一个索引到另一个索引的步长。默认步长为`1`。
- en: 'Here is an example:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个例子：
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Note that the stride may also be negative:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，步长也可以是负数：
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'It is also possible to create a new list that is reversed, using a negative
    stride:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以创建一个反转的新列表，使用负步长：
- en: '[PRE12]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Alternatively, you might want to use the method `reverse`, which is explained
    in [Section 3.1.4](c4f97b8b-36c4-4db4-9e58-02aac275b257.xhtml): *List methods.*'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，你也可以使用方法`reverse`，该方法在[第3.1.4节](c4f97b8b-36c4-4db4-9e58-02aac275b257.xhtml)：*列表方法*中有详细说明。
- en: 3.1.2 Altering lists
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1.2 修改列表
- en: 'Typical operations on lists are the insertion and deletion of elements and
    list concatenation. With the slicing notation, list insertion and deletion become
    obvious; deletion is just replacing a part of a list with an empty list `[]`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 列表的典型操作是插入和删除元素以及列表连接。使用切片表示法，列表的插入和删除变得非常直观；删除就是用空列表`[]`替换列表的一部分：
- en: '[PRE13]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Insertion means replacing an empty slice with the list to be inserted:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 插入意味着用要插入的列表替换空切片：
- en: '[PRE14]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Two lists are concatenated by the plus operator `+` :'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 两个列表通过加法运算符`+`连接：
- en: '[PRE15]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Concatenating a list `n` times with itself motivates the use of the multiplication
    operator `*`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 将列表`n`次与自身连接，激发了使用乘法运算符`*`的需求：
- en: '[PRE16]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'There are no arithmetic operations on a list, such as elementwise summation
    or division. For such operations, we use arrays; see [Section 3.2](c4f97b8b-36c4-4db4-9e58-02aac275b257.xhtml):
    A quick glance at the concept of arrays.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 列表上没有算术运算，比如逐元素求和或除法。对于这些操作，我们使用数组；请参见[第3.2节](c4f97b8b-36c4-4db4-9e58-02aac275b257.xhtml)：数组概念简览。
- en: 3.1.3 Belonging to a list
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1.3 属于列表
- en: 'You may use the keywords `in` and `not in` to determine whether an element
    belongs to a list or not, which is similar to ![](img/240418bd-550d-4d6d-a5f3-501370f5490d.png) and ![](img/c905a7b8-fd14-4009-9804-7be9fe23cad1.png) in
    mathematics:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用关键字`in`和`not in`来确定一个元素是否属于列表，这类似于数学中的![](img/240418bd-550d-4d6d-a5f3-501370f5490d.png)和![](img/c905a7b8-fd14-4009-9804-7be9fe23cad1.png)：
- en: '[PRE17]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 3.1.4 List methods
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1.4 列表方法
- en: 'Some useful methods of the `list` type are collected in the following *Table
    3.1*:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 一些有用的`list`类型方法汇集在以下*表 3.1*中：
- en: '| **Command** | **Action** |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| **命令** | **操作** |'
- en: '| `list.append(x)` | Add `x` to the end of the list. |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `list.append(x)` | 将`x`添加到列表的末尾。 |'
- en: '| `list.extend(L)` | Extend the list by the elements of the list `L`. |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `list.extend(L)` | 将列表`L`的元素添加到列表末尾。 |'
- en: '| `list.insert(i,x)` | Insert `x` at position `i`. |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `list.insert(i,x)` | 将`x`插入到位置`i`。 |'
- en: '| `list.remove(x)` | Remove the first item from the list whose value is `x`.
    |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `list.remove(x)` | 移除列表中第一个值为`x`的元素。 |'
- en: '| `list.sort()` | Sort the items of the list. |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `list.sort()` | 对列表项进行排序。 |'
- en: '| `list.reverse()` | Reverse the elements of the list. |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `list.reverse()` | 反转列表中的元素。 |'
- en: '| `list.pop()` | Remove the last element of the list. |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `list.pop()` | 移除列表中的最后一个元素。 |'
- en: 'Table 3.1: In-place methods of the datatype list'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 表3.1：列表数据类型的原地方法
- en: These methods are in-place operations, that is, they change the list directly.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法是原地操作，即它们直接修改列表。
- en: 'Other methods, such as those given in *Table 3.2*, do not alter the list, but
    return some information or create a new list object:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 其他方法，如*表3.2*中给出的那些，不会修改列表，而是返回一些信息或创建一个新列表对象：
- en: '| **Command** | **Action** |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| **命令** | **操作** |'
- en: '| `list.count(x)` | Count how often `x` appears in the list. |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `list.count(x)` | 计算`x`在列表中出现的次数。 |'
- en: '| `list.copy()` | Create a copy of the list. |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `list.copy()` | 创建列表的副本。 |'
- en: 'Table 3.2: Methods of the datatype list that return a new object'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 表3.2：返回新对象的列表数据类型方法
- en: In-place operations
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 原地操作
- en: 'Most methods that result in a list are in-place operations. These are operations
    that change a Python object directly without creating a new object of the same
    type. They can be best explained by looking at the following example, `reverse`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数生成列表的方法都是原地操作。这些操作直接改变Python对象，而不会创建相同类型的新对象。通过查看以下示例`reverse`可以最清楚地理解：
- en: '[PRE18]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Be aware of in-place operations. You might be tempted to write:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 注意原地操作。你可能会忍不住写出以下代码：
- en: '[PRE19]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This is correct Python. But in-place operations return the value `None` and
    alter the list. Therefore, using the variable `newL` as if it was a (sorted) list,
    for example, as
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这是正确的Python代码。但原地操作会返回`None`，并改变列表。因此，例如，像使用`newL`作为（排序后的）列表那样，
- en: '[PRE20]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'causes an error:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 会导致错误：
- en: '[PRE21]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Here, we demonstrate in-place list operations:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们展示了原地列表操作：
- en: '[PRE22]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '`L` is altered. The method `count` is an example of a method that generates
    a new object:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`L` 被修改。方法`count`是一个生成新对象的示例：'
- en: '[PRE23]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 3.1.5 Merging lists – zip
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1.5 合并列表 – zip
- en: 'A particularly useful function for lists is `zip`. It can be used to merge
    two given lists into a new list by pairing the elements of the original lists.
    The result is a list of tuples (see [Section 3.3](c4f97b8b-36c4-4db4-9e58-02aac275b257.xhtml): *Tuples*):'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 一个特别有用的列表函数是`zip`。它可以将两个给定的列表通过配对原列表中的元素合并成一个新列表。结果是一个元组列表（请参见[第3.3节](c4f97b8b-36c4-4db4-9e58-02aac275b257.xhtml)：*元组*）：
- en: '[PRE24]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This example also demonstrates what happens if the lists have different lengths:
    the length of the zipped list is the shorter of the two input lists.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 本例还展示了如果列表长度不一致会发生什么：压缩后的列表长度是两个输入列表中较短的那个。
- en: 'The function `zip` creates a special iterable object that can be turned into
    a list by applying the function `list`, as in the preceding example. See [Section
    9.3](66c25bba-72d2-46a9-929a-1f57fa7a1684.xhtml): *Iterable objects *for more
    details on iterable objects.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`zip`创建一个特殊的可迭代对象，可以通过应用`list`函数将其转化为列表，如前面的示例所示。有关可迭代对象的更多细节，请参见[第9.3节](66c25bba-72d2-46a9-929a-1f57fa7a1684.xhtml)：*可迭代对象*。
- en: 3.1.6 List comprehension
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1.6 列表推导式
- en: 'A convenient way to build up lists is by using the list comprehension construct,
    possibly with a condition inside. The syntax of a list comprehension is:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 构建列表的便捷方法是使用列表推导式，可能还带有条件。列表推导式的语法如下：
- en: '[PRE25]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'or more generally:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 或者更普遍地：
- en: '[PRE26]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Here are some examples:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些示例：
- en: '[PRE27]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'It is possible to have several `for` loops inside a list comprehension:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在列表推导式中包含多个`for`循环：
- en: '[PRE28]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This is of particular interest when dealing with arrays; see [Section 3.2](c4f97b8b-36c4-4db4-9e58-02aac275b257.xhtml): *A
    quick glance at the concept of arrays*.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这在处理数组时尤其重要；详见[第3.2节](c4f97b8b-36c4-4db4-9e58-02aac275b257.xhtml)：*快速了解数组概念*。
- en: 'List comprehension is closely related to the mathematical notation for sets.
    Compare [![](img/17ea4cf5-e5a8-43b6-ac07-2dd603f247c2.png)]and `L2 = [2*x for
    x in L]`. One big difference though is that lists are ordered while sets aren''t;
    see [Section 3.5](c4f97b8b-36c4-4db4-9e58-02aac275b257.xhtml): *Sets*.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 列表推导式与集合的数学表示法紧密相关。比较[![](img/17ea4cf5-e5a8-43b6-ac07-2dd603f247c2.png)]和`L2
    = [2*x for x in L]`。不过一个很大的区别是，列表是有序的，而集合不是；详见[第3.5节](c4f97b8b-36c4-4db4-9e58-02aac275b257.xhtml)：*集合*。
- en: As we complete our understanding of lists, we'll now move on to the next section,
    where we will learn about arrays.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成对列表的理解后，我们将继续下一节，学习数组的相关内容。
- en: 3.2 A quick glance at the concept of arrays
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.2 快速了解数组的概念
- en: The NumPy package offers arrays, which are container structures for manipulating
    vectors, matrices, or even higher-order tensors in mathematics. In this section,
    we point out the similarities between arrays and lists. But arrays deserve a broader
    presentation, which will be given in [Chapter 4](b9f628e9-f682-41be-b5a6-94359f8629fc.xhtml): *Linear
    Algebra – Arrays*, and [Chapter 5](e60692b7-f6d2-42df-a59f-bfaf357ea932.xhtml): *Advanced
    Array Concepts*.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy包提供了数组，它们是用于操作数学中的向量、矩阵或甚至更高阶张量的容器结构。在本节中，我们指出了数组与列表之间的相似性。但数组值得更广泛的介绍，这将在[第4章](b9f628e9-f682-41be-b5a6-94359f8629fc.xhtml)：*线性代数——数组*，以及[第5章](e60692b7-f6d2-42df-a59f-bfaf357ea932.xhtml)：*高级数组概念*中详细讲解。
- en: 'Arrays are constructed from lists by the function `array` :'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是通过函数`array`从列表构造的：
- en: '[PRE29]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'To access an element of a vector, we need one index, while an element of a
    matrix is addressed by two indexes:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问向量的元素，我们需要一个索引，而访问矩阵的元素需要两个索引：
- en: '[PRE30]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'At first glance, arrays are similar to lists, but be aware that they are different
    in a fundamental way, which can be explained by the following points:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 初看，数组与列表相似，但请注意，它们在一个基本方面是不同的，可以通过以下几点来解释：
- en: 'Access to array data corresponds to that of lists, using square brackets and
    slices. But for arrays representing matrices, a double index is used. Lists assigned
    to a slice of an array can be used to alter the array:'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对数组数据的访问与列表相似，使用方括号和切片。但对于表示矩阵的数组，使用双重索引。赋值给数组切片的列表可以用来修改数组：
- en: '[PRE31]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The number of elements in a vector, or the number of rows of a matrix, is obtained
    by the function `len`:'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取向量中的元素数量，或矩阵的行数，可以使用函数`len`：
- en: '[PRE32]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Arrays store only elements of the same numeric type (usually `float` or `complex` but
    also `int`).
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组只存储相同数值类型的元素（通常是`float`或`complex`，也可以是`int`）。
- en: The operations `+`, `*`, `/`, and `-` are all elementwise. The function `dot` and,
    in Python versions ≥ 3.5, the infix operator `@` are used for the scalar product
    and the corresponding matrix operations.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运算符`+`、`*`、`/`和`-`都是逐元素操作。函数`dot`以及在Python版本≥3.5中，使用中缀运算符`@`来进行标量积和相应的矩阵操作。
- en: 'Unlike lists, there is no `append` method for arrays. Nevertheless, there are
    special methods to construct arrays by stacking smaller size arrays; see [Section
    4.7](b9f628e9-f682-41be-b5a6-94359f8629fc.xhtml): *Stacking*. A related point
    is that arrays are not as elastic as lists; you cannot use slices to change their
    length.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与列表不同，数组没有`append`方法。尽管如此，有一些特殊方法可以通过堆叠较小的数组来构造数组；参见[第4.7节](b9f628e9-f682-41be-b5a6-94359f8629fc.xhtml)：*堆叠*。一个相关的点是，数组不像列表那样具有弹性；你不能使用切片来改变它们的长度。
- en: 'Vector slices are views, that is, they may be used to modify the original array;
    see [Section 5.1](e60692b7-f6d2-42df-a59f-bfaf357ea932.xhtml): *Array views and
    copies*.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向量切片是视图，即它们可以用来修改原始数组；参见[第5.1节](e60692b7-f6d2-42df-a59f-bfaf357ea932.xhtml)：*数组视图与副本*。
- en: 'We gave you in this section a quick glance at the container type `array`. It
    is so central in scientific computing with Python that we will devote two entire
    chapters to it with many more aspects to be presented and discussed; see [Chapter
    4](b9f628e9-f682-41be-b5a6-94359f8629fc.xhtml): *Linear Algebra – Arrays*, and [Chapter
    5](e60692b7-f6d2-42df-a59f-bfaf357ea932.xhtml): *Advanced Array Concepts*.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们快速了解了容器类型`array`。它在科学计算中非常重要，以至于我们将专门用两章内容来详细讲解，它还将涉及更多的方面；参见[第4章](b9f628e9-f682-41be-b5a6-94359f8629fc.xhtml)：*线性代数——数组*，以及[第5章](e60692b7-f6d2-42df-a59f-bfaf357ea932.xhtml)：*高级数组概念*。
- en: 3.3 Tuples
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.3 元组
- en: 'A tuple is an immutable list. Immutable means that it cannot be modified. A
    tuple is written as a comma-separated sequence of objects (a list without brackets).
    To increase readability, you often enclose a tuple in a pair of parentheses:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 元组是不可变的列表。不可变意味着它不能被修改。元组是由逗号分隔的对象序列（没有括号的列表）。为了增加可读性，通常将元组括在一对圆括号中：
- en: '[PRE33]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Omitting parentheses can have side effects; see the following example:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 省略圆括号可能会产生副作用；请看下面的示例：
- en: '[PRE34]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The comma indicates that the object is a tuple:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 逗号表示该对象是一个元组：
- en: '[PRE35]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Tuples are useful when a group of values goes together; for example, they are
    used to return multiple values from functions. See [Section 7.3](35749482-dbc7-41b2-aa19-dc63b242f18f.xhtml): *Return
    values*.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 元组在一组值需要一起使用时很有用；例如，它们用于从函数返回多个值。参见[第7.3节](35749482-dbc7-41b2-aa19-dc63b242f18f.xhtml)：*返回值*。
- en: 3.3.1 Packing and unpacking variables
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.3.1 打包与解包变量
- en: 'You may assign several variables at once by unpacking a list or tuple:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过解包列表或元组来一次性赋值多个变量：
- en: '[PRE36]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Use packing and unpacking to swap the contents of two variables:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 使用打包和解包来交换两个变量的内容：
- en: '[PRE37]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 3.4 Dictionaries
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.4 字典
- en: Lists, tuples, and arrays are ordered sets of objects. Individual objects are
    inserted, accessed, and processed according to their place in the list. On the
    other hand, dictionaries are unordered sets of pairs. You access dictionary data
    by keys.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 列表、元组和数组是有序的对象集合。单独的对象根据它们在列表中的位置被插入、访问和处理。另一方面，字典是无序的键值对集合。你通过键来访问字典数据。
- en: 3.4.1 Creating and altering dictionaries
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.4.1 创建和修改字典
- en: 'For example, we may create a dictionary containing the data of a rigid body
    in mechanics, as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以创建一个包含机械学中刚体数据的字典，如下所示：
- en: '[PRE38]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: A key/data pair is indicated by a colon, `:`. These pairs are comma-separated
    and listed inside a pair of curly brackets, `{}`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 键/值对由冒号`:`表示。这些对通过逗号分隔，并列在一对大括号`{}`内。
- en: 'Individual elements are accessed by their keys:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 单个元素通过它们的键进行访问：
- en: '[PRE39]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'New objects are added to the dictionary by creating a new key:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 新对象通过创建新键被添加到字典中：
- en: '[PRE40]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Dictionaries are also used to provide parameters to a function (refer to Section 7.2: *Parameters
    and arguments* in [Chapter 7](1654fae9-6203-4871-8352-e436445fa49a.xhtml), *Functions*,
    for further information).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 字典也用于向函数提供参数（更多信息请参见[第7章](1654fae9-6203-4871-8352-e436445fa49a.xhtml)，*函数*中的第7.2节：*参数和实参*）。
- en: Keys in a dictionary can be, among others, strings, functions, tuples with immutable
    elements, and classes. Keys cannot be lists or arrays.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 字典中的键可以是字符串、函数、包含不可变元素的元组以及类等。键**不能**是列表或数组。
- en: 'The command `dict` generates a dictionary from a list with key/value pairs:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`dict`命令从包含键/值对的列表中生成字典：'
- en: '[PRE41]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `zip` function may come in handy in this context; see [Section 3.15](c4f97b8b-36c4-4db4-9e58-02aac275b257.xhtml): *Merging
    lists – zip*.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`zip`函数在此情况下可能会很有用；见[第3.15节](c4f97b8b-36c4-4db4-9e58-02aac275b257.xhtml)：*合并列表–zip*。'
- en: 3.4.2 Looping over dictionaries
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.4.2 遍历字典
- en: 'There are mainly three ways to loop over dictionaries:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历字典的方式主要有三种：
- en: 'By keys:'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过键：
- en: '[PRE42]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'or equivalently:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 或者等效地：
- en: '[PRE43]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'By value:'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过值：
- en: '[PRE44]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'By item, that is, key/value pairs:'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过项目，即键/值对：
- en: '[PRE45]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Please consult [Section 14.4](f95f92d6-d8d1-46a6-bb5b-560714044c70.xhtml): *Shelves* for
    a special dictionary object for file access.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[第14.4节](f95f92d6-d8d1-46a6-bb5b-560714044c70.xhtml)：*架子*，了解用于文件访问的特殊字典对象。
- en: 3.5 Sets
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.5 集合
- en: The last container object we introduce in this section is defined by the data
    type `set`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍的最后一个容器对象由数据类型`set`定义。
- en: Sets are containers that share properties and operations with sets in mathematics.
    A mathematical set is a collection of distinct objects. Like in mathematics, in
    Python the elements of a set are also listed within a pair of braces.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 集合是与数学集合共享属性和操作的容器。数学集合是由不同对象组成的集合。就像数学中一样，在Python中，集合的元素也被列在一对大括号内。
- en: 'Here are some mathematical set expressions:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些数学集合表达式：
- en: '![](img/aad383dc-c771-4612-9a69-441947c90471.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](img/aad383dc-c771-4612-9a69-441947c90471.png)'
- en: 'And here are their Python counterparts:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是它们的Python对应项：
- en: '[PRE46]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Sets contain an element only once, corresponding to the aforementioned definition:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 集合中只能包含一个元素，这与上述定义一致：
- en: '[PRE47]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Moreover, a set is unordered; that is, the order of the elements in the set
    is not defined:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，集合是无序的；也就是说，集合中元素的顺序是未定义的：
- en: '[PRE48]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Sets in Python can contain all kinds of immutable objects, that is, numeric
    objects, strings, and Booleans.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的集合可以包含所有类型的不可变对象，即数字对象、字符串和布尔值。
- en: 'There are the methods `union` and `intersection` for the corresponding mathematical
    operations:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 存在`union`和`intersection`方法，分别对应数学中的并集和交集操作：
- en: '[PRE49]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Also, sets can be compared using the methods `issubset` and `issuperset`:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，集合可以使用`issubset`和`issuperset`方法进行比较：
- en: '[PRE50]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: An empty set is defined in Python by `empty_set=set([])` and not by `{}`, which
    would define an empty dictionary!
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 空集合在Python中通过`empty_set=set([])`定义，而不是通过`{}`，后者会定义一个空字典！
- en: 3.6 Container conversions
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.6 容器转换
- en: 'We summarize in the following *Table 3.3* the most important properties of
    the container types presented so far. (Arrays will be treated separately in [Chapter
    4](b9f628e9-f682-41be-b5a6-94359f8629fc.xhtml): *Linear Algebra – Arrays*):'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在以下*表3.3*中总结了迄今为止介绍的容器类型的最重要属性。（数组将在[第4章](b9f628e9-f682-41be-b5a6-94359f8629fc.xhtml)：*线性代数–数组*中单独讨论）：
- en: '| **Type** | **Access** | **Order** | **Duplicate Values** | **Mutability**
    |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| **类型** | **访问方式** | **顺序** | **重复值** | **可变性** |'
- en: '| List | By index | Yes | Yes | Yes |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| 列表 | 通过索引 | 是 | 是 | 是 |'
- en: '| Tuple | By index | Yes | Yes | No |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| 元组 | 通过索引 | 是 | 是 | 否 |'
- en: '| Dictionary | By key | No | Yes | Yes |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| 字典 | 通过键 | 否 | 是 | 是 |'
- en: '| Set | No | No | No | Yes |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| 集合 | 否 | 否 | 否 | 是 |'
- en: 'Table 3.3: Container types'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '表 3.3: 容器类型'
- en: As you can see in the previous table, there is a difference in accessing container
    elements, and sets and dictionaries are not ordered.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在前面的表格中看到的，访问容器元素的方式是有区别的，集合和字典是无序的。
- en: 'Due to the different properties of the various container types, we frequently
    convert one type to another (see *Table 3.4*):'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 由于各种容器类型的属性不同，我们经常将一种类型转换为另一种类型（见 *表 3.4*）：
- en: '| **Container Types** | **Syntax** |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| **容器类型** | **语法** |'
- en: '| List → Tuple | `tuple([1, 2, 3])` |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| 列表 → 元组 | `tuple([1, 2, 3])` |'
- en: '| Tuple → List | `list((1, 2, 3))` |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| 元组 → 列表 | `list((1, 2, 3))` |'
- en: '| List, Tuple → Set | `set([1, 2]), set((1, ))` |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| 列表，元组 → 集合 | `set([1, 2]), set((1, ))` |'
- en: '| Set → List | `list({1, 2 ,3})` |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| 集合 → 列表 | `list({1, 2 ,3})` |'
- en: '| Dictionary → List | `{''a'':4}.values()` |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| 字典 → 列表 | `{''a'':4}.values()` |'
- en: '| List → Dictionary | - |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| 列表 → 字典 | - |'
- en: 'Table 3.4: Conversion rules for container types'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '表 3.4: 容器类型转换规则'
- en: 'We saw in this section how to convert container types. In [Chapter 2](879c0554-386f-4bb1-8fa8-b86c43927545.xhtml):
    *Variables and Basic Types*, we saw how to convert more elementary datatypes such
    as numbers. So, it is time now to consider how to actually check which datatype
    a variable has, which is the topic of the next section.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们了解了如何转换容器类型。在[第2章](879c0554-386f-4bb1-8fa8-b86c43927545.xhtml)：*变量与基本类型*，我们了解了如何转换更基础的数据类型，例如数字。所以，现在是时候考虑如何实际检查一个变量的数据类型，这将是下一节的主题。
- en: 3.7 Checking the type of a variable
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.7 检查变量类型
- en: 'The direct way to see the type of a variable is to use the command type:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 查看变量类型的直接方式是使用命令 `type`：
- en: '[PRE51]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'However, if you want to test for a variable to be of a certain type, you should
    use `isinstance` (instead of comparing the types with `type`):'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你想检查一个变量是否属于某种类型，应该使用 `isinstance`（而不是使用 `type` 比较类型）：
- en: '[PRE52]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The reason for using `isinstance` becomes apparent after having read about
    the concept of subclassing and inheritance in [Section 8.5](1654fae9-6203-4871-8352-e436445fa49a.xhtml): *Subclassing
    and inheritance*. In short, often different types share some common properties
    with some basic type. The classical example is the type `bool`, which is derived
    by subclassing from the more general type `int`. In this situation, we see how
    the command `isinstance` can be used in a more general way:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `isinstance` 的理由在阅读过[第8.5节](1654fae9-6203-4871-8352-e436445fa49a.xhtml)：*子类化与继承*后变得更加明显。简而言之，不同的类型往往与某个基础类型共享一些共同的属性。经典的例子是
    `bool` 类型，它是通过从更通用的 `int` 类型继承得到的。在这种情况下，我们看到如何更通用地使用 `isinstance` 命令：
- en: '[PRE53]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'So, in order to make sure that the variable `test` can be used as if it were an
    integer – the particular type may be irrelevant – you should check that it is
    an instance of `int`:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了确保变量 `test` 可以像整数一样使用——尽管具体类型可能无关紧要——你应该检查它是否是 `int` 的实例：
- en: '[PRE54]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Python is not a typed language. That means that objects are identified by what
    they can do rather than what they are. For instance, if you have a string manipulating
    function that acts on an object by using the `len` method, then your function
    will probably be useful for any objects implementing the `len` method.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: Python 不是一种强类型语言。这意味着对象的识别依据其功能，而不是其类型。例如，如果你有一个字符串操作函数，该函数通过使用 `len` 方法作用于一个对象，那么你的函数可能对任何实现了
    `len` 方法的对象都有效。
- en: 'So far, we have come across different datatypes: `float`, `int`, `bool`, `complex`,
    `list`, `tuple`, `module`, `function`, `str`, `dict`, and `array`.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经遇到了不同的数据类型：`float`，`int`，`bool`，`complex`，`list`，`tuple`，`module`，`function`，`str`，`dict`
    和 `array`。
- en: 3.8 Summary
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.8 总结
- en: In this chapter, you learned how to work with container types, mainly lists.
    It is important to know how to fill these containers and how to access and manage
    their content. We saw that there is access by position or by keyword.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你学习了如何使用容器类型，主要是列表。了解如何填充这些容器以及如何访问和管理其中的内容非常重要。我们看到，访问方式可以是通过位置或通过关键字。
- en: We will meet the important concept of slicing again in the next chapter on arrays.
    These are specially designed containers for mathematical operations.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章的数组部分再次遇到切片这一重要概念。这些是专门为数学运算设计的容器。
- en: 3.9 Exercises
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.9 练习
- en: '**Ex. 1:** Execute the following statements:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '**例 1：** 执行以下语句：'
- en: '[PRE55]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: What is the content of `L3`?
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`L3` 的内容是什么？'
- en: 'Try to predict the outcome of the following commands:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试预测以下命令的结果：
- en: '[PRE56]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: What does the following command do?
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下命令的作用是什么？
- en: '[PRE57]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Concatenate `L3` and `L4` to a new list `L5`.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `L3` 和 `L4` 连接成一个新的列表 `L5`。
- en: '**Ex. 2:** Use the `range` command and a list comprehension to generate a list
    with 100 equidistantly spaced values between 0 and 1.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '**Ex. 2:** 使用 `range` 命令和列表推导式生成一个包含 100 个等距值的列表，范围从 0 到 1。'
- en: '**Ex. 3:** Assume that the following signal is stored in a list:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '**Ex. 3:** 假设以下信号存储在一个列表中：'
- en: '[PRE58]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'What is the outcome of:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 以下结果是什么？
- en: '[PRE59]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Do this exercise by inspection only, that is, without using your Python shell.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 仅通过检查来做这个练习，也就是说，不使用 Python shell。
- en: '**Ex. 4:** Consider the Python statements:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '**Ex. 4:** 考虑以下 Python 语句：'
- en: '[PRE60]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: and assume that the variable `m` has been previously assigned an integer value.
    What is the value of `ans`? Answer this question without executing the statements
    in Python.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 并假设变量 `m` 已经被赋值为一个整数。`ans` 的值是多少？在不执行 Python 语句的情况下回答这个问题。
- en: '**Ex. 5:** Consider the recursion formula:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '**Ex. 5:** 考虑递归公式：'
- en: '![](img/11b74e07-fe97-4c9e-a0b6-1b384cff0015.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![](img/11b74e07-fe97-4c9e-a0b6-1b384cff0015.png)'
- en: Create a list `u`. Store in its first three elements the three values ![](img/921ed357-eca6-4286-ace3-ea396515a5c5.png),
    and ![](img/232fc9b2-0542-4858-843d-d4e57c224f47.png). These represent the starting
    values ![](img/e5832afc-9afc-46ae-b065-53b9711fd5b9.png) and ![](img/0683b5d5-4b9d-4362-8a66-35245b0bc4a7.png)
    in the given formula. Build up the complete list from the recursion formula.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个列表 `u`。将其前面三个元素分别存储为三个值 ![](img/921ed357-eca6-4286-ace3-ea396515a5c5.png)
    和 ![](img/232fc9b2-0542-4858-843d-d4e57c224f47.png)。这些值表示给定公式中的起始值 ![](img/e5832afc-9afc-46ae-b065-53b9711fd5b9.png)
    和 ![](img/0683b5d5-4b9d-4362-8a66-35245b0bc4a7.png)。根据递归公式构建完整的列表。
- en: 'Construct a second list, `td`, in which you store the values *![](img/4256cd7e-e93c-49c4-9bc6-1404ee654be4.png)*,
    with ![](img/2c943450-f803-4e9c-b44d-66af7f791edd.png). Plot `td` versus `u` (see
    [Section 6.1](86c61820-e645-486c-9418-10079ffac7f8.xhtml): *Making plots*). Make
    a second plot in which you plot the difference, that is, ![](img/13138cdc-1cc2-4ce8-9f80-d82f7a7c630c.png),
    where ![](img/325d4dc1-fe3d-4d4c-907c-f8aa912e0b37.png)represents the values inside
    the vector `td`. Set axis labels and a title.'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建第二个列表 `td`，将值存储为 *![](img/4256cd7e-e93c-49c4-9bc6-1404ee654be4.png)*，其中 ![](img/2c943450-f803-4e9c-b44d-66af7f791edd.png)。绘制
    `td` 与 `u` 的图（见 [第 6.1 节](86c61820-e645-486c-9418-10079ffac7f8.xhtml)：*绘制图表*）。再绘制第二张图，展示差异，即 ![](img/13138cdc-1cc2-4ce8-9f80-d82f7a7c630c.png)，其中 ![](img/325d4dc1-fe3d-4d4c-907c-f8aa912e0b37.png)
    表示 `td` 向量中的值。设置轴标签和标题。
- en: The recursion is a multistep formula to solve the differential equation ![](img/bddef92b-5e38-4de4-a136-f9b278e2e06a.png)
    with the initial value ![](img/75f4fafd-e7c9-405b-9cf0-a5263202aa3d.png).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 递归是一个多步公式，用于求解具有初始值 ![](img/75f4fafd-e7c9-405b-9cf0-a5263202aa3d.png) 的微分方程 ![](img/bddef92b-5e38-4de4-a136-f9b278e2e06a.png)。
- en: '[![](img/e544c41b-2a9b-49b5-b72f-c77590198308.png)] approximates [![](img/9b609804-6bf2-47e1-a952-85b804bab70c.png)].'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '[![](img/e544c41b-2a9b-49b5-b72f-c77590198308.png)] 近似于 [![](img/9b609804-6bf2-47e1-a952-85b804bab70c.png)]。'
- en: '**Ex. 6:** Let ![](img/2f193357-daa9-41f6-a179-e4971501a234.png) and ![](img/b785da32-e046-4761-8745-9258b57b0bf8.png)
    be sets. The set ![](img/59f36140-6831-4e59-a86c-031dc8f9cb56.png) is called the
    symmetric difference of the two sets. Write a function that performs this operation.
    Compare your results to the result of the command:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '**Ex. 6:** 假设 ![](img/2f193357-daa9-41f6-a179-e4971501a234.png) 和 ![](img/b785da32-e046-4761-8745-9258b57b0bf8.png)
    是集合。集合 ![](img/59f36140-6831-4e59-a86c-031dc8f9cb56.png) 被称为这两个集合的对称差。编写一个函数来执行此操作。将你的结果与以下命令的结果进行比较：'
- en: '[PRE61]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '**Ex. 7:** Verify in Python the statement that the empty set is a subset of
    any set.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '**Ex. 7:** 在 Python 中验证空集合是任何集合的子集这一说法。'
- en: '**Ex. 8:** Study other operations on sets. You can find a complete list of
    those by using the command completion feature of `IPython`. In particular, study
    the `update` and `intersection_update` methods. What is the difference between `intersection` and `intersection_update`?'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '**Ex. 8:** 研究集合的其他操作。你可以使用 `IPython` 的命令自动补全功能找到这些操作的完整列表。特别是，研究 `update` 和
    `intersection_update` 方法。`intersection` 和 `intersection_update` 有什么区别？'
