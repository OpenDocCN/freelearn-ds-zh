- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Beautifying Streamlit Apps
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 美化Streamlit应用程序
- en: Welcome to *Section 2* of the book! In *Section 1*, *Creating Basic Streamlit
    Applications*, we focused on the basics – visualization, deployment, and data
    munging – all the topics that are crucial to getting started with Streamlit. In
    this part of the book, the purpose is to explore Streamlit through more complex
    applications and use cases, with the intent of turning you into an expert Streamlit
    user.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到本书的*第二部分*！在*第一部分*，*创建基础Streamlit应用程序*中，我们专注于基础内容——可视化、部署和数据处理——这些都是入门Streamlit时至关重要的主题。在本部分中，目的是通过更复杂的应用程序和用例来探索Streamlit，旨在将你培养成一个Streamlit专家。
- en: Throughout this chapter, we’ll work with elements (including sidebars, tabs,
    columns, and colors) to extend our ability to make beautiful Streamlit applications.
    Along with this, we’ll explore how to create multi-page applications to manage
    user flow, creating a cleaner and more structured user experience.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用元素（包括侧边栏、标签、列和颜色）来扩展我们美化Streamlit应用程序的能力。同时，我们将探索如何创建多页面应用程序来管理用户流动，创造一个更清晰、更结构化的用户体验。
- en: By the end of this chapter, you should feel much more comfortable creating applications
    that are better than the average **Minimum Viable Product** (**MVP**). We’ll start
    by learning about columns and move on to the rest of the elements discussed, weaving
    each into the main Streamlit app for the chapter.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，你应该会更加自信地创建比普通**最小可行产品**（**MVP**）更好的应用程序。我们将从学习列（columns）开始，然后继续讨论本章中的其他元素，并将每个元素融入到主Streamlit应用程序中。
- en: 'Specifically, in this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，在本章中，我们将涵盖以下主题：
- en: Setting up the **San Francisco** (**SF**) Trees dataset
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置**旧金山**（**SF**）树木数据集
- en: Working with columns
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用列（columns）
- en: Working with tabs
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用标签
- en: Exploring page configuration
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索页面配置
- en: Using the Streamlit sidebar
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Streamlit侧边栏
- en: Picking colors with a color picker
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用颜色选择器选择颜色
- en: Multi-page apps
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多页面应用程序
- en: Editable DataFrames
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可编辑的DataFrame
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter requires a free GitHub account, which can be obtained at [https://www.github.com](https://www.github.com).
    A full primer on GitHub, along with detailed setup instructions, can be found
    in the *A quick primer on GitHub* section in the previous chapter, *Chapter 5*,
    *Deploying Streamlit with Streamlit Community Cloud*.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章需要一个免费的GitHub账户，可以通过[https://www.github.com](https://www.github.com)获得。关于GitHub的完整简介以及详细的设置说明，可以在上一章*第5章*，*在Streamlit社区云上部署Streamlit*中的*GitHub简要介绍*部分找到。
- en: Setting up the SF Trees dataset
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置SF Trees数据集
- en: 'For this chapter, we will be working with the SF Trees dataset again, the same
    dataset that we used in *Chapter 3,* *Data Visualization*. As we did in the previous
    chapters, we need to follow this list of steps for the setup:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将再次使用SF Trees数据集，这是我们在*第3章*，*数据可视化*中使用的数据集。和之前的章节一样，我们需要按照以下步骤进行设置：
- en: Create a new folder for the chapter.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为章节创建一个新文件夹。
- en: Add our data to the folder.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们的数据添加到文件夹中。
- en: Create a Python file for our app.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为我们的应用程序创建一个Python文件。
- en: Let’s see each of these steps in detail.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细了解每一个步骤。
- en: 'In our main `streamlit_apps` folder, run the following code in your terminal
    to make a new folder cleverly called `pretty_trees`. You can also create a new
    folder manually outside the terminal:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的主`streamlit_apps`文件夹中，在终端运行以下代码，创建一个巧妙命名为`pretty_trees`的新文件夹。你也可以在终端外手动创建一个新文件夹：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, we need to move our data from *Chapter 3,* *Data Visualization*, into
    our folder for this chapter. The following code copies the data into the correct
    folder:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要将*第3章*，*数据可视化*中的数据移动到本章的文件夹中。以下代码将数据复制到正确的文件夹：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If you do not have the `trees_app` folder and have not yet completed *Chapter
    3,* *Data Visualization*, you can also download the necessary data from [https://github.com/tylerjrichards/Streamlit-for-Data-Science](https://github.com/tylerjrichards/Streamlit-for-Data-Science)
    within the folder titled `trees_app`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有`trees_app`文件夹，并且还没有完成*第3章*，*数据可视化*，你也可以从[https://github.com/tylerjrichards/Streamlit-for-Data-Science](https://github.com/tylerjrichards/Streamlit-for-Data-Science)下载所需的数据，文件夹名称为`trees_app`。
- en: 'Now that we have our data ready, we need to create a Python file to host our
    Streamlit app’s code; the following code does precisely this:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了数据，我们需要创建一个Python文件来托管我们的Streamlit应用程序代码；以下代码正是完成这一任务：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `pretty_trees` file will hold our Python code, so go ahead and open it up
    in the text editor of your choice and the chapter can officially begin with us
    learning how to work with columns in Streamlit!
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`pretty_trees` 文件将包含我们的 Python 代码，所以打开你喜欢的文本编辑器，接下来我们就可以正式开始学习如何在 Streamlit
    中使用列！'
- en: Working with columns in Streamlit
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Streamlit 中使用列
- en: In all of our apps prior to this point, we have viewed each Streamlit task as
    a top-down experience. We output text as our title, collect some user input, and
    then put our visualizations below that. However, Streamlit allows us to format
    our app into dynamic columns using the `st.columns()` feature.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之前的所有应用中，我们都将每个 Streamlit 任务视为自上而下的体验。我们将文本作为标题输出，收集一些用户输入，然后将我们的可视化内容放在下方。然而，Streamlit
    允许我们使用 `st.columns()` 功能将应用格式化为动态列。
- en: We can divide our Streamlit app into multiple columns of different lengths and
    then treat each column as its own unique space (called a container) in our app
    to include text, graphs, images, or anything else we would like.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将 Streamlit 应用划分为多个不同长度的列，然后将每个列视为应用中独立的空间（称为容器），以便放置文本、图表、图片或任何其他内容。
- en: 'The syntax for columns in Streamlit uses the `with` notation, which you may
    already have been familiar with for use cases such as resource management and
    dealing with opening and writing to files in Python. The easiest way to think
    about the `with` notation in Streamlit columns is that they are self-contained
    blocks of code that tell Streamlit exactly where to place items in our apps. Let’s
    check out an example to see how it works. The following code imports our SF Trees
    dataset and creates three columns of equal length within it, writing text into
    each one:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Streamlit 中，列的语法使用 `with` 语法，这可能你已经熟悉，用于资源管理以及在 Python 中处理文件的打开和写入。理解 Streamlit
    列中的 `with` 语法的最简单方式是将它看作是自包含的代码块，这些代码块告诉 Streamlit 我们希望在应用中将元素放置在哪里。让我们看看一个例子，看看它是如何工作的。以下代码导入了我们的
    SF Trees 数据集，并在其中创建了三个等长的列，在每个列中写入文本：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The preceding code will create the app shown in the following screenshot:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将创建如下截图所示的应用：
- en: '![](img/B18444_06_01.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18444_06_01.png)'
- en: 'Figure 6.1: First three columns'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1：前三列
- en: 'As we can see, `st.columns()` defines three columns of equal length, and we
    can use the `with` notation to print some text in each. We can also call the `st.write()`
    function (or any other Streamlit function that writes content to our Streamlit
    app) directly on our predefined columns for the same outcome, as shown in the
    following code. The following code will have the exact same output as the preceding
    code block:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`st.columns()` 定义了三个等长的列，我们可以使用 `with` 语法在每个列中打印一些文本。我们还可以直接在我们预定义的列上调用
    `st.write()` 函数（或任何其他将内容写入 Streamlit 应用的函数），以获得相同的结果，如下代码所示。以下代码将产生与前一个代码块完全相同的输出：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As we write more complex Streamlit apps with more content in each column, `with`
    statements tend to make for cleaner apps that are easier to understand and debug.
    The majority of this book will use `with` statements whenever possible.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编写更复杂的 Streamlit 应用并在每个列中加入更多内容时，`with` 语句有助于使应用更加简洁，易于理解和调试。本书的大部分内容将尽可能使用
    `with` 语句。
- en: 'In Streamlit, the column width is relative to the size of the other defined
    columns. Because of this, if we scale up the width of each column to `10` instead
    of `1`, our app will not change at all. Additionally, we can also pass a single
    number into `st.beta_columns()`, which will return that number of columns of equal
    width. The following code block shows three options for column width that all
    result in the same column width:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Streamlit 中，列的宽度是相对于其他已定义列的大小的。因此，如果我们将每列的宽度从 `1` 增大到 `10`，我们的应用将不会发生任何变化。此外，我们还可以向
    `st.beta_columns()` 传递一个数字，这将返回该数字个相等宽度的列。以下代码块展示了三种列宽选项，所有选项的列宽都相同：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As a final example, the following code block allows the user input to determine
    the width of each column. Go ahead and play around with the resulting app to better
    understand how we can use columns to change the format behind our Streamlit apps:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后一个示例，以下代码块允许用户输入来决定每个列的宽度。你可以玩一玩生成的应用，更好地理解如何使用列来改变 Streamlit 应用的格式：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In *Chapter 3,* *Data Visualization*, we used the following code to show differences
    between the built-in Streamlit functions `st.line_chart()`, `st.bar_chart()`,
    and `st.area_chart()`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第 3 章*，*数据可视化* 中，我们使用以下代码展示了 Streamlit 内置函数 `st.line_chart()`、`st.bar_chart()`
    和 `st.area_chart()` 之间的差异：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The preceding code block creates the following Streamlit app, with three graphs
    of SF trees grouped by their width placed one right after the other (only the
    two graphs are shown for brevity):'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码块创建了以下Streamlit应用，三个按宽度分组的SF树图表一个接一个地排列（为了简洁起见，这里只显示两个图表）：
- en: '![](img/B18444_06_02.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18444_06_02.png)'
- en: 'Figure 6.2: SF line and bar charts'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2：SF线图和柱状图
- en: 'The point of this exercise was to better understand the three Streamlit functions,
    but how can we do that if we need to scroll to see them all? Let’s improve on
    this by putting our three graphs side by side using three columns. The following
    code predefines three equally wide columns and places one graph in each:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这次练习的目的是更好地理解Streamlit的三个函数，但如果我们需要滚动才能看到所有内容，我们怎么做呢？让我们通过使用三个列将三个图表并排放置来改进这一点。以下代码预定义了三个等宽的列，并将一个图表放入每个列中：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'When we run the preceding code, we get a strange result shown in the following
    screenshot:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行前面的代码时，得到如下所示的奇怪结果：
- en: '![](img/B18444_06_03.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18444_06_03.png)'
- en: 'Figure 6.3: Skinny graphs'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3：细长图表
- en: This is most certainly not what we wanted! Each graph is far too narrow. Luckily
    for us, this brings us to our next mini-topic, page configuration in Streamlit.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这显然不是我们想要的！每个图表都太窄了。幸运的是，这引出了我们下一个小主题：Streamlit中的页面配置。
- en: Exploring page configuration
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索页面配置
- en: Streamlit allows us to configure a few essential page-specific features at the
    top of each Streamlit app. So far, we have been using the Streamlit defaults,
    but at the top of our Streamlit app, we can manually configure everything, from
    the page title shown on the web browser that is used to open our Streamlit apps,
    to the page layout, to the sidebar default state (we will cover the sidebar in
    the *Using the Streamlit sidebar* section!).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Streamlit允许我们在每个Streamlit应用的顶部配置一些必要的页面特性。到目前为止，我们一直在使用Streamlit的默认设置，但在Streamlit应用的顶部，我们可以手动配置一切，从浏览器中显示的页面标题（用于打开Streamlit应用），到页面布局，再到侧边栏的默认状态（我们将在*使用Streamlit侧边栏*部分讲解！）。
- en: 'The default for Streamlit apps is to have a centered page layout, which is
    why there is copious white space on the edges of our apps. The following code
    sets up our Streamlit app in a wide format instead of our default-centered one:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Streamlit应用的默认设置是页面布局居中，因此我们的应用边缘有大量的空白区域。以下代码将我们的Streamlit应用设置为宽格式，而不是默认的居中格式：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'When we run the preceding code, we now see that our three graphs are well spaced,
    and we can easily compare the three. The following screenshot shows the Streamlit
    app in a wide format:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行前面的代码时，现在可以看到三个图表之间有了良好的间隔，我们可以轻松地对比这三个图表。以下截图显示了Streamlit应用的宽格式：
- en: '![](img/B18444_06_04.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18444_06_04.png)'
- en: 'Figure 6.4: Wide-format graphs'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4：宽格式图表
- en: 'There are two more bits of information that we need to know about Streamlit
    columns. The first is that we can also edit the gap between the column containers
    that we create, and the second is that we can also ensure that graphs stay within
    their columns and don’t bleed over into the other ones. For the gap part, the
    default is to leave a small gap between the columns, but we can change this to
    a medium or a large gap instead. This next bit of code adds a large gap between
    each of the three columns:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要了解关于Streamlit列的两个信息。第一个是我们可以编辑我们创建的列容器之间的间距，第二个是我们可以确保图表保持在其列内，而不会溢出到其他列。至于间距部分，默认情况下列之间会有一个小间隙，但我们可以将其改为中等或大间隙。以下代码为每三个列之间添加了一个大间隙：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now, if we look between the graphs, we will notice a gap!
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们观察图表之间的空隙，我们会注意到有一个间隙！
- en: '![](img/B18444_06_05.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18444_06_05.png)'
- en: 'Figure 6.5: Gap in the graphs'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.5：图表间隙
- en: As you may notice, Streamlit’s built-in charts that we’re using already ensure
    that the graphs stay in the columns as they’re supposed to and also sit flush
    with the end of the column. This is because the default on each is to set the
    parameter `use_container_width` to `True`, so what happens if we set it to `False`,
    like this next bit of code?
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所注意到的，我们正在使用的Streamlit内置图表已经确保了图表保持在列内，并且与列的末端对齐。这是因为每个图表的默认设置是将参数`use_container_width`设置为`True`，那么如果我们将其设置为`False`，会发生什么呢？请看以下代码：
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As we can see in this next screenshot, the graph no longer sits flush with
    the column, thereby making our apps look worse (which is why the default has the
    value as `True`!):'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在下一张截图中看到的那样，图表不再与列对齐，从而让我们的应用看起来更糟（这也是为什么默认设置为`True`的原因！）：
- en: '![](img/B18444_06_06.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18444_06_06.png)'
- en: 'Figure 6.6: Container width'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.6：容器宽度
- en: This concludes our exploration of using columns in Streamlit and also concludes
    our first look at page configuration defaults. We will increasingly use both of
    these skills in the remainder of the book. Our next topic is to introduce the
    Streamlit sidebar.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对在 Streamlit 中使用列的探索，同时也结束了我们第一次了解页面配置默认设置。我们将在本书的其余部分越来越多地使用这两项技能。我们的下一个主题是介绍
    Streamlit 侧边栏。
- en: Using Streamlit tabs
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Streamlit 标签页
- en: There is a second way to organize your Streamlit app layout that is remarkably
    similar to the Streamlit column, called the tab. Tabs are useful when you have
    content that is too wide to break up into columns, even in wide mode, and also
    are useful when you want to focus attention by only showing one piece of content
    at a time. For example, if we had three very distinct graphs that only looked
    good in wide mode, but we didn’t want to put them vertically on top of each other,
    we could use tabs to selectively show them. Let’s explore exactly how this works!
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种组织 Streamlit 应用布局的方式，非常类似于 Streamlit 列，叫做标签页。标签页在内容太宽，无法分割为列的情况下非常有用，即使在宽模式下也是如此；当你希望只显示一个内容时，标签页也很有用。例如，如果我们有三个非常不同的图表，在宽模式下才能显示得很好，但我们又不想将它们垂直堆叠在一起，我们可以使用标签页选择性地显示它们。让我们来探索一下这到底是如何工作的！
- en: '`st.tabs` works very similarly to `st.columns`, but instead of telling Streamlit
    the number of tabs we want, we instead pass along the names of the tabs and then
    use now-familiar `with` statements to place content into the tab. The next bit
    of code turns the columns from our most recent Streamlit app into tabs:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`st.tabs` 的功能与 `st.columns` 非常相似，不过我们不再告诉 Streamlit 我们想要多少个标签页，而是传递标签页的名称，然后使用现在熟悉的
    `with` 语句将内容放入标签页中。接下来的代码将我们最近的 Streamlit 应用中的列转换为标签页：'
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'From this, we will get the following app:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，我们将得到以下应用：
- en: '![](img/B18444_06_07.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18444_06_07.png)'
- en: 'Figure 6.7: First tabs'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.7：第一个标签页
- en: And that’s all there is to tabs! Tabs don’t have the gap parameter that columns
    do (because, well, what would a gap be for tabs?), but aside from this, we can
    map all the information we learned about columns onto our knowledge of tabs. Now,
    on to the Streamlit sidebar.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这么简单！标签页没有像列那样的间距参数（因为，嗯，标签页有什么用间距呢？），但除了这一点，我们可以将所有关于列的知识映射到标签页的使用上。现在，接下来是
    Streamlit 侧边栏。
- en: Using the Streamlit sidebar
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Streamlit 侧边栏
- en: As we have already seen in Streamlit, when we start to both accept large amounts
    of user input and also start to develop longer Streamlit apps, we often lose the
    ability for the user to see both their input and the output on the same screen.
    In other cases, we may want to put all the user input into its own section to
    clearly separate input and output in our Streamlit app. For both of these use
    cases, we can use the Streamlit sidebar, which allows us to place a minimizable
    sidebar on the left side of the Streamlit app and add any Streamlit component
    to it.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在 Streamlit 中已经看到的，当我们开始接收大量用户输入并且开发更长的 Streamlit 应用时，我们常常会失去让用户在同一屏幕上看到输入和输出的能力。在其他情况下，我们可能希望将所有用户输入放在一个单独的区域中，以便清晰地分隔输入和输出。在这两种使用场景下，我们可以使用
    Streamlit 侧边栏，它允许我们在 Streamlit 应用的左侧放置一个可最小化的侧边栏，并将任何 Streamlit 组件添加到其中。
- en: 'To begin with, we can create a basic example that takes one of the graphs from
    our preceding app and filters the data behind it based on the user’s input. In
    this case, we can ask the user to specify the type of tree owner (for example,
    a private owner or the Department of Public Works) and filter on those conditions
    using the `st.multiselect()` function, which allows the user to select multiple
    options from a list:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以创建一个基本示例，将之前应用中的一个图表提取出来，并根据用户输入对其背后的数据进行过滤。在这种情况下，我们可以要求用户指定树木所有者的类型（例如，私人所有者或公共工程部），并使用
    `st.multiselect()` 函数按这些条件进行过滤，该函数允许用户从列表中选择多个选项：
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The preceding code will create the following Streamlit app. As we have done
    before, we hide the `owners` variable within an `if` statement, as we would like
    the app to run with the entire dataset if the user has yet to select from the
    options. The sidebar allows the user to easily see both the options they selected
    and the output to our app:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将创建以下的 Streamlit 应用。和之前一样，我们将 `owners` 变量隐藏在 `if` 语句中，因为我们希望在用户尚未从选项中选择时，应用能够使用整个数据集。侧边栏让用户可以轻松查看他们选择的选项以及应用的输出：
- en: '![](img/B18444_06_08.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18444_06_08.png)'
- en: 'Figure 6.8: First sidebar'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.8：第一个侧边栏
- en: Our next step for this app is going to be to add a few more visualizations,
    starting with the tree map we created in *Chapter 3,* *Data Visualization*, and
    then combine the sidebar with what we have already learned about columns in this
    chapter.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应用的下一步是添加更多的可视化，从我们在*第3章*，*数据可视化*中创建的树木地图开始，然后将侧边栏与我们在本章学到的列知识相结合。
- en: 'The following code places the map of trees throughout SF, filtered by our multi-select
    box, below the histogram:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将树木地图放置在SF的直方图下方，并通过我们的多选框进行过滤：
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The following screenshot shows the Streamlit app from the preceding code, with
    the line chart just above the new map of the trees in SF, filtered by the tree
    owner:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了前面代码中的Streamlit应用，线图位于新地图上方，地图显示的是SF的树木，已根据树木拥有者进行过滤：
- en: '![](img/B18444_06_09.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18444_06_09.png)'
- en: 'Figure 6.9: Filtered map with sidebar'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.9：带侧边栏的过滤地图
- en: 'Our next step for this app will be to combine what we learned about columns
    with the sidebar by adding another graph on top of the map. In *Chapter 3,* *Data
    Visualization*, we created a histogram of the age of the trees. We can use that
    as our third graph in this Streamlit app using the Plotly library:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应用的下一步将是通过在地图上方添加另一个图表，将我们学到的关于列的知识与侧边栏相结合。在*第3章*，*数据可视化*中，我们创建了树木年龄的直方图。我们可以使用它作为这个Streamlit应用中的第三个图表，借助Plotly库：
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This first section:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分：
- en: Loads the trees dataset.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载树木数据集。
- en: Adds an age column based on the date column in our dataset.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基于我们数据集中的日期列，添加一个年龄列。
- en: Creates a multi-select widget on the sidebar.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在侧边栏创建一个多选控件。
- en: Filters, based on the sidebar.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基于侧边栏的过滤器。
- en: 'Our next step is to create our three graphs:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一步是创建三个图表：
- en: '[PRE16]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'As we have already discussed in *Chapter 3,* *Data Visualization*, built-in
    Streamlit functions such as `st.map()` and `st.line_chart()` are useful for quick
    visualizations but lack some configuration options, such as proper titles or axis
    renaming. We can do so much more with Plotly! The following screenshot shows our
    Streamlit app with a few tree owner filters pre-set:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在*第3章*，*数据可视化*中已经讨论过的那样，Streamlit内置的函数，如`st.map()`和`st.line_chart()`，对于快速可视化非常有用，但缺乏一些配置选项，比如合适的标题或轴重命名。我们可以通过Plotly做得更多！下图显示了我们的Streamlit应用，预设了一些树木拥有者过滤器：
- en: '![](img/B18444_06_10.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18444_06_10.png)'
- en: 'Figure 6.10: Three filtered graphs'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.10：三个过滤后的图表
- en: Our next feature to discuss in this chapter is how to add color input into Streamlit
    apps with a color picker!
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 本章接下来的功能是如何通过颜色选择器将颜色输入添加到Streamlit应用中！
- en: Picking colors with a color picker
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用颜色选择器选择颜色
- en: 'Colors are very difficult to take in as user input in apps. If a user wants
    red, do they want light red or dark red? Maroon or a pinkish red? Streamlit’s
    approach to this problem is `st.color_picker()`, which lets the user pick a color
    as a part of their user input, and returns that color in a hex string (which is
    a unique string that defines very specific color shades used by most graphing
    libraries as input). The following code adds this color picker to our previous
    app and changes the color of the Seaborn graphs to be based on the color that
    the user selects:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 颜色作为用户输入在应用中非常难以处理。如果用户想要红色，他们是想要浅红色还是深红色？是栗色还是偏粉红的红色？Streamlit解决这个问题的方法是`st.color_picker()`，它允许用户选择一种颜色作为输入，并以十六进制字符串的形式返回该颜色（这是一个独特的字符串，用于定义大多数图表库用于输入的非常特定的颜色阴影）。以下代码将此颜色选择器添加到我们之前的应用中，并根据用户选择的颜色更改Seaborn图表的颜色：
- en: '[PRE17]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The change here from our previous app is to add the `graph_color` variable,
    which is a result of the `st.color_picker()` function. We added a name to this
    color picker and placed the color picker in the sidebar right under the owner’s
    multi-select widget. Now that we have the color input from the user, we can use
    this to change the colors in our graphs, as shown in the following code:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前的应用相比，变化在于添加了`graph_color`变量，它是`st.color_picker()`函数的结果。我们为这个颜色选择器添加了名称，并将其放在侧边栏中，位于拥有者的多选控件下方。现在，我们从用户那里获取了颜色输入，就可以使用它来更改图表中的颜色，如以下代码所示：
- en: '[PRE18]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'When you run this Streamlit app, you can see exactly how the color picker works
    (this book is published in grayscale, so it is not visible in the hard copy).
    It has a default color (in our case, black), which you can change by selecting
    the component and then clicking on your color of choice. The following screenshot
    shows both the component when clicked on and the result in our SF Trees app:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这个 Streamlit 应用时，你可以看到颜色选择器是如何工作的（这本书是黑白印刷的，所以在纸质版中不可见）。它有一个默认颜色（在我们的案例中是黑色），你可以通过选择该组件然后点击你选择的颜色来更改它。以下截图展示了点击时的组件和我们
    SF Trees 应用中的结果：
- en: '![](img/B18444_06_11.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18444_06_11.png)'
- en: 'Figure 6.11: Color picker'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.11：颜色选择器
- en: 'Now that we know how to change the colors of visualizations in Streamlit, let’s
    move over to the last section of this chapter: creating multi-page apps.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道如何更改 Streamlit 中可视化的颜色，让我们进入本章的最后一部分：创建多页应用。
- en: Multi-page apps
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多页应用
- en: Our Streamlit apps thus far have all been single pages, where all or nearly
    all the information in the app has been visible to us with a simple scroll. However,
    Streamlit also has multi-page functionality. Multi-page apps are a powerful tool
    for creating apps that are not limited to one page of content and can extend the
    user experience that comes with Streamlit. For example, the Streamlit data team
    currently primarily builds multi-page apps, having a new app for each project
    or team that they are creating Streamlit apps for.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的 Streamlit 应用都是单页应用，在这些应用中，所有或几乎所有的信息都能通过简单滚动看到。然而，Streamlit 也有多页功能。多页应用是一个强大的工具，可以用来创建不仅限于一页内容的应用，并扩展
    Streamlit 带来的用户体验。例如，Streamlit 数据团队目前主要构建多页应用，为每个项目或团队创建一个新的应用。
- en: 'For our first multi-page app, we’re going to focus on separating the map section
    of the trees app from the rest of the graphs in two separate apps. The way Streamlit
    creates multi-page apps is it looks in the same directory as our Streamlit app
    for a folder called `pages` and then runs each Python file inside the `pages`
    folder as its own Streamlit app. To do this, create a new folder inside `pretty_trees`
    called `pages`, and then put a file inside `pages` called `map.py`. In your terminal
    from the base folder in the repository, you can run the following:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的第一个多页应用，我们将专注于将树木应用中的地图部分与其他图表分开，创建两个独立的应用。Streamlit 创建多页应用的方式是，它会在与我们的
    Streamlit 应用相同的目录中查找一个名为 `pages` 的文件夹，然后将 `pages` 文件夹中的每个 Python 文件作为独立的 Streamlit
    应用运行。为此，在 `pretty_trees` 文件夹中创建一个名为 `pages` 的新文件夹，然后在 `pages` 文件夹中创建一个名为 `map.py`
    的文件。在你的终端中，从仓库的基础文件夹运行以下命令：
- en: '[PRE19]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, when we run our Streamlit app, we should see the **map** app on the sidebar
    as its own app:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们运行 Streamlit 应用时，我们应该在侧边栏看到 **地图** 应用作为独立应用：
- en: '![](img/B18444_06_12.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18444_06_12.png)'
- en: 'Figure 6.12: Our first multi-page app'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.12：我们的第一个多页应用
- en: 'When we click **map** in the top left, it will be completely blank. Now, we
    need to take the map code and move it over into the `map.py` file! Inside the
    `map.py` file, we can include the following code (which is just copied and pasted
    from our original app):'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们点击左上角的**地图**时，它将完全为空白。现在，我们需要将地图代码移到 `map.py` 文件中！在 `map.py` 文件中，我们可以包含以下代码（这只是从我们原始应用中复制粘贴过来的）：
- en: '[PRE20]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'When we click on the **map** app, it should no longer be blank but should instead
    look like this:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们点击**地图**应用时，它不再是空白的，而应该像这样：
- en: '![](img/B18444_06_13.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18444_06_13.png)'
- en: 'Figure 6.13: Map MPA'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.13：地图 MPA
- en: 'The last thing we need to do for this app is to remove the map code from the
    main file. Our main file’s code should now be much smaller and should look like
    this. Here is a snippet of the code:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为这个应用做的最后一件事是将地图代码从主文件中移除。现在我们主文件的代码应该大大减少，应该看起来像这样。以下是代码片段：
- en: '[PRE21]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: If we wanted to add a new app, we would only need to add another file to the
    `pages` folder, and Streamlit would handle all the rest.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想添加一个新应用，我们只需在 `pages` 文件夹中添加另一个文件，Streamlit 会处理其余的部分。
- en: As you can see, multi-page apps can be extremely powerful. As our apps get longer
    and the user experience of our apps becomes more complicated, we can rely on multi-page
    apps to drive clarity in the user experience. With these, you can easily imagine
    creating one large multi-page app that has individual apps for your different
    business users (like your marketing team, your sales team, etc.) or even just
    as an elegant way to split up your larger apps. If you ever want to create a new
    app, just add another Python file to the `pages` folder, and the new app will
    pop up in the sidebar!
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，多页面应用可以非常强大。随着我们的应用变得越来越复杂，用户体验也变得更加复杂，我们可以依赖多页面应用来提升用户体验的清晰度。通过这些，你可以轻松想象创建一个大型的多页面应用，为不同的业务用户（如市场团队、销售团队等）提供单独的应用，甚至只是一个优雅的方式来拆分你更大的应用。如果你想创建一个新的应用，只需在
    `pages` 文件夹中添加一个新的 Python 文件，新应用就会出现在侧边栏！
- en: 'A member of the Streamlit data science team (Zachary Blackwood, [https://github.com/blackary](https://github.com/blackary))
    created a Python library called `st-pages` that adds a host of new features on
    top of multi-page apps, like adding emojis to page links or creating sections
    for files. The library is fairly young but is a great additional resource if you
    are interested in creating even larger apps than we have worked on in this chapter.
    There is a large and vibrant community around Streamlit, and libraries like these
    are just our first foray into the wonders of open source Streamlit:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Streamlit 数据科学团队的一员（Zachary Blackwood，[https://github.com/blackary](https://github.com/blackary)）创建了一个名为
    `st-pages` 的 Python 库，该库为多页面应用提供了一系列新特性，如为页面链接添加表情符号或为文件创建分区。这个库还很年轻，但如果你有兴趣创建比本章中更大的应用，它是一个非常好的附加资源。Streamlit
    拥有一个庞大且充满活力的社区，像这样的库只是我们初次接触开源 Streamlit 的一个开始：
- en: '![](img/B18444_06_14.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18444_06_14.png)'
- en: 'Figure 6.14: st-pages'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.14：st-pages
- en: That is it for multi-page apps! Now on to editable DataFrames.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是多页面应用的内容！现在我们来讨论可编辑的 DataFrame。
- en: Editable DataFrames
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可编辑的 DataFrame
- en: So far in this book, we have assumed that we want the data used in these apps
    to be static. We have used mostly CSV files or programmatically generated datasets
    that remain unchanged by the users of our apps.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本书中，我们假设希望在这些应用中使用的数据是静态的。我们大多使用的是 CSV 文件或由程序生成的数据集，这些数据集在用户使用应用时不会发生变化。
- en: This is very often the case, but we might want to give users the ability to
    alter or edit the underlying data in a very user-friendly way. To help solve this,
    Streamlit released `st.experimental_data_editor`, a way to give users edit ability
    on top of an `st.dataframe-style` interface.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况非常常见，但我们可能希望让用户能够以非常用户友好的方式更改或编辑底层数据。为了解决这个问题，Streamlit 发布了 `st.experimental_data_editor`，它允许用户在
    `st.dataframe-style` 界面上进行编辑。
- en: There are a massive number of potential apps for editing DataFrames, from using
    Streamlit as a quality control system to allowing for direct edits to configuration
    parameters to doing even more of the “what-if” analyses that we have done so far
    in this book. As a creator of many different apps in a work setting, I have noticed
    that people are often extremely comfortable with the everpresent spreadsheet and
    prefer that type of UI.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 有大量潜在的应用可以编辑 DataFrame，从使用 Streamlit 作为质量控制系统，到直接编辑配置参数，再到做更多类似于本书中“假设分析”的操作。作为一个在工作环境中创建许多不同应用的人，我注意到人们通常对随时可见的电子表格非常熟悉，并且更喜欢这种类型的用户界面。
- en: For this example, let’s create a new app called `data_quality.py` in the `pages`
    folder, and try out the new editable DataFrame feature. Imagine that we’re a part
    of the data department in SF, and having missing data in privately owned trees
    is causing some issues for us. We want a few people to come and take a look at
    our data and edit anything that they see might be wrong, and then we also want
    to write that data back to our trusty data source, the CSV file.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将在 `pages` 文件夹中创建一个名为 `data_quality.py` 的新应用，并尝试使用新的可编辑 DataFrame 功能。假设我们是
    SF 的数据部门的一员，私有树木中的缺失数据正在给我们带来一些问题。我们希望让几个人来查看我们的数据并编辑他们认为有问题的内容，然后我们还希望将这些数据写回到我们的可靠数据源——CSV
    文件中。
- en: 'First, we can start by writing a small message at the top of our new file,
    filtering the data as we have done before, and showing the DataFrame to the user,
    like so:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以通过在新文件的顶部写一条简短的信息，像之前一样过滤数据，并将 DataFrame 显示给用户，代码如下：
- en: '[PRE22]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To make this data editable, we only need to change `st.dataframe` to `st.experimental_data_editor`,
    and then pass the result back to a new DataFrame:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使数据可编辑，我们只需将`st.dataframe`更改为`st.experimental_data_editor`，然后将结果返回到一个新的数据框：
- en: '[PRE23]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This app, when it is run, looks like the following. I clicked on a cell and
    edited it to show that this works!
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这个应用时，界面如下所示。我点击了一个单元格并编辑它，以显示这个功能是有效的！
- en: '![](img/B18444_06_15.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18444_06_15.png)'
- en: 'Figure 6.15: st-experimental_data_editor'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.15：st-experimental_data_editor
- en: 'The entire DataFrame is passed back by the data editor, so our last step is
    to edit the original, unfiltered DataFrame and then overwrite the CSV file. We
    want to make sure that the user is sure about their changes, so we can add a button
    that writes the result back to the original CSV file:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 数据编辑器会返回整个数据框，因此我们的最后一步是编辑原始的、未经过滤的数据框，然后覆盖CSV文件。我们希望确保用户确认他们的修改，因此我们可以添加一个按钮，将结果写回原始的CSV文件：
- en: '[PRE24]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This app now looks like this. We can notice that the plot size measurements
    are missing for many of the rows in this dataset!
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个应用的界面如下所示。我们可以注意到，这个数据集中的许多行缺少绘图大小的测量数据！
- en: '![](img/B18444_06_16.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18444_06_16.png)'
- en: 'Figure 6.16: Missing plot size measurements in SF Trees Data Quality App'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.16：SF树木数据质量应用中缺失的绘图大小测量
- en: 'We can add them and then click the save data button to overwrite. Maybe we
    also noticed a data quality issue in the first row, where the x is capitalized
    (dissimilar from the rest!). Let’s edit that too:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以添加它们，然后点击保存数据按钮进行覆盖。也许我们还注意到第一行存在数据质量问题，其中的x字母是大写的（与其余部分不同！）。我们来编辑一下：
- en: '![](img/B18444_06_17.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18444_06_17.png)'
- en: 'Figure 6.17: Editing SF Trees Data Quality App'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.17：编辑SF树木数据质量应用
- en: Now, if we reload the app or have this data hosted on Streamlit Community Cloud
    and someone else visits the app, all the data is corrected.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们重新加载应用或将数据托管在Streamlit Community Cloud上，其他人访问应用时，所有数据都会被修正。
- en: As of the time of writing this book, the data editor is an extremely new feature
    (it was released in Streamlit 1.19, and this book runs on Streamlit 1.20). I am
    sure that by the time you are reading this, there are even more cool new features
    built on top of the data editor and the DataFrame! Please check out the documentation
    ([https://docs.streamlit.io/](https://docs.streamlit.io/)) for more data editor
    knowledge. Now on to the summary!
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 截至本书编写时，数据编辑器是一个非常新的功能（它是在Streamlit 1.19版本中发布的，而本书使用的是Streamlit 1.20版本）。我相信在你阅读这本书时，基于数据编辑器和数据框（DataFrame）会有更多酷炫的新功能！请查看文档([https://docs.streamlit.io/](https://docs.streamlit.io/))以获取更多数据编辑器的相关知识。现在，让我们进入总结部分！
- en: Summary
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This concludes our adventures with the SF Trees dataset and learning about the
    various ways to make our Streamlit apps more aesthetically pleasing. We covered
    separating our apps into columns and page configuration, along with gathering
    user input in the sidebar, getting specific colors in user input through the `st.color_picker()`
    feature, and finally learning how to use Streamlit multi-page apps and the new
    data editor.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这段历程结束了，我们探索了SF树木数据集，并了解了使Streamlit应用更具美感的各种方式。我们涵盖了如何将应用拆分成列和页面配置，如何在侧边栏收集用户输入，如何通过`st.color_picker()`功能获取用户输入的特定颜色，最后学习了如何使用Streamlit的多页面应用和新的数据编辑器。
- en: In the next chapter, we will learn about the open source community around Streamlit
    by understanding how to download and use Streamlit Components built by users.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过了解如何下载和使用用户构建的Streamlit组件，来学习关于Streamlit的开源社区。
- en: Learn more on Discord
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Discord上了解更多
- en: 'To join the Discord community for this book – where you can share feedback,
    ask questions to the author, and learn about new releases – follow the QR code
    below:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 要加入本书的Discord社区——在这里你可以分享反馈、向作者提问并了解新版本——请扫描下面的二维码：
- en: '[https://packt.link/sl](https://packt.link/sl)'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/sl](https://packt.link/sl)'
- en: '![](img/QR_Code13440134443835796.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code13440134443835796.png)'
