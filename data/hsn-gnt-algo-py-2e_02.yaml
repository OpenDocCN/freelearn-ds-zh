- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: An Introduction to Genetic Algorithms
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 遗传算法简介
- en: Drawing its inspiration from Charles Darwin’s theory of natural evolution, one
    of the most fascinating techniques for problem-solving is the algorithm family
    suitably named evolutionary computation. Within this family, the most prominent
    and widely used branch is known as genetic algorithms. This chapter is the beginning
    of your journey to mastering this extremely powerful, yet extremely simple, technique.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 从查尔斯·达尔文的自然进化理论中汲取灵感，解决问题的最具魅力的技术之一就是被恰当地命名为进化计算的算法家族。在这个家族中，最突出且广泛应用的分支被称为遗传算法。本章将是你掌握这一既极其强大又极其简单的技术的起点。
- en: In this chapter, we will introduce genetic algorithms and their analogy to Darwinian
    evolution before diving into their basic principles of operation and their underlying
    theory. We will then go over the differences between genetic algorithms and traditional
    ones and cover the advantages and limitations of genetic algorithms and their
    uses. We will conclude by reviewing cases where the use of a genetic algorithm
    may prove beneficial.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍遗传算法及其与达尔文进化的类比，然后深入探讨其基本操作原理和基础理论。接着，我们将讲解遗传算法与传统算法的区别，并讨论遗传算法的优缺点及其应用。最后，我们将回顾使用遗传算法可能带来益处的案例。
- en: 'In this introductory chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章节的介绍中，我们将涵盖以下主题：
- en: What are genetic algorithms?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是遗传算法？
- en: The theory behind genetic algorithms
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遗传算法背后的理论
- en: Differences between genetic algorithms and traditional algorithms
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遗传算法与传统算法的区别
- en: Advantages and limitations of genetic algorithms
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遗传算法的优点和局限性
- en: When to use genetic algorithms
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 何时使用遗传算法
- en: What are genetic algorithms?
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是遗传算法？
- en: Genetic algorithms are a family of search algorithms that are inspired by the
    principles of evolution in nature. By imitating the process of natural selection
    and reproduction, genetic algorithms can produce high-quality solutions for various
    problems involving search, optimization, and learning. At the same time, their
    analogy to natural evolution allows genetic algorithms to overcome some of the
    hurdles that are encountered by traditional search and optimization algorithms,
    especially for problems with a large number of parameters and complex mathematical
    representations.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 遗传算法是一类受自然进化原理启发的搜索算法。通过模仿自然选择和繁殖的过程，遗传算法能够为各种涉及搜索、优化和学习的问题提供高质量的解决方案。同时，遗传算法与自然进化的类比使其能够克服传统搜索和优化算法所面临的一些障碍，特别是对于具有大量参数和复杂数学表示的问题。
- en: In the rest of this section, we will review the basic ideas of genetic algorithms,
    as well as their analogy to the evolutionary processes transpiring in nature.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的其余部分，我们将回顾遗传算法的基本思想，以及它们与自然界中发生的进化过程的类比。
- en: Darwinian evolution
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 达尔文进化
- en: 'Genetic algorithms implement a simplified version of the Darwinian evolution
    that takes place in nature. The principles of the Darwinian evolution theory can
    be summarized using the following principles:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 遗传算法实现了自然界中达尔文进化的简化版本。达尔文进化理论的原理可以通过以下原则来概括：
- en: '**The principle of variation**: The traits (attributes) of individual specimens
    belonging to a population may vary. As a result, the specimens differ from each
    other to some degree, for example, in their behavior or appearance.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**变异原理**：属于同一群体的个体的特征（属性）可能会有所不同。因此，个体之间在某种程度上有所差异，例如在行为或外观上。'
- en: '**The principle of inheritance**: Some traits are consistently passed on from
    specimens to their offspring. As a result, offspring resemble their parents more
    than they resemble unrelated specimens.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**遗传原理**：某些特征会持续从个体传递给其后代。因此，后代更像其父母，而不像无关的个体。'
- en: '**The principle of selection**: Populations typically struggle for resources
    within their given environment. The specimens possessing traits that are better
    adapted to the environment will be more successful at surviving and will also
    contribute more offspring to the next generation.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选择原理**：群体通常会在其所处环境中争夺资源。那些具有更好适应环境特征的个体，将更有可能存活，并且会为下一代贡献更多的后代。'
- en: In other words, evolution maintains a population of individual specimens that
    vary from each other. Those who are better adapted to their environment have a
    greater chance of surviving, breeding, and passing their traits to the next generation.
    This way, as generations go by, species become more adapted to their environment
    and the challenges presented to them.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，进化保持了一个个体样本群体，这些个体彼此之间存在差异。那些更适应环境的个体有更大的生存、繁殖并将其特征传递给下一代的机会。通过这种方式，随着代际的更替，物种会越来越适应其环境以及面临的挑战。
- en: An important enabler of evolution is crossover or recombination – where offspring
    are created with a mix of their parents’ traits. Crossover helps in maintaining
    the diversity of the population and in bringing together better traits over time.
    In addition, mutations – random variations in traits – can play a role in evolution
    by introducing changes that can result in a leap forward every once in a while.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 进化的一个重要推动因素是交叉或重组——通过将父母特征混合来创造后代。交叉有助于维持群体的多样性，并随着时间的推移将更好的特征结合在一起。此外，突变——特征上的随机变化——通过引入变化，偶尔也能在进化中起到推动作用，从而实现跃进。
- en: The genetic algorithms analogy
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基因算法类比
- en: Genetic algorithms seek to find the optimal solution for a given problem, whereas
    Darwinian evolution maintains a population of individual specimens. Genetic algorithms
    maintain a population of candidate solutions, called **individuals**, for that
    given problem. These candidate solutions are evaluated iteratively and used to
    create a new generation of solutions. Those who are better at solving this problem
    have a greater chance of being selected and passing their qualities to the next
    generation of candidate solutions. This way, as generations go by, candidate solutions
    get better at solving the problem at hand.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 基因算法旨在为给定的问题寻找最优解，而达尔文进化则保持一个个体样本群体。基因算法保持一个候选解群体，称为**个体**，用于给定的问题。这些候选解会经过反复评估，并用于创建新一代的解。那些更擅长解决这个问题的候选解有更大的机会被选中，并将它们的特质传递给下一代候选解。通过这种方式，随着代际更替，候选解在解决当前问题时会变得越来越优秀。
- en: In the following sections, we will describe the various components of genetic
    algorithms that enable this analogy for Darwinian evolution.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将描述基因算法的各个组成部分，这些组成部分使得达尔文进化类比成为可能。
- en: Genotype
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基因型
- en: 'In nature, breeding, reproduction, and mutation are facilitated via the genotype
    – a collection of genes that are grouped into chromosomes. If two specimens breed
    to create offspring, each chromosome of the offspring will carry a mix of genes
    from both parents. Mimicking this concept, in the case of genetic algorithms,
    each individual is represented by a chromosome representing a collection of genes.
    For example, a chromosome can be expressed as a binary string, where each bit
    represents a single gene:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在自然界中，繁殖、交配和突变是通过基因型来实现的——基因型是由一组基因组成的染色体集合。如果两个个体交配并产生后代，每个后代的染色体都会携带来自两个父母的基因混合。模仿这一概念，在基因算法中，每个个体由一个染色体表示，染色体代表一组基因。例如，染色体可以表示为一个二进制字符串，其中每个比特代表一个基因：
- en: '![Figure 1.1: Simple binary-coded chromosome](img/B20851_01_1.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.1：简单的二进制编码染色体](img/B20851_01_1.jpg)'
- en: 'Figure 1.1: Simple binary-coded chromosome'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1：简单的二进制编码染色体
- en: '*Figure 1**.1* shows an example of one such binary-coded chromosome, representing
    one particular individual.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1.1* 展示了一个这样的二进制编码染色体的例子，表示一个特定个体。'
- en: Population
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 群体
- en: 'At any point in time, genetic algorithms maintain a population of individuals
    – a collection of candidate solutions for the problem at hand. Since each individual
    is represented by some chromosome, this population of individuals can be seen
    as a collection of such chromosomes:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何时刻，基因算法都会保持一个个体群体——即一组当前问题的候选解。由于每个个体由某种染色体表示，因此这些个体的群体可以看作是这些染色体的集合：
- en: '![Figure 1.2: The population of individuals represented by binary-coded chromosomes](img/B20851_01_2.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.2：由二进制编码染色体表示的个体群体](img/B20851_01_2.jpg)'
- en: 'Figure 1.2: The population of individuals represented by binary-coded chromosomes'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.2：由二进制编码染色体表示的个体群体
- en: The population continually represents the current generation and evolves when
    the current generation is replaced by a new one.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 该群体持续代表当前的世代，并在当前世代被新一代替换时发生进化。
- en: Fitness function
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 适应度函数
- en: At each iteration of the algorithm, the individuals are evaluated using a fitness
    function (also called the target function). This is the function we seek to optimize
    or the problem we are attempting to solve.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在算法的每次迭代中，使用适应度函数（也称为目标函数）来评估个体。这是我们要优化的函数或我们尝试解决的问题。
- en: Individuals who achieve a better fitness score represent better solutions and
    are more likely to be chosen to reproduce and be represented in the next generation.
    Over time, the quality of the solutions improves, the fitness values increase,
    and the process can stop once a solution is found with a satisfactory fitness
    value.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 达到更高适应度得分的个体代表更好的解决方案，更有可能被选择进行繁殖，并在下一代中得到体现。随着时间的推移，解决方案的质量提高，适应度值增加，一旦找到满意的适应度值，过程就可以停止。
- en: Selection
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选择
- en: After calculating the fitness of every individual in the population, a selection
    process is used to determine which of the individuals in the population will get
    to reproduce and create the offspring that will form the next generation.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算每个个体的适应度后，使用选择过程来确定种群中的哪些个体将进行繁殖，并产生下一代的后代。
- en: This selection process is based on the fitness score of the individuals. Those
    with higher score values are more likely to be chosen and pass their genetic material
    to the next generation.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这个选择过程是基于个体的适应度得分。得分较高的个体更有可能被选择，并将其遗传物质传递给下一代。
- en: Individuals with low fitness values can still be chosen but with a lower probability.
    This way, their genetic material is not completely excluded, maintaining genetic
    diversity.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 适应度较低的个体仍然可以被选择，但概率较低。通过这种方式，它们的遗传物质不会完全被排除，从而保持遗传多样性。
- en: Crossover
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 交叉
- en: 'To create a pair of new individuals, two parents are usually chosen from the
    current generation, and parts of their chromosomes are interchanged (crossed over)
    to create two new chromosomes representing the offspring. This operation is called
    crossover or recombination:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创造一对新个体，通常从当前一代中选择两个父母，并交换它们染色体的一部分（交叉），以产生两条新的染色体，代表后代。这个操作称为交叉或重组：
- en: '![Figure 1.3: Crossover operation between two binary-coded chromosomes. ](img/B20851_01_3.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.3：两个二进制编码染色体之间的交叉操作](img/B20851_01_3.jpg)'
- en: 'Figure 1.3: Crossover operation between two binary-coded chromosomes.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.3：两个二进制编码染色体之间的交叉操作
- en: 'Source: [https://commons.wikimedia.org/wiki/File:Computational.science.Genetic.algorithm.Crossover.One.Point.svg](https://commons.wikimedia.org/wiki/File:Computational.science.Genetic.algorithm.Crossover.One.Point.svg).'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 来源：[https://commons.wikimedia.org/wiki/File:Computational.science.Genetic.algorithm.Crossover.One.Point.svg](https://commons.wikimedia.org/wiki/File:Computational.science.Genetic.algorithm.Crossover.One.Point.svg)
- en: Image by Yearofthedragon
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图片来源：Yearofthedragon
- en: '*Figure 1**.3* illustrates a simple crossover operation of creating two offspring
    from two parents.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1**.3* 展示了一个简单的交叉操作，通过两个父母创造两个后代。'
- en: Mutation
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 变异
- en: The purpose of the mutation operator is to refresh the population, introduce
    new patterns into the chromosomes, and encourage search in uncharted areas of
    the solution space periodically and randomly.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 变异算子的目的是刷新种群，将新的模式引入染色体中，并定期和随机地鼓励在解决方案空间的未知区域进行搜索。
- en: 'A mutation may manifest itself as a random change in a gene. Mutations are
    implemented as random changes to one or more of the chromosome values; for example,
    flipping a bit in a binary string:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 变异可能表现为基因的随机变化。变异是通过对染色体值中的一个或多个进行随机更改来实现的；例如，在二进制串中翻转一个比特：
- en: '![Figure 1.4: Mutation operator applied to a binary-coded chromosome](img/B20851_01_4.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.4：应用于二进制编码染色体的变异算子](img/B20851_01_4.jpg)'
- en: 'Figure 1.4: Mutation operator applied to a binary-coded chromosome'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.4：应用于二进制编码染色体的变异算子
- en: '*Figure 1**.4* shows an example of the mutation operation.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1**.4* 显示了变异操作的示例。'
- en: Now, let’s look at the theory behind genetic algorithms.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看遗传算法背后的理论。
- en: The theory behind genetic algorithms
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 遗传算法背后的理论
- en: The building-block hypothesis underlying genetic algorithms is that the optimal
    solution to the problem at hand is assembled of small building blocks, and as
    we bring more of these building blocks together, we get closer to this optimal
    solution.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 遗传算法的基础假设是，当前问题的最优解由小的构建块组成，随着我们将更多的构建块组合在一起，我们会越来越接近这个最优解。
- en: Individuals in the population who contain some of the desired building blocks
    are identified by their superior scores. The repeated operations of selection
    and crossover result in better individuals conveying these building blocks to
    the next generations, while possibly combining them with other successful building
    blocks. This creates genetic pressure, thus guiding the population toward having
    more and more individuals with the building blocks that form the optimal solution.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 种群中的个体，通过其优越的得分，识别出包含部分期望基因片段的个体。反复进行选择和交叉操作，使得优良个体将这些基因片段传递给下一代，同时可能与其他成功的基因片段组合。这种过程形成遗传压力，引导种群朝向拥有更多期望基因片段的方向，最终形成最优解。
- en: As a result, each generation is better than the previous one and contains more
    individuals that are closer to the optimal solution.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，每一代都会比上一代更好，包含更多接近最优解的个体。
- en: 'For example, consider a population of four-digit binary strings where our goal
    is to find the string with the highest sum of digits. This is known as the **OneMax**
    problem and will be discussed in more detail later in this book. In this scenario,
    the digit 1 appearing at any of the four possible digit positions will be a good
    building block. As the algorithm progresses, it will identify solutions that have
    these building blocks and bring them together. Each generation will have more
    individuals with 1 value in various positions, ultimately leading to the string
    1111, which incorporates all the desired building blocks. This process is illustrated
    in the following figure:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一个四位二进制字符串的种群，其中我们的目标是找到和数字之和最高的字符串。这被称为**OneMax**问题，并将在本书后面详细讨论。在这种情况下，出现在四个可能数字位置的1是一个很好的基因片段。随着算法的推进，它会识别出含有这些基因片段的解并将它们组合在一起。每一代会有更多个体在不同位置包含1值，最终产生包含所有期望基因片段的字符串1111。该过程如下图所示：
- en: '![Figure 1.5: Demonstration of a crossover operation bringing the building
    blocks of the optimal solution together](img/B20851_01_5.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图1.5：交叉操作展示了如何将最优解的基因片段结合在一起](img/B20851_01_5.jpg)'
- en: 'Figure 1.5: Demonstration of a crossover operation bringing the building blocks
    of the optimal solution together'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.5：交叉操作展示了如何将最优解的基因片段结合在一起
- en: '*Figure 1**.5* demonstrates how two individuals that are good solutions for
    this problem (each has three 1 values) create an offspring that is the best possible
    solution (four 1 bits – that is, the offspring on the right-hand side) when the
    crossover operation brings the desired building blocks of both parents together.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*图1.5* 展示了两个对于该问题来说是优秀解的个体（每个个体有三个1值）如何通过交叉操作，结合父母双方的期望基因片段，从而产生最佳解（四个1位，也就是右边的后代）。'
- en: The schema theorem
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 该模式定理
- en: A more formal expression of the building-block hypothesis is **Holland’s schema
    theorem**, also called the **fundamental theorem of** **genetic algorithms**.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 构建块假设的更正式表达是**霍兰德的模式定理**，也叫做**遗传算法的基本定理**。
- en: This theorem refers to schemata (the plural of schema), which are patterns (or
    templates) that can be found within chromosomes. Each schema represents a subset
    of chromosomes that have a certain similarity among them.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 该定理涉及到模式（模式的复数形式），它们是可以在染色体中找到的模式（或模板）。每个模式表示一组染色体，它们在某些方面具有相似性。
- en: For example, if binary strings of length four represent the set of chromosomes,
    the schema *1*01* represents all those chromosomes that have a 1 in the leftmost
    position, 01 in the rightmost two positions, and either a 1 or a 0 in the second
    from the left position, since the * represents a **wildcard** value.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果四位二进制字符串表示染色体集合，那么模式*1*01*表示所有那些在最左端位置有1、在最右端两个位置有01、以及在从左数第二的位置可能有1或0的染色体，因为*表示**通配符**值。
- en: 'For each schema, we can assign two measurements:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个模式，我们可以分配两个测量值：
- en: '**Order**: The number of digits that are fixed (not wildcards)'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**阶数**：固定数字的数量（非通配符）'
- en: '**Defining length**: The distance between the two furthermost fixed digits'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**定义长度**：两个最远固定数字之间的距离'
- en: 'The following table provides several examples of four-digit binary schemata
    and their measurements:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格提供了几个四位二进制模式及其测量值的示例：
- en: '| **Schema** | **Order** | **Defining Length** |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| **模式** | **阶数** | **定义长度** |'
- en: '| 1101 | 4 | 3 |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| 1101 | 4 | 3 |'
- en: '| 1*01 | 3 | 3 |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| 1*01 | 3 | 3 |'
- en: '| *101 | 3 | 2 |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| *101 | 3 | 2 |'
- en: '| *1*1 | 2 | 2 |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| *1*1 | 2 | 2 |'
- en: '| **01 | 2 | 1 |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| **01 | 2 | 1 |'
- en: '| 1*** | 1 | 0 |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| 1*** | 1 | 0 |'
- en: '| **** | 0 | 0 |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| **** | 0 | 0 |'
- en: 'Table 1.1: Examples of four-digit binary schemata and their corresponding measurements'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 表1.1：四位二进制模式及其对应的度量示例
- en: Each chromosome in the population corresponds to multiple schemata in the same
    way that a given string matches regular expressions. Chromosome 1101, for example,
    corresponds to every schemata that appears in this table since it matches each
    of the patterns they represent. If this chromosome has a higher score, it is more
    likely to survive the selection operation, along with all the schemata it represents.
    As this chromosome gets crossed over with another, or as it gets mutated, some
    of the schemata will survive and others will disappear. The schemata of low order
    and short defining length are the ones more likely to survive.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 种群中的每个染色体都对应着多个模式，就像给定的字符串与正则表达式匹配一样。例如，染色体1101对应于该表中所有出现的模式，因为它与这些模式所代表的每一个模式都匹配。如果该染色体的得分较高，它更有可能在选择操作中存活下来，并且所有它代表的模式也会一起存活。当该染色体与另一个染色体交叉，或发生变异时，一些模式会存活下来，而其他模式则会消失。低阶和短定义长度的模式更有可能存活。
- en: Consequentially, the schema theorem states that the frequency of schemata of
    low order, short defining length, and above-average fitness increases exponentially
    in frequency in successive generations. In other words, the smaller, simpler building
    blocks that represent the attributes that make a solution better will become increasingly
    present in the population as the genetic algorithm progresses. We will look at
    the difference between genetic and traditional algorithms in the next section.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，模式定理指出，低阶、短定义长度和优于平均适应度的模式的频率会在后代中呈指数增长。换句话说，代表使得解更好的小而简单的构建块将在遗传算法的进程中越来越频繁地出现在种群中。我们将在下一节讨论遗传算法和传统算法之间的区别。
- en: Differences from traditional algorithms
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与传统算法的区别
- en: There are several important differences between genetic algorithms and traditional
    search and optimization algorithms, such as gradient-based algorithms.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 遗传算法与传统的搜索和优化算法（如基于梯度的算法）之间有几个重要的区别。
- en: 'The key distinguishing factors are as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 关键的区分因素如下：
- en: Maintaining a population of solutions
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维持一个解的种群
- en: Using a genetic representation of the solutions
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用解的遗传表示
- en: Utilizing the outcome of a fitness function
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用适应度函数的结果
- en: Exhibiting a probabilistic behavior
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展现出概率行为
- en: We will describe these factors in greater detail in the following sections.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在以下章节中更详细地描述这些因素。
- en: Population-based
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于种群
- en: The genetic search is conducted over a population of candidate solutions (individuals)
    rather than a single candidate. At any point in the search, the algorithm retains
    a set of individuals that form the current generation. Each iteration of the genetic
    algorithm creates the next generation of individuals.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 遗传搜索是在候选解的种群（个体）上进行的，而不是单一候选解。在搜索的任何时刻，算法会保留一组个体，形成当前的世代。遗传算法的每次迭代都会创造出下一个世代的个体。
- en: In contrast, most other search algorithms maintain a single solution and iteratively
    modify it in search of the best solution. The gradient descent algorithm, for
    example, iteratively moves the current solution in the direction of the steepest
    descent, which is defined by the negative of the given function’s gradient.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，大多数其他搜索算法保持一个单一解，并通过迭代修改该解来寻找最佳解。例如，梯度下降算法通过在最陡下降方向上迭代地移动当前解来优化解，该方向由给定函数的梯度的负值定义。
- en: Genetic representation
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 遗传表示
- en: Instead of operating directly on candidate solutions, genetic algorithms operate
    on their representations (or coding), often referred to as **chromosomes**. An
    example of a simple chromosome is a fixed-length binary string.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 遗传算法不是直接作用于候选解，而是作用于它们的表示（或编码），通常称为**染色体**。一个简单染色体的例子是一个固定长度的二进制字符串。
- en: These chromosomes allow us to facilitate the genetic operations of crossover
    and mutation. Crossover is implemented by interchanging chromosome parts between
    two parents, while mutation is implemented by modifying parts of the chromosome.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这些染色体使我们能够进行交叉和变异的遗传操作。交叉通过交换两个父本的染色体部分来实现，而变异则通过修改染色体的部分来实现。
- en: A side effect of the use of genetic representation is decoupling the search
    from the original problem domain. Genetic algorithms are not aware of what the
    chromosomes represent and do not attempt to interpret them.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 使用遗传表示法的一个副作用是将搜索与原始问题域解耦。遗传算法并不关心染色体代表的内容，也不会试图解释它们。
- en: Fitness function
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 适应度函数
- en: The fitness function represents the problem we would like to solve. The objective
    of genetic algorithms is to find the individuals that yield the highest score
    when this function is calculated for them.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 适应度函数表示我们希望解决的问题。遗传算法的目标是找到在该函数计算后获得最高分的个体。
- en: Unlike many of the traditional search algorithms, genetic algorithms only consider
    the value that’s obtained by the fitness function and do not rely on derivatives
    or any other information. This makes them suitable for handling functions that
    are hard or impossible to mathematically differentiate.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多传统搜索算法不同，遗传算法只考虑通过适应度函数得到的值，而不依赖于导数或任何其他信息。这使得它们适合处理那些难以或无法数学上求导的函数。
- en: Probabilistic behavior
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概率行为
- en: While many of the traditional algorithms are deterministic, the rules that are
    used by genetic algorithms to advance from one generation to the next are probabilistic.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然许多传统算法是确定性的，但遗传算法通过的规则是概率性的，即从一代到下一代的进化过程是基于概率的。
- en: For example, when selecting the individuals that will be used to create the
    next generation, the probability of selecting a given individual increases with
    the individual’s fitness, but there is still a random element in making that choice.
    Individuals with low score values can still be chosen as well, although with a
    lower probability.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在选择用于创建下一代的个体时，选择某个个体的概率会随着该个体适应度的提高而增加，但在选择过程中仍然存在随机元素。适应度较低的个体也可能被选择，但概率较低。
- en: The mutation is probability-driven as well, usually occurs with low likelihood,
    and makes changes at one or more random location(s) in the chromosome.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 突变也具有概率驱动特性，通常以较低的概率发生，并在染色体的一个或多个随机位置进行改变。
- en: The crossover operator can also have a probabilistic element. In some variations
    of genetic algorithms, the crossover will only occur at a certain probability.
    If no crossover takes place, both parents are duplicated into the next generation
    without change.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 交叉算子也可以包含一个概率元素。在某些遗传算法的变种中，交叉只会在一定的概率下发生。如果没有发生交叉，两个父代将直接复制到下一代，保持不变。
- en: Despite the probabilistic nature of this process, the genetic-algorithm-based
    search is not random; instead, it uses the random aspect to direct the search
    toward areas in the search space where there is a better chance to improve the
    results. Now, let’s look at the advantages of genetic algorithms.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这一过程具有概率性，但基于遗传算法的搜索并非完全随机；相反，它利用随机元素将搜索引导至搜索空间中更有可能改进结果的区域。现在，让我们看看遗传算法的优势。
- en: Advantages of genetic algorithms
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 遗传算法的优势
- en: The unique characteristics of genetic algorithms that we discussed in the previous
    sections provide several advantages over traditional search algorithms.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前面讨论的遗传算法独特特性提供了相对于传统搜索算法的几个优势。
- en: 'The main advantages of genetic algorithms are as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 遗传算法的主要优势如下：
- en: Global optimization capability
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全局优化能力
- en: Can handle problems with a complex mathematical representation
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能处理具有复杂数学表示的问题
- en: Can handle problems that lack mathematical representation
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能处理缺乏数学表示的问题
- en: Resilience to noise
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对噪声的韧性
- en: Support for parallelism and distributed processing
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持并行处理和分布式处理
- en: Suitable for continuous learning
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适合持续学习
- en: We will cover each of these in the upcoming sections.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的章节中讨论这些内容。
- en: Global optimization
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 全局优化
- en: In many cases, optimization problems have local maxima and minima points; these
    represent solutions that are better than those around them, but not the best overall.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，优化问题存在局部最大值和最小值点；这些点代表比周围更好的解，但并非整体最优。
- en: 'The following figure illustrates the differences between global and local maximum
    and minimum points:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示说明了全局最大值和最小值与局部最大值和最小值的区别：
- en: '![Figure 1.6: The global and local maxima and minima of a function. ](img/B20851_01_6.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图1.6：函数的全局和局部最大值与最小值。](img/B20851_01_6.jpg)'
- en: 'Figure 1.6: The global and local maxima and minima of a function.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.6：函数的全局和局部最大值与最小值。
- en: 'Source: [https://commons.wikimedia.org/wiki/File:Computational.science.Genetic.algorithm.Crossover.One.Point.svg](https://commons.wikimedia.org/wiki/File:Computational.science.Genetic.algorithm.Crossover.One.Point.svg).'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 来源：[https://commons.wikimedia.org/wiki/File:Computational.science.Genetic.algorithm.Crossover.One.Point.svg](https://commons.wikimedia.org/wiki/File:Computational.science.Genetic.algorithm.Crossover.One.Point.svg)
- en: Image by KSmrq
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图片由KSmrq提供
- en: Most traditional search and optimization algorithms, and particularly those
    that are gradient-based, are prone to getting stuck in a local maximum rather
    than finding the global one. This is because, in the vicinity of a local maximum,
    any small change will degrade the score.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数传统的搜索和优化算法，尤其是基于梯度的算法，容易陷入局部最大值，而不是找到全局最大值。这是因为在局部最大值附近，任何小的变化都会导致评分下降。
- en: Genetic algorithms, on the other hand, are less sensitive to this phenomenon
    and are more likely to find the global maximum. This is due to the use of a population
    of candidate solutions rather than a single one, and the crossover and mutation
    operations that will, in many cases, result in candidate solutions that are distant
    from the previous ones. This is true so long as we manage to maintain the diversity
    of the population and avoid **premature convergence**, as we will mention in the
    next section.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，遗传算法对这种现象不太敏感，更容易找到全局最大值。这是因为遗传算法使用的是一组候选解，而不是单一解，并且交叉和变异操作通常会导致候选解与之前的解相距较远。只要我们能保持种群的多样性，避免**过早收敛**，正如我们将在下一节中提到的那样，这种情况就成立。
- en: Handling complex problems
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理复杂问题
- en: Since genetic algorithms only require the outcome of the fitness function for
    each individual and are not concerned with other aspects of the fitness function,
    such as derivatives, they can be used for problems with complex mathematical representations
    or functions that are hard or impossible to differentiate.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 由于遗传算法只需要每个个体的适应度函数结果，并且不关心适应度函数的其他方面（例如导数），它们可以用于具有复杂数学表示的问题，或者用于那些难以或无法求导的函数。
- en: Other complex cases where genetic algorithms excel include problems with a large
    number of parameters and problems with a mix of parameter types – for example,
    a combination of continuous and discrete parameters.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 遗传算法在其他复杂案例中表现出色，包括具有大量参数的问题和混合参数类型的问题——例如，连续参数和离散参数的组合。
- en: Handling a lack of mathematical representation
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理缺乏数学表示的问题
- en: Genetic algorithms can be used for problems that lack mathematical representation
    altogether. One such case of particular interest is when the fitness score is
    based on human opinion. Imagine, for example, that we want to find the most attractive
    color palette to be used on a website. We can try different color combinations
    and ask users to rate the attractiveness of the site. We can apply genetic algorithms
    to search for the best scoring combination while using this opinion-based score
    as the fitness function’s outcome. The genetic algorithm will operate as usual,
    even though the fitness function lacks any mathematical representation and there
    is no way to calculate the score directly from a given color combination.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 遗传算法可以用于完全缺乏数学表示的问题。一个特别值得关注的情况是，当适应度评分基于人类意见时。例如，假设我们希望找到一个最具吸引力的色彩调色板来应用于网站。我们可以尝试不同的颜色组合，并要求用户评价网站的吸引力。我们可以应用遗传算法来搜索得分最高的组合，同时使用这种基于意见的评分作为适应度函数的输出。即使适应度函数缺乏数学表示，并且无法直接从给定的颜色组合中计算得分，遗传算法仍然可以正常工作。
- en: As we will see in the next chapter, genetic algorithms can even deal with cases
    where the score of each individual cannot be obtained, so long as we have a way
    to compare two individuals and determine which of them is better. An example of
    this is a machine learning algorithm that drives a car in a simulated race. A
    genetic-algorithm-based search can optimize and tune the machine learning algorithm
    by having different versions of it compete against each other to determine which
    version is better.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将在下一章中看到的那样，遗传算法甚至可以处理每个个体的得分无法获得的情况，只要我们有办法比较两个个体并确定哪一个更好。一个例子是，基于机器学习算法的模拟赛车驾驶。基于遗传算法的搜索可以通过让不同版本的算法相互竞争，来优化和调优该机器学习算法，以确定哪个版本更好。
- en: Resilience to noise
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对噪声的鲁棒性
- en: Some problems present noisy behavior. This means that, even for similar input
    parameter values, the output value may be somewhat different every time it’s measured.
    This can happen, for example, when the data that’s being used is being read from
    sensor outputs, or in cases where the score is based on human opinion, as was
    discussed in the previous section.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 一些问题表现出噪声行为。这意味着，即使是相似的输入参数值，每次测量时输出值可能会有所不同。例如，当使用的数据来自传感器输出，或者在分数基于人类意见的情况下（如前一节所讨论的）就会发生这种情况。
- en: While this kind of behavior can throw off many traditional search algorithms,
    genetic algorithms are generally resilient to it thanks to the repetitive operation
    of reassembling and reevaluating the individuals.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种行为可能会扰乱许多传统的搜索算法，但由于遗传算法在重新组装和重新评估个体时的重复操作，它通常对这种情况具有较强的抵抗力。
- en: Parallelism
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并行性
- en: Genetic algorithms lend themselves well to parallelization and distributed processing.
    Fitness is calculated independently for each individual, which means all the individuals
    in the population can be evaluated concurrently.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 遗传算法非常适合并行化和分布式处理。适应度是针对每个个体独立计算的，这意味着种群中的所有个体都可以同时进行评估。
- en: In addition, the operations of selection, crossover, and mutation can each be
    performed concurrently on individuals and pairs of individuals in the population.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，选择、交叉和变异操作可以在种群中的个体和个体对上并行执行。
- en: This makes genetic algorithms natural candidates for distributed as well as
    cloud-based implementation.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得遗传算法成为分布式和云端实现的天然候选者。
- en: Continuous learning
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 持续学习
- en: In nature, evolution never stops. As the environmental conditions change, the
    population will adapt to them. Similarly, genetic algorithms can operate continuously
    in an ever-changing environment, and at any point in time, the best current solution
    can be fetched and used.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在自然界中，进化永不停息。随着环境条件的变化，种群会相应适应这些变化。同样，遗传算法可以在不断变化的环境中持续运行，并且在任何时刻，都可以获取并使用当前最优解。
- en: For this to be effective, the changes in the environment need to be slow concerning
    the generation turnaround rate of the genetic-algorithm-based search. Now that
    we’ve covered the advantages of genetic algorithms, let’s look at the limitations.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使其有效，环境的变化相较于遗传算法搜索的代际周转速率应该是缓慢的。现在我们已经讨论了遗传算法的优势，接下来让我们看看它的局限性。
- en: Limitations of genetic algorithms
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 遗传算法的局限性
- en: To get the most out of genetic algorithms, we need to be aware of their limitations
    and potential pitfalls.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 为了最大限度地发挥遗传算法的作用，我们需要了解它们的局限性和潜在的陷阱。
- en: 'The limitations of genetic algorithms are as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 遗传算法的局限性如下：
- en: The need for special definitions
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对特殊定义的需求
- en: The need for hyperparameter tuning
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要超参数调优
- en: Computationally intensive operations
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算密集型操作
- en: The risk of premature convergence
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提前收敛的风险
- en: No guaranteed solution
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无法保证得到最优解
- en: We will cover each of these in the upcoming sections.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的章节中逐一讨论这些问题。
- en: Special definitions
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特殊定义
- en: When applying genetic algorithms to a given problem, we need to create a suitable
    representation for them – define the fitness function and the chromosome structure,
    as well as the selection, crossover, and mutation operators that will work for
    this problem. This can often prove to be challenging and time-consuming.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在将遗传算法应用于特定问题时，我们需要为其创建一个合适的表示——定义适应度函数和染色体结构，并为该问题设计合适的选择、交叉和变异操作符。这往往是一项既具有挑战性又费时的任务。
- en: Luckily, genetic algorithms have already been applied to countless different
    types of problems, and many of these definitions have been standardized. This
    book covers numerous types of real-life problems and the way they can be solved
    using genetic algorithms. Use this as guidance whenever you are challenged by
    a new problem.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，遗传算法已经应用于无数种不同类型的问题，许多定义已经标准化。本书涵盖了许多现实生活中的问题及其如何通过遗传算法解决。遇到新问题时，可以参考这些内容作为指导。
- en: Hyperparameter tuning
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 超参数调优
- en: The behavior of genetic algorithms is controlled by a set of hyperparameters,
    such as the population size and mutation rate. When applying genetic algorithms
    to the problem at hand, there are no exact rules for making these choices.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 遗传算法的行为由一组超参数控制，例如种群大小和变异率。在将遗传算法应用于当前问题时，并没有确切的规则来做出这些选择。
- en: However, this is the case for virtually all search and optimization algorithms.
    After going over the examples in this book and doing some experimentation of your
    own, you will be able to make sensible choices for these values.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这对于几乎所有的搜索和优化算法都是如此。在本书中的示例和你自己的实验之后，你将能够为这些值做出明智的选择。
- en: Computationally intensive
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算密集型
- en: Operating on (potentially large) populations and the repetitive nature of genetic
    algorithms can be computationally intensive, as well as time-consuming, before
    a good result is reached.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在（潜在较大）种群上操作以及遗传算法的重复性质可能会导致计算密集型和耗时，在获得良好结果之前需要较长时间。
- en: These can be alleviated with a good choice of hyperparameters, implementing
    parallel processing, and in some cases, caching the intermediate results.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题可以通过良好的超参数选择、实现并行处理，且在某些情况下通过缓存中间结果来缓解。
- en: Premature convergence
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 早熟收敛
- en: If the fitness of one individual is much higher than the rest of the population,
    it may be duplicated enough that it takes over the entire population. This can
    lead to the genetic algorithm getting prematurely stuck in a local maximum, instead
    of finding the global one.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果某个个体的适应度远高于其余种群，它可能会被复制足够多次，导致其占据整个种群。这可能会导致遗传算法过早地陷入局部最优解，而不是找到全局最优解。
- en: To prevent this from occurring, it is important to maintain the diversity of
    the population. Various ways to maintain diversity will be discussed in the next
    chapter.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止这种情况发生，保持种群的多样性非常重要。维持多样性的方法将在下一章讨论。
- en: No guaranteed solution
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 没有保证的解决方案
- en: The use of genetic algorithms does not guarantee that the global maximum for
    the problem at hand will be found.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 使用遗传算法并不能保证找到当前问题的全局最优解。
- en: However, this is almost the case for any search and optimization algorithm,
    unless it is an analytical solution for a particular type of problem.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这几乎是所有搜索和优化算法的通病，除非它是某类特定问题的解析解。
- en: Generally, genetic algorithms, when used appropriately, are known to provide
    good solutions within a reasonable amount of time. Now, let’s look at a few use
    cases for genetic algorithms.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，遗传算法在适当使用时，能够在合理的时间内提供良好的解决方案。现在，让我们来看一下遗传算法的一些应用案例。
- en: Use cases for genetic algorithms
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 遗传算法的应用案例
- en: 'Based on the material we covered in the previous sections, genetic algorithms
    are best suited for the following types of problems:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 基于我们在前面章节中涵盖的内容，遗传算法最适用于以下类型的问题：
- en: '**Problems with complex mathematical representation**: Since genetic algorithms
    only require the outcome of the fitness function, they can be used for problems
    with target functions that are hard or impossible to differentiate (such as planning
    and scheduling), problems with a large number of parameters (such as image reconstruction),
    and problems with a mix of parameter types (such as hyperparameter optimization).'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**具有复杂数学表示的问题**：由于遗传算法只需要适应度函数的结果，因此它们可以用于具有难以或不可能微分的目标函数的问题（例如规划和调度问题）、具有大量参数的问题（例如图像重建）以及具有混合参数类型的问题（例如超参数优化）。'
- en: '**Problems with no mathematical representation**: Genetic algorithms don’t
    require a mathematical representation of the problem, so long as a score value
    can be obtained, or a method is available to compare two solutions. This can be
    useful, for example, when solving reinforcement learning tasks or optimizing the
    architecture of a deep learning model.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**没有数学表示的问题**：遗传算法不需要问题的数学表示，只要能够获得评分值或提供比较两个解决方案的方法即可。这在解决强化学习任务或优化深度学习模型架构时非常有用。'
- en: '**Problems involving a noisy environment**: Genetic algorithms are resilient
    to conditions where data may not be consistent, such as information originating
    from sensor output or human-based scoring; for example, choosing the best color
    palette for a website based on customers’ feedback and usage patterns.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**涉及噪声环境的问题**：遗传算法对于数据可能不一致的情况具有较强的适应性，例如来自传感器输出或基于人工评分的信息；例如，根据客户反馈和使用模式选择网站的最佳配色方案。'
- en: '**Problems involving an environment that changes over time**: Genetic algorithms
    can respond to slow changes in the environment by continuously creating new generations
    that will adapt to these changes. Revisiting the website color palette example
    mentioned previously, the customers’ favorite colors may change over time as per
    fashion trends. On the other hand, when a problem has a known and specialized
    way of being solved, using an existing traditional or analytic method is likely
    to be a more efficient choice.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**涉及到随时间变化的环境问题**：遗传算法能够通过不断产生新一代来应对环境中的缓慢变化，从而适应这些变化。回到前面提到的网站配色方案示例，客户的偏好颜色可能会随着时尚趋势的变化而发生变化。另一方面，当一个问题有已知且专门的解决方法时，使用现有的传统或分析方法通常是更高效的选择。'
- en: With that, we’ve come to the end of this chapter.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 至此，本章结束。
- en: Summary
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we started by introducing genetic algorithms, their analogy
    to Darwinian evolution, and their basic principles of operation, including the
    use of population, genotype, the fitness function, and the genetic operators of
    selection, crossover, and mutation.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 本章首先介绍了遗传算法，它与达尔文进化论的类比以及其基本操作原理，包括使用种群、基因型、适应度函数，以及选择、交叉和变异的遗传操作符。
- en: Then, we covered the theory underlying genetic algorithms by going over the
    building-block hypothesis and the schema theorem and illustrating how genetic
    algorithms work by bringing together superior, small building blocks to create
    the best solutions.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，我们通过讲解构建模块假设和模式定理，阐述了遗传算法背后的理论，并通过将优越的小模块组合在一起，展示了遗传算法如何工作，以创造最佳的解决方案。
- en: Next, we went over the differences between genetic algorithms and traditional
    ones, such as maintaining a population of solutions and using a genetic representation
    of those solutions.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们讲解了遗传算法与传统算法的不同之处，比如保持解决方案种群和使用这些解决方案的遗传表示。
- en: We continued by covering the strengths of genetic algorithms, including their
    capacity for global optimization, handling problems with complex or non-existent
    mathematical representations, and resilience to noise, followed by their weaknesses,
    including the need for special definitions and hyperparameter tuning, as well
    as the risk of premature convergence.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接着介绍了遗传算法的优点，包括其全球优化能力、处理复杂或没有数学表示的问题的能力，以及对噪声的韧性，随后是其缺点，包括对特殊定义和超参数调整的需求，以及过早收敛的风险。
- en: We concluded by going over the cases where the use of a genetic algorithm may
    prove beneficial, such as in mathematically complex problems and optimization
    tasks in a noisy or ever-changing environment.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们总结时回顾了使用遗传算法可能带来好处的情形，例如在数学复杂的问题和噪声或不断变化的环境中的优化任务。
- en: In the next chapter, we will delve deeper into the key components and the implementation
    details of genetic algorithms in preparation for the following chapters, where
    we will use them to code solutions for various types of problems.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将深入探讨遗传算法的关键组件和实现细节，为接下来的章节做准备，在那些章节中我们将使用遗传算法来编码解决各种类型的问题。
- en: Further reading
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入阅读
- en: For more information on what we covered in this chapter, please refer to *Introduction
    to Genetic Algorithms*, from the book *Hands-On Artificial Intelligence for IoT*,
    by Amita Kapoor, January 2019, available at https:[//subscription.packtpub.com/book/big_data_and_business_intelligence/9781788836067](https://subscription.packtpub.com/book/data/9781788836067/1).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 欲了解更多关于本章内容的信息，请参考Amita Kapoor于2019年1月出版的《*Hands-On Artificial Intelligence
    for IoT*》一书中的*遗传算法入门*，该书可通过[https://subscription.packtpub.com/book/big_data_and_business_intelligence/9781788836067](https://subscription.packtpub.com/book/data/9781788836067/1)获取。
