- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Deploying a FastAPI Project
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署 FastAPI 项目
- en: 'Building a good application is great, but it’s even better if customers can
    enjoy it. In this chapter, you’ll look at different techniques and the best practices
    for deploying your FastAPI application to make it available on the web. First,
    you’ll learn how to structure your project to make it ready for deployment by
    using environment variables to set the configuration options you need, as well
    as by managing your dependencies properly with `pip`. Once that’s done, we’ll
    show you three ways to deploy your application: with a serverless cloud platform,
    with a Docker container, and with a traditional Linux server.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 构建一个优秀的应用程序很好，但如果客户能够享受它就更好了。在这一章中，你将学习如何通过使用环境变量设置所需的配置选项以及通过使用 `pip` 正确管理你的依赖项来结构化你的项目，以便为部署做好准备。一旦完成，我们将展示三种部署应用程序的方式：使用无服务器云平台、使用
    Docker 容器以及使用传统的 Linux 服务器。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将涵盖以下主要主题：
- en: Setting and using environment variables
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置和使用环境变量
- en: Managing Python dependencies
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理 Python 依赖项
- en: Deploying a FastAPI application on a serverless platform
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在无服务器平台上部署 FastAPI 应用程序
- en: Deploying a FastAPI application with Docker
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Docker 部署 FastAPI 应用程序
- en: Deploying a FastAPI application on a traditional server
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在传统服务器上部署 FastAPI 应用程序
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, you’ll require a Python virtual environment, just as we set
    up in [*Chapter 1*](B19528_01.xhtml#_idTextAnchor024), *Python Development* *Environment
    Setup*.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这一章，你需要一个 Python 虚拟环境，就像我们在[*第 1 章*](B19528_01.xhtml#_idTextAnchor024)，*Python
    开发环境设置*中设置的那样。
- en: You’ll find all the code examples for this chapter in the dedicated GitHub repository
    at https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter10.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在专门的 GitHub 代码库中找到本章的所有代码示例，地址为 https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter10。
- en: Setting and using environment variables
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置和使用环境变量
- en: 'Before deep-diving into the different deployment techniques, we need to structure
    our application to enable reliable, fast, and secure deployments. One of the key
    things in this process is handling configuration variables: a database URL, an
    external API token, a debug flag, and so on. When handling those variables, it’s
    necessary to handle them dynamically instead of hardcoding them into your source
    code. Why?'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入讨论不同的部署技术之前，我们需要结构化我们的应用程序，以实现可靠、快速和安全的部署。在这个过程中的一个关键点是处理配置变量：数据库 URL、外部
    API 令牌、调试标志等等。在处理这些变量时，需要动态处理而不是将它们硬编码到源代码中。为什么呢？
- en: First of all, those variables will likely be different in your local environment
    and in production. Typically, your database URL will point to a local database
    on your computer while developing but will point to a proper production database
    in production. This is even more pertinent if you want to have other environments
    such as a staging or pre-production environment. Furthermore, if we need to change
    one of the values, we’ll have to change the code, commit it, and deploy it again.
    Thus, we need a convenient mechanism to set those values.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这些变量在本地环境和生产环境中可能会不同。通常情况下，你的数据库 URL 在开发时可能指向本地计算机上的数据库，但在生产环境中可能会指向一个正式的生产数据库。如果你还有其他环境，比如
    staging 或预生产环境，这一点就更加重要了。此外，如果我们需要更改其中一个值，我们必须修改代码、提交并重新部署。因此，我们需要一个方便的机制来设置这些值。
- en: 'Secondly, it’s unsafe to write those values in your code. Values such as database
    connection strings or API tokens are extremely sensitive. If they appear in your
    code, they’ll likely be committed to your repository: they can be read by anyone
    who has access to your repository, which causes obvious security issues.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，在代码中写入这些值是不安全的。例如数据库连接字符串或 API 令牌等敏感信息。如果它们出现在你的代码中，它们很可能会被提交到你的代码库中：这些信息可以被任何有访问权限的人读取，这会带来明显的安全问题。
- en: 'To solve this, we usually use **environment variables**. Environment variables
    are values that aren’t set in the program itself but in the whole operating system.
    Most programming languages have the required functions to read those variables
    from the system. You can try this very easily in a Unix command line:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们通常使用**环境变量**。环境变量是程序本身没有设置的值，而是设置在整个操作系统中的值。大多数编程语言都有必要的函数来从系统中读取这些变量。你可以在
    Unix 命令行中很容易地尝试这个：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the Python source code, we can get the value dynamically from the system.
    During deployment, we’ll only have to make sure that we set the correct environment
    variables on the server. This way, we can easily change a value without redeploying
    the code and have several deployments of our application containing different
    configurations sharing the same source code. However, bear in mind that sensitive
    values that have been set in environment variables can still leak if you don’t
    pay attention – for example, in log files or error stack traces.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python源代码中，我们可以从系统中动态获取值。在部署时，我们只需要确保在服务器上设置正确的环境变量。这样，我们就可以在不重新部署代码的情况下轻松更改值，并且可以让多个不同配置的部署共享相同的源代码。然而，请注意，如果不小心，已经设置为环境变量的敏感值仍然可能会泄露——例如，在日志文件或错误堆栈跟踪中。
- en: 'To help us with this task, we’ll use a very convenient feature of Pydantic:
    settings management. This allows us to structure and use our configuration variables
    as we do for any other data model. It even takes care of automatically retrieving
    the values from environment variables!'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助我们完成这项任务，我们将使用Pydantic的一个非常方便的特性：设置管理。这样，我们就可以像使用其他数据模型一样结构化和使用我们的配置变量。它甚至会自动从环境变量中检索这些值！
- en: For the rest of this chapter, we’ll work with an application that you can find
    in `chapter10/project` within our example repository. It’s a simple FastAPI application
    that uses SQLAlchemy, very similar to the one we reviewed in the *Communicating
    with a SQL database with the SQLAlchemy ORM* section of [*Chapter 6*](B19528_06.xhtml#_idTextAnchor346),
    *Databases and* *Asynchronous ORMs*.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 本章剩余部分，我们将使用一个你可以在`chapter10/project`中找到的应用程序。它是一个简单的FastAPI应用，使用SQLAlchemy，与我们在[*第6章*](B19528_06.xhtml#_idTextAnchor346)中的*与SQL数据库的通信，使用SQLAlchemy
    ORM*部分中回顾的非常相似，*数据库和* *异步ORM*。
- en: Running the commands from the project directory
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 从项目目录运行命令
- en: If you cloned the example repository, be sure to run the commands shown in this
    chapter from the `project` directory. On the command line, simply type `cd chapter10/project`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你克隆了示例仓库，确保从`project`目录运行本章中显示的命令。在命令行中，直接输入`cd chapter10/project`。
- en: 'To structure a settings model, all you need to do is create a class that inherits
    from `pydantic.BaseSettings`. The following example shows a configuration class
    with a debug flag, an environment name, and a database URL:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要结构化一个设置模型，你只需要创建一个继承自`pydantic.BaseSettings`的类。下面的示例展示了一个包含调试标志、环境名称和数据库URL的配置类：
- en: settings.py
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: settings.py
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter10/project/project/settings.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter10/project/project/settings.py)'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter10/project/project/settings.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter10/project/project/settings.py)'
- en: As you can see, creating this class is very similar to creating a standard Pydantic
    model. We can even define default values, as we did for `debug` here.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，创建这个类与创建标准的Pydantic模型非常相似。我们甚至可以像为`debug`做的那样定义默认值。
- en: 'To use it, we only have to create an instance of this class. We can then import
    it wherever we need it in our project. For example, here is how to retrieve the
    database URL to create our SQLAlchemy engine:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用它，我们只需要创建该类的一个实例。然后，我们可以在项目中的任何地方导入它。例如，下面是如何获取数据库URL来创建我们的SQLAlchemy引擎：
- en: database.py
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: database.py
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter10/project/project/database.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter10/project/project/database.py)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter10/project/project/database.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter10/project/project/database.py)'
- en: 'We also use the `debug` flag to print all the settings in the `lifespan` event
    at startup:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用`debug`标志在启动时的`lifespan`事件中打印所有设置：
- en: app.py
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: app.py
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter10/project/project/app.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter10/project/project/app.py)'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter10/project/project/app.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter10/project/project/app.py)'
- en: 'Since our application is designed to work with SQLAlchemy, we also took care
    of initializing a database migration environment with Alembic, as we showed in
    [*Chapter 6*](B19528_06.xhtml#_idTextAnchor346), *Databases and Asynchronous ORMs*.
    The difference here is that we use our `settings` object to dynamically configure
    the database URL; instead of hardcoding it in `alembic.ini`, we can set it from
    our settings in `env.py`, as you can see here:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的应用程序是为了与 SQLAlchemy 一起使用的，我们还处理了使用 Alembic 初始化数据库迁移环境的工作，就像我们在 [*第 6 章*](B19528_06.xhtml#_idTextAnchor346)中展示的那样，*数据库与异步
    ORM*。这里的区别是，我们使用 `settings` 对象动态配置数据库 URL；我们不再在`alembic.ini`中硬编码它，而是可以从 `env.py`
    中的设置来配置它，正如你在这里看到的：
- en: env.py
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: env.py
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter10/project/alembic/env.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter10/project/alembic/env.py)'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter10/project/alembic/env.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter10/project/alembic/env.py)'
- en: Notice that we take care of manually removing the `aiosqlite` driver part of
    the URL. Indeed, as we mentioned previously, Alembic is designed to work synchronously,
    so we need to pass it a standard URL. Now, we can generate migrations from our
    development database and apply them in production without changing anything in
    our Alembic configuration!
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们手动移除了 URL 中的`aiosqlite`驱动部分。实际上，正如我们之前提到的，Alembic 被设计为同步工作，因此我们需要传递一个标准的
    URL。现在，我们可以从开发数据库生成迁移，并在生产环境中应用这些迁移，而无需更改 Alembic 配置！
- en: 'The good thing with this `Settings` model is that it works just like any other
    Pydantic model: it automatically parses the values it finds in environment variables
    and raises an error if one value is missing in your environment. This way, you
    can ensure you don’t forget any values directly when the app starts. You can test
    this behavior by running the application:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个 `Settings` 模型的好处在于，它像任何其他 Pydantic 模型一样工作：它会自动解析在环境变量中找到的值，如果某个值在环境中缺失，它会抛出错误。通过这种方式，你可以确保应用程序启动时不会遗漏任何值。你可以通过运行应用程序来测试这种行为：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We have a clear list of the missing variables. Let’s set those variables in
    our environment and try again:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经清楚列出了缺失的变量。让我们将这些变量设置到环境中，并重新尝试：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The application started! You can even see that our lifespan handler printed
    our settings values. Notice that Pydantic is case-insensitive (by default) when
    retrieving environment variables. By convention, environment variables are usually
    set in all caps on the system.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序已启动！你甚至可以看到我们的生命周期处理器打印了我们的设置值。注意，当检索环境变量时，Pydantic 默认是不区分大小写的。按照惯例，环境变量通常在系统中以大写字母设置。
- en: Using a .env file
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 .env 文件
- en: In local development, it’s a bit annoying to set environment variables by hand,
    especially if you’re working on several projects at the same time on your machine.
    To solve this, Pydantic allows you to read the values from a `.env` file. This
    file contains a simple list of environment variables and their associated values.
    It’s usually easier to edit and manipulate during development.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在本地开发中，手动设置环境变量有点麻烦，特别是当你同时在机器上处理多个项目时。为了解决这个问题，Pydantic 允许你从 `.env` 文件中读取值。该文件包含一个简单的环境变量及其关联值的列表，通常在开发过程中更容易编辑和操作。
- en: 'To make this work, we’ll need a new library, `python-dotenv`, whose task is
    to parse those `.env` files. You can install it as usual with the following command:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们需要一个新的库`python-dotenv`，它的任务是解析这些 `.env` 文件。你可以像往常一样通过以下命令安装它：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To enable this feature, notice how we added the `Config` subclass with the
    `env_file` property:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了启用这个功能，请注意我们是如何添加具有`env_file`属性的`Config`子类的：
- en: settings.py
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: settings.py
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter10/project/project/settings.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter10/project/project/settings.py)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter10/project/project/settings.py](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter10/project/project/settings.py)'
- en: By doing this, we simply tell Pydantic to look for environment variables set
    in a file named `.env`, if it’s available.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，我们只是简单地告诉 Pydantic 查找名为 `.env` 的文件中的环境变量，如果该文件存在的话。
- en: 'Finally, you can create your `.env` file at the root of the project with the
    following content:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以在项目的根目录创建你的 `.env` 文件，内容如下：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'And that’s it! The values will now be read from this `.env` file. If the file
    is missing, `Settings` will try to read them from the environment variables as
    usual. Of course, this is only for convenience while developing: this file *shouldn’t
    be committed* and you should rely on *properly set environment variables in production*.
    To ensure you don’t commit this file by accident, it’s usually recommended that
    you add it to your `.``gitignore` file.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！这些值现在将从 `.env` 文件中读取。如果文件丢失，`Settings` 将像往常一样尝试从环境变量中读取。当然，这只是为了开发时的方便：这个文件*不应该被提交*，你应该依赖于*生产环境中正确设置的环境变量*。为了确保你不会不小心提交此文件，通常建议将其添加到你的
    `.gitignore` 文件中。
- en: Creating hidden files such as .env files
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 创建像 `.env` 文件这样的隐藏文件
- en: 'In Unix systems, files starting with a dot, such as `.env`, are considered
    hidden files. If you try to create them from the operating system’s file explorer,
    it might show you warnings or even prevent you from doing so. Thus, it’s usually
    more convenient to create them from your IDE, such as Visual Studio Code, or from
    the command line by executing the following command: `touch .env`.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Unix 系统中，以点（`.`）开头的文件，如 `.env`，被视为隐藏文件。如果你尝试从操作系统的文件浏览器创建它们，可能会显示警告，甚至阻止你这么做。因此，通常更方便通过你的
    IDE（如 Visual Studio Code）或者通过命令行执行以下命令来创建它们：`touch .env`。
- en: 'Great! Our application now supports dynamic configuration variables, which
    are now easy to set and change on our deployment platforms. Another important
    thing to take care of is dependencies: we’ve installed quite a lot of them at
    this point, but we must make sure they are installed properly during deployments!'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们的应用程序现在支持动态配置变量，这些变量现在可以很容易地在部署平台上设置和更改。另一个需要注意的重要事项是依赖项：到目前为止我们已经安装了相当多的依赖项，但必须确保在部署过程中它们能被正确安装！
- en: Managing Python dependencies
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理 Python 依赖项
- en: 'Throughout this book, we’ve installed libraries using `pip` to add some useful
    features to our application: FastAPI, of course, but also SQLAlchemy, pytest,
    and so on. When deploying a project to a new environment, such as a production
    server, we have to make sure all those dependencies are installed for our application
    to work properly. This is also true if you have colleagues that also need to work
    on the project: they need to know the dependencies they must install on their
    machines.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们使用 `pip` 安装了库，以便为我们的应用程序添加一些有用的功能：当然是 FastAPI，还有 SQLAlchemy、pytest 等等。当将项目部署到新环境中时，比如生产服务器，我们必须确保所有这些依赖项已经安装，以确保应用程序能正常工作。如果你的同事也需要在项目上工作，他们也需要知道他们需要在自己的机器上安装哪些依赖项。
- en: Fortunately, `pip` comes with a solution for this so that we don’t have to remember
    all this in our heads. Indeed, most Python projects define a `requirements.txt`
    file, which contains a list of all Python dependencies. It usually lives at the
    root of your project. `pip` has a special option for reading this file and installing
    all the needed dependencies.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，`pip` 提供了一个解决方案，帮助我们不需要记住所有这些内容。事实上，大多数 Python 项目会定义一个 `requirements.txt`
    文件，其中包含所有 Python 依赖项的列表。这个文件通常位于项目的根目录。`pip` 有一个专门的选项来读取此文件并安装所有需要的依赖项。
- en: 'When you already have a working environment, such as the one we’ve used since
    the beginning of this book, people usually recommend that you run the following
    command:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当你已经有一个工作环境时，比如我们从本书开始就使用的环境，通常推荐你运行以下命令：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The result of `pip freeze` is a list of *every Python package currently installed
    in your environment*, along with their corresponding versions. This list can be
    directly used in the `requirements.txt` file.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`pip freeze` 的结果是一个*列出当前在环境中安装的每个 Python 包*，以及它们相应的版本。这个列表可以直接用在 `requirements.txt`
    文件中。'
- en: The problem with this approach is that it lists every package, including the
    sub-dependencies of the libraries you install. Said another way, in this list,
    you’ll see packages that you don’t directly use but that are needed by the ones
    you installed. If, for some reason, you decide to not use a library anymore, you’ll
    be able to remove it, but it’ll be very hard to guess which sub-dependencies it
    has installed. In the long term, your `requirements.txt` file will grow larger
    and larger, with lots of dependencies that are useless in your project.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的问题在于，它列出了每个包，包括你安装的库的子依赖。换句话说，在这个列表中，你会看到一些你并未直接使用的包，但它们是你安装的包所需要的。如果因为某些原因，你决定不再使用某个库，你是可以将其移除的，但很难猜出它安装了哪些子依赖。从长远来看，你的`requirements.txt`文件会变得越来越大，包含许多在项目中没用的依赖。
- en: To solve this, some people recommend that you *manually maintain your* `requirements.txt`
    *file*. With this approach, you have to list yourself all the libraries you use,
    along with their respective versions. During installation, `pip` will take care
    of installing the sub-dependencies, but they’ll never appear in `requirements.txt`.
    This way, when you remove one of your dependencies, you make sure any useless
    packages are not kept.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，有些人建议你*手动维护你的*`requirements.txt` *文件*。采用这种方法时，你需要自己列出所有使用的库以及它们的版本。在安装时，`pip`会负责安装子依赖，但它们不会出现在`requirements.txt`中。通过这种方式，当你删除某个依赖时，你可以确保不会保留任何不必要的包。
- en: 'In the following example, you can see the `requirements.txt` file for the project
    we are working on in this chapter:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，你可以看到我们在本章中所做项目的`requirements.txt`文件：
- en: requirements.txt
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: requirements.txt
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter10/project/requirements.txt](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter10/project/requirements.txt)'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter10/project/requirements.txt](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter10/project/requirements.txt)'
- en: As you can see, the list is much shorter! Now, whenever we install a new dependency,
    our responsibility is to add it manually to `requirements.txt`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，列表变得简短多了！现在，每当我们安装一个新依赖时，我们的责任就是手动将其添加到`requirements.txt`中。
- en: A word on alternate package managers such as Poetry, Pipenv, and Conda
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 关于替代包管理器，如 Poetry、Pipenv 和 Conda
- en: While exploring the Python community, you may hear about alternate package managers
    such as Poetry, Pipenv, and Conda. These managers were created to solve some issues
    posed by `pip`, especially related to sub-dependency management. While they are
    very good tools, lots of cloud platforms expect a traditional `requirements.txt`
    file to specify the dependencies, rather than those more modern tools. Therefore,
    they may not be the best choice for a FastAPI application.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索Python社区时，你可能会听说过替代的包管理器，如Poetry、Pipenv和Conda。这些管理器是为了解决`pip`带来的一些问题，特别是在子依赖管理方面。虽然它们是非常好的工具，但许多云平台期望使用传统的`requirements.txt`文件来指定依赖，而不是那些更现代的工具。因此，它们可能不是FastAPI应用程序的最佳选择。
- en: 'The `requirements.txt` file should be committed along with your source code.
    When you need to install the dependencies on a new computer or server, you’ll
    simply need to run this command:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`requirements.txt`文件应该与源代码一起提交。当你需要在新电脑或服务器上安装依赖时，你只需要运行以下命令：'
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Of course, make sure that you’re working on proper virtual environments when
    doing this, as we described in [*Chapter 1*](B19528_01.xhtml#_idTextAnchor024),
    *Python Development* *Environment Setup*.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在进行此操作时，请确保你正在正确的虚拟环境中工作，就像我们在[*第一章*](B19528_01.xhtml#_idTextAnchor024)中描述的那样，*Python
    开发* *环境设置*。
- en: You have probably noticed the `gunicorn` dependency in `requirements.txt`. Let’s
    look at what it is and why it’s needed.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到在`requirements.txt`中有`gunicorn`的依赖。让我们来看看它是什么以及为什么需要它。
- en: Adding Gunicorn as a server process for deployment
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将Gunicorn添加为部署时的服务器进程
- en: In [*Chapter 2*](B19528_02.xhtml#_idTextAnchor032), *Python Programming Specificities*,
    we briefly introduced the WSGI and ASGI protocols. They define the norm and data
    structure for building web servers in Python. Traditional Python web frameworks,
    such as Django and Flask, rely on the WSGI protocol. ASGI appeared recently and
    is presented as the “spiritual successor” of WSGI, providing a protocol for developing
    web servers running asynchronously. This protocol is at the heart of FastAPI and
    Starlette.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第 2 章*](B19528_02.xhtml#_idTextAnchor032)《Python 编程特性》中，我们简要介绍了 WSGI 和 ASGI
    协议。它们定义了在 Python 中构建 Web 服务器的规范和数据结构。传统的 Python Web 框架，如 Django 和 Flask，依赖于 WSGI
    协议。ASGI 是最近出现的，并被视为 WSGI 的“精神继承者”，为开发运行异步的 Web 服务器提供协议。这个协议是 FastAPI 和 Starlette
    的核心。
- en: 'As we mentioned in [*Chapter 3*](B19528_03.xhtml#_idTextAnchor058), *Developing
    RESTful APIs with FastAPI*, we use *Uvicorn* to run our FastAPI applications:
    its role is to accept HTTP requests, transform them according to the ASGI protocol,
    and pass them to the FastAPI application, which returns an ASGI-compliant response
    object. Then, Uvicorn can form a proper HTTP response from this object.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[*第 3 章*](B19528_03.xhtml#_idTextAnchor058)《使用 FastAPI 开发 RESTful API》中提到的，我们使用
    *Uvicorn* 来运行 FastAPI 应用：它的作用是接受 HTTP 请求，将其按照 ASGI 协议转换，并传递给 FastAPI 应用，后者返回一个符合
    ASGI 协议的响应对象。然后，Uvicorn 可以从该对象形成适当的 HTTP 响应。
- en: In the WSGI world, the most widely used server is *Gunicorn*. It has the same
    role in the context of a Django or Flask application. Why are we talking about
    it, then? Gunicorn has lots of refinements and features that make it more robust
    and reliable in production than Uvicorn. However, Gunicorn is designed to work
    for WSGI applications. So, what can we do?
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在 WSGI 的世界中，最广泛使用的服务器是 *Gunicorn*。在 Django 或 Flask 应用的上下文中，它扮演着相同的角色。那么，我们为什么要讨论它呢？Gunicorn
    有许多优化和特性，使得它在生产环境中比 Uvicorn 更加稳健和可靠。然而，Gunicorn 设计时是针对 WSGI 应用的。那么，我们该怎么办呢？
- en: 'Actually, we can use both: Gunicorn will be used as a robust process manager
    for our production server. However, we’ll specify a special worker class provided
    by Uvicorn, which will allow us to run ASGI applications such as FastAPI. This
    is the recommended way of doing deployments in the official Uvicorn documentation:
    [https://www.uvicorn.org/deployment/#using-a-process-manager](https://www.uvicorn.org/deployment/#using-a-process-manager).'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们可以同时使用这两个：Gunicorn 将作为我们的生产服务器的强大进程管理器。然而，我们会指定 Uvicorn 提供的特殊工作类，这将允许我们运行
    ASGI 应用程序，如 FastAPI。这是官方 Uvicorn 文档中推荐的部署方式：[https://www.uvicorn.org/deployment/#using-a-process-manager](https://www.uvicorn.org/deployment/#using-a-process-manager)。
- en: 'So, let’s install Gunicorn to our dependencies by using the following command
    (remember to add it to your `requirements.txt` file):'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们通过以下命令将 Gunicorn 安装到我们的依赖中（记得将它添加到 `requirements.txt` 文件中）：
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If you wish, you can try to run our FastAPI project using Gunicorn by using
    the following command:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意，可以尝试使用以下命令，通过 Gunicorn 运行我们的 FastAPI 项目：
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Its usage is quite similar to Uvicorn, except that we tell it to use a Uvicorn
    worker. Once again, this is necessary to make it work with an ASGI application.
    Also, notice the `-w` option. This allows us to set the number of workers to launch
    for our server. Here, we launch four instances of our application. Then, Gunicorn
    takes care of load-balancing the incoming requests between each worker. This is
    what makes Gunicorn more robust: if, for any reason, your application blocks the
    event loop with a synchronous operation, other workers will be able to process
    other requests while this is happening.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 它的使用方式与 Uvicorn 十分类似，不同之处在于我们告诉它使用 Uvicorn 工作类。同样，这是为了使其与 ASGI 应用兼容。此外，请注意 `-w`
    选项。它允许我们设置为服务器启动的工作进程数。在这里，我们启动了四个实例的应用。然后，Gunicorn 会负责在每个工作进程之间负载均衡传入的请求。这就是
    Gunicorn 更加稳健的原因：如果由于某种原因，你的应用因同步操作而阻塞了事件循环，其他工作进程仍然可以处理其他请求。
- en: Now, we are ready to deploy our FastAPI application! In the next section, you’ll
    learn how to deploy one on a serverless platform.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好部署 FastAPI 应用程序了！在下一节中，你将学习如何在无服务器平台上部署一个。
- en: Deploying a FastAPI application on a serverless platform
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在无服务器平台上部署 FastAPI 应用
- en: In recent years, serverless platforms have gained a lot of popularity and have
    become a very common way to deploy web applications. Those platforms completely
    hide the complexity of setting up and managing a server, giving you the tools
    to automatically build and deploy your application in minutes. Google App Engine,
    Heroku, and Azure App Service are among the most popular. Even though they have
    their own specificities, all these serverless platforms work on the same principles.
    This is why, in this section, we’ll outline the common steps you should follow.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，无服务器平台得到了广泛的应用，并成为部署Web应用程序的常见方式。这些平台完全隐藏了设置和管理服务器的复杂性，提供了自动构建和部署应用程序的工具，通常只需要几分钟。Google
    App Engine、Heroku和Azure App Service是其中最受欢迎的。尽管它们各自有特定的要求，但所有这些无服务器平台都遵循相同的原理。因此，在本节中，我们将概述您应该遵循的通用步骤。
- en: 'Usually, serverless platforms expect you to provide the source code in the
    form of a GitHub repository, which you push directly to their servers or which
    they pull automatically from GitHub. Here, we’ll assume that you have a GitHub
    repository with the source code structured like so:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，无服务器平台要求您以GitHub仓库的形式提供源代码，您可以直接将其推送到他们的服务器，或者他们会自动从GitHub拉取代码。在这里，我们假设您有一个GitHub仓库，源代码结构如下：
- en: '![Figure 10.1 – Project structure for serverless deployment](img/B19528_10_01.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图10.1 – 无服务器部署的项目结构](img/B19528_10_01.jpg)'
- en: Figure 10.1 – Project structure for serverless deployment
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1 – 无服务器部署的项目结构
- en: 'Here are the general steps you should follow to deploy your projects on this
    kind of platform:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是您应该遵循的在这种平台上部署项目的一般步骤：
- en: Create an account on a cloud platform of your choice. You must do this before
    you can start any work. It’s worth noting that most cloud platforms offer free
    credits when you are getting started so that you can try their services for free.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您选择的云平台上创建一个帐户。在开始任何工作之前，您必须完成这一步。值得注意的是，大多数云平台在您入门时会提供免费积分，让您可以免费试用它们的服务。
- en: 'Install the necessary command-line tools. Most cloud providers supply a complete
    CLI for managing their services. Typically, this is required for deploying your
    application. Here are the relevant documentation pages for the most popular cloud
    providers:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装必要的命令行工具。大多数云服务提供商提供完整的CLI来管理他们的服务。通常，这对于部署您的应用程序是必需的。以下是一些最受欢迎的云服务提供商的相关文档页面：
- en: 'Google Cloud: [https://cloud.google.com/sdk/gcloud](https://cloud.google.com/sdk/gcloud)'
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Google Cloud: [https://cloud.google.com/sdk/gcloud](https://cloud.google.com/sdk/gcloud)'
- en: 'Microsoft Azure: [https://docs.microsoft.com/en-us/cli/azure/install-azure-cli](https://docs.microsoft.com/en-us/cli/azure/install-azure-cli)'
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Microsoft Azure: [https://docs.microsoft.com/en-us/cli/azure/install-azure-cli](https://docs.microsoft.com/en-us/cli/azure/install-azure-cli)'
- en: 'Heroku: https://devcenter.heroku.com/articles/heroku-cli'
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Heroku: https://devcenter.heroku.com/articles/heroku-cli'
- en: 'Set up the application configuration. Depending on the platform, you’ll either
    have to create a configuration file or use the CLI or the web interface to do
    this. Here are the relevant documentation pages for the most popular cloud providers:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置应用程序配置。根据平台的不同，您需要创建配置文件，或者使用命令行工具或网页界面来完成此操作。以下是一些最受欢迎的云服务提供商的相关文档页面：
- en: 'Google App Engine (configuration file): [https://cloud.google.com/appengine/docs/standard/python3/configuring-your-app-with-app-yaml](https://cloud.google.com/appengine/docs/standard/python3/configuring-your-app-with-app-yaml)'
  id: totrans-103
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Google App Engine（配置文件）：[https://cloud.google.com/appengine/docs/standard/python3/configuring-your-app-with-app-yaml](https://cloud.google.com/appengine/docs/standard/python3/configuring-your-app-with-app-yaml)
- en: 'Azure App Service (web interface and CLI): [https://docs.microsoft.com/en-us/azure/app-service/quickstart-python](https://docs.microsoft.com/en-us/azure/app-service/quickstart-python)
    and [https://docs.microsoft.com/en-us/azure/app-service/configure-language-python](https://docs.microsoft.com/en-us/azure/app-service/configure-language-python)'
  id: totrans-104
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure App Service（网页界面和CLI）：[https://docs.microsoft.com/en-us/azure/app-service/quickstart-python](https://docs.microsoft.com/en-us/azure/app-service/quickstart-python)
    和 [https://docs.microsoft.com/en-us/azure/app-service/configure-language-python](https://docs.microsoft.com/en-us/azure/app-service/configure-language-python)
- en: 'Heroku (configuration file): [https://devcenter.heroku.com/articles/getting-started-with-python#define-a-procfile](https://devcenter.heroku.com/articles/getting-started-with-python#define-a-procfile)'
  id: totrans-105
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Heroku（配置文件）：[https://devcenter.heroku.com/articles/getting-started-with-python#define-a-procfile](https://devcenter.heroku.com/articles/getting-started-with-python#define-a-procfile)
- en: The key point in this step is to correctly *set the startup command*. As we
    saw in the previous section, it’s essential to set the Uvicorn worker class using
    the `gunicorn` command, as well as set the correct path to your application.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这一过程中的关键是正确地*设置启动命令*。正如我们在上一节看到的，使用`gunicorn`命令设置Uvicorn工作进程类并设置正确的应用路径是至关重要的。
- en: 'Set the environment variables. Depending on the cloud provider, you should
    be able to do so during configuration or deployment. Remember that they are key
    for your application to work. Here are the relevant documentation pages for the
    most popular cloud providers:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置环境变量。根据不同的云服务提供商，你应该能够在配置或部署过程中完成这项操作。请记住，环境变量对你的应用程序正常运行至关重要。以下是一些流行的云服务提供商的相关文档页面：
- en: 'Google App Engine (configuration file): [https://cloud.google.com/appengine/docs/standard/python/config/appref](https://cloud.google.com/appengine/docs/standard/python/config/appref)'
  id: totrans-108
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Google App Engine（配置文件）：[https://cloud.google.com/appengine/docs/standard/python/config/appref](https://cloud.google.com/appengine/docs/standard/python/config/appref)
- en: 'Azure App Service (web interface): [https://docs.microsoft.com/en-us/azure/app-service/configure-common#configure-app-settings](https://docs.microsoft.com/en-us/azure/app-service/configure-common#configure-app-settings)'
  id: totrans-109
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure 应用服务（网页界面）：[https://docs.microsoft.com/en-us/azure/app-service/configure-common#configure-app-settings](https://docs.microsoft.com/en-us/azure/app-service/configure-common#configure-app-settings)
- en: 'Heroku (CLI or web interface): [https://devcenter.heroku.com/articles/config-vars](https://devcenter.heroku.com/articles/config-vars)'
  id: totrans-110
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Heroku（CLI或网页界面）：[https://devcenter.heroku.com/articles/config-vars](https://devcenter.heroku.com/articles/config-vars)
- en: 'Deploy the application. Some platforms can automatically deploy when they detect
    changes on a hosted repository, such as GitHub. Others require that you start
    deployment from the command-line tools. Here are the relevant documentation pages
    for the most popular cloud providers:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署应用程序。一些平台在检测到托管仓库（例如GitHub）上的更改时会自动部署。其他平台则要求你从命令行工具启动部署。以下是一些流行的云服务提供商的相关文档页面：
- en: 'Google App Engine (CLI): [https://cloud.google.com/appengine/docs/standard/python3/testing-and-deploying-your-app#deploying_your_application](https://cloud.google.com/appengine/docs/standard/python3/testing-and-deploying-your-app#deploying_your_application)'
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Google App Engine（CLI）：[https://cloud.google.com/appengine/docs/standard/python3/testing-and-deploying-your-app#deploying_your_application](https://cloud.google.com/appengine/docs/standard/python3/testing-and-deploying-your-app#deploying_your_application)
- en: 'Azure App Service (continuous deployment or manual Git deployment): [https://docs.microsoft.com/en-us/azure/app-service/deploy-continuous-deployment?tabs=github](https://docs.microsoft.com/en-us/azure/app-service/deploy-continuous-deployment?tabs=github)
    and [https://docs.microsoft.com/en-us/azure/app-service/deploy-local-git?tabs=cli](https://docs.microsoft.com/en-us/azure/app-service/deploy-local-git?tabs=cli%0D)'
  id: totrans-113
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure 应用服务（持续部署或手动Git部署）：[https://docs.microsoft.com/en-us/azure/app-service/deploy-continuous-deployment?tabs=github](https://docs.microsoft.com/en-us/azure/app-service/deploy-continuous-deployment?tabs=github)
    和 [https://docs.microsoft.com/en-us/azure/app-service/deploy-local-git?tabs=cli](https://docs.microsoft.com/en-us/azure/app-service/deploy-local-git?tabs=cli%0D)
- en: 'Heroku (CLI): [https://devcenter.heroku.com/articles/getting-started-with-python#deploy-the-app](https://devcenter.heroku.com/articles/getting-started-with-python#deploy-the-app)'
  id: totrans-114
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Heroku（CLI）：[https://devcenter.heroku.com/articles/getting-started-with-python#deploy-the-app](https://devcenter.heroku.com/articles/getting-started-with-python#deploy-the-app)
- en: Your application should now be live on the platform. Under the hood, most cloud
    platforms actually automatically build and deploy Docker containers while following
    the configuration you provide.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 你的应用程序现在应该已经在平台上运行了。实际上，大多数云平台会在后台自动构建和部署Docker容器，同时遵循你提供的配置。
- en: 'They will make your application available on a generic subdomain such as `myapplication.herokuapp.com`.
    Of course, they also provide mechanisms for binding it to your own domain or subdomain.
    Here are the relevant documentation pages for the most popular cloud providers:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 它们会在一个通用的子域名上提供你的应用程序，如`myapplication.herokuapp.com`。当然，它们也提供将其绑定到你自己的域名或子域名的机制。以下是一些流行的云服务提供商的相关文档页面：
- en: 'Google App Engine: [https://cloud.google.com/appengine/docs/standard/python3/mapping-custom-domains](https://cloud.google.com/appengine/docs/standard/python3/mapping-custom-domains)'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Google App Engine：[https://cloud.google.com/appengine/docs/standard/python3/mapping-custom-domains](https://cloud.google.com/appengine/docs/standard/python3/mapping-custom-domains)
- en: 'Azure App Service: [https://docs.microsoft.com/en-us/azure/app-service/manage-custom-dns-migrate-domain](https://docs.microsoft.com/en-us/azure/app-service/manage-custom-dns-migrate-domain%0D)'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Azure 应用服务: [https://docs.microsoft.com/en-us/azure/app-service/manage-custom-dns-migrate-domain](https://docs.microsoft.com/en-us/azure/app-service/manage-custom-dns-migrate-domain%0D)'
- en: 'Heroku: [https://devcenter.heroku.com/articles/custom-domains](https://devcenter.heroku.com/articles/custom-domains)'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Heroku: [https://devcenter.heroku.com/articles/custom-domains](https://devcenter.heroku.com/articles/custom-domains)'
- en: Adding database servers
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加数据库服务器
- en: 'Most of the time, your application will be backed by a database engine, such
    as PostgreSQL. Fortunately, cloud providers propose fully managed databases, billed
    according to the computing power, memory, and storage you need. Once created,
    you’ll have access to a connection string to connect to the database instance.
    All you have to do then is set it in the environment variables of your application.
    Here are the relevant documentation pages for getting started with managed databases
    with the most popular cloud providers:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，您的应用将由数据库引擎提供支持，例如 PostgreSQL。幸运的是，云服务提供商提供了完全托管的数据库，按所需的计算能力、内存和存储收费。一旦创建，您将获得一个连接字符串，用于连接到数据库实例。之后，您只需将其设置为应用程序的环境变量即可。以下是开始使用最流行云服务提供商的托管数据库的相关文档页面：
- en: 'Google Cloud SQL: [https://cloud.google.com/sql/docs/postgres/create-instance](https://cloud.google.com/sql/docs/postgres/create-instance)'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Google Cloud SQL: [https://cloud.google.com/sql/docs/postgres/create-instance](https://cloud.google.com/sql/docs/postgres/create-instance)'
- en: 'Azure Database for PostgreSQL: [https://docs.microsoft.com/en-us/azure/postgresql/quickstart-create-server-database-portal](https://docs.microsoft.com/en-us/azure/postgresql/quickstart-create-server-database-portal)'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Azure PostgreSQL 数据库: [https://docs.microsoft.com/en-us/azure/postgresql/quickstart-create-server-database-portal](https://docs.microsoft.com/en-us/azure/postgresql/quickstart-create-server-database-portal)'
- en: 'Amazon RDS: [https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_GettingStarted.html](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_GettingStarted.html)'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '亚马逊 RDS: [https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_GettingStarted.html](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_GettingStarted.html)'
- en: 'Heroku Postgres: [https://devcenter.heroku.com/articles/heroku-postgresql](https://devcenter.heroku.com/articles/heroku-postgresql%0D)'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Heroku Postgres: [https://devcenter.heroku.com/articles/heroku-postgresql](https://devcenter.heroku.com/articles/heroku-postgresql%0D)'
- en: As we’ve seen, serverless platforms are the quickest and easiest way to deploy
    a FastAPI application. However, in some situations, you may wish to have more
    control of how things are deployed, or you may need system packages that are not
    available on serverless platforms. In those cases, it may be worthwhile to use
    a Docker container.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，无服务器平台是部署 FastAPI 应用最快、最简便的方式。然而，在某些情况下，您可能希望对部署方式有更多控制，或者可能需要一些在无服务器平台上不可用的系统包。在这种情况下，使用
    Docker 容器可能是值得的。
- en: Deploying a FastAPI application with Docker
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Docker 部署 FastAPI 应用
- en: 'Docker is a widely used technology for containerization. **Containers** are
    small, self-contained systems running on a computer. Each container contains all
    the files and configurations necessary for running a single application: a web
    server, a database engine, a data processing application, and so on. The main
    goal is to be able to run those applications without worrying about the dependency
    and version conflicts that often happen when trying to install and configure them
    on the system.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 是一种广泛使用的容器化技术。**容器**是运行在计算机上的小型、自包含的系统。每个容器包含运行单一应用程序所需的所有文件和配置：如 Web
    服务器、数据库引擎、数据处理应用等。其主要目标是能够在不担心依赖关系和版本冲突的情况下运行这些应用，这些问题在尝试在系统上安装和配置应用时经常发生。
- en: 'Besides, Docker containers are designed to be *portable and reproducible*:
    to create a Docker container, you simply have to write a **Dockerfile** containing
    all the necessary instructions to build the small system, along with all the files
    and configuration you need. Those instructions are executed during a **build**,
    which results in a Docker **image**. This image is a package containing your small
    system, ready to use, which you can easily share on the internet through **registries**.
    Any developer who has a working Docker installation can then download this image
    and run it on their system in a container.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Docker 容器被设计为 *便携和可复现的*：要创建一个 Docker 容器，你只需编写一个 **Dockerfile**，其中包含所有必要的指令来构建这个小系统，以及你所需的所有文件和配置。这些指令会在
    **构建** 过程中执行，最终生成一个 Docker **镜像**。这个镜像是一个包含你小系统的包，准备好使用，你可以通过 **镜像仓库** 在互联网上轻松分享。任何拥有工作
    Docker 安装的开发人员，都可以下载这个镜像，并在他们的系统中通过容器运行它。
- en: Docker has been quickly adopted by developers as it greatly eases the setup
    of complex development environments, allowing them to have several projects with
    different system package versions, all without worrying about their installation
    on their local machine.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 被开发人员迅速采纳，因为它大大简化了复杂开发环境的设置，使他们能够拥有多个项目，并且每个项目使用不同版本的系统包，而不需要担心它们在本地机器上的安装问题。
- en: 'However, Docker is not only for local development: it’s also widely used for
    deploying applications to production. Since the builds are reproducible, we can
    ensure that the local and production environments remain the same, which limits
    any issues when moving to production.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Docker 不仅仅是为了本地开发：它也广泛用于将应用程序部署到生产环境。由于构建是可复现的，我们可以确保本地和生产环境保持一致，这样在部署到生产环境时能够减少问题。
- en: In this section, we’ll learn how to write a Dockerfile for a FastAPI application,
    how to build an image, and how to deploy it on a cloud platform.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何为 FastAPI 应用编写 Dockerfile，如何构建镜像，以及如何将其部署到云平台。
- en: Writing a Dockerfile
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写 Dockerfile
- en: As we mentioned in the introduction to this section, a Dockerfile is a set of
    instructions for building your Docker image, a self-contained system containing
    all the required components to run your applications. To begin with, all Dockerfiles
    derive from a base image; usually, this is a standard Linux installation, such
    as Debian or Ubuntu. From this base, we can copy files from our local machine
    into the image (usually, the source code of our application) and execute Unix
    commands – for example, to install packages or execute scripts.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本节介绍中提到的，Dockerfile 是一组构建 Docker 镜像的指令，它是一个包含运行应用程序所需的所有组件的自包含系统。首先，所有
    Dockerfile 都是从一个基础镜像衍生出来的；通常，这个基础镜像是一个标准的 Linux 安装，如 Debian 或 Ubuntu。基于这个基础镜像，我们可以将文件从本地机器复制到镜像中（通常是应用程序的源代码），并执行
    Unix 命令——例如，安装软件包或执行脚本。
- en: In our case, the creator of FastAPI has created a base Docker image that contains
    all the necessary tools to run a FastAPI app! All we have to do is start from
    this image, copy our source files, and install our dependencies! Let’s learn how
    to do that!
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，FastAPI 的创建者已经创建了一个基础的 Docker 镜像，包含了运行 FastAPI 应用所需的所有工具！我们要做的就是从这个镜像开始，复制我们的源文件，并安装我们的依赖项！让我们来学习如何做！
- en: 'First of all, you’ll need a working Docker installation on your machine. Follow
    the official *Getting Started* tutorial, which should guide you in this process:
    [https://docs.docker.com/get-started/](https://docs.docker.com/get-started/).'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要在你的机器上安装 Docker。请按照官方的 *入门指南*，该指南将引导你完成安装过程：[https://docs.docker.com/get-started/](https://docs.docker.com/get-started/)。
- en: 'To create a Docker image, we simply have to create a file named `Dockerfile`
    at the root of our project. The following example shows the content of this file
    for our current project:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个 Docker 镜像，我们只需要在项目根目录下创建一个名为 `Dockerfile` 的文件。以下示例展示了我们当前项目中该文件的内容：
- en: Dockerfile
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile
- en: '[PRE15]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter10/project/Dockerfile](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter10/project/Dockerfile)'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter10/project/Dockerfile](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter10/project/Dockerfile)'
- en: 'Let’s go through each instruction. The first instruction, `FROM`, is the base
    image we derive from. Here, we took the `uvicorn-gunicorn-fastapi` image, which
    was created by the creator of FastAPI. Docker images have tags, which can be used
    to pick a specific version of the image. Here, we chose Python version 3.10\.
    Lots of variations exist for this image, including ones with other versions of
    Python. You can check them out in the official README file: [https://github.com/tiangolo/uvicorn-gunicorn-fastapi-docker](https://github.com/tiangolo/uvicorn-gunicorn-fastapi-docker).'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐条讲解每个指令。第一条指令是`FROM`，它指定了我们所基于的基础镜像。在这里，我们使用了`uvicorn-gunicorn-fastapi`镜像，这是FastAPI的创建者制作的。Docker镜像有标签，可以用来选择镜像的特定版本。在这里，我们选择了Python
    3.10版本。该镜像有许多变种，包括其他版本的Python。你可以在官方的README文件中查看它们：[https://github.com/tiangolo/uvicorn-gunicorn-fastapi-docker](https://github.com/tiangolo/uvicorn-gunicorn-fastapi-docker)。
- en: 'Then, we set the `APP_MODULE` environment variable thanks to the `ENV` instruction.
    In a Docker image, environment variables can be set at build time, as we did here,
    or at runtime. `APP_MODULE` is an environment variable defined by the base image.
    It should point to the path of your FastAPI application: it’s the same argument
    that we set at the end of Uvicorn and Gunicorn commands to launch the application.
    You can find the list of all the accepted environment variables for the base image
    in the official README file.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，我们通过`ENV`指令设置了`APP_MODULE`环境变量。在Docker镜像中，环境变量可以在构建时设置，就像我们在这里做的那样，也可以在运行时设置。`APP_MODULE`是由基础镜像定义的一个环境变量。它应该指向你的FastAPI应用的路径：它是我们在Uvicorn和Gunicorn命令的末尾用来启动应用的相同参数。你可以在官方的README文件中找到基础镜像接受的所有环境变量列表。
- en: Next, we have our first `COPY` statement. As you may have guessed, this instruction
    will copy a file from your local system to the image. Here, we only copied our
    `requirements.txt` file. We’ll explain why shortly. Notice that we copied the
    file into the `/app` directory of the image; it’s the main working directory defined
    by the base image.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有了第一个`COPY`语句。正如你可能已经猜到的，这条指令会将一个文件从本地系统复制到镜像中。在这里，我们只复制了`requirements.txt`文件。稍后我们会解释原因。请注意，我们将文件复制到了镜像中的`/app`目录；这是由基础镜像定义的主要工作目录。
- en: We then have a `RUN` statement. This instruction is used to execute Unix commands.
    In our case, we ran `pip` to install our dependencies, following the `requirements.txt`
    file we just copied. This is essential to make sure all our Python dependencies
    are present.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们有一个`RUN`语句。这条指令用于执行Unix命令。在我们的案例中，我们运行了`pip`来安装我们依赖的包，依据的是我们刚刚复制的`requirements.txt`文件。这是确保所有Python依赖包都已安装的关键步骤。
- en: 'Finally, we copied the rest of our source code files into the `/app` directory.
    Now, let’s explain why we separately copied `requirements.txt`. The important
    thing to understand is that Docker images are built using layers: each instruction
    will create a new layer in the build system. To improve performance, Docker does
    its best to reuse layers it has already built. Therefore, if it detects no changes
    from the previous build, it’ll reuse the ones it has in memory without rebuilding
    them.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将剩余的源代码文件复制到了`/app`目录。现在，让我们来解释为什么我们单独复制了`requirements.txt`。要理解的关键点是，Docker镜像是通过层构建的：每个指令都会在构建系统中创建一个新层。为了提高性能，Docker尽量重用已经构建的层。因此，如果它检测到与上次构建没有变化，它将重用内存中已有的层，而不是重新构建它们。
- en: By copying the `requirements.txt` file alone and installing the Python dependencies
    before the rest of the source code, we allow Docker to reuse the layer where the
    dependencies have been installed. If we edit our source code but not `requirements.txt`,
    the Docker build will only execute the last `COPY` instruction, reusing all the
    previous layers. Thus, the image is built in a few seconds instead of minutes.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 通过仅复制`requirements.txt`文件并在源代码的其他部分之前安装Python依赖项，我们允许Docker重用已安装依赖项的层。如果我们修改了源代码但没有修改`requirements.txt`，Docker构建将只会执行最后一条`COPY`指令，重用所有先前的层。因此，镜像将在几秒钟内构建完成，而不是几分钟。
- en: Most of the time, Dockerfiles end with a `CMD` instruction, which should be
    the command to execute when the container is started. In our case, we would have
    used the Gunicorn command we saw in the *Adding Gunicorn as a server* section.
    However, in our case, the base image already handles this for us.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，Dockerfile会以`CMD`指令结束，这条指令定义了容器启动时要执行的命令。在我们的案例中，我们会使用在*添加Gunicorn作为服务器*部分中看到的Gunicorn命令。然而，在我们的情况下，基础镜像已经为我们处理了这个问题。
- en: Adding a prestart script
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加预启动脚本
- en: When deploying an application, it’s quite common to run several commands before
    the application starts. The most typical case is to execute database migrations
    so that our production database has the correct set of tables and columns. To
    help us with this, our base Docker image allows us to create a bash script named
    `prestart.sh`. If this file is present, it’ll be automatically run before the
    FastAPI application is started.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在部署应用程序时，通常会在应用程序启动之前运行几个命令。最典型的情况是执行数据库迁移，以确保我们的生产数据库具有正确的表和列。为了帮助我们，基础的 Docker
    镜像允许我们创建一个名为`prestart.sh`的 bash 脚本。如果该文件存在，它将在 FastAPI 应用程序启动之前自动运行。
- en: 'In our case, we just run the Alembic command to execute migrations:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们只需要运行 Alembic 命令来执行迁移：
- en: prestart.sh
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: prestart.sh
- en: '[PRE16]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter10/project/prestart.sh](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter10/project/prestart.sh)'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter10/project/prestart.sh](https://github.com/PacktPublishing/Building-Data-Science-Applications-with-FastAPI-Second-Edition/tree/main/chapter10/project/prestart.sh)'
- en: Bear in mind that this is a mechanism provided only for convenience by the `tiangolo/uvicorn-gunicorn-fastapi`
    image. If you start from a more basic image, you’ll have to come up with your
    own solution to run a prestart script.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这只是`tiangolo/uvicorn-gunicorn-fastapi`镜像提供的一个方便机制。如果你从一个更基础的镜像开始，你将需要自己想出一种解决方案来运行预启动脚本。
- en: Building a Docker image
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建 Docker 镜像
- en: 'We can now build our Docker image! From the root of your project, just run
    the following command:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以构建 Docker 镜像了！只需在项目的根目录下运行以下命令：
- en: '[PRE17]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The dot (`.`) denotes the path of the root context to build your image – in
    this case, the current directory. The `-t` option is here to tag the image and
    give it a practical name.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 点号（`.`）表示构建镜像的根上下文路径——在这种情况下是当前目录。`-t`选项用于标记镜像并为其指定一个实际的名称。
- en: 'Docker will then perform the build. You’ll see that it’ll download the base
    image and sequentially run your instructions. This should take a few minutes.
    If you run the command again, you’ll experience what we explained earlier about
    layers: if there is no change, layers are reused and the build takes only a few
    seconds.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 将开始构建。你会看到它下载基础镜像，并依次执行你的指令。这应该需要几分钟。如果你再次运行该命令，你将体验到我们之前提到的关于镜像层的内容：如果没有变化，镜像层会被重用，构建仅需几秒钟。
- en: Running a Docker image locally
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 本地运行 Docker 镜像
- en: 'Before deploying it to production, you can try to run your image locally. To
    do this, run the following command:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在将其部署到生产环境之前，你可以尝试在本地运行镜像。为此，运行以下命令：
- en: '[PRE18]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here, we used the `run` command with the name of the image we just built. There
    are, of course, a few options here:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了`run`命令并指定了我们刚刚构建的镜像名称。当然，这里有一些选项：
- en: '`-p` allows you to publish ports on your local machine. By default, Docker
    containers are not accessible on your local machine. If you publish ports, they
    will be available through `localhost`. On the container side, the FastAPI application
    is executed on port `80`. We publish it on port `8000` on our local machine –
    that is, `8000:80`.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-p`允许你在本地机器上发布端口。默认情况下，Docker 容器在本地机器上是不可访问的。如果你发布端口，它们将通过`localhost`提供。在容器端，FastAPI
    应用程序在`80`端口运行。我们将它发布到本地机器的`8000`端口，也就是`8000:80`。'
- en: '`-e` is used to set environment variables. As we mentioned in the *Setting
    and using environment variables* section, we need those variables to configure
    our application. Docker allows us to set them easily and dynamically at runtime.
    Notice that we set a simple SQLite database for testing purposes. However, in
    production, it should point to a proper database.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-e`用于设置环境变量。如我们在*设置和使用环境变量*部分中提到的，我们需要这些变量来配置我们的应用程序。Docker 允许我们在运行时轻松且动态地设置它们。请注意，我们为测试目的设置了一个简单的
    SQLite 数据库。然而，在生产环境中，它应该指向一个合适的数据库。'
- en: 'You can review the numerous options of this command in the official Docker
    documentation: [https://docs.docker.com/engine/reference/commandline/run/#options](https://docs.docker.com/engine/reference/commandline/run/#options).'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在官方 Docker 文档中查看此命令的众多选项：[https://docs.docker.com/engine/reference/commandline/run/#options](https://docs.docker.com/engine/reference/commandline/run/#options)。
- en: This command will run your application, which will be accessible through `http://localhost:8000`.
    Docker will show you the logs in the terminal.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将运行你的应用程序，应用程序将通过`http://localhost:8000`访问。Docker 将在终端中显示日志。
- en: Deploying a Docker image
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署 Docker 镜像
- en: 'Now that you have a working Docker image, you can deploy it on virtually any
    machine that runs Docker. This can be your own server or a dedicated platform.
    Lots of serverless platforms have emerged to help you deploy container images
    automatically: Google Cloud Run, Amazon Elastic Container Service, and Microsoft
    Azure Container Instances are just a few.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了一个可用的 Docker 镜像，你可以在几乎任何运行 Docker 的机器上部署它。这可以是你自己的服务器，也可以是专用平台。许多无服务器平台已经出现，帮助你自动部署容器镜像：Google
    Cloud Run、Amazon Elastic Container Service 和 Microsoft Azure Container Instances
    仅是其中的几个。
- en: 'Usually, what you have to do is upload (**push**, in Docker jargon) your image
    to a registry. By default, Docker pulls and pushes images from Docker Hub, the
    official Docker registry, but lots of services and platforms propose their own
    registries. Usually, using the private cloud registry proposed by the cloud platform
    is necessary to deploy it on this platform. Here are the relevant documentation
    pages for getting started with private registries with the most popular cloud
    providers:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你需要做的是将你的镜像上传（在 Docker 术语中是**推送**）到一个注册中心。默认情况下，Docker 从 Docker Hub（官方 Docker
    注册中心）拉取和推送镜像，但许多服务和平台提供了自己的注册中心。通常，为了在该平台上部署，必须使用云平台提供的私有云注册中心。以下是与最流行的云服务提供商的私有注册中心入门相关的文档页面：
- en: 'Google Artifact Registry: [https://cloud.google.com/artifact-registry/docs/docker/store-docker-container-images](https://cloud.google.com/artifact-registry/docs/docker/store-docker-container-images)'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Google Artifact Registry: [https://cloud.google.com/artifact-registry/docs/docker/store-docker-container-images](https://cloud.google.com/artifact-registry/docs/docker/store-docker-container-images)'
- en: 'Amazon ECR: [https://docs.aws.amazon.com/AmazonECR/latest/userguide/getting-started-console.html](https://docs.aws.amazon.com/AmazonECR/latest/userguide/getting-started-console.html)'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Amazon ECR: [https://docs.aws.amazon.com/AmazonECR/latest/userguide/getting-started-console.html](https://docs.aws.amazon.com/AmazonECR/latest/userguide/getting-started-console.html)'
- en: 'Microsoft Azure Container Registry: [https://docs.microsoft.com/en-us/azure/container-registry/container-registry-get-started-docker-cli?tabs=azure-cli](https://docs.microsoft.com/en-us/azure/container-registry/container-registry-get-started-docker-cli?tabs=azure-cli)'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Microsoft Azure Container Registry: [https://docs.microsoft.com/en-us/azure/container-registry/container-registry-get-started-docker-cli?tabs=azure-cli](https://docs.microsoft.com/en-us/azure/container-registry/container-registry-get-started-docker-cli?tabs=azure-cli)'
- en: 'If you followed the relevant instructions, you should have a private registry
    for storing Docker images. The instructions probably showed you how to authenticate
    your local Docker command line with it and how to push your first image. Basically,
    all you have to do is tag the image you built with the path to your private registry:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你按照相关的说明操作，你应该已经有了一个私有注册中心来存储 Docker 镜像。说明中可能会教你如何用本地的 Docker 命令行进行身份验证，以及如何推送你的第一个镜像。基本上，你需要做的就是为你构建的镜像打上标签，并指向你的私有注册中心路径：
- en: '[PRE19]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, you need to push it to the registry:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你需要将其推送到注册中心：
- en: '[PRE20]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Your image is now safely stored in the cloud platform registry. You can now
    use a serverless container platform to deploy it automatically. Here are the relevant
    documentation pages for getting started with private registries with the most
    popular cloud providers:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 你的镜像现在已安全存储在云平台注册中心。你现在可以使用无服务器容器平台自动部署它。以下是与最流行的云服务提供商的私有注册中心入门相关的文档页面：
- en: 'Google Cloud Run: [https://cloud.google.com/run/docs/quickstarts/build-and-deploy/python](https://cloud.google.com/run/docs/quickstarts/build-and-deploy/python)'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Google Cloud Run: [https://cloud.google.com/run/docs/quickstarts/build-and-deploy/python](https://cloud.google.com/run/docs/quickstarts/build-and-deploy/python)'
- en: 'Amazon Elastic Container Service: [https://docs.aws.amazon.com/AmazonECS/latest/developerguide/getting-started-ecs-ec2.html](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/getting-started-ecs-ec2.html)'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Amazon Elastic Container Service: [https://docs.aws.amazon.com/AmazonECS/latest/developerguide/getting-started-ecs-ec2.html](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/getting-started-ecs-ec2.html)'
- en: 'Microsoft Azure Container Instances: [https://docs.microsoft.com/en-us/azure/container-instances/container-instances-tutorial-deploy-app](https://docs.microsoft.com/en-us/azure/container-instances/container-instances-tutorial-deploy-app%0D)'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Microsoft Azure Container Instances: [https://docs.microsoft.com/en-us/azure/container-instances/container-instances-tutorial-deploy-app](https://docs.microsoft.com/en-us/azure/container-instances/container-instances-tutorial-deploy-app%0D)'
- en: Of course, you’ll be able to set the environment variables just like you can
    for fully managed apps. Those environments also provide lots of options for tuning
    the scalability of your containers, both vertically (using more powerful instances)
    and horizontally (spawning more instances).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以像为完全托管的应用程序一样设置环境变量。这些环境还提供了许多选项，用于调整容器的可扩展性，包括垂直扩展（使用更强大的实例）和水平扩展（启动更多实例）。
- en: 'Once done, your application should be live on the web! The great thing about
    deploying Docker images compared to automated serverless platforms is that you
    are not limited to the features supported by the platform: you can deploy anything,
    even complex applications that require a lot of exotic packages, without worrying
    about compatibility.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，你的应用程序应该已经可以在网络上访问了！与自动化的无服务器平台相比，部署 Docker 镜像的一个好处是，你不受平台支持功能的限制：你可以部署任何东西，甚至是需要大量特殊包的复杂应用，而不必担心兼容性问题。
- en: At this point, we’ve seen the easiest and most efficient ways to deploy a FastAPI
    application. However, you may wish to deploy one the old-fashioned way and manually
    set up your server. In the next section, we’ll provide some guidelines for doing
    so.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 到这时，我们已经看到了部署 FastAPI 应用程序的最简单和最有效的方法。然而，你可能希望使用传统方法部署，并手动设置服务器。在接下来的章节中，我们将提供一些实施指南。
- en: Deploying a FastAPI application on a traditional server
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在传统服务器上部署 FastAPI 应用程序
- en: In some situations, you may not have the chance to use a serverless platform
    to deploy your application. Some security or regulatory policies may force you
    to deploy on physical servers with specific configurations. In this case, it’s
    worth knowing some basic things so that you can deploy your application on traditional
    servers.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，你可能没有机会使用无服务器平台来部署应用程序。一些安全或合规政策可能迫使你在具有特定配置的物理服务器上进行部署。在这种情况下，了解一些基本知识会非常有用，帮助你在传统服务器上部署应用程序。
- en: 'In this section, we’ll consider you are working on a Linux server:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们假设你正在使用 Linux 服务器：
- en: First of all, make sure a *recent version of Python has been installed* on your
    server, ideally with the version matching the one you used in development. The
    easiest way to do this is to set up `pyenv`, as we saw in [*Chapter 1*](B19528_01.xhtml#_idTextAnchor024),
    *Python Development* *Environment Setup*.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，确保在服务器上安装了*最新版本的 Python*，理想情况下是与开发中使用的版本相匹配。设置 `pyenv` 是实现这一点的最简单方法，就像我们在
    [*第一章*](B19528_01.xhtml#_idTextAnchor024) *Python 开发环境设置*中看到的那样。
- en: To retrieve your source code and keep it in sync with your latest developments,
    you can *clone your Git repository* on your server. This way, you only have to
    pull the changes and restart the server process to deploy a new version.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了获取源代码并与最新开发同步，你可以*克隆你的 Git 仓库*到服务器上。这样，你只需拉取更改并重启服务器进程，就能部署新版本。
- en: Set up a *Python virtual environment*, as we explained in [*Chapter 1*](B19528_01.xhtml#_idTextAnchor024),
    *Python Development Environment Setup*. You can install the dependencies with
    `pip` thanks to your `requirements.txt` file.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置一个*Python 虚拟环境*，正如我们在 [*第一章*](B19528_01.xhtml#_idTextAnchor024) *Python 开发环境设置*中所解释的那样。你可以通过
    `requirements.txt` 文件使用 `pip` 安装依赖。
- en: At that point, you should be able to run Gunicorn and start serving your FastAPI
    application. However, some improvements are strongly recommended.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到那时，你应该能够运行 Gunicorn 并开始为 FastAPI 应用程序提供服务。然而，强烈建议进行一些改进。
- en: '*Use a process manager* to ensure your Gunicorn process is always running and
    restarted when the server is restarted. A good option for this is *Supervisor*.
    The Gunicorn documentation provides good guidelines for this: [https://docs.gunicorn.org/en/stable/deploy.html#supervisor](https://docs.gunicorn.org/en/stable/deploy.html#supervisor).'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*使用进程管理器*来确保 Gunicorn 进程始终运行，并在服务器重启时自动重启。一个不错的选择是*Supervisor*。Gunicorn 文档提供了很好的指南：[https://docs.gunicorn.org/en/stable/deploy.html#supervisor](https://docs.gunicorn.org/en/stable/deploy.html#supervisor)。'
- en: 'It’s also recommended to *put Gunicorn behind an HTTP proxy* instead of directly
    putting it on the front line. Its role is to handle SSL connections, perform load
    balancing, and serve static files such as images or documents. The Gunicorn documentation
    recommends using nginx for this task and provides a basic configuration: [https://docs.gunicorn.org/en/stable/deploy.html#nginx-configuration](https://docs.gunicorn.org/en/stable/deploy.html#nginx-configuration).'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还建议*将 Gunicorn 放在 HTTP 代理后面*，而不是直接将其暴露在前端。其作用是处理 SSL 连接、执行负载均衡，并提供静态文件，如图片或文档。Gunicorn
    文档建议使用 nginx 来完成此任务，并提供了基本的配置：[https://docs.gunicorn.org/en/stable/deploy.html#nginx-configuration](https://docs.gunicorn.org/en/stable/deploy.html#nginx-configuration)。
- en: 'As you can see, in this context, there are quite a lot of configurations and
    decisions to make regarding your server configuration. Of course, you should also
    pay attention to security and make sure your server is well protected against
    the usual attacks. In the following DigitalOcean tutorial, you’ll find some guidelines
    for securing your server: [https://www.digitalocean.com/community/tutorials/recommended-security-measures-to-protect-your-servers](https://www.digitalocean.com/community/tutorials/recommended-security-measures-to-protect-your-servers).'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，在这种情况下，你需要做出许多关于服务器配置的决定。当然，你还应该注意安全，确保你的服务器能够有效防范常见攻击。在以下的 DigitalOcean
    教程中，你将找到一些保护服务器安全的指导原则：[https://www.digitalocean.com/community/tutorials/recommended-security-measures-to-protect-your-servers](https://www.digitalocean.com/community/tutorials/recommended-security-measures-to-protect-your-servers)。
- en: 'If you’re not an experienced system administrator, we recommend that you favor
    serverless platforms; professional teams handle security, system updates, and
    server scalability for you, letting you focus on what matters most to you: developing
    a great application!'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不是经验丰富的系统管理员，我们建议你优先选择无服务器平台；专业团队会为你处理安全性、系统更新和服务器可扩展性，让你可以专注于最重要的事情：开发出色的应用程序！
- en: Summary
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'Your application is now live on the web! In this chapter, we covered the best
    practices to apply before deploying your application to production: use environment
    variables to set configuration options, such as database URLs, and manage your
    Python dependencies with a `requirements.txt` file. Then, we showed you how to
    deploy your application to a serverless platform, which handles everything for
    you by retrieving your source code, packaging it with its dependencies, and serving
    it on the web. Next, you learned how to build a Docker image for FastAPI using
    the base image created by the creator of FastAPI. As you saw, it allows you to
    be flexible while configuring the system, but you can still deploy it in a few
    minutes with a serverless platform that’s compatible with containers. Finally,
    we provided you with some guidelines for manual deployment on a traditional Linux
    server.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 你的应用程序现在已经上线！在本章中，我们介绍了在将应用程序部署到生产环境之前应该应用的最佳实践：使用环境变量设置配置选项，如数据库 URL，并通过 `requirements.txt`
    文件管理 Python 依赖。然后，我们展示了如何将应用程序部署到无服务器平台，这个平台会为你处理一切，包括获取源代码、打包依赖项并将其提供给用户。接下来，你学习了如何使用
    FastAPI 的创建者提供的基础镜像构建 Docker 镜像。正如你所看到的，这样可以灵活配置系统，但你依然可以在几分钟内通过支持容器的无服务器平台完成部署。最后，我们为你提供了一些在传统
    Linux 服务器上手动部署的指导原则。
- en: This marks the end of the second part of this book. You should now be confident
    in writing efficient, reliable FastAPI applications and be able to deploy them
    on the web.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这标志着本书第二部分的结束。现在你应该对编写高效、可靠的 FastAPI 应用程序充满信心，并能够将其部署到互联网上。
- en: In the next chapter, we will begin some data science tasks and integrate them
    efficiently into a FastAPI project.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始一些数据科学任务，并将它们高效地集成到 FastAPI 项目中。
