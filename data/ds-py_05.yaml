- en: Chapter 5. Python and PixieDust Best Practices and Advanced Concepts
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第五章：Python和PixieDust最佳实践与高级概念
- en: '"In God we Trust, all others bring data."'
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “我们信仰上帝，其他的都带上数据。”
- en: – *W. Edwards Deming*
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: – *W. Edwards Deming*
- en: 'In the remaining chapters of this book, we will do a deep dive into the architecture
    of industry use cases, including the implementation of sample data pipelines,
    heavily applying the techniques we''ve learned so far. Before we start looking
    at the code, let''s complete our toolbox with a few best practices and advanced
    PixieDust concepts that will be useful in the implementation of our sample applications:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的剩余章节中，我们将深入探讨行业用例的架构，包括示范数据管道的实现，广泛应用我们到目前为止学到的技术。在开始查看代码之前，让我们通过一些最佳实践和高级PixieDust概念来完善我们的工具箱，这些将有助于我们实现示例应用：
- en: Calling third-party Python libraries with `@captureOutput` decorator
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`@captureOutput`装饰器调用第三方Python库
- en: Increasing modularity and code reuse of your PixieApp
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提高PixieApp的模块化和代码复用性
- en: PixieDust support of streaming data
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PixieDust对流数据的支持
- en: Adding dashboard drill-downs with PixieApp events
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用PixieApp事件添加仪表盘钻取功能
- en: Extending PixieDust with a custom display renderer
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用自定义显示渲染器扩展PixieDust
- en: 'Debugging:'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试：
- en: Line-by-line Python code debugging running on the Jupyter Notebook using pdb
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用pdb调试在Jupyter Notebook中运行的逐行Python代码
- en: Visual debugging with PixieDebugger
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用PixieDebugger进行可视化调试
- en: Using the PixieDust logging framework to troubleshoot issues
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用PixieDust日志框架排查问题
- en: Tips for client-side JavaScript debugging
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端JavaScript调试技巧
- en: Running Node.js inside a Python Notebook
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Python Notebook中运行Node.js
- en: Use @captureOutput decorator to integrate the output of third-party Python libraries
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`@captureOutput`装饰器集成第三方Python库的输出
- en: Suppose that you want to reuse your PixieApp in a third-party library that you
    have been using for a while in order to perform a certain task, such as, for example,
    computing clusters with the scikit-learn machine learning library ([http://scikit-learn.org](http://scikit-learn.org))
    and displaying them as a graph. The problem is that most of the time, you are
    calling a high-level method that doesn't return data, but rather directly draws
    something on the cell output area, such as a chart or a report table. Calling
    this method from a PixieApp route will not work because the contract for routes
    is to return an HTML fragment string that will be processed by the framework.
    In this case, the method most likely doesn't return anything since it is writing
    the results directly in the cell output. The solution is to use the `@captureOutput`
    decorator—which is part of the PixieApp framework—in the route method.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你希望将自己的PixieApp在已经使用一段时间的第三方库中复用，以执行某个任务，例如，使用scikit-learn机器学习库([http://scikit-learn.org](http://scikit-learn.org))进行集群计算并将其作为图形显示。问题是，大多数情况下，你调用的是一个高级方法，它并不会返回数据，而是直接在单元格输出区域绘制某些内容，比如图表或报告表格。从PixieApp路由调用此方法将不起作用，因为路由的合同要求返回一个HTML片段字符串，该字符串将由框架处理。在这种情况下，该方法很可能没有返回任何内容，因为它将结果直接写入单元格输出区域。解决方案是在路由方法中使用`@captureOutput`装饰器——这是PixieApp框架的一部分。
- en: Create a word cloud image with @captureOutput
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用@captureOutput创建词云图像
- en: To better illustrate the `@captureOutput` scenario described earlier, let's
    take a concrete example where we want to build a PixieApp that uses the `wordcloud`
    Python library ([https://pypi.python.org/pypi/wordcloud](https://pypi.python.org/pypi/wordcloud))
    to generate a word cloud image from a text file provided by the user via a URL.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地说明前面描述的`@captureOutput`场景，让我们以一个具体示例为例，在这个示例中，我们想要构建一个PixieApp，使用`wordcloud`
    Python库([https://pypi.python.org/pypi/wordcloud](https://pypi.python.org/pypi/wordcloud))从用户通过URL提供的文本文件生成词云图像。
- en: 'We first install the `wordcloud` library by running the following command in its own cell:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先通过在自己的单元格中运行以下命令来安装`wordcloud`库：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Note**: Make sure to restart the kernel when the installation of the `wordcloud`
    library is complete.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：确保在安装完`wordcloud`库后重新启动内核。'
- en: 'The code for the PixieApp looks like this:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: PixieApp的代码如下所示：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code here:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode1.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode1.py)'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode1.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode1.py)'
- en: 'Notice that by simply adding the `@captureOutput` decorator to the `generate_word_cloud`
    route, we don''t need to return an HTML fragment string any more. We can simply
    invoke the Matplotlib `imshow()` function that sends the image to the system output.
    The PixieApp framework will take care of capturing the output and package it as
    an HTML fragment string that will be injected in the correct div placeholder.
    The result is as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，通过简单地在 `generate_word_cloud` 路由上添加 `@captureOutput` 装饰器，我们不再需要返回 HTML 片段字符串。我们可以直接调用
    Matplotlib 的 `imshow()` 函数，将图像发送到系统输出。PixieApp 框架将负责捕获输出，并将其打包为 HTML 片段字符串，然后注入到正确的
    div 占位符中。结果如下：
- en: Note
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Note**: We use the following input URL coming from the `wordcloud` repo on
    GitHub:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：我们使用以下来自 GitHub 上 `wordcloud` 仓库的输入 URL：'
- en: '[https://github.com/amueller/word_cloud/blob/master/examples/constitution.txt](https://github.com/amueller/word_cloud/blob/master/examples/constitution.txt)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/amueller/word_cloud/blob/master/examples/constitution.txt](https://github.com/amueller/word_cloud/blob/master/examples/constitution.txt)'
- en: Note
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Another good link to use is:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可以使用的好链接是：
- en: '[https://raw.githubusercontent.com/amueller/word_cloud/master/examples/a_new_hope.txt](https://raw.githubusercontent.com/amueller/word_cloud/master/examples/a_new_hope.txt)'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://raw.githubusercontent.com/amueller/word_cloud/master/examples/a_new_hope.txt](https://raw.githubusercontent.com/amueller/word_cloud/master/examples/a_new_hope.txt)'
- en: '![Create a word cloud image with @captureOutput](img/B09699_05_01.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![使用 @captureOutput 创建词云图像](img/B09699_05_01.jpg)'
- en: Simple PixieApp that generates a word cloud from a text
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的 PixieApp，生成来自文本的词云
- en: 'Any function that draws directly to the cell output can be used with the `@captureOutput`
    decorator. For example, you can use the Matplotlib `show()` method or the IPython
    `display()` method with the HTML or JavaScript classes. You can even use the `display_markdown()`
    method to output rich text using the Markdown markup language ([https://en.wikipedia.org/wiki/Markdown](https://en.wikipedia.org/wiki/Markdown))
    as shown in the following code:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 任何直接绘制到单元格输出的函数都可以与 `@captureOutput` 装饰器一起使用。例如，你可以使用 Matplotlib 的 `show()`
    方法或 IPython 的 `display()` 方法与 HTML 或 JavaScript 类一起使用。你甚至可以使用 `display_markdown()`
    方法，通过 Markdown 标记语言输出富文本，如下代码所示：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This produces the following result:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下结果：
- en: '![Create a word cloud image with @captureOutput](img/B09699_05_02.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![使用 @captureOutput 创建词云图像](img/B09699_05_02.jpg)'
- en: PixieApp using @captureOutput with Markdown
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: PixieApp 使用 @captureOutput 与 Markdown
- en: Increase modularity and code reuse
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 增加模块化和代码重用性
- en: 'Breaking up your application into smaller, self-contained components is always
    a good development practice because it makes the code reusable and easier to maintain.
    The PixieApp framework provides two ways to create and run reusable components:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 将你的应用程序拆分为较小的、自包含的组件始终是一种良好的开发实践，因为这样可以使代码更具可重用性，并且更易于维护。PixieApp 框架提供了两种创建和运行可重用组件的方法：
- en: Dynamically invoking other PixieApps with the `pd_app` attribute
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态调用其他 PixieApp 使用 `pd_app` 属性
- en: Packaging part of an application as a reusable widget
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将应用程序的一部分打包为可重用的小部件
- en: Using the `pd_app` attribute, you can dynamically invoke another PixieApp (we'll
    call it child PixieApp from here on) by its fully qualified class name. The output
    of the child PixieApp is placed in the host HTML element (usually a div element)
    or in a dialog by using the `runInDialog=true` option. You can also initialize
    the child PixieApp using the `pd_options` attribute, in which case the framework
    will invoke the corresponding route.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `pd_app` 属性，你可以通过完全限定的类名动态调用另一个 PixieApp（从现在开始我们称之为子 PixieApp）。子 PixieApp
    的输出将放置在宿主 HTML 元素（通常是一个 div 元素）中，或者通过使用 `runInDialog=true` 选项放入对话框中。你还可以使用 `pd_options`
    属性初始化子 PixieApp，在这种情况下，框架将调用相应的路由。
- en: To better understand how `pd_app` works, let's rewrite our `WordCloud` application
    by refactoring the code that generates the `WordCloud` image in its own PixieApp
    that we'll call `WCChildApp`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解 `pd_app` 的工作原理，让我们通过将生成 `WordCloud` 图像的代码重构为其自己的 PixieApp，称为 `WCChildApp`，来重写我们的
    `WordCloud` 应用程序。
- en: 'The following code implements `WCChildApp` as a regular PixieApp, but notice
    that it doesn''t contain a default route. It only has a route called `generate_word_cloud`
    that is supposed to be called by another PixieApp using a `url` argument:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码实现了 `WCChildApp` 作为常规 PixieApp，但请注意，它不包含默认路由。它只有一个名为 `generate_word_cloud`
    的路由，应该由另一个 PixieApp 使用 `url` 参数来调用：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode2.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode2.py)'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode2.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode2.py)'
- en: 'We can now build the main PixieApp that will invoke the `WCChildApp` when the
    user clicks on the **Go** button after specifying the URL:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以构建主PixieApp，当用户指定URL后点击**Go**按钮时，它将调用`WCChildApp`：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode3.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode3.py)'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode3.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode3.py)'
- en: 'In the preceding code, the `Go` button has the following attributes:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，`Go`按钮具有以下属性：
- en: '`pd_app="WCChildApp"`: Use the class name for the child PixieApp. Note that
    if your child PixieApp lives in an imported Python module, then you''ll need to
    use the fully qualified name.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pd_app="WCChildApp"`：使用子PixieApp的类名。请注意，如果你的子PixieApp位于一个导入的Python模块中，那么你需要使用完整限定名。'
- en: '`pd_options="url=$val(url{{prefix}})"`: Store the URL entered by the user as
    an initialization option to the child PixieApp.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pd_options="url=$val(url{{prefix}})"`：将用户输入的URL作为子PixieApp的初始化选项进行存储。'
- en: '`pd_target="wordcloud{{prefix}}"`: Tell PixieDust to place the output of the
    child PixieApp in the div with the ID `wordcloud{{prefix}}`.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pd_target="wordcloud{{prefix}}"`：告诉PixieDust将子PixieApp的输出放置在ID为`wordcloud{{prefix}}`的div中。'
- en: The `pd_app` attribute is a powerful way to modularize your code by encapsulating
    the logic and presentation of a component. The `pd_widget` attribute provides
    another way to achieve similar results, but this time the component is not invoked
    externally, but rather by inheritance.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`pd_app`属性是通过封装组件的逻辑和展示来模块化代码的强大方式。`pd_widget`属性提供了另一种实现类似结果的方式，不过这次组件不是由外部调用，而是通过继承来调用。'
- en: 'Each method has pros and cons:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 每种方法都有其优缺点：
- en: The `pd_widget` technique is implemented as a route and is certainly more lightweight
    than `pd_app,` which requires the creation of an entirely new PixieApp instance.
    Note that both `pd_widget` and `pd_app` (through the `parent_pixieapp` variable)
    have access to all variables contained in the host app.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pd_widget`技术作为一个路由实现，肯定比`pd_app`更加轻量化，因为`pd_app`需要创建一个全新的PixieApp实例。请注意，`pd_widget`和`pd_app`（通过`parent_pixieapp`变量）都可以访问宿主应用程序中的所有变量。'
- en: The `pd_app` attribute provides a cleaner separation between the components
    and more flexibility than widgets. You could, for example, have a button that
    dynamically invokes multiple PixieApps based on some user selection.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pd_app`属性提供了更清晰的组件分离，并且比小部件具有更多灵活性。例如，你可以有一个按钮，根据某些用户选择动态调用多个PixieApps。'
- en: Note
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Note**: As we''ll see later in this chapter, this is actually what the PixieDust
    display uses for the options dialog.'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**注意**：正如我们将在本章后面看到的，这实际上就是PixieDust显示选项对话框时使用的方式。'
- en: If you find yourself in need of having multiple copies of the same component
    in a PixieApp, ask yourself whether the component requires its state to be maintained
    in a class variable. If that's the case, it is preferable to use `pd_app,` but,
    if not, then using `pd_widget` would work as well.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现自己需要在PixieApp中有多个相同组件的副本，请问问自己该组件是否需要将其状态保持在类变量中。如果是这样，最好使用`pd_app`，如果不是，那么使用`pd_widget`也可以。
- en: Creating a widget with pd_widget
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`pd_widget`创建小部件
- en: 'To create a widget, you can use the following steps:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 创建小部件可以按照以下步骤进行：
- en: Create a PixieApp class that contains a route tagged with a special argument
    called `widget`
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个PixieApp类，该类包含一个带有特殊参数`widget`的路由
- en: Make the main class inherit from the PixieApp widget
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使主类继承自PixieApp小部件
- en: Invoke the widget using the `pd_widget` attribute on a div element
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`pd_widget`属性在div元素中调用小部件
- en: 'Again, as an illustration, let''s rewrite the `WordCloud` app with the widget:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 再次举例说明，让我们用小部件重写`WordCloud`应用程序：
- en: '[PRE5]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode4.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode4.py)'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode4.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode4.py)'
- en: Notice in the preceding code that `url` is now referenced as a class variable
    because we assume that the base class will provide it. The code has to test whether
    `url` is `None,` which would be the case on startup. We implement it this way
    because `pd_widget` is an attribute that cannot easily be dynamically generated
    (you would have to use a secondary route that generates the div fragment with
    the `pd_widget` attribute).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 注意前面的代码中，`url` 现在被引用为一个类变量，因为我们假设基类会提供它。代码必须测试 `url` 是否为 `None`，因为在启动时，它的值正是
    `None`。我们之所以这样实现，是因为 `pd_widget` 是一个无法轻松动态生成的属性（你需要使用一种二级途径来生成带有 `pd_widget` 属性的
    div 片段）。
- en: 'The main PixieApp class now looks like this:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在主要的 PixieApp 类看起来是这样的：
- en: '[PRE6]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode5.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode5.py)'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode5.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode5.py)'
- en: The div that contains the `pd_widget` attribute is rendered on start, but since
    `url` is still `None`, no word cloud is actually generated. The `Go` button has
    a `pd_script` attribute that set the `self.url` to the value provided by the user.
    It also has a `pd_refresh` attribute sets to the `pd_widget` div that will call
    the `wordcloud` widget again, but this time with a URL initialized to the correct
    value.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 包含 `pd_widget` 属性的 div 在启动时被渲染出来，但由于 `url` 仍然是 `None`，因此实际上并没有生成词云。`Go` 按钮有一个
    `pd_script` 属性，该属性将 `self.url` 设置为用户提供的值。它还有一个 `pd_refresh` 属性，该属性设置为 `pd_widget`
    div，这将再次调用 `wordcloud` 小部件，但这一次 URL 会被初始化为正确的值。
- en: In this section, we've seen two ways to modularize your code for reuse, as well
    as the pros and cons for both. I strongly recommend that you play with the code
    to get a feel of when to use each technique. Don't worry if you feel this is still
    a little fuzzy; it will hopefully become clearer when we use these techniques
    in the sample code of the chapters ahead.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我们已经看到了两种将代码模块化以便重用的方法，以及它们各自的优缺点。我强烈建议你自己动手实验这些代码，感受一下在何时使用每种技巧。如果你觉得这部分内容还是有些模糊，不用担心；希望在接下来的章节中使用这些技巧时，它会变得更加清晰。
- en: In the next section, we change gears and look at streaming data support in PixieDust.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将转向并研究 PixieDust 中的流式数据支持。
- en: PixieDust support of streaming data
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PixieDust 对流式数据的支持
- en: With the rise of **IOT** devices (**Internet of Things**), being able to analyze
    and visualize live streams of data is becoming more and more important. For example,
    you could have sensors such as thermometers in machines or portable medical devices
    like pacemakers, continuously streaming data to a streaming service such as Kafka.
    PixieDust makes it easier to work with live data inside Jupyter Notebooks by providing
    simple integration APIs to both the PixieApp and the `display()` framework.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 随着**物联网**（**Internet of Things**）设备的兴起，能够分析和可视化实时数据流变得越来越重要。例如，你可以有像温度计这样的传感器，或者像心脏起搏器这样的便携式医疗设备，持续地将数据流传输到像
    Kafka 这样的流式服务中。PixieDust 通过提供简单的集成 API，简化了在 Jupyter Notebook 中与实时数据的交互，使得 `PixieApp`
    和 `display()` 框架的集成更加便捷。
- en: On a visualization level, PixieDust uses Bokeh ([https://bokeh.pydata.org](https://bokeh.pydata.org))
    support for efficient data source updates to plot streaming data into live charts
    (note that at the moment, only line chart and scatter plot are supported, but
    more will be added in the future). The `display()` framework also supports geospatial
    visualization of streaming data using the Mapbox rendering engine.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在可视化层面，PixieDust 使用 Bokeh ([https://bokeh.pydata.org](https://bokeh.pydata.org))
    支持高效的数据源更新，将流式数据绘制到实时图表中（请注意，目前仅支持折线图和散点图，但未来会添加更多图表类型）。`display()` 框架还支持使用 Mapbox
    渲染引擎进行流式数据的地理空间可视化。
- en: To activate streaming visualizations, you need to use a class that inherits
    from `StreamingDataAdapter,` which is an abstract class that is part of the PixieDust
    API. This class acts as a generic bridge between the streaming data source and
    the visualization framework.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用流式可视化，你需要使用一个继承自 `StreamingDataAdapter` 的类，这是 PixieDust API 中的一个抽象类。这个类充当了流式数据源和可视化框架之间的通用桥梁。
- en: Note
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Note**: I recommend spending time looking at the code for `StreamingDataAdapter`
    here:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：我建议你花些时间查看这里的 `StreamingDataAdapter` 代码：'
- en: '[https://github.com/pixiedust/pixiedust/blob/0c536b45c9af681a4da160170d38879298aa87cb/pixiedust/display/streaming/__init__.py](https://github.com/pixiedust/pixiedust/blob/0c536b45c9af681a4da160170d38879298aa87cb/pixiedust/display/streaming/__init__.py)'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/pixiedust/pixiedust/blob/0c536b45c9af681a4da160170d38879298aa87cb/pixiedust/display/streaming/__init__.py](https://github.com/pixiedust/pixiedust/blob/0c536b45c9af681a4da160170d38879298aa87cb/pixiedust/display/streaming/__init__.py)'
- en: 'The following diagram shows how the `StreamingDataAdapter` data structure fits
    into the `display()` framework:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了`StreamingDataAdapter`数据结构如何融入`display()`框架：
- en: '![PixieDust support of streaming data](img/B09699_05_03.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![PixieDust 支持流数据](img/B09699_05_03.jpg)'
- en: StreamingDataAdapter architecture
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: StreamingDataAdapter 架构
- en: When implementing a subclass of `StreamingDataAdapter`, you must override the
    `doGetNextData()` method provided by the base class, which will be called repeatedly
    to fetch new data to update the visualization. You can also optionally override
    the `getMetadata()` method to pass context to the rendering engine (we'll use
    this method later to configure the Mapbox rendering).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现`StreamingDataAdapter`的子类时，必须重写基类提供的`doGetNextData()`方法，该方法会被重复调用以获取新数据并更新可视化。你还可以选择性地重写`getMetadata()`方法，将上下文传递给渲染引擎（稍后我们将使用此方法配置
    Mapbox 渲染）。
- en: 'The abstract implementation of `doGetNextData()` looks like this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`doGetNextData()`的抽象实现如下：'
- en: '[PRE7]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode6.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode6.py)'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode6.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode6.py)'
- en: The preceding docstring explains the different types of data that is allowed
    to be returned from `doGetNextData()`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的文档字符串解释了`doGetNextData()`方法允许返回的不同类型的数据。
- en: 'As an example, we want to visualize the location of a fictitious drone wandering
    around the earth on a map and in real time. Its current location is provided by a REST
    service at: [https://wanderdrone.appspot.com](https://wanderdrone.appspot.com).'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个示例，我们希望可视化一个虚构无人机在地图上实时地绕地球游荡的位置。其当前位置由一个 REST 服务提供，网址为：[https://wanderdrone.appspot.com](https://wanderdrone.appspot.com)。
- en: 'The payload uses GeoJSON ([http://geojson.org](http://geojson.org)), for example:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 负载使用 GeoJSON（[http://geojson.org](http://geojson.org)），例如：
- en: '[PRE8]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode7.json](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode7.json)'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode7.json](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode7.json)'
- en: 'To render our drone location in real time, we create a `DroneStreamingAdapter`
    class that inherits from `StreamingDataAdapter` and simply return the drone location
    service URL in the `doGetNextData()` method as shown in the following code:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实时渲染我们的无人机位置，我们创建了一个`DroneStreamingAdapter`类，继承自`StreamingDataAdapter`，并在`doGetNextData()`方法中返回无人机位置服务的
    URL，如下代码所示：
- en: '[PRE9]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode8.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode8.py)'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode8.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode8.py)'
- en: 'In the `getMetadata()` method, we return the Mapbox specific style properties
    (as documented here: [https://www.mapbox.com/mapbox-gl-js/style-spec](https://www.mapbox.com/mapbox-gl-js/style-spec))
    that uses a rocket Maki icon ([https://www.mapbox.com/maki-icons](https://www.mapbox.com/maki-icons))
    as a symbol for the drone.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在`getMetadata()`方法中，我们返回了特定于 Mapbox 的样式属性（如文档中所述：[https://www.mapbox.com/mapbox-gl-js/style-spec](https://www.mapbox.com/mapbox-gl-js/style-spec)），该样式使用火箭
    Maki 图标（[https://www.mapbox.com/maki-icons](https://www.mapbox.com/maki-icons)）作为无人机的符号。
- en: 'With a few lines of code, we were able to create a real-time geospatial visualization
    of a drone location, with the following results:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 通过几行代码，我们能够创建一个实时的无人机位置地理空间可视化，结果如下：
- en: '![PixieDust support of streaming data](img/B09699_05_04.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![PixieDust 支持流数据](img/B09699_05_04.jpg)'
- en: Real-time geospatial mapping of a drone
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 无人机的实时地理空间映射
- en: Note
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the complete Notebook for this example in the PixieDust repo at
    this location:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 PixieDust 仓库的以下位置找到此示例的完整笔记本：
- en: '[https://github.com/pixiedust/pixiedust/blob/master/notebook/pixieapp-streaming/Mapbox%20Streaming.ipynb](https://github.com/pixiedust/pixiedust/blob/master/notebook/pixieapp-streaming/Mapbox%20Streaming.ipynb)'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/pixiedust/pixiedust/blob/master/notebook/pixieapp-streaming/Mapbox%20Streaming.ipynb](https://github.com/pixiedust/pixiedust/blob/master/notebook/pixieapp-streaming/Mapbox%20Streaming.ipynb)'
- en: Adding streaming capabilities to your PixieApp
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将流媒体功能添加到您的 PixieApp
- en: 'In the next example, we show how to visualize streaming data coming from an
    Apache Kafka data source, using the `MessageHubStreamingApp` PixieApp provided
    out of the box by PixieDust: [https://github.com/pixiedust/pixiedust/blob/master/pixiedust/apps/messageHub/messageHubApp.py](https://github.com/pixiedust/pixiedust/blob/master/pixiedust/apps/messageHub/messageHubApp.py).'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，我们展示如何使用 PixieDust 提供的开箱即用的 `MessageHubStreamingApp` PixieApp 来可视化来自
    Apache Kafka 数据源的流数据：[https://github.com/pixiedust/pixiedust/blob/master/pixiedust/apps/messageHub/messageHubApp.py](https://github.com/pixiedust/pixiedust/blob/master/pixiedust/apps/messageHub/messageHubApp.py)。
- en: Note
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Note**: `MessageHubStreamingApp` works with the IBM Cloud Kafka service called
    Message Hub ([https://console.bluemix.net/docs/services/MessageHub/index.html#messagehub](https://console.bluemix.net/docs/services/MessageHub/index.html#messagehub)),
    but it can easily be adapted to any other Kafka service.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：`MessageHubStreamingApp` 与 IBM Cloud Kafka 服务 Message Hub（[https://console.bluemix.net/docs/services/MessageHub/index.html#messagehub](https://console.bluemix.net/docs/services/MessageHub/index.html#messagehub)）一起使用，但它可以很容易地适配任何其他
    Kafka 服务。'
- en: 'Don''t worry if you are not familiar with Apache Kafka as we''ll cover aspects
    of this in [Chapter 7](ch07.xhtml "Chapter 7. Analytics Study: NLP and Big Data
    with Twitter Sentiment Analysis"), *Analytics Study: NLP and Big Data with Twitter
    Sentiment Analysis*.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不熟悉 Apache Kafka，不用担心，我们将在[第 7 章](ch07.xhtml "第 7 章：分析研究：使用 Twitter 情感分析的
    NLP 和大数据")中介绍相关内容，*分析研究：使用 Twitter 情感分析的 NLP 和大数据*。
- en: This PixieApp lets the user choose a Kafka topic associated with a service instance
    and display the events in real-time. Assuming that the events payload from the
    selected topic uses a JSON format, it presents a schema inferred from sampling
    the events data. The user can then choose a particular field (must be numerical)
    and a real-time chart showing the average of the values for this field over time
    is displayed.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 该 PixieApp 允许用户选择与服务实例关联的 Kafka 主题，并实时显示事件。假设所选主题的事件有效负载使用 JSON 格式，它会展示从事件数据采样推断出的模式。用户随后可以选择一个特定字段（必须是数值型），并显示该字段随时间变化的平均值的实时图表。
- en: '![Adding streaming capabilities to your PixieApp](img/B09699_05_05.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![将流媒体功能添加到您的 PixieApp](img/B09699_05_05.jpg)'
- en: Real-time visualization of streaming data
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 流媒体数据的实时可视化
- en: 'The key PixieApp attribute needed to provide streaming capabilities is `pd_refresh_rate,`
    which executes a particular kernel request at specified intervals (pull model).
    In the preceding application, we use it to update the real-time chart, as shown
    in the following HTML fragment returned by the `showChart` route:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 提供流媒体功能的关键 PixieApp 属性是 `pd_refresh_rate,` 它在指定的间隔执行特定的内核请求（拉取模型）。在前面的应用中，我们使用它来更新实时图表，如下所示，由
    `showChart` 路由返回的 HTML 片段：
- en: '[PRE10]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode9.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode9.py)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode9.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode9.py)'
- en: The preceding div is bound to the `avgChannelData` entity via the `pd_entity`
    attribute and is responsible for creating the real-time chart that is updated
    every second (*pd_refresh_rate=1000 ms*). In turn, the `avgChannelData` entity
    is created via a call to `getStreamingChannel(),` which is passed to the `self`.
    The `computeAverage` function is responsible for updating the average value for
    all the data being streamed. It is important to note that `avgChannelData` is
    a class that inherits from `StreamingDataAdapter` and, therefore, can be passed
    to the `display()` framework for building real-time charts.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 上述 div 通过 `pd_entity` 属性与 `avgChannelData` 实体绑定，并负责创建每秒更新的实时图表（*pd_refresh_rate=1000
    ms*）。反过来，`avgChannelData` 实体通过调用 `getStreamingChannel(),` 创建，并传递给 `self`。`computeAverage`
    函数负责更新所有流数据的平均值。需要注意的是，`avgChannelData` 是一个继承自 `StreamingDataAdapter` 的类，因此可以传递给
    `display()` 框架，用于构建实时图表。
- en: 'The last piece of the puzzle is for the PixieApp to return a `displayHandler`
    needed by the `display()` framework. This is done by overriding the `newDisplayHandler()`
    method as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是让PixieApp返回`displayHandler`，这是`display()`框架所需要的。可以通过如下方式重写`newDisplayHandler()`方法来实现：
- en: '[PRE11]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode10.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode10.py)'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode10.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode10.py)'
- en: In the preceding code, we use it to create an instance of `LineChartStreamingDisplay`
    provided by PixieDust in the `pixiedust.display.streaming.bokeh` package ([https://github.com/pixiedust/pixiedust/blob/master/pixiedust/display/streaming/bokeh/lineChartStreamingDisplay.py](https://github.com/pixiedust/pixiedust/blob/master/pixiedust/display/streaming/bokeh/lineChartStreamingDisplay.py)),
    passing the `avgChannelData` entity.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用它创建了一个由PixieDust提供的`LineChartStreamingDisplay`实例，该实例位于`pixiedust.display.streaming.bokeh`包中（[https://github.com/pixiedust/pixiedust/blob/master/pixiedust/display/streaming/bokeh/lineChartStreamingDisplay.py](https://github.com/pixiedust/pixiedust/blob/master/pixiedust/display/streaming/bokeh/lineChartStreamingDisplay.py)），并传入了`avgChannelData`实体。
- en: 'If you want to see this application in action, you need to create a Message
    Hub service instance on IBM Cloud ([https://console.bluemix.net/catalog/services/message-hub](https://console.bluemix.net/catalog/services/message-hub))
    and, using its credentials, invoke this PixieApp in a Notebook with the following
    code:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想看到这个应用的实际效果，你需要在IBM Cloud上创建一个消息中心服务实例（[https://console.bluemix.net/catalog/services/message-hub](https://console.bluemix.net/catalog/services/message-hub)），并使用其凭证在Notebook中调用此PixieApp，代码如下：
- en: '[PRE12]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If you are interested in knowing more about PixieDust streaming, you can find
    other streaming application examples here:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有兴趣了解更多关于PixieDust流媒体的内容，你可以在这里找到其他流媒体应用示例：
- en: 'A simple PixieApp that demonstrate how to create streaming visualizations from
    randomly generated data: [https://github.com/pixiedust/pixiedust/blob/master/notebook/pixieapp-streaming/PixieApp%20Streaming-Random.ipynb](https://github.com/pixiedust/pixiedust/blob/master/notebook/pixieapp-streaming/PixieApp%20Streaming-Random.ipynb)'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个简单的PixieApp示例，演示如何从随机生成的数据创建流媒体可视化：[https://github.com/pixiedust/pixiedust/blob/master/notebook/pixieapp-streaming/PixieApp%20Streaming-Random.ipynb](https://github.com/pixiedust/pixiedust/blob/master/notebook/pixieapp-streaming/PixieApp%20Streaming-Random.ipynb)
- en: 'PixieApp that shows how to build live visualization of stock tickers: [https://github.com/pixiedust/pixiedust/blob/master/notebook/pixieapp-streaming/PixieApp%20Streaming-Stock%20Ticker.ipynb](https://github.com/pixiedust/pixiedust/blob/master/notebook/pixieapp-streaming/PixieApp%20Streaming-Stock%20Ticker.ipynb)'
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示如何构建实时股票行情可视化的PixieApp：[https://github.com/pixiedust/pixiedust/blob/master/notebook/pixieapp-streaming/PixieApp%20Streaming-Stock%20Ticker.ipynb](https://github.com/pixiedust/pixiedust/blob/master/notebook/pixieapp-streaming/PixieApp%20Streaming-Stock%20Ticker.ipynb)
- en: The next topic will cover PixieApp events that let you add interactivity between
    different components of your application.
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接下来的主题将介绍PixieApp事件，它可以让你在应用程序的不同组件之间添加交互性。
- en: Adding dashboard drill-downs with PixieApp events
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用PixieApp事件添加仪表盘钻取功能
- en: The PixieApp framework supports sending and receiving events between different
    components using the publish-subscribe pattern available in browsers. The great
    advantage of using this model, which borrows from the loose coupling pattern ([https://en.wikipedia.org/wiki/Loose_coupling](https://en.wikipedia.org/wiki/Loose_coupling)),
    is that it allows the sending and receiving components to remain agnostic of each
    other. Therefore, their implementation can be executed independently from one
    another and will not be sensitive to changes in requirements. This can be very
    useful when your PixieApp is using components from different PixieApps built by
    different teams, or if the events are coming from the user interacting with a
    chart (for instance, clicking on a map) and you want to provide drill-down features.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: PixieApp框架支持使用浏览器中可用的发布-订阅模式在不同组件之间发送和接收事件。使用这种模式的巨大优势在于，它借鉴了松耦合模式（[https://en.wikipedia.org/wiki/Loose_coupling](https://en.wikipedia.org/wiki/Loose_coupling)），使得发送和接收组件可以彼此独立。这样，它们的实现可以相互独立执行，并且不受需求变化的影响。这在你的PixieApp使用来自不同团队的不同PixieApp组件时非常有用，或者当事件来自用户与图表交互（例如，点击地图）时，你希望提供钻取功能。
- en: 'Each event carries a JSON payload of arbitrary keys and values. The payload
    must have at least one of the following keys (or both):'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 每个事件都携带一个包含任意键值对的JSON负载。负载必须至少包含以下一个键（或两者）：
- en: '`targetDivId`: A DOM ID identifying the element sending the event'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`targetDivId`：标识发送事件元素的DOM ID'
- en: '`type`: A string identifying the event type'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type`：标识事件类型的字符串'
- en: 'Publishers can trigger events in two ways:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 发布者可以通过两种方式触发事件：
- en: '**Declarative**: Use the `pd_event_payload` attribute to specify the payload
    content. This attribute follows the same rules as `pd_options`:'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**声明式**：使用`pd_event_payload`属性来指定负载内容。该属性遵循与`pd_options`相同的规则：'
- en: Each key/value pair must be encoded using the `key=value` notation
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个键值对必须使用`key=value`的表示法进行编码
- en: The event will be triggered by a click or a change event
  id: totrans-157
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件将由点击或变化事件触发
- en: Support must be provided for the `$val()` directive to dynamically inject user-entered
    input
  id: totrans-158
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须支持`$val()`指令，以动态注入用户输入的内容
- en: Use the `<pd_event_payload>` child to enter raw JSON
  id: totrans-159
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`<pd_event_payload>`子元素输入原始JSON
- en: '[PRE13]'
  id: totrans-160
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-161
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Example:'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 示例：
- en: 'Alternatively, we can use this:'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 或者，我们可以使用以下方法：
- en: Note
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode11.html](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode11.html)'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode11.html](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode11.html)'
- en: '**Programmatic**: In some cases, you may want to directly trigger an event
    via JavaScript. In this case, you can use the `sendEvent(payload, divId)` method
    of the `pixiedust` global object. The `divId` is an optional argument that specifies
    the origin of the event. If the `divId` argument is omitted, then it defaults
    to the `divId` of the element that is currently sending the event. As a result,
    you should always use `pixiedust.sendEvent` without a `divId` from a JavaScript
    handler of a user event such as click, and hover.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编程式**：在某些情况下，你可能想通过JavaScript直接触发事件。在这种情况下，你可以使用`pixiedust`全局对象的`sendEvent(payload,
    divId)`方法。`divId`是一个可选参数，指定事件的来源。如果省略`divId`参数，则默认为当前发送事件的元素的`divId`。因此，通常情况下，你应使用`pixiedust.sendEvent`而不带`divId`，来自用户事件的JavaScript处理程序，例如点击和悬停。'
- en: 'Example:'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 示例：
- en: '[PRE15]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode12.html](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode12.html)'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode12.html](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode12.html)'
- en: 'Subscribers can listen to an event by declaring a `<pd_event_handler>` element
    that can accept any of the PixieApp Kernel execution attributes, such as `pd_options`
    and `pd_script`. It must also use the `pd_source` attribute to filter which events
    they want to process. The `pd_source` attribute can contain one of the following
    values:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 订阅者可以通过声明一个`<pd_event_handler>`元素来监听事件，该元素可以接受PixieApp内核执行属性中的任何一个，如`pd_options`和`pd_script`。它还必须使用`pd_source`属性来筛选它们想要处理的事件。`pd_source`属性可以包含以下值之一：
- en: '`targetDivId`: Only events originating from the element with the specified
    ID will be accepted'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`targetDivId`：只接受来自指定ID元素的事件'
- en: '`type`: Only events with the specified type will be accepted'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type`：只有指定类型的事件才会被接受'
- en: '`"*"`: Denotes that any event will be accepted'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"*"`：表示接受任何事件'
- en: 'Example:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：
- en: '[PRE16]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode13.html](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode13.html)'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode13.html](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode13.html)'
- en: 'The following diagram shows how components interact with one another:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了组件如何相互交互：
- en: '![Adding dashboard drill-downs with PixieApp events](img/B09699_05_06.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![使用PixieApp事件添加仪表板下钻功能](img/B09699_05_06.jpg)'
- en: Sending/receiving events between components
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 组件之间的事件发送/接收
- en: 'In the following code sample, we illustrate the PixieDust eventing system by building
    two publishers, a button element and a table, where each row is an event source.
    We also have two listeners implemented as div elements:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码示例中，我们通过构建两个发布者，一个按钮元素和一个表格来说明PixieDust事件系统，其中每一行都是一个事件源。我们还有两个监听器，作为div元素实现：
- en: '[PRE17]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode14.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode14.py)'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode14.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode14.py)'
- en: 'The preceding code produces the following results:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码会生成以下结果：
- en: '![Adding dashboard drill-downs with PixieApp events](img/B09699_05_07.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![使用 PixieApp 事件添加仪表板钻取功能](img/B09699_05_07.jpg)'
- en: User interaction flow for PixieApp events
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: PixieApp 事件的用户交互流程
- en: PixieApp events enable you to create sophisticated dashboards with drill-down
    capabilities. It is also good to know that you can leverage events that are automatically
    published for some of the charts generated by the `display()` framework. For example,
    built-in renderers, such as Google Maps, Mapbox, and Table, will automatically
    generate events when the user clicks somewhere on the chart. This is very useful
    for rapidly building all kinds of interactive dashboards with drill-down capabilities.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: PixieApp 事件使你能够创建具有钻取功能的复杂仪表板。还要知道，你可以利用 `display()` 框架为某些图表自动发布的事件。例如，内置渲染器（如
    Google Maps、Mapbox 和 Table）将在用户点击图表上的某个地方时自动生成事件。这对于快速构建各种具有钻取功能的互动仪表板非常有用。
- en: In the next topic, we'll discuss how to use the PixieDust extensibility APIs
    to create custom visualizations.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个主题中，我们将讨论如何使用 PixieDust 可扩展性 API 创建自定义可视化。
- en: Extending PixieDust visualizations
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展 PixieDust 可视化
- en: PixieDust is designed to be highly extensible. You can create your own visualization
    and control when it can be invoked, based on the entity being displayed. There
    are multiple extensibility layers provided by the PixieDust framework. The lowest
    and most powerful one lets you create your own `Display` class. However, the majority
    of visualizations have a lot of properties in common, such as standard options (aggregation,
    max rows, title, and so on), or a caching mechanism to prevent recomputing everything
    if the user only selected a minor option that doesn't require reprocessing of
    the data.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: PixieDust 被设计为高度可扩展。你可以创建自己的可视化并控制它何时可以被调用，这取决于正在显示的实体。PixieDust 框架提供了多个可扩展性层。最底层也是最强大的那一层让你创建自己的
    `Display` 类。然而，大多数可视化具有许多共同的属性，例如标准选项（聚合、最大行数、标题等），或者是一个缓存机制，用来防止在用户仅选择了一个不需要重新处理数据的小选项时重新计算所有内容。
- en: To prevent users from reinventing the wheel every time, PixieDust offers a second
    extensibility layer called **renderer** that includes all the facilities described
    here.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止用户每次都从头开始，PixieDust 提供了第二层可扩展性，称为 **renderer**，它包含了这里描述的所有功能。
- en: 'The following diagram illustrates the different layers:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示说明了不同的层级：
- en: '![Extending PixieDust visualizations](img/B09699_05_08.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![扩展 PixieDust 可视化](img/B09699_05_08.jpg)'
- en: PixieDust extension layers
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: PixieDust 扩展层
- en: 'To start working with the **Display Extension Layer**, you''ll need to get
    your visualization presented in the menu by creating a class that inherits from
    `pixiedust.display.DisplayHandlerMeta`. This class contains two methods that need
    to be overridden:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用 **Display 扩展层**，你需要通过创建一个继承自 `pixiedust.display.DisplayHandlerMeta` 的类，将你的可视化显示在菜单中。此类包含两个需要重写的方法：
- en: '`getMenuInfo(self,entity,dataHandler)`: Return an empty array if the entity
    passed as an argument is not supported, otherwise an array containing a set of
    JSON objects with information about the menu. Each JSON object must contain the
    following information:'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getMenuInfo(self,entity,dataHandler)`：如果传入的实体参数不被支持，返回一个空数组，否则返回一个包含一组 JSON
    对象的数组，其中包含菜单信息。每个 JSON 对象必须包含以下信息：'
- en: '`id`: A unique string that identifies your tool.'
  id: totrans-203
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id`：一个唯一的字符串，用于标识你的工具。'
- en: '`categoryId`: A unique string that identifies the menu category or group. A
    full list of all the built-in categories is provided a little later on.'
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`categoryId`：一个唯一的字符串，用于标识菜单类别或组。稍后会提供所有内置类别的完整列表。'
- en: '`title`: An arbitrary string that describes the menu.'
  id: totrans-205
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`title`：一个任意字符串，用于描述菜单。'
- en: '`icon`: The name of a font-awesome icon, or a URL for an image.'
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`icon`：一个字体图标的名称，或者一个图片的 URL。'
- en: '`newDisplayHandler(self,options,entity)`: When your menu is activated by the
    user, the `newDisplayHandler()` method is called. This method must return a class
    instance that inherits from `pixiedust.display.Display`. The contract is for this
    class to implement the `doRender()` method, which is responsible for creating
    the visualization.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`newDisplayHandler(self,options,entity)`：当用户激活菜单时，将调用`newDisplayHandler()`方法。该方法必须返回一个继承自`pixiedust.display.Display`的类实例。要求该类实现`doRender()`方法，该方法负责创建可视化效果。'
- en: 'Let''s take the example of creating a custom table rendering for a pandas DataFrame.
    We first create the `DisplayHandlerMeta` class that configures the menu and the
    factory method:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以为pandas DataFrame创建自定义表格渲染为例。我们首先创建`DisplayHandlerMeta`类来配置菜单和工厂方法：
- en: '[PRE18]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode15.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode15.py)'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode15.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode15.py)'
- en: Notice that the preceding `SimpleDisplayMeta` class needs to be decorated with
    `@PixiedustDisplay,` which is required to add this class to the internal PixieDust
    registry of plugins. In the `getMenuInfo()` method, we first check whether the
    entity type is *pandas DataFrame* and, if not, return an empty array signifying
    that this plugin doesn't support the current entity and will therefore not contribute
    anything to the menu. If the type is correct, we return an array with one JSON
    object containing the menu info.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，前面的`SimpleDisplayMeta`类需要使用`@PixiedustDisplay`进行装饰，这对于将此类添加到PixieDust插件的内部注册表是必需的。在`getMenuInfo()`方法中，我们首先检查实体类型是否为*pandas
    DataFrame*，如果不是，则返回一个空数组，表示此插件不支持当前实体，因此不会对菜单做出任何贡献。如果类型正确，我们将返回一个包含菜单信息的JSON对象的数组。
- en: The factory method `newDisplayHandler()` gets passed the `options` and `entity`
    as parameters. The `options` argument is a dictionary of key/value pairs containing
    the various choices made by the users. As we'll see later, the visualization can
    define arbitrary key/value pairs reflecting its capabilities, and the PixieDust
    framework will automatically persist them in the cell metadata.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂方法`newDisplayHandler()`接受`options`和`entity`作为参数。`options`参数是一个包含用户选择的各种键/值对的字典。如我们稍后将看到的，可视化效果可以定义任意的键/值对来反映其功能，PixieDust框架将自动将其保存在单元格元数据中。
- en: 'For example, you could add an option for displaying HTTP links as clickable
    in the UI. In our example, we return a `SimpleDisplay` instance as defined here:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以为在UI中将HTTP链接显示为可点击的选项添加一个功能。在我们的示例中，我们返回一个定义好的`SimpleDisplay`实例，如下所示：
- en: '[PRE19]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode16.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode16.py)'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode16.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode16.py)'
- en: As stated before, the `SimpleDisplay` class must inherit from the `Display`
    class and implement the `doRender()` method. Within the implementation of this
    method, you have access to the `self.entity` and `self.options` variables to adjust
    how the information is rendered on screen. In the preceding sample, we use the
    `self._addHTMLTemplateString()` method to create the HTML fragment that will render
    the visualization. As is the case for PixieApp routes, the string being passed
    to `self._addHTMLTemplateString()` can leverage the Jinja2 template engine and
    have automatic access to variables such as `entity`. If you don't want to hardcode
    the template string in the Python file, you can extract it into its own file that
    you must place in a directory called `templates` that must be located in the same
    directory as the calling Python file. You would then need to use the `self._addHTMLTemplate()`
    method that takes the name of the file as an argument (without specifying the
    `templates` directory).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`SimpleDisplay` 类必须继承自 `Display` 类，并实现 `doRender()` 方法。在该方法的实现中，您可以访问 `self.entity`
    和 `self.options` 变量，以调整如何在屏幕上呈现信息。在前面的示例中，我们使用 `self._addHTMLTemplateString()`
    方法来创建将渲染可视化的 HTML 片段。与 PixieApp 路由类似，传递给 `self._addHTMLTemplateString()` 的字符串可以利用
    Jinja2 模板引擎，并自动访问如 `entity` 等变量。如果您不想在 Python 文件中硬编码模板字符串，您可以将其提取到一个独立的文件中，该文件必须放置在名为
    `templates` 的目录中，并且该目录必须与调用 Python 文件位于同一目录下。然后，您需要使用 `self._addHTMLTemplate()`
    方法，该方法将文件名作为参数（无需指定 `templates` 目录）。
- en: Note
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The other advantage of externalizing the HTML fragment into its own file is
    that you don't have to restart the kernel every time you make a change, which
    can save you a lot of time. Because of the way Python works, the same cannot be
    said if the HTML fragment is embedded in the source code, in which case you would
    have to restart the kernel for any changes made in the HTML fragment.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 将 HTML 片段外部化为独立文件的另一个好处是，您在进行更改时不必每次都重启内核，这可以节省很多时间。由于 Python 的工作方式，如果 HTML
    片段嵌入在源代码中，情况就不同了，在这种情况下，您必须重新启动内核才能使 HTML 片段的任何更改生效。
- en: 'It is also important to note that `self._addHTMLTemplate()` and `self._addHTMLTemplateString()`
    accept keyword arguments that will be passed to the Jinja2 template. For example:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要注意的是，`self._addHTMLTemplate()` 和 `self._addHTMLTemplateString()` 接受关键字参数，这些参数将传递给
    Jinja2 模板。例如：
- en: '[PRE20]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We can now run a cell that displays, for example, the `cars` dataset:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以运行一个单元格，显示例如 `cars` 数据集：
- en: Note
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Note**: The **Simple Table** extension only works with pandas, not Spark
    DataFrame. Therefore, you would need to use `forcePandas = True` when calling
    `sampleData()` if your Notebook is connected to Spark.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：**简单表格**扩展只适用于 pandas，而不适用于 Spark DataFrame。因此，如果您的 Notebook 连接到 Spark，您需要在调用
    `sampleData()` 时使用 `forcePandas = True`。'
- en: '![Extending PixieDust visualizations](img/B09699_05_09.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![扩展 PixieDust 可视化](img/B09699_05_09.jpg)'
- en: Running a custom visualization plugin on a pandas DataFrame
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在 pandas DataFrame 上运行自定义可视化插件
- en: As shown in the PixieDust extension layer architecture diagram, you can also
    extend PixieDust using the **Renderer Extension Layer**, which is more prescriptive
    than the **Display Extension Layer** but provides many more capabilities out of
    the box, such as options management and interim data computation caching. From
    the user interface perspective, users can switch between renderers using a **Renderer**
    drop-down in the upper right-hand corner of the chart area.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如 PixieDust 扩展层架构图所示，您还可以使用 **渲染器扩展层** 来扩展 PixieDust，**渲染器扩展层**比 **显示扩展层** 更具规定性，但开箱即用提供了更多的功能，如选项管理和中间数据计算缓存。从用户界面的角度来看，用户可以通过图表区域右上角的
    **渲染器** 下拉菜单在不同的渲染器之间切换。
- en: PixieDust comes with a few built-in renderers, such as Matplotlib, Seaborn,
    Bokeh, Mapbox, Brunel, and Google Maps, but it doesn't declare any hard dependency
    on the underlying visualization libraries, including Bokeh, Brunel, or Seaborn.
    Therefore, it is incumbent on the user to manually install them, otherwise, they
    won't show up in the menus.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: PixieDust 附带了一些内置渲染器，如 Matplotlib、Seaborn、Bokeh、Mapbox、Brunel 和 Google Maps，但它并不声明对底层可视化库（包括
    Bokeh、Brunel 或 Seaborn）的硬依赖。因此，用户必须手动安装这些库，否则它们将不会出现在菜单中。
- en: 'The following screenshot illustrates the mechanism to switch between renderers
    for a given chart:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了在给定图表上切换渲染器的机制：
- en: '![Extending PixieDust visualizations](img/B09699_05_10.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![扩展 PixieDust 可视化](img/B09699_05_10.jpg)'
- en: Switching between renderers
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 切换渲染器
- en: 'Adding a new renderer is similar to adding a display visualization (it''s using
    the same APIs), though it''s actually simpler since you only have to build one
    class (no need to build the metadata class). Here are the steps you need to follow:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 添加新的渲染器类似于添加显示可视化（使用相同的 API），尽管实际上更简单，因为您只需构建一个类（无需构建元数据类）。以下是您需要遵循的步骤：
- en: Create a Display class that inherits from the specialized `BaseChartDisplay
    class`. Implement the required `doRenderChart()` method.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个从专门的 `BaseChartDisplay class` 继承的 Display 类。实现所需的 `doRenderChart()` 方法。
- en: Use the `@PixiedustRenderer` decorator to register the `rendererId` (which must
    be unique across all renderers) and the type of chart being rendered.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `@PixiedustRenderer` 装饰器注册 `rendererId`（在所有渲染器中必须是唯一的）和正在渲染的图表类型。
- en: 'Note that the same `rendererId` can be reused for all the charts included in the
    renderer. PixieDust provides a set of core chart types:'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，相同的 `rendererId` 可以用于渲染器中包含的所有图表。PixieDust 提供了一组核心图表类型：
- en: '`tableView`'
  id: totrans-239
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tableView`'
- en: '`barChart`'
  id: totrans-240
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`barChart`'
- en: '`lineChart`'
  id: totrans-241
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lineChart`'
- en: '`scatterPlot`'
  id: totrans-242
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scatterPlot`'
- en: '`pieChart`'
  id: totrans-243
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pieChart`'
- en: '`mapView`'
  id: totrans-244
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mapView`'
- en: '`histogram`'
  id: totrans-245
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`histogram`'
- en: '*(Optional)* Create a set of dynamic options using the `@commonChartOptions`
    decorator.'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*(可选)* 使用 `@commonChartOptions` 装饰器创建一组动态选项。'
- en: '*(Optional)* Customize the options dialog by overriding the `get_options_dialog_pixieapp()`
    method to return the fully qualified name of a PixieApp class inheriting from
    the `BaseOptions` class in the `pixiedust.display.chart.options.baseOptions` package.'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*(可选)* 通过覆盖 `get_options_dialog_pixieapp()` 方法来自定义选项对话框，返回 `pixiedust.display.chart.options.baseOptions`
    包中继承自 `BaseOptions` 类的 PixieApp 类的完全限定名称。'
- en: 'As an example, let''s rewrite the preceding custom `SimpleDisplay` table visualization
    using the renderer extension layer:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们使用扩展层的渲染器重新编写前述的自定义 `SimpleDisplay` 表可视化：
- en: '[PRE21]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此处找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode17.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode17.py)'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode17.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode17.py)'
- en: We decorate the class with the `@PixiedustRenderer` decorator, specifying a
    unique `rendererId` called `simpletable,` and associating it with the `tableView`
    chart type defined by the PixieDust framework. We return `None` for the `get_options_dialog_pixieapp()`
    method to signify that this extension does not support custom options. As a result,
    the **Options** button will not be shown. In the `doRenderChart()` method, we
    return the HTML fragment. Since we want to use Jinja2, we need to render it using
    the `self.renderTemplateString` method.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `@PixiedustRenderer` 装饰器装饰这个类，指定一个名为 `simpletable` 的唯一 `rendererId`，并将其与
    PixieDust 框架定义的 `tableView` 图表类型关联。我们在 `get_options_dialog_pixieapp()` 方法中返回 `None`，表示此扩展不支持自定义选项。因此，**选项**按钮将不会显示。在
    `doRenderChart()` 方法中，我们返回 HTML 片段。由于我们想使用 Jinja2，我们需要使用 `self.renderTemplateString`
    方法进行渲染。
- en: We can now test this new renderer using the `cars` dataset.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用 `cars` 数据集测试这个新的渲染器。
- en: Note
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Again, when running the code, make sure that you're loading the `cars` dataset
    as a pandas DataFrame. If you have already run the first implementation of the
    **Simple Table** and are reusing the Notebook, it is possible that you will still
    see the old **Simple Table** menu. If that's the case, you will need to restart
    the kernel and try again.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行代码时，请确保将 `cars` 数据集加载为 pandas DataFrame。如果您已经运行了**简单表**的第一个实现，并且正在重用笔记本电脑，则可能仍会看到旧的**简单表**菜单。如果是这种情况，请重新启动内核并重试。
- en: 'The following screenshot shows the simple table visualization as a renderer:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了作为渲染器的简单表可视化：
- en: '![Extending PixieDust visualizations](img/B09699_05_11.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![扩展 PixieDust 可视化](img/B09699_05_11.jpg)'
- en: Testing the renderer implementation of the Simple Table
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 测试简单表的渲染器实现
- en: 'You can find more material about this topic at: [https://pixiedust.github.io/pixiedust/develop.html](https://pixiedust.github.io/pixiedust/develop.html).
    Hopefully, by now, you have a good idea about the type of customization you can
    write to integrate your own visualization in the `display()` framework.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在这里找到更多关于此主题的材料：[https://pixiedust.github.io/pixiedust/develop.html](https://pixiedust.github.io/pixiedust/develop.html)。希望到目前为止，您已经对您可以编写的类型自定义有了一个很好的了解，以集成到
    `display()` 框架中。
- en: 'In the next section, we''ll discuss a very important topic for developers:
    debugging.'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将讨论开发者非常重要的一个主题：调试。
- en: Debugging
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调试
- en: Being able to rapidly debug an application is critical to the success of your
    project. If not, most—if not all—of the gains we've made in term of productivity
    and collaboration, by breaking the silo between data science and engineering,
    will be lost. It is also important to note that our code runs in different places,
    that is, Python on the server side, and JavaScript on the client side, and that
    debugging must take place in both places. For Python code, let's look at two ways
    to troubleshoot programming errors.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 能够快速调试应用程序对于项目的成功至关重要。如果没有这样做，我们在打破数据科学与工程之间的壁垒所取得的生产力和协作上的进展，大部分（如果不是全部）将会丧失。还需要注意的是，我们的代码在不同的位置运行，即Python在服务器端，JavaScript在客户端，调试必须在这两个地方进行。对于Python代码，让我们来看两种排查编程错误的方法。
- en: Debugging on the Jupyter Notebook using pdb
  id: totrans-264
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Jupyter Notebook中使用pdb调试
- en: pdb ([https://docs.python.org/3/library/pdb.html](https://docs.python.org/3/library/pdb.html))
    is an interactive command- line Python debugger that comes as standard with every
    Python distribution.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: pdb（[https://docs.python.org/3/library/pdb.html](https://docs.python.org/3/library/pdb.html)）是一个交互式命令行Python调试器，每个Python发行版中都默认包含。
- en: 'There are multiple ways to invoke the debugger:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 调用调试器的方式有多种：
- en: 'At launch, from the command line:'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动时，从命令行：
- en: '[PRE22]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Programmatically, in the code:'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在代码中以编程方式：
- en: '[PRE23]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'By setting an explicit breakpoint in the code with the `set_trace()` method:'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过在代码中设置显式的断点，使用`set_trace()`方法：
- en: '[PRE24]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note
  id: totrans-273
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以在此处找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode18.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode18.py)'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode18.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode18.py)'
- en: Post-mortem, after an exception has occurred, by calling `pdb.pm()`.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在发生异常后，通过调用`pdb.pm()`进行事后调试。
- en: Once in the interactive debugger, you can invoke commands, inspect variables,
    run statements, set breakpoints, and so on.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在交互式调试器中，您可以调用命令、检查变量、运行语句、设置断点等。
- en: Note
  id: totrans-278
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'A complete list of commands can be found here:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的命令列表可以在此处找到：
- en: '[https://docs.python.org/3/library/pdb.html](https://docs.python.org/3/library/pdb.html)'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.python.org/3/library/pdb.html](https://docs.python.org/3/library/pdb.html)'
- en: The great news is that Jupyter Notebooks provide first-class support for the
    interactive debugger. To invoke the debugger, simply use the `%pdb` cell magic
    command to turn it on/off, and, if an exception is triggered, then the debugger
    will automatically stop execution at the offending line.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是Jupyter Notebook对交互式调试器提供了一流的支持。要调用调试器，只需使用`%pdb`单元魔法命令来启用/禁用它，并且如果触发异常，调试器将自动在出错的行停止执行。
- en: Magic commands ([http://ipython.readthedocs.io/en/stable/interactive/magics.html](http://ipython.readthedocs.io/en/stable/interactive/magics.html))
    are constructs specific to the IPython kernel. They are language agnostic and
    therefore can theoretically be available in any language supported by the kernel
    (for example, Python, Scala, and R).
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 魔法命令（[http://ipython.readthedocs.io/en/stable/interactive/magics.html](http://ipython.readthedocs.io/en/stable/interactive/magics.html)）是特定于IPython内核的构造。它们与语言无关，因此理论上可以在内核支持的任何语言中使用（例如Python、Scala和R）。
- en: 'There are two types of magic commands:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种类型的魔法命令：
- en: '**Line magics**: The syntax is `%<magic_command_name> [optional arguments]`for
    example, `%matplotlib inline`, which configures Matplotlib to output the charts
    inline in the Notebook output cell.'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行魔法**：语法为`%<magic_command_name> [optional arguments]`，例如`%matplotlib inline`，它配置Matplotlib将图表以内联方式输出到Notebook的输出单元格中。'
- en: 'They can be invoked anywhere in the cell code, and can even return values that
    can be assigned to Python variables, for example:'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它们可以在单元格代码中的任何位置调用，甚至可以返回值，赋值给Python变量，例如：
- en: '[PRE25]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Note
  id: totrans-287
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find a list of all the line magics here:'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以在此处找到所有行魔法命令的列表：
- en: '[http://ipython.readthedocs.io/en/stable/interactive/magics.html#line-magics](http://ipython.readthedocs.io/en/stable/interactive/magics.html#line-magics)'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[http://ipython.readthedocs.io/en/stable/interactive/magics.html#line-magics](http://ipython.readthedocs.io/en/stable/interactive/magics.html#line-magics)'
- en: '**Cell magics**: The syntax is `%%<magic_command_name> [optional arguments]`.
    For example, we call the HTML cell magic to display HTML on the output cell:'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单元魔法**：语法为`%%<magic_command_name> [optional arguments]`。例如，我们可以调用HTML单元魔法在输出单元格中显示HTML：'
- en: '[PRE26]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Cell magics must be located at the top of the cell; any other location would
    result in an execution error. Everything below the cell magic is passed as an
    argument to the handler to be interpreted according to the cell magic specification.
    For example, the HTML cell magic expects the rest of the cell content to be HTML.
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 单元格魔法命令必须位于单元格的顶部；如果放在其他位置将导致执行错误。单元格魔法命令下方的所有内容都会作为参数传递给处理程序，并根据单元格魔法命令的规范进行解释。例如，HTML单元格魔法命令期望单元格的其余部分是HTML格式。
- en: 'The following code example calls a function that raises a `ZeroDivisionError`
    exception, with `pdb` automatic calling activated:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例调用了一个引发`ZeroDivisionError`异常的函数，并且激活了`pdb`的自动调用：
- en: Note
  id: totrans-294
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Note**: Once you turn `pdb` on, it stays on for the duration of the Notebook session.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：一旦启用`pdb`，它将保持开启，直到整个Notebook会话结束。'
- en: '![Debugging on the Jupyter Notebook using pdb](img/B09699_05_12.jpg)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
  zh: '![使用pdb在Jupyter Notebook中调试](img/B09699_05_12.jpg)'
- en: Interactive command-line debugging
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 交互式命令行调试
- en: 'Here are some important `pdb` commands that can be used to troubleshoot an
    issue:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些可以用来排查问题的重要`pdb`命令：
- en: '`s(tep)`: Step into the function being called and stop at the next statement
    line.'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s(tep)`：进入被调用的函数并停在下一行语句处。'
- en: '`n(ext)`: Continue to the next line, without entering into a nest function.'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`n(ext)`：继续执行到下一行，而不进入嵌套函数。'
- en: '`l(list)`: List code surrounding the current line.'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`l(list)`：列出当前行周围的代码。'
- en: '`c(ontinue)`: Keep running the program and stop at the next breakpoint, or
    if another exception is raised.'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`c(ontinue)`：继续运行程序并停在下一个断点，或者当其他异常被触发时停下。'
- en: '`d(own)`: Move down the stack frame.'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`d(own)`：向下移动堆栈帧。'
- en: '`u(p)`: Move up the stack frame.'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`u(p)`：向上移动堆栈帧。'
- en: '`<any expression>`: Evaluate and display an expression within the context of the
    current frame. For example, you can use `locals()` to get a list of all the local
    variables scoped to the current frame.'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<any expression>`：在当前框架上下文中评估并显示一个表达式。例如，你可以使用`locals()`来获取当前框架作用域内的所有局部变量列表。'
- en: 'If an exception occurred and you didn''t set the automatic `pdb` calling, you
    can still invoke the debugger after the fact by using `%debug` magic in another
    cell, as shown in the following screenshot:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发生了异常，而且你没有设置自动调用`pdb`，你仍然可以在事后通过在另一个单元格中使用`%debug`魔法命令来调用调试器，如下图所示：
- en: '![Debugging on the Jupyter Notebook using pdb](img/B09699_05_13.jpg)'
  id: totrans-307
  prefs: []
  type: TYPE_IMG
  zh: '![使用pdb在Jupyter Notebook中调试](img/B09699_05_13.jpg)'
- en: Doing a post-mortem debugging session with %debug
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 使用%debug进行事后调试会话
- en: 'Similar to a regular Python script, you can also explicitly set a breakpoint
    programmatically with the `pdb.set_trace()` method. However, it is recommended
    using the enhanced version of `set_trace()` provided by the IPython core module
    that provides syntax coloring:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于普通的Python脚本，你也可以使用`pdb.set_trace()`方法显式地设置一个断点。然而，建议使用由IPython核心模块提供的增强版`set_trace()`，它支持语法高亮：
- en: '![Debugging on the Jupyter Notebook using pdb](img/B09699_05_14.jpg)'
  id: totrans-310
  prefs: []
  type: TYPE_IMG
  zh: '![使用pdb在Jupyter Notebook中调试](img/B09699_05_14.jpg)'
- en: Explicit breakpoint
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 显式断点
- en: In the next topic, we look at an enhanced version of the Python debugger provided
    by PixieDust.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个主题中，我们将介绍一个由PixieDust提供的增强版Python调试器。
- en: Visual debugging with PixieDebugger
  id: totrans-313
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用PixieDebugger进行可视化调试
- en: 'Using the standard command line-oriented Python pdb to debug your code is a
    nice tool to have in our tool belt, but it has two major limitations:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 使用标准命令行调试工具Python的pdb来调试代码是一个不错的工具，但它有两个主要的局限性：
- en: It's command line-oriented, which means that commands have to be entered manually
    and results are sequentially appended to the cell output, making it impractical
    when it comes to advanced debugging
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是命令行导向的，这意味着命令必须手动输入，结果会按顺序附加到单元格输出中，这使得它在进行高级调试时不太实用。
- en: It doesn't work with PixieApps
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不能与PixieApps一起使用
- en: The PixieDebugger capability addresses both issues. You can use it with any
    Python code running in a Jupyter Notebook cell to visually debug the code. To
    invoke the PixieDebugger in a cell, simply add the `%%pixie_debugger` cell magic
    at the top of the cell.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: PixieDebugger的功能解决了这两个问题。你可以在Jupyter Notebook的任何Python代码中使用它来进行可视化调试。要在单元格中启用PixieDebugger，只需在单元格顶部添加`%%pixie_debugger`单元格魔法命令。
- en: Note
  id: totrans-318
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Note**: If you have not already done so, don''t forget to always import `pixiedust`
    in a separate cell before attempting to use `%%pixie_debugger`.'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：如果你还没有这么做，请记得在尝试使用`%%pixie_debugger`之前，先在单独的单元格中导入`pixiedust`。'
- en: 'As an example, the following code is trying to compute how many cars have the
    name `chevrolet` in the `cars` dataset:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下代码尝试计算`cars`数据集中名为`chevrolet`的汽车数量：
- en: '[PRE27]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note
  id: totrans-322
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在此找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode19.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode19.py)'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode19.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode19.py)'
- en: 'Running the cell with the preceding code will trigger the visual debugger shown
    in the following screenshot. The user interface lets you step into the code line
    by line, with the ability to inspect local variables, evaluate Python expressions,
    and set breakpoints. The code execution toolbar provides buttons for managing
    code execution: resume execution, step over the current line, step into the code
    a particular function, run to the end of the current function, and display the
    stack frame up and down one level:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码单元将触发以下截图所示的可视化调试器。用户界面让你逐行调试代码，具备检查局部变量、评估Python表达式和设置断点的功能。代码执行工具栏提供了用于管理代码执行的按钮：恢复执行、跳过当前行、进入代码中的特定函数、运行到当前函数的末尾，以及上下显示栈帧一层：
- en: '![Visual debugging with PixieDebugger](img/B09699_05_15.jpg)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
  zh: '![使用PixieDebugger进行可视化调试](img/B09699_05_15.jpg)'
- en: PixieDebugger in action
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: PixieDebugger在工作中
- en: With no parameter, the `pixie_debugger` cell magic will stop at the first executable
    statement in the code. However, you can easily configure it to stop at specific
    locations using the `-b` switch, followed by a list of breakpoints that could
    be either a line number or a method name.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 没有参数时，`pixie_debugger`单元格魔法将会在代码中的第一个可执行语句处停止。你可以通过使用`-b`开关轻松配置它在特定位置停止，后面跟着一个断点列表，这些断点可以是行号或方法名。
- en: 'Starting from the preceding example code, let''s add breakpoints at the `count_cars()`
    method and line **11**:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的示例代码开始，让我们在`count_cars()`方法和**第11行**添加断点：
- en: '[PRE28]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Note
  id: totrans-331
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在此找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode20.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode20.py)'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode20.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode20.py)'
- en: 'Running the preceding code will now trigger the PixieDebugger to stop at the
    first executable statement of the `count_cars()` method. It also added a breakpoint
    at line 11, which will cause the execution flow to stop there if the user resumes,
    as can be seen in the following screenshot:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码将触发PixieDebugger，在`count_cars()`方法的第一个可执行语句处停止。它还在第11行添加了一个断点，如果用户恢复执行，执行流程将在此停止，如下图所示：
- en: '![Visual debugging with PixieDebugger](img/B09699_05_16.jpg)'
  id: totrans-335
  prefs: []
  type: TYPE_IMG
  zh: '![使用PixieDebugger进行可视化调试](img/B09699_05_16.jpg)'
- en: PixieDebugger with predefined breakpoints
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 带有预定义断点的PixieDebugger
- en: Note
  id: totrans-337
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Note**: To run to a specific line of code without setting an explicit breakpoint,
    simply hover over the line number in the gutter in the left-hand pane and click
    on the icon that appears.'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：要运行到特定的代码行而不设置显式断点，只需在左侧面板的行号区域悬停，然后点击出现的图标。'
- en: Like the `%debug` line magic, you can also invoke the PixieDebugger to do post-mortem
    debugging by using the `%pixie_debugger` line magic.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 像`%debug`行魔法一样，你还可以使用`%pixie_debugger`行魔法来调用PixieDebugger进行事后调试。
- en: Debugging PixieApp routes with PixieDebugger
  id: totrans-340
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用PixieDebugger调试PixieApp路由
- en: 'PixieDebugger is fully integrated into the PixieApp framework. Whenever an
    exception happens while triggering a route, the resulting traceback is augmented
    with two extra buttons:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: PixieDebugger完全集成到PixieApp框架中。每当触发路由时发生异常，生成的回溯信息将会增加两个额外的按钮：
- en: '**Post Mortem**: Invoke the PixieDebugger to start a post-mortem troubleshooting
    session that lets you inspect variables and analyses the stack frames'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事后调试**：调用PixieDebugger开始事后故障排除会话，允许你检查变量并分析堆栈帧'
- en: '**Debug Route**: Replay the current route stopping at the first executable
    statement in the PixieDebugger'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调试路线**：回放当前路线，在PixieDebugger中停止在第一个可执行语句处'
- en: 'As an example, let''s consider the following code for implementing a PixieApp
    that lets the user search the `cars` dataset by providing a column name and a
    search query:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下是实现一个PixieApp的代码，允许用户通过提供列名和查询条件来搜索`cars`数据集：
- en: '[PRE29]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note
  id: totrans-346
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在此找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode21.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode21.py)'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode21.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode21.py)'
- en: 'The default value for the search column is `name`, but if the user enters a
    column name that doesn''t exist, a traceback is generated as follows:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索列的默认值为`name`，但如果用户输入的列名不存在，将会生成如下的回溯信息：
- en: '![Debugging PixieApp routes with PixieDebugger](img/B09699_05_17.jpg)'
  id: totrans-350
  prefs: []
  type: TYPE_IMG
  zh: '![Debugging PixieApp routes with PixieDebugger](img/B09699_05_17.jpg)'
- en: Enhanced traceback with buttons for invoking the PixieDebugger
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 增强的回溯信息，带有用于调用PixieDebugger的按钮
- en: 'Clicking on the **Debug Route** will automatically start the PixieDebugger
    and stop at the first executable statement of the route, as shown in the following
    screenshot:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**Debug Route**将自动启动PixieDebugger，并在路由的第一个可执行语句处停下来，如下图所示：
- en: '![Debugging PixieApp routes with PixieDebugger](img/B09699_05_18.jpg)'
  id: totrans-353
  prefs: []
  type: TYPE_IMG
  zh: '![Debugging PixieApp routes with PixieDebugger](img/B09699_05_18.jpg)'
- en: Debugging a PixieApp route
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 调试PixieApp路由
- en: 'You could also deliberately have the PixieDebugger stop at the `display_screen()`
    route without waiting for a traceback to happen by using the `debug_route` keyword
    argument to the `run` method:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过使用`debug_route`关键字参数来让PixieDebugger在`display_screen()`路由处停下来，而无需等待回溯信息的生成，方法如下：
- en: '[PRE30]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: PixieDebugger is the first visual Python debugger for Jupyter Notebook, providing
    a feature that has long been requested by the Jupyter user community. However,
    using live debugging is not the only tool that developers use. In the next section,
    we will look at debugging by inspecting logging messages.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: PixieDebugger是第一个为Jupyter Notebook提供的可视化Python调试器，提供了Jupyter用户社区长期要求的功能。然而，实时调试并不是开发者使用的唯一工具。在接下来的部分，我们将通过检查日志记录消息来进行调试。
- en: Troubleshooting issues using PixieDust logging
  id: totrans-358
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用PixieDust日志记录进行故障排查
- en: 'It is always good practice to instrument your code with logging messages, and
    the PixieDust framework provides an easy way to create and read back logging messages
    directly from the Jupyter Notebook. To start off, you''ll need to create a logger
    by calling the `getLogger()` method as follows:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 习惯上最好在代码中使用日志记录消息，而PixieDust框架提供了一种简便的方式，可以直接从Jupyter Notebook创建和读取日志消息。首先，你需要通过调用`getLogger()`方法创建一个日志记录器，方法如下：
- en: '[PRE31]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Note
  id: totrans-361
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode22.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode22.py)'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode22.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode22.py)'
- en: 'You can use anything as an argument to the `getLogger()` method. However, to better
    identify where a particular message comes from, it is recommended using the `__name__`
    variable, which returns the name of the current module. The `my_logger` variable
    is a standard Python logger object that provides logging methods with various
    levels:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将任何内容作为`getLogger()`方法的参数。然而，为了更好地识别特定消息的来源，建议使用`__name__`变量，它返回当前模块的名称。`my_logger`变量是一个标准的Python日志记录器对象，提供各种级别的日志记录方法：
- en: '`debug(msg, *args, **kwargs)`: Logs a message with the `DEBUG` level.'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`debug(msg, *args, **kwargs)`：以`DEBUG`级别记录一条消息。'
- en: '`info(msg, *args, **kwargs)`: Logs a message with the `INFO` level.'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`info(msg, *args, **kwargs)`：以`INFO`级别记录一条消息。'
- en: '`warning(msg, *args, **kwargs)`: Logs a message with the `WARNING` level.'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`warning(msg, *args, **kwargs)`：以`WARNING`级别记录一条消息。'
- en: '`error(msg, *args, **kwargs)`: Logs a message with the `ERROR` level.'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`error(msg, *args, **kwargs)`：以`ERROR`级别记录一条消息。'
- en: '`critical(msg, *args, **kwargs)`: Logs a message with the `CRITICAL` level.'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`critical(msg, *args, **kwargs)`：以`CRITICAL`级别记录一条消息。'
- en: '`exception(msg, *args, **kwargs)`: Logs a message with the `EXCEPTION` level.
    This method should only be called from within an exception handler.'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exception(msg, *args, **kwargs)`：以`EXCEPTION`级别记录一条消息。此方法仅应在异常处理程序中调用。'
- en: Note
  id: totrans-371
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Note**: You can find more information about the Python logging framework
    here:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：你可以在这里找到更多关于Python日志框架的信息：'
- en: '[https://docs.python.org/2/library/logging.html](https://docs.python.org/2/library/logging.html)'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.python.org/2/library/logging.html](https://docs.python.org/2/library/logging.html)'
- en: 'You can then query the log messages directly from the Jupyter Notebook using
    the `%pixiedustLog` cell magic, which takes the following parameters:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你可以通过`%pixiedustLog`单元魔法直接从Jupyter Notebook查询日志消息，该魔法需要以下参数：
- en: '`-l`: Filter by log level, for example, `CRITICAL`, `FATAL`, `ERROR`, `WARNING`,
    `INFO`, and `DEBUG`'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-l`: 按日志级别过滤，例如 `CRITICAL`、`FATAL`、`ERROR`、`WARNING`、`INFO` 和 `DEBUG`'
- en: '`-f`: Filter a message that contains a given string, for example, `Exception`'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-f`: 过滤包含特定字符串的消息，例如 `Exception`'
- en: '`-m`: Maximum number of log messages returned'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-m`: 返回的最大日志消息数'
- en: 'In the following example, we use the `%pixiedustLog` magic to display all the
    debug messages, limiting these to the last five messages:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们使用 `%pixiedustLog` 魔法来显示所有调试消息，将这些消息限制为最后五条：
- en: '![Troubleshooting issues using PixieDust logging](img/B09699_05_19.jpg)'
  id: totrans-379
  prefs: []
  type: TYPE_IMG
  zh: '![使用 PixieDust 日志排查问题](img/B09699_05_19.jpg)'
- en: Display the last five log messages
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 显示最后五条日志消息
- en: For convenience, when working with Python classes, you can also use the `@Logger`
    decorator, which automatically creates a logger using the class name as its identifier.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便使用，在处理 Python 类时，你还可以使用 `@Logger` 装饰器，它会自动创建一个以类名为标识符的日志记录器。
- en: 'Here is a code example that uses the `@Logger` decorator:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用 `@Logger` 装饰器的代码示例：
- en: '[PRE32]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Note
  id: totrans-384
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode23.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode23.py)'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode23.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode23.py)'
- en: 'After running the preceding PixieApp in a cell, you can invoke the `%pixiedustLog`
    magic to display the messages:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 在单元格中运行前述 PixieApp 后，你可以调用 `%pixiedustLog` 魔法来显示消息：
- en: '![Troubleshooting issues using PixieDust logging](img/B09699_05_20.jpg)'
  id: totrans-388
  prefs: []
  type: TYPE_IMG
  zh: '![使用 PixieDust 日志排查问题](img/B09699_05_20.jpg)'
- en: Querying the log with a specific term
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 使用特定术语查询日志
- en: This completes our discussion on server-side debugging. In the next section,
    we look at a technique for performing client-side debugging
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们关于服务器端调试的讨论。在下一节中，我们将探讨一种执行客户端调试的技术
- en: Client-side debugging
  id: totrans-391
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 客户端调试
- en: One of the design principles of the PixieApp programming model is to minimize
    the need for developers to write JavaScript. The framework will automatically
    trigger kernel requests by listening to user input events, such as click or change
    events. However, there will be cases where writing a little bit of JavaScript
    is inevitable. These JavaScript snippets are usually part of a particular route
    HTML fragment and are dynamically injected into the browser, which makes it very
    difficult to debug.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: PixieApp 编程模型的设计原则之一是尽量减少开发者编写 JavaScript 的需要。框架将通过监听用户输入事件（如点击或更改事件）自动触发内核请求。然而，在某些情况下，编写少量的
    JavaScript 是不可避免的。这些 JavaScript 片段通常是特定路由 HTML 片段的一部分，并动态注入到浏览器中，这使得调试变得非常困难。
- en: One popular technique is to sprinkle `console.log` calls in the JavaScript code
    in order to print messages to the browser developer console.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 一种流行的技巧是在 JavaScript 代码中加入 `console.log` 调用，以便将消息打印到浏览器的开发者控制台。
- en: Note
  id: totrans-394
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Note**: Each browser flavor has its own way of invoking the developer console.
    For example, in Google Chrome, you would use **View** | **Developer** | **JavaScript
    Console,** or the *Command* + *Alt* + *J* shortcut.'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：每种浏览器都有自己调用开发者控制台的方式。例如，在 Google Chrome 中，你可以使用 **查看** | **开发者** | **JavaScript
    控制台**，或 *Command* + *Alt* + *J* 快捷键。'
- en: One other debugging technique that I particularly like is to programmatically
    insert in a breakpoint in the JavaScript code using the `debugger;` statement.
    This statement has no effect unless the browser developer tools are open and source
    debugging is enabled, in which case, the execution will automatically break at
    the `debugger;` statement.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个我特别喜欢的调试技巧是通过在 JavaScript 代码中编程插入一个断点，使用 `debugger;` 语句。除非浏览器开发者工具已打开并启用了源代码调试，否则此语句没有任何效果。在这种情况下，执行将自动在
    `debugger;` 语句处中断。
- en: 'The following PixieApp example uses a JavaScript function to resolve a dynamic
    value referenced by the `$val()` directive:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个 PixieApp 示例，使用 JavaScript 函数解析 `$val()` 指令引用的动态值：
- en: '[PRE33]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Note
  id: totrans-399
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the code file here:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到代码文件：
- en: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode24.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode24.py)'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode24.py](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode24.py)'
- en: 'In the preceding code, the button is dynamically setting the value of a state
    using the `FooJS` JavaScript function that contains a debugger statement. Executing
    the app and clicking on the button while the developer tool is open will automatically
    start a debugging session on the browser:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，按钮动态地使用包含调试器语句的`FooJS` JavaScript函数设置状态的值。执行应用程序并在开发者工具打开时点击按钮，将自动在浏览器中启动调试会话：
- en: '![Client-side debugging](img/B09699_05_21.jpg)'
  id: totrans-403
  prefs: []
  type: TYPE_IMG
  zh: '![客户端调试](img/B09699_05_21.jpg)'
- en: Debugging JavaScript code on the client side with a debugger; statement
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端使用调试器调试JavaScript代码；语句
- en: Run Node.js inside a Python Notebook
  id: totrans-405
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Python Notebook中运行Node.js
- en: Even though I've clearly stated at the beginning of this book that Python has
    emerged as a clear leader in the field of data science, it is still only marginally
    used by the developer community where traditional languages, such as Node.js,
    are still preferred. Recognizing that, for some developers, learning a new language,
    such as Python, is a cost of entry to data science that may be too high, I partnered
    with my IBM colleague, Glynn Bird, to build an extension library to PixieDust
    called `pixiedust_node` ([https://github.com/pixiedust/pixiedust_node](https://github.com/pixiedust/pixiedust_node))
    that would let developers run Node.js/JavaScript code inside cells in a Python
    Notebook. The goal of this library is to ease developers into the Python world
    by allowing them to reuse their favourite Node.js libraries, for example, to load
    and process data from existing data sources.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我在本书开头已经明确表示，Python已成为数据科学领域的明确领导者，但它在开发者社区中的使用仍然处于边缘地位，而传统语言（如Node.js）仍然是首选。认识到对于一些开发者而言，学习像Python这样的新语言可能是进入数据科学的成本太高，我与我的IBM同事Glynn
    Bird合作，构建了一个名为`pixiedust_node`的PixieDust扩展库（[https://github.com/pixiedust/pixiedust_node](https://github.com/pixiedust/pixiedust_node)），让开发者可以在Python
    Notebook的单元格中运行Node.js/JavaScript代码。这个库的目标是通过让开发者可以重用他们喜欢的Node.js库（例如，用于加载和处理现有数据源中的数据）来帮助他们更容易地进入Python世界。
- en: 'To install the `pixiedust_node` library, simply run the following command in
    its own cell:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装`pixiedust_node`库，只需在自己的单元格中运行以下命令：
- en: '[PRE34]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Note
  id: totrans-409
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Note**: Don''t forget to restart the kernel once the installation is complete.'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：安装完成后，不要忘记重启内核。'
- en: '**Important**: You need to make sure that a Node.js runtime version 6 or higher
    is installed on the same machine as the Jupyter Notebook Server.'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要**：你需要确保在与Jupyter Notebook Server同一台机器上安装Node.js运行时版本6或更高版本。'
- en: 'Once the kernel has restarted, we import the `pixiedust_node` module:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦内核重启，我们导入`pixiedust_node`模块：
- en: '[PRE35]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'You should see information about both PixieDust and `pixiedust_node` in the
    output as follows:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在输出中看到关于PixieDust和`pixiedust_node`的信息，如下所示：
- en: '![Run Node.js inside a Python Notebook](img/B09699_05_22.jpg)'
  id: totrans-415
  prefs: []
  type: TYPE_IMG
  zh: '![在Python Notebook中运行Node.js](img/B09699_05_22.jpg)'
- en: pixiedust_node welcome output
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: pixiedust_node欢迎输出
- en: 'When `pixiedust_node` is imported, a Node subprocess is created from the Python
    side along with a special thread that reads the output of the subprocess and passes
    it to the Python side to be displayed in the cell currently executing in the Notebook.
    This subprocess is responsible for starting an **REPL** session (**Read-Eval-Print
    Loop**: [https://en.wikipedia.org/wiki/Read-eval-print_loop](https://en.wikipedia.org/wiki/Read-eval-print_loop))
    that will execute all the scripts sent from the Notebook and make any created
    classes, functions, and variables reusable across all executions.'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 当导入`pixiedust_node`时，Python端会创建一个Node子进程，并启动一个特殊线程来读取子进程的输出，将其传递给Python端，以便在当前执行的Notebook单元格中显示。这个子进程负责启动**REPL**会话（**读取-求值-打印循环**：[https://en.wikipedia.org/wiki/Read-eval-print_loop](https://en.wikipedia.org/wiki/Read-eval-print_loop)），它将执行所有从Notebook发送的脚本，并使所有创建的类、函数和变量在所有执行中可重用。
- en: 'It also defines a set of functions that are designed to interact with the Notebook
    and the PixieDust `display()` API:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 它还定义了一组旨在与Notebook和PixieDust `display()` API交互的函数：
- en: '`print(data)`: Outputs the value of data in the cell currently executing in
    the Notebook.'
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`print(data)`：在当前执行的Notebook单元格中输出data的值。'
- en: '`display(data)`: Calls the PixieDust `display()` API with a pandas DataFrame
    converted from data. If data cannot be converted into a pandas DataFrame, then
    it defaults to the `print` method.'
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`display(data)`：调用PixieDust的`display()` API，使用从数据转换的pandas DataFrame。如果数据无法转换为pandas
    DataFrame，则默认使用`print`方法。'
- en: '`html(data)`: Displays the data as HTML in the cell currently executing in
    the Notebook.'
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`html(data)`：以HTML格式在当前执行的Notebook单元格中显示数据。'
- en: '`image(data)`: Expects data to be a URL to an image and displays it in the
    cell currently executing in the Notebook.'
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`image(data)`：期望数据是一个指向图像的 URL，并在当前执行的单元格中显示图像。'
- en: '`help()`: Displays a list of all the preceding methods.'
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`help()`：显示所有前述方法的列表。'
- en: 'In addition, `pixiedust_node` makes two variables, called `npm` and `node,`
    globally available in the Notebook:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`pixiedust_node` 使两个变量，`npm` 和 `node`，在笔记本中全局可用：
- en: '`node.cancel()`: Stops the current execution of code in the Node.js subprocess.'
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`node.cancel()`：停止当前在 Node.js 子进程中执行的代码。'
- en: '`node.clear()`: Resets the Node.js session; all existing variables will be
    deleted.'
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`node.clear()`：重置 Node.js 会话；所有现有变量将被删除。'
- en: '`npm.install(package)`: Installs an npm package and makes it available to the
    Node.js session. The package is persisted across sessions.'
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`npm.install(package)`：安装一个 npm 包并使其在 Node.js 会话中可用。该包在会话之间保持持久。'
- en: '`npm.uninstall(package)`: Removes the npm package from the system and the current
    Node.js session.'
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`npm.uninstall(package)`：从系统和当前 Node.js 会话中删除 npm 包。'
- en: '`npm.list()`: Lists all npm packages currently installed.'
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`npm.list()`：列出当前安装的所有 npm 包。'
- en: '`pixiedust_node` creates a cell magic that lets you run arbitrary JavaScript
    code. Simply use the `%%node` magic at the top of the cell and run it as usual.
    The code will then be executed in the Node.js subprocess REPL session.'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '`pixiedust_node` 创建一个单元格魔法，允许你运行任意 JavaScript 代码。只需在单元格顶部使用 `%%node` 魔法并像往常一样运行，代码将被执行在
    Node.js 子进程的 REPL 会话中。'
- en: 'The following code displays a string that includes the current datetime using
    the JavaScript `Date` object ([https://www.w3schools.com/Jsref/jsref_obj_date.asp](https://www.w3schools.com/Jsref/jsref_obj_date.asp)):'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码使用 JavaScript `Date` 对象（[https://www.w3schools.com/Jsref/jsref_obj_date.asp](https://www.w3schools.com/Jsref/jsref_obj_date.asp)）显示一个包含当前日期时间的字符串：
- en: '[PRE36]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This outputs the following:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出以下内容：
- en: '[PRE37]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The following diagram illustrates the execution flow of the preceding cell:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示说明了前述单元格的执行流程：
- en: '![Run Node.js inside a Python Notebook](img/B09699_05_23.jpg)'
  id: totrans-436
  prefs: []
  type: TYPE_IMG
  zh: '![在 Python 笔记本中运行 Node.js](img/B09699_05_23.jpg)'
- en: The life cycle of a Node.js script execution
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 脚本执行的生命周期
- en: The JavaScript code is processed by the `pixiedust_node` magic and sent to the
    Node subprocess for execution. As the code is being executed, its output is read
    by the special thread and displayed back in the cell currently executing in the
    Notebook. Note that the JavaScript code may make an asynchronous call, in which case
    the execution will return right away before the asynchronous calls have finished.
    In this case, the Notebook will indicate that the cell code is done, even though
    more output may be generated later by the asynchronous code. There is no way to
    deterministically know when an asynchronous code is done. Therefore it is incumbent
    upon the developer to manage this state carefully.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 代码由 `pixiedust_node` 魔法处理并发送到 Node 子进程执行。在代码执行过程中，其输出将由特殊线程读取并显示回当前在笔记本中执行的单元格。请注意，JavaScript
    代码可能会进行异步调用，在这种情况下，执行将立即返回，而异步调用可能还没有完成。在这种情况下，笔记本会显示单元格代码已完成，即使异步代码可能稍后会生成更多输出。无法确定异步代码何时完成。因此，开发人员必须小心地管理此状态。
- en: '`pixiedust_node` also has the ability to share variables between the Python
    side and the JavaScript side, and vice-versa. Therefore, you could declare a Python
    variable (such as an array of integers, for example), apply a transformation in
    JavaScript (perhaps using your favorite library), and have it processed back in Python.'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '`pixiedust_node` 还具有在 Python 和 JavaScript 之间共享变量的能力，反之亦然。因此，你可以声明一个 Python
    变量（例如整数数组），在 JavaScript 中应用转换（也许使用你喜欢的库），然后再返回 Python 中处理。'
- en: 'The following code is run in two cells, one in pure Python declaring an array
    of integers, and one in JavaScript that multiplies each element by 2:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码在两个单元格中运行，一个纯 Python 单元格声明一个整数数组，另一个 JavaScript 单元格将每个元素乘以 2：
- en: '![Run Node.js inside a Python Notebook](img/B09699_05_24.jpg)'
  id: totrans-441
  prefs: []
  type: TYPE_IMG
  zh: '![在 Python 笔记本中运行 Node.js](img/B09699_05_24.jpg)'
- en: 'The reverse direction also works the same. The following code starts by creating
    a JSON variable in JavaScript in a node cell, and then creates and displays a
    pandas DataFrame in the Python cell:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 反向方向也同样有效。以下代码首先在 JavaScript 的 node 单元格中创建一个 JSON 变量，然后在 Python 单元格中创建并显示一个
    pandas DataFrame：
- en: '[PRE38]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The results are as follows:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '[PRE39]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Then, in a Python cell, we use PixieDust `display()`:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在 Python 单元格中，我们使用 PixieDust 的 `display()`：
- en: '[PRE40]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Using the following options:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下选项：
- en: '![Run Node.js inside a Python Notebook](img/B09699_05_25.jpg)'
  id: totrans-449
  prefs: []
  type: TYPE_IMG
  zh: '![在 Python 笔记本中运行 Node.js](img/B09699_05_25.jpg)'
- en: display() options for data created from a node cell
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Node 单元创建的数据的 display() 选项
- en: 'And we get the following results:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到以下结果：
- en: '![Run Node.js inside a Python Notebook](img/B09699_05_26.jpg)'
  id: totrans-452
  prefs: []
  type: TYPE_IMG
  zh: '![在 Python 笔记本中运行 Node.js](img/B09699_05_26.jpg)'
- en: Bar chart from data created in a node cell
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Node 单元创建的数据生成的柱状图
- en: 'We could also have arrived at the same results directly from the Node cell
    by using the `display()` method made available by `pixiedust_node`, as shown in the following
    code:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以直接从 Node 单元使用`pixiedust_node`提供的 `display()` 方法，达到相同的结果，如下所示：
- en: '[PRE41]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'If you are interested in knowing more about `pixiedust_node`, I strongly recommend
    this blog post: [https://medium.com/ibm-watson-data-lab/nodebooks-node-js-data-science-notebooks-aa140bea21ba](https://medium.com/ibm-watson-data-lab/nodebooks-node-js-data-science-notebooks-aa140bea21ba).
    As always, I encourage the reader to get involved with improving these tools,
    either by contributing code or ideas for enhancement.'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于`pixiedust_node`的信息，我强烈推荐阅读这篇博客文章：[https://medium.com/ibm-watson-data-lab/nodebooks-node-js-data-science-notebooks-aa140bea21ba](https://medium.com/ibm-watson-data-lab/nodebooks-node-js-data-science-notebooks-aa140bea21ba)。像往常一样，我鼓励读者通过贡献代码或提出改进意见来参与这些工具的改进。
- en: Summary
  id: totrans-457
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we've explored various advanced concepts, tools, and best practices that
    added more tools to our toolbox, ranging from advanced techniques for PixieApps
    (Streaming, how to implement a route by integrating third-party libraries with
    `@captureOutput`, PixieApp events, and better modularity with `pd_app`), to essential
    developer tools like the PixieDebugger. We've also covered the details of how
    to create your own custom visualization using the PixieDust `display()` API. We
    also discussed `pixiedust_node,` which is an extension of the PixieDust framework
    that lets developers who are more comfortable with JavaScript work with data in
    their favorite language.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探索了各种高级概念、工具和最佳实践，增加了更多工具到我们的工具箱中，涵盖了从 PixieApps（流式处理、如何通过将第三方库与`@captureOutput`集成来实现路由、PixieApp
    事件、以及通过`pd_app`实现更好的模块化）到开发者必备工具 PixieDebugger 的内容。我们还详细介绍了如何使用 PixieDust `display()`
    API 创建自定义可视化。我们还讨论了`pixiedust_node`，它是 PixieDust 框架的扩展，允许那些更熟悉 JavaScript 的开发者在他们喜爱的语言中处理数据。
- en: 'Throughout the remainder of this book, we are going to put all these lessons
    learned to good use by building industry use case data pipelines, starting with
    a *Deep Learning Visual Recognition* application in [Chapter 6](ch06.xhtml "Chapter 6. Analytics
    Study: AI and Image Recognition with TensorFlow"), *Analytics Study: AI and Image
    Recognition with TensorFlow*.'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的剩余部分，我们将利用这些学到的知识，构建行业应用数据管道，从[第六章](ch06.xhtml "第六章. 数据分析研究：使用 TensorFlow
    进行 AI 和图像识别")，*数据分析研究：使用 TensorFlow 进行 AI 和图像识别*中的 *深度学习视觉识别* 应用开始。
- en: A developer quick-reference guide for the PixieApp programming model is provided
    in [Appendix](apa.xhtml "Appendix A. PixieApp Quick-Reference"), *PixieApp Quick-Reference*
    at the end of this book.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 本书结尾提供了关于 PixieApp 编程模型的开发者快速参考指南，详见[附录](apa.xhtml "附录 A. PixieApp 快速参考")，*PixieApp
    快速参考*。
