- en: Maintenance, Optimization, and Performance Tuning
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 维护、优化和性能调整
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下菜谱：
- en: Organizing the database
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组织数据库
- en: Setting up the correct data privilege mechanism
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置正确的数据权限机制
- en: Backing up the database
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 备份数据库
- en: Using indexes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用索引
- en: Clustering for efficiency
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了效率进行聚类
- en: Optimizing SQL queries
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化SQL查询
- en: Migrating a PostGIS database to a different server
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将PostGIS数据库迁移到不同的服务器
- en: Replicating a PostGIS database with streaming replication
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用流复制复制PostGIS数据库
- en: Geospatial sharding
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 地理空间分片
- en: Paralellizing in PosgtreSQL
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在PostgreSQL中并行处理
- en: Introduction
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Unlike prior chapters, this chapter does not discuss the capabilities or applications
    of PostGIS. Instead, it focuses on the techniques for organizing the database,
    improving the query performance, and ensuring the long-term viability of the spatial
    data.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的章节不同，本章不讨论PostGIS的功能或应用。相反，它侧重于组织数据库的技术、提高查询性能以及确保空间数据的长期可行性。
- en: These techniques are frequently ignored by most PostGIS users until it is too
    late - for example, when data has already been lost because of users' actions
    or the performance has already decreased as the volume of data or number of users
    increased.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这些技术通常被大多数PostGIS用户忽视，直到为时已晚——例如，当数据已经因为用户的行为而丢失，或者当数据量或用户数量增加时，性能已经下降。
- en: Such neglect is often due to the amount of time required to learn about each
    technique, as well as the time it takes implement them. This chapter attempts
    to demonstrate each technique in a distilled manner that minimizes the learning
    curve and maximizes the benefits.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这种忽视通常是由于学习每种技术所需的时间以及实施它们所需的时间量。本章试图以提炼的方式展示每种技术，以最大限度地减少学习曲线并最大限度地提高效益。
- en: Organizing the database
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组织数据库
- en: One of the most important things to consider when creating and using a database
    is how to organize the data. The layout should be decided when you first establish
    the database. The layout can be decided on or changed at a later date, but this
    is almost guaranteed to be a tedious, if not difficult, task. If it is never decided
    on, a database will become disorganized over time and introduce significant hurdles
    when upgrading components or running backups.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建和使用数据库时，需要考虑的最重要的事情之一是如何组织数据。布局应在首次建立数据库时确定。布局可以在稍后决定或更改，但这几乎可以保证是一个繁琐的，如果不是困难的任务。如果从未决定，数据库将随着时间的推移而变得杂乱无章，在升级组件或运行备份时引入重大障碍。
- en: By default, a new PostgreSQL database has only one **schema **- namely, `public`.
    Most users place all the data (their own and third-party modules, such as PostGIS)
    in the `public` schema. Doing so mixes different information from various origins.
    An easy method with which to separate the information is by using schemas. This
    enables us to use one schema for our data and a separate schema for everything
    else.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，新的PostgreSQL数据库只有一个**模式**——即`public`。大多数用户将所有数据（他们自己的和第三方模块，如PostGIS）放在`public`模式中。这样做会混合来自不同来源的不同信息。一种简单的方法来分离信息是使用模式。这使得我们可以为我们的数据使用一个模式，为其他所有事物使用一个单独的模式。
- en: Getting ready
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we will create a database and install PostGIS in its own schema.
    We will also load some geometries and rasters for future use by other recipes
    in this chapter.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将创建一个数据库并在其自己的模式中安装PostGIS。我们还将加载一些几何形状和栅格数据，以便在本书的其他菜谱中使用。
- en: 'The following are the two methods to create a PostGIS-enabled database:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在创建PostGIS启用数据库的两种方法：
- en: Using the `CREATE EXTENSION` statement
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`CREATE EXTENSION`语句
- en: Running the installation SQL scripts with a PostgreSQL client
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用PostgreSQL客户端运行安装SQL脚本
- en: 'The `CREATE EXTENSION` method is available if you are running PostgreSQL 9.1
    or a later version and is the recommended method for installing PostGIS:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在运行PostgreSQL 9.1或更高版本，则可以使用`CREATE EXTENSION`方法，这是安装PostGIS的推荐方法：
- en: 'Visit the following link to download the shapefiles for California schools
    and police stations: [http://scec.usc.edu/internships/useit/content/california-emergency-facilities-shapefile](http://scec.usc.edu/internships/useit/content/california-emergency-facilities-shapefile).'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问以下链接下载加利福尼亚学校和警察局的shapefiles：[http://scec.usc.edu/internships/useit/content/california-emergency-facilities-shapefile](http://scec.usc.edu/internships/useit/content/california-emergency-facilities-shapefile)。
- en: How to do it...
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Carry out the following steps to create and organize a database:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以创建和组织数据库：
- en: 'Create a database named `chapter10` by executing the following command:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行以下命令创建一个名为`chapter10`的数据库：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create a schema named `postgis` in the `chapter10` database, where we will
    install PostGIS. Execute the following command:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`chapter10`数据库中创建一个名为`postgis`的模式，我们将在这里安装PostGIS。执行以下命令：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Install PostGIS in the `postgis` schema of the `chapter10` database:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`chapter10`数据库的`postgis`模式中安装PostGIS：
- en: 'If you are running PostgreSQL 9.1 or a newer version, use the `CREATE EXTENSION`
    statement:'
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你运行的是PostgreSQL 9.1或更高版本，使用`CREATE EXTENSION`语句：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `WITH SCHEMA` clause of the `CREATE EXTENSION` statement instructs PostgreSQL
    to install PostGIS and its objects in the `postgis` schema.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`CREATE EXTENSION`语句的`WITH SCHEMA`子句指示PostgreSQL在`postgis`模式中安装PostGIS及其对象。'
- en: 'Check whether or not the PostGIS installation has succeeded by running the
    following commands:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令检查PostGIS安装是否成功：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '****![](img/f3eebd3c-c546-4bef-ad81-18acf1521025.png)****'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '****![](img/f3eebd3c-c546-4bef-ad81-18acf1521025.png)****'
- en: 'Verify the list of relations in the schema, which should include all the ones
    created by the extension:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 验证模式中关系列表，它应该包括由扩展创建的所有关系：
- en: '**![](img/60d51d76-e3f4-419e-b465-4e6c9568bb35.png)**'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**![](img/60d51d76-e3f4-419e-b465-4e6c9568bb35.png)**'
- en: If you are using `pgAdmin` or a similar database system, you can also check
    on the graphical interface whether the schemas, views, and table were created
    successfully.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用`pgAdmin`或类似的数据库系统，你还可以在图形界面中检查模式、视图和表是否已成功创建。
- en: The `SET` statement instructs PostgreSQL to consider the `public` and `postgis`
    schemas when processing any SQL statements from our client connection. Without
    the `SET` statement, the `\d` command will not return any relation from the `postgis`
    schema.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`SET`语句指示PostgreSQL在处理来自我们客户端连接的任何SQL语句时考虑`public`和`postgis`模式。没有`SET`语句，`\d`命令将不会从`postgis`模式返回任何关系。'
- en: 'To prevent the need to manually use the `SET` statement every time a client
    connects to the `chapter10` database, alter the database by executing the following
    command:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了防止每次客户端连接到`chapter10`数据库时都需要手动使用`SET`语句，通过执行以下命令修改数据库：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: All future connections and queries to `chapter10` will result in PostgreSQL
    automatically using both `public` and `postgis` schemas.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 所有未来的连接和查询到`chapter10`都将导致PostgreSQL自动使用`public`和`postgis`模式。
- en: 'Note: It may be the case that, for Windows users, this option may not work
    well; in version 9.6.7 it worked but not in version 9.6.3\. If it does not work,
    you may need to clearly define the `search_path` on every command. Both versions
    are provided.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：对于Windows用户，此选项可能不起作用；在版本9.6.7中它起作用，但在版本9.6.3中不起作用。如果不起作用，你可能需要在每个命令中明确定义`search_path`。两种版本都提供。
- en: 'Load the PRISM rasters and San Francisco boundaries geometry, which we used
    in [Chapter 5](9e0e214c-c084-42dc-afdf-e58e021f9094.xhtml), *Working with Raster
    Data*, by executing the following command:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行以下命令加载PRISM栅格和旧金山边界几何形状，这些我们在[第5章](9e0e214c-c084-42dc-afdf-e58e021f9094.xhtml)，“处理栅格数据”中使用过：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then, define the search path:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，定义搜索路径：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As we did in [Chapter 5](9e0e214c-c084-42dc-afdf-e58e021f9094.xhtml), *Working
    with Raster Data*, we will postprocess the raster filenames to a `date` column
    by executing the following command:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如我们在[第5章](9e0e214c-c084-42dc-afdf-e58e021f9094.xhtml)，“处理栅格数据”中所做的那样，我们将通过执行以下命令对栅格文件名进行后处理，将其添加到`date`列：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then, we load the San Francisco boundaries by executing the following command:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们通过执行以下命令加载旧金山边界：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then, define the search path:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，定义搜索路径：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Copy this chapter''s dataset to its own directory by executing the following
    commands:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将本章的数据集复制到其自己的目录中，通过执行以下命令：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We will use the shapefiles for California schools and police stations provided
    by the USEIT program at the University of Southern California. Import the shapefiles
    by executing the following commands; use the spatial index flag `-I` only for
    the police stations shapefile:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用南加州大学USEIT项目提供的加利福尼亚州学校和警察局的shapefiles。通过执行以下命令导入shapefiles；仅对警察局的shapefile使用空间索引标志`-I`：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then, define the search path:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，定义搜索路径：
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then, define the search path:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，定义搜索路径：
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: How it works...
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we created a new database and installed PostGIS in its own schema.
    We kept the PostGIS objects separate from our geometries and rasters without installing
    PostGIS in the `public` schema. This separation keeps the `public` schema tidy
    and reduces the accidental modification or deletion of the PostGIS objects. If
    the definition of the search path did not work, then use the explicit definition
    of the schema in all the commands, as shown.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们创建了一个新的数据库并在其自己的模式中安装了 PostGIS。我们将 PostGIS 对象与我们的几何和栅格数据保持分离，而没有在 `public`
    模式中安装 PostGIS。这种分离使 `public` 模式保持整洁，并减少了意外修改或删除 PostGIS 对象的风险。如果搜索路径的定义不起作用，那么在所有命令中使用显式的模式定义，如下所示。
- en: In the following recipes, we will see that our decision to install PostGIS in
    its own schema results in fewer problems when maintaining the database.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的菜谱中，我们将看到我们决定在单独的模式中安装 PostGIS 的决定在维护数据库时导致的问题更少。
- en: Setting up the correct data privilege mechanism
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置正确的数据权限机制
- en: PostgreSQL provides a fine-grained privilege system that dictates who can use
    a particular set of data and how that set of data can be accessed by an approved
    user. Because of its granular nature, creating an effective set of privileges
    can be confusing, and may result in undesired behavior. There are different levels
    of access that can be provided, from controlling who can connect to the database
    server itself, to who can query a view, to who can execute a PostGIS function.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: PostgreSQL 提供了一个细粒度的权限系统，它规定了谁可以使用特定的一组数据以及一组数据如何被授权用户访问。由于其细粒度特性，创建一个有效的权限集可能会令人困惑，并可能导致不希望的行为。可以提供不同级别的访问权限，从控制谁可以连接到数据库服务器本身，到谁可以查询视图，到谁可以执行
    PostGIS 函数。
- en: The challenges of establishing a good set of privileges can be minimized by
    thinking of the database as an onion. The outermost layer has generic rules and
    each layer inward applies rules that are more specific than the last. An example
    of this is a company's database server that only the company's network can access.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将数据库视为洋葱，可以最小化建立良好权限集的挑战。最外层有通用规则，每一层向内应用的规则比上一层更具体。一个例子是只有公司网络可以访问的公司数据库服务器。
- en: Only one of the company's divisions can access database A, which contains a
    schema for each department. Within one schema, all users can run the `SELECT`
    queries against views, but only specific users can add, update, or delete records
    from tables.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 公司的某个部门只能访问数据库 A，该数据库包含每个部门的模式。在一个模式内，所有用户都可以对视图执行 `SELECT` 查询，但只有特定的用户可以添加、更新或从表中删除记录。
- en: In PostgreSQL, users and groups are known as **roles**. A role can be parent
    to other roles that are themselves parents to even more roles.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PostgreSQL 中，用户和组被称为**角色**。一个角色可以是其他角色的父角色，而这些角色本身还可以是更多角色的父角色。
- en: Getting ready
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we focus on establishing the best set of privileges for the
    `postgis` schema created in the previous recipe. With the right selection of privileges,
    we can control who can use the contents of and apply operations to a geometry,
    geography, or raster column.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们专注于为之前菜谱中创建的 `postgis` 模式建立最佳的权限集。通过正确的权限选择，我们可以控制谁可以使用几何、地理或栅格列的内容并对其执行操作。
- en: One aspect worth mentioning is that the owner of a database object (such as
    the database itself, a schema, or a table) always has full control over that object.
    Unless someone changes the owner, the user who created the database object is
    typically the owner of the object.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的一个方面是，数据库对象（如数据库本身、模式或表）的所有者始终对该对象拥有完全控制权。除非有人更改所有者，否则通常创建数据库对象的用户是该对象的所有者。
- en: Again, when tested in Windows, the functionalities regarding the granting of
    permission worked on version 9.6.7 and did not work in version 9.6.3.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，当在 Windows 上测试时，关于权限授予的功能在版本 9.6.7 上工作，但在版本 9.6.3 上则不工作。
- en: How to do it...
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'In the preceding recipe, we imported several rasters and shapefiles to their
    respective tables. By default, access to those tables is restricted to only the
    user who performed the import operation, also known as the owner. The following
    steps permit other users to access those tables:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的菜谱中，我们将几个栅格和形状文件导入到相应的表中。默认情况下，对这些表的访问权限仅限于执行导入操作的用户，也称为所有者。以下步骤允许其他用户访问这些表：
- en: 'We need to create several groups and users in order for this recipe to demonstrate
    and test the privileges set in the `chapter10` database by executing the following
    commands:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了演示和测试通过以下命令在`chapter10`数据库中设置的权限，我们需要创建几个组和用户：
- en: '[PRE14]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The first two `CREATE ROLE` statements create the groups `group1` and `group2`.
    The last three `CREATE ROLE` statements create three users, with the `user1` and
    `user2` users assigned to `group1` and the `user3` user assigned to `group2`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个`CREATE ROLE`语句创建了`group1`和`group2`组。最后三个`CREATE ROLE`语句创建了三个用户，其中`user1`和`user2`用户分配给`group1`，而`user3`用户分配给`group2`。
- en: 'We want `group1` and `group2` to have access to the `chapter10` database. We
    want `group1` to be permitted to connect to the database and create temporary
    tables, while `group2` should be granted all database-level privileges, so we
    use the `GRANT` statement as follows:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望`group1`和`group2`能够访问`chapter10`数据库。我们希望`group1`被允许连接到数据库并创建临时表，而`group2`应被授予所有数据库级别的权限，因此我们使用以下`GRANT`语句：
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let''s check whether or not the `GRANT` statement worked by executing the following
    commands:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过执行以下命令来检查`GRANT`语句是否生效：
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '**![](img/f1835127-0ac0-44f9-b76f-1956fc2ac59c.png)**'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**![](img/f1835127-0ac0-44f9-b76f-1956fc2ac59c.png)**'
- en: 'As you can see, `group1` and `group2` are present in the `Access privileges`
    column of the `chapter10` database:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`group1`和`group2`出现在`chapter10`数据库的`访问权限`列中：
- en: '[PRE17]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'There is one thing in the privileges of `chapter10` that may be of concern
    to us:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`chapter10`的权限中有一件事可能让我们感到担忧：
- en: '[PRE18]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Unlike the privilege listings for `group1` and `group2`, this listing has no
    value before the equal sign (`*=*`). This listing is for the special metagroup
    `public`, which is built into PostgreSQL and to which all users and groups automatically
    belong.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 与`group1`和`group2`的权限列表不同，这个列表在等号之前没有值（`*=*`）。这个列表是为特殊元组`public`准备的，它是PostgreSQL内置的，并且所有用户和组都自动属于这个元组。
- en: 'We don''t want everyone to have access to the `chapter10` database, so we need
    to use the `REVOKE` statement to remove privileges from the `public` metagroup
    by executing the following command:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不希望每个人都能够访问`chapter10`数据库，因此我们需要使用`REVOKE`语句通过以下命令从`public`元组中移除权限：
- en: '[PRE19]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let''s see what the initial privileges are for the schemas of the `chapter10`
    database by executing the following command:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过执行以下命令来查看`chapter10`数据库模式的初始权限：
- en: '![](img/ba689d1e-20bb-4ea4-8f09-2a12352cbf16.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ba689d1e-20bb-4ea4-8f09-2a12352cbf16.png)'
- en: 'The `postgis` schema has no privileges listed. However, this does not mean
    that no one can access the `postgis` schema. Only the owner of the schema -`postgres`,
    in this case - can access it. We will grant access to the `postgis` schema to
    both `group1` and `group2` by executing the following command:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`postgis`模式没有列出任何权限。然而，这并不意味着没有人可以访问`postgis`模式。只有模式的所有者（在这个例子中是`postgres`）可以访问它。我们将通过执行以下命令将`postgis`模式的访问权限授予`group1`和`group2`：'
- en: '[PRE20]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We generally do not want to grant the `CREATE` privilege in the `postgis` schema
    to any user or group. New objects (such as functions, views, and tables) should
    not be added to the `postgis` schema.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常不希望将`CREATE`权限授予`postgis`模式中的任何用户或组。不应该向`postgis`模式添加新的对象（如函数、视图和表）。
- en: 'If we want all users and groups to have access to the `postgis` schema, we
    can grant the `USAGE` privilege to the metagroup `public` by executing the following
    command:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们想让所有用户和组都能访问`postgis`模式，我们可以通过执行以下命令将`USAGE`权限授予元组`public`：
- en: '[PRE21]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If you want to revoke this privilege, use the following command:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想撤销这个权限，请使用以下命令：
- en: '[PRE22]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Before continuing further, we should check that our privileges have been reflected
    in the database:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在继续之前，我们应该检查我们的权限是否已经在数据库中反映出来：
- en: '**![](img/49120cf3-41f7-4a23-8d50-fd4f88fa7982.png)**'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**![](img/49120cf3-41f7-4a23-8d50-fd4f88fa7982.png)**'
- en: Granting the `USAGE` privilege to a schema does not allow the granted users
    and groups to use any objects in the schema. The `USAGE` privilege only permits
    the users and groups to view the schema's child objects. Each child object has
    its own set of privileges, which we establish in the remaining steps.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 将`USAGE`权限授予一个模式并不允许被授予的用户和组在该模式中使用任何对象。`USAGE`权限仅允许用户和组查看模式的孩子对象。每个孩子对象都有自己的权限集，我们将在接下来的步骤中设置这些权限。
- en: PostGIS comes with more than 1,000 functions. It would be unreasonable to individually
    set privileges for each of those functions. Instead, we grant the `EXECUTE` privilege
    to the metagroup public and then grant and/or revoke privileges to specific functions,
    such as management functions.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: PostGIS附带超过1,000个函数。为每个函数单独设置权限是不合理的。相反，我们授予元组`public`的`EXECUTE`权限，然后为特定的函数（如管理函数）授予和/或撤销权限。
- en: 'First, grant the `EXECUTE` privilege to the metagroup `public` by executing
    the following command:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，通过执行以下命令将`EXECUTE`权限授予元组`public`：
- en: '[PRE23]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, revoke the `EXECUTE` privileges of the `public` metagroup for some functions,
    such as `postgis_full_version()`, by executing the following command:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，通过执行以下命令来撤销`public`元组对某些函数（如`postgis_full_version()`）的`EXECUTE`权限：
- en: '[PRE24]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If there are problems accessing the functions on the `postgis` schema, use
    the following command:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在`postgis`模式上访问函数有问题，请使用以下命令：
- en: '[PRE25]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `GRANT` and `REVOKE` statements do not differentiate between tables and
    views, so care must be taken to ensure that the applied privileges are appropriate
    for the object.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`GRANT`和`REVOKE`语句不会区分表和视图，因此必须小心确保所应用的权限适用于对象。'
- en: 'We will grant the `SELECT`, `REFERENCES`, and `TRIGGER` privileges to the `public`
    metagroup on all `postgis` tables and views by executing the following command;
    none of these privileges gives the `public` metagroup the ability to alter the
    tables'' or views'' contents:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将通过执行以下命令将`SELECT`、`REFERENCES`和`TRIGGER`权限授予`public`元组在所有`postgis`表和视图中；这些权限中的任何一个都不会赋予`public`元组更改表或视图内容的能力：
- en: '[PRE26]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We want to allow `group1` to be able to insert new records into the `spatial_ref_sys`
    table, so we must execute the following command:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望允许`group1`能够向`spatial_ref_sys`表插入新记录，因此我们必须执行以下命令：
- en: '[PRE27]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Groups and users that are not part of `group1` (such as `group2`) can only use
    the `SELECT` statements on `spatial_ref_sys`. Groups and users that are part of
    `group1` can now use the `INSERT` statement to add new spatial reference systems.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 不属于`group1`（如`group2`）的组和用户只能使用`spatial_ref_sys`上的`SELECT`语句。现在是`group1`的组和用户可以使用`INSERT`语句添加新的空间参考系统。
- en: 'Let''s give `user2`, which is a member of `group1`, the ability to use the
    `UPDATE` and `DELETE` statements on `spatial_ref_sys` by executing the following
    command; we are not going to give anyone the privilege to use the `TRUNCATE` statement
    on `spatial_ref_sys`:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过执行以下命令，给`user2`（`group1`的成员）赋予在`spatial_ref_sys`上使用`UPDATE`和`DELETE`语句的能力；我们不会给任何人赋予在`spatial_ref_sys`上使用`TRUNCATE`语句的权限：
- en: '[PRE28]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'After establishing the privileges, it is always good practice to check that
    they actually work. The best way to do so is by logging into the database as one
    of the users. We will use the `user3` user to do this by executing the following
    command:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在建立权限后，始终检查它们是否实际起作用是个好习惯。最好的做法是以其中一个用户登录到数据库。我们将通过执行以下命令使用`user3`用户来做这件事：
- en: '[PRE29]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, check that we can run a `SELECT` statement on the `spatial_ref_sys` table
    by executing the following commands:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，通过执行以下命令检查我们是否可以在`spatial_ref_sys`表上运行`SELECT`语句：
- en: '[PRE30]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Of if the schema need to be defined, use the following sentence:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要定义模式，请使用以下语句：
- en: '**![](img/3bd3c608-e4e1-409e-a288-db8316e507e8.png)**'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**![](img/3bd3c608-e4e1-409e-a288-db8316e507e8.png)**'
- en: 'Let''s try inserting a new record in `spatial_ref_sys` by executing the following
    commands:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过执行以下命令尝试在`spatial_ref_sys`中插入一条新记录：
- en: '[PRE31]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Excellent! Now update the records in `spatial_ref_sys` by executing the following
    commands:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 太好了！现在通过执行以下命令更新`spatial_ref_sys`中的记录：
- en: '[PRE32]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Run a final check on the `postgis_full_version()` function by executing the
    following commands:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行以下命令对`postgis_full_version()`函数进行最后的检查：
- en: '[PRE33]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: How it works...
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we granted and revoked privileges based on the group or user,
    with security increasing as a group or user descends into the database. This resulted
    in `group1` and `group2` being able to connect to the `chapter10` database and
    use objects found in the `postgis` schema. `group1` could also insert new records
    into the `spatial_ref_sys` table. Only `user2` was permitted to update or delete
    the records of `spatial_ref_sys`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们根据组或用户授予和撤销权限，随着组或用户向下进入数据库，安全性逐渐提高。这导致`group1`和`group2`能够连接到`chapter10`数据库并使用`postgis`模式中的对象。`group1`还可以向`spatial_ref_sys`表插入新记录。只有`user2`被允许更新或删除`spatial_ref_sys`的记录。
- en: The `GRANT` and `REVOKE` statements used in this recipe work, but they can be
    tedious to use with a command-line utility, such as `psql`. Instead, use a graphical
    tool, such as pgAdmin, that provides a grant wizard. Such tools also make it easier
    to check the behavior of the database after granting and revoking privileges.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中使用的 `GRANT` 和 `REVOKE` 语句是有效的，但使用命令行实用程序（如 `psql`）使用它们可能会很繁琐。相反，使用提供授权向导的图形工具，如
    pgAdmin。此类工具还使检查授权和撤销权限后数据库的行为变得更加容易。
- en: For additional practice, set up the privileges on the `public` schema and child
    objects so that, although `group1` and `group2` will be able to run the `SELECT`
    queries on the tables, only `group2` will be able to use the `INSERT` statement
    on the `caschools` table. You will also want to make sure that an `INSERT` statement
    executed by a user of `group2` actually works.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行额外的练习，设置 `public` 模式及其子对象的权限，以便尽管 `group1` 和 `group2` 将能够在表上运行 `SELECT`
    查询，但只有 `group2` 能够在 `caschools` 表上使用 `INSERT` 语句。你还需要确保 `group2` 的用户执行的 `INSERT`
    语句实际上可以工作。
- en: Backing up the database
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 备份数据库
- en: Maintaining functional backups of your data and work is probably the least appreciated,
    yet the most important thing you can do to improve your productivity (and stress
    levels). You may think that you don't need to have backups of your PostGIS database
    because you have the original data imported to the database, but do you remember
    all the work you did to develop the final product? How about the intermediary
    products? Even if you remember every step in the process, how much time will it
    take to create the intermediary and final products?
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 维护数据和工作功能备份可能是最不受重视的，但却是提高你生产力和压力水平最重要的事情。你可能认为你不需要备份你的 PostGIS 数据库，因为你已经将原始数据导入到数据库中，但你记得你为开发最终产品所做的工作吗？中间产品呢？即使你记得过程中的每一步，创建中间和最终产品需要多少时间？
- en: If any of these questions gives you pause, you need to create a backup for your
    data. Fortunately, PostgreSQL makes the backup process painless, or at least less
    painful than the alternatives.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些任何问题让你犹豫，你需要为你的数据创建一个备份。幸运的是，PostgreSQL 使备份过程变得简单，或者至少比其他方法痛苦少一些。
- en: Getting ready
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we use PostgreSQL's `pg_dump` utility. The `pg_dump` utility
    ensures that the data being backed up is consistent, even if it is currently in
    use.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们使用 PostgreSQL 的 `pg_dump` 工具。`pg_dump` 工具确保正在备份的数据是一致的，即使它目前正在使用中。
- en: How to do it...
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Use the following steps to back up a database:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下步骤来备份数据库：
- en: 'Start backing up the `chapter10` database by executing the following command:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行以下命令开始备份 `chapter10` 数据库：
- en: '[PRE34]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We use the `-f` flag to specify that the backup should be placed in the `chapter10.backup`
    file. We also use the `-F` flag to set the format of the backup output as custom
    - the most flexible and compressed of `pg_dump's` output formats by default.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `-f` 标志指定备份应放置在 `chapter10.backup` 文件中。我们还使用 `-F` 标志将备份输出格式设置为自定义 - 默认情况下，这是
    `pg_dump` 输出格式中最灵活和压缩的。
- en: 'Inspect the backup file by outputting the contents onto a SQL file by executing
    the following command:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行以下命令将内容输出到 SQL 文件来检查备份文件：
- en: '[PRE35]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: After creating a backup, it is good practice to make sure that the backup is
    valid. We do so with the `pg_restore` PostgreSQL tool. The `-f` flag instructs
    `pg_restore` to emit the restored output to a file instead of a database. The
    emitted output comprises standard SQL statements.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建备份后，确保备份有效是一个好习惯。我们使用 PostgreSQL 的 `pg_restore` 工具这样做。`-f` 标志指示 `pg_restore`
    将恢复输出到文件而不是数据库。发出的输出包括标准 SQL 语句。
- en: 'Use a text editor to view `chapter10.sql`. You should see blocks of SQL statements
    for creating tables, filling created tables, and setting privileges, as shown
    here:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用文本编辑器查看 `chapter10.sql`。你应该会看到创建表、填充已创建的表和设置权限的 SQL 语句块，如下所示：
- en: '****![](img/e2db1646-4fff-42f8-aa63-7c2bda5be17e.png)****'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '****![图片](img/e2db1646-4fff-42f8-aa63-7c2bda5be17e.png)****'
- en: 'And the files continue to show information about tables, sequences, and so
    on:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 并且文件继续显示有关表、序列等信息：
- en: '**![](img/d95a1938-6903-40d5-8808-d5b54a8b0d3d.png)**'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**![图片](img/d95a1938-6903-40d5-8808-d5b54a8b0d3d.png)**'
- en: 'Because we backed up the `chapter10` database using the custom format, we have
    fine-grained control over how `pg_restore` behaves and what it restores. Let''s
    extract only the `public` schema using the `-n` flag, as follows:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们使用自定义格式备份了 `chapter10` 数据库，因此我们对 `pg_restore` 的行为以及它恢复的内容有细粒度的控制。让我们使用 `-n`
    标志仅提取 `public` 模式，如下所示：
- en: '[PRE36]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: If you compare `chapter10_public.sql` to the `chapter10.sql` file exported in
    the preceding step, you will see that the `postgis` schema is not restored.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将 `chapter10_public.sql` 与前一步导出的 `chapter10.sql` 文件进行比较，你会看到 `postgis` 模式没有被恢复。
- en: How it works...
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As you can see, backing up your database is easy in PostgreSQL. Unfortunately,
    backups are meaningless if they are not performed on a regular schedule. If the
    database is lost or corrupted, any work done since the last backup is also lost.
    It is recommended that you perform backups at intervals that minimize the amount
    of work lost. The ideal interval will depend on the frequency of changes made
    to the database.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，在 PostgreSQL 中备份数据库非常简单。不幸的是，如果备份不是定期进行的，那么备份就没有意义。如果数据库丢失或损坏，自上次备份以来所做的任何工作也将丢失。建议你按照最小化丢失工作量的时间间隔进行备份。理想的时间间隔将取决于对数据库进行的更改频率。
- en: The `pg_dump` utility can be scheduled to run at regular intervals by adding
    a job to the operating system's task scheduler; the instructions for doing this
    are available in the PostgreSQL wiki at [http://wiki.postgresql.org/wiki/Automated_Backup_on_Windows](http://wiki.postgresql.org/wiki/Automated_Backup_on_Windows)
    and [http://wiki.postgresql.org/wiki/Automated_Backup_on_Linux](http://wiki.postgresql.org/wiki/Automated_Backup_on_Linux).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过向操作系统的任务调度器添加一个作业来安排 `pg_dump` 工具定期运行；有关如何操作的说明可以在 PostgreSQL 维基百科的 [http://wiki.postgresql.org/wiki/Automated_Backup_on_Windows](http://wiki.postgresql.org/wiki/Automated_Backup_on_Windows)
    和 [http://wiki.postgresql.org/wiki/Automated_Backup_on_Linux](http://wiki.postgresql.org/wiki/Automated_Backup_on_Linux)
    中找到。
- en: The `pg_dump` utility is not adequate for all situations. If you have a database
    undergoing constant changes or that is larger than a few tens of gigabytes, you
    will need a backup mechanism far more robust than that discussed in this recipe.
    Information regarding these robust mechanisms can be found in the PostgreSQL documentation
    at [http://www.postgresql.org/docs/current/static/backup.html](http://www.postgresql.org/docs/current/static/backup.html).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`pg_dump` 工具并不适用于所有情况。如果你有一个不断变化的数据库或者大于几十个吉字节，你需要一个比本食谱中讨论的更强大的备份机制。有关这些强大机制的信息可以在
    PostgreSQL 文档的 [http://www.postgresql.org/docs/current/static/backup.html](http://www.postgresql.org/docs/current/static/backup.html)
    中找到。'
- en: 'The following are several third-party backup tools available for establishing
    robust and advanced backup schemes:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些可用于建立强大和高级备份方案的第三方备份工具：
- en: Barman, which is available at [http://www.pgbarman.org](http://www.pgbarman.org)
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Barman 可在 [http://www.pgbarman.org](http://www.pgbarman.org) 获取
- en: pg-rman, which is available at [http://code.google.com/p/pg-rman](http://code.google.com/p/pg-rman)
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: pg-rman 可在 [http://code.google.com/p/pg-rman](http://code.google.com/p/pg-rman)
    获取
- en: Using indexes
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用索引
- en: A database index is very much like the index of a book (such as this one). While
    a book's index indicates the pages on which a word is present, a database column
    index indicates the rows in a table that contain a searched-for value. Just as
    a book's index does not indicate exactly where on the page a word is located,
    the database index may not be able to denote the exact location of the searched-for
    value in a row's column.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库索引非常类似于书籍的索引（如这本书的索引）。虽然一本书的索引指示了包含某个单词的页面，但数据库列索引指示了包含搜索值的表中的行。就像一本书的索引不会指示单词在页面上的确切位置一样，数据库索引可能无法表示搜索值在行列中的确切位置。
- en: PostgreSQL has several types of index, such as `B-Tree`, `Hash`, `GIST`, `SP-GIST`,
    and `GIN`. All of these index types are designed to help queries find matching
    rows faster. What makes the indices different are the underlying algorithms. Generally,
    to keep things simple, almost all PostgreSQL indexes are of the `B-Tree` type.
    PostGIS (spatial) indices are of the `GIST` type.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: PostgreSQL 有几种索引类型，如 `B-Tree`、`Hash`、`GIST`、`SP-GIST` 和 `GIN`。所有这些索引类型都是为了帮助查询更快地找到匹配的行而设计的。使索引不同的地方在于其底层算法。通常，为了保持简单，几乎所有
    PostgreSQL 索引都是 `B-Tree` 类型。PostGIS（空间）索引是 `GIST` 类型。
- en: Geometries, geographies, and rasters are all large, complex objects, and relating
    to or among these objects takes time. Spatial indices are added to the PostGIS
    data types to improve search performance. The performance improvement comes not
    from comparing actual, potentially complex, spatial objects, but rather the simple
    bounding boxes of those objects.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 几何形状、地理空间和栅格都是大型的复杂对象，与这些对象相关联或在这些对象之间进行关联需要时间。空间索引被添加到 PostGIS 数据类型中以提高搜索性能。性能提升不是来自比较实际的、可能复杂的空间对象，而是这些对象的简单边界框。
- en: Getting ready
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this recipe, `psql` will be used as follows to time the queries:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，`psql`将如下使用来计时查询：
- en: '[PRE37]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We will use the `caschools` and `sfpoly` tables loaded in this chapter's first
    recipe.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用本章第一个菜谱中加载的`caschools`和`sfpoly`表。
- en: How to do it...
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'The best way to see how a query can be affected by an index is by running the
    query before and after the addition of an index. In this recipe, in order to avoid
    the need to define the schema, all the tables are assumed to be on the public
    schema. The following steps will guide you through the process of optimizing a
    query with an index:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解查询如何受到索引的影响，最好的方法是运行添加索引前后的查询。在这个菜谱中，为了避免需要定义模式，所有表都被假定为位于public模式中。以下步骤将指导您通过使用索引优化查询的过程：
- en: 'Run the following query, which returns the names of all the schools found in
    San Francisco:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下查询，该查询返回在旧金山找到的所有学校的名称：
- en: '[PRE38]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The results from the query do not matter. We are more interested in the time
    it took to run the query. When we run the query three times, it runs with the
    following elapsed times; your numbers may be different from these numbers:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查询的结果并不重要。我们更感兴趣的是查询的运行时间。当我们运行查询三次时，它的运行时间如下；您的数字可能与这些数字不同：
- en: '[PRE39]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The query ran quickly. But, if the query needs to be run many times (say 1,000
    times), it will take more than 500 seconds to run it that number of times. Can
    the query run faster? Use `EXPLAIN ANALYZE` to see how PostgreSQL runs the query,
    as follows:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查询运行得很快。但是，如果需要多次运行查询（比如说1,000次），那么运行这么多次将需要超过500秒。查询能否运行得更快？使用`EXPLAIN ANALYZE`来查看PostgreSQL如何运行查询，如下所示：
- en: '[PRE40]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Adding `EXPLAIN ANALYZE` before the query instructs PostgreSQL to return the
    actual plan used to execute the query, as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在查询之前添加`EXPLAIN ANALYZE`指示PostgreSQL返回用于执行查询的实际计划，如下所示：
- en: '![](img/1cedc1ca-7e3d-4fb2-8ac5-5a26b408acc9.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1cedc1ca-7e3d-4fb2-8ac5-5a26b408acc9.png)'
- en: What is significant in the preceding `QUERY PLAN` is `Join Filter`, which has
    consumed most of the execution time. This may be happening because the `caschools`
    table does not have a spatial index on the `geom` column.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的`查询计划`中，重要的是`连接过滤器`，它消耗了大部分执行时间。这可能是因为`caschools`表在`geom`列上没有空间索引。
- en: 'Add a spatial index to the `geom` column, as follows:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式在`geom`列上添加空间索引：
- en: '[PRE41]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Rerun the query from step 1 three times so as to minimize runtime variations.
    With a spatial index, the query ran with the following elapsed query times:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复执行步骤1三次以最小化运行时间的差异。使用空间索引，查询的运行时间如下：
- en: '[PRE42]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The query did not run much faster with the spatial index. What happened? We
    need to check the `QUERY PLAN`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 查询并没有因为空间索引而运行得更快。发生了什么？我们需要检查`查询计划`。
- en: 'You can see whether or not, or even how the `QUERY PLAN` changed in PostgreSQL
    using `EXPLAIN ANALYZE`, as follows:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以使用`EXPLAIN ANALYZE`查看PostgreSQL中`查询计划`是否以及如何改变，如下所示：
- en: '![](img/beca8da3-a674-440e-b267-f282a6c016d5.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/beca8da3-a674-440e-b267-f282a6c016d5.png)'
- en: The `QUERY PLAN` table is the same as that found in *step 4*. The query is not
    using the spatial index. Why?
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`查询计划`表与*步骤4*中找到的相同。查询没有使用空间索引。为什么？'
- en: If you look at the query, we used `ST_Transform()` to reproject `caschools.geom`
    on the spatial reference system of `sfpoly.geom`. The `ST_Transform()` geometries
    used in the `ST_Intersects()` spatial test were in SRID 3310, but the geometries
    used for the `caschools_geom_idx` index were in SRID 4269\. This difference in
    spatial reference systems prevented the use of the index in the query.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果查看查询，我们使用了`ST_Transform()`将`caschools.geom`重新投影到`sfpoly.geom`的空间参考系上。在`ST_Intersects()`空间测试中使用的`ST_Transform()`几何形状位于SRID
    3310，但用于`caschools_geom_idx`索引的几何形状位于SRID 4269。这种空间参考系的不同阻止了在查询中使用索引。
- en: 'We can create a spatial index that uses geometries projected in the desired
    spatial reference system. An index that uses a function is known as a **functional
    index**. It can be created as follows:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以创建一个使用在所需空间参考系中投影的几何形状的空间索引。使用函数的索引被称为**函数索引**。它可以按照以下方式创建：
- en: '[PRE43]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Rerun the query from step 1 three times to get the following output :'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复执行步骤1三次以获得以下输出：
- en: '[PRE44]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: That's better! The duration of the process has decreased from about 135 ms to
    60 ms.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这更好！过程的持续时间从大约135毫秒减少到60毫秒。
- en: 'Check the `QUERY PLAN` table as follows:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式检查`查询计划`表：
- en: '**![](img/b78beb79-9794-4c27-9580-9892ae640541.png)**'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '**![图片](img/b78beb79-9794-4c27-9580-9892ae640541.png)**'
- en: The plan shows that the query used the `caschools_geom_3310_idx` index. The
    `Index Scan` command was significantly faster than the previously used `Join Filter`
    command.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 计划显示查询使用了`caschools_geom_3310_idx`索引。`Index Scan`命令比之前使用的`Join Filter`命令快得多。
- en: How it works...
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Database indices help us quickly and efficiently find the values we are interested
    in. Generally, a query using an index is faster than one that is not, but the
    performance improvement may not be to the degree found in this recipe.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库索引帮助我们快速有效地找到我们感兴趣的值。通常，使用索引的查询比不使用索引的查询要快，但性能提升可能不会像本食谱中找到的那样显著。
- en: 'Additional information about PostgreSQL and PostGIS indices can be found at
    the following links:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 PostgreSQL 和 PostGIS 索引的更多信息可以在以下链接中找到：
- en: '[https://www.postgresql.org/docs/9.6/static/indexes.html](https://www.postgresql.org/docs/9.6/static/indexes.html)'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.postgresql.org/docs/9.6/static/indexes.html](https://www.postgresql.org/docs/9.6/static/indexes.html)'
- en: '[https://postgis.net/docs/using_postgis_dbmanagement.html#idm2267](https://postgis.net/docs/using_postgis_dbmanagement.html#idm2267)'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://postgis.net/docs/using_postgis_dbmanagement.html#idm2267](https://postgis.net/docs/using_postgis_dbmanagement.html#idm2267)'
- en: We will discuss query plans in greater detail in a later recipe in this chapter.
    By understanding query plans, it becomes possible to optimize the performance
    of deficient queries.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面的食谱中更详细地讨论查询计划。通过理解查询计划，可以优化性能不佳的查询。
- en: Clustering for efficiency
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 效率聚类
- en: Most users stop optimizing the performance of a table after adding the appropriate
    indices. This usually happens because the performance reaches a point where it
    is good enough. But what if the table has millions or billions of records? This
    amount of information may not fit in the database server's RAM, thereby forcing
    hard drive access. Generally, table records are stored sequentially on the hard
    drive. But the data being fetched for a query from the hard drive may be accessing
    many different parts of the hard drive. Having to access different parts of a
    hard drive is a known performance limitation.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数用户在添加适当的索引后就会停止优化表性能。这通常是因为性能已经足够好。但如果表有数百万或数十亿条记录呢？这么多的信息可能无法适应数据库服务器的 RAM，从而迫使访问硬盘。通常，表记录在硬盘中按顺序存储。但查询从硬盘中检索的数据可能需要访问硬盘的许多不同部分。需要访问硬盘的不同部分是一个已知的性能限制。
- en: To mitigate hard drive performance issues, a database table can have its records
    reordered on the hard drive so that similar record data is stored next to or near
    each other. The reordering of a database table is known as **clustering** and
    is used with the `CLUSTER` statement in PostgreSQL.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减轻硬盘性能问题，数据库表可以在硬盘中重新排序其记录，以便相似的记录数据存储在彼此附近。数据库表的重新排序称为**聚类**，并用于 PostgreSQL
    中的`CLUSTER`语句。
- en: Getting ready
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will use the California schools (`caschools`) and San Francisco boundaries
    (`sfpoly`) tables for this recipe. If neither table is available, refer to the
    first recipe of this chapter.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用加利福尼亚学校（`caschools`）和旧金山边界（`sfpoly`）表来完成本食谱。如果这两个表都不可用，请参考本章的第一个食谱。
- en: 'The `psql` utility will be used for this recipe''s queries, as shown here:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的查询将使用`psql`实用工具，如下所示：
- en: '[PRE45]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: How to do it...
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Use the following steps to cluster a table:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下步骤对表进行聚类：
- en: 'Before using the `CLUSTER` statement, check the time at which the query used
    in the previous recipe was executed by executing the following commands:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在使用`CLUSTER`语句之前，通过执行以下命令检查之前食谱中使用的查询的时间：
- en: '[PRE46]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We get the following performance numbers for three query runs:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们得到了以下三次查询运行的性能数字：
- en: '[PRE47]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Cluster the `caschools` table using the `caschools_geom_3310_idx` index as
    follows:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`caschools_geom_3310_idx`索引对`caschools`表进行聚类，如下所示：
- en: '[PRE48]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Rerun the query from the first step three times for the following performance
    timings:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新运行第一步中的查询三次，以获取以下性能时间：
- en: '[PRE49]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The performance improvements were not significant.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 性能提升并不显著。
- en: How it works...
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Using the `CLUSTER` statement on the `caschools` table did not result in a significant
    performance boost. The lesson here is that, despite the fact that the data is
    physically reordered based on the index information in order to optimize searching,
    there is no guarantee that query performance will improve on a clustered table.
    Clustering should be reserved for tables with many large records only after adding
    the appropriate indices to and optimizing queries for the tables in question.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在`caschools`表上使用`CLUSTER`语句并没有带来显著的性能提升。这里的教训是，尽管数据是根据索引信息在物理上进行重新排序以优化搜索，但并不能保证查询性能在分簇表中会得到提升。分簇应仅用于已添加适当索引并优化了查询的表，并且只有当记录很大时才使用。
- en: Optimizing SQL queries
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化SQL查询
- en: When an SQL query is received, PostgreSQL runs the query through its planner
    to decide the best execution plan. The best execution plan generally results in
    the fastest query performance. Though the planner usually makes the correct choices,
    on occasion, a specific query will have a suboptimal execution plan.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 当接收到一个SQL查询时，PostgreSQL会通过其规划器运行查询以决定最佳执行计划。最佳执行计划通常会导致最快的查询性能。尽管规划器通常做出正确的选择，但有时特定的查询可能会有次优的执行计划。
- en: 'For these situations, the following are several things that can be done to
    change the behavior of the PostgreSQL planner:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些情况，以下是一些可以采取的措施来改变PostgreSQL规划器的行为：
- en: Add appropriate column indices to the tables in question
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向相关表添加适当的列索引
- en: Update the statistics of the database tables
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新数据库表的统计信息
- en: Rewrite the SQL query by evaluating the query's execution plan and using capabilities
    available in your PostgreSQL installation
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过评估查询的执行计划并使用PostgreSQL安装中可用的功能来重写SQL查询
- en: Consider changing or adding the layout of the database tables
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑更改或添加数据库表的布局
- en: Change the query planner's configuration
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改查询规划器的配置
- en: Adding indices (the first bullet point) is discussed in a separate recipe found
    in this chapter. Updating statistics (the second point) is generally done automatically
    by PostgreSQL after a certain amount of table activity, but the statistics can
    be manually updated using the `ANALYZE` statement. Changing the database layout
    and the query planner's configuration (the fourth and fifth bullet point, respectively)
    are advanced operations used only when the first three points have already been
    attempted and, thus, will not be discussed further.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 添加索引（第一个要点）在本章的另一个单独的食谱中有讨论。更新统计信息（第二个要点）通常在表活动达到一定量后由PostgreSQL自动完成，但可以使用`ANALYZE`语句手动更新统计信息。更改数据库布局和查询规划器的配置（分别对应第四和第五个要点）是仅在尝试了前三个要点之后才使用的先进操作，因此将不再进一步讨论。
- en: This recipe only discusses the third option - that is, optimizing performance
    by rewriting SQL queries.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱仅讨论第三种选项——即通过重写SQL查询来优化性能。
- en: Getting ready
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we will find the nearest police station to every school and
    the distance in meters between each school in San Francisco and its nearest station;
    we will attempt to do this as fast as possible. This will require us to rewrite
    our query many times to be more efficient and take advantage of the new PostgreSQL
    capabilities. For this recipe, ensure that you also include the `capolice` table.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个食谱，我们将找到每个学校的最近警察局以及旧金山每个学校与其最近警察局之间的米距离；我们将尝试尽可能快地完成这项任务。这需要我们多次重写查询以使其更高效并利用新的PostgreSQL功能。为此食谱，请确保还包括`capolice`表。
- en: How to do it...
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'The following steps will guide you through the iterative process required to
    improve query performance:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将指导您通过迭代过程来提高查询性能：
- en: 'To find a school''s nearest police station and the distance between each school
    in San Francisco and its nearest station, we will start by executing the following
    query:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要找到旧金山的每个学校的最近警察局以及每个学校与其最近警察局之间的距离，我们首先将执行以下查询：
- en: '[PRE50]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Generally speaking, this is a crude and simplistic query. The subquery `scpo`
    occurs twice in the query because it needs to compute the shortest distance from
    a school to its nearest police station and the name of the police station closest
    to each school. If each instance of `scpo` took 10 seconds to compute, two instances
    of `scpo` would take 20 seconds. This is very detrimental to performance.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一般而言，这是一个粗略且简单的查询。子查询 `scpo` 在查询中出现了两次，因为它需要计算学校到最近警察局的最近距离以及每个学校最近的警察局名称。如果每个
    `scpo` 实例需要 10 秒来计算，那么两个实例就需要 20 秒。这对性能非常有害。
- en: 'Note: the time may vary substantially between experiments, depending on the
    machine configuration, database usage, and so on. However, the changes in the
    duration of the experiments will be noticeable and should follow the same improvement
    ratio presented in this section.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：实验的时间可能会因机器配置、数据库使用等因素而有很大差异。然而，实验持续时间的改变将是明显的，并且应该遵循本节中展示的相同改进比率。
- en: 'The query output looks as follows:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 查询输出如下：
- en: '**![](img/2bd4c201-1c99-4e8b-9d4f-19788c436949.png)**'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '**![](img/2bd4c201-1c99-4e8b-9d4f-19788c436949.png)**'
- en: '...'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '**![](img/f80ecca2-dd69-41bc-8517-8620721fe083.png)**'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '**![](img/f80ecca2-dd69-41bc-8517-8620721fe083.png)**'
- en: 'The query results provide the addresses of the schools in San Francisco, the
    addresses of the closest police station to each of those schools, and the distance
    from each school to its closest police station. However, we are also interested
    in getting the answer as fast as possible. With timing turned on in `psql`, we
    get the following performance numbers for three runs of the query:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查询结果提供了旧金山的学校地址，以及每所学校最近的警察局的地址和距离。然而，我们也很感兴趣尽快得到答案。在 `psql` 中开启计时，我们得到以下三次查询的性能数据：
- en: '[PRE51]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Just by looking at the query in step 1, we can see that there are redundant
    subqueries. Let''s get rid of those duplicates using **common table expressions**
    (**CTEs**), introduced in PostgreSQL 8.4\. CTEs are used to logically and syntactically
    separate a block of SQL from subsequent parts of the query. Since CTEs are logically
    separated, they are run at the start of the query execution and their results
    are cached for subsequent use:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只需查看第一步中的查询，我们就可以看到存在冗余的子查询。让我们使用在 PostgreSQL 8.4 版本中引入的**公共表表达式**（**CTEs**）来消除这些重复。CTEs
    用于逻辑上和语法上从查询的后续部分中分离出一段 SQL。由于 CTEs 是逻辑上分离的，它们在查询执行开始时运行，并且其结果被缓存以供后续使用：
- en: '[PRE52]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Not only is the query syntactically cleaner, but the performance is improved,
    as shown here:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不仅查询在语法上更简洁，性能也有所提高，如下所示：
- en: '[PRE53]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The execution times went from more than 5 seconds to less than 3 seconds.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 执行时间从超过 5 秒减少到不到 3 秒。
- en: 'Though some may stop optimizing this query at this point, we will continue
    to improve the query performance. We can use the window functions, which are another
    PostgreSQL capability introduced in v8.4\. Using the window functions as follows,
    we can get rid of the `JOIN` expression:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尽管有些人可能会在这个时候停止优化这个查询，但我们将继续提高查询性能。我们可以使用窗口函数，这是在 v8.4 版本中引入的另一个 PostgreSQL
    功能。如下使用窗口函数，我们可以消除 `JOIN` 表达式：
- en: '[PRE54]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We use the `first_value()` window function to extract the first `police_address`
    and `distance` values for each school sorted by the distance between the school
    and a police station. The improvement is considerable, reducing from almost 3
    seconds to around 1.2 seconds:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用 `first_value()` 窗口函数提取每个学校按学校与警察局之间的距离排序的第一个 `police_address` 和 `distance`
    值。改进相当显著，从几乎 3 秒减少到大约 1.2 秒：
- en: '[PRE55]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'However, it is worth to inspect the execution plan with `EXPLAIN ANALYZE VERBOSE`
    to see what is decreasing the query performance. Because of the verbosity of the
    output, we''ve trimmed it to just the following lines of interest:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，使用 `EXPLAIN ANALYZE VERBOSE` 检查执行计划是值得的，以查看是什么降低了查询性能。由于输出非常冗长，我们只剪裁了以下几行感兴趣的内容：
- en: '**![](img/9d14f781-b3a1-4456-8c64-bf3e42a3c659.png)**'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '**![](img/9d14f781-b3a1-4456-8c64-bf3e42a3c659.png)**'
- en: '[PRE56]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: In the `EXPLAIN ANALYZE VERBOSE` output, we want to inspect the values for the
    actual time, which provide the actual start and end times for that part of the
    query. Of all the actual time ranges, the actual time value of 15.047..1186.907
    for the `Nested Loop` (highlighted in the preceding output) is the worst. This
    query step consumes at least 80 percent of the total execution time, so any work
    done to improve performance must be done in this step.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`EXPLAIN ANALYZE VERBOSE`的输出中，我们想要检查实际时间的值，这些值提供了查询该部分的实际开始和结束时间。在所有实际时间范围内，`Nested
    Loop`（在先前的输出中突出显示）的实际时间值15.047..1186.907是最差的。这个查询步骤至少消耗了总执行时间的80%，因此任何旨在提高性能的工作都必须在这个步骤中完成。
- en: The columns returned from the slow `Nested Loop` utility are found in the value
    for the output. Of these columns, `st_distance()` is present only in this step
    and not in any inner step. This means we will need to mitigate the number of calls
    to `ST_Distance()`.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从慢速`Nested Loop`实用程序返回的列可以在输出值中找到。在这些列中，`st_distance()`只存在于这一步，而不在任何内部步骤中。这意味着我们需要减轻对`ST_Distance()`的调用次数。
- en: At this step, further query improvements are not possible without running PostgreSQL
    9.1 or a later version. PostgreSQL 9.1 introduced indexed nearest-neighbor searches
    using the `<->` and `<#>` operators to compare the geometries' convex hulls and
    bounding boxes, respectively. For point geometries, both operators result in the
    same answer.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一步，没有运行PostgreSQL 9.1或更高版本，进一步的查询改进是不可能的。PostgreSQL 9.1引入了使用`<->`和`<#>`运算符的索引最近邻搜索，分别用于比较几何图形的凸包和边界框。对于点几何图形，这两个运算符得出相同的答案。
- en: 'Let''s rewrite the query to take advantage of the `<->` operator. The following
    query still uses the CTEs and window functions:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们重写查询以利用`<->`运算符。以下查询仍然使用了CTEs和窗口函数：
- en: '[PRE57]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The query has the following performance numbers:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该查询有以下性能指标：
- en: '[PRE58]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Wow! Using indexed nearest-neighbor searches with the `<->` operator, we reduced
    our initial query from one second to less than a tenth of a second.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！使用带索引的最近邻搜索和`<->`运算符，我们将初始查询从一秒减少到不到十分之一秒。
- en: How it works...
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we optimized a query that users may commonly encounter while
    using PostGIS. We started by taking advantage of the PostgreSQL capabilities to
    improve the performance and syntax of our query. When performance could no longer
    improve, we ran `EXPLAIN ANALYZE VERBOSE` to find out what was consuming most
    of the query-execution time. We learned that the `ST_Distance()` function consumed
    the most time from the execution plan. We finally used the `<->` operator of PostgreSQL
    9.1 to dramatically improve the query-execution time to under a second.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们优化了一个用户在使用PostGIS时可能会遇到的查询。我们首先利用PostgreSQL的功能来提高查询的性能和语法。当性能不能再提高时，我们运行`EXPLAIN
    ANALYZE VERBOSE`以找出消耗查询执行时间最多的是什么。我们了解到`ST_Distance()`函数消耗了执行计划中最多的时间。我们最终使用了PostgreSQL
    9.1的`<->`运算符，显著提高了查询执行时间，使其低于一秒。
- en: 'The output of `EXPLAIN ANALYZE VERBOSE` used in this recipe is not easy to
    understand. For complex queries, it is recommended that you use the visual output
    in pgAdmin (discussed in a separate chapter''s recipe) or the color coding provided
    by the [http://explain.depesz.com/](http://explain.depesz.com/) web service, as
    shown in the following screenshot:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱中使用的`EXPLAIN ANALYZE VERBOSE`输出不易理解。对于复杂的查询，建议您使用pgAdmin中的可视化输出（在单独章节的菜谱中讨论）或[http://explain.depesz.com/](http://explain.depesz.com/)网络服务提供的颜色编码，如下面的截图所示：
- en: '![](img/26713564-98ba-4901-ae34-3e187fd27ab1.png)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![](img/26713564-98ba-4901-ae34-3e187fd27ab1.png)'
- en: Migrating a PostGIS database to a different server
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将PostGIS数据库迁移到不同的服务器
- en: At some point, user databases need to be migrated to a different server. This
    need for server migration could be due to new hardware or a database-server software
    upgrade.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在某个时候，用户数据库需要迁移到不同的服务器。这种服务器迁移的需求可能是由于新的硬件或数据库服务器软件升级。
- en: 'The following are the three methods available for migrating a database:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是将数据库迁移的三个可用方法：
- en: Dumping and restoring the database with `pg_dump` and `pg_restore`
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`pg_dump`和`pg_restore`导出和恢复数据库
- en: Performing an in-place upgrade of the database with `pg_upgrade`
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`pg_upgrade`对数据库进行就地升级
- en: Performing streaming replication from one server to another
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从一个服务器到另一个服务器的流式复制
- en: Getting ready
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we will use the `dump` and `restore` methods to move user data
    to a new database with a new PostGIS installation. Unlike the other methods, this
    method is the most foolproof, works in all situations, and stores a backup in
    case things don't work as expected.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在本菜谱中，我们将使用`dump`和`restore`方法将用户数据移动到具有新PostGIS安装的新数据库。与其他方法不同，这种方法是最保险的，适用于所有情况，并在预期不按预期工作时存储备份。
- en: As mentioned before, creating a schema specifically to work with PostGIS may
    not work properly for Windows users. Working on the `public` schema is an option
    in order to test the results.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，为与PostGIS一起使用而创建的特定模式可能对Windows用户不起作用。在`public`模式上工作是一个测试结果的选择。
- en: How to do it...
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'On the command line, perform the following steps:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令行中，执行以下步骤：
- en: 'Even though a backup file was created in this chapter''s third recipe, create
    a new backup file by executing the following command:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尽管在本章的第三个菜谱中已创建了一个备份文件，但通过执行以下命令创建一个新的备份文件：
- en: '[PRE59]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Create a new database to which the backup file will be restored by executing
    the following commands:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行以下命令创建一个新的数据库，将备份文件恢复到该数据库：
- en: '[PRE60]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Connect to the `new10`, database and create a `postgis` schema as follows:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接到`new10`数据库并创建一个`postgis`模式，如下所示：
- en: '[PRE61]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Execute the `CREATE EXTENSION command to install the Postgis extension in the
    postgis schema`:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行`CREATE EXTENSION`命令在`postgis`模式中安装PostGIS扩展：
- en: '[PRE62]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Make sure you set the `search_path` parameter to include the `postgis` schema,
    as follows:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保您已将`search_path`参数设置为包含`postgis`模式，如下所示：
- en: '[PRE63]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Restore only the `public` schema from the backup file to the `new10` database
    by executing the following command:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行以下命令仅从备份文件中恢复`public`模式到`new10`数据库：
- en: '[PRE64]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The `restore` method runs and should not generate errors. If it does, an error
    message such as the following will appear:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`restore`方法运行时不应生成错误。如果生成了错误，将出现如下错误消息：'
- en: '[PRE65]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: We have now installed PostGIS in the `postgis` schema, but the database server
    can't find the `ST_BandMetadata()` function. If a function cannot be found, it
    is usually an issue with `search_path`. We will fix this issue in the next step.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已在`postgis`模式中安装了PostGIS，但数据库服务器找不到`ST_BandMetadata()`函数。如果找不到函数，通常与`search_path`有关。我们将在下一步修复此问题。
- en: 'Check what `pg_restore` actually does by executing the following command:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行以下命令检查`pg_restore`实际上执行了什么：
- en: '[PRE66]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Looking at the `COPY` statement for the prism table, everything looks fine.
    But the `search_path` method preceding the table does not include the `postgis`
    schema as shown here:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看prism表的`COPY`语句，一切看起来都很正常。但在此表之前显示的`search_path`方法没有包含`postgis`模式，如下所示：
- en: '[PRE67]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Change the `search_path` value in `chapter10.sql` to include the `postgis`
    schema by executing the following command:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行以下命令将`chapter10.sql`中的`search_path`值更改为包含`postgis`模式：
- en: '[PRE68]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Run `chapter10.sql` with `psql`, as follows; the original `chapter10.backup`
    file can''t be used because the necessary change can''t be applied to `pg_restore`:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`psql`运行`chapter10.sql`，如下所示；原始`chapter10.backup`文件不能使用，因为无法将必要更改应用于`pg_restore`：
- en: '[PRE69]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: How it works...
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This procedure is essentially the standard PostgreSQL backup and restore cycle.
    It may not be simple, but has the benefit of being accessible in terms of the
    tools used and the control available in each step of the process. Though the other
    migration methods may be convenient, they typically require faith in an opaque
    process or the installation of additional software.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 此过程本质上与标准的PostgreSQL备份和恢复周期相同。它可能不是简单的，但具有使用工具和过程每个步骤中可用的控制的优点。尽管其他迁移方法可能方便，但它们通常需要相信一个不透明的过程或安装额外的软件。
- en: Replicating a PostGIS database with streaming replication
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用流复制复制PostGIS数据库
- en: The reality of the world is that, given enough time, everything will break.
    This includes the hardware and software of computers running PostgreSQL. To protect
    data in PostgreSQL from corruption or loss, backups are taken using tools such
    as `pg_dump`. However, restoring a database backup can take a very long time,
    during which users cannot use the database.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 世界的现实是，给定足够的时间，一切都会出问题。这包括运行PostgreSQL的计算机的硬件和软件。为了保护PostgreSQL中的数据免受损坏或丢失，使用`pg_dump`等工具进行备份。然而，恢复数据库备份可能需要非常长的时间，在此期间用户无法使用数据库。
- en: When downtime must be kept to a minimum or is not acceptable, one or more standby
    servers are used to compensate for the failed primary PostgreSQL server. The data
    on the standby server is kept in sync with the primary PostgreSQL server by streaming
    data as frequently as possible.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 当必须将停机时间保持在最低限度或不可接受时，可以使用一个或多个备用服务器来补偿失败的 PostgreSQL 主服务器。备用服务器上的数据将通过尽可能频繁地流式传输数据与主
    PostgreSQL 服务器保持同步。
- en: In addition, you are strongly discouraged from trying to mix different PostgreSQL
    versions. Primary and standby servers must run the same PostgreSQL version.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，强烈建议你不要尝试混合不同的 PostgreSQL 版本。主服务器和备用服务器必须运行相同的 PostgreSQL 版本。
- en: Getting ready
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we will use the streaming replication capability introduced
    in PostgreSQL 9.X. This recipe will use one server with two parallel PostgreSQL
    installations instead of the typical two or more servers, each with one PostgreSQL
    installation. We will use two new database clusters in order to keep things simple.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用 PostgreSQL 9.X 中引入的流复制功能。这个菜谱将使用一个服务器上的两个并行 PostgreSQL 安装，而不是典型的两个或更多服务器，每个服务器上有一个
    PostgreSQL 安装。我们将使用两个新的数据库集群以保持事情简单。
- en: How to do it...
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Use the following steps to replicate a PostGIS database:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下步骤来复制一个 PostGIS 数据库：
- en: 'Create directories for the primary and standby database clusters by executing
    the following commands:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行以下命令创建主数据库集群和备用数据库集群的目录：
- en: '[PRE70]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Initialize the database clusters with `initdb` as follows, defining the user
    `me` as the owner of the database:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `initdb` 初始化数据库集群，如下所示，将用户 `me` 定义为数据库的所有者：
- en: '[PRE71]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: You may opt for avoiding the `--locale=en_US.utf-8` option if an error occurs;
    in that case, the system will adopt the default locale on your computer.
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果出现错误，你可以选择避免使用 `--locale=en_US.utf-8` 选项；在这种情况下，系统将采用计算机上的默认区域设置。
- en: 'Create directories for the archives of the primary and standby database clusters
    by executing the following commands:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行以下命令创建主数据库集群和备用数据库集群的归档目录：
- en: '[PRE72]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Open the `pg_hba.conf` authentication file of the primary cluster with your
    preferred editing application.
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你喜欢的编辑应用程序打开主集群的 `pg_hba.conf` 认证文件。
- en: 'If you''re running PostgreSQL 9.0, add the following text to the end of `pg_hba.conf`:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你正在运行 PostgreSQL 9.0，请将以下文本添加到 `pg_hba.conf` 文件的末尾：
- en: '**![](img/09148717-56b5-4ed5-8162-a265d8531a68.png)**'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '**![](img/09148717-56b5-4ed5-8162-a265d8531a68.png)**'
- en: For PostgreSQL 9.1 or a later version, the configuration lines are already part
    of the `pg_hba.conf` file. You just need to remove the comment character (*#*)
    from the beginning of each matching line.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 PostgreSQL 9.1 或更高版本，配置行已经包含在 `pg_hba.conf` 文件中。你只需从每个匹配行的开头删除注释字符（*#*）。
- en: 'Edit the primary cluster''s `postgresql.conf` configuration file to set the
    streaming replication parameters. Search for each parameter, uncomment and replace
    the assigned value to the following:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑主集群的 `postgresql.conf` 配置文件，设置流复制参数。搜索每个参数，取消注释并替换分配的值如下：
- en: '[PRE73]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'A relative location could also be used:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以使用相对位置：
- en: '[PRE74]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'When using Linux or macOS type instead:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 Linux 或 macOS 时，请使用以下类型：
- en: '[PRE75]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Start PostgreSQL on the primary database cluster by executing the following
    command:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行以下命令在主数据库集群上启动 PostgreSQL：
- en: '[PRE76]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Create a base backup of the primary database cluster and copy it to the standby
    database cluster. Before performing the backup, create an exclusion list file
    for `xcopy` (Windows only) by executing the following command:'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建主数据库集群的基础备份并将其复制到备用数据库集群。在执行备份之前，通过执行以下命令为 `xcopy` 创建一个排除列表文件（仅限 Windows）：
- en: '[PRE77]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Add the following to `exclude.txt`:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下内容添加到 `exclude.txt`：
- en: '[PRE78]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Run the base backup and copy the directory contents from the primary to the
    standby database cluster, as follows:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行以下操作以运行基础备份并将目录内容从主数据库集群复制到备用数据库集群：
- en: '[PRE79]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Make the following changes to the standby cluster''s `postgresql.conf` configuration
    file uncommenting these parameters and adjusting the values:'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对备用集群的 `postgresql.conf` 配置文件进行以下更改，取消注释这些参数并调整值：
- en: '[PRE80]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'A relative location could also be used:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以使用相对位置：
- en: '[PRE81]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'When using Linux or macOS type instead:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 Linux 或 macOS 时，请使用以下类型：
- en: '[PRE82]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Create the `recovery.conf` configuration file in the standby cluster directory
    by executing the following command for Windows:'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行以下命令在备用集群目录中创建 `recovery.conf` 配置文件（针对 Windows）：
- en: '[PRE83]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'For Linux or macOS:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Linux 或 macOS：
- en: '[PRE84]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Enter the following in the `recovery.conf` configuration file and save the
    changes:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `recovery.conf` 配置文件中输入以下内容并保存更改：
- en: '[PRE85]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Or a relative location could be used also:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 或者也可以使用相对位置：
- en: '[PRE86]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'For Linux or macOS use:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Linux或macOS使用：
- en: '[PRE87]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Start PostgreSQL on the standby database cluster by executing the following
    command:'
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行以下命令在备用数据库集群上启动PostgreSQL：
- en: '[PRE88]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Run some simple tests to make sure the replication is working.
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行一些简单的测试以确保复制工作正常。
- en: 'Create the `test` database and the `test` table on the primary database server
    by executing the following commands:'
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行以下命令在主数据库服务器上创建`test`数据库和`test`表：
- en: '[PRE89]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Connect to the standby database server by executing the following command:'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行以下命令连接到备用数据库服务器：
- en: '[PRE90]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'See if the `test` database is present by executing the following command:'
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行以下命令检查`test`数据库是否存在：
- en: '[PRE91]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '****![](img/bddc7f6b-50a0-4d2b-99ff-29ae5fc3cb10.png)****'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '****![](img/bddc7f6b-50a0-4d2b-99ff-29ae5fc3cb10.png)****'
- en: 'Connect to the `test` database and get the list of tables by executing the
    following command:'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行以下命令连接到`test`数据库并获取表列表：
- en: '[PRE92]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '**![](img/49c1d6eb-9f00-4596-aeca-aba9044138f6.png)**'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '**![](img/49c1d6eb-9f00-4596-aeca-aba9044138f6.png)**'
- en: 'Get the records, if any, in the `test` table by executing the following commands:'
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行以下命令获取`test`表中的记录（如果有）：
- en: '**![](img/24afe91f-4db6-429d-9d15-c831d6f64781.png)**'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '**![](img/24afe91f-4db6-429d-9d15-c831d6f64781.png)**'
- en: Congratulations! The streaming replication works.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！流式复制工作正常。
- en: How it works...
  id: totrans-375
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As demonstrated in this recipe, the basic setup for streaming replication is
    straightforward. Changes made to the primary database server are quickly pushed
    to the standby database server.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 如本配方所示，流式复制的基本设置非常简单。对主数据库服务器所做的更改会迅速推送到备用数据库服务器。
- en: 'There are third-party applications to help establish, administer, and maintain
    streaming replication on production servers. These applications permit complex
    replication strategies, including multimaster, multistandby, and proper failover.
    A few of these applications include the following:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 有第三方应用程序可以帮助在生产服务器上建立、管理和维护流式复制。这些应用程序允许复杂的复制策略，包括多主、多备用和适当的故障转移。以下是一些这些应用程序的例子：
- en: Pgpool-II, which is available at [http://www.pgpool.net](http://www.pgpool.net)
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pgpool-II，可在[http://www.pgpool.net](http://www.pgpool.net)找到
- en: Bucardo, which is available at [http://bucardo.org/wiki/Bucardo](http://bucardo.org/wiki/Bucardo)
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bucardo，可在[http://bucardo.org/wiki/Bucardo](http://bucardo.org/wiki/Bucardo)找到
- en: Postgres-XC, which is available at [http://postgresxc.wikia.com/wiki/Postgres-XC_Wiki](http://postgresxc.wikia.com/wiki/Postgres-XC_Wiki)
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Postgres-XC，可在[http://postgresxc.wikia.com/wiki/Postgres-XC_Wiki](http://postgresxc.wikia.com/wiki/Postgres-XC_Wiki)找到
- en: Slony-I, which is available at [http://slony.info](http://slony.info)
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Slony-I，可在[http://slony.info](http://slony.info)找到
- en: Geospatial sharding
  id: totrans-382
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 地理空间分片
- en: Working with large datasets can be challenging for the database engine, especially
    when they are stored in a single table or in a single database. PostgreSQL offers
    an option to split the data into several external databases, with smaller tables,
    that work logically as one. Sharding allows distributing the load of storage and
    processing of a large dataset so that the impact of large local tables is reduced.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数据库引擎来说，处理大型数据集可能具有挑战性，尤其是当它们存储在单个表或单个数据库中时。PostgreSQL提供了一个选项，可以将数据分割成几个外部数据库，这些数据库具有较小的表，逻辑上作为一个整体工作。分片允许将大型数据集的存储和处理负载进行分布，从而减少大型本地表的影响。
- en: One of the most important issues to make it work is the definition of a function
    to classify and evenly distribute the data. Given that this function can be a
    geographical property, sharding can be applied to geospatial data.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 使其工作最重要的一个问题是定义一个函数来分类和均匀分配数据。鉴于这个函数可以是地理属性，因此可以将分片应用于地理空间数据。
- en: Getting ready
  id: totrans-385
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In this recipe, we will use the `postgres_fdw` extension that allows the creation
    of foreign data wrappers, needed to access data stored in external PostgreSQL
    databases. In order to use this extension, we will need the combination of several
    concepts: server, foreign data wrapper, user mapping, foreign table and table
    inheritance. We will see them in action in this recipe, and you are welcome to
    explore them in detail on the PostgreSQL documentation.'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，我们将使用`postgres_fdw`扩展，它允许创建外数据包装器，这是访问存储在外部PostgreSQL数据库中的数据所必需的。为了使用此扩展，我们需要几个概念的组合：服务器、外数据包装器、用户映射、外表和表继承。我们将在本配方中展示它们的作用，并欢迎您在PostgreSQL文档中详细探索它们。
- en: We will use the fire hotspot dataset and the world country borders shapefile
    used in [Chapter 1](38f20dd1-ca55-47e8-80cd-21670bcb32b2.xhtml), *Moving Data
    in and out of PostGIS*, in order to distribute the records for the hotspot data
    based on a geographical criteria, we will create a new distributed version of
    the hotspot dataset.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用[第1章](38f20dd1-ca55-47e8-80cd-21670bcb32b2.xhtml)，*在PostGIS中移动数据进和出*中使用的火灾热点数据集和世界国家边界shapefile，根据地理标准分配热点数据的记录，我们将创建热点数据集的新分布式版本。
- en: We will use the `postgis_cookbook` database for this recipe.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`postgis_cookbook`数据库来完成这个菜谱。
- en: How to do it...
  id: totrans-389
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'If you did not follow the recipes in [Chapter 1](38f20dd1-ca55-47e8-80cd-21670bcb32b2.xhtml),
    *Moving Data in and out of PostGIS*, be sure to import the hotspots (`Global_24h.csv`)
    in PostGIS. The following steps explain how to do it with `ogr2ogr` (you should
    import the dataset in their original SRID, 4326, to make spatial operations faster):'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有遵循[第1章](38f20dd1-ca55-47e8-80cd-21670bcb32b2.xhtml)，*在PostGIS中移动数据进和出*的菜谱，请确保将热点（`Global_24h.csv`）导入PostGIS。以下步骤解释了如何使用`ogr2ogr`（您应该以原始SRID，4326，导入数据集，以使空间操作更快）：
- en: 'Start a session in the `postgis_cookbook` database:'
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`postgis_cookbook`数据库中启动一个会话：
- en: '[PRE93]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Create a new schema `chp10` in the `postgis_cookbook` database:'
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`postgis_cookbook`数据库中创建一个新的模式`chp10`：
- en: '[PRE94]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'We need to create the `hotspots_dist` table, that will serve as parent for
    the foreign tables:'
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要创建`hotspots_dist`表，它将作为外键表的父亲：
- en: '[PRE95]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Exit the `psql` environment:'
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 退出`psql`环境：
- en: '[PRE96]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Connect to the psql environment as the postgres user:'
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以postgres用户连接到psql环境：
- en: '[PRE97]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Create the remote databases, connect them, create the `postgis` extension and
    create the foreign tables that will receive the sharded data. Then, exit the `psql`
    environment. For this, execute the following SQL commands:'
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建远程数据库，连接它们，创建`postgis`扩展，并创建将接收分片数据的外键表。然后，退出`psql`环境。为此，执行以下SQL命令：
- en: '[PRE98]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'In order to import the fire dataset, create a GDAL virtual data source composed
    of just one layer derived from the `Global_24h.csv` file. To do so, create a text
    file named `global_24h.vrt` in the same directory where the CSV file is and edit
    it as follows:'
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了导入火灾数据集，创建一个由`Global_24h.csv`文件的一个层派生的GDAL虚拟数据源。为此，在CSV文件所在的同一目录中创建一个名为`global_24h.vrt`的文本文件，并按如下方式编辑它：
- en: '[PRE99]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Import in PostGIS the `Global_24h.csv` file using the `global_24.vrt` virtual
    driver you created in a previous recipe:'
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您在先前的菜谱中创建的`global_24.vrt`虚拟驱动程序将`Global_24h.csv`文件导入PostGIS：
- en: '[PRE100]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Create the extension `postgres_fdw` in the database:'
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在数据库中创建`postgres_fdw`扩展：
- en: '[PRE101]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Define the servers that will host the external databases. You need to define
    the name of the database, the host address and the port in which the database
    will receive connections. In this case we will create 4 databases, one per global
    quadrant, according to latitude and longitude in the Mercator SRID. Execute the
    following commands to create the four servers:'
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义将托管外部数据库的服务器。您需要定义数据库名称、主机地址以及数据库将接收连接的端口号。在这种情况下，我们将创建4个数据库，每个全球象限一个，根据墨卡托SRID的纬度和经度。执行以下命令以创建四个服务器：
- en: '[PRE102]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: For this example, we will be using local databases, but the host parameter can
    be either an IP address or a database file. The user who creates these commands
    will be defined as the local owner of the servers.
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这个例子，我们将使用本地数据库，但主机参数可以是IP地址或数据库文件。创建这些命令的用户将被定义为服务器的本地所有者。
- en: 'Create the user mapping in order to be able to connect to the foreign databases.
    For this, you need to write the login information of the owner of the foreign
    database in their local server:'
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建用户映射，以便能够连接到外部数据库。为此，您需要在本地服务器上写入外部数据库所有者的登录信息：
- en: '[PRE103]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Create the tables in the foreign databases, based on the local table `chp10.hotspots_dist`:'
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在外部数据库中创建表，基于本地表`chp10.hotspots_dist`：
- en: '[PRE104]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: The name of the table name should preferably be written in lowercase.
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 表名最好写成小写。
- en: 'Create a function that will calculate the quadrant of the point to be inserted
    in the database:'
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数，用于计算要插入数据库的点所在的象限：
- en: '[PRE105]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Insert the test coordinates (10, 10), (-10, 10) and (-10 -10). The first one
    should be stored in the NE quadrant, the second on the SE quadrant and the third
    on the SW quadrant.
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 插入测试坐标（10, 10），（-10, 10）和（-10 -10）。第一个应该存储在东北象限，第二个在东南象限，第三个在西南象限。
- en: '[PRE106]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Check the data insertion in the tables, both the local view and the external
    database `hotspots_quad_NE`:'
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查表中的数据插入，包括本地视图和外部数据库`hotspots_quad_NE`：
- en: '[PRE107]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '![](img/73fec4b3-0929-4392-a90e-5c99400559aa.png)'
  id: totrans-423
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/73fec4b3-0929-4392-a90e-5c99400559aa.png)'
- en: 'As can be seen, the local version shows all the points that were inserted.
    Now, execute the query over a remote database:'
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如所示，本地版本显示了所有插入的点。现在，在远程数据库上执行查询：
- en: '[PRE108]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '![](img/f93746d9-a205-44a3-a32d-f313abcd8e9d.png)'
  id: totrans-426
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f93746d9-a205-44a3-a32d-f313abcd8e9d.png)'
- en: The remote databases only has the point that it should store, based on the trigger
    function defined earlier.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 远程数据库只存储根据之前定义的触发函数应该存储的点。
- en: 'Now, insert all the points from the original hotspot table, imported in step
    8\. For this test, we will just insert the geometry information. Execute the following
    SQL sentence:'
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，从原始热点表插入所有点，这些点在步骤8中已导入。对于这次测试，我们只需插入几何信息。执行以下SQL语句：
- en: '[PRE109]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'As in *step 15*, in order to check if the results were classified and stored
    correctly, execute the following queries, to the local table `hotspots_dist` and
    the remote table `hotsports_quad_ne`:'
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如同*步骤15*，为了检查结果是否被正确分类和存储，对本地表`hotspots_dist`和远程表`hotsports_quad_ne`执行以下查询：
- en: '[PRE110]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '![](img/1d1d5449-6471-42c7-ac60-4122c03183a9.png)'
  id: totrans-432
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1d1d5449-6471-42c7-ac60-4122c03183a9.png)'
- en: The results show the first 10 points stored in the local logical version of
    the database.
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结果显示了本地数据库逻辑版本中存储的前10个点。
- en: '[PRE111]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '![](img/5232c5f1-508d-4e2a-ba05-33b76503e49b.png)'
  id: totrans-435
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5232c5f1-508d-4e2a-ba05-33b76503e49b.png)'
- en: 'The results show the first 10 points stored in the remote database with all
    the points in the NE quadrant. The points indeed show that they all have positive
    latitude and longitude values. When presented in a GIS application, the results
    is the following:'
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结果显示了远程数据库中存储的前10个点，包括NE象限中的所有点。这些点确实显示它们都具有正的纬度和经度值。当在GIS应用程序中展示时，结果是以下内容：
- en: '![](img/db9c50fd-d050-4be5-a352-e1f6b3566399.png)'
  id: totrans-437
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/db9c50fd-d050-4be5-a352-e1f6b3566399.png)'
- en: How it works...
  id: totrans-438
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, a basic setup for geographical sharding is demonstrated. More
    sophisticated functions can be implemented easily on the same proposed structure.
    In addition, for heavy lifting applications purposes, there are some products
    in the market that could be explored, if considered necessary.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，展示了地理分片的基本设置。可以在相同提出的结构上轻松实现更复杂的功能。此外，对于重负载应用程序，市场上有一些产品可以考虑。
- en: 'The example shown was based partly on a GitHub implementation found at the
    following link: [https://gist.github.com/sylr/623bab09edd04d53ee4e](https://gist.github.com/sylr/623bab09edd04d53ee4e).'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 所示的示例部分基于以下链接中找到的GitHub实现：[https://gist.github.com/sylr/623bab09edd04d53ee4e](https://gist.github.com/sylr/623bab09edd04d53ee4e)。
- en: Paralellizing in PosgtreSQL
  id: totrans-441
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在PostgreSQL中并行化
- en: Similar to sharding, working with a large amount of rows within a geospatial
    table in postgres, will cause a lot of processing time for a single worker. With
    the release of postgres 9.6, the server is capable of executing queries which
    can be processed by multiple CPUs for a faster answer. According to the postgres
    documentation, depending of the table size and the query plan, there might not
    be a considerable benefit when implementing a parallel query, instead of a serial
    query.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 与分片类似，在PostgreSQL的地理空间表中处理大量行，将导致单个工作者的处理时间很长。随着PostgreSQL 9.6的发布，服务器能够执行可以由多个CPU处理的查询，以获得更快的答案。根据PostgreSQL文档，根据表的大小和查询计划，在实现并行查询而不是串行查询时，可能不会带来明显的优势。
- en: Getting ready
  id: totrans-443
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we need a specific version of postgres. It is not mandatory
    for you to download and install the postgres version that will be used. The reason
    is that, some developers might have an already configured postgres database version
    with data, and having multiple servers running within a computer might cause issues
    later.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，我们需要PostgreSQL的一个特定版本。您不必下载和安装将要使用的PostgreSQL版本。原因是，一些开发者可能已经配置了一个带有数据的PostgreSQL数据库版本，而在计算机内运行多个服务器可能会在以后引起问题。
- en: To overcome this problem, we will make use of a **docker container**. A container
    could be defined as a lightweight instantiation of a software application that
    is isolated from other containers and your computer host. Similar to a virtual
    machine, you could have multiple versions of your software stored inside your
    host, and start multiple containers whenever necessary.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服这个问题，我们将使用一个**docker容器**。容器可以被定义为一个轻量级的软件应用实例，它与其他容器以及你的计算机主机隔离。类似于虚拟机，你可以在主机中存储多个软件版本，并在需要时启动多个容器。
- en: 'First, we will download docker from [https://docs.docker.com/install/](https://docs.docker.com/install/)
    and install the **Community Edition** (**CE**) version. Then, we will pull an
    already precompiled docker image. Start a Terminal and run the following command:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将从[https://docs.docker.com/install/](https://docs.docker.com/install/)下载docker，并安装**社区版**（**CE**）。然后，我们将拉取一个已经预编译的docker镜像。打开一个终端并运行以下命令：
- en: '[PRE112]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'This docker image has PostgreSQL 10 with Postgis 2.4 and SFCGAL plugin. Now
    we need to start an instance given the image. An important part corresponds to
    the `-p 5433:5432`. These arguments maps every connection and request that is
    received at port `5433` in your host (local) computer to the `5432` port of your
    container:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 这个docker镜像包含PostgreSQL 10、Postgis 2.4和SFCGAL插件。现在我们需要根据镜像启动一个实例。一个重要的部分是`-p
    5433:5432`。这些参数将你的主机（本地）计算机上接收到的每个连接和请求映射到容器的`5432`端口：
- en: '[PRE113]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Now, you can connect to your PostgreSQL container:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以连接到你的PostgreSQL容器：
- en: '[PRE114]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: Where root and `d842288536c9` corresponds to your container username and group
    respectively.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 其中root和`d842288536c9`分别对应你的容器用户名和组。
- en: How to do it...
  id: totrans-453
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Because we created an isolated instance of your postgres database, we have
    to recreate to use, database name and schema. These operations are optional. However,
    we encourage you to follow this to make this recipe consistent with the rest of
    the book:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们已经创建了一个隔离的PostgreSQL数据库实例，我们必须重新创建数据库名称和模式才能使用。这些操作是可选的。然而，我们鼓励你遵循以下步骤，以确保这个食谱与本书的其他部分保持一致：
- en: 'Create the user `me` in your container:'
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的容器中创建用户`me`：
- en: '[PRE115]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Reconnect to the database but now as user `me` to create database and schema:'
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新连接到数据库，但现在作为用户`me`来创建数据库和模式：
- en: '[PRE116]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'You are now connected to database `postgis-cookbook` as user `me`:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已连接到数据库`postgis-cookbook`，用户为`me`：
- en: '[PRE117]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'Insert a layer into the database. In this case, we will make use of the `gis.osm_buildings_a_free_1
    shapefile` from Colombia. Make sure you have these files within the `SHP_PATH`
    before starting the container. This database insertion could be run in two forms:
    First one is inside your docker container:'
  id: totrans-461
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在数据库中插入一个层。在这种情况下，我们将使用来自哥伦比亚的`gis.osm_buildings_a_free_1 shapefile`。在启动容器之前，请确保这些文件位于`SHP_PATH`中。这种数据库插入可以以两种形式运行：第一种是在你的docker容器内部：
- en: '[PRE118]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'The second option is in your host computer. Make sure to correctly set your
    shapefiles path and host port that maps to the `5432` container port. Also, your
    host must have `postgresql-client` installed:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种选项是在你的主机计算机上。确保正确设置你的shapefiles路径和映射到容器端口`5432`的主机端口。此外，你的主机必须已安装`postgresql-client`：
- en: '[PRE119]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Execute parallel query. Using the building table we can execute a `postgis`
    command in parallel. To check how many workers are created, we make use of the
    `EXPLAIN ANALYZE` command. So, for example, if we want to calculate the sum of
    all geometries from the table in a serial query:'
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行并行查询。使用建筑表，我们可以并行执行一个`postgis`命令。为了检查创建了多少个工作线程，我们使用`EXPLAIN ANALYZE`命令。所以，例如，如果我们想在一个串行查询中计算表中所有几何形状的总和：
- en: '[PRE120]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'We get the following result:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了以下结果：
- en: '[PRE121]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'Now, if we modify the `max_parallel_workers` and `max_parallel_workers_per_gather`
    parameters, we activate the parallel query capability of PostgreSQL:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们修改`max_parallel_workers`和`max_parallel_workers_per_gather`参数，我们就可以激活PostgreSQL的并行查询功能：
- en: '[PRE122]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'This command prints in Terminal:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令会在终端打印：
- en: '[PRE123]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'Execute parallel scans. For example, if we want to select polygons whose area
    is higher than a value:'
  id: totrans-473
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行并行扫描。例如，如果我们想选择面积高于某个值的多边形：
- en: '[PRE124]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'We get the following result:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了以下结果：
- en: '[PRE125]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'This query is not executed in parallel. This happens because `ST_Area` function
    is defined with a `COST` value of `10`. A `COST` for PostgreSQL is a positive
    number giving the estimated execution cost for a function. If we increase this
    value to `100`, we can get a parallel plan:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 这个查询不会并行执行。这是因为`ST_Area`函数被定义为具有`COST`值为`10`。对于PostgreSQL来说，`COST`是一个正数，表示函数的估计执行成本。如果我们把这个值增加到`100`，我们可以得到一个并行计划：
- en: '[PRE126]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'Now we have a parallel plan and 3 workers are executing the query:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个并行计划，并且有3个工作者正在执行查询：
- en: '[PRE127]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'Execute parallel joins. First, we create a point table where we create randomly
    `10` points per polygon:'
  id: totrans-481
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行并行连接。首先，我们创建一个点表，其中每个多边形随机创建`10`个点：
- en: '[PRE128]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'Now, we can run a table join between two tables, which does not give us a parallel
    plan:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在两个表之间运行表连接，但这不会给我们一个并行计划：
- en: '[PRE129]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'For this case, we need to modify the parameter `parallel_tuple_cost` which
    sets the planner''s estimate of the cost of transferring one tuple from a parallel
    worker process to another process. Setting the value to `0.001` gives us a parallel
    plan:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这种情况，我们需要修改参数`parallel_tuple_cost`，该参数设置规划器对从一个并行工作者进程传输一个元组到另一个进程的成本的估计。将值设置为`0.001`会给我们一个并行计划：
- en: '[PRE130]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: How it works...
  id: totrans-487
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As demonstrated in this recipe, parallelizing queries in PostgreSQL allows the
    optimization of operations that involve a large dataset. The database engine is
    already capable of implementing parallelism, but defining the proper configuration
    is crucial in order to take advantage of the functionality.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 如本菜谱所示，在PostgreSQL中并行化查询允许优化涉及大量数据集的操作。数据库引擎已经能够实现并行性，但定义适当的配置对于利用该功能至关重要。
- en: In this recipe, we used the `max_parallel_workers` and the `parallel_tuple_cost`
    to configure the desired amount a parallelism. We could evaluate the performance
    with the `ANALYZE` function.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们使用了`max_parallel_workers`和`parallel_tuple_cost`来配置所需的并行度。我们可以使用`ANALYZE`函数来评估性能。
