<html><head></head><body>
  <div id="sbo-rt-content"><div class="chapter" title="Chapter 3. Introducing Petrel"><div class="titlepage"><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Introducing Petrel</h1></div></div></div><p>As discussed in <a class="link" href="ch01.html" title="Chapter 1. Getting Acquainted with Storm">Chapter 1</a>, <span class="emphasis"><em>Getting Acquainted with Storm</em></span>, Storm is a platform for processing large amounts of data in real time. Storm applications are often written in Java, but Storm supports other languages as well, including Python. While the concepts are similar across languages, the details vary by language. In this chapter, we'll get our first hands-on experience using Storm with Python. First, you'll learn about a Python library called Petrel, which is necessary for creating topologies in Python. Next, we'll set up our Python/Storm development environment. Then, we'll take a close look at a working Storm topology written in Python. Finally, we'll run the topology and you will learn some key techniques to ease the process of developing and debugging topologies. After you complete this chapter, you'll have a good high-level understanding of developing basic Storm topologies. In this chapter, we will cover these topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">What is Petrel?</li><li class="listitem" style="list-style-type: disc">Installing Petrel</li><li class="listitem" style="list-style-type: disc">Creating your first topology</li><li class="listitem" style="list-style-type: disc">Running the topology</li><li class="listitem" style="list-style-type: disc">Productivity tips with Petrel</li></ul></div><div class="section" title="What is Petrel?"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec16"/>What is Petrel?</h1></div></div></div><p>All Python<a id="id74" class="indexterm"/> topologies in this book rely on an open source Python library called Petrel. If you have prior experience with Storm, you may recall that there is a GitHub project called <code class="literal">storm-starter</code> that includes examples of using Storm with various languages (you can find the latest<a id="id75" class="indexterm"/> version of <code class="literal">storm-starter</code> at <a class="ulink" href="https://github.com/apache/storm/tree/master/examples/storm-starter">https://github.com/apache/storm/tree/master/examples/storm-starter</a>). The <code class="literal">storm-starter</code> project includes a module called <code class="literal">storm.py</code>, which allows you to implement Storm topologies in Python. Given the availability of <code class="literal">storm.py</code>, is it really necessary to use another library? While it is certainly possible to build topologies using <code class="literal">storm.py</code>, it lacks some important features. To work around those gaps, a developer must use languages and tools that won't be familiar to most Python developers. If you are already familiar with these tools and do not mind juggling multiple technology stacks as you work with Storm, you may be happy with <code class="literal">storm.py</code>. But most developers who are<a id="id76" class="indexterm"/> new to Storm find the <code class="literal">storm.py</code> approach to be overly complex, even overwhelming. Let's discuss the weaknesses of <code class="literal">storm.py</code> in more detail.</p><div class="section" title="Building a topology"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec24"/>Building a topology</h2></div></div></div><p>In order to run<a id="id77" class="indexterm"/> a topology, Storm needs a description of spouts, bolts, and streams within it. This description is encoded in a format <a id="id78" class="indexterm"/>called <span class="strong"><strong>Thrift</strong></span>. The <code class="literal">storm.py</code> module does not <a id="id79" class="indexterm"/>support the creation of this description; the developer must create it using another programming language (typically Java or Clojure).</p></div><div class="section" title="Packaging a topology"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec25"/>Packaging a topology</h2></div></div></div><p>A topology is submitted to<a id="id80" class="indexterm"/> Storm in the form of a Java <code class="literal">.jar</code> file (similar to Python <code class="literal">.egg</code> or <code class="literal">.tar.gz</code> files). In addition to the topology description, a Python<a id="id81" class="indexterm"/> topology <code class="literal">.jar</code> must also include the Python code for the topology. Creating a JAR file typically involves using Java development tools such as Ant or Maven.</p></div><div class="section" title="Logging events and errors"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec26"/>Logging events and errors</h2></div></div></div><p>It is much easier to <a id="id82" class="indexterm"/>debug and monitor a topology if it includes logging messages to allow tracking of the data that flows through it. If things go wrong in a Python<a id="id83" class="indexterm"/> topology and the code crashes, it's invaluable to see what the error was and where it occurred. The <code class="literal">storm.py</code> module provides no help in these areas. If a component crashes, it simply exits without capturing any information. In my experience, this is the most frustrating aspect of working with <code class="literal">storm.py</code>.</p></div><div class="section" title="Managing third-party dependencies"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec27"/>Managing third-party dependencies</h2></div></div></div><p>Real-world Python <a id="id84" class="indexterm"/>applications often use third-party libraries. If a cluster needs to run multiple topologies, each topology may have different, even conflicting versions of these libraries. Python virtual environments are a great tool for managing this. However, <code class="literal">storm.py</code> does not help you create, activate, or install third-party libraries in a Python virtual environment. Petrel addresses all of these limitations of Storm's built-in Python support, providing a simpler, more streamlined development <a id="id85" class="indexterm"/>experience. Petrel's key features include the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A Python API for building a topology</li><li class="listitem" style="list-style-type: disc">Packaging a topology for submission to Storm</li><li class="listitem" style="list-style-type: disc">Logging events and errors</li><li class="listitem" style="list-style-type: disc">On worker<a id="id86" class="indexterm"/> nodes, setting up a topology-specific Python runtime environment using <code class="literal">setup.sh</code></li></ul></div><p>In this chapter, we'll talk<a id="id87" class="indexterm"/> about the first three points. We'll see an example of the fourth in <a class="link" href="ch04.html" title="Chapter 4. Example Topology – Twitter">Chapter 4</a>, <span class="emphasis"><em>Example Topology – Twitter</em></span>.</p></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Installing Petrel"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec17"/>Installing Petrel</h1></div></div></div><p>Let's set up our Python <a id="id88" class="indexterm"/>development environment. We assume here that you have already followed the instructions in <a class="link" href="ch01.html" title="Chapter 1. Getting Acquainted with Storm">Chapter 1</a>, <span class="emphasis"><em>Getting Acquainted with Storm</em></span>, to install <a id="id89" class="indexterm"/>Storm 0.9.3:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First, we need to install <code class="literal">virtualenv</code>, a tool for managing Python libraries. On Ubuntu, simply run this command:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong>sudo apt-get install python-virtualenv</strong></span></pre></div></li><li class="listitem">Next, we create a Python virtual environment. This provides a way to install Python libraries without requiring root access to the machine and without interfering with the system's Python packages:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong>virtualenv petrel</strong></span></pre></div><p>You will see something like the following output:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>New python executable in petrel/bin/python</strong></span>
<span class="strong"><strong>Installing distribute.............................................................................................................................................................................................done</strong></span></pre></div></li><li class="listitem">Next, run this command to activate the virtual environment. Your shell prompt will change to include the <code class="literal">virtualenv</code> name, indicating that the virtual environment is active:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong>source petrel/bin/activate</strong></span>
<span class="strong"><strong>(petrel)barry@Dell660s:~$</strong></span></pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note06"/>Note</h3><p>You'll need to run this command again—each time you open a new terminal.</p></div></div></li><li class="listitem">Finally, install Petrel:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong>easy_install petrel==0.9.3.0.3</strong></span></pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note07"/>Note</h3><p>The first three digits<a id="id90" class="indexterm"/> of the Petrel version number must match the<a id="id91" class="indexterm"/> version of Storm that you're using. If you're using a version of Storm with no corresponding Petrel release, you can install Petrel from <a id="id92" class="indexterm"/>source. Check out <a class="ulink" href="https://github.com/AirSage/Petrel#installing-petrel-from-source">https://github.com/AirSage/Petrel#installing-petrel-from-source</a> for instructions.</p></div></div></li></ol></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip02"/>Tip</h3><p>
<span class="strong"><strong>Downloading the example code</strong></span></p><p>You can download the example code files for all Packt books you have purchased from your account at <a class="ulink" href="http://www.packtpub.com">http://www.packtpub.com</a>. If you purchased this book elsewhere, you can visit <a class="ulink" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a> and register to have the files e-mailed directly to you</p></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Creating your first topology"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec18"/>Creating your first topology</h1></div></div></div><p>Now, we'll create<a id="id93" class="indexterm"/> a Storm topology that breaks sentences into words and then counts the number of occurrences of each word. Implementing this topology in Storm requires the following components:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Sentence spout (<code class="literal">randomsentence.py</code>): A topology<a id="id94" class="indexterm"/> always begins with a spout; that's how data gets into Storm. The sentence spout will emit an infinite stream of <a id="id95" class="indexterm"/>sentences.</li><li class="listitem" style="list-style-type: disc">Splitter bolt (<code class="literal">splitsentence.py</code>): This receives <a id="id96" class="indexterm"/>sentences and splits them into words.</li><li class="listitem" style="list-style-type: disc">Word count bolt (<code class="literal">wordcount.py</code>): This receives words and counts the occurrences. For each word<a id="id97" class="indexterm"/> processed, output the word along with the number of occurrences.</li></ul></div><p>The following figure shows how data flows through the topology:</p><div class="mediaobject"><img src="images/B03471_03_01.jpg" alt="Creating your first topology"/><div class="caption"><p>Word count topology</p></div></div><p>Now that we've seen the basic data flow, let's implement the topology and see how it works.</p><div class="section" title="Sentence spout"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec28"/>Sentence spout</h2></div></div></div><p>In this section, we<a id="id98" class="indexterm"/> implement a spout that generates random sentences. Enter this code in a file called <code class="literal">randomsentence.py</code>:</p><div class="informalexample"><pre class="programlisting">import time
import random

from petrel import storm
from petrel.emitter import Spout

class RandomSentenceSpout(Spout):
    def __init__(self):
        super(RandomSentenceSpout, self).__init__(script=__file__)

    @classmethod
    def declareOutputFields(cls):
        return ['sentence']

    sentences = [
        "the cow jumped over the moon",
        "an apple a day keeps the doctor away",
    ]

    def nextTuple(self):
        time.sleep(0.25)
        sentence = self.sentences[
            random.randint(0, len(self.sentences) - 1)]
        storm.emit([sentence])

def run():
    RandomSentenceSpout().run()</pre></div><p>The spout inherits from Petrel's <code class="literal">Spout</code> class.</p><p>Petrel requires every spout and bolt class to implement <code class="literal">__init__()</code> and pass its filename to the <code class="literal">(script=__file__)</code> base class. The <code class="literal">script</code> parameter tells Petrel which Python script to run while launching an instance of the component.</p><p>The <code class="literal">declareOutputFields()</code> function tells <a id="id99" class="indexterm"/>Storm about the structure of the tuples emitted by this spout. Each tuple consists of a single field named <code class="literal">sentence</code>.</p><p>Storm calls <code class="literal">nextTuple()</code> each time it is ready for more data from the spout. In a real-world spout, you might be reading from an external data source, such as Kafka or Twitter. This spout is just an example, so it generates its own data. It simply makes a random choice between one of two sentences.</p><p>You may have noticed that the spout sleeps for 0.25 seconds on every call to <code class="literal">nextTuple()</code>. Why<a id="id100" class="indexterm"/> is this so? It's not technically necessary, but it slows things down and makes the output easier to read when the topology runs in local mode.</p><p>What does the <code class="literal">run()</code> function do? It's a bit of <span class="emphasis"><em>glue</em></span> code required by Petrel. When a spout or bolt script is loaded into Storm, Petrel calls the <code class="literal">run()</code> function to create the component and begins processing messages. If your spout or bolt needs to do additional initialization, this is a good place for it to do so.</p></div><div class="section" title="Splitter bolt"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec29"/>Splitter bolt</h2></div></div></div><p>This section<a id="id101" class="indexterm"/> provides the splitter bolt, which consumes sentences from the spout and splits them into words. Enter this code in a file called <code class="literal">splitsentence.py</code>:</p><div class="informalexample"><pre class="programlisting">from petrel import storm
from petrel.emitter import BasicBolt

class SplitSentenceBolt(BasicBolt):
    def __init__(self):
        super(SplitSentenceBolt, self).__init__(script=__file__)

    def declareOutputFields(self):
        return ['word']

    def process(self, tup):
        words = tup.values[0].split("")
        for word in words:
          storm.emit([word])

def run():
    SplitSentenceBolt().run()</pre></div><p>
<code class="literal">SplitSentenceBolt</code> inherits from the <code class="literal">BasicBolt</code> Petrel class. This class is used for most simple bolts. You may recall that Storm has a feature for ensuring that every message is processed, "replaying" previous tuples if they were not processed to completion. <code class="literal">BasicBolt</code> simplifies working with this feature. It does so by automatically acknowledging to Storm as each tuple is processed. The more flexible <code class="literal">Bolt</code> class allows the programmer to directly acknowledge tuples, but is it beyond the scope of this book.</p><p>The split sentence bolt has a run function, similar to the spout.</p><p>The<a id="id102" class="indexterm"/> <code class="literal">process()</code> function receives<a id="id103" class="indexterm"/> sentences from the spout and splits them into words. Each word is emitted as an individual tuple.</p></div><div class="section" title="Word Counting Bolt"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec30"/>Word Counting Bolt</h2></div></div></div><p>This section implements the <a id="id104" class="indexterm"/>word count bolt, which consumes words from the spout and counts them. Enter the following code in the <code class="literal">wordcount.py</code> file:</p><div class="informalexample"><pre class="programlisting">from collections import defaultdict

from petrel import storm
from petrel.emitter import BasicBolt

class WordCountBolt(BasicBolt):
    def __init__(self):
        super(WordCountBolt, self).__init__(script=__file__)
        self._count = defaultdict(int)

    @classmethod
    def declareOutputFields(cls):
        return ['word', 'count']

    def process(self, tup):
        word = tup.values[0]
        self._count[word] += 1
        storm.emit([word, self._count[word]])

def run():
    WordCountBolt().run()</pre></div><p>The word count bolt has a new wrinkle; unlike the sentence bolt, it needs to store information from one tuple to the next—the word count. The <code class="literal">__init__()</code> function sets up a <code class="literal">_count</code> field to handle this.</p><p>The word count bolt uses Python's handy <code class="literal">defaultdict</code> class, which simplifies counting things by automatically providing a <code class="literal">0</code> entry when we access a nonexistent key.</p><div class="section" title="Defining a topology"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec09"/>Defining a topology</h3></div></div></div><p>The previous <a id="id105" class="indexterm"/>sections provided the spout and bolts for the word count topology. Now, we need to tell Storm how the components combine to form a topology. In Petrel, this is done with a <code class="literal">create.py</code> script. This script provides the following information:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Spouts and bolts that make up the topology</li><li class="listitem" style="list-style-type: disc">For each bolt, where its input data comes from</li><li class="listitem" style="list-style-type: disc">How tuples are partitioned among the instances of the bolt</li></ul></div><p>Here is the <code class="literal">create.py</code> script:</p><div class="informalexample"><pre class="programlisting">from randomsentence import RandomSentenceSpout
from splitsentence import SplitSentenceBolt
from wordcount import WordCountBolt

def create(builder):
    builder.setSpout("spout", RandomSentenceSpout(), 1)
    builder.setBolt(
        "split", SplitSentenceBolt(), 1).shuffleGrouping("spout")
    builder.setBolt(
        "count", WordCountBolt(), 1).fieldsGrouping(
        "split", ["word"])</pre></div><p>It is vital that the word count bolt uses Storm's <code class="literal">fieldsGrouping</code> behavior (as described in the <span class="emphasis"><em>Stream grouping</em></span> section of <a class="link" href="ch02.html" title="Chapter 2. The Storm Anatomy">Chapter 2</a>, <span class="emphasis"><em>The Storm Anatomy</em></span>).This setting for a bolt lets you group the tuples in your data stream on one or more fields. For the word count topology, <code class="literal">fieldsGrouping</code> ensures that all instances of a word will be counted by the same Storm worker process.</p><p>When the topology is deployed on a cluster, there will probably be many separate running instances of the word count bolt. If we didn't configure <code class="literal">fieldsGrouping</code> on the <code class="literal">"word"</code> field, then we might get the following results by processing the sentence, "the cow jumped over the moon":</p><div class="informalexample"><pre class="programlisting">Word count instance 1: { "the": 1, "cow": 1, "jumped": 1 }
Word count instance 2: { "over": 1, "the": 1, "moon": 1 }</pre></div><p>There are two entries for <code class="literal">"the"</code>, and because of this, the count is wrong! We want something like this instead:</p><div class="informalexample"><pre class="programlisting">Word count instance 1: { "the": 2, "cow": 1, "jumped": 1 }
Word count instance 2: { "over": 1, "moon": 1 }</pre></div></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Running the topology"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec19"/>Running the topology</h1></div></div></div><p>Just a few more details <a id="id106" class="indexterm"/>and we'll be ready to run the topology:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create a<a id="id107" class="indexterm"/> <code class="literal">topology.yaml</code> file. This is a configuration file for Storm. A complete explanation of this file is beyond the scope of this book, but you can see the entire set of available options at <a class="ulink" href="https://github.com/apache/storm/blob/master/conf/defaults.yaml">https://github.com/apache/storm/blob/master/conf/defaults.yaml</a>:<div class="informalexample"><pre class="programlisting">nimbus.host: "localhost"
topology.workers: 1</pre></div></li><li class="listitem">Create an empty <code class="literal">manifest.txt</code> file. You can use an editor to do this or simply run <code class="literal">touch manifest.txt</code>. This is a Petrel-specific file that tells Petrel what additional files (if any) should be included in the <code class="literal">.jar</code> file that it submits to Storm. In <a class="link" href="ch04.html" title="Chapter 4. Example Topology – Twitter">Chapter 4</a>, <span class="emphasis"><em>Example Topology – Twitter</em></span> we'll see an example that really uses this file.</li><li class="listitem">Before running the topology, let's review the list of files we've created. Make sure you have created these files correctly:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">randomsentence.py</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">splitsentence.py</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">wordcount.py</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">create.py</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">topology.yaml</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">manifest.txt</code></li></ul></div></li><li class="listitem">Run the topology with the following command:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong>petrel submit --config topology.yaml --logdir `pwd`</strong></span></pre></div><p>Congratulations! You have created and run your first topology!</p><p>Petrel runs the <code class="literal">create.py</code> script to discover the structure of the topology, and then <a id="id108" class="indexterm"/>uses that information plus the <code class="literal">manifest.txt</code> file to build a <code class="literal">topology.jar</code> file and submit it to Storm. Next, Storm unpacks the <code class="literal">topology.jar</code> file and prepares the workers. With Petrel, this requires creating a Python virtual environment and installing Petrel from the Internet. In about 30 seconds, the topology will be up and running in Storm.</p><p>You'll see an endless stream of output, sprinkled with messages similar to the following:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>25057 [Thread-20] INFO  backtype.storm.daemon.task - Emitting: split default ["the"]</strong></span>
<span class="strong"><strong>25058 [Thread-20] INFO  backtype.storm.daemon.task - Emitting: split default ["moon"]</strong></span>
<span class="strong"><strong>25059 [Thread-22] INFO  backtype.storm.daemon.task - Emitting: count default ["cow",3]</strong></span>
<span class="strong"><strong>25059 [Thread-9-count] INFO  backtype.storm.daemon.executor - Processing received message source: split:3, stream: default, id: {}, ["over"]</strong></span>
<span class="strong"><strong>25059 [Thread-9-count] INFO  backtype.storm.daemon.executor - Processing received message source: split:3, stream: default, id: {}, ["the"]</strong></span>
<span class="strong"><strong>25059 [Thread-9-count] INFO  backtype.storm.daemon.executor - Processing received message source: split:3, stream: default, id: {}, ["moon"]</strong></span>
<span class="strong"><strong>25060 [Thread-22] INFO  backtype.storm.daemon.task - Emitting: count default ["jumped",3]</strong></span>
<span class="strong"><strong>25060 [Thread-22] INFO  backtype.storm.daemon.task - Emitting: count default ["over",3]</strong></span>
<span class="strong"><strong>25060 [Thread-22] INFO  backtype.storm.daemon.task - Emitting: count default ["the",9]</strong></span>
<span class="strong"><strong>25060 [Thread-22] INFO  backtype.storm.daemon.task - Emitting: count default ["moon",3]</strong></span></pre></div></li><li class="listitem">When you've seen <a id="id109" class="indexterm"/>enough, press <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>C</em></span> to kill Storm. Sometimes, it doesn't exit cleanly. If it doesn't, typically the following steps will clean things up: press <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>C</em></span> a few more times, and press <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>Z</em></span> to pause Storm.</li><li class="listitem">Type <code class="literal">ps</code> to get a list of <code class="literal">processesLook</code> for a Java process and get its process <code class="literal">idType "kill -9 processid"</code>, replacing <code class="literal">processid</code> with the ID of the Java process.</li></ol></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Troubleshooting"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec20"/>Troubleshooting</h1></div></div></div><p>If the topology <a id="id110" class="indexterm"/>doesn't run correctly, review the log files created in the current directory. Errors are often caused by using a version of Storm that does not have a corresponding version of <a id="id111" class="indexterm"/>Petrel on the PyPI website (<a class="ulink" href="https://pypi.python.org/pypi/petrel">https://pypi.python.org/pypi/petrel</a>). At the time of writing this<a id="id112" class="indexterm"/> book, two Storm versions are supported:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">0.9.3</li><li class="listitem" style="list-style-type: disc">0.9.4</li></ul></div><p>If you are using an unsupported version of Storm, you are likely to see an error similar to one of these:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>  File "/home/barry/.virtualenvs/petrel2/lib/python2.7/site-packages/petrel-0.9.3.0.3-py2.7.egg/petrel/cmdline.py", line 19, in get_storm_version</strong></span>
<span class="strong"><strong>    return m.group(2)</strong></span>
<span class="strong"><strong>AttributeError: 'NoneType' object has no attribute 'group'</strong></span>

<span class="strong"><strong>IOError: [Errno 2] No such file or directory: '/home/barry/.virtualenvs/petrel2/lib/python2.7/site-packages/petrel-0.9.3.0.3-py2.7.egg/petrel/generated/storm-petrel-0.10.0-SNAPSHOT.jar'</strong></span></pre></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Productivity tips with Petrel"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec21"/>Productivity tips with Petrel</h1></div></div></div><p>We've covered a lot of<a id="id113" class="indexterm"/> ground in this chapter. While we don't know every detail of Storm, we've seen how to construct a topology with multiple components and send data between them.</p><p>The Python code<a id="id114" class="indexterm"/> for the topology is quite short—only about 75 lines in all. This makes a nice example, but really, it's just a little too short. When you start writing your own topologies, things probably won't work perfectly the first time. New code usually has bugs, and may even crash sometimes. To get things working correctly, you'll need to know what's happening in the topology, especially when there are problems. As you work on fixing problems, you'll be running the same topology over and over, and the<a id="id115" class="indexterm"/> 30-second startup time for a topology <a id="id116" class="indexterm"/>can seem like eternity.</p><div class="section" title="Improving startup performance"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec31"/>Improving startup performance</h2></div></div></div><p>Let's address startup performance first. By default, when a Petrel topology starts up, it creates a new Python <code class="literal">virtualenv</code> and installs Petrel and other dependencies in it. While this behavior is very <a id="id117" class="indexterm"/>useful for deploying a topology on a cluster, it is very inefficient during development, when you may be launching the topology dozens of times. To skip the <code class="literal">virtualenv</code> creation step, simply change the <code class="literal">submit</code> command to have Petrel reuse the existing Python virtual environment:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>petrel submit --config topology.yaml --venv self</strong></span></pre></div><p>This cuts the startup time from 30 seconds down to about 10 seconds.</p></div><div class="section" title="Enabling and using logging"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec32"/>Enabling and using logging</h2></div></div></div><p>Like many languages, Python<a id="id118" class="indexterm"/> has a logging framework that <a id="id119" class="indexterm"/>provides a way to capture information on what is happening inside a running application. This section describes how to use logging with Storm:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">In the same directory as that of the word count topology, create a new file, called <code class="literal">logconfig.ini</code>:<div class="informalexample"><pre class="programlisting">[loggers]
keys=root,storm
[handlers]
keys=hand01
[formatters]
keys=form01
[logger_root]
level=INFO
handlers=hand01
[logger_storm]
qualname=storm
level=DEBUG
handlers=hand01
propagate=0
[handler_hand01]
class=FileHandler
level=DEBUG
formatter=form01
args=(os.getenv('PETREL_LOG_PATH') or 'petrel.log', 'a')
[formatter_form01]
format=[%(asctime)s][%(name)s][%(levelname)s]%(message)s
datefmt=
class=logging.Formatter</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note08"/>Note</h3><p>What you just saw is a simple log configuration for demonstration purposes. For more information<a id="id120" class="indexterm"/> about Python logging, consult the logging module documentation at <a class="ulink" href="https://www.python.org/">https://www.python.org/</a>.</p></div></div></li><li class="listitem">Update <code class="literal">wordcount.py</code> to log its<a id="id121" class="indexterm"/> input and <a id="id122" class="indexterm"/>output. The newly added lines are highlighted:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong>import logging</strong></span>
from collections import defaultdict

from petrel import storm
from petrel.emitter import BasicBolt

<span class="strong"><strong>log = logging.getLogger('wordcount')</strong></span>

class WordCountBolt(BasicBolt):
    def __init__(self):
        super(WordCountBolt, self).__init__(script=__file__)
        self._count = defaultdict(int)

    @classmethod
    def declareOutputFields(cls):
        return ['word', 'count']

    def process(self, tup):
<span class="strong"><strong>       log.debug('WordCountBolt.process() called with: %s',</strong></span>
<span class="strong"><strong>                  tup)</strong></span>
<span class="strong"><strong>       word = tup.values[0]</strong></span>
<span class="strong"><strong>       self._count[word] += 1</strong></span>
<span class="strong"><strong>       log.debug('WordCountBolt.process() emitting: %s',</strong></span>
<span class="strong"><strong>           [word, self._count[word]])</strong></span>
       storm.emit([word, self._count[word]])

def run():
    WordCountBolt().run()</pre></div></li><li class="listitem">Now launch the updated topology:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong>petrel submit --config topology.yaml --venv self --logdir `pwd`</strong></span></pre></div></li></ol></div><p>As the topology runs, a log<a id="id123" class="indexterm"/> file for the word count component will be written to the current directory, capturing <a id="id124" class="indexterm"/>what's happening. The filename varies from run to run, but it will be something like <code class="literal">petrel22011_wordcount.log</code>:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>WordCountBolt.process() called with: &lt;Tuple component='split' id='5891744987683180633' stream='default' task=3 values=['moon']&gt;</strong></span>
<span class="strong"><strong>WordCountBolt.process() emitting: ['moon', 2]</strong></span>
<span class="strong"><strong>WordCountBolt.process() called with: &lt;Tuple component='split' id='-8615076722768870443' stream='default' task=3 values=['the']&gt;</strong></span>
<span class="strong"><strong>WordCountBolt.process() emitting: ['the', 7]</strong></span></pre></div></div><div class="section" title="Automatic logging of fatal errors"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec33"/>Automatic logging of fatal errors</h2></div></div></div><p>If a spout or bolt crashes<a id="id125" class="indexterm"/> due to a runtime error, you'll need to know what happened in order to fix it. To help with this, Petrel automatically writes fatal runtime errors to the log:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Add a line at the beginning of the word count bolt's <code class="literal">process()</code> function so that it crashes:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong>    def process(self, tup):</strong></span>
<span class="strong"><strong>        raise ValueError('abc')</strong></span>
<span class="strong"><strong>        log.debug('WordCountBolt.process() called with: %s', tup)</strong></span>
<span class="strong"><strong>        word = tup.values[0]</strong></span>
<span class="strong"><strong>        self._count[word] += 1</strong></span>
<span class="strong"><strong>        log.debug('WordCountBolt.process() emitting: %s',</strong></span>
<span class="strong"><strong>            [word, self._count[word]])</strong></span>
<span class="strong"><strong>        storm.emit([word, self._count[word]])</strong></span></pre></div></li><li class="listitem">Run the topology again and examine the word count log file. It'll contain a backtrace for the failure:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong>[2015-02-08 22:28:42,383][storm][INFO]Caught exception</strong></span>
<span class="strong"><strong>[2015-02-08 22:28:42,383][storm][ERROR]Sent failure message ("E_BOLTFAILED__wordcount__Dell660s__pid__21794__port__-1__taskindex__-1__ValueError") to Storm</strong></span>
<span class="strong"><strong>[2015-02-08 22:28:47,385][storm][ERROR]Caught exception in BasicBolt.run</strong></span>
<span class="strong"><strong>Traceback (most recent call last):</strong></span>
<span class="strong"><strong>  File "/home/barry/dev/Petrel/petrel/petrel/storm.py", line 381, in run</strong></span>
<span class="strong"><strong>    self.process(tup)</strong></span>
<span class="strong"><strong>  File "/tmp/b46e3137-1956-4abf-80c8-acaa7d3626d1/supervisor/stormdist/test+topology-1-1423452516/resources/wordcount.py", line 19, in process</strong></span>
<span class="strong"><strong>    raise ValueError('abc')</strong></span>
<span class="strong"><strong>ValueError: abc</strong></span>
<span class="strong"><strong>[2015-02-08 22:28:47,386][storm][ERROR]The error occurred while processing this tuple: ['an']</strong></span>
<span class="strong"><strong>Worker wordcount exiting normally.</strong></span></pre></div></li></ol></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec22"/>Summary</h1></div></div></div><p>In this chapter, you learned how Petrel makes it possible to develop Storm topologies in pure Python. We created and ran a simple topology, and you learned how it works. You also learned how to use Petrel's <code class="literal">--venv self</code> option and Python logging to streamline your development and debugging process.</p><p>In the next chapter, we will see some more complex topologies, including a spout that reads from a real-world data source (Twitter), rather than randomly generated data.</p></div></div>
</body></html>