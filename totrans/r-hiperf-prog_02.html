<html><head></head><body><div class="chapter" title="Chapter&#xA0;2.&#xA0;Profiling &#x2013; Measuring Code's Performance"><div class="titlepage"><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Profiling – Measuring Code's Performance</h1></div></div></div><p>The first step to improve the performance of R programs is to identify where the performance bottlenecks are occurring. To do this, we <span class="strong"><strong>profile</strong></span> or measure the performance of an R program as it runs with respect to various measures such as execution time, memory utilization, CPU utilization, and disk I/O. This gives us a good idea of how the program and its parts perform, so that we can tackle the biggest bottlenecks first. This chapter will show you how to use a few simple tools to measure the performance of R programs.</p><p>The 80/20 rule is applied here. 80 percent of the possible performance improvements can usually be achieved by tackling 20 percent of the largest performance problems. We will look at how to determine which problems to solve first in order to get maximum improvement in the least amount of time and effort.</p><p>This chapter covers the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Measuring the total execution time</li><li class="listitem" style="list-style-type: disc">Profiling the execution time</li><li class="listitem" style="list-style-type: disc">Profiling the memory utilization</li><li class="listitem" style="list-style-type: disc">Monitoring memory utilization, CPU utilization, and disk I/O using OS tools</li><li class="listitem" style="list-style-type: disc">Identifying and resolving bottlenecks</li></ul></div><div class="section" title="Measuring total execution time"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec14"/>Measuring total execution time</h1></div></div></div><p>When people say that their program is not performing well, they are often referring to the <a id="id20" class="indexterm"/>
<span class="strong"><strong>execution time</strong></span> or the <a id="id21" class="indexterm"/>time it takes to complete the execution of the program. Execution time is probably the most important performance measure in many contexts as it is has a direct impact on people and processes. A shorter execution time means the R programmer can perform his or her analysis more quickly to derive insights faster.</p><p>It turns out that execution time is also the easiest performance characteristic that can be measured accurately and in detail (though not always the easiest to solve). Therefore, we will start learning about the way to profile an R code by learning to measure the execution time of R programs. We will learn three different tools to do this: <code class="literal">system.time()</code>, <code class="literal">benchmark()</code>, and <code class="literal">microbenchmark()</code>.</p><div class="section" title="Measuring execution time with system.time()"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec07"/>Measuring execution time with system.time()</h2></div></div></div><p>The first <a id="id22" class="indexterm"/>profiling tool we will learn about<a id="id23" class="indexterm"/> is <code class="literal">system.time()</code>. It is a very useful tool that we can use to measure the execution time of any R expression.</p><p>Say we want to find out how long it takes to generate 100 million uniform random variables. Take a look at the following statement and the output when it is run in the R console:</p><div class="informalexample"><pre class="programlisting">system.time(runif(1e8))
##  user  system elapsed 
## 2.969   0.166   3.138</pre></div><p>The <code class="literal">runif(1e8)</code> expression generates 100 million random values between 0 and 1. In order to measure how long it takes to run this command, we simply pass this expression to <code class="literal">system.time()</code>.</p><p>The output contains three elements, all measured in seconds:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>User time</strong></span>: This <a id="id24" class="indexterm"/>element <a id="id25" class="indexterm"/>is the CPU time charged for the execution of user instructions of the given expression, for example, looping through an array. It does not include CPU time used by other processes (for example, if the computer happens to be running a virus scan in the background, the CPU time taken by it is not counted).</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>System time</strong></span>: System time<a id="id26" class="indexterm"/> is the <a id="id27" class="indexterm"/>CPU time charged for the execution of system instructions on behalf of the given expression, for example, opening and closing files, or allocating and freeing memory. This does not include CPU time used by other processes.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Elapsed time</strong></span>: Elapsed time<a id="id28" class="indexterm"/> is <a id="id29" class="indexterm"/>the total clock time taken to execute the given expression. It includes the time that the CPU has spent on other processes and time spent in waiting (for example, waiting for a file to be opened for reading). Sometimes, elapsed time is longer than the sum of user time and system time because the CPU is multitasking on other processes, or it has to wait for resources such as files and network connections to be available. At other times, elapsed time is shorter than the sum of user time and system time. This can happen when multiple threads or CPUs are used to execute the expression. For example, a task that takes 10 seconds of user time can be completed in 5 seconds if there are two CPUs sharing the load.</li></ul></div><p>Most of the time, we <a id="id30" class="indexterm"/>are interested in the total elapsed time to execute the given expression. When the expression is executed on a single thread (the default for R), the elapsed time is usually very close to the sum of the user time and system time. If that is not the case, either the expression has spent time waiting for resources to be available, or there were many other processes on the system competing for the CPU's time.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip03"/>Tip</h3><p>It is best to shut down any unnecessary programs and processes on the system before running <code class="literal">system.time()</code> in order to reduce the competition for the CPU's time and to get an accurate measurement. Of course, the antivirus software or any other critical system software should not be turned off.</p></div></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note03"/>Note</h3><p>The <code class="literal">system.time()</code> declaration actually returns a vector with five elements but its <code class="literal">print()</code> function displays only the first three. To see all the five elements, we can call <code class="literal">print(unclass(system.time(expr)))</code>. The other two elements are the system and user times for the execution of any child processes spawned by <code class="literal">expr</code>. On Windows machines, these are not available and will always be given as <code class="literal">NA</code>.</p></div></div><p>This is what happens when we run <code class="literal">system.time()</code> a few more times with the same expression:</p><div class="informalexample"><pre class="programlisting">system.time(runif(1e8))
##  user  system elapsed 
## 2.963   0.160   3.128 
system.time(runif(1e8))
##  user  system elapsed 
## 2.971   0.162   3.136 
system.time(runif(1e8))
##  user  system elapsed 
## 2.944   0.161   3.106</pre></div><p>By running <code class="literal">system.time()</code> repeatedly, we get slightly different results each time because R's overheads, OS caching mechanisms, other running processes, and many other factors might have a <a id="id31" class="indexterm"/>slight impact on the execution time.</p></div><div class="section" title="Repeating time measurements with rbenchmark"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec08"/>Repeating time measurements with rbenchmark</h2></div></div></div><p>It is sometimes<a id="id32" class="indexterm"/> helpful to run the same expression multiple times and get the average execution time, or even the distribution of execution times over multiple runs. The <code class="literal">rbenchmark</code> CRAN package lets us do this easily.</p><p>First, install and load the <code class="literal">rbenchmark</code> package:</p><div class="informalexample"><pre class="programlisting">install.packages("rbenchmark")
library(rbenchmark)</pre></div><p>Next, use <code class="literal">benchmark()</code> to run the same random number generation task 10 times, by specifying <code class="literal">replications=10</code>:</p><div class="informalexample"><pre class="programlisting">bench1 &lt;- benchmark(runif(1e8), replications=10)
bench1
##           test replications elapsed relative user.self
## 1 runif(1e+08)           10   32.38        1    29.781
##   sys.self user.child sys.child
## 1    2.565          0         0</pre></div><p>The results show the total elapsed system and user time taken to generate 100 million uniform random variables over 10 repetitions. We can find the mean times taken per repetition using <code class="literal">within()</code> to divide the time measurements by the number of repetitions:</p><div class="informalexample"><pre class="programlisting">within(bench1, {
       elapsed.mean &lt;- elapsed/replications
       user.self.mean &lt;- user.self/replications
       sys.self.mean &lt;- sys.self/replications
       })
##           test replications elapsed relative user.self
## 1 runif(1e+08)           10   32.38        1    29.781
##   sys.self user.child sys.child sys.self.mean user.self.mean
## 1    2.565          0         0        0.2565         2.9781
##   elapsed.mean
## 1        3.238</pre></div><p>What if we want to know the execution times for each repetition, or the distribution of execution times over the repetitions? We can pass a vector instead of a single number as the <code class="literal">replications</code> parameter. For each element of this vector, <code class="literal">benchmark()</code> will execute the given expression the specified number of times. So we can get 10 samples of the execution of the <a id="id33" class="indexterm"/>random number generation once, as shown in the following code. In addition to the elapsed user and system time, <code class="literal">benchmark()</code> returns an additional column, <code class="literal">relative</code>, which indicates how each repetition's elapsed time is compared with the fastest one. For example, the first repetition took 1.011 times as long as the fastest repetition (the fourth one), or 1.1 percent longer to run:</p><div class="informalexample"><pre class="programlisting">benchmark(runif(1e8), replications=rep.int(1, 10))
##            test replications elapsed relative user.self
## 1  runif(1e+08)            1   3.162    1.011     2.971
## 2  runif(1e+08)            1   3.145    1.005     2.951
## 3  runif(1e+08)            1   3.141    1.004     2.949
## 4  runif(1e+08)            1   3.128    1.000     2.937
## 5  runif(1e+08)            1   3.261    1.043     3.021
## 6  runif(1e+08)            1   3.207    1.025     2.993
## 7  runif(1e+08)            1   3.274    1.047     3.035
## 8  runif(1e+08)            1   3.174    1.015     2.966
## 9  runif(1e+08)            1   3.172    1.014     2.970
## 10 runif(1e+08)            1   3.230    1.033     3.004
##    sys.self user.child sys.child
## 1     0.187          0         0
## 2     0.191          0         0
## 3     0.189          0         0
## 4     0.190          0         0
## 5     0.228          0         0
## 6     0.210          0         0
## 7     0.230          0         0
## 8     0.207          0         0
## 9     0.201          0         0
## 10    0.224          0         0</pre></div></div><div class="section" title="Measuring distribution of execution time with microbenchmark"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec09"/>Measuring distribution of execution time with microbenchmark</h2></div></div></div><p>The CRAN package <a id="id34" class="indexterm"/>
<code class="literal">microbenchmark</code> provides yet another way to measure the execution time of an R expression. Though its <code class="literal">microbenchmark()</code> function only measures the elapsed time and not the user time or system time, it gives an idea of how the execution times across repeated runs are distributed. It also automatically corrects for the overheads related to the execution of the timing tests. The <code class="literal">microbenchmark()</code> function is very handy to measure short running tasks over many repetitions provided you do not need to measure the user or system times. We will use this tool many times throughout this book.</p><p>Install and load the <code class="literal">microbenchmark</code> package:</p><div class="informalexample"><pre class="programlisting">install.packages("microbenchmark")
library(microbenchmark)</pre></div><p>Now, run the same random number generation task 10 times using <code class="literal">microbenchmark()</code>:</p><div class="informalexample"><pre class="programlisting">microbenchmark(runif(1e8), times=10)
## Unit: seconds
##          expr      min       lq  median       uq      max
##  runif(1e+08) 3.170571 3.193331 3.25089 3.299966 3.314355
##  neval
##     10</pre></div><p>The statistics shows the minimum, lower quartile, median, upper quartile, and maximum values of the elapsed time over 10 repetitions. This gives us an idea of the distribution of the elapsed times over different repetitions of the same expression.</p></div></div></div>
<div class="section" title="Profiling the execution time"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec15"/>Profiling the execution time</h1></div></div></div><p>So far, we <a id="id35" class="indexterm"/>have seen how to measure the execution time of a whole R expression. What about a more complex expression with multiple parts such as calls to other functions? Is there a way to dig deeper and profile the execution time of each of the parts that make up the expression? R comes with the profiling tool <code class="literal">Rprof()</code> that allows us to do just that. Let's see how it works.</p><div class="section" title="Profiling a function with Rprof()"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec10"/>Profiling a function with Rprof()</h2></div></div></div><p>In this <a id="id36" class="indexterm"/>example, we <a id="id37" class="indexterm"/>write the following <code class="literal">sampvar()</code> function to calculate the unbiased sample variance of a numeric vector. This is obviously not the best way to write this function (in fact R provides the <code class="literal">var()</code> function to do this), but it serves to illustrate how code profiling works:</p><div class="informalexample"><pre class="programlisting"># Compute sample variance of numeric vector x
sampvar &lt;- function(x) {
    # Compute sum of vector x
    my.sum &lt;- function(x) {
        sum &lt;- 0
        for (i in x) {
            sum &lt;- sum + i
        }
        sum
    }
    
    # Compute sum of squared variances of the elements of x from
    # the mean mu
    sq.var &lt;- function(x, mu) {
        sum &lt;- 0
        for (i in x) {
            sum &lt;- sum + (i - mu) ^ 2
        }
        sum
    }
    
    mu &lt;- my.sum(x) / length(x)
    sq &lt;- sq.var(x, mu)
    sq / (length(x) - 1)
}</pre></div><p>Within <code class="literal">sampvar()</code>, we define two utility functions:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">my.sum()</code>: This computes the sum of a vector by looping over the elements of the vector.</li><li class="listitem" style="list-style-type: disc"><code class="literal">sq.var()</code>: This computes the sum of the squared deviations of a vector from a given mean, by looping over the elements of the vector.</li></ul></div><p>The <code class="literal">sampvar()</code> function first computes the sample mean, then the sum of squared deviations from that mean, and then the sample variance by dividing that sum by <span class="emphasis"><em>n-1</em></span>.</p><p>We can profile the <code class="literal">sampvar()</code> function as follows:</p><div class="informalexample"><pre class="programlisting">x &lt;- runif(1e7)
Rprof("Rprof.out")
y &lt;- sampvar(x)
Rprof(NULL)
summaryRprof("Rprof.out")
## $by.self
##          self.time self.pct total.time total.pct
## "sq.var"      4.38    58.24       5.28     70.21
## "my.sum"      1.88    25.00       2.24     29.79
## "^"           0.46     6.12       0.46      6.12
## "+"           0.44     5.85       0.44      5.85
## "-"           0.28     3.72       0.28      3.72
## "("           0.08     1.06       0.08      1.06
##
## $by.total
##           total.time total.pct self.time self.pct
## "sampvar"       7.52    100.00      0.00     0.00
## "sq.var"        5.28     70.21      4.38    58.24
## "my.sum"        2.24     29.79      1.88    25.00
## "^"             0.46      6.12      0.46     6.12
## "+"             0.44      5.85      0.44     5.85
## "-"             0.28      3.72      0.28     3.72
## "("             0.08      1.06      0.08     1.06
##
## $sample.interval
## [1] 0.02
##
## $sampling.time
## [1] 7.52</pre></div><p>This is how the <a id="id38" class="indexterm"/>code works:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">The <code class="literal">runif(1e7)</code> expression generates a random sample of 10 million numbers.</li><li class="listitem">The <code class="literal">Rprof("Rprof.out")</code> expression tells R to begin profiling. <code class="literal">Rprof.out</code> is the name of a file in which the profiling data is stored. It will be stored in R's current working directory unless another file path is specified.</li><li class="listitem">The <code class="literal">sampvar(x)</code> expression calls the function we just created.</li><li class="listitem">The <code class="literal">Rprof(NULL)</code> expression tells R <a id="id39" class="indexterm"/>to stop profiling. Otherwise, it will continue to profile other R statements that we run but do not intend to profile.</li><li class="listitem">The <code class="literal">summaryRprof("Rprof.out")</code> expression prints the results of the profiling.</li></ol></div></div><div class="section" title="The profiling results"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec11"/>The profiling results</h2></div></div></div><p>The <a id="id40" class="indexterm"/>results are broken down into a few measures:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">self.time</code> and <code class="literal">self.pct</code> columns represent the elapsed time for each function, excluding the elapsed time of other functions that are called by the function.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">total.time</code> and <code class="literal">total.pct</code> columns represent the total elapsed time for each function including the time spent inside function calls.</li></ul></div><p>From the profiling data, we get some interesting observations:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">sampvar()</code> function's <code class="literal">self.time</code> is negligible (reported as zero), indicating that almost all the time taken to run <code class="literal">sampvar</code> is contributed by the functions that it calls.</li><li class="listitem" style="list-style-type: disc">While <code class="literal">sampvar()</code> spent a total of 7.52 seconds, 5.28 seconds of this time was contributed by <code class="literal">sq.var()</code>, and 2.24 seconds by <code class="literal">my.sum()</code> (see <code class="literal">total.time</code> of <code class="literal">sq.var()</code> and <code class="literal">my.sum()</code>).</li><li class="listitem" style="list-style-type: disc">The <code class="literal">sq.var()</code> function took the largest chunk of time (70.21 percent) to get executed and looks like a good place to start improving the performance.</li><li class="listitem" style="list-style-type: disc">The R operators <code class="literal">-</code>, <code class="literal">+</code>, and <code class="literal">*</code> were extremely quick, taking not more than a total of 0.46 seconds each, even though they were executed millions of times.</li></ul></div><p><code class="literal">Rprof()</code> works by observing R's call stack as the R expression is running, and taking a snapshot of the call stack at fixed intervals (every 0.02 seconds by default) to see which function is currently executing. From these snapshots, <code class="literal">summaryRprof()</code> can compute how much time was spent in each function.</p><p>For a more intuitive view of the profiling data, we can use the <code class="literal">proftools</code> package. We will also need to install the <code class="literal">graph</code> and <code class="literal">Rgraphviz</code> packages from the Bioconductor repository:</p><div class="informalexample"><pre class="programlisting">install.packages("proftools")
source("http://bioconductor.org/biocLite.R")
biocLite(c("graph", "Rgraphviz"))
library(proftools)
p &lt;- readProfileData(filename="Rprof.out")
plotProfileCallGraph(p, style=google.style, score="total")</pre></div><p>The <code class="literal">plotProfileCallGraph()</code> function generates an intuitive visual plot of the profile data. We use the <code class="literal">google.style</code> template which shows functions with longer <code class="literal">self.time</code> in bigger boxes. We also specify <code class="literal">score="total"</code> to color the boxes according to <code class="literal">total.time</code>. The following figure shows the output of the same profiling data:</p><div class="mediaobject"><img src="graphics/9263OS_02_01.jpg" alt="The profiling results"/><div class="caption"><p>Profiling data for sampvar() rendered by plotProfileCallGrah()</p></div></div><p>We can see <a id="id41" class="indexterm"/>from <code class="literal">sampvar()</code> that it has the longest <code class="literal">total.time</code> of 100 percent. This is expected since it is the function that is being profiled. The next longest-running function is <code class="literal">sq.var()</code>, which accounts for 70.21 percent of the elapsed time. <code class="literal">sq.var()</code> also happens to have the longest <code class="literal">self.time</code>, which can be seen from the size of its box. Thus, <code class="literal">sq.var()</code> seems like a good candidate for the first step in addressing performance problems.</p><p>The <code class="literal">Rprof()</code> function<a id="id42" class="indexterm"/> is a useful tool to understand the performance of different parts of R programs and quickly spot bottlenecks that we can address to improve the overall performance of our R code.</p></div></div>
<div class="section" title="Profiling memory utilization"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec16"/>Profiling memory utilization</h1></div></div></div><p>Next, let's <a id="id43" class="indexterm"/>consider how to profile the memory utilization of R code.</p><p>One approach is to use <code class="literal">Rprof()</code> by setting the <code class="literal">memory.profiling</code> argument and the corresponding <code class="literal">memory</code> argument to <code class="literal">summaryRprof()</code>:</p><div class="informalexample"><pre class="programlisting">Rprof("Rprof-mem.out", memory.profiling=TRUE)
y &lt;- sampvar(x)
Rprof(NULL)
summaryRprof("Rprof-mem.out", memory="both")
## $by.self
##          self.time self.pct total.time total.pct mem.total
## "sq.var"      4.16    54.88       5.40     71.24    1129.4
## "my.sum"      1.82    24.01       2.18     28.76     526.9
## "^"           0.56     7.39       0.56      7.39     171.0
## "+"           0.44     5.80       0.44      5.80     129.2
## "-"           0.40     5.28       0.40      5.28     140.2
## "("           0.20     2.64       0.20      2.64      49.7
##
## $by.total
##           total.time total.pct mem.total self.time self.pct
## "sampvar"       7.58    100.00    1656.2      0.00     0.00
## "sq.var"        5.40     71.24    1129.4      4.16    54.88
## "my.sum"        2.18     28.76     526.9      1.82    24.01
## "^"             0.56      7.39     171.0      0.56     7.39
## "+"             0.44      5.80     129.2      0.44     5.80
## "-"             0.40      5.28     140.2      0.40     5.28
## "("             0.20      2.64      49.7      0.20     2.64
##
## $sample.interval
## [1] 0.02
##
## $sampling.time
## [1] 7.58</pre></div><p>The output now <a id="id44" class="indexterm"/>shows an additional column <code class="literal">mem.total</code> reporting the memory utilization of each function. For this example, it seems that it took 1,656 MB of memory to run <code class="literal">sampvar()</code>! This seems exceptionally high for computations on a numeric vector with 10 million elements, which would measure only 76.3 MB in the memory (you can check this by running <code class="literal">print(object.size(x), units="auto")</code>).</p><p>Unfortunately, <code class="literal">mem.total</code> is a misleading measure because <code class="literal">Rprof()</code> attributes the memory usage to the function that happens to be running when it takes a snapshot, but the memory could have been used by other functions and not have been released yet. Furthermore, R's garbage collector regularly releases unused memory to the operating system, so the actual memory being used at any given time might be vastly different from that reported by <code class="literal">Rprof()</code>. In other words, <code class="literal">Rprof()</code> gives an indication of the total amount of memory allocated while running an R code, but does not take into account the memory freed by the garbage collector.</p><p>To see how garbage <a id="id45" class="indexterm"/>collection affects memory utilization, we can run the following:</p><div class="informalexample"><pre class="programlisting">&gt; gcinfo(TRUE)
y &lt;- sampvar(x)
## Garbage collection 945 = 886+43+16 (level 0) ... 
## 31.1 Mbytes of cons cells used (59%)
## 82.8 Mbytes of vectors used (66%)
## Garbage collection 946 = 887+43+16 (level 0) ... 
## 31.1 Mbytes of cons cells used (59%)
## 82.8 Mbytes of vectors used (66%)
##... (truncated for brevity) ...
gcinfo(FALSE)</pre></div><p>The <code class="literal">gcinfo(TRUE)</code> expression tells R to inform us every time the garbage collector releases memory. On our machine, the garbage collector was activated 272 times while running <code class="literal">sampvar()</code>! Although <code class="literal">Rprof()</code> reported that 1.7 GB of the memory was allocated in total, the garbage collector was hard at work to release unused memory so that R's total memory consumption stayed manageable at around 113.9 MB (<span class="emphasis"><em>31.1 MB + 82.8 MB</em></span>).</p><p>Because <code class="literal">Rprof()</code> measures the cumulative allocated memory without accounting for garbage collection, it is not suited for determining whether an R program will exceed the available memory on a system. <code class="literal">gcinfo()</code> provides a clearer picture, albeit still an approximate one, by providing a snapshot of the memory consumption at every garbage collection interval.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note04"/>Note</h3><p>The <code class="literal">gcinfo()</code> and <code class="literal">gc()</code> functions give pretty good estimates of memory utilization in this case because our code uses only standard R operations. Some R packages use custom memory allocators that <code class="literal">gcinfo()</code> and <code class="literal">gc()</code> are not able to track, so memory utilization can be underreported.</p></div></div></div>
<div class="section" title="Monitoring memory utilization, CPU utilization, and disk I/O using OS tools"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec17"/>Monitoring memory utilization, CPU utilization, and disk I/O using OS tools</h1></div></div></div><p>Unlike execution time, R does not provide any good tools to profile CPU utilization and disk I/O. Even the <a id="id46" class="indexterm"/>memory profiling tools in R might not provide a complete or accurate picture. This is where we turn to <a id="id47" class="indexterm"/>OS-provided system monitoring tools to keep an eye on the computational resources as we run R programs. They are task manager or resource monitor in Windows, activity monitor in Mac OS X, and <code class="literal">top</code> in Linux. When running these tools, look for the processes that represent R (usually called <code class="literal">R</code> or <code class="literal">rsession</code>).</p><p>The information that we get <a id="id48" class="indexterm"/>varies depending on the operating system, but here are the <a id="id49" class="indexterm"/>key measures of R's resource utilization to keep an eye on:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>% CPU or CPU usage</strong></span>: The percentage of the system's CPU time used by R</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>% memory, resident memory, or working set</strong></span>: The percentage of the system's physical memory used by R</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Swap size or page outs</strong></span>: The size of memory used by R that is stored in the operating system's swapspace</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Bytes read or written per second</strong></span>: The rate of data being read or written from/to disk by R</li></ul></div><p>In addition, we might <a id="id50" class="indexterm"/>also want to monitor these system-wide resource utilization measures:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>% free memory</strong></span>: The percentage of the system's physical memory that is available for use</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Swap size or page outs</strong></span>: The total size of memory that is stored in the OS's swapspace</li></ul></div><p>The preceding measures <a id="id51" class="indexterm"/>are helpful in troubleshooting R's performance problems:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>High CPU utilization</strong></span>: A CPU is likely the main bottleneck of R's performance. Use the profiling techniques in this chapter to identify which parts of the code are taking most of the CPU's time.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Low CPU utilization, low free system memory with large swap size, and high disk I/O</strong></span>: The system is likely running out of physical memory and is thus swapping memory onto the disk. Use the memory management techniques in <a class="link" href="ch06.html" title="Chapter 6. Simple Tweaks to Use Less RAM">Chapters 6</a>, <span class="emphasis"><em>Simple Tweaks to Use Less RAM</em></span>, and <a class="link" href="ch07.html" title="Chapter 7. Processing Large Datasets with Limited RAM">Chapter 7</a>, <span class="emphasis"><em>Processing Large Datasets with Limited RAM</em></span>, to reduce the memory required by the R program.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Sufficient free system memory with high disk I/O</strong></span>: The program writes/reads to disk very often. Check for any unnecessary I/O operations and store intermediate data in the memory if there is sufficient free memory.</li></ul></div></div>
<div class="section" title="Identifying and resolving bottlenecks"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec18"/>Identifying and resolving bottlenecks</h1></div></div></div><p>Now that <a id="id52" class="indexterm"/>we have covered <a id="id53" class="indexterm"/>the basic techniques to profile an R code, which performance bottlenecks should we try to solve first?</p><p>As a rule of thumb, we first try to improve the pieces of code that are causing the largest performance bottlenecks, whether in terms of execution time, memory utilization, or other measures. These can be identified with the profiling techniques covered earlier. Then we work our way down the list of the largest bottlenecks until the overall performance of the program is good enough.</p><p>As you can recall, the <code class="literal">varsamp()</code> example that we profiled using <code class="literal">Rprof()</code>. The function with the highest <code class="literal">self.time</code> was <code class="literal">sq.var()</code>. How can we make this function run faster? We can write it in the form of a vector operation <code class="literal">my.sum((x - mu) ^ 2)</code> rather than looping through each element of <code class="literal">x</code>. As we will see in the next chapter, converting loops to vectorized operations is a good way to speed up many R operations. In fact, we can even remove the function altogether since the new vector expression fits in one line:</p><div class="informalexample"><pre class="programlisting"># Compute sample variance of numeric vector x
sampvar &lt;- function(x) {
    # Compute sum of vector x
    my.sum &lt;- function(x) {
        sum &lt;- 0
        for (i in x) {
            sum &lt;- sum + i
        }
        sum
    }
    
    mu &lt;- my.sum(x) / length(x)
    sq &lt;- my.sum((x - mu) ^ 2)
    sq / (length(x) - 1)
}

x &lt;- runif(1e7)
Rprof("Rprof-mem.out", memory.profiling=TRUE)
y &lt;- sampvar(x)
Rprof(NULL)
summaryRprof("Rprof-mem.out", memory="both")
## $by.self
##          self.time self.pct total.time total.pct mem.total
## "my.sum"      3.92    85.22       4.60    100.00    1180.6
## "+"           0.66    14.35       0.66     14.35     104.2
## "-"           0.02     0.43       0.02      0.43      83.1
##
## $by.total
##               total.time total.pct mem.total self.time self.pct
## "my.sum"            4.60    100.00    1180.6      3.92    85.22
## "eval"              4.60    100.00    1180.6      0.00     0.00
## "sampvar"           4.60    100.00    1180.6      0.00     0.00
## "source"            4.60    100.00    1180.6      0.00     0.00
## "withVisible"       4.60    100.00    1180.6      0.00     0.00
## "+"                 0.66     14.35     104.2      0.66    14.35
## "-"                 0.02      0.43      83.1      0.02     0.43
##
## $sample.interval
## [1] 0.02
##
## $sampling.time
## [1] 4.6</pre></div><p>This change <a id="id54" class="indexterm"/>shaved 2.98 seconds off the elapsed time and 477 MB off the total memory allocated while running the function.</p><p>Now the <code class="literal">my.sum()</code> function <a id="id55" class="indexterm"/>contributes to a significant 85 percent of the total elapsed time. Let's replace it with the <code class="literal">sum()</code> function from R, which runs much faster:</p><div class="informalexample"><pre class="programlisting"># Compute sample variance of numeric vector x
sampvar &lt;- function(x) {
    mu &lt;- sum(x) / length(x)
    sq &lt;- sum((x - mu) ^ 2)
    sq / (length(x) - 1)
}

x &lt;- runif(1e7)
Rprof("Rprof-mem.out", memory.profiling=TRUE)
y &lt;- sampvar(x)
Rprof(NULL)
summaryRprof("Rprof-mem.out", memory="both")
## $by.self
##     self.time self.pct total.time total.pct mem.total
## "-"      0.08      100       0.08       100      76.2
##
## $by.total
##           total.time total.pct mem.total self.time self.pct
## "-"             0.08       100      76.2      0.08      100
## "sampvar"       0.08       100      76.2      0.00        0
##
## $sample.interval
## [1] 0.02
##
## $sampling.time
## [1] 0.08</pre></div><p>Voila! In two <a id="id56" class="indexterm"/>simple <a id="id57" class="indexterm"/>steps, we reduced the elapsed time of <code class="literal">sampvar()</code> from 7.58 seconds to 0.08 seconds (a 99 percent reduction). Furthermore, the memory utilization as reported by <code class="literal">Rprof()</code> was also reduced from over 1.6 GB to a mere 76.2 MB (a 95.4 percent reduction). This reduction in memory allocation and garbage collection also played a significant part in speeding up our code.</p><p>Let's compare how fast our code runs compared to the R function <code class="literal">var()</code>, which is written in C for optimal performance (we will learn in <a class="link" href="ch04.html" title="Chapter 4. Using Compiled Code for Greater Speed">Chapter 4</a>, <span class="emphasis"><em>Using Compiled Code for Greater Speed</em></span>):</p><div class="informalexample"><pre class="programlisting">library(microbenchmark)
microbenchmark(sampvar(x), var(x))
## Unit: milliseconds
##        expr      min       lq   median       uq      max neval
##  sampvar(x) 44.31072 44.90836 50.38668 62.14281 74.93704   100
##      var(x) 35.62815 36.60720 37.04430 37.88039 42.85260   100</pre></div><p>With a median elapsed time of 50 milliseconds, our function takes only 36 percent more time than the optimized C version that has a median of 37 milliseconds.</p><p>The preceding exercise illustrates how code profiling can be used as part of a workflow to identify, prioritize, and fix performance issues in R programs. The rest of this book will cover techniques that we can use to solve specific performance problems.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec19"/>Summary</h1></div></div></div><p>In this chapter, we learned how to measure the execution time of R expressions using <code class="literal">system.time()</code>, <code class="literal">benchmark()</code> (from the <code class="literal">rbenchmark</code> package) and <code class="literal">microbenchmark()</code> (from the <code class="literal">microbenchmark</code> package). We examined how to profile the execution time and memory usage of different parts of an R program using <code class="literal">Rprof()</code> and <code class="literal">summaryRprof()</code> and to display the results in an intuitive visual form using the <code class="literal">proftools</code> package.</p><p>We also saw the role of OS-provided monitoring tools to understand the overall performance of R programs and how these system measures can provide clues about the performance bottlenecks that our R programs might be facing.</p><p>Finally, we learned how to apply the profiling techniques in a practical, iterative workflow to identify, prioritize and resolve performance related problems in an R code.</p><p>In the next chapter, we will learn some simple tweaks to improve R code so that it runs faster.</p></div></body></html>