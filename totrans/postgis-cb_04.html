<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Working with Vector Data – Advanced Recipes</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will cover:</p>
<ul>
<li>Improving proximity filtering with KNN</li>
<li>Improving proximity filtering with KNN <span>–</span> advanced</li>
<li>Rotating geometries</li>
<li>Improving ST_Polygonize</li>
<li>Translating, scaling, and rotating geometries <span>–</span> advanced</li>
<li>Detailed building footprints from LiDAR</li>
<li>Creating a fixed number of clusters from a set of points</li>
<li>Calculating a Voronoi diagrams</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p>Beyond being a spatial database with the capacity to store and query spatial data, PostGIS is a very powerful analytical tool. What this means to the user is a tremendous capacity to expose and encapsulate deep spatial analyses right within a PostgreSQL database.</p>
<p>The recipes in this chapter can roughly be divided into four main sections:</p>
<ul>
<li>Highly optimized queries:
<ul>
<li>Improving proximity filtering with KNN</li>
<li>Improving proximity filtering with KNN <span>–</span> advanced</li>
</ul>
</li>
<li>Using the database to create and modify geometries:
<ul>
<li>Rotating geometries</li>
<li>Improving ST_Polygonize</li>
<li>Translating, scaling, and rotating geometries – advanced</li>
<li>Getting detailed building footprints from LiDAR</li>
</ul>
</li>
<li><span>Creating a fixed number of clusters from a set of points:</span>
<ul>
<li>Using the PostGIS function,<span> </span><kbd>ST_ClusterKMeans</kbd>,<span> </span><span class="im">to create K clusters from a set of points</span></li>
<li><span class="im">Using a minimum bounding circle to visually represent the clusters with the</span><span> </span><kbd>ST_ MinimumBoundingCircle</kbd><span> </span>function</li>
</ul>
</li>
<li>Calculating a Voronoi diagram:
<ul>
<li>Using the <kbd>ST_VoronoiPolygon</kbd> function in order to calculate Voronoi diagrams</li>
</ul>
</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Improving proximity filtering with KNN</h1>
                </header>
            
            <article>
                
<p class="mce-root">The basic question that we seek to answer in this recipe is the fundamental distance question, <em>which are the five coffee shops closest to me?</em> It turns out that while it is a fundamental question, it's not always easy to answer, though we will make this possible in this recipe. We will approach this in two steps. The first step with which we'll approach this is in a simple heuristic way, which will allow us to come to a solution quickly. Then, we'll take advantage of the deeper PostGIS functionality to make the solution faster and more general with a <strong>k-Nearest Neighbor</strong> (<strong>KNN</strong>) approach.</p>
<p class="mce-root"><span>A concept that we need to understand from the outset is that of a spatial index. A spatial index, like other database indexes, functions like a book index. It is a special construct to make looking for things inside our table easier, much in the way a book index helps us find content in a book faster. In the case of a spatial index, it helps us find faster ways, when things are in space. Therefore, by using a spatial index in our geographic searches, we can speed up our searches by orders of magnitude.</span></p>
<div class="packt_infobox"><span>To learn more about spatial indexes, see </span><a href="http://en.wikipedia.org/wiki/Spatial_index#Spatial_index"><span class="URLPACKT">http://en.wikipedia.org/wiki/Spatial_index#Spatial_index</span></a><span>.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>We will start by loading our data. Our data is the address records from Cuyahoga County, Ohio, USA:</p>
<pre><strong>shp2pgsql -s 3734 -d -i -I -W LATIN1 -g the_geom CUY_ADDRESS_POINTS chp04.knn_addresses | psql -U me -d postgis_cookbook</strong>  </pre>
<p>As this dataset may take a while to load, you can alternatively load a subset:</p>
<pre><strong>shp2pgsql -s 3734 -d -i -I -W LATIN1 -g the_geom CUY_ADDRESS_POINTS_subset chp04.knn_addresses | psql -U me -d postgis_cookbook</strong>  </pre>
<p>We specified the <kbd>-I</kbd> flag in order to request that a spatial index be created upon the import of this data.</p>
<p>Let us start by seeing how many records we are dealing with:</p>
<pre><strong>SELECT COUNT(*) FROM chp04.knn_addresses; 
--484958</strong></pre>
<p>We have, in this address table, almost half a million address records, which is not an insubstantial number to perform a query.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>KNN is an approach of searching for an arbitrary number of points closest to a given point. Without the right tools, this can be a very slow process that requires testing the distance between the point of interest and all the possible neighbors. The problem with this approach is that the search becomes exponentially slower with a greater number of points. Let's start with this naive approach and then improve on it.</p>
<p>Suppose we were interested in finding the 10 records closest to the geographic location -81.738624, 41.396679. The naive approach would be to transform this value into our local coordinate system and compare the distance to each point in the database from the search point, order those values by distance, and limit the search to the first 10 closest records (it is not recommended that you run the following query as it could run indefinitely):</p>
<pre><strong>SELECT ST_Distance(searchpoint.the_geom, addr.the_geom) AS dist, * FROM 
  chp04.knn_addresses addr, 
  (SELECT ST_Transform(ST_SetSRID(ST_MakePoint(-81.738624, 41.396679),<br/>    4326), 3734) AS the_geom) searchpoint 
  ORDER BY ST_Distance(searchpoint.the_geom, addr.the_geom) 
  LIMIT 10;</strong> </pre>
<p>This is a fine approach for smaller datasets. This is a logical, simple, fast approach for a relatively small numbers of records; however, this approach scales very poorly, getting exponentially slower with the addition of records (with 500,000 points, this would take a very long time).</p>
<p>An alternative is to only compare the point of interest to the ones known to be close by setting a search distance. So, for example, in the following diagram, we have a star that represents the current location, and we want to know the 10 closest addresses. The grid in the diagram is 100 feet long, so we can search for the points within 200 feet, then measure the distance to each of these points, and return the closest 10 points:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/f955df93-9fac-4334-9970-590159d7af79.png" style="width:20.92em;height:20.75em;"/></div>
<p>Thus, our approach to answer this question is to limit the search using the <kbd>ST_DWithin</kbd> operator to only search for records within a certain distance. <kbd>ST_DWithin</kbd> uses our spatial index, so the initial distance search is fast and the list of returned records should be short enough to do the same pair-wise distance comparison we did earlier in this section. In our case here, we could limit the search to within 200 feet:</p>
<pre><strong>SELECT ST_Distance(searchpoint.the_geom, addr.the_geom) AS dist, * FROM 
  chp04.knn_addresses addr, 
  (SELECT ST_Transform(ST_SetSRID(ST_MakePoint(-81.738624, 41.396679), <br/>    4326), 3734) AS the_geom) searchpoint 
  WHERE ST_DWithin(searchpoint.the_geom, addr.the_geom, 200) 
  ORDER BY ST_Distance(searchpoint.the_geom, addr.the_geom) 
  LIMIT 10;</strong> </pre>
<p>The output for the previous query is as follows:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/d5dd72ff-d4fd-453d-965a-1ef237c81bba.png" style="width:41.33em;height:14.75em;"/></div>
<p>This approach performs well so long as our search window, <kbd>ST_DWithin</kbd>, is the right size for the data. The problem with this approach is that, in order to optimize it, we need to know how to set a search window that is about the right size. Any larger than the right size and the query will run more slowly than we'd like. Any smaller than the right size and we might not get all the points back that we need. Inherently, we don't know this ahead of time, so we can only hope for the best guess.</p>
<p>In this same dataset, if we apply the same query in another location, the output will return no points because the 10 closest points are further than 200 feet away. We can see this in the following diagram:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/5adf9ef6-709d-4f4f-9d36-289a4e6b6d01.png" style="width:17.25em;height:17.33em;"/></div>
<p>Fortunately, for PostGIS 2.0+ we can leverage the distance operators (<kbd>&lt;-&gt;</kbd> and <kbd>&lt;#&gt;</kbd>) to do indexed nearest neighbor searches. This makes for very fast KNN searches that don't require us to guess ahead of time how far away we need to search. Why are the searches fast? The spatial index helps of course, but in the case of the distance operator, we are using the structure of the index itself, which is hierarchical, to very quickly sort our neighbors.</p>
<p>When used in an <kbd>ORDER BY</kbd> clause, the distance operator uses the index:</p>
<pre><strong>SELECT ST_Distance(searchpoint.the_geom, addr.the_geom) AS dist, * FROM 
  chp04.knn_addresses addr, 
  (SELECT ST_Transform(ST_SetSRID(ST_MakePoint(-81.738624, 41.396679),<br/>    4326), 3734) AS the_geom) searchpoint 
  ORDER BY addr.the_geom &lt;-&gt; searchpoint.the_geom 
  LIMIT 10;</strong> </pre>
<p>This approach requires no prior knowledge of how far the nearest neighbors might be. It also scales very well, returning thousands of records in not more than the time it takes to return a few records. It is sometimes slower than using <kbd>ST_DWithin</kbd>, depending on how small our search distance is and how large the dataset we are dealing with is. But the trade-off is that we don't need to make a guess of our search distance and for large queries, it can be much faster than the naive approach.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>What makes this magic possible is that PostGIS uses an R-tree index. This means that the index itself is sorted hierarchically based on spatial information. As demonstrated, we can leverage the structure of the index in sorting distances from a given arbitrary location, and thus use the index to directly return the sorted records. This means that the structure of the spatial index itself helps us answer such fundamental questions quickly and inexpensively.</p>
<div class="packt_tip">More information about KNN and R-tree can be found at <a href="http://workshops.boundlessgeo.com/postgis-intro/knn.html"><span class="URLPACKT">http://workshops.boundlessgeo.com/postgis-intro/knn.html</span></a> and <a href="https://en.wikipedia.org/wiki/R-tree"><span class="URLPACKT">https://en.wikipedia.org/wiki/R-tree</span></a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li>The <em>Improving proximity filtering with KNN – advanced</em> recipe</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Improving proximity filtering with KNN – advanced</h1>
                </header>
            
            <article>
                
<p>In the preceding recipe, we wanted to answer the simple question of which are the nearest 10 locations to a given point. There is another simple question with a surprisingly sophisticated answer. The question is how do we approach this problem when we want to traverse an entire dataset and test each record for its nearest neighbors?</p>
<p>Our problem is as follows: for each point in our table, we are interested in the angle to the nearest object in another table. A case demonstrating this scenario is if we want to represent address points as building-like squares rotated to align with an adjacent road, similar to the historic <strong>United States Geological Survey</strong> (<strong>USGS</strong>) quadrangle maps, as shown in the following screenshot:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/7a57964b-3e25-475a-a04b-49fb729b4a2f.png" style="width:39.58em;height:32.83em;"/></div>
<p>For larger buildings, USGS quads show the buildings' footprints, but for residential buildings below their minimum threshold, the points are just rotated squares—a nice cartographic effect that could easily be replicated with address points.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>As in the previous recipe, we will start off by loading our data. Our data is the address records from Cuyahoga County, Ohio, USA. If you loaded this in the previous recipe, there is no need to reload the data. If you have not loaded the data yet, run the following command:</p>
<pre><strong>shp2pgsql -s 3734 -d -i -I -W LATIN1 -g the_geom CUY_ADDRESS_POINTS chp04.knn_addresses | psql -U me -d postgis_cookbook</strong></pre>
<p>As this dataset may take a while to load, you can alternatively load a subset using the following command:</p>
<pre><strong>shp2pgsql -s 3734 -d -i -I -W LATIN1 -g the_geom CUY_ADDRESS_POINTS_subset chp04.knn_addresses | psql -U me -d postgis_cookbook</strong></pre>
<p>The address points will serve as a proxy for our building structures. However, to align our structure to the nearby streets, we will need a <kbd>streets</kbd> layer. We will use Cuyahoga County's street centerline data for this:</p>
<pre><strong>shp2pgsql -s 3734 -d -i -I -W LATIN1 -g the_geom CUY_STREETS chp04.knn_streets | psql -U me -d postgis_cookbook</strong></pre>
<p>Before we commence, we have to consider another aspect of using indexes, which we didn't need to consider in our previous KNN recipe. When our KNN approach used only points, our indexing was exact—the bounding box of a point is effectively a point. As bounding boxes are what indexes are built around, our indexing estimates of distance perfectly reflected the actual distances between our points. In the case of non-point geometries, as is our example here, the bounding box is an approximation of the lines to which we will be comparing our points. Put another way, what this means is that our nearest neighbor may not be our very nearest neighbor, but is likely our approximate nearest neighbor, or one of our nearest neighbors.</p>
<p>In practice, we apply a heuristic approach: we simply gather slightly more than the number of nearest neighbors we are interested in and then sort them based on the actual distance in order to gather only the number we are interested in. In this way, we only need to sort a small number of records.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Insofar as KNN is a nuanced approach to these problems, forcing KNN to run on all the records in a dataset takes what I like to call a venerable and age-old approach. In other words, it requires a bit of a hack.</p>
<div class="packt_tip">More on the general solution to using KNN within a function can be found in Alexandre Neto's post on the PostGIS users list at the following link:<br/>
<a href="http://lists.osgeo.org/pipermail/postgis-users/2012-May/034017.html"><span class="URLPACKT">http://lists.osgeo.org/pipermail/postgis-users/2012-May/034017.html</span></a></div>
<p>In SQL, the typical way to loop is to use a <kbd>SELECT</kbd> statement. For our case, we don't have a function that does KNN looping through the records in a table to use; we simply have an operator that allows us to efficiently order our returning records by distance from a given record. The workaround is to write a temporary function and thus be able to use <kbd>SELECT</kbd> to loop through the records for us. The cost is the creation and deletion of the function, plus the work done by the query, and the combination of costs is well worth the <em>hackiness</em> of the approach.</p>
<p>First, consider the following function:</p>
<pre><strong>CREATE OR REPLACE FUNCTION chp04.angle_to_street (geometry) RETURNS double precision AS $$ 
 
WITH index_query as (SELECT ST_Distance($1,road.the_geom) as dist, degrees(ST_Azimuth($1, ST_ClosestPoint(road.the_geom, $1))) as azimuth FROM  chp04.knn_streets As road ORDER BY $1 &lt;#&gt; road.the_geom limit 5) 
 
SELECT azimuth FROM index_query ORDER BY dist 
LIMIT 1; 
 
$$ LANGUAGE SQL;</strong></pre>
<p>Now, we can use this function quite easily:</p>
<pre><strong>CREATE TABLE chp04.knn_address_points_rot AS SELECT addr.*, chp04.angle_to_street(addr.the_geom) FROM chp04.knn_addresses  addr;</strong> </pre>
<p>If you have loaded the whole address dataset, this will take a while.</p>
<p>If we choose to, we can optionally drop the function so that extra functions are not left in our database:</p>
<pre><strong>DROP FUNCTION chp04.angle_to_street (geometry);</strong> </pre>
<p>In the next recipe, <em>Rotating geometries</em>, the calculated angle will be used to build new geometries.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Our function is simple, KNN magic aside. As an input to the function, we allow geometry, as shown in the following query:</p>
<pre><strong>CREATE OR REPLACE FUNCTION chp04.angle_to_street (geometry) RETURNS double precision AS $$</strong> </pre>
<p>The preceding function returns a floating-point value.</p>
<p>We then use a <kbd>WITH</kbd> statement to create a temporary table, which returns the five closest lines to our point of interest. Remember, as the index uses bounding boxes, we don't really know which line is the closest, so we gather a few extra points and then filter them based on distance. This idea is implemented in the following query:</p>
<pre><strong>WITH index_query as (SELECT ST_Distance($1,road.geom) as dist, degrees(ST_Azimuth($1, ST_ClosestPoint(road.geom, $1))) as azimuth 
FROM street_centerlines As road 
ORDER BY $1 &lt;#&gt; road.geom LIMIT 5)</strong> </pre>
<p>Note that we are actually returning to columns. The first column is <kbd>dist,</kbd> in which we calculate the distance to the nearest five road lines. Note that this operation is performed after the <kbd>ORDER BY</kbd> and <kbd>LIMIT</kbd> functions have been used as filters, so this does not take much computation. Then, we use <kbd>ST_Azimuth</kbd> to calculate the angle from our point to the closest points (<kbd>ST_ClosestPoint</kbd>) on each of our nearest five lines. In summary, what returns with our temporary <kbd>index_query</kbd> table is the distance to the nearest five lines and the respective rotation angles to the nearest five lines.</p>
<p>If we recall, however, we were not looking for the angle to the nearest five but to the true nearest road line. For this, we order the results by distance and further use <kbd>LIMIT 1</kbd>:</p>
<pre><strong>SELECT azimuth FROM index_query ORDER BY dist 
LIMIT 1;</strong> </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li>The <em>Improving proximity filtering with KNN</em> recipe</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Rotating geometries</h1>
                </header>
            
            <article>
                
<p>Among the many functions that PostGIS provides, geometry manipulation is a very powerful addition. In this recipe, we will explore a simple example of using the <kbd>ST_Rotate</kbd> function to rotate geometries. We will use a function from the <em>Improving proximity filtering with KNN – advanced</em> recipe to calculate our rotation values.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p><kbd>ST_Rotate</kbd> has a few variants: <kbd>ST_RotateX</kbd>, <kbd>ST_RotateY</kbd>, and <kbd>ST_RotateZ</kbd>, with the <kbd>ST_Rotate</kbd> function serving as an alias for <kbd>ST_RotateZ</kbd>. Thus, for two-dimensional cases, <kbd>ST_Rotate</kbd> is a typical use case.</p>
<p>In the <em>Improving proximity filtering with KNN – advanced</em> recipe, our function calculated the angle to the nearest road from a building's centroid or address point. We can symbolize that building's point according to that rotation factor as a square symbol, but more interestingly, we can explicitly build the area of that footprint in real space and rotate it to match our calculated rotation angle.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Recall our function from the <em>Improving proximity filtering with KNN – advanced</em> recipe:</p>
<pre><strong>CREATE OR REPLACE FUNCTION chp04.angle_to_street (geometry) RETURNS double precision AS $$ 
 
WITH index_query as (SELECT ST_Distance($1,road.the_geom) as dist, degrees(ST_Azimuth($1, ST_ClosestPoint(road.the_geom, $1))) as azimuth 
FROM  chp04.knn_streets As road 
ORDER BY $1 &lt;#&gt; road.the_geom limit 5) 
 
SELECT azimuth FROM index_query ORDER BY dist 
LIMIT 1; 
 
$$ LANGUAGE SQL;</strong> </pre>
<p>This function will calculate the geometry's angle to the nearest road line. Now, to construct geometries using this calculation, run the following function:</p>
<pre><strong>CREATE TABLE chp04.tsr_building AS 
 
SELECT ST_Rotate(ST_Envelope(ST_Buffer(the_geom, 20)), radians(90 - chp04.angle_to_street(addr.the_geom)), addr.the_geom) 
  AS the_geom FROM chp04.knn_addresses addr 
LIMIT 500;</strong> </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>In the first step, we are taking each of the points and first applying a buffer of 20 feet to them:</p>
<pre><strong>ST_Buffer(the_geom, 20)</strong> </pre>
<p>Then, we calculate the envelope of the buffer, providing us with a square around that buffered area. This is a quick and easy way to create a square geometry of a specified size from a point:</p>
<pre><strong>ST_Envelope(ST_Buffer(the_geom, 20))</strong> </pre>
<p>Finally, we use <kbd>ST_Rotate</kbd> to rotate the geometry to the appropriate angle. Here is where the query becomes harder to read. The <kbd>ST_Rotate</kbd> function takes two arguments:</p>
<pre><strong>ST_Rotate(geometry to rotate, angle, origin around which to rotate)</strong> </pre>
<p>The geometry we are using is the newly calculated geometry from the buffering and envelope creation. The angle is the one we calculate using our <kbd>chp04.angle_to_street</kbd> function. Finally, the origin around which we rotate is the input point itself, resulting in the following portion of our query:</p>
<pre><strong>ST_Rotate(ST_Envelope(ST_Buffer(the_geom, 20)), radians(90 -chp04.angle_to_street(addr.the_geom)), addr.the_geom); </strong></pre>
<p>This gives us some really nice cartography, as shown in the following diagram:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/c7bef09c-e81c-4b13-bd96-394873f1a030.png" style="width:31.83em;height:22.00em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li>The <em>Improving proximity filtering with KNN – advanced</em> recipe</li>
<li>The <em>Translating, scaling, and rotating geometries – advanced</em> recipe</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Improving ST_Polygonize</h1>
                </header>
            
            <article>
                
<p>In this short recipe, we will be using a common coding pattern in use when geometries are being constructed with <kbd>ST_Polygonize</kbd> and formalizing it into a function for reuse.</p>
<p><kbd>ST_Polygonize</kbd> is a very useful function. You can pass a set of <em>unioned</em> lines or an array of lines to <kbd>ST_Polygonize</kbd>, and the function will construct polygons from the input. <kbd>ST_Polygonize</kbd> does so aggressively insofar as it will construct all possible polygons from the inputs. One frustrating aspect of the function is that it does not return a multi-polygon, but instead returns a geometry collection. Geometry collections can be problematic in third-party tools for interacting with PostGIS as so many third party tools don't have mechanisms in place for recognizing and displaying geometry collections.</p>
<p>The pattern we will formalize here is the commonly recommended approach for changing geometry collections into mutlipolygons when it is appropriate to do so. This approach will be useful not only for <kbd>ST_Polygonize</kbd>, which we will use in the subsequent recipe, but can also be adapted for other cases where a function returns geometry collections, which are, for all practical purposes, multi-polygons. Hence, this is why it merits its own dedicated recipe.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>The basic pattern for handling geometry collections is to use <kbd>ST_Dump</kbd> to convert them to a dump type, extract the geometry portion of the dump, collect the geometry, and then convert this collection into a multi-polygon. The dump type is a special PostGIS type that is a combination of the geometries and an index number for the geometries. It's typical to use <kbd>ST_Dump</kbd> to convert from a geometry collection to a dump type and then do further processing on the data from there. Rarely is a dump object used directly, but it is typically an intermediate type of data.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>We expect this function to take a geometry and return a multi-polygon geometry:</p>
<pre><strong>CREATE OR REPLACE FUNCTION chp04.polygonize_to_multi (geometry) RETURNS geometry AS $$</strong> </pre>
<p>For readability, we will use a <kbd>WITH</kbd> statement to construct the series of transformations in geometry. First, we will polygonize:</p>
<pre><strong>WITH polygonized AS ( 
  SELECT ST_Polygonize($1) AS the_geom 
),</strong> </pre>
<p>Then, we will dump:</p>
<pre><strong>dumped AS ( 
  SELECT (ST_Dump(the_geom)).geom AS the_geom FROM polygonized 
)</strong> </pre>
<p>Now, we can collect and construct a multi-polygon from our result:</p>
<pre><strong>SELECT ST_Multi(ST_Collect(the_geom)) FROM dumped;</strong> </pre>
<p>Put this together into a single function:</p>
<pre><strong>CREATE OR REPLACE FUNCTION chp04.polygonize_to_multi (geometry) RETURNS geometry AS $$ 
 
WITH polygonized AS ( 
  SELECT ST_Polygonize($1) AS the_geom 
), 
dumped AS ( 
  SELECT (ST_Dump(the_geom)).geom AS the_geom FROM polygonized 
) 
SELECT ST_Multi(ST_Collect(the_geom)) FROM dumped; 
$$ LANGUAGE SQL;</strong> </pre>
<p>Now, we can polygonize directly from a set of closed lines and skip the typical intermediate step when we use the <kbd>ST_Polygonize</kbd> function of having to handle a geometry collection.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li>The <em>Translating, scaling, and rotating geometries – advanced</em> recipe</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Translating, scaling, and rotating geometries – advanced</h1>
                </header>
            
            <article>
                
<p>Often, in a spatial database, we are interested in making explicit the representation of geometries that are implicit in the data. In the example that we will use here, the explicit portion of the geometry is a single point coordinate where a field survey plot has taken place. In the following screenshot, this explicit location is the dot. The implicit geometry is the actual extent of the field survey, which includes 10 subplots arranged in a 5 x 2 array and rotated according to a bearing.</p>
<p>These subplots are the purple squares in the following diagram:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/b4f9a6f4-68fb-4557-a442-c966ba78e9b3.png" style="width:16.25em;height:17.17em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>There are a number of ways for us to approach this problem. In the interest of simplicity, we will first construct our grid and then rotate it in place. Also, we could in principle use a <kbd>ST_Buffer</kbd> function in combination with <kbd>ST_Extent</kbd> to construct the squares in our resultant geometry, but, as <kbd>ST_Extent</kbd> uses floating-point approximations of the geometry for the sake of efficiency, this could result in some mismatches at the edges of our subplots.</p>
<p>The approach we will use for the construction of the subplots is to construct the grid with a series of <kbd>ST_MakeLine</kbd> and use <kbd>ST_Node</kbd> to <em>flatten</em> or node the results. This ensures that we have all of our lines properly intersecting each other. <kbd>ST_Polygonize</kbd> will then construct our multi-polygon geometry for us. We will leverage this function through our wrapper function from the <em>Improving ST_Polygonize</em> recipe.</p>
<p>Our plots are 10 units on a side, in a 5 x 2 array. As such, we can imagine a function to which we pass our plot origin, and the function returns a multi-polygon of all the subplot geometries. One additional element to consider is that the orientation of the layout of our plots is rotated to a bearing. We expect the function to actually use two inputs, so origin and rotation will be the variables that we will pass to our function.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>We can consider geometry and a float value as the inputs, and we want the function to return geometry:</p>
<pre><strong>CREATE OR REPLACE FUNCTION chp04.create_grid (geometry, float) RETURNS geometry AS $$</strong> </pre>
<p>In order to construct the subplots, we will require three lines running parallel to the <em>X</em> axis:</p>
<pre><strong>WITH middleline AS ( 
  SELECT ST_MakeLine(ST_Translate($1, -10, 0), <br/>    ST_Translate($1, 40.0, 0)) AS the_geom 
), 
topline AS ( 
  SELECT ST_MakeLine(ST_Translate($1, -10, 10.0),<br/>    ST_Translate($1, 40.0, 10)) AS the_geom 
), 
bottomline AS ( 
  SELECT ST_MakeLine(ST_Translate($1, -10, -10.0), <br/>    ST_Translate($1, 40.0, -10)) AS the_geom 
),</strong></pre>
<p>And we will require six lines running parallel to the <em>Y</em> axis:</p>
<pre><strong>oneline AS ( 
  SELECT ST_MakeLine(ST_Translate($1, -10, 10.0), <br/>    ST_Translate($1, -10, -10)) AS the_geom 
), 
twoline AS ( 
  SELECT ST_MakeLine(ST_Translate($1, 0, 10.0),<br/>    ST_Translate($1, 0, -10)) AS the_geom 
), 
threeline AS ( 
  SELECT ST_MakeLine(ST_Translate($1, 10, 10.0),<br/>    ST_Translate($1, 10, -10)) AS the_geom 
), 
fourline AS ( 
  SELECT ST_MakeLine(ST_Translate($1, 20, 10.0),<br/>    ST_Translate($1, 20, -10)) AS the_geom 
), 
fiveline AS ( 
  SELECT ST_MakeLine(ST_Translate($1, 30, 10.0),<br/>    ST_Translate($1, 30, -10)) AS the_geom 
), 
sixline AS ( 
  SELECT ST_MakeLine(ST_Translate($1, 40, 10.0), <br/>    ST_Translate($1, 40, -10)) AS the_geom 
),</strong> </pre>
<p>To use these for polygon construction, we will require them to have nodes where they cross and touch. A <kbd>UNION ALL</kbd> function will combine these lines in a single record; <kbd>ST_Union</kbd> will provide the geometric processing necessary to construct the nodes of interest and will combine our lines into a single entity ready for <kbd>chp04.polygonize_to_multi</kbd>:</p>
<pre><strong>combined AS ( 
  SELECT ST_Union(the_geom) AS the_geom FROM 
  ( 
    SELECT the_geom FROM middleline 
      UNION ALL 
    SELECT the_geom FROM topline 
      UNION ALL 
    SELECT the_geom FROM bottomline 
      UNION ALL 
    SELECT the_geom FROM oneline 
      UNION ALL 
    SELECT the_geom FROM twoline 
      UNION ALL 
    SELECT the_geom FROM threeline 
      UNION ALL 
    SELECT the_geom FROM fourline 
      UNION ALL 
    SELECT the_geom FROM fiveline 
      UNION ALL 
    SELECT the_geom FROM sixline 
  ) AS alllines 
)</strong> </pre>
<p>But we have not created polygons yet, just lines. The final step, using our <kbd>polygonize_to_multi</kbd> function, finishes the work for us:</p>
<pre><strong>SELECT chp04.polygonize_to_multi(ST_Rotate(the_geom, $2, $1)) AS the_geom FROM combined</strong><strong>;</strong> </pre>
<p>The combined query is as follows:</p>
<pre><strong>CREATE OR REPLACE FUNCTION chp04.create_grid (geometry, float) RETURNS geometry AS $$ 
 
WITH middleline AS ( 
  SELECT ST_MakeLine(ST_Translate($1, -10, 0),<br/>    ST_Translate($1, 40.0, 0)) AS the_geom 
), 
topline AS ( 
  SELECT ST_MakeLine(ST_Translate($1, -10, 10.0),<br/>    ST_Translate($1, 40.0, 10)) AS the_geom 
), 
bottomline AS ( 
  SELECT ST_MakeLine(ST_Translate($1, -10, -10.0), <br/>    ST_Translate($1, 40.0, -10)) AS the_geom 
), 
oneline AS ( 
  SELECT ST_MakeLine(ST_Translate($1, -10, 10.0),<br/>    ST_Translate($1, -10, -10)) AS the_geom 
), 
twoline AS ( 
  SELECT ST_MakeLine(ST_Translate($1, 0, 10.0),<br/>    ST_Translate($1, 0, -10)) AS the_geom 
), 
threeline AS ( 
  SELECT ST_MakeLine(ST_Translate($1, 10, 10.0), <br/>    ST_Translate($1, 10, -10)) AS the_geom 
), 
fourline AS ( 
  SELECT ST_MakeLine(ST_Translate($1, 20, 10.0),<br/>    ST_Translate($1, 20, -10)) AS the_geom 
), 
fiveline AS ( 
  SELECT ST_MakeLine(ST_Translate($1, 30, 10.0),<br/>    ST_Translate($1, 30, -10)) AS the_geom 
), 
sixline AS ( 
  SELECT ST_MakeLine(ST_Translate($1, 40, 10.0),<br/>    ST_Translate($1, 40, -10)) AS the_geom 
), 
combined AS ( 
  SELECT ST_Union(the_geom) AS the_geom FROM 
  ( 
    SELECT the_geom FROM middleline 
      UNION ALL 
    SELECT the_geom FROM topline 
      UNION ALL 
    SELECT the_geom FROM bottomline 
      UNION ALL 
    SELECT the_geom FROM oneline 
      UNION ALL 
    SELECT the_geom FROM twoline 
      UNION ALL 
    SELECT the_geom FROM threeline 
      UNION ALL 
    SELECT the_geom FROM fourline 
      UNION ALL 
    SELECT the_geom FROM fiveline 
      UNION ALL 
    SELECT the_geom FROM sixline 
  ) AS alllines 
) 
SELECT chp04.polygonize_to_multi(ST_Rotate(the_geom, $2, $1)) AS the_geom FROM combined; 
$$ LANGUAGE SQL;</strong> </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>This function, shown in the preceding section, essentially draws the geometry from a single input point and rotation value. It does so by using nine instances of <kbd>ST_MakeLine</kbd>. Typically, one might use <kbd>ST_MakeLine</kbd> in combination with <kbd>ST_MakePoint</kbd> to accomplish this. We bypass this need by having the function consume a point geometry as an input. We can, therefore, use <kbd>ST_Translate</kbd> to move this point geometry to the endpoints of the lines of interest in order to construct our lines with <kbd>ST_MakeLine</kbd>.</p>
<p>One final step, of course, is to test the use of our new geometry constructing function:</p>
<pre><strong>CREATE TABLE chp04.tsr_grid AS 
 
-- embed inside the function 
  SELECT chp04.create_grid(ST_SetSRID(ST_MakePoint(0,0),<br/>  3734), 0) AS the_geom 
    UNION ALL 
  SELECT chp04.create_grid(ST_SetSRID(ST_MakePoint(0,100),<br/>  3734), 0.274352 * pi()) AS the_geom 
    UNION ALL 
  SELECT chp04.create_grid(ST_SetSRID(ST_MakePoint(100,0),<br/>  3734), 0.824378 * pi()) AS the_geom 
    UNION ALL 
  SELECT chp04.create_grid(ST_SetSRID(ST_MakePoint(0,-100), 3734),<br/>  0.43587 * pi()) AS the_geom 
    UNION ALL 
  SELECT chp04.create_grid(ST_SetSRID(ST_MakePoint(-100,0), 3734),<br/>  1 * pi()) AS the_geom;</strong> </pre>
<p>The different grids generated by the previous functions are the following:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/ac3d5118-8daf-44eb-8849-6361be7f277a.png" style="width:25.00em;height:21.42em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li>The <em>Improving ST_Polygonize</em> recipe</li>
<li>The <em>Improving proximity filtering with KNN – advanced</em> recipe</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Detailed building footprints from LiDAR</h1>
                </header>
            
            <article>
                
<p>Frequently, with spatial analyses, we receive data in one form that seems quite promising but we need it in another more extensive form. LiDAR is an excellent solution for such problems; LiDAR data is laser scanned either from an airborne platform, such as a fixed-wing plane or helicopter, or from a ground unit. LiDAR devices typically return a cloud of points referencing absolute or relative positions in space. As a raw dataset, they are often not as useful as they are once they have been processed. Many LiDAR datasets are classified into land cover types, so a LiDAR dataset, in addition to having data that contains <em>x</em>, <em>y</em>, and <em>z</em> values for all the points sampled across a space, will often contain LiDAR points that are classified as ground, vegetation, tall vegetation, buildings, and so on.</p>
<p>As useful as this is, the data is intensive, that is, it has discreet points, rather than extensive, as polygon representations of such data would be. This recipe was developed as a simple method to use PostGIS to transform the intensive LiDAR samples of buildings into extensive building footprints:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/6e57df89-b74d-4a2a-a83a-b6cbc28a6b75.png" style="width:31.58em;height:23.50em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>The LiDAR dataset we will use is a 2006 collection, which was classified into ground, tall vegetation (&gt; 20 feet), buildings, and so on. One characteristic of the analysis that follows is that we assume the classification to be correct, and so we are not revisiting the quality of the classification or attempting to improve it within PostGIS.</p>
<p>A characteristic of the LiDAR dataset is that a sample point exists for relatively flat surfaces at approximately no fewer than 1 for every 5 feet. This will inform you about how we manipulate the data.</p>
<p>First, let's load our dataset using the following command:</p>
<pre><strong>shp2pgsql -s 3734 -d -i -I -W LATIN1 -g the_geom lidar_buildings chp04.lidar_buildings | psql -U me -d postgis_cookbook</strong>  </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>The simplest way to convert point data to polygon data would be to buffer the points by their known separation:</p>
<pre><strong>ST_Buffer(the_geom, 5)</strong> </pre>
<p>We can imagine, however, that such a simplistic approach might look strange:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/3cce7f71-f083-4a35-9990-3a393b100a05.png" style="width:39.83em;height:23.58em;"/></div>
<p>As such, it would be good to perform a union of these geometries in order to dissolve the internal boundaries:</p>
<pre><strong>ST_Union(ST_Buffer(the_geom, 5)) </strong></pre>
<p>Now, we can see the start of some simple building footprints:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/312afb52-48b9-4d06-8316-e3218c7dea96.png" style="width:44.67em;height:25.92em;"/></div>
<p>While this is marginally better, the result is quite lumpy. We will use the <kbd>ST_Simplify_PreserveTopology</kbd> function to simplify the polygons and then grab just the external ring to remove the internal holes:</p>
<pre><strong>CREATE TABLE chp04.lidar_buildings_buffer AS 
 
WITH lidar_query AS 
(SELECT ST_ExteriorRing(ST_SimplifyPreserveTopology(<br/>  (ST_Dump(ST_Union(ST_Buffer(the_geom, 5)))).geom, 10<br/>)) AS the_geom FROM chp04.lidar_buildings) 
 
SELECT chp04.polygonize_to_multi(the_geom) AS the_geom from lidar_query; </strong></pre>
<p>Now, we have simplified versions of our buffered geometries:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/e1acae8e-9162-4d4b-9563-ef7281bac776.png" style="width:27.33em;height:17.58em;"/></div>
<p>There are two things to note here. The larger the building, relative to the density of the sampling, the better it looks. We might query to eliminate smaller buildings, which are likely to degenerate when this approach is used, depending on the density of our LiDAR data.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>To put it informally, our buffering technique effectively lumps together or clusters adjacent samples. This is possible only because we have regularly sampled data, but that is OK. The density and scan patterns for the LiDAR data are typical of such datasets, so we can expect this approach to be applicable to other datasets.</p>
<p>The <kbd>ST_Union</kbd> function converts these discreet buffered points into a single record with dissolved internal boundaries. To complete the clustering, we simply need to use <kbd>ST_Dump</kbd> to convert these boundaries back to discreet polygons so that we can utilize individual building footprints. Finally, we simplify the pattern with <kbd>ST_SimplifyPreserveTopology</kbd> and extract the external ring, or use <kbd>ST_ExteriorRing</kbd> outside these polygons, which removes the holes inside the building footprints. Since <kbd>ST_ExteriorRing</kbd> returns a line, we have to reconstruct our polygon. We use <kbd>chp04.polygonize_to_multi</kbd>, a function we wrote in the <em>Improving ST_Polygonize</em> recipe, to handle just such occasions. In addition, you can check the <em>Normalizing internal overlays</em> recipe in <a href="dec6904b-477f-4c16-a90f-7563a36c4652.xhtml">Chapter 2</a>, <em>Structures That Work</em>, in order to learn how to correct polygons with possible geographical errors.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a fixed number of clusters from a set of points</h1>
                </header>
            
            <article>
                
<p>In PostGIS version 2.3, some cluster functionalities were introduced. In this recipe, we will explore <kbd>ST_ClusterKMeans</kbd>, a function that aggregates geometries into <em>k</em> clusters and retrieves the <em>id</em> of the assigned cluster for each geometry in the input. The general syntax for the function is as follows:</p>
<pre><strong>ST_ClusterKMeans(geometry winset geom, integer number_of_clusters);</strong> </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>In this recipe, we will use the earthquake dataset included in the source from <a href="68d3e400-24be-4757-ab79-5b395dd79f3c.xhtml"><span class="ChapterrefPACKT">Chapter 3</span></a>, <em>Working with Vector Data – The Basics</em>, as our input geometries for the function. We also need to define the number of clusters that the function will output; the value of <em>k</em> for this example will be 10. You could play with this value and see the different cluster arrangements the function outputs; the greater the value for <em>k</em>, the smaller the number of geometries each cluster will contain.</p>
<p>If you have not previously imported the earthquake data into the <a href="68d3e400-24be-4757-ab79-5b395dd79f3c.xhtml"><span class="ChapterrefPACKT">Chapter 3</span></a>, <em>Working with Vector Data – The Basics</em>, schema, refer to the <em>Getting ready</em> section of the <em>GIS analysis with spatial joins</em> recipe.</p>
<p class="mce-root">Once we have created the <kbd>chp03.earthquake</kbd> table, we will need two tables. The first one will contain the centroid geometries of the clusters and their respective IDs, which the <kbd>ST_ClusterKMeans</kbd> function retrieves. The second table will have the geometries for the minimum bounding circle for each cluster. To do so, run the following SQL commands:</p>
<pre><strong>CREATE TABLE chp04.earthq_cent ( 
  cid integer PRIMARY KEY, the_geom geometry('POINT',4326) 
); 
 
CREATE TABLE chp04.earthq_circ ( 
  cid integer PRIMARY KEY, the_geom geometry('POLYGON',4326) 
);</strong> </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>We will then populate the centroid table by generating the cluster ID for each geometry in <kbd>chp03.earthquakes</kbd> using the <kbd>ST_ClusterKMeans</kbd> function, and then we will use the <kbd>ST_Centroid</kbd> function to calculate the 10 centroids for each cluster:</p>
<pre><strong>INSERT INTO chp04.earthq_cent (the_geom, cid) ( 
  SELECT DISTINCT ST_SetSRID(ST_Centroid(tab2.ge2), 4326) as centroid,<br/>  tab2.cid FROM( 
    SELECT ST_UNION(tab.ge) OVER (partition by tab.cid ORDER BY tab.cid) <br/>    as ge2, tab.cid as cid FROM( 
      SELECT ST_ClusterKMeans(e.the_geom, 10) OVER() AS cid, e.the_geom <br/>      as ge FROM chp03.earthquakes as e) as tab 
  )as tab2 
);</strong> </pre>
<p>If we check the inserted rows with the following command:</p>
<pre><strong>SELECT * FROM chp04.earthq_cent;</strong> </pre>
<p>The output will be as follows:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/44c789c0-15a0-49db-8617-fb7727593e18.png" style="width:19.75em;height:18.17em;"/></div>
<p>Then, insert the corresponding minimum bounding circles for the clusters in the <kbd>chp04.earthq_circ</kbd> table. Execute the following SQL command:</p>
<pre><strong># INSERT INTO chp04.earthq_circ (the_geom, cid) ( 
  SELECT DISTINCT ST_SetSRID( 
    ST_MinimumBoundingCircle(tab2.ge2), 4326) as circle, tab2.cid <br/>    FROM( 
      SELECT ST_UNION(tab.ge) OVER (partition by tab.cid ORDER BY tab.cid) <br/>      as ge2, tab.cid as cid <br/>      FROM( 
        SELECT ST_ClusterKMeans(e.the_geom, 10) OVER() as cid, e.the_geom <br/>        as ge FROM chp03.earthquakes AS e 
      ) as tab 
    )as tab2 
  );</strong> </pre>
<p>In a desktop GIS, import all three tables as layers (<kbd>chp03.earthquakes</kbd>, <kbd>chp04.earthq_cent</kbd>, and <kbd>chp04.earthq_circ</kbd>) in order to visualize them and understand the clustering. Note that circles may overlap; however, this does not mean that clusters do as well, since each point belongs to one and only one cluster, but the minimum bounding circle for a cluster may overlap with another minimum bounding circle for another cluster:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/60c745cb-ede9-418c-af5e-9f1d49a93198.png" style="width:39.83em;height:21.25em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Calculating Voronoi diagrams</h1>
                </header>
            
            <article>
                
<p>In the 2.3 version, PostGIS provides a way to create Voronoi diagrams from the vertices of a geometry; this will work only with versions of GEOS greater than or equal to 3.5.0.</p>
<p>The following is a Voronoi diagram generated from a set of address points. Note how the points from which the diagram was generated are equidistant to the lines that divide them. Packed soap bubbles viewed from above form a similar network of shapes:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/1cce9415-80d2-4771-93f1-4da9254591e3.png" style="width:24.75em;height:20.00em;"/></div>
<p>Voronoi diagrams are a space-filling approach that are useful for a variety of spatial analysis problems. We can use these to create space filling polygons around points, the edges of which are equidistant from all the surrounding points.</p>
<div class="packt_tip">More information about Voronoi diagrams can be found at the following link:<br/>
<a href="http://en.wikipedia.org/wiki/Voronoi_diagram"><span class="URLPACKT">http://en.wikipedia.org/wiki/Voronoi_diagram</span></a></div>
<p>The PostGIS function <kbd>ST_VoronoiPolygons()</kbd>, receives the following parameters: a geometry from which to build the Voronoi diagram, a tolerance, which is a float that will tell the function the distance within which vertices will be treated as equivalent for the output, and an <kbd>extent_to</kbd> geometry that will tell the extend of the diagram if this geometry is bigger than the calculated output from the input vertices. For this recipe, we will not use tolerance, which defaults to 0.0 units, <kbd>nor extend_to</kbd>, which is set to <kbd>NULL</kbd> by default.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>We will create a small arbitrary point dataset to feed into our function around which we will calculate the Voronoi diagram:</p>
<pre><strong>DROP TABLE IF EXISTS chp04.voronoi_test_points; 
CREATE TABLE chp04.voronoi_test_points 
( 
  x numeric, 
  y numeric 
) 
WITH (OIDS=FALSE); 
 
ALTER TABLE chp04.voronoi_test_points ADD COLUMN gid serial; 
ALTER TABLE chp04.voronoi_test_points ADD PRIMARY KEY (gid); 
 
INSERT INTO chp04.voronoi_test_points (x, y) 
  VALUES (random() * 5, random() * 7); 
INSERT INTO chp04.voronoi_test_points (x, y) 
  VALUES (random() * 2, random() * 8); 
INSERT INTO chp04.voronoi_test_points (x, y) 
  VALUES (random() * 10, random() * 4); 
INSERT INTO chp04.voronoi_test_points (x, y) 
  VALUES (random() * 1, random() * 15); 
INSERT INTO chp04.voronoi_test_points (x, y) 
  VALUES (random() * 4, random() * 9); 
INSERT INTO chp04.voronoi_test_points (x, y) 
  VALUES (random() * 8, random() * 3); 
INSERT INTO chp04.voronoi_test_points (x, y) 
  VALUES (random() * 5, random() * 3); 
INSERT INTO chp04.voronoi_test_points (x, y) 
  VALUES (random() * 20, random() * 0.1); 
INSERT INTO chp04.voronoi_test_points (x, y) 
  VALUES (random() * 5, random() * 7); 
 
SELECT AddGeometryColumn ('chp04','voronoi_test_points','the_geom',3734,'POINT',2); 
 
UPDATE chp04.voronoi_test_points 
  SET the_geom = ST_SetSRID(ST_MakePoint(x,y), 3734) 
  WHERE the_geom IS NULL</strong><br/><strong>;</strong> </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>With preparations in place, now we are ready to create the Voronoi diagram. First, we will create the table that will contain the <kbd>MultiPolygon</kbd>:</p>
<pre><strong>DROP TABLE IF EXISTS chp04.voronoi_diagram; 
CREATE TABLE chp04.voronoi_diagram( 
  gid serial PRIMARY KEY, 
  the_geom geometry(MultiPolygon, 3734) 
);</strong></pre>
<p>Now, to calculate the Voronoi diagram, we use <kbd>ST_Collect</kbd> in order to provide a <kbd>MultiPoint</kbd> object for the <kbd>ST_VoronoiPolygons</kbd> function. The output of this alone would be a <kbd>GeometryCollection</kbd>; however, we are interested in getting a <kbd>MultiPolygon</kbd> instead, so we need to use the <kbd>ST_CollectionExtract</kbd> function, which when given the number <kbd>3</kbd> as the second parameter, extracts all polygons from a <kbd>GeometryCollection</kbd>:</p>
<pre><strong>INSERT INTO chp04.voronoi_diagram(the_geom)( 
  SELECT ST_CollectionExtract( 
    ST_SetSRID( 
      ST_VoronoiPolygons(points.the_geom),   
    3734), 
  3) 
  FROM ( 
    SELECT 
    ST_Collect(the_geom) as the_geom 
    FROM chp04.voronoi_test_points 
  )<br/>as points);  </strong></pre>
<p>If we import the layers for <kbd>voronoi_test_points</kbd> and <kbd>voronoi_diagram</kbd> into a desktop GIS, we get the following Voronoi diagram of the randomly generated points:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/5ce90b85-864c-4b16-853d-b4be6f6f7c7b.png" style="width:17.00em;height:20.75em;"/></div>
<p>Now we can process much larger datasets. The following is a Voronoi diagram derived from the address points from the <em>Improving proximity filtering with KNN – advanced</em> recipe, with the coloration based on the azimuth to the nearest street, also calculated in that recipe:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/8925a02c-213f-409e-be59-8116de57596c.png" style="width:34.92em;height:31.00em;"/></div>


            </article>

            
        </section>
    </body></html>