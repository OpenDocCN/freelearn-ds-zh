- en: Learning Geospatial Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most challenging aspects of geospatial analysis is the data. Geospatial
    data already includes dozens of file formats and database structures and continues
    to evolve and grow to include new types of data and standards. Additionally, almost
    any file format can technically contain geospatial information and is done by
    simply adding a location.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will look at the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Getting an overview of common data formats
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examining some common traits of geospatial data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding spatial indexing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Knowing the most widely used vector data types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding raster data types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll also gain some insight into newer, more complex types, including point
    cloud data, web services, and geospatial databases.
  prefs: []
  type: TYPE_NORMAL
- en: Getting an overview of common data formats
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As a geospatial analyst, you may frequently encounter the following general
    data types:'
  prefs: []
  type: TYPE_NORMAL
- en: Spreadsheets and **comma-separated values** (**CSV files**) or **tab-separated
    values** (**TSV files**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Geotagged photos
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lightweight binary points, lines, and polygons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multi-gigabyte satellite or aerial images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Elevation data such as grids, point clouds, or integer-based images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: XML files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JSON files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Databases (both servers and file databases)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Geodatabases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each format contains its own challenges for access and processing. When you
    perform analysis on data, you usually have to do some form of preprocessing first.
    You might clip or subset a satellite image of a large area down to just your area
    of interest, or you might reduce the number of points in a collection to just
    the ones meeting certain criteria in your data model. A good example of this type
    of preprocessing is the `SimpleGIS` example that we looked at the end of [Chapter
    1](6b5bd08a-170c-4471-a3f3-d79d5b91f017.xhtml), *Learning about Geospatial Analysis
    with Python*. The state dataset included just the state of Colorado rather than
    all 50 states. The city dataset included only three sample cities demonstrating
    three levels of population, along with different relative locations.
  prefs: []
  type: TYPE_NORMAL
- en: The common geospatial operations in [Chapter 1](6b5bd08a-170c-4471-a3f3-d79d5b91f017.xhtml), *Learning
    about Geospatial Analysis with Python*, are the building blocks for this type
    of preprocessing. However, it is important to note that there has been a gradual
    shift in the field of geospatial analysis toward readily available basemaps. Until
    around 2004, geospatial data was difficult to acquire and desktop computing power
    was much less than it is today. Preprocessing data was an absolute first step
    for any geospatial project. However, in 2004, Google released Google Maps, which
    wasn't long after Google Earth. Microsoft had also been developing a technology
    acquisition called **TerraServer**, which they relaunched around this time. In
    2004, the **Open Geospatial Consortium** (**OGC**) updated the version of its
    **Web Map Service** (**WMS**), which was growing in use and popularity. This same
    year, Esri also released version 9 of its ArcGIS server system. These innovations
    were driven by Google's web map tiling model, which allowed for smooth, global,
    scrolling maps at many different resolutions, and were often called **slippy maps**.
  prefs: []
  type: TYPE_NORMAL
- en: People used map servers on the internet before Google Maps, most famously with
    the MapQuest driving directions website. However, these map servers offered only
    small amounts of data at a time and usually over limited areas. The Google tiling
    system converted global maps into tiered image tiles for both images and mapping
    data. These were served dynamically using JavaScript and the browser-based `XMLHttpRequest`
    API, more commonly known as **Asynchronous JavaScript and XML** (**AJAX**). Google's
    system scaled to millions of users using ordinary web browsers. More importantly,
    it allowed programmers to leverage JavaScript programming to create mashups so
    that they could use the Google Maps JavaScript API to add additional data to the
    maps. The mashup concept is actually a shared geospatial layers system. Users
    can combine and recombine data from different web services into a single map,
    as long as the data is web-accessible. Other commercial and open source systems
    quickly mimicked this concept.
  prefs: []
  type: TYPE_NORMAL
- en: Notable examples of distributed geospatial layers are **OpenLayers**, which
    provide an open source, Google-like API that has now gone beyond Google's API,
    offering additional features. Complimentary to OpenLayers is **OpenStreetMap**,
    which is the open source answer to the tiled map services consumed by systems
    such as OpenLayers. OpenStreetMap has global, street-level vector data and other
    spatial features that have been collected from available government data sources
    and the contributions of thousands of editors worldwide. OpenStreetMap's data
    maintenance model is similar to the way Wikipedia, the online encyclopedia, crowd
    sources information creation and updates for articles. Recently, even more mapping
    APIs have appeared, including Leaflet and Mapbox, which continue to increase in
    flexibility, simplicity, and capability.
  prefs: []
  type: TYPE_NORMAL
- en: The mashup revolution had interesting and beneficial side effects on data. Geospatial
    data is traditionally difficult to obtain. The cost of collecting, processing,
    and distributing data kept geospatial analysis constrained to those who could
    afford this steep overhead cost by producing data or purchasing it. For decades,
    geospatial analysis was the tool of governments, very large organizations, and
    universities. Once the web mapping trend shifted to large-scale, globally tiled
    maps, organizations began essentially providing basemap layers for free in order
    to draw developers to their platform. The massively scalable global map system
    required massively scalable, high-resolution data to be useful. Geospatial software
    producers and data providers wanted to maintain their market share and kept up
    with the technology trend.
  prefs: []
  type: TYPE_NORMAL
- en: Geospatial analysts benefited greatly from this market shift in several ways.
    First of all, data providers began distributing data in a common projection called
    **Mercator**. The Mercator projection is a nautical navigation projection that
    was introduced over 400 years ago. As we mentioned in [Chapter 1](6b5bd08a-170c-4471-a3f3-d79d5b91f017.xhtml),
    *Learning about Geospatial Analysis with Python*, all projections have practical
    benefits, as well as distortions. The distortion in the Mercator projection is
    its size. In a global view, Greenland appears bigger than the continent of South
    America. However, like every projection, it also has some benefits. Mercator preserves
    angles. Predictable angles allowed medieval navigators to draw straight bearing
    lines when plotting a course across oceans. Google Maps didn't launch with Mercator.
    However, it quickly became clear that roads in high and low latitudes met at odd
    angles on the map instead of the 90 degrees in reality.
  prefs: []
  type: TYPE_NORMAL
- en: Since the primary purpose of Google Maps was street-level driving directions,
    Google sacrificed the global view accuracy for far better relative accuracy among
    streets when viewing a single city. Competing mapping systems followed suit. Google
    also standardized on the WGS 84 datum. This datum defines a specific spherical
    model of the Earth, called a **geoid**. This model defines the normal sea level.
    What's significant about this choice by Google is that the **Global Positioning
    System** (**GPS**) also uses this datum. Therefore, most GPS units default to
    this datum as well, making Google Maps easily compatible with raw GIS data.
  prefs: []
  type: TYPE_NORMAL
- en: The Google variation of the Mercator projection is often called **Google Mercator**.
    The **European Petroleum Survey Group** (**EPSG**) assigns short numeric codes
    to projections as an easy way to reference them. Rather than waiting for the EPSG
    to approve or assign a code that was first only relevant to Google, they began
    calling the projection EPSG:900913, which is *Google* spelled with numbers. Later,
    EPSG assigned the code EPSG:3857, deprecating the older code. Most GIS systems
    recognize the two codes as synonymous. It should be noted that Google tweaked
    the standard Mercator projection slightly for its use; however, this variation
    is almost imperceptible. Google uses spherical formulas at all map scales, while
    the standard Mercator assumes an ellipsoidal form at large scales.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following image of the Mercator projection ([https://en.wikipedia.org/wiki/File:Tissot_mercator.png](https://en.wikipedia.org/wiki/File:Tissot_mercator.png))
    was taken from Wikipedia:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/aa3f6516-3f64-4141-bf6c-3a82af6b95a6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It shows the distortion caused by the Mercator projection using Tissot''s indicatrix,
    which projects small ellipses of equal size on a map. The distortion of the ellipse
    clearly shows how the projection affects the size and distance: web mapping services
    have reduced the chore of hunting for data and much of the preprocessing for analysts
    to create basemaps. However, to create anything of value, you must understand
    geospatial data and how to work with it. This chapter provides an overview of
    the common data types and issues that you will encounter in geospatial analysis.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Throughout this chapter, two terms will be commonly used:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Vector data:** Vector data includes any format that minimally represents
    geolocation data using points, lines, or polygons.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Raster data:** Raster data includes any format that stores data in a grid
    of rows and columns. Raster data includes all image formats.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are the two primary categories under which most geospatial datasets can
    be grouped.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to see a projection that shows the relative size of continents
    more accurately, refer to the Goode homolosine projection: [https://en.wikipedia.org/wiki/Goode_homolosine_projection](https://en.wikipedia.org/wiki/Goode_homolosine_projection).'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding data structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Despite having dozens of formats, geospatial data has some common traits. Understanding
    these traits can help you approach and understand unfamiliar data formats by identifying
    the ingredients common to nearly all spatial data. The structure of a given data
    format is usually driven by its intended use.
  prefs: []
  type: TYPE_NORMAL
- en: Some data is optimized for efficient storage or compression, some is optimized
    for efficient access, some is designed to be lightweight and readable (web formats),
    while other data formats seek to contain as many different data types as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Interestingly, some of the most popular formats today are also some of the simplest
    and even lack features found in more capable and sophisticated formats. Ease of
    use is extremely important to geospatial analysts because so much time is spent
    integrating data into geographic information systems, as well as exchanging data
    among analysts. Simple data formats facilitate these activities the best.
  prefs: []
  type: TYPE_NORMAL
- en: Common traits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Geospatial analysis is an approach in which you apply information processing
    techniques to data with a geographic context. This definition contains the most
    important elements of geospatial data:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Geolocation data**: Geolocation information can be as simple as a single
    point on the Earth referencing where a photo was taken. It can also be as complex
    as a satellite camera engineering model and orbital mechanics information being
    used to reconstruct the exact conditions and location under which the satellite
    captured the image.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Subject information**: Subject information can also cover a wide range of
    possibilities. Sometimes, the pixels in an image are the data in terms of a visual
    representation of the ground. Other times, an image may be processed using multispectral
    bands, such as infrared light, to provide information that''s not visible in the
    image. Processed images are often classified using a structured color palette
    that is linked to a key, describing the information each color represents. Other
    possibilities include some form of database with rows and columns of information
    for each geolocated feature, such as the population associated with each city
    in our `SimpleGIS` from [Chapter 1](6b5bd08a-170c-4471-a3f3-d79d5b91f017.xhtml),
    *Learning about Geospatial Analysis with Python*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These two factors are present in every format that can be considered geospatial
    data. Another common feature of geospatial data is spatial indexing. Overview
    datasets are also related to indexing.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding spatial indexing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Geospatial datasets are often very large files, easily reaching hundreds of
    megabytes or even several gigabytes in size. Geospatial software can be quite
    slow in trying to repeatedly access large files when performing analysis.
  prefs: []
  type: TYPE_NORMAL
- en: As discussed briefly in [Chapter 1](6b5bd08a-170c-4471-a3f3-d79d5b91f017.xhtml),
    *Learning about Geospatial Analysis with Python*, spatial indexing creates a guide,
    which allows the software to quickly locate query results without examining every
    single feature in the dataset. Spatial indexes allow the software to eliminate
    possibilities and perform more detailed searches or comparisons on a much smaller
    subset of the data.
  prefs: []
  type: TYPE_NORMAL
- en: Spatial indexing algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many spatial indexing algorithms are derivatives of well-established algorithms
    that have been used on non-spatial information for decades. The two most common
    spatial indexing algorithms are **Quadtree index** and **R-tree index**.
  prefs: []
  type: TYPE_NORMAL
- en: Quadtree index
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Quadtree algorithm actually represents a series of different algorithms
    based on a common theme. Each node in a Quadtree index contains four children.
    These child nodes are typically square or rectangular in shape. When a node contains
    a specified number of features and more features are added, the node splits.
  prefs: []
  type: TYPE_NORMAL
- en: The concept of dividing a space into nested squares speeds up spatial searches.
    The software must only handle five points at a time and use simple greater-than/less-than
    comparisons to check whether a point is inside a node. Quadtree indexes are most
    commonly found in file-based index formats.
  prefs: []
  type: TYPE_NORMAL
- en: The following diagram shows a point dataset sorted by a Quadtree algorithm.
    The black points are the actual dataset, while the boxes are the bounding boxes
    of the index. Note that none of the bounding boxes overlap. The diagram on the
    left shows the spatial representation of the index, while the diagram on the right
    shows the hierarchical relationship of a typical index, which is how spatial software
    sees the index and data.
  prefs: []
  type: TYPE_NORMAL
- en: 'This structure allows a spatial search algorithm to quickly eliminate possibilities
    when trying to locate one or more points in relation to some other set of features,
    as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/398e27ef-ba22-41b8-b31f-070bf520ed09.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that we understand quadtree indexes, let's look at another common type of
    spatial indexes called R-trees.
  prefs: []
  type: TYPE_NORMAL
- en: R-tree index
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**R-tree** indexes are more sophisticated than Quadtrees. R-trees are designed
    to handle 3D data and are optimized to store the index in a way that is compatible
    with the way databases use disk space and memory. Nearby objects are grouped together
    using an algorithm from a variety of spatial algorithms. All objects in a group
    are bounded by a minimum rectangle. These rectangles are aggregated into hierarchical
    nodes that are balanced at each level.'
  prefs: []
  type: TYPE_NORMAL
- en: Unlike a Quadtree, the bounding boxes of an R-tree may overlap across nodes.
    Due to their relative complexity and database-oriented structure, R-trees are
    most commonly found in spatial databases, as opposed to file-based formats.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram from [https://en.wikipedia.org/wiki/File:R-tree.svg](https://en.wikipedia.org/wiki/File:R-tree.svg)
    shows a balanced R-tree for a 2D point dataset:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0dbb8666-cc09-4f9f-99d4-7dd14fa27ae2.png)'
  prefs: []
  type: TYPE_IMG
- en: Indexes break up large datasets, but to speed up searching, they may employ
    a technique called **grids**. We'll look at that next.
  prefs: []
  type: TYPE_NORMAL
- en: Grids
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spatial indexes also often employ the concept of an integer grid. Geospatial
    coordinates are usually floating-point decimal numbers with anywhere from 2 to
    16 decimal places. Performing comparisons on floating-point numbers is far more
    computationally expensive than working with integers. Indexed searching is about
    eliminating possibilities that don't require precision first.
  prefs: []
  type: TYPE_NORMAL
- en: Most spatial indexing algorithms, therefore, map floating-point coordinates
    to a fixed-sized integer grid. On searching for a particular feature, the software
    can use more efficient integer comparisons rather than working with floating-point
    numbers. Once the results are narrowed down, the software can access the full
    resolution data.
  prefs: []
  type: TYPE_NORMAL
- en: Grid sizes can be as small as 256 x 256 for simple file formats, or can be as
    large as 3 million x 3 million in large geospatial databases designed to incorporate
    every known coordinate system and possible resolution.
  prefs: []
  type: TYPE_NORMAL
- en: The integer mapping technique is very similar to the rendering technique that
    is used to plot data on a graphics canvas in mapping programs. The `SimpleGIS`
    script in [Chapter 1](6b5bd08a-170c-4471-a3f3-d79d5b91f017.xhtml), *Learning about
    Geospatial Analysis with Python*, also uses this technique to render points and
    polygons using the built-in Python turtle graphics engine.
  prefs: []
  type: TYPE_NORMAL
- en: What are overviews?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview data is most commonly found in raster formats. Overviews are resampled
    and lower-resolution versions of raster datasets that provide thumbnail views
    or simply faster-loading image views at different map scales. They are also known
    as **pyramids**, and the process of creating them is known as **pyramiding an
    image**. These overviews are usually preprocessed and stored with the full resolution
    data either embedded with the file or in a separate file.
  prefs: []
  type: TYPE_NORMAL
- en: The compromise of this convenience is that the additional images add to the
    overall file size of the dataset; however, they speed up image viewers. Vector
    data also has a concept of overviews, usually to give a dataset geographic context
    in an overview map. However, because vector data is scalable, reduced size overviews
    are usually created on the fly by software using a generalization operation, as
    mentioned in [Chapter 1](6b5bd08a-170c-4471-a3f3-d79d5b91f017.xhtml), *Learning
    about Geospatial Analysis with Python*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Occasionally, vector data is rasterized by converting it into a thumbnail image,
    which is stored with, or embedded in, the image header. The following diagram
    demonstrates the concept of image overviews that shows visually why they are often
    called pyramids:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2c449dc3-a96e-499f-b133-afafb9a0737c.png)'
  prefs: []
  type: TYPE_IMG
- en: Spatial indexing and overviews help speed up access to data by software for
    analysts. Next, we'll look at metadata, which provides both a human-and machine-readable
    way to understand, search, and even catalog data.
  prefs: []
  type: TYPE_NORMAL
- en: What is metadata?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As discussed in [Chapter 1](6b5bd08a-170c-4471-a3f3-d79d5b91f017.xhtml), *Learning
    about Geospatial Analysis with Python*, metadata is any data that describes the
    associated dataset. Common examples of metadata include basic elements such as
    the footprint of the dataset on the Earth, as well as more detailed information
    such as spatial projection and information describing how the dataset was created.
  prefs: []
  type: TYPE_NORMAL
- en: Most data formats contain the footprint or bounding box of the data on the Earth.
    Detailed metadata is typically stored in a separate location in a standard format,
    such as the US **Federal Geographic Data Committee** (**FGDC**), **Content Standard
    for Digital Geospatial Metadata** (**CSDGM**), ISO, or the newer European Union
    initiative, which includes metadata requirements, and is called the **Infrastructure
    for Spatial Information in the European Community** (**INSPIRE**).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the file structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The preceding elements can be stored in a variety of ways in a single file,
    multiple files, or databases, depending on the format. Additionally, this geospatial
    information can be stored in a variety of formats, including embedded binary headers,
    XML, database tables, spreadsheets/CSV, separate text, or binary files.
  prefs: []
  type: TYPE_NORMAL
- en: Human-readable formats such as XML files, spreadsheets, and structured text
    files require only a text editor to be investigated. These files are also easily
    parsed and processed using Python's built-in modules, data types, and string manipulation
    functions. Binary-based formats are more complicated. Therefore, it is typically
    easier to use a third-party library to deal with binary formats.
  prefs: []
  type: TYPE_NORMAL
- en: However, you don't have to use a third-party library, especially if you just
    want to investigate the data at a high level. Python's built-in `struct` module
    has everything that you need. The `struct` module lets you read and write binary
    data as strings. When using the `struct` module, you need to be aware of the concept
    of byte order. Byte order refers to how the bytes of information that make up
    a file are stored in memory. This order is usually platform-specific, but in some
    rare cases, including shapefiles, the byte order is mixed into the file.
  prefs: []
  type: TYPE_NORMAL
- en: The Python `struct` module uses the greater than (`>`) and less than (`<`) symbols
    to specify byte order (big-endian and little-endian, respectively).
  prefs: []
  type: TYPE_NORMAL
- en: The following brief example demonstrates the usage of the Python `struct` module
    to parse the bounding box coordinates from an Esri shapefile vector dataset. You
    can download this shapefile as a zipped file from the following URL: [https://github.com/GeospatialPython/Learn/blob/master/hancock.zip?raw=true](https://github.com/GeospatialPython/Learn/blob/master/hancock.zip?raw=true).
    [](https://geospatialpython.googlecode.com/files/hancock.zip)
  prefs: []
  type: TYPE_NORMAL
- en: 'When you unzip this, you will see three files. For this example, we''ll be
    using `hancock.shp`. The Esri shapefile format has a fixed location and data type
    in the file header from byte 36 to byte 37 for the minimum *x*, minimum *y*, maximum
    *x*, and maximum *y* bounding box values. In this example, we will execute the
    following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Import the `struct` module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `hancock.zip` shapefile in the binary read mode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to byte `36`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Read each 8-byte double variables specified as `d`, and unpack it using the
    `struct` module in little-endian order, as designated by the `<` sign.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The best way to execute this script is in the interactive Python interpreter.
    We will then read the minimum longitude, minimum latitude, maximum longitude,
    and maximum latitude:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll notice that, when the `struct` module unpacks a value, it returns a
    Python tuple with one value. You can shorten the preceding unpacking code to one
    line by specifying all four doubles at once and increasing the byte length to
    32 bytes, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now that we understand how to describe data, let's learn about one of the most
    common types of geospatial data—vector data.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing the most widely used vector data types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Vector data is, by far, the most common geospatial format because it is the
    most efficient way to store spatial information. In general, it requires fewer
    computer resources to store and process than raster data. The OGC has over 16
    formats directly related to vector data. Vector data stores only geometric primitives,
    including points, lines, and polygons. However, only the points are stored for
    each type of shape. For example, in the case of a simple straight vector line
    shape, only the endpoints would be necessarily stored and defined as a line. Software
    displaying this data would read the shape type and then connect the endpoints
    with a line dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: Geospatial vector data is similar to the concept of vector computer graphics,
    with some notable exceptions. Geospatial vector data contains positive and negative
    Earth-based coordinates, while vector graphics typically store computer screen
    coordinates. Geospatial vector data is also usually linked to other information
    about the object that's represented by the geometry. This information may be as
    simple as a timestamp in the case of GPS data or an entire database table for
    larger geographic information systems.
  prefs: []
  type: TYPE_NORMAL
- en: Vector graphics often store styling information describing colors, shadows,
    and other display-related instructions, while geospatial vector data typically
    does not. Another important difference is the shapes. Geospatial vectors typically
    only include very primitive geometries based on points, straight lines, and straight-line
    polygons, while many computer graphic vector formats have concepts of curves and
    circles. However, geospatial vectors can model these shapes using more points.
  prefs: []
  type: TYPE_NORMAL
- en: Other human-readable formats, such as CSV, simple text strings, GeoJSON, and
    XML-based formats, are technically vector data because they store geometry as
    opposed to rasters, which represent all the data within the bounding box of the
    dataset. Until the explosion of XML in the late 1990s, vector data formats were
    nearly all binary. XML provided a hybrid approach that was both computer and human-readable.
    The compromise is that text formats such as GeoJSON and XML data greatly increase
    the file size compared to binary formats. These formats will be discussed later
    in this section.
  prefs: []
  type: TYPE_NORMAL
- en: The number of vector formats to choose from is staggering. The open source vector
    library, OGR ([http://www.gdal.org/ogr_formats.html](http://www.gdal.org/ogr_formats.html)),
    lists over 86 supported vector formats. Its commercial counterpart, Safe Software's
    **Feature Manipulation Engine** (**FME**), lists over 188 supported vector formats
    ([http://www.safe.com/fme/format-search/#filters%5B%5D=VECTOR](http://www.safe.com/fme/format-search/#filters%5B%5D=VECTOR)).
    These lists include a few vector graphics formats, as well as human-readable geospatial
    formats. There are still dozens of formats out there to at least be aware of,
    in case you come across them.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's look at a specific, and widely used type of vector data called shapefiles.
  prefs: []
  type: TYPE_NORMAL
- en: Shapefiles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most ubiquitous geospatial format is the Esri shapefile. The geospatial
    software company known as Esri released the shapefile format specification as
    an open format in 1998 ([http://www.esri.com/library/whitepapers/pdfs/shapefile.pdf](http://www.esri.com/library/whitepapers/pdfs/shapefile.pdf)).
    Esri developed it as a format for their ArcView software, designed as a lower-end
    GIS option to complement their high-end professional package, **ArcInfo**, formerly
    called **ARC/INFO**. However, the open specification, efficiency, and simplicity
    of the format turned it into an unofficial GIS standard that is still extremely
    popular over 15 years later.
  prefs: []
  type: TYPE_NORMAL
- en: Virtually, every piece of the software labeled as geospatial software supports
    shapefiles because the shapefile format is so common. For this reason, you can
    almost get by as an analyst by being intimately familiar with shapefiles and mostly
    ignoring other formats. You can convert almost any other format into a shapefile
    through the source format's native software or a third-party converter, such as
    the OGR library, for which there is a Python module. Other Python modules that
    handle shapefiles are Shapely and Fiona, which are based on OGR.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the most striking features of a shapefile is that the format consists
    of multiple files (from minimum to maximum, there can be 3-15 different files).
    The following table describes the file formats. The `.shp`, `.shx`, and `.dbf`
    files are required for a valid shapefile:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Shapefile supporting file extension** | **Supporting file purpose** | **Notes**
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `.shp` | This is the shapefile. It contains the geometry. | It is a required
    file. Some software that needs only geometry will accept the `.shp` files without
    the `.shx` or `.dbf` file. |'
  prefs: []
  type: TYPE_TB
- en: '| `.shx` | This is the shape index file. It is a fixed-sized record index referencing
    geometry for faster access. | It is a required file. This file is meaningless
    without the `.shp` file. |'
  prefs: []
  type: TYPE_TB
- en: '| `.dbf` | This is the database file. It contains the geometry attributes.
    | It is a required file. Some software will access this format without the `.shp`
    file present as the specification predates shapefiles. It''s based on the very
    old FoxPro and dBase formats. An open specification exists for it called Xbase.
    The `.dbf` files can be opened by most types of spreadsheet software. |'
  prefs: []
  type: TYPE_TB
- en: '| `.sbn` | This is the spatial bin file, that is, the shapefile spatial index.
    | It contains bounding boxes of features mapped to a 256 x 256 integer grid. It
    is very common for this file to accompany large shapefile datasets. |'
  prefs: []
  type: TYPE_TB
- en: '| `.sbx` | A fixed-sized record index for the `.sbn` file. | A traditional
    ordered record index of a spatial index. Frequently seen. |'
  prefs: []
  type: TYPE_TB
- en: '| `.prj` | This contains map projection information that''s stored in a well-known
    text format. | A very common and required file for on-the-fly projection by the
    GIS software. This same format can also accompany raster data. |'
  prefs: []
  type: TYPE_TB
- en: '| `.fbn` | A spatial index of read-only features. | Very rarely seen. |'
  prefs: []
  type: TYPE_TB
- en: '| `.fbx` | A fixed-sized record index of the `.fbn` spatial index. | Very rarely
    seen. |'
  prefs: []
  type: TYPE_TB
- en: '| `.ixs` | A geocoding index. | Common in geocoding applications, including
    driving-direction type applications. |'
  prefs: []
  type: TYPE_TB
- en: '| `.mxs` | Another type of geocoding index. | Less common than the `.ixs` format.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `.ain` | Attribute index. | Mostly legacy format, and rarely used in modern
    software. |'
  prefs: []
  type: TYPE_TB
- en: '| `.aih` | Attribute index. | Accompanies the `.ain` files. |'
  prefs: []
  type: TYPE_TB
- en: '| `.qix` | Quadtree index. | A spatial index format created by the open source
    community because the Esri `.sbn` and `.sbx` files were undocumented until recently.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `.atx` | Attribute index. | A more recent Esri software-specific attribute
    index to speed up attribute queries. |'
  prefs: []
  type: TYPE_TB
- en: '| `.shp.xml` | Metadata. | A geospatial metadata `.xml` container. It can be
    any of the multiple XML standards, including FGDC and ISO. |'
  prefs: []
  type: TYPE_TB
- en: '| `.cpg` | Code page file for `.dbf`. | It is used for the internationalization
    of `.dbf` files. |'
  prefs: []
  type: TYPE_TB
- en: You will probably never encounter all of these formats at once. However, any
    shapefile that you use will have multiple files. You will commonly see `.shp`,
    `.shx`, `.dbf`, `.prj`, `.sbn`, `.sbx`, and occasionally, `.shp.xml` files. If
    you want to rename a shapefile, you must rename all of the associated files with
    the same name; however, in Esri software and other GIS packages, these datasets
    will appear as a single file.
  prefs: []
  type: TYPE_NORMAL
- en: Another important feature of shapefiles is that the records are not numbered.
    Records include the geometry, the `.shx` index record, and the `.dbf` record.
    These records are stored in a fixed order. When you examine shapefile records
    using the software, they appear to be numbered.
  prefs: []
  type: TYPE_NORMAL
- en: People are often confused when they delete a shapefile record, save the file,
    and reopen it; the number of the record that was deleted still appears. The reason
    for this is that the shapefile records are numbered dynamically on loading, but
    not saved. So, for example, if you delete record number 23 and save the shapefile,
    record number 24 will become 23 the next time you read the shapefile. Many people
    expect to open the shapefile and see the records jump from 22 to 24\. The only
    way to track shapefile records in this way is to create a new attribute called
    ID or similar in the `.dbf` file and assign each record a permanent and unique
    identifier.
  prefs: []
  type: TYPE_NORMAL
- en: Just like renaming shapefiles, care must be taken while editing shapefiles.
    It's best to use software that treats the shapefiles as a single dataset. If you
    edit any of the files individually and add/delete a record without editing the
    accompanying files, the shapefile will be seen as corrupt by most geospatial software.
  prefs: []
  type: TYPE_NORMAL
- en: CAD files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**CAD** stands for **computer-aided design**. The primary formats for CAD data
    were created by Autodesk for their leading AutoCAD package. The two formats that
    are commonly seen are **Drawing Exchange Format** (**DXF**) and AutoCAD''s native
    **Drawing** (**DWG**) format.'
  prefs: []
  type: TYPE_NORMAL
- en: DWG was traditionally a closed format, but it has become more open.
  prefs: []
  type: TYPE_NORMAL
- en: 'The CAD software is used for everything that is engineering-related, from designing
    bicycles to cars, parks, and city sewer systems. As a geospatial analyst, you
    don''t have to worry about mechanical engineering designs; however, civil engineering
    designs become quite an issue. Most engineering firms use geospatial analysis
    to a very limited degree, but store nearly all of their data in the CAD format.
    The DWG and DXF formats can represent objects using features not found in geospatial
    software or that are weakly supported by geospatial systems. Some examples of
    these features include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Curves
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Surfaces (for objects that are different from geospatial elevation surfaces)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 3D solids
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Text (rendered as an object)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Text styling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Viewport configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These CAD and engineering-specific features make it difficult to cleanly convert
    CAD data into geospatial formats. If you encounter CAD data, the easiest option
    is to ask the data provider if they have shapefiles or some other geospatial-centric
    format.
  prefs: []
  type: TYPE_NORMAL
- en: Tag-based and markup-based formats
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tag-based markup formats are typically XML formats. They also include other
    structured text formats such as the **Well-Known Text** (**WKT**) format, which
    is used for projection information files as well as different types of data exchange.
  prefs: []
  type: TYPE_NORMAL
- en: XML formats include the **Keyhole Markup Language** (**KML**), the **OpenStreetMap**
    (**OSM**) format, and the Garmin GPX format for GPS data, which has become a popular
    exchange format. The Open Geospatial Consortium's **Geographic Markup Language**
    (**GML**) standard is one of the oldest and most widely used XML-based geographic
    formats. It is also the basis for the OGC **Web Feature Service** (**WFS**) standard
    for web applications. However, GML has been largely superseded by KML and the
    GeoJSON format.
  prefs: []
  type: TYPE_NORMAL
- en: 'XML formats often contain more than just geometry. They also contain attributes
    and rendering instructions such as color, styling, and symbology. Google''s KML
    format has become a fully supported OGC standard. The following is a sample of
    KML showing a simple placemark:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The XML format is attractive to geospatial analysts for the following reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: It is a human-readable format.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can be edited in a text editor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is well supported by programming languages (especially Python).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is, by definition, easily extensible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: XML is not perfect, though. It is an inefficient storage mechanism for very
    large data formats and can quickly become cumbersome to edit. Errors in datasets
    are common, and most parsers do not handle errors robustly. Despite the downsides,
    XML is widely used in geospatial analysis.
  prefs: []
  type: TYPE_NORMAL
- en: '**Scalable Vector Graphics** (**SVG**) is a widely supported XML format for
    computer graphics. It is supported well by browsers and is often used for geospatial
    rendering. However, SVG was not designed as a geographic format.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The WKT format is also an older OGC standard. The most common use for it is
    to define projection information usually stored in `.prj` projection files, along
    with a shapefile or raster. The WKT string for the WGS 84 coordinate system is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The parameters that define a projection can be quite long. A standards committee,
    which was created by the EPSG, introduced a numerical coding system to reference
    projections. These codes, such as EPSG:4326, are used as shorthand for strings
    such as the preceding code. There are also short names for commonly used projections
    such as Mercator, which can be used in different software packages to reference
    a projection.
  prefs: []
  type: TYPE_NORMAL
- en: More information on these reference systems can be found on the spatial reference
    website at [http://spatialreference.org/ref/](http://spatialreference.org/ref/).
  prefs: []
  type: TYPE_NORMAL
- en: GeoJSON
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GeoJSON is a relatively new and brilliant text format based on the **JavaScript
    Object Notation** (**JSON**) format, which has been a commonly used data exchange
    format for years. Despite its short history, GeoJSON can be found embedded in
    all major geospatial software systems and most websites that distribute data.
    This is because JavaScript is the language of the dynamic web, and GeoJSON can
    be directly fed into JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: GeoJSON is a completely backward-compatible extension for the popular JSON format.
    The structure of JSON is very similar and, in some cases, identical to existing
    data structures of common programming languages. JSON is almost identical to Python's
    dictionary and list data types. Due to this similarity, parsing JSON in a script
    is simple to do from scratch, but there are many libraries to make it even easier.
    Python contains a built-in library aptly named `json`.
  prefs: []
  type: TYPE_NORMAL
- en: GeoJSON provides you with a standard way to define geometry, attributes, bounding
    boxes, and projection information. GeoJSON has all of the advantages of XML, including
    human-readable syntax, excellent software support, and wide use in the industry.
    It also surpasses XML.
  prefs: []
  type: TYPE_NORMAL
- en: 'GeoJSON is far more compact than XML, largely because it uses simple symbols
    to define objects rather than opening and closing text-laden tags. This compactness
    also helps with the readability and manageability of larger datasets. However,
    it is still inferior to binary formats from a data volume standpoint. The following
    is a sample of the GeoJSON syntax, defining a geometry collection with both a
    point and line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is a valid GeoJSON, but it is also a valid Python data structure.
    You can copy the preceding code sample directly into the Python interpreter as
    a variable definition and it will evaluate without error, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Due to its compact size, internet-friendly syntax by virtue of being written
    in JavaScript, and support from major programming languages, GeoJSON is a key
    component of leading REST geospatial web APIs, which will be covered later in
    this chapter. It currently offers the best compromise among the computer resource
    efficiency of binary formats, the human-readability of text formats, and programmatic
    utility.
  prefs: []
  type: TYPE_NORMAL
- en: GeoPackage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll briefly mention the GeoPackage format here as it's covered in [Chapter
    3](a5e439d1-e7fd-46b4-8fd3-8f811bfe73e4.xhtml), *The Geospatial Technology Landscape*,
    as well as because it's a type of geodatabase. The `geopackage` format is an OGC
    open standard on a SQLite file-based database container that is a platform, vendor,
    and software independent. It's an attempt to get away from all of the issues that
    are generated from either proprietary data formats or limited data formats.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''ll look at the other major data type: raster data.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding raster data types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Raster data consists of rows and columns of cells or pixels, with each cell
    representing a single value. The easiest way to think of raster data is as images,
    which is how they are typically represented by software. However, raster datasets
    are not necessarily stored as images. They can also be ASCII text files or **Binary
    Large Objects** (**BLOBs**) in databases.
  prefs: []
  type: TYPE_NORMAL
- en: Another difference between geospatial raster data and regular digital images
    is their resolution. Digital images express resolution as dots-per-inch if printed
    in full size. Resolution can also be expressed as the total number of pixels in
    the image, and are defined as megapixels. However, geospatial raster data uses
    the ground distance that each cell represents. For example, a raster dataset with
    a two-foot resolution means that a single cell represents two feet on the ground,
    which also means that only objects larger than two feet can be identified visually
    in the dataset.
  prefs: []
  type: TYPE_NORMAL
- en: Raster datasets may contain multiple bands, meaning that different wavelengths
    of light can be collected at the same time over the same area. Often, this range
    is from 3-7 bands, but can be several hundred in hyperspectral systems. These
    bands are viewed individually or swapped in and out as the RGB bands of an image.
    They can also be recombined into a derivative single-band image using mathematics
    and then recolored using a set number of classes representing values within the
    dataset.
  prefs: []
  type: TYPE_NORMAL
- en: Another common application of raster data is in the field of scientific computing,
    which shares many elements of geospatial remote sensing but adds some interesting
    twists. Scientific computing often uses complex raster formats, including **Network
    Common Data Form** (**NetCDF**), **GRIB**, and **HDF5**, which store entire data
    models. These formats are more like directories in a filesystem and can contain
    multiple datasets or multiple versions of the same dataset. Oceanography and meteorology
    are the most common applications of this kind of analysis. An example of a scientific
    computing dataset is the output of a weather model, where the cells of the raster
    dataset in different bands may represent a different variables' output from the
    model in a time series.
  prefs: []
  type: TYPE_NORMAL
- en: Like vector data, raster data can come in a variety of formats. The open source
    `raster` library, known as **Geospatial Data Abstraction Library** (**GDAL**),
    which actually includes the vector OGR library we mentioned earlier, lists over
    130 supported raster formats ([http://www.gdal.org/formats_list.html](http://www.gdal.org/formats_list.html)).
    The FME software package supports this many as well. However, just like shapefiles
    and CAD data, there are a few standout raster formats.
  prefs: []
  type: TYPE_NORMAL
- en: TIFF files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **Tagged Image File Format** (**TIFF**) is the most common geospatial raster
    format. The TIFF format''s flexible tagging system allows it to store any type
    of data whatsoever in a single file. TIFFs can contain overview images, multiple
    bands, integer elevation data, basic metadata, internal compression, and a variety
    of other data that''s typically stored in additional supporting files by other
    formats. Anyone can extend the TIFF format unofficially by adding tagged data
    to the file structure. This extensibility has benefits and drawbacks. However,
    a TIFF file may work fine in one piece of software but fail when it''s accessed
    in another because the two software packages implement the massive TIFF specification
    to different degrees. An old joke about TIFFs has a frustrating amount of truth
    to it: **TIFF** stands for **Thousands of Incompatible File Formats**. The GeoTIFF
    extension defines how geospatial data is stored. Geospatial rasters stored as
    TIFF files may have any of the following file extensions: `.tiff`, `.tif`, or
    `.gtif`.'
  prefs: []
  type: TYPE_NORMAL
- en: JPEG, GIF, BMP, and PNG
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JPEG, GIF, BMP, and PNG formats are common image formats in general, but can
    be used for basic geospatial data storage as well. Typically, these formats rely
    on accompanying the supporting text files for the georeferencing of the information
    in order to make them compatible with the GIS software, such as WKT, `.prj`, or
    world files.
  prefs: []
  type: TYPE_NORMAL
- en: The JPEG format is also fairly common for geospatial data. JPEGs have a built-in
    metadata tagging system, similar to TIFFs, called EXIF. JPEGs are commonly used
    for geotagged photographs in addition to raster GIS layers. **Bitmap** (**BMP**)
    images are used for desktop applications and document graphics. However, JPEG,
    GIF, and PNG are the formats that are used in web mapping applications, especially
    for pregenerated server map tiles for quick access via slippy maps.
  prefs: []
  type: TYPE_NORMAL
- en: Compressed formats
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since geospatial rasters tend to be very large, they are often stored using
    advanced compression techniques. The latest open standard is the JPEG 2000 format,
    which is an upgrade of the JPEG format and includes wavelet compression and a
    few other features, such as georeferencing data. The **Multi-resolution Seamless
    Image Database** (**MrSID**) (`.sid`) and **Enhanced Compression Wavelet** (**ECW**)
    (`.ecw`) are two proprietary wavelet compression formats often seen in geospatial
    contexts.
  prefs: []
  type: TYPE_NORMAL
- en: The TIFF format supports compression, including the **Lempel-Ziv-Welch** (**LZW**)
    algorithm. It must be noted that compressed data is suitable as part of a basemap,
    but should not be used for remote sensing processing. Compressed images are designed
    to look visually correct but often alter the original cell value. Lossless compression
    algorithms try to avoid degrading the source data, but it's generally considered
    a bad idea to attempt to perform spectral analysis on data that has been through
    compression. The JPEG format is designed to be a lossy format that sacrifices
    data for a smaller file size. It is also commonly encountered, so it is important
    to remember this fact to avoid invalid results.
  prefs: []
  type: TYPE_NORMAL
- en: ASCII Grids
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another means of storing raster data, often elevation data, is in ASCII Grid
    files. This file format was created by Esri, but has become an unofficial standard
    supported by most software packages. An ASCII Grid is a simple text file containing
    (*x*, *y*) values as rows and columns. The spatial information for the raster
    is contained in a simple header. The format of the file is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'While not the most efficient way to store data, ASCII Grid files are very popular
    because they don''t require any special data libraries to create or access geospatial
    raster data. These files are often distributed as `.zip` files. The header values
    in the preceding format contain the following information:'
  prefs: []
  type: TYPE_NORMAL
- en: The number of columns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number of rows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *x*-axis cell center coordinate | *x*-axis lower-left corner coordinate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *y*-axis cell center coordinate | *y*-axis lower-left corner coordinate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The cell size in mapping units
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The no-data value (typically, 9,999)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: World files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: World files are simple text files that can provide geospatial referencing information
    to any image externally for file formats that typically have no native support
    for spatial information, including JPEG, GIF, PNG, and BMP. The world file is
    recognized by geospatial software due to its naming convention. The most common
    way to name a world file is by using the raster file name and then altering the
    extension to remove the middle letter and adding `w` at the end.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table shows some examples of raster images in different formats
    and the associated world file name based on the convention:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Raster file name | World file name |'
  prefs: []
  type: TYPE_TB
- en: '| `World.jpg` | `World.jgw` |'
  prefs: []
  type: TYPE_TB
- en: '| `World.tif` | `World.tfw` |'
  prefs: []
  type: TYPE_TB
- en: '| `World.bmp` | `World.bpw` |'
  prefs: []
  type: TYPE_TB
- en: '| `World.png` | `World.pgw` |'
  prefs: []
  type: TYPE_TB
- en: '| `World.gif` | `World.gfw` |'
  prefs: []
  type: TYPE_TB
- en: 'The structure of a world file is very simple. It is a six-line text file, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Line 1: The cell size along the *x*-axis in ground units'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Line 2: The rotation on the *y*-axis'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Line 3: The rotation on the *x*-axis'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Line 4: The cell size along the *y*-axis in ground units'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Line 5: The center *x*-coordinate of the upper-left cell'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Line 6: The center *y*-coordinate of the upper-left cell'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is an example of world file values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The (*x*, *y*) coordinates and the (*x*, *y*) cell size contained in lines 1,
    4, 5, and 6 allow you to calculate the coordinate of any cell or the distance
    across a set of cells. The rotation values are important for geospatial software
    because remotely sensed images are often rotated due to the data collection platform.
  prefs: []
  type: TYPE_NORMAL
- en: Rotating the images runs the risk of resampling the data and, therefore, data
    loss, so the rotation values allow the software to account for the distortion.
    The surrounding pixels outside the image are typically assigned a `no data` value
    and represented as the color black.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following image, courtesy of the **U.S. Geological Survey** (**USGS**)
    from [https://viewer.nationalmap.gov/advanced-viewer/](https://viewer.nationalmap.gov/advanced-viewer/),
    demonstrates image rotation, where the satellite collection path is oriented from
    southeast to northeast, but the underlying basemap is north:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5827a80b-d807-473f-b890-10df982a5080.png)'
  prefs: []
  type: TYPE_IMG
- en: World files are a great tool when working with raster data in Python. Most geospatial
    software and data libraries support world files, so they are usually a good choice
    when it comes to georeferencing.
  prefs: []
  type: TYPE_NORMAL
- en: You'll find that world files are very useful, but as you use them infrequently,
    you will forget what the unlabeled contents represent. A quick reference for world
    files is available at [https://kralidis.ca/gis/worldfile.htm](http://kralidis.ca/gis/worldfile.htm).
  prefs: []
  type: TYPE_NORMAL
- en: Vector data and raster data are the two most common data types. However, there
    is another type that is gaining popularity due to the cost of collecting it gradually
    becoming cheaper. That type is point cloud data, and we'll examine it next.
  prefs: []
  type: TYPE_NORMAL
- en: What is point cloud data?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Point cloud data is any data collected as the (*x*, *y*, *z*) location of a
    surface point based on some sort of focused energy return. This can be created
    using lasers, radar waves, acoustic soundings, or other waveform generation devices.
    The spacing between points is arbitrary and dependent on the type and position
    of the sensor collecting the data.
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we will primarily be concerned with LIDAR data and radar data.
    Radar point cloud data is typically collected on space missions, while LIDAR is
    typically collected by terrestrial or airborne vehicles. Conceptually, both types
    of data are similar.
  prefs: []
  type: TYPE_NORMAL
- en: LIDAR
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: LIDAR uses powerful laser range-finding systems to model the world with very
    high precision. The term **LIDAR**, or LiDAR, is a combination of the words *light*
    and *radar*. Some people claim it also stands for **Light Detection and Ranging**.
    LIDAR sensors can be mounted on aerial platforms, including satellites, airplanes,
    or helicopters. They can also be mounted on vehicles for ground-based collection.
  prefs: []
  type: TYPE_NORMAL
- en: Due to the high-speed, continuous data collection provided by LIDAR, and a wide
    field of view – often 360 degrees of the sensor – LIDAR data doesn't typically
    have a rectangular footprint the way other forms of raster data do. LIDAR datasets
    are usually called point clouds because the data is a stream of *(x,y,z*) locations,
    where *z* is the distance from the laser to a detected object and the (*x*,*y*)
    values are the projected location of the object calculated from the location of
    the sensor.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following image, courtesy of USGS, shows a point cloud LIDAR dataset in
    an urban area using a terrestrial sensor, as opposed to an aerial one. The colors
    are based on the strength of the laser''s energy return, with red areas being
    closer to the LIDAR sensor and green areas farther away, which can give a precise
    height to within a few centimeters:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cfdac61c-49f8-41cb-bf3d-a9733d879a9a.png)'
  prefs: []
  type: TYPE_IMG
- en: The most common data format for LIDAR data is the **LIDAR Exchange Format**
    (**LAS**), which is a community standard. LIDAR data can be represented in many
    ways, including a simple text file with one (*x*, *y*, *z*) tuple per line. Sometimes,
    LIDAR data can be colorized using image pixel colors that have been collected
    at the same time. LIDAR data can also be used to create 2D elevation rasters.
  prefs: []
  type: TYPE_NORMAL
- en: This technique is the most common use for LIDAR in geospatial analysis. Any
    other use requires specialized software that allows the user to work in 3D. In
    that case, other geospatial data cannot be combined with the point cloud.
  prefs: []
  type: TYPE_NORMAL
- en: What are web services?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Geospatial web services allow users to perform data discovery, data visualization,
    and data access across the web. Web services are usually accessed by applications
    based on user input, such as zooming in to an online map or searching a data catalog.
    The most common protocols are the **Web Map Service** (**WMS**), which returns
    a rendered map image, and **Web Feature Service** (**WFS**), which typically returns
    GML, which was mentioned in this chapter's introduction.
  prefs: []
  type: TYPE_NORMAL
- en: Many WFS services can also return KML, JSON, zipped shapefiles, and other formats.
    These services are called through HTTP `GET` requests. The following URL is an
    example of a WMS `GET` request, which returns a map image of the world that is
    640 pixels wide and 400 pixels tall and has an EPSG code of 900913: [http://ows.mundialis.de/services/service?SERVICE=wms&VERSION=1.1.1&REQUEST=GetMap&FORMAT=image/png&STYLES=&WIDTH=600&HEIGHT=400&LAYERS=TOPO-OSM-WMS&SRS=EPSG:900913&BBOX=-20037508,-20037508,20037508,20037508](http://ows.mundialis.de/services/service?SERVICE=wms&VERSION=1.1.1&REQUEST=GetMap&FORMAT=image/png&STYLES=&WIDTH=600&HEIGHT=400&LAYERS=TOPO-OSM-WMS&SRS=EPSG:900913&BBOX=-20037508,-20037508,20037508,20037508).
    [](http://osm.woc.noaa.gov/mapcache?SERVICE=wms&VERSION=1.1.1&REQUEST=GetMap&FORMAT=image/png&WIDTH=600&HEIGHT=400&LAYERS=osm&SRS=EPSG:900913&BBOX=-20037508,-20037508,20037508,20037508)
  prefs: []
  type: TYPE_NORMAL
- en: Web services are rapidly evolving. The Open GIS Consortium is adding new standards
    for sensor networks and other geospatial contexts. **REpresentational State Transfer**
    (**REST**) services are also commonly used. REST services use simple URLs to make
    requesting data very easy to implement in nearly any programming language by tailoring
    URL parameters and their values accordingly. Nearly every programming language
    has robust HTTP client libraries that are capable of using REST services.
  prefs: []
  type: TYPE_NORMAL
- en: These REST services can return many types of data, including images, XML, or
    JSON. There is no overarching geospatial REST standard yet, but the OGC has been
    working on one for quite some time. Esri has created a working implementation
    that is currently widely used.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following URL is an example of an Esri geospatial REST service that would
    return KML based on a weather radar image layer. You can add this URL to Google
    Earth as a network link, or you can download it as compressed KML (KMZ) in a browser
    to import it into another program: [https://idpgis.ncep.noaa.gov/arcgis/rest/services/NWS_Observations/radar_base_reflectivity/MapServer/generateKml?docName=NWSRadar&layers=0&layerOptions=separateImage](https://idpgis.ncep.noaa.gov/arcgis/rest/services/NWS_Observations/radar_base_reflectivity/MapServer/generateKml?docName=NWSRadar&layers=0&layerOptions=separateImage).'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find tutorials on the myriad of OGC services here: [http://cite.opengeospatial.org/pub/cite/files/edu/fundamental-concepts/text/basic.html](http://cite.opengeospatial.org/pub/cite/files/edu/fundamental-concepts/text/basic.html).'
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing this book, the OGC is going through an API evolution
    that will significantly lower the barrier of using geospatial APIs through technologies
    such as REST, OpenAPI, JSON/HTML, and Swagger. You can track these trends through
    OGC's technology roadmap here: [https://github.com/opengeospatial/OGC-Technology-Trends](https://github.com/opengeospatial/OGC-Technology-Trends).
  prefs: []
  type: TYPE_NORMAL
- en: Now, we'll move from individual file formats to powerful geodatabases that can
    consolidate data through a single API.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding geospatial databases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A geospatial database, or geodatabase, refers to an entire category of file
    formats, data schemas, and even software. In [Chapter 3](a5e439d1-e7fd-46b4-8fd3-8f811bfe73e4.xhtml), *The
    Geospatial Technology Landscape*, we'll cover geodatabases as software packages,
    formally known as database management systems. But in this section, we'll describe
    their attributes as file formats. Geodatabases historically stored only vector
    data, though modern geodatabases are well-suited for raster data management as
    well.
  prefs: []
  type: TYPE_NORMAL
- en: Geodatabases can exhibit all of the common traits we noted previously. This
    information is stored in the database in what we call the database model. A very
    popular model is the traditional relational model, which uses tables of rows and
    columns. Each row and column combination is called a cell. Rows can be related
    to another table to link information using a designated column where each cell
    becomes a key referencing a cell in another table that then links the rows together.
  prefs: []
  type: TYPE_NORMAL
- en: The actual names of the columns and the relationships among data constitute
    the data definition. At a minimum, geodatabases associate a geometry description
    with attributes about the object the geometry represents. Single points are often
    represented by `x` and `y` columns. However, polygons and polylines have arbitrary
    numbers of points. This means that geodatabases often store geometry information
    as a **BLOB** using a format standard known as **Well-Known Binary**, or **WKB**.
  prefs: []
  type: TYPE_NORMAL
- en: The attribute information is usually defined as data types such as integers,
    floating-point decimal numbers, strings, or dates. The table may also include
    projection information for map display, as well as a spatial indexing column to
    speed up searching and geospatial comparisons. A geodatabase may also have another
    related table in order to link detailed metadata about the geospatial data.
  prefs: []
  type: TYPE_NORMAL
- en: Large geospatial raster datasets are rarely stored directly in the database.
    Typically, the raster data is stored on disk with a name, and a filesystem reference
    is stored in the database that points to the raster data. A geodatabase may also
    store a geometry column representing the ground footprint of the raster data,
    which can then be used as a proxy for geospatial operations.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You now have the background needed to work with common types of geospatial data.
    You also know about the common traits of geospatial datasets that will allow you
    to evaluate unfamiliar types of data and identify key elements that will drive
    you toward which tools to use when interacting with this data.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll examine the modules and libraries that you can use
    to work with geospatial datasets. We will learn about the geospatial technology
    ecosystem, which consists of thousands of software libraries and packages. We
    will also understand the hierarchy of geospatial software and how it allows you
    to quickly comprehend and evaluate any geospatial tool.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find tutorials on the myriad of OGC services here: [http://cite.opengeospatial.org/pub/cite/files/edu/fundamental-concepts/text/basic.html](http://cite.opengeospatial.org/pub/cite/files/edu/fundamental-concepts/text/basic.html)[.](http://www.ogcnetwork.net/tutorials)
  prefs: []
  type: TYPE_NORMAL
