- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Implementing SAX
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现 SAX
- en: This chapter is about the **Symbolic Aggregate Approximation** (**SAX**) component
    of the iSAX index and is divided into two parts – the first part with the theoretical
    knowledge, and the second part with the code to compute SAX and the practical
    examples. At the end of the chapter, you will see how to calculate some handy
    statistical quantities that can give you a higher overview of your time series
    and plot a histogram of your data.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是关于 iSAX 索引的 **Symbolic Aggregate Approximation** (**SAX**) 组件，分为两部分——第一部分是理论知识，第二部分是计算
    SAX 和实际应用的代码示例。在章节末尾，你将看到如何计算一些有用的统计量，这些统计量可以让你对时间序列有一个更高的概述，并绘制数据的直方图。
- en: 'In this chapter, we will cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: The required theory
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所需的理论
- en: An introduction to SAX
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SAX 简介
- en: Developing a Python package
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发 Python 包
- en: Working with the SAX package
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 SAX 包
- en: Counting the SAX representations of a time series
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算时间序列的 SAX 表示
- en: The `tsfresh` Python package
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tsfresh` Python 包'
- en: Creating a histogram of a time series
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建时间序列的直方图
- en: Calculating the percentiles of a time series
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算时间序列的百分位数
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The GitHub repository for the book is [https://github.com/PacktPublishing/Time-Series-Indexing](https://github.com/PacktPublishing/Time-Series-Indexing).
    The code for each chapter is in its own directory. Therefore, the code for [*Chapter
    2*](B14769_02_MA.xhtml#_idTextAnchor053) can be found in the `ch02` folder. If
    you already used `git(1)` to get a local copy of the entire GitHub repository,
    there is no need to get that again. Just make your current working directory `ch02`
    while working with this chapter.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 该书的 GitHub 仓库是 [https://github.com/PacktPublishing/Time-Series-Indexing](https://github.com/PacktPublishing/Time-Series-Indexing)。每章的代码都在其自己的目录中。因此，[第
    2 章](B14769_02_MA.xhtml#_idTextAnchor053) 的代码可以在 `ch02` 文件夹中找到。如果你已经使用 `git(1)`
    获取了整个 GitHub 仓库的本地副本，就无需再次获取。只需在处理本章内容时将当前工作目录设置为 `ch02`。
- en: The required theory
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 所需的理论
- en: In this section, you are going to learn the required theory that supports the
    SAX representation. However, keep in mind that this book is more practical than
    it is theoretical. If you want to learn the theory in depth, you should read the
    research papers mentioned in this chapter, as well as the forthcoming ones, and
    the *Useful links* section found at the end of each chapter. Thus, the theory
    is about serving our main purpose, which is the implementation of techniques and
    algorithms.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习支持 SAX 表示所需的理论。然而，请记住，这本书更注重实践而非理论。如果你想深入理解理论，你应该阅读本章中提到的以及即将发表的研究论文，以及每章末尾的“有用链接”部分。因此，理论主要是为了服务于我们的主要目的，即实现技术和算法。
- en: 'The operation and the details of SAX are fully described in a research paper
    titled *Experiencing SAX: a novel symbolic representation of time series*, which
    was written by Jessica Lin, Eamonn Keogh, Li Wei, and Stefano Lonardi. This paper
    ([https://doi.org/10.1007/s10618-007-0064-z](https://doi.org/10.1007/s10618-007-0064-z))
    was officially published back in 2007\. You do not have to read all of it from
    the front cover to the back cover, but it is a great idea to download it and read
    the first pages of it, giving special attention to the abstract and the introduction
    section.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 'SAX 的操作和细节在由 Jessica Lin、Eamonn Keogh、Li Wei 和 Stefano Lonardi 撰写的题为 *Experiencing
    SAX: a novel symbolic representation of time series* 的研究论文中得到了全面描述。这篇论文([https://doi.org/10.1007/s10618-007-0064-z](https://doi.org/10.1007/s10618-007-0064-z))于2007年正式发表。你不必从头到尾阅读它，但下载并阅读其摘要和引言部分是个好主意。'
- en: We will begin by explaining the terms *PAA* and *SAX*. **PAA** stands for **Piecewise
    Aggregate Approximation**. The PAA representation offers a way to reduce the dimensionality
    of a time series. This means that it takes a long time series and creates a smaller
    version of it that is easier to work with.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先解释术语 *PAA* 和 *SAX*。**PAA** 代表 **Piecewise Aggregate Approximation**。PAA
    表示提供了一种降低时间序列维度的方法。这意味着它将一个长时间序列转换为一个更小的版本，这使得处理起来更容易。
- en: 'PAA is also explained in the *Experiencing SAX: a novel symbolic representation
    of time series* paper ([https://doi.org/10.1007/s10618-007-0064-z](https://doi.org/10.1007/s10618-007-0064-z)).
    From that, we can easily understand that PAA and SAX are closely related, as the
    idea behind SAX is based on PAA. The *SAX representation* is a **symbolic representation
    of time series**. Put simply, it offers a way of representing a time series in
    a summary form, in order to save space and increase speed.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 'PAA 也在 *Experiencing SAX: a novel symbolic representation of time series* 论文中进行了解释([https://doi.org/10.1007/s10618-007-0064-z](https://doi.org/10.1007/s10618-007-0064-z))。从那里，我们可以很容易地理解
    PAA 和 SAX 是密切相关的，因为 SAX 的理念基于 PAA。*SAX 表示* 是时间序列的 **符号表示**。简单来说，它提供了一种以摘要形式表示时间序列的方法，以便节省空间并提高速度。'
- en: The difference between PAA and SAX
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: PAA 和 SAX 的区别
- en: The main difference between PAA and the SAX representation is that PAA just
    calculates the mean values of a time series, based on a sliding window size, whereas
    the SAX representation utilizes those mean values and further transforms PAA to
    get a discrete representation of a time series (or subsequence). In other words,
    the SAX representation converts the PAA representation into something that is
    better to work with. As you will find out in a while, this transformation takes
    place with the help of **breakpoints**, which divide the numeric space of the
    mean values into subspaces. Each subspace has a discrete representation based
    on the given breakpoint values.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: PAA 和 SAX 表示之间的主要区别在于，PAA 只是基于滑动窗口大小计算时间序列的均值，而 SAX 表示利用这些均值并将 PAA 进一步转换为时间序列（或子序列）的离散表示。换句话说，SAX
    表示将 PAA 表示转换为更易于处理的形式。正如您很快就会发现的，这种转换是在 **断点**的帮助下进行的，这些断点将均值值的数值空间划分为子空间。每个子空间都有一个基于给定断点值的离散表示。
- en: Both PAA and SAX are techniques for dimensionality reduction. SAX is going to
    be explained in much more detail in a while, whereas the discussion about PAA
    ends here.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: PAA 和 SAX 都是降维技术。SAX 将在稍后进行更详细的解释，而关于 PAA 的讨论就到这里结束。
- en: The next subsection tells us why we need SAX.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个子节告诉我们为什么我们需要 SAX。
- en: Why do we need SAX?
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们为什么需要 SAX？
- en: Time series are difficult to search. The longer a time series (or subsequence)
    is, the more computationally intensive it is to search for it or compare it with
    another one. The same applies to working with indexes that index time series –
    iSAX is such an index.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 时间序列难以搜索。时间序列（或子序列）越长，搜索它或将其与另一个进行比较的计算量就越大。同样，使用索引时间序列的索引也是如此——iSAX 就是这样一种索引。
- en: To make things simpler for you, what we will do is take a subsequence with *x*
    elements and transform it into a representation with *w* elements, where *w* is
    much smaller than *x*. In strict terms, this is called **dimensionality reduction**,
    and it allows us to work with long subsequences using less data. However, once
    we decide that we need to work with a given subsequence, we need to work with
    it using its full dimensions – that is, all its *x* elements.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让您的事情更简单，我们将采取一个包含 *x* 个元素的子序列并将其转换为包含 *w* 个元素的表现形式，其中 *w* 远小于 *x*。严格来说，这被称为
    **降维**，它使我们能够使用更少的数据处理长时间子序列。然而，一旦我们决定需要处理一个给定的子序列，我们就需要使用其全部维度来处理它——也就是说，所有它的
    *x* 个元素。
- en: The next subsection talks about normalization, which, among other things, allows
    us to compare values at different scales.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个子节讨论了归一化，这使我们能够在不同的尺度上比较值。
- en: Normalization
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 归一化
- en: The first two questions you might ask are what normalization is and why we need
    it.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能问的第一个两个问题是归一化是什么以及为什么需要它。
- en: '**Normalization** is the process of adjusting values that use different scales
    to a common scale. A simple example is comparing Fahrenheit and Celsius temperatures
    – we cannot do that unless we bring all values to the same scale. This is the
    simplest form of normalization.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**归一化**是将使用不同尺度的值调整到共同尺度的过程。一个简单的例子是比较华氏和摄氏温度——除非我们将所有值都带到相同的尺度，否则我们无法这样做。这是归一化的最简单形式。'
- en: Although various types of normalization exist, what is needed here is **standard
    score normalization**, which is the simplest form of normalization, because this
    is what is used for time series and subsequences. Please do not confuse database
    normalization and normal forms with value normalization, as they are totally different
    concepts.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管存在各种类型的归一化，但这里需要的是 **标准分数归一化**，这是最简单的归一化形式，因为这是用于时间序列和子序列的。请勿将数据库归一化和范式与值归一化混淆，因为它们是完全不同的概念。
- en: 'The reasons that we introduce normalization into the process are as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将归一化引入过程的原因如下：
- en: The first and most important reason is that we can compare datasets that use
    a different range of values. A simple case is comparing Celsius and Fahrenheit
    temperatures.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个也是最重要的原因是，我们可以比较使用不同值范围的数据集。一个简单的例子是比较摄氏度和华氏温度。
- en: A side effect of the previous point is that data anomalies are reduced but not
    eliminated.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于数据异常减少但并未消除，这是前一点的一个副作用。
- en: In general, normalized data is easier to understand and process because we deal
    with values in a predefined range.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常，归一化数据更容易理解和处理，因为我们处理的是预定义范围内的值。
- en: Searching using an index that uses normalized values might be faster than when
    working with bigger values.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用归一化值索引进行搜索可能比使用较大值时更快。
- en: Searching, sorting, and creating indexes is faster since values are smaller.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于值较小，搜索、排序和创建索引更快。
- en: Normalization is conceptually cleaner and easier to maintain and change as your
    needs change.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 归一化在概念上更清晰，更容易维护和根据需要更改。
- en: Another simple example that supports the need for normalization is when comparing
    positive values with negative ones. It is almost impossible to draw useful conclusions
    when comparing such different kinds of observations. Normalization solves such
    issues.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个支持归一化需求的简单例子是当比较正值和负值时。在比较这种不同类型的观察结果时，几乎不可能得出有用的结论。归一化解决了这些问题。
- en: Although we are not going to need to, bear in mind that we cannot go from the
    normalized version of a subsequence to the original subsequence, so the normalization
    process is irreversible.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们不需要这样做，但请记住，我们不能从子序列的归一化版本回到原始子序列，因此归一化过程是不可逆的。
- en: 'The following function shows how to normalize a time series with some help
    from the NumPy Python package:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数展示了如何使用NumPy Python包的帮助来归一化时间序列：
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The previous function reveals the formula of normalization. Given a dataset,
    the normalized form of each one of its elements is equal to the value of the observation,
    minus the **mean value** of the dataset over the **standard deviation** of the
    dataset – both these statistical terms are explained in *The tsfresh Python package*
    section of this chapter.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个函数揭示了归一化的公式。给定一个数据集，其每个元素的归一化形式等于观察值，减去数据集的**平均值**除以数据集的**标准差**——这两个统计术语在本章的*The
    tsfresh Python包*部分中解释。
- en: This is seen in the return value of the previous function, `(x-mu)/std`. NumPy
    is clever enough to calculate that value for each observation without the need
    to use a `for` loop. If the standard deviation is close to `0`, which is simulated
    by the value of the `eps` variable, then the return value of `normalize()` is
    equal to a NumPy array full of zeros.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这在前一个函数的返回值中可以看到，`(x-mu)/std`。NumPy足够聪明，可以计算每个观察值而不需要使用`for`循环。如果标准差接近`0`，这是由`eps`变量的值模拟的，那么`normalize()`的返回值将等于一个全为零的NumPy数组。
- en: 'The `normalize.py` script, which uses the previously developed function that
    does not appear here, gets a time series as input and returns its normalized version.
    Its code is as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 使用之前开发的函数（此处未显示）的`normalize.py`脚本，以时间序列作为输入，并返回其归一化版本。其代码如下：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The last `for` loop of the program is used to print the contents of the `taNorm`
    NumPy array with a smaller precision in order to take up less space. To do that,
    we need to convert the `taNorm` NumPy array into a regular Python list using the
    `tolist()` method.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 程序中的最后一个`for`循环用于以较小的精度打印`taNorm` NumPy数组的内容，以便占用更少的空间。为此，我们需要使用`tolist()`方法将`taNorm`
    NumPy数组转换为常规Python列表。
- en: 'We are going to feed `normalize.py` a short time series; however, the script
    also works with longer ones. The output of `normalize.py` looks as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将向`normalize.py`提供一个短时间序列；然而，该脚本也可以处理更长的序列。`normalize.py`的输出如下：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: With normalization in mind, let us now proceed to the next subsection, where
    we are going to visualize a time series and show the visual difference between
    the original version and the normalized version of it.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到归一化，我们现在继续到下一个子节，我们将可视化一个时间序列，并展示原始版本和归一化版本之间的视觉差异。
- en: Visualizing normalized time series
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可视化归一化时间序列
- en: In this subsection, we are going to show the difference between the normalized
    and the original version of a time series with the help of visualization. Keep
    in mind that we usually *do not normalize the entire time series*. The normalization
    takes place on a subsequence level based on the sliding window size. In other
    words, for the purposes of this book, we will normalize subsequences, not an entire
    time series. Additionally, for the calculation of the SAX representation, we process
    the normalized subsequences based on the **segment value**, which specifies the
    parts that a SAX representation will have. So, for a segment value of 2, we split
    the normalized subsequence into two. For a segment value of 4, we split the normalized
    subsequence into four sets.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节中，我们将通过可视化展示归一化版本和原始时序版本之间的差异。请注意，我们通常*不会对整个时序进行归一化*。归一化是在基于滑动窗口大小的子序列级别进行的。换句话说，为了本书的目的，我们将归一化子序列，而不是整个时序。此外，对于SAX表示法的计算，我们根据**段值**处理归一化子序列，这指定了SAX表示法将包含的部分。因此，对于段值为2，我们将归一化子序列分成两个部分。对于段值为4，我们将归一化子序列分成四个集合。
- en: 'Nevertheless, viewing the normalized and original versions of a time series
    is very educational. The Python code of `visualize_normalized.py`, without the
    implementation of `normalize()`, is as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，查看时序的归一化和原始版本是非常有教育意义的。`visualize_normalized.py`的Python代码（不包括`normalize()`的实现）如下：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `plt.plot()` function is called twice, plotting a line each time. Feel free
    to experiment with the Python code in order to change the look of the output.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`plt.plot()`函数被调用了两次，每次都绘制一条线。您可以自由地实验Python代码，以改变输出的外观。'
- en: '*Figure 2**.1* shows the output of `visualize_normalized.py ts1.gz`, which
    uses a time series with 50 elements.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2.1*显示了`visualize_normalized.py ts1.gz`的输出，它使用了一个包含50个元素的时序。'
- en: '![Figure 2.1 – The plotting of a time series and its normalized version](img/Figure_2.1_B14769.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图2.1 – 时序及其归一化版本的绘图](img/Figure_2.1_B14769.jpg)'
- en: Figure 2.1 – The plotting of a time series and its normalized version
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 – 时序及其归一化版本的绘图
- en: I think that *Figure 2**.1* speaks for itself! The values of the normalized
    version are located *around the value of 0*, whereas the values of the original
    time series can be anywhere! Additionally, we make the original time series smoother
    without completely losing its original shape and edges.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为*图2.1*本身就很有说服力！归一化版本的值位于*0值附近*，而原始时序的值可以在任何地方！此外，我们在不完全失去原始形状和边缘的情况下使原始时序更加平滑。
- en: The next section is about the details of the SAX representation, which is a
    key component of every iSAX index.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将介绍SAX表示法的细节，这是每个iSAX索引的关键组成部分。
- en: An introduction to SAX
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SAX简介
- en: 'As mentioned previously, **SAX** stands for **Symbolic Aggregate Approximation**.
    The SAX representation was officially announced back in 2007 in the *Experiencing
    SAX: a novel symbolic representation of time series* paper ([https://doi.org/10.1007/s10618-007-0064-z](https://doi.org/10.1007/s10618-007-0064-z)).'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，**SAX**代表**符号聚合近似**。SAX表示法在2007年的论文《体验SAX：时间序列的一种新颖的符号表示》中被正式宣布（[https://doi.org/10.1007/s10618-007-0064-z](https://doi.org/10.1007/s10618-007-0064-z)）。
- en: Keep in mind that we do not want to find the SAX representation of an entire
    time series. We just want to find the SAX representation of a subsequence of a
    time series. The main difference between a time series and a subsequence is that
    a time series is many times bigger than a subsequence.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我们不想找到整个时序的SAX表示法。我们只想找到时序子序列的SAX表示法。时序和子序列之间的主要区别是时序通常比子序列大得多。
- en: Each SAX representation has two parameters named **cardinality** and the number
    of **segments**. We will begin by explaining the cardinality parameter.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 每个SAX表示法有两个参数，分别命名为**基数**和**段数**。我们将首先解释基数参数。
- en: The cardinality parameter
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基数参数
- en: The *cardinality* parameter specifies the number of possible values each segment
    can have. As a side effect, the cardinality parameter *defines the way the y axis
    is divided* – this is used to get the value of each segment. There exist multiple
    ways to specify the value of a segment based on the cardinality. These include
    alphabet characters, decimal numbers, and binary numbers. In this book, we will
    use binary numbers because they are easier to understand and interpret, using
    a file with the **precalculated breakpoints** for cardinalities up to 256.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*基数* 参数指定了每个段可以有多少个可能的值。作为副作用，基数参数 *定义了y轴的分割方式* – 这用于获取每个段的值。根据基数，存在多种指定段值的方法。这包括字母字符、十进制数和二进制数。在这本书中，我们将使用二进制数，因为它们更容易理解和解释，使用带有
    **预先计算的断点** 的文件，这些断点适用于高达256的基数。'
- en: So, a cardinality of 4, which is 22, gives us four possible values, as we use
    2 bits. However, we can easily replace `00` with the letter `a`, `01` with the
    letter `b`, `10` with the letter `c`, `11` with the letter `d`, and so on, in
    order to use letters instead of binary numbers. Keep in mind that this might require
    minimal code changes in the presented code, and it would be good to try this as
    an exercise when you feel comfortable with SAX and the provided Python code.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，基数4，即22，给出了四个可能的值，因为我们使用了2位。然而，我们可以轻松地将 `00` 替换为字母 `a`，`01` 替换为字母 `b`，`10`
    替换为字母 `c`，`11` 替换为字母 `d`，以此类推，以便使用字母而不是二进制数。请记住，这可能需要在展示的代码中进行最小的代码更改，并且当您对SAX和提供的Python代码感到舒适时，尝试这个练习会很好。
- en: 'The format of the file with the breakpoints, which in our case supports cardinalities
    up to 256 and is called `SAXalphabet`, is as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 断点文件的格式如下，在我们的例子中支持高达256的基数，被称为 `SAXalphabet`：
- en: '[PRE4]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The values presented here are called breakpoints in the SAX terminology. The
    value in the first line divides the *y* axis into two areas, separated by the
    *x* axis. So, in this case, we need 1 bit to define whether we are in the upper
    space (the positive *y* value) or the lower one (the negative *y* value).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示的值在SAX术语中被称为断点。第一行中的值将 *y* 轴分割成两个区域，由 *x* 轴分隔。因此，在这种情况下，我们需要1位来定义我们是在上空间（正
    *y* 值）还是下空间（负 *y* 值）。
- en: As we will use binary numbers to represent each SAX segment, there is no point
    in wasting them. Therefore, the values that we will use are the powers of 2, from
    2 1 (*cardinality 2*) to 2 8 (*cardinality 256*).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将使用二进制数来表示每个SAX段，因此没有必要浪费它们。因此，我们将使用的值是2的幂，从2 1 (*基数2*) 到2 8 (*基数256*)。
- en: Let us now present *Figure 2**.2*, which shows how `-0.67449, 0, 0.67449` divides
    the *y* axis, which is used in the 2 2 cardinality. The bottom part begins from
    the minus infinitive up to `-0.67449`, the second part from `-0.67449` up to `0`,
    the third part from `0` to `0.67449`, and the last part from `0.67449` up to plus
    infinitive.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来展示 *图2**.2**，它展示了 `-0.67449, 0, 0.67449` 如何将 *y* 轴分割，这在2 2基数中是使用的。底部部分从负无穷大到
    `-0.67449`，第二部分从 `-0.67449` 到 `0`，第三部分从 `0` 到 `0.67449`，最后一部分从 `0.67449` 到正无穷大。
- en: '![Figure 2.2 – The y axis for cardinality 4 (three breakpoints)](img/Figure_2.2_B14769.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图2.2 – 基数为4的y轴（三个断点）](img/Figure_2.2_B14769.jpg)'
- en: Figure 2.2 – The y axis for cardinality 4 (three breakpoints)
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 – 基数为4的y轴（三个断点）
- en: Let us now present *Figure 2**.3*, which shows how `-1.1503, -0.67449, -0.31864,
    0, 0.31864, 0.67449, 1.1503` divides the *y* axis. This is for the 2 3 cardinality.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来展示 *图2**.3**，它展示了 `-1.1503, -0.67449, -0.31864, 0, 0.31864, 0.67449, 1.1503`
    如何分割 *y* 轴。这是针对2 3基数的。
- en: '![Figure 2.3 – The y axis for cardinality 8 (7 breakpoints)](img/Figure_2.3_B14769.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图2.3 – 基数为8的y轴（七个断点）](img/Figure_2.3_B14769.jpg)'
- en: Figure 2.3 – The y axis for cardinality 8 (7 breakpoints)
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3 – 基数为8的y轴（七个断点）
- en: As this can be a tedious job, we have created a utility that does all the plotting.
    Its name is `cardinality.py`, and it reads the `SAXalphabet` file to find the
    breakpoints of the desired cardinality before plotting them.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这可能是一项繁琐的工作，我们创建了一个工具来完成所有的绘图。它的名字是 `cardinality.py`，它读取 `SAXalphabet` 文件，在绘图之前找到所需基数的断点。
- en: 'The Python code for `cardinality.py` is as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`cardinality.py` 的Python代码如下：'
- en: '[PRE5]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The script requires two command-line parameters – the cardinality and the output
    file, which is used to save the image. Note that a cardinality value of 8 requires
    7 breakpoints, a cardinality value of 32 requires 31 breakpoints, and so on. Therefore,
    the Python code for `cardinality.py` decreases the line number that it is going
    to search for in the `SAXalphabet` file to support that functionality. Therefore,
    when given a cardinality value of 8, the script is going to look for the line
    with 7 breakpoints in `SAXalphabet`. Additionally, as the script reads the breakpoint
    values as strings, we need to convert these strings into floating-point values
    using the `lines = [eval(i) for i in elements]` statement. The rest of the code
    is related to the Matplotlib Python package and how to draw lines using `plt.axhline()`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本需要两个命令行参数——基数和输出文件，用于保存图像。请注意，基数值为8需要7个断点，基数值为32需要31个断点，依此类推。因此，`cardinality.py`的Python代码减少了它将在`SAXalphabet`文件中搜索的行数，以支持该功能。因此，当给定基数值为8时，脚本将寻找`SAXalphabet`中具有7个断点的行。此外，由于脚本将断点值作为字符串读取，我们需要使用`lines
    = [eval(i) for i in elements]`语句将这些字符串转换为浮点值。其余的代码与Matplotlib Python包有关，以及如何使用`plt.axhline()`绘制线条。
- en: The next subsection is about the segments parameter.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个子节是关于段落数据的参数。
- en: The segments parameter
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 段参数
- en: The (number of) *segments* parameter specifies the number of parts (*words*)
    a SAX representation is going to have. Therefore, a segments value of 2 means
    that the SAX representation is going to have two words, each one using the specified
    cardinality. Therefore, the values of each part are determined by the cardinality.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: （段落数量的）*段*参数指定了SAX表示将要拥有的部分（*单词*）的数量。因此，段值为2意味着SAX表示将有两个单词，每个单词使用指定的基数。因此，每个部分的值由基数确定。
- en: A side effect of this parameter is that, after normalizing a subsequence, we
    divide it by the number of segments and work with these different parts separately.
    This is the way the SAX representation works.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这个参数的一个副作用是，在归一化子序列后，我们将它除以段落数量，并分别处理这些不同的部分。这就是SAX表示的工作方式。
- en: Both cardinality and segments values control the data compression ratio and
    the accuracy of the subsequences of a time series and, therefore, the entire time
    series.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 基数和段值控制时间序列子序列以及整个时间序列的数据压缩比和准确性。
- en: The next subsection shows how to manually compute the SAX representation of
    a subsequence – this is the best way to fully understand the process and be able
    to identify bugs or errors in the code.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个子节展示了如何手动计算子序列的SAX表示——这是完全理解过程和能够识别代码中的错误或错误的最有效方式。
- en: How to manually find the SAX representation of a subsequence
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何手动找到子序列的SAX表示
- en: 'Finding the SAX representation of a subsequence looks easy but requires lots
    of computations, which makes the process ideal for a computer. Here are the steps
    to find the SAX representation of a time series or subsequence:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 找到子序列的SAX表示看起来很简单，但需要大量的计算，这使得这个过程非常适合计算机。以下是找到时间序列或子序列的SAX表示的步骤：
- en: First, we need to have the number of segments and the cardinality.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要有段落数量和基数。
- en: Then, we normalize the subsequence or the time series.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们归一化子序列或时间序列。
- en: After that, we divide the normalized subsequence by the number of segments.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们将归一化的子序列除以段落数量。
- en: For each one of these parts, we find its mean value.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这些部分中的每一个，我们找到它的平均值。
- en: Finally, based on each mean value, we calculate its representation based on
    the cardinality. The cardinality is what defines the breakpoint values that are
    going to be used.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，基于每个平均值，我们根据基数计算其表示。基数定义了将要使用的断点值。
- en: We will use two simple examples to illustrate the manual computation of the
    SAX representation of a time series. The time series is the same in both cases.
    What will be different are the SAX parameters and the sliding window size.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用两个简单的例子来说明时间序列SAX表示的手动计算。在这两种情况下，时间序列是相同的。不同之处在于SAX参数和滑动窗口大小。
- en: 'Let’s imagine we have the following time series and a sliding window size of
    4:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设我们有一个以下时间序列和一个滑动窗口大小为4：
- en: '[PRE6]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Based on the sliding window size, we extract the first two subsequences from
    the time series:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 基于滑动窗口大小，我们从时间序列中提取前两个子序列：
- en: '`S1 = {-1, 2,` `3, 4}`'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`S1 = {-1, 2, 3, 4}`'
- en: '`S2 = {2, 3,` `4, 5}`'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`S2 = {2, 3, 4, 5}`'
- en: The first step that we should take is to `normalize.py` script we developed
    earlier – we just have to save each subsequence into its own plain text file and
    compress it using the `gzip` utility, before giving it as input to `normalize.py`.
    If you use a Microsoft Windows machine, you should look for a utility that allows
    you to create such ZIP files. An alternative is to work with plain text files,
    which might require some small code changes in the `pd.read_csv()` function call.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该采取的第一步是使用我们之前开发的 `normalize.py` 脚本 – 我们只需将每个子序列保存到自己的纯文本文件中，并使用 `gzip` 工具对其进行压缩，然后再将其作为输入提供给
    `normalize.py`。如果你使用的是微软 Windows 机器，你应该寻找一个允许你创建此类 ZIP 文件的实用程序。另一种选择是使用纯文本文件，这可能在
    `pd.read_csv()` 函数调用中需要一些小的代码更改。
- en: 'The output of the `normalize.py` script when processing `S1` (`s1.txt.gz`)
    and `S2` (`s2.txt.gz`) is the following:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理 `S1` (`s1.txt.gz`) 和 `S2` (`s2.txt.gz`) 时，`normalize.py` 脚本的输出如下：
- en: '[PRE7]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'So, the normalized versions of `S1` and `S2` are as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`S1` 和 `S2` 的归一化版本如下：
- en: '`N1 = {-1.6036, 0.0000,` `0.5345, 1.0690}`'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`N1 = {-1.6036, 0.0000,` `0.5345, 1.0690}`'
- en: '`N2 = {-1.3416, -0.4472,` `0.4472, 1.3416}`'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`N2 = {-1.3416, -0.4472,` `0.4472, 1.3416}`'
- en: 'In this first example, we use a segments value of 2 and a cardinality value
    of 4 (22). A segment value of 2 means that we must divide each *normalized subsequence*
    into two parts. These two parts contain the following data, based on the normalized
    versions of `S1` and `S2`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个第一个例子中，我们使用段值为 2，基数值为 4（22）。段值为 2 意味着我们必须将每个 *归一化子序列* 分成两部分。这两部分包含以下数据，基于
    `S1` 和 `S2` 的归一化版本：
- en: For `S1`, the two parts are `{-1.6036, 0.0000}` and `{``0.5345, 1.0690}`
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 `S1`，两部分是 `{-1.6036, 0.0000}` 和 `{``0.5345, 1.0690}`
- en: For `S2`, the two parts are `{-1.3416, -0.4472}` and `{``0.4472, 1.3416}`
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 `S2`，两部分是 `{-1.3416, -0.4472}` 和 `{``0.4472, 1.3416}`
- en: 'The mean values of each part are as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 每个部分的平均值如下：
- en: For `S1`, they are `-0.8018` and `0.80175`
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 `S1`，它们分别是 `-0.8018` 和 `0.80175`
- en: For `S2`, they are `-0.8944` and `0.8944`
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 `S2`，它们是 `-0.8944` 和 `0.8944`
- en: 'For the cardinality of 4, we are going to look at *Figure 2**.2* and the respective
    breakpoints, which are `-0.67449`, `0`, and `0.67449`. So, the SAX values of each
    segment are as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 对于基数 4，我们将查看 *图 2**.2* 和相应的断点，分别是 `-0.67449`，`0` 和 `0.67449`。因此，每个段的 SAX 值如下：
- en: For S1, they are `00` because `-0.8018` falls at the bottom of the plot and
    `11`
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 S1，它们是 `00`，因为 `-0.8018` 位于图表底部，而 `11`
- en: For S2, they are `00` and `11` because `0.8944` falls at the top of the plot
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 S2，它们是 `00` 和 `11`，因为 `0.8944` 位于图表的顶部
- en: Therefore, the SAX representation of `S1` is `[00, 11]` and for `S2`, it is
    `[00, 11]`. It turns out that both subsequences have the same SAX representation.
    This makes sense, as they only differ in one element, which means that their normalized
    versions are similar.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`S1` 的 SAX 表示是 `[00, 11]`，而 `S2` 的表示也是 `[00, 11]`。这两个子序列具有相同的 SAX 表示是有道理的，因为它们只在一个元素上有所不同，这意味着它们的归一化版本相似。
- en: Note that in both cases, the lower cardinality begins from the bottom of the
    plot. For *Figure 2**.2*, this means that `00` is at the bottom of the plot, `01`
    is next, followed by `10`, and `11` is at the top of the plot.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在两种情况下，较低的基数都从图表的底部开始。对于 *图 2**.2*，这意味着 `00` 位于图表底部，`01` 接着是，然后是 `10`，而 `11`
    位于图表顶部。
- en: In the second example, we will use a sliding window size of 8, a segments value
    of 4, and a cardinality value of 8 (23).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个例子中，我们将使用滑动窗口大小为 8，段值 4，基数值 8（23）。
- en: About the sliding window size
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 关于滑动窗口大小
- en: Keep in mind that the normalized representation of the subsequence remains the
    same when the sliding window size remains the same. However, if either the cardinality
    or the segments change, the resulting SAX representation might be completely different.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，当滑动窗口大小保持不变时，子序列的归一化表示保持不变。然而，如果基数或段发生变化，生成的 SAX 表示可能完全不同。
- en: Based on the sliding window size, we extract the first two subsequences from
    the time series – `S1 = {-1, 2, 3, 4, 5, -1, -3, 4}` and `S2 = {2, 3, 4, 5, -1,
    -3,` `4, 10}`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 根据滑动窗口大小，我们从时间序列中提取前两个子序列 – `S1 = {-1, 2, 3, 4, 5, -1, -3, 4}` 和 `S2 = {2, 3,
    4, 5, -1, -3,` `4, 10}`。
- en: 'The output of the `normalize.py` script is going to be the following:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`normalize.py` 脚本的输出将是以下内容：'
- en: '[PRE8]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: So, the normalized versions of `S1` and `S2` are `N1 = {-0.9595, 0.1371, 0.5026,
    0.8681, 1.2337, -0.9595, -1.6906, 0.8681}` and `N2 = {-0.2722, 0.0000, 0.2722,
    0.5443, -1.0887, -1.6330, 0.2722,` `1.9052}`, respectively.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`S1`和`S2`的归一化版本分别是`N1 = {-0.9595, 0.1371, 0.5026, 0.8681, 1.2337, -0.9595,
    -1.6906, 0.8681}`和`N2 = {-0.2722, 0.0000, 0.2722, 0.5443, -1.0887, -1.6330, 0.2722,
    1.9052}`。
- en: A segment value of 4 means that we must divide each one of the *normalized subsequences*
    into four parts. For `S1`, these parts are `{-0.9595, 0.1371}`, `{0.5026, 0.8681}`,
    `{1.2337, -0.9595}`, and `{-``1.6906, 0.8681}`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 段数值为4意味着我们必须将每个**归一化子序列**分成四个部分。对于`S1`，这些部分是`{-0.9595, 0.1371}`，`{0.5026, 0.8681}`，`{1.2337,
    -0.9595}`，和`{-1.6906, 0.8681}`。
- en: For `S2`, these parts are `{-0.2722, 0.0000}`, `{0.2722, 0.5443}`, `{-1.0887,
    -1.6330}`, and `{``0.2722, 1.9052}`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`S2`，这些部分是`{-0.2722, 0.0000}`，`{0.2722, 0.5443}`，`{-1.0887, -1.6330}`，和`{0.2722,
    1.9052}`。
- en: For `S1`, the mean values are `-0.4112`, `0.68535`, `0.1371`, and `-0.41125`.
    For `S2`, the mean values are `-0.1361`, `0.40825`, `-1.36085`, and `1.0887`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`S1`，平均值是`-0.4112`，`0.68535`，`0.1371`，和`-0.41125`。对于`S2`，平均值是`-0.1361`，`0.40825`，`-1.36085`，和`1.0887`。
- en: About the breakpoints of the cardinality value of 8
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 关于基数值为8的断点
- en: Just a reminder here that for the cardinality value of 8, the breakpoints are
    (000) `-1.1503`, (001) `-0.67449`, (010) `-0.31864`, (011) `0`, (100) `0.31864`,
    (101) `0.67449`, and (110) `1.1503` (111). In parentheses, we present the SAX
    values for each breakpoint. For the first breakpoint, we have the 000 value to
    its left and 001 to its right. For the last breakpoint, we have the 110 value
    to its left and 111 to its right. Remember that we use seven breakpoints for a
    cardinality value of 8.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这里提醒一下，对于基数值为8的情况，断点为（000）`-1.1503`，（001）`-0.67449`，（010）`-0.31864`，（011）`0`，（100）`0.31864`，（101）`0.67449`，以及（110）`1.1503`（111）。在括号中，我们展示了每个断点的SAX值。对于第一个断点，其左侧是000值，右侧是001值。对于最后一个断点，其左侧是110值，右侧是111值。记住，我们使用七个断点来表示基数值为8。
- en: Therefore, the SAX representation of `S1` is `['010', '110', '100', '010']`,
    and for `S2`, it is`['011', '101', '000', '110']`. The use of single quotes around
    SAX words means that internally we store SAX words as strings, despite the fact
    that we calculate them as binary numbers because it is easier to search and compare
    strings.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`S1`的SAX表示为`['010', '110', '100', '010']`，而`S2`的表示为`['011', '101', '000',
    '110']`。在SAX词周围使用单引号表示，尽管我们将其计算为二进制数，但内部我们将其作为字符串存储，因为这样更容易搜索和比较。
- en: The next subsection examines a case where a subsequence cannot be divided perfectly
    by the number of segments.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个子节考察了一个不能被段落数完美分割的子序列的案例。
- en: Ηow can we divide 10 data points into 3 segments?
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们如何将10个数据点分成3个段？
- en: So far, we have seen examples where the length of the subsequence can be perfectly
    divided by the number of segments. However, what happens if that is not possible?
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了子序列长度可以完美被段落数分割的例子。然而，如果不可能这样做，会发生什么呢？
- en: In that case, there exist data points that contribute to two adjacent segments
    at the same time. However, instead of putting the whole point into a segment,
    we put part of it into one segment and part of it into another!
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，存在一些数据点同时贡献于两个相邻的段。然而，我们不是将整个点放入一个段中，而是将其一部分放入一个段，另一部分放入另一个段！
- en: 'This is further explained on page 18 of the *Experiencing SAX: a novel symbolic
    representation of time series* paper. As stated in the paper, if we cannot divide
    the sliding window length by the number of segments, we can use a part of a point
    in a segment and a part of a point in another segment. We do that for points that
    are between two segments and not for any random points. This can be explained
    using an example. Imagine we have a time series such as *T* = {*t*1, *t*2, *t*3,
    *t*4, *t*5, *t*6, *t*7, *t*8, *t*9, *t*10}*.* For the *S*1 segment, we take the
    values of {*t*1, *t*2, *t*3} and one-third of the value of *t*4\. For the *S*2
    segment, we take the values of {*t*5, *t*6} and two-thirds of the values of *t*4
    and *t*7\. For the *S*3 segment, we take the values of {*t*8, *t*9, *t*10} and
    the third of the value of *t*7 that we have not used so far. This is also explained
    in *Figure 2**.4*:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.4 – Dividing 10 data points into 3 segments](img/Figure_2.4_B14769.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
- en: Figure 2.4 – Dividing 10 data points into 3 segments
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Put simply, this is a convention decided by the creators of SAX that applies
    to all cases where we cannot perfectly divide the number of elements by that of
    the segments.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we will not deal with that case. The sliding window size, which
    is the length of the generated subsequences, and the number of segments are both
    part of a perfect division, with a remainder of 0\. This simplification does not
    change the way SAX works, but it makes our lives a little easier.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: The subject of the next subsection is how to go from higher cardinalities to
    lower ones without doing every computation.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Reducing the cardinality of a SAX representation
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The knowledge gained from this subsection will be applicable when we discuss
    the iSAX index. However, as what you will learn is directly related to SAX, we
    have decided to discuss it here first.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Imagine that we have a SAX representation at a given cardinality and that we
    want to reduce the cardinality. Is that possible? Can we do this without calculating
    everything from scratch? The answer is simple – this can be done by ignoring trailing
    bits. Given a binary value of 10,100, the first trailing bit is 0, then the next
    trailing bit is 0, then 1, and so on. So, we start from the bits at the end, and
    we remove them one by one.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: As most of you, including me when I first read about it, might find this unclear,
    let me show you some practical examples. Let us take the following two SAX representations
    from the *How to manually find the SAX representation of a subsequence* subsection
    of this chapter – `[00, 11]` and `[010, 110, 100, 010]`. To convert `[00, 11]`
    into the cardinality of 2, we must just delete the digits at the end of each SAX
    word. So, the new version of `[00, 11]` will be `[0, 1]`. Similarly, `[010, 110,
    100, 010]` is going to be `[01, 11, 10, 01]` for the cardinality of 4 and `[0,
    1, 1, 0]` for the cardinality of 2.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: So, from a higher cardinality – a cardinality with more digits – we can go to
    a lower cardinality by *subtracting the appropriate number of digits from the
    right side* of one or more segments (the trailing bits). Can we go in the opposite
    direction? Not without losing accuracy, but that would still be better than nothing.
    However, generally, we don’t go in the opposite direction. So far, we know the
    theory regarding the SAX representation. The section that follows briefly explains
    the basics of Python packages and shows the development of our own package, named
    `sax`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，从更高的基数——一个有更多数字的基数——我们可以通过从一段或多段（尾数位）的右侧 *减去适当的数字* 来降低基数。我们能朝相反的方向前进吗？不能不损失精度，但即便如此，这仍然比没有好。然而，通常情况下，我们不会朝相反的方向前进。到目前为止，我们已经了解了关于
    SAX 表示的理论。接下来的部分将简要解释 Python 包的基础知识，并展示我们自己的包 `sax` 的开发过程。
- en: Developing a Python package
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发 Python 包
- en: In this section, we describe the process of developing a Python package that
    calculates the SAX representation of a subsequence. Apart from this being a good
    programming exercise, the package is going to be enriched in the chapters that
    follow when we create the iSAX index.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们描述了开发一个 Python 包的过程，该包用于计算子序列的 SAX 表示。除了这是一个好的编程练习之外，当我们在后续章节中创建 iSAX
    索引时，该包将在接下来的章节中得到丰富。
- en: We will begin by explaining the basics of Python packages.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先解释 Python 包的基础知识。
- en: The basics of Python packages
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python 包的基础知识
- en: I am not a Python expert, and the presented information is far from complete.
    However, it covers the required knowledge regarding Python packages.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我不是 Python 专家，所提供的信息远非完整。然而，它涵盖了有关 Python 包所需的知识。
- en: In all but the latest Python versions, we used to need a file named `__init__.py`
    inside the directory of every Python package. Its purpose is to perform initialization
    actions and imports, as well as define variables. Although this is not the case
    with most recent Python versions, our packages will still have a `__init__.py`
    file in them. The good thing is that it is allowed to be empty if you have nothing
    to put into it. There is a link at the end of the chapter to the official Python
    documentation regarding packages, regular packages, and namespace packages, where
    the use of `__init__.py` is explained in more detail.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在除了最新版本的 Python 之外的所有版本中，我们通常需要在每个 Python 包的目录中创建一个名为 `__init__.py` 的文件。它的目的是执行初始化操作和导入，以及定义变量。尽管在最新的
    Python 版本中这种情况不再适用，但我们的包中仍然会包含一个 `__init__.py` 文件。好事是，如果你没有东西要放入其中，它可以是空的。本章末尾有一个链接指向官方
    Python 文档，其中详细解释了包、常规包和命名空间包的使用，以及 `__init__.py` 的使用。
- en: The next subsection discusses the details of the Python package that we are
    going to develop.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个子节将讨论我们将要开发的 Python 包的详细信息。
- en: The SAX Python package
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SAX Python 包
- en: 'The code of the `sax` Python package is included in a directory named `sax`.
    The contents of the `sax` directory are presented with the help of the `tree(1)`
    command, which you might need to install on your own:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`sax` Python 包的代码包含在一个名为 `sax` 的目录中。`sax` 目录的内容通过 `tree(1)` 命令展示，你可能需要自行安装该命令：'
- en: '[PRE9]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `__pycache__` directory is automatically generated by Python once you begin
    using the Python package and contains precompiled bytecode Python code. You can
    completely ignore that directory.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Python 会在你开始使用 Python 包之后自动生成名为 `__pycache__` 的目录，该目录包含预编译的 Python 字节码。你可以完全忽略该目录。
- en: Let us begin by showing the contents of `sax.py`, which is going to be presented
    in multiple code chunks.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看 `sax.py` 的内容，它将被分成多个代码块展示。
- en: 'First, we have the `import` section and the implementation of the `normalize()`
    function, which normalizes a NumPy array:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们有 `import` 部分，以及 `normalize()` 函数的实现，该函数用于规范化一个 NumPy 数组：
- en: '[PRE10]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'After that, we have the implementation of the `createPAA()` function, which
    returns the SAX representation of a time series, given the cardinality and the
    segments:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将介绍 `createPAA()` 函数的实现，该函数根据基数和段返回时间序列的 SAX 表示：
- en: '[PRE11]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Python uses the double slash `//` operator to perform floor division. What the
    `//` operator does is divide the first number by the second number before rounding
    the result down to the nearest integer – this is used for the `segment_size` variable.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Python 使用双斜杠 `//` 运算符执行向下取整除法。`//` 运算符的作用是在将结果向下取整到最接近的整数之前，将第一个数除以第二个数——这用于
    `segment_size` 变量。
- en: The rest of the code is about specifying the correct index numbers when working
    with the given time series (or subsequence). Hence, the `for` loop is used to
    process the entire time series (or subsequence) based on the segments value.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的其余部分是关于在处理给定的时间序列（或子序列）时指定正确的索引号。因此，`for`循环用于根据段值处理整个时间序列（或子序列）。
- en: 'Next, we have the implementation of a function that computes the mean value
    of a NumPy array:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有一个计算NumPy数组平均值的函数的实现：
- en: '[PRE12]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Finally, we have the function that returns the SAX value of a SAX word, given
    its mean value and its cardinality. Remember that we calculate the mean value
    of each SAX word separately in the `createPAA()` function:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有一个函数，它根据SAX词的平均值和基数返回SAX值。记住，我们在`createPAA()`函数中单独计算每个SAX词的平均值：
- en: '[PRE13]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The previous code computes the SAX value of a SAX word using its mean value.
    It iteratively visits the breakpoints, from the lowest value to the biggest, up
    to the point that the mean value exceeds the current breakpoint. This way, we
    find the index of the SAX word (mean value) in the list of breakpoints.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码通过使用平均值来计算SAX词的SAX值。它迭代地访问断点，从最低值到最高值，直到平均值超过当前断点。这样，我们在断点列表中找到SAX词（平均值）的索引。
- en: Now, let us discuss a tricky point, which has to do with the last statements
    that reverse the SAX word. This mainly has to do with whether we begin counting
    from the top or the bottom of the different areas that the breakpoints create.
    All ways are equivalent – we just decided to go that way. This is because a previous
    implementation of SAX used that order, and we wanted to make sure that we created
    the same results for testing reasons. If you want to alter that functionality,
    you just have to remove the last `for` loop.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们讨论一个棘手的问题，这与反转SAX词的最后几个语句有关。这主要与我们是开始从断点创建的不同区域的顶部还是底部计数有关。所有方法都是等效的——我们只是决定那样做。这是因为SAX的前一个实现使用了那个顺序，我们想要确保为了测试目的我们创建了相同的结果。如果你想改变这个功能，你只需要移除最后的`for`循环。
- en: As you saw at the beginning of this section, the `sax` package is composed of
    three Python files, not just the one that we just presented. So, we will present
    the remaining two files.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在本节开头所见，`sax`包由三个Python文件组成，而不仅仅是刚才我们展示的那个。因此，我们将展示剩下的两个文件。
- en: 'First, we will present the contents of `variables.py`:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将展示`variables.py`的内容：
- en: '[PRE14]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You might wonder what the main reason is for having such a file. The answer
    is that we need to have a place to keep our global parameters and options, and
    having a separate file for that is a perfect solution. This will make much more
    sense when the code becomes longer and more complex.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道为什么有这样的文件。答案是，我们需要一个地方来保存我们的全局参数和选项，而有一个单独的文件来处理这一点是一个完美的解决方案。当代码变得更长更复杂时，这会更有意义。
- en: 'Second, we present the code in `tools.py`:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们展示`tools.py`中的代码：
- en: '[PRE15]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here, we reference two variables from the `variable.py` file, which are `variables.breakpointsFile`
    and `variables.maximumCardinality`:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们引用了`variable.py`文件中的两个变量，分别是`variables.breakpointsFile`和`variables.maximumCardinality`：
- en: '[PRE16]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This is a helper function that we use when we want to make sure that a value
    is a power of 2:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个辅助函数，我们在想要确保一个值是2的幂时使用它：
- en: '[PRE17]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `load_sax_alphabet()` function loads the contents of the file with the definitions
    of breakpoints and assigns them to the `variables.elements` variable. The `breakpoints()`
    function returns the breakpoint values when given the cardinality.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`load_sax_alphabet()`函数加载包含断点定义的文件内容，并将它们分配给`variables.elements`变量。`breakpoints()`函数在给定基数时返回断点值。'
- en: As you can see, the code of the entire package is relatively short, which is
    a good thing.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，整个包的代码相对较短，这是一个好事。
- en: In this section, we developed a Python package to compute SAX representations.
    In the next section, we are going to begin working with the `sax` package.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们开发了一个Python包来计算SAX表示。在下一节中，我们将开始使用`sax`包。
- en: Working with the SAX package
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SAX包
- en: Now that we have the SAX package at hand, it is time to use it by developing
    various utilities, starting with a utility that computes the SAX representations
    of the subsequences of a time series.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了SAX包，是时候通过开发各种实用程序来使用它了，从计算时间序列子序列的SAX表示的实用程序开始。
- en: Computing the SAX representations of the subsequences of a time series
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算时间序列子序列的SAX表示
- en: 'In this subsection, we will develop a utility that computes the SAX representations
    for all the subsequences of a time series and also presents their normalized forms.
    The name of the utility is `ts2PAA.py` and contains the following code:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节中，我们将开发一个实用工具，该工具计算时间序列所有子序列的 SAX 表示，并展示它们的归一化形式。该实用工具的名称是 `ts2PAA.py`，包含以下代码：
- en: '[PRE18]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `ts2PAA.py` script takes a time series, breaks it into subsequences, and
    computes the normalized version of each subsequence using `sax.normalize()`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`ts2PAA.py` 脚本接受一个时间序列，将其分割成子序列，并使用 `sax.normalize()` 计算每个子序列的归一化版本。'
- en: 'The output of `ts2PAA.py` is as follows (some output is omitted for brevity):'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`ts2PAA.py` 的输出如下（为了简洁，省略了一些输出）：'
- en: '[PRE19]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The previous output shows the SAX representation, the original subsequence,
    and the normalized version of the subsequence for all the subsequences of a time
    series. Each subsequence is on a separate line.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的输出显示了时间序列所有子序列的 SAX 表示、原始子序列和子序列的归一化版本。每个子序列都在单独的一行上。
- en: Using Python packages
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Python 包
- en: Most of the chapters that follow will need the SAX package we developed here.
    For reasons of simplicity, we will copy the SAX package implementation into all
    directories that use that package. This might not be the best practice on production
    systems where we want a single copy of each software or package, but it is the
    best practice when learning and experimenting.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的大多数章节都需要我们在这里开发的 SAX 包。出于简单起见，我们将 SAX 包的实现复制到所有使用该包的目录中。在希望每个软件或包只有一个副本的生产系统中，这可能不是最佳实践，但在学习和实验时是最佳实践。
- en: So far, we have learned how to use the basic functionality of the `sax` package.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了如何使用 `sax` 包的基本功能。
- en: The next section presents a utility that counts the SAX representations of the
    subsequences of a time series and prints the results.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节介绍了一个实用工具，该工具用于计算时间序列子序列的 SAX 表示并打印结果。
- en: Counting the SAX representations of a time series
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算时间序列的 SAX 表示
- en: This section of the chapter presents a utility that counts the SAX representations
    of a time series. The Python data structure behind the logic of the utility is
    a dictionary, where the keys are the SAX representations converted into strings
    and the values are integers.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 本章本节介绍了用于计算时间序列 SAX 表示的实用工具。该实用工具背后的逻辑所使用的 Python 数据结构是一个字典，其中键是转换为字符串的 SAX
    表示，值是整数。
- en: 'The code for `counting.py` is as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`counting.py` 的代码如下：'
- en: '[PRE20]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `for` loop splits the time series into subsequences and computes the SAX
    representation of each subsequence using `sax.createPAA()`, before updating the
    relevant counter in the `KEYS` dictionary. The `tempSAXword = tempSAXword[:-1]`
    statement removes an unneeded underscore character from the SAX representation.
    Finally, we print the content of the `KEYS` dictionary.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`for` 循环将时间序列分割成子序列，并使用 `sax.createPAA()` 计算每个子序列的 SAX 表示，然后更新 `KEYS` 字典中的相关计数器。`tempSAXword
    = tempSAXword[:-1]` 语句从 SAX 表示中移除一个不需要的下划线字符。最后，我们打印 `KEYS` 字典的内容。'
- en: 'The output of `counting.py` should be similar to the following:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`counting.py` 的输出应类似于以下内容：'
- en: '[PRE21]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: What does this output tell us?
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出告诉我们什么？
- en: For a time series with 50 elements (`ts1.gz`) and a sliding window size of 4,
    there exist `18` subsequences with the `10_01` SAX representation, `8` subsequences
    with the `11_00` SAX representation, `14` subsequences with the `01_10` SAX representation,
    and `7` subsequences with the `00_11` SAX representation. For easier comparison,
    and to be able to use a SAX representation as a key to a dictionary, we convert
    `[01 10]` into the `01_10` string, `[11 00]` into `11_00`, and so on.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 对于包含 50 个元素的时间序列 (`ts1.gz`) 和滑动窗口大小为 4 的情况，存在 `18` 个具有 `10_01` SAX 表示的子序列，`8`
    个具有 `11_00` SAX 表示的子序列，`14` 个具有 `01_10` SAX 表示的子序列，以及 `7` 个具有 `00_11` SAX 表示的子序列。为了便于比较，并且能够将
    SAX 表示用作字典的键，我们将 `[01 10]` 转换为 `01_10` 字符串，将 `[11 00]` 转换为 `11_00`，依此类推。
- en: How many subsequences does a time series have?
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 时间序列有多少个子序列？
- en: Keep in mind that given a time series with `n` elements and a sliding window
    size of `w`, the total number of subsequences is `n – w +` `1`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，给定一个包含 `n` 个元素的时间序列和滑动窗口大小为 `w`，子序列的总数是 `n – w + 1`。
- en: '`counting.py` can be used for many practical tasks and will be updated in [*Chapter
    3*](B14769_03.xhtml#_idTextAnchor081).'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`counting.py` 可以用于许多实际任务，并将更新在 [*第 3 章*](B14769_03.xhtml#_idTextAnchor081)
    中。'
- en: The next section discusses a handy Python package that can help us learn more
    about processing our time series from a statistical point of view.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个章节讨论了一个实用的 Python 包，可以帮助我们从统计角度更深入地了解处理时间序列。
- en: The tsfresh Python package
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`tsfresh` Python 包'
- en: This is a bonus section not directly related to the subject of the book, but
    it is helpful, nonetheless. It is about a handy Python package called `tsfresh`,
    which can give you a good overview of your time series from a statistical perspective.
    We are not going to present all the capabilities of `tsfresh`, just the ones that
    you can easily use to get information about your time series data – at this point,
    you might need to install `tsfresh` on your machine. Keep in mind that the `tsfresh`
    package has lots of package dependencies.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个与本书主题不直接相关的附加章节，但仍然很有帮助。它介绍了一个实用的 Python 包，名为 `tsfresh`，可以从统计角度给你提供一个关于时间序列的概览。我们不会展示
    `tsfresh` 的所有功能，只是介绍那些你可以轻松使用来获取时间序列数据信息的部分——在这个阶段，你可能需要在你的机器上安装 `tsfresh`。请记住，`tsfresh`
    包有很多依赖包。
- en: 'So, we are going to compute the following properties of a dataset – in this
    case, a time series:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将计算数据集的以下属性——在这种情况下，是一个时间序列：
- en: '**Mean value**: The mean value of a dataset is the summary of all the values
    divided by the number of values.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**平均值**：数据集的平均值是所有值的总和除以值的数量。'
- en: '**Standard deviation**: The standard deviation of a dataset measures the amount
    of variation in it. There is a formula to calculate the standard deviation, but
    we usually compute it using a function from a Python package.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标准差**：数据集的标准差衡量其变化量。有一个计算标准差的公式，但我们通常使用 Python 包中的函数来计算它。'
- en: '**Skewness**: The skewness of a dataset is a measure of the asymmetry in it.
    The value of skewness can be positive, negative, zero, or undefined.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**偏度**：数据集的偏度是衡量其不对称性的一个指标。偏度的值可以是正的、负的、零或未定义。'
- en: '**Kurtosis**: The kurtosis of a dataset is a measure of the tailedness of a
    dataset. In more mathematical terms, kurtosis measures the heaviness of the tail
    of a distribution compared to a normal distribution.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**峰度**：数据集的峰度是衡量数据集尾部特性的一个指标。用更数学化的术语来说，峰度衡量的是分布尾部相对于正态分布的厚重程度。'
- en: All these quantities will make much more sense once you plot your data, which
    is left as an exercise for you; otherwise, they will be just numbers. So, now
    that we know some basic statistic terms, let us present a Python script that calculates
    all these quantities for a time series.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些量在你绘制数据后会有更多的意义，这留给你作为练习；否则，它们只是数字。所以，现在我们了解了一些基本的统计术语，让我们展示一个 Python 脚本，它可以计算时间序列的所有这些量。
- en: 'The Python code for `using_tsfresh.py` is as follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`using_tsfresh.py` 的 Python 代码如下：'
- en: '[PRE22]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The output of `using_tsfresh.py` when processing `ts1.gz` should look similar
    to the following:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `using_tsfresh.py` 处理 `ts1.gz` 的输出应该类似于以下内容：
- en: '[PRE23]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `tsfresh` package can do many more things; we have just presented the tip
    of the iceberg of the capabilities of `tsfresh`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`tsfresh` 包可以做更多的事情；我们只是展示了 `tsfresh` 功能的冰山一角。'
- en: The next section is about creating a histogram of a time series.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个章节是关于创建时间序列的直方图。
- en: Creating a histogram of a time series
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建时间序列的直方图
- en: This is another bonus section, where we will illustrate how to create a histogram
    of a time series to get a better overview of its values.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个另一个附加章节，我们将展示如何创建时间序列的直方图，以更好地了解其值。
- en: A **histogram**, which looks a lot like a bar chart, defines buckets (bins)
    and counts the number of values that fall into each bin. Strictly speaking, a
    histogram allows you to understand your data by creating a plot of the **distribution
    of values**. You can see the maximum and the minimum values, as well as find out
    data patterns, just by looking at a histogram.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '**直方图**，看起来很像条形图，定义了桶（bin）并计算落入每个桶中的值的数量。严格来说，直方图通过创建值的**分布**图来帮助你理解你的数据。你可以通过查看直方图看到最大值和最小值，以及发现数据模式。'
- en: 'The Python code for `histogram.py` is as follows:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`histogram.py` 的 Python 代码如下：'
- en: '[PRE24]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The third argument of the `np.linespace()` function helps us define the number
    of bins the histogram has. The first parameter is the minimum value, and the second
    parameter is the maximum value of the presented samples. This script does not
    save its output in a file but, instead, opens a window on your GUI to display
    the output. The `plt.hist()` function creates the histogram, whereas the `plt.legend()`
    function puts the legend in the output.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`np.linspace()` 函数的第三个参数帮助我们定义直方图的bins数量。第一个参数是最小值，第二个参数是展示样本的最大值。此脚本不会将其输出保存到文件中，而是打开一个GUI窗口来显示输出。`plt.hist()`
    函数创建直方图，而 `plt.legend()` 函数将图例放置在输出中。'
- en: 'A sample output of `histogram.py` can be seen in *Figure 2**.5*:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`histogram.py` 的一个示例输出可以在 *图2.5* 中看到：'
- en: '![Figure 2.5 – A sample histogram](img/Figure_2.5_B14769.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![图2.5 – 一个示例直方图](img/Figure_2.5_B14769.jpg)'
- en: Figure 2.5 – A sample histogram
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5 – 一个示例直方图
- en: 'A different sample output from `histogram.py` can be seen in *Figure 2**.6*:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`histogram.py` 的另一个示例输出可以在 *图2.6* 中看到：'
- en: '![Figure 2.6 – A sample histogram](img/Figure_2.6_B14769.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![图2.6 – 一个示例直方图](img/Figure_2.6_B14769.jpg)'
- en: Figure 2.6 – A sample histogram
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6 – 一个示例直方图
- en: So, what is the difference between the histograms in *Figure 2**.5* and *Figure
    2**.6*? There exist many differences, including the fact that the histogram in
    *Figure 2**.5* does not have empty bins and it contains both negative and positive
    values. On the other hand, the histogram in *Figure 2**.6* contains negative values
    only that are far away from 0.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，*图2.5* 和 *图2.6* 中的直方图有什么区别？存在许多差异，包括*图2.5* 中的直方图没有空bins，并且包含负值和正值。另一方面，*图2.6*
    中的直方图只包含远离0的负值。
- en: Now that we know about histograms, let us learn about another interesting statistical
    quantity – *percentiles*.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了直方图，让我们学习另一个有趣的统计量 – *百分位数*。
- en: Calculating the percentiles of a time series
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算时间序列的百分位数
- en: In this last bonus section of this chapter, we are going to learn how to compute
    the percentiles of a time series or a list (and if you find the information presented
    here difficult to understand, feel free to skip it). The main usage of such information
    is to better understand your time series data.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章最后一个附加部分，我们将学习如何计算时间序列或列表的百分位数（如果你觉得这里提供的信息难以理解，请随意跳过）。此类信息的主要用途是更好地理解你的时间序列数据。
- en: A *percentile* is a score where a given percentage of scores in the frequency
    distribution falls. Therefore, the 20th percentile is the score below which 20%
    of the scores of the distribution of the values of a dataset falls.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '*百分位数*是一个分数，其中给定百分比的分数在频率分布中。因此，20百分位数是低于该分数的分数，占分布中数据集值的20%。'
- en: A **quartile** is one of the following three percentiles – 25%, 50%, or 75%.
    So, we have the first quartile, the second quartile, and the third quartile, respectively.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '**四分位数**是以下三个百分位数之一 – 25%，50%，或75%。因此，我们有第一四分位数，第二四分位数和第三四分位数，分别。'
- en: Both percentiles and quartiles are calculated in datasets sorted in ascending
    order. Even if you have not sorted that dataset, the relevant NumPy function,
    which is called `quantile()`, does that behind the scenes.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 百分位数和四分位数都是在按升序排序的数据集中计算的。即使你没有对那个数据集进行排序，相关的NumPy函数，即 `quantile()`，也会在幕后完成排序。
- en: 'The Python code of `percentiles.py` is as follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`percentiles.py` 的Python代码如下：'
- en: '[PRE25]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: All the work is done by the `quantile()` function of the NumPy package. Among
    other things, `quantile()` appropriately arranges its elements before performing
    any calculations. We do not know what happens internally, but most likely, `quantile()`
    sorts its input in ascending order.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 所有工作都是由NumPy包中的 `quantile()` 函数完成的。除了其他事情之外，`quantile()` 在进行任何计算之前都会适当地排列其元素。我们不知道内部发生了什么，但很可能是
    `quantile()` 会将其输入按升序排序。
- en: The first parameter of `quantile()` is the NumPy array, and its second parameter
    is the percentage (percentile) that interests us. A 25% percentage is equal to
    the first quantile, a 50% percentage is equal to the second quantile, and a 75%
    percentage is equal to the third quantile. A 1% percentage is equal to the 1%
    percentile, and so on.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`quantile()` 的第一个参数是NumPy数组，第二个参数是我们感兴趣的百分比（百分位数）。25%的百分比等于第一个四分位数，50%的百分比等于第二个四分位数，75%的百分比等于第三个四分位数。1%的百分比等于1%的百分位数，依此类推。'
- en: 'The output of `percentiles.py` is as follows:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`percentiles.py` 的输出如下：'
- en: '[PRE26]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Summary
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter included the theory behind and practical implementation of SAX
    and an understanding of a time series from a statistical viewpoint. As the iSAX
    index construction is based on the SAX representation, we cannot construct an
    iSAX index without computing SAX representations.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包括了SAX的理论背景和实际实现，以及从统计角度理解时间序列。由于iSAX索引的构建基于SAX表示，我们无法在不计算SAX表示的情况下构建iSAX索引。
- en: Before you begin reading [*Chapter 3*](B14769_03.xhtml#_idTextAnchor081), please
    make sure that you know how to calculate the SAX representation of a time series
    or a subsequence, given the sliding window size, the number of segments, and the
    cardinality.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在你开始阅读[*第3章*](B14769_03.xhtml#_idTextAnchor081)之前，请确保你知道如何根据滑动窗口大小、段数和基数计算时间序列或子序列的SAX表示。
- en: The next chapter contains the theory related to the iSAX index, shows you how
    to manually construct an iSAX index (which you will find very entertaining), and
    includes the development of some handy utilities.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章包含与iSAX索引相关的理论，展示了如何手动构建iSAX索引（你会发现这非常有趣），并包括了一些实用的工具开发。
- en: Useful links
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有用链接
- en: 'About Python packages: [https://docs.python.org/3/reference/import.xhtml](https://docs.python.org/3/reference/import.xhtml)'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于Python包：[https://docs.python.org/3/reference/import.xhtml](https://docs.python.org/3/reference/import.xhtml)
- en: 'The `tsfresh` package: [https://pypi.org/project/tsfresh/](https://pypi.org/project/tsfresh/)'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tsfresh` 包：[https://pypi.org/project/tsfresh/](https://pypi.org/project/tsfresh/)'
- en: The documentation for the `tsfresh` package can be found at [https://tsfresh.readthedocs.io/en/latest/](https://tsfresh.readthedocs.io/en/latest/)
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tsfresh` 包的文档可以在[https://tsfresh.readthedocs.io/en/latest/](https://tsfresh.readthedocs.io/en/latest/)找到。'
- en: 'The `scipy` package: [https://pypi.org/project/scipy/](https://pypi.org/project/scipy/)
    and [https://scipy.org/](https://scipy.org/)'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scipy` 包：[https://pypi.org/project/scipy/](https://pypi.org/project/scipy/)
    和 [https://scipy.org/](https://scipy.org/)'
- en: 'Normalization: [https://en.wikipedia.org/wiki/Normalization_(statistics)](https://en.wikipedia.org/wiki/Normalization_(statistics))'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 归一化：[https://en.wikipedia.org/wiki/Normalization_(statistics)](https://en.wikipedia.org/wiki/Normalization_(statistics))
- en: 'Histogram: [https://en.wikipedia.org/wiki/Histogram](https://en.wikipedia.org/wiki/Histogram)'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直方图：[https://en.wikipedia.org/wiki/Histogram](https://en.wikipedia.org/wiki/Histogram)
- en: 'Percentile: [https://en.wikipedia.org/wiki/Percentile](https://en.wikipedia.org/wiki/Percentile)'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 百分位数：[https://en.wikipedia.org/wiki/Percentile](https://en.wikipedia.org/wiki/Percentile)
- en: 'Normal distribution: [https://en.wikipedia.org/wiki/Normal_distribution](https://en.wikipedia.org/wiki/Normal_distribution)'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正态分布：[https://en.wikipedia.org/wiki/Normal_distribution](https://en.wikipedia.org/wiki/Normal_distribution)
- en: Exercises
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'Try to solve the following exercises in Python:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在Python中解决以下练习：
- en: Divide *by hand* the *y* axis for the 16 = 24 cardinality. Did you divide it
    into 16 areas or 17 areas? How many breakpoints did you use?
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动将 *y* 轴划分为16 = 2^4的基数。你是否将其划分为16个区域或17个区域？你使用了多少个断点？
- en: Divide *by hand* the *y* axis for the 64 = 26 cardinality. Did you divide it
    into 64 areas?
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动将 *y* 轴划分为64 = 2^6的基数。你是否将其划分为64个区域？
- en: Use the `cardinality.py` utility to plot the breakpoints of the 16 = 24 cardinality.
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `cardinality.py` 工具绘制16 = 2^4基数断点。
- en: Use the `cardinality.py` utility to plot the breakpoints of the 128 = 2 7 cardinality.
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `cardinality.py` 工具绘制128 = 2^7基数断点。
- en: Find the SAX representation of the `{0, 2, -1, 2, 3, 4, -2, 4}` subsequence
    using 4 segments and a cardinality of 4 (2 2). Do not forget to normalize it first.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用4个段和基数4（2^2）找到子序列 `{0, 2, -1, 2, 3, 4, -2, 4}` 的SAX表示，别忘了先进行归一化。
- en: Find the SAX representation of the `{0, 2, -1, 2, 3, 4, -2, 4}` subsequence
    using 2 segments and a cardinality of 2 (2 1). Do not forget to normalize it first.
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用2个段和基数2（2^1）找到子序列 `{0, 2, -1, 2, 3, 4, -2, 4}` 的SAX表示，别忘了先进行归一化。
- en: Find the SAX representation of the `{0, 2, -1, 2, 3, 1, -2, -4}` subsequence
    using 4 segments and a cardinality of 2.
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用4个段和基数2找到子序列 `{0, 2, -1, 2, 3, 1, -2, -4}` 的SAX表示。
- en: Given the `{0, -1, 1.5, -1.5, 0, 1, 0}` time series and a sliding window size
    of 4, find the SAX representation of all its subsequences using 2 segments and
    a cardinality of 2.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定时间序列 `{0, -1, 1.5, -1.5, 0, 1, 0}` 和滑动窗口大小为4，使用2个段和基数2找到所有子序列的SAX表示。
- en: Create a synthetic time series and process it using `using_tsfresh.py`.
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个合成的时间序列并使用 `using_tsfresh.py` 处理它。
- en: Create a synthetic time series with 1,000 elements and process it using `histogram.py`.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个包含1,000个元素的合成时间序列并使用 `histogram.py` 处理它。
- en: Create a synthetic time series with 5,000 elements and process it using `histogram.py`.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建包含5,000个元素的合成时间序列，并使用`histogram.py`进行处理。
- en: Create a synthetic time series with 10,000 elements and process it using `counting.py`.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建包含10,000个元素的合成时间序列，并使用`counting.py`进行处理。
- en: Create a synthetic time series with 100 elements and process it using `percentiles.py`.
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建包含100个元素的合成时间序列，并使用`percentiles.py`进行处理。
- en: Create a synthetic dataset with 100 elements and examine it using `counting.py`.
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建包含100个元素的合成数据集，并使用`counting.py`进行检验。
- en: Modify `histogram.py` to save its graphical output in a PNG file.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改`histogram.py`以将其图形输出保存为PNG文件。
- en: Plot a time series using `histogram.py` and then process it using `using_tsfresh.py`
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`histogram.py`绘制时间序列，然后使用`using_tsfresh.py`进行处理。
