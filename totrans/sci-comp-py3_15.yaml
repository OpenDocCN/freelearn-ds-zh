- en: Chapter 15. Symbolic Computations - SymPy
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will give a brief introduction on using Python for symbolic
    computations. There is powerful software in the market for performing symbolic
    computations, for example, Maple^(TM) or Mathematica^(TM). But sometimes, it might
    be favorable to make symbolic calculations in the language or framework you are
    used to. At this stage of this book, we assume that this language is Python, so
    we seek for a tool in Python - the SymPy module.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: A complete description of SymPy - if possible, would fill an entire book, and
    that is not the purpose of this chapter. Instead, we will stake out a path into
    this tool by some guiding examples, giving a flavor of the potential of this tool
    as a complement to NumPy and SciPy.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: What are symbolic computations?
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All computations we did so far in this book were so-called numeric computations.
    These were a sequence of operations mainly on floating-point numbers. It is the
    nature of numeric computations that the result is an approximation of the exact
    solution.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Symbolic computations operate on formulas or symbols by transforming them as
    taught in algebra or calculus into other formulas. The last step of these transformations
    might then require that numbers are inserted and a numeric evaluation is performed.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: 'We illustrate the difference by computing this definite integral:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: '![What are symbolic computations?](img/integral.jpg)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
- en: 'Symbolically this expression can be transformed by considering the primitive
    function of the integrand:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: '![What are symbolic computations?](img/primitive.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
- en: 'We now obtain a formula for the definite integral by inserting the integral
    bounds:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '![What are symbolic computations?](img/integralsolution.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
- en: This is called a closed-form expression for the integral. Very few mathematical
    problems have a solution that can be given in a closed-form expression. It is
    the exact value of the integral without any approximation. Also no error is introduced
    by representing real numbers as floating-point numbers, which would otherwise
    introduce round-off errors.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: 'Approximation and round-off come into play at the very last moment, when this
    expression needs to be evaluated. The square root and the *arctan* can only be
    evaluated approximately by numerical methods. Such an evaluation gives the final
    result up to a certain (often unknown) precision:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '![What are symbolic computations?](img/numintegral.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
- en: 'On the other hand, numerical computation would directly approximate the definite
    integral by some approximation method, for example, Simpson''s rule, and deliver
    a numeric result, often with an estimate of error. In Python, this is done by
    these commands:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: They return the value *0.9896614396122965* and an estimate for the error bound
    *1.1735663442283496 10^(-08).*
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the comparison of numeric and symbolic approximation:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '![What are symbolic computations?](img/symbolic-1.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.1: Symbolic and numeric quadrature'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Elaborating an example in SymPy
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To begin with, let's elaborate the previous example in SymPy which are explained
    the steps.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we have to import the module:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The second command makes sure that formulas are presented in a graphical way,
    if possible. Then, we generate a symbol and define the integrand:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`x` is now a Python object of type `Symbol` and `f` is a SymPy `Lambda` function
    (note the command starting with a capital letter).'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we start with the symbolic computation of the integral:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Depending on your working environment, the result is presented in different
    ways; refer to following screenshot (*Figure 15.2*) which represents two different
    result of SymPy formula in different environments:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '![Elaborating an example in SymPy](img/screendump.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.2: Two screenshots of a SymPy presentation of a formula in two different
    environments.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'We can check by differentiation whether the result is correct. To this end,
    we assign a name to the primitive function and differentiate with respect to *x*:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The result obtained will be as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '![Elaborating an example in SymPy](img/unsimplifiedsolution.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
- en: 'which can be simplified by using the following command:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: to
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '![Elaborating an example in SymPy](img/integrand.jpg).'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: The result we expected.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: 'The definite integral is obtained by using the following command:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'It gives the following output after simplification with `simplify`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '![Elaborating an example in SymPy](img/solution2.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
- en: 'To obtain a numerical value, we finally evaluate this expression to a floating-point
    number:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Basic elements of SymPy
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here we introduce the basic elements of SymPy. You will find it favorable to
    be already familiar with classes and data types in Python.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Symbols - the basis of all formulas
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The basic construction element to build a formula in SymPy is the symbol. As
    we saw in the introductory example, a symbol is created by the command `symbols`.
    This SymPy command generates symbol objects from a given string:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'It is actually a short form of following command:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'followed by a unpacking step to obtain variables:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The arguments of the command define the string representation of the symbol.
    The variable name of the symbol is often chosen identical to its string representation,
    but this is not required by the language:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, we also defined that the symbol is assumed to be an integer.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: 'An entire set of symbols can be defined in a very compact way:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Similarly, symbols for indexed variables can be defined by using the following:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This gives a tuple of symbols,
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '![Symbols - the basis of all formulas](img/tupleofsymbols.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
- en: The rules for the range of the indexes are those we saw earlier in this book
    when working with slices (refer [Chapter 3](ch03.html "Chapter 3. Container Types"),
    *Container Types* for more details).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: Numbers
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Python evaluates operations on numbers directly and introduces unavoidably
    rounding errors. These would obstruct all symbolic calculations. This is avoided
    when we  `sympify` numbers:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `sympify` command converts an integer to an object of type `sympy.core.numbers.Integer`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Instead of writing 1/3 as an operation of two integers, it can also be represented
    directly as a rational number by `Rational(1,3)`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Functions
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SymPy distinguishes between defined and undefined functions. The term undefined
    functions (might be a bit misleading) refers to well-defined Python objects for
    generic functions that have no special properties.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: An example of a function with special properties is `atan` or the `Lambda` function
    used in the introductory example of this chapter.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: 'Note the different names for the different implementations of the same mathematical
    function: `sympy.atan` and `scipy.arctan`.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: Undefined functions
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A symbol for an undefined function is created by giving the `symbols` command
    an extra class argument:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The same can be achieved by using the `Function` constructor:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: with undefined functions, we can evaluate general rules of calculus.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let us evaluate the following expression:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '![Undefined functions](img/chainrule1.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
- en: 'This is symbolically computed in Python by using the following command:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'When executed, the previous code returns the following as output:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '![Undefined functions](img/chainrule2.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
- en: This example shows how the product rule and the chain rule were applied.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: 'We can even use undefined functions as a function in several variables, for
    example:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'which returns the following output:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '![Undefined functions](img/sev_variables.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
- en: Note
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note the use of the star operator to unpack a tuple to form *f* with arguments;
    refer to section *Anonymous functions*, [Chapter 7](ch07.html "Chapter 7. Functions"),
    *Functions*
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: 'By using list comprehension, we can construct a list of all partial derivatives
    of *f* :'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This returns a list with the elements of ![Undefined functions](img/nabla_f.jpg)
    (the gradient of *f*):'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '![Undefined functions](img/nabla_f_2.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
- en: 'The command can also be rewritten by using the `diff` method of the `Function`
    object:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Another method is Taylor series expansion :'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This returns Taylor''s formula, together with the rest term expressed by the
    Landau symbol:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '![Undefined functions](img/taylor1.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
- en: Elementary Functions
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Examples for elementary functions in SymPy are trigonometric functions and
    their inverses. The following example shows how simplify acts on expression which
    include elementary function:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Here is another example for the use of elementary functions:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If you use SciPy and SymPy together, we strongly recommend that you use them
    in different namespaces:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Lambda - functions
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In section *Anonymous functions* of [Chapter 7](ch07.html "Chapter 7. Functions"),
    *Functions*, we saw how to define so-called anonymous functions in Python. The
    counterpart in SymPy is done by the `Lambda` command. Note the difference; `lambda`
    is a keyword while `Lambda` is a constructor.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: The command `Lambda` takes two arguments, the symbol of the function's independent
    variable, and a SymPy expression to evaluate the function.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example that defines air resistance (also called drag) as a function
    of speed:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '`f_drag` is displayed as an expression:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '![Lambda - functions](img/f_drag.jpg).'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: 'This function can be evaluated in the usual way by providing it with an argument:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'which will results in given expression:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '![Lambda - functions](img/f_drag2.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
- en: 'It is also possible to create functions in several variables by just providing
    it with several arguments as for example:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'A call to this function can be done in two ways, either by directly providing
    several arguments:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'or by unpacking a tuple or list:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Matrix objects in SymPy make it even possible to define vector-valued functions:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This enables us to compute Jacobians:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Which gives the following expression as output:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '![Lambda - functions](img/jacobian.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
- en: 'In the case of more variables, it is convenient to use a more compact form
    to define the function:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Symbolic Linear Algebra
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Symbolic linear algebra is supported by SymPy''s `matrix` data type which we
    will introduce first. Then we will present some linear algebra methods as examples
    for the broad spectrum of possibilities for symbolic computations in this field:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Symbolic matrices
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We briefly met the `matrix` data type when we discussed vector valued functions.
    There, we saw it in its simplest form, which converts a list of lists into a matrix.
    To have an example, let''s construct a rotation matrix:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: When working with SymPy matrices we have to note that the operator `*` performs
    matrix multiplications and is not acting as an elementwise multiplication which
    is the case for NumPy arrays.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: 'The above defined rotation matrix can be checked for orthogonality, by using
    this matrix multiplication and the transpose of a matrix:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The previous example shows how a matrix is transposed and how the identity
    matrix is created. Alternatively, we could have checked whether its inverse is
    its transpose, which can be done as:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Another way to set up a matrix is by providing a list of symbols and a shape:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This creates the following matrix:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '![Symbolic matrices](img/matrixM.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
- en: 'A third way to create a matrix is by generating its entries by a given function.
    The syntax is:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We exemplify the above matrix by considering Toeplitz matrix is a matrix with
    constant diagonals. Given a *2n-1 * data vector *a*, its elements are defined
    as
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '![Symbolic matrices](img/Toeplitz.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
- en: 'In SymPy, the matrix can be defined by directly making use of this definition:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Executing the previous code gives `toeplitz(5)`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '![Symbolic matrices](img/Toeplitz-new.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
- en: 'One clearly sees the desired structures; all elements along subdiagonals and
    superdiagonals are the same. We can access matrix elements by the indexes and
    slices according to the Python syntax introduced in the section *Lists* of [Chapter
    3](ch03.html "Chapter 3. Container Types"), *Container Type*:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Examples for Linear Algebra Methods in SymPy
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The basic task in linear algebra is to solve linear equation systems:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '![Examples for Linear Algebra Methods in SymPy](img/linsys.jpg).'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us do this symbolically for a 3 *×* 3 matrix:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The output of this relatively small problem is already merely readable which
    can be seen in the following expression:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '![Examples for Linear Algebra Methods in SymPy](img/huge_formula.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
- en: 'Again, the use of  `simplify` command helps us to detect canceling terms and
    to collect common factors:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'which will result in the following output which looks much better:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '![Examples for Linear Algebra Methods in SymPy](img/less_huge_formula.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
- en: Symbolic computations becomes very slow with increase in matrix dimensions.
    For dimensions bigger than 15, there might even occur memory problems.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding figure (*Figure 15.3*) illustrates the differences in CPU time
    between symbolically and numerically solving a linear system:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '![Examples for Linear Algebra Methods in SymPy](img/linsys_CPU.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.3: CPU time for numerically and symbolically solving a linear system.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Substitutions
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let us first consider a simple symbolic expression:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: What happens if we set `x = 0` ?  We observe that `b` did not change. What we
    did was that we changed the Python variable `x`. It now no longer refers to the
    symbol object but to the integer object *0*. The symbol represented by the string
    `'x'`  remains unaltered, and so does `b`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, altering an expression by replacing symbols by numbers, other symbols,
    or expressions is done by a special substitution method which can be seen in following
    code:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This method takes one or two arguments:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Dictionaries as arguments allow us to make several substitutions in one step:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'As items in dictionaries have no defined order - one never knows which would
    be the first - there is a need for assuring that permuting the items would not
    affect the substitution result. Therefore in SymPy, substitutions are first made
    within the dictionary and then on the expression. This is demonstrated by the
    following example:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Both substitutions return the same result, that is,
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '![Substitutions](img/subs_result.jpg) .'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: 'A third alternative to define multiple substitutions is by using a list of
    old-value/ new-value pairs instead:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'It is also possible to substitute entire expressions by others:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'To illustrate substitutions of matrix elements, we take the *5 × 5* Toeplitz
    matrix again:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '![Substitutions](img/Toeplitz.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
- en: Consider the substitution `M.subs(T[0,2],0)`. It changes the symbol object at
    position [0, 2], which is the symbol *a*[2]. It also occurs at two other places,
    which are automatically affected by this substitution.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: 'The given expression is the resulting matrix:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '![Substitutions](img/mod_toeplitz.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
- en: 'Alternatively we can create a variable for this symbol and use it in the substitution:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'As a more complex example for substitution we describe, how to turn the Toeplitz
    matrix into a tridiagonal Toeplitz matrix*.* This can be done in the following
    ways: First we generate a list of those symbols that we want to substitute; and
    then we use the `zip` command to generate a list of pairs. Finally we substitute
    by giving a list of old-value/new-value pairs as described above:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'This gives the following matrix as result:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '![Substitutions](img/toeplitz_3diag.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
- en: Evaluating symbolic expressions
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the context of scientific computing, there is often the need of first making
    symbolic manipulations and then converting the symbolic result into a floating-point
    number .
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: 'The central tool for evaluating a symbolic expression is `evalf`. It converts
    symbolic expressions to floating-point numbers by using the following:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The data type of the resulting object is `Float` (note the capitalization),
    which is a SymPy data type that allows floating-point numbers with an arbitrary
    number of digits (arbitrary precision). The default precision corresponds to 15
    digits, but it can be changed by giving `evalf` an extra positive integer argument
    specifying the desired precision in terms the numbers of digits,
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: A consequence of working with arbitrary precision is that numbers can be arbitrary
    small, that is, the limits of the classical floating-point representation are
    broken; refer *Floating Point Numbers* section in [Chapter 2](ch02.html "Chapter 2. Variables
    and Basic Types"), *Variables and Basic Types*.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: Interestingly enough,  evaluating a SymPy function with an input of type `Float`
    returns a Float with the same precision as the input. We demonstrate the use of
    this fact in a more elaborated example from numerical analysis.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: 'Example: A study on the convergence order of Newton''s Method'
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An iterative method with iterates *x[n]* is said to converge with order *q*
    with ![Example: A study on the convergence order of Newton''s Method](img/qinN.jpg),
    if there exists a positive constant *C* such that'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '![Example: A study on the convergence order of Newton''s Method](img/orderq.jpg).'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: 'Newton''s method when started with a good initial has order *q* = 2, and for
    certain problems, even *q* = 3\. Newton''s method when applied to the problem
    arctan(*x*) = 0 gives the following iteration scheme:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '![Example: A study on the convergence order of Newton''s Method](img/atanNewton.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
- en: which converges cubically; that is *q* = 3.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: This implies that the number of correct digits triples from iteration to iteration.
    To demonstrate cubic convergence and to numerically determine the constant *C*
    is hardly possible with the standard 16-digit float data type.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code, uses SymPy together with high-precision evaluation instead
    and puts a study on cubic convergence to the extreme:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The result is depicted in the next figure (*Figure 15.4*) which shows that the
    number of correct digits triples from iteration to iteration.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '![Example: A study on the convergence order of Newton''s Method](img/exterem_newton.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.4: A study on the convergence of Newton''s method applied to arctan(x)=0'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: 'This extreme precision requirement (3,000 digits!) enables us to evaluate seven
    terms of the preceding sequence to demonstrate cubic convergence in the following
    way:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The result is a list of seven terms which let us assume that *C =* 2/3:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Converting a symbolic expression into a numeric function
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have seen the numerical evaluation of a symbolic expression is done in
    three steps, first we do some symbolic computations and then we substitute values
    by numbers and do an evaluation to a floating point number by `evalf`.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: The reason for symbolic computations is often that one wants to make parameter
    studies. This requires that the parameter is modified within a given parameter
    range. This requires that an symbolic expression is eventually turned into a numeric
    function.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: A study on the parameter dependency of polynomial coefficients
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We demonstrate a symbolic/ numeric parameter study by an interpolation example
    to introduce the SymPy command `lambdify`. Let us consider the task to interpolate
    the data *x* = [0, *t*, 1] and *y* = [0, 1,-1]. Here, *t* is a free parameter,
    which we will vary over the interval [-0.4, 1.4]. The quadratic interpolation
    polynomial has coefficients depending on this parameter:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '![A study on the parameter dependency of polynomial coefficients](img/polynomial.jpg).'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: 'Using SymPy and the monomial approach described in gives us closed formulas
    for these coefficients:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We obtain a symbolic function for the leading coefficient *a*[2] of the interpolation
    polynomial:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '![A study on the parameter dependency of polynomial coefficients](img/leading_coeff.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
- en: Now it is time to turn the expression into a numeric function, for example,
    to make a plot. This is done by the function `lamdify`.  This function takes two
    arguments, the independent variable  and a SymPy function.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: 'For our example in Python we can write:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'This function can now be plotted, for example, by the following commands:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The preceding figure (*Figure 15.5*) is the result of this parameter study,
    one clearly sees the singularities due to multiple interpolation points, (here
    at *t* = 0 or *t* = 1):'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '![A study on the parameter dependency of polynomial coefficients](img/leading_coeff-1.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.5: The dependency of a polynomial coefficient on the location of
    an interpolation point.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter you were introduced in the world of symbolic computations and
    you got a glimpse of the power of SymPy. By guiding examples you learned how to
    set up symbolic expressions, how to work with symbolic matrices, and you saw how
    to make simplifications. Working with symbolic functions and transforming them
    into numerical evaluations built finally the link to scientific computing and
    floating point results. You experienced the strength of SymPy as you used its
    full integration into Python with its powerful constructs and legible syntax.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您被引入了符号计算的世界，并一瞥了SymPy的强大功能。通过引导示例，您学习了如何设置符号表达式，如何处理符号矩阵，以及如何进行简化。通过使用符号函数并将它们转换为数值评估，最终建立了与科学计算和浮点结果的联系。当您使用其与Python的强大构造和易读语法完全集成时，您体验到了SymPy的强大之处。
- en: Consider this last chapter as an appetizer rather than a complete menu. We hope
    you became hungry for future fascinating programming challenges in scientific
    computing and mathematics.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 将这一章视为开胃菜而非完整菜单。我们希望您对科学计算和数学中未来令人着迷的编程挑战产生了渴望。
