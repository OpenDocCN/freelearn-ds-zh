- en: Chapter 15. Symbolic Computations - SymPy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will give a brief introduction on using Python for symbolic
    computations. There is powerful software in the market for performing symbolic
    computations, for example, Maple^(TM) or Mathematica^(TM). But sometimes, it might
    be favorable to make symbolic calculations in the language or framework you are
    used to. At this stage of this book, we assume that this language is Python, so
    we seek for a tool in Python - the SymPy module.
  prefs: []
  type: TYPE_NORMAL
- en: A complete description of SymPy - if possible, would fill an entire book, and
    that is not the purpose of this chapter. Instead, we will stake out a path into
    this tool by some guiding examples, giving a flavor of the potential of this tool
    as a complement to NumPy and SciPy.
  prefs: []
  type: TYPE_NORMAL
- en: What are symbolic computations?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All computations we did so far in this book were so-called numeric computations.
    These were a sequence of operations mainly on floating-point numbers. It is the
    nature of numeric computations that the result is an approximation of the exact
    solution.
  prefs: []
  type: TYPE_NORMAL
- en: Symbolic computations operate on formulas or symbols by transforming them as
    taught in algebra or calculus into other formulas. The last step of these transformations
    might then require that numbers are inserted and a numeric evaluation is performed.
  prefs: []
  type: TYPE_NORMAL
- en: 'We illustrate the difference by computing this definite integral:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What are symbolic computations?](img/integral.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Symbolically this expression can be transformed by considering the primitive
    function of the integrand:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What are symbolic computations?](img/primitive.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We now obtain a formula for the definite integral by inserting the integral
    bounds:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What are symbolic computations?](img/integralsolution.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is called a closed-form expression for the integral. Very few mathematical
    problems have a solution that can be given in a closed-form expression. It is
    the exact value of the integral without any approximation. Also no error is introduced
    by representing real numbers as floating-point numbers, which would otherwise
    introduce round-off errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Approximation and round-off come into play at the very last moment, when this
    expression needs to be evaluated. The square root and the *arctan* can only be
    evaluated approximately by numerical methods. Such an evaluation gives the final
    result up to a certain (often unknown) precision:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What are symbolic computations?](img/numintegral.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'On the other hand, numerical computation would directly approximate the definite
    integral by some approximation method, for example, Simpson''s rule, and deliver
    a numeric result, often with an estimate of error. In Python, this is done by
    these commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: They return the value *0.9896614396122965* and an estimate for the error bound
    *1.1735663442283496 10^(-08).*
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the comparison of numeric and symbolic approximation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What are symbolic computations?](img/symbolic-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.1: Symbolic and numeric quadrature'
  prefs: []
  type: TYPE_NORMAL
- en: Elaborating an example in SymPy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To begin with, let's elaborate the previous example in SymPy which are explained
    the steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we have to import the module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The second command makes sure that formulas are presented in a graphical way,
    if possible. Then, we generate a symbol and define the integrand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`x` is now a Python object of type `Symbol` and `f` is a SymPy `Lambda` function
    (note the command starting with a capital letter).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we start with the symbolic computation of the integral:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Depending on your working environment, the result is presented in different
    ways; refer to following screenshot (*Figure 15.2*) which represents two different
    result of SymPy formula in different environments:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Elaborating an example in SymPy](img/screendump.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.2: Two screenshots of a SymPy presentation of a formula in two different
    environments.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can check by differentiation whether the result is correct. To this end,
    we assign a name to the primitive function and differentiate with respect to *x*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The result obtained will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Elaborating an example in SymPy](img/unsimplifiedsolution.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'which can be simplified by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: to
  prefs: []
  type: TYPE_NORMAL
- en: '![Elaborating an example in SymPy](img/integrand.jpg).'
  prefs: []
  type: TYPE_NORMAL
- en: The result we expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'The definite integral is obtained by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'It gives the following output after simplification with `simplify`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Elaborating an example in SymPy](img/solution2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To obtain a numerical value, we finally evaluate this expression to a floating-point
    number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Basic elements of SymPy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here we introduce the basic elements of SymPy. You will find it favorable to
    be already familiar with classes and data types in Python.
  prefs: []
  type: TYPE_NORMAL
- en: Symbols - the basis of all formulas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The basic construction element to build a formula in SymPy is the symbol. As
    we saw in the introductory example, a symbol is created by the command `symbols`.
    This SymPy command generates symbol objects from a given string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'It is actually a short form of following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'followed by a unpacking step to obtain variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The arguments of the command define the string representation of the symbol.
    The variable name of the symbol is often chosen identical to its string representation,
    but this is not required by the language:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Here, we also defined that the symbol is assumed to be an integer.
  prefs: []
  type: TYPE_NORMAL
- en: 'An entire set of symbols can be defined in a very compact way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, symbols for indexed variables can be defined by using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This gives a tuple of symbols,
  prefs: []
  type: TYPE_NORMAL
- en: '![Symbols - the basis of all formulas](img/tupleofsymbols.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The rules for the range of the indexes are those we saw earlier in this book
    when working with slices (refer [Chapter 3](ch03.html "Chapter 3. Container Types"),
    *Container Types* for more details).
  prefs: []
  type: TYPE_NORMAL
- en: Numbers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Python evaluates operations on numbers directly and introduces unavoidably
    rounding errors. These would obstruct all symbolic calculations. This is avoided
    when we  `sympify` numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `sympify` command converts an integer to an object of type `sympy.core.numbers.Integer`.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of writing 1/3 as an operation of two integers, it can also be represented
    directly as a rational number by `Rational(1,3)`.
  prefs: []
  type: TYPE_NORMAL
- en: Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SymPy distinguishes between defined and undefined functions. The term undefined
    functions (might be a bit misleading) refers to well-defined Python objects for
    generic functions that have no special properties.
  prefs: []
  type: TYPE_NORMAL
- en: An example of a function with special properties is `atan` or the `Lambda` function
    used in the introductory example of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note the different names for the different implementations of the same mathematical
    function: `sympy.atan` and `scipy.arctan`.'
  prefs: []
  type: TYPE_NORMAL
- en: Undefined functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A symbol for an undefined function is created by giving the `symbols` command
    an extra class argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The same can be achieved by using the `Function` constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: with undefined functions, we can evaluate general rules of calculus.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let us evaluate the following expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Undefined functions](img/chainrule1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This is symbolically computed in Python by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'When executed, the previous code returns the following as output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Undefined functions](img/chainrule2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This example shows how the product rule and the chain rule were applied.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can even use undefined functions as a function in several variables, for
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'which returns the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Undefined functions](img/sev_variables.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note the use of the star operator to unpack a tuple to form *f* with arguments;
    refer to section *Anonymous functions*, [Chapter 7](ch07.html "Chapter 7. Functions"),
    *Functions*
  prefs: []
  type: TYPE_NORMAL
- en: 'By using list comprehension, we can construct a list of all partial derivatives
    of *f* :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This returns a list with the elements of ![Undefined functions](img/nabla_f.jpg)
    (the gradient of *f*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Undefined functions](img/nabla_f_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The command can also be rewritten by using the `diff` method of the `Function`
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Another method is Taylor series expansion :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This returns Taylor''s formula, together with the rest term expressed by the
    Landau symbol:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Undefined functions](img/taylor1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Elementary Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Examples for elementary functions in SymPy are trigonometric functions and
    their inverses. The following example shows how simplify acts on expression which
    include elementary function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is another example for the use of elementary functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'If you use SciPy and SymPy together, we strongly recommend that you use them
    in different namespaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Lambda - functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In section *Anonymous functions* of [Chapter 7](ch07.html "Chapter 7. Functions"),
    *Functions*, we saw how to define so-called anonymous functions in Python. The
    counterpart in SymPy is done by the `Lambda` command. Note the difference; `lambda`
    is a keyword while `Lambda` is a constructor.
  prefs: []
  type: TYPE_NORMAL
- en: The command `Lambda` takes two arguments, the symbol of the function's independent
    variable, and a SymPy expression to evaluate the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example that defines air resistance (also called drag) as a function
    of speed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '`f_drag` is displayed as an expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Lambda - functions](img/f_drag.jpg).'
  prefs: []
  type: TYPE_NORMAL
- en: 'This function can be evaluated in the usual way by providing it with an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'which will results in given expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Lambda - functions](img/f_drag2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'It is also possible to create functions in several variables by just providing
    it with several arguments as for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'A call to this function can be done in two ways, either by directly providing
    several arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'or by unpacking a tuple or list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Matrix objects in SymPy make it even possible to define vector-valued functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This enables us to compute Jacobians:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Which gives the following expression as output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Lambda - functions](img/jacobian.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the case of more variables, it is convenient to use a more compact form
    to define the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Symbolic Linear Algebra
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Symbolic linear algebra is supported by SymPy''s `matrix` data type which we
    will introduce first. Then we will present some linear algebra methods as examples
    for the broad spectrum of possibilities for symbolic computations in this field:'
  prefs: []
  type: TYPE_NORMAL
- en: Symbolic matrices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We briefly met the `matrix` data type when we discussed vector valued functions.
    There, we saw it in its simplest form, which converts a list of lists into a matrix.
    To have an example, let''s construct a rotation matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: When working with SymPy matrices we have to note that the operator `*` performs
    matrix multiplications and is not acting as an elementwise multiplication which
    is the case for NumPy arrays.
  prefs: []
  type: TYPE_NORMAL
- en: 'The above defined rotation matrix can be checked for orthogonality, by using
    this matrix multiplication and the transpose of a matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous example shows how a matrix is transposed and how the identity
    matrix is created. Alternatively, we could have checked whether its inverse is
    its transpose, which can be done as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Another way to set up a matrix is by providing a list of symbols and a shape:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates the following matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Symbolic matrices](img/matrixM.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'A third way to create a matrix is by generating its entries by a given function.
    The syntax is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We exemplify the above matrix by considering Toeplitz matrix is a matrix with
    constant diagonals. Given a *2n-1 * data vector *a*, its elements are defined
    as
  prefs: []
  type: TYPE_NORMAL
- en: '![Symbolic matrices](img/Toeplitz.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In SymPy, the matrix can be defined by directly making use of this definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Executing the previous code gives `toeplitz(5)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Symbolic matrices](img/Toeplitz-new.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'One clearly sees the desired structures; all elements along subdiagonals and
    superdiagonals are the same. We can access matrix elements by the indexes and
    slices according to the Python syntax introduced in the section *Lists* of [Chapter
    3](ch03.html "Chapter 3. Container Types"), *Container Type*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Examples for Linear Algebra Methods in SymPy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The basic task in linear algebra is to solve linear equation systems:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Examples for Linear Algebra Methods in SymPy](img/linsys.jpg).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us do this symbolically for a 3 *×* 3 matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this relatively small problem is already merely readable which
    can be seen in the following expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Examples for Linear Algebra Methods in SymPy](img/huge_formula.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Again, the use of  `simplify` command helps us to detect canceling terms and
    to collect common factors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'which will result in the following output which looks much better:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Examples for Linear Algebra Methods in SymPy](img/less_huge_formula.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Symbolic computations becomes very slow with increase in matrix dimensions.
    For dimensions bigger than 15, there might even occur memory problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding figure (*Figure 15.3*) illustrates the differences in CPU time
    between symbolically and numerically solving a linear system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Examples for Linear Algebra Methods in SymPy](img/linsys_CPU.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.3: CPU time for numerically and symbolically solving a linear system.'
  prefs: []
  type: TYPE_NORMAL
- en: Substitutions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let us first consider a simple symbolic expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: What happens if we set `x = 0` ?  We observe that `b` did not change. What we
    did was that we changed the Python variable `x`. It now no longer refers to the
    symbol object but to the integer object *0*. The symbol represented by the string
    `'x'`  remains unaltered, and so does `b`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, altering an expression by replacing symbols by numbers, other symbols,
    or expressions is done by a special substitution method which can be seen in following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'This method takes one or two arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Dictionaries as arguments allow us to make several substitutions in one step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'As items in dictionaries have no defined order - one never knows which would
    be the first - there is a need for assuring that permuting the items would not
    affect the substitution result. Therefore in SymPy, substitutions are first made
    within the dictionary and then on the expression. This is demonstrated by the
    following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Both substitutions return the same result, that is,
  prefs: []
  type: TYPE_NORMAL
- en: '![Substitutions](img/subs_result.jpg) .'
  prefs: []
  type: TYPE_NORMAL
- en: 'A third alternative to define multiple substitutions is by using a list of
    old-value/ new-value pairs instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'It is also possible to substitute entire expressions by others:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'To illustrate substitutions of matrix elements, we take the *5 × 5* Toeplitz
    matrix again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Substitutions](img/Toeplitz.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Consider the substitution `M.subs(T[0,2],0)`. It changes the symbol object at
    position [0, 2], which is the symbol *a*[2]. It also occurs at two other places,
    which are automatically affected by this substitution.
  prefs: []
  type: TYPE_NORMAL
- en: 'The given expression is the resulting matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Substitutions](img/mod_toeplitz.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Alternatively we can create a variable for this symbol and use it in the substitution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'As a more complex example for substitution we describe, how to turn the Toeplitz
    matrix into a tridiagonal Toeplitz matrix*.* This can be done in the following
    ways: First we generate a list of those symbols that we want to substitute; and
    then we use the `zip` command to generate a list of pairs. Finally we substitute
    by giving a list of old-value/new-value pairs as described above:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives the following matrix as result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Substitutions](img/toeplitz_3diag.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Evaluating symbolic expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the context of scientific computing, there is often the need of first making
    symbolic manipulations and then converting the symbolic result into a floating-point
    number .
  prefs: []
  type: TYPE_NORMAL
- en: 'The central tool for evaluating a symbolic expression is `evalf`. It converts
    symbolic expressions to floating-point numbers by using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The data type of the resulting object is `Float` (note the capitalization),
    which is a SymPy data type that allows floating-point numbers with an arbitrary
    number of digits (arbitrary precision). The default precision corresponds to 15
    digits, but it can be changed by giving `evalf` an extra positive integer argument
    specifying the desired precision in terms the numbers of digits,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: A consequence of working with arbitrary precision is that numbers can be arbitrary
    small, that is, the limits of the classical floating-point representation are
    broken; refer *Floating Point Numbers* section in [Chapter 2](ch02.html "Chapter 2. Variables
    and Basic Types"), *Variables and Basic Types*.
  prefs: []
  type: TYPE_NORMAL
- en: Interestingly enough,  evaluating a SymPy function with an input of type `Float`
    returns a Float with the same precision as the input. We demonstrate the use of
    this fact in a more elaborated example from numerical analysis.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example: A study on the convergence order of Newton''s Method'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An iterative method with iterates *x[n]* is said to converge with order *q*
    with ![Example: A study on the convergence order of Newton''s Method](img/qinN.jpg),
    if there exists a positive constant *C* such that'
  prefs: []
  type: TYPE_NORMAL
- en: '![Example: A study on the convergence order of Newton''s Method](img/orderq.jpg).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Newton''s method when started with a good initial has order *q* = 2, and for
    certain problems, even *q* = 3\. Newton''s method when applied to the problem
    arctan(*x*) = 0 gives the following iteration scheme:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Example: A study on the convergence order of Newton''s Method](img/atanNewton.jpg)'
  prefs: []
  type: TYPE_IMG
- en: which converges cubically; that is *q* = 3.
  prefs: []
  type: TYPE_NORMAL
- en: This implies that the number of correct digits triples from iteration to iteration.
    To demonstrate cubic convergence and to numerically determine the constant *C*
    is hardly possible with the standard 16-digit float data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code, uses SymPy together with high-precision evaluation instead
    and puts a study on cubic convergence to the extreme:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The result is depicted in the next figure (*Figure 15.4*) which shows that the
    number of correct digits triples from iteration to iteration.
  prefs: []
  type: TYPE_NORMAL
- en: '![Example: A study on the convergence order of Newton''s Method](img/exterem_newton.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.4: A study on the convergence of Newton''s method applied to arctan(x)=0'
  prefs: []
  type: TYPE_NORMAL
- en: 'This extreme precision requirement (3,000 digits!) enables us to evaluate seven
    terms of the preceding sequence to demonstrate cubic convergence in the following
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is a list of seven terms which let us assume that *C =* 2/3:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Converting a symbolic expression into a numeric function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have seen the numerical evaluation of a symbolic expression is done in
    three steps, first we do some symbolic computations and then we substitute values
    by numbers and do an evaluation to a floating point number by `evalf`.
  prefs: []
  type: TYPE_NORMAL
- en: The reason for symbolic computations is often that one wants to make parameter
    studies. This requires that the parameter is modified within a given parameter
    range. This requires that an symbolic expression is eventually turned into a numeric
    function.
  prefs: []
  type: TYPE_NORMAL
- en: A study on the parameter dependency of polynomial coefficients
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We demonstrate a symbolic/ numeric parameter study by an interpolation example
    to introduce the SymPy command `lambdify`. Let us consider the task to interpolate
    the data *x* = [0, *t*, 1] and *y* = [0, 1,-1]. Here, *t* is a free parameter,
    which we will vary over the interval [-0.4, 1.4]. The quadratic interpolation
    polynomial has coefficients depending on this parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A study on the parameter dependency of polynomial coefficients](img/polynomial.jpg).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using SymPy and the monomial approach described in gives us closed formulas
    for these coefficients:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'We obtain a symbolic function for the leading coefficient *a*[2] of the interpolation
    polynomial:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A study on the parameter dependency of polynomial coefficients](img/leading_coeff.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now it is time to turn the expression into a numeric function, for example,
    to make a plot. This is done by the function `lamdify`.  This function takes two
    arguments, the independent variable  and a SymPy function.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our example in Python we can write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'This function can now be plotted, for example, by the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding figure (*Figure 15.5*) is the result of this parameter study,
    one clearly sees the singularities due to multiple interpolation points, (here
    at *t* = 0 or *t* = 1):'
  prefs: []
  type: TYPE_NORMAL
- en: '![A study on the parameter dependency of polynomial coefficients](img/leading_coeff-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.5: The dependency of a polynomial coefficient on the location of
    an interpolation point.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter you were introduced in the world of symbolic computations and
    you got a glimpse of the power of SymPy. By guiding examples you learned how to
    set up symbolic expressions, how to work with symbolic matrices, and you saw how
    to make simplifications. Working with symbolic functions and transforming them
    into numerical evaluations built finally the link to scientific computing and
    floating point results. You experienced the strength of SymPy as you used its
    full integration into Python with its powerful constructs and legible syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Consider this last chapter as an appetizer rather than a complete menu. We hope
    you became hungry for future fascinating programming challenges in scientific
    computing and mathematics.
  prefs: []
  type: TYPE_NORMAL
