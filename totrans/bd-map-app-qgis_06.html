<html><head></head><body>
<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch06" class="calibre1"/>Chapter 6. Mastering the QGIS Python API</h1></div></div></div><p class="calibre8">In this chapter, we will look at a number of more advanced aspects of the PyQGIS library, as well as various techniques for working with QGIS using Python. In particular, we will learn:</p><div><ul class="itemizedlist"><li class="listitem">How to work with symbol layers</li><li class="listitem">More advanced ways of using symbols to draw vector data onto a map</li><li class="listitem">How to implement your own symbols and renderers in Python</li><li class="listitem">How to create a custom map layer using Python</li><li class="listitem">How to implement your own custom map canvas items</li><li class="listitem">How to use memory data providers</li></ul></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_1"><a id="ch06lvl1sec41" class="calibre1"/>Working with symbol layers</h1></div></div></div><p class="calibre8">In the <a id="id345" class="calibre1"/>previous chapters, we created symbols to display vector features by instantiating one of the three basic subclasses of <code class="email">QgsSymbolV2</code>:</p><div><ul class="itemizedlist"><li class="listitem"><code class="email">QgsMarkerSymbolV2</code> for point geometries</li><li class="listitem"><code class="email">QgsLineSymbolV2</code> for line geometries</li><li class="listitem"><code class="email">QgsFillSymbolV2</code> for polygon geometries</li></ul></div><p class="calibre8">We did this either by calling one of the preceding class's static <code class="email">createSimple()</code> methods, or by asking the <code class="email">QgsSymbolV2</code> class to provide us with the default symbol for a given type of geometry. Irrespective of how we did it, the result was a ready-to-use symbol object that displays a given type of vector geometry.</p><p class="calibre8">Internally, symbols consist of one or more symbol layers that are displayed one on top of the other, to draw the vector feature:</p><div><img src="img/00056.jpeg" alt="Working with symbol layers" class="calibre11"/></div><p class="calibre12"> </p><div><h3 class="title2"><a id="note21" class="calibre1"/>Note</h3><p class="calibre8">The symbol layers are drawn in the order in which they are added to the symbol. So, in this example, <strong class="calibre9">Symbol Layer 1</strong> will be drawn <em class="calibre10">before</em> <strong class="calibre9">Symbol Layer 2</strong>. This has the effect of drawing the second symbol layer on top of the first. Make sure you get the order of your symbol layers correct, or you might find a symbol layer completely obscured by another layer.</p></div><p class="calibre8">While the symbols we have been working with so far have had only one layer, there are some clever tricks you can perform with multilayer symbols. We will look at multilayer symbols in the section <em class="calibre10">Combining symbol layers</em>.</p><p class="calibre8">When you create a <a id="id346" class="calibre1"/>symbol, it will automatically be initialized with a default symbol layer. For example, a line symbol (an instance of <code class="email">QgsLineSymbolV2</code>) will be created with a single layer of type <code class="email">QgsSimpleLineSymbolLayerV2</code>. This layer is used to draw the line feature onto the map.</p><p class="calibre8">To work with symbol layers, you need to remove this default layer and replace it with your own symbol layer or layers. For example:</p><div><pre class="programlisting">symbol = QgsSymbolV2.defaultSymbol(layer.geometryType())
symbol.deleteSymbolLayer(0) # Remove default symbol layer.

symbol_layer_1 = QgsSimpleFillSymbolLayerV2()
symbol_layer_1.setFillColor(QColor("yellow"))

symbol_layer_2 = QgsLinePatternFillSymbolLayer()
symbol_layer_2.setLineAngle(30)
symbol_layer_2.setDistance(2.0)
symbol_layer_2.setLineWidth(0.5)
symbol_layer_2.setColor(QColor("green"))

symbol.appendSymbolLayer(symbol_layer_1)
symbol.appendSymbolLayer(symbol_layer_2)</pre></div><p class="calibre8">The following methods <a id="id347" class="calibre1"/>can be used to manipulate the layers within a symbol:</p><div><ul class="itemizedlist"><li class="listitem"><code class="email">symbol.symbolLayerCount()</code>: This <a id="id348" class="calibre1"/>returns the number of symbol layers within <a id="id349" class="calibre1"/>this symbol.</li><li class="listitem"><code class="email">symbol.symbolLayer(index)</code>: This returns the given symbol layer within the <a id="id350" class="calibre1"/>symbol. Note that the first symbol <a id="id351" class="calibre1"/>layer has an index of zero.</li><li class="listitem"><code class="email">symbol.changeSymbolLayer(index, symbol_layer)</code>: This replaces a given <a id="id352" class="calibre1"/>symbol <a id="id353" class="calibre1"/>layer within the symbol.</li><li class="listitem"><code class="email">symbol.appendSymbolLayer(symbol_layer)</code>: This appends a new symbol <a id="id354" class="calibre1"/>layer to the <a id="id355" class="calibre1"/>symbol.</li><li class="listitem"><code class="email">symbol.insertSymbolLayer(index, symbol_layer)</code>: This inserts a symbol <a id="id356" class="calibre1"/>layer at <a id="id357" class="calibre1"/>a given index.</li><li class="listitem"><code class="email">symbol.deleteSymbolLayer(index)</code>: This <a id="id358" class="calibre1"/>removes <a id="id359" class="calibre1"/>the symbol layer at the given index.<div><h3 class="title2"><a id="note22" class="calibre1"/>Note</h3><p class="calibre8">Remember that to use the symbol once you've created it, you create an appropriate renderer and then assign that renderer to your map layer. For example:</p><div><pre class="programlisting">renderer = QgsSingleSymbolRendererV2(symbol)
<strong class="calibre9">layer.setRendererV2(renderer)</strong>
</pre></div></div></li></ul></div><p class="calibre8">The following symbol layer classes are available for you to use:</p><div><table border="1" class="calibre14"><colgroup class="calibre15"><col class="calibre16"/><col class="calibre16"/><col class="calibre16"/></colgroup><thead class="calibre17"><tr class="calibre18"><th valign="bottom" class="calibre19">
<p class="calibre20">PyQGIS class</p>
</th><th valign="bottom" class="calibre19">
<p class="calibre20">Description</p>
</th><th valign="bottom" class="calibre19">
<p class="calibre20">Example</p>
</th></tr></thead><tbody class="calibre21"><tr class="calibre18"><td valign="top" class="calibre22">
<p class="calibre20">
<code class="literal">QgsSimpleMarkerSymbolLayerV2</code>
</p>
</td><td valign="top" class="calibre22">
<p class="calibre20">This <a id="id360" class="indexterm"/>displays a point geometry as a small colored <a id="id361" class="indexterm"/>circle.</p>
</td><td valign="top" class="calibre22">
<div><img src="img/00057.jpeg" alt="Working with symbol layers" class="calibre29"/></div><p class="calibre30"> </p>
</td></tr><tr class="calibre18"><td valign="top" class="calibre22">
<p class="calibre20">
<code class="literal">QgsEllipseSymbolLayerV2</code>
</p>
</td><td valign="top" class="calibre22">
<p class="calibre20">This <a id="id362" class="indexterm"/>displays <a id="id363" class="indexterm"/>a point geometry as an ellipse.</p>
</td><td valign="top" class="calibre22">
<div><img src="img/00058.jpeg" alt="Working with symbol layers" class="calibre29"/></div><p class="calibre30"> </p>
</td></tr><tr class="calibre18"><td valign="top" class="calibre22">
<p class="calibre20">
<code class="literal">QgsFontMarkerSymbolLayerV2</code>
</p>
</td><td valign="top" class="calibre22">
<p class="calibre20">This <a id="id364" class="indexterm"/>displays <a id="id365" class="indexterm"/>a point geometry as a single character. You can choose the font and character to be displayed.</p>
</td><td valign="top" class="calibre22">
<div><img src="img/00059.jpeg" alt="Working with symbol layers" class="calibre29"/></div><p class="calibre30"> </p>
</td></tr><tr class="calibre18"><td valign="top" class="calibre22">
<p class="calibre20">
<code class="literal">QgsSvgMarkerSymbolLayerV2</code>
</p>
</td><td valign="top" class="calibre22">
<p class="calibre20">This <a id="id366" class="indexterm"/>displays a point geometry using a single SVG <a id="id367" class="indexterm"/>format image.</p>
</td><td valign="top" class="calibre22">
<div><img src="img/00060.jpeg" alt="Working with symbol layers" class="calibre29"/></div><p class="calibre30"> </p>
</td></tr><tr class="calibre18"><td valign="top" class="calibre22">
<p class="calibre20">
<code class="literal">QgsVectorFieldSymbolLayer</code>
</p>
</td><td valign="top" class="calibre22">
<p class="calibre20">This <a id="id368" class="indexterm"/>displays <a id="id369" class="indexterm"/>a point geometry by drawing a <strong class="calibre23">displacement line</strong>. One end of the line is the <a id="id370" class="indexterm"/>coordinate of the point, while the other end is calculated using attributes of the feature.</p>
</td><td valign="top" class="calibre22">
<div><img src="img/00061.jpeg" alt="Working with symbol layers" class="calibre29"/></div><p class="calibre30"> </p>
</td></tr><tr class="calibre18"><td valign="top" class="calibre22">
<p class="calibre20">
<code class="literal">QgsSimpleLineSymbolLayerV2</code>
</p>
</td><td valign="top" class="calibre22">
<p class="calibre20">This <a id="id371" class="indexterm"/>displays a line geometry or the outline of a <a id="id372" class="indexterm"/>polygon geometry using a line of a given color, width, and style.</p>
</td><td valign="top" class="calibre22">
<div><img src="img/00062.jpeg" alt="Working with symbol layers" class="calibre29"/></div><p class="calibre30"> </p>
</td></tr><tr class="calibre18"><td valign="top" class="calibre22">
<p class="calibre20">
<code class="literal">QgsMarkerLineSymbolLayerV2</code>
</p>
</td><td valign="top" class="calibre22">
<p class="calibre20">This <a id="id373" class="indexterm"/>displays a line geometry or the outline of a <a id="id374" class="indexterm"/>polygon geometry by repeatedly drawing a marker symbol along the length of the line.</p>
</td><td valign="top" class="calibre22">
<div><img src="img/00063.jpeg" alt="Working with symbol layers" class="calibre29"/></div><p class="calibre30"> </p>
</td></tr><tr class="calibre18"><td valign="top" class="calibre22">
<p class="calibre20">
<code class="literal">QgsSimpleFillSymbolLayerV2</code>
</p>
</td><td valign="top" class="calibre22">
<p class="calibre20">This <a id="id375" class="indexterm"/>displays a polygon geometry by filling the interior with a given solid color and then <a id="id376" class="indexterm"/>drawing a line around the perimeter.</p>
</td><td valign="top" class="calibre22">
<div><img src="img/00064.jpeg" alt="Working with symbol layers" class="calibre29"/></div><p class="calibre30"> </p>
</td></tr><tr class="calibre18"><td valign="top" class="calibre22">
<p class="calibre20">
<code class="literal">QgsGradientFillSymbolLayerV2</code>
</p>
</td><td valign="top" class="calibre22">
<p class="calibre20">This <a id="id377" class="indexterm"/>fills the interior of a polygon geometry using <a id="id378" class="indexterm"/>a color or grayscale gradient.</p>
</td><td valign="top" class="calibre22">
<div><img src="img/00065.jpeg" alt="Working with symbol layers" class="calibre29"/></div><p class="calibre30"> </p>
</td></tr><tr class="calibre18"><td valign="top" class="calibre22">
<p class="calibre20">
<code class="literal">QgsCentroidFillSymbolLayerV2</code>
</p>
</td><td valign="top" class="calibre22">
<p class="calibre20">This <a id="id379" class="indexterm"/>draws a <a id="id380" class="indexterm"/>simple dot at the centroid of a polygon geometry.</p>
</td><td valign="top" class="calibre22">
<div><img src="img/00066.jpeg" alt="Working with symbol layers" class="calibre29"/></div><p class="calibre30"> </p>
</td></tr><tr class="calibre18"><td valign="top" class="calibre22">
<p class="calibre20">
<code class="literal">QgsLinePatternFillSymbolLayer</code>
</p>
</td><td valign="top" class="calibre22">
<p class="calibre20">This <a id="id381" class="indexterm"/>draws the interior of a polygon geometry using a repeated line. You can choose <a id="id382" class="indexterm"/>the angle, width, and color to use for the line.</p>
</td><td valign="top" class="calibre22">
<div><img src="img/00067.jpeg" alt="Working with symbol layers" class="calibre29"/></div><p class="calibre30"> </p>
</td></tr><tr class="calibre18"><td valign="top" class="calibre22">
<p class="calibre20">
<code class="literal">QgsPointPatternFillSymbolLayer</code>
</p>
</td><td valign="top" class="calibre22">
<p class="calibre20">This <a id="id383" class="indexterm"/>draws the interior of a polygon geometry <a id="id384" class="indexterm"/>using a repeated point.</p>
</td><td valign="top" class="calibre22">
<div><img src="img/00068.jpeg" alt="Working with symbol layers" class="calibre29"/></div><p class="calibre30"> </p>
</td></tr><tr class="calibre18"><td valign="top" class="calibre22">
<p class="calibre20">
<code class="literal">QgsSVGFillSymbolLayer</code>
</p>
</td><td valign="top" class="calibre22">
<p class="calibre20">This <a id="id385" class="indexterm"/>draws the interior of a polygon geometry using a <a id="id386" class="indexterm"/>repeated SVG format image.</p>
</td><td valign="top" class="calibre22">
<div><img src="img/00069.jpeg" alt="Working with symbol layers" class="calibre29"/></div><p class="calibre30"> </p>
</td></tr></tbody></table></div><p class="calibre8">These predefined symbol layers, either individually or in various combinations, give you enormous flexibility in how features are to be displayed. However, if these aren't enough for you, you can also implement your own symbol layers using Python. We will look at how this can be done later in this chapter.</p></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec42" class="calibre1"/>Combining symbol layers</h1></div></div></div><p class="calibre8">By combining <a id="id387" class="calibre1"/>symbol layers, you can achieve a range of complex visual effects. For example, you can combine an instance of <code class="email">QgsSimpleMarkerSymbolLayerV2</code> with an instance of <code class="email">QgsVectorFieldSymbolLayer</code> to display a point geometry using two symbols at once:</p><div><img src="img/00070.jpeg" alt="Combining symbol layers" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">One of the main uses of symbol layers is to draw different LineString or PolyLine symbols to represent different types of roads. For example, you can draw a complex road symbol by combining multiple symbol layers, like this:</p><div><img src="img/00071.jpeg" alt="Combining symbol layers" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">This effect is achieved by using three separate symbol layers:</p><div><img src="img/00072.jpeg" alt="Combining symbol layers" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">Here is the Python code used to generate the preceding map symbol:</p><div><pre class="programlisting">symbol =QgsLineSymbolV2.createSimple({})
symbol.deleteSymbolLayer(0) # Remove default symbol layer.

symbol_layer = QgsSimpleLineSymbolLayerV2()
symbol_layer.setWidth(4)
symbol_layer.setColor(QColor("light gray"))
symbol_layer.setPenCapStyle(Qt.FlatCap)
symbol.appendSymbolLayer(symbol_layer)

symbol_layer = QgsSimpleLineSymbolLayerV2()
symbol_layer.setColor(QColor("black"))
symbol_layer.setWidth(2)
symbol_layer.setPenCapStyle(Qt.FlatCap)
symbol.appendSymbolLayer(symbol_layer)

symbol_layer = QgsSimpleLineSymbolLayerV2()
symbol_layer.setWidth(1)
symbol_layer.setColor(QColor("white"))
symbol_layer.setPenStyle(Qt.DotLine)
symbol.appendSymbolLayer(symbol_layer)</pre></div><p class="calibre8">As you can see, you can set the line width, color, and style to create whatever effect you want. As always, you have to define the layers in the correct order, with the back-most symbol layer defined first. By <a id="id388" class="calibre1"/>combining line symbol layers in this way, you can create almost any type of road symbol that you want.</p><p class="calibre8">You can also use symbol layers when displaying polygon geometries. For example, you can draw <code class="email">QgsPointPatternFillSymbolLayer</code> on top of <code class="email">QgsSimpleFillSymbolLayerV2</code> to have repeated points on top of a simple filled polygon, like this:</p><div><img src="img/00073.jpeg" alt="Combining symbol layers" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">Finally, you can make use <a id="id389" class="calibre1"/>of <strong class="calibre9">transparency</strong> to allow the various symbol layers (or entire symbols) to blend into each other. For example, you can create a pinstripe effect by combining two symbol layers, like this:</p><div><pre class="programlisting">symbol = QgsFillSymbolV2.createSimple({})
symbol.deleteSymbolLayer(0) # Remove default symbol layer.

symbol_layer = QgsGradientFillSymbolLayerV2()
symbol_layer.setColor2(QColor("dark gray"))
symbol_layer.setColor(QColor("white"))
symbol.appendSymbolLayer(symbol_layer)

symbol_layer = QgsLinePatternFillSymbolLayer()
symbol_layer.setColor(QColor(0, 0, 0, 20))
symbol_layer.setLineWidth(2)
symbol_layer.setDistance(4)
symbol_layer.setLineAngle(70)
symbol.appendSymbolLayer(symbol_layer)</pre></div><p class="calibre8">The result is quite subtle and visually pleasing:</p><div><img src="img/00074.jpeg" alt="Combining symbol layers" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">In addition to changing the <a id="id390" class="calibre1"/>transparency for a symbol layer, you can also change the transparency for the symbol as a whole. This is done by using the <code class="email">setAlpha()</code> method, like this:</p><div><pre class="programlisting">symbol.setAlpha(0.3)</pre></div><p class="calibre8">The result looks like this:</p><div><img src="img/00075.jpeg" alt="Combining symbol layers" class="calibre11"/></div><p class="calibre12"> </p><div><h3 class="title2"><a id="note23" class="calibre1"/>Note</h3><p class="calibre8">Note that <code class="email">setAlpha()</code> takes a floating point number between 0.0 and 1.0, while the transparency of a <code class="email">QColor</code> object, like the ones we used earlier, is specified using an alpha value between 0 and 255.</p></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec43" class="calibre1"/>Implementing symbol layers in Python</h1></div></div></div><p class="calibre8">If the built-in <a id="id391" class="calibre1"/>symbol layers aren't flexible enough for your needs, you can implement your own symbol layers using Python. To <a id="id392" class="calibre1"/>do this, you create a subclass of the appropriate type of symbol layer (<code class="email">QgsMarkerSymbolLayerV2</code>, <code class="email">QgsLineSymbolV2</code>, or <code class="email">QgsFillSymbolV2</code>) and implement the various drawing methods yourself. For example, here is a simple marker symbol layer that draws a cross for a Point geometry:</p><div><pre class="programlisting">class CrossSymbolLayer(QgsMarkerSymbolLayerV2):
    def __init__(self, length=10.0, width=2.0):
        QgsMarkerSymbolLayerV2.__init__(self)
        self.length = length
        self.width  = width

    def layerType(self):
        return "Cross"

    def properties(self):
        return {'length' : self.length,
                'width' : self.width}

    def clone(self):
        return CrossSymbolLayer(self.length, self.width)

    def startRender(self, context):
        self.pen = QPen()
        self.pen.setColor(self.color())
        self.pen.setWidth(self.width)

    def stopRender(self, context):
        self.pen = None

    def renderPoint(self, point, context):
        left = point.x() - self.length
        right = point.x() + self.length
        bottom = point.y() - self.length
        top = point.y() + self.length

        painter = context.renderContext().painter()
        painter.setPen(self.pen)
        painter.drawLine(left, bottom, right, top)
        painter.drawLine(right, bottom, left, top)</pre></div><p class="calibre8">Using this custom symbol layer in your code is straightforward:</p><div><pre class="programlisting">symbol = QgsMarkerSymbolV2.createSimple({})
symbol.deleteSymbolLayer(0)

symbol_layer = CrossSymbolLayer()
symbol_layer.setColor(QColor("gray"))

symbol.appendSymbolLayer(symbol_layer) </pre></div><p class="calibre8">Running this code will <a id="id393" class="calibre1"/>draw a cross at the location <a id="id394" class="calibre1"/>of each point geometry, as follows:</p><div><img src="img/00076.jpeg" alt="Implementing symbol layers in Python" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">Of course, this is a simple example, but it shows you how to use custom symbol layers implemented in Python. Let's now take a closer look at the implementation of the <code class="email">CrossSymbolLayer</code> class, and see what each method does:</p><div><ul class="itemizedlist"><li class="listitem"><code class="email">__init__()</code>: Notice how the <code class="email">__init__</code> method accepts parameters that customize <a id="id395" class="calibre1"/>the way the symbol layer works. These parameters, which should always have default values assigned to them, are the <a id="id396" class="calibre1"/><strong class="calibre9">properties</strong> associated with the symbol layer. If you want to make your custom symbol available within the <strong class="calibre9">QGIS Layer Properties</strong> window, you will need to register your custom symbol layer and tell QGIS how to edit the symbol layer's properties. We will look at this shortly.</li><li class="listitem"><code class="email">layerType()</code>: This <a id="id397" class="calibre1"/>method <a id="id398" class="calibre1"/>returns a unique name for your symbol layer.</li><li class="listitem"><code class="email">properties()</code>: This <a id="id399" class="calibre1"/>should return a <a id="id400" class="calibre1"/>dictionary that contains the various properties used by this symbol layer. The properties returned by this method will be stored in the QGIS project file, and used later to restore the symbol layer.</li><li class="listitem"><code class="email">clone()</code>: This <a id="id401" class="calibre1"/>method should return a copy of the symbol layer. Since we have defined our properties <a id="id402" class="calibre1"/>as parameters to the <code class="email">__init__</code> method, implementing this method simply involves creating a new instance of the class and copying the properties from the current symbol layer to the new instance.</li><li class="listitem"><code class="email">startRender()</code>: This <a id="id403" class="calibre1"/>method is called before the first feature in the map layer is rendered. This can be used to <a id="id404" class="calibre1"/>define any objects that will be required to draw the feature. Rather than creating these objects each time, it is more efficient (and therefore faster) to create them only once to render all the features. In this example, we create the <code class="email">QPen</code> object that we will use to draw the Point geometries.</li><li class="listitem"><code class="email">stopRender()</code>: This <a id="id405" class="calibre1"/>method is called after the last feature <a id="id406" class="calibre1"/>has been rendered. This can be used to release the objects created by the <code class="email">startRender()</code> method.</li><li class="listitem"><code class="email">renderPoint()</code>: This is where all the work is done for drawing point geometries. As <a id="id407" class="calibre1"/>you can see, this <a id="id408" class="calibre1"/>method takes two parameters: the point at which to draw the symbol, and the <strong class="calibre9">rendering context</strong> (an <a id="id409" class="calibre1"/>instance of <code class="email">QgsSymbolV2RenderContext</code>) to use for drawing the symbol.</li><li class="listitem">The rendering <a id="id410" class="calibre1"/>context provides various methods to access the feature being displayed, as well as information about the rendering operation, the current scale factor, and so on. Most importantly, it allows you to access the PyQt <code class="email">QPainter</code> object required to actually draw the symbol on the screen.</li></ul></div><p class="calibre8">The <code class="email">renderPoint()</code> method <a id="id411" class="calibre1"/>is only used for symbol layers that draw point geometries. For line geometries, you should implement the <code class="email">renderPolyline()</code> method, which has the following signature:</p><div><pre class="programlisting">def renderPolyline(self, points, context):</pre></div><p class="calibre8">The <code class="email">points</code> parameter <a id="id412" class="calibre1"/>will be a <code class="email">QPolygonF</code> object that contains the various points that make up the LineString, and <code class="email">context</code> will be the rendering context to use to draw the geometry.</p><p class="calibre8">If your symbol layer is intended to work with polygons, you should implement the <code class="email">renderPolygon()</code> method, which looks like this:</p><div><pre class="programlisting">def renderPolygon(self, outline, rings, context):</pre></div><p class="calibre8">Here, <code class="email">outline</code> is a <code class="email">QPolygonF</code> object that contains the points that make up the exterior of the polygon, and <code class="email">rings</code> is a list of <code class="email">QPolygonF</code> objects that define the interior rings or "holes" within the polygon. As always, <code class="email">context</code> is the rendering context to use when drawing the geometry.</p><p class="calibre8">A custom symbol layer created in this way will work fine if you just want to use it within your own external PyQGIS application. However, if you want to use a custom symbol layer within a running copy of QGIS, and in particular, if you want to allow end users to work with the symbol layer using the <strong class="calibre9">Layer Properties</strong> window, there are some extra steps you will have to take, which are as follows:</p><div><ul class="itemizedlist"><li class="listitem">If you want the symbol to be visually highlighted when the user clicks on it, you will need to change your symbol layer's <code class="email">renderXXX()</code> method to see if the feature being <a id="id413" class="calibre1"/>drawn has been selected by the user, and if so, change the way it is drawn. The easiest way to do this is to change the geometry's color. For example:<div><pre class="programlisting">if context.selected():
    color = context.selectionColor()
else:
    color = self.color</pre></div></li><li class="listitem">To allow the user to edit the symbol layer's properties, you should create a subclass of <code class="email">QgsSymbolLayerV2Widget</code>, which defines the user interface to edit the <a id="id414" class="calibre1"/>properties. For example, a simple widget for the purpose of editing the length and width of a <code class="email">CrossSymbolLayer</code> can be defined as follows:<div><pre class="programlisting">class CrossSymbolLayerWidget(QgsSymbolLayerV2Widget):
    def __init__(self, parent=None):
        QgsSymbolLayerV2Widget.__init__(self, parent)
        self.layer = None

        self.lengthField = QSpinBox(self)
        self.lengthField.setMinimum(1)
        self.lengthField.setMaximum(100)
        self.connect(self.lengthField,
                     SIGNAL("valueChanged(int)"),
                     self.lengthChanged)

        self.widthField = QSpinBox(self)
        self.widthField.setMinimum(1)
        self.widthField.setMaximum(100)
        self.connect(self.widthField,
                     SIGNAL("valueChanged(int)"),
                     self.widthChanged)

        self.form = QFormLayout()
        self.form.addRow('Length', self.lengthField)
        self.form.addRow('Width', self.widthField)

        self.setLayout(self.form)

    def setSymbolLayer(self, layer):
        if layer.layerType() == "Cross":
            self.layer = layer
            self.lengthField.setValue(layer.length)
            self.widthField.setValue(layer.width)

    def symbolLayer(self):
        return self.layer

    def lengthChanged(self, n):
        self.layer.length = n
        self.emit(SIGNAL("changed()"))

    def widthChanged(self, n):
        self.layer.width = n
        self.emit(SIGNAL("changed()"))</pre></div><p class="calibre26">We define the contents of our widget using the standard <code class="email">__init__()</code> initializer. As you <a id="id415" class="calibre1"/>can see, we define two fields, <code class="email">lengthField</code> and <code class="email">widthField</code>, which let the user change the <code class="email">length</code> and <code class="email">width</code> properties <a id="id416" class="calibre1"/>respectively for our symbol layer.</p><p class="calibre26">The <code class="email">setSymbolLayer()</code> <a id="id417" class="calibre1"/>method tells the widget which <code class="email">QgsSymbolLayerV2</code> object to use, while the <code class="email">symbolLayer()</code> method returns the <code class="email">QgsSymbolLayerV2</code> object this widget is editing. Finally, the two <code class="email">XXXChanged()</code> methods are called when the user changes the value of the fields, allowing us to update the symbol layer's properties to match the value set by the user.</p></li><li class="listitem">Finally, you will need to register your symbol layer. To do this, create a subclass of <code class="email">QgsSymbolLayerV2AbstractMetadata</code> and pass it to the <code class="email">QgsSymbolLayerV2Registry</code> object's <code class="email">addSymbolLayerType()</code> method. Here is an example implementation of the metadata for our <code class="email">CrossSymbolLayer</code> <a id="id418" class="calibre1"/>class, along with the code to register it within QGIS:<div><pre class="programlisting">class CrossSymbolLayerMetadata(QgsSymbolLayerV2AbstractMetadata):
    def __init__(self):
        QgsSymbolLayerV2AbstractMetadata.__init__(self, "Cross", "Cross marker", QgsSymbolV2.Marker)

    def createSymbolLayer(self, properties):
        if "length" in properties:
            length = int(properties['length'])
        else:
            length = 10
        if "width" in properties:
            width = int(properties['width'])
        else:
            width = 2
        return CrossSymbolLayer(length, width)

    def createSymbolLayerWidget(self, layer):
        return CrossSymbolLayerWidget()

registry = QgsSymbolLayerV2Registry.instance()
registry.addSymbolLayerType(CrossSymbolLayerMetadata())</pre></div></li></ul></div><p class="calibre8">Note that the <a id="id419" class="calibre1"/>parameters for the <code class="email">QgsSymbolLayerV2AbstractMetadata.__init__()</code> method are as follows:</p><div><ul class="itemizedlist"><li class="listitem"><code class="email">name</code>: The unique name for the symbol layer, which must match the name returned by the symbol layer's <code class="email">layerType()</code> method.</li><li class="listitem"><code class="email">visibleName</code>: A display name for this symbol layer, as shown to the user within the <strong class="calibre9">Layer Properties</strong> window.</li><li class="listitem"><code class="email">type</code>: The type of symbol that this symbol layer will be used for.</li></ul></div><p class="calibre8">The <code class="email">createSymbolLayer()</code> method is used to restore the symbol layer based on the properties stored in the <a id="id420" class="calibre1"/>QGIS project file when the project was saved. The <code class="email">createSymbolLayerWidget()</code> method is called to create the user <a id="id421" class="calibre1"/>interface widget that lets the user view and edit the symbol layer's properties.</p></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec44" class="calibre1"/>Implementing renderers in Python</h1></div></div></div><p class="calibre8">If you need to <a id="id422" class="calibre1"/>choose symbols based on more complicated criteria than the built-in renderers will provide, you can write your own custom <code class="email">QgsFeatureRendererV2</code> subclass using Python. For example, the following Python code <a id="id423" class="calibre1"/>implements a simple renderer that alternates between odd and even symbols as point features are displayed:</p><div><pre class="programlisting">class OddEvenRenderer(QgsFeatureRendererV2):
    def __init__(self):
        QgsFeatureRendererV2.__init__(self, "OddEvenRenderer")
        self.evenSymbol = QgsMarkerSymbolV2.createSimple({})
        self.evenSymbol.setColor(QColor("light gray"))
        self.oddSymbol = QgsMarkerSymbolV2.createSimple({})
        self.oddSymbol.setColor(QColor("black"))
        self.n = 0

    def clone(self):
        return OddEvenRenderer()

    def symbolForFeature(self, feature):
        self.n = self.n + 1
        if self.n % 2 == 0:
            return self.evenSymbol
        else:
            return self.oddSymbol

    def startRender(self, context, layer):
        self.n = 0
        self.oddSymbol.startRender(context)
        self.evenSymbol.startRender(context)

    def stopRender(self, context):
        self.oddSymbol.stopRender(context)
        self.evenSymbol.stopRender(context)

    def usedAttributes(self):
        return []</pre></div><p class="calibre8">Using this renderer will cause the various point geometries to be displayed in alternating colors, for example:</p><div><img src="img/00077.jpeg" alt="Implementing renderers in Python" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">Let's take a closer <a id="id424" class="calibre1"/>look at how this class was implemented, and what the various methods do:</p><div><ul class="itemizedlist"><li class="listitem"><code class="email">__init__()</code>: This is your standard Python initializer. Notice how we have to provide a unique name for the renderer when calling the <code class="email">QgsFeatureRendererV2.__init__()</code> method; this is used to keep track of the <a id="id425" class="calibre1"/>various renderers within QGIS itself.</li><li class="listitem"><code class="email">clone()</code>: This <a id="id426" class="calibre1"/>creates a copy of this renderer. If your renderer uses properties to control how it works, this method should copy those properties into the new renderer object.</li><li class="listitem"><code class="email">symbolForFeature()</code>: This <a id="id427" class="calibre1"/>returns the symbol to use for drawing the given feature.</li><li class="listitem"><code class="email">startRender()</code>: This <a id="id428" class="calibre1"/>gives you the opportunity to prepare your renderer and any symbols you use before the features are rendered.  Note that you must call the <code class="email">startRender()</code> method on each symbol that your renderer uses; as the renderer can make use of multiple symbols, you need to implement this so that your symbols are also given a chance to prepare for rendering.</li><li class="listitem"><code class="email">stopRender()</code>: This <a id="id429" class="calibre1"/>finishes rendering the features. Once again, you need to implement this so that your symbols can have a chance to clean up once the rendering process has finished.</li><li class="listitem"><code class="email">usedAttributes()</code>: This <a id="id430" class="calibre1"/>method should be implemented to return the list of feature attributes that the renderer makes use of. If your renderer does not use attributes to choose between the various symbols, then you do not need to implement this method.</li></ul></div><p class="calibre8">If you wish, you can also implement your own widget that lets the user change the way the renderer works. This is done by subclassing <code class="email">QgsRendererV2Widget</code> and setting up the widget to edit the renderer's various properties in the same way that we implemented a subclass of <code class="email">QgsSymbolLayerV2Widget</code> to edit the properties for a symbol layer. You will also need to provide metadata for your new renderer (by subclassing <code class="email">QgsRendererV2AbstractMetadata</code>) and use the <code class="email">QgsRendererV2Registry</code> object to register your new renderer. If you do this, the user will be able to select your custom renderer for new map <a id="id431" class="calibre1"/>layers, and change the way your renderer <a id="id432" class="calibre1"/>works by editing the renderer's properties.</p></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec45" class="calibre1"/>Working with custom map layers</h1></div></div></div><p class="calibre8">Instead of using a standard map layer with a data provider, features, symbols, and so on, you can implement <a id="id433" class="calibre1"/>your own <strong class="calibre9">custom map layer</strong> entirely in Python. Custom map layers are generally used to draw specific data that is too complicated to represent as vector format data, or to draw special visual features such as a grid or a watermark onto the map.</p><p class="calibre8">Custom map layers are implemented by subclassing the <code class="email">QgsPluginLayer</code> class. The process is actually very simple, though you will need to translate between map and device coordinates so that the items you draw in your Python layer match up with the features drawn in the other layers within your canvas.</p><div><h3 class="title2"><a id="note24" class="calibre1"/>Note</h3><p class="calibre8">Don't get confused by the name; you don't have to write a QGIS plugin to create your own <code class="email">QgsPluginLayer</code> subclass.</p></div><p class="calibre8">Let's see how we can create our own subclass of <code class="email">QgsPluginLayer</code>. We're going to create a simple grid that can appear as a layer within the map. Let's start by defining the <code class="email">QgsPluginLayer</code> subclass itself:</p><div><pre class="programlisting">class GridLayer(QgsPluginLayer):
    def __init__(self):
        QgsPluginLayer.__init__(self, "GridLayer", "Grid Layer")
        self.setValid(True)</pre></div><p class="calibre8">In our <code class="email">__init__()</code> method, we give the plugin layer a unique name (<code class="email">"GridLayer"</code>) and a user-visible name (<code class="email">"Grid Layer"</code>), and then tell QGIS that the layer is valid.</p><p class="calibre8">Next, we need to set up the coordinate reference system and extent of our layer. Since we're creating a grid <a id="id434" class="calibre1"/>that covers the entire Earth, we'll use the standard EPSG 4236 coordinate system (that is, latitude/longitude coordinates), and set the extent of the layer to cover the entire surface of the Earth:</p><div><pre class="programlisting">        self.setCrs(QgsCoordinateReferenceSystem(4326))
        self.setExtent(QgsRectangle(-180, 90, 180, 90))</pre></div><p class="calibre8">We're now ready to define the method that draws the contents of the layer. As you might imagine, this method is called <code class="email">draw()</code>. Let's start by obtaining the <code class="email">QPainter</code> object we'll use to do the actual drawing:</p><div><pre class="programlisting">    def draw(self, renderContext):
        painter = renderContext.painter()</pre></div><p class="calibre8">Next, we want to find the portion of the Earth's surface that is currently visible:</p><div><pre class="programlisting">        extent = renderContext.extent()</pre></div><p class="calibre8">This gives us the portion of the grid that we want to draw. To make sure the grid lines are on whole degrees of latitude and longitude, we round the extent up and down to the nearest whole number, like this:</p><div><pre class="programlisting">        xMin = int(math.floor(extent.xMinimum()))
        xMax = int(math.ceil(extent.xMaximum()))
        yMin = int(math.floor(extent.yMinimum()))
        yMax = int(math.ceil(extent.yMaximum()))</pre></div><p class="calibre8">Next, we need to set up the painter to draw the grid lines:</p><div><pre class="programlisting">        pen = QPen()
        pen.setColor(QColor("light gray"))
        pen.setWidth(1.0)
        painter.setPen(pen)</pre></div><p class="calibre8">Now, we're almost ready to start drawing the grid. To draw the grid lines, though, we'll need some way of <a id="id435" class="calibre1"/>translating between latitude/longitude values and pixel coordinates on the computer screen. We'll do this using a <code class="email">QgsMapToPixel</code> object, which we can get from the rendering context:</p><div><pre class="programlisting">        mapToPixel = renderContext.mapToPixel()</pre></div><p class="calibre8">Now, we're finally ready to draw the grid lines. Let's start by drawing a vertical grid line on each whole degree of longitude:</p><div><pre class="programlisting">        for x in range(xMin, xMax+1):
            coord1 = mapToPixel.transform(x, yMin)
            coord2 = mapToPixel.transform(x, yMax)
            painter.drawLine(coord1.x(), coord1.y(),
                             coord2.x(), coord2.y())</pre></div><p class="calibre8">We can then do the same for the horizontal grid lines:</p><div><pre class="programlisting">        for y in range(yMin, yMax+1):
            coord1 = mapToPixel.transform(xMin, y)
            coord2 = mapToPixel.transform(xMax, y)
            painter.drawLine(coord1.x(), coord1.y(),
                             coord2.x(), coord2.y())</pre></div><p class="calibre8">The last thing we need to do is tell QGIS that our layer was drawn successfully. We do this by having our <code class="email">draw()</code> method return <code class="email">True</code>:</p><div><pre class="programlisting">        return True</pre></div><p class="calibre8">This completes our implementation of the <code class="email">GridLayer</code> class. If you want to use this class within a QGIS script or plugin, you will need to register the class so that QGIS knows about it. Fortunately, doing this is straightforward:</p><div><pre class="programlisting">class GridLayerType(QgsPluginLayerType):
    def __init__(self):
        QgsPluginLayerType.__init__(self, "GridLayer")

    def createLayer(self):
        return GridLayer()

registry = QgsPluginLayerRegistry.instance()
registry.addPluginLayerType(GridLayerType())</pre></div><p class="calibre8">If you run this program <a id="id436" class="calibre1"/>within QGIS and add the <code class="email">GridLayer</code> to your project, you'll see the grid lines drawn on the map:</p><div><img src="img/00078.jpeg" alt="Working with custom map layers" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">Look carefully at the preceding image; you'll see that the grid lines are drawn in front of the polygon, but behind the circle. This is one of the main benefits of implementing your own map layer, as <a id="id437" class="calibre1"/>opposed to using a map canvas item; you can choose which layers appear in front or behind your custom map layer.</p></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec46" class="calibre1"/>Creating custom map canvas items</h1></div></div></div><p class="calibre8">A map canvas item <a id="id438" class="calibre1"/>is an item that is placed on top of the map canvas. Standard map canvas items include text annotations, vertex markers, and the visual highlighting of a feature. It is also possible to create your own custom map canvas items by subclassing <code class="email">QgsMapCanvasItem</code>. To see how this works, let's create a map canvas item that draws a compass rose onto the map:</p><div><img src="img/00079.jpeg" alt="Creating custom map canvas items" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">We'll start by <a id="id439" class="calibre1"/>creating the basic <code class="email">QgsMapCanvasItem</code> subclass:</p><div><pre class="programlisting">class CompassRoseItem(QgsMapCanvasItem):
    def __init__(self, canvas):
        QgsMapCanvasItem.__init__(self, canvas)
        self.center = QgsPoint(0, 0)
        self.size   = 100

    def setCenter(self, center):
        self.center = center

    def center(self):
        return self.center

    def setSize(self, size):
        self.size = size

    def size(self):
        return self.size

    def boundingRect(self):
        return QRectF(self.center.x() - self.size/2,
                      self.center.y() - self.size/2,
                      self.center.x() + self.size/2,
                      self.center.y() + self.size/2)

    def paint(self, painter, option, widget):
        # ...</pre></div><p class="calibre8">As you can see, we position the compass rose onto the map canvas by defining <code class="email">center</code> and <code class="email">size</code> instance variables, and provide methods to retrieve and set these values. We also implement the required <code class="email">boundingRect()</code> method, which returns the overall bounding rectangle for the canvas item, in screen coordinates.</p><p class="calibre8">This leaves us with the <code class="email">paint()</code> method, which does the job of drawing the compass rose. While this method takes three parameters, the only parameter we'll be using is the first one, which is the <code class="email">QPainter</code> object we will use to draw the compass rose.</p><p class="calibre8">The compass rose <a id="id440" class="calibre1"/>might look quite complicated, but the code needed to implement it is quite straightforward. The most complicated part is figuring out the dimensions of the <code class="email">"N"</code>, <code class="email">"S"</code>, <code class="email">"E"</code>, and <code class="email">"W"</code> labels so that we have enough room left for the compass rose itself. Let's start by calculating some basic information about the labels that we are going to display:</p><div><pre class="programlisting">    def paint(self, painter, option, widget):
        fontSize = int(18 * self.size/100)
        painter.setFont(QFont("Times", pointSize=fontSize,weight=75))
        metrics = painter.fontMetrics()
        labelSize = metrics.height()
        margin    = 5</pre></div><p class="calibre8">We calculate the size of the font to use for the labels (in points), and then set our painter to use a boldfaced <code class="email">"Times"</code> font of that size. We then get a <code class="email">QFontMetrics</code> object that we will use to calculate the labels' dimensions, and define a hardwired pixel margin so that we leave a gap between the label and the compass rose itself.</p><p class="calibre8">Next, we want to draw the two central parts of the compass rose in light gray and black respectively. To do this, we'll use a <code class="email">QPainterPath</code> object to define the area to be filled in:</p><div><pre class="programlisting">        x = self.center.x()
        y = self.center.y()
        size = self.size - labelSize - margin

        path = QPainterPath()
        path.moveTo(x, y - size * 0.23)
        path.lineTo(x - size * 0.45, y - size * 0.45)
        path.lineTo(x - size * 0.23, y)
        path.lineTo(x - size * 0.45, y + size * 0.45)
        path.lineTo(x, y + size * 0.23)
        path.lineTo(x + size * 0.45, y + size * 0.45)
        path.lineTo(x + size * 0.23, y)
        path.lineTo(x + size * 0.45, y - size * 0.45)
        path.closeSubpath()

        painter.fillPath(path, QColor("light gray"))

        path = QPainterPath()
        path.moveTo(x, y - size)
        path.lineTo(x - size * 0.18, y - size * 0.18)
        path.lineTo(x - size, y)
        path.lineTo(x - size * 0.18, y + size * 0.18)
        path.lineTo(x, y + size)
        path.lineTo(x + size * 0.18, y + size * 0.18)
        path.lineTo(x + size, y)
        path.lineTo(x + size * 0.18, y - size * 0.18)
        path.closeSubpath()

        painter.fillPath(path, QColor("black"))</pre></div><p class="calibre8">Finally, we want <a id="id441" class="calibre1"/>to draw the labels at each of the four compass points:</p><div><pre class="programlisting">        labelX = x - metrics.width("N")/2
        labelY = y - self.size + labelSize - metrics.descent()
        painter.drawText(QPoint(labelX, labelY), "N")

        labelX = x - metrics.width("S")/2
        labelY = y + self.size - labelSize + metrics.ascent()
        painter.drawText(QPoint(labelX, labelY), "S")

        labelX = x - self.size + labelSize/2 - metrics.width("E")/2
        labelY = y - metrics.height()/2 + metrics.ascent()
        painter.drawText(QPoint(labelX, labelY), "E")

        labelX = x + self.size - labelSize/2 - metrics.width("W")/2
        labelY = y - metrics.height()/2 + metrics.ascent()
        painter.drawText(QPoint(labelX, labelY), "W")</pre></div><p class="calibre8">This completes the <a id="id442" class="calibre1"/>implementation of our <code class="email">QgsMapCanvasItem</code> subclass. To use it, we simply have to create and initialize a new <code class="email">CompassRoseItem</code>. Here is an example of how we can display a <code class="email">CompassRoseItem</code> within the map canvas:</p><div><pre class="programlisting">rose = CompassRoseItem(iface.mapCanvas())
rose.setCenter(QPointF(150, 400))
rose.setSize(80)</pre></div><p class="calibre8">Your new <code class="email">QgsMapCanvasItem</code> will automatically be added to the map canvas when the object is initialized—you don't need to explicitly add it to the canvas. To remove the compass rose from the map canvas, you can do the following:</p><div><pre class="programlisting">iface.mapCanvas().scene().removeItem(rose)</pre></div><p class="calibre8">Note that map canvas items float above the map layers, and unfortunately, cannot directly interact with the user—you can't intercept and respond to mouse events using a map canvas item.</p></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec47" class="calibre1"/>Using memory-based layers</h1></div></div></div><p class="calibre8">While a map layer <a id="id443" class="calibre1"/>would normally display geospatial data taken from an external data source such as a shapefile, a raster DEM file, or a database, it is also possible to create geospatial features directly from your Python code. For example, imagine that you write a program to display the halfway point along a road. This halfway point could be represented as a <code class="email">QgsPoint</code> geometry, which would be displayed on the map using an appropriate marker symbol. Since you are calculating the point, this isn't a feature you would want to store in a shapefile or database. Rather, the feature is calculated and displayed when your program is run.</p><p class="calibre8">This is an ideal application for a memory-based layer. This type of layer stores geospatial features in memory, allowing you to create new features on the fly and display them within a map layer.</p><p class="calibre8">To create a memory-based map layer, instantiate a new <code class="email">QgsVectorLayer</code> object, just like normal. The initializer for this class looks like the following:</p><div><pre class="programlisting">layer = QgsVectorLayer(path, baseName, providerLib)</pre></div><div><h3 class="title2"><a id="note25" class="calibre1"/>Note</h3><p class="calibre8">This is slightly simplified—there is another parameter, <code class="email">loadDefaultStyleFlag</code>, which doesn't apply to memory-based layers. Fortunately, there's a default value for this parameter, so we can ignore it.</p></div><p class="calibre8">Let's take a look at the three parameters needed to create a memory-based map layer:</p><div><ul class="itemizedlist"><li class="listitem"><code class="email">path</code>: This string <a id="id444" class="calibre1"/>provides information that is needed to create the memory-based layer, including the type of information that the layer will store. We will look at this parameter in more detail shortly.</li><li class="listitem"><code class="email">baseName</code>: This is the <a id="id445" class="calibre1"/>name used for the memory-based layer. The name can be anything you like, though the user will see it in the QGIS layer legend.</li><li class="listitem"><code class="email">providerLib</code>: This <a id="id446" class="calibre1"/>should be set to <code class="email">"memory"</code> for memory-based layers.</li></ul></div><p class="calibre8">To create a simple <a id="id447" class="calibre1"/>memory-based layer, you can do the following:</p><div><pre class="programlisting">layer = QgsVectorLayer("Polygon", "My Layer", "memory")</pre></div><p class="calibre8">This will create a memory-based layer named <code class="email">"My Layer"</code>, which stores polygon features with no attributes.</p><p class="calibre8">The <code class="email">path</code> parameter will let us do much more than simply define the type of geometry to be stored in the layer. The <code class="email">path</code> parameter has the following overall syntax:</p><div><pre class="programlisting">geometryType?key=value&amp;key=value...</pre></div><p class="calibre8">This URL-like syntax starts with the type of geometry, and can have any number of key/value pairs that provide additional information about the memory layer. The following geometry types are currently supported:</p><div><ul class="itemizedlist"><li class="listitem"><code class="email">Point</code></li><li class="listitem"><code class="email">LineString</code></li><li class="listitem"><code class="email">Polygon</code></li><li class="listitem"><code class="email">MultiPoint</code></li><li class="listitem"><code class="email">MultiLineString</code></li><li class="listitem"><code class="email">MultiPolygon</code></li></ul></div><p class="calibre8">Using the key/value <a id="id448" class="calibre1"/>pairs, you can also define:</p><div><ul class="itemizedlist"><li class="listitem">The coordinate reference system that the layer should use. For example:<div><pre class="programlisting">crs=IGNF:WGS84G</pre></div><p class="calibre26">The coordinate reference system can be defined using a CRS authority code, as in the preceding example, or you can specify the CRS in WKT format, for example: <code class="email">crs=+proj=longlat +a=69000 +b=55000 +no_defs</code>.</p><div><h3 class="title2"><a id="note26" class="calibre1"/>Note</h3><p class="calibre8">If you don't define the coordinate reference system in this way, QGIS will prompt the user to select a CRS when your program is run. This could be very confusing for the user, so you should always specify a CRS when you create a memory layer.</p></div></li><li class="listitem">Attributes to <a id="id449" class="calibre1"/>store for each feature within the layer. Here is an example of an attribute definition:<div><pre class="programlisting">field=phone_number:string</pre></div><p class="calibre26">The following types of fields are currently supported:</p><div><ul class="itemizedlist1"><li class="listitem"><code class="email">integer</code></li><li class="listitem"><code class="email">double</code></li><li class="listitem"><code class="email">string</code></li></ul></div><p class="calibre26">You can also specify the field length and precision by listing these in parentheses, for example, <code class="email">field=height:double(10,2)</code> or <code class="email">field=name:string(50)</code>.</p><p class="calibre26">If you want to have multiple attributes, you simply have one <code class="email">field=...</code>entry for each of the attributes you want to define.</p><div><h3 class="title2"><a id="note27" class="calibre1"/>Note</h3><p class="calibre8">The memory layer's data provider has an <code class="email">addAttributes()</code> method, which you might assume you'd use to define the attributes. However, the <code class="email">addAttributes()</code> method only adds the attributes to the data provider, not the map layer, which can cause QGIS to crash. To avoid this, it is better to define your attributes within the path when you set up your map layer, rather than trying to add them later.</p></div></li><li class="listitem">A spatial index for this layer's features:<div><pre class="programlisting">index=yes</pre></div></li></ul></div><p class="calibre8">Let's use this to create a more complex memory layer that stores point geometries using a specified coordinate reference system, a spatial index, and some attributes. Here is how we might do this:</p><div><pre class="programlisting">layer = QgsVectorLayer(
"Point?crs=EPSG:4326&amp;field=height:double&amp;field=name:string(255)&amp;index=yes", "Point Layer", "memory")</pre></div><p class="calibre8">Once we've instantiated our memory layer, we can create the various features we want to display, and then add them to the layer. The following pseudocode shows how this is done:</p><div><pre class="programlisting">provider = layer.dataProvider()

feature1 = ...
feature2 = ...

provider.addFeatures([feature1, feature2, ...])</pre></div><p class="calibre8">As you can see, we define the <a id="id450" class="calibre1"/>various features (which are instances of <code class="email">QgsFeature</code>), and then add them all at once to the memory layer. You can add the features one at a time, of course, but it's generally more efficient to define a list of features and add them all at once.</p><p class="calibre8">Let's now see how we can create a feature. We start by defining the underlying geometry that the feature will <a id="id451" class="calibre1"/>display. There are various ways of creating geometries, including:</p><div><ul class="itemizedlist"><li class="listitem">Instantiating a <code class="email">QgsPoint</code>, <code class="email">QgsPolyLine</code>, <code class="email">QgsPolygon</code>, or related object, and then using this to create a <code class="email">QgsGeometry</code> object using one of the <code class="email">QgsGeometry.fromXXX()</code> methods. For example:<div><pre class="programlisting">point = QgsPoint(x, y)
geometry = QgsGeometry.fromPoint(point)</pre></div></li><li class="listitem">Creating a WKT-format string that represents the geometry, and then creating the <code class="email">QgsGeometry</code> object using this string. For example:<div><pre class="programlisting">geometry = QgsGeometry.fromWkt("POINT (10 10)")</pre></div></li><li class="listitem">Creating a new <code class="email">QgsGeometry</code> object out of an existing geometry by using one of the geometry manipulation methods. For example:<div><pre class="programlisting">new_geometry = old_geometry.buffer(10)</pre></div></li></ul></div><p class="calibre8">Once we have the geometry, we're ready to create the <code class="email">QgsFeature</code> object itself:</p><div><pre class="programlisting">feature = QgsFeature()
feature.setGeometry(geometry)</pre></div><p class="calibre8">Next, we want to set the attributes for this feature. Before we can do this though, we need to tell the feature which attributes it will store. This is done in the following way:</p><div><pre class="programlisting">fields = provider.fields()
feature.setFields(fields)</pre></div><p class="calibre8">Finally, we can set the attribute values. For example:</p><div><pre class="programlisting">feature.setAttribute("height", 301)
feature.setAttribute("name", "Eiffel Tower")</pre></div><p class="calibre8">Putting all this <a id="id452" class="calibre1"/>together, let's build a complete example program that creates a memory layer, populates it with a few <code class="email">QgsPoint</code> features, and updates the map canvas to show those points. Here is this example program:</p><div><pre class="programlisting">layer = QgsVectorLayer("Point?crs=EPSG:4326&amp;field=height:double&amp;field=name:string(255)", "Point Layer", "memory")
provider = layer.dataProvider()
QgsMapLayerRegistry.instance().addMapLayer(layer)

fields = provider.fields()
features = []

feature = QgsFeature()
feature.setGeometry(QgsGeometry.fromWkt("POINT (2.2945 48.8582)"))
feature.setFields(fields)
feature.setAttribute("height", 301)
feature.setAttribute("name", "Eiffel Tower")
features.append(feature)

feature = QgsFeature()
feature.setGeometry(QgsGeometry.fromWkt("POINT (0.0761 51.5081)"))
feature.setFields(fields)
feature.setAttribute("height", 27)
feature.setAttribute("name", "Tower of London")
features.append(feature)

feature = QgsFeature()
feature.setGeometry(QgsGeometry.fromWkt("POINT (10.3964 43.7231)"))
feature.setFields(fields)
feature.setAttribute("height", 56)
feature.setAttribute("name", "Leaning Tower of Pisa")
features.append(feature)

provider.addFeatures(features)
layer.updateExtents()
iface.mapCanvas().zoomToFullExtent()</pre></div><p class="calibre8">Running this program from within QGIS will create a new memory-based map layer named <code class="email">"Point Layer"</code> with <a id="id453" class="calibre1"/>three features in it, which represent the location of three famous towers in Western Europe:</p><div><img src="img/00080.jpeg" alt="Using memory-based layers" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">To make this example useful, we would add symbols to draw the towers in a more meaningful way, and probably also display the name and height as a label beside each point. However, you can see how a memory layer can be used to create spatial data from within your program and include it as a layer within the map.</p><p class="calibre8">Note that you aren't limited to using memory layers to represent actual geospatial data. You could just as easily use the memory layer to display information that doesn't represent a location. For <a id="id454" class="calibre1"/>example, you can use a memory layer to draw arrows onto a map, or to shade certain areas of the map using a semi-transparent polygon. Memory-based map layers are an extremely powerful tool, and one that you will often use when writing your own programs based on QGIS.</p></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec48" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">In this chapter, we looked at many of the more advanced features of the QGIS Python API. We learned how the various built-in symbol layers can be used to draw geometries on the map, how to combine symbol layers in useful ways, and how to implement your own symbol layers using Python. We then looked at writing your own custom renderer to choose which symbol to use for each feature, and how to create your own custom map layer using Python code. We investigated the creation of custom map canvas items, and then saw how memory-based map layers can be used to programmatically add features to your map.</p><p class="calibre8">With this, we complete our tour of the more advanced aspects of PyQGIS. In the next chapter, we will learn how to create custom map tools that let the user select, add, edit, and delete features within a PyQGIS application.</p></div></body></html>