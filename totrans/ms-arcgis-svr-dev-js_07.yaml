- en: Chapter 7. Plays Well with Others
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 7 章：与其他库和框架兼容
- en: JavaScript development has matured over recent years. Once a simple language
    used to script a few animations and user interactions, JavaScript applications
    now support a full range of tasks that were only possible with desktop applications
    a few years ago. There are numerous well-documented libraries and frameworks that
    make complicated applications manageable through a web browser.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，JavaScript 开发已经成熟。曾经只是用来编写一些动画和用户交互的简单语言，JavaScript 应用现在可以支持几年前只有桌面应用才能完成的全面任务。有众多文档齐全的库和框架，通过网页浏览器使复杂应用变得可管理。
- en: No JavaScript library or framework does everything perfectly. Most libraries
    focus on improving a few key requirements for application development, such as
    DOM manipulation, data binding, animation, or graphics. Some focus on speed; others
    focus on cross-browser compatibility.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 没有任何 JavaScript 库或框架能够完美地完成所有事情。大多数库专注于提高应用开发的一些关键需求，例如 DOM 操作、数据绑定、动画或图形。有些库侧重于速度；而有些则侧重于跨浏览器兼容性。
- en: A successful JavaScript developer doesn't have to build an application from
    scratch using one library or raw JavaScript to make it work. By adding current
    libraries that work well together, the developer can speed up development and
    handle multiple browser types without having to worry about them.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 成功的 JavaScript 开发者不必从头开始使用单个库或原生 JavaScript 来构建应用以使其工作。通过添加当前兼容性良好的库，开发者可以加快开发速度，并处理多种浏览器类型，而无需担心它们。
- en: 'In this chapter, we''ll cover the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Integrating jQuery into the applications
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 jQuery 集成到应用中
- en: Integrating Backbone.js into the applications
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 Backbone.js 集成到应用中
- en: Integrating Knockout.js into the applications
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 Knockout.js 集成到应用中
- en: Discuss Using AngularJS in a mapping application
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论在地图应用中使用 AngularJS
- en: Compatibility with other libraries and frameworks
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与其他库和框架的兼容性
- en: One way developers describe the usability of JavaScript libraries is how compatible
    they are with other libraries. The more libraries your library plays well with,
    the more likely it can be used on projects. When libraries don't play well with
    other libraries and frameworks, it can lead to unintended code bugs and actions
    that nobody saw coming. Since a developer cannot control what other libraries
    are used in a project with their library, it is better if a library plays well
    with others.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者描述 JavaScript 库可用性的一个方式是它们与其他库的兼容性。你的库与越多库兼容，就越有可能在项目中使用。当库与其他库和框架不兼容时，可能会导致意外的代码错误和未预料到的行为。由于开发者无法控制项目中使用的其他库，因此如果库与其他库兼容会更好。
- en: There are several ways that libraries can conflict with one another. One way
    that was more common in the past is through namespace collision. If two libraries
    create the same `cut()` function in the global namespace, you can't be sure which
    one will be called. Another, more subtle conflict arises through manipulating
    the prototype of standard JavaScript types. One library will expect the `map()`
    method called on an array to perform a specific task, but if another library overwrote
    `Array.prototype.map()`, the results may not turn out as expected, and may break
    the application. Typically, it's only polite to manipulate the prototype of base
    JavaScript types if you are patching support for older browsers.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 库之间可能存在几种冲突方式。过去更常见的一种方式是通过命名空间冲突。如果两个库在全局命名空间中创建了相同的 `cut()` 函数，你无法确定哪个会被调用。另一种更微妙的是通过操作标准
    JavaScript 类型的原型。一个库可能会期望对数组上的 `map()` 方法执行特定任务，但如果另一个库覆盖了 `Array.prototype.map()`，结果可能不会如预期，甚至可能破坏应用。通常，只有当你修补旧浏览器的支持时，才礼貌地操作基础
    JavaScript 类型的原型。
- en: A more recent way that JavaScript libraries can clash is in how they implement
    modules. Before ECMAScript 6 came out with the standard for modules, there were
    two schools of module development. One revolved around using CommonJS to define
    modules, and the other was AMD. Typically, modules from one can be loaded by the
    other, as they are called and constructed differently. Most small libraries that
    aren't defined one way or another can be loaded into either one, with a little
    work.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 库之间冲突的另一种较新的方式是它们实现模块的方式。在 ECMAScript 6 发布模块标准之前，有两种模块开发流派。一种是通过使用
    CommonJS 来定义模块，另一种是 AMD。通常，一种模块可以从另一种中加载，因为它们的调用和构建方式不同。大多数未明确定义的小型库都可以通过一些工作加载到其中。
- en: Even within AMD, there can be some conflicts. Some libraries and frameworks
    use Require.JS to load their modules. While syntactily similar, there are some
    differences in older versions of Dojo that create errors when mixing with Require.JS
    modules. It's something to be aware of when mixing and mashing up JavaScript libraries
    in your application.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在AMD中，也可能存在一些冲突。一些库和框架使用Require.JS来加载它们的模块。虽然语法上相似，但Dojo的老版本与Require.JS模块混合时会产生错误。当你在应用程序中混合和匹配JavaScript库时，这是一件需要注意的事情。
- en: Popular libraries to play with
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常用的库来玩耍
- en: Now that we've looked at library compatibility as a whole, it's time to check
    out how the ArcGIS API for JavaScript plays with other JavaScript libraries and
    frameworks. We'll look at some of the popular libraries used by developers, and
    attempt to load them along with the ArcGIS API for JavaScript. We'll create the
    same application using jQuery, Backbone.js, Knockout.js, and AngularJS, and see
    how they compare. Finally, we'll look at a few do's and don'ts with any framework
    and the ArcGIS API.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经整体研究了库的兼容性，是时候检查ArcGIS API for JavaScript如何与其他JavaScript库和框架协同工作了。我们将查看一些开发者使用的流行库，并尝试将它们与ArcGIS
    API for JavaScript一起加载。我们将使用jQuery、Backbone.js、Knockout.js和AngularJS创建相同的应用程序，并比较它们。最后，我们将探讨与任何框架和ArcGIS
    API相关的几项“应该做”和“不应该做”的事项。
- en: Our story continues
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们的故事还在继续
- en: So, our census data app is a big hit for the Y2K society. They like the look
    of the graphics, and want us to expand it. The functionality of the widget is
    great, but they've made a new request. It seems that one of the members watched
    a late night comedian on television the other night, and found out that there
    are people out there who can't find their state or county on a map.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的普查数据应用程序在Y2K社会中非常受欢迎。他们喜欢图形的外观，并希望我们扩展它。小部件的功能很棒，但他们提出了新的要求。似乎有一位成员在昨晚的深夜喜剧节目中得知，有些人无法在地图上找到他们的州或县。
- en: After discussing possible solutions with our client, we've decided to add some
    drop-down controls that let the user select a state, county, and even a census
    block group. On picking a state, the map zooms to the state and shows the data
    in a popup. Also, the county dropdown is populated with the county names in that
    state. When the county is selected, the county is selected with a popup, and the
    block group names are populated for that county and state. Finally, if the block
    group is selected, the block group is zoomed to, and the data is displayed on
    the map.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在与客户讨论可能的解决方案后，我们决定添加一些下拉控件，让用户可以选择一个州、县，甚至是一个人口普查区块组。选择一个州后，地图会缩放到该州，并在弹出窗口中显示数据。此外，县下拉列表会填充该州的所有县名。当选择县时，县会通过弹出窗口被选中，并为该县和州填充区块组名称。最后，如果选择了区块组，区块组会被缩放到，并在地图上显示数据。
- en: In somewhat related news, we've picked up an intern. He's an eager young kid
    who likes to follow the latest in JavaScript. He wants to contribute something
    to this project, and this looks like a good task to let him cut his teeth on.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在某种程度上相关的新闻中，我们招聘了一名实习生。他是一位热衷于跟随最新JavaScript动态的年轻小伙子。他希望为这个项目做出贡献，而这个任务看起来是一个让他锻炼的好机会。
- en: The problem is, our intern wants to write the code using another library or
    framework, and not just a simple one. He wants to bring in a number of popular
    libraries including jQuery, Backbone, Knockout, Node.js, and Angular. While we
    appreciate his desire to learn (and to pad his resume), we have to have a serious
    talk with him about picking libraries appropriate for the project.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，我们的实习生想要使用另一个库或框架来编写代码，而不仅仅是简单的库。他希望引入包括jQuery、Backbone、Knockout、Node.js和Angular在内的多个流行库。虽然我们欣赏他学习的愿望（以及充实简历），但我们不得不与他严肃地讨论选择适合项目的库。
- en: After talking the intern out of a Node.js project (since this is a client-side
    app, with no need for server-side work at this point), we explain the general
    use of the other libraries, he had on his list. We decide to give the intern a
    learning project, and let him build four copies of the app, each incorporating
    either jQuery, Backbone, Knockout, or Angular. He can evaluate each app and let
    us know which worked best with the application. We figure it's okay that he does
    four times the work, since he's not a paid intern.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在说服实习生放弃Node.js项目（因为这个是一个客户端应用程序，目前不需要服务器端工作）之后，我们向他解释了他在列表上其他库的一般用法。我们决定给实习生一个学习项目，让他构建四个应用程序的副本，每个应用程序都包含jQuery、Backbone、Knockout或Angular之一。他可以评估每个应用程序，并告诉我们哪个与该应用程序配合得最好。我们认为他做四倍的工作是可以接受的，因为他不是付费实习生。
- en: 'We should go ahead and set up four project folders with copies of the `D3.js`
    app from our previous chapter''s work. In each of the projects, we need to modify
    the `Census.html` template in the `/js/template` folder to show the drop-down
    menus. We''ll add three drop-down menus with bold labels and selects that will
    be populated later by the four libraries. It should look like the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该继续设置四个项目文件夹，并复制我们上一章工作中的`D3.js`应用程序的副本。在每个项目中，我们需要修改`/js/template`文件夹中的`Census.html`模板，以显示下拉菜单。我们将添加三个带有粗体标签的下拉菜单，这些菜单将由四个库稍后填充。它应该看起来像以下这样：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'When the new application loads, the new widget should look something like the
    following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当新应用程序加载时，新的小部件应该看起来像以下这样：
- en: '![Our story continues](img/6459OT_07_01.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![我们的故事继续](img/6459OT_07_01.jpg)'
- en: An overview of jQuery
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: jQuery概述
- en: The most popular library for a number of years has to be jQuery. jQuery was
    originally created by John Resig as a library to handle DOM manipulation and events.
    Cross-browser compatibility is a strong selling point for this library, since
    it works in everything from the newest version of Chrome to Internet Explorer
    versions so old they make most developers cringe. Its intuitive commands and functionality
    make it easy to pick up for novice developers. The library is so popular that,
    as of the end of 2013, it is estimated to be used in 61 percent of the top 100,000
    websites in the world, according to the jQuery blog ([http://blog.jquery.com/2014/01/13/the-state-of-jquery-2014/](http://blog.jquery.com/2014/01/13/the-state-of-jquery-2014/)).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几年中，最受欢迎的库之一无疑是jQuery。jQuery最初由John Resig创建，作为一个用于处理DOM操作和事件的库。跨浏览器兼容性是该库的一个强大卖点，因为它在从最新版本的Chrome到非常古老的Internet
    Explorer版本上都能工作，以至于大多数开发者都会感到不适。其直观的命令和功能使得新手开发者容易上手。该库非常受欢迎，据jQuery博客（[http://blog.jquery.com/2014/01/13/the-state-of-jquery-2014/](http://blog.jquery.com/2014/01/13/the-state-of-jquery-2014/)）报道，截至2013年底，它被估计用于世界上排名前100,000的网站中的61%。
- en: If you understand how jQuery works, you can skip the next section and go to
    *Adding jQuery in our App*. If not, here's a quick rundown on how jQuery works.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你理解jQuery的工作原理，你可以跳过下一节，直接进入*在我们的应用程序中添加jQuery*。如果不理解，这里简要介绍一下jQuery的工作原理。
- en: How jQuery works
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: jQuery的工作原理
- en: 'The jQuery library is incredibly useful for selecting and manipulating DOM
    elements on a web page. DOM elements can be selected using the `jQuery()` function,
    or its common shortcut method `$()`. It accepts either a DOM element or a string
    with a CSS selector. To select an element with an `id`, you would put a `#` in
    front of the ID name. To select a CSS class, you insert a `.` in front of the
    class name. To select all elements of a tag name, just use the tag name. In fact,
    almost any legal CSS `select` statement is supported by jQuery. Here are some
    examples in the following code:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery库在网页上选择和操作DOM元素方面非常有用。可以使用`jQuery()`函数或其常用快捷方法`$()`来选择DOM元素。它接受一个DOM元素或一个包含CSS选择器的字符串。要选择一个具有`id`的元素，你需要在ID名称前加上一个`#`。要选择一个CSS类，你需要在类名前插入一个`.`。要选择具有特定标签名的所有元素，只需使用该标签名。实际上，jQuery几乎支持任何合法的CSS
    `select`语句。以下是一些代码示例：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Once the nodes are selected by the jQuery object, you can perform a number of
    functions on them. You can make them appear and disappear using the `show()` and
    `hide()` methods. You can change their style using `css()`, their properties using
    `attr()`, and their content using `html()` or `text()` methods. Selected form
    element values can be retrieved and set using the `val()`. You can also find elements
    within the selected elements with `find()`, and iterate through each item with
    the `each()` method. Events can also be assigned using the `on()` method, and
    removed using `off()`. These are just the most common jQuery methods.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦jQuery对象选择了节点，你可以在它们上执行多个函数。你可以使用`show()`和`hide()`方法使它们显示或消失。你可以使用`css()`改变它们的样式，使用`attr()`改变它们的属性，使用`html()`或`text()`方法改变它们的内容。可以使用`val()`方法检索和设置选定的表单元素值。你也可以使用`find()`在选定的元素内查找元素，并使用`each()`方法遍历每个项目。事件也可以使用`on()`方法分配，并使用`off()`方法移除。这些只是最常见的jQuery方法。
- en: 'Another powerful feature of jQuery is a property called **chaining**. jQuery
    functions return the jQuery object. You can immediately call another function
    on what was returned. These chained commands are evaluated from left to right.
    You can create some powerful transformations on your HTML using this code. For
    example, if you wanted to turn every unordered list item into a green frog and
    every ordered list item to a big brown toad, you could do the following:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery 的另一个强大功能是名为 **链式** 的属性。jQuery 函数返回 jQuery 对象。您可以直接在返回的内容上调用另一个函数。这些链式命令从左到右进行评估。您可以使用此代码对您的
    HTML 执行一些强大的转换。例如，如果您想将每个无序列表项变成一只绿色的青蛙，每个有序列表项变成一只大棕色的蟾蜍，您可以这样做：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Just be warned, as you work with complex chained functions in jQuery, sometimes
    the target of the function will change. Functions like `each()` and `find()` will
    change the selection that is passed to the next function. In this example, the
    developer wants to show a form, set its width to `400px`, clear the values of
    the text blanks, and turn the labels blue. When they run it, they will find that
    the labels don''t turn blue as they expected:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 只是要警告一下，当您在 jQuery 中使用复杂的链式函数时，有时函数的目标会改变。像 `each()` 和 `find()` 这样的函数会改变传递给下一个函数的选择。在这个例子中，开发者想要显示一个表单，将其宽度设置为
    `400px`，清除文本框的值，并将标签变为蓝色。当他们运行它时，他们会发现标签没有像预期的那样变蓝：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'When the developer called `find(''input'')`, it changed the selected items
    from form elements to input elements. Then, when the `find(''label'')` was called,
    jQuery searched for labels that were inside the input tags. Not finding any, nothing
    turned blue. Thankfully, the developer remembered that jQuery also provides an
    `end()` function that returns you to your original selection. The following bit
    of code works much better:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当开发者调用 `find('input')` 时，它将选定的表单元素更改为输入元素。然后，当调用 `find('label')` 时，jQuery 在输入标签内搜索标签。没有找到任何标签，所以没有东西变蓝。幸运的是，开发者记得
    jQuery 还提供了一个 `end()` 函数，该函数可以返回到原始选择。以下代码片段工作得更好：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now that we've taken a crash course in jQuery, let's try to use it in our application.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对 jQuery 进行了快速学习，让我们尝试在我们的应用中使用它。
- en: Adding jQuery to your app
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 jQuery 添加到您的应用中
- en: So, our intern is starting to work with the jQuery-based app when he runs into
    his first problem. How does he make jQuery and Dojo play well together? For the
    answer to that, we can look at some of the lessons from [Chapter 6](ch06.html
    "Chapter 6. Charting Your Progress"), *Charting Your Progress*, when we added
    `D3.js` to our application.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的实习生开始使用基于 jQuery 的应用时，遇到了他的第一个问题。他如何让 jQuery 和 Dojo 一起良好地工作？为了回答这个问题，我们可以参考
    [第 6 章](ch06.html "第 6 章。绘制您的进度")，*绘制您的进度*，当我们向应用中添加 `D3.js` 时的一些经验教训。
- en: 'Loading a copy of our `D3.js` app, we''ll start by adding a reference to the
    jQuery library in our `dojoConfig` packages. Remember that it is the JavaScript
    configuration object that is loaded before we load the ArcGIS Javascript API.
    We''ll add a package with the name and file location, but we''ll also add a `main`
    property that will make the application load the jQuery library. You can download
    a copy of the jQuery library and place it in an accessible folder in your application,
    or you can make a reference to an external **content delivery network** (or **CDN**)
    that''s hosting the library. Using an external reference to jQuery hosted by Google,
    it should look something like the following code:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 加载我们 `D3.js` 应用的副本，我们首先将在 `dojoConfig` 包中添加对 jQuery 库的引用。记住，这是在加载 ArcGIS JavaScript
    API 之前加载的 JavaScript 配置对象。我们将添加一个具有名称和文件位置的包，但我们还会添加一个 `main` 属性，这将使应用加载 jQuery
    库。您可以从网上下载 jQuery 库并将其放置在应用中的一个可访问文件夹中，或者您可以将引用指向一个托管库的外部 **内容分发网络**（或 **CDN**）。使用由
    Google 托管的 jQuery 的外部引用，它应该看起来像以下代码：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now that we can access jQuery through AMD, let''s open our `Census.js` file
    and add it as a module in our file. We''ll add a reference to it in the `require`
    statement, and assign it to the module `$`, as it is commonly referred to in most
    jQuery examples. It should look something like the following code:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过 AMD 访问 jQuery，让我们打开 `Census.js` 文件，并将其作为模块添加到我们的文件中。我们将在 `require`
    语句中添加对其的引用，并将其分配给模块 `$`，正如在大多数 jQuery 示例中常见的那样。它应该看起来像以下代码：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, we''ll need to update the `Census` widget template to give jQuery something
    to search for. While updating `Census.html` in the `js/templates/` folder, we''ll
    add a `stateselect`, `countyselect`, and `blockgroupselect` class to each of the
    `select` menus. While adding IDs would make selecting the elements faster, adding
    class names will ensure that there is no ID name collision with other widgets
    in the application. The template will look like the following example:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要更新`Census`小部件模板，以便jQuery有东西可以搜索。当我们在`js/templates/`文件夹中更新`Census.html`时，我们将为每个`select`菜单添加一个`stateselect`、`countyselect`和`blockgroupselect`类。虽然添加ID会使选择元素更快，但添加类名将确保与应用程序中的其他小部件没有ID名称冲突。模板将看起来像以下示例：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Since we have something for jQuery to select, we need to let jQuery select
    it in our code. Add some jQuery selectors to the constructor of our `Census` widget
    to get the nodes that have the `stateselect`, `countyselect`, and `blockgroupselect`
    classes, and assign them to the `stateSelect`, `countySelect`, and `blockGroupSelect`
    properties of our widget, in that order. This is referred to as **caching** our
    selections, which is a good practice for jQuery apps, since repeating DOM searches
    can take a long time, especially in a larger application:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们有东西让jQuery选择，我们需要在我们的代码中让jQuery选择它。向我们的`Census`小部件构造函数中添加一些jQuery选择器，以获取具有`stateselect`、`countyselect`和`blockgroupselect`类的节点，并将它们按顺序分配给小部件的`stateSelect`、`countySelect`和`blockGroupSelect`属性。这被称为**缓存**我们的选择，这对于jQuery应用程序来说是一个好习惯，因为重复的DOM搜索可能需要很长时间，尤其是在一个较大的应用程序中：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If we ran the application now, we would find that there was nothing in the
    `stateSelect`, `countySelect`, and `blockGroupSelect` properties. Why? If you
    remember, back in [Chapter 3](ch03.html "Chapter 3. The Dojo Widget System"),
    *The Dojo Widget System*, we talked about the lifecycle of a `Dojo` widget. We
    discussed the fact that, while the constructor function runs, the template won''t
    have loaded yet. In fact, it will not be available until the widget runs the `postCreate()`
    method. We''ll need to add `postCreate()` to our application, add a line that
    refers to the `postCreate` function inherited from the `WidgetBase` class, and
    then cut and paste the jQuery code we wrote earlier into this function. It should
    look something like the following code:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在运行应用程序，我们会发现`stateSelect`、`countySelect`和`blockGroupSelect`属性中没有任何内容。为什么？如果你还记得，在[第3章](ch03.html
    "第3章。Dojo小部件系统")《Dojo小部件系统》中，我们讨论了`Dojo`小部件的生命周期。我们讨论了这样一个事实，即在构造函数运行时，模板还没有加载。实际上，它将不会可用，直到小部件运行`postCreate()`方法。我们需要在我们的应用程序中添加`postCreate()`，添加一行引用从`WidgetBase`类继承的`postCreate`函数的代码，然后将我们之前编写的jQuery代码剪切并粘贴到这个函数中。它应该看起来像以下代码：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now, when the `postCreate` method is called, `stateSelect`, `countySelect`,
    and `blockGroupSelect` will be filled with appropriate objects.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当`postCreate`方法被调用时，`stateSelect`、`countySelect`和`blockGroupSelect`将填充适当的对象。
- en: Filling in our dropdowns
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 填充下拉列表
- en: We need data to fill in our select dropdowns. For that, we'll need to get state,
    county, and block group names from the map services and fill them in the dropdowns.
    For the fifty or more states, that is easy, but what about counties and block
    groups? There are over 250 counties in the state of Texas alone, and even more
    block groups. We need a systematic way to populate the dropdowns.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要数据来填充我们的选择下拉列表。为此，我们需要从地图服务中获取州、县和街区组名称，并将它们填充到下拉列表中。对于五十多个州来说，这很简单，但县和街区组怎么办？仅德克萨斯州就有250多个县，街区组更多。我们需要一种系统化的方法来填充下拉列表。
- en: What if, every time we selected a state, the county dropdown was filled with
    all the counties in that state? Also, what if the block groups list wasn't populated
    until the user selected the county of interest? We can achieve this if we listen
    to the `select` element's `change` event. When the event fires, we'll have a new
    selection result from the previous level query for the new list.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果每次我们选择一个州，县下拉列表就填充该州的所有县，会怎么样？此外，如果街区组列表直到用户选择了感兴趣的县才填充，会怎么样？如果我们监听`select`元素的`change`事件，我们可以实现这一点。当事件触发时，我们将从上一级查询的新列表中获得新的选择结果。
- en: 'We''ll start by stubbing out two new methods in the `Census` module, called
    `queryDropdownData()` and `populateDropdown()`. Instead of adding a list of parameters
    that we don''t know yet, we''ll add a single argument called `args` to the `queryDropdownData()`
    method. To the `populateDropdown()` method, we''ll add the `args` parameter, plus
    a `featureSet` parameter that will come from querying the map data:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先在`Census`模块中添加两个新的方法，分别命名为`queryDropdownData()`和`populateDropdown()`。而不是添加我们尚未知的参数列表，我们将向`queryDropdownData()`方法添加一个名为`args`的单个参数。对于`populateDropdown()`方法，我们将添加`args`参数，以及一个来自查询地图数据的`featureSet`参数：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Adding the QueryTask
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加查询任务
- en: 'Inside the `queryDropdownData()` method, we''re going to query a map service
    to get the list of counties in a state, or block groups in a county. For this,
    we''ll need to add the ArcGIS JavaScript API''s `QueryTask`. If you remember from
    [Chapter 2](ch02.html "Chapter 2. Digging into the API"), *Digging into the API*,
    `QueryTask` lets us pull SQL-like queries to single layers in a map service. We''ll
    need to add references to the `require` statement for the `QueryTask` and its
    associated task parameter builder, the `Query`. We''ll go ahead and construct
    these in our `getDropdown()` method:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在`queryDropdownData()`方法内部，我们将查询地图服务以获取一个州中的县列表或县中的街区组列表。为此，我们需要添加ArcGIS JavaScript
    API的`QueryTask`引用。如果你还记得[第2章](ch02.html "第2章。深入API")中的内容，*深入API*，`QueryTask`允许我们从地图服务中的单个图层中拉取类似SQL的查询。我们需要添加对`QueryTask`及其关联的任务参数构建器`Query`的引用。我们将继续在我们的`getDropdown()`方法中构建这些：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now we need to define the parameters for both `QueryTask` and the query. For
    that, we''ll use parameters passed through the `args` object. We can define an
    `args.url` to send a URL string to the `QueryTask`. We can also use `args.field`
    to set the field name for the data we want returned in the query object, and `args.where`
    to supply a `where` clause to filter the results. `queryDropdownData()` should
    now look like the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要定义`QueryTask`和查询的参数。为此，我们将使用通过`args`对象传递的参数。我们可以定义一个`args.url`来向`QueryTask`发送URL字符串。我们还可以使用`args.field`来设置查询对象中我们想要返回的数据的字段名，以及`args.where`来提供一个`where`子句以过滤结果。`queryDropdownData()`现在应该看起来如下：
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'For our `populateDropdown()` method, we''ll take the jQuery-based selector
    and add the `featureSet` features that will be returned from the `queryDropdownData()`
    method. Remember that a `featureSet` contains a `features` parameter, which contains
    a list of graphic results. Out of the graphics returned, we''re only interested
    in the attributes of the field returned. It should look as follows. We''re going
    to use the jQuery `each()` function on the list of features to iterate through,
    create an option for each result, attach it to the selector, and fill it in with
    values. It should look like the following:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的`populateDropdown()`方法，我们将使用基于jQuery的选择器，并添加来自`queryDropdownData()`方法的`featureSet`功能。记住，`featureSet`包含一个`features`参数，它包含一系列图形结果。我们只对返回的图形的属性感兴趣。它应该看起来如下。我们将使用jQuery的`each()`函数遍历功能列表，为每个结果创建一个选项，将其附加到选择器上，并用值填充它。它应该看起来像以下这样：
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Other helper functions
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他辅助函数
- en: 'With the addition of `QueryTask`, we can now directly query the state, county,
    or block group we select from the drop-down menu. We need to define the function
    that will collect that information from the server. We can call the method in
    our widget `queryShapeAndData()`, and it will take a single `args` parameter with
    the data we need from it:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加`QueryTask`，我们现在可以直接查询从下拉菜单中选择的州、县或街区组。我们需要定义一个函数，从服务器收集这些信息。我们可以在我们的小部件中调用`queryShapeAndData()`方法，它将接受一个包含所需数据的单个`args`参数：
- en: '[PRE14]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'While it is possible to add these graphics directly to the map, we should format
    the data so that it brings up an `infoWindow` as if we clicked it ourselves. For
    this, we''ll add an `_onQueryComplete()` method. It will accept a `featureSet`
    returned from a `QueryTask`, and return a list of features with appropriate popup
    templates just like the ones we assign when we identify through clicks. Unfortunately,
    `featureSets` do not return the same descriptive information as `IdentifyResults`,
    so we will have to manually add the title of the feature for it to accurately
    pick the right `InfoTemplate`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然直接将这些图形添加到地图上是可能的，但我们应该格式化数据，使其在点击时能够弹出 `infoWindow`，就像我们亲自点击一样。为此，我们将添加一个
    `_onQueryComplete()` 方法。它将接受来自 `QueryTask` 的 `featureSet`，并返回一个具有适当弹出模板的特征列表，就像我们在通过点击进行识别时分配的模板一样。不幸的是，`featureSets`
    并不返回与 `IdentifyResults` 相同的描述信息，因此我们将必须手动添加特征的标题，以便它能够准确地选择正确的 `InfoTemplate`：
- en: '[PRE15]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Going back to the `queryShapeAndData()` method, we can add the `callback` function
    to the `execute` statement and have it return a processed result every time. The
    last part of `queryShapeAndData()`will look like the following:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 回到 `queryShapeAndData()` 方法，我们可以在 `execute` 语句中添加 `callback` 函数，并使其每次返回一个处理过的结果。`queryShapeAndData()`
    的最后部分将看起来像以下这样：
- en: '[PRE16]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Finally, we need a way to show the queried graphics on the map. We''ll create
    a method called `_updateInfoWindowFromQuery()` that takes a `featureSet`, zooms
    to its features, and adds the `infoWindow`. We''re going to use the `esri/graphicsUtils`
    module to collect the overall extent of the graphics, so that we can zoom to it.
    Once the asynchronous zoom finishes, we''ll set the graphic on the `infoWindow`
    and show it. You can see the code that does all this in the following:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要一种方法来在地图上显示查询到的图形。我们将创建一个名为 `_updateInfoWindowFromQuery()` 的方法，它接受一个
    `featureSet`，将其特征缩放到合适的大小，并添加 `infoWindow`。我们将使用 `esri/graphicsUtils` 模块来收集图形的整体范围，以便我们可以将其缩放。一旦异步缩放完成，我们将在
    `infoWindow` 上设置图形并显示它。您可以在以下代码中看到执行所有这些操作的代码：
- en: '[PRE17]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Handling events
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理事件
- en: Now, we will add event listeners to the `stateSelect`, `countySelect`, and `blockGroupSelect`
    items. We'll use the helper functions we developed in previous sections to populate
    the data, using some of our knowledge of `dojo/Deferred` to connect them asynchronously.
    Let's begin with the states.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将向 `stateSelect`、`countySelect` 和 `blockGroupSelect` 项添加事件监听器。我们将使用我们在前面的章节中开发的辅助函数来填充数据，并使用我们对
    `dojo/Deferred` 的了解来异步连接它们。让我们从州开始。
- en: When you select a state from the drop-down menu, the `select` element will fire
    a `change` event. We're not going to collect data on this event. Instead, we'll
    get data directly from the drop-down selectors and use that to generate the queries
    we need.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当您从下拉菜单中选择一个状态时，`select` 元素将触发一个 `change` 事件。我们不会收集这个事件的数据。相反，我们将直接从下拉选择器获取数据，并使用这些数据生成我们需要的查询。
- en: 'Let''s go ahead and stub out the `_stateSelectChanged()` method in the `Census`
    widget. It takes no arguments. We''ll do the same with the `_countySelectChanged()`
    and `_blockGroupSelectChanged()` methods as well. Then, using jQuery''s `.on()`
    method, we''ll listen for the `change` events in the `stateSelect`, `countySelect`,
    and `blockGroupSelect` controls. We''ll use dojo''s `lang.hitch()` method to make
    sure that, when we say `this`, we mean `this` widget. It should look like the
    following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续在 `Census` 小部件中创建 `_stateSelectChanged()` 方法。它不接受任何参数。我们将以相同的方式处理 `_countySelectChanged()`
    和 `_blockGroupSelectChanged()` 方法。然后，使用 jQuery 的 `.on()` 方法，我们将监听 `stateSelect`、`countySelect`
    和 `blockGroupSelect` 控件中的 `change` 事件。我们将使用 dojo 的 `lang.hitch()` 方法确保当我们说 `this`
    时，我们指的是 `this` 小部件。它应该看起来像以下这样：
- en: '[PRE18]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Handling the state
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理状态
- en: 'In the `_stateSelectChanged()` method, we''ll start by collecting the name
    of the state selected in `stateSelect`. If there is a value, we''ll start by querying
    for the graphical data on that state. We''ll use the `queryShapeAndData()` method
    to query for the shape data and process it. When that is complete, we can pass
    it along to the `_updateInfoWindowFromQuery()` method:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `_stateSelectChanged()` 方法中，我们将首先收集在 `stateSelect` 中选择的状态的名称。如果有值，我们将开始查询该州上的图形数据。我们将使用
    `queryShapeAndData()` 方法来查询形状数据并处理它。当这完成时，我们可以将其传递给 `_updateInfoWindowFromQuery()`
    方法：
- en: '[PRE19]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now that we''re showing the graphic, it''s time to fill in the county name.
    We''ll use the `queryDropdownData()` method to query for the list of counties,
    and using `.then()` asynchronously, pass the results to our `_populateDropdown()`
    method. We''ll assign the county names first in the list of queried values, because
    we want them in alphabetical order. We''ll tack that on at the end of the `_stateSelectChanged()`
    method, and it should appear like the following:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们正在显示图形，是时候填写县名了。我们将使用`queryDropdownData()`方法查询县列表，并使用`.then()`异步地将结果传递给我们的`_populateDropdown()`方法。我们将首先在查询值列表中分配县名，因为我们希望它们按字母顺序排列。我们将在`_stateSelectChanged()`方法的末尾添加它，它应该看起来像以下内容：
- en: '[PRE20]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: How the counties differ
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 各县之间的差异
- en: The counties should load similarly to the states. The big issue is that we are
    required to query for the underlying block groups in a county with state and county
    FIPs codes. There are no state or county names available in the block group census
    data.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 县应该以类似州的方式加载。主要问题是我们必须查询具有州和县FIP代码的县下的基础区块组。区块组人口普查数据中没有州或县名称。
- en: 'Since we assigned the FIP codes to the `data-fips` attributes of the drop-down
    options, there should be a way we can get them, right? Yes we can, but we''ll
    have to take advantage of jQuery''s chaining methods. From `stateSelect`, for
    instance, we can use the `jQuery.find(":selected")` method to find the selected
    option inside the `select`. From there, we can call jQuery''s `attr()` method
    to grab the `data-fips` attribute. For the state and county names and FIPs codes,
    it should look like the following:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将FIP代码分配给了下拉菜单的`data-fips`属性，应该有一种方法可以获取它们，对吧？是的，我们可以，但我们必须利用jQuery的链式方法。例如，从`stateSelect`，我们可以使用`jQuery.find(":selected")`方法在`select`中找到选定的选项。从那里，我们可以调用jQuery的`attr()`方法来获取`data-fips`属性。对于州和县名称以及FIP代码，它应该看起来像以下内容：
- en: '[PRE21]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: From here, we can use `stateName` and `countyName` to query for the correct
    county to show, and `stateFIPS` and `countyFIPS` to get the list of block groups.
    They'll use the same functions as the `_stateSelectChanged()` method, but with
    different map services and `where` clauses.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，我们可以使用`stateName`和`countyName`来查询要显示的正确县，使用`stateFIPS`和`countyFIPS`来获取区块组的列表。它们将使用与`_stateSelectChanged()`方法相同的函数，但具有不同的地图服务和`where`子句。
- en: Finally, the block groups
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 最后，区块组
- en: 'The `_blockGroupSelectChanged()` method is much easier to write, because we''re
    only interested in showing the block group. The key here is to collect the selected
    state FIP code, the selected county FIP code, and the `blockgroup` value from
    their respective dropdowns. Then we''ll piece together the `where` clause on the
    query, and request the graphics for the map. The method should look like the following
    code:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`_blockGroupSelectChanged()` 方法编写起来要容易得多，因为我们只对显示区块组感兴趣。关键在于收集从各自的下拉菜单中选择的州FIP代码、县FIP代码以及`blockgroup`值。然后我们将拼接查询中的`where`子句，并请求地图的图形。该方法应类似于以下代码：'
- en: '[PRE22]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Filling in the states
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 填充州信息
- en: Now that the application is wired, we can finally load the state data from the
    map service. We'll start by querying the state layer for state names and state
    FIP codes. To get all the states, we'll use a little SQL trick. SQL will return
    all rows where the `where` clause is true, so if you want all the rows, you have
    to return something that's always true. In this case, we'll assign `1=1` to the
    where clause for `queryDropdownData()`, because it is always true that `1=1`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应用程序已经连接好，我们终于可以从地图服务中加载数据了。我们将首先查询州层以获取州名和州FIP代码。为了获取所有州，我们将使用一个小巧的SQL技巧。SQL将返回`where`子句为真的所有行，因此如果你想要所有行，你必须返回一些总是为真的东西。在这种情况下，我们将`1=1`分配给`queryDropdownData()`的`where`子句，因为`1=1`总是为真。
- en: 'Once we receive the query results from the server, we''ll pass them to our
    `_populateDropdown()` method. We''ll assign the options to the `stateSelect` drop-down,
    show the state names on each choice, and store the FIP codes in the options as
    well. We''ll add the following snippet to the end of our `postCreate()` method:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们从服务器收到查询结果，我们将它们传递给我们的`_populateDropdown()`方法。我们将选项分配给`stateSelect`下拉菜单，在每个选项上显示州名，并将FIP代码也存储在选项中。我们将在`postCreate()`方法的末尾添加以下片段：
- en: '[PRE23]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: So, if we've wired everything up correctly, we can view the site in the browser
    and open the `Census` widget. We should then see the states already loaded in
    the drop-down menu. You will have to select a state before the counties fill in,
    and select a county for the block groups.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们已经正确连接了一切，我们就可以在浏览器中查看网站并打开`Census`小部件。然后我们应该看到已经加载到下拉菜单中的各州。在县份填充之前，您必须选择一个州，并为区块组选择一个县。
- en: Keep this project handy. We'll make copies of this one as a starting point for
    the other projects. Now let's try to build a Backbone app.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 将此项目放在手边。我们将以此作为起点复制此项目以用于其他项目。现在让我们尝试构建一个Backbone应用程序。
- en: An overview of Backbone.js
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Backbone.js概述
- en: With a simple application like the one we wrote with jQuery, the logic can turn
    into spaghetti-code rather quickly. We need to implement good practices to organize
    our code. Which practices do we implement? One of the first libraries to try to
    answer this question is Backbone.js.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在像我们用jQuery编写的简单应用程序中，逻辑可以迅速变成意大利面代码。我们需要实施良好的实践来组织我们的代码。我们实施哪些实践？第一个试图回答这个问题的库之一是Backbone.js。
- en: Backbone.js is one of the earliest JavaScript libraries to implement a **Model
    View Controller (MVC)** architecture. MVC organizes code by separating data and
    business logic (the `Model`) from the output (the `View`) and updates both through
    a separate component (the `Controller`). With MVC, you don't write a complicated
    JavaScript function that gets input from some text blanks, adds the contents together,
    and saves the results. Those three actions can be written into three different
    functions, separated by what they do and how they fit into the `Model`, `View`,
    and `Controller` classifications.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Backbone.js是早期实现**模型-视图-控制器（MVC）**架构的JavaScript库之一。MVC通过将数据和企业逻辑（`Model`）与输出（`View`）分离，并通过一个单独的组件（`Controller`）更新两者来组织代码。使用MVC，您不需要编写一个复杂的JavaScript函数，该函数从一些文本框中获取输入，将内容相加，并保存结果。这三个动作可以写入三个不同的函数，分别根据它们的功能以及它们如何适合`Model`、`View`和`Controller`分类。
- en: Backbone.js requires a couple of other libraries in order to work properly.
    Backbone uses jQuery to handle DOM manipulation, including showing and hiding
    elements on the page. Backbone also requires another library called Underscore.js.
    This library provides a number of functions and shortcuts for dealing with JavaScript
    objects, arrays, and so forth. Underscore.js provides methods found in `dojo/_base/lang`
    and `dojo/_base/array`, as well as other methods that can help you pull out relevant
    data from your feature graphics.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Backbone.js需要几个其他库才能正常工作。Backbone使用jQuery来处理DOM操作，包括在页面上显示和隐藏元素。Backbone还需要另一个名为Underscore.js的库。这个库提供了一系列处理JavaScript对象、数组等的函数和快捷方式。Underscore.js提供了在`dojo/_base/lang`和`dojo/_base/array`中找到的方法，以及可以帮助您从特征图形中提取相关数据的其他方法。
- en: Components of Backbone
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Backbone的组件
- en: 'Compared to most popular libraries and frameworks, Backbone.js is rather simple.
    It organizes your code into five categories: `Model`, `View`, `Collection`, `Event`,
    and `Router`. These work together to showcase your data and react to user input.
    All but the events are created through Backbone''s `extend()` method, which contains
    a JavaScript object that defines the `Model`, `View`, `Collection`, or `Router`.
    Events, on the other hand, are defined through the creation of the other items.
    Let''s review each item individually.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数流行的库和框架相比，Backbone.js相当简单。它将您的代码组织成五个类别：`Model`、`View`、`Collection`、`Event`和`Router`。这些类别共同展示您的数据并对用户输入做出反应。除了事件之外，所有这些类别都是通过Backbone的`extend()`方法创建的，该方法包含一个定义`Model`、`View`、`Collection`或`Router`的JavaScript对象。另一方面，事件是通过创建其他项目来定义的。让我们逐个回顾每个项目。
- en: The Model
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模型
- en: Backbone.js' `Model` provides a description of the data you're going to use.
    You can assign default properties, methods, and events to the model that will
    be called by application features created in the other categories. Models are
    created through the `Backbone.Model.extend()` constructor method. Models created
    with this method become constructors for model data in your application. Data
    created through models have different methods to `get()` and `set()` data, test
    for the presence of data through `has()`, and even detect changes in the data
    through `isChanged()` or `changedAttributes()`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Backbone.js 的 `Model` 提供了将要使用的数据的描述。你可以将默认属性、方法和事件分配给模型，这些模型将由其他类别中创建的应用程序功能调用。模型通过
    `Backbone.Model.extend()` 构造函数创建。使用此方法创建的模型成为应用程序中模型数据的构造函数。通过模型创建的数据具有不同的 `get()`
    和 `set()` 数据的方法，通过 `has()` 测试数据的存在，甚至可以通过 `isChanged()` 或 `changedAttributes()`
    检测数据的变化。
- en: 'Here''s an example of a playing card model, as well as a card created using
    the model. The `CardModel` variable includes `rank` and `suit` properties, as
    well as a function to describe the card in a single string:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个玩牌模型示例，以及使用该模型创建的卡片。`CardModel` 变量包括 `rank` 和 `suit` 属性，以及一个用于将卡片描述为单个字符串的函数：
- en: '[PRE24]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The View
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 视图
- en: The Backbone `View` sets up how the data will be presented in the application.
    The `View` defines the HTML output through a series of parameters defined in the
    `Backbone.View.extend()` constructor. You can create a view on a particular DOM
    element in your HTML by assigning the `.el` property in the `extend()` constructor
    method. You can also assign a `tagName` property to define the HTML element that
    is created, a `template` property if the content is more complicated than a single
    element, and even a `className` property to assign a CSS class to the main element.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Backbone 的 `View` 设置了数据在应用程序中的展示方式。`View` 通过一系列在 `Backbone.View.extend()` 构造函数中定义的参数来定义
    HTML 输出。你可以在 HTML 中的特定 DOM 元素上创建一个视图，通过在 `extend()` 构造函数方法中分配 `.el` 属性来实现。你还可以分配一个
    `tagName` 属性来定义创建的 HTML 元素，一个 `template` 属性如果内容比单个元素更复杂，甚至可以分配一个 `className` 属性来将
    CSS 类分配给主元素。
- en: The view makes heavy use of both jQuery and Underscore.js. For example, while
    the element of the view is defined by the view's `.el` property, a jQuery version
    is available by referring to the Views `$el` property. Also, HTML content can
    be defined through the view's template, which is created through Underscore's
    `.template()` creator.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 视图大量使用了 jQuery 和 Underscore.js。例如，虽然视图的元素由视图的 `.el` 属性定义，但可以通过引用视图的 `$el` 属性获得
    jQuery 版本。此外，HTML 内容可以通过视图的模板定义，该模板是通过 Underscore 的 `.template()` 创建器创建的。
- en: When a view is first created, it starts with a method called `initialize()`
    that you define. In the `initialize()` method, you can assign event listeners
    to other parts of the view, including models and collections. You can also tell
    the view to `render()`, or write out the HTML code. The `render()` method that
    you define is used to add the custom HTML within the `View` element. You can also
    render other views within the `View`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当视图首次创建时，它从一个名为 `initialize()` 的方法开始，该方法由你定义。在 `initialize()` 方法中，你可以将事件监听器分配给视图的其他部分，包括模型和集合。你还可以告诉视图
    `render()`，或者写出 HTML 代码。你定义的 `render()` 方法用于在 `View` 元素内添加自定义 HTML。你还可以在 `View`
    内渲染其他视图。
- en: 'In the following code, you can find a sample `View` to show a card:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，你可以找到一个展示卡片的示例 `View`：
- en: '[PRE25]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The Collection
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集合
- en: If a `Backbone` model describes one piece of data, how do you describe a list
    of them? That's where a `Collection` comes in. A collection represents a list
    of data items of a particular model. As is probably no surprise, a `Collection`
    constructor can be created using the `Backbone.Collection.extend()` method.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个 `Backbone` 模型描述了一个数据项，那么如何描述一个数据项的列表呢？这就是 `Collection` 的用武之地。一个 `Collection`
    代表了特定模型的数据项列表。可能不会让人意外，`Collection` 构造函数可以通过 `Backbone.Collection.extend()` 方法创建。
- en: Collections offer a number of methods for managing the content of your list.
    You can `.add()` or `.remove()` model-defined items from your collection list,
    as well as `.reset()` the entire list to whatever you pass as a parameter. You
    can define a `url` parameter as a JSON data source, and `.fetch()` the data.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 集合提供了一系列管理列表内容的方法。你可以从集合列表中 `.add()` 或 `.remove()` 模型定义的项目，以及 `.reset()` 整个列表到传递的任何参数。你可以定义一个
    `url` 参数作为 JSON 数据源，并 `.fetch()` 数据。
- en: 'In the following code, you can see how a `Collection` is created using a deck
    of cards. It is based on the `CardModel` defined in the model:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，你可以看到如何使用一副扑克牌创建一个 `Collection`。它基于在模型中定义的 `CardModel`：
- en: '[PRE26]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Implementing a router
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现路由器
- en: Backbone routers help define the state of the application through the URL. They
    respond to changes in the URL hash, or the text following the `#` symbol in the
    URL. The hash was originally created in web pages to allow you to click an anchor
    tag to move down the page to related content, without reloading the entire page.
    When a `Backbone` router is enabled, you can change the hash, say, through a button
    or anchor click, and it will run some JavaScript code in response to the content.
    All this happens, and the page doesn't reload.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Backbone路由器帮助通过URL定义应用程序的状态。它们响应URL哈希的变化，或者URL中 `#` 符号后面的文本。哈希最初是在网页中创建的，以便你可以点击锚点标签向下移动页面到相关内容，而无需重新加载整个页面。当启用
    `Backbone` 路由器时，你可以更改哈希，比如通过按钮或锚点点击，它将运行一些JavaScript代码来响应内容。所有这些都在发生，页面不会重新加载。
- en: This lack of page reloads when the router changes makes single-page applications
    possible. Instead of loading new pages, Backbone can simply show different views
    in response to the router. This gives a snappier response on the page.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当路由器更改时没有页面重新加载，这使得单页应用程序成为可能。而不是加载新页面，Backbone可以简单地根据路由器显示不同的视图。这给页面带来了更快的响应。
- en: Handling events
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理事件
- en: Events are defined within the other items created by Backbone. Event listeners
    are attached to elements of the `Model`, `View`, `Collection`, or `Router`, by
    way of the `on()` method. The `on()` method takes three parameters, a string containing
    the name of the event, the function that is to be called when the event occurs,
    and the context that defines what `this` is.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 事件在Backbone创建的其他项中定义。通过 `on()` 方法将事件监听器附加到 `Model`、`View`、`Collection` 或 `Router`
    的元素上。`on()` 方法接受三个参数，一个包含事件名称的字符串，当事件发生时要调用的函数，以及定义 `this` 的上下文。
- en: 'Events within HTML elements created by the view are defined in a different
    way. The `Backbone.View.extend()` constructor contains an `events` parameter that
    is defined by an unusually formatted JSON object. Event names, and jQuery selectors
    for the elements, are used as the key, and a string containing the name of the
    function called in the view makes up the key value. Example events might look
    like the following:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 由视图创建的HTML元素中的事件以不同的方式定义。`Backbone.View.extend()` 构造函数包含一个 `events` 参数，它由一个格式不寻常的JSON对象定义。事件名称和元素的jQuery选择器用作键，一个包含在视图中调用的函数名称的字符串组成键值。示例事件可能如下所示：
- en: '[PRE27]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Putting some Backbone in your app
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在你的应用程序中加入一些Backbone
- en: Since Backbone uses jQuery under the hood to work with the DOM, we can reuse
    much of the code from our jQuery application. We'll be using the same ArcGIS JavaScript
    API modules to interact with the map services. We'll only change how the drop-down
    options are rendered and how the change events on those dropdowns are handled.
    So, let's start by making a copy of our jQuery application and naming the folder
    `Backbone`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Backbone底层使用jQuery与DOM交互，我们可以重用jQuery应用程序中的大部分代码。我们将使用相同的ArcGIS JavaScript
    API模块与地图服务交互。我们只需更改下拉选项的渲染方式和处理这些下拉框上的更改事件。所以，让我们先复制我们的jQuery应用程序，并将文件夹命名为 `Backbone`。
- en: 'Next, we''ll need to add references to the Backbone and Underscore libraries
    in our `dojoConfig`, so that they are available through AMD. We''ll load them
    from a CDN source for this application, although you''re free to download them
    into folders for your own applications:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要在我们的 `dojoConfig` 中添加对Backbone和Underscore库的引用，以便它们可以通过AMD可用。对于这个应用程序，我们将从CDN源加载它们，尽管你可以将它们下载到自己的应用程序文件夹中：
- en: '[PRE28]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'After that, we''ll make reference to the jQuery, Underscore, and Backbone libraries
    in our `define` statement in the `Census.js` file. The files should load in as
    so:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将在 `Census.js` 文件中的 `define` 语句中引用jQuery、Underscore和Backbone库。文件应按如下方式加载：
- en: '[PRE29]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Defining the models
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义模型
- en: 'Now, we have the opportunity to define the data models that we''ll be working
    with. If you remember from the jQuery exercise, we were primarily interested in
    the names and the FIP codes for the census locations. In the `postCreate()` method
    of the census widget, we''ll define our models using default values from those
    fields:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有定义我们将要工作的数据模型的机会。如果你还记得jQuery练习，我们主要对普查地点的名称和FIP代码感兴趣。在普查小部件的 `postCreate()`
    方法中，我们将使用这些字段的默认值来定义我们的模型：
- en: '[PRE30]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Defining the collections
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义集合
- en: 'For the state, county, and block group collections, we''ll simply define them
    based on the corresponding models we defined previously. We''ll then create collection
    objects that are tied to the Dojo `dijit`. It should look like the following:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 对于州、县和街区组集合，我们将简单地根据之前定义的相应模型来定义它们。然后我们将创建与Dojo `dijit`关联的集合对象。它应该看起来像以下这样：
- en: '[PRE31]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Defining the views
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义视图
- en: Now that we've defined our models and collections, it's time to create a view
    for them. Our view should create the options with the data that we need in our
    application. We'll need to create a separate view for each of the dropdowns, since
    assigning templates when the view is created causes errors with this version of
    the Backbone.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了我们的模型和集合，是时候为它们创建视图了。我们的视图应该创建出我们在应用程序中需要的数据选项。由于在创建视图时分配模板会导致Backbone版本出现错误，因此我们需要为每个下拉菜单创建一个单独的视图。
- en: 'Let''s start with the `StateView` variable. The `StateView` variable will be
    created through `Backbone.View.extend`. In the `StateView` variable, we want to
    define a template, an `initialize()` method, and a `render()` method. The `initialize()`
    method will listen for the collection''s `reset` event, and cause it to `render()`
    again. The template is defined by Underscore''s `_.template` function called on
    an HTML string pulled up by jQuery. The jQuery selector will look for our state
    option template by looking for an element with the ID of `stateitemtemplate`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`StateView`变量开始。`StateView`变量将通过`Backbone.View.extend`创建。在`StateView`变量中，我们想要定义一个模板、一个`initialize()`方法和一个`render()`方法。`initialize()`方法将监听集合的`reset`事件，并使其再次`render()`。模板是通过Underscore的`_.template`函数定义的，该函数调用由jQuery拉取的HTML字符串。jQuery选择器将查找具有`stateitemtemplate`
    ID的元素：
- en: '[PRE32]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In the preceding view, the `render` function does two things. First, it loads
    the view template and the empty jQuery selection object into variables. Next,
    it iterates over each of the collection models using Underscore's `each()` method,
    fills in the template with the JSON content from the model, and appends it inside
    the `select` element. Some other Backbone examples would stop the option creation
    from appending the options to the `select` element in a separate view, but this
    method was chosen for compact purposes.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的视图中，`render`函数做了两件事。首先，它将视图模板和空的jQuery选择对象加载到变量中。接下来，它使用Underscore的`each()`方法遍历每个集合模型，用模型中的JSON内容填充模板，并将其追加到`select`元素内部。一些其他的Backbone示例会在单独的视图中停止选项创建，将选项追加到`select`元素中，但这种方法是为了简洁而选择的。
- en: 'Now that the `StateView` is defined, you can copy and paste the code and tweak
    it to create separate `CountyView` and `BlockGroupView` constructors. In each
    of those, the only thing you need to change is the template jQuery selector, to
    `#countyitemtemplate` and `#blkgrpitemtemplate`, respectively. Keep the `initialize()`
    and `render()` methods the same:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已经定义了`StateView`，你可以复制并粘贴代码，并对其进行调整以创建单独的`CountyView`和`BlockGroupView`构造函数。在这些构造函数中，你需要更改的唯一事情是模板jQuery选择器，分别更改为`#countyitemtemplate`和`#blkgrpitemtemplate`。保持`initialize()`和`render()`方法不变：
- en: '[PRE33]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Finally, we''ll assign our actual view properties to these `View` constructors.
    With each view, we''ll assign the element they''ll be rendered from, which are
    the `select` elements in our widget and the collections they will be using:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将实际的视图属性分配给这些`View`构造函数。对于每个视图，我们将分配它们将要渲染的元素，即我们的小部件中的`select`元素以及它们将要使用的集合：
- en: '[PRE34]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Creating templates
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建模板
- en: Thinking back to the jQuery app, we filled in the select dropdowns with options
    tags that contained data on both the name of the feature and a FIP code with which
    we could query the next level down. We need to create the same HTML elements in
    HTML templates rather than piecing them together through code. We'll do this by
    adding HTML templates to our main page.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下jQuery应用程序，我们用包含特征名称和可用于查询下一级FIP代码的选项标签填充了选择下拉菜单。我们需要在HTML模板中创建相同的HTML元素，而不是通过代码将它们拼接在一起。我们将通过向我们的主页添加HTML模板来完成此操作。
- en: How do we create HTML templates that aren't visible on the page? We can do this
    by inserting them into script tags. We'll give each template script tag a type
    of `text/template`. This lets us know that the content of the script is actually
    HTML code. Browsers will look at the type, not know what to do with a `text/template`
    type, and simply ignore it.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何创建页面上不可见的 HTML 模板？我们可以通过将它们插入到脚本标签中来实现。我们将给每个模板脚本标签一个 `text/template` 类型。这让我们知道脚本的内容实际上是
    HTML 代码。浏览器会查看类型，不知道如何处理 `text/template` 类型，因此简单地忽略它。
- en: 'So, let''s create templates for the state options, county options, and block
    group options. We''ll assign the templates IDs of `stateitemtemplate`, `countyitemtemplate`,
    and `blkgrpitemtemplate`, as we added in our code. In each template, we''ll assign
    the value, text, and `data-fips` value to the appropriate item in the model. Take
    a look at the following templates:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们为州选项、县选项和区块组选项创建模板。我们将分配模板 ID 为 `stateitemtemplate`、`countyitemtemplate`
    和 `blkgrpitemtemplate`，正如我们在代码中所添加的那样。在每个模板中，我们将值、文本和 `data-fips` 值分配给模型中的适当项。请看以下模板：
- en: '[PRE35]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Depending on the template library you use, different libraries have different
    ways to assign values. Underscore's `template()` method wraps the attribute names
    in `<%= %>` tags. You can use other template libraries, such as Handlebars.js,
    but, since Underscore is required, why not use what we have?
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你使用的模板库，不同的库有不同的赋值方式。Underscore 的 `template()` 方法将属性名称包裹在 `<%= %>` 标签中。你可以使用其他模板库，如
    Handlebars.js，但由于需要 Underscore，为什么不使用我们已有的呢？
- en: Wiring events
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接事件
- en: Now let's make things happen. We're going to reuse the event listeners we created
    for the jQuery exercise, and make them work for Backbone. We'll start by looking
    at the `_stateSelectChanged()` method.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们让事情发生。我们将重用为 jQuery 练习创建的事件监听器，并使它们适用于 Backbone。我们将从查看 `_stateSelectChanged()`
    方法开始。
- en: The first thing that changes is how we collect `stateName` and `stateFIPS`.
    Instead of referring the `stateSelect` that was previously defined as a jQuery
    object, we'll access the `select` through the `stateView.$el` property. Remember
    that, in a `View`, the `el` property exposes the DOM element, while the `$el`
    property exposes the jQuery element. For the other selection change listeners,
    we can find and replace `countySelect` and `blockGroupSelect` with `countyView.$el`
    and `blockGroupView.$el`, respectively.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 首先改变的是我们如何收集 `stateName` 和 `stateFIPS`。我们不再引用之前定义的作为 jQuery 对象的 `stateSelect`，而是通过
    `stateView.$el` 属性访问 `select`。记住，在 `View` 中，`el` 属性暴露 DOM 元素，而 `$el` 属性暴露 jQuery
    元素。对于其他选择更改监听器，我们可以找到并替换 `countySelect` 和 `blockGroupSelect` 为 `countyView.$el`
    和 `blockGroupView.$el`。
- en: 'The only other part that needs changing is how the new drop-down data is populated
    after it is queried form the map service. We can replace the `_populateDropdown()`
    method with a simple anonymous function. In the anonymous function, we''ll create
    a list of feature attributes from the `featureSet` using Underscore''s `pluck()`
    method. It goes item by item through an array, and grabs the property of the item
    you describe and puts that in a new list. Next, we''ll assign that list to the
    `countyCollection` through its `reset()` method. That''s all that is needed to
    update the county list. The same process can be performed on the `_countySelectChanged()`
    method to repopulate the block groups. Your code changes should look like the
    following:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 需要更改的唯一其他部分是在从地图服务查询后如何填充新的下拉数据。我们可以用简单的匿名函数替换 `_populateDropdown()` 方法。在匿名函数中，我们将使用
    Underscore 的 `pluck()` 方法从 `featureSet` 创建一个属性列表。它逐项遍历数组，获取你描述的项的属性，并将其放入一个新的列表中。接下来，我们将通过其
    `reset()` 方法将这个列表分配给 `countyCollection`。这就是更新县列表所需的所有内容。同样的过程也可以应用于 `_countySelectChanged()`
    方法，以重新填充区块组。你的代码更改应如下所示：
- en: '[PRE36]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Getting the Backbone to dance
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 让 Backbone 跳舞
- en: 'Finally, we need to populate the initial value of `stateView`. We''ll use the
    `queryDropdownData()` method call at the end of jQuery''s `postCreate()`. If we
    make the same changes to this call that we made to the event listeners, we should
    be able to populate the state drop-down menu. From there, we should be able to
    populate the other menus through the event listeners we assigned to the `View`
    elements:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要填充 `stateView` 的初始值。我们将在 jQuery 的 `postCreate()` 方法调用的末尾使用 `queryDropdownData()`
    方法。如果我们对这个调用做出与事件监听器相同的更改，我们应该能够填充状态下拉菜单。从那里，我们应该能够通过分配给 `View` 元素的事件监听器填充其他菜单：
- en: '[PRE37]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Note
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you want to learn more about implementing ArcGIS JavaScript APIs using Backbone.js
    and Marionette, you can review the blog posts by Dave Bouwman on the matter at
    [http://blog.davebouwman.com/2013/02/20/part-1-app-design-and-page-layout/](http://blog.davebouwman.com/2013/02/20/part-1-app-design-and-page-layout/).
    For more information on Backbone.js, you can read *Backbone.js Patterns and Best
    Practices* by Swarnendu De.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于使用Backbone.js和Marionette实现ArcGIS JavaScript API的信息，你可以查看Dave Bouwman关于此问题的博客文章，网址为[http://blog.davebouwman.com/2013/02/20/part-1-app-design-and-page-layout/](http://blog.davebouwman.com/2013/02/20/part-1-app-design-and-page-layout/)。有关Backbone.js的更多信息，你可以阅读Swarnendu
    De的《Backbone.js Patterns and Best Practices》。
- en: An overview of Knockout.js
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Knockout.js概述
- en: Another JavaScript library that can be used to create an interactive single
    page application is Knockout.js. Knockout was developed by Steve Sanderson of
    Microsoft, though it's not considered a Microsoft product. It's based on Windows
    Presentation Framework in that it uses the **Model-View-ViewModel (MVVM)** architecture
    and allows two-way binding on observed properties. Two-way binding means that
    data isn't just written to an HTML element, but it can also be updated, like a
    text input field in a form, and the data will be already reflected in the application.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可以用来创建交互式单页应用的JavaScript库是Knockout.js。Knockout.js是由微软的Steve Sanderson开发的，尽管它不被视为微软的产品。它基于Windows
    Presentation Framework，因为它使用**模型-视图-ViewModel (MVVM**)架构，并允许在观察属性上进行双向绑定。双向绑定意味着数据不仅被写入HTML元素，还可以更新，就像表单中的文本输入字段一样，数据将已经在应用中反映出来。
- en: Knockout and MVVM
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Knockout和MVVM
- en: The MVVM is similar in nature to MVC architecture. Both use a model to get to
    the data, and a `View` to show the data. However, instead of an active controller
    directing the model and views, the `ViewModel` sits under the UI layer and exposes
    functions and data from the model to the `View`. The `ViewModel` typically knows
    nothing about the `View` it's working with. It simply stores and provides information
    as requested by the HTML `View`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: MVVM架构在本质上与MVC架构相似。两者都使用模型来获取数据，并使用`View`来显示数据。然而，与一个主动的控制器指导模型和视图不同，`ViewModel`位于UI层之下，并将模型的功能和数据暴露给`View`。`ViewModel`通常对其所工作的`View`一无所知。它只是根据HTML
    `View`的请求存储和提供信息。
- en: 'In Knockout, the `ViewModel` is created like any normal JavaScript object,
    with a few additions from Knockout. Properties of the `ViewModel` that are used
    in two-way binding are created using Knockout''s `observable()` and `observableArray()`
    constructors. This allows these properties to be accessed by the `View`, and updated
    without having to update the DOM, as you would have to in jQuery. A constructor
    looks something like the following:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在Knockout中，`ViewModel`的创建方式与任何正常的JavaScript对象一样，只是Knockout增加了一些功能。用于双向绑定的`ViewModel`属性使用Knockout的`observable()`和`observableArray()`构造函数创建。这允许这些属性被`View`访问，并更新，而不需要像jQuery那样更新DOM。构造函数看起来如下所示：
- en: '[PRE38]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The HTML document acts as a `View`, and can be bound to the `ViewModel` through
    the HTML5-based `data-*` attributes (more specifically, the `data-bind` attribute).
    When the browser loads an HTML view and a script containing the `ViewModel`, the
    Knockout will bind attributes in the data-bind tags to the appropriate fields
    in the `ViewModel`. For the preceding `ViewModel` created, you might see some
    HTML like the following:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: HTML文档充当`View`，可以通过基于HTML5的`data-*`属性（更具体地说，是`data-bind`属性）绑定到`ViewModel`。当浏览器加载包含`ViewModel`的HTML视图和脚本时，Knockout将绑定`data-bind`标签中的属性到`ViewModel`中的相应字段。对于前面创建的`ViewModel`，你可能会看到一些如下所示的HTML：
- en: '[PRE39]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In the `ViewModel`, properties can be added that are computed values based
    on other observables in the `ViewModel`. These are created with the `ko.computed()`
    constructor. For example, we can take the `PersonViewModel` in the preceding code
    and add a computed `fullName` property that automatically updates when the first
    or last name changes:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ViewModel`中，可以添加基于`ViewModel`中其他可观察值的计算属性。这些属性使用`ko.computed()`构造函数创建。例如，我们可以从前面代码中的`PersonViewModel`添加一个计算属性`fullName`，当名字或姓氏改变时，它会自动更新：
- en: '[PRE40]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Knockout doesn't have many extra features that other libraries and frameworks
    possess, such as routers and AJAX requests. It typically relies on other libraries,
    such as `Sammy.js` for routing and jQuery for AJAX. However, what it does offer
    is two-way binding that works even in older browsers.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Knockout没有许多其他库和框架所拥有的额外功能，例如路由器和AJAX请求。它通常依赖于其他库，如`Sammy.js`用于路由和jQuery用于AJAX。然而，它所提供的是即使在旧浏览器上也能工作的双向绑定。
- en: Using Knockout in our app
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s make another copy of our jQuery app and name the folder `Knockout`.
    We will not need jQuery for this application, since we can use Knockout and the
    ArcGIS JavaScript API to handle those functions. We''ll start by replacing all
    the references to jQuery with Knockout references. The `dojoConfig` script at
    the head of the document should look like the following:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Next, we''ll add a reference to Knockout in our `Census.js` file. We''ll keep
    the other AMD modules and code, and we''ll replace things as we go. The `define()`
    statement at the top of `Census.js` should look a bit like the following:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Defining the ViewModel
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We know what kind of data model we're dealing with, but what we need is a `ViewModel`
    to organize it. We can create the `ViewModel` constructor in our `Census` dijit,
    and expose it for use by our widget.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `ViewModel` for this widget only requires six items. We need to maintain
    the lists of states, counties, and block groups, to populate the `select` elements,
    as well as the selected values. For the `stateList`, `countyList`, and `blockGroupList`
    properties of the `ViewModel`, we''ll construct Knockout''s `observableArrays`
    for each. `selectedState`, `selectedCounty`, and `selectedBlockGroup` will each
    be created using Knockout observables. You can see how we construct the `ViewModel`
    in the widget in the following example:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Adding custom binding handlers
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In our jQuery and Backbone applications, we attached event listeners to the
    `select` elements so that, when they change, we can query for census data and
    populate the next select down. In Knockout, we can do the same thing using custom
    binding handlers. Binding handlers have two optional methods: `init()` and `update()`.
    The `init()` method runs when binding first occurs, while the `update()` method
    runs every time the bound value changes. Both `init()` and `update()` have five
    arguments, as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '`element`: The HTML DOM element involved in the binding.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`valueAccessor`: A function that gives access to the observable property bound
    to the element. To get the value of this property, call the `ko.unwrap()` method
    on the value returned from `ValueAccessor()`.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`allBindings`: An object used to get the particular bindings to the element,
    like the text, value, or name. Binding properties can be retrieved using `allBindings.get()`.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`viewModel`: This was the old way to get at the entire `ViewModel`, prior to
    version 3.x.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bindingContext`: This is the way to get to all the bindings. `bindingContext`
    may have at least some of the following:'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$data`: The current `ViewModel` assigned to this element'
  id: totrans-190
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$rawData`: Direct access to the values held in the `ViewModel`'
  id: totrans-191
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$parent`: Access to the parent `ViewModel` this `ViewModel` may be assigned
    to'
  id: totrans-192
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$parents`: An array object providing access to each tier of `ViewModel` connected
    to this `ViewModel`'
  id: totrans-193
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$root`: This grants direct access to the base `ViewModel`, originally bound
    to the entire page'
  id: totrans-194
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We need to create the binding handlers before we apply bindings to the page.
    While we can create the binding handlers earlier, we''re going to assign them
    in the `postCreate()` method of our widget, since that''s where we''ve applied
    the changes in our other applications. We''ll start by creating some empty binding
    handlers for `stateUpdate`, `countyUpdate`, and `blockGroupUpdate`. We''re only
    interested in the `update()` methods, so we''ll leave the `init()` method out.
    The following code is the empty version of `stateUpdate`:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在将绑定应用到页面之前，我们需要创建绑定处理程序。虽然我们可以在更早的时候创建绑定处理程序，但我们打算在部件的`postCreate()`方法中分配它们，因为这是我们其他应用程序中应用更改的地方。我们将首先为`stateUpdate`、`countyUpdate`和`blockGroupUpdate`创建一些空的绑定处理程序。我们只对`update()`方法感兴趣，所以我们将省略`init()`方法。以下代码是`stateUpdate`的空版本：
- en: '[PRE44]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Within the binding handlers, and the subsequent calls to the ArcGIS JavaScript
    API modules, the widget scope is going to get lost. In the `postCreate()` method,
    we''ll create a variable named `self`, and assign a reference to the widget to
    it, like so:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在绑定处理程序和随后的对ArcGIS JavaScript API模块的调用中，部件作用域将会丢失。在`postCreate()`方法中，我们将创建一个名为`self`的变量，并将对部件的引用分配给它，如下所示：
- en: '[PRE45]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'With the binding handlers set, we''ll bring our code over from our previous
    event handlers. From _`stateSelectChanged()`, we''ll copy over the code and make
    our changes. First, we''ll change how the functions collect the state names and
    census FIP codes for the queries. Once we have the names, getting the visual data
    will be easy. Finally, we''ll change how the `ViewModel` is updated once the query
    for the counties in the state is finished. The `stateUpdate` binding handler should
    look like the following:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 设置了绑定处理程序后，我们将从我们之前的事件处理程序中迁移我们的代码。从`_stateSelectChanged()`复制代码并做出我们的更改。首先，我们将更改函数收集州名称和人口普查FIP代码以供查询的方式。一旦我们有了名称，获取视觉数据将会很容易。最后，我们将更改一旦完成对州内县的查询后如何更新`ViewModel`。`stateUpdate`绑定处理程序应如下所示：
- en: '[PRE46]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'For the county and the block groups, we''ll follow similar patterns in `countyUpdate`
    and `blockGroupUpdate`. Remember the following changes for this app:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 对于县和区块组，我们将在`countyUpdate`和`blockGroupUpdate`中遵循类似的模式。记住以下对这个应用程序的更改：
- en: Replacing references to `this` with the variable `self`
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`this`引用替换为变量`self`
- en: Get county and block group feature attribute data from `ko.unwrap(valueAccessor())`
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从`ko.unwrap(valueAccessor())`获取县和区块组特征属性数据
- en: Collect the list of feature attributes for the drop-down list using the `Dojo`
    module method `arrayUtils.map()`
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Dojo`模块方法`arrayUtils.map()`收集下拉列表的特征属性列表
- en: Add an attribute with blank values to the first feature of the feature attributes
    list
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在特征属性列表的第一个特征上添加一个值为空的属性
- en: Add the new list to the `bindingContext.$data` array
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将新列表添加到`bindingContext.$data`数组中
- en: Defining the View
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义视图
- en: Now that we've done all the hard work setting up the `ViewModel` and the related
    functionality, let's work with some HTML. Open the `Census.html` template in the
    `js/template/` folder. This is where we are going to apply our `View`. Start by
    removing the class assignments on the three `select` elements, and replace them
    with the text `data-bind=""`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了设置`ViewModel`及其相关功能的所有艰苦工作，让我们来处理一些HTML。在`js/template/`文件夹中打开`Census.html`模板。这是我们将要应用`View`的地方。首先，移除三个`select`元素上的类分配，并用文本`data-bind=""`替换它们。
- en: 'Next, we''re going to assign four properties within each data-bind context:
    `options`, `optionsText`, `value`, and the appropriate binding handler we created
    in the previous section. The options will be assigned to the appropriate `observableArray`
    list. The `optionsText` will be the field name that we want to see on the options.
    Both the value and the binding handler we created will be bound to the selected
    observable for that type. The `Census.html` file should look like the following:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在每个`data-bind`上下文中分配四个属性：`options`、`optionsText`、`value`以及我们在上一节中创建的适当绑定处理程序。选项将被分配到适当的`observableArray`列表中。`optionsText`将是我们要在选项中看到的字段名称。值和我们创建的绑定处理程序都将绑定到该类型的选定可观察对象。`Census.html`文件应如下所示：
- en: '[PRE47]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Applying the ViewModel
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用ViewModel
- en: 'Now that we have a working `View` and `ViewModel`, and the code that links
    it to our `Model`, it''s time to put it all together. Once the page has loaded
    in the `postCreate()` method, and all our binding handlers have been assigned,
    it''s safe to call `ko.applyBindings()` to the `ViewModel`. In most examples that
    you see online, the `ViewModel` is bound as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了工作的`View`和`ViewModel`，以及将它们与`Model`连接的代码，是时候将它们全部组合在一起了。一旦页面在`postCreate()`方法中加载，并且所有我们的绑定处理程序都已分配，就可以安全地调用`ko.applyBindings()`到`ViewModel`上。在您在网上看到的多数示例中，`ViewModel`的绑定方式如下：
- en: '[PRE48]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'It would be great to finish with that and call it a day, but we don''t have
    any state data to start out the `SelectViewModel`. We''re going to have it assign
    it some way. We''re going to take some code from the jQuery and Backbone code
    to assign the initial values to the state dropdowns. We''ll then modify it to
    fit the pattern we established for assigning the other dropdowns. We''ll query
    for a list of states, and add the list to our working `ViewModel`, like so:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果能就此结束并称之为一天，那将是极好的，但我们没有状态数据来初始化`SelectViewModel`。我们将以某种方式分配它。我们将从jQuery和Backbone代码中取一些代码来分配状态下拉框的初始值。然后我们将修改它以适应我们为分配其他下拉框所建立的模式。我们将查询州列表，并将列表添加到我们的工作`ViewModel`中，如下所示：
- en: '[PRE49]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Note
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more information on KnockoutJS, you can visit [http://knockoutjs.com](http://knockoutjs.com)
    or [http://learn.knockoutjs.com](http://learn.knockoutjs.com) for interactive
    tutorials. For books on the library, you can check out *KnockoutJS Starter* by
    Eric M. Barnard, or *Mastering KnockoutJS* by Timothy Moran.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如需了解更多关于KnockoutJS的信息，您可以访问[http://knockoutjs.com](http://knockoutjs.com)或[http://learn.knockoutjs.com](http://learn.knockoutjs.com)获取交互式教程。关于该库的书籍，您可以查阅Eric
    M. Barnard所著的*KnockoutJS Starter*，或Timothy Moran所著的*Mastering KnockoutJS*。
- en: A brief overview of AngularJS
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AngularJS简要概述
- en: One of the more recent popular frameworks that we can use alongside our JavaScript
    application is AngularJS. Angular was originally created at Google as a language
    to help designers code. It quickly grew into the JavaScript framework of choice,
    both at Google and abroad. The core Angular development team makes sure that Angular
    excels in data binding and testability.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在JavaScript应用程序旁边使用的较新的流行框架之一是AngularJS。Angular最初在Google创建，作为一种帮助设计师编码的语言。它很快成为Google和国外首选的JavaScript框架。核心Angular开发团队确保Angular在数据绑定和可测试性方面表现出色。
- en: Angular works by parsing through the HTML page for specific element attributes.
    These attributes give directives to Angular about how to bind input and output
    elements on the page to JavaScript variables in memory. Data that is bound to
    the HTML can either be defined in code or requested from a JSON source. The binding
    is two way, similar to Knockout, but this framework has been fleshed out to provide
    more popular features found in other libraries.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: Angular通过解析HTML页面中的特定元素属性来工作。这些属性向Angular提供了关于如何将页面上的输入和输出元素绑定到内存中的JavaScript变量的指令。绑定到HTML的数据可以是代码中定义的，也可以是从JSON源请求的。绑定是双向的，类似于Knockout，但这个框架已经扩展，提供了其他库中更受欢迎的功能。
- en: Angular and MV*
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Angular和MV*
- en: While Angular was designed with MVC in mind, developers argue that it doesn't
    follow the MVC pattern. They say that the controller aspects don't really behave
    as controllers, but more like presenters (in MVP) or `ViewModel` (MVVM). This
    led some Angular developers to coin the term **Model View Whatever** (**MVW**
    or **MV*** for short). Whatever architecture style it uses, it has caught the
    attention of many developers. It's currently one of the most popular frameworks,
    favored even more than jQuery by most JavaScript developers.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Angular的设计初衷是MVC模式，但开发者们争论说它并不完全遵循MVC模式。他们说控制器方面并不真正像控制器那样行为，更像演示者（在MVP中）或`ViewModel`（在MVVM中）。这导致一些Angular开发者创造了术语**模型视图任意**（**MVW**或简称**MV**）。无论它使用哪种架构风格，它都引起了众多开发者的注意。它目前是最受欢迎的框架之一，甚至比jQuery更受大多数JavaScript开发者的青睐。
- en: Angular vocabulary
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Angular词汇表
- en: 'One of the barriers to using AngularJS is the new vocabulary it introduces.
    Many of the terms were created by computer scientists at Google, so they may sound
    very academic. However, when we place them within the context of a language we
    know, we can understand the concepts better. We''re going to discuss the following
    Angular terms, and how they relate to our mapping application:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 使用AngularJS的一个障碍是它引入的新词汇。许多术语是由Google的计算机科学家创造的，所以它们可能听起来非常学术。然而，当我们把它们放在我们熟悉的语言环境中时，我们可以更好地理解这些概念。我们将讨论以下Angular术语，以及它们如何与我们的映射应用程序相关联：
- en: Controller
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制器
- en: Service
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务
- en: Directive
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指令
- en: The app controller
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应用程序控制器
- en: In Angular, the **Controller** is a JavaScript object connected by two-way binding
    to an HTML document using Angular tags. Changes to values within the scope of
    the controller will change the values displayed on the HTML document. The Angular
    controller is comparable to the `ViewModel` in Knockout. For map-driven applications
    written with Angular, the map is often defined as part of the main controller.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular中，**控制器**是一个通过Angular标签与HTML文档进行双向绑定的JavaScript对象。控制器范围内的值的变化将改变HTML文档上显示的值。Angular控制器与Knockout中的`ViewModel`类似。对于使用Angular编写的基于地图的应用程序，地图通常被定义为主要控制器的一部分。
- en: The app service
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应用程序服务
- en: In Angular, a **service** is a JavaScript object used to communicate with servers
    and other data sources. Services are created once, and keep running through the
    life of the application in the browser. The equivalent item in the ArcGIS JavaScript
    API would be a task like `QueryTask` or `GeometryService`. In fact, if you wrote
    an Angular app using the ArcGIS JavaScript API, you could wrap a `QueryTask` within
    an Angular service and serve data that way.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular中，**服务**是一个用于与服务器和其他数据源通信的JavaScript对象。服务创建一次，并在浏览器应用程序的生命周期内持续运行。ArcGIS
    JavaScript API中的等效项可能是`QueryTask`或`GeometryService`之类的任务。实际上，如果你使用ArcGIS JavaScript
    API编写Angular应用程序，你可以将`QueryTask`包装在Angular服务中，并通过这种方式提供数据。
- en: The app directive
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应用程序指令
- en: In Angular, a **directive** is a custom element with its own behavior defined
    in code. The directive loads a template HTML file, applies its own bindings, and
    displays on a web page. In the ArcGIS JavaScript API, the equivalent to a directive
    is the Dojo `dijit` that we learned about in [Chapter 3](ch03.html "Chapter 3. The
    Dojo Widget System"), *The Dojo Widget System*. The `dijit` defines an HTML template
    and the JavaScript behavior bound to it. One difference between directives and
    dijits is that Angular directives are allowed to give an HTML element a custom
    name, such as `<overviewmap></overviewmap>`, while `dijits` must be built on existing
    HTML elements. Also, Angular events and descriptions are described with `ng-*`
    HTML parameters rather than `data-dojo-*` parameters.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular中，**指令**是一个具有在代码中定义的自身行为的自定义元素。指令加载一个模板HTML文件，应用自己的绑定，并在网页上显示。在ArcGIS
    JavaScript API中，与指令相对应的是我们在[第3章](ch03.html "第3章。Dojo小部件系统")“Dojo小部件系统”中了解到的Dojo
    `dijit`。`dijit`定义了一个HTML模板以及与之绑定的JavaScript行为。指令和`dijit`之间有一个区别，那就是Angular指令允许给HTML元素一个自定义名称，例如`<overviewmap></overviewmap>`，而`dijits`必须建立在现有的HTML元素之上。此外，Angular事件和描述是用`ng-*`
    HTML参数而不是`data-dojo-*`参数来描述的。
- en: Making a web mapping app more Angular
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使Web地图应用更加Angular
- en: Since AngularJS is a framework, it is expected to handle the work of page layout,
    event handling, and so on. However, Dojo is also a framework, and has its own
    opinions about how those page events should be handled. Can the two get along?
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 由于AngularJS是一个框架，它被期望处理页面布局、事件处理等工作。然而，Dojo也是一个框架，并且对如何处理这些页面事件有自己的看法。这两个框架能否和平共处？
- en: The key to using AngularJS and the ArcGIS JavaScript API side by side is to
    let Angular handle most of the page layout, but use the map, widgets, and task
    from the ArcGIS JavaScript API to communicate with ArcGIS Server.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在AngularJS和ArcGIS JavaScript API并行的使用中，关键是要让Angular处理大部分页面布局，但使用来自ArcGIS JavaScript
    API的地图、小部件和任务与ArcGIS Server进行通信。
- en: Much of the work needed to make our application run with AngularJS would take
    far too long to explain, and deserves its own chapter. Instead, I've supplied
    a few resources you can look over to integrate Angular into your own application.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 使我们的应用程序在AngularJS下运行所需的大部分工作需要太长时间来解释，并值得拥有自己的章节。相反，我提供了一些你可以查阅的资源，以将Angular集成到自己的应用程序中。
- en: Note
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more information about incorporating ArcGIS JavaScript API with Angular.JS,
    you can read blog posts by Rene Rubalcava at [http://odoe.net/blog/using-angularjs-with-arcgis-api-for-javascript/](http://odoe.net/blog/using-angularjs-with-arcgis-api-for-javascript/)
    or read his book *ArcGIS Web Development*, published by Manning Press. You can
    also review code from ESRI at [https://github.com/Esri/angular-esri-map](https://github.com/Esri/angular-esri-map).
    Finally, for more information about Angular.JS, you can read *Instant AngularJS
    Starter* by Dan Menard, or *Mastering Web Application Development with AngularJS*
    by Pawel Kozlowski and Peter Bacon Darwin.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 关于将 ArcGIS JavaScript API 与 Angular.JS 集成的更多信息，你可以阅读 Rene Rubalcava 在 [http://odoe.net/blog/using-angularjs-with-arcgis-api-for-javascript/](http://odoe.net/blog/using-angularjs-with-arcgis-api-for-javascript/)
    的博客文章，或者阅读他由 Manning Press 出版的书籍 *ArcGIS Web Development*。你还可以查看 ESRI 在 [https://github.com/Esri/angular-esri-map](https://github.com/Esri/angular-esri-map)
    上的代码。最后，关于 Angular.JS 的更多信息，你可以阅读 Dan Menard 的 *Instant AngularJS Starter*，或者
    Pawel Kozlowski 和 Peter Bacon Darwin 的 *Mastering Web Application Development
    with AngularJS*。
- en: Overall results with other frameworks
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他框架的整体结果
- en: All the frameworks we have reviewed in this chapter have worked with the ArcGIS
    API for JavaScript. Some, such as jQuery, slipped right and could be used right
    away. Others, such as Backbone and Angular, required a significant rewrite of
    the application. Each of these libraries takes up significant bandwidth when the
    browser downloads the website. These libraries and frameworks would have to bring
    something very important to make it worth the wait.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们审查的所有框架都与 ArcGIS API for JavaScript 一起工作。其中一些，如 jQuery，可以无缝使用，可以直接使用。而其他一些，如
    Backbone 和 Angular，则需要重写应用程序。这些库在浏览器下载网站时都会占用大量的带宽。这些库和框架必须带来非常重要的东西，才能使等待变得值得。
- en: jQuery
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: jQuery
- en: The jQuery library performs a number of functions found in Dojo. Both work well
    in a wide array of browsers. While jQuery's functionality and style make it easier
    to work with the HTML DOM, its event handling doesn't couple directly with Dojo's
    event handlers. In other words, `$(map).on("click", …)` doesn't do the same thing
    as `map.on("click", …)`.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery 库执行了在 Dojo 中找到的许多功能。两者在广泛的浏览器中都能很好地工作。虽然 jQuery 的功能和风格使其更容易与 HTML DOM
    一起工作，但其事件处理并不直接与 Dojo 的事件处理程序耦合。换句话说，`$(map).on("click", …)` 并不与 `map.on("click",
    …)` 做同样的事情。
- en: If you're creating an application that's jQuery centric and you want to add
    an ArcGIS-based map, it's perfectly fine to mix the two libraries together. You
    can easily define map operations with Dojo and other form operations through jQuery.
    However, jQuery doesn't add anything to the ArcGIS JavaScript library that can't
    be accomplished by importing a couple of extra Dojo modules (which saves on download
    bandwidth as well).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在创建一个以 jQuery 为核心的应用程序，并且想添加一个基于 ArcGIS 的地图，将这两个库混合在一起是完全可以的。你可以轻松地使用 Dojo
    和其他表单操作通过 jQuery 定义地图操作。然而，jQuery 并没有添加任何 ArcGIS JavaScript 库中无法通过导入几个额外的 Dojo
    模块（这也有助于节省下载带宽）实现的功能。
- en: Backbone.js
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Backbone.js
- en: Backbone organizes your code well, but it requires a lot of code to make it
    work. All the models, views, and other features have to be defined individually,
    and coupled with one another. There are other extension libraries, such as `Marionette.js`,
    that can make Backbone easier to code. Using Backbone could be very beneficial
    to architect the application around the map, but for this simple job, it was a
    little excessive.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: Backbone 代码组织良好，但需要大量的代码才能使其工作。所有模型、视图和其他功能都必须单独定义，并且相互关联。还有一些扩展库，如 `Marionette.js`，可以使
    Backbone 更容易编写。使用 Backbone 可以非常有益于围绕地图构建应用程序，但对于这个简单的任务来说，它有点过度了。
- en: Knockout and Angular
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Knockout 和 Angular
- en: Both Knockout and Angular are great frameworks for CRUD (Create, Read, Update,
    and Destroy) applications, but they don't bring anything new and powerful to web
    mapping applications. They can slow an application down if a lot of two-way binding
    is applied to an HTML document. Also, since Angular is a framework, it is written
    to handle many of the user interactions behind the scenes. Large portions of the
    code would have to be rewritten if Angular was added to an existing ArcGIS JavaScript
    API application.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: Knockout 和 Angular 都是优秀的 CRUD（创建、读取、更新和删除）应用框架，但它们并没有为网络地图应用带来任何新颖和强大的功能。如果在一个
    HTML 文档中应用大量的双向绑定，它们可能会使应用程序变慢。此外，由于 Angular 是一个框架，它被编写来处理许多后台的用户交互。如果将 Angular
    添加到现有的 ArcGIS JavaScript API 应用程序中，大部分代码都需要重写。
- en: In conclusion, we could have easily accomplished what we wanted using Dojo and
    the ArcGIS JavaScript API. We could save time and bandwidth on a smaller device
    like a smartphone or tablet by writing these portions using the ArcGIS JavaScript
    API. However, it helps to know how to incorporate ArcGIS maps with existing applications
    written in these other frameworks.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，我们本可以使用 Dojo 和 ArcGIS JavaScript API 轻松实现我们的目标。通过使用 ArcGIS JavaScript API
    编写这些部分，我们可以在智能手机或平板电脑等小型设备上节省时间和带宽。然而，了解如何将这些框架中编写的现有应用程序与 ArcGIS 地图集成是有帮助的。
- en: Summary
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you have learned how to use the ArcGIS JavaScript API along
    with other JavaScript libraries. We built applications using jQuery, Backbone.js,
    Knockout.js, and Angular.js. We compared the different uses of the libraries and
    frameworks, and how they worked with the ArcGIS API and Dojo.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您已经学习了如何使用 ArcGIS JavaScript API 以及其他 JavaScript 库。我们使用 jQuery、Backbone.js、Knockout.js
    和 Angular.js 构建了应用程序。我们比较了这些库和框架的不同用途，以及它们如何与 ArcGIS API 和 Dojo 一起工作。
- en: In the next chapter, we'll tackle a topic that strikes fear into the hearts
    of some JavaScript developers… styling.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨一些 JavaScript 开发者可能会感到恐惧的主题……样式。
