- en: Chapter 7. Plays Well with Others
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaScript development has matured over recent years. Once a simple language
    used to script a few animations and user interactions, JavaScript applications
    now support a full range of tasks that were only possible with desktop applications
    a few years ago. There are numerous well-documented libraries and frameworks that
    make complicated applications manageable through a web browser.
  prefs: []
  type: TYPE_NORMAL
- en: No JavaScript library or framework does everything perfectly. Most libraries
    focus on improving a few key requirements for application development, such as
    DOM manipulation, data binding, animation, or graphics. Some focus on speed; others
    focus on cross-browser compatibility.
  prefs: []
  type: TYPE_NORMAL
- en: A successful JavaScript developer doesn't have to build an application from
    scratch using one library or raw JavaScript to make it work. By adding current
    libraries that work well together, the developer can speed up development and
    handle multiple browser types without having to worry about them.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Integrating jQuery into the applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating Backbone.js into the applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating Knockout.js into the applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discuss Using AngularJS in a mapping application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compatibility with other libraries and frameworks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One way developers describe the usability of JavaScript libraries is how compatible
    they are with other libraries. The more libraries your library plays well with,
    the more likely it can be used on projects. When libraries don't play well with
    other libraries and frameworks, it can lead to unintended code bugs and actions
    that nobody saw coming. Since a developer cannot control what other libraries
    are used in a project with their library, it is better if a library plays well
    with others.
  prefs: []
  type: TYPE_NORMAL
- en: There are several ways that libraries can conflict with one another. One way
    that was more common in the past is through namespace collision. If two libraries
    create the same `cut()` function in the global namespace, you can't be sure which
    one will be called. Another, more subtle conflict arises through manipulating
    the prototype of standard JavaScript types. One library will expect the `map()`
    method called on an array to perform a specific task, but if another library overwrote
    `Array.prototype.map()`, the results may not turn out as expected, and may break
    the application. Typically, it's only polite to manipulate the prototype of base
    JavaScript types if you are patching support for older browsers.
  prefs: []
  type: TYPE_NORMAL
- en: A more recent way that JavaScript libraries can clash is in how they implement
    modules. Before ECMAScript 6 came out with the standard for modules, there were
    two schools of module development. One revolved around using CommonJS to define
    modules, and the other was AMD. Typically, modules from one can be loaded by the
    other, as they are called and constructed differently. Most small libraries that
    aren't defined one way or another can be loaded into either one, with a little
    work.
  prefs: []
  type: TYPE_NORMAL
- en: Even within AMD, there can be some conflicts. Some libraries and frameworks
    use Require.JS to load their modules. While syntactily similar, there are some
    differences in older versions of Dojo that create errors when mixing with Require.JS
    modules. It's something to be aware of when mixing and mashing up JavaScript libraries
    in your application.
  prefs: []
  type: TYPE_NORMAL
- en: Popular libraries to play with
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've looked at library compatibility as a whole, it's time to check
    out how the ArcGIS API for JavaScript plays with other JavaScript libraries and
    frameworks. We'll look at some of the popular libraries used by developers, and
    attempt to load them along with the ArcGIS API for JavaScript. We'll create the
    same application using jQuery, Backbone.js, Knockout.js, and AngularJS, and see
    how they compare. Finally, we'll look at a few do's and don'ts with any framework
    and the ArcGIS API.
  prefs: []
  type: TYPE_NORMAL
- en: Our story continues
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So, our census data app is a big hit for the Y2K society. They like the look
    of the graphics, and want us to expand it. The functionality of the widget is
    great, but they've made a new request. It seems that one of the members watched
    a late night comedian on television the other night, and found out that there
    are people out there who can't find their state or county on a map.
  prefs: []
  type: TYPE_NORMAL
- en: After discussing possible solutions with our client, we've decided to add some
    drop-down controls that let the user select a state, county, and even a census
    block group. On picking a state, the map zooms to the state and shows the data
    in a popup. Also, the county dropdown is populated with the county names in that
    state. When the county is selected, the county is selected with a popup, and the
    block group names are populated for that county and state. Finally, if the block
    group is selected, the block group is zoomed to, and the data is displayed on
    the map.
  prefs: []
  type: TYPE_NORMAL
- en: In somewhat related news, we've picked up an intern. He's an eager young kid
    who likes to follow the latest in JavaScript. He wants to contribute something
    to this project, and this looks like a good task to let him cut his teeth on.
  prefs: []
  type: TYPE_NORMAL
- en: The problem is, our intern wants to write the code using another library or
    framework, and not just a simple one. He wants to bring in a number of popular
    libraries including jQuery, Backbone, Knockout, Node.js, and Angular. While we
    appreciate his desire to learn (and to pad his resume), we have to have a serious
    talk with him about picking libraries appropriate for the project.
  prefs: []
  type: TYPE_NORMAL
- en: After talking the intern out of a Node.js project (since this is a client-side
    app, with no need for server-side work at this point), we explain the general
    use of the other libraries, he had on his list. We decide to give the intern a
    learning project, and let him build four copies of the app, each incorporating
    either jQuery, Backbone, Knockout, or Angular. He can evaluate each app and let
    us know which worked best with the application. We figure it's okay that he does
    four times the work, since he's not a paid intern.
  prefs: []
  type: TYPE_NORMAL
- en: 'We should go ahead and set up four project folders with copies of the `D3.js`
    app from our previous chapter''s work. In each of the projects, we need to modify
    the `Census.html` template in the `/js/template` folder to show the drop-down
    menus. We''ll add three drop-down menus with bold labels and selects that will
    be populated later by the four libraries. It should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'When the new application loads, the new widget should look something like the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Our story continues](img/6459OT_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: An overview of jQuery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most popular library for a number of years has to be jQuery. jQuery was
    originally created by John Resig as a library to handle DOM manipulation and events.
    Cross-browser compatibility is a strong selling point for this library, since
    it works in everything from the newest version of Chrome to Internet Explorer
    versions so old they make most developers cringe. Its intuitive commands and functionality
    make it easy to pick up for novice developers. The library is so popular that,
    as of the end of 2013, it is estimated to be used in 61 percent of the top 100,000
    websites in the world, according to the jQuery blog ([http://blog.jquery.com/2014/01/13/the-state-of-jquery-2014/](http://blog.jquery.com/2014/01/13/the-state-of-jquery-2014/)).
  prefs: []
  type: TYPE_NORMAL
- en: If you understand how jQuery works, you can skip the next section and go to
    *Adding jQuery in our App*. If not, here's a quick rundown on how jQuery works.
  prefs: []
  type: TYPE_NORMAL
- en: How jQuery works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The jQuery library is incredibly useful for selecting and manipulating DOM
    elements on a web page. DOM elements can be selected using the `jQuery()` function,
    or its common shortcut method `$()`. It accepts either a DOM element or a string
    with a CSS selector. To select an element with an `id`, you would put a `#` in
    front of the ID name. To select a CSS class, you insert a `.` in front of the
    class name. To select all elements of a tag name, just use the tag name. In fact,
    almost any legal CSS `select` statement is supported by jQuery. Here are some
    examples in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Once the nodes are selected by the jQuery object, you can perform a number of
    functions on them. You can make them appear and disappear using the `show()` and
    `hide()` methods. You can change their style using `css()`, their properties using
    `attr()`, and their content using `html()` or `text()` methods. Selected form
    element values can be retrieved and set using the `val()`. You can also find elements
    within the selected elements with `find()`, and iterate through each item with
    the `each()` method. Events can also be assigned using the `on()` method, and
    removed using `off()`. These are just the most common jQuery methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another powerful feature of jQuery is a property called **chaining**. jQuery
    functions return the jQuery object. You can immediately call another function
    on what was returned. These chained commands are evaluated from left to right.
    You can create some powerful transformations on your HTML using this code. For
    example, if you wanted to turn every unordered list item into a green frog and
    every ordered list item to a big brown toad, you could do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Just be warned, as you work with complex chained functions in jQuery, sometimes
    the target of the function will change. Functions like `each()` and `find()` will
    change the selection that is passed to the next function. In this example, the
    developer wants to show a form, set its width to `400px`, clear the values of
    the text blanks, and turn the labels blue. When they run it, they will find that
    the labels don''t turn blue as they expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'When the developer called `find(''input'')`, it changed the selected items
    from form elements to input elements. Then, when the `find(''label'')` was called,
    jQuery searched for labels that were inside the input tags. Not finding any, nothing
    turned blue. Thankfully, the developer remembered that jQuery also provides an
    `end()` function that returns you to your original selection. The following bit
    of code works much better:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now that we've taken a crash course in jQuery, let's try to use it in our application.
  prefs: []
  type: TYPE_NORMAL
- en: Adding jQuery to your app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, our intern is starting to work with the jQuery-based app when he runs into
    his first problem. How does he make jQuery and Dojo play well together? For the
    answer to that, we can look at some of the lessons from [Chapter 6](ch06.html
    "Chapter 6. Charting Your Progress"), *Charting Your Progress*, when we added
    `D3.js` to our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Loading a copy of our `D3.js` app, we''ll start by adding a reference to the
    jQuery library in our `dojoConfig` packages. Remember that it is the JavaScript
    configuration object that is loaded before we load the ArcGIS Javascript API.
    We''ll add a package with the name and file location, but we''ll also add a `main`
    property that will make the application load the jQuery library. You can download
    a copy of the jQuery library and place it in an accessible folder in your application,
    or you can make a reference to an external **content delivery network** (or **CDN**)
    that''s hosting the library. Using an external reference to jQuery hosted by Google,
    it should look something like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we can access jQuery through AMD, let''s open our `Census.js` file
    and add it as a module in our file. We''ll add a reference to it in the `require`
    statement, and assign it to the module `$`, as it is commonly referred to in most
    jQuery examples. It should look something like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll need to update the `Census` widget template to give jQuery something
    to search for. While updating `Census.html` in the `js/templates/` folder, we''ll
    add a `stateselect`, `countyselect`, and `blockgroupselect` class to each of the
    `select` menus. While adding IDs would make selecting the elements faster, adding
    class names will ensure that there is no ID name collision with other widgets
    in the application. The template will look like the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we have something for jQuery to select, we need to let jQuery select
    it in our code. Add some jQuery selectors to the constructor of our `Census` widget
    to get the nodes that have the `stateselect`, `countyselect`, and `blockgroupselect`
    classes, and assign them to the `stateSelect`, `countySelect`, and `blockGroupSelect`
    properties of our widget, in that order. This is referred to as **caching** our
    selections, which is a good practice for jQuery apps, since repeating DOM searches
    can take a long time, especially in a larger application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If we ran the application now, we would find that there was nothing in the
    `stateSelect`, `countySelect`, and `blockGroupSelect` properties. Why? If you
    remember, back in [Chapter 3](ch03.html "Chapter 3. The Dojo Widget System"),
    *The Dojo Widget System*, we talked about the lifecycle of a `Dojo` widget. We
    discussed the fact that, while the constructor function runs, the template won''t
    have loaded yet. In fact, it will not be available until the widget runs the `postCreate()`
    method. We''ll need to add `postCreate()` to our application, add a line that
    refers to the `postCreate` function inherited from the `WidgetBase` class, and
    then cut and paste the jQuery code we wrote earlier into this function. It should
    look something like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Now, when the `postCreate` method is called, `stateSelect`, `countySelect`,
    and `blockGroupSelect` will be filled with appropriate objects.
  prefs: []
  type: TYPE_NORMAL
- en: Filling in our dropdowns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need data to fill in our select dropdowns. For that, we'll need to get state,
    county, and block group names from the map services and fill them in the dropdowns.
    For the fifty or more states, that is easy, but what about counties and block
    groups? There are over 250 counties in the state of Texas alone, and even more
    block groups. We need a systematic way to populate the dropdowns.
  prefs: []
  type: TYPE_NORMAL
- en: What if, every time we selected a state, the county dropdown was filled with
    all the counties in that state? Also, what if the block groups list wasn't populated
    until the user selected the county of interest? We can achieve this if we listen
    to the `select` element's `change` event. When the event fires, we'll have a new
    selection result from the previous level query for the new list.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start by stubbing out two new methods in the `Census` module, called
    `queryDropdownData()` and `populateDropdown()`. Instead of adding a list of parameters
    that we don''t know yet, we''ll add a single argument called `args` to the `queryDropdownData()`
    method. To the `populateDropdown()` method, we''ll add the `args` parameter, plus
    a `featureSet` parameter that will come from querying the map data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Adding the QueryTask
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Inside the `queryDropdownData()` method, we''re going to query a map service
    to get the list of counties in a state, or block groups in a county. For this,
    we''ll need to add the ArcGIS JavaScript API''s `QueryTask`. If you remember from
    [Chapter 2](ch02.html "Chapter 2. Digging into the API"), *Digging into the API*,
    `QueryTask` lets us pull SQL-like queries to single layers in a map service. We''ll
    need to add references to the `require` statement for the `QueryTask` and its
    associated task parameter builder, the `Query`. We''ll go ahead and construct
    these in our `getDropdown()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to define the parameters for both `QueryTask` and the query. For
    that, we''ll use parameters passed through the `args` object. We can define an
    `args.url` to send a URL string to the `QueryTask`. We can also use `args.field`
    to set the field name for the data we want returned in the query object, and `args.where`
    to supply a `where` clause to filter the results. `queryDropdownData()` should
    now look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'For our `populateDropdown()` method, we''ll take the jQuery-based selector
    and add the `featureSet` features that will be returned from the `queryDropdownData()`
    method. Remember that a `featureSet` contains a `features` parameter, which contains
    a list of graphic results. Out of the graphics returned, we''re only interested
    in the attributes of the field returned. It should look as follows. We''re going
    to use the jQuery `each()` function on the list of features to iterate through,
    create an option for each result, attach it to the selector, and fill it in with
    values. It should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Other helper functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With the addition of `QueryTask`, we can now directly query the state, county,
    or block group we select from the drop-down menu. We need to define the function
    that will collect that information from the server. We can call the method in
    our widget `queryShapeAndData()`, and it will take a single `args` parameter with
    the data we need from it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'While it is possible to add these graphics directly to the map, we should format
    the data so that it brings up an `infoWindow` as if we clicked it ourselves. For
    this, we''ll add an `_onQueryComplete()` method. It will accept a `featureSet`
    returned from a `QueryTask`, and return a list of features with appropriate popup
    templates just like the ones we assign when we identify through clicks. Unfortunately,
    `featureSets` do not return the same descriptive information as `IdentifyResults`,
    so we will have to manually add the title of the feature for it to accurately
    pick the right `InfoTemplate`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Going back to the `queryShapeAndData()` method, we can add the `callback` function
    to the `execute` statement and have it return a processed result every time. The
    last part of `queryShapeAndData()`will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need a way to show the queried graphics on the map. We''ll create
    a method called `_updateInfoWindowFromQuery()` that takes a `featureSet`, zooms
    to its features, and adds the `infoWindow`. We''re going to use the `esri/graphicsUtils`
    module to collect the overall extent of the graphics, so that we can zoom to it.
    Once the asynchronous zoom finishes, we''ll set the graphic on the `infoWindow`
    and show it. You can see the code that does all this in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Handling events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, we will add event listeners to the `stateSelect`, `countySelect`, and `blockGroupSelect`
    items. We'll use the helper functions we developed in previous sections to populate
    the data, using some of our knowledge of `dojo/Deferred` to connect them asynchronously.
    Let's begin with the states.
  prefs: []
  type: TYPE_NORMAL
- en: When you select a state from the drop-down menu, the `select` element will fire
    a `change` event. We're not going to collect data on this event. Instead, we'll
    get data directly from the drop-down selectors and use that to generate the queries
    we need.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go ahead and stub out the `_stateSelectChanged()` method in the `Census`
    widget. It takes no arguments. We''ll do the same with the `_countySelectChanged()`
    and `_blockGroupSelectChanged()` methods as well. Then, using jQuery''s `.on()`
    method, we''ll listen for the `change` events in the `stateSelect`, `countySelect`,
    and `blockGroupSelect` controls. We''ll use dojo''s `lang.hitch()` method to make
    sure that, when we say `this`, we mean `this` widget. It should look like the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Handling the state
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the `_stateSelectChanged()` method, we''ll start by collecting the name
    of the state selected in `stateSelect`. If there is a value, we''ll start by querying
    for the graphical data on that state. We''ll use the `queryShapeAndData()` method
    to query for the shape data and process it. When that is complete, we can pass
    it along to the `_updateInfoWindowFromQuery()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we''re showing the graphic, it''s time to fill in the county name.
    We''ll use the `queryDropdownData()` method to query for the list of counties,
    and using `.then()` asynchronously, pass the results to our `_populateDropdown()`
    method. We''ll assign the county names first in the list of queried values, because
    we want them in alphabetical order. We''ll tack that on at the end of the `_stateSelectChanged()`
    method, and it should appear like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: How the counties differ
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The counties should load similarly to the states. The big issue is that we are
    required to query for the underlying block groups in a county with state and county
    FIPs codes. There are no state or county names available in the block group census
    data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we assigned the FIP codes to the `data-fips` attributes of the drop-down
    options, there should be a way we can get them, right? Yes we can, but we''ll
    have to take advantage of jQuery''s chaining methods. From `stateSelect`, for
    instance, we can use the `jQuery.find(":selected")` method to find the selected
    option inside the `select`. From there, we can call jQuery''s `attr()` method
    to grab the `data-fips` attribute. For the state and county names and FIPs codes,
    it should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: From here, we can use `stateName` and `countyName` to query for the correct
    county to show, and `stateFIPS` and `countyFIPS` to get the list of block groups.
    They'll use the same functions as the `_stateSelectChanged()` method, but with
    different map services and `where` clauses.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the block groups
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `_blockGroupSelectChanged()` method is much easier to write, because we''re
    only interested in showing the block group. The key here is to collect the selected
    state FIP code, the selected county FIP code, and the `blockgroup` value from
    their respective dropdowns. Then we''ll piece together the `where` clause on the
    query, and request the graphics for the map. The method should look like the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Filling in the states
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that the application is wired, we can finally load the state data from the
    map service. We'll start by querying the state layer for state names and state
    FIP codes. To get all the states, we'll use a little SQL trick. SQL will return
    all rows where the `where` clause is true, so if you want all the rows, you have
    to return something that's always true. In this case, we'll assign `1=1` to the
    where clause for `queryDropdownData()`, because it is always true that `1=1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we receive the query results from the server, we''ll pass them to our
    `_populateDropdown()` method. We''ll assign the options to the `stateSelect` drop-down,
    show the state names on each choice, and store the FIP codes in the options as
    well. We''ll add the following snippet to the end of our `postCreate()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: So, if we've wired everything up correctly, we can view the site in the browser
    and open the `Census` widget. We should then see the states already loaded in
    the drop-down menu. You will have to select a state before the counties fill in,
    and select a county for the block groups.
  prefs: []
  type: TYPE_NORMAL
- en: Keep this project handy. We'll make copies of this one as a starting point for
    the other projects. Now let's try to build a Backbone app.
  prefs: []
  type: TYPE_NORMAL
- en: An overview of Backbone.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With a simple application like the one we wrote with jQuery, the logic can turn
    into spaghetti-code rather quickly. We need to implement good practices to organize
    our code. Which practices do we implement? One of the first libraries to try to
    answer this question is Backbone.js.
  prefs: []
  type: TYPE_NORMAL
- en: Backbone.js is one of the earliest JavaScript libraries to implement a **Model
    View Controller (MVC)** architecture. MVC organizes code by separating data and
    business logic (the `Model`) from the output (the `View`) and updates both through
    a separate component (the `Controller`). With MVC, you don't write a complicated
    JavaScript function that gets input from some text blanks, adds the contents together,
    and saves the results. Those three actions can be written into three different
    functions, separated by what they do and how they fit into the `Model`, `View`,
    and `Controller` classifications.
  prefs: []
  type: TYPE_NORMAL
- en: Backbone.js requires a couple of other libraries in order to work properly.
    Backbone uses jQuery to handle DOM manipulation, including showing and hiding
    elements on the page. Backbone also requires another library called Underscore.js.
    This library provides a number of functions and shortcuts for dealing with JavaScript
    objects, arrays, and so forth. Underscore.js provides methods found in `dojo/_base/lang`
    and `dojo/_base/array`, as well as other methods that can help you pull out relevant
    data from your feature graphics.
  prefs: []
  type: TYPE_NORMAL
- en: Components of Backbone
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Compared to most popular libraries and frameworks, Backbone.js is rather simple.
    It organizes your code into five categories: `Model`, `View`, `Collection`, `Event`,
    and `Router`. These work together to showcase your data and react to user input.
    All but the events are created through Backbone''s `extend()` method, which contains
    a JavaScript object that defines the `Model`, `View`, `Collection`, or `Router`.
    Events, on the other hand, are defined through the creation of the other items.
    Let''s review each item individually.'
  prefs: []
  type: TYPE_NORMAL
- en: The Model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Backbone.js' `Model` provides a description of the data you're going to use.
    You can assign default properties, methods, and events to the model that will
    be called by application features created in the other categories. Models are
    created through the `Backbone.Model.extend()` constructor method. Models created
    with this method become constructors for model data in your application. Data
    created through models have different methods to `get()` and `set()` data, test
    for the presence of data through `has()`, and even detect changes in the data
    through `isChanged()` or `changedAttributes()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of a playing card model, as well as a card created using
    the model. The `CardModel` variable includes `rank` and `suit` properties, as
    well as a function to describe the card in a single string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The View
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Backbone `View` sets up how the data will be presented in the application.
    The `View` defines the HTML output through a series of parameters defined in the
    `Backbone.View.extend()` constructor. You can create a view on a particular DOM
    element in your HTML by assigning the `.el` property in the `extend()` constructor
    method. You can also assign a `tagName` property to define the HTML element that
    is created, a `template` property if the content is more complicated than a single
    element, and even a `className` property to assign a CSS class to the main element.
  prefs: []
  type: TYPE_NORMAL
- en: The view makes heavy use of both jQuery and Underscore.js. For example, while
    the element of the view is defined by the view's `.el` property, a jQuery version
    is available by referring to the Views `$el` property. Also, HTML content can
    be defined through the view's template, which is created through Underscore's
    `.template()` creator.
  prefs: []
  type: TYPE_NORMAL
- en: When a view is first created, it starts with a method called `initialize()`
    that you define. In the `initialize()` method, you can assign event listeners
    to other parts of the view, including models and collections. You can also tell
    the view to `render()`, or write out the HTML code. The `render()` method that
    you define is used to add the custom HTML within the `View` element. You can also
    render other views within the `View`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code, you can find a sample `View` to show a card:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The Collection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If a `Backbone` model describes one piece of data, how do you describe a list
    of them? That's where a `Collection` comes in. A collection represents a list
    of data items of a particular model. As is probably no surprise, a `Collection`
    constructor can be created using the `Backbone.Collection.extend()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Collections offer a number of methods for managing the content of your list.
    You can `.add()` or `.remove()` model-defined items from your collection list,
    as well as `.reset()` the entire list to whatever you pass as a parameter. You
    can define a `url` parameter as a JSON data source, and `.fetch()` the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code, you can see how a `Collection` is created using a deck
    of cards. It is based on the `CardModel` defined in the model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Implementing a router
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Backbone routers help define the state of the application through the URL. They
    respond to changes in the URL hash, or the text following the `#` symbol in the
    URL. The hash was originally created in web pages to allow you to click an anchor
    tag to move down the page to related content, without reloading the entire page.
    When a `Backbone` router is enabled, you can change the hash, say, through a button
    or anchor click, and it will run some JavaScript code in response to the content.
    All this happens, and the page doesn't reload.
  prefs: []
  type: TYPE_NORMAL
- en: This lack of page reloads when the router changes makes single-page applications
    possible. Instead of loading new pages, Backbone can simply show different views
    in response to the router. This gives a snappier response on the page.
  prefs: []
  type: TYPE_NORMAL
- en: Handling events
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Events are defined within the other items created by Backbone. Event listeners
    are attached to elements of the `Model`, `View`, `Collection`, or `Router`, by
    way of the `on()` method. The `on()` method takes three parameters, a string containing
    the name of the event, the function that is to be called when the event occurs,
    and the context that defines what `this` is.
  prefs: []
  type: TYPE_NORMAL
- en: 'Events within HTML elements created by the view are defined in a different
    way. The `Backbone.View.extend()` constructor contains an `events` parameter that
    is defined by an unusually formatted JSON object. Event names, and jQuery selectors
    for the elements, are used as the key, and a string containing the name of the
    function called in the view makes up the key value. Example events might look
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Putting some Backbone in your app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since Backbone uses jQuery under the hood to work with the DOM, we can reuse
    much of the code from our jQuery application. We'll be using the same ArcGIS JavaScript
    API modules to interact with the map services. We'll only change how the drop-down
    options are rendered and how the change events on those dropdowns are handled.
    So, let's start by making a copy of our jQuery application and naming the folder
    `Backbone`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''ll need to add references to the Backbone and Underscore libraries
    in our `dojoConfig`, so that they are available through AMD. We''ll load them
    from a CDN source for this application, although you''re free to download them
    into folders for your own applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we''ll make reference to the jQuery, Underscore, and Backbone libraries
    in our `define` statement in the `Census.js` file. The files should load in as
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Defining the models
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, we have the opportunity to define the data models that we''ll be working
    with. If you remember from the jQuery exercise, we were primarily interested in
    the names and the FIP codes for the census locations. In the `postCreate()` method
    of the census widget, we''ll define our models using default values from those
    fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Defining the collections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For the state, county, and block group collections, we''ll simply define them
    based on the corresponding models we defined previously. We''ll then create collection
    objects that are tied to the Dojo `dijit`. It should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Defining the views
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we've defined our models and collections, it's time to create a view
    for them. Our view should create the options with the data that we need in our
    application. We'll need to create a separate view for each of the dropdowns, since
    assigning templates when the view is created causes errors with this version of
    the Backbone.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the `StateView` variable. The `StateView` variable will be
    created through `Backbone.View.extend`. In the `StateView` variable, we want to
    define a template, an `initialize()` method, and a `render()` method. The `initialize()`
    method will listen for the collection''s `reset` event, and cause it to `render()`
    again. The template is defined by Underscore''s `_.template` function called on
    an HTML string pulled up by jQuery. The jQuery selector will look for our state
    option template by looking for an element with the ID of `stateitemtemplate`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding view, the `render` function does two things. First, it loads
    the view template and the empty jQuery selection object into variables. Next,
    it iterates over each of the collection models using Underscore's `each()` method,
    fills in the template with the JSON content from the model, and appends it inside
    the `select` element. Some other Backbone examples would stop the option creation
    from appending the options to the `select` element in a separate view, but this
    method was chosen for compact purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the `StateView` is defined, you can copy and paste the code and tweak
    it to create separate `CountyView` and `BlockGroupView` constructors. In each
    of those, the only thing you need to change is the template jQuery selector, to
    `#countyitemtemplate` and `#blkgrpitemtemplate`, respectively. Keep the `initialize()`
    and `render()` methods the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we''ll assign our actual view properties to these `View` constructors.
    With each view, we''ll assign the element they''ll be rendered from, which are
    the `select` elements in our widget and the collections they will be using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Creating templates
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Thinking back to the jQuery app, we filled in the select dropdowns with options
    tags that contained data on both the name of the feature and a FIP code with which
    we could query the next level down. We need to create the same HTML elements in
    HTML templates rather than piecing them together through code. We'll do this by
    adding HTML templates to our main page.
  prefs: []
  type: TYPE_NORMAL
- en: How do we create HTML templates that aren't visible on the page? We can do this
    by inserting them into script tags. We'll give each template script tag a type
    of `text/template`. This lets us know that the content of the script is actually
    HTML code. Browsers will look at the type, not know what to do with a `text/template`
    type, and simply ignore it.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s create templates for the state options, county options, and block
    group options. We''ll assign the templates IDs of `stateitemtemplate`, `countyitemtemplate`,
    and `blkgrpitemtemplate`, as we added in our code. In each template, we''ll assign
    the value, text, and `data-fips` value to the appropriate item in the model. Take
    a look at the following templates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Depending on the template library you use, different libraries have different
    ways to assign values. Underscore's `template()` method wraps the attribute names
    in `<%= %>` tags. You can use other template libraries, such as Handlebars.js,
    but, since Underscore is required, why not use what we have?
  prefs: []
  type: TYPE_NORMAL
- en: Wiring events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now let's make things happen. We're going to reuse the event listeners we created
    for the jQuery exercise, and make them work for Backbone. We'll start by looking
    at the `_stateSelectChanged()` method.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing that changes is how we collect `stateName` and `stateFIPS`.
    Instead of referring the `stateSelect` that was previously defined as a jQuery
    object, we'll access the `select` through the `stateView.$el` property. Remember
    that, in a `View`, the `el` property exposes the DOM element, while the `$el`
    property exposes the jQuery element. For the other selection change listeners,
    we can find and replace `countySelect` and `blockGroupSelect` with `countyView.$el`
    and `blockGroupView.$el`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'The only other part that needs changing is how the new drop-down data is populated
    after it is queried form the map service. We can replace the `_populateDropdown()`
    method with a simple anonymous function. In the anonymous function, we''ll create
    a list of feature attributes from the `featureSet` using Underscore''s `pluck()`
    method. It goes item by item through an array, and grabs the property of the item
    you describe and puts that in a new list. Next, we''ll assign that list to the
    `countyCollection` through its `reset()` method. That''s all that is needed to
    update the county list. The same process can be performed on the `_countySelectChanged()`
    method to repopulate the block groups. Your code changes should look like the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Getting the Backbone to dance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Finally, we need to populate the initial value of `stateView`. We''ll use the
    `queryDropdownData()` method call at the end of jQuery''s `postCreate()`. If we
    make the same changes to this call that we made to the event listeners, we should
    be able to populate the state drop-down menu. From there, we should be able to
    populate the other menus through the event listeners we assigned to the `View`
    elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want to learn more about implementing ArcGIS JavaScript APIs using Backbone.js
    and Marionette, you can review the blog posts by Dave Bouwman on the matter at
    [http://blog.davebouwman.com/2013/02/20/part-1-app-design-and-page-layout/](http://blog.davebouwman.com/2013/02/20/part-1-app-design-and-page-layout/).
    For more information on Backbone.js, you can read *Backbone.js Patterns and Best
    Practices* by Swarnendu De.
  prefs: []
  type: TYPE_NORMAL
- en: An overview of Knockout.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another JavaScript library that can be used to create an interactive single
    page application is Knockout.js. Knockout was developed by Steve Sanderson of
    Microsoft, though it's not considered a Microsoft product. It's based on Windows
    Presentation Framework in that it uses the **Model-View-ViewModel (MVVM)** architecture
    and allows two-way binding on observed properties. Two-way binding means that
    data isn't just written to an HTML element, but it can also be updated, like a
    text input field in a form, and the data will be already reflected in the application.
  prefs: []
  type: TYPE_NORMAL
- en: Knockout and MVVM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The MVVM is similar in nature to MVC architecture. Both use a model to get to
    the data, and a `View` to show the data. However, instead of an active controller
    directing the model and views, the `ViewModel` sits under the UI layer and exposes
    functions and data from the model to the `View`. The `ViewModel` typically knows
    nothing about the `View` it's working with. It simply stores and provides information
    as requested by the HTML `View`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Knockout, the `ViewModel` is created like any normal JavaScript object,
    with a few additions from Knockout. Properties of the `ViewModel` that are used
    in two-way binding are created using Knockout''s `observable()` and `observableArray()`
    constructors. This allows these properties to be accessed by the `View`, and updated
    without having to update the DOM, as you would have to in jQuery. A constructor
    looks something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The HTML document acts as a `View`, and can be bound to the `ViewModel` through
    the HTML5-based `data-*` attributes (more specifically, the `data-bind` attribute).
    When the browser loads an HTML view and a script containing the `ViewModel`, the
    Knockout will bind attributes in the data-bind tags to the appropriate fields
    in the `ViewModel`. For the preceding `ViewModel` created, you might see some
    HTML like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `ViewModel`, properties can be added that are computed values based
    on other observables in the `ViewModel`. These are created with the `ko.computed()`
    constructor. For example, we can take the `PersonViewModel` in the preceding code
    and add a computed `fullName` property that automatically updates when the first
    or last name changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Knockout doesn't have many extra features that other libraries and frameworks
    possess, such as routers and AJAX requests. It typically relies on other libraries,
    such as `Sammy.js` for routing and jQuery for AJAX. However, what it does offer
    is two-way binding that works even in older browsers.
  prefs: []
  type: TYPE_NORMAL
- en: Using Knockout in our app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s make another copy of our jQuery app and name the folder `Knockout`.
    We will not need jQuery for this application, since we can use Knockout and the
    ArcGIS JavaScript API to handle those functions. We''ll start by replacing all
    the references to jQuery with Knockout references. The `dojoConfig` script at
    the head of the document should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll add a reference to Knockout in our `Census.js` file. We''ll keep
    the other AMD modules and code, and we''ll replace things as we go. The `define()`
    statement at the top of `Census.js` should look a bit like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Defining the ViewModel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We know what kind of data model we're dealing with, but what we need is a `ViewModel`
    to organize it. We can create the `ViewModel` constructor in our `Census` dijit,
    and expose it for use by our widget.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `ViewModel` for this widget only requires six items. We need to maintain
    the lists of states, counties, and block groups, to populate the `select` elements,
    as well as the selected values. For the `stateList`, `countyList`, and `blockGroupList`
    properties of the `ViewModel`, we''ll construct Knockout''s `observableArrays`
    for each. `selectedState`, `selectedCounty`, and `selectedBlockGroup` will each
    be created using Knockout observables. You can see how we construct the `ViewModel`
    in the widget in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Adding custom binding handlers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In our jQuery and Backbone applications, we attached event listeners to the
    `select` elements so that, when they change, we can query for census data and
    populate the next select down. In Knockout, we can do the same thing using custom
    binding handlers. Binding handlers have two optional methods: `init()` and `update()`.
    The `init()` method runs when binding first occurs, while the `update()` method
    runs every time the bound value changes. Both `init()` and `update()` have five
    arguments, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`element`: The HTML DOM element involved in the binding.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`valueAccessor`: A function that gives access to the observable property bound
    to the element. To get the value of this property, call the `ko.unwrap()` method
    on the value returned from `ValueAccessor()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`allBindings`: An object used to get the particular bindings to the element,
    like the text, value, or name. Binding properties can be retrieved using `allBindings.get()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`viewModel`: This was the old way to get at the entire `ViewModel`, prior to
    version 3.x.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bindingContext`: This is the way to get to all the bindings. `bindingContext`
    may have at least some of the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$data`: The current `ViewModel` assigned to this element'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$rawData`: Direct access to the values held in the `ViewModel`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$parent`: Access to the parent `ViewModel` this `ViewModel` may be assigned
    to'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$parents`: An array object providing access to each tier of `ViewModel` connected
    to this `ViewModel`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$root`: This grants direct access to the base `ViewModel`, originally bound
    to the entire page'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We need to create the binding handlers before we apply bindings to the page.
    While we can create the binding handlers earlier, we''re going to assign them
    in the `postCreate()` method of our widget, since that''s where we''ve applied
    the changes in our other applications. We''ll start by creating some empty binding
    handlers for `stateUpdate`, `countyUpdate`, and `blockGroupUpdate`. We''re only
    interested in the `update()` methods, so we''ll leave the `init()` method out.
    The following code is the empty version of `stateUpdate`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Within the binding handlers, and the subsequent calls to the ArcGIS JavaScript
    API modules, the widget scope is going to get lost. In the `postCreate()` method,
    we''ll create a variable named `self`, and assign a reference to the widget to
    it, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'With the binding handlers set, we''ll bring our code over from our previous
    event handlers. From _`stateSelectChanged()`, we''ll copy over the code and make
    our changes. First, we''ll change how the functions collect the state names and
    census FIP codes for the queries. Once we have the names, getting the visual data
    will be easy. Finally, we''ll change how the `ViewModel` is updated once the query
    for the counties in the state is finished. The `stateUpdate` binding handler should
    look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'For the county and the block groups, we''ll follow similar patterns in `countyUpdate`
    and `blockGroupUpdate`. Remember the following changes for this app:'
  prefs: []
  type: TYPE_NORMAL
- en: Replacing references to `this` with the variable `self`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get county and block group feature attribute data from `ko.unwrap(valueAccessor())`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collect the list of feature attributes for the drop-down list using the `Dojo`
    module method `arrayUtils.map()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add an attribute with blank values to the first feature of the feature attributes
    list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add the new list to the `bindingContext.$data` array
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining the View
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we've done all the hard work setting up the `ViewModel` and the related
    functionality, let's work with some HTML. Open the `Census.html` template in the
    `js/template/` folder. This is where we are going to apply our `View`. Start by
    removing the class assignments on the three `select` elements, and replace them
    with the text `data-bind=""`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''re going to assign four properties within each data-bind context:
    `options`, `optionsText`, `value`, and the appropriate binding handler we created
    in the previous section. The options will be assigned to the appropriate `observableArray`
    list. The `optionsText` will be the field name that we want to see on the options.
    Both the value and the binding handler we created will be bound to the selected
    observable for that type. The `Census.html` file should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Applying the ViewModel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have a working `View` and `ViewModel`, and the code that links
    it to our `Model`, it''s time to put it all together. Once the page has loaded
    in the `postCreate()` method, and all our binding handlers have been assigned,
    it''s safe to call `ko.applyBindings()` to the `ViewModel`. In most examples that
    you see online, the `ViewModel` is bound as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'It would be great to finish with that and call it a day, but we don''t have
    any state data to start out the `SelectViewModel`. We''re going to have it assign
    it some way. We''re going to take some code from the jQuery and Backbone code
    to assign the initial values to the state dropdowns. We''ll then modify it to
    fit the pattern we established for assigning the other dropdowns. We''ll query
    for a list of states, and add the list to our working `ViewModel`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more information on KnockoutJS, you can visit [http://knockoutjs.com](http://knockoutjs.com)
    or [http://learn.knockoutjs.com](http://learn.knockoutjs.com) for interactive
    tutorials. For books on the library, you can check out *KnockoutJS Starter* by
    Eric M. Barnard, or *Mastering KnockoutJS* by Timothy Moran.
  prefs: []
  type: TYPE_NORMAL
- en: A brief overview of AngularJS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the more recent popular frameworks that we can use alongside our JavaScript
    application is AngularJS. Angular was originally created at Google as a language
    to help designers code. It quickly grew into the JavaScript framework of choice,
    both at Google and abroad. The core Angular development team makes sure that Angular
    excels in data binding and testability.
  prefs: []
  type: TYPE_NORMAL
- en: Angular works by parsing through the HTML page for specific element attributes.
    These attributes give directives to Angular about how to bind input and output
    elements on the page to JavaScript variables in memory. Data that is bound to
    the HTML can either be defined in code or requested from a JSON source. The binding
    is two way, similar to Knockout, but this framework has been fleshed out to provide
    more popular features found in other libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Angular and MV*
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While Angular was designed with MVC in mind, developers argue that it doesn't
    follow the MVC pattern. They say that the controller aspects don't really behave
    as controllers, but more like presenters (in MVP) or `ViewModel` (MVVM). This
    led some Angular developers to coin the term **Model View Whatever** (**MVW**
    or **MV*** for short). Whatever architecture style it uses, it has caught the
    attention of many developers. It's currently one of the most popular frameworks,
    favored even more than jQuery by most JavaScript developers.
  prefs: []
  type: TYPE_NORMAL
- en: Angular vocabulary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the barriers to using AngularJS is the new vocabulary it introduces.
    Many of the terms were created by computer scientists at Google, so they may sound
    very academic. However, when we place them within the context of a language we
    know, we can understand the concepts better. We''re going to discuss the following
    Angular terms, and how they relate to our mapping application:'
  prefs: []
  type: TYPE_NORMAL
- en: Controller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Directive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The app controller
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Angular, the **Controller** is a JavaScript object connected by two-way binding
    to an HTML document using Angular tags. Changes to values within the scope of
    the controller will change the values displayed on the HTML document. The Angular
    controller is comparable to the `ViewModel` in Knockout. For map-driven applications
    written with Angular, the map is often defined as part of the main controller.
  prefs: []
  type: TYPE_NORMAL
- en: The app service
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Angular, a **service** is a JavaScript object used to communicate with servers
    and other data sources. Services are created once, and keep running through the
    life of the application in the browser. The equivalent item in the ArcGIS JavaScript
    API would be a task like `QueryTask` or `GeometryService`. In fact, if you wrote
    an Angular app using the ArcGIS JavaScript API, you could wrap a `QueryTask` within
    an Angular service and serve data that way.
  prefs: []
  type: TYPE_NORMAL
- en: The app directive
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Angular, a **directive** is a custom element with its own behavior defined
    in code. The directive loads a template HTML file, applies its own bindings, and
    displays on a web page. In the ArcGIS JavaScript API, the equivalent to a directive
    is the Dojo `dijit` that we learned about in [Chapter 3](ch03.html "Chapter 3. The
    Dojo Widget System"), *The Dojo Widget System*. The `dijit` defines an HTML template
    and the JavaScript behavior bound to it. One difference between directives and
    dijits is that Angular directives are allowed to give an HTML element a custom
    name, such as `<overviewmap></overviewmap>`, while `dijits` must be built on existing
    HTML elements. Also, Angular events and descriptions are described with `ng-*`
    HTML parameters rather than `data-dojo-*` parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Making a web mapping app more Angular
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since AngularJS is a framework, it is expected to handle the work of page layout,
    event handling, and so on. However, Dojo is also a framework, and has its own
    opinions about how those page events should be handled. Can the two get along?
  prefs: []
  type: TYPE_NORMAL
- en: The key to using AngularJS and the ArcGIS JavaScript API side by side is to
    let Angular handle most of the page layout, but use the map, widgets, and task
    from the ArcGIS JavaScript API to communicate with ArcGIS Server.
  prefs: []
  type: TYPE_NORMAL
- en: Much of the work needed to make our application run with AngularJS would take
    far too long to explain, and deserves its own chapter. Instead, I've supplied
    a few resources you can look over to integrate Angular into your own application.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more information about incorporating ArcGIS JavaScript API with Angular.JS,
    you can read blog posts by Rene Rubalcava at [http://odoe.net/blog/using-angularjs-with-arcgis-api-for-javascript/](http://odoe.net/blog/using-angularjs-with-arcgis-api-for-javascript/)
    or read his book *ArcGIS Web Development*, published by Manning Press. You can
    also review code from ESRI at [https://github.com/Esri/angular-esri-map](https://github.com/Esri/angular-esri-map).
    Finally, for more information about Angular.JS, you can read *Instant AngularJS
    Starter* by Dan Menard, or *Mastering Web Application Development with AngularJS*
    by Pawel Kozlowski and Peter Bacon Darwin.
  prefs: []
  type: TYPE_NORMAL
- en: Overall results with other frameworks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the frameworks we have reviewed in this chapter have worked with the ArcGIS
    API for JavaScript. Some, such as jQuery, slipped right and could be used right
    away. Others, such as Backbone and Angular, required a significant rewrite of
    the application. Each of these libraries takes up significant bandwidth when the
    browser downloads the website. These libraries and frameworks would have to bring
    something very important to make it worth the wait.
  prefs: []
  type: TYPE_NORMAL
- en: jQuery
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The jQuery library performs a number of functions found in Dojo. Both work well
    in a wide array of browsers. While jQuery's functionality and style make it easier
    to work with the HTML DOM, its event handling doesn't couple directly with Dojo's
    event handlers. In other words, `$(map).on("click", …)` doesn't do the same thing
    as `map.on("click", …)`.
  prefs: []
  type: TYPE_NORMAL
- en: If you're creating an application that's jQuery centric and you want to add
    an ArcGIS-based map, it's perfectly fine to mix the two libraries together. You
    can easily define map operations with Dojo and other form operations through jQuery.
    However, jQuery doesn't add anything to the ArcGIS JavaScript library that can't
    be accomplished by importing a couple of extra Dojo modules (which saves on download
    bandwidth as well).
  prefs: []
  type: TYPE_NORMAL
- en: Backbone.js
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Backbone organizes your code well, but it requires a lot of code to make it
    work. All the models, views, and other features have to be defined individually,
    and coupled with one another. There are other extension libraries, such as `Marionette.js`,
    that can make Backbone easier to code. Using Backbone could be very beneficial
    to architect the application around the map, but for this simple job, it was a
    little excessive.
  prefs: []
  type: TYPE_NORMAL
- en: Knockout and Angular
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Both Knockout and Angular are great frameworks for CRUD (Create, Read, Update,
    and Destroy) applications, but they don't bring anything new and powerful to web
    mapping applications. They can slow an application down if a lot of two-way binding
    is applied to an HTML document. Also, since Angular is a framework, it is written
    to handle many of the user interactions behind the scenes. Large portions of the
    code would have to be rewritten if Angular was added to an existing ArcGIS JavaScript
    API application.
  prefs: []
  type: TYPE_NORMAL
- en: In conclusion, we could have easily accomplished what we wanted using Dojo and
    the ArcGIS JavaScript API. We could save time and bandwidth on a smaller device
    like a smartphone or tablet by writing these portions using the ArcGIS JavaScript
    API. However, it helps to know how to incorporate ArcGIS maps with existing applications
    written in these other frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you have learned how to use the ArcGIS JavaScript API along
    with other JavaScript libraries. We built applications using jQuery, Backbone.js,
    Knockout.js, and Angular.js. We compared the different uses of the libraries and
    frameworks, and how they worked with the ArcGIS API and Dojo.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll tackle a topic that strikes fear into the hearts
    of some JavaScript developers… styling.
  prefs: []
  type: TYPE_NORMAL
