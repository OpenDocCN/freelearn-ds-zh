- en: Chapter 4. Using OpenCL Functions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 4 章：使用 OpenCL 函数
- en: 'In this chapter, we''ll cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Storing vectors to an array
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将向量存储到数组中
- en: Loading vectors from an array
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从数组中加载向量
- en: Using geometric functions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用几何函数
- en: Using integer functions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用整数函数
- en: Using floating-point functions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用浮点函数
- en: Using trigonometric functions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用三角函数
- en: Arithmetic and rounding in OpenCL
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenCL 中的算术和舍入
- en: Using the shuffle function in OpenCL
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 OpenCL 中使用 shuffle 函数
- en: Using the select function in OpenCL
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 OpenCL 中使用选择函数
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In this chapter, we are going to explore how to utilize the common functions
    provided by OpenCL in your code. The functions we are examining would be mostly
    mathematical operations applied to the elements, and in particular applied to
    a vector of elements. Recall that the vectors are OpenCL's primary way to allow
    multiple elements to be processed on your hardware. As the OpenCL vendor can often
    produce vectorized hardware instructions to efficiently load and store such elements,
    try to use them as much as possible.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨如何在你的代码中利用 OpenCL 提供的常用函数。我们正在检查的函数将主要是应用于元素的数学运算，特别是应用于元素向量。回想一下，向量是
    OpenCL 允许多个元素在硬件上并行处理的主要方式。由于 OpenCL 供应商通常可以生成矢量化硬件指令来有效地加载和存储此类元素，因此尽可能多地使用它们。
- en: 'In detail, we are going to take a dive into how the following works:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 详细来说，我们将深入了解以下内容的工作原理：
- en: Data load and store functions for vectors
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向量的数据加载和存储函数
- en: Geometric functions
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 几何函数
- en: Integer functions
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整数函数
- en: Floating-point functions
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浮点函数
- en: Trigonometric functions
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三角函数
- en: Finally, we will present two sections on how the OpenCL's `shuffle` and `select`
    functions would work if you choose to use them in your applications.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将介绍两个部分，说明如果你选择在你的应用程序中使用 OpenCL 的 `shuffle` 和 `select` 函数，它们将如何工作。
- en: Storing vectors to an array
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将向量存储到数组中
- en: In the previous chapters, you caught glimpses of how we use vectors in various
    ways from a tool to transport data in an efficient manner to the device and from
    the device. We have also learned that OpenCL provides a substantial amount of
    functions that actually work on vectors. In this section, we will explore how
    we can store vectors to an array (when we use arrays in this context with a vector,
    we mean an array that contains scalar values).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，你瞥见了我们如何以各种方式使用向量，从一种将数据以高效方式传输到设备并从设备传输的工具，到 OpenCL 实际上在向量上工作的函数。我们还了解到
    OpenCL 提供了大量针对向量的函数。在本节中，我们将探讨如何将向量存储到数组中（当我们在这个上下文中使用数组与向量一起时，我们指的是包含标量值的数组）。
- en: The `vstore<N>` functions, where `<N>` is `2`, `3`, `4`, `8`, and `16`, are
    the primary functions you will use to actually signal the OpenCL that you wish
    to store the elements in your vector that has to be transported in a parallel
    fashion to a destination; this is often a scalar array or another vector.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`vstore<N>` 函数，其中 `<N>` 是 `2`、`3`、`4`、`8` 和 `16`，是你将使用的主要函数，以实际通知 OpenCL 你希望将你的向量元素以并行方式存储到目的地；这通常是一个标量数组或另一个向量。'
- en: 'We should be clear that `gentypeN` is not a C-like type alias for a data type,
    but rather a logical placeholder for the types such as `char`, `uchar`, `short`,
    `ushort`, `int`, `uint`, `long`, `ulong`, `float`, and `double`. The `N` stands
    for whether it is a data structure that aggregates `2`, `3`, `4`, `8`, or `16`
    elements. Remember that if you wish to store vectors of the type `double`, then
    you need to ensure that the directive `#pragma OPENCL EXTENSION cl_khr_fp64 :
    enable` is in your code before any `double` precision data type is declared in
    the kernel code.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '我们应该清楚，`gentypeN` 不是一个类似于 C 的数据类型别名，而是一个用于诸如 `char`、`uchar`、`short`、`ushort`、`int`、`uint`、`long`、`ulong`、`float`
    和 `double` 等类型的逻辑占位符。`N` 表示它是一个聚合 `2`、`3`、`4`、`8` 或 `16` 个元素的数结构。记住，如果你希望存储 `double`
    类型的向量，那么你需要在内核代码中声明任何 `double` 精度数据类型之前，确保代码中包含指令 `#pragma OPENCL EXTENSION cl_khr_fp64
    : enable`。'
- en: Tip
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Hence, the `vstoreN` API will write `sizeof(gentypeN)` bytes given by the data
    to the address `(p + (offset *N))`. The address computed as `(p + (offset * N))`
    must be 8-bit aligned if `gentype` is `char` or `uchar`; 16-bit aligned if `gentype`
    is `short` or `ushort`; 32-bit aligned if `gentype` is `int` or `uint`; 64-bit
    aligned if `gentype` is `long`, `ulong` or `double`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`vstoreN` API 将将数据提供的 `sizeof(gentypeN)` 字节写入地址 `(p + (offset * N))`。如果 `gentype`
    是 `char` 或 `uchar`，则计算为 `(p + (offset * N))` 的地址必须是 8 位对齐；如果 `gentype` 是 `short`
    或 `ushort`，则必须是 16 位对齐；如果 `gentype` 是 `int` 或 `uint`，则必须是 32 位对齐；如果 `gentype`
    是 `long`、`ulong` 或 `double`，则必须是 64 位对齐。
- en: You should notice that the memory writes can span from the global memory space
    (`__global`) to local (`__local`), or even to a work item private memory space
    (`__private`) but never to a constant memory space (`__constant` is read-only).
    Depending on your algorithm, you may need to coordinate the writes to another
    memory space with memory barriers otherwise known as fences.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该注意到，内存写入可以跨越全局内存空间（`__global`），到局部（`__local`），甚至到工作项私有内存空间（`__private`），但永远不会到常量内存空间（`__constant`是只读的）。根据你的算法，你可能需要通过内存屏障（也称为栅栏）来协调对另一个内存空间的写入。
- en: Tip
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The reason why you will need memory barriers or fences is that the memory reads
    and writes, in general, can be out of order, and the main reason for this is that
    the compiler optimization of the source code re-orders the instructions so that
    it can take advantage of the hardware.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要内存屏障或栅栏的原因是，通常情况下，内存的读取和写入可能会发生乱序，而造成这种情况的主要原因在于源代码的编译器优化会重新排序指令，以便利用硬件的优势。
- en: To expand on that idea a little, you might be aware that C++ has a keyword,
    `volatile`, which is used to mark a variable so that the compiler optimizations
    generally do not apply optimized load-stores to any use of that variable; and
    basically any use of such variable typically involves a load-use-store cycle at
    every use-site also known as sequence points.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步阐述这个想法，你可能知道C++有一个关键字`volatile`，它用于标记一个变量，使得编译器优化通常不会对该变量的任何使用应用优化过的加载/存储；基本上，这种变量的任何使用通常都涉及在每个使用点（也称为序列点）的加载-使用-存储周期。
- en: 'Loop unrolling is an optimization technique where the compiler attempts to
    remove branching in the code and hence, emitting any branch predication instructions
    so that the code executes efficiently. In the loops that you are accustomed to,
    you often find an expression as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 循环展开是一种优化技术，编译器试图在代码中移除分支，从而发出任何分支预测指令，以便代码高效执行。在你习惯的循环中，你经常会找到一个如下所示的表达式：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'What happens here is that when this code is compiled, you will notice that
    the ISA will issue an instruction to compare the value of `i` against that of
    `n`, and based on the result of that comparison, perform certain actions. Branching
    occurs when the executing thread takes a path if the condition is true or another
    path if the condition is false. Typically, a CPU executes both paths concurrently
    until it knows with a 100 percent certainty that it should take one of these paths,
    and the CPU can either dump the other unused path or it needs to backtrack its
    execution. In either case, you will lose several CPU cycles when this happens.
    Therefore, the developer can help the compiler and in our case, give a hint to
    the compiler what the value of `n` should be so that the compiler doesn''t have
    to generate code to check for `i < n`. Unfortunately, OpenCL 1.2 doesn''t support
    loop unrolling as an extension, but rather the AMD APP SDK and CUDA toolkits provide
    the following C directives:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生的情况是，当这段代码被编译时，你会注意到ISA会发出一条指令来比较`i`的值与`n`的值，并根据比较结果执行某些操作。当执行线程在条件为真时采取一条路径，条件为假时采取另一条路径时，就会发生分支。通常，CPU会同时执行这两条路径，直到它以100%的确定性知道应该采取其中一条路径，CPU可以丢弃另一条未使用的路径，或者它需要回溯其执行。在任一情况下，当这种情况发生时，你都会损失几个CPU周期。因此，开发者可以帮助编译器，在我们的情况下，向编译器提供关于`n`的值的提示，这样编译器就不必生成代码来检查`i
    < n`。不幸的是，OpenCL 1.2不支持作为扩展的循环展开，而是AMD APP SDK和CUDA工具包提供了以下C指令：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Without these functions, the OpenCL kernel would potentially issue a memory
    load-store for each processed element as illustrated by the following diagram:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 没有这些函数，OpenCL内核可能会为每个处理的元素发出一个内存加载/存储操作，如下面的图示所示：
- en: '![Storing vectors to an array](img/4520OT_04_01.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![将向量存储到数组中](img/4520OT_04_01.jpg)'
- en: Let's build a simple example of how we can use these `vstoreN` functions in
    a simple example.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个简单的例子来看看我们如何使用这些`vstoreN`函数。
- en: Getting ready
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe will show you a code snippet from `Ch4/simple_vector_store/simple_vector_store.cl`
    where a vector of 16 elements is loaded in and subsequently copied by using `vstore16(...)`.
    This API isn't exactly sugar syntax for a loop unrolling of 16 elements, and the
    reason is the compiler generates instructions that loads a vector of 16 elements
    from memory; also loop unrolling doesn't exist in OpenCL 1.1 as we know it but,
    it doesn't hurt to think in terms of that if it helps in understanding the concept
    behind the `vstoreN` APIs.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方将向你展示来自 `Ch4/simple_vector_store/simple_vector_store.cl` 的代码片段，其中使用 `vstore16(...)`
    加载并随后复制一个16个元素的向量。这个API并不完全等同于16个元素的循环展开的糖语法，原因是编译器生成从内存中加载16个元素的向量的指令；另外，OpenCL
    1.1中不存在我们知道的循环展开，但如果这有助于理解 `vstoreN` API背后的概念，那么从那个角度思考是没有害处的。
- en: How to do it…
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'The following is the kernel code where we will demonstrate the data transfers:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的内核代码是我们将演示数据传输的地方：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To compile it on the OS X platform, you will have to run a compile command
    similar to this:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要在OS X平台上编译它，你将不得不运行一个类似于以下编译命令：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Alternatively, you can type `make` in the source directory `Ch4/simple_vector_store/`.
    When that happens, you will have a binary executable named `VectorStore`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以在 `Ch4/simple_vector_store/` 源目录中输入 `make`。当这样做时，你将得到一个名为 `VectorStore`
    的二进制可执行文件。
- en: 'To run the program on OS X, simply execute the program `VectorStore` and you
    should either see the output: `Check passed!` or `Check failed!` as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 要在OS X上运行程序，只需执行程序 `VectorStore`，你应该看到以下输出：`Check passed!` 或 `Check failed!`，如下所示：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How it works…
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: This code can be understood from the perspective that a large vector exists
    in the global memory space, and our attempt is to load the vector into a variable
    in the private memory, that is, each work item has a unique variable named `t`;
    do nothing to it and store it back out to another in-memory array that is present
    in the global memory space.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码可以从这样一个角度来理解：在全局内存空间中存在一个大向量，我们的尝试是将这个向量加载到私有内存中的一个变量中，即每个工作项都有一个名为 `t`
    的唯一变量；对它不做任何操作，并将其存储回全局内存空间中另一个内存数组。
- en: Tip
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: In case you are curious about how this works, the memory writes are actually
    coalesced so that the writes are issued in bursts of bytes. The size of this burst
    is dependent on the hardware's internal architecture. As a concrete example in
    AMD's ATI GPUs, these memory writes are issued once every 16 writes are known
    to occur and it is related to the implementation of work items in the GPU. You
    see that it's very inefficient for the GPU to issue a read or write for every
    work item. When you combine this with the fact that there could be potentially
    hundreds of thousands of computing threads active in a clustered GPU solution,
    you can imagine the complexity is unfathomable if the manufacturers were to implement
    a logic that allows the developer to manage the programs on a work item/per-thread
    granularity. Hence graphic card manufacturers have decided that it is more efficient
    to implement the graphical cards to execute a group of threads in lock-step. ATI
    calls this group of executing threads a wave-front and NVIDIA calls it a warp.
    This understanding is critical when you start to develop nontrivial algorithms
    on your OpenCL device.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对此工作原理感到好奇，内存写入实际上是合并的，以便以字节突发的方式发出写入。这个突发的大小取决于硬件的内部架构。以AMD的ATI GPU为例，这些内存写入在已知发生16次写入后才会发出，这与GPU中工作项的实现有关。你可以看到，对于GPU来说，为每个工作项发出读取或写入是非常低效的。当你结合这样一个事实，即在一个集群GPU解决方案中可能存在数十万个活跃的计算线程，你可以想象，如果制造商实现一个允许开发者以工作项/线程粒度管理程序的逻辑，那么复杂性将是难以想象的。因此，显卡制造商决定，以锁步方式执行一组线程更有效率。ATI称这组执行线程为波前，NVIDIA称其为warp。当你开始在OpenCL设备上开发非平凡算法时，这种理解是至关重要的。
- en: When you build the sample application and run it, it doesn't do anything in
    particularly special from what we have seen but it is useful to see how the underlying
    code is generated, and in this example the Intel OpenCL SDK is illustrative.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当你构建示例应用程序并运行它时，它并没有做我们看到的特别特殊的事情，但看到底层代码是如何生成的是有用的，在这个例子中，Intel OpenCL SDK是说明性的。
- en: '![How it works…](img/4520OT_04_02.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的…](img/4520OT_04_02.jpg)'
- en: The assembly code snippet in particular is that of the resultant translation
    to **SSE2/3/4** or **Intel AVX** (**Advanced Vector Extensions**) code.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 特别的，汇编代码片段是结果翻译到 **SSE2/3/4** 或 **Intel AVX** （**高级向量扩展**）代码。
- en: Loading vectors from an array
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从数组中加载向量
- en: The `vloadN` functions are typically used to load multiple elements from an
    in-memory array to a destination in-memory data structure and are often a vector.
    Similar to the `vstoreN` functions, the `vloadN` functions also load elements
    from the global (`__global`), local (`__local`), work item private (`__private`),
    and finally constant memory spaces (`__constant`).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`vloadN` 函数通常用于从内存中的数组加载多个元素到内存中的目标数据结构，通常是向量。类似于 `vstoreN` 函数，`vloadN` 函数也加载来自全局（`__global`）、局部（`__local`）、工作项私有（`__private`）以及最后常量内存空间（`__constant`）的元素。'
- en: 'We should be clear that `gentypeN` is not a C-like type alias for a data type
    but rather a logical placeholder for the types: `char`, `uchar`, `short`, `ushort`,
    `int`, `uint`, `long`, `ulong`, `float`, or `double` and the `N` stands for whether
    it''s a data structure that aggregates `2`, `3`, `4`, `8`, or `16` elements. Without
    this function, the kernel needs to issue potentially multiple memory loads as
    illustrated by the following diagram:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该清楚，`gentypeN` 不是一个类似于C的数据类型别名，而是一个用于类型的逻辑占位符：`char`、`uchar`、`short`、`ushort`、`int`、`uint`、`long`、`ulong`、`float`
    或 `double`，而 `N` 表示它是一个聚合 `2`、`3`、`4`、`8` 或 `16` 个元素的 数据结构。没有这个函数，内核需要发出可能多个内存加载，如下面的图示所示：
- en: '![Loading vectors from an array](img/4520OT_04_03.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![从数组中加载向量](img/4520OT_04_03.jpg)'
- en: Getting ready
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The following is an excerpt from `Ch4/simple_vector_load/simple_vector_load.cl`.
    We focus our attention to understand how to load vectors of elements from the
    device memory space for computation within the device, that is, CPU/GPU. But this
    time round, we use an optimization technique called **prefetching** (its warming
    up the cache when your code is going to make use of the data soon and you want
    it to be near also known as spatial and temporal locality), and is typically used
    to assign to local memory space so that all work items can read the data off the
    cache without flooding requests onto the bus.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从 `Ch4/simple_vector_load/simple_vector_load.cl` 的摘录。我们专注于理解如何在设备内存空间中加载元素向量以进行设备内的计算，即CPU/GPU。但这次，我们使用了一种称为**预取**（当你的代码即将使用数据时预热缓存，并且你希望它也接近，也称为空间和时间局部性）的优化技术，通常用于分配给局部内存空间，以便所有工作项都可以从缓存中读取数据，而不会在总线上产生过多的请求。
- en: How to do it…
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'The following is the kernel code from which we shall draw our inspiration:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们将从中汲取灵感的内核代码：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To compile it on the OS X platform, you will have to run a compile command
    similar to this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 要在OS X平台上编译它，你必须运行一个类似于以下命令的编译命令：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Alternatively, you can type `make` in the source directory `Ch4/simple_vector_load/`.
    When that happens, you will have a binary executable named `VectorLoad`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以在源目录 `Ch4/simple_vector_load/` 中输入 `make`。当这样做时，你将得到一个名为 `VectorLoad`
    的二进制可执行文件。
- en: 'To run the program on OS X, simply execute the program `VectorLoad` and you
    should either see the output: `Check passed!` or `Check failed!` as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要在OS X上运行程序，只需执行程序 `VectorLoad`，你应该会看到以下输出：`Check passed!` 或 `Check failed!`：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: How it works…
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The kernel would proceed to prefetch the `16` values of type `float` from the
    `__global` memory space to the global cache via the first work item in the work
    group, which would ultimately arrive in the work item's `__private` memory space
    via the `vload16` API. Once that value is loaded, we can assign individual floats
    to the array and finally output them to the destination via an explicit write
    to the `__global` memory space of `out`. This is one method in which you can conduct
    memory load from a scalar array that resides in the global memory space.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 内核将继续从全局内存空间通过工作组中的第一个工作项预取 `16` 个 `float` 类型的值到全局缓存，这些值最终将通过 `vload16` API到达工作项的
    `__private` 内存空间。一旦这些值被加载，我们可以将单个浮点数分配给数组，并最终通过显式写入 `out` 的 `__global` 内存空间将它们输出到目标位置。这是从驻留在全局内存空间中的标量数组进行内存加载的一种方法。
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The preceding line is an optimization technique used to improve data reuse
    by making it available before it is required; this prefetch instruction is applied
    to a work item in a work group and we''ve chosen the first work item in each work
    group to carry this out. In algorithms where there is heavy data reuse, the benefits
    would be more significant than the following example:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 前一行是一个优化技术，用于通过在需要之前提供数据来提高数据重用性；这个预取指令应用于工作组中的一个工作项，并且我们选择了每个工作组中的第一个工作项来执行这项操作。在存在大量数据重用的算法中，其好处将比以下示例更显著：
- en: 'Another thing you may have noticed is that we didn''t write the following code:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还注意到我们没有编写以下代码：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The reason why we did not do this is because OpenCL forbids the implicit/explicit
    conversion of a vector type to a scalar.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有这样做的原因是 OpenCL 禁止隐式/显式地将向量类型转换为标量。
- en: '![How it works…](img/4520OT_04_04.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理…](img/4520OT_04_04.jpg)'
- en: One interesting thing that is worth pointing out other than the generated SSE
    instructions is the fact that multiple hardware prefetch instructions are generated,
    even though the code only mentions one prefetch instruction. This is the sort
    of façade that allows OpenCL vendors to implement the functionality based on an
    open standard, while still allowing the vendors to hide the actual implementation
    details from the developer.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 除了生成的 SSE 指令之外，还有一件有趣的事情值得指出，那就是即使代码只提到了一个预取指令，也会生成多个硬件预取指令。这种伪装允许 OpenCL 供应商根据开放标准实现功能，同时仍然允许供应商向开发者隐藏实际的实现细节。
- en: Using geometric functions
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用几何函数
- en: The geometric functions are used by the programmers to perform common computation
    on vectors, for example, cross or dot products, normalizing a vector, and length
    of a vector. To recap a little about vector cross and dot products, remember that
    a vector in the mathematical sense represents a quantity that has both direction
    and magnitude, and these vectors are used extensively in computer graphics.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 几何函数被程序员用于在向量上执行常见计算，例如，叉积或点积，归一化向量，以及向量的长度。为了回顾一下向量的叉积和点积，请记住，在数学意义上，向量代表具有方向和大小的数量，这些向量在计算机图形学中被广泛使用。
- en: 'Quite often, we need to compute the distance (in degrees or radians) between
    two vectors and to do this, we need to compute the dot product, which is defined
    as:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 很频繁地，我们需要计算两个向量之间的距离（以度或弧度为单位），为此，我们需要计算点积，它被定义为：
- en: '![Using geometric functions](img/4520OT_04_05.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![使用几何函数](img/4520OT_04_05.jpg)'
- en: 'It follows that if *a* is perpendicular to *b* then it must be that *a . b
    = 0*. The dot product is also used to compute the matrix-vector multiplication
    which solves a class of problems known as **linear systems**. Cross products of
    two 3D vectors will produce a vector that is perpendicular to both of them and
    can be defined as:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果 *a* 与 *b* 垂直，那么它必须满足 *a . b = 0*。点积还用于计算矩阵-向量乘法，这解决了被称为 **线性系统** 的一类问题。两个
    3D 向量的叉积将产生一个垂直于它们的向量，可以定义为：
- en: '![Using geometric functions](img/4520OT_04_06.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![使用几何函数](img/4520OT_04_06.jpg)'
- en: The difference between these products is the fact that the dot product produces
    a scalar value while the cross product produces a vector value.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这些乘积之间的区别在于，点积产生一个标量值，而叉积产生一个向量值。
- en: 'The following is a list of OpenCL''s geometric functions:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个 OpenCL 的几何函数列表：
- en: '| Function | Description |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| 函数 | 描述 |'
- en: '| --- | --- |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `float4 cross(float4 m, float4 n)``float3 cross(float3 m, float3 n)` | Returns
    the cross product of `m.xyz` and `n.xyz` and the `w` component in the result vector
    is always zero |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `float4 cross(float4 m, float4 n)` `float3 cross(float3 m, float3 n)` | 返回
    `m.xyz` 和 `n.xyz` 的叉积，结果向量中的 `w` 分量始终为零 |'
- en: '| `float dot(floatn m, floatn n)` | Returns the dot product of two vectors
    |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `float dot(floatn m, floatn n)` | 返回两个向量的点积 |'
- en: '| `float distance(floatn m, floatn n)` | Returns the distance between `m` and
    `n`. This is computed as:`length(m – n)` |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `float distance(floatn m, floatn n)` | 返回 `m` 和 `n` 之间的距离。这是通过 `length(m
    – n)` 计算得出的 |'
- en: '| `float length(floatn p)` | Return the length of the vector `p` |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `float length(floatn p)` | 返回向量 `p` 的长度 |'
- en: '| `floatn normalize(floatn p)` | Returns a vector in the same direction as
    `p` but with a length of `1` |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `floatn normalize(floatn p)` | 返回与 `p` 方向相同但长度为 `1` 的向量 |'
- en: '| `float fast_distance(floatn p0, floatn p1)` | Returns `fast_length(p0 – p1)`
    |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `float fast_distance(floatn p0, floatn p1)` | 返回 `fast_length(p0 – p1)` |'
- en: '| `float fast_length(floatn p)` | Returns the length of vector `p` computed
    as:`half_sqrt()` |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `float fast_length(floatn p)` | 返回向量 `p` 的长度，计算方式为:`half_sqrt()` |'
- en: '| `floatn fast_normalize(floatn p)` | Returns a vector in the same direction
    as `p` but with a length of `1`. `fast_normalize` is computed as:`p * half_sqrt()`
    |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `floatn fast_normalize(floatn p)` | 返回与 `p` 方向相同但长度为 `1` 的向量。`fast_normalize`
    是通过:`p * half_sqrt()` 计算得出的 |'
- en: You should be aware that these functions are implemented in OpenCL using the
    *round to nearest even* rounding mode also known as **rte-mode**.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该知道，这些函数是在 OpenCL 中使用 *四舍五入到最接近偶数* 的舍入模式实现的，也称为 **rte-mode**。
- en: Next, let's take a look at an example that utilizes some of these functions.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看一个利用这些函数的示例。
- en: Getting ready
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The code snippet in `Ch4/simple_dot_product/matvecmult.cl` illustrates how to
    compute the dot product between a 2D vector and a matrix and write back the result
    of that computation to the output array. When you are starting out with OpenCL,
    there might be two probable ways in which you will write this functionality, and
    I think it is instructive to discover what the differences are; however we only
    show the relevant code snippet that demonstrates the dot API.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`Ch4/simple_dot_product/matvecmult.cl` 中的代码片段说明了如何计算二维向量和矩阵之间的点积，并将该计算的输出结果写回输出数组。当你刚开始使用
    OpenCL 时，可能会有两种可能的方式来编写这个功能，我认为发现这些差异是有教育意义的；然而，我们只展示了演示点积 API 的相关代码片段。'
- en: How to do it…
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'The following is the simplest implementation of the matrix dot product operation:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是最简单的矩阵点积操作的实现：
- en: '[PRE10]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To compile this on the OS X platform, you will have to run a compile command
    similar to this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 OS X 平台上编译此程序，你需要运行一个类似于以下的编译命令：
- en: '[PRE11]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Alternatively, you can type `make` in the source directory `Ch4/simple_dot_product/`.
    When that happens, you will have a binary executable named `MatVecMult`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以在源目录 `Ch4/simple_dot_product/` 中输入 `make`。当这样做时，你将有一个名为 `MatVecMult` 的二进制可执行文件。
- en: 'To run the program on OS X, simply execute the program `MatVecMult` and you
    should either see the output: `Check passed!` or `Check failed!` as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 OS X 上运行程序，只需执行名为 `MatVecMult` 的程序，你应该会看到以下输出：`Check passed!` 或 `Check failed!`：
- en: '[PRE12]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: How it works…
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'The previous code snippet is probably the simplest you will want to write to
    implement the matrix dot product operation. The kernel actually reads a vector
    of `4` floats from the `__global` memory spaces of both inputs, computes the dot
    product between them, and writes it back out to `__global` memory space of the
    destination. Previously, we mentioned that there might be another way to write
    this. Yes, there is and the relevant code is shown as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码片段可能是你想要编写的最简单的实现矩阵点积操作的代码。内核实际上从两个输入的 `__global` 内存空间中读取 `4` 个浮点数向量，计算它们之间的点积，并将结果写回目标
    `__global` 内存空间。之前我们提到可能还有另一种编写方式。是的，有，相关的代码如下：
- en: '[PRE13]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: When you compare this implementation without using the dot API, you will discover
    that you not only need to type more but also you will have increased the number
    of work item variables which happens to be in the `__private` memory space; often
    you don't want to do this because it hinders the code readability, and also quite
    importantly scalability because too many registers are consumed.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当你比较这个没有使用点积 API 的实现时，你会发现你不仅需要输入更多，而且你还将增加工作项变量的数量，这些变量恰好位于 `__private` 内存空间中；通常你不想这样做，因为它阻碍了代码的可读性，并且也非常重要的是可扩展性，因为消耗了太多的寄存器。
- en: Note
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In OpenCL implementations, they would need to manage the available resources
    on the device, which could be available memory or available compute units. One
    such resource is the register file that contains a fixed number of general-purpose
    registers that the device has for executing one or many kernels. During the compilation
    of the OpenCL kernel, it will be determined how many registers are needed by each
    kernel for execution. An example would be where we assume that a kernel is developed
    that uses 10 variables in the `__private` memory space and the register file is
    `65536`, and that would imply that we can launch 65536 / 10 = 6553 work items
    to run our kernel. If you rewrite your kernel in such a way that uses more data
    sharing through the `__local` memory spaces, then you can free more registers
    and you can scale your kernel better.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在 OpenCL 实现中，他们需要管理设备上的可用资源，这些资源可能是可用内存或可用计算单元。其中一种资源是包含固定数量通用寄存器的寄存器文件，设备使用这些寄存器来执行一个或多个内核。在
    OpenCL 内核编译期间，将确定每个内核执行所需的寄存器数量。例如，我们假设开发了一个内核，它使用 `__private` 内存空间中的 10 个变量，寄存器文件为
    `65536`，这意味着我们可以启动 65536 / 10 = 6553 个工作项来运行我们的内核。如果你以这种方式重写你的内核，使用更多的 `__local`
    内存空间中的数据共享，那么你可以释放更多的寄存器，并且可以更好地扩展你的内核。
- en: Using integer functions
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用整数函数
- en: The integer functions in OpenCL primarily provides useful ways in which you
    can use them to perform the usual mathematical calculations such as obtaining
    an absolute value, halving a value, locating the minimum or maximum of three values,
    cyclic shift of a number, and specialized form of multiplication which is designed
    to work for a certain class of problems. Many of the functions that we have mentioned
    such as `min` and `max` do not perform the comparisons in an atomic fashion, but
    if you do like to ensure that, then a class of atomic functions can be used instead
    and we'll examine them later.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCL 中的整数函数主要提供了有用的方式，你可以使用它们来执行常规的数学计算，例如获取绝对值、将值除以二、定位三个值的最小值或最大值、数字的循环移位，以及为解决特定类问题而设计的特殊乘法形式。我们提到的许多函数，如
    `min` 和 `max`，并不以原子的方式执行比较，但如果你确实想确保这一点，则可以使用一类原子函数，我们将在稍后考察它们。
- en: A class of integer functions is the atomic functions, which allows the developer
    to swap values (single-precision floating-point values too) in an atomic fashion,
    and some of these functions implements **CAS** (**Compare-And-Swap**) semantics.
    Typically, you may want to ensure some sort of atomicity to certain operations
    because without that, you will encounter race conditions.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 整数函数的一类是原子函数，它允许开发者以原子方式交换值（包括单精度浮点值），其中一些函数实现了**CAS**（**比较并交换**）语义。通常，你可能想确保某些操作具有原子性，因为没有这个特性，你将遇到竞态条件。
- en: '![Using integer functions](img/4520OT_04_07.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![使用整数函数](img/4520OT_04_07.jpg)'
- en: 'The atomic functions typically take in two inputs (they have to be of integral
    types, only `atomic_xchg` supports single-precision floating-point types), where
    the first argument is a pointer to a memory location in the global (`__global`)
    and local (`__local`) memory spaces ,and they are typically annotated with the
    `volatile` keyword, which prevents the compiler from optimizing the instructions
    related to the use of the variable; this is important as the reads and writes
    could be out of order and could affect the correctness of the program. The following
    is an illustration of a mental model of how atomic operations serialize the access
    to a piece of shared data:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 原子函数通常接受两个输入（它们必须是整型，只有 `atomic_xchg` 支持单精度浮点类型），第一个参数是一个指向全局（`__global`）和局部（`__local`）内存空间中内存位置的指针，它们通常用
    `volatile` 关键字进行标注，这阻止编译器优化与变量使用相关的指令；这很重要，因为读取和写入可能是不按顺序的，可能会影响程序的正确性。以下是一个说明原子操作如何序列化对共享数据的访问的心理模型：
- en: '![Using integer functions](img/4520OT_04_08.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![使用整数函数](img/4520OT_04_08.jpg)'
- en: 'The following example, `atomic_add`, has two versions which work on signed
    or unsigned values:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例 `atomic_add` 有两种版本，它们可以处理有符号或无符号值：
- en: '[PRE14]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Another observation you need to be aware of is the fact that just because you
    can apply atomicity to assert the correctness of certain values, it does not necessarily
    imply program correctness.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要注意到的一个另一点是，仅仅因为你可以应用原子性来断言某些值的正确性，并不意味着程序的正确性。
- en: The reason why this is the case is due to the manner in which work items are
    implemented as we mentioned earlier in this chapter, that NVIDIA and ATI executes
    work items in groups known as work groups and each work group would contain multiple
    chunks of executing threads, otherwise, known as **warp** (32 threads) and **wavefront**
    (64 threads) respectively. Hence when a work group executes on a kernel, all the
    work items in that group are executing in lock-step and normally this isn't a
    problem. The problem arises when the work group is large enough to contain more
    than one warp/wavefront; then you have a situation where one warp/wavefront executes
    slower than another and this can be a big issue.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况的原因是由于工作项的实现方式，正如我们在本章前面提到的，NVIDIA 和 ATI 以称为工作组的形式执行工作项，每个工作组包含多个执行线程块，分别称为**warp**（32个线程）和**wavefront**（64个线程）。因此，当工作组在内核上执行时，该组中的所有工作项都是同步执行的，通常这不会成为问题。问题出现在工作组足够大，可以包含多个
    warp/wavefront 的情况下；那么你将面临一个情况，其中一个 warp/wavefront 的执行速度比另一个慢，这可能会成为一个大问题。
- en: 'The real issue is that the memory ordering cannot be enforced across all compliant
    OpenCL devices; so the only way to tell the kernel that we like the loads and
    stores to be coordinated is by putting a memory barrier at certain points in your
    program. When such a barrier is present, the compiler will generate the instructions
    that will make sure all the loads-stores to the global/local memory space prior
    to the barrier is done for all the executing work items before executing any instructions
    that come after the barrier, which will guarantee that the updated data is seen;
    or in compiler lingo: memory loads and stores will be committed to the memory
    before any loads and stores follows the barrier/fence.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 真正的问题是，无法在所有符合 OpenCL 标准的设备上强制执行内存排序；因此，唯一的方法是在程序中的某些点上放置内存屏障，来告诉内核我们希望加载和存储操作协调一致。当存在这样的屏障时，编译器将生成指令，确保在执行屏障之后的任何指令之前，所有执行工作项都完成了在屏障之前对全局/局部内存空间的加载和存储操作，这将保证更新的数据被看到；或者用编译器的术语来说：内存加载和存储操作将在任何加载和存储操作之后提交到内存中。
- en: These APIs provide the developer with a much better level of control when it
    comes to ordering both reads and writes, reads only, or writes only. The argument
    flags, can take a combination of `CLK_LOCAL_MEM_FENCE` and/or `CLK_GLOBAL_MEM_FENCE`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这些 API 为开发者提供了在读取和写入排序、只读或只写方面更好的控制级别。参数标志可以组合 `CLK_LOCAL_MEM_FENCE` 和/或 `CLK_GLOBAL_MEM_FENCE`。
- en: Getting ready
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The recipe will show you the code snippet in `Ch4/par_min/par_min.cl` for finding
    the minimum value in a large array in the device, that is, GPU or CPU memory space.
    This example combines a few concepts such as using the OpenCL's atomic directives
    to enable atomic functions and memory barriers to coordinate memory loads and
    stores.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 该配方将向你展示 `Ch4/par_min/par_min.cl` 中的代码片段，用于在设备（即 GPU 或 CPU 内存空间）中的大数组中找到最小值。此示例结合了几个概念，例如使用
    OpenCL 的原子指令来启用原子函数和内存屏障来协调内存加载和存储。
- en: How to do it…
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The following code demonstrates how you might want to find the minimum number
    in a large container of integers:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了如何在包含大量整数的容器中找到最小数的方法：
- en: '[PRE15]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To compile it on the OS X platform, you will have to run a compile command
    similar to this:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 OS X 平台上编译它，你必须运行一个类似于以下编译命令：
- en: '[PRE16]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Alternatively, you can type `make` in the source directory `Ch4/par_min/`. When
    that happens, you will have a binary executable named `ParallelMin`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以在源目录 `Ch4/par_min/` 中输入 `make`。当这样做时，你将得到一个名为 `ParallelMin` 的二进制可执行文件。
- en: 'To run the program on OS X, simply execute the program `ParallelMin` and you
    should either see the output: `Check passed!` or `Check failed!` as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在 OS X 操作系统上运行程序，只需执行程序 `ParallelMin`，你应该会看到以下输出：`Check passed!` 或 `Check failed!`，如下所示：
- en: '[PRE17]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: How it works…
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The way this works is that a work item walks through the source buffer and attempts
    to locate the minimum value in parallel, and when the kernel is running on the
    CPU or GPU, the source buffer is chopped evenly between those threads and each
    thread would walk through the buffer that's assigned to them in `__global memory`
    and reduces all values into a minimum value in the `__private` memory.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这种工作方式是，一个工作项遍历源缓冲区并尝试并行地找到最小值，当内核在 CPU 或 GPU 上运行时，源缓冲区被均匀地分配给这些线程，每个线程将遍历分配给它们的
    `__global` 缓冲区，并将所有值减少到 `__private` 内存中的最小值。
- en: Subsequently, all threads will reduce the minimum values in their `__private`
    memories to `__local` memory via an atomic operation and this reduced value is
    flushed to the `_` `_global` memory.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 随后，所有线程将通过原子操作将它们 `__private` 内存中的最小值减少到 `__local` 内存，并将此减少的值刷新到 `_` `_global`
    内存。
- en: Once the work groups have completed the execution, the second kernel, that is,
    `reduce` will reduce all the work group values into a single value in the `__global`
    memory using an atomic operation.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦工作组完成执行，第二个内核，即 `reduce`，将使用原子操作将所有工作组的值减少到 `__global` 内存中的单个值。
- en: Using floating-point functions
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用浮点函数
- en: So far, you have seen a couple of functions that takes argument as input or
    output single-precision or double-precision floating-point values. Given a floating-point
    value *x*, the OpenCL floating-point functions provide you with the capability
    to extract the mantissa and exponent from *x* via `frexp()`, decompose *x* via
    `modf()`, compute the next largest/smallest single-precision floating-point value
    via `nextafter()`, and others. Considering that there are so many useful floating-point
    functions, there are two functions which are important to understand because it's
    very common in OpenCL code. They are the `mad()` and `fma()` functions which is
    Multiply-Add and Fused Multiply-Add instruction respectively.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经看到了几个函数，它们接受单精度或双精度浮点数值作为输入或输出。给定一个浮点值 *x*，OpenCL 浮点函数为你提供了通过 `frexp()`
    从 *x* 中提取尾数和指数的能力，通过 `modf()` 分解 *x*，通过 `nextafter()` 计算下一个最大的/最小的单精度浮点值，以及其他功能。考虑到有如此多的有用浮点函数，有两个函数非常重要，因为它们在
    OpenCL 代码中非常常见。它们是 `mad()` 和 `fma()` 函数，分别对应乘加和融合乘加指令。
- en: The **Multiply-Add** (**MAD**) instruction performs a floating-point multiplication
    followed by a floating-point addition, but whether the product and its intermediary
    products are rounded is undefined. The **Fused Multiply-Add** (**FMA**) instruction
    only rounds the product and none of its intermediary products. The implementations
    typically trade off the precision against the speed of the operations.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '**乘加**（**Multiply-Add**，**MAD**）指令执行浮点数乘法后跟浮点数加法，但产品及其中间产品是否四舍五入是不确定的。**融合乘加**（**Fused
    Multiply-Add**，**FMA**）指令仅对产品进行四舍五入，不对其任何中间产品进行四舍五入。实现通常在操作的精度和速度之间进行权衡。'
- en: 'We probably shouldn''t dive into academic studies of this nature; however in
    times like this, we thought it might be helpful to point out how academia in many
    situations can help us to make an informed decision. Having said that, a particular
    study by Delft University of Technology entitled *A Comprehensive Performance
    Comparison of CUDA* and OpenCL link [http://www.pds.ewi.tudelft.nl/pubs/papers/icpp2011a.pdf](http://www.pds.ewi.tudelft.nl/pubs/papers/icpp2011a.pdf),
    suggests that FMA has a higher instruction count as compared to MAD implementations,
    which might lead us to the conclusion that MAD should run faster than FMA. We
    can guess approximately how much faster by taking a simple ratio between both
    instruction counts, which we should point out is a really simplistic view since
    we should not dispense away the fact that compiler vendors play a big role with
    their optimizing compilers, and to highlight that NVIDIA conducted a study entitled
    *Precision & Performance: Floating Point and IEEE 754 compliance for NVIDIA GPUs*,
    which can be read at: [http://developer.download.nvidia.com/assets/cuda/files/NVIDIA-CUDA-Floating-Point.pdf](http://developer.download.nvidia.com/assets/cuda/files/NVIDIA-CUDA-Floating-Point.pdf).
    The study suggests that FMA can offer performance in addition to precision, and
    NVIDIA is at least one company that we are aware of who is replacing MAD with
    FMA in their GPU chips.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能不应该深入这类学术研究；然而，在这样的时代，我们认为指出学术在许多情况下如何帮助我们做出明智的决定可能是有帮助的。话虽如此，代尔夫特理工大学的一项特别研究，题为
    *CUDA 和 OpenCL 的全面性能比较* [链接](http://www.pds.ewi.tudelft.nl/pubs/papers/icpp2011a.pdf)，表明与
    MAD 实现相比，FMA 指令计数更高，这可能会让我们得出结论，即 MAD 应该比 FMA 运行得更快。我们可以通过简单地比较两个指令计数来猜测大约快多少，但我们应指出，这是一个非常简化的观点，因为我们不应忽视编译器供应商在优化编译器中扮演着重要角色的事实，并强调
    NVIDIA 进行了一项名为 *精度与性能：NVIDIA GPU 的浮点数和 IEEE 754 兼容性* 的研究，该研究可在以下链接中阅读：[链接](http://developer.download.nvidia.com/assets/cuda/files/NVIDIA-CUDA-Floating-Point.pdf)。该研究建议
    FMA 可以提供精度和性能，NVIDIA 至少是我们所知的一个公司，它们在 GPU 芯片中用 FMA 替换了 MAD。
- en: Following the subject of multiplication, you should be aware that there are
    instructions for the multiplication of integers instead of floats; examples of
    those are `mad_hi`, `mad_sat`, and `mad24`, and these functions provide the developer
    with the fine grain control of effecting a more efficient computation and how
    it can be realized using these optimized versions. For example, `mad24` only operates
    on the lower 24-bits of a 32-bit integer because the expected value is in the
    range of [-223, 223 -1] when operating signed integers or [0, 224 -1] for unsigned
    integers.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循乘法的主题，你应该知道有针对整数乘法而不是浮点数的指令；这些指令的例子有 `mad_hi`、`mad_sat` 和 `mad24`，这些函数为开发者提供了对影响更高效计算以及如何使用这些优化版本实现的精细控制。例如，`mad24`
    只在 32 位整数的低 24 位上操作，因为当操作有符号整数时预期值在 [-223, 223 -1] 范围内，对于无符号整数则是 [0, 224 -1]。
- en: Getting ready
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The code snippet in `Ch4/simple_fma_vs_mad/fma_mad_cmp.cl` demonstrates how
    we can test the performance between the MAD and FMA instructions, if you so wish,
    to accomplish the computation. However, what we are going to demonstrate is to
    simply run each one of the kernels in turn, and we can check that the results
    are the same in both computations.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`Ch4/simple_fma_vs_mad/fma_mad_cmp.cl` 中的代码片段演示了如何测试 MAD 和 FMA 指令之间的性能，如果你愿意，可以完成计算。然而，我们将要演示的是简单地依次运行每个内核，并检查两种计算的结果是否相同。'
- en: How to do it…
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'The following code demonstrates how to use the MAD and FMA functions in OpenCL:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了如何在 OpenCL 中使用 MAD 和 FMA 函数：
- en: '[PRE18]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To compile it on the OS X platform, you will have to run a compile command
    similar to this:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 OS X 平台上编译它，你将需要运行一个类似于以下命令的编译命令：
- en: '[PRE19]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Alternatively, you can type `make` in the source directory `Ch4/simple_fma_vs_mad/`.
    When that happens, you will have a binary executable named `FmaMadCmp`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以在源目录 `Ch4/simple_fma_vs_mad/` 中输入 `make`。当这样做时，你将得到一个名为 `FmaMadCmp` 的二进制可执行文件。
- en: 'To run the program on OS X, simply execute the program `FmaMadCmp` and you
    should either see the output: `Check passed!` or `Check failed!` as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 OS X 上运行程序，只需执行程序 `FmaMadCmp`，你应该看到以下输出：`Check passed!` 或 `Check failed!`，如下所示：
- en: '[PRE20]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: How it works…
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'The driver code uses single-precision floating-point values to compute the
    value of the equation by running the two kernels in turn on the GPU/CPU. Each
    kernel would load the values from the `__global` memory space to the work item/thread''s
    `__private` memory space. The difference between both kernels is that one uses
    the FMA instruction while the other uses the MAD instruction. The method that
    is used to detect whether FMA instruction support is available on the device of
    choice is to detect whether `CP_FP_FMA` is returned after a call to `clGetDeviceInfo`
    passing in any of the following parameters: `CL_DEVICE_SINGLE_FP_CONFIG`, `CL_DEVICE_DOUBLE_FP_CONFIG`,
    and `CL_DEVICE_HALF_FP_CONFIG`. We use the flag `CP_FP_FMA` and `FP_FAST_FMA`
    to load the `fma` functions on our platform by including the header file `#include
    <math.h>`.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 驱动代码使用单精度浮点值通过在 GPU/CPU 上依次运行两个内核来计算方程的值。每个内核都会将值从 `__global` 内存空间加载到工作项/线程的
    `__private` 内存空间。两个内核之间的区别在于一个使用 FMA 指令，而另一个使用 MAD 指令。检测所选设备上是否支持 FMA 指令的方法是在调用
    `clGetDeviceInfo` 时传递以下参数之一：`CL_DEVICE_SINGLE_FP_CONFIG`、`CL_DEVICE_DOUBLE_FP_CONFIG`
    和 `CL_DEVICE_HALF_FP_CONFIG`。我们使用标志 `CP_FP_FMA` 和 `FP_FAST_FMA` 通过包含头文件 `#include
    <math.h>` 在我们的平台上加载 `fma` 函数。
- en: Note
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The C-macro `FP_FAST_FMA`, if defined is set to the constant of 1 to indicate
    that the `fma()` generally executes about as fast, or faster than, a multiple
    and an addition of double operands. If this macro is undefined, then it implies
    that your hardware doesn't support it.In the GNU GCC compiler suite, the macro
    you want to detect is `__FP_FAST_FMA`, which links to the `FP_FAST_FMA` if defined
    or passing `–mfused-madd` to the GCC compiler (on by default, autogenerate the
    FMA instructions if ISA supports).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果定义了 C 宏 `FP_FAST_FMA`，则将其设置为 1 的常量，以指示 `fma()` 通常执行速度与乘法和加法双操作数相当，或者更快。如果此宏未定义，则意味着你的硬件不支持它。在
    GNU GCC 编译器套件中，你想要检测的宏是 `__FP_FAST_FMA`，如果定义了它，则链接到 `FP_FAST_FMA`，或者将 `–mfused-madd`
    传递给 GCC 编译器（默认开启，如果 ISA 支持，则自动生成 FMA 指令）。
- en: Using trigonometric functions
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用三角函数
- en: The trigonometric functions are very useful if you were in the computer graphics
    industry ,or you are writing a simulation program for weather forecasts, continued
    fractions, and so on. OpenCL provides the usual suspects when it comes to the
    trigonometry support with `cos`, `acos`, `sin`, `asin`, `tan`, `atan`, `atanh`
    (hyperbolic arc tangent), `sinh` (hyperbolic sine), and so on.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在计算机图形学行业工作，或者你正在编写用于天气预报、连分数等的模拟程序，三角函数将非常有用。OpenCL 在提供三角函数支持时提供了常用的函数，如
    `cos`、`acos`、`sin`、`asin`、`tan`、`atan`、`atanh`（双曲反正切）、`sinh`（双曲正弦）等。
- en: 'In this section, we will take a look at the popular trigonometric identity
    function:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨流行的三角恒等式函数：
- en: '[PRE21]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: From the Pythagoras's theorem, we understood that a right-angled triangle with
    sides *a*,*b*,*c* and angle *t* at the vertex where *a* and *c* meet, *cos(t)*
    is by definition *a*/*c*, *sin(t* `)` is by definition *b*/*c*, and so *cos2(t)
    + sin2(t) = (a/c)2 + (b/c)2* when combined with the fact that *a2 + b2 = c2* hence
    *cos2(t) + sin2(t) = 1*.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 从毕达哥拉斯定理中，我们了解到，在 *a*、*b*、*c* 边的直角三角形中，在 *a* 和 *c* 相遇的顶点处有一个角 *t*，根据定义，*cos(t)*
    是 *a*/*c*，*sin(t)* 是 *b*/*c*，因此 *cos2(t) + sin2(t) = (a/c)2 + (b/c)2*，结合事实 *a2
    + b2 = c2*，因此 *cos2(t) + sin2(t) = 1*。
- en: Having armed ourselves with this knowledge, there are many interesting problems
    you can solve with this identity but for the sake of illustration let's suppose
    that we want to find the number of unit circles.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在掌握了这些知识之后，你可以用这个恒等式解决许多有趣的问题，但为了说明，让我们假设我们想要找到单位圆的数量。
- en: Unit circles are another way of looking at the identity we just talked about.
    A contrived example of this would be to determine which values would be valid
    unit circles from the given two arrays of supposedly values in degrees.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 单位圆是另一种看待我们刚才讨论的恒等式的方法。一个虚构的例子是确定从给定的两个数组中哪些值会是有效的单位圆。
- en: Getting ready
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The code snippet in `Ch4/simple_trigonometry/simple_trigo.cl` demonstrates the
    OpenCL kernel that is used to compute which values from the two data sources can
    correctly form a unit circle.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`Ch4/simple_trigonometry/simple_trigo.cl` 中的代码片段展示了用于计算从两个数据源中哪些值可以正确形成一个单位圆的
    OpenCL 内核。'
- en: Note
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you recall from basic trigonometry lessons you took, when you add the result
    of *sin(x) + cos(x)* where *x* is drawn from either positive or negative numbers,
    it will produce two distinct straight line functions *y = 1* and *y = -1* and
    when you square the results of *sin(x)* and *cos(x)*, the result of *cos2(t) +
    sin2(t) = 1* is obvious. See the following diagrams for illustration:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得你上过的基础三角学课程，当你将 *sin(x) + cos(x)* 的结果相加，其中 *x* 是来自正数或负数的值时，它将产生两个不同的直线函数
    *y = 1* 和 *y = -1*，并且当你对 *sin(x)* 和 *cos(x)* 的结果进行平方，*cos2(t) + sin2(t) = 1* 的结果显然。请参见以下图表以供说明：
- en: '![Getting ready](img/4520OT_04_09.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作](img/4520OT_04_09.jpg)'
- en: 'The preceding diagram and the following diagram reflect the graphs of *sin(x)*
    and *cos(x)* respectively:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图表和以下图表分别反映了 *sin(x)* 和 *cos(x)* 的图表：
- en: '![Getting ready](img/4520OT_04_10.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作](img/4520OT_04_10.jpg)'
- en: 'The following diagram illustrates how superimposing the previous two graphs
    would give a straight line that is represented by the equation:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表说明了如何将前两个图表叠加在一起，从而得到由以下方程表示的直线：
- en: '![Getting ready](img/4520OT_04_11.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作](img/4520OT_04_11.jpg)'
- en: How to do it…
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'The following code snippet shows you the kernel code that will determine unit
    circles:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了将确定单位圆的内核代码：
- en: '[PRE22]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To compile it on the OS X platform, you will have to run a compile command
    similar to this:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 OS X 平台上编译它，你需要运行一个类似于以下命令的编译命令：
- en: '[PRE23]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Alternatively, you can type `make` in the source directory `Ch4/simple_trigonometry/`.
    When that happens, you will have a binary executable named `SimpleTrigo`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以在源目录 `Ch4/simple_trigonometry/` 中输入 `make`。当这样做时，你将得到一个名为 `SimpleTrigo`
    的二进制可执行文件。
- en: 'To run the program on OS X, simply execute the program `SimpleTrigo` and you
    should either see the output shown as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 OS X 上运行程序，只需执行程序 `SimpleTrigo`，你应该会看到以下所示的输出：
- en: '[PRE24]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: How it works…
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The driver program conducts its usual operations of loading the two data sources
    by filling it up with values. Then the data sources is registered on the device
    command queue along with the kernel program objects that are ready for execution.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 驱动程序通过填充值来加载两个数据源，并将数据源注册在设备命令队列上，同时注册了准备执行的内核程序对象。
- en: During the execution of the kernel, the data sources are loaded into the device
    via a single-precision floating-point 16-element vector. As highlighted in previous
    chapters, this takes advantage of the device's vectorized hardware. The in-memory
    vectors are passed into the sine and cosine functions which comes in two versions
    where one takes a scalar value and second takes a vector value, and we flush the
    result out to global memory once we are done; and you will notice that the multiplication/addition
    operator actually does component-wise multiplication and addition.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在内核执行期间，数据源通过单一精度浮点16元素向量加载到设备中。正如前几章所强调的，这利用了设备的向量化硬件。内存中的向量被传递到正弦和余弦函数中，这两个版本中一个接受标量值，另一个接受向量值，一旦完成，我们就将结果输出到全局内存中；您会注意到乘法/加法运算符实际上执行的是逐分量乘法和加法。
- en: Arithmetic and rounding in OpenCL
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OpenCL中的算术和舍入
- en: 'Rounding is an important topic in OpenCL and we have not really dived into
    it yet but that''s about to change. OpenCL 1.1 supports four rounding modes: round
    to nearest (even number), round to zero, round to positive infinity, and round
    to negative infinity. The only round mode required by OpenCL 1.1 compliant devices
    is the round to nearest even.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 舍入是OpenCL中的一个重要主题，我们还没有真正深入探讨，但这种情况即将改变。OpenCL 1.1支持四种舍入模式：四舍五入到最接近的数（偶数）、四舍五入到零、四舍五入到正无穷大和四舍五入到负无穷大。OpenCL
    1.1合规设备所需的唯一舍入模式是四舍五入到最近的偶数。
- en: Note
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If the result is intermediate between two representable values, the even representation
    is chosen. Even, here, means that the lowest bit is zero.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果结果是两个可表示值之间的中间值，则选择偶数表示。在这里，“偶数”意味着最低位为零。
- en: You should be aware that these are applicable to single-precision floating-point
    values supported in OpenCL 1.1; we have to check with the vendors who provide
    functions that operate on double-precision floating-point values, though the author
    suspects that they should comply at least to support the round to nearest even
    mode.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该知道，这些适用于OpenCL 1.1支持的单一精度浮点值；我们必须与提供操作双精度浮点值函数的供应商进行核对，尽管作者怀疑它们至少应该遵守以支持四舍五入到最近的偶数模式。
- en: Another point is that, you cannot programmatically configure your kernels to
    inherit/change the rounding mode used by your calling environment, which most
    likely is where your program executes on the CPU. In GCC at least, you can actually
    use the inline assembly directives, for example, `asm("assembly code inside quotes")`
    to change the rounding mode in your program by inserting appropriate hardware
    instructions to your program. The next section attempts to demonstrate how this
    can be done by using the regular C programming with a little help from GCC.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 另一点是，您不能通过编程方式配置您的内核以继承/更改调用环境使用的舍入模式，这很可能是您的程序在CPU上执行的地方。在GCC至少，您实际上可以使用内联汇编指令，例如，`asm("assembly
    code inside quotes")`，通过向程序中插入适当的硬件指令来更改程序中的舍入模式。下一节将尝试通过使用常规C编程并从GCC获得一些帮助来演示如何实现这一点。
- en: Note
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'In the Intel 64 and IA-32 architectures, the rounding mode is controlled by
    a 2-bit **rounding control** (**RC**) field, and the implementation is hidden
    in two hardware registers: **x87 FPU** control register and **MXCSR** register.
    These two registers have the RC field and the RC in the x87 FPU control register
    is used by the CPU when computations are performed in the x87 FPU, while the RC
    field in the MXCSR is used to control rounding for **SIMD** floating-point computations
    performed with the **SSE/SSE2** instructions.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在Intel 64和IA-32架构中，舍入模式由一个2位的**舍入控制**（**RC**）字段控制，其实现在两个硬件寄存器中隐藏：**x87 FPU**控制寄存器和**MXCSR**寄存器。这两个寄存器都有RC字段，x87
    FPU控制寄存器中的RC在CPU执行x87 FPU计算时被使用，而MXCSR中的RC字段用于控制使用**SSE/SSE2**指令执行的**SIMD**浮点计算的舍入。
- en: Getting ready
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In the code snippet found in `Ch4/simple_rounding/simple_rounding.cl`, we demonstrate
    how *round to nearest even* mode is the default mode in the built-in functions
    provided by OpenCL 1.1\. The example proceeds to demonstrate how a particular
    built-in function and remainder, will use the default rounding mode to store the
    result of a floating-point computation. The next couple of operations is to demonstrate
    the usage of the following OpenCL built-in functions such as `rint`, `round`,
    `ceil`, `floor`, and `trunc`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Ch4/simple_rounding/simple_rounding.cl` 代码片段中，我们展示了 *四舍五入到最接近的偶数* 模式是 OpenCL
    1.1 提供的内置函数中的默认模式。示例继续演示了特定内置函数和余数将如何使用默认舍入模式来存储浮点计算的结果。接下来的几个操作是为了演示以下 OpenCL
    内置函数的用法，如 `rint`、`round`、`ceil`、`floor` 和 `trunc`。
- en: How to do it…
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'The following code snippet examines the various rounding modes:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段检查了各种舍入模式：
- en: '[PRE25]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To compile it on the OS X platform, you will have to run a compile command
    similar to this:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 OS X 平台上编译它，你必须运行一个类似于以下命令的编译命令：
- en: '[PRE26]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Alternatively, you can type `make` in the source directory `Ch4/simple_rounding/`.
    When that happens, you will have a binary executable named `SimpleRounding`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以在源目录 `Ch4/simple_rounding/` 中输入 `make`。当这样做时，你将得到一个名为 `SimpleRounding`
    的二进制可执行文件。
- en: 'To run the program on OS X, simply execute the program `SimpleRounding` and
    you should either see the output shown as follows:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 OS X 上运行程序，只需执行程序 `SimpleRounding`，你应该会看到以下所示的输出：
- en: '[PRE27]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: How it works…
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As before, the in-memory data structures on the host are initialized with values
    and they are issued to the device once the device's command queue is created;
    once that's done the kernel is sent off to the command queue for execution. The
    results is subsequently read back from the device and displayed on the console.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，主机上的内存数据结构使用值初始化，并在创建设备命令队列后一次性发送到设备；一旦完成，内核就会被发送到命令队列进行执行。随后，结果从设备读取并显示在控制台上。
- en: In order to understand how these functions work, is important that we study
    their behavior by first probing their method signatures, and subsequently analyzing
    the results of executing the program to gain insights into how the results came
    to be.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解这些函数是如何工作的，我们首先通过探究它们的方法签名，然后分析程序执行的结果，以获得对结果是如何产生的洞察是非常重要的。
- en: There's more…
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多……
- en: 'OpenCL 1.2 brings a wealth of mathematical functions to arm the developer and
    four of the common ones are computing the floor and ceiling, round-to-integral,
    truncation, and rounding floating-point values. The floor''s method signature
    is:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCL 1.2 为开发者带来了丰富的数学函数，以武装其能力，其中四个常见的函数是计算地板和天花板、四舍五入到整数、截断以及四舍五入浮点数。地板函数的签名是：
- en: '[PRE28]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This function rounds to the integral value using the *round to negative infinity*
    rounding mode. First of all, your OpenCL device needs to support this mode of
    rounding, and you can determine this by checking the existence of the value `CL_FP_ROUND_TO_INF`
    when you pass in `CL_DEVICE_DOUBLE_FP_CONFIG` to `clGetDeviceInfo(device_id, ...)`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数使用*四舍五入到负无穷*舍入模式四舍五入到整数值。首先，你的 OpenCL 设备需要支持这种舍入模式，你可以通过在传递 `CL_DEVICE_DOUBLE_FP_CONFIG`
    到 `clGetDeviceInfo(device_id, ...)` 时检查 `CL_FP_ROUND_TO_INF` 值的存在来确定这一点。
- en: 'The next method, ceil''s signature is:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个方法，ceil的签名是：
- en: '[PRE29]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This function rounds to the integral value using the *round to positive infinity*
    rounding mode.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数使用*四舍五入到正无穷*舍入模式四舍五入到整数值。
- en: Be aware that when a value between `-1` and `0` is passed to `ceil`, then the
    result is automatically `-0`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当将介于 `-1` 和 `0` 之间的值传递给 `ceil` 时，结果将自动变为 `-0`。
- en: 'The method for rounding to the integral value has a signature like this:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 四舍五入到整数值的方法签名如下：
- en: '[PRE30]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This function rounds to the integral value using the *round to nearest even*
    rounding mode.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数使用*四舍五入到最接近的偶数*舍入模式四舍五入到整数值。
- en: Be aware that when a value between `-0.5` and `0` is passed to `rint`, then
    the result is automatically `-0`.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当将介于 `-0.5` 和 `0` 之间的值传递给 `rint` 时，结果将自动变为 `-0`。
- en: 'The truncation function is very useful when precision is not high on your priority
    list and its method signature is:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 截断函数在精度不是你优先考虑的事项时非常有用，其方法签名是：
- en: '[PRE31]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This function rounds to the integral value using the *round to zero* rounding
    mode.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数使用*四舍五入到零*舍入模式四舍五入到整数值。
- en: 'The rounding method signature is:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 舍入方法签名如下：
- en: '[PRE32]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This function returns the integral value nearest to *x* rounding halfway cases
    away from zero, regardless of the current rounding direction. The full list of
    available functions can be found in the *Section 6.12.2* of the OpenCL 1.2 specification.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数返回最接近 *x* 的整数值，对于四舍五入的情况，无论当前舍入方向如何，都舍去零。可用函数的完整列表可以在 OpenCL 1.2 规范的 *第 6.12.2
    节* 中找到。
- en: 'When you run the program, you should get the following result:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行程序时，你应该得到以下结果：
- en: '[PRE33]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Using the shuffle function in OpenCL
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 OpenCL 中使用 shuffle 函数
- en: 'The `shuffle` and `shuffle2` functions were introduced in OpenCL 1.1 to construct
    a permutation of elements from their inputs (which are either one vector or two
    vectors), and returns a vector of the same type as its input; the number of elements
    in the returned vector is determined by the argument, `mask`, that is passed to
    it. Let''s take a look at its method signature:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`shuffle` 和 `shuffle2` 函数是在 OpenCL 1.1 中引入的，用于从它们的输入（这些输入可以是单个向量或两个向量）构建元素排列，并返回与输入相同类型的向量；返回向量的元素数量由传递给它的参数
    `mask` 决定。让我们看看它的方法签名：'
- en: '[PRE34]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `N` and `M` used in the signatures represents the length of the returned
    and input vectors and can take values from {`2`,`3`,`4`,`8`,`16`}. The `ugentype`
    represents an unsigned type, `gentype` represents the integral types in OpenCL,
    and floating-point types (that is, half, single, or double-precision) too; and
    if you choose to use the floating-point types then recall the extensions `cl_khr_fp16`
    or `cl_khr_fp64`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在签名中使用的 `N` 和 `M` 代表返回向量和输入向量的长度，可以取值 `{`2`，`3`，`4`，`8`，`16`}`。`ugentype` 代表无符号类型，`gentype`
    代表 OpenCL 中的整数类型以及浮点类型（即半精度、单精度或双精度）；如果你选择使用浮点类型，请记住扩展 `cl_khr_fp16` 或 `cl_khr_fp64`。
- en: 'Here''s an example of how it works:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个它如何工作的例子：
- en: '[PRE35]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Let's take a look at a simple implementation where we draw our inspiration from
    the popular **Fisher-Yates Shuffle**(**FYS**) algorithm. This FYS algorithm generates
    a random permutation of a finite set and the basic process is similar to randomly
    picking a numbered ticket from a container, or cards from a deck, one after another
    until none is left in the container/deck. One of the nicest properties of this
    algorithm is that it is guaranteed to produce an unbiased result. Our example
    would focus on how shuffling would work, since what it essentially does is to
    select a particular element based on a mask that's supposed to be randomly generated.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个简单的实现，我们从流行的 **Fisher-Yates Shuffle**（**FYS**）算法中汲取灵感。这个 FYS 算法生成一个有限集合的随机排列，其基本过程类似于从一个容器中随机抽取一个编号的票，或者从一副牌中抽取一张牌，依次进行，直到容器/牌堆中没有剩余的牌。这个算法最令人欣赏的特性之一是它保证产生一个无偏的结果。我们的例子将关注于如何进行洗牌，因为它本质上是根据一个应该随机生成的掩码来选择特定的元素。
- en: Getting ready
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The code snippet in `Ch4/simple_shuffle/simple_shuffle.cl` pretty much captured
    most of the ideas we are trying to illustrate. The idea is simple, we want to
    generate a mask and use the mask to generate permutations of the output array.
    We are not going to use a pseudo random number generator like the Mersenne twister,
    but rather rely on C's `stdlib.h` function, a random function with a valid seed
    from which we generate a bunch of random numbers where each number cannot exceed
    the maximum size of the array of the output array, that is, `15`.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`Ch4/simple_shuffle/simple_shuffle.cl` 中的代码片段几乎捕捉了我们试图说明的大部分想法。想法很简单，我们想要生成一个掩码，并使用该掩码生成输出数组的排列。我们不会使用梅森旋转器这样的伪随机数生成器，而是依赖于
    C 的 `stdlib.h` 函数，一个具有有效种子的随机函数，从这个函数中生成一系列随机数，其中每个数不能超过输出数组最大大小的值，即 `15`。'
- en: Note
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `rand()` function in `stdlib.h` is not really favored because it generates
    a less random sequence than `random()`, because the lower dozen bits generated
    by `rand()` go through a cyclic pattern.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`stdlib.h` 中的 `rand()` 函数并不真正受欢迎，因为它生成的随机序列比 `random()` 生成的序列要少，因为 `rand()`
    生成的低十二位数字会通过一个循环模式。'
- en: How to do it…
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Before we begin the shuffling, we need to seed the RNG prior, and we can do
    that via a simple API call to `srandom()` passing the seed. The next step is to
    run our kernel a number of times and we achieve this by enclosing the kernel execution
    in a loop. The following code snippet from the host code in `Ch4/simple_shuffle/simple_shuffle.c`
    shows this:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始洗牌之前，我们需要先对 RNG 进行初始化，这可以通过对 `srandom()` 进行简单的 API 调用并传递种子来实现。下一步是运行我们的内核多次，我们通过将内核执行封装在循环中来实现这一点。以下是从
    `Ch4/simple_shuffle/simple_shuffle.c` 中的主机代码的代码片段，展示了这一点：
- en: '[PRE36]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The following kernel code transports the inputs via *a* and *b* and their combined
    element size is `16`, the mask is being transported on the constant memory space
    (that is, read-only).
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 以下内核代码通过*a*和*b*传输输入，它们的组合元素大小为`16`，掩码正在传输到常量内存空间（即只读）。
- en: '[PRE37]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'To compile it on the OS X platform, you will have to run a compile command
    similar to this:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 要在OS X平台上编译它，你必须运行一个类似于以下命令的编译命令：
- en: '[PRE38]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Alternatively, you can type `make` in the source directory `Ch4/simple_shuffle/.`
    When that happens, you will have a binary executable named `SimpleShuffle`.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以在源目录`Ch4/simple_shuffle/.`中键入`make`。当这样做时，你将有一个名为`SimpleShuffle`的二进制可执行文件。
- en: 'To run the program on OS X, simply execute the program `SimpleShuffle` and
    you should see the output shown as follows:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 要在OS X上运行程序，只需执行名为`SimpleShuffle`的程序，你应该会看到如下所示的输出：
- en: '[PRE39]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: How it works…
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'The following diagram suggests that each executing kernel works through a portion
    of the source array, which contains of *k* elements by fetching the data from
    the `__global` memory space to the `__private` memory space. The next operation
    is to run the shuffling using a vector of random numbers, which we have pregenerated
    on the host and for each partitioned data block, the kernel will produce a resultant
    array; and once that''s done the kernel flushes out the data to the `__global`
    memory space. The following diagram illustrates the idea where the resultant array
    consists of a permutated array made from its individual constituents which are
    themselves permutations:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表表明，每个正在执行的内核通过从`__global`内存空间获取数据到`__private`内存空间的部分源数组工作，该数组包含*k*个元素。接下来的操作是使用预生成的随机数向量进行洗牌，这些随机数是在主机上预先生成的，对于每个分区数据块，内核将生成一个结果数组；一旦完成，内核将数据刷新到`__global`内存空间。以下图表说明了这个想法，其中结果数组由其单个组成部分的排列组成的排列数组：
- en: '![How it works…](img/4520OT_04_12.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作…](img/4520OT_04_12.jpg)'
- en: Using the select function in OpenCL
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在OpenCL中使用select函数
- en: 'The `select` function is first of all similar to the `shuffle` and `shuffle2`
    functions we have seen in the previous section and is also known as the **ternary
    selection**, and it is a member of the relational functions in OpenCL, which is
    commonly found in the C++ and Java programming languages; but there is a significant
    difference and that is the `select` function and its variant `bitselect` works
    not only with single-precision or double-precision floating types, but also vectors
    of single-precision or double-precision floating-point values. Here''s what it
    looks like:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`select`函数首先与我们在上一节中看到的`shuffle`和`shuffle2`函数相似，也被称为**三元选择**，并且它是OpenCL中的关系函数之一，在C++和Java编程语言中常见；但有一个显著的区别，那就是`select`函数及其变体`bitselect`不仅与单精度或双精度浮点类型一起工作，还与单精度或双精度浮点值向量一起工作。下面是它的样子：'
- en: '[PRE40]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Hence, when the predicate is evaluated to be true the expression on the left-hand
    side of the colon will be evaluated; otherwise the expression on the right-hand
    side of the colon is evaluated and in both evaluations, a result is returned.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当谓词评估为真时，冒号左侧的表达式将被评估；否则，评估冒号右侧的表达式，并且在两种评估中，都会返回一个结果。
- en: 'Using an example in OpenCL, the conditional statement as follows:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 使用OpenCL中的示例，以下条件语句：
- en: '[PRE41]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'can be rewritten using the `select()` function as:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`select()`函数重写为：
- en: '[PRE42]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: And for such a transformation to be correct, the original `if` statement cannot
    contain any code that calls to I/O.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这种转换正确，原始的`if`语句不能包含任何调用I/O的代码。
- en: The main advantage `select`/`bitselect` offers is that vendors can choose to
    eradicate branching and branch predication from its implementation, which means
    that the resultant program is likely to be more efficient. What this means is
    that these two functions act as a façade so that vendors such as AMD could implement
    the actual functionality using the ISA of SSE2 `__mm_cmpeq_pd`, and `__mm_cmpneq_pd`
    ; similarly, Intel could choose from the ISA of Intel AVX such as `__mm_cmp_pd`,
    `__mm256_cmp_pd`, or from SSE2 to implement the functionality of `select` or `bitselect`.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`select`/`bitselect`提供的主要优势是，供应商可以选择从其实施中消除分支和分支预测，这意味着生成的程序可能更高效。这意味着这两个函数充当了一个门面，使得像AMD这样的供应商可以使用SSE2的`__mm_cmpeq_pd`和`__mm_cmpneq_pd`等ISA来实现实际的功能；同样，Intel可以选择Intel
    AVX的ISA，如`__mm_cmp_pd`、`__mm256_cmp_pd`或从SSE2来实现`select`或`bitselect`的功能。'
- en: Getting ready
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The following example demonstrates how we can use the function, `select`. The
    function demonstrates the convenience that it offers since it operates on the
    abstraction of applying a function to several data values, which happens to be
    in a vector. The code snippet in `Ch4/simple_select_filter/select_filter.cl` attempts
    to conduct a selection by picking the elements from each list in turn to establish
    the result, which in this example happens to be a vector.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了我们可以如何使用 `select` 函数。该函数展示了它提供的便利性，因为它在向量的抽象上操作，将函数应用于多个数据值。`Ch4/simple_select_filter/select_filter.cl`
    中的代码片段试图通过依次从每个列表中选择元素来执行选择，以建立结果，在这个例子中结果恰好是一个向量。
- en: How to do it…
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'The following snippet demonstrates how to do use the `select` function in OpenCL:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段演示了如何在 OpenCL 中使用 `select` 函数：
- en: '[PRE43]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'To compile it on the OS X platform, you will have to run a compile command
    similar to this:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 OS X 平台上编译它，你将不得不运行一个类似的编译命令：
- en: '[PRE44]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Alternatively, you can type `make` in the source directory `Ch4/simple_select/`.
    When that happens, you will have a binary executable named `SelectFilter`.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以在源目录 `Ch4/simple_select/` 中输入 `make`。当这样做时，你将得到一个名为 `SelectFilter` 的二进制可执行文件。
- en: 'To run the program on OS X, simply execute the program `SelectFilter` and you
    should either see the output shown as follows:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 OS X 上运行程序，只需执行程序 `SelectFilter`，你应该会看到以下输出：
- en: '[PRE45]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: How it works…
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: The program proceeds to establish a context to the OpenCL compliant device through
    the APIs `clGetPlatformIDs` and `clGetDeviceIDs`. Once that is established, we
    go about creating our in-memory data structures and prepare it for submission
    to the device's command queue.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 程序继续通过 `clGetPlatformIDs` 和 `clGetDeviceIDs` API 建立到 OpenCL 兼容设备的上下文。一旦建立，我们就着手创建内存中的数据结构，并准备将其提交到设备的命令队列。
- en: The in-memory data structures on the host are small arrays, which we can submit
    to the device for consumption by sending it across the system bus to hydrate the
    structures in the device memory. They stay in the device memory as local variables
    represented by variables `in1` and `in2`.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 主机上的内存数据结构是小型数组，我们可以将其提交给设备以供消费，通过将其发送到系统总线来在设备内存中填充这些结构。它们作为局部变量 `in1` 和 `in2`
    存留在设备内存中。
- en: Once the data is inflated in the device's memory, the algorithm in `select_filter.cl`
    will proceed to select each element in turn by conducting a bit comparison where
    the most significant bit is checked; if the MSB is equal to `1` the corresponding
    value from **Buffer B** is returned; otherwise the corresponding position from
    **Buffer A** is returned. Recall from computer science that -1, that is, unary
    minus 1, works out to be `0xffff` in 2's complement notation and hence the MSB
    of that value would most definitely be equal to `1`.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦数据在设备的内存中膨胀，`select_filter.cl` 中的算法将依次通过位比较来选择每个元素，其中检查最高有效位；如果最高有效位等于 `1`，则返回
    **Buffer B** 中相应的值；否则返回 **Buffer A** 中相应的位置。从计算机科学中回忆起来，-1，即一元减 1，在二进制补码表示法中等于
    `0xffff`，因此该值的最高有效位肯定等于 `1`。
- en: The following diagram illustrates this selection process. As before, once the
    selection process is completed, it is flushed out to the results vector, result.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表说明了这个选择过程。与之前一样，一旦选择过程完成，它就会被刷新到结果向量 `result` 中。
- en: '![How it works…](img/4520OT_04_13.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理…](img/4520OT_04_13.jpg)'
