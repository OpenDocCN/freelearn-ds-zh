<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-53"><a id="_idTextAnchor053" class="pcalibre calibre6 pcalibre1"/>4</h1>
<h1 id="_idParaDest-54" class="calibre5"><a id="_idTextAnchor054" class="pcalibre calibre6 pcalibre1"/>Transportation Data</h1>
<p class="calibre3">This chapter tackles transportation logistics, which involves the movement of supplies or goods from one location to another. We’ll introduce a goods delivery problem to find the optimal routing of supplies to minimize the delivery time and cost to deliver the goods. We’ll explore shortest paths, optimal routes to visit all necessary locations, and scaling algorithms to large networks. Further, we’ll examine caveats to simple distance weightings to calculate route optimality, considering delivery hazards on routes that can influence optimality.</p>
<p class="calibre3">When you have finished this chapter, you’ll understand how to frame transportation problems as network problems and scale them to very large routing networks using Python.</p>
<p class="calibre3">Specifically, we will cover the following topics in this chapter:</p>
<ul class="calibre10">
<li class="calibre11">Introduction to transportation problems</li>
<li class="calibre11">Shortest path applications</li>
<li class="calibre11">Traveling salesman problem</li>
<li class="calibre11"><strong class="bold">Maximum flow/minimum cut</strong> (<strong class="bold">max-flow </strong><strong class="bold">min-cut</strong>) algorithm</li>
</ul>
<p class="calibre3">Let’s get started with some basic problems in transportation logistics.</p>
<h1 id="_idParaDest-55" class="calibre5"><a id="_idTextAnchor055" class="pcalibre calibre6 pcalibre1"/>Technical requirements</h1>
<p class="calibre3">You will require Jupyter Notebook to run the practical examples in this chapter. </p>
<p class="calibre3">The code for this chapter is available here: <a href="https://github.com/PacktPublishing/Modern-Graph-Theory-Algorithms-with-Python" class="pcalibre calibre6 pcalibre1">https://github.com/PacktPublishing/Modern-Graph-Theory-Algorithms-with-Python</a></p>
<h1 id="_idParaDest-56" class="calibre5"><a id="_idTextAnchor056" class="pcalibre calibre6 pcalibre1"/>Introduction to transportation problems</h1>
<p class="calibre3">Physical<a id="_idIndexMarker161" class="pcalibre calibre6 pcalibre1"/> goods and supplies are important in many industries, and the movement of goods between locations represents an important problem in industries such as consumer-packaged goods, retail, military, and manufacturing. <strong class="bold">Supply chain logistics</strong>—the science<a id="_idIndexMarker162" class="pcalibre calibre6 pcalibre1"/> of acquiring, transporting, and storing resources—influences many aspects of business in these industry sectors. Without goods to sell, a company cannot turn a profit. Without materials to manufacture goods, products cannot be made or transported to vendors.</p>
<p class="calibre3">During the <a id="_idIndexMarker163" class="pcalibre calibre6 pcalibre1"/>COVID-19 pandemic, many critical supply chain routes shut down, leaving long waits for goods in many parts of the world or facing higher prices for necessities such as food. Crises such as the Ukraine war can leave entire countries short of food, creating humanitarian crises in other areas. Many supply chain logistics problems can be formulated through the lens of network science, and graph theory offers several useful tools to plan out the best routes to stock goods or materials across locations. In this chapter, we’ll learn more about supply chain logistics and leverage tools from graph theory to plan supply routes between grocery stores.</p>
<h2 id="_idParaDest-57" class="calibre7"><a id="_idTextAnchor057" class="pcalibre calibre6 pcalibre1"/>Paths between stores</h2>
<p class="calibre3">A common supply chain logistics <a id="_idIndexMarker164" class="pcalibre calibre6 pcalibre1"/>problem retailers face is the transportation of goods across several stores in an area. For instance, consider a suburban area with five grocery stores belonging to the same chain spread out across the area, as depicted in <em class="italic">Figure 4</em><em class="italic">.1</em>:</p>
<div><div><img alt="Figure 4.1 – A metro area with five grocery stores from the same chain" src="img/B21087_04_01.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 4.1 – A metro area with five grocery stores from the same chain</p>
<p class="calibre3">The metro area of <em class="italic">Figure 4</em><em class="italic">.1</em> shows stores that are nearby (right corner) and some that are further away from each other (such as the ones on the left). Perhaps we are transporting fresh fruit and vegetables from a nearby farm to each of the five stores. Without considering streets, fuel stops, or other considerations (we’ll discuss these later in the chapter), it seems like a <a id="_idIndexMarker165" class="pcalibre calibre6 pcalibre1"/>route between stores would be easy to define. One such path is shown in <em class="italic">Figure 4</em><em class="italic">.2</em>:</p>
<div><div><img alt="Figure 4.2 – A routing plan to deliver fruit and vegetables to each of the grocery stores in the hypothetical suburban area" src="img/B21087_04_02.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 4.2 – A routing plan to deliver fruit and vegetables to each of the grocery stores in the hypothetical suburban area</p>
<p class="calibre3">Contrary to <em class="italic">Figure 4</em><em class="italic">.2</em>, in a real situation, there are likely to be many routes between stores a truck could take. Alternative streets and combinations of routes might exist. The truck may need fuel between stores, and the locations of gas stations might influence which route is ideal. Roads may be closed for construction. Afternoon thunderstorms might flood some of the streets on good routes, creating hazards that the truck needs to avoid. Some stores might be out of oranges and grapefruit, giving them priority for early deliveries so that customers can purchase these fruits.</p>
<p class="calibre3">Over larger distances, the question of transportation mode also arises. Shipping by sea or routing goods by plane might be preferable if obstacles such as oceans or mountain ranges exist between stores that need stocking. Since the world globalized, it is common for goods to travel across continents and oceans (shipping is shown in <em class="italic">Figure 4</em><em class="italic">.3</em>):</p>
<div><div><img alt="Figure 4.3 – ﻿An illustration of a cargo ship leaving port" src="img/B21087_04_03.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 4.3 – An illustration of a cargo ship leaving port</p>
<p class="calibre3">Many products <a id="_idIndexMarker166" class="pcalibre calibre6 pcalibre1"/>or parts of products used in the United States and Europe come from China, Japan, or India. Travel by sea can provide cheaper and quicker alternatives to land or air delivery. One of the key problems in supply chain logistics is balancing the needs for cost-effectiveness, <strong class="bold">time-to-delivery</strong> (<strong class="bold">TTD</strong>), and the <a id="_idIndexMarker167" class="pcalibre calibre6 pcalibre1"/>need for bulk goods movements. Let’s dive into some of these considerations in more detail.</p>
<h2 id="_idParaDest-58" class="calibre7"><a id="_idTextAnchor058" class="pcalibre calibre6 pcalibre1"/>Fuel costs</h2>
<p class="calibre3">One of the pressing<a id="_idIndexMarker168" class="pcalibre calibre6 pcalibre1"/> problems in logistics today is the optimization of a route with respect to the cost of delivery. Customers don’t want to pay high prices for delivery or wait long periods of time for goods to arrive. Since the COVID-19 shutdowns and the Ukraine war, fuel prices have increased, and some routes for goods are no longer available. This drives up costs for manufacturers, businesses that need to move goods to physical locations, and consumers buying goods from businesses.</p>
<p class="calibre3">Ground routes, particularly <a id="_idIndexMarker169" class="pcalibre calibre6 pcalibre1"/>when coupled with electric delivery vehicles (shown in <em class="italic">Figure 4</em><em class="italic">.4(a)</em>), can provide a good option for companies operating locally. However, many supply chains depend on parts or goods located overseas, and options such as shipping (shown in <em class="italic">Figure 4</em><em class="italic">.4(b)</em>) or air travel are necessary:</p>
<div><div><img alt="Figure 4.4 – ﻿An illustration of: (a) A semi-truck used to haul goods domestically and (b) a shipping option to move goods overseas" src="img/B21087_04_04.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 4.4 – An illustration of: (a) A semi-truck used to haul goods domestically and (b) a shipping option to move goods overseas</p>
<p class="calibre3">However, the cost of fuel is rarely the only consideration, as time is critical for any goods that might spoil and as safety concerns related to cargo loss often take precedence over fuel costs in real-world problems. Let’s consider some scenarios where TTD is an important consideration in the optimization algorithms used to schedule delivery times, routes, and best modes of transportation.</p>
<h2 id="_idParaDest-59" class="calibre7"><a id="_idTextAnchor059" class="pcalibre calibre6 pcalibre1"/>Time to deliver goods</h2>
<p class="calibre3">The first consideration for<a id="_idIndexMarker170" class="pcalibre calibre6 pcalibre1"/> delivery time involves the urgency factor. Goods may spoil within a certain time frame (such as produce or vaccines), and this often outweighs the cost, as the goods will not be useable outside of the necessary time-to-use period. Sales windows also merit consideration, as Christmas or Ramadan items will not be in as great a demand after the holiday passes. This results in a loss of profits for the business.</p>
<p class="calibre3">Let’s consider two <a id="_idIndexMarker171" class="pcalibre calibre6 pcalibre1"/>tourist cafés, one located in the city of Paramaribo, Suriname, and one located in rural Suriname near a nature adventure camp. The city location (shown in <em class="italic">Figure 4</em><em class="italic">.5 (a)</em>) has access to a refrigerator to store fruit used in its smoothies; the rural location (shown in <em class="italic">Figure 4</em><em class="italic">.5 (b)</em>) does not have a refrigerator. Delivery priority on a shipment of fresh fruit from a local farm might prioritize the rural location, as the fruit will spoil faster there:</p>
<div><div><img alt="Figure 4.5 – ﻿An illustration of: (a) A café in Paramaribo, Suriname and (b) a café in rural Suriname near a tourist camp" src="img/B21087_04_05.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 4.5 – An illustration of: (a) A café in Paramaribo, Suriname and (b) a café in rural Suriname near a tourist camp</p>
<p class="calibre3">Besides the problem of spoiled goods and missed promotional periods, timing factors can include barriers to delivery, such as construction or tollways on a route. In addition, time spent in customs can vary dramatically from country to country, and it may be advantageous to take a longer driving route to avoid traveling through a particular country.</p>
<p class="calibre3">Often, it is<a id="_idIndexMarker172" class="pcalibre calibre6 pcalibre1"/> necessary to mathematically weight routes not only by physical distance but by travel time, including factors such as customs or likelihood of construction.</p>
<h2 id="_idParaDest-60" class="calibre7"><a id="_idTextAnchor060" class="pcalibre calibre6 pcalibre1"/>Navigational hazards</h2>
<p class="calibre3">Navigational concerns not only<a id="_idIndexMarker173" class="pcalibre calibre6 pcalibre1"/> include man-made impediments to delivery; they also include natural ones. Hurricanes can delay shipments through busy ports, such as the Port of Miami. Avalanches in the Alps are a navigational consideration for companies opting for train transport. The shipping industry averages a loss of 10 ships per year to high seas and rogue waves. Some shipping routes, such as those off the southeast coast of South Africa, are known to produce high waves (typically as currents mix with a variety of ocean swells coming from different directions).</p>
<p class="calibre3">Hazard-weighting of paths can be wise when working with optimal travel routes and determining which mode of transportation is most cost-effective and convenient. Most areas of the world contain open source hazard data and material to determine which hazards are present and how likely one is to encounter them. For instance, the World Bank provides<a id="_idIndexMarker174" class="pcalibre calibre6 pcalibre1"/> the <strong class="bold">Climate Change Knowledge Portal</strong> (<strong class="bold">CCKP</strong>) with natural disaster risks during different periods, including downloadable data.</p>
<p class="calibre3">Now that we know some routing considerations, let’s dive into a simple example, including five stores in a localized area of Miami needing produce delivered that are all accessible via truck and defined to exclude current construction zones in a time of year when the area does not experience flooding or hurricanes. First, we’ll need to understand how we can calculate the shortest paths between vertices in a network, which has deep roots in graph theory.</p>
<h1 id="_idParaDest-61" class="calibre5"><a id="_idTextAnchor061" class="pcalibre calibre6 pcalibre1"/>Shortest path applications</h1>
<p class="calibre3">The shortest paths<a id="_idIndexMarker175" class="pcalibre calibre6 pcalibre1"/> between places and sets of places have a long history in graph theory. Originally, this problem arose from a question about traversing the seven bridges of Königsberg, Germany. In 1736, Leonhard Euler posited that a route that crossed each bridge to a region next to one side of a bridge exactly once did not exist. Indeed, this is the case. If there is one more region than the number of bridges for an odd number of bridges, a trip is possible without traversing bridges more than once. Note that the proof of this is beyond the scope of this book; if you are interested, you can find many proofs online if you search for proofs of the Königsberg bridge problem.</p>
<p class="calibre3">However, problems such as this come up often in the transportation industry and <strong class="bold">global positioning system</strong> (<strong class="bold">GPS</strong>) routing<a id="_idIndexMarker176" class="pcalibre calibre6 pcalibre1"/> solutions and algorithms that calculate shortest paths with or without specific constraints such as the Königsberg bridge problem are common in routing problems today. We often want to visit multiple locations while traversing the fewest roads, bridges, or obstacles possible, and we can formulate this problem much in the way Euler formulated his bridge problem. However, we typically have many different possible routes and locations, making proof much more difficult given alternative routes that exist.</p>
<p class="calibre3"><code>0</code> or <code>1</code> representing<a id="_idIndexMarker178" class="pcalibre calibre6 pcalibre1"/> the existence of an edge between vertices in the adjacency matrix) or weighted (where edges that exist have numbers not limited to <code>1</code> designating their existence and some property between them). In the context of shortest path calculation in geographical data, these weights usually represent distances between locations.</p>
<p class="calibre3">Many paths can exist between vertices. For instance, consider a network with seven vertices. Between vertices one and six, many possible paths exist, including the one shown in <em class="italic">Figure 4</em><em class="italic">.6</em>. However, the shortest path will always exist, minimizing the distance (physical or other, depending on how edge weights are assigned from a dataset) between any two vertices in the network. When a network is not connected, this may be undefined or set to an infinite distance:</p>
<div><div><img alt="Figure 4.6 – A network with seven vertices and a path from the first vertex to the sixth vertex" src="img/B21087_04_06.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 4.6 – A network with seven vertices and a path from the first vertex to the sixth vertex</p>
<p class="calibre3">Sometimes, the shortest <a id="_idIndexMarker179" class="pcalibre calibre6 pcalibre1"/>path between vertices (say, between one and seven in our <em class="italic">Figure 4</em><em class="italic">.6</em> network) may not be unique. Multiple paths of the same length may exist, such as the two shortest paths between vertex one and vertex seven (shown in <em class="italic">Figure 4</em><em class="italic">.7</em>):</p>
<div><div><img alt="Figure 4.7 – A network with multiple shortest paths between a pair of vertices (vertex one and vertex seven)" src="img/B21087_04_07.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 4.7 – A network with multiple shortest paths between a pair of vertices (vertex one and vertex seven)</p>
<p class="calibre3">In an undirected<a id="_idIndexMarker180" class="pcalibre calibre6 pcalibre1"/> network, all edges between vertices can be considered when finding the shortest paths between vertices. As mentioned earlier, if the network is not connected, infinite path lengths may exist. For undirected and unweighted networks, the shortest paths will traverse the fewest edges (again, with infinite values possible if there are no edge paths to connect two vertices). <em class="italic">Figure 4</em><em class="italic">.8</em> shows a network that is not connected:</p>
<div><div><img alt="Figure 4.8 – A disconnected network" src="img/B21087_04_08.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 4.8 – A disconnected network</p>
<p class="calibre3">The shortest path between vertices eight and nine is simply the edge connecting vertex eight to vertex nine. Assuming that this network is not weighted, the shortest distance from this path is one. The shortest path between vertices one and six is given by the edges connecting vertex six to vertex three and vertex three to vertex one. The shortest distance between vertex six and three is, thus, two. However, the shortest path between vertex eight and vertex six does not exist and would be designated as an infinite distance.</p>
<p class="calibre3">Dijkstra’s algorithm <a id="_idIndexMarker181" class="pcalibre calibre6 pcalibre1"/>begins at one of the paired vertices and explores the vertices to which that vertex is connected. The shortest path between that initial vertex and its neighboring vertices is then recorded, minus the initial vertex (as it is already in our path set). The next set of vertices connected to the shortest-distance neighboring vertex is then explored to find the next shortest path that exists. This iterative exploration continues until the other paired vertex is found.</p>
<p class="calibre3">Let’s consider how<a id="_idIndexMarker182" class="pcalibre calibre6 pcalibre1"/> Dijkstra’s algorithm <a id="_idIndexMarker183" class="pcalibre calibre6 pcalibre1"/>can help us find the shortest route between stores. Consider a set of five stores from the same grocery chain in one suburb that may need restocking by the parent chain’s supplier. <em class="italic">Table 4.1</em> gives a summary of the distances between these five stores in miles:</p>
<table class="no-table-style" id="table001-2">
<colgroup class="calibre12">
<col class="calibre13"/>
<col class="calibre13"/>
<col class="calibre13"/>
<col class="calibre13"/>
<col class="calibre13"/>
<col class="calibre13"/>
</colgroup>
<tbody class="calibre14">
<tr class="no-table-style1">
<td class="no-table-style2"/>
<td class="no-table-style2">
<p class="calibre3"><strong class="bold">Store 1</strong></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><strong class="bold">Store 2</strong></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><strong class="bold">Store 3</strong></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><strong class="bold">Store 4</strong></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><strong class="bold">Store 5</strong></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><strong class="bold">Store 1</strong></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><code>0</code></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><code>2</code></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><code>2.4</code></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><code>3</code></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><code>3</code></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><strong class="bold">Store 2</strong></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><code>2</code></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><code>0</code></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><code>3.7</code></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><code>1.4</code></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><code>4.3</code></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><strong class="bold">Store 3</strong></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><code>2.4</code></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><code>3.7</code></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><code>0</code></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><code>4.9</code></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><code>0.9</code></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><strong class="bold">Store 4</strong></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><code>3</code></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><code>1.4</code></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><code>4.9</code></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><code>0</code></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><code>5.4</code></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><strong class="bold">Store 5</strong></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><code>3</code></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><code>4.3</code></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><code>0.9</code></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><code>5.4</code></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><code>0</code></p>
</td>
</tr>
</tbody>
</table>
<p class="img---caption" lang="en-US" xml:lang="en-US">Table 4.1 – A table of mile distances between a chain of stores in a suburb</p>
<p class="calibre3">We can create this network of stores in <code>Script 4.1</code>:</p>
<pre class="source-code">
#import packages
import networkx as nx
#create the Stores network
STRS = nx.Graph()
STRS.add_nodes_from(["store1","store2","store3","store4","store5"])
#define weighted ebunches, which represent lists of edges
e1 = [("store1","store2",2),("store1","store3",2.4),
    ("store1","store4",3),("store1","store5",3)]
e2 = [("store2","store3",3.7),("store2","store4",1.4),
    ("store2","store5",4.3)]
e3 = [("store3","store4",4.9),("store3","store5",0.9),
    ("store4","store5",5.4)]
#add edges
STRS.add_weighted_edges_from(e1)
STRS.add_weighted_edges_from(e2)
STRS.add_weighted_edges_from(e3)
#plot
weight_labels=nx.get_edge_attributes(STRS,'weight')
pos = nx.spring_layout(STRS)
nx.draw(STRS,pos,with_labels=True,)
nx.draw_networkx_edge_labels(STRS, pos,edge_labels=weight_labels)</pre> <p class="calibre3"><code>Script 4.1</code> gives us a<a id="_idIndexMarker184" class="pcalibre calibre6 pcalibre1"/> network of our five stores with a nice plot summary showing distances between stores, as shown in <em class="italic">Figure 4</em><em class="italic">.9</em>:</p>
<div><div><img alt="Figure 4.9 – A plot of our five stores and the distances between each of them" src="img/B21087_04_09.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 4.9 – A plot of our five stores and the distances between each of them</p>
<p class="calibre3">We can now create an adjacency<a id="_idIndexMarker185" class="pcalibre calibre6 pcalibre1"/> matrix based on our network and find the shortest paths between locations by adding to <code>Script 4.1</code>. Let’s calculate the shortest distances between <strong class="bold">store 1</strong> and each other store in our chain’s locations:</p>
<pre class="source-code">
#create adjacency matrix
adj1 = nx.adjacency_matrix(STRS)
adj1.todense()
#find all shortest paths starting at Store 1
length1, path1 = nx.single_source_dijkstra(STRS,"store1")
length1</pre> <p class="calibre3">From this calculation, we derive both the shortest distance between <code>length1</code>) and the shortest routes in general (<code>path1</code>). We can see the shortest distances between <code>length1</code>. The shortest route to <strong class="bold">store 2</strong> takes two miles, while the shortest route to <strong class="bold">store 4</strong> or <strong class="bold">store 5</strong> takes three miles. <strong class="bold">store 3</strong> is 2.4 miles from <strong class="bold">store 1</strong>.</p>
<p class="calibre3">One of the major<a id="_idIndexMarker186" class="pcalibre calibre6 pcalibre1"/> drawbacks of using Dijkstra’s algorithm is that it is a blind search algorithm that needs to wander through all possible options to find the shortest paths between each possible vertex pair along the path. That takes a long time for large networks, and in practice, a modification of Dijkstra’s algorithm is needed to reduce search time.</p>
<p class="calibre3">The <strong class="bold">A* algorithm</strong> (pronounced A-star) modifies Dijkstra’s algorithm by using a heuristic function to guide the search (as opposed to visiting each vertex as in Dijkstra’s algorithm). Heuristic functions are common in search tasks, as they expedite the process and can modify the search<a id="_idIndexMarker187" class="pcalibre calibre6 pcalibre1"/> of an algorithm that has failed. The heuristic used in the A* algorithm combines the cost of the path from the starting vertex with an estimate of remaining costs to prioritize vertices closest to the final vertex. One of the main uses for the A* algorithm is to give directions to a user of GPS to find optimal routes to a destination.</p>
<p class="calibre3">In general, the A* algorithm efficiently finds shortest path candidates, particularly in large or dense networks. However, its performance depends on the heuristic used to estimate the cost of reaching a given destination by traversing the network. While Dijkstra’s algorithm is guaranteed to find the shortest path, the A* algorithm is not guaranteed to find the shortest path. On large, dense networks, however, it is not feasible to run Dijkstra’s algorithm, so A* must be used.</p>
<p class="calibre3"><em class="italic">Table 4.2</em> summarizes the differences between Dijkstra’s algorithm and the A* algorithm to guide you on <a id="_idIndexMarker188" class="pcalibre calibre6 pcalibre1"/>how and when to use each <a id="_idIndexMarker189" class="pcalibre calibre6 pcalibre1"/>algorithm for shortest path computation:</p>
<table class="no-table-style" id="table002">
<colgroup class="calibre12">
<col class="calibre13"/>
<col class="calibre13"/>
<col class="calibre13"/>
<col class="calibre13"/>
</colgroup>
<tbody class="calibre14">
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><strong class="bold">Shortest </strong><strong class="bold">path algorithm</strong></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><strong class="bold">Type </strong><strong class="bold">of search</strong></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><strong class="bold">Result guarantees</strong></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><strong class="bold">Computational speed</strong></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3">Dijkstra’s algorithm</p>
</td>
<td class="no-table-style2">
<p class="calibre3">Blind search of all vertices</p>
</td>
<td class="no-table-style2">
<p class="calibre3">Always finds the shortest path</p>
</td>
<td class="no-table-style2">
<p class="calibre3">Slow enough to limit use on dense or large networks</p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3">A* algorithm</p>
</td>
<td class="no-table-style2">
<p class="calibre3">Heuristic function guiding search</p>
</td>
<td class="no-table-style2">
<p class="calibre3">No <a id="_idIndexMarker190" class="pcalibre calibre6 pcalibre1"/>guarantees to finding<a id="_idIndexMarker191" class="pcalibre calibre6 pcalibre1"/> the shortest path</p>
</td>
<td class="no-table-style2">
<p class="calibre3">Fast enough for most problems</p>
</td>
</tr>
</tbody>
</table>
<p class="img---caption" lang="en-US" xml:lang="en-US">Table 4.2 – Difference between Dijkstra’s algorithm and the A* algorithm</p>
<p class="calibre3">Let’s consider a different<a id="_idIndexMarker192" class="pcalibre calibre6 pcalibre1"/> store network, one in which routes do not exist from each store to every other store by creating a secondary store network in NetworkX through <code>Script 4.2</code>:</p>
<pre class="source-code">
#create a different Stores network
STRS2 = nx.Graph()
STRS2.add_nodes_from(["store1","store2","store3","store4","store5"])
#define weighted ebunch
e12 = [("store1","store2",2),("store1","store4",3)]
e22 = [("store2","store3",3.7),("store2","store4",1.4)]
e32 = [("store3","store4",4.9),("store4","store5",5.4)]
#add edges
STRS2.add_weighted_edges_from(e12)
STRS2.add_weighted_edges_from(e22)
STRS2.add_weighted_edges_from(e32)
#plot
weight_labels=nx.get_edge_attributes(STRS2,'weight')
pos = nx.spring_layout(STRS2)
nx.draw(STRS2,pos,with_labels=True,)
nx.draw_networkx_edge_labels(STRS2,pos,edge_labels=weight_labels)</pre> <p class="calibre3"><em class="italic">Figure 4</em><em class="italic">.10</em> shows this new<a id="_idIndexMarker193" class="pcalibre calibre6 pcalibre1"/> store network, with some stores directly connected to each other and<a id="_idIndexMarker194" class="pcalibre calibre6 pcalibre1"/> others requiring a route past other stores. Note that <strong class="bold">store 5</strong> is the furthest store from the other stores, connected to <strong class="bold">store 4</strong> but no other stores:</p>
<div><div><img alt="Figure 4.10 – A store network where not every store is connected to another store with a passable route" src="img/B21087_04_10.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 4.10 – A store network where not every store is connected to another store with a passable route</p>
<p class="calibre3">Let’s consider a route from <strong class="bold">store 2</strong> to <strong class="bold">store 5</strong>. Several possible routes exist (<strong class="bold">store 2</strong> to <strong class="bold">store 3</strong> to <strong class="bold">store 4</strong> to <strong class="bold">store 5</strong>, <strong class="bold">store 2</strong> to <strong class="bold">store 1</strong> to <strong class="bold">store 4</strong> to <strong class="bold">store 5</strong>, and <strong class="bold">store 2</strong> to <strong class="bold">store 4</strong> to <strong class="bold">store 5</strong>). The shortest possible route may not have the fewest stops along the way if all distances are<a id="_idIndexMarker195" class="pcalibre calibre6 pcalibre1"/> relatively short. In this case, we can simply look at our network<a id="_idIndexMarker196" class="pcalibre calibre6 pcalibre1"/> and see that <strong class="bold">store 2</strong> to <strong class="bold">store 4</strong> to <strong class="bold">store 5</strong> is the shortest route. However, in very large networks, this would take a lot of time and likely involve much longer paths.</p>
<p class="calibre3">We can use the A* algorithm in NetworkX to find our shortest route by adding to <code>Script 4.2</code>:</p>
<pre class="source-code">
#find shortest path from Store 2 to Store 5
nx.astar_path(STRS2,"store2","store5", weight='weight')</pre> <p class="calibre3">As expected, the A* algorithm<a id="_idIndexMarker197" class="pcalibre calibre6 pcalibre1"/> finds the shortest path from <strong class="bold">store 2</strong> to <strong class="bold">store 4</strong> to <strong class="bold">store 5</strong>. Again, with <a id="_idIndexMarker198" class="pcalibre calibre6 pcalibre1"/>a much larger network, we’d need an algorithm such as the A* algorithm to find the shortest route quickly. Even a network of 20 stores with several connections among stores would be problematic to compute by hand from a visualization of the network. We’ve seen how algorithms can help us find the shortest paths between two specific destinations. Let’s now take a look at the shortest paths that include stops at several different vertices. This type of solution is critical to many optimal routing problems and builds on our problem of finding the shortest paths between two different destinations.</p>
<h1 id="_idParaDest-62" class="calibre5"><a id="_idTextAnchor062" class="pcalibre calibre6 pcalibre1"/>Traveling salesman problem</h1>
<p class="calibre3">A natural extension of shortest paths is the shortest possible route that stops at each location. For instance, consider a produce truck that needs to stock all five of our stores. The shortest route that will stop at each of our five stores saves time and fuel for the driver and allows produce to arrive at each store in the shortest time frame.</p>
<p class="calibre3">The <strong class="bold">traveling salesman problem</strong> seeks <a id="_idIndexMarker199" class="pcalibre calibre6 pcalibre1"/>to find the shortest route that stops at each location or the shortest route that stops at an arbitrary number of possible locations. In graph theory, this problem (and Euler’s problem) is related to cycles of a graph, which define a non-empty path that starts and ends at the same vertex.</p>
<p class="calibre3">In practice, algorithms are needed to find the shortest path, and for large problems, computational time and convergence to a solution can restrict the usage of most algorithms. NetworkX provides the <strong class="bold">Christofides algorithm</strong> as<a id="_idIndexMarker200" class="pcalibre calibre6 pcalibre1"/> a solver, which finds the shortest spanning tree (network structured like a tree with no cycles) and then matches the vertices of the tree to find minimum distances.</p>
<p class="calibre3">Let’s find a solution to the traveling salesman problem for our original five-store network with <code>Script 4.3</code>:</p>
<pre class="source-code">
#define traveling salesman algorithm and apply it to the stores's #networks
tsp = nx.approximation.traveling_salesman_problem
tsp(STRS)</pre> <p class="calibre3">This path starts at <strong class="bold">store 1</strong>, proceeds to <strong class="bold">store 3</strong> (2.4 miles), then <strong class="bold">store 5</strong> (0.9 miles), then <strong class="bold">store 4</strong> (5.4 miles), then <strong class="bold">store 2</strong> (1.4 miles), and finally back to <strong class="bold">store 1</strong> (2 miles).</p>
<p class="calibre3">Let’s see how this works on our secondary store network by adding to <code>Script 4.3</code>:</p>
<pre class="source-code">
#apply TSP algorithm to the second stores's networks
tsp(STRS2)</pre> <p class="calibre3">In this case, we need to visit <a id="_idIndexMarker201" class="pcalibre calibre6 pcalibre1"/>some stores more than once to visit each store. The solution our algorithm gives us starts at <strong class="bold">store 1</strong>, then <strong class="bold">store 4</strong> (3 miles), then <strong class="bold">store 5</strong> (5.4 miles), then <strong class="bold">store 4</strong> again (5.4 miles), then <strong class="bold">store 2</strong> (1.4 miles), then <strong class="bold">store 3</strong> (3.7 miles), then back to <strong class="bold">store 2</strong> (3.7 miles), and finally back to <strong class="bold">store 1</strong> (2 miles). This is a much longer route than we need in our original store network (12.1 miles versus 22.6 miles), owing to non-direct paths between many of the stores.</p>
<p class="calibre3">In this section, we reviewed a solution to the traveling salesman problem, where we have a set of vertices that we need to visit and want to find the most efficient way to visit all of them. In the next section, we’ll switch from examining shortest path problems and looking at partitioning vertices to maximize travel between vertices in each set (such as maximizing rush-hour traffic flow while shutting down a few routes for maintenance).</p>
<h1 id="_idParaDest-63" class="calibre5"><a id="_idTextAnchor063" class="pcalibre calibre6 pcalibre1"/>Max-flow min-cut algorithm</h1>
<p class="calibre3">Aside from shortest paths and<a id="_idIndexMarker202" class="pcalibre calibre6 pcalibre1"/> routes, transportation logistics sometimes involve city planning to plan, say, roadwork with the least interruption to traffic patterns or supply chains. The goal is to maximize traffic flow through points of interest (say, major intersections or buildings with high volumes of visitors/workers each day) while minimizing which routes are cut off.</p>
<p class="calibre3">In graph theory, the max-flow min-cut algorithm seeks to partition a network to maximize the flow of information through a social network, the flow of traffic in a transportation network, or the flow of material through an electrical or water pipeline network, among others. Typically, there’s a starting vertex and an ending vertex with respect to flow, though it is possible to run the algorithm through all possible combinations and aggregate results to maximize flow for the entire network.</p>
<p class="calibre3">Let’s consider the example of traffic flow from a dense residential area outside of a city to the downtown area, where most people work. We’d like to plan out work on replacing stoplights at key intersections throughout the city, which are divided by canals. Some roads in the city have more lanes than others, allowing for a higher volume of traffic to utilize those routes. We’d like to minimize disruption to commuters during the workday.</p>
<p class="calibre3">We can create a <a id="_idIndexMarker203" class="pcalibre calibre6 pcalibre1"/>network of this situation, with the residential area designated as vertex <code>"a"</code> and the downtown area as vertex <code>"g"</code>. We’ll designate the level of traffic the route can handle with the capacity parameter. Let’s build an example network in NetworkX with <code>Script 4.4</code>:</p>
<pre class="source-code">
#build the city intersection network
G1=nx.DiGraph()
G1.add_edge("a", "b", capacity=2.0)
G1.add_edge("a", "d", capacity=0.5)
G1.add_edge("b", "d", capacity=3.0)
G1.add_edge("c", "d", capacity=2.5)
G1.add_edge("c", "e", capacity=1.0)
G1.add_edge("e", "f", capacity=4.0)
G1.add_edge("f", "g", capacity=1.0)
#plot network
capacity_labels=nx.get_edge_attributes(G1,'capacity')
pos = nx.spring_layout(G1)
nx.draw(G1,pos,with_labels=True,)
nx.draw_networkx_edge_labels(G1,pos,edge_labels=capacity_labels)</pre> <p class="calibre3">This script should<a id="_idIndexMarker204" class="pcalibre calibre6 pcalibre1"/> produce a network that looks like the one in <em class="italic">Figure 4</em><em class="italic">.11</em>:</p>
<div><div><img alt="Figure 4.11 – A plot of the traffic network" src="img/B21087_04_11.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 4.11 – A plot of the traffic network</p>
<p class="calibre3">Now that we have our network, let’s apply our max-flow min-cut algorithm and find where we can replace our first traffic light by adding to <code>Script 4.4</code>:</p>
<pre class="source-code">
#find cut-points
partition = nx.minimum_cut(G1, "a", "g")
print(partition)</pre> <p class="calibre3">Our partition suggests <a id="_idIndexMarker205" class="pcalibre calibre6 pcalibre1"/>that our best option cuts the connection between intersections <code>"c"</code> and <code>"d"</code>. Some commuters may be disadvantaged, but this preserves movement for the largest number of commuters overall.</p>
<h1 id="_idParaDest-64" class="calibre5"><a id="_idTextAnchor064" class="pcalibre calibre6 pcalibre1"/>Summary</h1>
<p class="calibre3">In this chapter, we explored transportation problems and routing problems, which come up often in real-world industries. We found the shortest paths between stores with the Dijkstra and A* algorithms on two example store networks. We then considered the traveling salesman problem for optimal route planning on our two store networks to see how connectivity impacts route length. Finally, we considered optimal cuts to maximize flow on a small city network. In the next chapter, we’ll tackle clustering on networks by examining ecological data.</p>
<h1 id="_idParaDest-65" class="calibre5"><a id="_idTextAnchor065" class="pcalibre calibre6 pcalibre1"/>References</h1>
<p class="calibre3">Chen, L., Kyng, R., Liu, Y. P., Peng, R., Gutenberg, M. P., &amp; Sachdeva, S. (2022, October). Maximum flow and minimum-cost flow in almost linear time. <em class="italic">In 2022 IEEE 63rd Annual Symposium on Foundations of Computer Science (FOCS) (pp. </em><em class="italic">612-623). IEEE.</em></p>
<p class="calibre3">Johnson, D. B. (1973). A note on Dijkstra’s shortest path algorithm. <em class="italic">Journal of the ACM (JACM), </em><em class="italic">20(3), 385-388.</em></p>
<p class="calibre3">Kang, N. K., Son, H. J., &amp; Lee, S. H. (2018). Modified A-star algorithm for modular plant land transportation. <em class="italic">Journal of Mechanical Science and Technology, </em><em class="italic">32, 5563-5571.</em></p>
<p class="calibre3">Little, J. D., Murty, K. G., Sweeney, D. W., &amp; Karel, C. (1963). An algorithm for the traveling salesman problem. <em class="italic">Operations research, </em><em class="italic">11(6), 972-989.</em></p>
<p class="calibre3">Liu, S., Münch, F., &amp; Peyerimhoff, N. (2018). Bakry–Émery curvature and diameter bounds on graphs. <em class="italic">Calculus of Variations and Partial Differential Equations, </em><em class="italic">57, 1-9.</em></p>
<p class="calibre3">Rondinelli, D., &amp; Berry, M. (2000). Multimodal transportation, logistics, and the environment: managing interactions in a global economy. <em class="italic">European Management Journal, </em><em class="italic">18(4), 398-410.</em></p>
<p class="calibre3">Rosenthal, W., &amp; Lehner, S. (2008). <em class="italic">Rogue waves: Results of the </em><em class="italic">MaxWave project.</em></p>
</div>
</body></html>