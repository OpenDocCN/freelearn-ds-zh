<html><head></head><body>
		<div><h1 id="_idParaDest-246"><em class="italic"><a id="_idTextAnchor246"/>Chapter 9</em>: Grover's Search Algorithm </h1>
			<p>In this chapter, we will take a look at a fairly well-known quantum algorithm: <strong class="bold">Grover's search algorithm</strong>. We will learn how to code it by building our own circuits for the following<a id="_idIndexMarker709"/> variations: a 2-qubit version, a 3-qubit version, and a 4- and more qubit version, to see how the complexity of the circuit grows with the number of qubits. </p>
			<p>We will run our algorithm both on a local simulator and on an IBM Quantum® backend and will see how the algorithm works pretty well on the relatively short circuit that is required for a 2-qubit Grover, but not as well on the much larger circuits that are required for more qubits. The number of gates in your circuit gets successively larger, and the various errors that we explored in <a href="B14436_08_Final_PG_ePub.xhtml#_idTextAnchor220"><em class="italic">Chapter 8</em></a>, <em class="italic">Cleaning Up Your Quantum Act with Ignis</em>, start to dominate. </p>
			<p>In this chapter, we will cover the following recipes:</p>
			<ul>
				<li>Exploring quantum phase kickback</li>
				<li>A quick interlude on classical search</li>
				<li>Building Grover's search algorithm</li>
				<li>Searching with a 3-qubit Grover</li>
				<li>Adding more qubits to the Grover search </li>
				<li>Using the Grover circuit in your own code</li>
			</ul>
			<h1 id="_idParaDest-247"><a id="_idTextAnchor247"/>Technical requirements</h1>
			<p>The quantum programs that we will discuss in this chapter can be found here: <a href="https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/tree/master/Chapter09">https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/tree/master/Chapter09</a>.</p>
			<p>Much like we did in <a href="B14436_06_Final_PG_ePub.xhtml#_idTextAnchor156"><em class="italic">Chapter 6</em></a>, <em class="italic">Understanding the Qiskit® Gate Library</em>, we will create one main Python file to contain the more complex functions that we will use: <code>ch9_grover_functions.py</code>.</p>
			<p>Among other functions, this program includes a set of core functions that are used to build the Grover algorithm:<a id="_idTextAnchor248"/><a id="_idTextAnchor249"/></p>
			<ul>
				<li><code>create_oracle()</code>: This function builds a 2-5-qubit Oracle for the correct solution.</li>
				<li><code>create_amplifier()</code>: This function builds the phase amplification part of your Grover circuit.</li>
				<li><code>create_grover()</code>: This function puts the pieces together and returns a functioning Grover circuit that you can run on a simulator or on a real quantum computer.</li>
			</ul>
			<p>We will discuss these further in the <em class="italic">Building the Grover search algorithm</em> recipe. Suffice to say that these main functions are all that is required to build the Grover algorithm, and the rest of the components in the program are there to assist in visualizing the process.</p>
			<p>The other functions that are included in the <code>ch9_grover_functions.py</code> file are as follows:</p>
			<ul>
				<li><code>print_psi()</code>: This function prints out a nicely formatted statevector for your circuits.</li>
				<li><code>get_psi()</code>: This function returns the statevector for your circuit, and also displays it as a Q-sphere, Bloch sphere, or plain vector.</li>
				<li><code>print_unitary()</code>: This function prints out the unitary matrix for your circuit. For this chapter, where we expect no imaginary components of the unitary; we simplify things a bit and only print out the real values and use the BasicAer <code>unitary_simulator</code> to create the unitary.</li>
				<li><code>display_circuit()</code>: This function displays the circuit, and optionally a Q-sphere view of the circuit statevector and the unitary matrix of the circuit.</li>
			</ul>
			<p>Finally, we have a set of functions that we use to run our circuits on simulators, quantum computers, and transpilers:</p>
			<ul>
				<li><code>run_grover()</code>: Included for completeness, a function that runs your Grover circuit on a simulator or on an IBM Quantum® backend.</li>
				<li><code>mitigated_results()</code>: Revisiting the previous chapter, <a href="B14436_08_Final_PG_ePub.xhtml#_idTextAnchor220"><em class="italic">Chapter 8</em></a>, <em class="italic">Cleaning Up Your Quantum Act with Ignis</em>, we use this function to run error mitigation on our 2-qubit Grover. As we will see, running error mitigation on the 3- and 4+-qubit circuits will not produce any better results.</li>
				<li><code>transpile_circuit()</code>: To provide insight, we bring back the transpile functionality that we used in the <em class="italic">What your quantum circuit really looks like</em> recipe of <a href="B14436_06_Final_PG_ePub.xhtml#_idTextAnchor156"><em class="italic">Chapter 6</em></a>, <em class="italic">Understanding the Qiskit® Gate Library</em>.</li>
			</ul>
			<p>But before we dive into the algorithm, we will start by taking a look at one of the building blocks for many quantum algorithms (Grover included)—so-called <strong class="bold">phase kickback</strong>.</p>
			<h1 id="_idParaDest-248"><a id="_idTextAnchor250"/>Exploring quantum phase kickback</h1>
			<p>In this first recipe, we <a id="_idIndexMarker710"/>will take a closer look at a staple component of many quantum algorithms, quantum phase kickback, which is used to let one or more qubits pick up the phase angle of a second qubit without changing that second qubit. In the <em class="italic">Building the Grover algorithm</em> recipe, we will use phase kickback to identify the correct solution for our search and to amplify the probability of measuring that solution.</p>
			<p>This recipe will require a little bit of math to explain some pretty unintuitive aspects of the process and results, but we'll walk through it. It is a really good starting point for the mind-blowing aspects of quantum algorithms.</p>
			<h2 id="_idParaDest-249"><a id="_idTextAnchor251"/>Getting ready</h2>
			<p>The sample code for this recipe can be found here: <a href="https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter09/ch9_r1_kickback.py">https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter09/ch9_r1_kickback.py</a>.</p>
			<p>The recipe in itself is pretty simple and consists of a set of steps that will walk you through the phase kickback process, first on one, then two qubits.</p>
			<p>With each step, we will use the <code>display_circuit()</code> function from <code>ch9_grover_functions.py</code> to display what happens to the qubits, so let's start by taking a look at that function:</p>
			<pre>def display_circuit(circuit,psi,unitary):
    disp=True
    if disp:
        display(circuit.draw(output="mpl"))
        if psi:
            get_psi(circuit,"Q")
        if unitary:
            print_unitary(circuit)</pre>
			<p>The <code>display_circuit()</code> function is<a id="_idIndexMarker711"/> the main visualization function of the collection and takes a quantum <code>circuit</code> and two logical arguments as input. If <code>psi=True</code>, we will call the <code>get_psi()</code> function, which displays the circuit as a Q-sphere and calls the <code>print_psi()</code> function to print a nice version of the resulting circuit statevector. If <code>unitary=True</code>, then it calls the <code>print_unitary()</code> function to display the unitary matrix of the circuit.</p>
			<p>In this recipe, we set <code>unitary=False</code> and focus on the statevector visualization.</p>
			<h2 id="_idParaDest-250"><a id="_idTextAnchor252"/>How to do it...</h2>
			<p>Let's explore how to add phases to qubits:</p>
			<ol>
				<li>We start by importing the required classes and methods and the <code>display_circuit()</code> function, which will let us display what we are doing:<pre>from qiskit import QuantumCircuit
from ch9_grover_functions import display_circuit</pre></li>
				<li>Now, let's create a single qubit initialized to state <img alt="" src="img/Formula_06_047.png"/>:<pre>qc1 = QuantumCircuit(1)
display_circuit(qc1,True,False)</pre><p>The <code>display_circuit()</code> function shows us the Q-sphere visualization of our qubit <a id="_idIndexMarker712"/>initialized to state <img alt="" src="img/Formula_09_001.png"/> :</p><p class="figure-caption"> </p><div><img alt="Figure 9.1 – Single qubit set to &#13;&#10;" src="img/Figure__9.1_B14436.jpg"/></div><p class="figure-caption">Figure 9.1 – Single qubit set to <img alt="" src="img/Formula_09_003.png"/></p><p>Let's take a look at the underlying math, as we discussed in <a href="B14436_02_Final_PG_ePub.xhtml#_idTextAnchor045"><em class="italic">Chapter 2</em></a>, <em class="italic">Quantum Computing and Qubits with Python</em>. What we have done here is create a statevector that can be displayed like this:</p><div><img alt="" src="img/Formula_09_004.jpg"/></div><p>Or described in the form of the angles <img alt="" src="img/Formula_09_112.png"/> and <img alt="" src="img/Formula_09_113.png"/>:</p><div><img alt="" src="img/Formula_09_005.jpg"/></div><p>For our qubit, initiated to <img alt="" src="img/Formula_09_006.png"/> , the statevector resolves to the following: </p><div><img alt="" src="img/Formula_09_007.jpg"/></div></li>
				<li>Set the qubit in<a id="_idIndexMarker713"/> superposition:<pre>qc1.h(0)
display_circuit(qc1,True,False)</pre><p>With the qubit in superposition, the Q-sphere shows that there is an equal probability of getting <img alt="" src="img/Formula_06_0221.png"/> and <img alt="" src="img/Formula_06_139.png"/>:</p><div><img alt="Figure 9.2 – Single qubit in superposition&#13;&#10;" src="img/Figure__9.2_B14436.jpg"/></div><p class="figure-caption">Figure 9.2 – Single qubit in superposition</p><p>For a qubit in superposition, with <img alt="" src="img/Formula_09_010.png"/>, which is what we will work with here, the formula from the previous step translates into the following:</p><div><img alt="" src="img/Formula_09_011.jpg"/></div><p>This means that we describe the relative phase of the qubit by the angle <img alt="" src="img/Formula_09_012.png"/> then <img alt="" src="img/Formula_09_013.png"/> and the phase of the qubit is the opposite of the phase when <img alt="" src="img/Formula_09_014.png"/><img alt="" src="img/Formula_09_018.png"/>, in which case, <img alt="" src="img/Formula_09_114.png"/> = 1. As you can see from the equation, the phase angle only affects the <img alt="" src="img/Formula_06_056.png"/> part of the qubit. This will be important in the next step.</p></li>
				<li>Now, let's add a phase<a id="_idIndexMarker714"/> to the second qubit using the Z gate.<p>From here on, I will not show the <code>display_circuit(qc1,True,False)</code> code; just assume it is included after each step to show the progress:</p><pre>qc1.z(0)</pre><p>Remember that the Q-sphere represents the end states of the qubit, the size of the vector tip represents the relative probability of measuring the corresponding outcome, and the color represents the relative phase of the outcome.</p><p>When you measure the qubit, the phase has no impact, only the probabilities. Here you can see that state <img alt="" src="img/Formula_06_001.png"/> with phase angle 0 has a 50% probability of giving the result 0, and state <img alt="" src="img/Formula_06_056.png"/> with phase angle <img alt="" src="img/Formula_09_0181.png"/> also a 50% chance of giving the result 1:</p><div><img alt="Figure 9.3 – A single qubit in superposition with phase angle &#13;&#10;" src="img/Figure__9.3_B14436.jpg"/></div><p class="figure-caption">Figure 9.3 – A single qubit in superposition with phase angle <img alt="" src="img/Formula_09_018.png"/></p><p>In this recipe, we will be<a id="_idIndexMarker715"/> using the <em class="italic">Z gate</em>, which is also <a id="_idIndexMarker716"/>called the <strong class="bold">phase gate</strong>, to add the phase <img alt="" src="img/Formula_09_0182.png"/> to the <img alt="" src="img/Formula_09_019.png"/> state:</p><div><img alt="" src="img/Formula_09_020.jpg"/></div><p>Expressed with the preceding statevector nomenclature, this transformation looks like this:</p><p>Qubit in superposition with phase 0 (or with phase 2<img alt="" src="img/Formula_09_018.png"/>):</p><div><img alt="" src="img/Formula_09_021.jpg"/></div><p>Qubit in superposition with phase <img alt="" src="img/Formula_09_0182.png"/> (after passing through a Z gate):</p><div><img alt="" src="img/Formula_09_023.jpg"/></div><p>Notice how the + sign in front of <img alt="" src="img/Formula_06_002.png"/> changes to -, signifying the state flip. </p></li>
				<li>Now let's go through the same steps for 2 qubits, adding the phase <img alt="" src="img/Formula_008_037.png"/> to each:<pre>qc = QuantumCircuit(2)
qc.h([0,1])
qc.z(1)
qc.z(0)</pre><p>Skipping the intermediate steps, the end result of the preceding code when printed using the<a id="_idIndexMarker717"/> two psi functions is the following:</p><div><img alt="Figure 9.4 – Two qubits in superposition, both with phase angle " src="img/Figure__9.4_B14436.jpg"/></div><p class="figure-caption">Figure 9.4 – Two qubits in superposition, both with phase angle <img alt="" src="img/Formula_09_018.png"/></p><p>For two qubits in superposition, what feels somewhat intuitive for the preceding single-qubit example gets a little muddled, so let's do it step by step. </p><p>Like in the 1-qubit example, each qubit can be described like this:</p><div><img alt="" src="img/Formula_09_026.jpg"/></div><p>Setting the qubits up in a superposition, they can be written out like this:</p><div><img alt="" src="img/Formula_09_027.jpg"/></div><p>In our simplified superpositioned view, this resolves into the following expression:</p><p><img alt="" src="img/Formula_09_028.png"/> and <img alt="" src="img/Formula_09_029.png"/> </p><div><img alt="" src="img/Formula_09_030.jpg"/></div><p>And for two qubits, the phase shift transformation is done as in the following steps:</p><p>First, two qubits in <a id="_idIndexMarker718"/>superposition with 0 (or indeed <img alt="" src="img/Formula_09_031.png"/>) phase angle <img alt="" src="img/Formula_09_032.png"/>:</p><div><img alt="" src="img/Formula_09_033.jpg"/></div><p>Then, 2 qubits in superposition with the second (<img alt="" src="img/Formula_09_034.png"/>) having phase angle <img alt="" src="img/Formula_09_035.png"/>:</p><div><img alt="" src="img/Formula_09_036.jpg"/></div><p>Finally, 2 qubits in superposition with both having phase angle <img alt="" src="img/Formula_09_037.png"/></p><div><img alt="" src="img/Formula_09_038.jpg"/></div><p>This last example represents the final outcome of the preceding sample code. The Q-sphere has four equally probable outcomes, with two of them <strong class="bold">tagged</strong> with the phase <img alt="" src="img/Formula_008_037.png"/>, namely <img alt="" src="img/Formula_09_040.png"/> and <img alt="" src="img/Formula_09_041.png"/>. </p><p>This makes sense if you remember that only the <img alt="" src="img/Formula_06_002.png"/> state includes the phase parameter, and that if both qubits have the phase <img alt="" src="img/Formula_008_024.png"/>, the exponential sum for the combination is <img alt="" src="img/Formula_09_044.png"/>, which results in no phase for <img alt="" src="img/Formula_09_045.png"/>. Remember this result. It will appear in the next step.</p></li>
				<li>Entangle a qubit <a id="_idIndexMarker719"/>with a phase angle.<p>So far, this is math, and as you saw in the first recipe, this is what Qiskit® will build for you. You can change the phase of one qubit without touching the other. The real interesting part comes when you entangle the qubits using a CX gate, from qubit 0 to qubit 1: </p><div><img alt="Figure 9.5 – CX (Controlled-NOT) gate from 0 to 1&#13;&#10;" src="img/Figure__9.5_B14436.jpg"/></div><p class="figure-caption">Figure 9.5 – CX (Controlled-NOT) gate from 0 to 1</p><p>The unitary matrix version of that gate is as follows:</p><div><img alt="" src="img/Formula_09_046.jpg"/></div><p>For two qubits, each in superposition, the outcome is not that exciting; you end up with what you started with:</p><div><img alt="" src="img/Formula_09_047.jpg"/></div><p>But now add a phase shift of <img alt="" src="img/Formula_09_0182.png"/> to the controlled qubit 1, <img alt="" src="img/Formula_09_049.png"/> from <a id="_idIndexMarker720"/>the preceding and do the calculation again:</p><div><img alt="" src="img/Formula_09_050.jpg"/></div></li>
				<li>This is how it is done in the sample code: <pre>qc = QuantumCircuit(2)
qc.h([0,1])
qc.z(1)
qc.cx(0,1)</pre><p>Again, we are skipping the intermediate steps and focusing on the end result. Do step through them and compare them to the preceding calculations:</p></li>
			</ol>
			<div><div><img alt="Figure 9.6 – Two entangled qubits with the same  phase, using phase kickback&#13;&#10;" src="img/Figure__9.6_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.6 – Two entangled qubits with the same <img alt="" src="img/Formula_09_018.png"/> phase, using phase kickback</p>
			<p>Take a look at that result. It is pretty astounding!</p>
			<p>Let me explain: we started out with two qubits in superposition, one of them with a phase angle <img alt="" src="img/Formula_008_040.png"/>. Then <a id="_idIndexMarker721"/>we entangled the qubits, using the qubit with no phase angle as the controlling qubit, and the qubit with a phase angle being the controlled qubit. What we ended up with is the following:</p>
			<div><div><img alt="" src="img/Formula_09_052.jpg"/>
				</div>
			</div>
			<p>Two qubits in superposition, both having phase angle <img alt="" src="img/Formula_008_040.png"/>, just like the example that we manually built before.</p>
			<p>This is called phase kickback and is a common trick used in quantum algorithms. In the remaining recipes of this chapter, we will look at the Grover algorithm, which uses phase kickback to tag a correct solution of a problem with a phase to set it apart from incorrect solutions.</p>
			<p>For 2-qubit Grover, we will use the CX gate (controlled-NOT) to achieve this, for 3-qubit Grover, the <a id="_idIndexMarker722"/>CCX (controlled-controlled NOT), and finally for 4 qubits, the CCCX gate (controlled-controlled-controlled-NOT).</p>
			<h1 id="_idParaDest-251"><a id="_idTextAnchor253"/>A quick interlude on classical search</h1>
			<p>Before we hit the Grover <a id="_idIndexMarker723"/>algorithm, let's just take a quick peek at a standard, classical linear search algorithm. For a classical algorithm that searches an unordered database, the average number of times you have to look for a given entry is of the order of <img alt="" src="img/Formula_09_054.png"/> where <strong class="bold">N</strong> is the number of items in the database. For example, if your unordered database has four items, you will generally have to look an average of two times to find your item.</p>
			<h2 id="_idParaDest-252"><a id="_idTextAnchor254"/>Getting ready</h2>
			<p>The sample code for this recipe can be found here: <a href="https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter09/ch9_r2_classic_search.py">https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter09/ch9_r2_classic_search.py</a>.</p>
			<h2 id="_idParaDest-253"><a id="_idTextAnchor255"/>How to do it…</h2>
			<p>Let's search for a specific two-bit entry in a small database with four items:</p>
			<ol>
				<li value="1">First, we need to enter the two-bit string that we are searching for, and then the number of searches to try to get some statistics:<pre>Searching in a scrambled database with 4 entries:
 ('00', '01', '10', '11')
Enter a two bit string for the two qubit state to search for, such as '10' ('Exit' to stop):
10
Number of searches to test:
20</pre><p>The two-bit format here will be reused in the Grover recipes of this chapter and will then symbolize the statevector of two qubits, for example, <img alt="" src="img/Formula_09_055.png"/>. We will also use 3- and 4-bit entries for the corresponding number of qubits.</p></li>
				<li>The script now scrambles the initial database and runs the search function:<pre>for m in range(searches):
    database=random.sample(values,len(values))
    result=simple_search(database, oracle)
    average.append(result+1)
    search.append(m+1)</pre><p>The <code>simple_search()</code> function <a id="_idIndexMarker724"/>takes a database list as input, and then walks through it until it finds the entry that we are searching for. The position of the item is returned, and is shunted as the number of searches in the <code>search</code> variable:</p><pre>def simple_search(database, oracle):
    for position, post in enumerate(database):
        if post == oracle:
            return position</pre></li>
				<li>And finally, the collected statistics are displayed using the <code>plot_results()</code> function:<pre>def plot_results(average,search,values):
    import matplotlib.pyplot as plt
    from statistics import mean 
    print("Average searches to find:", mean(average))
    # Plot the search data
    plt.bar(search, average, align='center', alpha=0.5)
    plt.ylabel('Searches')
    plt.title(str(mean(average))+' average searches\nto         find one item among '+str(len(values)))
    plt.axhline(mean(average))
    plt.show()</pre><p>The preceding code <a id="_idIndexMarker725"/>should create something similar to this:</p></li>
			</ol>
			<div><div><img alt="Figure 9.7 – Typical outcome of a classical linear search among four unsorted items&#13;&#10;" src="img/Figure__9.7_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.7 – Typical outcome of a classical linear search among four unsorted items</p>
			<p>This small search example illustrates one classical algorithm that can be used to find a single item in a database. In this example, we have statistically shown that finding a single entry in an unordered database of four items takes in the order of <em class="italic">two searches</em> to achieve, which matches the prediction of <em class="italic">N/2 searches</em>.</p>
			<p>If you add random items to the database, then you can convince yourself that this is true for databases of 8 and 16 items as well, which corresponds to 3- and 4-bit search strings.</p>
			<p>In <em class="italic">The Grover search algorithm</em> recipe, we will see how we can use the Grover quantum algorithm to find the item in the order of <img alt="" src="img/Formula_09_056.png"/> searches. That is a quadratic speedup. Not much difference in a four-item database, but if your database contains hundreds of thousands <a id="_idIndexMarker726"/>or even millions of items, it makes a difference.  </p>
			<h1 id="_idParaDest-254"><a id="_idTextAnchor256"/>Building Grover's search algorithm</h1>
			<p>Let's take our first bite<a id="_idIndexMarker727"/> into Grover's search algorithm, one of the more straightforward quantum algorithms for solving an actual problem using quantum computing, namely finding information in an indexed but unsorted database. As we discussed in <em class="italic">A quick interlude on classical search</em>, Grover is expected to be quadratically faster than its classical counterpart.</p>
			<p>In Qiskit Terra, we can create an implementation of Grover that uses a phase-kickback oracle combined with another <a id="_idIndexMarker728"/>neat trick: <strong class="bold">phase amplification</strong>. Phase amplification increases the amplitude of the correct phase-shifted answer and thereby increases the probability of that outcome when you measure your circuit.</p>
			<p>First, we create <a id="_idIndexMarker729"/>a so-called <strong class="bold">oracle function</strong>, which is designed to take as input a set of qubits in initial superposition and switch the phase of the correct answer by <img alt="" src="img/Formula_09_057.png"/>, while leaving the phase of the incorrect answers alone. The oracle circuit is what is<a id="_idIndexMarker730"/> called a <strong class="bold">black box</strong>, which is coded to identify an answer from a set of inputs.</p>
			<p>In our example, we explicitly code the oracle to identify a specific answer, which feels like cheating. If we already know the answer, what is the point of running the Grover algorithm to find it? In our simple example, this is true, but an oracle black box might be any type of function in a hybrid classical/quantum computing program.</p>
			<p>You can see it this way: an oracle can identify the correct answer if that answer exists in the input that you feed it; it cannot calculate the correct answer.</p>
			<p>The oracle unitary matrix is essentially an identity matrix, with a single negative entry that represents the solution and will switch the phase for the corresponding state. This unitary matrix can be realized using standard gates in a quantum circuit.</p>
			<p>In this recipe, we will build the Grover circuit for two qubits. For each step, we will display what we are doing using the Q-sphere and the statevector of the circuit. For the two vital components—the oracle and the amplifier—we also display the unitary matrixes that they represent.</p>
			<h2 id="_idParaDest-255"><a id="_idTextAnchor257"/>Getting ready</h2>
			<p>The sample code for this recipe can be found here: <a href="https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter09/ch9_r3_grover_main.py">https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter09/ch9_r3_grover_main.py</a>.</p>
			<p>The script, in turn, uses three steps to create the Grover circuit. Let's go over them one by one, with our initial example for a two-qubit Grover circuit in the next subsections. The basic features of the circuit <a id="_idIndexMarker731"/>that we are implementing here are the same as you add more qubits.</p>
			<p>The sample code for building the Oracle, the amplifier circuit, and the final Grover circuit can be found here: <a href="https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter09/ch9_grover_functions.py">https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter09/ch9_grover_functions.py</a>.</p>
			<h4>Creating the oracle circuit</h4>
			<p>The first component<a id="_idIndexMarker732"/> that we need is the oracle. One simple way of <a id="_idIndexMarker733"/>building an oracle to tag a correct answer with a phase shift is to use a phase kickback circuit like the one we built in the <em class="italic">Exploring quantum phase kickback </em>recipe.</p>
			<p>As an example, let's set up a phase kickback oracle circuit that kicks back the phase for a specific outcome, such as <img alt="" src="img/Formula_09_055.png"/>. This means that the possible statevector <img alt="" src="img/Formula_09_055.png"/> will be phase-shifted <img alt="" src="img/Formula_008_024.png"/> relative to all the other possible statevectors, in this case, <img alt="" src="img/Formula_09_060.png"/>.</p>
			<p>This is what the oracle circuit looks like when printed out from Qiskit®: </p>
			<div><div><img alt="Figure 9.8 – A phase kickback oracle circuit and corresponding unitary matrix for the correct result &#13;&#10;" src="img/Figure__9.8_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.8 – A phase kickback oracle circuit and corresponding unitary matrix for the correct result <img alt="" src="img/Formula_09_055.png"/></p>
			<p>How does this<a id="_idIndexMarker734"/> work? Let's <a id="_idIndexMarker735"/>walk through what each part of the circuit does:</p>
			<ol>
				<li value="1">On the first controlling qubit, we add an X gate to make sure that <img alt="" src="img/Formula_09_061.png"/> on that qubit gets flipped to <img alt="" src="img/Formula_09_062.png"/>, so that it triggers the CX gate.</li>
				<li>On the second qubit, we first add an H gate.<p>What does this one do? In this case, we want to add a phase to the second qubit, so that we can then use the CX gate to kick back to the first qubit. Here, if the second qubit is an incorrect <img alt="" src="img/Formula_09_063.png"/>, applying the H gate gives us a superposition <img alt="" src="img/Formula_09_064.png"/> with phase 0. There is nothing to kick back, and the solution is not tagged. However, if the second qubit is a correct <img alt="" src="img/Formula_09_065.png"/>, the H gate gives us <img alt="" src="img/Formula_09_066.png"/>, which has a phase of <img alt="" src="img/Formula_008_037.png"/>, which is then promptly tagged to the solution by the CX gate.</p></li>
				<li>Finally, after the CX gate, we then add another X gate to flip the first qubit back to its initial state, and another H gate for the second qubit to do the same.</li>
			</ol>
			<p>What we have achieved is tagging the statevector for the oracle answer <img alt="" src="img/Formula_09_068.png"/> with a phase shift of <img alt="" src="img/Formula_008_037.png"/>. Only that combination will get the phase shift; no other combination will.</p>
			<p>Perhaps this is easier <a id="_idIndexMarker736"/>to see in the displayed unitary matrix, where all solutions except for the correct one are <a id="_idIndexMarker737"/>represented by a 1 in the diagonal, whereas the correct solution (<img alt="" src="img/Formula_09_070.png"/>) is represented by -1, which results in a phase shift in the resulting statevector.</p>
			<p>And this is how we do it in our Python sample:</p>
			<pre>def create_oracle(oracle_type,size):
    from qiskit import QuantumCircuit, ClassicalRegister,        QuantumRegister
    global qr, cr
    qr = QuantumRegister(size)
    cr = ClassicalRegister(size)
    oracleCircuit=QuantumCircuit(qr,cr)
    oracle_type_rev=oracle_type[::-1]
    for n in range(size-1,-1,-1):
        if oracle_type_rev[n] =="0":
            oracleCircuit.x(qr[n])
    oracleCircuit.h(qr[size-1])
    if size==2: 
        oracleCircuit.cx(qr[size-2],qr[size-1]);
    if size==3:
        oracleCircuit.ccx(qr[size-3],qr[size-2],qr[size-1])
    if size==4:
        oracleCircuit.mcx([qr[size-4],qr[size-3],
            qr[size-2]],qr[size-1])
    if size&gt;=5:
        oracleCircuit.mcx([qr[size-5],qr[size-4],
            qr[size-3],qr[size-2]],qr[size-1])
    oracleCircuit.h(qr[size-1])
    for n in range(size-1,-1,-1):
        if oracle_type_rev[n] =="0":
            oracleCircuit.x(qr[n])
    return(oracleCircuit)</pre>
			<p>Let's step <a id="_idIndexMarker738"/>through <a id="_idIndexMarker739"/>it:</p>
			<ol>
				<li value="1">The input to the <code>create_oracle()</code> function is an oracle type and a size, where the type is a string that specifies the qubit combination we are looking for, for example, 10 for the <img alt="" src="img/Formula_09_068.png"/> combination.</li>
				<li>Next, we step through the oracle type in reverse, adding an X gate for each 0 in the string to flip it to a 1, as per the preceding discussion.<p>Notice here that the input to the oracle for a two-bit string is the reverse of how Qiskit® labels its qubits, so we need to reverse it into <code>oracle_input_rev</code> before processing it.</p></li>
				<li>We then add an H gate to the last qubit.</li>
				<li>Now for the real meat. Depending on the size of the circuit we are building, we add a superposition gate to take care of the phase kickback:<p>For two qubits, a CX gate is added by the program.</p><p>For three qubits, a CCX gate is added; we'll see more on that in <em class="italic">Searching with a 3-qubit Grover</em> recipe.</p><p>For 4 and 5 qubits, an MCX (multi-control NOT) gate is added; we'll see more about that one in the <em class="italic">Adding more qubits to the Grover search</em> recipe.</p></li>
				<li>And finally, we perform the H gate and X gate steps in reverse to balance out the oracle circuit.</li>
			</ol>
			<p>We now have an <a id="_idIndexMarker740"/>oracle <a id="_idIndexMarker741"/>circuit that will tag the oracle type that we passed it.</p>
			<h4>Creating the amplifier circuit</h4>
			<p>The amplifier circuit <a id="_idIndexMarker742"/>is built the same way no matter how many qubits<a id="_idIndexMarker743"/> we use for the oracle. It takes the input statevector and amplifies the probability of the correct solution by reflecting the phase-changed probability across the average probability of all solutions.</p>
			<p>Here is what that circuit looks like for a 2-qubit circuit:</p>
			<p class="figure-caption">	</p>
			<div><div><img alt="Figure 9.9 – A two-qubit amplifier circuit and its corresponding unitary matrix&#13;&#10;" src="img/Figure__9.9_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.9 – A two-qubit amplifier circuit and its corresponding unitary matrix</p>
			<p>Again, perhaps this is easier to see if you look at the amplifier unitary matrix. If you do the matrix multiplication for the phase-shifted solution, you will see that the probability for the phase-shifted solution is amplified, whereas the probability for the no-phase shifted ones is not. It turns out that in the special case of a two-qubit Grover circuit, the probability of getting the correct solution is actually 100%; you will find the correct solution among four possible ones in just one search. That is pretty amazing!</p>
			<p>In the following matrix multiplication, we will multiply the amplifier matrix with the phase-tagged superposition vector to get a solution vector with just one possible result, <img alt="" src="img/Formula_09_068.png"/>, at 100% probability:</p>
			<div><div><img alt="" src="img/Formula_09_073.jpg"/>
				</div>
			</div>
			<p>In our Python<a id="_idIndexMarker744"/> sample, this<a id="_idIndexMarker745"/> is how it is done:</p>
			<pre>def create_amplifier(size):
    from qiskit import QuantumCircuit
    # Let's create the amplifier circuit for two qubits.
    amplifierCircuit=QuantumCircuit(qr,cr)
    amplifierCircuit.barrier(qr)
    amplifierCircuit.h(qr)
    amplifierCircuit.x(qr)
    amplifierCircuit.h(qr[size-1])
    if size==2: 
        amplifierCircuit.cx(qr[size-2],qr[size-1]);
    if size==3:
        amplifierCircuit.ccx(qr[size-3],qr[size-2],qr[size-1])
    if size==4:
        amplifierCircuit.mcx([qr[size-4],qr[size-3],
            qr[size-2]],qr[size-1])
    if size&gt;=5:
        amplifierCircuit.mcx([qr[size-5],qr[size-4],
            qr[size-3],qr[size-2]],qr[size-1])
    amplifierCircuit.h(qr[size-1])
    amplifierCircuit.barrier(qr)
    amplifierCircuit.x(qr)
    amplifierCircuit.h(qr)
    return(amplifierCircuit)</pre>
			<p>The function <code>create_amplifier()</code> only takes size as input. The amplifier works the same no matter<a id="_idIndexMarker746"/> what <a id="_idIndexMarker747"/>the oracle is. As you can see, it is somewhat similar to the oracle circuit; it too builds a balanced circuit:</p>
			<ol>
				<li value="1">It starts with H gates on all qubits.</li>
				<li>The second step is to add X gates on all qubits. </li>
				<li>And again, depending on the size of the circuit, it adds a CX, CCX, or MCX gate for the phase kickback in the middle.</li>
				<li>And just like for <a id="_idIndexMarker748"/>the oracle circuit, we now<a id="_idIndexMarker749"/> reverse the initial X and H gates, to balance out the circuit.</li>
			</ol>
			<p>We now have our oracle and our amplifier; all we need to do is put them together.</p>
			<h4>Creating the Grover circuit</h4>
			<p>The Grover circuit <a id="_idIndexMarker750"/>puts the pieces together, adds H gates at the beginning, to<a id="_idIndexMarker751"/> set up a superposition, and adds measurement gates at the end to let you run the circuit.</p>
			<p>The <code>create_grover()</code> function takes the oracle circuit and the amplifier circuit as input. It also takes a Boolean <code>showsteps</code> parameter. With this one set to <code>showsteps</code> parameter to <strong class="bold">False</strong> to just run the Grover circuit with no extra visualizations.</p>
			<p>The Python code looks like this:</p>
			<pre>def create_grover(oracleCircuit,amplifierCircuit,showstep):
    from qiskit import QuantumCircuit
    from math import sqrt, pow, pi
    groverCircuit = QuantumCircuit(qr,cr)
    # Initiate the Grover with Hadamards
    if showstep: display_circuit(groverCircuit,True,False)
    groverCircuit.h(qr)
    groverCircuit.barrier(qr)
    if showstep: display_circuit(groverCircuit,True,False)
    # Add the oracle and the inversion
    for n in range(int(pi/4*(sqrt(pow(2,
            oracleCircuit.num_qubits))))):
        groverCircuit+=oracleCircuit
        if showstep: display_circuit(groverCircuit,True,False)
        groverCircuit+=amplifierCircuit
        if showstep: display_circuit(groverCircuit,True,False)
    # Add measurements
    groverCircuit.measure(qr,cr)
    return(groverCircuit)</pre>
			<p>Here are the steps for the code we just saw:</p>
			<ol>
				<li value="1">We create a quantum circuit with the global quantum and classical registers that we set when we created the oracle.</li>
				<li>Next, we add H gates<a id="_idIndexMarker752"/> on all the qubits and <a id="_idIndexMarker753"/>add a barrier instruction to keep our circuit intact on transpiling. There are a lot of duplicate gates that follow each other here, and we need to retain all of them for the circuit to work.</li>
				<li>Now comes the critical step where we add the oracle and amplifier circuits. <p>To get a well-formed outcome from the Grover circuit, we need to perform the correct number of searches as we discussed in <em class="italic">A quick interlude on classical search</em>. In the quantum Grover algorithm, this is represented by running the oracle and amplifier circuits once for each search.</p><p>For a database of size N=2q, the optimal number of searches or repetitions is set by the following formula: n<img alt="" src="img/Formula_09_074.png"/> . In this case, <em class="italic">q</em> is the number of qubits in our circuit.</p><p>If you do the math, you see that for a 2-qubit Grover circuit, it is enough with 1 search only (n=1.57). For 3- and 4-qubit circuits, we add 2 and 3 repetitions respectively by just physically adding the oracle and amplifier circuits. </p><p>For an insight into why we use <img alt="" src="img/Formula_09_075.png"/> repetitions, see the <em class="italic">What happens if we run Grover's algorithm for too long?</em> section of the <em class="italic">Lecture 22, Tues April 11: Grover</em> article that is listed in the <em class="italic">See also</em> section.</p></li>
				<li>Finally, we add the measurement instructions to the circuit, which is now ready to run.</li>
			</ol>
			<p>These are the three functions that we need to build the Grover circuit. But if you want to, sit down and play around with building a set of oracles and testing them on simulators or real IBM Quantum® quantum<a id="_idIndexMarker754"/> computers; see what error mitigation does to the results and see what your <a id="_idIndexMarker755"/>Grover code actually looks like, and how big it becomes after it is transpiled for an IBM Quantum® backend.</p>
			<h2 id="_idParaDest-256"><a id="_idTextAnchor258"/>How to do it...</h2>
			<p>To create a two-qubit <a id="_idIndexMarker756"/>Grover circuit, follow these steps:</p>
			<ol>
				<li value="1">In your Python environment, run <code>ch9_r3_grover_main.py</code>.</li>
				<li>When prompted, enter the Oracle answer you want to find in the form of a two-digit string consisting of only 1 and 0, for example, <em class="italic">10</em>.</li>
				<li>The program now uses the <code>create_oracle()</code> function from the <code>ch9_grover_functions.py</code> script to build a two-qubit oracle circuit, using the oracle type that you entered, and then displays what you created:<pre>…
if size==2: 
        amplifierCircuit.cx(qr[size-2],qr[size-1]);
…</pre><p>The two-qubit<a id="_idIndexMarker757"/> oracle for <img alt="" src="img/Formula_09_076.png"/> is displayed:</p><div><img alt="Figure 9.10 – Oracle circuit for , coded for " src="img/Figure__9.10_B14436.jpg"/></div><p class="figure-caption">Figure 9.10 – Oracle circuit for <img alt="" src="img/Formula_09_077.png"/>, coded for <img alt="" src="img/Formula_09_078.png"/></p><p>We are building a<a id="_idIndexMarker758"/> circuit with a CX gate to handle the phase kickback from the second qubit to the first qubit.</p></li>
				<li>Now build the amplifier circuit for two qubits.<p>The next step is to create the amplifier circuit by using the <code>create_amplifier()</code> function. This also uses a CX gate for the phase kickback. The only input the function needs is the number of qubits.</p><p>This is where we make a couple of circuit manipulations on all the qubits at the same time, using the quantum register as input. For example, by using the following code, we add a Hadamard gate to all qubits in the <code>qr</code> two-qubit quantum register, that is, both of them: <code>amplifierCircuit.h(qr)</code>.</p><p>The amplifier circuit and its corresponding unitary matrix look the same for all two-qubit Grover <a id="_idIndexMarker759"/>circuits:</p><div><img alt="Figure 9.11 – Two-qubit amplifier circuit&#13;&#10;" src="img/Figure__9.11_B14436.jpg"/></div><p class="figure-caption">Figure 9.11 – Two-qubit amplifier circuit</p><p>Go back to the <em class="italic">Creating the amplifier circuit</em> section for a matrix multiplication refresher, if needed:</p><div><img alt="" src="img/Formula_09_079.jpg"/></div><p>As you can see, the <a id="_idIndexMarker760"/>phase shifter state 10 has been amplified to <code>-1</code>. When we calculate the outcome probabilities by squaring the outcome state parameter as we did in the <a href="B14436_02_Final_PG_ePub.xhtml#_idTextAnchor045"><em class="italic">Chapter 2</em></a>, <em class="italic">Quantum Computing and Qubits with Python</em>, in the <em class="italic">Comparing a bit and a qubit</em> section, we get the following probable outcome. Result 10 = 100%, and all other outcomes = 0%. The probability of getting the amplified correct answer is 100%.</p></li>
				<li>Create the Grover circuit step by step:<p>In the next step, the program creates the Grover quantum circuit that encloses our oracle and amplifier and adds measurement gates. Again, we use the <code>create_grover()</code> function for this.</p><p>With the verbose circuit creation display, we get the following output in a quick flow. Let's take a look at the circuits one at a time.</p><p>Create a<a id="_idIndexMarker761"/> blank two-qubit circuit:</p><div><img alt="Figure 9.12 – A blank circuit with 100% probability of getting the result &#13;&#10;" src="img/Figure__9.12_B14436.jpg"/></div><p class="figure-caption">Figure 9.12 – A blank circuit with 100% probability of getting the result <img alt="" src="img/Formula_008_007.png"/></p><p>Set the two qubits<a id="_idIndexMarker762"/> in superposition:</p><div><img alt="Figure 9.13 – A circuit with two qubits in superposition. There is an equal probability of 25% of getting each result:" src="img/Figure__9.13_B14436.jpg"/></div><p class="figure-caption">Figure 9.13 – A circuit with two qubits in superposition. There is an equal probability of 25% of getting each result: <img alt="" src="img/Formula_09_109.png"/>, <img alt="" src="img/Formula_008_013.png"/>, and <img alt="" src="img/Formula_09_110.png"/></p><p>Add the <a id="_idIndexMarker763"/>oracle circuit:</p><div><img alt="Figure 9.14 – Adding the oracle circuit for . There is still an equal probability of 25% of getting each result: , , and , but  is now phase-shifted &#13;&#10;" src="img/Figure__9.14_B14436.jpg"/></div><p class="figure-caption">Figure 9.14 – Adding the oracle circuit for <img alt="" src="img/Formula_09_082.png"/>. There is still an equal probability of 25% of getting each result: <img alt="" src="img/Formula_09_109.png"/>, <img alt="" src="img/Formula_008_013.png"/>, and <img alt="" src="img/Formula_09_110.png"/>, but <img alt="" src="img/Formula_008_013.png"/> is now phase-shifted <img alt="" src="img/Formula_09_018.png"/></p><p>Add the <a id="_idIndexMarker764"/>amplifier circuit:</p><div><img alt="Figure 9.15 – Adding the amplifier circuit, which amplifies the probability of the phase-shifted outcome. Now there is a 100% probability of getting  &#13;&#10;" src="img/Figure__9.15_B14436.jpg"/></div><p class="figure-caption">Figure 9.15 – Adding the amplifier circuit, which amplifies the probability of the phase-shifted outcome. Now there is a 100% probability of getting <img alt="" src="img/Formula_09_083.png"/> </p><p>Add the measurement <a id="_idIndexMarker765"/>components to finalize the circuit. The final circuit will look something like this:</p><div><img alt="Figure 9.16 – Three-qubit Grover circuit with one repetition of the oracle for  and an amplifier&#13;&#10;" src="img/Figure__9.16_B14436.jpg"/></div><p class="figure-caption">Figure 9.16 – Three-qubit Grover circuit with one repetition of the oracle for <img alt="" src="img/Formula_09_083.png"/> and an amplifier</p><p>As you can see, the first step of the Grover circuit is to set all the qubits in an even superposition by using the H gate. Then, the oracle and the amplifier circuits. Finally, we finish by adding measurement components for all the qubits so we can read out the end result.</p></li>
				<li>Now, let's run the<a id="_idIndexMarker766"/> circuit and see what result we get:<div><img alt="Figure 9.17 – Two-qubit Grover search outcome for  oracle on the Aer simulator" src="img/Figure__9.17_B14436.jpg"/></div><p class="figure-caption">Figure 9.17 – Two-qubit Grover search outcome for <img alt="" src="img/Formula_09_083.png"/> oracle on the Aer simulator</p></li>
				<li>Enter <code>Y</code> to run the Grover circuit on the least busy 5-qubit IBM Q backend:<div><img alt="Figure 9.18 – Two-qubit Grover search outcome for  oracle on an IBM Q backend&#13;&#10;" src="img/Figure__9.18_B14436.jpg"/></div><p class="figure-caption">Figure 9.18 – Two-qubit Grover search outcome for <img alt="" src="img/Formula_09_083.png"/> oracle on an IBM Q backend</p><p>So, what is going on<a id="_idIndexMarker767"/> here? How come we are not getting the super-precise outcome that the oracle and amplifier circuits promised? With the simulator, we had a 100% chance of getting the correct result. Now we are down to ~91%. Can we use error mitigation to do better? For a two-qubit Grover circuit, it turns out we can.</p></li>
				<li>Run the two-qubit Grover error mitigated for the behavior of the actual quantum computer.<p>Here we add in the mitigated run function that we tested in <a href="B14436_08_Final_PG_ePub.xhtml#_idTextAnchor220"><em class="italic">Chapter 8</em></a>, <em class="italic">Cleaning Up Our Act with Ignis</em>, which is encoded as the <code>mitigated_results(backend,circuit,results)</code> function:</p><pre>def mitigated_results(backend,circuit,results,
        results_sim):
    # Import the required classes
    from qiskit.providers.aer.noise import NoiseModel
    from qiskit.ignis.mitigation.measurement import
        (complete_meas_cal,CompleteMeasFitter)
    # Get noise model for backend
    noise_model = NoiseModel.from_backend(backend)
    # Create the measurement fitter
    qr = QuantumRegister(circuit.num_qubits)
    meas_calibs, state_labels = complete_meas_cal(
        qr=qr, circlabel='mcal')
    job = execute(meas_calibs,
        backend=Aer.get_backend('qasm_simulator'), 
        shots=8192, noise_model=noise_model)
    cal_results = job.result()
    meas_fitter = CompleteMeasFitter(cal_results, 
        state_labels, circlabel='mcal')
    print(meas_fitter.cal_matrix)
    # Get the filter object
    meas_filter = meas_fitter.filter
    # Results with mitigation
    mitigated_results = meas_filter.apply(results)
    mitigated_counts = mitigated_results.get_counts(0)
    return(mitigated_counts)</pre><p>The mitigated <a id="_idIndexMarker768"/>results are displayed:</p><div><img alt="Figure 9.19 – Error-mitigated results of a two-qubit Grover search outcome for  oracle on an IBM Quantum® backend&#13;&#10;" src="img/Figure__9.19_B14436.jpg"/></div><p class="figure-caption">Figure 9.19 – Error-mitigated results of a two-qubit Grover search outcome for <img alt="" src="img/Formula_09_0831.png"/> oracle on an IBM Quantum® backend</p><p>Yes, that is better; we <a id="_idIndexMarker769"/>now see a ~95% chance of getting the correct result! The error mitigation of this circuit improved our results somewhat and reduced the probability of incorrect solutions. The error mitigation works as the circuit that we have built is relatively small. </p></li>
				<li>See the final transpiled circuit.<p>The final step in our two-qubit Grover exploration is to take a look at the transpiled circuit that we ran on the quantum computer. For this, we reuse the <code>transpile_circuit(circuit,backend)</code> function that we introduced in the <em class="italic">What your quantum circuit really looks like</em> recipe of <a href="B14436_06_Final_PG_ePub.xhtml#_idTextAnchor156"><em class="italic">Chapter 6</em></a>, <em class="italic">Understanding the Qiskit® Gate Library</em>:</p><pre>def transpile_circuit(circuit,backend):
    from qiskit.compiler import transpile
    trans_circ = transpile(circuit, backend)
    display(trans_circ.draw(output="mpl"))
    print("Circuit data\n\nDepth: ",trans_circ.depth(),"\nWidth: ",trans_circ.width(),"\nSize: ",trans_circ.size())</pre></li>
			</ol>
			<div><div><img alt="Figure 9.20 – Final backend executable quantum circuit for the two-qubit Grover circuit&#13;&#10;" src="img/Figure__9.20_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.20 – Final backend executable quantum circuit for the two-qubit Grover circuit</p>
			<p>And here are some <a id="_idIndexMarker770"/>statistics about our Grover circuit:</p>
			<pre>Depth:  9 
Width:  7 
Size:  15</pre>
			<p>Our Grover circuit has a total depth, from left to right, of 9 gate manipulations; there are a total of 15 individual gates. </p>
			<p>For the two-qubit Grover, it turns out that we can use 100% backend basis gates, so our transpiled circuit is about the same size as our coded circuit. This will change for the three, four, and more qubit Grover circuits where we will be using the non-basis gates CCX and MCX. See the <em class="italic">Searching with a three qubit Grover</em> and <em class="italic">Adding more qubits to the Grover search</em> recipes to take a look.</p>
			<h2 id="_idParaDest-257"><a id="_idTextAnchor259"/>There's more…</h2>
			<p>A quick final note on the two-qubit Grover that we start out with. The two-qubit circuit we have built is just one of <a id="_idIndexMarker771"/>many different ways of approaching the Grover algorithm. I have intentionally chosen this approach to keep down the number of qubits that we use, and in doing so we are seeing the second qubit serve two purposes: it is part of the oracle, and it is also part of the phase kickback component. </p>
			<p>Another way of building the circuit is to use an ancilla qubit strictly for the phase kickback. This keeps the oracle qubits free, but adds one qubit, and slightly more complexity to the circuit; we now have to use a CCX gate to do the phase kickback, not a CX gate.</p>
			<p>An example of a Grover circuit coded for <img alt="" src="img/Formula_09_068.png"/> and built with an ancilla qubit is here: <a href="https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter09/ch9_grover_ancilla.py">https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter09/ch9_grover_ancilla.py</a>.</p>
			<p>Here's how that Python sample is built:</p>
			<ol>
				<li value="1">We start by importing the required classes:<pre>from qiskit import QuantumCircuit, Aer, execute
from IPython.core.display import display
from qiskit.tools.visualization import plot_histogram</pre></li>
				<li>Create a three-qubit circuit with two classical bits.  <p>We will use the third, ancilla qubit as the phase kickback controller:</p><pre>qc=QuantumCircuit(3,2)
qc.h([0,1])
qc.x(2)</pre></li>
				<li>Add the code for the oracle:<pre>qc.barrier([0,1,2])
qc.x(0)
qc.barrier([0,1,2])</pre></li>
				<li>Now we add the phase kickback using the ancilla qubit:<pre>qc.h(2)
qc.ccx(0,1,2)
qc.h(2)</pre></li>
				<li>We complete the coding of the oracle:<pre>qc.barrier([0,1,2])
qc.x(0)
qc.barrier([0,1,2])</pre></li>
				<li>Before we are done, we<a id="_idIndexMarker772"/> need to build the amplifier:<pre>qc.h([0,1])
qc.x([0,1])
qc.h(1)
qc.cx(0,1)
qc.h(1)
qc.barrier([0,1,2])
qc.x([0,1])
qc.h([0,1])</pre></li>
				<li>Add the measurements of the two first qubits.<p>As the ancilla qubit is just a tool we use inside the circuit, we do not need to measure it: </p><pre>qc.measure([0,1],[0,1])</pre></li>
				<li>Finally, we display the circuit, execute it on a simulator, and show the results:<pre>display(qc.draw('mpl'))
backend = Aer.get_backend('qasm_simulator')
job = execute(qc, backend, shots=1)
result = job.result()
counts = result.get_counts(qc)
display(plot_histogram(counts))</pre></li>
			</ol>
			<p>The <img alt="" src="img/Formula_09_068.png"/> oracle circuit looks like this: </p>
			<div><div><img alt="Figure 9.21 – A  oracle Grover circuit using three qubits with an ancilla qubit&#13;&#10;" src="img/Figure__9.21_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.21 – A <img alt="" src="img/Formula_09_0832.png"/> oracle Grover circuit using three qubits with an ancilla qubit</p>
			<p>Note that to expand the <a id="_idIndexMarker773"/>oracle with additional qubits, the only thing you have to do is add new qubits at the top and expand the CCX and CX gates to accommodate for the additional phase kickback requirements.</p>
			<h2 id="_idParaDest-258"><a id="_idTextAnchor260"/>See also</h2>
			<p>For a good read on understanding the Grover algorithm, take a look at <em class="italic">Lecture 22, Tues April 11: Grover</em> from the lecture series by Scott Aaronson, David J. Bruton Centennial Professor of Computer Science at The University of Texas at Austin: <a href="https://www.scottaaronson.com/qclec/22.pdf">https://www.scottaaronson.com/qclec/22.pdf</a>.</p>
			<h1 id="_idParaDest-259"><a id="_idTextAnchor261"/>Searching with a three qubit Grover</h1>
			<p>The 3-qubit Grover <a id="_idIndexMarker774"/>algorithm is very similar to the two qubit implementation that we explored in the previous recipe. The main difference is in how we build the oracle circuit for three instead of two qubits, building a phase kickback that adds the phase to two qubits instead of one.</p>
			<p>To do this, we have to use a controlled-NOT gate that uses two qubits as input to flip the third to entangle the qubits and mark the correct answer with a <img alt="" src="img/Formula_09_018.png"/> phase. That gate is the Toffoli (CCX) gate instead of the CX gate.</p>
			<p>In the following example, the two qubit input Toffoli gate (CCX) with 2 controlling qubits and 1 controlled qubit serves as the phase kickback that shifts the phase of the state by <img alt="" src="img/Formula_09_085.png"/> if the value <a id="_idIndexMarker775"/>of the three qubits matches the correct answer:</p>
			<div><div><img alt="Figure 9.22 – A CCX-driven oracle for " src="img/Figure__9.22_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.22 – A CCX-driven oracle for <img alt="" src="img/Formula_09_088.png"/></p>
			<p>We will be using the same sample functions as in <em class="italic">The Grover search algorithm</em> recipe.</p>
			<h2 id="_idParaDest-260"><a id="_idTextAnchor262"/>How to do it...</h2>
			<p>To create a three qubit Grover circuit, let's follow these steps:</p>
			<ol>
				<li value="1">In your Python environment, run <code>ch9_r3_grover_main.py</code>.</li>
				<li>When prompted, enter the oracle answer you want to find in the form of a three-digit string consisting of only 1 and 0, for example, <code>100</code>.</li>
				<li>The program now steps through the building process for your three qubit Grover, just like for the two qubit one we built in the previous recipe. We will highlight the important steps, but not go into any real details. The output should speak for itself.</li>
				<li>Create the Grover circuit.<p>With three qubits, we have a total of N = 8 (<img alt="" src="img/Formula_09_086.png"/>) possible outcomes, as we discussed in <em class="italic">Building Grover's search algorithm</em> recipe.</p><p>For a database of size N=2q, the optimal number of searches or repetitions is set by the following<a id="_idIndexMarker776"/> formula: n<img alt="" src="img/Formula_09_087.png"/> . For 3 qubits, we thus get n = 2.22. This we round to 2, for 2 repetitions of the oracle and amplifier circuits.</p><p>The final circuit will look something like this:</p><div><img alt="Figure 9.23 – Three-qubit Grover circuit with two repetitions for oracle &#13;&#10;" src="img/Figure__9.23_B14436.jpg"/></div><p class="figure-caption">Figure 9.23 – Three-qubit Grover circuit with two repetitions for oracle <img alt="" src="img/Formula_09_088.png"/></p><p>As you can see, the first step of the Grover circuit is to set all the qubits in an even superposition by using the H gate. Then we add two repetitions of the oracle and the amplifier circuits. Finally, we finish by adding measurement components for all the qubits so we can read out the end result.</p><p>If you have the Boolean <code>showsteps</code> parameter set to <strong class="bold">True</strong>, you will see the individual steps and <a id="_idIndexMarker777"/>temporary results for the Grover circuit, with the final step looking like this:</p><div><img alt="Figure 9.24 – Three-qubit Grover with the oracle coded for &#13;&#10;" src="img/Figure__9.24_B14436.jpg"/></div><p class="figure-caption">Figure 9.24 – Three-qubit Grover with the oracle coded for <img alt="" src="img/Formula_09_088.png"/></p><p>In this final step, you can see that the correct answer, <img alt="" src="img/Formula_09_090.png"/>, has been amplified and now has ~94% probability (0.9722) whereas all other results have in the order of 0.8% (-0.0882) probability.</p></li>
				<li>Now, let's run the circuit and see what result we get:<div><img alt="Figure 9.25 – Three-qubit Grover search outcome for a  oracle on a simulator&#13;&#10;" src="img/Figure__9.25_B14436.jpg"/></div><p class="figure-caption">Figure 9.25 – Three-qubit Grover search outcome for a <img alt="" src="img/Formula_09_088.png"/> oracle on a simulator</p><p>Notice how the results<a id="_idIndexMarker778"/> nicely match what we predicted from the final statevector.</p></li>
				<li>Enter <code>Y</code> to run the Grover circuit on the least busy five qubit IBM Quantum® backend:<div><img alt="Figure 9.26 – Three-qubit Grover search outcome for a  oracle on an IBM Quantum® backend&#13;&#10;" src="img/Figure__9.26_B14436.jpg"/></div><p class="figure-caption">Figure 9.26 – Three-qubit Grover search outcome for a <img alt="" src="img/Formula_09_0881.png"/> oracle on an IBM Quantum® backend</p><p>So, what is going on here? How come we are not getting the super-precise outcome that the oracle and amplifier circuits promised? With the simulator, we had about a 94% chance of getting the correct result. Here, we are apparently down to ~40%. Can we use error mitigation to do better?</p></li>
				<li>See the final, mitigated results:<div><img alt="Figure 9.27 – Error-mitigated results of a 3-qubit Grover search outcome for a  oracle on an IBM Quantum® backend&#13;&#10;" src="img/Figure__9.27_B14436.jpg"/></div><p class="figure-caption">Figure 9.27 – Error-mitigated results of a 3-qubit Grover search outcome for a <img alt="" src="img/Formula_09_0881.png"/> oracle on an IBM Quantum® backend</p><p>Nope, that didn't <a id="_idIndexMarker779"/>do it. Even though the results are slightly better, error mitigation didn't fix it. Why? Remember that basic error mitigation mainly concerns measurement errors and doesn't take into account issues that might crop up with the gates that make up the circuit.</p><p>The explanation is in the size of our final Grover circuit. Let's run the final step of the program, which transpiles the final circuit and provides us with the size, depth, and width of the circuit that is actually run on the backend.</p></li>
				<li>Press <em class="italic">Enter</em> to see the final, transpiled circuit:<div><img alt="Figure 9.28 – Final backend executable quantum circuit for the 3-qubit Grover circuit&#13;&#10;" src="img/Figure__9.28_B14436.jpg"/></div><p class="figure-caption">Figure 9.28 – Final backend executable quantum circuit for the 3-qubit Grover circuit</p></li>
				<li>And finally, we have <a id="_idIndexMarker780"/>the answer, the circuit size:<pre>Circuit data
Depth:  49 
Size:  76</pre><p>Our Grover circuit has a total depth, from left to right, of 49 gate manipulations; there are a total of 76 individual gates. If you take a quick look at <a href="B14436_08_Final_PG_ePub.xhtml#_idTextAnchor220"><em class="italic">Chapter 8</em></a>, <em class="italic">Cleaning Up Our Act with Ignis</em> again, you'll remember that we pulled out the gate error rates for the basis gates for each qubit. Although these errors are pretty small, in the order of tenths of a percent and less, when you run in the order of 100 or so gates as in the preceding circuit, chances are that there will be errors.</p><p>So, in the final analysis, the slightly higher probabilities of getting results other than the expected <img alt="" src="img/Formula_09_090.png"/> are <a id="_idIndexMarker781"/>mainly due to gate errors, and not measurement errors.</p></li>
			</ol>
			<h1 id="_idParaDest-261"><a id="_idTextAnchor263"/>Adding more qubits to the Grover search</h1>
			<p>So far, we have done <a id="_idIndexMarker782"/>reasonably well in our Grover coding. We built our two and three qubit circuits using unique Qiskit® gates for the number of qubits that our circuits contained: CX and CCX. For a four qubit and more Grover, we will use a multi-control NOT gate, MCX, to dynamically create the right number of control inputs.</p>
			<h2 id="_idParaDest-262"><a id="_idTextAnchor264"/>Getting ready</h2>
			<p>We will use the same sample functions as in the <em class="italic">Building the Grover's search algorithm</em> recipe.</p>
			<p>For two and three qubit Grovers, we could use the prefabricated CX and CCX gates to create our oracle and amplifier circuits. As we are using the same model to build a four and more qubit Grover, instead of using CCCX, CCCCX gates, and more, we use the MCX gate in our circuit, to let Qiskit® build the gate logic behind the scenes.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To understand what we are doing here, take a look back at <a href="B14436_06_Final_PG_ePub.xhtml#_idTextAnchor156"><em class="italic">Chapter 6</em></a>, <em class="italic">Understanding the Qiskit® Gate Library</em>, specifically at the CX and CCX gates.</p>
			<p>Here's the unitary matrix for the CX gate, as seen in the <em class="italic">Building the Grover's search algorithm</em> recipe:</p>
			<div><div><img alt="" src="img/Formula_09_095.jpg"/>
				</div>
			</div>
			<p>Here's the unitary matrix for the CCX gate (Toffoli), as seen in the <em class="italic">Searching with a 3-qubit Grover</em> recipe:</p>
			<div><div><img alt="" src="img/Formula_09_096.jpg"/>
				</div>
			</div>
			<p>The magic here is in the lower-right corner where the ones have left the diagonal and form a mini-diagonal the other way. The effect of this swap is to flip the value of the last qubit. Algebraically, this is an easy manipulation of the initial diagonal identity matrix; all we have to do is swap the two last rows. </p>
			<p>A <strong class="bold">controlled-controlled-controlled NOT</strong> (<strong class="bold">CCCX</strong>) gate unitary<a id="_idIndexMarker783"/> matrix will then look like this:</p>
			<div><div><img alt="" src="img/Formula_09_097.jpg"/>
				</div>
			</div>
			<p>It turns out that building a unitary matrix that represents CCCX is not that hard for just a few qubits, but the matrix grows in size as 2n so the next one, CCCCX, will be quite large.</p>
			<p>This is all great, but what do we now do with this glorious matrix? The answer is to let Qiskit® code it into gates for us by using the MCX gate. This gate takes a set of control qubits and a target qubit as input. You <a id="_idIndexMarker784"/>can also specify to use <strong class="bold">ancilla</strong> qubits for handling the phase kickback, but for our circuit, we will not do that. Look back at the ancilla sample in the <em class="italic">There's more</em> section of the <em class="italic">Building Grover's search algorithm</em> recipe. </p>
			<p>Here's what using that gate looks like in Python:</p>
			<pre>quantum_circuit.mcx([control qubits], target qubit)</pre>
			<p>For more help on the MCX gate, use Python <code>help</code>:</p>
			<pre>&gt;&gt; help(QuantumCircuit.mcx)</pre>
			<p>With the nitty-gritty behind the CCCX gate taken care of, building the 4+ Grover circuit is done exactly like the two and three qubit Grovers.</p>
			<h2 id="_idParaDest-263"><a id="_idTextAnchor265"/>How to do it...</h2>
			<p>We will be a little less stringent in covering and displaying all the steps here as the four qubit Grover takes up a lot more space than the others we have worked with. Feel free to revisit the previous recipes for details, and just apply them to the Grover we are building here.</p>
			<p>To create a 4-qubit Grover, follow these steps:</p>
			<ol>
				<li value="1">In your Python<a id="_idIndexMarker785"/> environment, run <code>ch9_r3_grover_main.py</code>.</li>
				<li>When prompted, enter the Oracle answer you want to find in the form of a 3-digit string consisting of only 1 and 0, for example, <code>1000</code>.</li>
				<li>Let's build the Grover circuit.<p>The program now steps through the building process for your three qubit Grover, just like for the two qubit one we built in the previous recipe. We will highlight the important steps, but not go into any real details. The output should speak for itself.</p><p>With three qubits, we have a total of N = 16 (<img alt="" src="img/Formula_09_098.png"/>) possible outcomes, and as we discussed in the <em class="italic">Building the Grover's search algorithm</em> recipe, the ideal number of repetitions of the circuit is <img alt="" src="img/Formula_09_099.png"/>. For 3 qubits, we thus get n = 3.14. This we round to 3, for 3 repetitions of the oracle and amplifier circuits.</p><p>The final circuit will look something like this:  </p><div><img alt="Figure 9.29 – Four-qubit Grover circuit with three repetitions for oracle " src="img/Figure__9.29_B14436.jpg"/></div><p class="figure-caption">Figure 9.29 – Four-qubit Grover circuit with three repetitions for oracle <img alt="" src="img/Formula_09_100.png"/></p><p>If you have the<a id="_idIndexMarker786"/> Boolean <code>showsteps</code> parameter set to <strong class="bold">True</strong>, you will see the individual steps and temporary results for the Grover circuit, with the final step looking like this:</p><div><img alt="Figure 9.30 – Four-qubit Grover with the oracle coded for &#13;&#10;" src="img/Figure__9.30_B14436.jpg"/></div><p class="figure-caption">Figure 9.30 – Four-qubit Grover with the oracle coded for <img alt="" src="img/Formula_09_101.png"/></p><p>In this final step, you can see (after some digging) that the correct answer, <img alt="" src="img/Formula_09_102.png"/> has been amplified (-0.98046875) and now has ~96% probability whereas all other results have in the order of 0.02% probability.</p></li>
				<li>Now, let's run<a id="_idIndexMarker787"/> the circuit and see what result we get:<div><img alt="Figure 9.31 – Four-qubit Grover search outcome for a  oracle on a simulator&#13;&#10;" src="img/Figure__9.31_B14436.jpg"/></div><p class="figure-caption">Figure 9.31 – Four-qubit Grover search outcome for a <img alt="" src="img/Formula_09_103.png"/> oracle on a simulator</p></li>
				<li>Enter <code>Y</code> to run the <a id="_idIndexMarker788"/>Grover circuit on the least busy five qubit IBM Quantum® backend:<div><img alt="Figure 9.32 – Four-qubit Grover search outcome for a  oracle on an IBM Quantum® backend&#13;&#10;" src="img/Figure__9.32_B14436.jpg"/></div><p class="figure-caption">Figure 9.32 – Four-qubit Grover search outcome for a <img alt="" src="img/Formula_09_104.png"/> oracle on an IBM Quantum® backend</p><p>This time, we seem<a id="_idIndexMarker789"/> to be getting nothing but noise. Surely there is no clear answer in that randomness. The correct answer is nowhere near the top of this list. Let's see the results after error mitigation.</p><p>The explanation is again in the size of our final Grover circuit. The final step of the program will give us the transpiled circuit.</p></li>
				<li>Press <em class="italic">Enter</em> to see the final, transpiled circuit. The result this time is pretty overwhelming:</li>
			</ol>
			<div><div><img alt="Figure 9.33 – Final backend executable quantum circuit for the 4-qubit Grover circuit&#13;&#10;" src="img/Figure__9.33_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.33 – Final backend executable quantum circuit for the 4-qubit Grover circuit</p>
			<p>Again, we have<a id="_idIndexMarker790"/> the answer, the circuit size:</p>
			<pre>Circuit data
Depth:  311 
Size:  409</pre>
			<p>Our Grover circuit has a total depth, from left to right, of 311 gate manipulations; there are a total of 409 individual gates. Again, just like in the <em class="italic">Searching with a three qubit Grover</em> recipe, the fact that we just get noise is due to gate errors and not measurement errors. The circuit has grown too big for efficient execution on a NISQ machine. There is nothing wrong with our Grover circuit, it is just too large!</p>
			<h2 id="_idParaDest-264"><a id="_idTextAnchor266"/>There's more…</h2>
			<p>Now go ahead and <a id="_idIndexMarker791"/>create a five qubit Grover and see where it takes you. The simulator should be able to handle it gallantly and give you the expected results, say for a <img alt="" src="img/Formula_09_105.png"/> oracle. But running it on a real quantum computer will just give you noise:</p>
			<div><div><img alt="Figure 9.34 – Five-qubit Grover search outcome for a  oracle on a simulator&#13;&#10;" src="img/Figure__9.34_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.34 – Five-qubit Grover search outcome for a <img alt="" src="img/Formula_09_106.png"/> oracle on a simulator</p>
			<p>The final results of a five qubit Grover circuit when run on a real quantum computer are displayed:</p>
			<div><div><img alt="Figure 9.35 – Five-qubit Grover search outcome for a  oracle on an IBM Quantum® backend&#13;&#10;" src="img/Figure__9.35_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.35 – Five-qubit Grover search outcome for a <img alt="" src="img/Formula_09_107.png"/> oracle on an IBM Quantum® backend</p>
			<p>Take a look at the final, transpiled circuit. Depending on which IBM Quantum® machine that you run your circuit on, you might <a id="_idIndexMarker792"/>get a different size and depth depending on the machine topology. Creating a CCCCX gate (using the MCX gate) on a machine with just five qubits will require a <em class="italic">lot</em> of swapping, not to mention repeating the oracle and amplifier four times.</p>
			<p>Here's a circuit size example from running on the <code>ibmqx2</code> five qubit backend:</p>
			<pre>Circuit data
Depth:  830 
Size:  1024</pre>
			<p>A circuit this size will have to wait for a universal quantum computer; it is too big to successfully run on a NISQ machine.</p>
			<h1 id="_idParaDest-265"><a id="_idTextAnchor267"/>Using the Grover circuit in your own code</h1>
			<p>There's quite a bit of code <a id="_idIndexMarker793"/>going into the combined <code>ch9_r3_grover_main.py</code> and <code>ch9_grover_functions.py</code> scripts. The interactive main program is not needed to just run Grover if, for example, you want to utilize it in another Python program. </p>
			<h2 id="_idParaDest-266"><a id="_idTextAnchor268"/>Getting ready</h2>
			<p>The sample Grover functions code that you need is included here: <a href="https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter09/ch9_grover_functions.py">https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter09/ch9_grover_functions.py</a>.</p>
			<h2 id="_idParaDest-267"><a id="_idTextAnchor269"/>How to do it…</h2>
			<ol>
				<li value="1">Technically, all you <a id="_idIndexMarker794"/>need to do is to include the following short code snippet in your own code:<pre>from ch9_grover_functions import *
oracle=create_oracle("01",2)
amplifier=create_amplifier(2)
grover=create_grover(oracle,amplifier,False)
print(grover)</pre></li>
				<li>The preceding code should give the following result:</li>
			</ol>
			<div><div><img alt="Figure 9.36 – Using the Grover functions in a minimal script to create a  Grover circuit&#13;&#10;" src="img/Figure__9.36_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.36 – Using the Grover functions in a minimal script to create a <img alt="" src="img/Formula_09_108.png"/> Grover circuit</p>
			<p>From a Qiskit Terra <a id="_idIndexMarker795"/>circuit point of view, we are now done, and you can include your <code>grover</code> circuit with your own hybrid classical/quantum code to get the Grover search results. </p>
			<h2 id="_idParaDest-268"><a id="_idTextAnchor270"/>There's more…</h2>
			<p>But we can do even better! Qiskit Aqua actually includes a <code>Grover()</code> function that you can use directly without having to write any code. More on this in the <em class="italic">Running Grover as an Aqua function</em> recipe in <a href="B14436_10_Final_PG_ePub.xhtml#_idTextAnchor271"><em class="italic">Chapter 10</em></a>, <em class="italic">Getting to Know Algorithms with Aqua</em>.</p>
		</div>
	</body></html>