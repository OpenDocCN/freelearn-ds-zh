- en: Introduction to Geospatial Databases
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 地理空间数据库简介
- en: In the previous chapters, you learned how to set up your Python environment
    and learned about the different libraries available for working with geospatial
    data using Python. In this chapter, you will start working with data.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，你学习了如何设置你的 Python 环境，并了解了使用 Python 处理地理数据的不同库。在本章中，你将开始处理数据。
- en: Databases provide one of the most popular ways to store large amounts of data,
    and one of the most popular open source databases is PostgreSQL. PostGIS extends
    PostgreSQL, adding geographic objects and the ability to query records spatially.
    When PostgreSQL and PostGIS are combined, they create a powerful geospatial data
    repository.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库提供了存储大量数据最受欢迎的方式之一，其中最受欢迎的开源数据库之一是 PostgreSQL。PostGIS 扩展了 PostgreSQL，增加了地理对象和空间查询记录的能力。当
    PostgreSQL 和 PostGIS 结合使用时，它们创建了一个强大的地理数据存储库。
- en: Geospatial databases improve on basic relational database queries by allowing
    you to query your data by location or by location to other features in the database.
    You can also perform geospatial operations such as measurements of features, distances
    between features, and converting between projections. Another feature of geospatial
    databases is the ability to create new geometries from existing features from
    a buffer, union, or clip operation.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 地理空间数据库通过允许你通过位置或通过数据库中其他特征的位置查询你的数据来改进基本的关系数据库查询。你还可以执行地理空间操作，如特征测量、特征之间的距离以及投影之间的转换。地理空间数据库的另一个特点是能够从现有特征创建新的几何形状，例如通过缓冲区、并集或裁剪操作。
- en: 'This chapter will cover the basics of geospatial databases. In this chapter,
    you will learn:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍地理空间数据库的基础知识。在本章中，你将学习：
- en: How to install PostgreSQL and PostGIS
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何安装 PostgreSQL 和 PostGIS
- en: How to install and use `pyscopg2` to connect to the database
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何安装和使用 `pyscopg2` 连接到数据库
- en: How to add data to a database
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何向数据库添加数据
- en: How to perform basic spatial queries
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何执行基本的空间查询
- en: How to query length and area
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何查询长度和面积
- en: How to query for points within a polygon
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何查询多边形内的点
- en: In [Chapter 7](4f2388a3-51fc-419f-a827-bbbedbbb6374.xhtml), *Geoprocessing with
    Geodatabases*, we will come back to geospatial databases and you will learn more
    advanced operations and how to display your data.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 7 章](4f2388a3-51fc-419f-a827-bbbedbbb6374.xhtml)，*使用地理数据库进行地理处理* 中，我们将回到地理空间数据库，你将学习更高级的操作以及如何显示你的数据。
- en: Installing PostgreSQL and PostGIS on Windows
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Windows 上安装 PostgreSQL 和 PostGIS
- en: You can install PostGIS by installing PostgreSQL and then install PostGIS afterwards,
    or you can install PostgreSQL and then use Stack Builder, which comes with PostgreSQL,
    afterwards to add PostGIS. Using Stack Builder allows you to download the desired
    PostgreSQL version and with a single-click also get the correct PostGIS version.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过安装 PostgreSQL 然后安装 PostGIS，或者安装 PostgreSQL 然后使用随 PostgreSQL 一起提供的 Stack
    Builder 来添加 PostGIS。使用 Stack Builder 允许你下载所需的 PostgreSQL 版本，并单击一次即可获取正确的 PostGIS
    版本。
- en: When I installed PostgreSQL 10, Stack Builder did not include PostGIS. By the
    time of publication, this should have been added. Screenshots may show a different
    PostGIS version because I used an old copy of PostgreSQL to show how Stack Builder
    would work. You can download PostgreSQL from [https://www.postgresql.org/download/](https://www.postgresql.org/download/).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当我安装 PostgreSQL 10 时，Stack Builder 没有包含 PostGIS。到出版时，这应该已经添加了。截图可能显示不同的 PostGIS
    版本，因为我使用了一个旧的 PostgreSQL 复制来展示 Stack Builder 将如何工作。您可以从 [https://www.postgresql.org/download/](https://www.postgresql.org/download/)
    下载 PostgreSQL。
- en: 'As we proceed, I will walk you through installing PostgreSQL and then using
    Stack Builder to add PostGIS and a database. After downloading the executable,
    run it by double-clicking it. You will see the wizard as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们继续前进，我将指导你安装 PostgreSQL，然后使用 Stack Builder 添加 PostGIS 和数据库。下载可执行文件后，双击它。你将看到以下向导：
- en: '![](img/ab1d1019-4b54-42a0-b5f1-1f1cd85528fd.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ab1d1019-4b54-42a0-b5f1-1f1cd85528fd.png)'
- en: 'You can choose where to install PostgreSQL, but it is probably best to leave
    it as the default unless you have a specific reason to locate it elsewhere:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以选择安装 PostgreSQL 的位置，但除非你有特定的理由将其放置在其他位置，否则最好将其保留为默认设置：
- en: '![](img/55e727f4-2062-405e-827f-12598859f6e4.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](img/55e727f4-2062-405e-827f-12598859f6e4.png)'
- en: 'Again, it is probably best to store the data in the default location, which
    is the same root folder as the PostgreSQL installation:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，最好将数据存储在默认位置，即与 PostgreSQL 安装相同的根文件夹：
- en: '![](img/f3ad5f9c-1140-4863-8b4b-eb17aad3b1dd.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f3ad5f9c-1140-4863-8b4b-eb17aad3b1dd.png)'
- en: 'Select the port in which you would like to run PostgreSQL. Applications will
    expect to find PostgreSQL on this port, so change it at your own risk. More advanced
    users can reconfigure port channels in the `.config` file after installation:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 选择你想要运行PostgreSQL的端口。应用程序将期望在这个端口上找到PostgreSQL，所以请自行承担更改端口的风险。更高级的用户可以在安装后修改`.config`文件中的端口通道配置：
- en: '![](img/c44ddd31-b32a-4e4a-8e34-45d9aafc8ff5.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c44ddd31-b32a-4e4a-8e34-45d9aafc8ff5.png)'
- en: 'Choose your Locale, or select the default. I have selected English, United
    States:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 选择你的区域设置，或者选择默认设置。我选择了英语，美国：
- en: '![](img/2c973abd-7587-4120-8f29-3d154b0424f0.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2c973abd-7587-4120-8f29-3d154b0424f0.png)'
- en: 'This is where you are presented with the option to launch Stack Builder, and
    from there, you can install PostGIS. Check the box to begin the installation.
    The installation should only take a few minutes on a newer system:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这里你将看到启动Stack Builder的选项，从那里你可以安装PostGIS。勾选复选框开始安装。在较新的系统上，安装应该只需要几分钟：
- en: '![](img/bea74fd6-ecc5-4a10-ab1d-cf225d5d2536.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bea74fd6-ecc5-4a10-ab1d-cf225d5d2536.png)'
- en: 'The PostgreSQL installation has been completed and Stack Builder should now
    be open. Under Spatial Extensions, select the proper version of PostGIS 32 or
    64-bit. Notice that it is a bundle and includes other packages such as `pgRouting`:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: PostgreSQL安装已完成，Stack Builder现在应该已经打开。在空间扩展部分，选择PostGIS 32位或64位的正确版本。请注意，它是一个捆绑包，包括其他包，如`pgRouting`：
- en: '![](img/e83cd2ff-7710-4050-ae93-9ee1b98b3cd7.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e83cd2ff-7710-4050-ae93-9ee1b98b3cd7.png)'
- en: 'Now, the install wizard for PostGIS will launch. You have to agree to the terms
    of the license:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，PostGIS的安装向导将启动。你必须同意许可协议：
- en: '![](img/900c8a5c-cc61-4955-a87a-92dc35c9a693.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/900c8a5c-cc61-4955-a87a-92dc35c9a693.png)'
- en: 'You can create a database at any time and this chapter will show you how to,
    however, it is best to check the Create spatial database box and take care of
    it now. If you do, your database will be set up and ready to use once PostGIS
    is installed:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以随时创建数据库，本章将向你展示如何操作，但是，最好现在就检查创建空间数据库框并处理它。如果你这样做，一旦PostGIS安装完成，你的数据库将设置好并准备好使用：
- en: '![](img/06694412-cd98-4d7a-a14c-d28b0adfe055.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/06694412-cd98-4d7a-a14c-d28b0adfe055.png)'
- en: 'PostGIS will try to install where PostgreSQL was installed:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: PostGIS将尝试在PostgreSQL安装的位置安装：
- en: '![](img/61781c67-8d35-4f74-bf14-006be7dcbbef.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/61781c67-8d35-4f74-bf14-006be7dcbbef.png)'
- en: 'Enter the username, password, and port for the database. The examples in this
    chapter will use `postgres` (username) and `postgres` (password). If you select
    a different username and password combination, remember it. In production, it
    is best not to use default usernames and passwords as they are well-known and
    will make you an easy target for hackers:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 输入数据库的用户名、密码和端口。本章中的示例将使用`postgres`（用户名）和`postgres`（密码）。如果你选择不同的用户名和密码组合，请记住它。在生产环境中，最好不使用默认的用户名和密码，因为它们众所周知，会使你容易受到黑客攻击：
- en: '![](img/e3b4d560-53a9-4022-9b3f-f697fe853839.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e3b4d560-53a9-4022-9b3f-f697fe853839.png)'
- en: 'Enter the name for the database. The examples we will be looking at will use
    `pythonspatial` as the database name. You will only use the name for the initial
    connection. The SQL queries in the example will use the table name:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 输入数据库名称。我们将要查看的示例将使用`pythonspatial`作为数据库名称。你将只使用该名称进行初始连接。示例中的SQL查询将使用表名：
- en: '![](img/b3471575-a2cc-4130-bf5a-5fdcf4ee5b06.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b3471575-a2cc-4130-bf5a-5fdcf4ee5b06.png)'
- en: Installing PostgreSQL and PostGIS on Mac
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Mac上安装PostgreSQL和PostGIS
- en: To install PostgreSQL and PostGIS on a Mac, you can use `Postgres.app`. You
    can download the file from [http://postgresapp.com/](http://postgresapp.com/).
    After the file has downloaded, move it to the `applications` folder and double-click
    it. Click Initialize. You will have a server on `localhost:5432`. The username
    and database name is the same as your Mac user. There is no password.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在Mac上安装PostgreSQL和PostGIS，你可以使用`Postgres.app`。你可以从[http://postgresapp.com/](http://postgresapp.com/)下载文件。文件下载完成后，将其移动到`applications`文件夹，并双击它。点击初始化。你将有一个在`localhost:5432`的服务器。用户名和数据库名与你的Mac用户名相同。没有密码。
- en: You should then be able to use the `psql` commands to create a new database
    and enable PostGIS.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你应该能够使用`psql`命令创建一个新的数据库并启用PostGIS。
- en: Working with PostgreSQL and PostGIS using Python
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Python与PostgreSQL和PostGIS协同工作
- en: To connect and manipulate your PostgreSQL database in Python, you will need
    a library to assist you. `psyscopg2` is that library. It provides a wrapper around
    the official `libpq` client library. In this section, we will cover how to install
    the library, how to connect to the database, and how to add a table and perform
    basic geospatial queries.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Python中使用`psycopg2`库连接和操作您的PostgreSQL数据库，您需要一个辅助库。`psycopg2`就是那个库。它提供了一个官方`libpq`客户端库的包装。在本节中，我们将介绍如何安装该库、如何连接到数据库以及如何添加表和执行基本的空间查询。
- en: Connecting to PostgreSQL using psycopg2
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用psycopg2连接到PostgreSQL
- en: '`pscycopg2` is the most popular library for working with PostgreSQL in Python.
    It fully implements the Python DB API 2.0 specification and works with Python
    3\. In the following sections, you will learn how to install the library, make
    connections, execute queries, and read the results. You can read the full documentation
    here: [http://initd.org/psycopg/docs/](http://initd.org/psycopg/docs/)'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`psycopg2`是Python中处理PostgreSQL最流行的库。它完全实现了Python DB API 2.0规范，并且与Python 3兼容。在接下来的章节中，您将学习如何安装库、建立连接、执行查询和读取结果。您可以在此处阅读完整的文档：[http://initd.org/psycopg/docs/](http://initd.org/psycopg/docs/)'
- en: Installing psycopg2
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装psycopg2
- en: 'Installing most Python libraries requires you to open your console and type:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 安装大多数Python库需要您打开控制台并输入：
- en: '[PRE0]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If that doesn''t work, and you are using an Anaconda Python distribution, you
    can run the `conda` command, using:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这不起作用，并且您使用的是Anaconda Python发行版，您可以使用`conda`命令，如下所示：
- en: '[PRE1]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'While most Python libraries can be downloaded and installed using:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数Python库都可以使用以下方式下载和安装：
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Since `psycopg2` is more advanced than that and requires you to have a C compiler,
    Python header files, `libpq` header files, and the `pg_config` program. If you
    need to install `psycopg2` from the source, the link to the instructions is in
    the following hint box.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`psycopg2`比这更高级，并且需要您拥有C编译器、Python头文件、`libpq`头文件和`pg_config`程序。如果您需要从源代码安装`psycopg2`，说明链接位于以下提示框中。
- en: To install `psycopg2` from the source, the instructions are located at: [http://initd.org/psycopg/docs/install.html#install-from-source](http://initd.org/psycopg/docs/install.html#install-from-source)
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 要从源代码安装`psycopg2`，说明位于：[http://initd.org/psycopg/docs/install.html#install-from-source](http://initd.org/psycopg/docs/install.html#install-from-source)
- en: Connecting to the database and creating a table
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接到数据库并创建一个表
- en: You should have created a database when you installed PostGIS. For the examples
    mentioned as follows, we will use this database.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该在安装PostGIS时创建数据库。对于以下提到的示例，我们将使用此数据库。
- en: 'If you did not create a database during the installation of PostGIS, you can
    do so using your terminal (command prompt in Windows) and the commands as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在安装PostGIS时没有创建数据库，您可以使用终端（Windows中的命令提示符）和以下命令创建：
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You may need to modify your path. On Windows, the command to do so is shown
    as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能需要修改您的路径。在Windows上，执行此操作的命令如下所示：
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To connect to your database, use the following code:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 要连接到您的数据库，请使用以下代码：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The code mentioned earlier starts by importing `psycopg2`. It then makes a `connection`
    by using the `connect()` function and passing the parameters for the database
    name, the `user`, and the `password`. It then creates a `cursor` which allows
    you to communicate with the database. You can use the `execute()` method of the
    `cursor` to create the table passing SQL statements as strings.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 之前提到的代码首先通过导入`psycopg2`开始。然后使用`connect()`函数并通过传递数据库名称、`user`和`password`参数来建立连接。然后创建一个`cursor`，允许您与数据库通信。您可以使用`cursor`的`execute()`方法通过字符串形式的SQL语句创建表。
- en: The code executes an SQL command which creates a table named `art_pieces` with
    an `id` of type `SERIAL` and makes it a `PRIMARY KEY`, `code` as type `VARCHAR`
    and a length of `255`, and the `location` as the `GEOMETRY` type. The `SERIAL
    PRIMARY KEY` tells PostgreSQL that we want an auto-incremented unique identifier.
    You can also use the `BIGSERIAL` type. The other type that is different is the `location`
    of the `GEOMETRY` type. This is the column that will hold the geo portion of our
    records.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码执行一个SQL命令，创建一个名为`art_pieces`的表，其中`id`的类型为`SERIAL`，并使其成为`PRIMARY KEY`，`code`的类型为`VARCHAR`，长度为`255`，`location`的类型为`GEOMETRY`。`SERIAL
    PRIMARY KEY`告诉PostgreSQL我们想要一个自动递增的唯一标识符。您也可以使用`BIGSERIAL`类型。另一种不同的类型是`location`的`GEOMETRY`类型。这是将存储我们记录地理部分的列。
- en: Lastly, you `commit()` to make sure the changes are saved. You can also `close()`
    when you are finished, but we will continue further.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您 `commit()` 以确保更改已保存。您也可以在完成时 `close()`，但我们将继续前进。
- en: Adding data to the table
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向表中添加数据
- en: In the previous section, we created a table. In this section, you will grab
    data from an open data site and put it on your table so that you can query it
    in the next section.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们创建了一个表。在本节中，您将从开放数据网站抓取数据并将其放入您的表中，以便您可以在下一节中进行查询。
- en: 'Most cities have open data websites and portals. The City of Albuquerque has
    several ArcServer endpoints with spatial data. The following code will use the
    `requests` Python library to grab public art data and then use `psycopg2` to send
    it to the PostgreSQL database, `pythonspatial`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数城市都有开放数据网站和门户。阿尔伯克基市有几个带有空间数据的 ArcServer 端点。以下代码将使用 `requests` Python 库抓取公共艺术数据，然后使用
    `psycopg2` 将其发送到 PostgreSQL 数据库，`pythonspatial`：
- en: '[PRE6]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The code which we mentioned earlier imports `requests`, then, using the URL
    to the ArcServer endpoint, it grabs the results of a query asking for all of the
    data (`where:1=1`) and all of the fields (outFields:`*`) in **World Geodetic System**
    (**WGS**) **84** (`outSR:4326`), and returns it as a JSON (`f:json`).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到的代码导入 `requests`，然后，使用 ArcServer 端点的 URL，它抓取了查询所有数据（`where:1=1`）和所有字段（outFields:`*`）在
    **世界大地测量系统**（**WGS**） **84**（`outSR:4326`）的结果，并将其作为 JSON（`f:json`）返回。
- en: ArcServer is a GIS Server made by the **Environmental Systems Research Institute**
    (**ESRI**). It provides a way to serve GIS data using an API and returning JSON.
    Many government agencies will have an Open Data Portal that utilizes an ArcServer
    to deliver the data.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: ArcServer 是由 **环境系统研究学院**（**ESRI**）制作的 GIS 服务器。它提供了一种使用 API 提供GIS数据并返回 JSON
    的方式。许多政府机构将有一个开放数据门户，该门户利用 ArcServer 来提供数据。
- en: 'The results are loaded into the `data` variable. Each record is in the array
    features (`data["features"][n]`). A single record, `data["features"][0]`, is shown
    as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 结果被加载到 `data` 变量中。每个记录都在数组 `features`（`data["features"][n]`）中。单个记录 `data["features"][0]`
    如下所示：
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: With the `data`, you will iterate through the array of `features`, inserting
    the `ART_CODE` as `code` and creating a **well-known text** (**WKT**) representation
    of each point.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `data`，您将遍历 `features` 数组，将 `ART_CODE` 作为 `code` 插入，并为每个点创建一个 **已知文本**（**WKT**）表示。
- en: To learn more about WKT, you can read its Wikipedia entry at: [https://en.wikipedia.org/wiki/Well-known_text](https://en.wikipedia.org/wiki/Well-known_text)
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于 WKT 的信息，您可以在其维基百科条目中阅读：[https://en.wikipedia.org/wiki/Well-known_text](https://en.wikipedia.org/wiki/Well-known_text)
- en: 'The following code shows you how to insert the data:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了如何插入数据：
- en: '[PRE8]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The preceding code iterates through each feature. It assigns `ART_CODE` to `code`,
    then constructs the WKT `(Point(-106.5918 35.1555))`, and assigns it to `wkt`.
    The code uses `ART_CODE` to show how to load other properties into the database.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码遍历每个要素。它将 `ART_CODE` 分配给 `code`，然后构建 WKT `(Point(-106.5918 35.1555))`，并将其分配给
    `wkt`。代码使用 `ART_CODE` 来展示如何将其他属性加载到数据库中。
- en: Data is almost never clean and perfect. This data is no exception. So that it
    doesn't crash when the `x` coordinate is missing, I have added an `if`*,* `else`
    statement to skip over missing data. This concept is known as **error handling**,
    and it is a best practice when constructing `requests`. The `else` statement is
    where the data gets inserted. Using `cursor.execute()`, you can construct the
    SQL query.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 数据几乎永远不会干净完美。这些数据也不例外。为了防止在 `x` 坐标缺失时崩溃，我添加了一个 `if`*，* `else` 语句来跳过缺失的数据。这个概念被称为
    **错误处理**，在构建 `requests` 时是一种最佳实践。`else` 语句是数据被插入的地方。使用 `cursor.execute()`，您可以构建
    SQL 查询。
- en: The query inserts `art_pieces` into the database along with the `code` and `location` fields
    with values. The first value, for `code`, is a placeholder `{}`. The second value,
    for `location`, is geometry which we stored as WKT. Because of this, it is inserted
    using the `ST_GeomFromText()` function and a placeholder `{}`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 查询将 `art_pieces` 以及 `code` 和 `location` 字段与值一起插入到数据库中。对于 `code` 的第一个值是一个占位符
    `{}`。对于 `location` 的第二个值是几何形状，我们将其存储为 WKT。因此，它使用 `ST_GeomFromText()` 函数和一个占位符
    `{}` 插入。
- en: 'The `format()` method is where you pass the variables to fill the placeholders—`code`,
    `wkt`. The following code shows what the query will look like when the placeholders
    are filled in:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`format()` 方法是您传递变量以填充占位符的地方——`code`，`wkt`。以下代码展示了当占位符被填充时查询将看起来是什么样子：'
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the previously mentioned code, you created the WKT as a concatenated string.
    This can be accomplished in a cleaner and more Pythonic fashion by using the Shapely
    library.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前提到的代码中，你通过连接字符串创建了 WKT。这可以通过使用 Shapely 库以更简洁和更 Pythonic 的方式完成。
- en: Shapely
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Shapely
- en: 'Shapely can be installed using:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Shapely 可以通过以下方式安装：
- en: '[PRE10]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Or with `conda`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 或者使用 `conda`：
- en: '[PRE11]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Shapely makes the task of creating and working with geometries easier and makes
    your code cleaner. In the previous code, you concatenated a string to create a
    WKT representation of a point. Using Shapely, you can create a point and then
    convert it to WKT. The following code shows you how:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Shapely 使得创建和使用几何形状的任务更加容易，并使你的代码更加简洁。在之前的代码中，你通过连接一个字符串来创建一个点的 WKT 表示。使用 Shapely，你可以创建一个点并将其转换为
    WKT。以下代码展示了如何操作：
- en: '[PRE12]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The previous code imports `Point` and `MultiPoint` from `shapely.geometry`.
    The code is the same as the previous version until the line in bold. To create
    a point, you use `Point(x,y)` in Shapely. It put all of the points in an array
    called `thepoints` to draw them in a Jupyter Notebook, for which an image is follows.
    Lastly, the SQL statement passes `p.wkt` to `ST_GeomFromText()`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码从 `shapely.geometry` 中导入了 `Point` 和 `MultiPoint`。代码与上一个版本相同，直到加粗的行。在 Shapely
    中创建一个点，你使用 `Point(x,y)`。它将所有点放入一个名为 `thepoints` 的数组中，以便在 Jupyter Notebook 中绘制，以下是一个图像。最后，SQL
    语句将 `p.wkt` 传递给 `ST_GeomFromText()`。
- en: 'In a Jupyter Notebook, you can print Shapely geometry just by typing the name
    of the variable holding the geometry and it will draw the end. The public `art`
    points are in the variable `thepoints`*.* A `MultiPoint` can be created using
    an array of points, and printing them draws the following image:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Jupyter Notebook 中，你只需输入包含几何形状的变量的名称即可打印 Shapely 几何形状，它将自动绘制。公共 `art` 点存储在变量
    `thepoints` 中*。可以使用点的数组创建一个 `MultiPoint`，打印它们将绘制以下图像：
- en: '![](img/e5a4bd3c-a6c7-4f3c-a4c3-5240543386ea.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e5a4bd3c-a6c7-4f3c-a4c3-5240543386ea.png)'
- en: Querying the data
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询数据
- en: You created a table, added columns for code and location, and populated it using
    data from another source. Now, you will learn how to query the data and get it
    out of the database.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 你创建了一个表，为代码和位置添加了列，并使用来自另一个源的数据填充了它。现在，你将学习如何查询数据并将其从数据库中导出。
- en: 'While there are spatial SQL queries available to you, you can always just select
    the data as if it were a non-spatially enabled database so that you can use it
    as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以使用空间 SQL 查询，但你总是可以像选择非空间启用数据库中的数据一样选择数据，这样你就可以像以下那样使用它：
- en: '[PRE13]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The following code shows the generic `SELECT` all query and the results:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了通用的 `SELECT` 全查询及其结果：
- en: '[PRE14]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The result should look as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 结果应该如下所示：
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The first number, `1`,`2`,n, is the `id` (the `SERIAL PRIMARY KEY`). Next, is
    the `code`. The geometry is the last column. The string of what appears to be
    random numbers and letters is a **well-known binary** (**WKB**) in hex.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个数字，`1`、`2`、n，是 `id`（`SERIAL PRIMARY KEY`）。接下来是 `code`。几何形状是最后一列。看起来像是随机数字和字母的字符串是一个
    **已知的二进制**（**WKB**）的十六进制表示。
- en: 'To convert the WKB, you use `shapely`. The following code walks you through
    converting the WKB to a `shapely` `Point`, and then printing the WKT:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要转换 WKB，你使用 `shapely`。以下代码将指导你如何将 WKB 转换为 `shapely` 的 `Point`，然后打印 WKT：
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The previous code imports the `loads()` method from `shapely.wkb`. You must
    add the `hex` parameter and make it equal to `True` or you will receive an error.
    To get the geography column of the first record, you can use `data[0][2]` with
    `[0]` as the record and `[2]` as the column. Now that you have a `shapely` `Point`,
    you can verify it by using `type(aPoint)`, you can print it as a WKT using `aPoint.wkt`.
    You should see the result as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码从 `shapely.wkb` 中导入了 `loads()` 方法。你必须添加 `hex` 参数并将其设置为 `True`，否则你会收到错误。要获取第一条记录的地理列，你可以使用
    `data[0][2]`，其中 `[0]` 是记录，`[2]` 是列。现在你有了 `shapely` 的 `Point`，你可以通过使用 `type(aPoint)`
    来验证它，你可以使用 `aPoint.wkt` 来打印它。你应该看到以下结果：
- en: '[PRE17]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If you want PostgreSQL to return the data in WKB without hex, you can do so
    using `ST_AsBinary()`. The following code shows you how:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想让 PostgreSQL 返回 WKB 格式的数据而不包含十六进制，你可以使用 `ST_AsBinary()` 来实现。以下代码展示了如何操作：
- en: '[PRE18]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The previous code wraps the location in `ST_AsBinary()`. To load the result
    into a `shapely` `Point`, you have to use `bytes()`. Then, you can see the WKT
    using `pNoHex.wkt`. You should see the same point as in the previous example.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码使用 `ST_AsBinary()` 包裹了位置。要将结果加载到 `shapely` 的 `Point` 中，你必须使用 `bytes()`。然后，你可以使用
    `pNoHex.wkt` 来查看 WKT。你应该看到与上一个示例中相同的点。
- en: 'Binary may come in handy, but you can also query the data and get the geometry
    back as a WKT:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制可能很有用，但您也可以查询数据并将几何作为 WKT 返回：
- en: '[PRE19]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The previous code uses `ST_AsText(geometry column)` to return the data as a
    WKT. You can return a column that contains geometry at any time by using `ST_AsText()`.
    Instead of `fetchall()`, the code uses `fetchone()` to grab a single record. You
    should see a single record as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码使用 `ST_AsText(geometry column)` 将数据作为 WKT 返回。您可以使用 `ST_AsText()` 在任何时候返回包含几何的列。代码使用
    `fetchone()` 而不是 `fetchall()` 来获取单个记录。您应该看到以下单个记录：
- en: '[PRE20]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You can load WKT into a `shapely` `Point` using `loads()`, but you need to
    import it first, just like you did earlier with WKB:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `loads()` 将 WKT 载入 `shapely` 的 `Point`，但您需要先导入它，就像您之前导入 WKB 一样：
- en: '[PRE21]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The previous code import `loads` from `shapely`—but this time using `shapely.wkt`,
    not `wkb`. Otherwise, you load the data the same way as in the previous examples.
    You can see the coordinates of the `shapely` `Point` using `pb.coords[:]`, or
    you can see them individually using `pb.x` and `pb.y`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码从 `shapely` 导入 `loads`——但这次使用 `shapely.wkt` 而不是 `wkb`。否则，您将以与之前示例相同的方式加载数据。您可以使用
    `pb.coords[:]` 查看坐标，或者使用 `pb.x` 和 `pb.y` 单独查看它们。
- en: 'The result of `pb.coords[:]` will be a coordinate pair, which is shown as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`pb.coords[:]` 的结果将是一对坐标，如下所示：'
- en: '[PRE22]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Changing the CRS
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改变坐标参考系统
- en: 'The data in the database is using **World Geodetic System 84** (**WGS 84**),
    latitude and longitude. What if you need the data out in **European Petroleum
    Survey Group** (**EPSG**) 3857? You can change the spatial reference in your query
    using `ST_Transform()`. The following code shows you how by using PostGIS functions:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库中的数据使用 **世界大地测量系统 84** （**WGS 84**）的纬度和经度。如果您需要将数据输出到 **欧洲石油调查组** （**EPSG**）
    3857，您可以使用 `ST_Transform()` 在查询中更改空间参考。以下代码通过使用 PostGIS 函数展示了如何操作：
- en: '[PRE23]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The previous code makes two queries to the database:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码对数据库进行了两次查询：
- en: Firstly, it assigns a spatial reference system identifier to the geometry column
    in the table using `UpdateGeomtrySRID()`. This needs to be done because the points
    were put in the table without any reference to an `SRID`. So when we try to get
    the results back using a different coordinate reference system, the database will
    not know how to transform our coordinates.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，它使用 `UpdateGeomtrySRID()` 将空间参考系统标识符分配给表中的几何列。这是因为点被放入表中而没有任何 `SRID` 的参考。因此，当我们尝试使用不同的坐标参考系统获取结果时，数据库将不知道如何转换我们的坐标。
- en: Secondly, the code queries the database to tell us what the `SRID` is on the
    geometry column in the table using `Find_SRID()`. If you do not have a properly
    added geometry column, the function will fail.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，代码查询数据库以告诉我们表中的几何列的 `SRID` 使用 `Find_SRID()`。如果您没有正确添加几何列，该函数将失败。
- en: 'Now that you have an `SRID` set on the column in the table, you can query the
    data and transform it:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经在表中的列上设置了 `SRID`，您可以查询数据并转换它：
- en: '[PRE24]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The previous code is a basic select `code` and `location`, as text, from `art_pieces`,
    but now there is an `ST_Transform` method. This method takes the column with geometry
    and the `SRID` you want the data sent back in. Now, the piece of art at `(-106.59,
    35.155)` is returned using `3857`, and shown as follows with the transformed coordinates:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码是一个基本的 `select code` 和 `location` 作为文本从 `art_pieces` 中选择，但现在有一个 `ST_Transform`
    方法。该方法接受具有几何的列和您希望数据返回的 `SRID`。现在，使用 `3857` 返回 `(-106.59, 35.155)` 的艺术品，如下所示，并显示转换后的坐标：
- en: '[PRE25]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Buffer
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓冲区
- en: 'A spatial database allows you to store spatial data, but you can also perform
    operations on the data and get different geometries back. The most common of these
    operations would be a buffer. You have a table of points, but using `ST_Buffer()`,
    you can have the database return a polygon around the point with a specified radius.
    The following code shows you how:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 空间数据库允许您存储空间数据，但您还可以对数据进行操作并获取不同的几何结果。这些操作中最常见的是缓冲区。您有一个点表，但使用 `ST_Buffer()`，您可以要求数据库返回一个具有指定半径的点周围的多边形。以下代码展示了如何操作：
- en: '[PRE26]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The previous code grabs a record from the table where the art code field equals
    `101`, and selects a buffer with a radius of `25` around the `location`. The result
    will be a polygon, which is shown as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码从表中抓取了一个记录，其中艺术代码字段等于 `101`，并选择了一个半径为 `25` 的 `location` 缓冲区。结果将是一个多边形，如下所示：
- en: When using geography, if the buffer is large, falls between two UTM zones, or
    crosses the dateline, it may behave unexpectedly.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用地理信息时，如果缓冲区很大，位于两个 UTM 区之间，或者穿过日界线，它可能会出现意外的行为。
- en: '[PRE27]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If you load the polygon into `shapely` using the following code, a Jupyter
    Notebook will draw the polygon:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用以下代码将多边形加载到 `shapely` 中，Jupyter Notebook 将绘制多边形：
- en: '[PRE28]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The buffer returned from `ST_Buffer` as a `shapely` polygon is shown as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`ST_Buffer` 返回的 `shapely` 多边形如下所示：'
- en: '![](img/a0fa316c-3695-4a82-8605-b6fba19a1efc.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a0fa316c-3695-4a82-8605-b6fba19a1efc.jpg)'
- en: 'You can also pass a parameter to `ST_Buffer` for the number of segments you
    used to draw a quarter of a circle. If you divide the circle into four quadrants,
    the `quad_segs` parameter will draw that many segments in each quadrant. A `quad_seg`
    value of 1 will draw a rotated square, which is shown as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以向 `ST_Buffer` 传递一个参数来指定绘制四分之一圆所使用的段数。如果你将圆分成四个象限，`quad_segs` 参数将在每个象限中绘制这么多段。`quad_seg`
    的值为 1 将绘制一个旋转的正方形，如下所示：
- en: '![](img/a47fc9b9-da9f-4b7f-8201-53e9978887b4.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a47fc9b9-da9f-4b7f-8201-53e9978887b4.png)'
- en: 'Whereas a `quad_seg` value of 2 would draw an octagon which is shown as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 而 `quad_seg` 的值为 2 将绘制一个八边形，如下所示：
- en: '![](img/201ce6dd-b0b8-40fe-9947-fb0c52a40f38.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/201ce6dd-b0b8-40fe-9947-fb0c52a40f38.png)'
- en: Distance and near
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 距离和邻近
- en: In the previous section, you had the database buffer a point and return the
    polygon. In this section, you will learn how to query the database for the distance
    between two points, and you will query the database and have it return records
    based on the distance from a specified point.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分，你让数据库缓冲一个点并返回多边形。在本节中，你将学习如何查询数据库以获取两点之间的距离，并且你将查询数据库并让它根据与指定点的距离返回记录。
- en: 'The PostGIS function for distance is `ST_Distance(a,b)`. You can pass `a` and
    `b` as geometry or geography. As `geography`, the result will be returned in meters. The
    following code will get the distance between two points in the database:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: PostGIS 的距离函数是 `ST_Distance(a,b)`。你可以将 `a` 和 `b` 作为几何图形或地理图形传递。作为地理图形，结果将以米为单位返回。以下代码将获取数据库中两点之间的距离：
- en: '[PRE29]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The previous code executes the SQL query for `ST_Distance()`, passing the `location`
    column of `a` and `b` which are records, where the code equals `101` and `102`. `::geography`
    is how you cast a geometry to a geography in PostGIS. How far are they from each
    other? They are 9,560.45428363 meters apart.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码执行了 `ST_Distance()` 的 SQL 查询，传递了 `a` 和 `b` 记录的 `location` 列，其中代码等于 `101`
    和 `102`。`::geography` 是在 PostGIS 中将几何图形转换为地理图形的方法。它们相距多远？它们相距 9,560.45428363 米。
- en: 'To convert this to miles use: `dist[0][0]*0.00062137`, which makes them 5.940
    miles apart.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 要将其转换为英里，请使用：`dist[0][0]*0.00062137`，这使得它们相距 5.940 英里。
- en: 'In the previous example, you used two points from the database, but you can
    also pass a hard-coded point as in the following code:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，你使用了数据库中的两个点，但你也可以像以下代码一样传递一个硬编码的点：
- en: '[PRE30]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The previous code is the same query, but this time you switch out point `b`
    (`code=102`) with a hard-coded WKT point. The results of the query should state
    that the points are 10,391.40637117 meters apart.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码是相同的查询，但这次你用硬编码的 WKT 点替换了点 `b` (`code=102`)。查询的结果应该声明这些点相距 10,391.40637117
    米。
- en: 'And, as in previous examples, you can also use `shapely` to pass the WKT of
    the point, as in the following code:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 并且，就像之前的例子一样，你也可以使用 `shapely` 传递点的 WKT，如下面的代码所示：
- en: '[PRE31]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The previous code creates the point in `shapely` and then uses `format(p.wkt)`
    to pass the WKT to the `{}` placeholder.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码在 `shapely` 中创建点，然后使用 `format(p.wkt)` 将 WKT 传递到 `{}` 占位符。
- en: 'You can get the distance between two points, but what if you want the distance
    of more than one point from another? To do that, you can remove the `a.location`
    and just use `location` as the first point. The following code will return five
    points and their distances from the specified point:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以获取两点之间的距离，但如果你想要多个点与另一个点的距离呢？为此，你可以移除 `a.location` 并仅使用 `location` 作为第一个点。以下代码将返回五个点及其与指定点的距离：
- en: '[PRE32]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The results should look like the data showing the distance in meters:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 结果应该看起来像显示距离（米）的数据：
- en: '[PRE33]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The database returned the first five points in the table with their code and
    distance from the specified point. If you remove the `LIMIT`, you will get all
    of the points.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库返回了表中前五个点的代码和与指定点的距离。如果你移除 `LIMIT`，你将得到所有点。
- en: 'By adding an `ORDER BY` clause and the k-nearest neighbor operator, you can
    extend this query to get the closest five points to the specified point. Look
    at the following code:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加 `ORDER BY` 子句和 k-最近邻运算符，你可以扩展这个查询以获取指定点的最近五个点。看看以下代码：
- en: '[PRE34]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The key element in the previous code is the symbol `*<->*`. This is the k-nearest
    neighbor operator. It returns the distance between two geometries. Using `ORDER
    BY location <-> ST_GeometryFromText()`, you are specifying two geometries. Because
    you set a `LIMIT` of `5`, the database will return the `5` closest points to the
    one specified—including the point of origin. The results should look like the
    following points:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 之前代码中的关键元素是符号 `*<->*`。这是 k-最近邻运算符。它返回两个几何体之间的距离。使用 `ORDER BY location <-> ST_GeometryFromText()`，你指定了两个几何体。由于你设置了
    `LIMIT` 为 `5`，数据库将返回与指定点最近的 `5` 个点——包括起点。结果应该看起来像以下点：
- en: '[PRE35]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Notice that the code value is not `101`-`106` or the first five from the database,
    and that the distance increases from `0.0`. The closest point, code `101`, is
    the point you specified in the query, so it is `0.0` meters away.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 注意代码值不是 `101`-`106` 或数据库中的前五个，并且距离从 `0.0` 开始增加。最近的点，代码 `101`，是你查询中指定的点，因此它距离
    `0.0` 米。
- en: Lines in the database
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库中的线
- en: 'The first section of this chapter focused on point operations. Now, we will
    turn our attention to lines. For the following examples, you will create a new
    table and insert three lines. The following code will accomplish that:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的第一部分重点介绍了点操作。现在，我们将把注意力转向线。对于以下示例，你将创建一个新的表并插入三条线。以下代码将完成这个任务：
- en: '[PRE36]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The previous code should be familiar. It starts by connecting to the Python
    spatial database, gets a `cursor`, and then creates a table with an `id` and a
    location of the `geometry` type. You should import `shapely LineString` and `MultiLine`, `Multiline`
    is so you can print the lines in the Jupyter notebook. You should create an array
    of `lines` and then loop through them, inserting each into the table using the
    `cursor`. You can then `commit()` the changes.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码应该很熟悉。它首先连接到 Python 空间数据库，获取一个 `cursor`，然后创建一个包含 `id` 和 `geometry` 类型位置的表。你应该导入
    `shapely LineString` 和 `MultiLine`，`MultiLine` 是为了你可以在 Jupyter notebook 中打印出这些线。你应该创建一个
    `lines` 的数组，然后遍历它们，使用 `cursor` 将每个插入到表中。然后你可以 `commit()` 这些更改。
- en: 'To see that the lines have been added to the database, you can execute the
    following code:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看是否已将行添加到数据库中，你可以执行以下代码：
- en: '[PRE37]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The previous code executes a basic select statement on the new table. There
    should be three records in the result set, as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码在新的表上执行了一个基本的 `SELECT` 语句。结果集应该有三条记录，如下所示：
- en: '[PRE38]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'If you print the `mls` variable (the variable holding a multilinestring in
    the earlier code) you can see the lines which are shown in the following image:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打印 `mls` 变量（在早期代码中持有多线字符串的变量），你可以看到以下图像中显示的线：
- en: '![](img/0666d28c-66e1-43e3-9feb-9f9dc54ef43b.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0666d28c-66e1-43e3-9feb-9f9dc54ef43b.png)'
- en: Now that you have a database table with a few lines, you can proceed to measure
    them and find out if they intersect.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经有一个包含几条线的数据库表，你可以继续测量它们并找出它们是否相交。
- en: Length of a line
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线的长度
- en: Points have no length and if they intersect, they have the same coordinates.
    Lines, however, have a length and can intersect at a point not specified in the
    table, between two of the points used to create the line.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 点没有长度，如果它们相交，它们有相同的坐标。然而，线有长度，并且可以在表中未指定的点上相交，或者在创建线的两个点之间。
- en: 'The following code will return the length of all of the `lines`:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将返回所有 `lines` 的长度：
- en: '[PRE39]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The previous code uses the `ST_Length` function. The function will accept both
    geometry and geography. In this example, `::geography` was used to convert the
    geometry so meters would be returned.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码使用了 `ST_Length` 函数。该函数将接受几何体和地理体。在这个例子中，使用了 `::geography` 将几何体转换，以便返回米。
- en: 'The results are as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '[PRE40]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'You can add an `ORDER BY` clause to the previous query and the database will
    return the `lines` from shortest to longest. The following code adds the clause:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在之前的查询中添加一个 `ORDER BY` 子句，数据库将按从短到长的顺序返回 `lines`。以下代码添加了该子句：
- en: '[PRE41]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Adding `ORDER BY` will return the records, swapping the position of `2` and
    `3`, as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 添加 `ORDER BY` 将返回记录，交换 `2` 和 `3` 的位置，如下所示：
- en: '[PRE42]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Intersecting lines
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相交的线
- en: You know the length of the `lines`, and by drawing the `lines` in a Jupyter
    Notebook, you know that `lines 1` and `lines 3` intersect. In PostGIS, you can
    use the `ST_Intersects()` function, passing either geometries or geographies.
    The database will return either true or false.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道`lines`的长度，通过在Jupyter Notebook中绘制`lines`，你知道`lines 1`和`lines 3`相交。在PostGIS中，你可以使用`ST_Intersects()`函数，传递几何体或地理体。数据库将返回`true`或`false`。
- en: 'The following code will execute the query on `lines 1` and `lines 3` and return
    `True`:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将在`lines 1`和`lines 3`上执行查询并返回`True`：
- en: '[PRE43]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The previous code will return `True`, because `lines 1` and `lines 3` intersect.
    But where do they intersect? Using `ST_Intersection()` will return to the point
    where the two `lines` meet:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码将返回`True`，因为`lines 1`和`lines 3`相交。但它们在哪里相交？使用`ST_Intersection()`将返回两条`线`相遇的点：
- en: '[PRE44]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'By switching from `ST_Intersects` to `ST_Intersection`, you get a point of
    contact between the two `lines`. The point is as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 通过从`ST_Intersects`切换到`ST_Intersection`，你将得到两条`线`之间的接触点。该点如下：
- en: '[PRE45]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Polygons in the database
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库中的多边形
- en: 'You can also store polygons using PostGIS. The following code will create a
    new table with a single polygon:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用PostGIS存储多边形。以下代码将创建一个包含单个多边形的新表：
- en: '[PRE46]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The previous code is almost identical to the `Point` and `Line` examples. Make
    the database connection and then get a `cursor`. Use `execute()` to create the
    table. Import `shapely`, construct your geometry and insert it into the table.
    Lastly, `commit()` the changes.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码几乎与`Point`和`Line`示例相同。建立数据库连接，然后获取一个`cursor`。使用`execute()`创建表。导入`shapely`，构建你的几何体并将其插入到表中。最后，`commit()`更改。
- en: 'The previous examples selected everything from the database and drew the geometry
    in the Jupyter Notebook. The following code will skip those steps and instead
    return to the area of the polygon:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的示例从数据库中选择了所有内容，并在Jupyter Notebook中绘制了几何体。以下代码将跳过这些步骤，而是返回到多边形的区域：
- en: '[PRE47]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Using `ST_Area()` and the geometry cast to geography, the previous code should
    return the following value in meters squared:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ST_Area()`和将几何体转换为地理体的方法，之前的代码应该返回以下平方米值：
- en: '[PRE48]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Now that you know there is a polygon in the table, you can learn how to search
    for a point within a polygon.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道表中有一个多边形，你可以学习如何在多边形内搜索一个点。
- en: Point in polygon
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 点在多边形内
- en: One of the most common problems is trying to determine whether a point is in
    the polygon. To solve this problem with PostGIS, you can use `ST_Contains` or
    `ST_Intersects`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的问题之一是试图确定一个点是否在多边形内。要使用PostGIS解决这个问题，你可以使用`ST_Contains`或`ST_Intersects`。
- en: '`St_Contains` takes two geometries and determines whether the first contains
    the second.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`St_Contains`接受两个几何体并确定第一个是否包含第二个。'
- en: The order matters—*a* contains *b*, which is the opposite of `ST_Within`, which
    uses the order *b*, *a*.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 顺序很重要——*a* 包含 *b*，这与使用顺序 *b*，*a* 的 `ST_Within` 相反。
- en: 'By using contains, no part of geometry *b* can be outside of geometry *a*.
    The following code solves a **point in polygon** (**PIP**) problem:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 使用包含时，几何体 *b* 的任何部分都不能在几何体 *a* 之外。以下代码解决了一个**点在多边形内**（**PIP**）问题：
- en: '[PRE49]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The previous code creates a point and then uses `ST_Contains(polygon,point)`
    and returns `True`. The point is in the polygon. You can use `ST_Contains` with
    any other valid geometry. Just remember, it must contain the entire geometry to
    be true.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码创建了一个点，然后使用`ST_Contains(polygon,point)`并返回`True`。该点位于多边形内。你可以使用`ST_Contains`与任何其他有效几何体。只需记住，它必须包含整个几何体才能为真。
- en: Another method to determine whether a point is in a polygon is by using `ST_Intersects`.
    `ST_Intersects` will return true if the point, or any other geometry, overlaps,
    touches, or is within the polygon. `ST_Intersects` can take either a geometry
    or a geography.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 判断一个点是否在多边形内的另一种方法是使用`ST_Intersects`。如果点或任何其他几何体与多边形重叠、接触或位于多边形内，`ST_Intersects`将返回`True`。`ST_Intersects`可以接受几何体或地理体。
- en: 'The following code will perform a PIP using `ST_Intersects`:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将使用`ST_Intersects`执行一个PIP：
- en: '[PRE50]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The previous code only differs from the `ST_Contains` example by the function
    that was used and that geometry was used. It also returns `True`. When using a
    polygon and a line, `ST_Intersects` will return true if any part of the line touches
    or is within the polygon. This differs from `ST_Contains`.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码仅与`ST_Contains`示例中的函数不同，使用了几何体，并且返回`True`。当使用多边形和线时，如果线的任何部分接触到或位于多边形内，`ST_Intersects`将返回`True`。这与`ST_Contains`不同。
- en: 'Using `ST_Intersection`, you can get the geometry that represents the intersection.
    In the `lines` example earlier, it was a point. In the case of a polygon and a
    line, which I will show later on, it will be a line. The following code uses `ST_Intersection`
    to get the `LineString` that intersects with the polygon:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ST_Intersection`，你可以获取表示交集的几何形状。在前面提到的`lines`例子中，它是一个点。在多边形和线的例子中，我将稍后展示，它将是一条线。以下代码使用`ST_Intersection`来获取与多边形相交的`LineString`：
- en: '[PRE51]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The previous code is almost identical to the preceding example, except we used
    intersection versus intersects. The result is the `LINESTRING`:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码几乎与前面的例子相同，只是我们使用了intersection（交集）与intersects（相交）的区别。结果是得到一个`LINESTRING`：
- en: '[PRE52]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Summary
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter covered the installation of PostgreSQL and PostGIS as well as `psycogp2`
    and Shapely. Then, we gave a brief overview of the major functions used when working
    with a spatial database. You should now be familiar with connecting to the database,
    executing queries to insert data, and how to get your data out. Furthermore, we
    covered functions that return new geometries, distances, and areas of geometry.
    Understanding how these functions work should allow you to read the PostGIS documents
    and be comfortable with forming the SQL statement for that function.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了PostgreSQL和PostGIS的安装，以及`psycogp2`和Shapely。然后，我们简要概述了在处理空间数据库时使用的的主要功能。你现在应该熟悉连接到数据库、执行插入数据的查询以及如何获取你的数据。此外，我们还介绍了返回新几何形状、距离和几何形状面积的功能。了解这些函数的工作原理应该允许你阅读PostGIS文档，并熟悉为该函数形成SQL语句。
- en: In the next chapter, you will learn about the major data types in GIS and how
    to use Python code libraries to read and write geospatial data. You will learn
    how to convert between data types, and how to upload and download data from geospatial
    databases and remote data sources.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习GIS中的主要数据类型以及如何使用Python代码库读取和写入地理空间数据。你将学习如何在数据类型之间进行转换，以及如何从地理空间数据库和远程数据源上传和下载数据。
