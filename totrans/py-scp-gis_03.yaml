- en: Introduction to Geospatial Databases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, you learned how to set up your Python environment
    and learned about the different libraries available for working with geospatial
    data using Python. In this chapter, you will start working with data.
  prefs: []
  type: TYPE_NORMAL
- en: Databases provide one of the most popular ways to store large amounts of data,
    and one of the most popular open source databases is PostgreSQL. PostGIS extends
    PostgreSQL, adding geographic objects and the ability to query records spatially.
    When PostgreSQL and PostGIS are combined, they create a powerful geospatial data
    repository.
  prefs: []
  type: TYPE_NORMAL
- en: Geospatial databases improve on basic relational database queries by allowing
    you to query your data by location or by location to other features in the database.
    You can also perform geospatial operations such as measurements of features, distances
    between features, and converting between projections. Another feature of geospatial
    databases is the ability to create new geometries from existing features from
    a buffer, union, or clip operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the basics of geospatial databases. In this chapter,
    you will learn:'
  prefs: []
  type: TYPE_NORMAL
- en: How to install PostgreSQL and PostGIS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to install and use `pyscopg2` to connect to the database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to add data to a database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to perform basic spatial queries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to query length and area
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to query for points within a polygon
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In [Chapter 7](4f2388a3-51fc-419f-a827-bbbedbbb6374.xhtml), *Geoprocessing with
    Geodatabases*, we will come back to geospatial databases and you will learn more
    advanced operations and how to display your data.
  prefs: []
  type: TYPE_NORMAL
- en: Installing PostgreSQL and PostGIS on Windows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can install PostGIS by installing PostgreSQL and then install PostGIS afterwards,
    or you can install PostgreSQL and then use Stack Builder, which comes with PostgreSQL,
    afterwards to add PostGIS. Using Stack Builder allows you to download the desired
    PostgreSQL version and with a single-click also get the correct PostGIS version.
  prefs: []
  type: TYPE_NORMAL
- en: When I installed PostgreSQL 10, Stack Builder did not include PostGIS. By the
    time of publication, this should have been added. Screenshots may show a different
    PostGIS version because I used an old copy of PostgreSQL to show how Stack Builder
    would work. You can download PostgreSQL from [https://www.postgresql.org/download/](https://www.postgresql.org/download/).
  prefs: []
  type: TYPE_NORMAL
- en: 'As we proceed, I will walk you through installing PostgreSQL and then using
    Stack Builder to add PostGIS and a database. After downloading the executable,
    run it by double-clicking it. You will see the wizard as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ab1d1019-4b54-42a0-b5f1-1f1cd85528fd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can choose where to install PostgreSQL, but it is probably best to leave
    it as the default unless you have a specific reason to locate it elsewhere:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/55e727f4-2062-405e-827f-12598859f6e4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Again, it is probably best to store the data in the default location, which
    is the same root folder as the PostgreSQL installation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f3ad5f9c-1140-4863-8b4b-eb17aad3b1dd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Select the port in which you would like to run PostgreSQL. Applications will
    expect to find PostgreSQL on this port, so change it at your own risk. More advanced
    users can reconfigure port channels in the `.config` file after installation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c44ddd31-b32a-4e4a-8e34-45d9aafc8ff5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Choose your Locale, or select the default. I have selected English, United
    States:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2c973abd-7587-4120-8f29-3d154b0424f0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This is where you are presented with the option to launch Stack Builder, and
    from there, you can install PostGIS. Check the box to begin the installation.
    The installation should only take a few minutes on a newer system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bea74fd6-ecc5-4a10-ab1d-cf225d5d2536.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The PostgreSQL installation has been completed and Stack Builder should now
    be open. Under Spatial Extensions, select the proper version of PostGIS 32 or
    64-bit. Notice that it is a bundle and includes other packages such as `pgRouting`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e83cd2ff-7710-4050-ae93-9ee1b98b3cd7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, the install wizard for PostGIS will launch. You have to agree to the terms
    of the license:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/900c8a5c-cc61-4955-a87a-92dc35c9a693.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can create a database at any time and this chapter will show you how to,
    however, it is best to check the Create spatial database box and take care of
    it now. If you do, your database will be set up and ready to use once PostGIS
    is installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/06694412-cd98-4d7a-a14c-d28b0adfe055.png)'
  prefs: []
  type: TYPE_IMG
- en: 'PostGIS will try to install where PostgreSQL was installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/61781c67-8d35-4f74-bf14-006be7dcbbef.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Enter the username, password, and port for the database. The examples in this
    chapter will use `postgres` (username) and `postgres` (password). If you select
    a different username and password combination, remember it. In production, it
    is best not to use default usernames and passwords as they are well-known and
    will make you an easy target for hackers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e3b4d560-53a9-4022-9b3f-f697fe853839.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Enter the name for the database. The examples we will be looking at will use
    `pythonspatial` as the database name. You will only use the name for the initial
    connection. The SQL queries in the example will use the table name:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b3471575-a2cc-4130-bf5a-5fdcf4ee5b06.png)'
  prefs: []
  type: TYPE_IMG
- en: Installing PostgreSQL and PostGIS on Mac
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To install PostgreSQL and PostGIS on a Mac, you can use `Postgres.app`. You
    can download the file from [http://postgresapp.com/](http://postgresapp.com/).
    After the file has downloaded, move it to the `applications` folder and double-click
    it. Click Initialize. You will have a server on `localhost:5432`. The username
    and database name is the same as your Mac user. There is no password.
  prefs: []
  type: TYPE_NORMAL
- en: You should then be able to use the `psql` commands to create a new database
    and enable PostGIS.
  prefs: []
  type: TYPE_NORMAL
- en: Working with PostgreSQL and PostGIS using Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To connect and manipulate your PostgreSQL database in Python, you will need
    a library to assist you. `psyscopg2` is that library. It provides a wrapper around
    the official `libpq` client library. In this section, we will cover how to install
    the library, how to connect to the database, and how to add a table and perform
    basic geospatial queries.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to PostgreSQL using psycopg2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`pscycopg2` is the most popular library for working with PostgreSQL in Python.
    It fully implements the Python DB API 2.0 specification and works with Python
    3\. In the following sections, you will learn how to install the library, make
    connections, execute queries, and read the results. You can read the full documentation
    here: [http://initd.org/psycopg/docs/](http://initd.org/psycopg/docs/)'
  prefs: []
  type: TYPE_NORMAL
- en: Installing psycopg2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Installing most Python libraries requires you to open your console and type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If that doesn''t work, and you are using an Anaconda Python distribution, you
    can run the `conda` command, using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'While most Python libraries can be downloaded and installed using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Since `psycopg2` is more advanced than that and requires you to have a C compiler,
    Python header files, `libpq` header files, and the `pg_config` program. If you
    need to install `psycopg2` from the source, the link to the instructions is in
    the following hint box.
  prefs: []
  type: TYPE_NORMAL
- en: To install `psycopg2` from the source, the instructions are located at: [http://initd.org/psycopg/docs/install.html#install-from-source](http://initd.org/psycopg/docs/install.html#install-from-source)
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to the database and creating a table
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You should have created a database when you installed PostGIS. For the examples
    mentioned as follows, we will use this database.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you did not create a database during the installation of PostGIS, you can
    do so using your terminal (command prompt in Windows) and the commands as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You may need to modify your path. On Windows, the command to do so is shown
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'To connect to your database, use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The code mentioned earlier starts by importing `psycopg2`. It then makes a `connection`
    by using the `connect()` function and passing the parameters for the database
    name, the `user`, and the `password`. It then creates a `cursor` which allows
    you to communicate with the database. You can use the `execute()` method of the
    `cursor` to create the table passing SQL statements as strings.
  prefs: []
  type: TYPE_NORMAL
- en: The code executes an SQL command which creates a table named `art_pieces` with
    an `id` of type `SERIAL` and makes it a `PRIMARY KEY`, `code` as type `VARCHAR`
    and a length of `255`, and the `location` as the `GEOMETRY` type. The `SERIAL
    PRIMARY KEY` tells PostgreSQL that we want an auto-incremented unique identifier.
    You can also use the `BIGSERIAL` type. The other type that is different is the `location`
    of the `GEOMETRY` type. This is the column that will hold the geo portion of our
    records.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, you `commit()` to make sure the changes are saved. You can also `close()`
    when you are finished, but we will continue further.
  prefs: []
  type: TYPE_NORMAL
- en: Adding data to the table
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we created a table. In this section, you will grab
    data from an open data site and put it on your table so that you can query it
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most cities have open data websites and portals. The City of Albuquerque has
    several ArcServer endpoints with spatial data. The following code will use the
    `requests` Python library to grab public art data and then use `psycopg2` to send
    it to the PostgreSQL database, `pythonspatial`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The code which we mentioned earlier imports `requests`, then, using the URL
    to the ArcServer endpoint, it grabs the results of a query asking for all of the
    data (`where:1=1`) and all of the fields (outFields:`*`) in **World Geodetic System**
    (**WGS**) **84** (`outSR:4326`), and returns it as a JSON (`f:json`).
  prefs: []
  type: TYPE_NORMAL
- en: ArcServer is a GIS Server made by the **Environmental Systems Research Institute**
    (**ESRI**). It provides a way to serve GIS data using an API and returning JSON.
    Many government agencies will have an Open Data Portal that utilizes an ArcServer
    to deliver the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The results are loaded into the `data` variable. Each record is in the array
    features (`data["features"][n]`). A single record, `data["features"][0]`, is shown
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: With the `data`, you will iterate through the array of `features`, inserting
    the `ART_CODE` as `code` and creating a **well-known text** (**WKT**) representation
    of each point.
  prefs: []
  type: TYPE_NORMAL
- en: To learn more about WKT, you can read its Wikipedia entry at: [https://en.wikipedia.org/wiki/Well-known_text](https://en.wikipedia.org/wiki/Well-known_text)
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows you how to insert the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code iterates through each feature. It assigns `ART_CODE` to `code`,
    then constructs the WKT `(Point(-106.5918 35.1555))`, and assigns it to `wkt`.
    The code uses `ART_CODE` to show how to load other properties into the database.
  prefs: []
  type: TYPE_NORMAL
- en: Data is almost never clean and perfect. This data is no exception. So that it
    doesn't crash when the `x` coordinate is missing, I have added an `if`*,* `else`
    statement to skip over missing data. This concept is known as **error handling**,
    and it is a best practice when constructing `requests`. The `else` statement is
    where the data gets inserted. Using `cursor.execute()`, you can construct the
    SQL query.
  prefs: []
  type: TYPE_NORMAL
- en: The query inserts `art_pieces` into the database along with the `code` and `location` fields
    with values. The first value, for `code`, is a placeholder `{}`. The second value,
    for `location`, is geometry which we stored as WKT. Because of this, it is inserted
    using the `ST_GeomFromText()` function and a placeholder `{}`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `format()` method is where you pass the variables to fill the placeholders—`code`,
    `wkt`. The following code shows what the query will look like when the placeholders
    are filled in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the previously mentioned code, you created the WKT as a concatenated string.
    This can be accomplished in a cleaner and more Pythonic fashion by using the Shapely
    library.
  prefs: []
  type: TYPE_NORMAL
- en: Shapely
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Shapely can be installed using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Or with `conda`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Shapely makes the task of creating and working with geometries easier and makes
    your code cleaner. In the previous code, you concatenated a string to create a
    WKT representation of a point. Using Shapely, you can create a point and then
    convert it to WKT. The following code shows you how:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The previous code imports `Point` and `MultiPoint` from `shapely.geometry`.
    The code is the same as the previous version until the line in bold. To create
    a point, you use `Point(x,y)` in Shapely. It put all of the points in an array
    called `thepoints` to draw them in a Jupyter Notebook, for which an image is follows.
    Lastly, the SQL statement passes `p.wkt` to `ST_GeomFromText()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a Jupyter Notebook, you can print Shapely geometry just by typing the name
    of the variable holding the geometry and it will draw the end. The public `art`
    points are in the variable `thepoints`*.* A `MultiPoint` can be created using
    an array of points, and printing them draws the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e5a4bd3c-a6c7-4f3c-a4c3-5240543386ea.png)'
  prefs: []
  type: TYPE_IMG
- en: Querying the data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You created a table, added columns for code and location, and populated it using
    data from another source. Now, you will learn how to query the data and get it
    out of the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'While there are spatial SQL queries available to you, you can always just select
    the data as if it were a non-spatially enabled database so that you can use it
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code shows the generic `SELECT` all query and the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The result should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The first number, `1`,`2`,n, is the `id` (the `SERIAL PRIMARY KEY`). Next, is
    the `code`. The geometry is the last column. The string of what appears to be
    random numbers and letters is a **well-known binary** (**WKB**) in hex.
  prefs: []
  type: TYPE_NORMAL
- en: 'To convert the WKB, you use `shapely`. The following code walks you through
    converting the WKB to a `shapely` `Point`, and then printing the WKT:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous code imports the `loads()` method from `shapely.wkb`. You must
    add the `hex` parameter and make it equal to `True` or you will receive an error.
    To get the geography column of the first record, you can use `data[0][2]` with
    `[0]` as the record and `[2]` as the column. Now that you have a `shapely` `Point`,
    you can verify it by using `type(aPoint)`, you can print it as a WKT using `aPoint.wkt`.
    You should see the result as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want PostgreSQL to return the data in WKB without hex, you can do so
    using `ST_AsBinary()`. The following code shows you how:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The previous code wraps the location in `ST_AsBinary()`. To load the result
    into a `shapely` `Point`, you have to use `bytes()`. Then, you can see the WKT
    using `pNoHex.wkt`. You should see the same point as in the previous example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Binary may come in handy, but you can also query the data and get the geometry
    back as a WKT:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous code uses `ST_AsText(geometry column)` to return the data as a
    WKT. You can return a column that contains geometry at any time by using `ST_AsText()`.
    Instead of `fetchall()`, the code uses `fetchone()` to grab a single record. You
    should see a single record as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'You can load WKT into a `shapely` `Point` using `loads()`, but you need to
    import it first, just like you did earlier with WKB:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The previous code import `loads` from `shapely`—but this time using `shapely.wkt`,
    not `wkb`. Otherwise, you load the data the same way as in the previous examples.
    You can see the coordinates of the `shapely` `Point` using `pb.coords[:]`, or
    you can see them individually using `pb.x` and `pb.y`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result of `pb.coords[:]` will be a coordinate pair, which is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Changing the CRS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The data in the database is using **World Geodetic System 84** (**WGS 84**),
    latitude and longitude. What if you need the data out in **European Petroleum
    Survey Group** (**EPSG**) 3857? You can change the spatial reference in your query
    using `ST_Transform()`. The following code shows you how by using PostGIS functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous code makes two queries to the database:'
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, it assigns a spatial reference system identifier to the geometry column
    in the table using `UpdateGeomtrySRID()`. This needs to be done because the points
    were put in the table without any reference to an `SRID`. So when we try to get
    the results back using a different coordinate reference system, the database will
    not know how to transform our coordinates.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Secondly, the code queries the database to tell us what the `SRID` is on the
    geometry column in the table using `Find_SRID()`. If you do not have a properly
    added geometry column, the function will fail.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that you have an `SRID` set on the column in the table, you can query the
    data and transform it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous code is a basic select `code` and `location`, as text, from `art_pieces`,
    but now there is an `ST_Transform` method. This method takes the column with geometry
    and the `SRID` you want the data sent back in. Now, the piece of art at `(-106.59,
    35.155)` is returned using `3857`, and shown as follows with the transformed coordinates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Buffer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A spatial database allows you to store spatial data, but you can also perform
    operations on the data and get different geometries back. The most common of these
    operations would be a buffer. You have a table of points, but using `ST_Buffer()`,
    you can have the database return a polygon around the point with a specified radius.
    The following code shows you how:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous code grabs a record from the table where the art code field equals
    `101`, and selects a buffer with a radius of `25` around the `location`. The result
    will be a polygon, which is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: When using geography, if the buffer is large, falls between two UTM zones, or
    crosses the dateline, it may behave unexpectedly.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'If you load the polygon into `shapely` using the following code, a Jupyter
    Notebook will draw the polygon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The buffer returned from `ST_Buffer` as a `shapely` polygon is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a0fa316c-3695-4a82-8605-b6fba19a1efc.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can also pass a parameter to `ST_Buffer` for the number of segments you
    used to draw a quarter of a circle. If you divide the circle into four quadrants,
    the `quad_segs` parameter will draw that many segments in each quadrant. A `quad_seg`
    value of 1 will draw a rotated square, which is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a47fc9b9-da9f-4b7f-8201-53e9978887b4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Whereas a `quad_seg` value of 2 would draw an octagon which is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/201ce6dd-b0b8-40fe-9947-fb0c52a40f38.png)'
  prefs: []
  type: TYPE_IMG
- en: Distance and near
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, you had the database buffer a point and return the
    polygon. In this section, you will learn how to query the database for the distance
    between two points, and you will query the database and have it return records
    based on the distance from a specified point.
  prefs: []
  type: TYPE_NORMAL
- en: 'The PostGIS function for distance is `ST_Distance(a,b)`. You can pass `a` and
    `b` as geometry or geography. As `geography`, the result will be returned in meters. The
    following code will get the distance between two points in the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The previous code executes the SQL query for `ST_Distance()`, passing the `location`
    column of `a` and `b` which are records, where the code equals `101` and `102`. `::geography`
    is how you cast a geometry to a geography in PostGIS. How far are they from each
    other? They are 9,560.45428363 meters apart.
  prefs: []
  type: TYPE_NORMAL
- en: 'To convert this to miles use: `dist[0][0]*0.00062137`, which makes them 5.940
    miles apart.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous example, you used two points from the database, but you can
    also pass a hard-coded point as in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The previous code is the same query, but this time you switch out point `b`
    (`code=102`) with a hard-coded WKT point. The results of the query should state
    that the points are 10,391.40637117 meters apart.
  prefs: []
  type: TYPE_NORMAL
- en: 'And, as in previous examples, you can also use `shapely` to pass the WKT of
    the point, as in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The previous code creates the point in `shapely` and then uses `format(p.wkt)`
    to pass the WKT to the `{}` placeholder.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can get the distance between two points, but what if you want the distance
    of more than one point from another? To do that, you can remove the `a.location`
    and just use `location` as the first point. The following code will return five
    points and their distances from the specified point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The results should look like the data showing the distance in meters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The database returned the first five points in the table with their code and
    distance from the specified point. If you remove the `LIMIT`, you will get all
    of the points.
  prefs: []
  type: TYPE_NORMAL
- en: 'By adding an `ORDER BY` clause and the k-nearest neighbor operator, you can
    extend this query to get the closest five points to the specified point. Look
    at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The key element in the previous code is the symbol `*<->*`. This is the k-nearest
    neighbor operator. It returns the distance between two geometries. Using `ORDER
    BY location <-> ST_GeometryFromText()`, you are specifying two geometries. Because
    you set a `LIMIT` of `5`, the database will return the `5` closest points to the
    one specified—including the point of origin. The results should look like the
    following points:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the code value is not `101`-`106` or the first five from the database,
    and that the distance increases from `0.0`. The closest point, code `101`, is
    the point you specified in the query, so it is `0.0` meters away.
  prefs: []
  type: TYPE_NORMAL
- en: Lines in the database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first section of this chapter focused on point operations. Now, we will
    turn our attention to lines. For the following examples, you will create a new
    table and insert three lines. The following code will accomplish that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The previous code should be familiar. It starts by connecting to the Python
    spatial database, gets a `cursor`, and then creates a table with an `id` and a
    location of the `geometry` type. You should import `shapely LineString` and `MultiLine`, `Multiline`
    is so you can print the lines in the Jupyter notebook. You should create an array
    of `lines` and then loop through them, inserting each into the table using the
    `cursor`. You can then `commit()` the changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see that the lines have been added to the database, you can execute the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous code executes a basic select statement on the new table. There
    should be three records in the result set, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'If you print the `mls` variable (the variable holding a multilinestring in
    the earlier code) you can see the lines which are shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0666d28c-66e1-43e3-9feb-9f9dc54ef43b.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that you have a database table with a few lines, you can proceed to measure
    them and find out if they intersect.
  prefs: []
  type: TYPE_NORMAL
- en: Length of a line
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Points have no length and if they intersect, they have the same coordinates.
    Lines, however, have a length and can intersect at a point not specified in the
    table, between two of the points used to create the line.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code will return the length of all of the `lines`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The previous code uses the `ST_Length` function. The function will accept both
    geometry and geography. In this example, `::geography` was used to convert the
    geometry so meters would be returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'The results are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'You can add an `ORDER BY` clause to the previous query and the database will
    return the `lines` from shortest to longest. The following code adds the clause:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding `ORDER BY` will return the records, swapping the position of `2` and
    `3`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Intersecting lines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You know the length of the `lines`, and by drawing the `lines` in a Jupyter
    Notebook, you know that `lines 1` and `lines 3` intersect. In PostGIS, you can
    use the `ST_Intersects()` function, passing either geometries or geographies.
    The database will return either true or false.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code will execute the query on `lines 1` and `lines 3` and return
    `True`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous code will return `True`, because `lines 1` and `lines 3` intersect.
    But where do they intersect? Using `ST_Intersection()` will return to the point
    where the two `lines` meet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'By switching from `ST_Intersects` to `ST_Intersection`, you get a point of
    contact between the two `lines`. The point is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Polygons in the database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can also store polygons using PostGIS. The following code will create a
    new table with a single polygon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The previous code is almost identical to the `Point` and `Line` examples. Make
    the database connection and then get a `cursor`. Use `execute()` to create the
    table. Import `shapely`, construct your geometry and insert it into the table.
    Lastly, `commit()` the changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous examples selected everything from the database and drew the geometry
    in the Jupyter Notebook. The following code will skip those steps and instead
    return to the area of the polygon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `ST_Area()` and the geometry cast to geography, the previous code should
    return the following value in meters squared:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Now that you know there is a polygon in the table, you can learn how to search
    for a point within a polygon.
  prefs: []
  type: TYPE_NORMAL
- en: Point in polygon
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most common problems is trying to determine whether a point is in
    the polygon. To solve this problem with PostGIS, you can use `ST_Contains` or
    `ST_Intersects`.
  prefs: []
  type: TYPE_NORMAL
- en: '`St_Contains` takes two geometries and determines whether the first contains
    the second.'
  prefs: []
  type: TYPE_NORMAL
- en: The order matters—*a* contains *b*, which is the opposite of `ST_Within`, which
    uses the order *b*, *a*.
  prefs: []
  type: TYPE_NORMAL
- en: 'By using contains, no part of geometry *b* can be outside of geometry *a*.
    The following code solves a **point in polygon** (**PIP**) problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The previous code creates a point and then uses `ST_Contains(polygon,point)`
    and returns `True`. The point is in the polygon. You can use `ST_Contains` with
    any other valid geometry. Just remember, it must contain the entire geometry to
    be true.
  prefs: []
  type: TYPE_NORMAL
- en: Another method to determine whether a point is in a polygon is by using `ST_Intersects`.
    `ST_Intersects` will return true if the point, or any other geometry, overlaps,
    touches, or is within the polygon. `ST_Intersects` can take either a geometry
    or a geography.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code will perform a PIP using `ST_Intersects`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The previous code only differs from the `ST_Contains` example by the function
    that was used and that geometry was used. It also returns `True`. When using a
    polygon and a line, `ST_Intersects` will return true if any part of the line touches
    or is within the polygon. This differs from `ST_Contains`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `ST_Intersection`, you can get the geometry that represents the intersection.
    In the `lines` example earlier, it was a point. In the case of a polygon and a
    line, which I will show later on, it will be a line. The following code uses `ST_Intersection`
    to get the `LineString` that intersects with the polygon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous code is almost identical to the preceding example, except we used
    intersection versus intersects. The result is the `LINESTRING`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covered the installation of PostgreSQL and PostGIS as well as `psycogp2`
    and Shapely. Then, we gave a brief overview of the major functions used when working
    with a spatial database. You should now be familiar with connecting to the database,
    executing queries to insert data, and how to get your data out. Furthermore, we
    covered functions that return new geometries, distances, and areas of geometry.
    Understanding how these functions work should allow you to read the PostGIS documents
    and be comfortable with forming the SQL statement for that function.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn about the major data types in GIS and how
    to use Python code libraries to read and write geospatial data. You will learn
    how to convert between data types, and how to upload and download data from geospatial
    databases and remote data sources.
  prefs: []
  type: TYPE_NORMAL
