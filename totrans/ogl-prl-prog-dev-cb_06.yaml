- en: Chapter 6. Developing a Sobel Edge Detection Filter
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章：开发Sobel边缘检测滤波器
- en: 'In this chapter, we''ll cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Understanding the convolution Theory
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解卷积理论
- en: Understanding convolution in 1D
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解一维卷积
- en: Understanding convolution in 2D
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解二维卷积
- en: OpenCL implementation of the Sobel edge filter
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenCL中Sobel边缘滤波器的实现
- en: Understanding profiling in OpenCL
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解OpenCL中的性能分析
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In this chapter, we are going to take a look at how to develop a popular image
    processing algorithm known as edge detection. This problem happens to be a part
    of solving a more general problem in image segmentation.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨如何开发一个流行的图像处理算法，即边缘检测。这个问题恰好是解决图像分割中更一般问题的部分。
- en: Note
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Image segmentation is the process of partitioning a digital image into multiple
    segments (sets of pixels, also known as super pixels). The goal of segmentation
    is to simplify and/or change the representation of an image into something that
    is more meaningful and easier to analyze. Image segmentation is typically used
    to locate objects and boundaries (lines, curves, and so on) in images.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 图像分割是将数字图像分割成多个段（像素集，也称为超像素）的过程。分割的目标是简化图像的表示，或将其转换为更有意义且更容易分析的形式。图像分割通常用于在图像中定位对象和边界（线条、曲线等）。
- en: The Sobel operator is a discrete differentiation operator, computing an approximation
    of the gradient of the image density function. The Sobel operator is based on
    convolving the image with a small, separable, and an integer-value filter in both
    horizontal and vertical directions. Thus, it is relatively inexpensive in terms
    of computations.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Sobel算子是一个离散微分算子，用于计算图像密度函数梯度的近似值。Sobel算子基于在水平和垂直方向上使用一个小型、可分离且具有整数值的滤波器对图像进行卷积。因此，在计算方面相对较为经济。
- en: Don't worry if you don't understand these notations right away, we are going
    to step through enough theory and math, and help you realize the application in
    OpenCL.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您一开始不理解这些符号，请不要担心，我们将逐步介绍足够的理论和数学知识，并帮助您理解在OpenCL中的应用。
- en: Briefly, the Sobel filtering is a three-step process. Two 3 x 3 filters are
    applied separately and independently on every pixel and the idea is to use these
    two filters to approximate the derivatives of x and y, respectively. Using the
    results of these filters, we can finally approximate the magnitude of the gradient.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，Sobel滤波是一个三步过程。两个3x3的滤波器分别独立地应用于每个像素，其目的是使用这两个滤波器分别近似x和y的导数。使用这些滤波器的结果，我们最终可以近似梯度的幅度。
- en: The gradient computed by running Sobel's edge detector through each pixel (which
    also uses its neighboring eight pixels) will inform us whether there are changes
    in the vertical and horizontal axes (where the neighboring pixels reside).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在每个像素（以及其相邻的八个像素）上运行Sobel边缘检测器计算出的梯度将告诉我们垂直和水平轴（相邻像素所在的位置）是否存在变化。
- en: For those who are already familiar with the convolution theory, in general,
    may skip to the *How to do it* section of this recipe.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 对于已经熟悉卷积理论的人来说，一般可以跳过本食谱的*如何操作*部分。
- en: Understanding the convolution theory
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解卷积理论
- en: In the past, mathematicians developed calculus so that there's a systematic
    way to reason about how things change, and the convolution theory is really about
    measuring how these changes affect one another. At that time, the convolution
    integral was born.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，数学家们发展了微积分，以便有一个系统的方法来推理事物变化的方式，而卷积理论实际上就是关于测量这些变化如何相互影响。那时，卷积积分应运而生。
- en: '![Understanding the convolution theory](img/4520OT_06_24.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![理解卷积理论](img/4520OT_06_24.jpg)'
- en: And the ![Understanding the convolution theory](img/4520OT_06_23.jpg) operator
    is the convolution operator used in conventional math. An astute reader will notice
    immediately that we have replaced one function with the other, and the reason
    why this is done is because of the fact that the convolution operator is commutative,
    that is, the order of computation does not matter. The computation of the integral
    can be done in discrete form, and without loss of generality, we can replace the
    integral sign ![Understanding the convolution theory](img/4520OT_06_22.jpg) with
    the summation sign ![Understanding the convolution theory](img/4520OT_06_21.jpg),
    and with that, let's see the mathematical definition of convolution in discrete
    time domain.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 并且![理解卷积理论](img/4520OT_06_23.jpg)算子是传统数学中使用的卷积算子。一个敏锐的读者会立即注意到我们用一个函数替换了另一个函数，这样做的原因是因为卷积算子是交换律的，也就是说，计算的顺序并不重要。积分的计算可以用离散形式进行，并且不失一般性，我们可以将积分符号![理解卷积理论](img/4520OT_06_22.jpg)替换为求和符号![理解卷积理论](img/4520OT_06_21.jpg)，有了这个，让我们看看离散时间域中卷积的数学定义。
- en: Getting ready
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: 'Later we will walk through what the following equation tells us over a discrete
    time domain:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 后续我们将通过以下方程式在离散时间域中了解它所传达的信息：
- en: '![Getting ready](img/4520OT_06_20.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![准备中](img/4520OT_06_20.jpg)'
- en: where *x[n]* is an input signal, *h[n]* is an impulse response, and *y[n]* is
    the output. The asterisk (***) denotes convolution. Notice that we multiply the
    terms of *x[k]* by the terms of a time-shifted *h[n]* and add them up. The key
    to understanding convolution lies behind impulse response and impulse decomposition.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *x[n]* 是输入信号，*h[n]* 是脉冲响应，*y[n]* 是输出。星号（***）表示卷积。请注意，我们将 *x[k]* 的项与时间移位的
    *h[n]* 的项相乘并求和。理解卷积的关键在于脉冲响应和脉冲分解。
- en: How to do it…
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: In order to understand the meaning of convolution, we are going to start from
    the concept of signal decomposition. The input signal can be broken down into
    additive components, and the system response of the input signal results in by
    adding the output of these components passed through the system.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解卷积的意义，我们将从信号分解的概念开始。输入信号可以被分解为加性成分，而输入信号的系统响应是通过将这些成分的输出通过系统相加得到的。
- en: The following section will illustrate on how convolution works in 1D, and once
    you're proficient in that, we will build on that concept and illustrate how in
    convolution works 2D and we'll see the Sobel edge detector in action!
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分将说明一维卷积是如何工作的，一旦你精通这个概念，我们将在此基础上说明二维卷积是如何工作的，并且我们将看到Sobel边缘检测器的作用！
- en: Understanding convolution in 1D
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解一维卷积
- en: Let's imagine that a burst of energy (signal) have arrived into our system and
    it looks similar to the following diagram with *x[n] = {1,3,4,2,1}, for n = 0,1,2,3,4*.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象一下，一股能量（信号）已经进入我们的系统，它看起来与以下图示相似，其中 *x[n] = {1,3,4,2,1}, for n = 0,1,2,3,4*。
- en: '![Understanding convolution in 1D](img/4520OT_06_01.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![理解一维卷积](img/4520OT_06_01.jpg)'
- en: And let's assume that our impulse function has a non-zero value whenever **n**
    = **0** or **1**, while it'll have a zero value for all other values of **n**.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的脉冲函数在 **n** = **0** 或 **1** 时具有非零值，而对于其他所有 **n** 的值，它将具有零值。
- en: How to do it...
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Using the preceding information, let''s work out what the output signal would
    be by quickly recalling the following equation:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面的信息，让我们通过快速回忆以下方程来计算输出信号：
- en: '![How to do it...](img/4520OT_06_19.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/4520OT_06_19.jpg)'
- en: 'Following this equation faithfully, we realize that the output signal is amplified
    initially and quickly tapers off, and after solving this manually (yes, I mean
    evaluating the equation on a pencil and paper) we would see the following final
    output signal:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 严格遵循此方程，我们发现输出信号最初被放大，然后迅速衰减，并且通过手动求解（是的，我是指在铅笔和纸上评估方程）我们将会看到以下最终的输出信号：
- en: '![How to do it...](img/4520OT_06_18.jpg)![How to do it...](img/4520OT_06_02.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/4520OT_06_18.jpg)![如何操作...](img/4520OT_06_02.jpg)'
- en: How it works…
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作…
- en: 'Looking at the preceding equation again, this time we rearrange them and remove
    all terms that evaluate to zero. Let''s try to see whether we can discover a pattern:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 再次查看前面的方程，这次我们重新排列它们并删除所有评估为零的项。让我们尝试看看是否可以发现一个模式：
- en: '![How it works…](img/4520OT_06_17.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作…](img/4520OT_06_17.jpg)'
- en: 'And I believe you can see that each output value is computed from its previous
    two output values (taking into account the impulse function)! And now we may conclude,
    quite comfortably, that the general formula for computing the convolution in 1D
    is in fact the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信你可以看到每个输出值都是从前两个输出值（考虑到脉冲函数）计算出来的！现在我们可以相当舒适地得出结论，计算一维卷积的一般公式实际上是以下这个：
- en: '![How it works…](img/4520OT_06_16.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作…](img/4520OT_06_16.jpg)'
- en: Finally, you should be aware that (by convention) any value that is not defined
    for any *x[i-k]* is automatically given the value zero. This seemingly small,
    subtle fact will play a role in our eventual understanding of the Sobel edge detection
    filter which we'll describe next.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你应该意识到（按照惯例），任何未定义的*x[i-k]*的值都会自动赋予零。这个看似微小、微妙的事实将在我们最终理解Sobel边缘检测滤波器中发挥作用，我们将在下一节描述。
- en: 'Finally for this section, let''s take a look at how a sequential convolution
    code in 1D might look like:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于本节，让我们看看一维序列卷积代码可能是什么样的：
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Examining the code again, you will probably notice that we are iterating over
    the 1D array and the most interesting code would be in `statement 1`, as this
    is where the action really lies. Let's put that new knowledge aside and move on
    to extending this to a 2D space.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 再次检查代码，你可能会注意到我们正在遍历一维数组，最有趣的代码会在`语句1`中，因为这里才是真正的动作所在。让我们把新的知识放一边，继续扩展到二维空间。
- en: Understanding convolution in 2D
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解二维卷积
- en: Convolution in 2D is actually an extension of the previously described *Understanding
    convolution in 1D* section, and we do so by computing the convolution in two dimensions.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 二维卷积实际上是之前描述的*理解一维卷积*部分的扩展，我们通过在两个维度上计算卷积来实现这一点。
- en: Getting ready
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The impulse function also exists in a 2D spatial domain, so let's call this
    function. *b[x,y]* has the value 1, where x and y are zero, and zero where x,y¹0\.
    The impulse function is also referred to as filter or kernel when it's being used
    in image processing.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 脉冲函数也存在于二维空间域中，所以让我们称这个函数为*b[x,y]*，当x和y为零时，其值为1，而当x,y不为零时，其值为零。当在图像处理中使用时，脉冲函数也被称为滤波器或核。
- en: How to do it…
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: Using the previous example as a guide, let's start thinking from the perspective
    of a signal which can be decomposed into the sum of its components and impulse
    functions, and their double summation accounts to the fact that this runs over
    both vertical and horizontal axes in our 2D space.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 以之前的例子为指南，让我们从信号的角度思考，该信号可以被分解为其组成部分和脉冲函数的总和，它们的双和解释了为什么这个操作在二维空间中的垂直和水平轴上运行。
- en: '![How to do it…](img/4520OT_06_15.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![如何做…](img/4520OT_06_15.jpg)'
- en: Next, I think it's very helpful if we use an example to illustrate how it works
    when we have two convolution kernels to represent the filters we like to apply
    on the elements in a 2D array. Let's give them names, **Sx** and **Sy**. The next
    thing is to try out how the equation would develop itself in a 2D setting, where
    the element we want to convolve is at *x[1,1]* and we make a note of its surrounding
    eight elements and then see what happens.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我认为如果我们用一个例子来说明当我们有两个卷积核来表示我们想在二维数组中的元素上应用的过滤器时，这会非常有帮助。让我们给他们起个名字，**Sx**和**Sy**。接下来要做的是尝试在二维环境中方程会如何发展，其中我们想要卷积的元素位于*x[1,1]*，然后我们记录其周围的八个元素，然后看看会发生什么。
- en: If you think about why we are choosing the surrounding eight elements, it's
    the only way we can measure how big a change is with respect to every other element.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你思考一下为什么我们选择周围的八个元素，这是我们能测度相对于其他每个元素变化大小的唯一方式。
- en: '![How to do it…](img/4520OT_06_14.jpg)![How to do it…](img/4520OT_06_03.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![如何做…](img/4520OT_06_14.jpg)![如何做…](img/4520OT_06_03.jpg)'
- en: 'Let''s give it a go:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试试看：
- en: '![How to do it…](img/4520OT_06_13.jpg)![How to do it…](img/4520OT_06_12.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![如何做…](img/4520OT_06_13.jpg)![如何做…](img/4520OT_06_12.jpg)'
- en: This results in the summation of nine elements (including the element we're
    interested in), and this process is repeated for all elements in the 2D array.
    The following diagram illustrates how convolution in 2D works in a 2D space.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致九个元素（包括我们感兴趣的元素）的总和，这个过程会重复应用于二维数组中的所有元素。以下图表说明了二维空间中二维卷积是如何工作的。
- en: Note
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You may wish to read Irwin Sobel's 1964 original doctoral thesis since he's
    the inventor, and this author had a good fortune of meeting the man himself.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望阅读Irwin Sobel于1964年的原始博士论文，因为他是发明者，而且这位作者有幸亲自见到这个人。
- en: What happens when you attempt to convolve around the elements that border the
    2D array or in image processing, are they referred to as edge pixels? If you use
    this formula for computation, you will notice that the results will be inaccurate,
    because those elements are undefined and hence they're in general discounted from
    the final computation. In general, you can imagine a 3 x 3 filtering operation
    being applied to each element of the 2D array and all such computations will result
    in a new value for that element in the output data array.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当你尝试在二维数组边缘的元素周围进行卷积或在图像处理中，它们被称为边缘像素吗？如果你使用这个公式进行计算，你会注意到结果将不准确，因为这些元素是未定义的，因此它们通常从最终计算中省略。一般来说，你可以想象一个3
    x 3的滤波操作被应用于二维数组的每个元素，所有这些计算都将导致输出数据数组中该元素的新的值。
- en: Next, you may wonder what is being done to this output array? Remember that
    this array now contains values, which basically shows how big is the change detected
    in a particular element is. And when you obtain a bunch of them in the vicinity,
    then it usually tells you major color changes, that is, edges.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你可能想知道对这个输出数组做了什么？记住，这个数组现在包含值，这基本上显示了在特定元素中检测到的变化有多大。当你在一群附近获得这些值时，通常告诉你主要颜色变化，即边缘。
- en: '![How to do it…](img/4520OT_06_04.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![如何做…](img/4520OT_06_04.jpg)'
- en: How it works…
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: With this understanding, you can probably begin to appreciate why we took this
    effort to illustrate the theory behind a concept.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种理解，你可能开始欣赏我们为什么努力说明概念背后的理论。
- en: When you want to build non-trivial OpenCL applications for your customers, one
    of the things you have to deal with is learning how to interpret a problem and
    convert it to a solution. And what that means is mostly about formulating an algorithm
    (or picking existing algorithms to suit your case) and verifying that it works.
    Most of the problems you're likely to encounter are going to involve some sort
    of mathematical understanding and your ability to learn about it. You should treat
    this as an adventure!
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想为你的客户构建非平凡的OpenCL应用程序时，你必须处理的一件事是学习如何解释问题并将其转换为解决方案。这意味着主要是关于制定算法（或选择适合你情况的现有算法）并验证它是否有效。你可能会遇到的大部分问题都将涉及某种数学理解以及你学习它的能力。你应该把它当作一次冒险！
- en: 'Now that we''ve armed ourselves with what convolution is in a 2D space, Let''s
    begin by taking a look at how convolution in 2D would work in regular C/C++ code
    with the following snippet:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了二维空间中的卷积是什么，让我们首先看看在常规C/C++代码中二维卷积是如何工作的，以下是一个代码片段：
- en: '[PRE1]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This implementation is probably the most direct for the purpose of understanding
    the concept, although it may not be the fastest (since it's not many-core aware).
    But it works, as there are conceptually two major loops where the two outer `fo`r
    loops are for iterating over the entire 2D array space, while the two inner `for`
    loops are for iterating the filter/kernel over the element, that is, convoluting
    and storing the final value into an appropriate output array.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这种实现可能是理解概念最直接的方法，尽管它可能不是最快的（因为它不是多核感知的）。但是它有效，因为从概念上讲有两个主要的循环，其中两个外部的`for`循环用于遍历整个2D数组空间，而两个内部的`for`循环用于遍历元素上的滤波器/内核，即进行卷积并将最终值存储到适当的输出数组中。
- en: Putting on our parallel algorithm developer hat now, we discover that `statement
    1` appears to be a nice target for work items to execute over. Next, let's take
    a look at how we can take what we've learnt and build the same program in OpenCL.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们戴上并行算法开发者的帽子，我们发现`语句1`似乎是一个很好的工作项执行目标。接下来，让我们看看我们如何利用所学知识在OpenCL中构建相同的程序。
- en: OpenCL implementation of the Sobel edge filter
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Sobel边缘滤波器的OpenCL实现
- en: Now that you've been armed with how convolution actually works, you should be
    able to imagine how our algorithm might look like. Briefly, we will read an input
    image assuming that it's going to be in the Windows BMP format.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了卷积的实际工作原理，你应该能够想象我们的算法可能的样子。简而言之，我们将读取一个输入图像，假设它将以Windows BMP格式存在。
- en: Getting ready
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Next we'll construct the necessary data structures for transporting this image
    file in the OpenCL device for convolution, and once that's done we'll read and
    write the data out to another image file, so that we can compare the two.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将构建必要的用于在OpenCL设备上传输此图像文件以进行卷积的数据结构，一旦完成，我们将读取并写入数据到另一个图像文件，这样我们就可以比较这两个文件。
- en: Note
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Optionally, you can choose to implement this using the `clCreateImage(...)`
    APIs provided by OpenCL, and we'll leave it as an exercise for the reader to make
    the attempt.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 可选地，你可以选择使用 OpenCL 提供的 `clCreateImage(...)` API 来实现这一点，我们将把这个尝试留给读者作为练习。
- en: In the following sections, you will be shown with an implementation from what
    is translated, what we have learnt so far. It won't be the most efficient algorithm,
    and that's really not our intention here. Rather, we want to show you how you
    can get this done quickly and we'll let you inject those optimizations which include
    the not withstanding, following data binning, data tiling, shared memory optimization,
    warp / wavefront-level programming, implementing 2D-convolution using fast fourier
    transformations, and so many other features.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，你将看到从翻译的内容中，我们学到了什么。这不会是最有效的算法，这真的不是我们的目的。相反，我们想展示你如何快速完成这项工作，我们将让你注入那些优化，包括但不限于以下数据分箱、数据分块、共享内存优化、warp
    / wavefront 级编程、使用快速傅里叶变换实现 2D 卷积，以及许多其他特性。
- en: Tip
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: A possible avenue from where I derived a lot of the latest techniques about
    solving convolution was by reading academic research papers published by AMD and
    NVIDIA, and also by visiting [gpgpu.org](http://gpgpu.org), [developer.amd.com](http://developer.amd.com),
    [developer.nvidia.com](http://developer.nvidia.com), and [developer.intel.com](http://developer.intel.com).
    Another good resource I can think of are books on image processing and computer
    vision from your favorite local bookstores. Also, books on processor and memory
    structure released by Intel are also good resources if you like.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我从阅读 AMD 和 NVIDIA 发布的学术论文以及访问 [gpgpu.org](http://gpgpu.org)、[developer.amd.com](http://developer.amd.com)、[developer.nvidia.com](http://developer.nvidia.com)
    和 [developer.intel.com](http://developer.intel.com) 中获得了许多关于解决卷积的最新技术。另一个我可以想到的好资源是你最喜欢的当地书店关于图像处理和计算机视觉的书籍。如果你喜欢，英特尔发布的关于处理器和内存结构的书籍也是很好的资源。
- en: How to do it…
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'We only show the code for the kernel found in `Ch6/sobelfilter/sobel_detector.cl`,
    since this is where our algorithm translation will reach its Xenith. And we''ve
    not shown the host code in `Ch6/sobelfilter/SobelFilter.c`, since we believe that
    you would be confident to know what typically resides in there:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只展示了位于 `Ch6/sobelfilter/sobel_detector.cl` 中的内核代码，因为我们的算法翻译将在这里达到顶峰。我们没有展示位于
    `Ch6/sobelfilter/SobelFilter.c` 中的主机代码，因为我们相信你会有信心知道那里通常有什么：
- en: '[PRE2]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'An astute reader will probably figure out by reading the code, that the derived
    values for `Gx` and `Gy` should have been as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一个敏锐的读者通过阅读代码可能会发现，`Gx` 和 `Gy` 的导出值应该是以下这样：
- en: '[PRE3]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: But since we know their values will be zero, there is no need for us to include
    the computation inside it. Although we did, it's really a minor optimization.
    It shaved off some GPU processing cycles!
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 但因为我们知道它们的值将是零，所以我们不需要在它里面包含计算。尽管我们确实做了，但这实际上是一个小的优化。它减少了 GPU 处理周期！
- en: 'As before, the compilation steps are similar to that in `Ch6/sobelfilter/SobelFilter.c`
    with the following command:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，编译步骤与 `Ch6/sobelfilter/SobelFilter.c` 中的类似，以下命令：
- en: '[PRE4]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: To execute the program, simply execute the executable file (`SobelFilter`) on
    the `Ch6/sobelfilter` directory, and an output image file named `OutputImage.bmp`
    would be presented (it's the output of reading in `InputImage.bmp` and conducting
    the convolution process against it).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行程序，只需在 `Ch6/sobelfilter` 目录下执行可执行文件（`SobelFilter`），就会呈现一个名为 `OutputImage.bmp`
    的输出图像文件（它是读取 `InputImage.bmp` 并对其执行卷积过程的输出）。
- en: The net effect is that the output contains an image that outlines the edges
    of the original input image, and you can even refer to the picture images in the
    *How it works…* section of this recipe to see how these two images are different
    from one another.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的效果是输出包含了一个描绘原始输入图像边缘的图像，你甚至可以参考本食谱中 *如何工作…* 部分的图片来查看这两个图像之间的不同。
- en: How it works…
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作…
- en: At first, we create a representation of a pixel to represent each of the channels
    in the RGBA fashion. That structure is given a simple name, `uchar4`, where it
    consists of four unsigned char data types which will correctly represent each
    color's range from [0..255] or [0x00..0xFF], since that's how each color's range
    is defined by convention.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个像素表示来代表 RGBA 格式中的每个通道。这个结构被赋予了一个简单的名字，`uchar4`，它由四个无符号 char 数据类型组成，这将正确地表示每个颜色的范围从
    [0..255] 或 [0x00..0xFF]，因为这是每个颜色范围的传统定义方式。
- en: We omit the description of the mechanism behind pulling the pixel information
    from the input image to how we construct the final in-memory representation of
    the image. Interested readers can search on the Internet regarding the Windows
    BMP format to understand how we parse the image data or read the source code in
    the `bmp.h` file via the `load` function, and we write out the image using the
    `write` function.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们省略了从输入图像中提取像素信息背后的机制描述，到我们如何构建图像在内存中的最终表示。感兴趣的读者可以在互联网上搜索有关Windows BMP格式的信息，以了解我们如何解析图像数据或通过`load`函数读取`bmp.h`文件中的源代码，我们使用`write`函数写入图像。
- en: Skipping the OpenCL device memory allocation, since that by now is standard
    fare we arrived quickly at the portion where we look at how the kernel processes
    each pixel of the input data.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 跳过OpenCL设备内存分配的描述，因为到目前为止这是标准操作，我们迅速到达了查看内核如何处理输入数据每个像素的部分。
- en: 'Before we do that, let''s quickly recall from the kernel launching code how
    many global work-items have been assigned and whether the work-group composition
    is like:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们这样做之前，让我们快速回顾内核启动代码，看看分配了多少全局工作项，以及工作组组成是否如下：
- en: '[PRE5]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`localThreads` is configured to have work-groups of sizes {256,1}, work-items
    processing a portion of the input 2D image data array.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`localThreads`被配置为具有大小为{256,1}的工作组，工作项处理输入2D图像数据数组的一部分。'
- en: When the image is loaded into the device memory, the image is processed in blocks.
    Each block has a number of work-items or threads if you process the image. Each
    work-item proceeds the next to perform the convolution process on the center of
    the pixel and also on its eight neighbors. The resultant value generated by each
    work-item will be outputed as pixel value into the device memory. Pictorially,
    the following diagram illustrates what a typical work-item will perform.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当图像被加载到设备内存中时，图像以块的形式进行处理。如果处理图像，每个块包含一定数量的工作项或线程。每个工作项接着执行，对像素中心及其八个邻居执行卷积过程。每个工作项生成的结果值将被输出为像素值到设备内存中。直观地，以下图示说明了典型工作项将执行的操作。
- en: Tip
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You need to watch out and that is we actually used the data type conversion
    function, `convert_float4` to apply our unsigned char data values encapsulated
    within each pixel, which effectively widens the data type so that it doesn't overflow
    when the Sobel operator is applied on them.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要注意，我们实际上使用了数据类型转换函数`convert_float4`来应用封装在每个像素中的无符号char数据值，这有效地扩展了数据类型，以便在应用Sobel算子时不会溢出。
- en: Finally, once we have the masked the values we need to compute the magnitude
    of this gradient and the standard way of computing that is to apply ![How it works…](img/4520OT_06_12a.jpg)
    where **Gx** = ![How it works…](img/4520OT_06_11.jpg) and **Gy** = ![How it works…](img/4520OT_06_10.jpg).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一旦我们获得了所需的掩码值，我们需要计算这个梯度的幅度，计算该幅度的标准方法是将![如何工作…](img/4520OT_06_12a.jpg)应用于其中**Gx**
    = ![如何工作…](img/4520OT_06_11.jpg)和**Gy** = ![如何工作…](img/4520OT_06_10.jpg)。
- en: '![How it works…](img/4520OT_06_05.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作…](img/4520OT_06_05.jpg)'
- en: Whether this algorithm works, the only way is to check it through an image.
    The following is the side-by-side comparison, where the first image is before
    the Sobel operator is applied and the second one is after it's being applied.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 无论此算法是否有效，唯一的方法是通过图像进行检查。以下是对比图，其中第一幅图像是在应用Sobel算子之前，第二幅图像是在应用之后。
- en: '![How it works…](img/4520OT_06_06.jpg)![How it works…](img/4520OT_06_07.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作…](img/4520OT_06_06.jpg)![如何工作…](img/4520OT_06_07.jpg)'
- en: However, there is another nice optimization which we could have done, and it
    would have helped if we understood that a 3 X 3 convolution kernel (for example,
    the Sobel operator) is actually equivalent to the product of two vectors. This
    realization is behind the optimization algorithm also known as separable convolution.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，还有一个很好的优化，我们可以进行，如果我们理解一个3x3卷积核（例如，Sobel算子）实际上等同于两个向量的乘积，这将有所帮助。这种认识是分离卷积优化算法背后的原理。
- en: Technically, a two-dimensional filter is considered to be separable if it can
    be expressed as an outer product of two vectors. Considering the Sobel operator
    here, we can actually write ![How it works…](img/4520OT_06_08.jpg) and ![How it
    works…](img/4520OT_06_09.jpg).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，如果一个二维滤波器可以表示为两个向量的外积，则被认为是可分离的。考虑到这里的Sobel算子，我们实际上可以写出![如何工作…](img/4520OT_06_08.jpg)和![如何工作…](img/4520OT_06_09.jpg)。
- en: Tip
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The superscript T is the transpose of a row vector, which is equivalent to the
    column-vector and vice versa. Note that convolution is itself associative, so
    it doesn't really matter in which way you multiply the vectors against the input
    image matrix.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 上标 T 是行向量的转置，它等同于列向量，反之亦然。请注意，卷积本身是结合律的，所以你以何种方式将向量与输入图像矩阵相乘并不重要。
- en: Why is this important? The main reason is because we actually save processing
    cycles by using this separable convolution kernel. Let's imagine we have a X-by-Y
    image and a convolution kernel of M-by-N. Using the original method, we would
    have conducted XYMN multiples and adds while using the separable convolution technique,
    we would have actually done XY (M + N) multiples and adds. Theoretically speaking,
    applying this to our 3-by-3 convolution kernel we would have increased our performance
    to 50 percent or 1.5 times and when we use a 9-by-9 convolution kernel, we would
    have increased our performance to 81 / 18 = 4.5 or 450 percent.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么这很重要？主要原因是我们实际上通过使用这个可分离的卷积核节省了处理周期。让我们想象我们有一个 X-by-Y 的图像和一个 M-by-N 的卷积核。使用原始方法，我们会进行
    XYMN 次乘法和加法，而使用可分离的卷积技术，我们实际上会进行 XY (M + N) 次乘法和加法。从理论上讲，如果我们将这个方法应用到我们的 3-by-3
    卷积核上，我们的性能将提高 50% 或 1.5 倍，当我们使用 9-by-9 的卷积核时，我们的性能将提高到 81 / 18 = 4.5 或 450%。
- en: Next, we are going to talk about how you can profile your algorithms and their
    runtimes so that you can make your algorithms not only run faster, but also deepen
    your understanding of how the algorithm works and more often than not, help the
    developer develop a better intuition on how to make better use of the OpenCL device's
    capabilities.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论如何分析你的算法及其运行时间，以便你可以让你的算法不仅运行得更快，而且更深入地理解算法的工作原理，并且往往可以帮助开发者更好地利用 OpenCL
    设备的功能。
- en: Understanding profiling in OpenCL
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 OpenCL 中的分析
- en: Profiling is a relatively simple operation from the perspective of an OpenCL
    developer, since it basically means that he/she wishes to measure how long a particular
    operation took. This is important because during any software development, users
    of the system would often specify the latencies which are considered acceptable,
    and as you develop bigger and more complex systems, profiling the application
    becomes important in helping you understand the bottlenecks of the application.
    The profiling we are going to take is a look done programmatically by the developer
    to explicitly measure the pockets of code. Of course, there is another class of
    profilers which profiles your OpenCL operations on a deeper level with various
    breakdowns on the running times measured and displayed, but that is out of the
    scope of the book. But we encourage readers to download the profilers from AMD
    and Intel to check them out.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 从 OpenCL 开发者的角度来看，分析是一个相对简单的操作，因为它基本上意味着他/她希望测量特定操作花费了多长时间。这很重要，因为在任何软件开发过程中，系统的用户通常会指定被认为是可接受的延迟，随着你开发更大、更复杂的系统，分析应用程序对于帮助你理解应用程序的瓶颈变得很重要。我们将进行的是开发者通过编程方式进行的分析，以明确测量代码的各个部分。当然，还有另一类分析器，它会在更深层次上分析你的
    OpenCL 操作，并对测量的运行时间进行各种细分，但这超出了本书的范围。但我们鼓励读者下载 AMD 和英特尔的分析器来检查它们。
- en: Note
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'While writing this book, AMD has made its OpenCL profiler and a generally available
    debugger named CodeXL found at [http://developer.amd.com/tools-and-sdks/heterogeneous-computing/codexl/](http://developer.amd.com/tools-and-sdks/heterogeneous-computing/codexl/).
    Intel has a similar package offered separately and you can refer to the following
    URL for more details:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写这本书的过程中，AMD 已经发布了其 OpenCL 分析器和一款名为 CodeXL 的通用调试器，可以在 [http://developer.amd.com/tools-and-sdks/heterogeneous-computing/codexl/](http://developer.amd.com/tools-and-sdks/heterogeneous-computing/codexl/)
    找到。英特尔提供了一款类似的独立包，你可以通过以下网址获取更多详细信息：
- en: '[http://software.intel.com/en-us/vcsource/tools/opencl-sdk-2013](http://software.intel.com/en-us/vcsource/tools/opencl-sdk-2013).
    As for NVIDIA GPGPUs, you can only use the APIs provided by OpenCL.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://software.intel.com/en-us/vcsource/tools/opencl-sdk-2013](http://software.intel.com/en-us/vcsource/tools/opencl-sdk-2013)。至于
    NVIDIA GPGPUs，你只能使用 OpenCL 提供的 API。'
- en: Getting ready
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The two operations that OpenCL allows the developer to have such insight into
    their runtimes are data transfer operations and kernel execution operations; the
    times are all measured in nanoseconds.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCL 允许开发者深入了解其运行时的两个操作是数据传输操作和内核执行操作；所有时间都是以纳秒为单位测量的。
- en: Note
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Since all devices cannot resolve to a nanosecond, it's important to determine
    what is the level of resolution, and you can know this by passing the `CL_DEVICE_PROFILING_TIMER_RESOLUTION`
    flag to `clGetDeviceInfo` for the appropriate device ID.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有设备都无法解析到纳秒级别，因此确定分辨率级别非常重要，你可以通过将`CL_DEVICE_PROFILING_TIMER_RESOLUTION`标志传递给`clGetDeviceInfo`以获取适当的设备ID来了解这一点。
- en: How to do it…
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'All you have to do is to pass the `CL_QUEUE_PROFILING_ENABLE` flag as part
    of the `properties` argument, when you create the command queue via `clCreateCommandQueue`.
    The API looks like this:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 你所需要做的就是将`CL_QUEUE_PROFILING_ENABLE`标志作为`properties`参数的一部分，在通过`clCreateCommandQueue`创建命令队列时传递。API看起来是这样的：
- en: '[PRE6]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Once the profiling is enabled, the next thing you need to do is to inject OpenCL
    events into areas of the code, where you want to know how the runtimes fare. To
    achieve this, you need to create a `cl_event` variable for the regions of code
    you wish to monitor and associate this variable with one of the following APIs:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦启用分析，接下来你需要做的是将OpenCL事件注入到代码的特定区域，你想要了解运行时间如何。为了实现这一点，你需要为你要监控的代码区域创建一个`cl_event`变量，并将此变量与以下API之一关联：
- en: 'Data transfer operations:'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据传输操作：
- en: '`clEnqueue{Read|Write|Map}Buffer`'
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clEnqueue{Read|Write|Map}Buffer`'
- en: '`clEnqueue{Read|Write|Map}BufferRect`'
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clEnqueue{Read|Write|Map}BufferRect`'
- en: '`clEnqueue{Read|Write|Map}Image`'
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clEnqueue{Read|Write|Map}Image`'
- en: '`clEnqueueUnmapMemObject`'
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clEnqueueUnmapMemObject`'
- en: '`clEnqueuCopyBuffer`'
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clEnqueuCopyBuffer`'
- en: '`clEnqueueCopyBufferRect`'
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clEnqueueCopyBufferRect`'
- en: '`clEnqueueCopyImage`'
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clEnqueueCopyImage`'
- en: '`clEnqueueCopyImageToBuffer`'
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clEnqueueCopyImageToBuffer`'
- en: '`clEnqueueCopyBufferToImage`'
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clEnqueueCopyBufferToImage`'
- en: 'Kernel operations:'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内核操作：
- en: '`clEnqueueNDRangeKernel`'
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clEnqueueNDRangeKernel`'
- en: '`clEnqueueTask`'
  id: totrans-134
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clEnqueueTask`'
- en: '`clEnqueueNativeTask`'
  id: totrans-135
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clEnqueueNativeTask`'
- en: How it works…
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'The way to obtain the runtimes for these operations is to invoke the `clGetEventProfilingInfo`
    API, passing in one of these flags: `CL_PROFILING_COMMAND_QUEUED`, `CL_PROFILING_COMMAND_SUBMIT`,
    `CL_PROFILING_COMMAND_START`, or `CL_PROFILING_COMMAND_END`. The API looks like
    this:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 获取这些操作的运行时间的方法是调用`clGetEventProfilingInfo` API，传递以下标志之一：`CL_PROFILING_COMMAND_QUEUED`、`CL_PROFILING_COMMAND_SUBMIT`、`CL_PROFILING_COMMAND_START`或`CL_PROFILING_COMMAND_END`。API看起来是这样的：
- en: '[PRE7]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: To obtain the time spent by the command in the queue, you invoke `clGetEventProfilingInfo`
    with `CL_PROFILING_COMMAND_SUBMIT` once, and at the end of the code region invoke
    `clGetEventProfilingInfo` with `CL_PROFILING_COMMAND_QUEUED` again to get the
    difference in time.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取命令在队列中花费的时间，你只需一次调用`clGetEventProfilingInfo`使用`CL_PROFILING_COMMAND_SUBMIT`，然后在代码区域的末尾再次调用`clGetEventProfilingInfo`使用`CL_PROFILING_COMMAND_QUEUED`以获取时间差。
- en: To obtain the duration that the command took to execute, invoke `clGetEventProfilingInfo`
    once with `CL_PROFILING_COMMAND_START` and invoke the same API with `CL_PROFILING_COMMAND_END`,
    from the difference in the runtimes you will obtain the value.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取命令执行所花费的时间，一次调用`clGetEventProfilingInfo`使用`CL_PROFILING_COMMAND_START`，然后使用相同的API调用`CL_PROFILING_COMMAND_END`，从运行时间的差异中你会得到值。
- en: 'The following is a small code snippet which illustrates the basic mechanism:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个小代码片段，说明了基本机制：
- en: '[PRE8]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
