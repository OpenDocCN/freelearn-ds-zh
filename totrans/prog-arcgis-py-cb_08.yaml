- en: Chapter 8. Using the ArcPy Data Access Module with Feature Classes and Tables
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章：使用 ArcPy 数据访问模块与要素类和表
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下菜谱：
- en: Retrieving features from a feature class with SearchCursor
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 SearchCursor 从要素类中检索特征
- en: Filtering records with a where clause
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 where 子句过滤记录
- en: Improving cursor performance with geometry tokens
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用几何标记提高游标性能
- en: Inserting rows with InsertCursor
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 InsertCursor 插入行
- en: Updating rows with UpdateCursor
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 UpdateCursor 更新行
- en: Deleting rows with UpdateCursor
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 UpdateCursor 删除行
- en: Inserting and updating rows inside an edit session
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在编辑会话中插入和更新行
- en: Reading geometry from a feature class
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从要素类中读取几何形状
- en: Using Walk() to navigate directories
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Walk() 导航目录
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: We'll start this chapter with a basic question. What are cursors? **Cursors**
    are in-memory objects containing one or more rows of data from a table or feature
    class. Each row contains attributes from each field in a data source along with
    the geometry for each feature. Cursors allow you to search, add, insert, update,
    and delete data from tables and feature classes.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从这个章节的基本问题开始。什么是游标？**游标**是包含来自表或要素类的数据行的一个或多个行的内存对象。每一行包含数据源中每个字段的属性以及每个要素的几何形状。游标允许您在表和要素类中搜索、添加、插入、更新和删除数据。
- en: The `arcpy` data access module or `arcpy.da` was introduced in ArcGIS 10.1 and
    contains methods that allow you to iterate through each row in a cursor. Various
    types of cursors can be created depending on the needs of developers. For example,
    search cursors can be created to read values from rows. Update cursors can be
    created to update values in rows or delete rows, and insert cursors can be created
    to insert new rows.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`arcpy`数据访问模块或`arcpy.da`是在ArcGIS 10.1中引入的，它包含允许您遍历游标中每一行的方法。根据开发者的需求，可以创建各种类型的游标。例如，可以创建搜索游标来读取行中的值。可以创建更新游标来更新行中的值或删除行，也可以创建插入游标来插入新行。'
- en: There are a number of cursor improvements that have been introduced with the
    `arcpy` data access module. Prior to the development of ArcGIS 10.1, cursor performance
    was notoriously slow. Now, cursors are significantly faster. Esri has estimated
    that `SearchCursors` are up to 30 times faster, while `InsertCursors` are up to
    12 times faster. In addition to these general performance improvements, the data
    access module also provides a number of new options that allow programmers to
    speed up processing. Rather than returning all the fields in a cursor, you can
    now specify that a subset of fields be returned. This increases the performance
    as less data needs to be returned. The same applies to geometry. Traditionally,
    when accessing the geometry of a feature, the entire geometric definition would
    be returned. You can now use geometry tokens to return a portion of the geometry
    rather than the full geometry of the feature. You can also use lists and tuples
    rather than using rows. There are also other new features, such as edit sessions
    and the ability to work with versions, domains, and subtypes.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 随着ArcPy数据访问模块的引入，已经推出了一系列游标改进。在ArcGIS 10.1开发之前，游标性能臭名昭著地慢。现在，游标的速度显著提高。Esri估计`SearchCursors`的速度可以快30倍，而`InsertCursors`可以快12倍。除了这些一般性能改进之外，数据访问模块还提供了一些新的选项，允许程序员加快处理速度。现在，您可以选择只返回游标中的部分字段，而不是所有字段，这样可以提高性能，因为需要返回的数据更少。同样也适用于几何形状。传统上，当访问要素的几何形状时，会返回整个几何定义。现在，您可以使用几何标记来返回几何形状的一部分，而不是要素的完整几何形状。您还可以使用列表和元组而不是使用行。还有其他一些新特性，例如编辑会话和与版本、域和子类型一起工作的能力。
- en: 'There are three cursor functions in `arcpy.da`. Each returns a cursor object
    with the same name as the function. `SearchCursor()` creates a read-only `SearchCursor`
    object containing rows from a table or feature class. `InsertCursor()` creates
    an `InsertCursor` object that can be used to insert new records into a table or
    feature class. `UpdateCursor()` returns a cursor object that can be used to edit
    or delete records from a table or feature class. Each of these cursor objects
    has methods to access rows in the cursor. You can see the relationship between
    the cursor functions, the objects they create, and how they are used, as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在`arcpy.da`中有三个光标函数。每个函数都返回一个与函数同名的光标对象。`SearchCursor()`创建一个包含来自表或要素类行的只读`SearchCursor`对象。`InsertCursor()`创建一个`InsertCursor`对象，可用于向表或要素类插入新记录。`UpdateCursor()`返回一个可用于编辑或删除表或要素类记录的光标对象。这些光标对象都有访问光标中行的方法。你可以看到光标函数、它们创建的对象以及它们的使用之间的关系，如下所示：
- en: '| Function | Object created | Usage |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| 函数 | 创建的对象 | 用途 |'
- en: '| --- | --- | --- |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `SearchCursor()` | `SearchCursor` | This is a read-only view of data from
    a table or feature class |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| `SearchCursor()` | `SearchCursor` | 这是从表或要素类获取数据的只读视图 |'
- en: '| `InsertCursor()` | `InsertCursor` | This adds rows to a table or feature
    class |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| `InsertCursor()` | `InsertCursor` | 这用于向表或要素类添加行 |'
- en: '| `UpdateCursor()` | `UpdateCursor` | This edits or deletes rows in a table
    or feature class |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| `UpdateCursor()` | `UpdateCursor` | 这用于编辑或删除表或要素类的行 |'
- en: The `SearchCursor()` function is used to return a `SearchCursor` object. This
    object can only be used to iterate through a set of rows returned for read-only
    purposes. No insertions, deletions, or updates can occur through this object.
    An optional `where` clause can be set to limit the rows returned.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`SearchCursor()`函数用于返回一个`SearchCursor`对象。此对象只能用于迭代为只读目的返回的一组行。通过此对象无法进行插入、删除或更新操作。可以设置可选的`where`子句以限制返回的行。'
- en: 'Once you''ve obtained a cursor instance, it is common to iterate the records,
    particularly with `SearchCursor` or `UpdateCursor`. There are some peculiarities
    that you need to understand when navigating the records in a cursor. Cursor navigation
    is forward-moving only. When a cursor is created, the pointer of the cursor sits
    just above the first row in the cursor. The first call to `next()` will move the
    pointer to the first row. Rather than calling the `next()` method, you can also
    use a `for` loop to process each of the records without the need to call the `next()`
    method. After performing whatever processing you need to do with this row, a subsequent
    call to `next()` will move the pointer to row 2\. This process continues as long
    as you need to access additional rows. However, after a row has been visited,
    you can''t go back a single record at a time. For instance, if the current row
    is row 3, you can''t programmatically back up to row 2\. You can only go forward.
    To revisit rows 1 and 2, you would need to either call the `reset()` method or
    recreate the cursor and move back through the object. As I mentioned earlier,
    cursors are often navigated through the use of `for` loops as well. In fact, this
    is a more common way to iterate a cursor and a more efficient way to code your
    scripts. Cursor navigation is illustrated in the following diagram:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你获得了光标实例，通常会对记录进行迭代，尤其是在使用`SearchCursor`或`UpdateCursor`时。在光标中导航记录时，你需要了解一些特殊之处。光标导航仅向前移动。当创建光标时，光标指针位于光标中第一行之上。对`next()`的第一次调用将指针移动到第一行。你不仅可以调用`next()`方法，还可以使用`for`循环来处理每条记录，而无需调用`next()`方法。在完成对这一行的任何所需处理之后，对`next()`的后续调用将指针移动到第二行。只要你需要访问额外的行，这个过程就会继续。然而，一旦访问过一行，你无法一次回退一个记录。例如，如果当前行是第三行，你无法通过编程方式回退到第二行。你只能向前移动。要重新访问第一行和第二行，你需要要么调用`reset()`方法，要么重新创建光标并通过对象回退。正如我之前提到的，光标通常通过使用`for`循环来导航。事实上，这是迭代光标和编写脚本更常见、更有效的方法。光标导航在以下图中展示：
- en: '![Introduction](img/B04314_08_2.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![简介](img/B04314_08_2.jpg)'
- en: The `InsertCursor()` function is used to create an `InsertCursor` object that
    allows you to programmatically add new records to feature classes and tables.
    To insert rows, call the `insertRow()` method on this object. You can also retrieve
    a read-only tuple containing the field names in use by the cursor through the
    `fields` property. A lock is placed on the table or feature class being accessed
    through the cursor. Therefore, it is important to always design your script in
    a way that releases the cursor when you are done.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `InsertCursor()` 函数创建 `InsertCursor` 对象，允许您以编程方式向要素类和表中添加新记录。要插入行，请在此对象上调用
    `insertRow()` 方法。您还可以通过 `fields` 属性检索包含游标正在使用的字段名称的只读元组。通过游标访问的表或要素类会被放置一个锁。因此，始终以在完成时释放游标的方式设计您的脚本是很重要的。
- en: The `UpdateCursor()` function can be used to create an `UpdateCursor` object
    that can update and delete rows in a table or feature class. As is the case with
    `InsertCursor`, this function places a lock on the data while it's being edited
    or deleted. If the cursor is used inside a Python's `with` statement, the lock
    will automatically be freed after the data has been processed. This hasn't always
    been the case. Prior to ArcGIS 10.1, cursors were required to be manually released
    using the Python `del` statement. Once an instance of `UpdateCursor` has been
    obtained, you can then call the `updateCursor()` method to update records in tables
    or feature classes and the `deleteRow()` method to delete a row.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `UpdateCursor()` 函数可以创建一个 `UpdateCursor` 对象，可以更新和删除表或要素类中的行。与 `InsertCursor`
    一样，此函数在编辑或删除数据时会对数据进行锁定。如果游标在 Python 的 `with` 语句内部使用，则在数据被处理后锁将自动释放。这并不总是如此。在
    ArcGIS 10.1 之前，必须使用 Python 的 `del` 语句手动释放游标。一旦获得 `UpdateCursor` 的实例，您就可以调用 `updateCursor()`
    方法来更新表或要素类中的记录，以及调用 `deleteRow()` 方法来删除一行。
- en: The subject of data locks requires a little more explanation. The `insert` and
    `update` cursors must obtain a lock on the data source they reference. This means
    that no other application can concurrently access this data source. Locks are
    a way of preventing multiple users from changing data at the same time and thus,
    corrupting the data. When the `InsertCursor()` and `UpdateCursor()` methods are
    called in your code, Python attempts to acquire a lock on the data. This lock
    must be specifically released after the cursor has finished processing so that
    the running applications of other users, such as `ArcMap` or `ArcCatalog`, can
    access the data sources. If this isn't done, no other application will be able
    to access the data. Prior to ArcGIS 10.1 and the `with` statement, cursors had
    to be specifically unlocked through Python's `del` statement. Similarly, `ArcMap`
    and `ArcCatalog` also acquire data locks when updating or deleting data. If a
    data source has been locked by either of these applications, your Python code
    will not be able to access the data. Therefore, the best practice is to close
    `ArcMap` and `ArcCatalog` before running any standalone Python scripts that use
    `insert` or `update` cursors.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 数据锁的主题需要更多的解释。`insert` 和 `update` 游标必须对其引用的数据源获取锁。这意味着没有其他应用程序可以同时访问此数据源。锁是防止多个用户同时更改数据并因此损坏数据的一种方式。当在您的代码中调用
    `InsertCursor()` 和 `UpdateCursor()` 方法时，Python 会尝试获取数据的锁。此锁必须在游标完成处理之后特别释放，以便其他用户的运行应用程序，如
    `ArcMap` 或 `ArcCatalog`，可以访问数据源。如果不这样做，其他应用程序将无法访问数据。在 ArcGIS 10.1 和 `with` 语句之前，游标必须通过
    Python 的 `del` 语句特别解锁。同样，`ArcMap` 和 `ArcCatalog` 在更新或删除数据时也会获取数据锁。如果数据源被这两个应用程序中的任何一个锁定，您的
    Python 代码将无法访问数据。因此，最佳实践是在运行任何使用 `insert` 或 `update` 游标的独立 Python 脚本之前关闭 `ArcMap`
    和 `ArcCatalog`。
- en: In this chapter, we're going to cover the use of cursors to access and edit
    tables and feature classes. However, many of the cursor concepts that existed
    before ArcGIS 10.1 still apply.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍使用游标访问和编辑表和要素类的方法。然而，ArcGIS 10.1 之前存在的许多游标概念仍然适用。
- en: Retrieving features from a feature class with SearchCursor
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 SearchCursor 从要素类检索要素
- en: There are many occasions when you need to retrieve rows from a table or feature
    class for read-only purposes. For example, you might want to generate a list of
    all land parcels in a city with a value greater than $100,000\. In this case,
    you don't have any need to edit the data. Your needs are met simply by generating
    a list of rows that meet some sort of criteria. A `SearchCursor` object contains
    a read-only copy of rows from a table or feature class. These objects can also
    be filtered through the use of a `where` clause so that only a subset of the dataset
    is returned.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多场合你需要从表或要素类中检索行以进行只读操作。例如，你可能想生成一个包含价值超过 $100,000 的所有土地地块的列表。在这种情况下，你不需要编辑数据。你的需求仅通过生成满足某些条件的行列表就能得到满足。`SearchCursor`
    对象包含来自表或要素类的行的只读副本。这些对象也可以通过使用 `where` 子句进行过滤，以便只返回数据集的一个子集。
- en: Getting ready
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The `SearchCursor()` function is used to return a `SearchCursor` object. This
    object can only be used to iterate a set of rows returned for read-only purposes.
    No insertions, deletions, or updates can occur through this object. An optional
    `where` clause can be set to limit the rows returned. In this recipe, you will
    learn how to create a basic `SearchCursor` object on a feature class through the
    use of the `SearchCursor()` function.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`SearchCursor()` 函数用于返回一个 `SearchCursor` 对象。此对象只能用于迭代为只读目的返回的一组行。通过此对象不能进行插入、删除或更新操作。可以设置一个可选的
    `where` 子句来限制返回的行。在本例中，你将学习如何通过使用 `SearchCursor()` 函数在要素类上创建一个基本的 `SearchCursor`
    对象。'
- en: The `SearchCursor` object contains a `fields` property along with the `next()`
    and `reset()` methods. The `fields` property is a read-only structure in the form
    of a Python **tuple**, containing the fields requested from the feature class
    or table. You are going to hear the term tuple a lot in conjunction with cursors.
    If you haven't covered this topic before, tuples are a Python structure to store
    a sequence of data similar to Python lists. However, there are some important
    differences between Python tuples and lists. Tuples are defined as a sequence
    of values inside parentheses, while lists are defined as a sequence of values
    inside brackets. Unlike lists, tuples can't grow and shrink, which can be a very
    good thing in some cases when you want data values to occupy a specific position
    each time. This is the case with cursor objects that use tuples to store data
    from fields in tables and feature classes.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`SearchCursor` 对象包含一个 `fields` 属性以及 `next()` 和 `reset()` 方法。`fields` 属性是一个只读结构，形式为
    Python **元组**，包含从要素类或表中请求的字段。你将经常在游标的使用中听到术语元组。如果你之前没有覆盖这个主题，元组是 Python 用来存储类似
    Python 列表的数据序列的结构。然而，Python 元组和列表之间有一些重要的区别。元组定义为括号内的一系列值，而列表定义为方括号内的一系列值。与列表不同，元组不能增长和缩小，这在某些情况下可能是一个非常好的事情，当你希望数据值每次都占据一个特定的位置时。这是使用元组来存储来自表和要素类字段的数据的游标对象的情况。'
- en: How to do it…
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps to learn how to retrieve rows from a table or feature class
    inside a `SearchCursor` object:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤学习如何在 `SearchCursor` 对象内部检索表或要素类的行：
- en: Open **IDLE** and create a new script window.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 **IDLE** 并创建一个新的脚本窗口。
- en: Save the script as `C:\ArcpyBook\Ch8\SearchCursor.py`.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将脚本保存为 `C:\ArcpyBook\Ch8\SearchCursor.py`。
- en: 'Import the `arcpy.da` module:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入 `arcpy.da` 模块：
- en: '[PRE0]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Set the workspace:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置工作空间：
- en: '[PRE1]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Use a Python `with` statement to create a cursor:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Python `with` 语句创建游标：
- en: '[PRE2]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Loop through each row in `SearchCursor` and print the name of the school. Make
    sure you indent the `for` loop inside the `with` block:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遍历 `SearchCursor` 中的每一行并打印学校的名称。确保在 `with` 块内缩进 `for` 循环：
- en: '[PRE3]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The entire script should appear as follows:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 整个脚本应如下所示：
- en: '[PRE4]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Save the script.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存脚本。
- en: You can check your work by examining the `C:\ArcpyBook\code\Ch8\SearchCursor_Step1.py`
    solution file.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以通过检查 `C:\ArcpyBook\code\Ch8\SearchCursor_Step1.py` 解决方案文件来检查你的工作。
- en: 'Run the script. You should see the following output:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行脚本。你应该看到以下输出：
- en: '[PRE5]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How it works…
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `with` statement used with the `SearchCursor()` function will create, open,
    and close the cursor. So, you no longer have to be concerned with explicitly releasing
    the lock on the cursor as you did prior to ArcGIS 10.1\. The first parameter passed
    into the `SearchCursor()` function is a feature class, represented by the `Schools.shp`
    file. The second parameter is a Python tuple containing a list of fields that
    we want returned in the cursor. For performance reasons, it is a best practice
    to limit the fields returned in the cursor to only those that you need to complete
    the task. Here, we've specified that only the `Facility` and `Name` fields should
    be returned. The `SearchCursor` object is stored in a variable called `cursor`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 使用与`SearchCursor()`函数一起使用的`with`语句将创建、打开和关闭游标。因此，你不再需要担心像在ArcGIS 10.1之前那样显式释放游标的锁。传递给`SearchCursor()`函数的第一个参数是一个要素类，由`Schools.shp`文件表示。第二个参数是一个Python元组，包含我们希望在游标中返回的字段列表。出于性能考虑，将游标中返回的字段限制为你需要完成任务的那些字段是一个最佳实践。在这里，我们指定只返回`Facility`和`Name`字段。`SearchCursor`对象存储在一个名为`cursor`的变量中。
- en: Inside the `with` block, we use a Python `for` loop to loop through each school
    returned. We also use the Python `sorted()` function to sort the contents of the
    cursor. To access the values from a field on the row, simply use the index number
    of the field you want to return. In this case, we want to return the contents
    of the `Name` column, which will be the `1` index number, since it is the second
    item in the tuple of field names that are returned.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在`with`块内部，我们使用Python的`for`循环遍历返回的每一所学校。我们还使用Python的`sorted()`函数对游标的内容进行排序。要访问行上的字段值，只需使用你想要返回的字段的索引号。在这种情况下，我们想要返回`Name`列的内容，这将是一个`1`索引号，因为它是在返回的字段名元组中的第二个项目。
- en: Filtering records with a where clause
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`where`子句过滤记录
- en: By default, `SearchCursor` will contain all rows in a table or feature class.
    However, in many cases, you will want to restrict the number of rows returned
    by some sort of criteria. Applying a filter through the use of a `where` clause
    limits the records returned.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`SearchCursor`将包含表或要素类中的所有行。然而，在许多情况下，你可能希望根据某种标准限制返回的行数。通过使用`where`子句应用过滤器可以限制返回的记录。
- en: Getting ready
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: By default, all rows from a table or feature class will be returned when you
    create a `SearchCursor` object. However, in many cases, you will want to restrict
    the records returned. You can do this by creating a query and passing it as a
    `where` clause parameter when calling the `SearchCursor()` function. In this recipe,
    you'll build on the script you created in the previous recipe by adding a `where`
    clause that restricts the records returned.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，当你创建`SearchCursor`对象时，将返回表或要素类中的所有行。然而，在许多情况下，你可能希望限制返回的记录。你可以通过创建一个查询，并在调用`SearchCursor()`函数时将其作为`where`子句参数传递来实现这一点。在这个菜谱中，你将通过添加一个限制返回记录的`where`子句来扩展你在上一个菜谱中创建的脚本。
- en: How to do it…
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Follow these steps to apply a filter to a `SearchCursor` object that restricts
    the rows returned from a table or feature class:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤对`SearchCursor`对象应用过滤器，以限制从表或要素类返回的行：
- en: Open **IDLE** and load the `SearchCursor.py` script that you created in the
    previous recipe.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**IDLE**并加载你在上一个菜谱中创建的`SearchCursor.py`脚本。
- en: 'Update the `SearchCursor()` function by adding a `where` clause that queries
    the facility field for records that have the `HIGH SCHOOL` text:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过添加一个查询设施字段并查询具有`HIGH SCHOOL`文本的记录的`where`子句来更新`SearchCursor()`函数。
- en: '[PRE6]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You can check your work by examining the `C:\ArcpyBook\code\Ch8\SearchCursor_Step2.py`
    solution file.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以通过检查`C:\ArcpyBook\code\Ch8\SearchCursor_Step2.py`解决方案文件来检查你的工作。
- en: 'Save and run the script. The output will now be much smaller and restricted
    to high schools only:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并运行脚本。现在输出将小得多，仅限于高中：
- en: '[PRE7]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: How it works…
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: We covered the creation of queries in [Chapter 7](ch07.html "Chapter 7. Querying
    and Selecting Data"), *Querying and Selecting Data*, so hopefully you now have
    a good grasp of how these are created along with all the rules you need to follow
    when coding these structures. The `where` clause parameter accepts any valid SQL
    query, and is used in this case to restrict the number of records that are returned.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第7章](ch07.html "第7章。查询和选择数据")中介绍了查询的创建，*查询和选择数据*，所以希望你现在对这些结构的创建有一个很好的掌握，以及当你编写这些结构时需要遵循的所有规则。`where`子句参数接受任何有效的SQL查询，并且在这个情况下用于限制返回的记录数。
- en: Improving cursor performance with geometry tokens
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用几何令牌提高游标性能
- en: '**Geometry tokens** were introduced in ArcGIS 10.1 as a performance improvement
    for cursors. Rather than returning the entire geometry of a feature inside the
    cursor, only a portion of the geometry is returned. Returning the entire geometry
    of a feature can result in decreased cursor performance due to the amount of data
    that has to be returned. It''s significantly faster to return only the specific
    portion of the geometry that is needed.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**几何令牌**是在ArcGIS 10.1中引入的，作为游标性能改进的一部分。而不是在游标内返回特征的整个几何形状，只返回几何形状的一部分。返回特征的整个几何形状可能会导致游标性能下降，因为需要返回的数据量很大。仅返回所需的具体几何形状部分要快得多。'
- en: Getting ready
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'A token is provided as one of the fields in the field list passed into the
    constructor for a cursor and is in the `SHAPE@<Part of Feature to be Returned>`
    format. The only exception to this format is the `OID@` token, which returns the
    object ID of the feature. The following code example retrieves only the `X` and
    `Y` coordinates of a feature:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 令牌作为字段列表中传递给构造函数的一个字段提供，其格式为`SHAPE@<要返回的特征部分>`。此格式的唯一例外是`OID@`令牌，它返回特征的对象ID。以下代码示例仅检索特征的`X`和`Y`坐标：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The following table lists the available geometry tokens. Not all cursors support
    the full list of tokens. Check the ArcGIS help files for information about the
    tokens supported by each cursor type. The `SHAPE@` token returns the entire geometry
    of the feature. Use this carefully though, because it is an expensive operation
    to return the entire geometry of a feature and can dramatically affect performance.
    If you don't need the entire geometry, then do not include this token!
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格列出了可用的几何令牌。并非所有游标都支持完整的令牌列表。请查阅ArcGIS帮助文件以获取有关每个游标类型支持的令牌的信息。`SHAPE@`令牌返回特征的整个几何形状。尽管如此，请谨慎使用，因为返回特征的整个几何形状是一个昂贵的操作，并且可能会显著影响性能。如果您不需要整个几何形状，则不要包含此令牌！
- en: '![Getting ready](img/B04314_08_8.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作](img/B04314_08_8.jpg)'
- en: In this recipe, you will use a geometry token to increase the performance of
    a cursor. You'll retrieve the `X` and `Y` coordinates of each land parcel from
    the `parcels` feature class along with some attribute information about the parcel.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，您将使用几何令牌来提高游标的处理性能。您将从`parcels`要素类中检索每个土地地块的`X`和`Y`坐标，以及地块的一些属性信息。
- en: How to do it…
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Follow these steps to add a geometry token to a cursor, which should improve
    the performance of this object:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤将几何令牌添加到游标中，这应该会提高该对象的处理性能：
- en: Open **IDLE** and create a new script window.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**IDLE**并创建一个新的脚本窗口。
- en: Save the script as `C:\ArcpyBook\Ch8\GeometryToken.py`.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将脚本保存为`C:\ArcpyBook\Ch8\GeometryToken.py`。
- en: 'Import the `arcpy.da` module and the time module:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`arcpy.da`模块和时间模块：
- en: '[PRE9]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Set the workspace:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置工作空间：
- en: '[PRE10]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We''re going to measure how long it takes to execute the code using a geometry
    token. Add the `start` time for the script:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用几何令牌来测量执行代码所需的时间。为脚本添加`start`时间：
- en: '[PRE11]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Use a Python `with` statement to create a cursor that includes the centroid
    of each feature as well as the ownership information stored in the `PY_FULL_OW`
    field:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Python的`with`语句创建一个游标，该游标包括每个特征的质心以及存储在`PY_FULL_OW`字段中的所有权信息：
- en: '[PRE12]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Loop through each row in `SearchCursor` and print the name of the parcel and
    location. Make sure you indent the `for` loop inside the `with` block:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遍历`SearchCursor`中的每一行，并打印包裹名称和位置。确保在`with`块内部缩进`for`循环：
- en: '[PRE13]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Measure the elapsed time:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测量经过的时间：
- en: '[PRE14]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Print the execution time:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印执行时间：
- en: '[PRE15]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The entire script should appear as follows:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 整个脚本应如下所示：
- en: '[PRE16]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You can check your work by examining the `C:\ArcpyBook\code\Ch8\GeometryToken.py`
    solution file.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以通过检查`C:\ArcpyBook\code\Ch8\GeometryToken.py`解决方案文件来检查您的作品。
- en: Save the script.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存脚本。
- en: 'Run the script. You should see something similar to the following output. Note
    the execution time; your time will vary:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行脚本。您应该看到以下类似的输出。注意执行时间；您的时间会有所不同：
- en: '[PRE17]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, we''re going to measure the execution time if the entire geometry is returned
    instead of just the portion of the geometry that we need:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将测量如果返回整个几何形状而不是所需几何形状的部分，执行时间将如何变化：
- en: Save a new copy of the script as `C:\ArcpyBook\Ch8\GeometryTokenEntireGeometry.py`.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将脚本保存为新副本，命名为`C:\ArcpyBook\Ch8\GeometryTokenEntireGeometry.py`。
- en: 'Change the `SearchCursor()` function to return the entire geometry using `SHAPE@`
    instead of `SHAPE@XY`:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`SearchCursor()`函数更改为使用`SHAPE@`而不是`SHAPE@XY`返回整个几何形状：
- en: '[PRE18]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You can check your work by examining the `C:\ArcpyBook\code\Ch8\GeometryTokenEntireGeometry.py`
    solution file.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以通过检查 `C:\ArcpyBook\code\Ch8\GeometryTokenEntireGeometry.py` 解决方案文件来检查你的工作。
- en: 'Save and run the script. You should see the following output. Your time will
    vary from mine, but notice that the execution time is slower. In this case, it''s
    only a little over a second slower, but we''re only returning 2600 features. If
    the feature class were significantly larger, as many are, this would be amplified:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并运行脚本。你应该会看到以下输出。你的时间可能会和我的不同，但请注意执行时间较慢。在这种情况下，它只慢了一点点，但我们只返回了2600个特征。如果特征类的大小显著更大，像许多情况一样，这将放大：
- en: '[PRE19]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: How it works…
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: A geometry token can be supplied as one of the field names supplied in the constructor
    for the cursor. These tokens are used to increase the performance of a cursor
    by returning only a portion of the geometry instead of the entire geometry. This
    can dramatically increase the performance of a cursor, particularly when you are
    working with large polyline or polygon datasets. If you only need specific properties
    of the geometry in your cursor, you should use these tokens.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将几何标记作为游标构造函数中提供的字段名称之一提供。这些标记用于通过仅返回部分几何而不是整个几何来提高游标性能。这可以显著提高游标的性能，尤其是在处理大型折线或多边形数据集时。如果你只需要游标中几何的特定属性，你应该使用这些标记。
- en: Inserting rows with InsertCursor
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 InsertCursor 插入行
- en: You can insert a row into a table or feature class using an `InsertCursor` object.
    If you want to insert attribute values along with the new row, you'll need to
    supply the values in the order found in the attribute table.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `InsertCursor` 对象将行插入到表或特征类中。如果你想将属性值与新行一起插入，你需要按属性表中的顺序提供这些值。
- en: Getting ready
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The `InsertCursor()` function is used to create an `InsertCursor` object that
    allows you to programmatically add new records to feature classes and tables.
    The `insertRow()` method on the `InsertCursor` object adds the row. A row in the
    form of a list or tuple is passed into the `insertRow()` method. The values in
    the list must correspond to the field values defined when the `InsertCursor` object
    was created. Similar to instances that include other types of cursors, you can
    also limit the field names returned using the second parameter of the method.
    This function supports geometry tokens as well.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`InsertCursor()` 函数用于创建一个 `InsertCursor` 对象，允许你以编程方式向特征类和表添加新记录。`InsertCursor`
    对象上的 `insertRow()` 方法添加行。将形式为列表或元组的行传递到 `insertRow()` 方法中。列表中的值必须与创建 `InsertCursor`
    对象时定义的字段值相对应。类似于包含其他类型游标的实例，你也可以使用方法的第二个参数限制返回的字段名称。此函数还支持几何标记。'
- en: 'The following code example illustrates how you can use `InsertCursor` to insert
    new rows into a feature class. Here, we insert two new wildfire points into the
    `California` feature class. The row values to be inserted are defined in a `list`
    variable. Then, an `InsertCursor` object is created, passing in the feature class
    and fields. Finally, the new rows are inserted into the feature class by using
    the `insertRow()` method:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例说明了如何使用 `InsertCursor` 将新行插入到特征类中。在这里，我们将两个新的野火点插入到 `California` 特征类中。要插入的行值定义在一个
    `list` 变量中。然后，创建一个 `InsertCursor` 对象，传入特征类和字段。最后，通过使用 `insertRow()` 方法将新行插入到特征类中：
- en: '[PRE20]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In this recipe, you will use `InsertCursor` to add wildfires retrieved from
    a `.txt` file into a point feature class. When inserting rows into a feature class,
    you will need to know how to add the geometric representation of a feature into
    the feature class. This can be accomplished by using `InsertCursor` along with
    two miscellaneous objects: `Array` and `Point`. In this exercise, we will add
    point features in the form of wildfire incidents to an empty point feature class.
    In addition to this, you will use Python file manipulation techniques to read
    the coordinate data from a text file.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将使用 `InsertCursor` 将从 `.txt` 文件中检索到的野火添加到点特征类中。在将行插入到特征类时，你需要知道如何将特征的空间表示添加到特征类中。这可以通过使用
    `InsertCursor` 以及两个杂项对象：`Array` 和 `Point` 来实现。在这个练习中，我们将以野火事件的形式将点特征添加到空点特征类中。此外，你还将使用
    Python 文件操作技术从文本文件中读取坐标数据。
- en: How to do it…
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'We will be importing the North American wildland fire incident data from a
    single day in October, 2007\. This data is contained in a comma-delimited text
    file containing one line for each fire incident on this particular day. Each fire
    incident has a latitude, longitude coordinate pair separated by commas along with
    a confidence value. This data was derived by automated methods that use remote
    sensing data to derive the presence or absence of a wildfire. Confidence values
    can range from 0 to 100\. Higher numbers represent a greater confidence that this
    is indeed a wildfire:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将导入2007年10月某一天的美国野火事件数据。这些数据包含在一个逗号分隔的文本文件中，该文件包含该特定日期上每个火灾事件的单独一行。每个火灾事件都有一个由逗号分隔的纬度、经度坐标对以及一个置信度值。这些数据是通过使用遥感数据来推导野火的有无而自动生成的。置信度值范围从0到100。数值越高表示这是一个真正的野火的置信度越大：
- en: Open the file at `C:\ArcpyBook\Ch8\Wildfire Data\NorthAmericaWildfire_2007275.txt`
    and examine the contents.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开文件`C:\ArcpyBook\Ch8\Wildfire Data\NorthAmericaWildfire_2007275.txt`并检查其内容。
- en: You will notice that this is a simple comma-delimited text file containing the
    longitude and latitude values for each fire along with a confidence value. We
    will use Python to read the contents of this file line by line and insert new
    point features into the `FireIncidents` feature class located in the `C:\ArcpyBook\Ch8
    \WildfireData\WildlandFires.mdb` personal geodatabase.
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你会注意到这是一个简单的逗号分隔的文本文件，包含每个火灾的经纬度值以及一个置信度值。我们将使用Python逐行读取该文件的内容，并将新的点要素插入到位于`C:\ArcpyBook\Ch8
    \WildfireData\WildlandFires.mdb`个人地理数据库中的`FireIncidents`要素类中。
- en: Close the file.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭文件。
- en: Open `ArcCatalog`.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`ArcCatalog`。
- en: Navigate to `C:\ArcpyBook\Ch8\WildfireData`.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到`C:\ArcpyBook\Ch8\WildfireData`。
- en: You should see a personal geodatabase called `WildlandFires`. Open this geodatabase
    and you will see a point feature class called `FireIncidents`. Right now, this
    is an empty feature class. We will add features by reading the text file you examined
    earlier and inserting points.
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该看到一个名为`WildlandFires`的个人地理数据库。打开此数据库，你会看到一个名为`FireIncidents`的点要素类。目前，这是一个空要素类。我们将通过读取你之前检查的文本文件并插入点来添加要素。
- en: Right-click on `FireIncidents` and select **Properties**.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击`FireIncidents`并选择**属性**。
- en: Click on the **Fields** tab.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**字段**选项卡。
- en: The latitude/longitude values found in the file we examined earlier will be
    imported into the `SHAPE` field and the confidence values will be written to the
    `CONFIDENCEVALUE` field.
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们之前检查的文件中找到的纬度/经度值将被导入到`SHAPE`字段，置信度值将被写入`CONFIDENCEVALUE`字段。
- en: Open **IDLE** and create a new script.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**IDLE**并创建一个新的脚本。
- en: Save the script to `C:\ArcpyBook\Ch8\InsertWildfires.py`.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将脚本保存到`C:\ArcpyBook\Ch8\InsertWildfires.py`。
- en: 'Import the `arcpy` modules:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`arcpy`模块：
- en: '[PRE21]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Set the workspace:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置工作空间：
- en: '[PRE22]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Open the text file and read all the lines into a list:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开文本文件并将所有行读入一个列表：
- en: '[PRE23]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Start a `try` block:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始一个`try`块：
- en: '[PRE24]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Create an `InsertCursor` object using a `with` block. Make sure you indent
    inside the `try` statement. The cursor will be created in the `FireIncidents`
    feature class:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`with`块创建一个`InsertCursor`对象。确保在`try`语句内部缩进。游标将在`FireIncidents`要素类中创建：
- en: '[PRE25]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Create a counter variable that will be used to print the progress of the script:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个计数器变量，用于打印脚本的进度：
- en: '[PRE26]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Loop through the text file line by line using a `for` loop. Since the text
    file is comma-delimited, we''ll use the Python `split()` function to separate
    each value into a list variable called `vals`. We''ll then pull out the individual
    latitude, longitude, and confidence value items and assign them to variables.
    Finally, we''ll place these values into a list variable called `rowValue`, which
    is then passed into the `insertRow()` function for the `InsertCursor` object,
    and we then print a message:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`for`循环逐行遍历文本文件。由于文本文件是逗号分隔的，我们将使用Python的`split()`函数将每个值分离到一个名为`vals`的列表变量中。然后我们将提取单独的纬度、经度和置信度值项并将它们分配给变量。最后，我们将这些值放入一个名为`rowValue`的列表变量中，然后将其传递给`InsertCursor`对象的`insertRow()`函数，然后打印一条消息：
- en: '[PRE27]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Add the `except` block to print any errors that may occur:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`except`块以打印可能发生的任何错误：
- en: '[PRE28]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Add a `finally` block to close the text file:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`finally`块以关闭文本文件：
- en: '[PRE29]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The entire script should appear as follows:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 整个脚本应如下所示：
- en: '[PRE30]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: You can check your work by examining the `C:\ArcpyBook\code\Ch8\InsertWildfires.py`
    solution file.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以通过检查`C:\ArcpyBook\code\Ch8\InsertWildfires.py`解决方案文件来检查你的工作。
- en: 'Save and run the script. You should see messages being written to the output
    window as the script runs:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并运行脚本。当脚本运行时，你应该会看到消息被写入输出窗口：
- en: '[PRE31]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Open **ArcMap** and add the `FireIncidents` feature class to the table of contents.
    The points should be visible, as shown in the following screenshot:![How to do
    it…](img/B04314_08_3.jpg)
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 **ArcMap** 并将 `FireIncidents` 要素类添加到内容表中。点应该可见，如下面的截图所示：![如何操作…](img/B04314_08_3.jpg)
- en: You may want to add a basemap to provide some reference for the data. In ArcMap,
    click on the **Add Basemap** button and select a basemap from the gallery.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可能想要添加一个底图来为数据提供一些参考。在 ArcMap 中，点击 **添加底图** 按钮，并从图库中选择一个底图。
- en: How it works…
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Some additional explanation may be needed here. The `lstFires` variable contains
    a list of all the wildfires that were contained in the comma-delimited text file.
    The `for` loop will loop through each of these records one by one, inserting each
    individual record into the `fire` variable. We also include an `if` statement
    that is used to skip the first record in the file, which serves as the header.
    As I explained earlier, we then pull out the individual latitude, longitude, and
    confidence value items from the `vals` variable, which is just a Python list object
    and assign them to variables called `latitude`, `longitude`, and `confid`. We
    then place these values into a new list variable called `rowValue` in the order
    that we defined when we created `InsertCursor`. Thus, the latitude and longitude
    pair should be placed first followed by the confidence value. Finally, we call
    the `insertRow()` function on the `InsertCursor` object assigned to the `cur`
    variable, passing in the new `rowValue` variable. We close by printing a message
    that indicates the progress of the script and also create the `except` and `finally`
    blocks to handle errors and close the text file. Placing the `file.close()` method
    in the `finally` block ensures that it will execute and close the file even if
    there is an error in the previous `try` statement.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这里可能需要一些额外的解释。`lstFires` 变量包含了一个逗号分隔的文本文件中包含的所有野火列表。`for` 循环将逐个遍历这些记录，将每个单独的记录插入到
    `fire` 变量中。我们还包含了一个 `if` 语句，用于跳过文件中的第一个记录，该记录作为标题。正如我之前解释的，然后我们从 `vals` 变量中提取单个纬度、经度和置信度值项，`vals`
    变量只是一个 Python 列表对象，并将它们分配给名为 `latitude`、`longitude` 和 `confid` 的变量。然后我们将这些值按照我们在创建
    `InsertCursor` 时定义的顺序放入一个新的列表变量 `rowValue` 中。因此，纬度和经度对应该首先放置，然后是置信度值。最后，我们在 `cur`
    变量分配的 `InsertCursor` 对象上调用 `insertRow()` 函数，传入新的 `rowValue` 变量。我们通过打印一条消息来结束，该消息指示脚本的进度，并创建
    `except` 和 `finally` 块来处理错误和关闭文本文件。将 `file.close()` 方法放在 `finally` 块中确保即使在之前的
    `try` 语句中发生错误，它也会执行并关闭文件。
- en: Updating rows with UpdateCursor
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 UpdateCursor 更新行
- en: If you need to edit or delete rows from a table or feature class, you can use
    `UpdateCursor`. As is the case with `InsertCursor`, the contents of `UpdateCursor`
    can be limited through the use of a `where` clause.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要编辑或删除表或要素类中的行，你可以使用 `UpdateCursor`。与 `InsertCursor` 一样，可以通过使用 `where` 子句来限制
    `UpdateCursor` 的内容。
- en: Getting ready
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The `UpdateCursor()` function can be used to either update or delete rows in
    a table or feature class. The returned cursor places a lock on the data, which
    will automatically be released if used inside a Python `with` statement. An `UpdateCursor`
    object is returned from a call to this method.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`UpdateCursor()` 函数可用于更新或删除表或要素类中的行。返回的游标会对数据进行锁定，如果在使用 Python `with` 语句时使用，锁定将自动释放。从对该方法的调用返回一个
    `UpdateCursor` 对象。'
- en: The `UpdateCursor` object places a lock on the data while it's being edited
    or deleted. If the cursor is used inside a Python `with` statement, the lock will
    automatically be freed after the data has been processed. This hasn't always been
    the case. Previous versions of cursors were required to be manually released using
    the Python `del` statement. Once an instance of `UpdateCursor` has been obtained,
    you can then call the `updateCursor()` method to update records in tables or feature
    classes and the `deleteRow()` method can be used to delete a row.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`UpdateCursor` 对象在编辑或删除数据时会对数据进行锁定。如果游标在 Python `with` 语句中使用，则在数据被处理后，锁定将自动释放。这并不总是如此。之前的游标版本需要使用
    Python `del` 语句手动释放。一旦获得 `UpdateCursor` 实例，你就可以调用 `updateCursor()` 方法来更新表或要素类中的记录，并使用
    `deleteRow()` 方法来删除一行。'
- en: In this recipe, you're going to write a script that updates each feature in
    the `FireIncidents` feature class by assigning a value of `poor`, `fair`, `good`,
    or `excellent` to a new field that is more descriptive of the confidence values
    using an `UpdateCursor`. Prior to updating the records, your script will add the
    `new` field to the `FireIncidents` feature class.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在本菜谱中，你将编写一个脚本，通过使用`UpdateCursor`将`poor`、`fair`、`good`或`excellent`的值分配给一个新字段，该字段更能描述置信值，从而更新`FireIncidents`要素类中的每个要素。在更新记录之前，你的脚本将向`FireIncidents`要素类添加`new`字段。
- en: How to do it…
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Follow these steps to create an `UpdateCursor` object that will be used to
    edit rows in a feature class:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建一个`UpdateCursor`对象，该对象将用于编辑要素类中的行：
- en: Open **IDLE** and create a new script.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**IDLE**并创建一个新的脚本。
- en: Save the script to `C:\ArcpyBook\Ch8\UpdateWildfires.py`.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将脚本保存到`C:\ArcpyBook\Ch8\UpdateWildfires.py`。
- en: 'Import the `arcpy` module:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`arcpy`模块：
- en: '[PRE32]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Set the workspace:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置工作空间：
- en: '[PRE33]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Start a `try` block:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始一个`try`块：
- en: '[PRE34]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Add a new field called `CONFID_RATING` to the `FireIncidents` feature class.
    Make sure to indent inside the `try` statement:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`FireIncidents`要素类添加一个名为`CONFID_RATING`的新字段。确保在`try`语句内缩进：
- en: '[PRE35]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Create a new instance of `UpdateCursor` inside a `with` block:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`with`块内创建一个新的`UpdateCursor`实例：
- en: '[PRE36]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Create a counter variable that will be used to print the progress of the script.
    Make sure you indent this line of code and all the lines of code that follow inside
    the `with` block:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个计数器变量，用于打印脚本的进度。确保将此行代码及其后`with`块内的所有代码缩进：
- en: '[PRE37]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Loop through each of the rows in the `FireIncidents` fire class. Update the
    `CONFID_RATING` field according to the following guidelines:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遍历`FireIncidents`火类中的每一行。根据以下指南更新`CONFID_RATING`字段：
- en: Confidence value 0 to 40 = `POOR`
  id: totrans-179
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 置信值0到40 = `POOR`
- en: Confidence value 41 to 60 = `FAIR`
  id: totrans-180
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 置信值41到60 = `FAIR`
- en: Confidence value 61 to 85 = `GOOD`
  id: totrans-181
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 置信值61到85 = `GOOD`
- en: Confidence value 86 to 100 = `EXCELLENT`
  id: totrans-182
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 置信值86到100 = `EXCELLENT`
- en: 'This can be translated in the following block of code:'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这可以通过以下代码块进行翻译：
- en: '[PRE38]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Add the `except` block to print any errors that may occur:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`except`块以打印可能发生的任何错误：
- en: '[PRE39]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The entire script should appear as follows:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 整个脚本应如下所示：
- en: '[PRE40]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: You can check your work by examining the `C:\ArcpyBook\code\Ch8\UpdateWildfires.py`
    solution file.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以通过检查`C:\ArcpyBook\code\Ch8\UpdateWildfires.py`解决方案文件来检查你的工作。
- en: 'Save and run the script. You should see messages being written to the output
    window as the script runs:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并运行脚本。当脚本运行时，你应该会在输出窗口看到消息：
- en: '[PRE41]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Open **ArcMap** and add the `FireIncidents` feature class. Open the attribute
    table and you should see that a new `CONFID_RATING` field has been added and populated
    by `UpdateCursor`:![How to do it…](img/B04314_08_4.jpg)
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**ArcMap**并添加`FireIncidents`要素类。打开属性表，你应该会看到已添加并由`UpdateCursor`填充的新`CONFID_RATING`字段：![如何操作…](img/B04314_08_4.jpg)
- en: Note
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When you insert, update, or delete data in cursors, the changes are permanent
    and can't be undone if you're working outside an edit session. However, with the
    new edit session functionality provided by ArcGIS 10.1, you can now make these
    changes inside an edit session to avoid these problems. We'll cover edit sessions
    soon.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在游标中插入、更新或删除数据时，更改是永久的，如果你在编辑会话外工作，则无法撤销更改。然而，使用ArcGIS 10.1提供的新编辑会话功能，你现在可以在编辑会话内进行这些更改以避免这些问题。我们很快会介绍编辑会话。
- en: How it works…
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: In this case, we've used `UpdateCursor` to update each of the features in a
    feature class. We first used the `Add Field` tool to add a new field called `CONFID_RATING`,
    which will hold new values that we assign based on values found in another field.
    The groups are poor, fair, good, and excellent and are based on numeric values
    found in the `CONFIDENCEVALUE` field. We then created a new instance of `UpdateCursor`
    based on the `FireIncidents` feature class, and returned the two fields mentioned
    previously. The script then loops through each of the features and assigns a value
    of poor, fair, good, or excellent to the `CONFID_RATING` field (`row[1]`), based
    on the numeric value found in `CONFIDENCEVALUE`. A Python `if`/`elif`/`else` structure
    is used to control the flow of the script based on the numeric value. The value
    for `CONFID_RATING` is then committed to the feature class by passing the row
    variable into the `updateRow`() method.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们使用了 `UpdateCursor` 来更新要素类中的每个要素。我们首先使用 `Add Field` 工具添加一个名为 `CONFID_RATING`
    的新字段，该字段将保存我们根据另一个字段中找到的值分配的新值。这些组是差、一般、好和优秀，并且基于 `CONFIDENCEVALUE` 字段中找到的数值。然后，我们根据
    `FireIncidents` 要素类创建了一个新的 `UpdateCursor` 实例，并返回了之前提到的两个字段。然后脚本遍历每个要素，并根据 `CONFIDENCEVALUE`
    中找到的数值将 `CONFID_RATING` 字段（`row[1]`）的值设置为差、一般、好或优秀。使用 Python 的 `if`/`elif`/`else`
    结构根据数值控制脚本的流程。然后通过将行变量传递到 `updateRow()` 方法中，将 `CONFID_RATING` 的值提交到要素类。
- en: Deleting rows with UpdateCursor
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 UpdateCursor 删除行
- en: In addition to being used to edit rows in a table or feature class, `UpdateCursor`
    can also be used to delete rows. Keep in mind that when rows are deleted outside
    an edit session, the changes are permanent.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 除了用于编辑表或要素类中的行之外，`UpdateCursor` 还可以用于删除行。请注意，当在编辑会话之外删除行时，更改是永久的。
- en: Getting ready
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In addition to updating records, `UpdateCursor` can also delete records from
    a table or feature class. The `UpdateCursor` object is created in the same way
    in either case, but instead of calling `updateRow()`, you call `deleteRow()` to
    delete a record. You can also apply a `where` clause to `UpdateCursor`, to limit
    the records returned. In this recipe, we'll use an `UpdateCursor` object that
    has been filtered using a `where` clause to delete records from our `FireIncidents`
    feature class.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 除了更新记录之外，`UpdateCursor` 还可以从表或要素类中删除记录。在两种情况下，`UpdateCursor` 对象的创建方式相同，但不是调用
    `updateRow()`，而是调用 `deleteRow()` 来删除记录。你还可以将 `where` 子句应用于 `UpdateCursor`，以限制返回的记录。在本例中，我们将使用带有
    `where` 子句过滤的 `UpdateCursor` 对象来从我们的 `FireIncidents` 要素类中删除记录。
- en: How to do it…
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Follow these steps to create an `UpdateCursor` object that will be used to
    delete rows from a feature class:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建一个 `UpdateCursor` 对象，该对象将用于从要素类中删除行：
- en: Open **IDLE** and create a new script.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 **IDLE** 并创建一个新的脚本。
- en: Save the script to `C:\ArcpyBook\Ch8\DeleteWildfires.py`.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将脚本保存到 `C:\ArcpyBook\Ch8\DeleteWildfires.py`。
- en: 'Import the `arcpy` and `os` modules:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入 `arcpy` 和 `os` 模块：
- en: '[PRE42]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Set the workspace:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置工作空间：
- en: '[PRE43]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Start a `try` block:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始一个 `try` 块：
- en: '[PRE44]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Create a new instance of `UpdateCursor` inside a `with` block. Make sure you
    indent inside the `try` statement:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `with` 块内创建 `UpdateCursor` 的新实例。确保在 `try` 语句内缩进：
- en: '[PRE45]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Create a counter variable that will be used to print the progress of the script.
    Make sure you indent this line of code and all the lines of code that follow inside
    the `with` block:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个计数变量，该变量将用于打印脚本的进度。确保缩进此行代码以及 `with` 块内随后的所有代码行：
- en: '[PRE46]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Delete the returned rows by calling the `deleteRow()` method. This is done
    by looping through the returned cursor and deleting the rows one at a time:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用 `deleteRow()` 方法删除返回的行。这是通过遍历返回的游标并逐行删除来完成的：
- en: '[PRE47]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Add the `except` block to print any errors that may occur:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `except` 块以打印可能发生的任何错误：
- en: '[PRE48]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The entire script should appear as follows:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 整个脚本应如下所示：
- en: '[PRE49]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: You can check your work by examining the `C:\ArcpyBook\code\Ch8\DeleteWildfires.py`
    solution file.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以通过检查 `C:\ArcpyBook\code\Ch8\DeleteWildfires.py` 解决方案文件来验证你的工作。
- en: 'Save and run the script. You should see messages being written to the output
    window as the script runs. 37 records should be deleted from the `FireIncidents`
    feature class:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并运行脚本。当脚本运行时，你应该会看到消息被写入输出窗口。`FireIncidents` 要素类中应该会删除 37 条记录：
- en: '[PRE50]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: How it works…
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Rows from feature classes and tables can be deleted using the `deleteRow()`
    method in `UpdateCursor`. In this recipe, we used a `where` clause in the constructor
    of `UpdateCursor` to limit the records returned to only features that included
    `CONFID_RATING` of `POOR`. We then looped through the features returned in the
    cursor and called the `deleteRow()` method to delete the row from the feature
    class.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`UpdateCursor`中的`deleteRow()`方法从要素类和表中删除行。在本食谱中，我们使用`UpdateCursor`构造函数中的`where`子句来限制返回的记录仅包含`CONFID_RATING`为`POOR`的要素。然后我们遍历游标返回的要素，并调用`deleteRow()`方法从要素类中删除该行。
- en: Inserting and updating rows inside an edit session
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在编辑会话内插入和更新行
- en: As I've mentioned throughout the chapter, inserts, updates, or deletes made
    to a table or feature class done outside an edit session are permanent. They can't
    be undone. Edit sessions give you much more flexibility to roll back any unwanted
    changes.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在本章中提到的，在编辑会话之外对表或要素类进行的插入、更新或删除操作是永久的。这些更改无法撤销。编辑会话为您提供了更大的灵活性，可以回滚任何不希望的变化。
- en: Getting ready
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Up until now, we've used insert and update cursors to add, edit, and delete
    data from feature classes and tables. These changes are permanent as soon as the
    script is executed and can't be undone. The new `Editor` class in the data access
    module supports the ability to create edit sessions and operations. With edit
    sessions, changes applied to feature classes or tables are temporary until permanently
    applied with a specific method call. This is the same functionality provided by
    the `Edit` toolbar in ArcGIS for Desktop.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们使用插入和更新游标来向要素类和表中添加、编辑和删除数据。这些更改在脚本执行后立即生效，并且无法撤销。数据访问模块中的新`Editor`类支持创建编辑会话和操作的能力。使用编辑会话，对要素类或表应用的变化在通过特定方法调用永久应用之前是临时的。这与ArcGIS
    for Desktop中的`Edit`工具栏提供的功能相同。
- en: 'Edit sessions begin with a call to `Editor.startEditing()`, which initiates
    the session. Inside the session, you then start an operation with the `Editor.startOperation()`
    method. Within this operation, you then perform various operations that perform
    edits on your data. These edits can also be subject to undo, redo, and abort operations
    to roll back, roll forward, and abort your editing operations. After the operations
    have been completed, you then call the `Editor.stopOperation()` method followed
    by `Editor.stopEditing()`. Sessions can be ended without saving changes. In this
    event, changes are not permanently applied. An overview of this process is provided
    in the following screenshot:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑会话从调用`Editor.startEditing()`开始，这会启动会话。在会话内部，您然后使用`Editor.startOperation()`方法开始一个操作。在这个操作中，您执行各种操作，这些操作对您的数据进行编辑。这些编辑也可以受到撤销、重做和取消操作的影响，以回滚、前进和取消您的编辑操作。操作完成后，您然后调用`Editor.stopOperation()`方法，接着调用`Editor.stopEditing()`。会话可以在不保存更改的情况下结束。在这种情况下，更改不会被永久应用。以下截图提供了此过程的概述：
- en: '![Getting ready](img/B04314_08_5.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作](img/B04314_08_5.jpg)'
- en: Edit sessions can also be ended without saving changes. In this event, changes
    are not permanently applied. Edit sessions also allow for operations to be applied
    inside the session and then either applied permanently to the database or rolled
    back. Additionally, the `Editor` class also supports undo and redo operations.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑会话也可以在不保存更改的情况下结束。在这种情况下，更改不会被永久应用。编辑会话还允许在会话内应用操作，然后可以选择将这些操作永久应用到数据库中或回滚。此外，`Editor`类还支持撤销和重做操作。
- en: 'The following code example shows the full edit session stack, including the
    creation of the `Editor` object, the beginning of an edit session and an operation,
    edits to the data (an insert operation in this case), stopping the operation,
    and finally, the end of the edit session by saving the data:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例显示了完整的编辑会话堆栈，包括创建`Editor`对象、开始编辑会话和操作、对数据进行编辑（在本例中为插入操作）、停止操作，以及最后通过保存数据结束编辑会话：
- en: '[PRE51]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The `Editor` class can be used with personal, file, and ArcSDE geodatabases.
    Also, sessions can also be started and stopped on versioned databases. You are
    limited to editing only a single workspace at a time, and this workspace is specified
    in the constructor of the `Editor` object simply by passing in a string that references
    the workspace. Once created, this `Editor` object then has access to all the methods
    to start, stop, and abort operations as well as perform undo and redo operations.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`Editor`类可以与个人、文件和ArcSDE地理数据库一起使用。此外，也可以在版本化数据库上启动和停止会话。你一次只能编辑一个工作空间，并且这个工作空间通过在`Editor`对象的构造函数中传递一个引用工作空间的字符串来指定。一旦创建，这个`Editor`对象就可以访问所有启动、停止和取消操作以及执行撤销和重做操作的方法。'
- en: How to do it…
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Follow these steps to wrap `UpdateCursor` inside an edit session:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤将`UpdateCursor`包裹在编辑会话内：
- en: Open **IDLE**.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**IDLE**。
- en: Open the `C:\ArcpyBook\Ch8\UpdateWildfires.py` script and save it to a new script
    called `C:\ArcpyBook\Ch8\EditSessionUpdateWildfires.py`.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`C:\ArcpyBook\Ch8\UpdateWildfires.py`脚本并将其保存到一个名为`C:\ArcpyBook\Ch8\EditSessionUpdateWildfires.py`的新脚本中。
- en: We're going to make several alterations to this existing script that updates
    values in the `CONFID_RATING` field.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将对这个现有的脚本进行几处修改，该脚本用于更新`CONFID_RATING`字段中的值。
- en: 'Remove the following lines of code:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除以下代码行：
- en: '[PRE52]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Create an instance of the `Editor` class and start an edit session. These lines
    of code should be placed inside the `try` block:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`Editor`类的实例并启动一个编辑会话。这些代码行应该放在`try`块内：
- en: '[PRE53]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Alter the `if` statement so that it appears as follows:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`if`语句，使其如下所示：
- en: '[PRE54]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'End the edit session and save the edits. Place this line of code just below
    the counter increment:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结束编辑会话并保存更改。将此代码行放在计数器增加的下面：
- en: '[PRE55]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The entire script should appear as follows:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 整个脚本应该如下所示：
- en: '[PRE56]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: You can check your work by examining the `C:\ArcpyBook\code\Ch8\EditSessionUpdateWildfires.py`
    solution file.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以通过检查`C:\ArcpyBook\code\Ch8\EditSessionUpdateWildfires.py`解决方案文件来检查你的工作。
- en: Save and run the script to update 374 records.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并运行脚本以更新374条记录。
- en: How it works…
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: Edit operations should take place inside an edit session, which can be initiated
    with the `Editor.startEditing()` method. The `startEditing()` method takes two
    optional parameters including `with_undo` and `multiuser_mode`. The `with_undo`
    parameter accepts a Boolean value of `true` or `false`, with a default of `true`.
    This creates an undo/redo stack when set to `true`. The `multiuser_mode` parameter
    defaults to `true`. When it's `false`, you have full control of editing a nonversioned
    or versioned dataset. If your dataset is nonversioned and you use `stopEditing(False)`,
    your edit will not be committed. Otherwise, if set to `true`, your edits will
    be committed. The `Editor.stopEditing()` method takes a single Boolean value of
    `true` or `false`, indicating whether changes should be saved or not. This defaults
    to `true`.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑操作应在编辑会话内进行，可以通过`Editor.startEditing()`方法启动编辑会话。`startEditing()`方法包含两个可选参数，包括`with_undo`和`multiuser_mode`。`with_undo`参数接受布尔值`true`或`false`，默认为`true`。当设置为`true`时，这将创建一个撤销/重做堆栈。`multiuser_mode`参数默认为`true`。当它为`false`时，你可以完全控制编辑非版本化或版本化数据集。如果你的数据集是非版本化的，并且你使用`stopEditing(False)`，你的编辑将不会被提交。否则，如果设置为`true`，你的编辑将被提交。`Editor.stopEditing()`方法接受一个布尔值`true`或`false`，表示是否应保存更改。默认为`true`。
- en: 'The `Editor` class supports undo and redo operations. We''ll first look at
    undo operations. During an edit session, various edit operations can be applied.
    In the event that you need to undo a previous operation, a call to `Editor.undoOperation()`
    will remove the most recent edit operation in the stack. This is illustrated as
    follows:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`Editor`类支持撤销和重做操作。我们将首先查看撤销操作。在编辑会话期间，可以应用各种编辑操作。如果需要撤销之前的操作，调用`Editor.undoOperation()`将移除堆栈中最新的编辑操作。这如下所示：'
- en: '![How it works…](img/B04314_08_6.jpg)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理…](img/B04314_08_6.jpg)'
- en: 'Redo operations, initiated by the `Editor.redoOperation()` method, will redo
    an operation that was previously undone. This is illustrated as follows:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`Editor.redoOperation()`方法启动的重做操作将重做之前撤销的操作。这如下所示：
- en: '![How it works…](img/B04314_08_7.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理…](img/B04314_08_7.jpg)'
- en: Reading geometry from a feature class
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从特征类读取几何
- en: There may be times when you need to retrieve the geometric definition of features
    in a feature class. ArcPy provides the ability to read this information through
    various objects.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你可能需要检索特征类中特征的几何定义。ArcPy通过各种对象提供了读取这些信息的能力。
- en: Getting ready
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In ArcPy, feature classes have associated geometry objects, including `Polygon`,
    `Polyline`, `PointGeometry`, or `MultiPoint` that you can access from your cursors.
    These objects refer to the `shape` field in the `table` attribute of a feature
    class. You can read the geometries of each feature in a feature class through
    these objects.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ArcPy 中，要素类关联着几何对象，包括 `Polygon`、`Polyline`、`PointGeometry` 或 `MultiPoint`，您可以从您的游标中访问这些对象。这些对象指向要素类
    `table` 属性中的 `shape` 字段。您可以通过这些对象读取要素类中每个要素的几何形状。
- en: Polyline and polygon feature classes are composed of features containing multiple
    parts. You can use the `partCount` property to return the number of parts per
    feature and then use `getPart()` for each part in the feature to loop through
    each of the points and pull out the coordinate information. Point feature classes
    are composed of one `PointGeometry` object per feature that contains the coordinate
    information for each point.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 多段线和多边形要素类由包含多个部分的要素组成。您可以使用 `partCount` 属性返回每个要素的部分数量，然后使用 `getPart()` 对每个要素中的每个部分进行循环，以遍历每个点并提取坐标信息。点要素类由每个要素的一个
    `PointGeometry` 对象组成，该对象包含每个点的坐标信息。
- en: In this recipe, you will use the `SearchCursor` and `Polygon` objects to read
    the geometry of a polygon feature class.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在本菜谱中，您将使用 `SearchCursor` 和 `Polygon` 对象来读取多边形要素类的几何形状。
- en: How to do it…
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Follow these steps to learn how to read the geometric information from each
    feature in a feature class:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤学习如何从要素类中的每个要素读取几何信息：
- en: Open **IDLE** and create a new script.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 **IDLE** 并创建一个新的脚本。
- en: Save the script to `C:\ArcpyBook\Ch8\ReadGeometry.py`.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将脚本保存到 `C:\ArcpyBook\Ch8\ReadGeometry.py`。
- en: 'Import the `arcpy` module:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入 `arcpy` 模块：
- en: '[PRE57]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Set the input feature class to the `SchoolDistricts` polygon feature class:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将输入要素类设置为 `SchoolDistricts` 多边形要素类：
- en: '[PRE58]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Create a `SearchCursor` object with the input feature class, and return the
    `ObjectID` and `Shape` fields. The `Shape` field contains the geometry for each
    feature. The cursor will be created inside a `for` loop that we''ll use to iterate
    all the features in the feature class:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用输入要素类创建一个 `SearchCursor` 对象，并返回 `ObjectID` 和 `Shape` 字段。`Shape` 字段包含每个要素的几何形状。游标将在一个
    `for` 循环内创建，我们将使用它来遍历要素类中的所有要素：
- en: '[PRE59]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Use a `for` loop to loop through each part of the feature:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `for` 循环遍历每个要素的部分：
- en: '[PRE60]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Use a `for` loop to loop through each vertex in each part and print the `X`
    and `Y` coordinates:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `for` 循环遍历每个部分中的每个顶点并打印 `X` 和 `Y` 坐标：
- en: '[PRE61]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: You can check your work by examining the `C:\ArcpyBook\code\Ch8\ReadGeometry.py`
    solution file.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以通过检查 `C:\ArcpyBook\code\Ch8\ReadGeometry.py` 解决方案文件来检查您的作业。
- en: 'Save and run the script. You should see the following output as the script
    writes the information for each feature, each part of the feature, and the `X`
    and `Y` coordinates that define each part:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并运行脚本。当脚本为每个要素、每个要素的部分以及定义每个部分的 `X` 和 `Y` 坐标写入信息时，您应该看到以下输出：
- en: '[PRE62]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: How it works…
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: We initially created a `SearchCursor` object to hold the contents of our feature
    class. After this, we looped through each row in the cursor by using a `for` loop.
    For each row, we looped through all the parts of the geometry. Remember that polyline
    and polygon features are composed of two or more parts. For each part, we also
    return the points associated with each part and we print the `X` and `Y` coordinates
    of each point.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最初创建了一个 `SearchCursor` 对象来保存我们要素类的所有内容。之后，我们使用 `for` 循环遍历游标中的每一行。对于每一行，我们遍历几何的所有部分。请记住，多段线和多边形要素由两个或多个部分组成。对于每个部分，我们也返回与每个部分关联的点，并打印每个点的
    `X` 和 `Y` 坐标。
- en: Using Walk() to navigate directories
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Walk() 导航目录
- en: In this recipe, you will learn how to generate data names in a catalog tree
    using the `Arcpy Walk()` function. Though similar to the Python `os.walk()` function,
    the `da.Walk()` function provides some important enhancements related to geodatabases.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在本菜谱中，您将学习如何使用 `Arcpy Walk()` 函数在目录树中生成数据名称。尽管与 Python 的 `os.walk()` 函数类似，但
    `da.Walk()` 函数提供了一些与地理数据库相关的重要增强功能。
- en: Getting ready
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The `Walk()` function, which is part of `arcpy.da`, generates data names in
    a catalog tree by walking the tree top-down or bottom-up. Each directory or workspace
    yields a tuple containing the directory path, directory names, and filenames.
    This function is similar to the Python `os.walk()` function but it has the added
    advantage of being able to recognize geodatabase structures. The `os.walk()` function
    is file-based so it isn't able to tell you information about geodatabase structures
    while `arcpy.da.walk()` can do so.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '`arcpy.da`中的`Walk()`函数通过自上而下或自下而上遍历目录树来生成目录树中的数据名称。每个目录或工作空间产生一个包含目录路径、目录名称和文件名的元组。此函数类似于Python的`os.walk()`函数，但它具有额外的优势，即能够识别地理数据库结构。`os.walk()`函数基于文件，因此它无法告诉你关于地理数据库结构的信息，而`arcpy.da.walk()`可以做到这一点。'
- en: How to do it…
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Follow these steps to learn how to use the `da.Walk()` function to navigate
    directories and workspaces to reveal the structure of a geodatabase:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤学习如何使用`da.Walk()`函数来遍历目录和空间，以揭示地理数据库的结构：
- en: In **IDLE**, create a new Python script called `DAWalk.py` and save it to the
    `C:\ArcpyBook\data` folder.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**IDLE**中创建一个名为`DAWalk.py`的新Python脚本，并将其保存到`C:\ArcpyBook\data`文件夹。
- en: 'Import the `arcpy`, `arcpy.da`, and `os` modules:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`arcpy`、`arcpy.da`和`os`模块：
- en: '[PRE63]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'First, we''ll use `os.walk()` to obtain a list of filenames in the current
    directory. Add this code:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将使用`os.walk()`获取当前目录中的文件名列表。添加以下代码：
- en: '[PRE64]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Save the file and run it to see output similar to what you see here:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件并运行它，以查看类似于以下输出的内容：
- en: '[PRE65]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Although `os.walk()` can be used to print all filenames within a directory,
    you'll notice that it doesn't have an understanding of the structure of Esri GIS
    format datasets, such as file geodatabases. Files, such as `a000000001.gdbindexes`,
    are physical files that make up a feature class but `os.walk()` can't tell you
    the logical structure of a feature class. In the next step, we'll use `da.walk()`
    to resolve this problem.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 虽然可以使用`os.walk()`打印出目录中的所有文件名，但你可能会注意到它并不理解Esri GIS格式数据集的结构，例如文件地理数据库。像`a000000001.gdbindexes`这样的文件是构成要素类的物理文件，但`os.walk()`无法告诉你要素类的逻辑结构。在下一步中，我们将使用`da.walk()`来解决这个问题。
- en: Comment out the code you just added.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注释掉你刚刚添加的代码。
- en: 'Add the following code block:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码块：
- en: '[PRE66]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The entire script should appear as follows:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 整个脚本应如下所示：
- en: '[PRE67]'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: You can check your work by examining the `C:\ArcpyBook\code\Ch8\Walk.py` solution
    file.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以通过检查`C:\ArcpyBook\code\Ch8\Walk.py`解决方案文件来验证你的工作。
- en: 'Save and execute the script to see the following output. Notice how much cleaner
    the output is and that the actual feature class names contained within the geodatabase
    are printed out instead of the physical filenames:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并执行脚本以查看以下输出。注意输出变得更加整洁，并且实际包含在地理数据库中的要素类名称被打印出来，而不是物理文件名：
- en: '[PRE68]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: How it works…
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The `da.Walk()` function accepts two parameters including the top-level workspace
    that will be retrieved (the current working directory), as well as the data type
    that will be used to filter the returned list. In this case, we retrieved only
    feature class-related files. The `Walk()` function returns a tuple containing
    the directory path, directory names, and filenames.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '`da.Walk()`函数接受两个参数，包括要检索的最高级别工作空间（当前工作目录）以及用于过滤返回列表的数据类型。在这种情况下，我们只检索与要素类相关的文件。`Walk()`函数返回一个包含目录路径、目录名称和文件名的元组。'
