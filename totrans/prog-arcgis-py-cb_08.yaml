- en: Chapter 8. Using the ArcPy Data Access Module with Feature Classes and Tables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving features from a feature class with SearchCursor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filtering records with a where clause
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improving cursor performance with geometry tokens
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inserting rows with InsertCursor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating rows with UpdateCursor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deleting rows with UpdateCursor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inserting and updating rows inside an edit session
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading geometry from a feature class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Walk() to navigate directories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll start this chapter with a basic question. What are cursors? **Cursors**
    are in-memory objects containing one or more rows of data from a table or feature
    class. Each row contains attributes from each field in a data source along with
    the geometry for each feature. Cursors allow you to search, add, insert, update,
    and delete data from tables and feature classes.
  prefs: []
  type: TYPE_NORMAL
- en: The `arcpy` data access module or `arcpy.da` was introduced in ArcGIS 10.1 and
    contains methods that allow you to iterate through each row in a cursor. Various
    types of cursors can be created depending on the needs of developers. For example,
    search cursors can be created to read values from rows. Update cursors can be
    created to update values in rows or delete rows, and insert cursors can be created
    to insert new rows.
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of cursor improvements that have been introduced with the
    `arcpy` data access module. Prior to the development of ArcGIS 10.1, cursor performance
    was notoriously slow. Now, cursors are significantly faster. Esri has estimated
    that `SearchCursors` are up to 30 times faster, while `InsertCursors` are up to
    12 times faster. In addition to these general performance improvements, the data
    access module also provides a number of new options that allow programmers to
    speed up processing. Rather than returning all the fields in a cursor, you can
    now specify that a subset of fields be returned. This increases the performance
    as less data needs to be returned. The same applies to geometry. Traditionally,
    when accessing the geometry of a feature, the entire geometric definition would
    be returned. You can now use geometry tokens to return a portion of the geometry
    rather than the full geometry of the feature. You can also use lists and tuples
    rather than using rows. There are also other new features, such as edit sessions
    and the ability to work with versions, domains, and subtypes.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three cursor functions in `arcpy.da`. Each returns a cursor object
    with the same name as the function. `SearchCursor()` creates a read-only `SearchCursor`
    object containing rows from a table or feature class. `InsertCursor()` creates
    an `InsertCursor` object that can be used to insert new records into a table or
    feature class. `UpdateCursor()` returns a cursor object that can be used to edit
    or delete records from a table or feature class. Each of these cursor objects
    has methods to access rows in the cursor. You can see the relationship between
    the cursor functions, the objects they create, and how they are used, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Function | Object created | Usage |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `SearchCursor()` | `SearchCursor` | This is a read-only view of data from
    a table or feature class |'
  prefs: []
  type: TYPE_TB
- en: '| `InsertCursor()` | `InsertCursor` | This adds rows to a table or feature
    class |'
  prefs: []
  type: TYPE_TB
- en: '| `UpdateCursor()` | `UpdateCursor` | This edits or deletes rows in a table
    or feature class |'
  prefs: []
  type: TYPE_TB
- en: The `SearchCursor()` function is used to return a `SearchCursor` object. This
    object can only be used to iterate through a set of rows returned for read-only
    purposes. No insertions, deletions, or updates can occur through this object.
    An optional `where` clause can be set to limit the rows returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you''ve obtained a cursor instance, it is common to iterate the records,
    particularly with `SearchCursor` or `UpdateCursor`. There are some peculiarities
    that you need to understand when navigating the records in a cursor. Cursor navigation
    is forward-moving only. When a cursor is created, the pointer of the cursor sits
    just above the first row in the cursor. The first call to `next()` will move the
    pointer to the first row. Rather than calling the `next()` method, you can also
    use a `for` loop to process each of the records without the need to call the `next()`
    method. After performing whatever processing you need to do with this row, a subsequent
    call to `next()` will move the pointer to row 2\. This process continues as long
    as you need to access additional rows. However, after a row has been visited,
    you can''t go back a single record at a time. For instance, if the current row
    is row 3, you can''t programmatically back up to row 2\. You can only go forward.
    To revisit rows 1 and 2, you would need to either call the `reset()` method or
    recreate the cursor and move back through the object. As I mentioned earlier,
    cursors are often navigated through the use of `for` loops as well. In fact, this
    is a more common way to iterate a cursor and a more efficient way to code your
    scripts. Cursor navigation is illustrated in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introduction](img/B04314_08_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `InsertCursor()` function is used to create an `InsertCursor` object that
    allows you to programmatically add new records to feature classes and tables.
    To insert rows, call the `insertRow()` method on this object. You can also retrieve
    a read-only tuple containing the field names in use by the cursor through the
    `fields` property. A lock is placed on the table or feature class being accessed
    through the cursor. Therefore, it is important to always design your script in
    a way that releases the cursor when you are done.
  prefs: []
  type: TYPE_NORMAL
- en: The `UpdateCursor()` function can be used to create an `UpdateCursor` object
    that can update and delete rows in a table or feature class. As is the case with
    `InsertCursor`, this function places a lock on the data while it's being edited
    or deleted. If the cursor is used inside a Python's `with` statement, the lock
    will automatically be freed after the data has been processed. This hasn't always
    been the case. Prior to ArcGIS 10.1, cursors were required to be manually released
    using the Python `del` statement. Once an instance of `UpdateCursor` has been
    obtained, you can then call the `updateCursor()` method to update records in tables
    or feature classes and the `deleteRow()` method to delete a row.
  prefs: []
  type: TYPE_NORMAL
- en: The subject of data locks requires a little more explanation. The `insert` and
    `update` cursors must obtain a lock on the data source they reference. This means
    that no other application can concurrently access this data source. Locks are
    a way of preventing multiple users from changing data at the same time and thus,
    corrupting the data. When the `InsertCursor()` and `UpdateCursor()` methods are
    called in your code, Python attempts to acquire a lock on the data. This lock
    must be specifically released after the cursor has finished processing so that
    the running applications of other users, such as `ArcMap` or `ArcCatalog`, can
    access the data sources. If this isn't done, no other application will be able
    to access the data. Prior to ArcGIS 10.1 and the `with` statement, cursors had
    to be specifically unlocked through Python's `del` statement. Similarly, `ArcMap`
    and `ArcCatalog` also acquire data locks when updating or deleting data. If a
    data source has been locked by either of these applications, your Python code
    will not be able to access the data. Therefore, the best practice is to close
    `ArcMap` and `ArcCatalog` before running any standalone Python scripts that use
    `insert` or `update` cursors.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we're going to cover the use of cursors to access and edit
    tables and feature classes. However, many of the cursor concepts that existed
    before ArcGIS 10.1 still apply.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving features from a feature class with SearchCursor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many occasions when you need to retrieve rows from a table or feature
    class for read-only purposes. For example, you might want to generate a list of
    all land parcels in a city with a value greater than $100,000\. In this case,
    you don't have any need to edit the data. Your needs are met simply by generating
    a list of rows that meet some sort of criteria. A `SearchCursor` object contains
    a read-only copy of rows from a table or feature class. These objects can also
    be filtered through the use of a `where` clause so that only a subset of the dataset
    is returned.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `SearchCursor()` function is used to return a `SearchCursor` object. This
    object can only be used to iterate a set of rows returned for read-only purposes.
    No insertions, deletions, or updates can occur through this object. An optional
    `where` clause can be set to limit the rows returned. In this recipe, you will
    learn how to create a basic `SearchCursor` object on a feature class through the
    use of the `SearchCursor()` function.
  prefs: []
  type: TYPE_NORMAL
- en: The `SearchCursor` object contains a `fields` property along with the `next()`
    and `reset()` methods. The `fields` property is a read-only structure in the form
    of a Python **tuple**, containing the fields requested from the feature class
    or table. You are going to hear the term tuple a lot in conjunction with cursors.
    If you haven't covered this topic before, tuples are a Python structure to store
    a sequence of data similar to Python lists. However, there are some important
    differences between Python tuples and lists. Tuples are defined as a sequence
    of values inside parentheses, while lists are defined as a sequence of values
    inside brackets. Unlike lists, tuples can't grow and shrink, which can be a very
    good thing in some cases when you want data values to occupy a specific position
    each time. This is the case with cursor objects that use tuples to store data
    from fields in tables and feature classes.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to learn how to retrieve rows from a table or feature class
    inside a `SearchCursor` object:'
  prefs: []
  type: TYPE_NORMAL
- en: Open **IDLE** and create a new script window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the script as `C:\ArcpyBook\Ch8\SearchCursor.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import the `arcpy.da` module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set the workspace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use a Python `with` statement to create a cursor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Loop through each row in `SearchCursor` and print the name of the school. Make
    sure you indent the `for` loop inside the `with` block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The entire script should appear as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save the script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can check your work by examining the `C:\ArcpyBook\code\Ch8\SearchCursor_Step1.py`
    solution file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the script. You should see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `with` statement used with the `SearchCursor()` function will create, open,
    and close the cursor. So, you no longer have to be concerned with explicitly releasing
    the lock on the cursor as you did prior to ArcGIS 10.1\. The first parameter passed
    into the `SearchCursor()` function is a feature class, represented by the `Schools.shp`
    file. The second parameter is a Python tuple containing a list of fields that
    we want returned in the cursor. For performance reasons, it is a best practice
    to limit the fields returned in the cursor to only those that you need to complete
    the task. Here, we've specified that only the `Facility` and `Name` fields should
    be returned. The `SearchCursor` object is stored in a variable called `cursor`.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `with` block, we use a Python `for` loop to loop through each school
    returned. We also use the Python `sorted()` function to sort the contents of the
    cursor. To access the values from a field on the row, simply use the index number
    of the field you want to return. In this case, we want to return the contents
    of the `Name` column, which will be the `1` index number, since it is the second
    item in the tuple of field names that are returned.
  prefs: []
  type: TYPE_NORMAL
- en: Filtering records with a where clause
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, `SearchCursor` will contain all rows in a table or feature class.
    However, in many cases, you will want to restrict the number of rows returned
    by some sort of criteria. Applying a filter through the use of a `where` clause
    limits the records returned.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By default, all rows from a table or feature class will be returned when you
    create a `SearchCursor` object. However, in many cases, you will want to restrict
    the records returned. You can do this by creating a query and passing it as a
    `where` clause parameter when calling the `SearchCursor()` function. In this recipe,
    you'll build on the script you created in the previous recipe by adding a `where`
    clause that restricts the records returned.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to apply a filter to a `SearchCursor` object that restricts
    the rows returned from a table or feature class:'
  prefs: []
  type: TYPE_NORMAL
- en: Open **IDLE** and load the `SearchCursor.py` script that you created in the
    previous recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Update the `SearchCursor()` function by adding a `where` clause that queries
    the facility field for records that have the `HIGH SCHOOL` text:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can check your work by examining the `C:\ArcpyBook\code\Ch8\SearchCursor_Step2.py`
    solution file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Save and run the script. The output will now be much smaller and restricted
    to high schools only:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We covered the creation of queries in [Chapter 7](ch07.html "Chapter 7. Querying
    and Selecting Data"), *Querying and Selecting Data*, so hopefully you now have
    a good grasp of how these are created along with all the rules you need to follow
    when coding these structures. The `where` clause parameter accepts any valid SQL
    query, and is used in this case to restrict the number of records that are returned.
  prefs: []
  type: TYPE_NORMAL
- en: Improving cursor performance with geometry tokens
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Geometry tokens** were introduced in ArcGIS 10.1 as a performance improvement
    for cursors. Rather than returning the entire geometry of a feature inside the
    cursor, only a portion of the geometry is returned. Returning the entire geometry
    of a feature can result in decreased cursor performance due to the amount of data
    that has to be returned. It''s significantly faster to return only the specific
    portion of the geometry that is needed.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A token is provided as one of the fields in the field list passed into the
    constructor for a cursor and is in the `SHAPE@<Part of Feature to be Returned>`
    format. The only exception to this format is the `OID@` token, which returns the
    object ID of the feature. The following code example retrieves only the `X` and
    `Y` coordinates of a feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The following table lists the available geometry tokens. Not all cursors support
    the full list of tokens. Check the ArcGIS help files for information about the
    tokens supported by each cursor type. The `SHAPE@` token returns the entire geometry
    of the feature. Use this carefully though, because it is an expensive operation
    to return the entire geometry of a feature and can dramatically affect performance.
    If you don't need the entire geometry, then do not include this token!
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/B04314_08_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this recipe, you will use a geometry token to increase the performance of
    a cursor. You'll retrieve the `X` and `Y` coordinates of each land parcel from
    the `parcels` feature class along with some attribute information about the parcel.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to add a geometry token to a cursor, which should improve
    the performance of this object:'
  prefs: []
  type: TYPE_NORMAL
- en: Open **IDLE** and create a new script window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the script as `C:\ArcpyBook\Ch8\GeometryToken.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import the `arcpy.da` module and the time module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set the workspace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We''re going to measure how long it takes to execute the code using a geometry
    token. Add the `start` time for the script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use a Python `with` statement to create a cursor that includes the centroid
    of each feature as well as the ownership information stored in the `PY_FULL_OW`
    field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Loop through each row in `SearchCursor` and print the name of the parcel and
    location. Make sure you indent the `for` loop inside the `with` block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Measure the elapsed time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Print the execution time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The entire script should appear as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can check your work by examining the `C:\ArcpyBook\code\Ch8\GeometryToken.py`
    solution file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the script. You should see something similar to the following output. Note
    the execution time; your time will vary:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we''re going to measure the execution time if the entire geometry is returned
    instead of just the portion of the geometry that we need:'
  prefs: []
  type: TYPE_NORMAL
- en: Save a new copy of the script as `C:\ArcpyBook\Ch8\GeometryTokenEntireGeometry.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Change the `SearchCursor()` function to return the entire geometry using `SHAPE@`
    instead of `SHAPE@XY`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can check your work by examining the `C:\ArcpyBook\code\Ch8\GeometryTokenEntireGeometry.py`
    solution file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Save and run the script. You should see the following output. Your time will
    vary from mine, but notice that the execution time is slower. In this case, it''s
    only a little over a second slower, but we''re only returning 2600 features. If
    the feature class were significantly larger, as many are, this would be amplified:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A geometry token can be supplied as one of the field names supplied in the constructor
    for the cursor. These tokens are used to increase the performance of a cursor
    by returning only a portion of the geometry instead of the entire geometry. This
    can dramatically increase the performance of a cursor, particularly when you are
    working with large polyline or polygon datasets. If you only need specific properties
    of the geometry in your cursor, you should use these tokens.
  prefs: []
  type: TYPE_NORMAL
- en: Inserting rows with InsertCursor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can insert a row into a table or feature class using an `InsertCursor` object.
    If you want to insert attribute values along with the new row, you'll need to
    supply the values in the order found in the attribute table.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `InsertCursor()` function is used to create an `InsertCursor` object that
    allows you to programmatically add new records to feature classes and tables.
    The `insertRow()` method on the `InsertCursor` object adds the row. A row in the
    form of a list or tuple is passed into the `insertRow()` method. The values in
    the list must correspond to the field values defined when the `InsertCursor` object
    was created. Similar to instances that include other types of cursors, you can
    also limit the field names returned using the second parameter of the method.
    This function supports geometry tokens as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code example illustrates how you can use `InsertCursor` to insert
    new rows into a feature class. Here, we insert two new wildfire points into the
    `California` feature class. The row values to be inserted are defined in a `list`
    variable. Then, an `InsertCursor` object is created, passing in the feature class
    and fields. Finally, the new rows are inserted into the feature class by using
    the `insertRow()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In this recipe, you will use `InsertCursor` to add wildfires retrieved from
    a `.txt` file into a point feature class. When inserting rows into a feature class,
    you will need to know how to add the geometric representation of a feature into
    the feature class. This can be accomplished by using `InsertCursor` along with
    two miscellaneous objects: `Array` and `Point`. In this exercise, we will add
    point features in the form of wildfire incidents to an empty point feature class.
    In addition to this, you will use Python file manipulation techniques to read
    the coordinate data from a text file.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will be importing the North American wildland fire incident data from a
    single day in October, 2007\. This data is contained in a comma-delimited text
    file containing one line for each fire incident on this particular day. Each fire
    incident has a latitude, longitude coordinate pair separated by commas along with
    a confidence value. This data was derived by automated methods that use remote
    sensing data to derive the presence or absence of a wildfire. Confidence values
    can range from 0 to 100\. Higher numbers represent a greater confidence that this
    is indeed a wildfire:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the file at `C:\ArcpyBook\Ch8\Wildfire Data\NorthAmericaWildfire_2007275.txt`
    and examine the contents.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will notice that this is a simple comma-delimited text file containing the
    longitude and latitude values for each fire along with a confidence value. We
    will use Python to read the contents of this file line by line and insert new
    point features into the `FireIncidents` feature class located in the `C:\ArcpyBook\Ch8
    \WildfireData\WildlandFires.mdb` personal geodatabase.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Close the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open `ArcCatalog`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to `C:\ArcpyBook\Ch8\WildfireData`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should see a personal geodatabase called `WildlandFires`. Open this geodatabase
    and you will see a point feature class called `FireIncidents`. Right now, this
    is an empty feature class. We will add features by reading the text file you examined
    earlier and inserting points.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Right-click on `FireIncidents` and select **Properties**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Fields** tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The latitude/longitude values found in the file we examined earlier will be
    imported into the `SHAPE` field and the confidence values will be written to the
    `CONFIDENCEVALUE` field.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Open **IDLE** and create a new script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the script to `C:\ArcpyBook\Ch8\InsertWildfires.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import the `arcpy` modules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set the workspace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the text file and read all the lines into a list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Start a `try` block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create an `InsertCursor` object using a `with` block. Make sure you indent
    inside the `try` statement. The cursor will be created in the `FireIncidents`
    feature class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a counter variable that will be used to print the progress of the script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Loop through the text file line by line using a `for` loop. Since the text
    file is comma-delimited, we''ll use the Python `split()` function to separate
    each value into a list variable called `vals`. We''ll then pull out the individual
    latitude, longitude, and confidence value items and assign them to variables.
    Finally, we''ll place these values into a list variable called `rowValue`, which
    is then passed into the `insertRow()` function for the `InsertCursor` object,
    and we then print a message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `except` block to print any errors that may occur:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a `finally` block to close the text file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The entire script should appear as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can check your work by examining the `C:\ArcpyBook\code\Ch8\InsertWildfires.py`
    solution file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Save and run the script. You should see messages being written to the output
    window as the script runs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open **ArcMap** and add the `FireIncidents` feature class to the table of contents.
    The points should be visible, as shown in the following screenshot:![How to do
    it…](img/B04314_08_3.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You may want to add a basemap to provide some reference for the data. In ArcMap,
    click on the **Add Basemap** button and select a basemap from the gallery.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some additional explanation may be needed here. The `lstFires` variable contains
    a list of all the wildfires that were contained in the comma-delimited text file.
    The `for` loop will loop through each of these records one by one, inserting each
    individual record into the `fire` variable. We also include an `if` statement
    that is used to skip the first record in the file, which serves as the header.
    As I explained earlier, we then pull out the individual latitude, longitude, and
    confidence value items from the `vals` variable, which is just a Python list object
    and assign them to variables called `latitude`, `longitude`, and `confid`. We
    then place these values into a new list variable called `rowValue` in the order
    that we defined when we created `InsertCursor`. Thus, the latitude and longitude
    pair should be placed first followed by the confidence value. Finally, we call
    the `insertRow()` function on the `InsertCursor` object assigned to the `cur`
    variable, passing in the new `rowValue` variable. We close by printing a message
    that indicates the progress of the script and also create the `except` and `finally`
    blocks to handle errors and close the text file. Placing the `file.close()` method
    in the `finally` block ensures that it will execute and close the file even if
    there is an error in the previous `try` statement.
  prefs: []
  type: TYPE_NORMAL
- en: Updating rows with UpdateCursor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you need to edit or delete rows from a table or feature class, you can use
    `UpdateCursor`. As is the case with `InsertCursor`, the contents of `UpdateCursor`
    can be limited through the use of a `where` clause.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `UpdateCursor()` function can be used to either update or delete rows in
    a table or feature class. The returned cursor places a lock on the data, which
    will automatically be released if used inside a Python `with` statement. An `UpdateCursor`
    object is returned from a call to this method.
  prefs: []
  type: TYPE_NORMAL
- en: The `UpdateCursor` object places a lock on the data while it's being edited
    or deleted. If the cursor is used inside a Python `with` statement, the lock will
    automatically be freed after the data has been processed. This hasn't always been
    the case. Previous versions of cursors were required to be manually released using
    the Python `del` statement. Once an instance of `UpdateCursor` has been obtained,
    you can then call the `updateCursor()` method to update records in tables or feature
    classes and the `deleteRow()` method can be used to delete a row.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you're going to write a script that updates each feature in
    the `FireIncidents` feature class by assigning a value of `poor`, `fair`, `good`,
    or `excellent` to a new field that is more descriptive of the confidence values
    using an `UpdateCursor`. Prior to updating the records, your script will add the
    `new` field to the `FireIncidents` feature class.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to create an `UpdateCursor` object that will be used to
    edit rows in a feature class:'
  prefs: []
  type: TYPE_NORMAL
- en: Open **IDLE** and create a new script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the script to `C:\ArcpyBook\Ch8\UpdateWildfires.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import the `arcpy` module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set the workspace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Start a `try` block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a new field called `CONFID_RATING` to the `FireIncidents` feature class.
    Make sure to indent inside the `try` statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new instance of `UpdateCursor` inside a `with` block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a counter variable that will be used to print the progress of the script.
    Make sure you indent this line of code and all the lines of code that follow inside
    the `with` block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Loop through each of the rows in the `FireIncidents` fire class. Update the
    `CONFID_RATING` field according to the following guidelines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Confidence value 0 to 40 = `POOR`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Confidence value 41 to 60 = `FAIR`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Confidence value 61 to 85 = `GOOD`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Confidence value 86 to 100 = `EXCELLENT`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This can be translated in the following block of code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `except` block to print any errors that may occur:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The entire script should appear as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can check your work by examining the `C:\ArcpyBook\code\Ch8\UpdateWildfires.py`
    solution file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Save and run the script. You should see messages being written to the output
    window as the script runs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open **ArcMap** and add the `FireIncidents` feature class. Open the attribute
    table and you should see that a new `CONFID_RATING` field has been added and populated
    by `UpdateCursor`:![How to do it…](img/B04314_08_4.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you insert, update, or delete data in cursors, the changes are permanent
    and can't be undone if you're working outside an edit session. However, with the
    new edit session functionality provided by ArcGIS 10.1, you can now make these
    changes inside an edit session to avoid these problems. We'll cover edit sessions
    soon.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this case, we've used `UpdateCursor` to update each of the features in a
    feature class. We first used the `Add Field` tool to add a new field called `CONFID_RATING`,
    which will hold new values that we assign based on values found in another field.
    The groups are poor, fair, good, and excellent and are based on numeric values
    found in the `CONFIDENCEVALUE` field. We then created a new instance of `UpdateCursor`
    based on the `FireIncidents` feature class, and returned the two fields mentioned
    previously. The script then loops through each of the features and assigns a value
    of poor, fair, good, or excellent to the `CONFID_RATING` field (`row[1]`), based
    on the numeric value found in `CONFIDENCEVALUE`. A Python `if`/`elif`/`else` structure
    is used to control the flow of the script based on the numeric value. The value
    for `CONFID_RATING` is then committed to the feature class by passing the row
    variable into the `updateRow`() method.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting rows with UpdateCursor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to being used to edit rows in a table or feature class, `UpdateCursor`
    can also be used to delete rows. Keep in mind that when rows are deleted outside
    an edit session, the changes are permanent.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to updating records, `UpdateCursor` can also delete records from
    a table or feature class. The `UpdateCursor` object is created in the same way
    in either case, but instead of calling `updateRow()`, you call `deleteRow()` to
    delete a record. You can also apply a `where` clause to `UpdateCursor`, to limit
    the records returned. In this recipe, we'll use an `UpdateCursor` object that
    has been filtered using a `where` clause to delete records from our `FireIncidents`
    feature class.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to create an `UpdateCursor` object that will be used to
    delete rows from a feature class:'
  prefs: []
  type: TYPE_NORMAL
- en: Open **IDLE** and create a new script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the script to `C:\ArcpyBook\Ch8\DeleteWildfires.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import the `arcpy` and `os` modules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set the workspace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Start a `try` block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new instance of `UpdateCursor` inside a `with` block. Make sure you
    indent inside the `try` statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a counter variable that will be used to print the progress of the script.
    Make sure you indent this line of code and all the lines of code that follow inside
    the `with` block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Delete the returned rows by calling the `deleteRow()` method. This is done
    by looping through the returned cursor and deleting the rows one at a time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `except` block to print any errors that may occur:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The entire script should appear as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can check your work by examining the `C:\ArcpyBook\code\Ch8\DeleteWildfires.py`
    solution file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Save and run the script. You should see messages being written to the output
    window as the script runs. 37 records should be deleted from the `FireIncidents`
    feature class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Rows from feature classes and tables can be deleted using the `deleteRow()`
    method in `UpdateCursor`. In this recipe, we used a `where` clause in the constructor
    of `UpdateCursor` to limit the records returned to only features that included
    `CONFID_RATING` of `POOR`. We then looped through the features returned in the
    cursor and called the `deleteRow()` method to delete the row from the feature
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Inserting and updating rows inside an edit session
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As I've mentioned throughout the chapter, inserts, updates, or deletes made
    to a table or feature class done outside an edit session are permanent. They can't
    be undone. Edit sessions give you much more flexibility to roll back any unwanted
    changes.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Up until now, we've used insert and update cursors to add, edit, and delete
    data from feature classes and tables. These changes are permanent as soon as the
    script is executed and can't be undone. The new `Editor` class in the data access
    module supports the ability to create edit sessions and operations. With edit
    sessions, changes applied to feature classes or tables are temporary until permanently
    applied with a specific method call. This is the same functionality provided by
    the `Edit` toolbar in ArcGIS for Desktop.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit sessions begin with a call to `Editor.startEditing()`, which initiates
    the session. Inside the session, you then start an operation with the `Editor.startOperation()`
    method. Within this operation, you then perform various operations that perform
    edits on your data. These edits can also be subject to undo, redo, and abort operations
    to roll back, roll forward, and abort your editing operations. After the operations
    have been completed, you then call the `Editor.stopOperation()` method followed
    by `Editor.stopEditing()`. Sessions can be ended without saving changes. In this
    event, changes are not permanently applied. An overview of this process is provided
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/B04314_08_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Edit sessions can also be ended without saving changes. In this event, changes
    are not permanently applied. Edit sessions also allow for operations to be applied
    inside the session and then either applied permanently to the database or rolled
    back. Additionally, the `Editor` class also supports undo and redo operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code example shows the full edit session stack, including the
    creation of the `Editor` object, the beginning of an edit session and an operation,
    edits to the data (an insert operation in this case), stopping the operation,
    and finally, the end of the edit session by saving the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The `Editor` class can be used with personal, file, and ArcSDE geodatabases.
    Also, sessions can also be started and stopped on versioned databases. You are
    limited to editing only a single workspace at a time, and this workspace is specified
    in the constructor of the `Editor` object simply by passing in a string that references
    the workspace. Once created, this `Editor` object then has access to all the methods
    to start, stop, and abort operations as well as perform undo and redo operations.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to wrap `UpdateCursor` inside an edit session:'
  prefs: []
  type: TYPE_NORMAL
- en: Open **IDLE**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `C:\ArcpyBook\Ch8\UpdateWildfires.py` script and save it to a new script
    called `C:\ArcpyBook\Ch8\EditSessionUpdateWildfires.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We're going to make several alterations to this existing script that updates
    values in the `CONFID_RATING` field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Remove the following lines of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create an instance of the `Editor` class and start an edit session. These lines
    of code should be placed inside the `try` block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Alter the `if` statement so that it appears as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'End the edit session and save the edits. Place this line of code just below
    the counter increment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The entire script should appear as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can check your work by examining the `C:\ArcpyBook\code\Ch8\EditSessionUpdateWildfires.py`
    solution file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save and run the script to update 374 records.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Edit operations should take place inside an edit session, which can be initiated
    with the `Editor.startEditing()` method. The `startEditing()` method takes two
    optional parameters including `with_undo` and `multiuser_mode`. The `with_undo`
    parameter accepts a Boolean value of `true` or `false`, with a default of `true`.
    This creates an undo/redo stack when set to `true`. The `multiuser_mode` parameter
    defaults to `true`. When it's `false`, you have full control of editing a nonversioned
    or versioned dataset. If your dataset is nonversioned and you use `stopEditing(False)`,
    your edit will not be committed. Otherwise, if set to `true`, your edits will
    be committed. The `Editor.stopEditing()` method takes a single Boolean value of
    `true` or `false`, indicating whether changes should be saved or not. This defaults
    to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Editor` class supports undo and redo operations. We''ll first look at
    undo operations. During an edit session, various edit operations can be applied.
    In the event that you need to undo a previous operation, a call to `Editor.undoOperation()`
    will remove the most recent edit operation in the stack. This is illustrated as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/B04314_08_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Redo operations, initiated by the `Editor.redoOperation()` method, will redo
    an operation that was previously undone. This is illustrated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/B04314_08_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Reading geometry from a feature class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There may be times when you need to retrieve the geometric definition of features
    in a feature class. ArcPy provides the ability to read this information through
    various objects.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In ArcPy, feature classes have associated geometry objects, including `Polygon`,
    `Polyline`, `PointGeometry`, or `MultiPoint` that you can access from your cursors.
    These objects refer to the `shape` field in the `table` attribute of a feature
    class. You can read the geometries of each feature in a feature class through
    these objects.
  prefs: []
  type: TYPE_NORMAL
- en: Polyline and polygon feature classes are composed of features containing multiple
    parts. You can use the `partCount` property to return the number of parts per
    feature and then use `getPart()` for each part in the feature to loop through
    each of the points and pull out the coordinate information. Point feature classes
    are composed of one `PointGeometry` object per feature that contains the coordinate
    information for each point.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will use the `SearchCursor` and `Polygon` objects to read
    the geometry of a polygon feature class.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to learn how to read the geometric information from each
    feature in a feature class:'
  prefs: []
  type: TYPE_NORMAL
- en: Open **IDLE** and create a new script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the script to `C:\ArcpyBook\Ch8\ReadGeometry.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import the `arcpy` module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set the input feature class to the `SchoolDistricts` polygon feature class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a `SearchCursor` object with the input feature class, and return the
    `ObjectID` and `Shape` fields. The `Shape` field contains the geometry for each
    feature. The cursor will be created inside a `for` loop that we''ll use to iterate
    all the features in the feature class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use a `for` loop to loop through each part of the feature:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use a `for` loop to loop through each vertex in each part and print the `X`
    and `Y` coordinates:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can check your work by examining the `C:\ArcpyBook\code\Ch8\ReadGeometry.py`
    solution file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Save and run the script. You should see the following output as the script
    writes the information for each feature, each part of the feature, and the `X`
    and `Y` coordinates that define each part:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We initially created a `SearchCursor` object to hold the contents of our feature
    class. After this, we looped through each row in the cursor by using a `for` loop.
    For each row, we looped through all the parts of the geometry. Remember that polyline
    and polygon features are composed of two or more parts. For each part, we also
    return the points associated with each part and we print the `X` and `Y` coordinates
    of each point.
  prefs: []
  type: TYPE_NORMAL
- en: Using Walk() to navigate directories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to generate data names in a catalog tree
    using the `Arcpy Walk()` function. Though similar to the Python `os.walk()` function,
    the `da.Walk()` function provides some important enhancements related to geodatabases.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Walk()` function, which is part of `arcpy.da`, generates data names in
    a catalog tree by walking the tree top-down or bottom-up. Each directory or workspace
    yields a tuple containing the directory path, directory names, and filenames.
    This function is similar to the Python `os.walk()` function but it has the added
    advantage of being able to recognize geodatabase structures. The `os.walk()` function
    is file-based so it isn't able to tell you information about geodatabase structures
    while `arcpy.da.walk()` can do so.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to learn how to use the `da.Walk()` function to navigate
    directories and workspaces to reveal the structure of a geodatabase:'
  prefs: []
  type: TYPE_NORMAL
- en: In **IDLE**, create a new Python script called `DAWalk.py` and save it to the
    `C:\ArcpyBook\data` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import the `arcpy`, `arcpy.da`, and `os` modules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'First, we''ll use `os.walk()` to obtain a list of filenames in the current
    directory. Add this code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save the file and run it to see output similar to what you see here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Although `os.walk()` can be used to print all filenames within a directory,
    you'll notice that it doesn't have an understanding of the structure of Esri GIS
    format datasets, such as file geodatabases. Files, such as `a000000001.gdbindexes`,
    are physical files that make up a feature class but `os.walk()` can't tell you
    the logical structure of a feature class. In the next step, we'll use `da.walk()`
    to resolve this problem.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Comment out the code you just added.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The entire script should appear as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can check your work by examining the `C:\ArcpyBook\code\Ch8\Walk.py` solution
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Save and execute the script to see the following output. Notice how much cleaner
    the output is and that the actual feature class names contained within the geodatabase
    are printed out instead of the physical filenames:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `da.Walk()` function accepts two parameters including the top-level workspace
    that will be retrieved (the current working directory), as well as the data type
    that will be used to filter the returned list. In this case, we retrieved only
    feature class-related files. The `Walk()` function returns a tuple containing
    the directory path, directory names, and filenames.
  prefs: []
  type: TYPE_NORMAL
