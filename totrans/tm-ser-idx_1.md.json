["```py\ngit clone git@github.com:PacktPublishing/Time-Series-Indexing.git\n```", "```py\ngit clone git@github.com:PacktPublishing/Time-Series-Indexing.git tsi\n```", "```py\n#!/usr/bin/env python3 \nimport numpy as np\nimport sys\ndef euclidean(a, b):\n    return np.linalg.norm(a-b)\ndef main():\n    ta = np.array([1, 2, 3])\n    tb = np.array([0, 2, 2])\n    if len(ta) != len(tb):\n        print(\"Time series should have the same length!\")\n        print(len(ta), len(tb))\n        sys.exit()\n    ed = euclidean(ta, tb)\n    print(\"Euclidean distance:\", ed)\nif __name__ == '__main__':\n    main()\n```", "```py\n$ ./ed.py\nEuclidean distance: 1.4142135623730951\n```", "```py\n#!/usr/bin/env python3\nimport time\nstart_time = time.time()\nfor i in range(5):\n    time.sleep(1)\nprint(\"--- %.5f seconds ---\" % (time.time() - start_time))\n```", "```py\n$ ./timing.py\n--- 5.01916 seconds ---\n```", "```py\n$ brew install anaconda\n```", "```py\n$ pacman -S anaconda\n```", "```py\n$ conda deactivate\n```", "```py\n$ source /opt/homebrew/anaconda3/bin/activate base\n```", "```py\n$ source /opt/anaconda/bin/activate base\n```", "```py\n$ conda update -n base -c defaults conda\n```", "```py\n$ conda create  ––name TSI python=3.8.5\n```", "```py\n$ conda info --envs\n# conda environments:\n#\nTSI                      /home/mtsouk/.conda/envs/TSI\nbase                    /opt/anaconda\n```", "```py\n$ conda list\n# packages in environment at /home/mtsouk/.conda/envs/TSI:\n#\n# Name                    Version                   Build\npython                    3.8.5                h7579374_1\nreadline                  8.2                  h5eee18b_0\nnumpy                     1.23.5                   pypi_0\npandas                    1.5.2                    pypi_0\n```", "```py\n$ conda env remove --name mtsouk\nRemove all packages in environment /home/mtsouk/.conda/envs/mtsouk:\n```", "```py\n(TSI) $ conda install numpy\n(TSI) $ conda install pandas\n(TSI) $ conda install scipy\n(TSI) $ conda install matplotlib\n(TSI) $ conda install stumpy\n```", "```py\n#!/usr/bin/env python3\nimport pandas as pd\nimport argparse\nimport stumpy\nimport numpy as np\nimport scipy\nimport matplotlib\ndef main():\n     print(\"scipy version:\", scipy.__version__)\n     print(\"numpy version:\", np.__version__) \nprint(\"stumpy version:\", stumpy.__version__) \nprint(\"matplotlib version:\", matplotlib.__version__) \nprint(\"argparse version:\", argparse.__version__) \nprint(\"pandas version:\", pd.__version__)\nif __name__ == '__main__':\n     main()\n```", "```py\n$ chmod 755 ./load_packages.py\n$ ./load_packages.py\nscipy version: 1.9.2\nnumpy version: 1.23.4\nstumpy version: 1.11.1\nmatplotlib version: 3.6.2\nargparse version: 1.1\npandas version: 1.5.0\n```", "```py\n#!/usr/bin/env python3\nimport random\nimport sys\nprecision = 5\nif len(sys.argv) != 4:\n    print(\"N MIN MAX\")\n    sys.exit()\n# Number of values\nN = int(sys.argv[1])\n# Minimum value\nMIN = int(sys.argv[2])\n# Maximum value\nMAX = int(sys.argv[3])\nx = random.uniform(MIN, MAX)\n# Random float number\nfor i in range(N):\n    print(round(random.uniform(MIN, MAX), precision))\n```", "```py\n$ ./synthetic_data.py 5 1 3\n1.18243\n2.81486\n1.74816\n1.42797\n2.21639\n```", "```py\n#!/usr/bin/env python3\nimport pandas as pd\nimport numpy as np\nimport sys\ndef main():\n        filename = sys.argv[1]\n        ts1Temp = pd.read_csv(filename, header = None)\n        # Convert to NParray\n        ta = ts1Temp.to_numpy()\n        ta = ta.reshape(len(ta))\n        print(\"Length:\", len(ta))\nif __name__ == '__main__':\n        main()\n```", "```py\n$ ./read_ts.py ts2\nLength: 50\n```", "```py\n#!/usr/bin/env python3\nimport sys\ndef main():\n    if len(sys.argv) != 2:\n        print(\"TS\")\n        sys.exit()\n    TS = sys.argv[1]\n    file = open(TS, 'r')\n    Lines = file.readlines()\n    count = 0\n    for line in Lines:\n        # Strips the newline character\n        t = line.strip()\n        try:\n            _ = float(t)\n        except:\n            count = count + 1\n    print(\"Number of errors:\", count)\nif __name__ == '__main__':\n    main()\n```", "```py\n$ cat ts.txt\n5.2\n-12.4\n-    # Error\n17.9\na a     # Error\n2 3 4    # Error\n4.2\n$ ./isNumeric.py ts.txt\nNumber of errors: 3\n```", "```py\n#!/usr/bin/env python3\nimport sys\ndef main():\n    if len(sys.argv) != 2:\n        print(\"TS\")\n        sys.exit()\n    TS = sys.argv[1]\n    file = open(TS, 'r')\n    Lines = file.readlines()\n    first = True\n    wordsPerLine = 0\n    for line in Lines:\n        t = line.strip()\n        words = t.split()\n        for word in words:\n            try:\n                _ = float(word)\n            except:\n                print(\"Error:\", word)\n        if first:\n            wordsPerLine = len(words)\n            first = False\n        elif wordsPerLine != len(words):\n            print(\"Expected\", wordsPerLine, \"found\", len(words))\n            continue\nif __name__ == '__main__':\n    main()\n```", "```py\n$ ./floats_per_line.py ts.txt\nError: -\nError: a\nError: b\nExpected 1 found 2\nExpected 1 found 3\n```", "```py\n#!/usr/bin/env python3\nimport argparse\nimport stumpy\nimport numpy as np\nimport pandas as pd\nimport sys\nclass TS:\n    def __init__(self, ts, index):\n        self.ts = ts\n        self.index = index\n```", "```py\ndef main():\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"-w\", dest = \"window\", type=int)\n    parser.add_argument(\"TS\")\n    args = parser.parse_args()\n    windowSize = args.window\n    file = args.TS\n    ts = pd.read_csv(file, names=['values'], compression='gzip', header = None)\n    ts_numpy = ts.to_numpy()\n    length = len(ts_numpy)\n    # Split time series into subsequences\n    for i in range(length - windowSize + 1):\n        # Get the subsequence\n        ts = ts_numpy[i:i+windowSize]\n        # Create new TS node based on ts\n        ts_node = TS(ts, i)\nif __name__ == '__main__':\n    main()\n```", "```py\n#!/usr/bin/env python3\nimport sys\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport math\ndef main():\n    if len(sys.argv) != 2:\n        print(\"TS\")\n        sys.exit()\n    F = sys.argv[1]\n    # Read Sequence as Pandas\n    ts = pd.read_csv(F, compression='gzip', header = None)\n    # Convert to NParray\n    ta = ts.to_numpy()\n    ta = ta.reshape(len(ta))\n    plt.plot(ta, label=F, linestyle='-', markevery=100, marker='o')\n    plt.xlabel('Time Series', fontsize=14)\n    plt.ylabel('Values', fontsize=14)\n    plt.grid()\n    plt.savefig(\"CH01_03.png\", dpi=300, format='png', bbox_inches='tight')\nif __name__ == '__main__':\n    main()\n```", "```py\n#!/usr/bin/env python3\nimport pandas as pd\nimport argparse\nimport time\nimport stumpy\ndef main():\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"-w\", \"--window\", dest = \"window\", default = \"16\", help=\"Sliding Window\", type=int)\n    parser.add_argument(\"TS\")\n    args = parser.parse_args()\n    windowSize = args.window\n    inputTS = args.TS\n    print(\"TS:\", inputTS, \"Sliding Window size:\", windowSize)\n    start_time = time.time()\n    ts = pd.read_csv(inputTS, names=['values'], compression='gzip')\n    # Convert to NParray\n    ts_numpy = ts.to_numpy()\n    ta = ts_numpy.reshape(len(ts_numpy))\n    realMP = stumpy.stump(ta, windowSize)\n    print(\"--- %.5f seconds ---\" % (time.time() - start_time))\nif __name__ == '__main__':\n    main()\n```", "```py\n$ taskset --cpu-list 3 ./matrix_profile.py 100k.txt.gz\nTS: 100k.txt.gz Sliding Window size: 16\n--- 120.44 seconds ---\n```", "```py\n$ taskset --cpu-list 0 ./matrix_profile.py 300k.gz -w 1024\nTS: 300k.gz Sliding Window size: 1024\n--- 922.30060 seconds ---\n```", "```py\n#!/usr/bin/env python3\nimport stumpy\nimport stumpy.mpdist\nimport numpy as np\nimport time\nimport sys\nimport pandas as pd\nif len(sys.argv) != 4:\n    print(\"TS1 + TS2 + Window size\")\n    sys.exit()\n# Time series files\nTS1 = sys.argv[1]\nTS2 = sys.argv[2]\nwindowSize = int(sys.argv[3])\nprint(\"TS1:\", TS1, \"TS2:\", TS2, \"Window Size:\", windowSize)\n# Read Sequence as Pandas\nts1Temp = pd.read_csv(TS1, compression='gzip', header = None).astype(np.float64)\n# Convert to NParray\nta = ts1Temp.to_numpy()\nta = ta.reshape(len(ta))\n# Read Sequence as Pandas\nts2Temp = pd.read_csv(TS2, compression='gzip', header = None).astype(np.float64)\n# Convert to NParray\ntb = ts2Temp.to_numpy()\ntb = tb.reshape(len(tb))\nprint(len(ta), len(tb))\nstart_time = time.time()\nmpdist = stumpy.mpdist(ta, tb, m=windowSize)\nprint(\"--- %.5f seconds ---\" % (time.time() - start_time))\nprint(\"MPdist: %.4f \" % mpdist)\n```", "```py\n$ taskset --cpu-list 0 ./mpdistance.py 100k_1.txt.gz 100k_2.txt.gz 512\nTS1: 100k_1.txt.gz TS2: 100k_2.txt.gz Window Size: 512\n100000 100000\n--- 349.81955 seconds ---\nMPdist: 28.3882\n```", "```py\n$ taskset --cpu-list 3 ./mpdistance.py h_500k_f.gz t_500k_f.gz 2048\nTS1: h_500k_f.gz TS2: t_500k_f.gz Window Size: 2048\n506218 506218\n--- 4102.92 seconds ---\nMPdist: 38.2851\n```"]