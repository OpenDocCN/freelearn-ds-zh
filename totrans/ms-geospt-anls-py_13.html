<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Geospatial REST API</h1>
                </header>
            
            <article>
                
<p><span>Publishing data for consumption on the web is a major component of</span> <span>modern GIS. To transfer data from remote servers to remote clients, most geospatial publishing software stacks use <strong>Representational State Transfer</strong> (<strong>REST</strong>) web services. In response to web requests for specific data resources, REST services return <strong>JavaScript Object Notation</strong> (<strong>JSON</strong>)-encoded data to the requesting client machine. The web services are combined in an application programming interface, or API, which will contain the endpoints that represent each data resource available for querying.</span></p>
<p>By combining a Python web framework with <strong>object-relational mapping</strong> (<strong>ORM</strong>) and a PostGIS backend, we can create a custom REST API that will respond to web requests with JSON. For this exercise, we will use the Flask web framework and the SQLAlchemy module with GeoAlchemy2 providing spatial ORM capabilities.</p>
<p>In this chapter, we will learn about the following:</p>
<ul>
<li>REST API components</li>
<li>JSON response formatting</li>
<li>How to process <kbd>GET</kbd>, <kbd>POST</kbd>, <kbd>PUT</kbd>, and <kbd>DELETE</kbd> request methods</li>
<li>Performing geospatial operations using the API</li>
<li>How to deploy a Flask website using IIS</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Writing a REST API in Python</h1>
                </header>
            
            <article>
                
<p>To understand the components of a REST API with JSON response, we will utilize the Flask web framework, a PostgreSQL/PostGIS database, and SQLAlchemy and GeoAlchemy2 for ORM queries. Flask will be used to create the URL endpoints for the API. PostGIS will store the data in tables defined by SQLAlchemy models, which define the column types for all columns except the geometry columns, which are defined by GeoAlchemy2 column types.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">REST</h1>
                </header>
            
            <article>
                
<p><span>REST is a standard for web services, designed to accept requests and parameters and return a representation of that data, usually in a JSON format but sometimes in XML or HTML format. </span>APIs that use REST architecture must meet these architectural constraints:</p>
<ul>
<li>Client-server interactions</li>
<li>Statelessness</li>
<li>Cacheablitity</li>
<li>Uniform interface </li>
<li>Layered system</li>
</ul>
<p><span>The client (a web browser or a remote computer) will send a request to a server at a designated URL endpoint. The request can include parameters that limit the data objects returned, much like conditionals in an SQL statement. It is stateless, meaning that each request must contain the request parameters and cannot refer to the results of another request. The data returned must be explicitly marked as cacheable or non-cacheable, to allow clients to decide if the data can be stored, or must be requested when required. When data is requested, all available API endpoints relating to the data (including links for adding or deleting data, if available) are returned as links along with the data representation. The underlying architecture of the server is not revealed by the API and can be manipulated (machines added or removed) without any change in the API structure. </span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">JSON</h1>
                </header>
            
            <article>
                
<p><span>JSON is designed to be understood by humans and machines alike. JavaScript data objects are easily generated from Python dictionaries, as they use the same key value structure and curly bracket notation. Python contains a built-in library for generating JSON (the</span> <kbd>json</kbd> <span>module), and web frameworks such as Flask also include code for generating JSON responses.</span></p>
<p><span>Multiple JSON standards exist for geospatial data, including GeoJSON and Esri JSON. Within this chapter, the REST API will use the GeoJSON format to respond to requests.</span></p>
<div class="packt_infobox">Read more about GeoJSON here: <a href="http://geojson.org/">http://geojson.org/</a>.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Python for REST API</h1>
                </header>
            
            <article>
                
<p>Python is a fantastic language for writing a REST API. It has modules that allow for database queries and others that process the HTTP web requests into the URL and parameter components. Using these modules, the requested resource is retrieved from the database and returns the data as JSON using modules that convert between Python dictionaries and JSON objects.</p>
<p>While a Python-based API can be built using the standard library, using a web framework to build the API will speed up the development time and enable component modules to be added as needed.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Flask</h1>
                </header>
            
            <article>
                
<p>Flask is a good choice for a Python web framework for a REST API. Partnered with SQLAlchemy and GeoAlchemy2 (see <a href="e483966e-f5c7-47dd-a40c-9b8b6f807107.xhtml">Chapter 11</a>, <em>Flask and GeoAlchemy2</em>, for more information on both), it allows the REST URL endpoints to be paired with a view (a Python function) that will process the request in different ways depending on the request method (such as <kbd>GET</kbd> and  <kbd>POST</kbd>, to name two examples) and return JSON data. </p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">REST modules</h1>
                </header>
            
            <article>
                
<p>As Flask is built to be extensible, there are many add-on modules that are designed to ease the creation of REST APIs. These include:</p>
<ul>
<li>Flask-RESTful (<a href="https://flask-restful.readthedocs.io/en/latest/">https://flask-restful.readthedocs.io/en/latest/</a>)</li>
<li>Eve (<a href="http://python-eve.org/">http://python-eve.org/</a>), which is built on top of Flask and Cerberus</li>
<li>Flask-REST-JSONAPI (<a href="https://github.com/miLibris/flask-rest-jsonapi">https://github.com/miLibris/flask-rest-jsonapi</a>)</li>
</ul>
<p>This chapter will use vanilla Flask capabilities, along with SQLAlchemy and GeoAlchemy2 for database queries, to illustrate the basics of API creation.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Other frameworks</h1>
                </header>
            
            <article>
                
<p>Django and GeoDjango (covered in <a href="a91ad85f-494d-4cc3-952f-d39a8933758e.xhtml">Chapter 12</a>, <em>GeoDjango</em>) are used extensively for REST API creation. With its batteries-included design motto, Django allows for easy API development. The Django REST framework adds easy API publication to the code base.</p>
<div class="packt_tip">Explore the Django REST Framework here: <a href="http://www.django-rest-framework.org/">http://www.django-rest-framework.org/</a>.<a href="http://www.django-rest-framework.org/"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Variables in Flask URLs</h1>
                </header>
            
            <article>
                
<p>When using Flask for URL processing, it is useful to understand how to add variables into URLs, as each resource may be requested using an ID or string identifier (for example, a state name). Flask URLs use placeholders to pass data into function parameters and utilize it as variables within the view for each endpoint. Using a converter, numerical data can be assigned a type within the placeholder; the default is a string type. </p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Number converters</h1>
                </header>
            
            <article>
                
<p>In this example, a <span>placeholder with a</span> converter for an integer ID is added at the end of the URL. By adding <kbd>int:</kbd> before the placeholder variable (<kbd>arena_id</kbd>), the ID can be used to query the <kbd>Arena</kbd> model/database table using the <kbd>get(id)</kbd> method of <kbd>session.query</kbd>, which expects an integer. If the datatype converter is not specified in the placeholder, the <kbd>arena_id</kbd> variable will contain a string character and won't be used by the <kbd>get(id)</kbd> method:</p>
<pre>@app.route('/nba/api/v0.1/arena/<strong>&lt;int:arena_id&gt;</strong>', methods=['GET'])<br/>def get_arena(<strong>arena_id</strong>):<br/>  arena = session.query(Arena).get(<strong>arena_id</strong>)</pre>
<p>With the parameter datatype specified, the requested <kbd>arena</kbd> object is returned by the ORM query and can be processed for a response.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Other data converters</h1>
                </header>
            
            <article>
                
<p>Besides integers, which use the converter <kbd>int</kbd>, floating point data can be converted using <kbd>float</kbd>, and URL data can be converted using <kbd>path</kbd>. Strings, which use the converter <kbd>string</kbd>, are the default.  In this case, a <kbd>float</kbd> value is captured and used to compare against <kbd>county</kbd> geometry areas. As the SRID for this data is in WKID, the area is in an odd format, but this query will work:</p>
<pre>@app.route('/nba/api/v0.1/county/query/size/&lt;<strong>float:size</strong>&gt;', methods=['GET'])<br/>def get_county_size(size):<br/>  counties = session.query(County).filter(County.geom.<strong>ST_Area</strong>() &gt; <strong>size</strong>).all()<br/>  data = [{"type": "Feature", <br/>  "properties":{"name":county.name,"id":county.id ,"state":county.state.name}, <br/>  "geometry":{"type":"MultiPolygon", <br/>  "coordinates":[shapely.geometry.geo.mapping(to_shape(county.geom))["coordinates"]]},<br/>  } for county in counties]<br/>  return jsonify({"type": "FeatureCollection","features":data})</pre>
<p>In this example, the value captured from the URL variable is compared to the <kbd>county</kbd> geometry using the <kbd>ST_Area</kbd> function, which borrows from PostGIS spatial SQL.</p>
<div class="packt_infobox">Read more about GeoAlchemy2 spatial functionality, and its use of spatial SQL, here: <a href="http://geoalchemy-2.readthedocs.io/en/latest/spatial_functions.html">http://geoalchemy-2.readthedocs.io/en/latest/spatial_functions.html</a>.<a href="http://geoalchemy-2.readthedocs.io/en/latest/spatial_functions.html"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Request methods</h1>
                </header>
            
            <article>
                
<p>When using a REST API, multiple HTTP request methods can be utilized. The <kbd>GET</kbd> method is used to request data, the <kbd>POST</kbd> method is used to add new data, the <kbd>PUT</kbd> method is used to update data, and the <kbd>DELETE</kbd> method is used to remove data from the database.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">GET</h1>
                </header>
            
            <article>
                
<p>For Flask URL endpoints, <kbd>GET</kbd> requests are specified using the method <kbd>GET</kbd>. Data can be passed as an argument and accessed using <kbd>request.args</kbd>:</p>
<pre>from flask import requests, jsonify<br/>@app.route('/nba/api/v0.1/arenas', methods=['<strong>GET</strong>'])<br/>def get_arenas():<br/>  if 'name' in <strong>request.args</strong>:<br/>       arenas = session.query(Arena).filter(name=<strong>request.args['name']</strong>)<br/>  else:<br/>       arenas = session.query(Arena).all()<br/>  data = [{"type": "Feature",  "properties":{"name":arena.name, "id":arena.id}, <br/>  "geometry":{"type":"Point","coordinates":[round(arena.longitude,6), round(arena.latitude,6)]},<br/>  } for arena in arenas]<br/>  return jsonify({"type": "FeatureCollection","features":data})</pre>
<p>The response data, processed into a list of Python dictionaries using a list comprehension, is added to another Python dictionary, and then converted to JSON using <kbd>jsonify</kbd> from Flask.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">POST</h1>
                </header>
            
            <article>
                
<p>The <kbd>POST</kbd> requests carry data that can be processed to add to a database. To differentiate a <kbd>POST</kbd> request, the Flask requests object has the <kbd>method</kbd> property, which can be checked to see if the request method was <kbd>GET</kbd> or <kbd>POST</kbd>. If we create a <kbd>form</kbd> (called <kbd>AddForm</kbd>) to add new <kbd>arenas</kbd> to the <kbd>Arenas</kbd> table, we could process the data submitted as a <kbd>POST</kbd> request and add it the database using the session manager:</p>
<pre>from flask import request<br/>from .forms import AddForm<br/>@app.route('/nba/api/v0.1/arena/add', methods=['GET', 'POST'])<br/>def add_arenas():<br/>  form = AddForm(request.form)<br/>  form.name.data = "New Arena"<br/>  form.longitude.data = -121.5<br/>  form.latitude.data = 37.8<br/>  if request.method == "POST":<br/>    arena = Arena()<br/>    arena.name = request.form['name']<br/>    arena.longitude =float(request.form['longitude'])<br/>    arena.latitude = float(request.form['latitude'])<br/>    arena.geom = 'SRID=4326;POINT({0} {1})'.format(arena.longitude, arena.latitude)<br/>    session.add(arena)<br/>    data = [{"type": "Feature", "properties":{"name":arena.name}, <br/>    "geometry":{"type":"Point", <br/>    "coordinates":[round(arena.longitude,6), round(arena.latitude,6)]},}]<br/>    return jsonify({'added':'success',"type": "FeatureCollection","features":data})<br/>  return render_template('addarena.html', form=form)</pre>
<p>As this method will accept both <kbd>GET</kbd> and <kbd>POST</kbd> requests, it sends a different response based on each request method.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Other available request methods</h1>
                </header>
            
            <article>
                
<p>While <kbd>GET</kbd> and <kbd>POST</kbd> are the main request methods, others are available for processing data. For the example API, we will only use <kbd>GET</kbd>, and <kbd>POST</kbd>, and <kbd>DELETE</kbd>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">PUT</h1>
                </header>
            
            <article>
                
<p>Similar to a <kbd>POST</kbd> request, a <kbd>PUT</kbd> request will carry data to update or add to a database. It will attempt to update the data multiple times to ensure complete transmission of the update.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">DELETE</h1>
                </header>
            
            <article>
                
<p>The <kbd>DELETE</kbd> method will remove a resource from the specified endpoint, for example, deleting an <kbd>arena</kbd> from the <kbd>Arenas</kbd> table. It requires a record identifier to specify the resource to be removed:</p>
<pre>@app.route('/nba/api/v0.1/arena/delete/<strong>&lt;int:arena_id&gt;</strong>', methods=['DELETE'])<br/>def delete_arena(<strong>arena_id</strong>):<br/>  arena = session.query(Arena).delete(<strong>arena_id</strong>)</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The REST API application</h1>
                </header>
            
            <article>
                
<p>To enable access to a database of NBA Arenas, US States, US Counties, and US Congressional Districts, we will build a REST API. The API will allow for queries about tables and about specific table resources, that is, rows of data. It will also allow for geospatial queries.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Application components</h1>
                </header>
            
            <article>
                
<p>The components of this application include:</p>
<ul>
<li><span>The database, created in <a href="e483966e-f5c7-47dd-a40c-9b8b6f807107.xhtml">Chapter 11</a>,  <em>Flask and GeoAlchemy2</em>, which contains the tables for NBA Arenas, US States, US Counties, and US Congressional Districts</span></li>
<li><span>The</span> <kbd>app.py</kbd><span> file, which initiates the application when called by a Python executable</span></li>
<li><span>The</span> <kbd>application</kbd> <span><span>folder, which contains the application code and folders</span></span></li>
<li><span>The</span> <kbd>__init__.py</kbd><span> file, which makes the <kbd>application</kbd> folder into a module, defines the Flask object and connects to the database</span></li>
<li><span>The</span> <kbd>views.py</kbd><span> file, which defines the API endpoints, the view functions, and the return responses</span></li>
<li><span>The</span> <kbd>models.py</kbd><span> file, which defines the database table models as Python classes that subclass from SQLAlchemy</span></li>
<li>The <kbd>forms.py</kbd> file, which defines the HTML forms</li>
<li>The <kbd>static</kbd> and <kbd>templates</kbd> folders, which contain templates and data</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Application folder and file structure</h1>
                </header>
            
            <article>
                
<p><span>The example REST API requires specific files and folders to be created. The outer folder, called <kbd>arenaapp</kbd>, will contain the <kbd>app.py</kbd> file and the folder called <kbd>application</kbd>. Create the folder called <kbd>arenaapp</kbd>. Inside of it, create a folder called <kbd>application</kbd>. Inside of <kbd>application</kbd>, create the folders <kbd>static</kbd> and <kbd>templates</kbd>:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/0ac1faae-182b-48c2-8d4b-36df91aa8089.png" width="631" height="220"/></div>
<p>The other files, <kbd>views.py</kbd>, <kbd>models.py</kbd>, and <kbd>forms.py</kbd>, will be located inside of <kbd>application</kbd>. Two folders, <kbd>static</kbd> and <kbd>templates</kbd>, will store application data and HTML forms:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/0c2891c3-592b-4374-8a1d-c5a6e57bc6ed.png" style="width:25.58em;height:17.42em;" width="424" height="289"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">app.py</h1>
                </header>
            
            <article>
                
<p><span>Using an IDE or text editor, create a file inside</span> <kbd>arenaapp</kbd> <span>called</span> <kbd>app.py</kbd><span>. </span>Open this file and add the following lines; this file will be run by the Python executable to initiate the REST API application:</p>
<pre>from application import app<br/>app.run()</pre>
<p><span>The</span> <kbd>__init__.py</kbd> file <span>allows the <kbd>application</kbd> folder to be imported by</span> <kbd>app.py</kbd><span>, allowing the Flask object</span> <kbd>app </kbd> <span>and its </span><kbd>app.run()</kbd> <span>method to be called. </span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">__init__.py</h1>
                </header>
            
            <article>
                
<p>Within the <kbd>application</kbd> folder, create a file called <kbd>__init__.py</kbd>. Inside of the file, add the following code (while adjusting the username and password to your specific database credentials:</p>
<pre>import flask<br/>app = flask.Flask(__name__)<br/>conn_string = 'postgresql://{user}:{password}@localhost:5432/chapter11'<br/>app.config['SQLALCHEMY_DATABASE_URI'] = conn_string <br/>app.config['SECRET_KEY'] = "SECRET_KEY"<br/>import application.views</pre>
<p>Within this file, the Flask object, <kbd>app</kbd>, is created and configured. To connect to the database, a connection string is used and stored in the <kbd>app.config</kbd> dictionary as the <kbd>'SQLALCHEMY_DATABASE_URI'</kbd>. <span>Remember to add the username and password into the connection string.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The database</h1>
                </header>
            
            <article>
                
<p>This will connect to the database created in <a href="e483966e-f5c7-47dd-a40c-9b8b6f807107.xhtml">Chapter 11</a>, <em>Flask and GeoAlchemy2</em>.  It is generated from shapefiles that have been imported and structured to match the models described as we proceed. To ensure that the application will work, be sure that the database has been created and that the shapefiles were imported. </p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">models.py</h1>
                </header>
            
            <article>
                
<p>Within <kbd>models.py</kbd>, the SQLAlchemy and GeoAlchemy2 modules are imported and the database session is initiated. The database models have their schemas defined as Python classes, allowing for queries and data updates.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Importing required modules</h1>
                </header>
            
            <article>
                
<p>These modules enable the application to define the models and connect to the database:</p>
<pre># The database connections and session management are managed with SQLAlchemy functions<br/>from sqlalchemy import create_engine<br/>from sqlalchemy.ext.declarative import declarative_base<br/>from sqlalchemy import Column, Integer, String, ForeignKey, Float<br/>from sqlalchemy.orm import sessionmaker, relationship<br/># The Geometry columns of the data tables are added to the ORM using the Geometry data type<br/>from geoalchemy2 import Geometry</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Declaring the session</h1>
                </header>
            
            <article>
                
<p>From the <kbd>app.config</kbd> dictionary, the database connection string is passed to the <kbd>create_engine</kbd> function. Once <kbd>engine</kbd> is bound to the <kbd>sessionmaker</kbd>, a <kbd>session</kbd> can be initiated:</p>
<pre>from application import app<br/># Connect to the database called chapter11 using SQLAlchemy functions<br/>engine = create_engine(app.config['SQLALCHEMY_DATABASE_URI'])<br/>Session = sessionmaker(bind=engine)<br/>session = Session()<br/>Base = declarative_base()</pre>
<p><span>A Python class called <kbd>Base</kbd> is created from the <kbd>declarative_base()</kbd> function. The <kbd>Base</kbd> class is then used to subclass all application classes.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Declaring the models</h1>
                </header>
            
            <article>
                
<p>For the models, all of the field types (for example, <kbd>Integer</kbd>, <kbd>String</kbd>, and <kbd>Float</kbd>) are defined using SQLAlchemy ORM-column classes, except for the geometry columns, which use the GeoAlchemy2  <kbd>Geometry</kbd> class. The <kbd>Geometry</kbd> class requires a geometry type and SRID:</p>
<pre># Define the Arena class, which will model the Arena database table<br/>class Arena(Base):<br/>    __tablename__ = 'arena'<br/>    id = Column(Integer, primary_key=True)<br/>    name = Column(String)<br/>    longitude = Column(Float)<br/>    latitude = Column(Float)<br/>    geom = Column(Geometry(<strong>geometry_type</strong>='POINT', <strong>srid</strong>=4326))</pre>
<p>The <kbd>County</kbd> class has a primary key field and a <kbd>name</kbd> field, as well as fields that define the many-to-one relationship with the <kbd>State</kbd> class. Instead of a <kbd>POINT</kbd> geometry type, it uses <kbd>MULTIPOLYGON</kbd>:</p>
<pre># Define the County class, which will model the County database table<br/>class County(Base):<br/>    __tablename__ = 'county'<br/>    id = Column(Integer, primary_key=True)<br/>    name = Column(String)<br/>    state_id = Column(Integer, <strong>ForeignKey</strong>('state.id'))<br/>    state_ref = <strong>relationship</strong>("State",backref='county')<br/>    geom = Column(Geometry(geometry_type='<strong>MULTIPOLYGON</strong>', srid=4326))</pre>
<p>The <kbd>District</kbd> class represents US Congressional Districts. Stored with a <kbd>MULTIPOLYGON</kbd> geometry type and an SRID of <kbd>4326</kbd>, it has a many-to-one relationship with the <kbd>State</kbd> class. Each <kbd>district</kbd> stored is linked to the state in which it resides:</p>
<pre># Define the District class, which will model the District database table<br/>class District(Base):<br/>    __tablename__ = 'district'<br/>    id = Column(Integer, primary_key=True)<br/>    district = Column(String)<br/>    name = Column(String)<br/>    state_id = Column(Integer, <strong>ForeignKey</strong>('state.id'))<br/>    state_ref = <strong>relationship</strong>("State",backref='district')<br/>    geom = Column(Geometry(geometry_type='<strong>MULTIPOLYGON</strong>', srid=4326))</pre>
<p>The <kbd>State</kbd> class has one-to-many relationships with the <kbd>County</kbd> and <kbd>District</kbd> classes respectively, defined using the <kbd>relationship</kbd> function. It also has a <kbd>MULTIPOLYGON</kbd> geometry column with an SRID of <kbd>4326</kbd>:</p>
<pre># Define the State class, which will model the State database table<br/>class State(Base):<br/>    __tablename__ = 'state'<br/>    id = Column(Integer, primary_key=True)<br/>    name = Column(String)<br/>    statefips = Column(String)<br/>    stpostal = Column(String)<br/>    counties = <strong>relationship</strong>('County', backref='state')<br/>    districts = <strong>relationship</strong>('District', backref='state')<br/>    geom = Column(Geometry(geometry_type='MULTIPOLYGON', srid=4326))</pre>
<p>With the fields and relationships defined, the next step is to create the REST API endpoints and write the views that will query the database and return GeoJSON responses. </p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">forms.py</h1>
                </header>
            
            <article>
                
<p>To capture data from the user, such as a new <kbd>arena</kbd>, a form will be used. Create a file called <kbd>forms.py</kbd> inside the <kbd>application</kbd> folder, and add the following code:</p>
<pre>from flask_wtf import FlaskForm<br/>from wtforms import TextField, FloatField<br/>class AddForm(FlaskForm):<br/>  name = TextField('Arena Name')<br/>  longitude = FloatField('Longitude')<br/>  latitude = FloatField('Latitude')</pre>
<p>This code will add the fields to a template, which will be discussed in the section on using <kbd>POST</kbd> methods. It will allow for code to be entered from an HTML template and passed to the server to add a new <kbd>arena</kbd>. </p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">views.py</h1>
                </header>
            
            <article>
                
<p>The API endpoints and processing are contained within <kbd>views.py</kbd>. The views are imported within <kbd>__init__.py</kbd> to make them available to the <kbd>app</kbd> object. Open an IDE and save a file called <kbd>views.py</kbd> inside the <kbd>application</kbd> folder.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Importing modules</h1>
                </header>
            
            <article>
                
<p>To enable the processing of web requests, we need to import functionality from Flask, GeoAlchemy2, and Shapely, a Python module for creating and processing geospatial data. We will also <kbd>import</kbd> the models and forms: </p>
<pre>from application import app<br/>from flask import render_template,jsonify, redirect, url_for, request, Markup<br/>from .forms import * <br/>from .models import *<br/>import geoalchemy2,shapely<br/>from geoalchemy2.shape import to_shape</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Base URL</h1>
                </header>
            
            <article>
                
<p>Each API pattern can be different, but should generally include a base URL that indicates the API version and should link to the other endpoints available within the API. This application will use a base URL pattern of <kbd>nba</kbd><em>/</em><kbd>api</kbd><em>/</em><kbd>v0.1</kbd>. In this case, the home URL (<kbd>'/'</kbd>) will <kbd>redirect</kbd> to the base URL of the API:</p>
<pre>@app.route('/', methods=['GET'])<br/>def get_api():<br/>  return redirect('/nba/api/v0.1')<br/><br/>@app.route('/nba/api/v0.1', methods=['GET'])<br/>def get_endpoints():<br/>  data= [{'name':"Arena", "endpoint":"/arena"},<br/>  {'name':"State", "endpoint":"/state"},<br/>  {'name':"County", "endpoint":"/county"},<br/>  {'name':"District", "endpoint":"/district"},]<br/>  return jsonify({"endpoints":data})</pre>
<p>The endpoints for each of the following sections are available from the base URL. Each resource URL can be constructed by adding the resource-specific endpoint to the base URL.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Arenas</h1>
                </header>
            
            <article>
                
<p>To request data from the <kbd>Arenas</kbd> table, we will define API endpoints and use view functions to query the <kbd>Arenas</kbd> model. Each response will be a package as GeoJSON. <span>This endpoint (</span><kbd>'/arena'</kbd><span>) will return a GeoJSON response, which will vary based on the presence of variables added to the URL. These variables include arena ID and name.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting all arenas</h1>
                </header>
            
            <article>
                
<p> To generate a response containing a representation of all <kbd>arenas</kbd>, a query is made using the SQLAlchemy ORM. To convert the query results into GeoJSON, a <span>list comprehension is used to generate a list of dictionaries that describe each <kbd>arena</kbd> returned from the ORM query. The resulting list (</span><kbd>data</kbd><span>) is then added to a dictionary, which is converted from a Python dictionary to a JSON object using the</span> <kbd>jsonify</kbd> <span>function:</span></p>
<pre>@app.route('/nba/api/v0.1/arena', methods=['GET'])<br/>def get_arenas():<br/>  arenas = session.query(Arena).all()<br/>  data = [{"type": "Feature", "properties":{"name":arena.name, "id":arena.id}, <br/>  "geometry":{"type":"Point", "coordinates":[round(arena.longitude,6),               round(arena.latitude,6)]},<br/>  } for arena in arenas]<br/>  return jsonify({"type": "FeatureCollection","features":data})</pre>
<p><span>The <kbd>name</kbd> and <kbd>id</kbd> field is returned, as well as the <kbd>longitude</kbd> and <kbd>latitude</kbd>. To limit the amount of data transmitted, the <kbd>latitude</kbd> and <kbd>longitude</kbd> are rounded to <kbd>6</kbd> decimals.  The low amount of precision required to describe the location of an <kbd>arena</kbd> makes this a reasonable limitation. While point data types are easier to return given that they consist of only two points, producing less data, polygon and polyline data are much larger and require more precision.</span></p>
<div class="packt_infobox">Compared to loops, list comprehensions decrease the processing time required for iterating over lists. Learn more about list comprehensions here:<br/>
<a href="https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions">https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions. </a></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting arenas by ID</h1>
                </header>
            
            <article>
                
<p>By adding a numeric ID to the <kbd>arena</kbd> endpoint, the specific <kbd>arena</kbd> will be located and returned. The <kbd>session.query</kbd> method <kbd>get</kbd> is used to retrieve the requested <kbd>arena</kbd> object:</p>
<pre>@app.route('/nba/api/v0.1/arena/&lt;int:arena_id&gt;', methods=['GET'])<br/>def get_arena(arena_id):<br/>  arena = session.query(Arena).get(arena_id)<br/>  data = [{"type": "Feature",  "properties":{"name":arena.name, "id":arena.id},  "geometry":{"type":"Point", "coordinates":[round(arena.longitude,6), round(arena.latitude,6)]}, <br/>  return jsonify({"type": "FeatureCollection","features":data})</pre>
<p>The selected <kbd>arena</kbd> is added to a dictionary inside a list, which is then added to a dictionary and returned as JSON <kbd>data</kbd>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting arenas by name</h1>
                </header>
            
            <article>
                
<p>An <kbd>arena</kbd> can be requested by <kbd>name</kbd> at this endpoint. By utilizing a query condition, known as a <kbd>filter</kbd>, an <kbd>arena</kbd> matching the <kbd>name</kbd> provided will be retrieved. To add flexibility, a <kbd>like</kbd> operator is used (along with a <kbd>"%"</kbd> wildcard operator) to make it possible for the <kbd>arena</kbd> <kbd>name</kbd> entered to be complete. Instead, the string entered will be used to <kbd>filter</kbd> the query and return only <kbd>arena</kbd> objects whose names start with the string entered:</p>
<pre>@app.route('/nba/api/v0.1/arena/&lt;arena_name&gt;', methods=['GET'])<br/>def get_arena_name(arena_name):<br/>  arenas = session.query(Arena).filter(Arena.name.like(arena_name+"%")).all()<br/>  data = [{"type": "Feature",  "properties":{"name":arena.name,"id":arena.id}, <br/>  "geometry":{"type":"Point",  "coordinates":[round(arena.longitude,6), round(arena.latitude,6)]}, <br/>  } for arena in arenas]<br/>  return jsonify({"type": "FeatureCollection","features":data})</pre>
<p>A list comprehension is used to generate the <kbd>arena</kbd> dictionaries. Here is an example of a response to a string query to the <kbd>arena</kbd> endpoint:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/5c9a2ed6-0822-4ca2-a9a5-336bedb5c3c5.png" style="width:30.08em;height:24.08em;" width="412" height="330"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">A geospatial query</h1>
                </header>
            
            <article>
                
<p>By adding one more URL component, the API is spatially enabled. Passing an <kbd>arena</kbd> ID and adding <kbd>"/intersect"</kbd> will use spatial queries to find data describing the requested NBA Arena. In this view function, the <kbd>County</kbd> and <kbd>District</kbd> tables are queried using an <kbd>intersect</kbd> <kbd>filter</kbd> (that is, the <kbd>county</kbd> containing the <kbd>arena</kbd> is identified using a point in polygon function). The underlying state is retrieved using a table relation between the <kbd>county</kbd> and the <kbd>state</kbd>. All of the geometry and the selected fields are returned:</p>
<pre>@app.route('/nba/api/v0.1/arena/&lt;int:arena_id&gt;/intersect', methods=['GET'])<br/>def arena_intersect(arena_id):<br/>  arena = session.query(Arena).get(arena_id)<br/>  county = session.query(County).filter(County.geom.<strong>ST_Intersects</strong>(arena.geom)).first()<br/>  district=session.query(District).filter(District.geom.<strong>ST_Intersects</strong>(arena.geom))<br/>  district = district.first()<br/>  <strong>if county != None:</strong><br/>    data = [{"type": "Feature", "properties": {"name":arena.name, "id":arena.id,} ,<br/>    "geometry":{"type":"Point", "coordinates":[round(arena.longitude,6), round(arena.latitude,6)]}, <br/>    },{"type": "Feature", "properties": {"name":county.name, "id":county.id,} ,<br/>    "geometry":{"type":"MultiPolygon", <br/>    "coordinates":[shapely.geometry.geo.mapping(to_shape(county.geom))]}, <br/>    },{"type": "Feature", "properties": {"name":district.district, "id":district.id,},<br/>    "geometry":{"type":"MultiPolygon", <br/>    "coordinates":[shapely.geometry.geo.mapping(to_shape(district.geom))]}, <br/>    },{"type": "Feature", "properties": {"name":county.state_ref.name, "id":county.state_ref.id,}, "geometry":{"type":"MultiPolygon", <br/>    "coordinates":[shapely.geometry.geo.mapping(to_shape(county.state_ref.geom))]}, <br/>    }]<br/>    return jsonify({"type": "FeatureCollection","features":data})<br/>  else:<br/>    return <strong>redirect</strong>('/nba/api/v0.1/arena/' + str(arena_id))</pre>
<p><span>To ensure that the function is valid, the <kbd>if</kbd> conditional checks if the <kbd>arena</kbd> is inside a US <kbd>county</kbd>; if not, the <kbd>county</kbd>, <kbd>district</kbd>, and <kbd>state</kbd> objects are not used. Instead, the request is redirected to the non-geospatial query view function.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">States</h1>
                </header>
            
            <article>
                
<p>The US States data can be large, due to the many vertices that make up each <kbd>state</kbd>. Within the endpoint for the <kbd>states</kbd>, we will add some URL parameters that will enable us to decide the geometry of each requested <kbd>state</kbd> should be returned.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting all states</h1>
                </header>
            
            <article>
                
<p>By checking for a URL argument in the <kbd>request.args</kbd> dictionary, and then checking if the argument evaluates as true, we can determine if all of the <kbd>state</kbd> geometries should be returned. The GeoJSON response is generated from the state's geometry by using the <kbd>to_shape</kbd> function and the <kbd>shapely.geometry.geo.mapping</kbd> (shortened to <kbd>smapping</kbd>) function:</p>
<pre>@app.route('/nba/api/v0.1/state', methods=['GET'])<br/>def get_states():<br/>  smapping = shapely.geometry.geo.mapping<br/>  states = session.query(State).all()<br/>  data = [{"type": "Feature", <br/>  "properties":{"state":state.name,"id":state.id}, <br/>  "geometry":{"type":"MultiPolygon", <br/>  "coordinates":"[Truncated]"},<br/>  } for state in states]<br/>  if "geometry" in request.args.keys():<br/>    if request.args["geometry"]=='1' or request.args["geometry"]=='True':<br/>      data = [{"type": "Feature", <br/>      "properties":{"state":state.name,"id":state.id}, <br/>      "geometry":{"type":"MultiPolygon", <br/>      "coordinates":[smapping(to_shape(state.geom))["coordinates"]]},<br/>      } for state in states]<br/>  return jsonify({"type": "FeatureCollection","features":data})</pre>
<p>If the <kbd>geometry</kbd> argument or parameter is not included, the geometry will be represented as truncated.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting a state by ID</h1>
                </header>
            
            <article>
                
<p>To get a specific <kbd>state</kbd> using the primary key ID of the <kbd>state</kbd>, we can add a URL variable that will check for an integer ID. It is returned with the <kbd>geometry</kbd> as a <kbd>geojson</kbd>:</p>
<pre>@app.route('/nba/api/v0.1/state/&lt;int:state_id&gt;', methods=['GET'])<br/>def get_state(state_id):<br/>  state = session.query(State).get(state_id)<br/>  geojson = shapely.geometry.geo.mapping(to_shape(state.geom))<br/>  data = [{"type": "Feature",  "properties":{"name":state.name}, <br/>  "geometry":{"type":"MultiPolygon",  "coordinates":[geojson["coordinates"]]},<br/>  }]<br/>  return jsonify({"type": "FeatureCollection","features":data})</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting a state by name</h1>
                </header>
            
            <article>
                
<p>Using a <kbd>filter</kbd> will allow for a URL variable to be used as a <kbd>query</kbd> <kbd>filter</kbd>. The string variable will be checked against the state <kbd>name</kbd> field in the database table, and uses a <kbd>like</kbd> operator to do a fuzzy comparison (that is, it will get all <kbd>states</kbd> that start with <kbd>'M'</kbd> if the <kbd>state_name</kbd> variable is <kbd>'M'</kbd>:</p>
<pre>@app.route('/nba/api/v0.1/state/&lt;state_name&gt;', methods=['GET'])<br/>def get_state_name(state_name):<br/>  states = session.query(State).filter(State.name.like(state_name+"%")).all()<br/>  geoms = {state.id:smapping(to_shape(state.geom)) for state in states}<br/>  data = [{"type": "Feature", "properties":{"state":state.name}, <br/>  "geometry":{"type":"MultiPolygon", <br/>  "coordinates":[shapely.geometry.geo.mapping(to_shape(state.geom)["coordinates"]]},<br/>  } for state in states]<br/>  return jsonify({"type": "FeatureCollection","features":data})</pre>
<p>This function has no URL parameters and will return the specified fields and <kbd>geometry</kbd> of the selected states. </p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting arenas by state</h1>
                </header>
            
            <article>
                
<p>This function uses spatial analysis to find all <kbd>arenas</kbd> that are contained by the <kbd>state</kbd>. The <kbd>state</kbd> is identified by the ID, and the URL component within which it will select all <kbd>arenas</kbd> whose <kbd>geometry</kbd> is within the <kbd>state</kbd> <kbd>geometry</kbd>:</p>
<pre>@app.route('/nba/api/v0.1/state/&lt;int:state_id&gt;/contains', methods=['GET'])<br/>def get_state_arenas(state_id):<br/>  state = session.query(State).get(state_id)<br/>  shp = to_shape(state.geom)<br/>  geojson = shapely.geometry.geo.mapping(shp)<br/>  data = [{"type": "Feature", "properties":{"name":state.name}, <br/>  "geometry":{"type":"MultiPolygon", "coordinates":[geojson]},<br/>  }]<br/>  arenas = session.query(Arena).filter(state.geom.ST_Contains(arena.geom))<br/>  data_arenas =[{"type": "Feature",<br/>  "properties":{"name":arena.name}, "geometry":{"type":"Point", <br/>  "coordinates":[round(arena.longitude,6), round(arena.latitude,6)]}, <br/>  } for arena in arenas]<br/>  data.extend(data_arenas)<br/>  return jsonify({"type": "FeatureCollection","features":data})</pre>
<p>The data returned will include the state <kbd>data</kbd> and <kbd>data</kbd> for all <kbd>arenas</kbd>, as GeoJSON allows for multiple datatypes to be packaged as a feature collection. </p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Counties</h1>
                </header>
            
            <article>
                
<p>Similar to the <kbd>State</kbd> database table, this will retrieve all of the <kbd>county</kbd> data. It accepts a <kbd>geometry</kbd> parameter to decide if it will return the <kbd>geometry</kbd> of each <kbd>county</kbd>:</p>
<pre>@app.route('/nba/api/v0.1/county', methods=['GET'])<br/>def get_counties():<br/>  counties = session.query(County).all()<br/>  geoms = {county.id:smapping(to_shape(county.geom)) for county in counties}<br/><strong>  if 'geometry' in request.args.keys():</strong><br/>      data = [{"type": "Feature", <br/>      "properties":{"name":county.name, "state":county.state.name}, <br/>      "geometry":{"type":"MultiPolygon", <br/>  "coordinates":[<strong>shapely.geometry.geo.mapping(to_shape(state.geom)</strong>["coordinates"]]},<br/>       } for county in counties]<br/><strong>  else:</strong><br/>      data = [{"type": "Feature", <br/>      "properties":{"name":county.name, "state":county.state.name}, <br/>      "geometry":{"type":"MultiPolygon", <br/>  "coordinates":["Truncated"]},<br/>       } for county in counties]<br/>  return jsonify({"type": "FeatureCollection","features":data})</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting a county by ID</h1>
                </header>
            
            <article>
                
<p>After retrieving all counties using the <kbd>get_counties</kbd> function, the ID of a specific <kbd>county</kbd> can be passed to this function. Using <kbd>session.query.(County).get(county_id)</kbd> allows for the retrieval of the <kbd>county</kbd> of interest:</p>
<pre>@app.route('/nba/api/v0.1/county/&lt;int:county_id&gt;', methods=['GET'])<br/>def get_county(county_id):<br/>  county = session.query(County).get(county_id)<br/>  shp = to_shape(county.geom)<br/>  geojson = shapely.geometry.geo.mapping(shp)<br/>  data = [{"type": "Feature",<br/>  "properties":{"name":county.name, "state":county.state.name}, <br/>  "geometry":{"type":"MultiPolygon", <br/>  "coordinates":[geojson]},<br/>  }]<br/>  return jsonify({"type": "FeatureCollection","features":data})</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting a county by name</h1>
                </header>
            
            <article>
                
<p>Again, we can use a URL variable to collect a string, and use the string supplied for a query filter. If <kbd>Wash</kbd> is used as the URL variable <kbd>county_name</kbd>, the query will find all <kbd>counties</kbd> with names that start with <kbd>Wash</kbd>:</p>
<pre>@app.route('/nba/api/v0.1/county/&lt;county_name&gt;', methods=['GET'])<br/>def get_county_name(county_name):<br/>  counties = session.query(County)<strong>.filter(County.name.like(county_name+"%"))</strong>.all()<br/>  data = [{"type": "Feature", <br/>  "properties":{"name":county.name, "state":county.state.name}, <br/>  "geometry":{"type":"MultiPolygon", <br/>  "coordinates":[shapely.geometry.geo.mapping(to_shape(county.geom))["coordinates"]]},<br/>  } for county in counties]<br/>  return jsonify({"type": "FeatureCollection","features":data})</pre>
<p>The <kbd>filter</kbd> method can be used on spatial fields as well as non-spatial fields. </p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Districts</h1>
                </header>
            
            <article>
                
<p>Districts can be similarly added to the API. In this case, we will add a geometry parameter to decide if the geometry should be returned. This allows for the requesting machine or browser to get all of the districts and their IDs, which can be used to get the individual district in the next section, or to get all of the data at once, as needed.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting all districts</h1>
                </header>
            
            <article>
                
<p>This endpoint, (<kbd>'/district'</kbd>), will query against the <kbd>District</kbd> model using <kbd>session.query(District).all()</kbd>:</p>
<pre>@app.route('/nba/api/v0.1/district', methods=['GET'])<br/>def get_districts():<br/>  districts = <strong>session.query(District).all()</strong><br/>  if 'geometry' in request.args.keys() and request.args['geometry'] in ('1','True'):<br/>    data = [{"type": "Feature", <br/>    "properties":{"representative":district.name, "district":district.district,<br/> "state": district.state_ref.name, "id":district.id}, <br/>    "geometry":{"type":"MultiPolygon", <br/>    "coordinates":shapely.geometry.geo.mapping(to_shape(district.geom))["coordinates"]},<br/>    } for district in districts]<br/>  else:<br/>    data = [{"type": "Feature", <br/>    "properties":{"representative":district.name, "district":district.district,<br/>    "state": district.state_ref.name, "id":district.id}, <br/>    "geometry":{"type":"MultiPolygon", <br/>    "coordinates":["Truncated"]},<br/>    } for district in districts]<br/>  return jsonify({"type": "FeatureCollection","features":data})</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting a district by ID</h1>
                </header>
            
            <article>
                
<p>Passing the integer <kbd>district</kbd> ID will return only the requested representation of the <kbd>district</kbd>. The <kbd>geometry</kbd> is converted to GeoJSON format using <kbd>shapely</kbd> and the <kbd>to_shape</kbd> method from <kbd>geoalchemy2.shape</kbd>:</p>
<pre>@app.route('/nba/api/v0.1/district/&lt;int:district_id&gt;', methods=['GET'])<br/>def get_district(district_id):<br/>  district = session.query(District).get(district_id)<br/><strong>  shp = to_shape(district.geom)</strong><br/><strong>  geojson = shapely.geometry.geo.mapping(shp)</strong><br/>  data = [{"type": "Feature",<br/>  "properties":{"district":district.district,"id":district.id}, <br/>  "geometry":{"type":"MultiPolygon", <br/>  "coordinates":[geojson['coordinates']]},<br/>  }]<br/>  return jsonify({"type": "FeatureCollection","features":data})</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting a district by name</h1>
                </header>
            
            <article>
                
<p>In this case, the <kbd>name</kbd> of the district is the congressional <kbd>district</kbd> number. There is a <kbd>name</kbd> field, but it contains the name of the elected representative from that <kbd>district</kbd>:</p>
<pre>@app.route('/nba/api/v0.1/district/&lt;dist&gt;', methods=['GET'])<br/>def get_district_name(dist):<br/>  districts = session.query(District).filter(District.district.like(dist+"%")).all()<br/>  data = [{"type": "Feature", <br/>  "properties":{"district":district.district,"id":district.id, <br/>  "representative":district.name},   "geometry":{"type":"MultiPolygon", <br/>  "coordinates":shapely.geometry.geo.mapping(to_shape(district.geom))["coordinates"]},<br/>  } for district in districts]<br/>  return jsonify({"type": "FeatureCollection","features":data})</pre>
<p>All of these methods can be adjusted to include more parameters. Try adding in conditionals that check for fields to return, or another conditional. All URL parameter arguments are added after a question mark (<kbd>'?'</kbd>) in the query.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">API POST endpoints  </h1>
                </header>
            
            <article>
                
<p>Adding an <kbd>arena</kbd> can be accomplished using both JSON data and using an HTML form. In this section, we'll create an HTML template, use the <kbd>AddForm</kbd> from <kbd>forms.py</kbd>, and use it to collect data from the <kbd>Leaflet.js</kbd> map included in <a href="a91ad85f-494d-4cc3-952f-d39a8933758e.xhtml" target="_blank">Chapter 12</a>, <em>GeoDjango</em>, code bundle. It also uses the library jQuery to allow the user to click on the map at any location, thus updating the <kbd>longitude</kbd> and <kbd>latitude</kbd> data from the map:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/3d47507c-fec2-4274-b8c2-21b86bfeff40.png" style="width:23.33em;height:31.17em;" width="619" height="825"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">New arenas</h1>
                </header>
            
            <article>
                
<p>To add new arenas to the database <kbd>Arena</kbd> table, a view function for processing and a Jinja2 HTML template will be created and used. The function will determine the request method and will send the appropriate response to the request. If it is a <kbd>GET</kbd> request, it will send an HTML template with the <kbd>AddForm</kbd> form. From the HTML template, filling in the data and pushing the button will submit a <kbd>POST</kbd> request, which will go to the same view function, and will use the submitted data to add a new row to the <kbd>Arena</kbd> table. </p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The view function</h1>
                </header>
            
            <article>
                
<p>The view function that will process the request accepts both <kbd>GET</kbd> and <kbd>POST</kbd> request methods. The endpoint <kbd>'/add'</kbd> is used in this case, though it could have been anything that differentiated it from the <kbd>arena</kbd> endpoint:</p>
<pre>@app.route('/nba/api/v0.1/arena/add', methods=['GET', 'POST'])<br/>def add_arenas():<br/>  form = AddForm(request.form)<br/>  form.name.data = "New Arena"<br/>  form.longitude.data = -121.5<br/>  form.latitude.data = 37.8<br/>  if request.method == "POST":<br/>    arena = Arena()<br/>    arena.name = request.form['name']<br/>    arena.latitude = float(request.form['latitude'])    <br/>    arena.longitude = float(request.form['longitude'])<br/>    arena.geom = 'SRID=4326;POINT({0} {1})'.format(arena.longitude, arena.latitude)<br/>    session.add(arena)<br/>    data = [{"type": "Feature", "properties":{"name":arena.name}, <br/>    "geometry":{"type":"Point", <br/>    "coordinates":[round(arena.longitude,6), round(arena.latitude,6)]},}]<br/>    return jsonify({'added':'success',"type": "FeatureCollection","features":data})<br/>  return render_template('addarena.html', form=form)</pre>
<p>Once the button is pushed, the data is submitted. The view function will determine what to do based on the request method—if it is a <kbd>POST</kbd> request, the data submitted in the <kbd>form</kbd> will be used to create a new <kbd>arena</kbd> object, and the session manager will save the object, adding it to the database.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The addarena.html head</h1>
                </header>
            
            <article>
                
<p><span>Next, let's create the template called </span><kbd>addarena.html</kbd><span>, which will be added to the</span> <kbd>templates</kbd> <span>folder inside the</span> <kbd>application</kbd> <span>folder. </span>At the top of the HTML file, in the head section, add the CSS, JavaScript, and jQuery libraries:</p>
<pre>&lt;!DOCTYPE html&gt;<br/>&lt;html&gt;<br/>&lt;head&gt;<br/>  &lt;title&gt;Arena Map&lt;/title&gt;<br/>  &lt;meta charset="utf-8" /&gt;<br/>  &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;<br/><strong>   &lt;link rel="stylesheet" href="https://unpkg.com/leaflet@1.2.0/dist/leaflet.css" /&gt;</strong><br/><strong>    &lt;script src="https://unpkg.com/leaflet@1.2.0/dist/leaflet.js"&gt;&lt;/script&gt;</strong><br/>    <strong>&lt;script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"&gt;&lt;/script&gt;</strong><br/>&lt;/head&gt;</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The addarena.html script</h1>
                </header>
            
            <article>
                
<p>Create the map <kbd>&lt;div&gt;</kbd> section and add the JavaScript that will enable map interactivity. If the map is clicked on, the JavaScript function <kbd>showMapClick</kbd> (which accepts an event <kbd><em>e</em></kbd>  as a parameter) will move the marker. Within the function, jQuery is used to set the value of the <kbd>latitude</kbd> and <kbd>longitude</kbd> <kbd>form</kbd> elements, getting the values from the event argument's <kbd>e.latlng</kbd> method: </p>
<pre>&lt;body&gt;<br/>&lt;div id="map" style="width: 600px; height: 400px;"&gt;&lt;/div&gt;<br/>&lt;script&gt;<br/>  var themap = L.map('map').setView([ {{form.latitude.data}},{{form.longitude.data}}], 13);<br/>  L.tileLayer('https://stamen-tiles-{s}.a.ssl.fastly.net/toner/{z}/{x}/{y}.{ext}', {<br/>  subdomains: 'abcd',<br/>  minZoom: 1,<br/>  maxZoom: 18,<br/>  ext: 'png'<br/>  }).addTo(themap);<br/>  marker = L.marker([ {{form.latitude.data}},{{form.longitude.data}}]).addTo(themap)<br/>    .bindPopup("Click to locate the new arena").openPopup();<br/>  var popup = L.popup();<br/>  function <strong>showMapClick</strong>(e) {<br/><strong>    $('#longitude').val(e.latlng.lng);</strong><br/><strong>    $('#latitude').val(e.latlng.lat);</strong><br/>    marker<br/>      .setLatLng(e.latlng)<br/>      .bindPopup("You added a new arena at " + e.latlng.toString())<br/>      .openPopup();<br/>  }<br/>  themap.on('click', showMapClick);<br/>&lt;/script&gt;</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The addarena.html form</h1>
                </header>
            
            <article>
                
<p>The <kbd>form</kbd> data will be submitted with the <kbd>POST</kbd> method. Once the <span class="packt_screen">Add Arena</span> button is pushed, the data inside the entry forms are submitted:</p>
<pre>  &lt;form method="post" class="form"&gt;<br/>    Name: {{form.name}}&lt;br&gt;<br/>    Longitude: {{ form.longitude(class_ = 'form-control first-input last-input', placeholder = form.longitude.data, ) }} &lt;br&gt;<br/>    Latitude: {{ form.latitude(class_ = 'form-control first-input last-input', placeholder = form.latitude.data, ) }} &lt;br&gt;<br/>    &lt;input type="submit" value="Add Arena"&gt;<br/>  &lt;/form&gt;<br/>&lt;/body&gt;<br/>&lt;/html&gt;</pre>
<p>Clicking on the button will submit the data to the view function. The data will be processed, and a <span class="packt_screen">success</span> JSON message returned:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/b9892c1f-af5c-4d01-9343-aef4bc325fc3.png" style="width:24.25em;height:20.83em;" width="595" height="515"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Sending a POST request using the requests library</h1>
                </header>
            
            <article>
                
<p>A new arena can be added using a web request, avoiding the need to use the HTML template. Here is a demonstration of a request using the <kbd>requests</kbd> library:</p>
<pre><strong>&gt;&gt;&gt; form = {'longitude':'-109.5', 'latitude':'40.7', 'name':'Test Arena'}</strong><br/><strong>&gt;&gt;&gt; requests.post('http://127.0.0.1:5000/nba/api/v0.1/arena/add', form)</strong><br/><strong>&lt;Response [200]&gt;</strong></pre>
<p>The POST request is sent to the <kbd>'/add'</kbd> endpoint, along with the required <kbd>form</kbd> parameters, as a Python dictionary.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Deleting an arena</h1>
                </header>
            
            <article>
                
<p>Deleting an <kbd>arena</kbd> (or another resource) can also be done using a view function and a specific endpoint:</p>
<pre>@app.route('/nba/api/v0.1/arena/delete/&lt;int:arena_id&gt;', methods=['DELETE'])<br/>def delete_arena(arena_id):<br/>  arena = session.query(Arena).delete(arena_id)<br/>  return jsonify({"deleted":"success"})</pre>
<p>To delete an <kbd>arena</kbd>, send a request using the <kbd>delete</kbd> method:</p>
<pre><strong>&gt;&gt;&gt; import requests</strong><br/><strong>&gt;&gt;&gt;requests.delete('http://127.0.0.1:5000/nba/api/v0.1/arena/delete/30')</strong></pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Running the REST API locally</h1>
                </header>
            
            <article>
                
<p>To run this API application locally, the <kbd>app.py</kbd> script is passed to the Python executable. This will start the built-in web server on the local machine:</p>
<pre><strong>C:\Projects\Chapter13\arenaapp&gt;python app.py</strong><br/><strong> * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)</strong></pre>
<p>Once the server is running, navigate to the API endpoint to get responses from the view functions. If the application is complete, however, the local server won't be powerful enough to handle the API requests. Instead, deployment on a production web server is required.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Deploying Flask to IIS</h1>
                </header>
            
            <article>
                
<p>To deploy the new API application on a Microsoft Server with <strong>Internet Information Services</strong> (<strong>IIS</strong>) installed, we have to download some Python code, and an IIS module called <strong>FastCGI</strong>. Once configured, the application will respond to web requests from any allowed machine.  </p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Flask and web servers</h1>
                </header>
            
            <article>
                
<p>While Flask includes a local web server for testing purposes, it is not designed for production deployments. Flask works best with web servers like Apache or IIS. While there is a lot of literature on how to deploy Flask with Apache, it is less common to find good instructions on how to deploy it using IIS. As most GIS professionals work with Windows servers or have access to them, these instructions will focus on deployment with IIS 7.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">WSGI</h1>
                </header>
            
            <article>
                
<p>The <strong>Web Server Gateway Interface</strong> (<strong>WSGI</strong>) is a Python specification that allows for a Python executable to be used to respond to web requests. WSGI is built into Python web frameworks such as Flask and Django.</p>
<p>To enable the use of the Flask web framework to serve web pages, some configuration of IIS is required, including the installation of an IIS <strong>Common Gateway Interface</strong> (<strong>CGI</strong>) module called FastCGI, and the installation of a Python module called <strong>WFastCGI</strong>. With these two additions, the IIS web server will connect to the code behind the API application.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Installing the WFastCGI module and FastCGI</h1>
                </header>
            
            <article>
                
<p>Use the Web Platform Installer, available here: <a href="http://www.microsoft.com/web/downloads/platform.aspx">http://www.microsoft.com/web/downloads/platform.aspx</a> (if it's not already installed). Use the search bar in the top-right, and enter <kbd>WFastCGI</kbd>. The search results will appear and will list available WFastCGI versions for both Python 2.x and Python 3.x. Select the version for Python 3.6 and run the installer.</p>
<p class="mce-root">This installation adds two important components to the required tech stack. The FastCGI module is added to IIS, and the WFastCGI Python code is added to a new Python installation. This new installation will be added at <kbd>C:\Python36</kbd>, unless there is an existing version in that location (not counting Python versions within an ArcGIS10.X Python installation).</p>
<p class="mce-root">Within this new installation, a file called <kbd>wfastcgi.py</kbd> is added in the <kbd>C:\Python36\Scripts</kbd> (or equivalent) folder. This file should be copied into the site folder, next to the <kbd>app.py</kbd> file.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Configuring FastCGI</h1>
                </header>
            
            <article>
                
<p class="mce-root">Open IIS, and click on the <span class="packt_screen">Default Web Site</span>. Within the features view of the Content Pane, select the <span class="packt_screen">Handler Mappings</span> icon. Double-click to open it. Select <span class="packt_screen">Add Module Mapping</span> from the right pane. When the <span class="packt_screen">Add Module Mapping</span> interface appears, enter the following:</p>
<ul>
<li class="mce-root">Add an asterisk (<kbd>*</kbd>) to the request path entry.</li>
<li class="mce-root">Select the <span class="packt_screen">FastCGI</span> module from the <span class="packt_screen">Module Selection List</span>.</li>
<li class="mce-root">If you copied the <kbd>wfastcgi.py</kbd> file into the code path and the code is at <kbd>C:\website</kbd>, enter this into the executable entry: <kbd>C:\Python36\python.exe|C:\website\wfastcgi.py</kbd>.</li>
<li class="mce-root"> Optionally, the <kbd>wfastcgi.py</kbd> file in the <kbd>Scripts</kbd> folder can be used. Here is the setup: <kbd>C:\Python36\python.exe|C:\Python36\Scripts\wfastcgi.py</kbd>.</li>
<li class="mce-root">Click on <span class="packt_screen">Request Restrictions</span> and uncheck the <span class="packt_screen">Invoke handler only if request is mapped to:</span> if it is checked. Click <span class="packt_screen">OK</span>.</li>
<li class="mce-root">Click <span class="packt_screen">OK</span> on the <span class="packt_screen">Add Module Mapping</span> interface.</li>
<li class="mce-root">Click <span class="packt_screen">Yes</span> on the confirmation.</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Root server settings and Environment Variables</h1>
                </header>
            
            <article>
                
<p class="mce-root">Go to the <kbd>root</kbd> server settings and click on the <span class="packt_screen">FastCGI Settings</span> icon. Double-click on the argument that matches the path added in the previous section. The <span class="packt_screen">Edit FastCGI Application</span> interface will open.</p>
<ul>
<li class="mce-root">Click on the <span class="packt_screen">EnvironmentVariables</span> (<span class="packt_screen">Collection</span>) entry. An ellipsis (<span class="packt_screen">...</span>) will appear. Double-click on the ellipsis to edit the environment variables.</li>
<li class="mce-root">Click the <span class="packt_screen">Add</span> button to add a new variable.</li>
<li class="mce-root">Add <kbd>PYTHONPATH</kbd> to the <span class="packt_screen">Name</span> entry.</li>
<li class="mce-root">Add the path to the site code (for example <kbd>C:\website\</kbd>) to the value entry.</li>
<li class="mce-root">Click the <span class="packt_screen">Add</span> button to add a second variable.</li>
<li class="mce-root">Add <kbd>WSGI_HANDLER</kbd> to the <span class="packt_screen">Name</span> entry.</li>
<li class="mce-root">If the site is controlled by a file called <kbd>app.py</kbd>, add <kbd>app.app</kbd> to the value entry (replacing <kbd>.py</kbd> with <kbd>.app</kbd>).</li>
<li class="mce-root">Once the variables have been added, push <span class="packt_screen">OK</span>. Push <span class="packt_screen">OK</span> in the <span class="packt_screen">Edit FastCGI Application</span>.</li>
</ul>
<p class="mce-root">The site should now be live. Navigate to a REST endpoint using a browser to confirm that the site loads as expected.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>Creating an API with REST specifications is easy with Python web frameworks. Flask makes it simple to coordinate the URL endpoints with request methods and response types. With built-in JSON capabilities, and with the use of the SQLAlchemy and GeoAlchemy2 ORMs, Flask is a perfect framework for creating a geospatial REST API.</p>
<p>In the next chapter, we will cover the use of the CARTOframes module for cloud visualization of geospatial data.</p>
<p> </p>


            </article>

            
        </section>
    </div>



  </body></html>